{"sha": "e613f9238f6db2fb4223d1df75d94168ba75d186", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2MTNmOTIzOGY2ZGIyZmI0MjIzZDFkZjc1ZDk0MTY4YmE3NWQxODY=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-12-20T21:05:30Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-12-20T21:05:30Z"}, "message": "Rollup merge of #67163 - TheSamsa:split-up-ptr-mod, r=Mark-Simulacrum\n\nSplit up ptr/mod.rs in libcore...\n\n...one with implementation detail for const ptr and the other with mut ptr\n\nI am not sure if the \"stable since 1.0.0\" flags are the correct choice for the two additional mods.\nAlso, is it necessary for them to be \"pub\"? If so, there should be a good description for them.\n\nCloses #66891", "tree": {"sha": "4ab36bda1bb970fa50eca278551147ce11794a60", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4ab36bda1bb970fa50eca278551147ce11794a60"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e613f9238f6db2fb4223d1df75d94168ba75d186", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd/TeaCRBK7hj4Ov3rIwAAdHIIAII0GDDYVsEMW3lltZbHe/MX\nKlvLoPjEXjOZmU3N1jlQmmibvk73WSN4C5zAhbyA6oElMO7W8je6HRsQ4otAbXku\nnsuk5jsJpuddajr5CwKK/jWquHFLqz5eybYJNNs4TEEkIxLOwM6mL4/NHiRJ5kb7\n60Ks2KCN+dZSCNCyANOdwyCYKlIS0ZQqUZsb9YiWt6saRX59MIiIwu3MpJ1ivHgS\nOhilOcMvWjbLjEf9rY+BcC9KstvdO92u1sLdcHUhG5KyDwhrf2Wgrpb1pGzv0Q92\nbQG1K6INkVU1Rxpy5wYTTXHTG5bGthPU0PSyyF6NF7zz5DbFjaQkRrsF5/nkqJE=\n=MHfy\n-----END PGP SIGNATURE-----\n", "payload": "tree 4ab36bda1bb970fa50eca278551147ce11794a60\nparent 364ecf50cb536efb22394668a341286d48713c54\nparent 12d65c28a6beac211edab9981a924f8c9331c9ec\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1576875930 +0100\ncommitter GitHub <noreply@github.com> 1576875930 +0100\n\nRollup merge of #67163 - TheSamsa:split-up-ptr-mod, r=Mark-Simulacrum\n\nSplit up ptr/mod.rs in libcore...\n\n...one with implementation detail for const ptr and the other with mut ptr\n\nI am not sure if the \"stable since 1.0.0\" flags are the correct choice for the two additional mods.\nAlso, is it necessary for them to be \"pub\"? If so, there should be a good description for them.\n\nCloses #66891\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e613f9238f6db2fb4223d1df75d94168ba75d186", "html_url": "https://github.com/rust-lang/rust/commit/e613f9238f6db2fb4223d1df75d94168ba75d186", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e613f9238f6db2fb4223d1df75d94168ba75d186/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "364ecf50cb536efb22394668a341286d48713c54", "url": "https://api.github.com/repos/rust-lang/rust/commits/364ecf50cb536efb22394668a341286d48713c54", "html_url": "https://github.com/rust-lang/rust/commit/364ecf50cb536efb22394668a341286d48713c54"}, {"sha": "12d65c28a6beac211edab9981a924f8c9331c9ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/12d65c28a6beac211edab9981a924f8c9331c9ec", "html_url": "https://github.com/rust-lang/rust/commit/12d65c28a6beac211edab9981a924f8c9331c9ec"}], "stats": {"total": 3396, "additions": 1695, "deletions": 1701}, "files": [{"sha": "be2b7ff5f773b69650719fdaef64a7f520aa253e", "filename": "src/libcore/ptr/const_ptr.rs", "status": "added", "additions": 755, "deletions": 0, "changes": 755, "blob_url": "https://github.com/rust-lang/rust/blob/e613f9238f6db2fb4223d1df75d94168ba75d186/src%2Flibcore%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e613f9238f6db2fb4223d1df75d94168ba75d186/src%2Flibcore%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fconst_ptr.rs?ref=e613f9238f6db2fb4223d1df75d94168ba75d186", "patch": "@@ -0,0 +1,755 @@\n+use crate::cmp::Ordering::{self, Less, Equal, Greater};\n+use crate::intrinsics;\n+use crate::mem;\n+use super::*;\n+\n+// ignore-tidy-undocumented-unsafe\n+\n+#[lang = \"const_ptr\"]\n+impl<T: ?Sized> *const T {\n+    /// Returns `true` if the pointer is null.\n+    ///\n+    /// Note that unsized types have many possible null pointers, as only the\n+    /// raw data pointer is considered, not their length, vtable, etc.\n+    /// Therefore, two pointers that are null may still not compare equal to\n+    /// each other.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let s: &str = \"Follow the rabbit\";\n+    /// let ptr: *const u8 = s.as_ptr();\n+    /// assert!(!ptr.is_null());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn is_null(self) -> bool {\n+        // Compare via a cast to a thin pointer, so fat pointers are only\n+        // considering their \"data\" part for null-ness.\n+        (self as *const u8) == null()\n+    }\n+\n+    /// Casts to a pointer of another type.\n+    #[stable(feature = \"ptr_cast\", since = \"1.38.0\")]\n+    #[rustc_const_stable(feature = \"const_ptr_cast\", since = \"1.38.0\")]\n+    #[inline]\n+    pub const fn cast<U>(self) -> *const U {\n+        self as _\n+    }\n+\n+    /// Returns `None` if the pointer is null, or else returns a reference to\n+    /// the value wrapped in `Some`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// While this method and its mutable counterpart are useful for\n+    /// null-safety, it is important to note that this is still an unsafe\n+    /// operation because the returned value could be pointing to invalid\n+    /// memory.\n+    ///\n+    /// When calling this method, you have to ensure that *either* the pointer is NULL *or*\n+    /// all of the following is true:\n+    /// - it is properly aligned\n+    /// - it must point to an initialized instance of T; in particular, the pointer must be\n+    ///   \"dereferencable\" in the sense defined [here].\n+    ///\n+    /// This applies even if the result of this method is unused!\n+    /// (The part about being initialized is not yet fully decided, but until\n+    /// it is, the only safe approach is to ensure that they are indeed initialized.)\n+    ///\n+    /// Additionally, the lifetime `'a` returned is arbitrarily chosen and does\n+    /// not necessarily reflect the actual lifetime of the data. *You* must enforce\n+    /// Rust's aliasing rules. In particular, for the duration of this lifetime,\n+    /// the memory the pointer points to must not get mutated (except inside `UnsafeCell`).\n+    ///\n+    /// [here]: crate::ptr#safety\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let ptr: *const u8 = &10u8 as *const u8;\n+    ///\n+    /// unsafe {\n+    ///     if let Some(val_back) = ptr.as_ref() {\n+    ///         println!(\"We got back the value: {}!\", val_back);\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// # Null-unchecked version\n+    ///\n+    /// If you are sure the pointer can never be null and are looking for some kind of\n+    /// `as_ref_unchecked` that returns the `&T` instead of `Option<&T>`, know that you can\n+    /// dereference the pointer directly.\n+    ///\n+    /// ```\n+    /// let ptr: *const u8 = &10u8 as *const u8;\n+    ///\n+    /// unsafe {\n+    ///     let val_back = &*ptr;\n+    ///     println!(\"We got back the value: {}!\", val_back);\n+    /// }\n+    /// ```\n+    #[stable(feature = \"ptr_as_ref\", since = \"1.9.0\")]\n+    #[inline]\n+    pub unsafe fn as_ref<'a>(self) -> Option<&'a T> {\n+        if self.is_null() { None } else { Some(&*self) }\n+    }\n+\n+    /// Calculates the offset from a pointer.\n+    ///\n+    /// `count` is in units of T; e.g., a `count` of 3 represents a pointer\n+    /// offset of `3 * size_of::<T>()` bytes.\n+    ///\n+    /// # Safety\n+    ///\n+    /// If any of the following conditions are violated, the result is Undefined\n+    /// Behavior:\n+    ///\n+    /// * Both the starting and resulting pointer must be either in bounds or one\n+    ///   byte past the end of the same allocated object. Note that in Rust,\n+    ///   every (stack-allocated) variable is considered a separate allocated object.\n+    ///\n+    /// * The computed offset, **in bytes**, cannot overflow an `isize`.\n+    ///\n+    /// * The offset being in bounds cannot rely on \"wrapping around\" the address\n+    ///   space. That is, the infinite-precision sum, **in bytes** must fit in a usize.\n+    ///\n+    /// The compiler and standard library generally tries to ensure allocations\n+    /// never reach a size where an offset is a concern. For instance, `Vec`\n+    /// and `Box` ensure they never allocate more than `isize::MAX` bytes, so\n+    /// `vec.as_ptr().add(vec.len())` is always safe.\n+    ///\n+    /// Most platforms fundamentally can't even construct such an allocation.\n+    /// For instance, no known 64-bit platform can ever serve a request\n+    /// for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.\n+    /// However, some 32-bit and 16-bit platforms may successfully serve a request for\n+    /// more than `isize::MAX` bytes with things like Physical Address\n+    /// Extension. As such, memory acquired directly from allocators or memory\n+    /// mapped files *may* be too large to handle with this function.\n+    ///\n+    /// Consider using [`wrapping_offset`] instead if these constraints are\n+    /// difficult to satisfy. The only advantage of this method is that it\n+    /// enables more aggressive compiler optimizations.\n+    ///\n+    /// [`wrapping_offset`]: #method.wrapping_offset\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let s: &str = \"123\";\n+    /// let ptr: *const u8 = s.as_ptr();\n+    ///\n+    /// unsafe {\n+    ///     println!(\"{}\", *ptr.offset(1) as char);\n+    ///     println!(\"{}\", *ptr.offset(2) as char);\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub unsafe fn offset(self, count: isize) -> *const T\n+        where\n+            T: Sized,\n+    {\n+        intrinsics::offset(self, count)\n+    }\n+\n+    /// Calculates the offset from a pointer using wrapping arithmetic.\n+    ///\n+    /// `count` is in units of T; e.g., a `count` of 3 represents a pointer\n+    /// offset of `3 * size_of::<T>()` bytes.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The resulting pointer does not need to be in bounds, but it is\n+    /// potentially hazardous to dereference (which requires `unsafe`).\n+    ///\n+    /// In particular, the resulting pointer remains attached to the same allocated\n+    /// object that `self` points to. It may *not* be used to access a\n+    /// different allocated object. Note that in Rust,\n+    /// every (stack-allocated) variable is considered a separate allocated object.\n+    ///\n+    /// In other words, `x.wrapping_offset(y.wrapping_offset_from(x))` is\n+    /// *not* the same as `y`, and dereferencing it is undefined behavior\n+    /// unless `x` and `y` point into the same allocated object.\n+    ///\n+    /// Compared to [`offset`], this method basically delays the requirement of staying\n+    /// within the same allocated object: [`offset`] is immediate Undefined Behavior when\n+    /// crossing object boundaries; `wrapping_offset` produces a pointer but still leads\n+    /// to Undefined Behavior if that pointer is dereferenced. [`offset`] can be optimized\n+    /// better and is thus preferrable in performance-sensitive code.\n+    ///\n+    /// If you need to cross object boundaries, cast the pointer to an integer and\n+    /// do the arithmetic there.\n+    ///\n+    /// [`offset`]: #method.offset\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// // Iterate using a raw pointer in increments of two elements\n+    /// let data = [1u8, 2, 3, 4, 5];\n+    /// let mut ptr: *const u8 = data.as_ptr();\n+    /// let step = 2;\n+    /// let end_rounded_up = ptr.wrapping_offset(6);\n+    ///\n+    /// // This loop prints \"1, 3, 5, \"\n+    /// while ptr != end_rounded_up {\n+    ///     unsafe {\n+    ///         print!(\"{}, \", *ptr);\n+    ///     }\n+    ///     ptr = ptr.wrapping_offset(step);\n+    /// }\n+    /// ```\n+    #[stable(feature = \"ptr_wrapping_offset\", since = \"1.16.0\")]\n+    #[inline]\n+    pub fn wrapping_offset(self, count: isize) -> *const T\n+        where\n+            T: Sized,\n+    {\n+        unsafe { intrinsics::arith_offset(self, count) }\n+    }\n+\n+    /// Calculates the distance between two pointers. The returned value is in\n+    /// units of T: the distance in bytes is divided by `mem::size_of::<T>()`.\n+    ///\n+    /// This function is the inverse of [`offset`].\n+    ///\n+    /// [`offset`]: #method.offset\n+    /// [`wrapping_offset_from`]: #method.wrapping_offset_from\n+    ///\n+    /// # Safety\n+    ///\n+    /// If any of the following conditions are violated, the result is Undefined\n+    /// Behavior:\n+    ///\n+    /// * Both the starting and other pointer must be either in bounds or one\n+    ///   byte past the end of the same allocated object. Note that in Rust,\n+    ///   every (stack-allocated) variable is considered a separate allocated object.\n+    ///\n+    /// * The distance between the pointers, **in bytes**, cannot overflow an `isize`.\n+    ///\n+    /// * The distance between the pointers, in bytes, must be an exact multiple\n+    ///   of the size of `T`.\n+    ///\n+    /// * The distance being in bounds cannot rely on \"wrapping around\" the address space.\n+    ///\n+    /// The compiler and standard library generally try to ensure allocations\n+    /// never reach a size where an offset is a concern. For instance, `Vec`\n+    /// and `Box` ensure they never allocate more than `isize::MAX` bytes, so\n+    /// `ptr_into_vec.offset_from(vec.as_ptr())` is always safe.\n+    ///\n+    /// Most platforms fundamentally can't even construct such an allocation.\n+    /// For instance, no known 64-bit platform can ever serve a request\n+    /// for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.\n+    /// However, some 32-bit and 16-bit platforms may successfully serve a request for\n+    /// more than `isize::MAX` bytes with things like Physical Address\n+    /// Extension. As such, memory acquired directly from allocators or memory\n+    /// mapped files *may* be too large to handle with this function.\n+    ///\n+    /// Consider using [`wrapping_offset_from`] instead if these constraints are\n+    /// difficult to satisfy. The only advantage of this method is that it\n+    /// enables more aggressive compiler optimizations.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function panics if `T` is a Zero-Sized Type (\"ZST\").\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(ptr_offset_from)]\n+    ///\n+    /// let a = [0; 5];\n+    /// let ptr1: *const i32 = &a[1];\n+    /// let ptr2: *const i32 = &a[3];\n+    /// unsafe {\n+    ///     assert_eq!(ptr2.offset_from(ptr1), 2);\n+    ///     assert_eq!(ptr1.offset_from(ptr2), -2);\n+    ///     assert_eq!(ptr1.offset(2), ptr2);\n+    ///     assert_eq!(ptr2.offset(-2), ptr1);\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"ptr_offset_from\", issue = \"41079\")]\n+    #[rustc_const_unstable(feature = \"const_ptr_offset_from\", issue = \"41079\")]\n+    #[inline]\n+    pub const unsafe fn offset_from(self, origin: *const T) -> isize\n+        where\n+            T: Sized,\n+    {\n+        let pointee_size = mem::size_of::<T>();\n+        let ok = 0 < pointee_size && pointee_size <= isize::max_value() as usize;\n+        // assert that the pointee size is valid in a const eval compatible way\n+        // FIXME: do this with a real assert at some point\n+        [()][(!ok) as usize];\n+        intrinsics::ptr_offset_from(self, origin)\n+    }\n+\n+    /// Calculates the distance between two pointers. The returned value is in\n+    /// units of T: the distance in bytes is divided by `mem::size_of::<T>()`.\n+    ///\n+    /// If the address different between the two pointers is not a multiple of\n+    /// `mem::size_of::<T>()` then the result of the division is rounded towards\n+    /// zero.\n+    ///\n+    /// Though this method is safe for any two pointers, note that its result\n+    /// will be mostly useless if the two pointers aren't into the same allocated\n+    /// object, for example if they point to two different local variables.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function panics if `T` is a zero-sized type.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(ptr_wrapping_offset_from)]\n+    ///\n+    /// let a = [0; 5];\n+    /// let ptr1: *const i32 = &a[1];\n+    /// let ptr2: *const i32 = &a[3];\n+    /// assert_eq!(ptr2.wrapping_offset_from(ptr1), 2);\n+    /// assert_eq!(ptr1.wrapping_offset_from(ptr2), -2);\n+    /// assert_eq!(ptr1.wrapping_offset(2), ptr2);\n+    /// assert_eq!(ptr2.wrapping_offset(-2), ptr1);\n+    ///\n+    /// let ptr1: *const i32 = 3 as _;\n+    /// let ptr2: *const i32 = 13 as _;\n+    /// assert_eq!(ptr2.wrapping_offset_from(ptr1), 2);\n+    /// ```\n+    #[unstable(feature = \"ptr_wrapping_offset_from\", issue = \"41079\")]\n+    #[inline]\n+    pub fn wrapping_offset_from(self, origin: *const T) -> isize\n+        where\n+            T: Sized,\n+    {\n+        let pointee_size = mem::size_of::<T>();\n+        assert!(0 < pointee_size && pointee_size <= isize::max_value() as usize);\n+\n+        let d = isize::wrapping_sub(self as _, origin as _);\n+        d.wrapping_div(pointee_size as _)\n+    }\n+\n+    /// Calculates the offset from a pointer (convenience for `.offset(count as isize)`).\n+    ///\n+    /// `count` is in units of T; e.g., a `count` of 3 represents a pointer\n+    /// offset of `3 * size_of::<T>()` bytes.\n+    ///\n+    /// # Safety\n+    ///\n+    /// If any of the following conditions are violated, the result is Undefined\n+    /// Behavior:\n+    ///\n+    /// * Both the starting and resulting pointer must be either in bounds or one\n+    ///   byte past the end of the same allocated object. Note that in Rust,\n+    ///   every (stack-allocated) variable is considered a separate allocated object.\n+    ///\n+    /// * The computed offset, **in bytes**, cannot overflow an `isize`.\n+    ///\n+    /// * The offset being in bounds cannot rely on \"wrapping around\" the address\n+    ///   space. That is, the infinite-precision sum must fit in a `usize`.\n+    ///\n+    /// The compiler and standard library generally tries to ensure allocations\n+    /// never reach a size where an offset is a concern. For instance, `Vec`\n+    /// and `Box` ensure they never allocate more than `isize::MAX` bytes, so\n+    /// `vec.as_ptr().add(vec.len())` is always safe.\n+    ///\n+    /// Most platforms fundamentally can't even construct such an allocation.\n+    /// For instance, no known 64-bit platform can ever serve a request\n+    /// for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.\n+    /// However, some 32-bit and 16-bit platforms may successfully serve a request for\n+    /// more than `isize::MAX` bytes with things like Physical Address\n+    /// Extension. As such, memory acquired directly from allocators or memory\n+    /// mapped files *may* be too large to handle with this function.\n+    ///\n+    /// Consider using [`wrapping_add`] instead if these constraints are\n+    /// difficult to satisfy. The only advantage of this method is that it\n+    /// enables more aggressive compiler optimizations.\n+    ///\n+    /// [`wrapping_add`]: #method.wrapping_add\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let s: &str = \"123\";\n+    /// let ptr: *const u8 = s.as_ptr();\n+    ///\n+    /// unsafe {\n+    ///     println!(\"{}\", *ptr.add(1) as char);\n+    ///     println!(\"{}\", *ptr.add(2) as char);\n+    /// }\n+    /// ```\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n+    #[inline]\n+    pub unsafe fn add(self, count: usize) -> Self\n+        where\n+            T: Sized,\n+    {\n+        self.offset(count as isize)\n+    }\n+\n+    /// Calculates the offset from a pointer (convenience for\n+    /// `.offset((count as isize).wrapping_neg())`).\n+    ///\n+    /// `count` is in units of T; e.g., a `count` of 3 represents a pointer\n+    /// offset of `3 * size_of::<T>()` bytes.\n+    ///\n+    /// # Safety\n+    ///\n+    /// If any of the following conditions are violated, the result is Undefined\n+    /// Behavior:\n+    ///\n+    /// * Both the starting and resulting pointer must be either in bounds or one\n+    ///   byte past the end of the same allocated object. Note that in Rust,\n+    ///   every (stack-allocated) variable is considered a separate allocated object.\n+    ///\n+    /// * The computed offset cannot exceed `isize::MAX` **bytes**.\n+    ///\n+    /// * The offset being in bounds cannot rely on \"wrapping around\" the address\n+    ///   space. That is, the infinite-precision sum must fit in a usize.\n+    ///\n+    /// The compiler and standard library generally tries to ensure allocations\n+    /// never reach a size where an offset is a concern. For instance, `Vec`\n+    /// and `Box` ensure they never allocate more than `isize::MAX` bytes, so\n+    /// `vec.as_ptr().add(vec.len()).sub(vec.len())` is always safe.\n+    ///\n+    /// Most platforms fundamentally can't even construct such an allocation.\n+    /// For instance, no known 64-bit platform can ever serve a request\n+    /// for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.\n+    /// However, some 32-bit and 16-bit platforms may successfully serve a request for\n+    /// more than `isize::MAX` bytes with things like Physical Address\n+    /// Extension. As such, memory acquired directly from allocators or memory\n+    /// mapped files *may* be too large to handle with this function.\n+    ///\n+    /// Consider using [`wrapping_sub`] instead if these constraints are\n+    /// difficult to satisfy. The only advantage of this method is that it\n+    /// enables more aggressive compiler optimizations.\n+    ///\n+    /// [`wrapping_sub`]: #method.wrapping_sub\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let s: &str = \"123\";\n+    ///\n+    /// unsafe {\n+    ///     let end: *const u8 = s.as_ptr().add(3);\n+    ///     println!(\"{}\", *end.sub(1) as char);\n+    ///     println!(\"{}\", *end.sub(2) as char);\n+    /// }\n+    /// ```\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n+    #[inline]\n+    pub unsafe fn sub(self, count: usize) -> Self\n+        where\n+            T: Sized,\n+    {\n+        self.offset((count as isize).wrapping_neg())\n+    }\n+\n+    /// Calculates the offset from a pointer using wrapping arithmetic.\n+    /// (convenience for `.wrapping_offset(count as isize)`)\n+    ///\n+    /// `count` is in units of T; e.g., a `count` of 3 represents a pointer\n+    /// offset of `3 * size_of::<T>()` bytes.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The resulting pointer does not need to be in bounds, but it is\n+    /// potentially hazardous to dereference (which requires `unsafe`).\n+    ///\n+    /// In particular, the resulting pointer remains attached to the same allocated\n+    /// object that `self` points to. It may *not* be used to access a\n+    /// different allocated object. Note that in Rust,\n+    /// every (stack-allocated) variable is considered a separate allocated object.\n+    ///\n+    /// Compared to [`add`], this method basically delays the requirement of staying\n+    /// within the same allocated object: [`add`] is immediate Undefined Behavior when\n+    /// crossing object boundaries; `wrapping_add` produces a pointer but still leads\n+    /// to Undefined Behavior if that pointer is dereferenced. [`add`] can be optimized\n+    /// better and is thus preferrable in performance-sensitive code.\n+    ///\n+    /// If you need to cross object boundaries, cast the pointer to an integer and\n+    /// do the arithmetic there.\n+    ///\n+    /// [`add`]: #method.add\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// // Iterate using a raw pointer in increments of two elements\n+    /// let data = [1u8, 2, 3, 4, 5];\n+    /// let mut ptr: *const u8 = data.as_ptr();\n+    /// let step = 2;\n+    /// let end_rounded_up = ptr.wrapping_add(6);\n+    ///\n+    /// // This loop prints \"1, 3, 5, \"\n+    /// while ptr != end_rounded_up {\n+    ///     unsafe {\n+    ///         print!(\"{}, \", *ptr);\n+    ///     }\n+    ///     ptr = ptr.wrapping_add(step);\n+    /// }\n+    /// ```\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n+    #[inline]\n+    pub fn wrapping_add(self, count: usize) -> Self\n+        where\n+            T: Sized,\n+    {\n+        self.wrapping_offset(count as isize)\n+    }\n+\n+    /// Calculates the offset from a pointer using wrapping arithmetic.\n+    /// (convenience for `.wrapping_offset((count as isize).wrapping_sub())`)\n+    ///\n+    /// `count` is in units of T; e.g., a `count` of 3 represents a pointer\n+    /// offset of `3 * size_of::<T>()` bytes.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The resulting pointer does not need to be in bounds, but it is\n+    /// potentially hazardous to dereference (which requires `unsafe`).\n+    ///\n+    /// In particular, the resulting pointer remains attached to the same allocated\n+    /// object that `self` points to. It may *not* be used to access a\n+    /// different allocated object. Note that in Rust,\n+    /// every (stack-allocated) variable is considered a separate allocated object.\n+    ///\n+    /// Compared to [`sub`], this method basically delays the requirement of staying\n+    /// within the same allocated object: [`sub`] is immediate Undefined Behavior when\n+    /// crossing object boundaries; `wrapping_sub` produces a pointer but still leads\n+    /// to Undefined Behavior if that pointer is dereferenced. [`sub`] can be optimized\n+    /// better and is thus preferrable in performance-sensitive code.\n+    ///\n+    /// If you need to cross object boundaries, cast the pointer to an integer and\n+    /// do the arithmetic there.\n+    ///\n+    /// [`sub`]: #method.sub\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// // Iterate using a raw pointer in increments of two elements (backwards)\n+    /// let data = [1u8, 2, 3, 4, 5];\n+    /// let mut ptr: *const u8 = data.as_ptr();\n+    /// let start_rounded_down = ptr.wrapping_sub(2);\n+    /// ptr = ptr.wrapping_add(4);\n+    /// let step = 2;\n+    /// // This loop prints \"5, 3, 1, \"\n+    /// while ptr != start_rounded_down {\n+    ///     unsafe {\n+    ///         print!(\"{}, \", *ptr);\n+    ///     }\n+    ///     ptr = ptr.wrapping_sub(step);\n+    /// }\n+    /// ```\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n+    #[inline]\n+    pub fn wrapping_sub(self, count: usize) -> Self\n+        where\n+            T: Sized,\n+    {\n+        self.wrapping_offset((count as isize).wrapping_neg())\n+    }\n+\n+    /// Reads the value from `self` without moving it. This leaves the\n+    /// memory in `self` unchanged.\n+    ///\n+    /// See [`ptr::read`] for safety concerns and examples.\n+    ///\n+    /// [`ptr::read`]: ./ptr/fn.read.html\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n+    #[inline]\n+    pub unsafe fn read(self) -> T\n+        where\n+            T: Sized,\n+    {\n+        read(self)\n+    }\n+\n+    /// Performs a volatile read of the value from `self` without moving it. This\n+    /// leaves the memory in `self` unchanged.\n+    ///\n+    /// Volatile operations are intended to act on I/O memory, and are guaranteed\n+    /// to not be elided or reordered by the compiler across other volatile\n+    /// operations.\n+    ///\n+    /// See [`ptr::read_volatile`] for safety concerns and examples.\n+    ///\n+    /// [`ptr::read_volatile`]: ./ptr/fn.read_volatile.html\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n+    #[inline]\n+    pub unsafe fn read_volatile(self) -> T\n+        where\n+            T: Sized,\n+    {\n+        read_volatile(self)\n+    }\n+\n+    /// Reads the value from `self` without moving it. This leaves the\n+    /// memory in `self` unchanged.\n+    ///\n+    /// Unlike `read`, the pointer may be unaligned.\n+    ///\n+    /// See [`ptr::read_unaligned`] for safety concerns and examples.\n+    ///\n+    /// [`ptr::read_unaligned`]: ./ptr/fn.read_unaligned.html\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n+    #[inline]\n+    pub unsafe fn read_unaligned(self) -> T\n+        where\n+            T: Sized,\n+    {\n+        read_unaligned(self)\n+    }\n+\n+    /// Copies `count * size_of<T>` bytes from `self` to `dest`. The source\n+    /// and destination may overlap.\n+    ///\n+    /// NOTE: this has the *same* argument order as [`ptr::copy`].\n+    ///\n+    /// See [`ptr::copy`] for safety concerns and examples.\n+    ///\n+    /// [`ptr::copy`]: ./ptr/fn.copy.html\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n+    #[inline]\n+    pub unsafe fn copy_to(self, dest: *mut T, count: usize)\n+        where\n+            T: Sized,\n+    {\n+        copy(self, dest, count)\n+    }\n+\n+    /// Copies `count * size_of<T>` bytes from `self` to `dest`. The source\n+    /// and destination may *not* overlap.\n+    ///\n+    /// NOTE: this has the *same* argument order as [`ptr::copy_nonoverlapping`].\n+    ///\n+    /// See [`ptr::copy_nonoverlapping`] for safety concerns and examples.\n+    ///\n+    /// [`ptr::copy_nonoverlapping`]: ./ptr/fn.copy_nonoverlapping.html\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n+    #[inline]\n+    pub unsafe fn copy_to_nonoverlapping(self, dest: *mut T, count: usize)\n+        where\n+            T: Sized,\n+    {\n+        copy_nonoverlapping(self, dest, count)\n+    }\n+\n+    /// Computes the offset that needs to be applied to the pointer in order to make it aligned to\n+    /// `align`.\n+    ///\n+    /// If it is not possible to align the pointer, the implementation returns\n+    /// `usize::max_value()`. It is permissible for the implementation to *always*\n+    /// return `usize::max_value()`. Only your algorithm's performance can depend\n+    /// on getting a usable offset here, not its correctness.\n+    ///\n+    /// The offset is expressed in number of `T` elements, and not bytes. The value returned can be\n+    /// used with the `wrapping_add` method.\n+    ///\n+    /// There are no guarantees whatsoever that offsetting the pointer will not overflow or go\n+    /// beyond the allocation that the pointer points into. It is up to the caller to ensure that\n+    /// the returned offset is correct in all terms other than alignment.\n+    ///\n+    /// # Panics\n+    ///\n+    /// The function panics if `align` is not a power-of-two.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Accessing adjacent `u8` as `u16`\n+    ///\n+    /// ```\n+    /// # fn foo(n: usize) {\n+    /// # use std::mem::align_of;\n+    /// # unsafe {\n+    /// let x = [5u8, 6u8, 7u8, 8u8, 9u8];\n+    /// let ptr = &x[n] as *const u8;\n+    /// let offset = ptr.align_offset(align_of::<u16>());\n+    /// if offset < x.len() - n - 1 {\n+    ///     let u16_ptr = ptr.add(offset) as *const u16;\n+    ///     assert_ne!(*u16_ptr, 500);\n+    /// } else {\n+    ///     // while the pointer can be aligned via `offset`, it would point\n+    ///     // outside the allocation\n+    /// }\n+    /// # } }\n+    /// ```\n+    #[stable(feature = \"align_offset\", since = \"1.36.0\")]\n+    pub fn align_offset(self, align: usize) -> usize\n+        where\n+            T: Sized,\n+    {\n+        if !align.is_power_of_two() {\n+            panic!(\"align_offset: align is not a power-of-two\");\n+        }\n+        unsafe { align_offset(self, align) }\n+    }\n+}\n+\n+// Equality for pointers\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: ?Sized> PartialEq for *const T {\n+    #[inline]\n+    fn eq(&self, other: &*const T) -> bool { *self == *other }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: ?Sized> Eq for *const T {}\n+\n+// Comparison for pointers\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: ?Sized> Ord for *const T {\n+    #[inline]\n+    fn cmp(&self, other: &*const T) -> Ordering {\n+        if self < other {\n+            Less\n+        } else if self == other {\n+            Equal\n+        } else {\n+            Greater\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: ?Sized> PartialOrd for *const T {\n+    #[inline]\n+    fn partial_cmp(&self, other: &*const T) -> Option<Ordering> {\n+        Some(self.cmp(other))\n+    }\n+\n+    #[inline]\n+    fn lt(&self, other: &*const T) -> bool { *self < *other }\n+\n+    #[inline]\n+    fn le(&self, other: &*const T) -> bool { *self <= *other }\n+\n+    #[inline]\n+    fn gt(&self, other: &*const T) -> bool { *self > *other }\n+\n+    #[inline]\n+    fn ge(&self, other: &*const T) -> bool { *self >= *other }\n+}"}, {"sha": "a3a73ff6c6cf6a3e41049d4a28d7bc5151a9137e", "filename": "src/libcore/ptr/mod.rs", "status": "modified", "additions": 5, "deletions": 1691, "changes": 1696, "blob_url": "https://github.com/rust-lang/rust/blob/e613f9238f6db2fb4223d1df75d94168ba75d186/src%2Flibcore%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e613f9238f6db2fb4223d1df75d94168ba75d186/src%2Flibcore%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmod.rs?ref=e613f9238f6db2fb4223d1df75d94168ba75d186", "patch": "@@ -65,16 +65,15 @@\n //! [`write_volatile`]: ./fn.write_volatile.html\n //! [`NonNull::dangling`]: ./struct.NonNull.html#method.dangling\n \n-// ignore-tidy-filelength\n // ignore-tidy-undocumented-unsafe\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use crate::cmp::Ordering::{self, Equal, Greater, Less};\n+use crate::intrinsics;\n use crate::fmt;\n use crate::hash;\n-use crate::intrinsics;\n use crate::mem::{self, MaybeUninit};\n+use crate::cmp::Ordering;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use crate::intrinsics::copy_nonoverlapping;\n@@ -93,6 +92,9 @@ mod unique;\n #[unstable(feature = \"ptr_internals\", issue = \"0\")]\n pub use unique::Unique;\n \n+mod const_ptr;\n+mod mut_ptr;\n+\n /// Executes the destructor (if any) of the pointed-to value.\n ///\n /// This is semantically equivalent to calling [`ptr::read`] and discarding\n@@ -1034,1586 +1036,6 @@ pub unsafe fn write_volatile<T>(dst: *mut T, src: T) {\n     intrinsics::volatile_store(dst, src);\n }\n \n-#[lang = \"const_ptr\"]\n-impl<T: ?Sized> *const T {\n-    /// Returns `true` if the pointer is null.\n-    ///\n-    /// Note that unsized types have many possible null pointers, as only the\n-    /// raw data pointer is considered, not their length, vtable, etc.\n-    /// Therefore, two pointers that are null may still not compare equal to\n-    /// each other.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let s: &str = \"Follow the rabbit\";\n-    /// let ptr: *const u8 = s.as_ptr();\n-    /// assert!(!ptr.is_null());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn is_null(self) -> bool {\n-        // Compare via a cast to a thin pointer, so fat pointers are only\n-        // considering their \"data\" part for null-ness.\n-        (self as *const u8) == null()\n-    }\n-\n-    /// Casts to a pointer of another type.\n-    #[stable(feature = \"ptr_cast\", since = \"1.38.0\")]\n-    #[rustc_const_stable(feature = \"const_ptr_cast\", since = \"1.38.0\")]\n-    #[inline]\n-    pub const fn cast<U>(self) -> *const U {\n-        self as _\n-    }\n-\n-    /// Returns `None` if the pointer is null, or else returns a reference to\n-    /// the value wrapped in `Some`.\n-    ///\n-    /// # Safety\n-    ///\n-    /// While this method and its mutable counterpart are useful for\n-    /// null-safety, it is important to note that this is still an unsafe\n-    /// operation because the returned value could be pointing to invalid\n-    /// memory.\n-    ///\n-    /// When calling this method, you have to ensure that *either* the pointer is NULL *or*\n-    /// all of the following is true:\n-    /// - it is properly aligned\n-    /// - it must point to an initialized instance of T; in particular, the pointer must be\n-    ///   \"dereferencable\" in the sense defined [here].\n-    ///\n-    /// This applies even if the result of this method is unused!\n-    /// (The part about being initialized is not yet fully decided, but until\n-    /// it is, the only safe approach is to ensure that they are indeed initialized.)\n-    ///\n-    /// Additionally, the lifetime `'a` returned is arbitrarily chosen and does\n-    /// not necessarily reflect the actual lifetime of the data. *You* must enforce\n-    /// Rust's aliasing rules. In particular, for the duration of this lifetime,\n-    /// the memory the pointer points to must not get mutated (except inside `UnsafeCell`).\n-    ///\n-    /// [here]: crate::ptr#safety\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let ptr: *const u8 = &10u8 as *const u8;\n-    ///\n-    /// unsafe {\n-    ///     if let Some(val_back) = ptr.as_ref() {\n-    ///         println!(\"We got back the value: {}!\", val_back);\n-    ///     }\n-    /// }\n-    /// ```\n-    ///\n-    /// # Null-unchecked version\n-    ///\n-    /// If you are sure the pointer can never be null and are looking for some kind of\n-    /// `as_ref_unchecked` that returns the `&T` instead of `Option<&T>`, know that you can\n-    /// dereference the pointer directly.\n-    ///\n-    /// ```\n-    /// let ptr: *const u8 = &10u8 as *const u8;\n-    ///\n-    /// unsafe {\n-    ///     let val_back = &*ptr;\n-    ///     println!(\"We got back the value: {}!\", val_back);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"ptr_as_ref\", since = \"1.9.0\")]\n-    #[inline]\n-    pub unsafe fn as_ref<'a>(self) -> Option<&'a T> {\n-        if self.is_null() { None } else { Some(&*self) }\n-    }\n-\n-    /// Calculates the offset from a pointer.\n-    ///\n-    /// `count` is in units of T; e.g., a `count` of 3 represents a pointer\n-    /// offset of `3 * size_of::<T>()` bytes.\n-    ///\n-    /// # Safety\n-    ///\n-    /// If any of the following conditions are violated, the result is Undefined\n-    /// Behavior:\n-    ///\n-    /// * Both the starting and resulting pointer must be either in bounds or one\n-    ///   byte past the end of the same allocated object. Note that in Rust,\n-    ///   every (stack-allocated) variable is considered a separate allocated object.\n-    ///\n-    /// * The computed offset, **in bytes**, cannot overflow an `isize`.\n-    ///\n-    /// * The offset being in bounds cannot rely on \"wrapping around\" the address\n-    ///   space. That is, the infinite-precision sum, **in bytes** must fit in a usize.\n-    ///\n-    /// The compiler and standard library generally tries to ensure allocations\n-    /// never reach a size where an offset is a concern. For instance, `Vec`\n-    /// and `Box` ensure they never allocate more than `isize::MAX` bytes, so\n-    /// `vec.as_ptr().add(vec.len())` is always safe.\n-    ///\n-    /// Most platforms fundamentally can't even construct such an allocation.\n-    /// For instance, no known 64-bit platform can ever serve a request\n-    /// for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.\n-    /// However, some 32-bit and 16-bit platforms may successfully serve a request for\n-    /// more than `isize::MAX` bytes with things like Physical Address\n-    /// Extension. As such, memory acquired directly from allocators or memory\n-    /// mapped files *may* be too large to handle with this function.\n-    ///\n-    /// Consider using [`wrapping_offset`] instead if these constraints are\n-    /// difficult to satisfy. The only advantage of this method is that it\n-    /// enables more aggressive compiler optimizations.\n-    ///\n-    /// [`wrapping_offset`]: #method.wrapping_offset\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let s: &str = \"123\";\n-    /// let ptr: *const u8 = s.as_ptr();\n-    ///\n-    /// unsafe {\n-    ///     println!(\"{}\", *ptr.offset(1) as char);\n-    ///     println!(\"{}\", *ptr.offset(2) as char);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub unsafe fn offset(self, count: isize) -> *const T\n-    where\n-        T: Sized,\n-    {\n-        intrinsics::offset(self, count)\n-    }\n-\n-    /// Calculates the offset from a pointer using wrapping arithmetic.\n-    ///\n-    /// `count` is in units of T; e.g., a `count` of 3 represents a pointer\n-    /// offset of `3 * size_of::<T>()` bytes.\n-    ///\n-    /// # Safety\n-    ///\n-    /// The resulting pointer does not need to be in bounds, but it is\n-    /// potentially hazardous to dereference (which requires `unsafe`).\n-    ///\n-    /// In particular, the resulting pointer remains attached to the same allocated\n-    /// object that `self` points to. It may *not* be used to access a\n-    /// different allocated object. Note that in Rust,\n-    /// every (stack-allocated) variable is considered a separate allocated object.\n-    ///\n-    /// In other words, `x.wrapping_offset(y.wrapping_offset_from(x))` is\n-    /// *not* the same as `y`, and dereferencing it is undefined behavior\n-    /// unless `x` and `y` point into the same allocated object.\n-    ///\n-    /// Compared to [`offset`], this method basically delays the requirement of staying\n-    /// within the same allocated object: [`offset`] is immediate Undefined Behavior when\n-    /// crossing object boundaries; `wrapping_offset` produces a pointer but still leads\n-    /// to Undefined Behavior if that pointer is dereferenced. [`offset`] can be optimized\n-    /// better and is thus preferrable in performance-sensitive code.\n-    ///\n-    /// If you need to cross object boundaries, cast the pointer to an integer and\n-    /// do the arithmetic there.\n-    ///\n-    /// [`offset`]: #method.offset\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// // Iterate using a raw pointer in increments of two elements\n-    /// let data = [1u8, 2, 3, 4, 5];\n-    /// let mut ptr: *const u8 = data.as_ptr();\n-    /// let step = 2;\n-    /// let end_rounded_up = ptr.wrapping_offset(6);\n-    ///\n-    /// // This loop prints \"1, 3, 5, \"\n-    /// while ptr != end_rounded_up {\n-    ///     unsafe {\n-    ///         print!(\"{}, \", *ptr);\n-    ///     }\n-    ///     ptr = ptr.wrapping_offset(step);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"ptr_wrapping_offset\", since = \"1.16.0\")]\n-    #[inline]\n-    pub fn wrapping_offset(self, count: isize) -> *const T\n-    where\n-        T: Sized,\n-    {\n-        unsafe { intrinsics::arith_offset(self, count) }\n-    }\n-\n-    /// Calculates the distance between two pointers. The returned value is in\n-    /// units of T: the distance in bytes is divided by `mem::size_of::<T>()`.\n-    ///\n-    /// This function is the inverse of [`offset`].\n-    ///\n-    /// [`offset`]: #method.offset\n-    /// [`wrapping_offset_from`]: #method.wrapping_offset_from\n-    ///\n-    /// # Safety\n-    ///\n-    /// If any of the following conditions are violated, the result is Undefined\n-    /// Behavior:\n-    ///\n-    /// * Both the starting and other pointer must be either in bounds or one\n-    ///   byte past the end of the same allocated object. Note that in Rust,\n-    ///   every (stack-allocated) variable is considered a separate allocated object.\n-    ///\n-    /// * The distance between the pointers, **in bytes**, cannot overflow an `isize`.\n-    ///\n-    /// * The distance between the pointers, in bytes, must be an exact multiple\n-    ///   of the size of `T`.\n-    ///\n-    /// * The distance being in bounds cannot rely on \"wrapping around\" the address space.\n-    ///\n-    /// The compiler and standard library generally try to ensure allocations\n-    /// never reach a size where an offset is a concern. For instance, `Vec`\n-    /// and `Box` ensure they never allocate more than `isize::MAX` bytes, so\n-    /// `ptr_into_vec.offset_from(vec.as_ptr())` is always safe.\n-    ///\n-    /// Most platforms fundamentally can't even construct such an allocation.\n-    /// For instance, no known 64-bit platform can ever serve a request\n-    /// for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.\n-    /// However, some 32-bit and 16-bit platforms may successfully serve a request for\n-    /// more than `isize::MAX` bytes with things like Physical Address\n-    /// Extension. As such, memory acquired directly from allocators or memory\n-    /// mapped files *may* be too large to handle with this function.\n-    ///\n-    /// Consider using [`wrapping_offset_from`] instead if these constraints are\n-    /// difficult to satisfy. The only advantage of this method is that it\n-    /// enables more aggressive compiler optimizations.\n-    ///\n-    /// # Panics\n-    ///\n-    /// This function panics if `T` is a Zero-Sized Type (\"ZST\").\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// #![feature(ptr_offset_from)]\n-    ///\n-    /// let a = [0; 5];\n-    /// let ptr1: *const i32 = &a[1];\n-    /// let ptr2: *const i32 = &a[3];\n-    /// unsafe {\n-    ///     assert_eq!(ptr2.offset_from(ptr1), 2);\n-    ///     assert_eq!(ptr1.offset_from(ptr2), -2);\n-    ///     assert_eq!(ptr1.offset(2), ptr2);\n-    ///     assert_eq!(ptr2.offset(-2), ptr1);\n-    /// }\n-    /// ```\n-    #[unstable(feature = \"ptr_offset_from\", issue = \"41079\")]\n-    #[rustc_const_unstable(feature = \"const_ptr_offset_from\", issue = \"41079\")]\n-    #[inline]\n-    pub const unsafe fn offset_from(self, origin: *const T) -> isize\n-    where\n-        T: Sized,\n-    {\n-        let pointee_size = mem::size_of::<T>();\n-        let ok = 0 < pointee_size && pointee_size <= isize::max_value() as usize;\n-        // assert that the pointee size is valid in a const eval compatible way\n-        // FIXME: do this with a real assert at some point\n-        [()][(!ok) as usize];\n-        intrinsics::ptr_offset_from(self, origin)\n-    }\n-\n-    /// Calculates the distance between two pointers. The returned value is in\n-    /// units of T: the distance in bytes is divided by `mem::size_of::<T>()`.\n-    ///\n-    /// If the address different between the two pointers is not a multiple of\n-    /// `mem::size_of::<T>()` then the result of the division is rounded towards\n-    /// zero.\n-    ///\n-    /// Though this method is safe for any two pointers, note that its result\n-    /// will be mostly useless if the two pointers aren't into the same allocated\n-    /// object, for example if they point to two different local variables.\n-    ///\n-    /// # Panics\n-    ///\n-    /// This function panics if `T` is a zero-sized type.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// #![feature(ptr_wrapping_offset_from)]\n-    ///\n-    /// let a = [0; 5];\n-    /// let ptr1: *const i32 = &a[1];\n-    /// let ptr2: *const i32 = &a[3];\n-    /// assert_eq!(ptr2.wrapping_offset_from(ptr1), 2);\n-    /// assert_eq!(ptr1.wrapping_offset_from(ptr2), -2);\n-    /// assert_eq!(ptr1.wrapping_offset(2), ptr2);\n-    /// assert_eq!(ptr2.wrapping_offset(-2), ptr1);\n-    ///\n-    /// let ptr1: *const i32 = 3 as _;\n-    /// let ptr2: *const i32 = 13 as _;\n-    /// assert_eq!(ptr2.wrapping_offset_from(ptr1), 2);\n-    /// ```\n-    #[unstable(feature = \"ptr_wrapping_offset_from\", issue = \"41079\")]\n-    #[inline]\n-    pub fn wrapping_offset_from(self, origin: *const T) -> isize\n-    where\n-        T: Sized,\n-    {\n-        let pointee_size = mem::size_of::<T>();\n-        assert!(0 < pointee_size && pointee_size <= isize::max_value() as usize);\n-\n-        let d = isize::wrapping_sub(self as _, origin as _);\n-        d.wrapping_div(pointee_size as _)\n-    }\n-\n-    /// Calculates the offset from a pointer (convenience for `.offset(count as isize)`).\n-    ///\n-    /// `count` is in units of T; e.g., a `count` of 3 represents a pointer\n-    /// offset of `3 * size_of::<T>()` bytes.\n-    ///\n-    /// # Safety\n-    ///\n-    /// If any of the following conditions are violated, the result is Undefined\n-    /// Behavior:\n-    ///\n-    /// * Both the starting and resulting pointer must be either in bounds or one\n-    ///   byte past the end of the same allocated object. Note that in Rust,\n-    ///   every (stack-allocated) variable is considered a separate allocated object.\n-    ///\n-    /// * The computed offset, **in bytes**, cannot overflow an `isize`.\n-    ///\n-    /// * The offset being in bounds cannot rely on \"wrapping around\" the address\n-    ///   space. That is, the infinite-precision sum must fit in a `usize`.\n-    ///\n-    /// The compiler and standard library generally tries to ensure allocations\n-    /// never reach a size where an offset is a concern. For instance, `Vec`\n-    /// and `Box` ensure they never allocate more than `isize::MAX` bytes, so\n-    /// `vec.as_ptr().add(vec.len())` is always safe.\n-    ///\n-    /// Most platforms fundamentally can't even construct such an allocation.\n-    /// For instance, no known 64-bit platform can ever serve a request\n-    /// for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.\n-    /// However, some 32-bit and 16-bit platforms may successfully serve a request for\n-    /// more than `isize::MAX` bytes with things like Physical Address\n-    /// Extension. As such, memory acquired directly from allocators or memory\n-    /// mapped files *may* be too large to handle with this function.\n-    ///\n-    /// Consider using [`wrapping_add`] instead if these constraints are\n-    /// difficult to satisfy. The only advantage of this method is that it\n-    /// enables more aggressive compiler optimizations.\n-    ///\n-    /// [`wrapping_add`]: #method.wrapping_add\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let s: &str = \"123\";\n-    /// let ptr: *const u8 = s.as_ptr();\n-    ///\n-    /// unsafe {\n-    ///     println!(\"{}\", *ptr.add(1) as char);\n-    ///     println!(\"{}\", *ptr.add(2) as char);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n-    #[inline]\n-    pub unsafe fn add(self, count: usize) -> Self\n-    where\n-        T: Sized,\n-    {\n-        self.offset(count as isize)\n-    }\n-\n-    /// Calculates the offset from a pointer (convenience for\n-    /// `.offset((count as isize).wrapping_neg())`).\n-    ///\n-    /// `count` is in units of T; e.g., a `count` of 3 represents a pointer\n-    /// offset of `3 * size_of::<T>()` bytes.\n-    ///\n-    /// # Safety\n-    ///\n-    /// If any of the following conditions are violated, the result is Undefined\n-    /// Behavior:\n-    ///\n-    /// * Both the starting and resulting pointer must be either in bounds or one\n-    ///   byte past the end of the same allocated object. Note that in Rust,\n-    ///   every (stack-allocated) variable is considered a separate allocated object.\n-    ///\n-    /// * The computed offset cannot exceed `isize::MAX` **bytes**.\n-    ///\n-    /// * The offset being in bounds cannot rely on \"wrapping around\" the address\n-    ///   space. That is, the infinite-precision sum must fit in a usize.\n-    ///\n-    /// The compiler and standard library generally tries to ensure allocations\n-    /// never reach a size where an offset is a concern. For instance, `Vec`\n-    /// and `Box` ensure they never allocate more than `isize::MAX` bytes, so\n-    /// `vec.as_ptr().add(vec.len()).sub(vec.len())` is always safe.\n-    ///\n-    /// Most platforms fundamentally can't even construct such an allocation.\n-    /// For instance, no known 64-bit platform can ever serve a request\n-    /// for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.\n-    /// However, some 32-bit and 16-bit platforms may successfully serve a request for\n-    /// more than `isize::MAX` bytes with things like Physical Address\n-    /// Extension. As such, memory acquired directly from allocators or memory\n-    /// mapped files *may* be too large to handle with this function.\n-    ///\n-    /// Consider using [`wrapping_sub`] instead if these constraints are\n-    /// difficult to satisfy. The only advantage of this method is that it\n-    /// enables more aggressive compiler optimizations.\n-    ///\n-    /// [`wrapping_sub`]: #method.wrapping_sub\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let s: &str = \"123\";\n-    ///\n-    /// unsafe {\n-    ///     let end: *const u8 = s.as_ptr().add(3);\n-    ///     println!(\"{}\", *end.sub(1) as char);\n-    ///     println!(\"{}\", *end.sub(2) as char);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n-    #[inline]\n-    pub unsafe fn sub(self, count: usize) -> Self\n-    where\n-        T: Sized,\n-    {\n-        self.offset((count as isize).wrapping_neg())\n-    }\n-\n-    /// Calculates the offset from a pointer using wrapping arithmetic.\n-    /// (convenience for `.wrapping_offset(count as isize)`)\n-    ///\n-    /// `count` is in units of T; e.g., a `count` of 3 represents a pointer\n-    /// offset of `3 * size_of::<T>()` bytes.\n-    ///\n-    /// # Safety\n-    ///\n-    /// The resulting pointer does not need to be in bounds, but it is\n-    /// potentially hazardous to dereference (which requires `unsafe`).\n-    ///\n-    /// In particular, the resulting pointer remains attached to the same allocated\n-    /// object that `self` points to. It may *not* be used to access a\n-    /// different allocated object. Note that in Rust,\n-    /// every (stack-allocated) variable is considered a separate allocated object.\n-    ///\n-    /// Compared to [`add`], this method basically delays the requirement of staying\n-    /// within the same allocated object: [`add`] is immediate Undefined Behavior when\n-    /// crossing object boundaries; `wrapping_add` produces a pointer but still leads\n-    /// to Undefined Behavior if that pointer is dereferenced. [`add`] can be optimized\n-    /// better and is thus preferrable in performance-sensitive code.\n-    ///\n-    /// If you need to cross object boundaries, cast the pointer to an integer and\n-    /// do the arithmetic there.\n-    ///\n-    /// [`add`]: #method.add\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// // Iterate using a raw pointer in increments of two elements\n-    /// let data = [1u8, 2, 3, 4, 5];\n-    /// let mut ptr: *const u8 = data.as_ptr();\n-    /// let step = 2;\n-    /// let end_rounded_up = ptr.wrapping_add(6);\n-    ///\n-    /// // This loop prints \"1, 3, 5, \"\n-    /// while ptr != end_rounded_up {\n-    ///     unsafe {\n-    ///         print!(\"{}, \", *ptr);\n-    ///     }\n-    ///     ptr = ptr.wrapping_add(step);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n-    #[inline]\n-    pub fn wrapping_add(self, count: usize) -> Self\n-    where\n-        T: Sized,\n-    {\n-        self.wrapping_offset(count as isize)\n-    }\n-\n-    /// Calculates the offset from a pointer using wrapping arithmetic.\n-    /// (convenience for `.wrapping_offset((count as isize).wrapping_sub())`)\n-    ///\n-    /// `count` is in units of T; e.g., a `count` of 3 represents a pointer\n-    /// offset of `3 * size_of::<T>()` bytes.\n-    ///\n-    /// # Safety\n-    ///\n-    /// The resulting pointer does not need to be in bounds, but it is\n-    /// potentially hazardous to dereference (which requires `unsafe`).\n-    ///\n-    /// In particular, the resulting pointer remains attached to the same allocated\n-    /// object that `self` points to. It may *not* be used to access a\n-    /// different allocated object. Note that in Rust,\n-    /// every (stack-allocated) variable is considered a separate allocated object.\n-    ///\n-    /// Compared to [`sub`], this method basically delays the requirement of staying\n-    /// within the same allocated object: [`sub`] is immediate Undefined Behavior when\n-    /// crossing object boundaries; `wrapping_sub` produces a pointer but still leads\n-    /// to Undefined Behavior if that pointer is dereferenced. [`sub`] can be optimized\n-    /// better and is thus preferrable in performance-sensitive code.\n-    ///\n-    /// If you need to cross object boundaries, cast the pointer to an integer and\n-    /// do the arithmetic there.\n-    ///\n-    /// [`sub`]: #method.sub\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// // Iterate using a raw pointer in increments of two elements (backwards)\n-    /// let data = [1u8, 2, 3, 4, 5];\n-    /// let mut ptr: *const u8 = data.as_ptr();\n-    /// let start_rounded_down = ptr.wrapping_sub(2);\n-    /// ptr = ptr.wrapping_add(4);\n-    /// let step = 2;\n-    /// // This loop prints \"5, 3, 1, \"\n-    /// while ptr != start_rounded_down {\n-    ///     unsafe {\n-    ///         print!(\"{}, \", *ptr);\n-    ///     }\n-    ///     ptr = ptr.wrapping_sub(step);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n-    #[inline]\n-    pub fn wrapping_sub(self, count: usize) -> Self\n-    where\n-        T: Sized,\n-    {\n-        self.wrapping_offset((count as isize).wrapping_neg())\n-    }\n-\n-    /// Reads the value from `self` without moving it. This leaves the\n-    /// memory in `self` unchanged.\n-    ///\n-    /// See [`ptr::read`] for safety concerns and examples.\n-    ///\n-    /// [`ptr::read`]: ./ptr/fn.read.html\n-    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n-    #[inline]\n-    pub unsafe fn read(self) -> T\n-    where\n-        T: Sized,\n-    {\n-        read(self)\n-    }\n-\n-    /// Performs a volatile read of the value from `self` without moving it. This\n-    /// leaves the memory in `self` unchanged.\n-    ///\n-    /// Volatile operations are intended to act on I/O memory, and are guaranteed\n-    /// to not be elided or reordered by the compiler across other volatile\n-    /// operations.\n-    ///\n-    /// See [`ptr::read_volatile`] for safety concerns and examples.\n-    ///\n-    /// [`ptr::read_volatile`]: ./ptr/fn.read_volatile.html\n-    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n-    #[inline]\n-    pub unsafe fn read_volatile(self) -> T\n-    where\n-        T: Sized,\n-    {\n-        read_volatile(self)\n-    }\n-\n-    /// Reads the value from `self` without moving it. This leaves the\n-    /// memory in `self` unchanged.\n-    ///\n-    /// Unlike `read`, the pointer may be unaligned.\n-    ///\n-    /// See [`ptr::read_unaligned`] for safety concerns and examples.\n-    ///\n-    /// [`ptr::read_unaligned`]: ./ptr/fn.read_unaligned.html\n-    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n-    #[inline]\n-    pub unsafe fn read_unaligned(self) -> T\n-    where\n-        T: Sized,\n-    {\n-        read_unaligned(self)\n-    }\n-\n-    /// Copies `count * size_of<T>` bytes from `self` to `dest`. The source\n-    /// and destination may overlap.\n-    ///\n-    /// NOTE: this has the *same* argument order as [`ptr::copy`].\n-    ///\n-    /// See [`ptr::copy`] for safety concerns and examples.\n-    ///\n-    /// [`ptr::copy`]: ./ptr/fn.copy.html\n-    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n-    #[inline]\n-    pub unsafe fn copy_to(self, dest: *mut T, count: usize)\n-    where\n-        T: Sized,\n-    {\n-        copy(self, dest, count)\n-    }\n-\n-    /// Copies `count * size_of<T>` bytes from `self` to `dest`. The source\n-    /// and destination may *not* overlap.\n-    ///\n-    /// NOTE: this has the *same* argument order as [`ptr::copy_nonoverlapping`].\n-    ///\n-    /// See [`ptr::copy_nonoverlapping`] for safety concerns and examples.\n-    ///\n-    /// [`ptr::copy_nonoverlapping`]: ./ptr/fn.copy_nonoverlapping.html\n-    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n-    #[inline]\n-    pub unsafe fn copy_to_nonoverlapping(self, dest: *mut T, count: usize)\n-    where\n-        T: Sized,\n-    {\n-        copy_nonoverlapping(self, dest, count)\n-    }\n-\n-    /// Computes the offset that needs to be applied to the pointer in order to make it aligned to\n-    /// `align`.\n-    ///\n-    /// If it is not possible to align the pointer, the implementation returns\n-    /// `usize::max_value()`. It is permissible for the implementation to *always*\n-    /// return `usize::max_value()`. Only your algorithm's performance can depend\n-    /// on getting a usable offset here, not its correctness.\n-    ///\n-    /// The offset is expressed in number of `T` elements, and not bytes. The value returned can be\n-    /// used with the `wrapping_add` method.\n-    ///\n-    /// There are no guarantees whatsoever that offsetting the pointer will not overflow or go\n-    /// beyond the allocation that the pointer points into. It is up to the caller to ensure that\n-    /// the returned offset is correct in all terms other than alignment.\n-    ///\n-    /// # Panics\n-    ///\n-    /// The function panics if `align` is not a power-of-two.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Accessing adjacent `u8` as `u16`\n-    ///\n-    /// ```\n-    /// # fn foo(n: usize) {\n-    /// # use std::mem::align_of;\n-    /// # unsafe {\n-    /// let x = [5u8, 6u8, 7u8, 8u8, 9u8];\n-    /// let ptr = &x[n] as *const u8;\n-    /// let offset = ptr.align_offset(align_of::<u16>());\n-    /// if offset < x.len() - n - 1 {\n-    ///     let u16_ptr = ptr.add(offset) as *const u16;\n-    ///     assert_ne!(*u16_ptr, 500);\n-    /// } else {\n-    ///     // while the pointer can be aligned via `offset`, it would point\n-    ///     // outside the allocation\n-    /// }\n-    /// # } }\n-    /// ```\n-    #[stable(feature = \"align_offset\", since = \"1.36.0\")]\n-    pub fn align_offset(self, align: usize) -> usize\n-    where\n-        T: Sized,\n-    {\n-        if !align.is_power_of_two() {\n-            panic!(\"align_offset: align is not a power-of-two\");\n-        }\n-        unsafe { align_offset(self, align) }\n-    }\n-}\n-\n-#[lang = \"mut_ptr\"]\n-impl<T: ?Sized> *mut T {\n-    /// Returns `true` if the pointer is null.\n-    ///\n-    /// Note that unsized types have many possible null pointers, as only the\n-    /// raw data pointer is considered, not their length, vtable, etc.\n-    /// Therefore, two pointers that are null may still not compare equal to\n-    /// each other.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let mut s = [1, 2, 3];\n-    /// let ptr: *mut u32 = s.as_mut_ptr();\n-    /// assert!(!ptr.is_null());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn is_null(self) -> bool {\n-        // Compare via a cast to a thin pointer, so fat pointers are only\n-        // considering their \"data\" part for null-ness.\n-        (self as *mut u8) == null_mut()\n-    }\n-\n-    /// Casts to a pointer of another type.\n-    #[stable(feature = \"ptr_cast\", since = \"1.38.0\")]\n-    #[rustc_const_stable(feature = \"const_ptr_cast\", since = \"1.38.0\")]\n-    #[inline]\n-    pub const fn cast<U>(self) -> *mut U {\n-        self as _\n-    }\n-\n-    /// Returns `None` if the pointer is null, or else returns a reference to\n-    /// the value wrapped in `Some`.\n-    ///\n-    /// # Safety\n-    ///\n-    /// While this method and its mutable counterpart are useful for\n-    /// null-safety, it is important to note that this is still an unsafe\n-    /// operation because the returned value could be pointing to invalid\n-    /// memory.\n-    ///\n-    /// When calling this method, you have to ensure that if the pointer is\n-    /// non-NULL, then it is properly aligned, dereferencable (for the whole\n-    /// size of `T`) and points to an initialized instance of `T`. This applies\n-    /// even if the result of this method is unused!\n-    /// (The part about being initialized is not yet fully decided, but until\n-    /// it is, the only safe approach is to ensure that they are indeed initialized.)\n-    ///\n-    /// Additionally, the lifetime `'a` returned is arbitrarily chosen and does\n-    /// not necessarily reflect the actual lifetime of the data. It is up to the\n-    /// caller to ensure that for the duration of this lifetime, the memory this\n-    /// pointer points to does not get written to outside of `UnsafeCell<U>`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let ptr: *mut u8 = &mut 10u8 as *mut u8;\n-    ///\n-    /// unsafe {\n-    ///     if let Some(val_back) = ptr.as_ref() {\n-    ///         println!(\"We got back the value: {}!\", val_back);\n-    ///     }\n-    /// }\n-    /// ```\n-    ///\n-    /// # Null-unchecked version\n-    ///\n-    /// If you are sure the pointer can never be null and are looking for some kind of\n-    /// `as_ref_unchecked` that returns the `&T` instead of `Option<&T>`, know that you can\n-    /// dereference the pointer directly.\n-    ///\n-    /// ```\n-    /// let ptr: *mut u8 = &mut 10u8 as *mut u8;\n-    ///\n-    /// unsafe {\n-    ///     let val_back = &*ptr;\n-    ///     println!(\"We got back the value: {}!\", val_back);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"ptr_as_ref\", since = \"1.9.0\")]\n-    #[inline]\n-    pub unsafe fn as_ref<'a>(self) -> Option<&'a T> {\n-        if self.is_null() { None } else { Some(&*self) }\n-    }\n-\n-    /// Calculates the offset from a pointer.\n-    ///\n-    /// `count` is in units of T; e.g., a `count` of 3 represents a pointer\n-    /// offset of `3 * size_of::<T>()` bytes.\n-    ///\n-    /// # Safety\n-    ///\n-    /// If any of the following conditions are violated, the result is Undefined\n-    /// Behavior:\n-    ///\n-    /// * Both the starting and resulting pointer must be either in bounds or one\n-    ///   byte past the end of the same allocated object. Note that in Rust,\n-    ///   every (stack-allocated) variable is considered a separate allocated object.\n-    ///\n-    /// * The computed offset, **in bytes**, cannot overflow an `isize`.\n-    ///\n-    /// * The offset being in bounds cannot rely on \"wrapping around\" the address\n-    ///   space. That is, the infinite-precision sum, **in bytes** must fit in a usize.\n-    ///\n-    /// The compiler and standard library generally tries to ensure allocations\n-    /// never reach a size where an offset is a concern. For instance, `Vec`\n-    /// and `Box` ensure they never allocate more than `isize::MAX` bytes, so\n-    /// `vec.as_ptr().add(vec.len())` is always safe.\n-    ///\n-    /// Most platforms fundamentally can't even construct such an allocation.\n-    /// For instance, no known 64-bit platform can ever serve a request\n-    /// for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.\n-    /// However, some 32-bit and 16-bit platforms may successfully serve a request for\n-    /// more than `isize::MAX` bytes with things like Physical Address\n-    /// Extension. As such, memory acquired directly from allocators or memory\n-    /// mapped files *may* be too large to handle with this function.\n-    ///\n-    /// Consider using [`wrapping_offset`] instead if these constraints are\n-    /// difficult to satisfy. The only advantage of this method is that it\n-    /// enables more aggressive compiler optimizations.\n-    ///\n-    /// [`wrapping_offset`]: #method.wrapping_offset\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let mut s = [1, 2, 3];\n-    /// let ptr: *mut u32 = s.as_mut_ptr();\n-    ///\n-    /// unsafe {\n-    ///     println!(\"{}\", *ptr.offset(1));\n-    ///     println!(\"{}\", *ptr.offset(2));\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub unsafe fn offset(self, count: isize) -> *mut T\n-    where\n-        T: Sized,\n-    {\n-        intrinsics::offset(self, count) as *mut T\n-    }\n-\n-    /// Calculates the offset from a pointer using wrapping arithmetic.\n-    /// `count` is in units of T; e.g., a `count` of 3 represents a pointer\n-    /// offset of `3 * size_of::<T>()` bytes.\n-    ///\n-    /// # Safety\n-    ///\n-    /// The resulting pointer does not need to be in bounds, but it is\n-    /// potentially hazardous to dereference (which requires `unsafe`).\n-    ///\n-    /// In particular, the resulting pointer remains attached to the same allocated\n-    /// object that `self` points to. It may *not* be used to access a\n-    /// different allocated object. Note that in Rust,\n-    /// every (stack-allocated) variable is considered a separate allocated object.\n-    ///\n-    /// In other words, `x.wrapping_offset(y.wrapping_offset_from(x))` is\n-    /// *not* the same as `y`, and dereferencing it is undefined behavior\n-    /// unless `x` and `y` point into the same allocated object.\n-    ///\n-    /// Compared to [`offset`], this method basically delays the requirement of staying\n-    /// within the same allocated object: [`offset`] is immediate Undefined Behavior when\n-    /// crossing object boundaries; `wrapping_offset` produces a pointer but still leads\n-    /// to Undefined Behavior if that pointer is dereferenced. [`offset`] can be optimized\n-    /// better and is thus preferrable in performance-sensitive code.\n-    ///\n-    /// If you need to cross object boundaries, cast the pointer to an integer and\n-    /// do the arithmetic there.\n-    ///\n-    /// [`offset`]: #method.offset\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// // Iterate using a raw pointer in increments of two elements\n-    /// let mut data = [1u8, 2, 3, 4, 5];\n-    /// let mut ptr: *mut u8 = data.as_mut_ptr();\n-    /// let step = 2;\n-    /// let end_rounded_up = ptr.wrapping_offset(6);\n-    ///\n-    /// while ptr != end_rounded_up {\n-    ///     unsafe {\n-    ///         *ptr = 0;\n-    ///     }\n-    ///     ptr = ptr.wrapping_offset(step);\n-    /// }\n-    /// assert_eq!(&data, &[0, 2, 0, 4, 0]);\n-    /// ```\n-    #[stable(feature = \"ptr_wrapping_offset\", since = \"1.16.0\")]\n-    #[inline]\n-    pub fn wrapping_offset(self, count: isize) -> *mut T\n-    where\n-        T: Sized,\n-    {\n-        unsafe { intrinsics::arith_offset(self, count) as *mut T }\n-    }\n-\n-    /// Returns `None` if the pointer is null, or else returns a mutable\n-    /// reference to the value wrapped in `Some`.\n-    ///\n-    /// # Safety\n-    ///\n-    /// As with [`as_ref`], this is unsafe because it cannot verify the validity\n-    /// of the returned pointer, nor can it ensure that the lifetime `'a`\n-    /// returned is indeed a valid lifetime for the contained data.\n-    ///\n-    /// When calling this method, you have to ensure that *either* the pointer is NULL *or*\n-    /// all of the following is true:\n-    /// - it is properly aligned\n-    /// - it must point to an initialized instance of T; in particular, the pointer must be\n-    ///   \"dereferencable\" in the sense defined [here].\n-    ///\n-    /// This applies even if the result of this method is unused!\n-    /// (The part about being initialized is not yet fully decided, but until\n-    /// it is the only safe approach is to ensure that they are indeed initialized.)\n-    ///\n-    /// Additionally, the lifetime `'a` returned is arbitrarily chosen and does\n-    /// not necessarily reflect the actual lifetime of the data. *You* must enforce\n-    /// Rust's aliasing rules. In particular, for the duration of this lifetime,\n-    /// the memory this pointer points to must not get accessed (read or written)\n-    /// through any other pointer.\n-    ///\n-    /// [here]: crate::ptr#safety\n-    /// [`as_ref`]: #method.as_ref\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let mut s = [1, 2, 3];\n-    /// let ptr: *mut u32 = s.as_mut_ptr();\n-    /// let first_value = unsafe { ptr.as_mut().unwrap() };\n-    /// *first_value = 4;\n-    /// println!(\"{:?}\", s); // It'll print: \"[4, 2, 3]\".\n-    /// ```\n-    #[stable(feature = \"ptr_as_ref\", since = \"1.9.0\")]\n-    #[inline]\n-    pub unsafe fn as_mut<'a>(self) -> Option<&'a mut T> {\n-        if self.is_null() { None } else { Some(&mut *self) }\n-    }\n-\n-    /// Calculates the distance between two pointers. The returned value is in\n-    /// units of T: the distance in bytes is divided by `mem::size_of::<T>()`.\n-    ///\n-    /// This function is the inverse of [`offset`].\n-    ///\n-    /// [`offset`]: #method.offset-1\n-    /// [`wrapping_offset_from`]: #method.wrapping_offset_from-1\n-    ///\n-    /// # Safety\n-    ///\n-    /// If any of the following conditions are violated, the result is Undefined\n-    /// Behavior:\n-    ///\n-    /// * Both the starting and other pointer must be either in bounds or one\n-    ///   byte past the end of the same allocated object. Note that in Rust,\n-    ///   every (stack-allocated) variable is considered a separate allocated object.\n-    ///\n-    /// * The distance between the pointers, **in bytes**, cannot overflow an `isize`.\n-    ///\n-    /// * The distance between the pointers, in bytes, must be an exact multiple\n-    ///   of the size of `T`.\n-    ///\n-    /// * The distance being in bounds cannot rely on \"wrapping around\" the address space.\n-    ///\n-    /// The compiler and standard library generally try to ensure allocations\n-    /// never reach a size where an offset is a concern. For instance, `Vec`\n-    /// and `Box` ensure they never allocate more than `isize::MAX` bytes, so\n-    /// `ptr_into_vec.offset_from(vec.as_ptr())` is always safe.\n-    ///\n-    /// Most platforms fundamentally can't even construct such an allocation.\n-    /// For instance, no known 64-bit platform can ever serve a request\n-    /// for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.\n-    /// However, some 32-bit and 16-bit platforms may successfully serve a request for\n-    /// more than `isize::MAX` bytes with things like Physical Address\n-    /// Extension. As such, memory acquired directly from allocators or memory\n-    /// mapped files *may* be too large to handle with this function.\n-    ///\n-    /// Consider using [`wrapping_offset_from`] instead if these constraints are\n-    /// difficult to satisfy. The only advantage of this method is that it\n-    /// enables more aggressive compiler optimizations.\n-    ///\n-    /// # Panics\n-    ///\n-    /// This function panics if `T` is a Zero-Sized Type (\"ZST\").\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// #![feature(ptr_offset_from)]\n-    ///\n-    /// let mut a = [0; 5];\n-    /// let ptr1: *mut i32 = &mut a[1];\n-    /// let ptr2: *mut i32 = &mut a[3];\n-    /// unsafe {\n-    ///     assert_eq!(ptr2.offset_from(ptr1), 2);\n-    ///     assert_eq!(ptr1.offset_from(ptr2), -2);\n-    ///     assert_eq!(ptr1.offset(2), ptr2);\n-    ///     assert_eq!(ptr2.offset(-2), ptr1);\n-    /// }\n-    /// ```\n-    #[unstable(feature = \"ptr_offset_from\", issue = \"41079\")]\n-    #[rustc_const_unstable(feature = \"const_ptr_offset_from\", issue = \"41079\")]\n-    #[inline]\n-    pub const unsafe fn offset_from(self, origin: *const T) -> isize\n-    where\n-        T: Sized,\n-    {\n-        (self as *const T).offset_from(origin)\n-    }\n-\n-    /// Calculates the distance between two pointers. The returned value is in\n-    /// units of T: the distance in bytes is divided by `mem::size_of::<T>()`.\n-    ///\n-    /// If the address different between the two pointers is not a multiple of\n-    /// `mem::size_of::<T>()` then the result of the division is rounded towards\n-    /// zero.\n-    ///\n-    /// Though this method is safe for any two pointers, note that its result\n-    /// will be mostly useless if the two pointers aren't into the same allocated\n-    /// object, for example if they point to two different local variables.\n-    ///\n-    /// # Panics\n-    ///\n-    /// This function panics if `T` is a zero-sized type.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// #![feature(ptr_wrapping_offset_from)]\n-    ///\n-    /// let mut a = [0; 5];\n-    /// let ptr1: *mut i32 = &mut a[1];\n-    /// let ptr2: *mut i32 = &mut a[3];\n-    /// assert_eq!(ptr2.wrapping_offset_from(ptr1), 2);\n-    /// assert_eq!(ptr1.wrapping_offset_from(ptr2), -2);\n-    /// assert_eq!(ptr1.wrapping_offset(2), ptr2);\n-    /// assert_eq!(ptr2.wrapping_offset(-2), ptr1);\n-    ///\n-    /// let ptr1: *mut i32 = 3 as _;\n-    /// let ptr2: *mut i32 = 13 as _;\n-    /// assert_eq!(ptr2.wrapping_offset_from(ptr1), 2);\n-    /// ```\n-    #[unstable(feature = \"ptr_wrapping_offset_from\", issue = \"41079\")]\n-    #[inline]\n-    pub fn wrapping_offset_from(self, origin: *const T) -> isize\n-    where\n-        T: Sized,\n-    {\n-        (self as *const T).wrapping_offset_from(origin)\n-    }\n-\n-    /// Calculates the offset from a pointer (convenience for `.offset(count as isize)`).\n-    ///\n-    /// `count` is in units of T; e.g., a `count` of 3 represents a pointer\n-    /// offset of `3 * size_of::<T>()` bytes.\n-    ///\n-    /// # Safety\n-    ///\n-    /// If any of the following conditions are violated, the result is Undefined\n-    /// Behavior:\n-    ///\n-    /// * Both the starting and resulting pointer must be either in bounds or one\n-    ///   byte past the end of the same allocated object. Note that in Rust,\n-    ///   every (stack-allocated) variable is considered a separate allocated object.\n-    ///\n-    /// * The computed offset, **in bytes**, cannot overflow an `isize`.\n-    ///\n-    /// * The offset being in bounds cannot rely on \"wrapping around\" the address\n-    ///   space. That is, the infinite-precision sum must fit in a `usize`.\n-    ///\n-    /// The compiler and standard library generally tries to ensure allocations\n-    /// never reach a size where an offset is a concern. For instance, `Vec`\n-    /// and `Box` ensure they never allocate more than `isize::MAX` bytes, so\n-    /// `vec.as_ptr().add(vec.len())` is always safe.\n-    ///\n-    /// Most platforms fundamentally can't even construct such an allocation.\n-    /// For instance, no known 64-bit platform can ever serve a request\n-    /// for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.\n-    /// However, some 32-bit and 16-bit platforms may successfully serve a request for\n-    /// more than `isize::MAX` bytes with things like Physical Address\n-    /// Extension. As such, memory acquired directly from allocators or memory\n-    /// mapped files *may* be too large to handle with this function.\n-    ///\n-    /// Consider using [`wrapping_add`] instead if these constraints are\n-    /// difficult to satisfy. The only advantage of this method is that it\n-    /// enables more aggressive compiler optimizations.\n-    ///\n-    /// [`wrapping_add`]: #method.wrapping_add\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let s: &str = \"123\";\n-    /// let ptr: *const u8 = s.as_ptr();\n-    ///\n-    /// unsafe {\n-    ///     println!(\"{}\", *ptr.add(1) as char);\n-    ///     println!(\"{}\", *ptr.add(2) as char);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n-    #[inline]\n-    pub unsafe fn add(self, count: usize) -> Self\n-    where\n-        T: Sized,\n-    {\n-        self.offset(count as isize)\n-    }\n-\n-    /// Calculates the offset from a pointer (convenience for\n-    /// `.offset((count as isize).wrapping_neg())`).\n-    ///\n-    /// `count` is in units of T; e.g., a `count` of 3 represents a pointer\n-    /// offset of `3 * size_of::<T>()` bytes.\n-    ///\n-    /// # Safety\n-    ///\n-    /// If any of the following conditions are violated, the result is Undefined\n-    /// Behavior:\n-    ///\n-    /// * Both the starting and resulting pointer must be either in bounds or one\n-    ///   byte past the end of the same allocated object. Note that in Rust,\n-    ///   every (stack-allocated) variable is considered a separate allocated object.\n-    ///\n-    /// * The computed offset cannot exceed `isize::MAX` **bytes**.\n-    ///\n-    /// * The offset being in bounds cannot rely on \"wrapping around\" the address\n-    ///   space. That is, the infinite-precision sum must fit in a usize.\n-    ///\n-    /// The compiler and standard library generally tries to ensure allocations\n-    /// never reach a size where an offset is a concern. For instance, `Vec`\n-    /// and `Box` ensure they never allocate more than `isize::MAX` bytes, so\n-    /// `vec.as_ptr().add(vec.len()).sub(vec.len())` is always safe.\n-    ///\n-    /// Most platforms fundamentally can't even construct such an allocation.\n-    /// For instance, no known 64-bit platform can ever serve a request\n-    /// for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.\n-    /// However, some 32-bit and 16-bit platforms may successfully serve a request for\n-    /// more than `isize::MAX` bytes with things like Physical Address\n-    /// Extension. As such, memory acquired directly from allocators or memory\n-    /// mapped files *may* be too large to handle with this function.\n-    ///\n-    /// Consider using [`wrapping_sub`] instead if these constraints are\n-    /// difficult to satisfy. The only advantage of this method is that it\n-    /// enables more aggressive compiler optimizations.\n-    ///\n-    /// [`wrapping_sub`]: #method.wrapping_sub\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let s: &str = \"123\";\n-    ///\n-    /// unsafe {\n-    ///     let end: *const u8 = s.as_ptr().add(3);\n-    ///     println!(\"{}\", *end.sub(1) as char);\n-    ///     println!(\"{}\", *end.sub(2) as char);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n-    #[inline]\n-    pub unsafe fn sub(self, count: usize) -> Self\n-    where\n-        T: Sized,\n-    {\n-        self.offset((count as isize).wrapping_neg())\n-    }\n-\n-    /// Calculates the offset from a pointer using wrapping arithmetic.\n-    /// (convenience for `.wrapping_offset(count as isize)`)\n-    ///\n-    /// `count` is in units of T; e.g., a `count` of 3 represents a pointer\n-    /// offset of `3 * size_of::<T>()` bytes.\n-    ///\n-    /// # Safety\n-    ///\n-    /// The resulting pointer does not need to be in bounds, but it is\n-    /// potentially hazardous to dereference (which requires `unsafe`).\n-    ///\n-    /// In particular, the resulting pointer remains attached to the same allocated\n-    /// object that `self` points to. It may *not* be used to access a\n-    /// different allocated object. Note that in Rust,\n-    /// every (stack-allocated) variable is considered a separate allocated object.\n-    ///\n-    /// Compared to [`add`], this method basically delays the requirement of staying\n-    /// within the same allocated object: [`add`] is immediate Undefined Behavior when\n-    /// crossing object boundaries; `wrapping_add` produces a pointer but still leads\n-    /// to Undefined Behavior if that pointer is dereferenced. [`add`] can be optimized\n-    /// better and is thus preferrable in performance-sensitive code.\n-    ///\n-    /// If you need to cross object boundaries, cast the pointer to an integer and\n-    /// do the arithmetic there.\n-    ///\n-    /// [`add`]: #method.add\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// // Iterate using a raw pointer in increments of two elements\n-    /// let data = [1u8, 2, 3, 4, 5];\n-    /// let mut ptr: *const u8 = data.as_ptr();\n-    /// let step = 2;\n-    /// let end_rounded_up = ptr.wrapping_add(6);\n-    ///\n-    /// // This loop prints \"1, 3, 5, \"\n-    /// while ptr != end_rounded_up {\n-    ///     unsafe {\n-    ///         print!(\"{}, \", *ptr);\n-    ///     }\n-    ///     ptr = ptr.wrapping_add(step);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n-    #[inline]\n-    pub fn wrapping_add(self, count: usize) -> Self\n-    where\n-        T: Sized,\n-    {\n-        self.wrapping_offset(count as isize)\n-    }\n-\n-    /// Calculates the offset from a pointer using wrapping arithmetic.\n-    /// (convenience for `.wrapping_offset((count as isize).wrapping_sub())`)\n-    ///\n-    /// `count` is in units of T; e.g., a `count` of 3 represents a pointer\n-    /// offset of `3 * size_of::<T>()` bytes.\n-    ///\n-    /// # Safety\n-    ///\n-    /// The resulting pointer does not need to be in bounds, but it is\n-    /// potentially hazardous to dereference (which requires `unsafe`).\n-    ///\n-    /// In particular, the resulting pointer remains attached to the same allocated\n-    /// object that `self` points to. It may *not* be used to access a\n-    /// different allocated object. Note that in Rust,\n-    /// every (stack-allocated) variable is considered a separate allocated object.\n-    ///\n-    /// Compared to [`sub`], this method basically delays the requirement of staying\n-    /// within the same allocated object: [`sub`] is immediate Undefined Behavior when\n-    /// crossing object boundaries; `wrapping_sub` produces a pointer but still leads\n-    /// to Undefined Behavior if that pointer is dereferenced. [`sub`] can be optimized\n-    /// better and is thus preferrable in performance-sensitive code.\n-    ///\n-    /// If you need to cross object boundaries, cast the pointer to an integer and\n-    /// do the arithmetic there.\n-    ///\n-    /// [`sub`]: #method.sub\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// // Iterate using a raw pointer in increments of two elements (backwards)\n-    /// let data = [1u8, 2, 3, 4, 5];\n-    /// let mut ptr: *const u8 = data.as_ptr();\n-    /// let start_rounded_down = ptr.wrapping_sub(2);\n-    /// ptr = ptr.wrapping_add(4);\n-    /// let step = 2;\n-    /// // This loop prints \"5, 3, 1, \"\n-    /// while ptr != start_rounded_down {\n-    ///     unsafe {\n-    ///         print!(\"{}, \", *ptr);\n-    ///     }\n-    ///     ptr = ptr.wrapping_sub(step);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n-    #[inline]\n-    pub fn wrapping_sub(self, count: usize) -> Self\n-    where\n-        T: Sized,\n-    {\n-        self.wrapping_offset((count as isize).wrapping_neg())\n-    }\n-\n-    /// Reads the value from `self` without moving it. This leaves the\n-    /// memory in `self` unchanged.\n-    ///\n-    /// See [`ptr::read`] for safety concerns and examples.\n-    ///\n-    /// [`ptr::read`]: ./ptr/fn.read.html\n-    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n-    #[inline]\n-    pub unsafe fn read(self) -> T\n-    where\n-        T: Sized,\n-    {\n-        read(self)\n-    }\n-\n-    /// Performs a volatile read of the value from `self` without moving it. This\n-    /// leaves the memory in `self` unchanged.\n-    ///\n-    /// Volatile operations are intended to act on I/O memory, and are guaranteed\n-    /// to not be elided or reordered by the compiler across other volatile\n-    /// operations.\n-    ///\n-    /// See [`ptr::read_volatile`] for safety concerns and examples.\n-    ///\n-    /// [`ptr::read_volatile`]: ./ptr/fn.read_volatile.html\n-    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n-    #[inline]\n-    pub unsafe fn read_volatile(self) -> T\n-    where\n-        T: Sized,\n-    {\n-        read_volatile(self)\n-    }\n-\n-    /// Reads the value from `self` without moving it. This leaves the\n-    /// memory in `self` unchanged.\n-    ///\n-    /// Unlike `read`, the pointer may be unaligned.\n-    ///\n-    /// See [`ptr::read_unaligned`] for safety concerns and examples.\n-    ///\n-    /// [`ptr::read_unaligned`]: ./ptr/fn.read_unaligned.html\n-    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n-    #[inline]\n-    pub unsafe fn read_unaligned(self) -> T\n-    where\n-        T: Sized,\n-    {\n-        read_unaligned(self)\n-    }\n-\n-    /// Copies `count * size_of<T>` bytes from `self` to `dest`. The source\n-    /// and destination may overlap.\n-    ///\n-    /// NOTE: this has the *same* argument order as [`ptr::copy`].\n-    ///\n-    /// See [`ptr::copy`] for safety concerns and examples.\n-    ///\n-    /// [`ptr::copy`]: ./ptr/fn.copy.html\n-    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n-    #[inline]\n-    pub unsafe fn copy_to(self, dest: *mut T, count: usize)\n-    where\n-        T: Sized,\n-    {\n-        copy(self, dest, count)\n-    }\n-\n-    /// Copies `count * size_of<T>` bytes from `self` to `dest`. The source\n-    /// and destination may *not* overlap.\n-    ///\n-    /// NOTE: this has the *same* argument order as [`ptr::copy_nonoverlapping`].\n-    ///\n-    /// See [`ptr::copy_nonoverlapping`] for safety concerns and examples.\n-    ///\n-    /// [`ptr::copy_nonoverlapping`]: ./ptr/fn.copy_nonoverlapping.html\n-    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n-    #[inline]\n-    pub unsafe fn copy_to_nonoverlapping(self, dest: *mut T, count: usize)\n-    where\n-        T: Sized,\n-    {\n-        copy_nonoverlapping(self, dest, count)\n-    }\n-\n-    /// Copies `count * size_of<T>` bytes from `src` to `self`. The source\n-    /// and destination may overlap.\n-    ///\n-    /// NOTE: this has the *opposite* argument order of [`ptr::copy`].\n-    ///\n-    /// See [`ptr::copy`] for safety concerns and examples.\n-    ///\n-    /// [`ptr::copy`]: ./ptr/fn.copy.html\n-    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n-    #[inline]\n-    pub unsafe fn copy_from(self, src: *const T, count: usize)\n-    where\n-        T: Sized,\n-    {\n-        copy(src, self, count)\n-    }\n-\n-    /// Copies `count * size_of<T>` bytes from `src` to `self`. The source\n-    /// and destination may *not* overlap.\n-    ///\n-    /// NOTE: this has the *opposite* argument order of [`ptr::copy_nonoverlapping`].\n-    ///\n-    /// See [`ptr::copy_nonoverlapping`] for safety concerns and examples.\n-    ///\n-    /// [`ptr::copy_nonoverlapping`]: ./ptr/fn.copy_nonoverlapping.html\n-    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n-    #[inline]\n-    pub unsafe fn copy_from_nonoverlapping(self, src: *const T, count: usize)\n-    where\n-        T: Sized,\n-    {\n-        copy_nonoverlapping(src, self, count)\n-    }\n-\n-    /// Executes the destructor (if any) of the pointed-to value.\n-    ///\n-    /// See [`ptr::drop_in_place`] for safety concerns and examples.\n-    ///\n-    /// [`ptr::drop_in_place`]: ./ptr/fn.drop_in_place.html\n-    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n-    #[inline]\n-    pub unsafe fn drop_in_place(self) {\n-        drop_in_place(self)\n-    }\n-\n-    /// Overwrites a memory location with the given value without reading or\n-    /// dropping the old value.\n-    ///\n-    /// See [`ptr::write`] for safety concerns and examples.\n-    ///\n-    /// [`ptr::write`]: ./ptr/fn.write.html\n-    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n-    #[inline]\n-    pub unsafe fn write(self, val: T)\n-    where\n-        T: Sized,\n-    {\n-        write(self, val)\n-    }\n-\n-    /// Invokes memset on the specified pointer, setting `count * size_of::<T>()`\n-    /// bytes of memory starting at `self` to `val`.\n-    ///\n-    /// See [`ptr::write_bytes`] for safety concerns and examples.\n-    ///\n-    /// [`ptr::write_bytes`]: ./ptr/fn.write_bytes.html\n-    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n-    #[inline]\n-    pub unsafe fn write_bytes(self, val: u8, count: usize)\n-    where\n-        T: Sized,\n-    {\n-        write_bytes(self, val, count)\n-    }\n-\n-    /// Performs a volatile write of a memory location with the given value without\n-    /// reading or dropping the old value.\n-    ///\n-    /// Volatile operations are intended to act on I/O memory, and are guaranteed\n-    /// to not be elided or reordered by the compiler across other volatile\n-    /// operations.\n-    ///\n-    /// See [`ptr::write_volatile`] for safety concerns and examples.\n-    ///\n-    /// [`ptr::write_volatile`]: ./ptr/fn.write_volatile.html\n-    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n-    #[inline]\n-    pub unsafe fn write_volatile(self, val: T)\n-    where\n-        T: Sized,\n-    {\n-        write_volatile(self, val)\n-    }\n-\n-    /// Overwrites a memory location with the given value without reading or\n-    /// dropping the old value.\n-    ///\n-    /// Unlike `write`, the pointer may be unaligned.\n-    ///\n-    /// See [`ptr::write_unaligned`] for safety concerns and examples.\n-    ///\n-    /// [`ptr::write_unaligned`]: ./ptr/fn.write_unaligned.html\n-    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n-    #[inline]\n-    pub unsafe fn write_unaligned(self, val: T)\n-    where\n-        T: Sized,\n-    {\n-        write_unaligned(self, val)\n-    }\n-\n-    /// Replaces the value at `self` with `src`, returning the old\n-    /// value, without dropping either.\n-    ///\n-    /// See [`ptr::replace`] for safety concerns and examples.\n-    ///\n-    /// [`ptr::replace`]: ./ptr/fn.replace.html\n-    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n-    #[inline]\n-    pub unsafe fn replace(self, src: T) -> T\n-    where\n-        T: Sized,\n-    {\n-        replace(self, src)\n-    }\n-\n-    /// Swaps the values at two mutable locations of the same type, without\n-    /// deinitializing either. They may overlap, unlike `mem::swap` which is\n-    /// otherwise equivalent.\n-    ///\n-    /// See [`ptr::swap`] for safety concerns and examples.\n-    ///\n-    /// [`ptr::swap`]: ./ptr/fn.swap.html\n-    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n-    #[inline]\n-    pub unsafe fn swap(self, with: *mut T)\n-    where\n-        T: Sized,\n-    {\n-        swap(self, with)\n-    }\n-\n-    /// Computes the offset that needs to be applied to the pointer in order to make it aligned to\n-    /// `align`.\n-    ///\n-    /// If it is not possible to align the pointer, the implementation returns\n-    /// `usize::max_value()`. It is permissible for the implementation to *always*\n-    /// return `usize::max_value()`. Only your algorithm's performance can depend\n-    /// on getting a usable offset here, not its correctness.\n-    ///\n-    /// The offset is expressed in number of `T` elements, and not bytes. The value returned can be\n-    /// used with the `wrapping_add` method.\n-    ///\n-    /// There are no guarantees whatsoever that offsetting the pointer will not overflow or go\n-    /// beyond the allocation that the pointer points into. It is up to the caller to ensure that\n-    /// the returned offset is correct in all terms other than alignment.\n-    ///\n-    /// # Panics\n-    ///\n-    /// The function panics if `align` is not a power-of-two.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Accessing adjacent `u8` as `u16`\n-    ///\n-    /// ```\n-    /// # fn foo(n: usize) {\n-    /// # use std::mem::align_of;\n-    /// # unsafe {\n-    /// let x = [5u8, 6u8, 7u8, 8u8, 9u8];\n-    /// let ptr = &x[n] as *const u8;\n-    /// let offset = ptr.align_offset(align_of::<u16>());\n-    /// if offset < x.len() - n - 1 {\n-    ///     let u16_ptr = ptr.add(offset) as *const u16;\n-    ///     assert_ne!(*u16_ptr, 500);\n-    /// } else {\n-    ///     // while the pointer can be aligned via `offset`, it would point\n-    ///     // outside the allocation\n-    /// }\n-    /// # } }\n-    /// ```\n-    #[stable(feature = \"align_offset\", since = \"1.36.0\")]\n-    pub fn align_offset(self, align: usize) -> usize\n-    where\n-        T: Sized,\n-    {\n-        if !align.is_power_of_two() {\n-            panic!(\"align_offset: align is not a power-of-two\");\n-        }\n-        unsafe { align_offset(self, align) }\n-    }\n-}\n-\n /// Align pointer `p`.\n ///\n /// Calculate offset (in terms of elements of `stride` stride) that has to be applied\n@@ -2728,29 +1150,6 @@ pub(crate) unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usize {\n     usize::max_value()\n }\n \n-// Equality for pointers\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized> PartialEq for *const T {\n-    #[inline]\n-    fn eq(&self, other: &*const T) -> bool {\n-        *self == *other\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized> Eq for *const T {}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized> PartialEq for *mut T {\n-    #[inline]\n-    fn eq(&self, other: &*mut T) -> bool {\n-        *self == *other\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized> Eq for *mut T {}\n-\n /// Compares raw pointers for equality.\n ///\n /// This is the same as using the `==` operator, but less generic:\n@@ -2944,88 +1343,3 @@ fnptr_impls_args! { A, B, C, D, E, F, G, H, I }\n fnptr_impls_args! { A, B, C, D, E, F, G, H, I, J }\n fnptr_impls_args! { A, B, C, D, E, F, G, H, I, J, K }\n fnptr_impls_args! { A, B, C, D, E, F, G, H, I, J, K, L }\n-\n-// Comparison for pointers\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized> Ord for *const T {\n-    #[inline]\n-    fn cmp(&self, other: &*const T) -> Ordering {\n-        if self < other {\n-            Less\n-        } else if self == other {\n-            Equal\n-        } else {\n-            Greater\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized> PartialOrd for *const T {\n-    #[inline]\n-    fn partial_cmp(&self, other: &*const T) -> Option<Ordering> {\n-        Some(self.cmp(other))\n-    }\n-\n-    #[inline]\n-    fn lt(&self, other: &*const T) -> bool {\n-        *self < *other\n-    }\n-\n-    #[inline]\n-    fn le(&self, other: &*const T) -> bool {\n-        *self <= *other\n-    }\n-\n-    #[inline]\n-    fn gt(&self, other: &*const T) -> bool {\n-        *self > *other\n-    }\n-\n-    #[inline]\n-    fn ge(&self, other: &*const T) -> bool {\n-        *self >= *other\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized> Ord for *mut T {\n-    #[inline]\n-    fn cmp(&self, other: &*mut T) -> Ordering {\n-        if self < other {\n-            Less\n-        } else if self == other {\n-            Equal\n-        } else {\n-            Greater\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized> PartialOrd for *mut T {\n-    #[inline]\n-    fn partial_cmp(&self, other: &*mut T) -> Option<Ordering> {\n-        Some(self.cmp(other))\n-    }\n-\n-    #[inline]\n-    fn lt(&self, other: &*mut T) -> bool {\n-        *self < *other\n-    }\n-\n-    #[inline]\n-    fn le(&self, other: &*mut T) -> bool {\n-        *self <= *other\n-    }\n-\n-    #[inline]\n-    fn gt(&self, other: &*mut T) -> bool {\n-        *self > *other\n-    }\n-\n-    #[inline]\n-    fn ge(&self, other: &*mut T) -> bool {\n-        *self >= *other\n-    }\n-}"}, {"sha": "fd5decbd7eac5718aaa413f11d04e0b8c32f88ea", "filename": "src/libcore/ptr/mut_ptr.rs", "status": "added", "additions": 925, "deletions": 0, "changes": 925, "blob_url": "https://github.com/rust-lang/rust/blob/e613f9238f6db2fb4223d1df75d94168ba75d186/src%2Flibcore%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e613f9238f6db2fb4223d1df75d94168ba75d186/src%2Flibcore%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmut_ptr.rs?ref=e613f9238f6db2fb4223d1df75d94168ba75d186", "patch": "@@ -0,0 +1,925 @@\n+use crate::cmp::Ordering::{self, Less, Equal, Greater};\n+use crate::intrinsics;\n+use super::*;\n+\n+// ignore-tidy-undocumented-unsafe\n+\n+#[lang = \"mut_ptr\"]\n+impl<T: ?Sized> *mut T {\n+    /// Returns `true` if the pointer is null.\n+    ///\n+    /// Note that unsized types have many possible null pointers, as only the\n+    /// raw data pointer is considered, not their length, vtable, etc.\n+    /// Therefore, two pointers that are null may still not compare equal to\n+    /// each other.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let mut s = [1, 2, 3];\n+    /// let ptr: *mut u32 = s.as_mut_ptr();\n+    /// assert!(!ptr.is_null());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn is_null(self) -> bool {\n+        // Compare via a cast to a thin pointer, so fat pointers are only\n+        // considering their \"data\" part for null-ness.\n+        (self as *mut u8) == null_mut()\n+    }\n+\n+    /// Casts to a pointer of another type.\n+    #[stable(feature = \"ptr_cast\", since = \"1.38.0\")]\n+    #[rustc_const_stable(feature = \"const_ptr_cast\", since = \"1.38.0\")]\n+    #[inline]\n+    pub const fn cast<U>(self) -> *mut U {\n+        self as _\n+    }\n+\n+    /// Returns `None` if the pointer is null, or else returns a reference to\n+    /// the value wrapped in `Some`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// While this method and its mutable counterpart are useful for\n+    /// null-safety, it is important to note that this is still an unsafe\n+    /// operation because the returned value could be pointing to invalid\n+    /// memory.\n+    ///\n+    /// When calling this method, you have to ensure that if the pointer is\n+    /// non-NULL, then it is properly aligned, dereferencable (for the whole\n+    /// size of `T`) and points to an initialized instance of `T`. This applies\n+    /// even if the result of this method is unused!\n+    /// (The part about being initialized is not yet fully decided, but until\n+    /// it is, the only safe approach is to ensure that they are indeed initialized.)\n+    ///\n+    /// Additionally, the lifetime `'a` returned is arbitrarily chosen and does\n+    /// not necessarily reflect the actual lifetime of the data. It is up to the\n+    /// caller to ensure that for the duration of this lifetime, the memory this\n+    /// pointer points to does not get written to outside of `UnsafeCell<U>`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let ptr: *mut u8 = &mut 10u8 as *mut u8;\n+    ///\n+    /// unsafe {\n+    ///     if let Some(val_back) = ptr.as_ref() {\n+    ///         println!(\"We got back the value: {}!\", val_back);\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// # Null-unchecked version\n+    ///\n+    /// If you are sure the pointer can never be null and are looking for some kind of\n+    /// `as_ref_unchecked` that returns the `&T` instead of `Option<&T>`, know that you can\n+    /// dereference the pointer directly.\n+    ///\n+    /// ```\n+    /// let ptr: *mut u8 = &mut 10u8 as *mut u8;\n+    ///\n+    /// unsafe {\n+    ///     let val_back = &*ptr;\n+    ///     println!(\"We got back the value: {}!\", val_back);\n+    /// }\n+    /// ```\n+    #[stable(feature = \"ptr_as_ref\", since = \"1.9.0\")]\n+    #[inline]\n+    pub unsafe fn as_ref<'a>(self) -> Option<&'a T> {\n+        if self.is_null() { None } else { Some(&*self) }\n+    }\n+\n+    /// Calculates the offset from a pointer.\n+    ///\n+    /// `count` is in units of T; e.g., a `count` of 3 represents a pointer\n+    /// offset of `3 * size_of::<T>()` bytes.\n+    ///\n+    /// # Safety\n+    ///\n+    /// If any of the following conditions are violated, the result is Undefined\n+    /// Behavior:\n+    ///\n+    /// * Both the starting and resulting pointer must be either in bounds or one\n+    ///   byte past the end of the same allocated object. Note that in Rust,\n+    ///   every (stack-allocated) variable is considered a separate allocated object.\n+    ///\n+    /// * The computed offset, **in bytes**, cannot overflow an `isize`.\n+    ///\n+    /// * The offset being in bounds cannot rely on \"wrapping around\" the address\n+    ///   space. That is, the infinite-precision sum, **in bytes** must fit in a usize.\n+    ///\n+    /// The compiler and standard library generally tries to ensure allocations\n+    /// never reach a size where an offset is a concern. For instance, `Vec`\n+    /// and `Box` ensure they never allocate more than `isize::MAX` bytes, so\n+    /// `vec.as_ptr().add(vec.len())` is always safe.\n+    ///\n+    /// Most platforms fundamentally can't even construct such an allocation.\n+    /// For instance, no known 64-bit platform can ever serve a request\n+    /// for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.\n+    /// However, some 32-bit and 16-bit platforms may successfully serve a request for\n+    /// more than `isize::MAX` bytes with things like Physical Address\n+    /// Extension. As such, memory acquired directly from allocators or memory\n+    /// mapped files *may* be too large to handle with this function.\n+    ///\n+    /// Consider using [`wrapping_offset`] instead if these constraints are\n+    /// difficult to satisfy. The only advantage of this method is that it\n+    /// enables more aggressive compiler optimizations.\n+    ///\n+    /// [`wrapping_offset`]: #method.wrapping_offset\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let mut s = [1, 2, 3];\n+    /// let ptr: *mut u32 = s.as_mut_ptr();\n+    ///\n+    /// unsafe {\n+    ///     println!(\"{}\", *ptr.offset(1));\n+    ///     println!(\"{}\", *ptr.offset(2));\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub unsafe fn offset(self, count: isize) -> *mut T\n+        where\n+            T: Sized,\n+    {\n+        intrinsics::offset(self, count) as *mut T\n+    }\n+\n+    /// Calculates the offset from a pointer using wrapping arithmetic.\n+    /// `count` is in units of T; e.g., a `count` of 3 represents a pointer\n+    /// offset of `3 * size_of::<T>()` bytes.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The resulting pointer does not need to be in bounds, but it is\n+    /// potentially hazardous to dereference (which requires `unsafe`).\n+    ///\n+    /// In particular, the resulting pointer remains attached to the same allocated\n+    /// object that `self` points to. It may *not* be used to access a\n+    /// different allocated object. Note that in Rust,\n+    /// every (stack-allocated) variable is considered a separate allocated object.\n+    ///\n+    /// In other words, `x.wrapping_offset(y.wrapping_offset_from(x))` is\n+    /// *not* the same as `y`, and dereferencing it is undefined behavior\n+    /// unless `x` and `y` point into the same allocated object.\n+    ///\n+    /// Compared to [`offset`], this method basically delays the requirement of staying\n+    /// within the same allocated object: [`offset`] is immediate Undefined Behavior when\n+    /// crossing object boundaries; `wrapping_offset` produces a pointer but still leads\n+    /// to Undefined Behavior if that pointer is dereferenced. [`offset`] can be optimized\n+    /// better and is thus preferrable in performance-sensitive code.\n+    ///\n+    /// If you need to cross object boundaries, cast the pointer to an integer and\n+    /// do the arithmetic there.\n+    ///\n+    /// [`offset`]: #method.offset\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// // Iterate using a raw pointer in increments of two elements\n+    /// let mut data = [1u8, 2, 3, 4, 5];\n+    /// let mut ptr: *mut u8 = data.as_mut_ptr();\n+    /// let step = 2;\n+    /// let end_rounded_up = ptr.wrapping_offset(6);\n+    ///\n+    /// while ptr != end_rounded_up {\n+    ///     unsafe {\n+    ///         *ptr = 0;\n+    ///     }\n+    ///     ptr = ptr.wrapping_offset(step);\n+    /// }\n+    /// assert_eq!(&data, &[0, 2, 0, 4, 0]);\n+    /// ```\n+    #[stable(feature = \"ptr_wrapping_offset\", since = \"1.16.0\")]\n+    #[inline]\n+    pub fn wrapping_offset(self, count: isize) -> *mut T\n+        where\n+            T: Sized,\n+    {\n+        unsafe { intrinsics::arith_offset(self, count) as *mut T }\n+    }\n+\n+    /// Returns `None` if the pointer is null, or else returns a mutable\n+    /// reference to the value wrapped in `Some`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// As with [`as_ref`], this is unsafe because it cannot verify the validity\n+    /// of the returned pointer, nor can it ensure that the lifetime `'a`\n+    /// returned is indeed a valid lifetime for the contained data.\n+    ///\n+    /// When calling this method, you have to ensure that *either* the pointer is NULL *or*\n+    /// all of the following is true:\n+    /// - it is properly aligned\n+    /// - it must point to an initialized instance of T; in particular, the pointer must be\n+    ///   \"dereferencable\" in the sense defined [here].\n+    ///\n+    /// This applies even if the result of this method is unused!\n+    /// (The part about being initialized is not yet fully decided, but until\n+    /// it is the only safe approach is to ensure that they are indeed initialized.)\n+    ///\n+    /// Additionally, the lifetime `'a` returned is arbitrarily chosen and does\n+    /// not necessarily reflect the actual lifetime of the data. *You* must enforce\n+    /// Rust's aliasing rules. In particular, for the duration of this lifetime,\n+    /// the memory this pointer points to must not get accessed (read or written)\n+    /// through any other pointer.\n+    ///\n+    /// [here]: crate::ptr#safety\n+    /// [`as_ref`]: #method.as_ref\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let mut s = [1, 2, 3];\n+    /// let ptr: *mut u32 = s.as_mut_ptr();\n+    /// let first_value = unsafe { ptr.as_mut().unwrap() };\n+    /// *first_value = 4;\n+    /// println!(\"{:?}\", s); // It'll print: \"[4, 2, 3]\".\n+    /// ```\n+    #[stable(feature = \"ptr_as_ref\", since = \"1.9.0\")]\n+    #[inline]\n+    pub unsafe fn as_mut<'a>(self) -> Option<&'a mut T> {\n+        if self.is_null() { None } else { Some(&mut *self) }\n+    }\n+\n+    /// Calculates the distance between two pointers. The returned value is in\n+    /// units of T: the distance in bytes is divided by `mem::size_of::<T>()`.\n+    ///\n+    /// This function is the inverse of [`offset`].\n+    ///\n+    /// [`offset`]: #method.offset-1\n+    /// [`wrapping_offset_from`]: #method.wrapping_offset_from-1\n+    ///\n+    /// # Safety\n+    ///\n+    /// If any of the following conditions are violated, the result is Undefined\n+    /// Behavior:\n+    ///\n+    /// * Both the starting and other pointer must be either in bounds or one\n+    ///   byte past the end of the same allocated object. Note that in Rust,\n+    ///   every (stack-allocated) variable is considered a separate allocated object.\n+    ///\n+    /// * The distance between the pointers, **in bytes**, cannot overflow an `isize`.\n+    ///\n+    /// * The distance between the pointers, in bytes, must be an exact multiple\n+    ///   of the size of `T`.\n+    ///\n+    /// * The distance being in bounds cannot rely on \"wrapping around\" the address space.\n+    ///\n+    /// The compiler and standard library generally try to ensure allocations\n+    /// never reach a size where an offset is a concern. For instance, `Vec`\n+    /// and `Box` ensure they never allocate more than `isize::MAX` bytes, so\n+    /// `ptr_into_vec.offset_from(vec.as_ptr())` is always safe.\n+    ///\n+    /// Most platforms fundamentally can't even construct such an allocation.\n+    /// For instance, no known 64-bit platform can ever serve a request\n+    /// for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.\n+    /// However, some 32-bit and 16-bit platforms may successfully serve a request for\n+    /// more than `isize::MAX` bytes with things like Physical Address\n+    /// Extension. As such, memory acquired directly from allocators or memory\n+    /// mapped files *may* be too large to handle with this function.\n+    ///\n+    /// Consider using [`wrapping_offset_from`] instead if these constraints are\n+    /// difficult to satisfy. The only advantage of this method is that it\n+    /// enables more aggressive compiler optimizations.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function panics if `T` is a Zero-Sized Type (\"ZST\").\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(ptr_offset_from)]\n+    ///\n+    /// let mut a = [0; 5];\n+    /// let ptr1: *mut i32 = &mut a[1];\n+    /// let ptr2: *mut i32 = &mut a[3];\n+    /// unsafe {\n+    ///     assert_eq!(ptr2.offset_from(ptr1), 2);\n+    ///     assert_eq!(ptr1.offset_from(ptr2), -2);\n+    ///     assert_eq!(ptr1.offset(2), ptr2);\n+    ///     assert_eq!(ptr2.offset(-2), ptr1);\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"ptr_offset_from\", issue = \"41079\")]\n+    #[rustc_const_unstable(feature = \"const_ptr_offset_from\", issue = \"41079\")]\n+    #[inline]\n+    pub const unsafe fn offset_from(self, origin: *const T) -> isize\n+        where\n+            T: Sized,\n+    {\n+        (self as *const T).offset_from(origin)\n+    }\n+\n+    /// Calculates the distance between two pointers. The returned value is in\n+    /// units of T: the distance in bytes is divided by `mem::size_of::<T>()`.\n+    ///\n+    /// If the address different between the two pointers is not a multiple of\n+    /// `mem::size_of::<T>()` then the result of the division is rounded towards\n+    /// zero.\n+    ///\n+    /// Though this method is safe for any two pointers, note that its result\n+    /// will be mostly useless if the two pointers aren't into the same allocated\n+    /// object, for example if they point to two different local variables.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function panics if `T` is a zero-sized type.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(ptr_wrapping_offset_from)]\n+    ///\n+    /// let mut a = [0; 5];\n+    /// let ptr1: *mut i32 = &mut a[1];\n+    /// let ptr2: *mut i32 = &mut a[3];\n+    /// assert_eq!(ptr2.wrapping_offset_from(ptr1), 2);\n+    /// assert_eq!(ptr1.wrapping_offset_from(ptr2), -2);\n+    /// assert_eq!(ptr1.wrapping_offset(2), ptr2);\n+    /// assert_eq!(ptr2.wrapping_offset(-2), ptr1);\n+    ///\n+    /// let ptr1: *mut i32 = 3 as _;\n+    /// let ptr2: *mut i32 = 13 as _;\n+    /// assert_eq!(ptr2.wrapping_offset_from(ptr1), 2);\n+    /// ```\n+    #[unstable(feature = \"ptr_wrapping_offset_from\", issue = \"41079\")]\n+    #[inline]\n+    pub fn wrapping_offset_from(self, origin: *const T) -> isize\n+        where\n+            T: Sized,\n+    {\n+        (self as *const T).wrapping_offset_from(origin)\n+    }\n+\n+    /// Calculates the offset from a pointer (convenience for `.offset(count as isize)`).\n+    ///\n+    /// `count` is in units of T; e.g., a `count` of 3 represents a pointer\n+    /// offset of `3 * size_of::<T>()` bytes.\n+    ///\n+    /// # Safety\n+    ///\n+    /// If any of the following conditions are violated, the result is Undefined\n+    /// Behavior:\n+    ///\n+    /// * Both the starting and resulting pointer must be either in bounds or one\n+    ///   byte past the end of the same allocated object. Note that in Rust,\n+    ///   every (stack-allocated) variable is considered a separate allocated object.\n+    ///\n+    /// * The computed offset, **in bytes**, cannot overflow an `isize`.\n+    ///\n+    /// * The offset being in bounds cannot rely on \"wrapping around\" the address\n+    ///   space. That is, the infinite-precision sum must fit in a `usize`.\n+    ///\n+    /// The compiler and standard library generally tries to ensure allocations\n+    /// never reach a size where an offset is a concern. For instance, `Vec`\n+    /// and `Box` ensure they never allocate more than `isize::MAX` bytes, so\n+    /// `vec.as_ptr().add(vec.len())` is always safe.\n+    ///\n+    /// Most platforms fundamentally can't even construct such an allocation.\n+    /// For instance, no known 64-bit platform can ever serve a request\n+    /// for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.\n+    /// However, some 32-bit and 16-bit platforms may successfully serve a request for\n+    /// more than `isize::MAX` bytes with things like Physical Address\n+    /// Extension. As such, memory acquired directly from allocators or memory\n+    /// mapped files *may* be too large to handle with this function.\n+    ///\n+    /// Consider using [`wrapping_add`] instead if these constraints are\n+    /// difficult to satisfy. The only advantage of this method is that it\n+    /// enables more aggressive compiler optimizations.\n+    ///\n+    /// [`wrapping_add`]: #method.wrapping_add\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let s: &str = \"123\";\n+    /// let ptr: *const u8 = s.as_ptr();\n+    ///\n+    /// unsafe {\n+    ///     println!(\"{}\", *ptr.add(1) as char);\n+    ///     println!(\"{}\", *ptr.add(2) as char);\n+    /// }\n+    /// ```\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n+    #[inline]\n+    pub unsafe fn add(self, count: usize) -> Self\n+        where\n+            T: Sized,\n+    {\n+        self.offset(count as isize)\n+    }\n+\n+    /// Calculates the offset from a pointer (convenience for\n+    /// `.offset((count as isize).wrapping_neg())`).\n+    ///\n+    /// `count` is in units of T; e.g., a `count` of 3 represents a pointer\n+    /// offset of `3 * size_of::<T>()` bytes.\n+    ///\n+    /// # Safety\n+    ///\n+    /// If any of the following conditions are violated, the result is Undefined\n+    /// Behavior:\n+    ///\n+    /// * Both the starting and resulting pointer must be either in bounds or one\n+    ///   byte past the end of the same allocated object. Note that in Rust,\n+    ///   every (stack-allocated) variable is considered a separate allocated object.\n+    ///\n+    /// * The computed offset cannot exceed `isize::MAX` **bytes**.\n+    ///\n+    /// * The offset being in bounds cannot rely on \"wrapping around\" the address\n+    ///   space. That is, the infinite-precision sum must fit in a usize.\n+    ///\n+    /// The compiler and standard library generally tries to ensure allocations\n+    /// never reach a size where an offset is a concern. For instance, `Vec`\n+    /// and `Box` ensure they never allocate more than `isize::MAX` bytes, so\n+    /// `vec.as_ptr().add(vec.len()).sub(vec.len())` is always safe.\n+    ///\n+    /// Most platforms fundamentally can't even construct such an allocation.\n+    /// For instance, no known 64-bit platform can ever serve a request\n+    /// for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.\n+    /// However, some 32-bit and 16-bit platforms may successfully serve a request for\n+    /// more than `isize::MAX` bytes with things like Physical Address\n+    /// Extension. As such, memory acquired directly from allocators or memory\n+    /// mapped files *may* be too large to handle with this function.\n+    ///\n+    /// Consider using [`wrapping_sub`] instead if these constraints are\n+    /// difficult to satisfy. The only advantage of this method is that it\n+    /// enables more aggressive compiler optimizations.\n+    ///\n+    /// [`wrapping_sub`]: #method.wrapping_sub\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let s: &str = \"123\";\n+    ///\n+    /// unsafe {\n+    ///     let end: *const u8 = s.as_ptr().add(3);\n+    ///     println!(\"{}\", *end.sub(1) as char);\n+    ///     println!(\"{}\", *end.sub(2) as char);\n+    /// }\n+    /// ```\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n+    #[inline]\n+    pub unsafe fn sub(self, count: usize) -> Self\n+        where\n+            T: Sized,\n+    {\n+        self.offset((count as isize).wrapping_neg())\n+    }\n+\n+    /// Calculates the offset from a pointer using wrapping arithmetic.\n+    /// (convenience for `.wrapping_offset(count as isize)`)\n+    ///\n+    /// `count` is in units of T; e.g., a `count` of 3 represents a pointer\n+    /// offset of `3 * size_of::<T>()` bytes.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The resulting pointer does not need to be in bounds, but it is\n+    /// potentially hazardous to dereference (which requires `unsafe`).\n+    ///\n+    /// In particular, the resulting pointer remains attached to the same allocated\n+    /// object that `self` points to. It may *not* be used to access a\n+    /// different allocated object. Note that in Rust,\n+    /// every (stack-allocated) variable is considered a separate allocated object.\n+    ///\n+    /// Compared to [`add`], this method basically delays the requirement of staying\n+    /// within the same allocated object: [`add`] is immediate Undefined Behavior when\n+    /// crossing object boundaries; `wrapping_add` produces a pointer but still leads\n+    /// to Undefined Behavior if that pointer is dereferenced. [`add`] can be optimized\n+    /// better and is thus preferrable in performance-sensitive code.\n+    ///\n+    /// If you need to cross object boundaries, cast the pointer to an integer and\n+    /// do the arithmetic there.\n+    ///\n+    /// [`add`]: #method.add\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// // Iterate using a raw pointer in increments of two elements\n+    /// let data = [1u8, 2, 3, 4, 5];\n+    /// let mut ptr: *const u8 = data.as_ptr();\n+    /// let step = 2;\n+    /// let end_rounded_up = ptr.wrapping_add(6);\n+    ///\n+    /// // This loop prints \"1, 3, 5, \"\n+    /// while ptr != end_rounded_up {\n+    ///     unsafe {\n+    ///         print!(\"{}, \", *ptr);\n+    ///     }\n+    ///     ptr = ptr.wrapping_add(step);\n+    /// }\n+    /// ```\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n+    #[inline]\n+    pub fn wrapping_add(self, count: usize) -> Self\n+        where\n+            T: Sized,\n+    {\n+        self.wrapping_offset(count as isize)\n+    }\n+\n+    /// Calculates the offset from a pointer using wrapping arithmetic.\n+    /// (convenience for `.wrapping_offset((count as isize).wrapping_sub())`)\n+    ///\n+    /// `count` is in units of T; e.g., a `count` of 3 represents a pointer\n+    /// offset of `3 * size_of::<T>()` bytes.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The resulting pointer does not need to be in bounds, but it is\n+    /// potentially hazardous to dereference (which requires `unsafe`).\n+    ///\n+    /// In particular, the resulting pointer remains attached to the same allocated\n+    /// object that `self` points to. It may *not* be used to access a\n+    /// different allocated object. Note that in Rust,\n+    /// every (stack-allocated) variable is considered a separate allocated object.\n+    ///\n+    /// Compared to [`sub`], this method basically delays the requirement of staying\n+    /// within the same allocated object: [`sub`] is immediate Undefined Behavior when\n+    /// crossing object boundaries; `wrapping_sub` produces a pointer but still leads\n+    /// to Undefined Behavior if that pointer is dereferenced. [`sub`] can be optimized\n+    /// better and is thus preferrable in performance-sensitive code.\n+    ///\n+    /// If you need to cross object boundaries, cast the pointer to an integer and\n+    /// do the arithmetic there.\n+    ///\n+    /// [`sub`]: #method.sub\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// // Iterate using a raw pointer in increments of two elements (backwards)\n+    /// let data = [1u8, 2, 3, 4, 5];\n+    /// let mut ptr: *const u8 = data.as_ptr();\n+    /// let start_rounded_down = ptr.wrapping_sub(2);\n+    /// ptr = ptr.wrapping_add(4);\n+    /// let step = 2;\n+    /// // This loop prints \"5, 3, 1, \"\n+    /// while ptr != start_rounded_down {\n+    ///     unsafe {\n+    ///         print!(\"{}, \", *ptr);\n+    ///     }\n+    ///     ptr = ptr.wrapping_sub(step);\n+    /// }\n+    /// ```\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n+    #[inline]\n+    pub fn wrapping_sub(self, count: usize) -> Self\n+        where\n+            T: Sized,\n+    {\n+        self.wrapping_offset((count as isize).wrapping_neg())\n+    }\n+\n+    /// Reads the value from `self` without moving it. This leaves the\n+    /// memory in `self` unchanged.\n+    ///\n+    /// See [`ptr::read`] for safety concerns and examples.\n+    ///\n+    /// [`ptr::read`]: ./ptr/fn.read.html\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n+    #[inline]\n+    pub unsafe fn read(self) -> T\n+        where\n+            T: Sized,\n+    {\n+        read(self)\n+    }\n+\n+    /// Performs a volatile read of the value from `self` without moving it. This\n+    /// leaves the memory in `self` unchanged.\n+    ///\n+    /// Volatile operations are intended to act on I/O memory, and are guaranteed\n+    /// to not be elided or reordered by the compiler across other volatile\n+    /// operations.\n+    ///\n+    /// See [`ptr::read_volatile`] for safety concerns and examples.\n+    ///\n+    /// [`ptr::read_volatile`]: ./ptr/fn.read_volatile.html\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n+    #[inline]\n+    pub unsafe fn read_volatile(self) -> T\n+        where\n+            T: Sized,\n+    {\n+        read_volatile(self)\n+    }\n+\n+    /// Reads the value from `self` without moving it. This leaves the\n+    /// memory in `self` unchanged.\n+    ///\n+    /// Unlike `read`, the pointer may be unaligned.\n+    ///\n+    /// See [`ptr::read_unaligned`] for safety concerns and examples.\n+    ///\n+    /// [`ptr::read_unaligned`]: ./ptr/fn.read_unaligned.html\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n+    #[inline]\n+    pub unsafe fn read_unaligned(self) -> T\n+        where\n+            T: Sized,\n+    {\n+        read_unaligned(self)\n+    }\n+\n+    /// Copies `count * size_of<T>` bytes from `self` to `dest`. The source\n+    /// and destination may overlap.\n+    ///\n+    /// NOTE: this has the *same* argument order as [`ptr::copy`].\n+    ///\n+    /// See [`ptr::copy`] for safety concerns and examples.\n+    ///\n+    /// [`ptr::copy`]: ./ptr/fn.copy.html\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n+    #[inline]\n+    pub unsafe fn copy_to(self, dest: *mut T, count: usize)\n+        where\n+            T: Sized,\n+    {\n+        copy(self, dest, count)\n+    }\n+\n+    /// Copies `count * size_of<T>` bytes from `self` to `dest`. The source\n+    /// and destination may *not* overlap.\n+    ///\n+    /// NOTE: this has the *same* argument order as [`ptr::copy_nonoverlapping`].\n+    ///\n+    /// See [`ptr::copy_nonoverlapping`] for safety concerns and examples.\n+    ///\n+    /// [`ptr::copy_nonoverlapping`]: ./ptr/fn.copy_nonoverlapping.html\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n+    #[inline]\n+    pub unsafe fn copy_to_nonoverlapping(self, dest: *mut T, count: usize)\n+        where\n+            T: Sized,\n+    {\n+        copy_nonoverlapping(self, dest, count)\n+    }\n+\n+    /// Copies `count * size_of<T>` bytes from `src` to `self`. The source\n+    /// and destination may overlap.\n+    ///\n+    /// NOTE: this has the *opposite* argument order of [`ptr::copy`].\n+    ///\n+    /// See [`ptr::copy`] for safety concerns and examples.\n+    ///\n+    /// [`ptr::copy`]: ./ptr/fn.copy.html\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n+    #[inline]\n+    pub unsafe fn copy_from(self, src: *const T, count: usize)\n+        where\n+            T: Sized,\n+    {\n+        copy(src, self, count)\n+    }\n+\n+    /// Copies `count * size_of<T>` bytes from `src` to `self`. The source\n+    /// and destination may *not* overlap.\n+    ///\n+    /// NOTE: this has the *opposite* argument order of [`ptr::copy_nonoverlapping`].\n+    ///\n+    /// See [`ptr::copy_nonoverlapping`] for safety concerns and examples.\n+    ///\n+    /// [`ptr::copy_nonoverlapping`]: ./ptr/fn.copy_nonoverlapping.html\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n+    #[inline]\n+    pub unsafe fn copy_from_nonoverlapping(self, src: *const T, count: usize)\n+        where\n+            T: Sized,\n+    {\n+        copy_nonoverlapping(src, self, count)\n+    }\n+\n+    /// Executes the destructor (if any) of the pointed-to value.\n+    ///\n+    /// See [`ptr::drop_in_place`] for safety concerns and examples.\n+    ///\n+    /// [`ptr::drop_in_place`]: ./ptr/fn.drop_in_place.html\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n+    #[inline]\n+    pub unsafe fn drop_in_place(self) {\n+        drop_in_place(self)\n+    }\n+\n+    /// Overwrites a memory location with the given value without reading or\n+    /// dropping the old value.\n+    ///\n+    /// See [`ptr::write`] for safety concerns and examples.\n+    ///\n+    /// [`ptr::write`]: ./ptr/fn.write.html\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n+    #[inline]\n+    pub unsafe fn write(self, val: T)\n+        where\n+            T: Sized,\n+    {\n+        write(self, val)\n+    }\n+\n+    /// Invokes memset on the specified pointer, setting `count * size_of::<T>()`\n+    /// bytes of memory starting at `self` to `val`.\n+    ///\n+    /// See [`ptr::write_bytes`] for safety concerns and examples.\n+    ///\n+    /// [`ptr::write_bytes`]: ./ptr/fn.write_bytes.html\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n+    #[inline]\n+    pub unsafe fn write_bytes(self, val: u8, count: usize)\n+        where\n+            T: Sized,\n+    {\n+        write_bytes(self, val, count)\n+    }\n+\n+    /// Performs a volatile write of a memory location with the given value without\n+    /// reading or dropping the old value.\n+    ///\n+    /// Volatile operations are intended to act on I/O memory, and are guaranteed\n+    /// to not be elided or reordered by the compiler across other volatile\n+    /// operations.\n+    ///\n+    /// See [`ptr::write_volatile`] for safety concerns and examples.\n+    ///\n+    /// [`ptr::write_volatile`]: ./ptr/fn.write_volatile.html\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n+    #[inline]\n+    pub unsafe fn write_volatile(self, val: T)\n+        where\n+            T: Sized,\n+    {\n+        write_volatile(self, val)\n+    }\n+\n+    /// Overwrites a memory location with the given value without reading or\n+    /// dropping the old value.\n+    ///\n+    /// Unlike `write`, the pointer may be unaligned.\n+    ///\n+    /// See [`ptr::write_unaligned`] for safety concerns and examples.\n+    ///\n+    /// [`ptr::write_unaligned`]: ./ptr/fn.write_unaligned.html\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n+    #[inline]\n+    pub unsafe fn write_unaligned(self, val: T)\n+        where\n+            T: Sized,\n+    {\n+        write_unaligned(self, val)\n+    }\n+\n+    /// Replaces the value at `self` with `src`, returning the old\n+    /// value, without dropping either.\n+    ///\n+    /// See [`ptr::replace`] for safety concerns and examples.\n+    ///\n+    /// [`ptr::replace`]: ./ptr/fn.replace.html\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n+    #[inline]\n+    pub unsafe fn replace(self, src: T) -> T\n+        where\n+            T: Sized,\n+    {\n+        replace(self, src)\n+    }\n+\n+    /// Swaps the values at two mutable locations of the same type, without\n+    /// deinitializing either. They may overlap, unlike `mem::swap` which is\n+    /// otherwise equivalent.\n+    ///\n+    /// See [`ptr::swap`] for safety concerns and examples.\n+    ///\n+    /// [`ptr::swap`]: ./ptr/fn.swap.html\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n+    #[inline]\n+    pub unsafe fn swap(self, with: *mut T)\n+        where\n+            T: Sized,\n+    {\n+        swap(self, with)\n+    }\n+\n+    /// Computes the offset that needs to be applied to the pointer in order to make it aligned to\n+    /// `align`.\n+    ///\n+    /// If it is not possible to align the pointer, the implementation returns\n+    /// `usize::max_value()`. It is permissible for the implementation to *always*\n+    /// return `usize::max_value()`. Only your algorithm's performance can depend\n+    /// on getting a usable offset here, not its correctness.\n+    ///\n+    /// The offset is expressed in number of `T` elements, and not bytes. The value returned can be\n+    /// used with the `wrapping_add` method.\n+    ///\n+    /// There are no guarantees whatsoever that offsetting the pointer will not overflow or go\n+    /// beyond the allocation that the pointer points into. It is up to the caller to ensure that\n+    /// the returned offset is correct in all terms other than alignment.\n+    ///\n+    /// # Panics\n+    ///\n+    /// The function panics if `align` is not a power-of-two.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Accessing adjacent `u8` as `u16`\n+    ///\n+    /// ```\n+    /// # fn foo(n: usize) {\n+    /// # use std::mem::align_of;\n+    /// # unsafe {\n+    /// let x = [5u8, 6u8, 7u8, 8u8, 9u8];\n+    /// let ptr = &x[n] as *const u8;\n+    /// let offset = ptr.align_offset(align_of::<u16>());\n+    /// if offset < x.len() - n - 1 {\n+    ///     let u16_ptr = ptr.add(offset) as *const u16;\n+    ///     assert_ne!(*u16_ptr, 500);\n+    /// } else {\n+    ///     // while the pointer can be aligned via `offset`, it would point\n+    ///     // outside the allocation\n+    /// }\n+    /// # } }\n+    /// ```\n+    #[stable(feature = \"align_offset\", since = \"1.36.0\")]\n+    pub fn align_offset(self, align: usize) -> usize\n+        where\n+            T: Sized,\n+    {\n+        if !align.is_power_of_two() {\n+            panic!(\"align_offset: align is not a power-of-two\");\n+        }\n+        unsafe { align_offset(self, align) }\n+    }\n+}\n+\n+// Equality for pointers\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: ?Sized> PartialEq for *mut T {\n+    #[inline]\n+    fn eq(&self, other: &*mut T) -> bool { *self == *other }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: ?Sized> Eq for *mut T {}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: ?Sized> Ord for *mut T {\n+    #[inline]\n+    fn cmp(&self, other: &*mut T) -> Ordering {\n+        if self < other {\n+            Less\n+        } else if self == other {\n+            Equal\n+        } else {\n+            Greater\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: ?Sized> PartialOrd for *mut T {\n+    #[inline]\n+    fn partial_cmp(&self, other: &*mut T) -> Option<Ordering> {\n+        Some(self.cmp(other))\n+    }\n+\n+    #[inline]\n+    fn lt(&self, other: &*mut T) -> bool { *self < *other }\n+\n+    #[inline]\n+    fn le(&self, other: &*mut T) -> bool { *self <= *other }\n+\n+    #[inline]\n+    fn gt(&self, other: &*mut T) -> bool { *self > *other }\n+\n+    #[inline]\n+    fn ge(&self, other: &*mut T) -> bool { *self >= *other }\n+}"}, {"sha": "ac08b2f2427c796db2d5468f1345b599e56decce", "filename": "src/test/ui/consts/offset_from_ub.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e613f9238f6db2fb4223d1df75d94168ba75d186/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e613f9238f6db2fb4223d1df75d94168ba75d186/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.stderr?ref=e613f9238f6db2fb4223d1df75d94168ba75d186", "patch": "@@ -1,11 +1,11 @@\n error: any use of this value will cause an error\n-  --> $SRC_DIR/libcore/ptr/mod.rs:LL:COL\n+  --> $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n    |\n LL |           intrinsics::ptr_offset_from(self, origin)\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |           |\n    |           ptr_offset_from cannot compute offset of pointers into different allocations.\n-   |           inside call to `std::ptr::<impl *const Struct>::offset_from` at $DIR/offset_from_ub.rs:19:27\n+   |           inside call to `std::ptr::const_ptr::<impl *const Struct>::offset_from` at $DIR/offset_from_ub.rs:19:27\n    | \n   ::: $DIR/offset_from_ub.rs:13:1\n    |\n@@ -21,13 +21,13 @@ LL | | };\n    = note: `#[deny(const_err)]` on by default\n \n error: any use of this value will cause an error\n-  --> $SRC_DIR/libcore/ptr/mod.rs:LL:COL\n+  --> $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n    |\n LL |           intrinsics::ptr_offset_from(self, origin)\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |           |\n    |           a memory access tried to interpret some bytes as a pointer\n-   |           inside call to `std::ptr::<impl *const u8>::offset_from` at $DIR/offset_from_ub.rs:25:14\n+   |           inside call to `std::ptr::const_ptr::<impl *const u8>::offset_from` at $DIR/offset_from_ub.rs:25:14\n    | \n   ::: $DIR/offset_from_ub.rs:23:1\n    |\n@@ -38,13 +38,13 @@ LL | | };\n    | |__-\n \n error: any use of this value will cause an error\n-  --> $SRC_DIR/libcore/ptr/mod.rs:LL:COL\n+  --> $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n    |\n LL |           intrinsics::ptr_offset_from(self, origin)\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |           |\n    |           exact_div: 1 cannot be divided by 2 without remainder\n-   |           inside call to `std::ptr::<impl *const u16>::offset_from` at $DIR/offset_from_ub.rs:33:14\n+   |           inside call to `std::ptr::const_ptr::<impl *const u16>::offset_from` at $DIR/offset_from_ub.rs:33:14\n    | \n   ::: $DIR/offset_from_ub.rs:28:1\n    |\n@@ -58,13 +58,13 @@ LL | | };\n    | |__-\n \n error: any use of this value will cause an error\n-  --> $SRC_DIR/libcore/ptr/mod.rs:LL:COL\n+  --> $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n    |\n LL |           intrinsics::ptr_offset_from(self, origin)\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |           |\n    |           invalid use of NULL pointer\n-   |           inside call to `std::ptr::<impl *const u8>::offset_from` at $DIR/offset_from_ub.rs:39:14\n+   |           inside call to `std::ptr::const_ptr::<impl *const u8>::offset_from` at $DIR/offset_from_ub.rs:39:14\n    | \n   ::: $DIR/offset_from_ub.rs:36:1\n    |\n@@ -76,13 +76,13 @@ LL | | };\n    | |__-\n \n error: any use of this value will cause an error\n-  --> $SRC_DIR/libcore/ptr/mod.rs:LL:COL\n+  --> $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n    |\n LL |           intrinsics::ptr_offset_from(self, origin)\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |           |\n    |           a memory access tried to interpret some bytes as a pointer\n-   |           inside call to `std::ptr::<impl *const u8>::offset_from` at $DIR/offset_from_ub.rs:46:14\n+   |           inside call to `std::ptr::const_ptr::<impl *const u8>::offset_from` at $DIR/offset_from_ub.rs:46:14\n    | \n   ::: $DIR/offset_from_ub.rs:42:1\n    |"}]}