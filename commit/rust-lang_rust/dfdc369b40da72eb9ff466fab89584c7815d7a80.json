{"sha": "dfdc369b40da72eb9ff466fab89584c7815d7a80", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmZGMzNjliNDBkYTcyZWI5ZmY0NjZmYWI4OTU4NGM3ODE1ZDdhODA=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-10-01T18:24:05Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-10-03T18:55:19Z"}, "message": "review comments", "tree": {"sha": "2bf92b426d8ee7edc4b58c6ece5115ae819fae58", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2bf92b426d8ee7edc4b58c6ece5115ae819fae58"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dfdc369b40da72eb9ff466fab89584c7815d7a80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dfdc369b40da72eb9ff466fab89584c7815d7a80", "html_url": "https://github.com/rust-lang/rust/commit/dfdc369b40da72eb9ff466fab89584c7815d7a80", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dfdc369b40da72eb9ff466fab89584c7815d7a80/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d27683a39f5924205d73e0015b8c25c97aadaa63", "url": "https://api.github.com/repos/rust-lang/rust/commits/d27683a39f5924205d73e0015b8c25c97aadaa63", "html_url": "https://github.com/rust-lang/rust/commit/d27683a39f5924205d73e0015b8c25c97aadaa63"}], "stats": {"total": 118, "additions": 70, "deletions": 48}, "files": [{"sha": "14c5dc6132cf87489b7dd8ed039d566b0da99af7", "filename": "src/libsyntax/parse/diagnostics.rs", "status": "modified", "additions": 43, "deletions": 36, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/dfdc369b40da72eb9ff466fab89584c7815d7a80/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfdc369b40da72eb9ff466fab89584c7815d7a80/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs?ref=dfdc369b40da72eb9ff466fab89584c7815d7a80", "patch": "@@ -17,6 +17,8 @@ use syntax_pos::{Span, DUMMY_SP, MultiSpan, SpanSnippetError};\n use log::{debug, trace};\n use std::mem;\n \n+const TURBOFISH: &'static str = \"use the \\\"turbofish\\\" `::<...>` instead of `<...>` to specify \\\n+                                 type arguments\";\n /// Creates a placeholder argument.\n crate fn dummy_arg(ident: Ident) -> Param {\n     let pat = P(Pat {\n@@ -544,10 +546,20 @@ impl<'a> Parser<'a> {\n \n     /// Produces an error if comparison operators are chained (RFC #558).\n     /// We only need to check the LHS, not the RHS, because all comparison ops have same\n-    /// precedence and are left-associative.\n+    /// precedence (see `fn precedence`) and are left-associative (see `fn fixity`).\n     ///\n     /// This can also be hit if someone incorrectly writes `foo<bar>()` when they should have used\n-    /// the turbofish syntax. We attempt some heuristic recovery if that is the case.\n+    /// the turbofish (`foo::<bar>()`) syntax. We attempt some heuristic recovery if that is the\n+    /// case.\n+    ///\n+    /// Keep in mind that given that `outer_op.is_comparison()` holds and comparison ops are left\n+    /// associative we can infer that we have:\n+    ///\n+    ///           outer_op\n+    ///           /   \\\n+    ///     inner_op   r2\n+    ///        /  \\\n+    ///     l1    r1\n     crate fn check_no_chained_comparison(\n         &mut self,\n         lhs: &Expr,\n@@ -560,30 +572,36 @@ impl<'a> Parser<'a> {\n         );\n         match lhs.kind {\n             ExprKind::Binary(op, _, _) if op.node.is_comparison() => {\n-\n                 // Respan to include both operators.\n                 let op_span = op.span.to(self.prev_span);\n                 let mut err = self.struct_span_err(\n                     op_span,\n                     \"chained comparison operators require parentheses\",\n                 );\n+\n+                let suggest = |err: &mut DiagnosticBuilder<'_>| {\n+                    err.span_suggestion(\n+                        op_span.shrink_to_lo(),\n+                        TURBOFISH,\n+                        \"::\".to_string(),\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                };\n+\n                 if op.node == BinOpKind::Lt &&\n                     *outer_op == AssocOp::Less ||  // Include `<` to provide this recommendation\n                     *outer_op == AssocOp::Greater  // even in a case like the following:\n                 {                                  //     Foo<Bar<Baz<Qux, ()>>>\n-                    let msg = \"use `::<...>` instead of `<...>` if you meant to specify type \\\n-                               arguments\";\n                     if *outer_op == AssocOp::Less {\n                         let snapshot = self.clone();\n                         self.bump();\n-                        // So far we have parsed `foo<bar<`, consume the rest of the type params\n-                        let modifiers = vec![\n+                        // So far we have parsed `foo<bar<`, consume the rest of the type args.\n+                        let modifiers = [\n                             (token::Lt, 1),\n                             (token::Gt, -1),\n                             (token::BinOp(token::Shr), -2),\n                         ];\n-                        let early_return = vec![token::Eof];\n-                        self.consume_tts(1, &modifiers[..], &early_return[..]);\n+                        self.consume_tts(1, &modifiers[..], &[]);\n \n                         if !&[\n                             token::OpenDelim(token::Paren),\n@@ -597,16 +615,11 @@ impl<'a> Parser<'a> {\n                     if token::ModSep == self.token.kind {\n                         // We have some certainty that this was a bad turbofish at this point.\n                         // `foo< bar >::`\n-                        err.span_suggestion(\n-                            op_span.shrink_to_lo(),\n-                            msg,\n-                            \"::\".to_string(),\n-                            Applicability::MaybeIncorrect,\n-                        );\n+                        suggest(&mut err);\n \n                         let snapshot = self.clone();\n-\n                         self.bump(); // `::`\n+\n                         // Consume the rest of the likely `foo<bar>::new()` or return at `foo<bar>`.\n                         match self.parse_expr() {\n                             Ok(_) => {\n@@ -621,8 +634,8 @@ impl<'a> Parser<'a> {\n                                     ThinVec::new(),\n                                 )));\n                             }\n-                            Err(mut err) => {\n-                                err.cancel();\n+                            Err(mut expr_err) => {\n+                                expr_err.cancel();\n                                 // Not entirely sure now, but we bubble the error up with the\n                                 // suggestion.\n                                 mem::replace(self, snapshot);\n@@ -632,45 +645,39 @@ impl<'a> Parser<'a> {\n                     } else if token::OpenDelim(token::Paren) == self.token.kind {\n                         // We have high certainty that this was a bad turbofish at this point.\n                         // `foo< bar >(`\n-                        err.span_suggestion(\n-                            op_span.shrink_to_lo(),\n-                            msg,\n-                            \"::\".to_string(),\n-                            Applicability::MaybeIncorrect,\n-                        );\n+                        suggest(&mut err);\n \n                         let snapshot = self.clone();\n                         self.bump(); // `(`\n \n                         // Consume the fn call arguments.\n-                        let modifiers = vec![\n+                        let modifiers = [\n                             (token::OpenDelim(token::Paren), 1),\n                             (token::CloseDelim(token::Paren), -1),\n                         ];\n-                        let early_return = vec![token::Eof];\n-                        self.consume_tts(1, &modifiers[..], &early_return[..]);\n+                        self.consume_tts(1, &modifiers[..], &[]);\n \n-                        if self.token.kind == token::Eof {\n+                        return if self.token.kind == token::Eof {\n                             // Not entirely sure now, but we bubble the error up with the\n                             // suggestion.\n                             mem::replace(self, snapshot);\n-                            return Err(err);\n+                            Err(err)\n                         } else {\n                             // 99% certain that the suggestion is correct, continue parsing.\n                             err.emit();\n                             // FIXME: actually check that the two expressions in the binop are\n                             // paths and resynthesize new fn call expression instead of using\n                             // `ExprKind::Err` placeholder.\n-                            return Ok(Some(self.mk_expr(\n+                            Ok(Some(self.mk_expr(\n                                 lhs.span.to(self.prev_span),\n                                 ExprKind::Err,\n                                 ThinVec::new(),\n-                            )));\n+                            )))\n                         }\n                     } else {\n                         // All we know is that this is `foo < bar >` and *nothing* else. Try to\n                         // be helpful, but don't attempt to recover.\n-                        err.help(msg);\n+                        err.help(TURBOFISH);\n                         err.help(\"or use `(...)` if you meant to specify fn arguments\");\n                         // These cases cause too many knock-down errors, bail out (#61329).\n                     }\n@@ -1459,15 +1466,15 @@ impl<'a> Parser<'a> {\n \n     fn consume_tts(\n         &mut self,\n-        mut acc: i64,\n-        modifier: &[(token::TokenKind, i64)], // Not using FxHasMap and FxHashSet due to\n+        mut acc: i64, // `i64` because malformed code can have more closing delims than opening.\n+        modifier: &[(token::TokenKind, i64)], // Not using `FxHashMap` and `FxHashSet` due to\n         early_return: &[token::TokenKind],    // `token::TokenKind: !Eq + !Hash`.\n     ) {\n         while acc > 0 {\n-            if let Some((_, val)) = modifier.iter().filter(|(t, _)| *t == self.token.kind).next() {\n+            if let Some((_, val)) = modifier.iter().find(|(t, _)| *t == self.token.kind) {\n                 acc += *val;\n             }\n-            if early_return.contains(&self.token.kind) {\n+            if self.token.kind == token::Eof || early_return.contains(&self.token.kind) {\n                 break;\n             }\n             self.bump();"}, {"sha": "9757f8258c1316f882d692c5463957c7e3f72211", "filename": "src/test/ui/did_you_mean/issue-40396.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dfdc369b40da72eb9ff466fab89584c7815d7a80/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40396.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dfdc369b40da72eb9ff466fab89584c7815d7a80/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40396.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40396.stderr?ref=dfdc369b40da72eb9ff466fab89584c7815d7a80", "patch": "@@ -3,7 +3,7 @@ error: chained comparison operators require parentheses\n    |\n LL |     (0..13).collect<Vec<i32>>();\n    |                    ^^^^^\n-help: use `::<...>` instead of `<...>` if you meant to specify type arguments\n+help: use the \"turbofish\" `::<...>` instead of `<...>` to specify type arguments\n    |\n LL |     (0..13).collect::<Vec<i32>>();\n    |                    ^^\n@@ -13,7 +13,7 @@ error: chained comparison operators require parentheses\n    |\n LL |     Vec<i32>::new();\n    |        ^^^^^\n-help: use `::<...>` instead of `<...>` if you meant to specify type arguments\n+help: use the \"turbofish\" `::<...>` instead of `<...>` to specify type arguments\n    |\n LL |     Vec::<i32>::new();\n    |        ^^\n@@ -23,7 +23,7 @@ error: chained comparison operators require parentheses\n    |\n LL |     (0..13).collect<Vec<i32>();\n    |                    ^^^^^\n-help: use `::<...>` instead of `<...>` if you meant to specify type arguments\n+help: use the \"turbofish\" `::<...>` instead of `<...>` to specify type arguments\n    |\n LL |     (0..13).collect::<Vec<i32>();\n    |                    ^^"}, {"sha": "f3bfe2d482f59b0588d990b69349a82bc3227992", "filename": "src/test/ui/parser/require-parens-for-chained-comparison.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/dfdc369b40da72eb9ff466fab89584c7815d7a80/src%2Ftest%2Fui%2Fparser%2Frequire-parens-for-chained-comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfdc369b40da72eb9ff466fab89584c7815d7a80/src%2Ftest%2Fui%2Fparser%2Frequire-parens-for-chained-comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frequire-parens-for-chained-comparison.rs?ref=dfdc369b40da72eb9ff466fab89584c7815d7a80", "patch": "@@ -3,18 +3,24 @@ struct X;\n \n fn main() {\n     false == false == false;\n-    //~^ ERROR: chained comparison operators require parentheses\n+    //~^ ERROR chained comparison operators require parentheses\n \n     false == 0 < 2;\n-    //~^ ERROR: chained comparison operators require parentheses\n-    //~| ERROR: mismatched types\n-    //~| ERROR: mismatched types\n+    //~^ ERROR chained comparison operators require parentheses\n+    //~| ERROR mismatched types\n+    //~| ERROR mismatched types\n \n     f<X>();\n     //~^ ERROR chained comparison operators require parentheses\n-    //~| HELP: use `::<...>` instead of `<...>`\n+    //~| HELP use the \"turbofish\" `::<...>` instead of `<...>` to specify type arguments\n \n     f<Result<Option<X>, Option<Option<X>>>(1, 2);\n     //~^ ERROR chained comparison operators require parentheses\n-    //~| HELP: use `::<...>` instead of `<...>`\n+    //~| HELP use the \"turbofish\" `::<...>` instead of `<...>` to specify type arguments\n+\n+    use std::convert::identity;\n+    let _ = identity<u8>;\n+    //~^ ERROR chained comparison operators require parentheses\n+    //~| HELP use the \"turbofish\" `::<...>` instead of `<...>` to specify type arguments\n+    //~| HELP or use `(...)` if you meant to specify fn arguments\n }"}, {"sha": "4b108e1db87b7de0a79162067f3706416295c942", "filename": "src/test/ui/parser/require-parens-for-chained-comparison.stderr", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/dfdc369b40da72eb9ff466fab89584c7815d7a80/src%2Ftest%2Fui%2Fparser%2Frequire-parens-for-chained-comparison.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dfdc369b40da72eb9ff466fab89584c7815d7a80/src%2Ftest%2Fui%2Fparser%2Frequire-parens-for-chained-comparison.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frequire-parens-for-chained-comparison.stderr?ref=dfdc369b40da72eb9ff466fab89584c7815d7a80", "patch": "@@ -15,7 +15,7 @@ error: chained comparison operators require parentheses\n    |\n LL |     f<X>();\n    |      ^^^\n-help: use `::<...>` instead of `<...>` if you meant to specify type arguments\n+help: use the \"turbofish\" `::<...>` instead of `<...>` to specify type arguments\n    |\n LL |     f::<X>();\n    |      ^^\n@@ -25,11 +25,20 @@ error: chained comparison operators require parentheses\n    |\n LL |     f<Result<Option<X>, Option<Option<X>>>(1, 2);\n    |      ^^^^^^^^\n-help: use `::<...>` instead of `<...>` if you meant to specify type arguments\n+help: use the \"turbofish\" `::<...>` instead of `<...>` to specify type arguments\n    |\n LL |     f::<Result<Option<X>, Option<Option<X>>>(1, 2);\n    |      ^^\n \n+error: chained comparison operators require parentheses\n+  --> $DIR/require-parens-for-chained-comparison.rs:22:21\n+   |\n+LL |     let _ = identity<u8>;\n+   |                     ^^^^\n+   |\n+   = help: use the \"turbofish\" `::<...>` instead of `<...>` to specify type arguments\n+   = help: or use `(...)` if you meant to specify fn arguments\n+\n error[E0308]: mismatched types\n   --> $DIR/require-parens-for-chained-comparison.rs:8:14\n    |\n@@ -48,6 +57,6 @@ LL |     false == 0 < 2;\n    = note: expected type `bool`\n               found type `{integer}`\n \n-error: aborting due to 6 previous errors\n+error: aborting due to 7 previous errors\n \n For more information about this error, try `rustc --explain E0308`."}]}