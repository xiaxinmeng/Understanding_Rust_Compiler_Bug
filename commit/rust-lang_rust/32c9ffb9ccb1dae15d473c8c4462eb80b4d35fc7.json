{"sha": "32c9ffb9ccb1dae15d473c8c4462eb80b4d35fc7", "node_id": "C_kwDOAAsO6NoAKDMyYzlmZmI5Y2NiMWRhZTE1ZDQ3M2M4YzQ0NjJlYjgwYjRkMzVmYzc", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-07-04T22:25:47Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-07-08T23:02:49Z"}, "message": "Clarify args terminology.\n\nThe deriving code has inconsistent terminology to describe args.\n\nIn some places it distinguishes between:\n- the `&self` arg (if present), versus\n- all other args.\n\nIn other places it distinguishes between:\n- the `&self` arg (if present) and any other arguments with the same\n  type (in practice there is at most one, e.g. in `PartialEq::eq`),\n  versus\n- all other args.\n\nThe terms \"self_args\" and \"nonself_args\" are sometimes used for the\nformer distinction, and sometimes for the latter. \"args\" is also\nsometimes used for \"all other args\".\n\nThis commit makes the code consistently uses \"self_args\"/\"nonself_args\"\nfor the former and \"selflike_args\"/\"nonselflike_args\" for the latter.\nThis change makes the code easier to read.\n\nThe commit also adds a panic on an impossible path (the `Self_` case) in\n`extract_arg_details`.", "tree": {"sha": "c7837d6da26f1dc5d6b177ffec4746ef6bbe1884", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c7837d6da26f1dc5d6b177ffec4746ef6bbe1884"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/32c9ffb9ccb1dae15d473c8c4462eb80b4d35fc7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/32c9ffb9ccb1dae15d473c8c4462eb80b4d35fc7", "html_url": "https://github.com/rust-lang/rust/commit/32c9ffb9ccb1dae15d473c8c4462eb80b4d35fc7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/32c9ffb9ccb1dae15d473c8c4462eb80b4d35fc7/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "052495d0017e2b18b781bcf0469a048e5051f5c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/052495d0017e2b18b781bcf0469a048e5051f5c0", "html_url": "https://github.com/rust-lang/rust/commit/052495d0017e2b18b781bcf0469a048e5051f5c0"}], "stats": {"total": 256, "additions": 147, "deletions": 109}, "files": [{"sha": "a67d16d6b2f206c3f859b4d13e21327455897590", "filename": "compiler/rustc_builtin_macros/src/deriving/clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32c9ffb9ccb1dae15d473c8c4462eb80b4d35fc7/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32c9ffb9ccb1dae15d473c8c4462eb80b4d35fc7/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs?ref=32c9ffb9ccb1dae15d473c8c4462eb80b4d35fc7", "patch": "@@ -80,7 +80,7 @@ pub fn expand_deriving_clone(\n             name: sym::clone,\n             generics: Bounds::empty(),\n             explicit_self: true,\n-            args: Vec::new(),\n+            nonself_args: Vec::new(),\n             ret_ty: Self_,\n             attributes: attrs,\n             unify_fieldless_variants: false,"}, {"sha": "4e798bf6acb108ea90b37332ae105f77d6c5357a", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/eq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32c9ffb9ccb1dae15d473c8c4462eb80b4d35fc7/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32c9ffb9ccb1dae15d473c8c4462eb80b4d35fc7/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs?ref=32c9ffb9ccb1dae15d473c8c4462eb80b4d35fc7", "patch": "@@ -32,7 +32,7 @@ pub fn expand_deriving_eq(\n             name: sym::assert_receiver_is_total_eq,\n             generics: Bounds::empty(),\n             explicit_self: true,\n-            args: vec![],\n+            nonself_args: vec![],\n             ret_ty: Unit,\n             attributes: attrs,\n             unify_fieldless_variants: true,"}, {"sha": "d80a2293e6674b0c2c0d36dd24488a7098170f53", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/ord.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32c9ffb9ccb1dae15d473c8c4462eb80b4d35fc7/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32c9ffb9ccb1dae15d473c8c4462eb80b4d35fc7/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs?ref=32c9ffb9ccb1dae15d473c8c4462eb80b4d35fc7", "patch": "@@ -28,7 +28,7 @@ pub fn expand_deriving_ord(\n             name: sym::cmp,\n             generics: Bounds::empty(),\n             explicit_self: true,\n-            args: vec![(self_ref(), sym::other)],\n+            nonself_args: vec![(self_ref(), sym::other)],\n             ret_ty: Path(path_std!(cmp::Ordering)),\n             attributes: attrs,\n             unify_fieldless_variants: true,"}, {"sha": "a9a0634836b839132f58fefa26b3ab54a34f5125", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_eq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32c9ffb9ccb1dae15d473c8c4462eb80b4d35fc7/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32c9ffb9ccb1dae15d473c8c4462eb80b4d35fc7/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=32c9ffb9ccb1dae15d473c8c4462eb80b4d35fc7", "patch": "@@ -69,7 +69,7 @@ pub fn expand_deriving_partial_eq(\n                 name: $name,\n                 generics: Bounds::empty(),\n                 explicit_self: true,\n-                args: vec![(self_ref(), sym::other)],\n+                nonself_args: vec![(self_ref(), sym::other)],\n                 ret_ty: Path(path_local!(bool)),\n                 attributes: attrs,\n                 unify_fieldless_variants: true,"}, {"sha": "c8c9a6fbb5793769bd81fa32368fa8eb1294a010", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32c9ffb9ccb1dae15d473c8c4462eb80b4d35fc7/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32c9ffb9ccb1dae15d473c8c4462eb80b4d35fc7/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=32c9ffb9ccb1dae15d473c8c4462eb80b4d35fc7", "patch": "@@ -26,7 +26,7 @@ pub fn expand_deriving_partial_ord(\n         name: sym::partial_cmp,\n         generics: Bounds::empty(),\n         explicit_self: true,\n-        args: vec![(self_ref(), sym::other)],\n+        nonself_args: vec![(self_ref(), sym::other)],\n         ret_ty,\n         attributes: attrs,\n         unify_fieldless_variants: true,"}, {"sha": "71f77ea8b6a397f858eff9cc39249868fd2b4dfc", "filename": "compiler/rustc_builtin_macros/src/deriving/debug.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32c9ffb9ccb1dae15d473c8c4462eb80b4d35fc7/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32c9ffb9ccb1dae15d473c8c4462eb80b4d35fc7/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs?ref=32c9ffb9ccb1dae15d473c8c4462eb80b4d35fc7", "patch": "@@ -28,7 +28,7 @@ pub fn expand_deriving_debug(\n             name: sym::fmt,\n             generics: Bounds::empty(),\n             explicit_self: true,\n-            args: vec![(fmtr, sym::f)],\n+            nonself_args: vec![(fmtr, sym::f)],\n             ret_ty: Path(path_std!(fmt::Result)),\n             attributes: Vec::new(),\n             unify_fieldless_variants: false,\n@@ -53,7 +53,7 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n     // We want to make sure we have the ctxt set so that we can use unstable methods\n     let span = cx.with_def_site_ctxt(span);\n     let name = cx.expr_lit(span, ast::LitKind::Str(ident.name, ast::StrStyle::Cooked));\n-    let fmt = substr.nonself_args[0].clone();\n+    let fmt = substr.nonselflike_args[0].clone();\n \n     // Struct and tuples are similar enough that we use the same code for both,\n     // with some extra pieces for structs due to the field names."}, {"sha": "d688143a2a5c622e56102406b81ca1bee70b1fbe", "filename": "compiler/rustc_builtin_macros/src/deriving/decodable.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/32c9ffb9ccb1dae15d473c8c4462eb80b4d35fc7/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32c9ffb9ccb1dae15d473c8c4462eb80b4d35fc7/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs?ref=32c9ffb9ccb1dae15d473c8c4462eb80b4d35fc7", "patch": "@@ -36,7 +36,10 @@ pub fn expand_deriving_rustc_decodable(\n                 )],\n             },\n             explicit_self: false,\n-            args: vec![(Ref(Box::new(Path(Path::new_local(typaram))), Mutability::Mut), sym::d)],\n+            nonself_args: vec![(\n+                Ref(Box::new(Path(Path::new_local(typaram))), Mutability::Mut),\n+                sym::d,\n+            )],\n             ret_ty: Path(Path::new_(\n                 pathvec_std!(result::Result),\n                 vec![\n@@ -63,7 +66,7 @@ fn decodable_substructure(\n     substr: &Substructure<'_>,\n     krate: Symbol,\n ) -> BlockOrExpr {\n-    let decoder = substr.nonself_args[0].clone();\n+    let decoder = substr.nonselflike_args[0].clone();\n     let recurse = vec![\n         Ident::new(krate, trait_span),\n         Ident::new(sym::Decodable, trait_span),"}, {"sha": "5177690917f21759da87a64be8c7cbcbc889602b", "filename": "compiler/rustc_builtin_macros/src/deriving/default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32c9ffb9ccb1dae15d473c8c4462eb80b4d35fc7/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32c9ffb9ccb1dae15d473c8c4462eb80b4d35fc7/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs?ref=32c9ffb9ccb1dae15d473c8c4462eb80b4d35fc7", "patch": "@@ -34,7 +34,7 @@ pub fn expand_deriving_default(\n             name: kw::Default,\n             generics: Bounds::empty(),\n             explicit_self: false,\n-            args: Vec::new(),\n+            nonself_args: Vec::new(),\n             ret_ty: Self_,\n             attributes: attrs,\n             unify_fieldless_variants: false,"}, {"sha": "c89558f6b86eb7f51ca53aadfba04be305c81505", "filename": "compiler/rustc_builtin_macros/src/deriving/encodable.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/32c9ffb9ccb1dae15d473c8c4462eb80b4d35fc7/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32c9ffb9ccb1dae15d473c8c4462eb80b4d35fc7/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs?ref=32c9ffb9ccb1dae15d473c8c4462eb80b4d35fc7", "patch": "@@ -120,7 +120,10 @@ pub fn expand_deriving_rustc_encodable(\n                 )],\n             },\n             explicit_self: true,\n-            args: vec![(Ref(Box::new(Path(Path::new_local(typaram))), Mutability::Mut), sym::s)],\n+            nonself_args: vec![(\n+                Ref(Box::new(Path(Path::new_local(typaram))), Mutability::Mut),\n+                sym::s,\n+            )],\n             ret_ty: Path(Path::new_(\n                 pathvec_std!(result::Result),\n                 vec![\n@@ -147,7 +150,7 @@ fn encodable_substructure(\n     substr: &Substructure<'_>,\n     krate: Symbol,\n ) -> BlockOrExpr {\n-    let encoder = substr.nonself_args[0].clone();\n+    let encoder = substr.nonselflike_args[0].clone();\n     // throw an underscore in front to suppress unused variable warnings\n     let blkarg = Ident::new(sym::_e, trait_span);\n     let blkencoder = cx.expr_ident(trait_span, blkarg);"}, {"sha": "cafca507bd44662199f2ecf9ab14cff82cd956e4", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 127, "deletions": 95, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/32c9ffb9ccb1dae15d473c8c4462eb80b4d35fc7/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32c9ffb9ccb1dae15d473c8c4462eb80b4d35fc7/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=32c9ffb9ccb1dae15d473c8c4462eb80b4d35fc7", "patch": "@@ -227,8 +227,8 @@ pub struct MethodDef<'a> {\n     /// Is there is a `&self` argument? If not, it is a static function.\n     pub explicit_self: bool,\n \n-    /// Arguments other than the self argument\n-    pub args: Vec<(Ty, Symbol)>,\n+    /// Arguments other than the self argument.\n+    pub nonself_args: Vec<(Ty, Symbol)>,\n \n     /// Returns type\n     pub ret_ty: Ty,\n@@ -245,8 +245,8 @@ pub struct MethodDef<'a> {\n pub struct Substructure<'a> {\n     /// ident of self\n     pub type_ident: Ident,\n-    /// verbatim access to any non-self arguments\n-    pub nonself_args: &'a [P<Expr>],\n+    /// verbatim access to any non-selflike arguments\n+    pub nonselflike_args: &'a [P<Expr>],\n     pub fields: &'a SubstructureFields<'a>,\n }\n \n@@ -782,31 +782,39 @@ impl<'a> TraitDef<'a> {\n             .methods\n             .iter()\n             .map(|method_def| {\n-                let (explicit_self, self_args, nonself_args, tys) =\n-                    method_def.split_self_nonself_args(cx, self, type_ident, generics);\n+                let (explicit_self, selflike_args, nonselflike_args, nonself_arg_tys) =\n+                    method_def.extract_arg_details(cx, self, type_ident, generics);\n \n                 let body = if from_scratch || method_def.is_static() {\n                     method_def.expand_static_struct_method_body(\n                         cx,\n                         self,\n                         struct_def,\n                         type_ident,\n-                        &nonself_args,\n+                        &nonselflike_args,\n                     )\n                 } else {\n                     method_def.expand_struct_method_body(\n                         cx,\n                         self,\n                         struct_def,\n                         type_ident,\n-                        &self_args,\n-                        &nonself_args,\n+                        &selflike_args,\n+                        &nonselflike_args,\n                         use_temporaries,\n                         is_packed,\n                     )\n                 };\n \n-                method_def.create_method(cx, self, type_ident, generics, explicit_self, tys, body)\n+                method_def.create_method(\n+                    cx,\n+                    self,\n+                    type_ident,\n+                    generics,\n+                    explicit_self,\n+                    nonself_arg_tys,\n+                    body,\n+                )\n             })\n             .collect();\n \n@@ -831,29 +839,37 @@ impl<'a> TraitDef<'a> {\n             .methods\n             .iter()\n             .map(|method_def| {\n-                let (explicit_self, self_args, nonself_args, tys) =\n-                    method_def.split_self_nonself_args(cx, self, type_ident, generics);\n+                let (explicit_self, selflike_args, nonselflike_args, nonself_arg_tys) =\n+                    method_def.extract_arg_details(cx, self, type_ident, generics);\n \n                 let body = if from_scratch || method_def.is_static() {\n                     method_def.expand_static_enum_method_body(\n                         cx,\n                         self,\n                         enum_def,\n                         type_ident,\n-                        &nonself_args,\n+                        &nonselflike_args,\n                     )\n                 } else {\n                     method_def.expand_enum_method_body(\n                         cx,\n                         self,\n                         enum_def,\n                         type_ident,\n-                        self_args,\n-                        &nonself_args,\n+                        selflike_args,\n+                        &nonselflike_args,\n                     )\n                 };\n \n-                method_def.create_method(cx, self, type_ident, generics, explicit_self, tys, body)\n+                method_def.create_method(\n+                    cx,\n+                    self,\n+                    type_ident,\n+                    generics,\n+                    explicit_self,\n+                    nonself_arg_tys,\n+                    body,\n+                )\n             })\n             .collect();\n \n@@ -867,11 +883,11 @@ impl<'a> MethodDef<'a> {\n         cx: &mut ExtCtxt<'_>,\n         trait_: &TraitDef<'_>,\n         type_ident: Ident,\n-        nonself_args: &[P<Expr>],\n+        nonselflike_args: &[P<Expr>],\n         fields: &SubstructureFields<'_>,\n     ) -> BlockOrExpr {\n         let span = trait_.span;\n-        let substructure = Substructure { type_ident, nonself_args, fields };\n+        let substructure = Substructure { type_ident, nonselflike_args, fields };\n         let mut f = self.combine_substructure.borrow_mut();\n         let f: &mut CombineSubstructureFunc<'_> = &mut *f;\n         f(cx, span, &substructure)\n@@ -891,49 +907,52 @@ impl<'a> MethodDef<'a> {\n         !self.explicit_self\n     }\n \n-    fn split_self_nonself_args(\n+    // The return value includes:\n+    // - explicit_self: The `&self` arg, if present.\n+    // - selflike_args: Expressions for `&self` (if present) and also any other\n+    //   args with the same type (e.g. the `other` arg in `PartialEq::eq`).\n+    // - nonselflike_args: Expressions for all the remaining args.\n+    // - nonself_arg_tys: Additional information about all the args other than\n+    //   `&self`.\n+    fn extract_arg_details(\n         &self,\n         cx: &mut ExtCtxt<'_>,\n         trait_: &TraitDef<'_>,\n         type_ident: Ident,\n         generics: &Generics,\n     ) -> (Option<ast::ExplicitSelf>, Vec<P<Expr>>, Vec<P<Expr>>, Vec<(Ident, P<ast::Ty>)>) {\n-        let mut self_args = Vec::new();\n-        let mut nonself_args = Vec::new();\n-        let mut arg_tys = Vec::new();\n+        let mut selflike_args = Vec::new();\n+        let mut nonselflike_args = Vec::new();\n+        let mut nonself_arg_tys = Vec::new();\n         let span = trait_.span;\n \n-        let ast_explicit_self = if self.explicit_self {\n+        let explicit_self = if self.explicit_self {\n             let (self_expr, explicit_self) = ty::get_explicit_self(cx, span);\n-            self_args.push(self_expr);\n+            selflike_args.push(self_expr);\n             Some(explicit_self)\n         } else {\n             None\n         };\n \n-        for (ty, name) in self.args.iter() {\n+        for (ty, name) in self.nonself_args.iter() {\n             let ast_ty = ty.to_ty(cx, span, type_ident, generics);\n             let ident = Ident::new(*name, span);\n-            arg_tys.push((ident, ast_ty));\n+            nonself_arg_tys.push((ident, ast_ty));\n \n             let arg_expr = cx.expr_ident(span, ident);\n \n             match *ty {\n                 // for static methods, just treat any Self\n                 // arguments as a normal arg\n-                Self_ if !self.is_static() => {\n-                    self_args.push(arg_expr);\n-                }\n                 Ref(ref ty, _) if matches!(**ty, Self_) && !self.is_static() => {\n-                    self_args.push(cx.expr_deref(span, arg_expr))\n-                }\n-                _ => {\n-                    nonself_args.push(arg_expr);\n+                    selflike_args.push(cx.expr_deref(span, arg_expr))\n                 }\n+                Self_ => cx.span_bug(span, \"`Self` in non-return position\"),\n+                _ => nonselflike_args.push(arg_expr),\n             }\n         }\n \n-        (ast_explicit_self, self_args, nonself_args, arg_tys)\n+        (explicit_self, selflike_args, nonselflike_args, nonself_arg_tys)\n     }\n \n     fn create_method(\n@@ -943,20 +962,21 @@ impl<'a> MethodDef<'a> {\n         type_ident: Ident,\n         generics: &Generics,\n         explicit_self: Option<ast::ExplicitSelf>,\n-        arg_types: Vec<(Ident, P<ast::Ty>)>,\n+        nonself_arg_tys: Vec<(Ident, P<ast::Ty>)>,\n         body: BlockOrExpr,\n     ) -> P<ast::AssocItem> {\n         let span = trait_.span;\n         // Create the generics that aren't for `Self`.\n         let fn_generics = self.generics.to_generics(cx, span, type_ident, generics);\n \n         let args = {\n-            let self_args = explicit_self.map(|explicit_self| {\n+            let self_arg = explicit_self.map(|explicit_self| {\n                 let ident = Ident::with_dummy_span(kw::SelfLower).with_span_pos(span);\n                 ast::Param::from_self(ast::AttrVec::default(), explicit_self, ident)\n             });\n-            let nonself_args = arg_types.into_iter().map(|(name, ty)| cx.param(span, name, ty));\n-            self_args.into_iter().chain(nonself_args).collect()\n+            let nonself_args =\n+                nonself_arg_tys.into_iter().map(|(name, ty)| cx.param(span, name, ty));\n+            self_arg.into_iter().chain(nonself_args).collect()\n         };\n \n         let ret_type = self.get_ret_ty(cx, trait_, generics, type_ident);\n@@ -1024,18 +1044,18 @@ impl<'a> MethodDef<'a> {\n         trait_: &TraitDef<'b>,\n         struct_def: &'b VariantData,\n         type_ident: Ident,\n-        self_args: &[P<Expr>],\n-        nonself_args: &[P<Expr>],\n+        selflike_args: &[P<Expr>],\n+        nonselflike_args: &[P<Expr>],\n         use_temporaries: bool,\n         is_packed: bool,\n     ) -> BlockOrExpr {\n         let mut raw_fields = Vec::new(); // Vec<[fields of self], [fields of next Self arg], [etc]>\n         let span = trait_.span;\n         let mut patterns = Vec::new();\n \n-        for (i, self_arg) in self_args.iter().enumerate() {\n+        for (i, selflike_arg) in selflike_args.iter().enumerate() {\n             let ident_exprs = if !is_packed {\n-                trait_.create_struct_field_accesses(cx, self_arg, struct_def)\n+                trait_.create_struct_field_accesses(cx, selflike_arg, struct_def)\n             } else {\n                 // Get the pattern for the let-destructuring.\n                 //\n@@ -1084,16 +1104,18 @@ impl<'a> MethodDef<'a> {\n             cx,\n             trait_,\n             type_ident,\n-            nonself_args,\n+            nonselflike_args,\n             &Struct(struct_def, fields),\n         );\n \n         if !is_packed {\n             body\n         } else {\n             // Do the let-destructuring.\n-            let mut stmts: Vec<_> = iter::zip(self_args, patterns)\n-                .map(|(arg_expr, pat)| cx.stmt_let_pat(span, pat, arg_expr.clone()))\n+            let mut stmts: Vec<_> = iter::zip(selflike_args, patterns)\n+                .map(|(selflike_arg_expr, pat)| {\n+                    cx.stmt_let_pat(span, pat, selflike_arg_expr.clone())\n+                })\n                 .collect();\n             stmts.extend(std::mem::take(&mut body.0));\n             BlockOrExpr(stmts, body.1)\n@@ -1106,15 +1128,15 @@ impl<'a> MethodDef<'a> {\n         trait_: &TraitDef<'_>,\n         struct_def: &VariantData,\n         type_ident: Ident,\n-        nonself_args: &[P<Expr>],\n+        nonselflike_args: &[P<Expr>],\n     ) -> BlockOrExpr {\n         let summary = trait_.summarise_struct(cx, struct_def);\n \n         self.call_substructure_method(\n             cx,\n             trait_,\n             type_ident,\n-            nonself_args,\n+            nonselflike_args,\n             &StaticStruct(struct_def, summary),\n         )\n     }\n@@ -1148,7 +1170,7 @@ impl<'a> MethodDef<'a> {\n     ///     }\n     /// }\n     /// ```\n-    /// Creates a match for a tuple of all `self_args`, where either all\n+    /// Creates a match for a tuple of all `selflike_args`, where either all\n     /// variants match, or it falls into a catch-all for when one variant\n     /// does not match.\n     ///\n@@ -1161,33 +1183,33 @@ impl<'a> MethodDef<'a> {\n     /// a simple equality check (for PartialEq).\n     ///\n     /// The catch-all handler is provided access the variant index values\n-    /// for each of the self-args, carried in precomputed variables.\n+    /// for each of the selflike_args, carried in precomputed variables.\n     fn expand_enum_method_body<'b>(\n         &self,\n         cx: &mut ExtCtxt<'_>,\n         trait_: &TraitDef<'b>,\n         enum_def: &'b EnumDef,\n         type_ident: Ident,\n-        mut self_args: Vec<P<Expr>>,\n-        nonself_args: &[P<Expr>],\n+        mut selflike_args: Vec<P<Expr>>,\n+        nonselflike_args: &[P<Expr>],\n     ) -> BlockOrExpr {\n         let span = trait_.span;\n         let variants = &enum_def.variants;\n \n-        let self_arg_names = iter::once(\"__self\".to_string())\n+        let selflike_arg_names = iter::once(\"__self\".to_string())\n             .chain(\n-                self_args\n+                selflike_args\n                     .iter()\n                     .enumerate()\n                     .skip(1)\n-                    .map(|(arg_count, _self_arg)| format!(\"__arg_{}\", arg_count)),\n+                    .map(|(arg_count, _selflike_arg)| format!(\"__arg_{}\", arg_count)),\n             )\n             .collect::<Vec<String>>();\n \n         // The `vi_idents` will be bound, solely in the catch-all, to\n-        // a series of let statements mapping each self_arg to an int\n+        // a series of let statements mapping each selflike_arg to an int\n         // value corresponding to its discriminant.\n-        let vi_idents = self_arg_names\n+        let vi_idents = selflike_arg_names\n             .iter()\n             .map(|name| {\n                 let vi_suffix = format!(\"{}_vi\", name);\n@@ -1206,36 +1228,36 @@ impl<'a> MethodDef<'a> {\n         // (Variant1, Variant1, ...) => Body1\n         // (Variant2, Variant2, ...) => Body2\n         // ...\n-        // where each tuple has length = self_args.len()\n+        // where each tuple has length = selflike_args.len()\n         let mut match_arms: Vec<ast::Arm> = variants\n             .iter()\n             .enumerate()\n             .filter(|&(_, v)| !(self.unify_fieldless_variants && v.data.fields().is_empty()))\n             .map(|(index, variant)| {\n-                let mk_self_pat = |cx: &mut ExtCtxt<'_>, self_arg_name: &str| {\n+                let mk_selflike_pat = |cx: &mut ExtCtxt<'_>, selflike_arg_name: &str| {\n                     let (p, idents) = trait_.create_enum_variant_pattern(\n                         cx,\n                         type_ident,\n                         variant,\n-                        self_arg_name,\n+                        selflike_arg_name,\n                         ast::Mutability::Not,\n                     );\n                     (cx.pat(span, PatKind::Ref(p, ast::Mutability::Not)), idents)\n                 };\n \n                 // A single arm has form (&VariantK, &VariantK, ...) => BodyK\n                 // (see \"Final wrinkle\" note below for why.)\n-                let mut subpats = Vec::with_capacity(self_arg_names.len());\n-                let mut self_pats_idents = Vec::with_capacity(self_arg_names.len() - 1);\n-                let first_self_pat_idents = {\n-                    let (p, idents) = mk_self_pat(cx, &self_arg_names[0]);\n+                let mut subpats = Vec::with_capacity(selflike_arg_names.len());\n+                let mut selflike_pats_idents = Vec::with_capacity(selflike_arg_names.len() - 1);\n+                let first_selflike_pat_idents = {\n+                    let (p, idents) = mk_selflike_pat(cx, &selflike_arg_names[0]);\n                     subpats.push(p);\n                     idents\n                 };\n-                for self_arg_name in &self_arg_names[1..] {\n-                    let (p, idents) = mk_self_pat(cx, &self_arg_name);\n+                for selflike_arg_name in &selflike_arg_names[1..] {\n+                    let (p, idents) = mk_selflike_pat(cx, &selflike_arg_name);\n                     subpats.push(p);\n-                    self_pats_idents.push(idents);\n+                    selflike_pats_idents.push(idents);\n                 }\n \n                 // Here is the pat = `(&VariantK, &VariantK, ...)`\n@@ -1250,24 +1272,24 @@ impl<'a> MethodDef<'a> {\n                 // we are in.\n \n                 // All of the Self args have the same variant in these\n-                // cases.  So we transpose the info in self_pats_idents\n+                // cases. So we transpose the info in selflike_pats_idents\n                 // to gather the getter expressions together, in the\n                 // form that EnumMatching expects.\n \n                 // The transposition is driven by walking across the\n-                // arg fields of the variant for the first self pat.\n-                let field_tuples = first_self_pat_idents\n+                // arg fields of the variant for the first selflike pat.\n+                let field_tuples = first_selflike_pat_idents\n                     .into_iter()\n                     .enumerate()\n                     // For each arg field of self, pull out its getter expr ...\n                     .map(|(field_index, (span, opt_ident, self_getter_expr, attrs))| {\n                         // ... but FieldInfo also wants getter expr\n                         // for matching other arguments of Self type;\n-                        // so walk across the *other* self_pats_idents\n+                        // so walk across the *other* selflike_pats_idents\n                         // and pull out getter for same field in each\n                         // of them (using `field_index` tracked above).\n                         // That is the heart of the transposition.\n-                        let others = self_pats_idents\n+                        let others = selflike_pats_idents\n                             .iter()\n                             .map(|fields| {\n                                 let (_, _opt_ident, ref other_getter_expr, _) = fields[field_index];\n@@ -1298,7 +1320,13 @@ impl<'a> MethodDef<'a> {\n                 // Build up code associated with such a case.\n                 let substructure = EnumMatching(index, variants.len(), variant, field_tuples);\n                 let arm_expr = self\n-                    .call_substructure_method(cx, trait_, type_ident, nonself_args, &substructure)\n+                    .call_substructure_method(\n+                        cx,\n+                        trait_,\n+                        type_ident,\n+                        nonselflike_args,\n+                        &substructure,\n+                    )\n                     .into_expr(cx, span);\n \n                 cx.arm(span, single_pat, arm_expr)\n@@ -1316,13 +1344,13 @@ impl<'a> MethodDef<'a> {\n                         cx,\n                         trait_,\n                         type_ident,\n-                        nonself_args,\n+                        nonselflike_args,\n                         &substructure,\n                     )\n                     .into_expr(cx, span),\n                 )\n             }\n-            _ if variants.len() > 1 && self_args.len() > 1 => {\n+            _ if variants.len() > 1 && selflike_args.len() > 1 => {\n                 // Since we know that all the arguments will match if we reach\n                 // the match expression we add the unreachable intrinsics as the\n                 // result of the catch all which should help llvm in optimizing it\n@@ -1349,8 +1377,8 @@ impl<'a> MethodDef<'a> {\n         //   catch-all `_` match, it would trigger the\n         //   unreachable-pattern error.\n         //\n-        if variants.len() > 1 && self_args.len() > 1 {\n-            // Build a series of let statements mapping each self_arg\n+        if variants.len() > 1 && selflike_args.len() > 1 {\n+            // Build a series of let statements mapping each selflike_arg\n             // to its discriminant value.\n             //\n             // i.e., for `enum E<T> { A, B(1), C(T, T) }`, and a deriving\n@@ -1365,10 +1393,14 @@ impl<'a> MethodDef<'a> {\n             // We also build an expression which checks whether all discriminants are equal:\n             // `__self_vi == __arg_1_vi && __self_vi == __arg_2_vi && ...`\n             let mut discriminant_test = cx.expr_bool(span, true);\n-            for (i, (&ident, self_arg)) in iter::zip(&vi_idents, &self_args).enumerate() {\n-                let self_addr = cx.expr_addr_of(span, self_arg.clone());\n-                let variant_value =\n-                    deriving::call_intrinsic(cx, span, sym::discriminant_value, vec![self_addr]);\n+            for (i, (&ident, selflike_arg)) in iter::zip(&vi_idents, &selflike_args).enumerate() {\n+                let selflike_addr = cx.expr_addr_of(span, selflike_arg.clone());\n+                let variant_value = deriving::call_intrinsic(\n+                    cx,\n+                    span,\n+                    sym::discriminant_value,\n+                    vec![selflike_addr],\n+                );\n                 let let_stmt = cx.stmt_let(span, false, ident, variant_value);\n                 index_let_stmts.push(let_stmt);\n \n@@ -1389,18 +1421,18 @@ impl<'a> MethodDef<'a> {\n                     cx,\n                     trait_,\n                     type_ident,\n-                    nonself_args,\n+                    nonselflike_args,\n                     &catch_all_substructure,\n                 )\n                 .into_expr(cx, span);\n \n-            // Final wrinkle: the self_args are expressions that deref\n+            // Final wrinkle: the selflike_args are expressions that deref\n             // down to desired places, but we cannot actually deref\n             // them when they are fed as r-values into a tuple\n             // expression; here add a layer of borrowing, turning\n             // `(*self, *__arg_0, ...)` into `(&*self, &*__arg_0, ...)`.\n-            self_args.map_in_place(|self_arg| cx.expr_addr_of(span, self_arg));\n-            let match_arg = cx.expr(span, ast::ExprKind::Tup(self_args));\n+            selflike_args.map_in_place(|selflike_arg| cx.expr_addr_of(span, selflike_arg));\n+            let match_arg = cx.expr(span, ast::ExprKind::Tup(selflike_args));\n \n             // Lastly we create an expression which branches on all discriminants being equal\n             //  if discriminant_test {\n@@ -1469,16 +1501,16 @@ impl<'a> MethodDef<'a> {\n \n             BlockOrExpr(vec![], Some(deriving::call_unreachable(cx, span)))\n         } else {\n-            // Final wrinkle: the self_args are expressions that deref\n+            // Final wrinkle: the selflike_args are expressions that deref\n             // down to desired places, but we cannot actually deref\n             // them when they are fed as r-values into a tuple\n             // expression; here add a layer of borrowing, turning\n             // `(*self, *__arg_0, ...)` into `(&*self, &*__arg_0, ...)`.\n-            self_args.map_in_place(|self_arg| cx.expr_addr_of(span, self_arg));\n-            let match_arg = if self_args.len() == 1 {\n-                self_args.pop().unwrap()\n+            selflike_args.map_in_place(|selflike_arg| cx.expr_addr_of(span, selflike_arg));\n+            let match_arg = if selflike_args.len() == 1 {\n+                selflike_args.pop().unwrap()\n             } else {\n-                cx.expr(span, ast::ExprKind::Tup(self_args))\n+                cx.expr(span, ast::ExprKind::Tup(selflike_args))\n             };\n             BlockOrExpr(vec![], Some(cx.expr_match(span, match_arg, match_arms)))\n         }\n@@ -1490,7 +1522,7 @@ impl<'a> MethodDef<'a> {\n         trait_: &TraitDef<'_>,\n         enum_def: &EnumDef,\n         type_ident: Ident,\n-        nonself_args: &[P<Expr>],\n+        nonselflike_args: &[P<Expr>],\n     ) -> BlockOrExpr {\n         let summary = enum_def\n             .variants\n@@ -1505,7 +1537,7 @@ impl<'a> MethodDef<'a> {\n             cx,\n             trait_,\n             type_ident,\n-            nonself_args,\n+            nonselflike_args,\n             &StaticEnum(enum_def, summary),\n         )\n     }\n@@ -1609,16 +1641,16 @@ impl<'a> TraitDef<'a> {\n     fn create_struct_field_accesses(\n         &self,\n         cx: &mut ExtCtxt<'_>,\n-        mut self_arg: &P<Expr>,\n+        mut selflike_arg: &P<Expr>,\n         struct_def: &'a VariantData,\n     ) -> Vec<(Span, Option<Ident>, P<Expr>, &'a [ast::Attribute])> {\n         let mut ident_exprs = Vec::new();\n         for (i, struct_field) in struct_def.fields().iter().enumerate() {\n             let sp = struct_field.span.with_ctxt(self.span.ctxt());\n \n             // We don't the need the deref, if there is one.\n-            if let ast::ExprKind::Unary(ast::UnOp::Deref, inner) = &self_arg.kind {\n-                self_arg = inner;\n+            if let ast::ExprKind::Unary(ast::UnOp::Deref, inner) = &selflike_arg.kind {\n+                selflike_arg = inner;\n             }\n \n             // Note: we must use `struct_field.span` rather than `span` in the\n@@ -1628,7 +1660,7 @@ impl<'a> TraitDef<'a> {\n             let val = cx.expr(\n                 sp,\n                 ast::ExprKind::Field(\n-                    self_arg.clone(),\n+                    selflike_arg.clone(),\n                     struct_field.ident.unwrap_or_else(|| {\n                         Ident::from_str_and_span(&i.to_string(), struct_field.span)\n                     }),"}, {"sha": "6ff36e7f4ed032e62d34d9e2f5d184cb31ffa805", "filename": "compiler/rustc_builtin_macros/src/deriving/hash.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32c9ffb9ccb1dae15d473c8c4462eb80b4d35fc7/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32c9ffb9ccb1dae15d473c8c4462eb80b4d35fc7/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs?ref=32c9ffb9ccb1dae15d473c8c4462eb80b4d35fc7", "patch": "@@ -30,7 +30,7 @@ pub fn expand_deriving_hash(\n             name: sym::hash,\n             generics: Bounds { bounds: vec![(typaram, vec![path_std!(hash::Hasher)])] },\n             explicit_self: true,\n-            args: vec![(Ref(Box::new(Path(arg)), Mutability::Mut), sym::state)],\n+            nonself_args: vec![(Ref(Box::new(Path(arg)), Mutability::Mut), sym::state)],\n             ret_ty: Unit,\n             attributes: vec![],\n             unify_fieldless_variants: true,\n@@ -49,7 +49,7 @@ fn hash_substructure(\n     trait_span: Span,\n     substr: &Substructure<'_>,\n ) -> BlockOrExpr {\n-    let [state_expr] = substr.nonself_args else {\n+    let [state_expr] = substr.nonselflike_args else {\n         cx.span_bug(trait_span, \"incorrect number of arguments in `derive(Hash)`\");\n     };\n     let call_hash = |span, thing_expr| {"}]}