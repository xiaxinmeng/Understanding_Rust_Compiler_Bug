{"sha": "6118795ee10bd7ad08cf697485be66a3fd685297", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxMTg3OTVlZTEwYmQ3YWQwOGNmNjk3NDg1YmU2NmEzZmQ2ODUyOTc=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-04-10T14:15:12Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-04-10T14:20:18Z"}, "message": "Change `derive` expansions to use `discriminant_value` intrinsic.\n\nFix #15523.", "tree": {"sha": "1ffd618a31bfcd481c286beac769d6c21379edfc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ffd618a31bfcd481c286beac769d6c21379edfc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6118795ee10bd7ad08cf697485be66a3fd685297", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6118795ee10bd7ad08cf697485be66a3fd685297", "html_url": "https://github.com/rust-lang/rust/commit/6118795ee10bd7ad08cf697485be66a3fd685297", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6118795ee10bd7ad08cf697485be66a3fd685297/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ea2739176be213117f570d6b9ed787deac53880e", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea2739176be213117f570d6b9ed787deac53880e", "html_url": "https://github.com/rust-lang/rust/commit/ea2739176be213117f570d6b9ed787deac53880e"}], "stats": {"total": 58, "additions": 28, "deletions": 30}, "files": [{"sha": "1b7311028f5ed6ae03a05d97ac9bdd5d70961404", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6118795ee10bd7ad08cf697485be66a3fd685297/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6118795ee10bd7ad08cf697485be66a3fd685297/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=6118795ee10bd7ad08cf697485be66a3fd685297", "patch": "@@ -157,6 +157,7 @@ mod tuple;\n \n #[doc(hidden)]\n mod core {\n+    pub use intrinsics;\n     pub use panicking;\n     pub use fmt;\n     pub use clone;"}, {"sha": "c3478266db278a34f66ec214adfba3076b9f2f6a", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 27, "deletions": 30, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/6118795ee10bd7ad08cf697485be66a3fd685297/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6118795ee10bd7ad08cf697485be66a3fd685297/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=6118795ee10bd7ad08cf697485be66a3fd685297", "patch": "@@ -706,15 +706,6 @@ impl<'a> TraitDef<'a> {\n     }\n }\n \n-fn variant_to_pat(cx: &mut ExtCtxt, sp: Span, enum_ident: ast::Ident, variant: &ast::Variant)\n-                  -> P<ast::Pat> {\n-    let path = cx.path(sp, vec![enum_ident, variant.node.name]);\n-    cx.pat(sp, match variant.node.kind {\n-        ast::TupleVariantKind(..) => ast::PatEnum(path, None),\n-        ast::StructVariantKind(..) => ast::PatStruct(path, Vec::new(), true),\n-    })\n-}\n-\n impl<'a> MethodDef<'a> {\n     fn call_substructure_method(&self,\n                                 cx: &mut ExtCtxt,\n@@ -1044,8 +1035,8 @@ impl<'a> MethodDef<'a> {\n             .collect::<Vec<ast::Ident>>();\n \n         // The `vi_idents` will be bound, solely in the catch-all, to\n-        // a series of let statements mapping each self_arg to a usize\n-        // corresponding to its variant index.\n+        // a series of let statements mapping each self_arg to an isize\n+        // corresponding to its discriminant value.\n         let vi_idents: Vec<ast::Ident> = self_arg_names.iter()\n             .map(|name| { let vi_suffix = format!(\"{}_vi\", &name[..]);\n                           cx.ident_of(&vi_suffix[..]) })\n@@ -1160,33 +1151,39 @@ impl<'a> MethodDef<'a> {\n         //   unreachable-pattern error.\n         //\n         if variants.len() > 1 && self_args.len() > 1 {\n-            let arms: Vec<ast::Arm> = variants.iter().enumerate()\n-                .map(|(index, variant)| {\n-                    let pat = variant_to_pat(cx, sp, type_ident, &**variant);\n-                    let lit = ast::LitInt(index as u64, ast::UnsignedIntLit(ast::TyUs));\n-                    cx.arm(sp, vec![pat], cx.expr_lit(sp, lit))\n-                }).collect();\n-\n             // Build a series of let statements mapping each self_arg\n-            // to a usize corresponding to its variant index.\n+            // to its discriminant value. If this is a C-style enum\n+            // with a specific repr type, then casts the values to\n+            // that type.  Otherwise casts to `isize`.\n+            //\n             // i.e. for `enum E<T> { A, B(1), C(T, T) }`, and a deriving\n             // with three Self args, builds three statements:\n             //\n             // ```\n-            // let __self0_vi = match   self {\n-            //     A => 0, B(..) => 1, C(..) => 2\n-            // };\n-            // let __self1_vi = match __arg1 {\n-            //     A => 0, B(..) => 1, C(..) => 2\n-            // };\n-            // let __self2_vi = match __arg2 {\n-            //     A => 0, B(..) => 1, C(..) => 2\n-            // };\n+            // let __self0_vi = unsafe {\n+            //     std::intrinsics::discriminant_value(&self) } as isize;\n+            // let __self1_vi = unsafe {\n+            //     std::intrinsics::discriminant_value(&__arg1) } as isize;\n+            // let __self2_vi = unsafe {\n+            //     std::intrinsics::discriminant_value(&__arg2) } as isize;\n             // ```\n             let mut index_let_stmts: Vec<P<ast::Stmt>> = Vec::new();\n             for (&ident, self_arg) in vi_idents.iter().zip(self_args.iter()) {\n-                let variant_idx = cx.expr_match(sp, self_arg.clone(), arms.clone());\n-                let let_stmt = cx.stmt_let(sp, false, ident, variant_idx);\n+                let path = vec![cx.ident_of_std(\"core\"),\n+                                cx.ident_of(\"intrinsics\"),\n+                                cx.ident_of(\"discriminant_value\")];\n+                let call = cx.expr_call_global(\n+                    sp, path, vec![cx.expr_addr_of(sp, self_arg.clone())]);\n+                let variant_value = cx.expr_block(P(ast::Block {\n+                    stmts: vec![],\n+                    expr: Some(call),\n+                    id: ast::DUMMY_NODE_ID,\n+                    rules: ast::UnsafeBlock(ast::CompilerGenerated),\n+                    span: sp }));\n+\n+                let target_ty = cx.ty_ident(sp, cx.ident_of(\"isize\"));\n+                let variant_disr = cx.expr_cast(sp, variant_value, target_ty);\n+                let let_stmt = cx.stmt_let(sp, false, ident, variant_disr);\n                 index_let_stmts.push(let_stmt);\n             }\n "}]}