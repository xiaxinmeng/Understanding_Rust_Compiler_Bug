{"sha": "cf6f821c3372b5ddc3cb0a92afcc48a1e0313efa", "node_id": "C_kwDOAAsO6NoAKGNmNmY4MjFjMzM3MmI1ZGRjM2NiMGE5MmFmY2M0OGExZTAzMTNlZmE", "commit": {"author": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-06-13T11:22:26Z"}, "committer": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-06-16T13:08:26Z"}, "message": "Try to clean up code...\n\nI'm not sure if I succeeded", "tree": {"sha": "1109880e7fd7e1879d0e51a46bbc5bb23b7be29e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1109880e7fd7e1879d0e51a46bbc5bb23b7be29e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf6f821c3372b5ddc3cb0a92afcc48a1e0313efa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf6f821c3372b5ddc3cb0a92afcc48a1e0313efa", "html_url": "https://github.com/rust-lang/rust/commit/cf6f821c3372b5ddc3cb0a92afcc48a1e0313efa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf6f821c3372b5ddc3cb0a92afcc48a1e0313efa/comments", "author": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a607cffc8c731f47a828c16d461bb97fda5ed41c", "url": "https://api.github.com/repos/rust-lang/rust/commits/a607cffc8c731f47a828c16d461bb97fda5ed41c", "html_url": "https://github.com/rust-lang/rust/commit/a607cffc8c731f47a828c16d461bb97fda5ed41c"}], "stats": {"total": 243, "additions": 150, "deletions": 93}, "files": [{"sha": "690ba14e699752f48e2d75db52a0bb63c0312477", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 150, "deletions": 93, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/cf6f821c3372b5ddc3cb0a92afcc48a1e0313efa/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf6f821c3372b5ddc3cb0a92afcc48a1e0313efa/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=cf6f821c3372b5ddc3cb0a92afcc48a1e0313efa", "patch": "@@ -10,7 +10,7 @@\n use Destination::*;\n \n use rustc_span::source_map::SourceMap;\n-use rustc_span::{SourceFile, Span};\n+use rustc_span::{FileLines, SourceFile, Span};\n \n use crate::snippet::{Annotation, AnnotationType, Line, MultilineAnnotation, Style, StyledString};\n use crate::styled_buffer::StyledBuffer;\n@@ -1756,12 +1756,6 @@ impl EmitterWriter {\n             let has_deletion = parts.iter().any(|p| p.is_deletion());\n             let is_multiline = complete.lines().count() > 1;\n \n-            enum DisplaySuggestion {\n-                Underline,\n-                Diff,\n-                None,\n-            }\n-\n             if let Some(span) = span.primary_span() {\n                 // Compare the primary span of the diagnostic with the span of the suggestion\n                 // being emitted.  If they belong to the same file, we don't *need* to show the\n@@ -1838,83 +1832,7 @@ impl EmitterWriter {\n             for (line_pos, (line, highlight_parts)) in lines.by_ref().zip(highlights).enumerate() {\n                 debug!(%line_pos, %line, ?highlight_parts);\n \n-                let print_line = |line_pos: usize,\n-                                  line: &str,\n-                                  highlight_parts: &Vec<SubstitutionHighlight>,\n-                                  buffer: &mut StyledBuffer,\n-                                  row_num: &mut usize| {\n-                    // Print the span column to avoid confusion\n-                    buffer.puts(\n-                        *row_num,\n-                        0,\n-                        &self.maybe_anonymized(line_start + line_pos),\n-                        Style::LineNumber,\n-                    );\n-                    if let DisplaySuggestion::Diff = show_code_change {\n-                        // Add the line number for both addition and removal to drive the point home.\n-                        //\n-                        // N - fn foo<A: T>(bar: A) {\n-                        // N + fn foo(bar: impl T) {\n-                        buffer.puts(\n-                            *row_num - 1,\n-                            0,\n-                            &self.maybe_anonymized(line_start + line_pos),\n-                            Style::LineNumber,\n-                        );\n-                        buffer.puts(*row_num - 1, max_line_num_len + 1, \"- \", Style::Removal);\n-                        buffer.puts(\n-                            *row_num - 1,\n-                            max_line_num_len + 3,\n-                            &normalize_whitespace(\n-                                &*file_lines\n-                                    .file\n-                                    .get_line(file_lines.lines[line_pos].line_index)\n-                                    .unwrap(),\n-                            ),\n-                            Style::NoStyle,\n-                        );\n-                        buffer.puts(*row_num, max_line_num_len + 1, \"+ \", Style::Addition);\n-                    } else if is_multiline {\n-                        match &highlight_parts[..] {\n-                            [SubstitutionHighlight { start: 0, end }] if *end == line.len() => {\n-                                buffer.puts(*row_num, max_line_num_len + 1, \"+ \", Style::Addition);\n-                            }\n-                            [] => {\n-                                draw_col_separator(buffer, *row_num, max_line_num_len + 1);\n-                            }\n-                            _ => {\n-                                buffer.puts(*row_num, max_line_num_len + 1, \"~ \", Style::Addition);\n-                            }\n-                        }\n-                    } else {\n-                        draw_col_separator(buffer, *row_num, max_line_num_len + 1);\n-                    }\n-\n-                    // print the suggestion\n-                    buffer.append(*row_num, &normalize_whitespace(line), Style::NoStyle);\n-\n-                    // Colorize addition/replacements with green.\n-                    for &SubstitutionHighlight { start, end } in highlight_parts {\n-                        // Account for tabs when highlighting (#87972).\n-                        let tabs: usize = line\n-                            .chars()\n-                            .take(start)\n-                            .map(|ch| match ch {\n-                                '\\t' => 3,\n-                                _ => 0,\n-                            })\n-                            .sum();\n-                        buffer.set_style_range(\n-                            *row_num,\n-                            max_line_num_len + 3 + start + tabs,\n-                            max_line_num_len + 3 + end + tabs,\n-                            Style::Addition,\n-                            true,\n-                        );\n-                    }\n-                    *row_num += 1;\n-                };\n-\n+                // Remember lines that are not highlighted to hide them if needed\n                 if highlight_parts.is_empty() {\n                     unhighlighted_lines.push((line_pos, line));\n                     continue;\n@@ -1927,22 +1845,77 @@ impl EmitterWriter {\n                     // (because then we just replace a line with ... which is\n                     // not helpful)\n                     n if n <= 3 => unhighlighted_lines.drain(..).for_each(|(p, l)| {\n-                        print_line(p, l, &Vec::new(), &mut buffer, &mut row_num)\n+                        self.draw_code_line(\n+                            &mut buffer,\n+                            &mut row_num,\n+                            &Vec::new(),\n+                            p,\n+                            l,\n+                            line_start,\n+                            show_code_change,\n+                            max_line_num_len,\n+                            &file_lines,\n+                            is_multiline,\n+                        )\n                     }),\n+                    // Print first unhighlighted line, \"...\" and last unhighlighted line, like so:\n+                    //\n+                    // LL | this line was highlighted\n+                    // LL | this line is just for context\n+                    //   ...\n+                    // LL | this line is just for context\n+                    // LL | this line was highlighted\n                     _ => {\n-                        unhighlighted_lines\n-                            .drain(..1)\n-                            .next()\n-                            .map(|(p, l)| print_line(p, l, &Vec::new(), &mut buffer, &mut row_num));\n+                        let last_line = unhighlighted_lines.pop();\n+                        let first_line = unhighlighted_lines.drain(..).next();\n+\n+                        first_line.map(|(p, l)| {\n+                            self.draw_code_line(\n+                                &mut buffer,\n+                                &mut row_num,\n+                                &Vec::new(),\n+                                p,\n+                                l,\n+                                line_start,\n+                                show_code_change,\n+                                max_line_num_len,\n+                                &file_lines,\n+                                is_multiline,\n+                            )\n+                        });\n+\n                         buffer.puts(row_num, max_line_num_len - 1, \"...\", Style::LineNumber);\n                         row_num += 1;\n-                        unhighlighted_lines\n-                            .pop()\n-                            .map(|(p, l)| print_line(p, l, &Vec::new(), &mut buffer, &mut row_num));\n+\n+                        last_line.map(|(p, l)| {\n+                            self.draw_code_line(\n+                                &mut buffer,\n+                                &mut row_num,\n+                                &Vec::new(),\n+                                p,\n+                                l,\n+                                line_start,\n+                                show_code_change,\n+                                max_line_num_len,\n+                                &file_lines,\n+                                is_multiline,\n+                            )\n+                        });\n                     }\n                 }\n \n-                print_line(line_pos, line, highlight_parts, &mut buffer, &mut row_num)\n+                self.draw_code_line(\n+                    &mut buffer,\n+                    &mut row_num,\n+                    highlight_parts,\n+                    line_pos,\n+                    line,\n+                    line_start,\n+                    show_code_change,\n+                    max_line_num_len,\n+                    &file_lines,\n+                    is_multiline,\n+                )\n             }\n \n             // This offset and the ones below need to be signed to account for replacement code\n@@ -2127,6 +2100,90 @@ impl EmitterWriter {\n             }\n         }\n     }\n+\n+    fn draw_code_line(\n+        &self,\n+        buffer: &mut StyledBuffer,\n+        row_num: &mut usize,\n+        highlight_parts: &Vec<SubstitutionHighlight>,\n+        line_pos: usize,\n+        line: &str,\n+        line_start: usize,\n+        show_code_change: DisplaySuggestion,\n+        max_line_num_len: usize,\n+        file_lines: &FileLines,\n+        is_multiline: bool,\n+    ) {\n+        // Print the span column to avoid confusion\n+        buffer.puts(*row_num, 0, &self.maybe_anonymized(line_start + line_pos), Style::LineNumber);\n+        if let DisplaySuggestion::Diff = show_code_change {\n+            // Add the line number for both addition and removal to drive the point home.\n+            //\n+            // N - fn foo<A: T>(bar: A) {\n+            // N + fn foo(bar: impl T) {\n+            buffer.puts(\n+                *row_num - 1,\n+                0,\n+                &self.maybe_anonymized(line_start + line_pos),\n+                Style::LineNumber,\n+            );\n+            buffer.puts(*row_num - 1, max_line_num_len + 1, \"- \", Style::Removal);\n+            buffer.puts(\n+                *row_num - 1,\n+                max_line_num_len + 3,\n+                &normalize_whitespace(\n+                    &*file_lines.file.get_line(file_lines.lines[line_pos].line_index).unwrap(),\n+                ),\n+                Style::NoStyle,\n+            );\n+            buffer.puts(*row_num, max_line_num_len + 1, \"+ \", Style::Addition);\n+        } else if is_multiline {\n+            match &highlight_parts[..] {\n+                [SubstitutionHighlight { start: 0, end }] if *end == line.len() => {\n+                    buffer.puts(*row_num, max_line_num_len + 1, \"+ \", Style::Addition);\n+                }\n+                [] => {\n+                    draw_col_separator(buffer, *row_num, max_line_num_len + 1);\n+                }\n+                _ => {\n+                    buffer.puts(*row_num, max_line_num_len + 1, \"~ \", Style::Addition);\n+                }\n+            }\n+        } else {\n+            draw_col_separator(buffer, *row_num, max_line_num_len + 1);\n+        }\n+\n+        // print the suggestion\n+        buffer.append(*row_num, &normalize_whitespace(line), Style::NoStyle);\n+\n+        // Colorize addition/replacements with green.\n+        for &SubstitutionHighlight { start, end } in highlight_parts {\n+            // Account for tabs when highlighting (#87972).\n+            let tabs: usize = line\n+                .chars()\n+                .take(start)\n+                .map(|ch| match ch {\n+                    '\\t' => 3,\n+                    _ => 0,\n+                })\n+                .sum();\n+            buffer.set_style_range(\n+                *row_num,\n+                max_line_num_len + 3 + start + tabs,\n+                max_line_num_len + 3 + end + tabs,\n+                Style::Addition,\n+                true,\n+            );\n+        }\n+        *row_num += 1;\n+    }\n+}\n+\n+#[derive(Clone, Copy)]\n+enum DisplaySuggestion {\n+    Underline,\n+    Diff,\n+    None,\n }\n \n impl FileWithAnnotatedLines {"}]}