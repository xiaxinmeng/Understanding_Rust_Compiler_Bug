{"sha": "0da7098116256d1e652284db4aa3815ff26105ed", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkYTcwOTgxMTYyNTZkMWU2NTIyODRkYjRhYTM4MTVmZjI2MTA1ZWQ=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-27T06:17:51Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-08-27T06:17:51Z"}, "message": "Rollup merge of #63761 - petrochenkov:procattrs, r=eddyb\n\nPropagate spans and attributes from proc macro definitions\n\nThanks to https://github.com/rust-lang/rust/pull/63269 we now have spans and attributes from proc macro definitions available in metadata.\n\nHowever, that PR didn't actually put them into use! This PR finishes that work.\n\nAttributes `rustc_macro_transparency`, `allow_internal_unstable`, `allow_internal_unsafe`, `local_inner_macros`, `rustc_builtin_macro`, `stable`, `unstable`, `rustc_deprecated`, `deprecated` now have effect when applied to proc macro definition functions.\nFrom those attributes only `deprecated` is both stable and supposed to be used in new code.\n(`#![staged_api]` still cannot be used in proc macro crates for unrelated reasons though.)\n\n`Span::def_site` from the proc macro API now returns the correct location of the proc macro definition.\n\nAlso, I made a mistake in https://github.com/rust-lang/rust/pull/63269#discussion_r312702919, loaded proc macros didn't actually use the resolver cache.\nThis PR fixes the caching issue, now proc macros go through the `Resolver::macro_map` cache as well.\n\n(Also, the first commit turns `proc_macro::quote` into a regular built-in macro to reduce the number of places where `SyntaxExtension`s need to be manually created.)", "tree": {"sha": "5abcd06ff7be32585dfc8b9d9c183e1bcc4966e9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5abcd06ff7be32585dfc8b9d9c183e1bcc4966e9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0da7098116256d1e652284db4aa3815ff26105ed", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdZMsPCRBK7hj4Ov3rIwAAdHIIABJCGq20kLWA+4Np1S6mkyn7\n5UurngQ5hdXtaEqzML61QIOMctFM2cijGpg6wcboeFDyJ5rs7J+VApPRgDrFbnN/\ng68FK39jn0EvN0jzk4Rrct17NgekIa5e3cQo27LefH4JSAOfN0qAillhU14cdBW/\nC/FMDB3qTh0cHG7mFw0+IOACm7deTYh2NQ3DM5ab0iu9OLjTUysLpE/D5pfzJdLC\nL8IN2SVO4mKn9KcnxdPvo3Th3UamQ5rnNzYgLNRgmAru3H6T/Xv2uqYPVG52oGUT\ngYOmUXnIpLlAK+ZUAAACbSLF7kQ5zSOpjV7afW29Ep+FHyQbUM53zNiNQyTyGl8=\n=FZJy\n-----END PGP SIGNATURE-----\n", "payload": "tree 5abcd06ff7be32585dfc8b9d9c183e1bcc4966e9\nparent 68597c764120b31b066f17d4f07de0d0a4384a0b\nparent c476b55e528ce854b6198de5bcfdd20b08440c9d\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1566886671 +0200\ncommitter GitHub <noreply@github.com> 1566886671 +0200\n\nRollup merge of #63761 - petrochenkov:procattrs, r=eddyb\n\nPropagate spans and attributes from proc macro definitions\n\nThanks to https://github.com/rust-lang/rust/pull/63269 we now have spans and attributes from proc macro definitions available in metadata.\n\nHowever, that PR didn't actually put them into use! This PR finishes that work.\n\nAttributes `rustc_macro_transparency`, `allow_internal_unstable`, `allow_internal_unsafe`, `local_inner_macros`, `rustc_builtin_macro`, `stable`, `unstable`, `rustc_deprecated`, `deprecated` now have effect when applied to proc macro definition functions.\nFrom those attributes only `deprecated` is both stable and supposed to be used in new code.\n(`#![staged_api]` still cannot be used in proc macro crates for unrelated reasons though.)\n\n`Span::def_site` from the proc macro API now returns the correct location of the proc macro definition.\n\nAlso, I made a mistake in https://github.com/rust-lang/rust/pull/63269#discussion_r312702919, loaded proc macros didn't actually use the resolver cache.\nThis PR fixes the caching issue, now proc macros go through the `Resolver::macro_map` cache as well.\n\n(Also, the first commit turns `proc_macro::quote` into a regular built-in macro to reduce the number of places where `SyntaxExtension`s need to be manually created.)\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0da7098116256d1e652284db4aa3815ff26105ed", "html_url": "https://github.com/rust-lang/rust/commit/0da7098116256d1e652284db4aa3815ff26105ed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0da7098116256d1e652284db4aa3815ff26105ed/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68597c764120b31b066f17d4f07de0d0a4384a0b", "url": "https://api.github.com/repos/rust-lang/rust/commits/68597c764120b31b066f17d4f07de0d0a4384a0b", "html_url": "https://github.com/rust-lang/rust/commit/68597c764120b31b066f17d4f07de0d0a4384a0b"}, {"sha": "c476b55e528ce854b6198de5bcfdd20b08440c9d", "url": "https://api.github.com/repos/rust-lang/rust/commits/c476b55e528ce854b6198de5bcfdd20b08440c9d", "html_url": "https://github.com/rust-lang/rust/commit/c476b55e528ce854b6198de5bcfdd20b08440c9d"}], "stats": {"total": 490, "additions": 318, "deletions": 172}, "files": [{"sha": "d408fef75153e2f83c597d9bfa6547b66585b1e2", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0da7098116256d1e652284db4aa3815ff26105ed/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da7098116256d1e652284db4aa3815ff26105ed/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=0da7098116256d1e652284db4aa3815ff26105ed", "patch": "@@ -19,12 +19,15 @@\n \n #![feature(nll)]\n #![feature(staged_api)]\n+#![feature(allow_internal_unstable)]\n #![feature(const_fn)]\n+#![feature(decl_macro)]\n #![feature(extern_types)]\n #![feature(in_band_lifetimes)]\n #![feature(optin_builtin_traits)]\n #![feature(mem_take)]\n #![feature(non_exhaustive)]\n+#![feature(rustc_attrs)]\n #![feature(specialization)]\n \n #![recursion_limit=\"256\"]\n@@ -222,11 +225,10 @@ pub mod token_stream {\n ///\n /// Unquoting is done with `$`, and works by taking the single next ident as the unquoted term.\n /// To quote `$` itself, use `$$`.\n-///\n-/// This is a dummy macro, the actual implementation is in `quote::quote`.`\n #[unstable(feature = \"proc_macro_quote\", issue = \"54722\")]\n-#[macro_export]\n-macro_rules! quote { () => {} }\n+#[allow_internal_unstable(proc_macro_def_site)]\n+#[cfg_attr(not(bootstrap), rustc_builtin_macro)]\n+pub macro quote ($($t:tt)*) { /* compiler built-in */ }\n \n #[unstable(feature = \"proc_macro_internals\", issue = \"27812\")]\n #[doc(hidden)]"}, {"sha": "144e2d6bac43bb3061ecbb3c785965732e56c7e5", "filename": "src/libproc_macro/quote.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0da7098116256d1e652284db4aa3815ff26105ed/src%2Flibproc_macro%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da7098116256d1e652284db4aa3815ff26105ed/src%2Flibproc_macro%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fquote.rs?ref=0da7098116256d1e652284db4aa3815ff26105ed", "patch": "@@ -57,9 +57,9 @@ macro_rules! quote {\n }\n \n /// Quote a `TokenStream` into a `TokenStream`.\n-/// This is the actual `quote!()` proc macro.\n+/// This is the actual implementation of the `quote!()` proc macro.\n ///\n-/// It is manually loaded in `CStore::load_macro_untracked`.\n+/// It is loaded by the compiler in `register_builtin_macros`.\n #[unstable(feature = \"proc_macro_quote\", issue = \"54722\")]\n pub fn quote(stream: TokenStream) -> TokenStream {\n     if stream.is_empty() {"}, {"sha": "5bf4067431f24a6b73a8e08ee4c2df3895377021", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0da7098116256d1e652284db4aa3815ff26105ed/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da7098116256d1e652284db4aa3815ff26105ed/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=0da7098116256d1e652284db4aa3815ff26105ed", "patch": "@@ -95,11 +95,6 @@ pub struct CrateMetadata {\n     pub raw_proc_macros: Option<&'static [ProcMacro]>,\n }\n \n-pub struct FullProcMacro {\n-    pub name: ast::Name,\n-    pub ext: Lrc<SyntaxExtension>\n-}\n-\n pub struct CStore {\n     metas: RwLock<IndexVec<CrateNum, Option<Lrc<CrateMetadata>>>>,\n     /// Map from NodeId's of local extern crate statements to crate numbers\n@@ -109,7 +104,7 @@ pub struct CStore {\n \n pub enum LoadedMacro {\n     MacroDef(ast::Item),\n-    ProcMacro(Lrc<SyntaxExtension>),\n+    ProcMacro(SyntaxExtension),\n }\n \n impl CStore {"}, {"sha": "5bfb315da473fa8b03bde89fda3cfc7d92e51d6d", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0da7098116256d1e652284db4aa3815ff26105ed/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da7098116256d1e652284db4aa3815ff26105ed/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=0da7098116256d1e652284db4aa3815ff26105ed", "patch": "@@ -30,11 +30,9 @@ use syntax::ast;\n use syntax::attr;\n use syntax::source_map;\n use syntax::edition::Edition;\n-use syntax::ext::base::{SyntaxExtension, SyntaxExtensionKind};\n-use syntax::ext::proc_macro::BangProcMacro;\n use syntax::parse::source_file_to_stream;\n use syntax::parse::parser::emit_unclosed_delims;\n-use syntax::symbol::{Symbol, sym};\n+use syntax::symbol::Symbol;\n use syntax_pos::{Span, FileName};\n use rustc_data_structures::bit_set::BitSet;\n \n@@ -436,15 +434,7 @@ impl cstore::CStore {\n     pub fn load_macro_untracked(&self, id: DefId, sess: &Session) -> LoadedMacro {\n         let data = self.get_crate_data(id.krate);\n         if data.is_proc_macro_crate() {\n-            return LoadedMacro::ProcMacro(data.get_proc_macro(id.index, sess).ext);\n-        } else if data.name == sym::proc_macro && data.item_name(id.index) == sym::quote {\n-            let client = proc_macro::bridge::client::Client::expand1(proc_macro::quote);\n-            let kind = SyntaxExtensionKind::Bang(Box::new(BangProcMacro { client }));\n-            let ext = SyntaxExtension {\n-                allow_internal_unstable: Some([sym::proc_macro_def_site][..].into()),\n-                ..SyntaxExtension::default(kind, data.root.edition)\n-            };\n-            return LoadedMacro::ProcMacro(Lrc::new(ext));\n+            return LoadedMacro::ProcMacro(data.load_proc_macro(id.index, sess));\n         }\n \n         let def = data.get_macro(id.index);"}, {"sha": "c777b5ea409a4315f45d103d4464c71314fda646", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 17, "deletions": 32, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/0da7098116256d1e652284db4aa3815ff26105ed/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da7098116256d1e652284db4aa3815ff26105ed/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=0da7098116256d1e652284db4aa3815ff26105ed", "patch": "@@ -1,6 +1,6 @@\n // Decoding metadata from a single crate's metadata\n \n-use crate::cstore::{self, CrateMetadata, MetadataBlob, NativeLibrary, ForeignModule, FullProcMacro};\n+use crate::cstore::{self, CrateMetadata, MetadataBlob, NativeLibrary, ForeignModule};\n use crate::schema::*;\n \n use rustc_data_structures::indexed_vec::IndexVec;\n@@ -512,27 +512,8 @@ impl<'a, 'tcx> CrateMetadata {\n         self.entry(index).span.decode((self, sess))\n     }\n \n-\n-    pub fn get_proc_macro(&self, id: DefIndex, sess: &Session) -> FullProcMacro {\n-        if sess.opts.debugging_opts.dual_proc_macros {\n-            let host_lib = self.host_lib.as_ref().unwrap();\n-            self.load_proc_macro(\n-                &host_lib.metadata.get_root(),\n-                id,\n-                sess\n-            )\n-        } else {\n-            self.load_proc_macro(&self.root, id, sess)\n-        }\n-    }\n-\n-    fn load_proc_macro(&self, root: &CrateRoot<'_>,\n-                        id: DefIndex,\n-                        sess: &Session)\n-                        -> FullProcMacro {\n-\n-        let raw_macro = self.raw_proc_macro(id);\n-        let (name, kind, helper_attrs) = match *raw_macro {\n+    crate fn load_proc_macro(&self, id: DefIndex, sess: &Session) -> SyntaxExtension {\n+        let (name, kind, helper_attrs) = match *self.raw_proc_macro(id) {\n             ProcMacro::CustomDerive { trait_name, attributes, client } => {\n                 let helper_attrs =\n                     attributes.iter().cloned().map(Symbol::intern).collect::<Vec<_>>();\n@@ -551,17 +532,21 @@ impl<'a, 'tcx> CrateMetadata {\n                 name, SyntaxExtensionKind::Bang(Box::new(BangProcMacro { client })), Vec::new()\n             )\n         };\n+        let edition = if sess.opts.debugging_opts.dual_proc_macros {\n+            self.host_lib.as_ref().unwrap().metadata.get_root().edition\n+        } else {\n+            self.root.edition\n+        };\n \n-        let span = self.get_span(id, sess);\n-\n-        FullProcMacro {\n-            name: Symbol::intern(name),\n-            ext: Lrc::new(SyntaxExtension {\n-                span,\n-                helper_attrs,\n-                ..SyntaxExtension::default(kind, root.edition)\n-            })\n-        }\n+        SyntaxExtension::new(\n+            &sess.parse_sess,\n+            kind,\n+            self.get_span(id, sess),\n+            helper_attrs,\n+            edition,\n+            Symbol::intern(name),\n+            &self.get_attributes(&self.entry(id), sess),\n+        )\n     }\n \n     pub fn get_trait_def(&self, item_id: DefIndex, sess: &Session) -> ty::TraitDef {"}, {"sha": "165a4c707bb6db54bf3e156fa719fd52ce9ae9ce", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0da7098116256d1e652284db4aa3815ff26105ed/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da7098116256d1e652284db4aa3815ff26105ed/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=0da7098116256d1e652284db4aa3815ff26105ed", "patch": "@@ -150,12 +150,12 @@ impl<'a> Resolver<'a> {\n             return Some(ext.clone());\n         }\n \n-        let macro_def = match self.cstore.load_macro_untracked(def_id, &self.session) {\n-            LoadedMacro::MacroDef(macro_def) => macro_def,\n-            LoadedMacro::ProcMacro(ext) => return Some(ext),\n-        };\n+        let ext = Lrc::new(match self.cstore.load_macro_untracked(def_id, &self.session) {\n+            LoadedMacro::MacroDef(item) =>\n+                self.compile_macro(&item, self.cstore.crate_edition_untracked(def_id.krate)),\n+            LoadedMacro::ProcMacro(ext) => ext,\n+        });\n \n-        let ext = self.compile_macro(&macro_def, self.cstore.crate_edition_untracked(def_id.krate));\n         self.macro_map.insert(def_id, ext.clone());\n         Some(ext)\n     }\n@@ -1104,7 +1104,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         let expansion = parent_scope.expansion;\n         let (ext, ident, span, is_legacy) = match &item.node {\n             ItemKind::MacroDef(def) => {\n-                let ext = self.r.compile_macro(item, self.r.session.edition());\n+                let ext = Lrc::new(self.r.compile_macro(item, self.r.session.edition()));\n                 (ext, item.ident, item.span, def.legacy)\n             }\n             ItemKind::Fn(..) => match Self::proc_macro_stub(item) {"}, {"sha": "cc78e928380a85a98dfc3662dd8c07bd43c4fc64", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0da7098116256d1e652284db4aa3815ff26105ed/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da7098116256d1e652284db4aa3815ff26105ed/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=0da7098116256d1e652284db4aa3815ff26105ed", "patch": "@@ -800,7 +800,7 @@ impl<'a> Resolver<'a> {\n \n     /// Compile the macro into a `SyntaxExtension` and possibly replace it with a pre-defined\n     /// extension partially or entirely for built-in macros and legacy plugin macros.\n-    crate fn compile_macro(&mut self, item: &ast::Item, edition: Edition) -> Lrc<SyntaxExtension> {\n+    crate fn compile_macro(&mut self, item: &ast::Item, edition: Edition) -> SyntaxExtension {\n         let mut result = macro_rules::compile(\n             &self.session.parse_sess, self.session.features_untracked(), item, edition\n         );\n@@ -822,6 +822,6 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        Lrc::new(result)\n+        result\n     }\n }"}, {"sha": "10ff1b17285fe0247f57f9330b44f387cf141171", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 65, "deletions": 2, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/0da7098116256d1e652284db4aa3815ff26105ed/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da7098116256d1e652284db4aa3815ff26105ed/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=0da7098116256d1e652284db4aa3815ff26105ed", "patch": "@@ -1,11 +1,11 @@\n use crate::ast::{self, NodeId, Attribute, Name, PatKind};\n-use crate::attr::{HasAttrs, Stability, Deprecation};\n+use crate::attr::{self, HasAttrs, Stability, Deprecation};\n use crate::source_map::SourceMap;\n use crate::edition::Edition;\n use crate::ext::expand::{self, AstFragment, Invocation};\n use crate::ext::hygiene::{ExpnId, Transparency};\n use crate::mut_visit::{self, MutVisitor};\n-use crate::parse::{self, parser, DirectoryOwnership};\n+use crate::parse::{self, parser, ParseSess, DirectoryOwnership};\n use crate::parse::token;\n use crate::ptr::P;\n use crate::symbol::{kw, sym, Ident, Symbol};\n@@ -601,6 +601,69 @@ impl SyntaxExtension {\n         }\n     }\n \n+    /// Constructs a syntax extension with the given properties\n+    /// and other properties converted from attributes.\n+    pub fn new(\n+        sess: &ParseSess,\n+        kind: SyntaxExtensionKind,\n+        span: Span,\n+        helper_attrs: Vec<Symbol>,\n+        edition: Edition,\n+        name: Name,\n+        attrs: &[ast::Attribute],\n+    ) -> SyntaxExtension {\n+        let allow_internal_unstable =\n+            attr::find_by_name(attrs, sym::allow_internal_unstable).map(|attr| {\n+                attr.meta_item_list()\n+                    .map(|list| {\n+                        list.iter()\n+                            .filter_map(|it| {\n+                                let name = it.ident().map(|ident| ident.name);\n+                                if name.is_none() {\n+                                    sess.span_diagnostic.span_err(\n+                                        it.span(), \"allow internal unstable expects feature names\"\n+                                    )\n+                                }\n+                                name\n+                            })\n+                            .collect::<Vec<Symbol>>()\n+                            .into()\n+                    })\n+                    .unwrap_or_else(|| {\n+                        sess.span_diagnostic.span_warn(\n+                            attr.span,\n+                            \"allow_internal_unstable expects list of feature names. In the future \\\n+                             this will become a hard error. Please use `allow_internal_unstable(\\\n+                             foo, bar)` to only allow the `foo` and `bar` features\",\n+                        );\n+                        vec![sym::allow_internal_unstable_backcompat_hack].into()\n+                    })\n+            });\n+\n+        let mut local_inner_macros = false;\n+        if let Some(macro_export) = attr::find_by_name(attrs, sym::macro_export) {\n+            if let Some(l) = macro_export.meta_item_list() {\n+                local_inner_macros = attr::list_contains_name(&l, sym::local_inner_macros);\n+            }\n+        }\n+\n+        let is_builtin = attr::contains_name(attrs, sym::rustc_builtin_macro);\n+\n+        SyntaxExtension {\n+            kind,\n+            span,\n+            allow_internal_unstable,\n+            allow_internal_unsafe: attr::contains_name(attrs, sym::allow_internal_unsafe),\n+            local_inner_macros,\n+            stability: attr::find_stability(&sess, attrs, span),\n+            deprecation: attr::find_deprecation(&sess, attrs, span),\n+            helper_attrs,\n+            edition,\n+            is_builtin,\n+            is_derive_copy: is_builtin && name == sym::Copy,\n+        }\n+    }\n+\n     pub fn dummy_bang(edition: Edition) -> SyntaxExtension {\n         fn expander<'cx>(_: &'cx mut ExtCtxt<'_>, span: Span, _: &[TokenTree])\n                          -> Box<dyn MacResult + 'cx> {"}, {"sha": "1a26b17dac782fae18ee1ff86c3b872e17162a33", "filename": "src/libsyntax/ext/proc_macro_server.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0da7098116256d1e652284db4aa3815ff26105ed/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da7098116256d1e652284db4aa3815ff26105ed/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs?ref=0da7098116256d1e652284db4aa3815ff26105ed", "patch": "@@ -360,12 +360,11 @@ pub(crate) struct Rustc<'a> {\n \n impl<'a> Rustc<'a> {\n     pub fn new(cx: &'a ExtCtxt<'_>) -> Self {\n-        // No way to determine def location for a proc macro right now, so use call location.\n-        let location = cx.current_expansion.id.expn_data().call_site;\n+        let expn_data = cx.current_expansion.id.expn_data();\n         Rustc {\n             sess: cx.parse_sess,\n-            def_site: cx.with_def_site_ctxt(location),\n-            call_site: cx.with_call_site_ctxt(location),\n+            def_site: cx.with_def_site_ctxt(expn_data.def_site),\n+            call_site: cx.with_call_site_ctxt(expn_data.call_site),\n         }\n     }\n "}, {"sha": "46ffa52f7f5725a1f652948151f23f94ffcd3a49", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 13, "deletions": 57, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/0da7098116256d1e652284db4aa3815ff26105ed/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da7098116256d1e652284db4aa3815ff26105ed/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=0da7098116256d1e652284db4aa3815ff26105ed", "patch": "@@ -1,3 +1,5 @@\n+use crate::ast;\n+use crate::attr::{self, TransparencyError};\n use crate::edition::Edition;\n use crate::ext::base::{DummyResult, ExtCtxt, MacResult, TTMacroExpander};\n use crate::ext::base::{SyntaxExtension, SyntaxExtensionKind};\n@@ -15,7 +17,6 @@ use crate::parse::token::{self, NtTT, Token};\n use crate::parse::{Directory, ParseSess};\n use crate::symbol::{kw, sym, Symbol};\n use crate::tokenstream::{DelimSpan, TokenStream, TokenTree};\n-use crate::{ast, attr, attr::TransparencyError};\n \n use errors::{DiagnosticBuilder, FatalError};\n use log::debug;\n@@ -290,6 +291,7 @@ pub fn compile(\n     def: &ast::Item,\n     edition: Edition,\n ) -> SyntaxExtension {\n+    let diag = &sess.span_diagnostic;\n     let lhs_nm = ast::Ident::new(sym::lhs, def.span);\n     let rhs_nm = ast::Ident::new(sym::rhs, def.span);\n     let tt_spec = ast::Ident::new(sym::tt, def.span);\n@@ -423,71 +425,25 @@ pub fn compile(\n     let (transparency, transparency_error) = attr::find_transparency(&def.attrs, body.legacy);\n     match transparency_error {\n         Some(TransparencyError::UnknownTransparency(value, span)) =>\n-            sess.span_diagnostic.span_err(\n-                span, &format!(\"unknown macro transparency: `{}`\", value)\n-            ),\n+            diag.span_err(span, &format!(\"unknown macro transparency: `{}`\", value)),\n         Some(TransparencyError::MultipleTransparencyAttrs(old_span, new_span)) =>\n-            sess.span_diagnostic.span_err(\n-                vec![old_span, new_span], \"multiple macro transparency attributes\"\n-            ),\n+            diag.span_err(vec![old_span, new_span], \"multiple macro transparency attributes\"),\n         None => {}\n     }\n \n     let expander: Box<_> = Box::new(MacroRulesMacroExpander {\n         name: def.ident, span: def.span, transparency, lhses, rhses, valid\n     });\n \n-    let allow_internal_unstable =\n-        attr::find_by_name(&def.attrs, sym::allow_internal_unstable).map(|attr| {\n-            attr.meta_item_list()\n-                .map(|list| {\n-                    list.iter()\n-                        .filter_map(|it| {\n-                            let name = it.ident().map(|ident| ident.name);\n-                            if name.is_none() {\n-                                sess.span_diagnostic.span_err(\n-                                    it.span(),\n-                                    \"allow internal unstable expects feature names\",\n-                                )\n-                            }\n-                            name\n-                        })\n-                        .collect::<Vec<Symbol>>()\n-                        .into()\n-                })\n-                .unwrap_or_else(|| {\n-                    sess.span_diagnostic.span_warn(\n-                        attr.span,\n-                        \"allow_internal_unstable expects list of feature names. In the \\\n-                         future this will become a hard error. Please use `allow_internal_unstable(\\\n-                         foo, bar)` to only allow the `foo` and `bar` features\",\n-                    );\n-                    vec![sym::allow_internal_unstable_backcompat_hack].into()\n-                })\n-        });\n-\n-    let mut local_inner_macros = false;\n-    if let Some(macro_export) = attr::find_by_name(&def.attrs, sym::macro_export) {\n-        if let Some(l) = macro_export.meta_item_list() {\n-            local_inner_macros = attr::list_contains_name(&l, sym::local_inner_macros);\n-        }\n-    }\n-\n-    let is_builtin = attr::contains_name(&def.attrs, sym::rustc_builtin_macro);\n-\n-    SyntaxExtension {\n-        kind: SyntaxExtensionKind::LegacyBang(expander),\n-        span: def.span,\n-        allow_internal_unstable,\n-        allow_internal_unsafe: attr::contains_name(&def.attrs, sym::allow_internal_unsafe),\n-        local_inner_macros,\n-        stability: attr::find_stability(&sess, &def.attrs, def.span),\n-        deprecation: attr::find_deprecation(&sess, &def.attrs, def.span),\n-        helper_attrs: Vec::new(),\n+    SyntaxExtension::new(\n+        sess,\n+        SyntaxExtensionKind::LegacyBang(expander),\n+        def.span,\n+        Vec::new(),\n         edition,\n-        is_builtin,\n-        is_derive_copy: is_builtin && def.ident.name == sym::Copy,\n-    }\n+        def.ident.name,\n+        &def.attrs,\n+    )\n }\n \n fn check_lhs_nt_follows("}, {"sha": "2b20cb88796c383141aedbba250dc4c1e010f935", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0da7098116256d1e652284db4aa3815ff26105ed/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da7098116256d1e652284db4aa3815ff26105ed/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=0da7098116256d1e652284db4aa3815ff26105ed", "patch": "@@ -375,10 +375,11 @@ impl<'a> Parser<'a> {\n         if let Some(directory) = directory {\n             parser.directory = directory;\n         } else if !parser.token.span.is_dummy() {\n-            if let FileName::Real(mut path) =\n-                    sess.source_map().span_to_unmapped_path(parser.token.span) {\n-                path.pop();\n-                parser.directory.path = Cow::from(path);\n+            if let Some(FileName::Real(path)) =\n+                    &sess.source_map().lookup_char_pos(parser.token.span.lo()).file.unmapped_path {\n+                if let Some(directory_path) = path.parent() {\n+                    parser.directory.path = Cow::from(directory_path.to_path_buf());\n+                }\n             }\n         }\n "}, {"sha": "1a6176916623b1017b3c2438c34e1d8eb03072c0", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0da7098116256d1e652284db4aa3815ff26105ed/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da7098116256d1e652284db4aa3815ff26105ed/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=0da7098116256d1e652284db4aa3815ff26105ed", "patch": "@@ -7,13 +7,18 @@\n #![feature(decl_macro)]\n #![feature(mem_take)]\n #![feature(nll)]\n+#![feature(proc_macro_internals)]\n+#![feature(proc_macro_quote)]\n #![feature(rustc_diagnostic_macros)]\n \n+extern crate proc_macro;\n+\n use crate::deriving::*;\n \n use syntax::ast::Ident;\n use syntax::edition::Edition;\n use syntax::ext::base::{SyntaxExtension, SyntaxExtensionKind, MacroExpanderFn};\n+use syntax::ext::proc_macro::BangProcMacro;\n use syntax::symbol::sym;\n \n mod error_codes;\n@@ -100,4 +105,7 @@ pub fn register_builtin_macros(resolver: &mut dyn syntax::ext::base::Resolver, e\n         RustcDecodable: decodable::expand_deriving_rustc_decodable,\n         RustcEncodable: encodable::expand_deriving_rustc_encodable,\n     }\n+\n+    let client = proc_macro::bridge::client::Client::expand1(proc_macro::quote);\n+    register(sym::quote, SyntaxExtensionKind::Bang(Box::new(BangProcMacro { client })));\n }"}, {"sha": "2819541bf6966127d538908cf0e18879f5a30433", "filename": "src/test/ui/auxiliary/cond_plugin.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0da7098116256d1e652284db4aa3815ff26105ed/src%2Ftest%2Fui%2Fauxiliary%2Fcond_plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da7098116256d1e652284db4aa3815ff26105ed/src%2Ftest%2Fui%2Fauxiliary%2Fcond_plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fauxiliary%2Fcond_plugin.rs?ref=0da7098116256d1e652284db4aa3815ff26105ed", "patch": "@@ -3,6 +3,7 @@\n \n #![crate_type = \"proc-macro\"]\n #![feature(proc_macro_hygiene)]\n+#![feature(proc_macro_quote)]\n \n extern crate proc_macro;\n "}, {"sha": "49cfb5518ba9c88bf1ef27959be5905127f8ea00", "filename": "src/test/ui/auxiliary/proc_macro_def.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0da7098116256d1e652284db4aa3815ff26105ed/src%2Ftest%2Fui%2Fauxiliary%2Fproc_macro_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da7098116256d1e652284db4aa3815ff26105ed/src%2Ftest%2Fui%2Fauxiliary%2Fproc_macro_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fauxiliary%2Fproc_macro_def.rs?ref=0da7098116256d1e652284db4aa3815ff26105ed", "patch": "@@ -3,6 +3,7 @@\n \n #![crate_type = \"proc-macro\"]\n #![feature(proc_macro_hygiene)]\n+#![feature(proc_macro_quote)]\n \n extern crate proc_macro;\n "}, {"sha": "c460db36f1aa3592be38a0fd71b3b0cd69c10fee", "filename": "src/test/ui/macros/auxiliary/proc_macro_sequence.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0da7098116256d1e652284db4aa3815ff26105ed/src%2Ftest%2Fui%2Fmacros%2Fauxiliary%2Fproc_macro_sequence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da7098116256d1e652284db4aa3815ff26105ed/src%2Ftest%2Fui%2Fmacros%2Fauxiliary%2Fproc_macro_sequence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fauxiliary%2Fproc_macro_sequence.rs?ref=0da7098116256d1e652284db4aa3815ff26105ed", "patch": "@@ -6,7 +6,7 @@\n \n extern crate proc_macro;\n \n-use proc_macro::{quote, Span, TokenStream};\n+use proc_macro::{quote, Span, TokenStream, TokenTree};\n \n fn assert_same_span(a: Span, b: Span) {\n     assert_eq!(a.start(), b.start());\n@@ -24,12 +24,22 @@ pub fn make_foo(_: TokenStream) -> TokenStream {\n     };\n \n     // Check that all spans are equal.\n-    let mut span = None;\n+    // FIXME: `quote!` gives def-site spans to idents and literals,\n+    // but leaves (default) call-site spans on groups and punctuation.\n+    let mut span_call = None;\n+    let mut span_def = None;\n     for tt in result.clone() {\n-        match span {\n-            None => span = Some(tt.span()),\n-            Some(span) => assert_same_span(tt.span(), span),\n+        match tt {\n+            TokenTree::Ident(..) | TokenTree::Literal(..) => match span_def {\n+                None => span_def = Some(tt.span()),\n+                Some(span) => assert_same_span(tt.span(), span),\n+            }\n+            TokenTree::Punct(..) | TokenTree::Group(..) => match span_call {\n+                None => span_call = Some(tt.span()),\n+                Some(span) => assert_same_span(tt.span(), span),\n+            }\n         }\n+\n     }\n \n     result"}, {"sha": "0eef4a2a678b6b7bb51d8f3932e9e3d03e8bfab5", "filename": "src/test/ui/macros/same-sequence-span.stderr", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0da7098116256d1e652284db4aa3815ff26105ed/src%2Ftest%2Fui%2Fmacros%2Fsame-sequence-span.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0da7098116256d1e652284db4aa3815ff26105ed/src%2Ftest%2Fui%2Fmacros%2Fsame-sequence-span.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fsame-sequence-span.stderr?ref=0da7098116256d1e652284db4aa3815ff26105ed", "patch": "@@ -17,11 +17,15 @@ LL |                $(= $z:tt)*\n error: `$x:expr` may be followed by `$y:tt`, which is not allowed for `expr` fragments\n   --> $DIR/same-sequence-span.rs:20:1\n    |\n-LL | proc_macro_sequence::make_foo!();\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |   proc_macro_sequence::make_foo!();\n+   |   ^--------------------------------\n+   |   |\n+   |  _in this macro invocation\n    | |\n-   | not allowed after `expr` fragments\n-   | in this macro invocation\n+LL | |\n+LL | |\n+LL | | fn main() {}\n+...  |\n    |\n    = note: allowed there are: `=>`, `,` or `;`\n "}, {"sha": "055781d2c6048c01d4769f96695cc1224daae3ba", "filename": "src/test/ui/proc-macro/attributes-on-definitions.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0da7098116256d1e652284db4aa3815ff26105ed/src%2Ftest%2Fui%2Fproc-macro%2Fattributes-on-definitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da7098116256d1e652284db4aa3815ff26105ed/src%2Ftest%2Fui%2Fproc-macro%2Fattributes-on-definitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fattributes-on-definitions.rs?ref=0da7098116256d1e652284db4aa3815ff26105ed", "patch": "@@ -0,0 +1,12 @@\n+// check-pass\n+// aux-build:attributes-on-definitions.rs\n+\n+#![forbid(unsafe_code)]\n+\n+extern crate attributes_on_definitions;\n+\n+attributes_on_definitions::with_attrs!();\n+//~^ WARN use of deprecated item\n+// No errors about the use of unstable and unsafe code inside the macro.\n+\n+fn main() {}"}, {"sha": "c61e043b229713a03dcc03cad43fd0e250f41af3", "filename": "src/test/ui/proc-macro/attributes-on-definitions.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0da7098116256d1e652284db4aa3815ff26105ed/src%2Ftest%2Fui%2Fproc-macro%2Fattributes-on-definitions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0da7098116256d1e652284db4aa3815ff26105ed/src%2Ftest%2Fui%2Fproc-macro%2Fattributes-on-definitions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fattributes-on-definitions.stderr?ref=0da7098116256d1e652284db4aa3815ff26105ed", "patch": "@@ -0,0 +1,8 @@\n+warning: use of deprecated item 'attributes_on_definitions::with_attrs': test\n+  --> $DIR/attributes-on-definitions.rs:8:1\n+   |\n+LL | attributes_on_definitions::with_attrs!();\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(deprecated)]` on by default\n+"}, {"sha": "93a339840d6211e514a1a054783a69b17ff3aa31", "filename": "src/test/ui/proc-macro/auxiliary/attributes-on-definitions.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0da7098116256d1e652284db4aa3815ff26105ed/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fattributes-on-definitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da7098116256d1e652284db4aa3815ff26105ed/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fattributes-on-definitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fattributes-on-definitions.rs?ref=0da7098116256d1e652284db4aa3815ff26105ed", "patch": "@@ -0,0 +1,23 @@\n+// force-host\n+// no-prefer-dynamic\n+\n+#![feature(allow_internal_unsafe)]\n+#![feature(allow_internal_unstable)]\n+\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+use proc_macro::*;\n+\n+#[proc_macro]\n+#[allow_internal_unstable(proc_macro_internals)]\n+#[allow_internal_unsafe]\n+#[deprecated(since = \"1.0.0\", note = \"test\")]\n+pub fn with_attrs(_: TokenStream) -> TokenStream {\n+    \"\n+    extern crate proc_macro;\n+    use ::proc_macro::bridge;\n+\n+    fn contains_unsafe() { unsafe {} }\n+    \".parse().unwrap()\n+}"}, {"sha": "e7f705c7feb67142afd56c93d908df98d53e420f", "filename": "src/test/ui/proc-macro/multispan.stderr", "status": "modified", "additions": 105, "deletions": 28, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/0da7098116256d1e652284db4aa3815ff26105ed/src%2Ftest%2Fui%2Fproc-macro%2Fmultispan.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0da7098116256d1e652284db4aa3815ff26105ed/src%2Ftest%2Fui%2Fproc-macro%2Fmultispan.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fmultispan.stderr?ref=0da7098116256d1e652284db4aa3815ff26105ed", "patch": "@@ -1,8 +1,19 @@\n error: hello to you, too!\n-  --> $DIR/multispan.rs:14:5\n-   |\n-LL |     hello!(hi);\n-   |     ^^^^^^^^^^^ in this macro invocation\n+  --> $DIR/auxiliary/multispan.rs:31:1\n+   |\n+LL | / pub fn hello(input: TokenStream) -> TokenStream {\n+LL | |     if let Err(diag) = parse(input) {\n+LL | |         diag.emit();\n+LL | |     }\n+LL | |\n+LL | |     TokenStream::new()\n+LL | | }\n+   | |_^\n+   | \n+  ::: $DIR/multispan.rs:14:5\n+   |\n+LL |       hello!(hi);\n+   |       ----------- in this macro invocation\n    |\n note: found these 'hi's\n   --> $DIR/multispan.rs:14:12\n@@ -11,10 +22,21 @@ LL |     hello!(hi);\n    |            ^^\n \n error: hello to you, too!\n-  --> $DIR/multispan.rs:17:5\n-   |\n-LL |     hello!(hi hi);\n-   |     ^^^^^^^^^^^^^^ in this macro invocation\n+  --> $DIR/auxiliary/multispan.rs:31:1\n+   |\n+LL | / pub fn hello(input: TokenStream) -> TokenStream {\n+LL | |     if let Err(diag) = parse(input) {\n+LL | |         diag.emit();\n+LL | |     }\n+LL | |\n+LL | |     TokenStream::new()\n+LL | | }\n+   | |_^\n+   | \n+  ::: $DIR/multispan.rs:17:5\n+   |\n+LL |       hello!(hi hi);\n+   |       -------------- in this macro invocation\n    |\n note: found these 'hi's\n   --> $DIR/multispan.rs:17:12\n@@ -23,10 +45,21 @@ LL |     hello!(hi hi);\n    |            ^^ ^^\n \n error: hello to you, too!\n-  --> $DIR/multispan.rs:20:5\n-   |\n-LL |     hello!(hi hi hi);\n-   |     ^^^^^^^^^^^^^^^^^ in this macro invocation\n+  --> $DIR/auxiliary/multispan.rs:31:1\n+   |\n+LL | / pub fn hello(input: TokenStream) -> TokenStream {\n+LL | |     if let Err(diag) = parse(input) {\n+LL | |         diag.emit();\n+LL | |     }\n+LL | |\n+LL | |     TokenStream::new()\n+LL | | }\n+   | |_^\n+   | \n+  ::: $DIR/multispan.rs:20:5\n+   |\n+LL |       hello!(hi hi hi);\n+   |       ----------------- in this macro invocation\n    |\n note: found these 'hi's\n   --> $DIR/multispan.rs:20:12\n@@ -35,10 +68,21 @@ LL |     hello!(hi hi hi);\n    |            ^^ ^^ ^^\n \n error: hello to you, too!\n-  --> $DIR/multispan.rs:23:5\n-   |\n-LL |     hello!(hi hey hi yo hi beep beep hi hi);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ in this macro invocation\n+  --> $DIR/auxiliary/multispan.rs:31:1\n+   |\n+LL | / pub fn hello(input: TokenStream) -> TokenStream {\n+LL | |     if let Err(diag) = parse(input) {\n+LL | |         diag.emit();\n+LL | |     }\n+LL | |\n+LL | |     TokenStream::new()\n+LL | | }\n+   | |_^\n+   | \n+  ::: $DIR/multispan.rs:23:5\n+   |\n+LL |       hello!(hi hey hi yo hi beep beep hi hi);\n+   |       ---------------------------------------- in this macro invocation\n    |\n note: found these 'hi's\n   --> $DIR/multispan.rs:23:12\n@@ -47,10 +91,21 @@ LL |     hello!(hi hey hi yo hi beep beep hi hi);\n    |            ^^     ^^    ^^           ^^ ^^\n \n error: hello to you, too!\n-  --> $DIR/multispan.rs:24:5\n-   |\n-LL |     hello!(hi there, hi how are you? hi... hi.);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ in this macro invocation\n+  --> $DIR/auxiliary/multispan.rs:31:1\n+   |\n+LL | / pub fn hello(input: TokenStream) -> TokenStream {\n+LL | |     if let Err(diag) = parse(input) {\n+LL | |         diag.emit();\n+LL | |     }\n+LL | |\n+LL | |     TokenStream::new()\n+LL | | }\n+   | |_^\n+   | \n+  ::: $DIR/multispan.rs:24:5\n+   |\n+LL |       hello!(hi there, hi how are you? hi... hi.);\n+   |       -------------------------------------------- in this macro invocation\n    |\n note: found these 'hi's\n   --> $DIR/multispan.rs:24:12\n@@ -59,10 +114,21 @@ LL |     hello!(hi there, hi how are you? hi... hi.);\n    |            ^^        ^^              ^^    ^^\n \n error: hello to you, too!\n-  --> $DIR/multispan.rs:25:5\n-   |\n-LL |     hello!(whoah. hi di hi di ho);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ in this macro invocation\n+  --> $DIR/auxiliary/multispan.rs:31:1\n+   |\n+LL | / pub fn hello(input: TokenStream) -> TokenStream {\n+LL | |     if let Err(diag) = parse(input) {\n+LL | |         diag.emit();\n+LL | |     }\n+LL | |\n+LL | |     TokenStream::new()\n+LL | | }\n+   | |_^\n+   | \n+  ::: $DIR/multispan.rs:25:5\n+   |\n+LL |       hello!(whoah. hi di hi di ho);\n+   |       ------------------------------ in this macro invocation\n    |\n note: found these 'hi's\n   --> $DIR/multispan.rs:25:19\n@@ -71,10 +137,21 @@ LL |     hello!(whoah. hi di hi di ho);\n    |                   ^^    ^^\n \n error: hello to you, too!\n-  --> $DIR/multispan.rs:26:5\n-   |\n-LL |     hello!(hi good hi and good bye);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ in this macro invocation\n+  --> $DIR/auxiliary/multispan.rs:31:1\n+   |\n+LL | / pub fn hello(input: TokenStream) -> TokenStream {\n+LL | |     if let Err(diag) = parse(input) {\n+LL | |         diag.emit();\n+LL | |     }\n+LL | |\n+LL | |     TokenStream::new()\n+LL | | }\n+   | |_^\n+   | \n+  ::: $DIR/multispan.rs:26:5\n+   |\n+LL |       hello!(hi good hi and good bye);\n+   |       -------------------------------- in this macro invocation\n    |\n note: found these 'hi's\n   --> $DIR/multispan.rs:26:12"}, {"sha": "0698b0f47542409f6b8d638c964e429d9786d8c3", "filename": "src/test/ui/proc-macro/three-equals.stderr", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0da7098116256d1e652284db4aa3815ff26105ed/src%2Ftest%2Fui%2Fproc-macro%2Fthree-equals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0da7098116256d1e652284db4aa3815ff26105ed/src%2Ftest%2Fui%2Fproc-macro%2Fthree-equals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fthree-equals.stderr?ref=0da7098116256d1e652284db4aa3815ff26105ed", "patch": "@@ -1,8 +1,19 @@\n error: found 2 equal signs, need exactly 3\n-  --> $DIR/three-equals.rs:15:5\n-   |\n-LL |     three_equals!(==);\n-   |     ^^^^^^^^^^^^^^^^^^ in this macro invocation\n+  --> $DIR/auxiliary/three-equals.rs:42:1\n+   |\n+LL | / pub fn three_equals(input: TokenStream) -> TokenStream {\n+LL | |     if let Err(diag) = parse(input) {\n+LL | |         diag.emit();\n+LL | |         return TokenStream::new();\n+...  |\n+LL | |     \"3\".parse().unwrap()\n+LL | | }\n+   | |_^\n+   | \n+  ::: $DIR/three-equals.rs:15:5\n+   |\n+LL |       three_equals!(==);\n+   |       ------------------ in this macro invocation\n    |\n    = help: input must be: `===`\n "}]}