{"sha": "03e9dac09a737f47f1ce75b12826cebe320f2f77", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzZTlkYWMwOWE3MzdmNDdmMWNlNzViMTI4MjZjZWJlMzIwZjJmNzc=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-27T12:17:06Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-27T12:20:36Z"}, "message": "Move various trans_ modules under a trans:: umbrella module\n\nCloses #1304", "tree": {"sha": "21f0a95f87ebcc7f40531e8bf8d21973881ab53e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/21f0a95f87ebcc7f40531e8bf8d21973881ab53e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/03e9dac09a737f47f1ce75b12826cebe320f2f77", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/03e9dac09a737f47f1ce75b12826cebe320f2f77", "html_url": "https://github.com/rust-lang/rust/commit/03e9dac09a737f47f1ce75b12826cebe320f2f77", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/03e9dac09a737f47f1ce75b12826cebe320f2f77/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b3f06c7d5476e7a53d83e2e6fc126c07af39d73c", "url": "https://api.github.com/repos/rust-lang/rust/commits/b3f06c7d5476e7a53d83e2e6fc126c07af39d73c", "html_url": "https://github.com/rust-lang/rust/commit/b3f06c7d5476e7a53d83e2e6fc126c07af39d73c"}], "stats": {"total": 415, "additions": 203, "deletions": 212}, "files": [{"sha": "068c8fddb334907b417325b3c97d39d1250181a3", "filename": "src/comp/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03e9dac09a737f47f1ce75b12826cebe320f2f77/src%2Fcomp%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03e9dac09a737f47f1ce75b12826cebe320f2f77/src%2Fcomp%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Flink.rs?ref=03e9dac09a737f47f1ce75b12826cebe320f2f77", "patch": "@@ -5,7 +5,7 @@ import lib::llvm::llvm;\n import front::attr;\n import middle::ty;\n import metadata::{encoder, cstore};\n-import middle::trans_common::crate_ctxt;\n+import middle::trans::common::crate_ctxt;\n import str;\n import std::fs;\n import vec;"}, {"sha": "098ed43750ed0cdb002ce5c8f4c2cac89c5e93f2", "filename": "src/comp/back/upcall.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/03e9dac09a737f47f1ce75b12826cebe320f2f77/src%2Fcomp%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03e9dac09a737f47f1ce75b12826cebe320f2f77/src%2Fcomp%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fupcall.rs?ref=03e9dac09a737f47f1ce75b12826cebe320f2f77", "patch": "@@ -1,10 +1,10 @@\n \n import driver::session;\n-import middle::trans;\n-import middle::trans_common::{T_fn, T_i1, T_i8, T_i32,\n-                              T_int, T_nil, T_dict,\n-                              T_opaque_vec, T_ptr,\n-                              T_size_t, T_void};\n+import middle::trans::base;\n+import middle::trans::common::{T_fn, T_i1, T_i8, T_i32,\n+                               T_int, T_nil, T_dict,\n+                               T_opaque_vec, T_ptr,\n+                               T_size_t, T_void};\n import lib::llvm::type_names;\n import lib::llvm::llvm::ModuleRef;\n import lib::llvm::llvm::ValueRef;\n@@ -42,7 +42,7 @@ fn declare_upcalls(targ_cfg: @session::config,\n         let arg_tys: [TypeRef] = [];\n         for t: TypeRef in tys { arg_tys += [t]; }\n         let fn_ty = T_fn(arg_tys, rv);\n-        ret trans::decl_cdecl_fn(llmod, \"upcall_\" + name, fn_ty);\n+        ret base::decl_cdecl_fn(llmod, \"upcall_\" + name, fn_ty);\n     }\n     let d = bind decl(llmod, _, _, _);\n     let dv = bind decl(llmod, _, _, T_void());"}, {"sha": "75749722823d941c20f0bf7dd925e0ef418cb83d", "filename": "src/comp/driver/driver.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/03e9dac09a737f47f1ce75b12826cebe320f2f77/src%2Fcomp%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03e9dac09a737f47f1ce75b12826cebe320f2f77/src%2Fcomp%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Fdriver.rs?ref=03e9dac09a737f47f1ce75b12826cebe320f2f77", "patch": "@@ -177,10 +177,10 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n \n     let (llmod, link_meta) =\n         time(time_passes, \"translation\",\n-             bind trans::trans_crate(sess, crate, ty_cx,\n-                                     outputs.obj_filename, exp_map, ast_map,\n-                                     mut_map, copy_map, last_uses, impl_map,\n-                                     method_map, dict_map));\n+             bind trans::base::trans_crate(\n+                 sess, crate, ty_cx, outputs.obj_filename, exp_map, ast_map,\n+                 mut_map, copy_map, last_uses, impl_map, method_map,\n+                 dict_map));\n     time(time_passes, \"LLVM passes\",\n          bind link::write::run_passes(sess, llmod, outputs.obj_filename));\n "}, {"sha": "b7b4d97fc211f1478e4c0c0ce7a8ba663a09513f", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03e9dac09a737f47f1ce75b12826cebe320f2f77/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03e9dac09a737f47f1ce75b12826cebe320f2f77/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=03e9dac09a737f47f1ce75b12826cebe320f2f77", "patch": "@@ -6,7 +6,7 @@ import syntax::ast::*;\n import syntax::ast_util;\n import syntax::ast_util::local_def;\n import common::*;\n-import middle::trans_common::crate_ctxt;\n+import middle::trans::common::crate_ctxt;\n import middle::ty;\n import middle::ty::node_id_to_monotype;\n import front::attr;"}, {"sha": "eb7ebbb0d04f4284816d4d9bc74499f7dcce85a4", "filename": "src/comp/middle/debuginfo.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/03e9dac09a737f47f1ce75b12826cebe320f2f77/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03e9dac09a737f47f1ce75b12826cebe320f2f77/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs?ref=03e9dac09a737f47f1ce75b12826cebe320f2f77", "patch": "@@ -3,8 +3,9 @@ import std::fs;\n import std::map::hashmap;\n import lib::llvm::llvm;\n import lib::llvm::llvm::ValueRef;\n-import middle::trans_common::*;\n-import middle::trans_build::B;\n+import trans::common::*;\n+import trans::base;\n+import trans::build::B;\n import middle::ty;\n import syntax::{ast, codemap};\n import codemap::span;\n@@ -84,7 +85,7 @@ fn add_named_metadata(cx: @crate_ctxt, name: str, val: ValueRef) {\n \n type debug_ctxt = {\n     llmetadata: metadata_cache,\n-    names: trans_common::namegen\n+    names: namegen\n };\n \n fn update_cache(cache: metadata_cache, mdtag: int, val: debug_metadata) {\n@@ -239,8 +240,8 @@ fn create_block(cx: @block_ctxt, sp: span) -> @metadata<block_md> {\n     }\n \n     let parent = alt cx.parent {\n-      trans_common::parent_none { create_function(cx.fcx, sp).node }\n-      trans_common::parent_some(bcx) { create_block(cx, sp).node }\n+      parent_none { create_function(cx.fcx, sp).node }\n+      parent_some(bcx) { create_block(cx, sp).node }\n     };\n     let file_node = create_file(bcx_ccx(cx), fname);\n     let unique_id = alt cache.find(LexicalBlockTag) {\n@@ -637,12 +638,12 @@ fn create_local_var(bcx: @block_ctxt, local: @ast::local)\n     });\n     let loc = codemap::lookup_char_pos(cx.sess.codemap,\n                                        local.span.lo);\n-    let ty = trans::node_id_type(cx, local.node.id);\n+    let ty = base::node_id_type(cx, local.node.id);\n     let tymd = create_ty(cx, ty, local.node.ty);\n     let filemd = create_file(cx, loc.filename);\n     let context = alt bcx.parent {\n-      trans_common::parent_none { create_function(bcx.fcx, local.span).node }\n-      trans_common::parent_some(_) { create_block(bcx, local.span).node }\n+      parent_none { create_function(bcx.fcx, local.span).node }\n+      parent_some(_) { create_block(bcx, local.span).node }\n     };\n     let mdnode = create_var(tg, context, name, filemd.node,\n                             loc.line as int, tymd.node);\n@@ -658,8 +659,8 @@ fn create_local_var(bcx: @block_ctxt, local: @ast::local)\n       }\n     };\n     let declargs = [llmdnode([llptr]), mdnode];\n-    trans_build::Call(bcx, cx.intrinsics.get(\"llvm.dbg.declare\"),\n-                      declargs);\n+    trans::build::Call(bcx, cx.intrinsics.get(\"llvm.dbg.declare\"),\n+                       declargs);\n     ret mdval;\n }\n \n@@ -680,7 +681,7 @@ fn create_arg(bcx: @block_ctxt, arg: ast::arg, sp: span)\n     };*/\n     let loc = codemap::lookup_char_pos(cx.sess.codemap,\n                                        sp.lo);\n-    let ty = trans::node_id_type(cx, arg.id);\n+    let ty = base::node_id_type(cx, arg.id);\n     let tymd = create_ty(cx, ty, arg.ty);\n     let filemd = create_file(cx, loc.filename);\n     let context = create_function(bcx.fcx, sp);\n@@ -693,8 +694,8 @@ fn create_arg(bcx: @block_ctxt, arg: ast::arg, sp: span)\n       local_mem(v) | local_imm(v) { v }\n     };\n     let declargs = [llmdnode([llptr]), mdnode];\n-    trans_build::Call(bcx, cx.intrinsics.get(\"llvm.dbg.declare\"),\n-                      declargs);\n+    trans::build::Call(bcx, cx.intrinsics.get(\"llvm.dbg.declare\"),\n+                       declargs);\n     ret mdval;\n }\n \n@@ -710,7 +711,7 @@ fn update_source_pos(cx: @block_ctxt, s: span) {\n                      blockmd.node,\n                      llnull()];\n     let dbgscope = llmdnode(scopedata);\n-    llvm::LLVMSetCurrentDebugLocation(trans_build::B(cx), dbgscope);\n+    llvm::LLVMSetCurrentDebugLocation(trans::build::B(cx), dbgscope);\n }\n \n fn create_function(fcx: @fn_ctxt, sp: span) -> @metadata<subprogram_md> {"}, {"sha": "4bcc2a29d38f699829e180094552a9a8f7703242", "filename": "src/comp/middle/gc.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/03e9dac09a737f47f1ce75b12826cebe320f2f77/src%2Fcomp%2Fmiddle%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03e9dac09a737f47f1ce75b12826cebe320f2f77/src%2Fcomp%2Fmiddle%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fgc.rs?ref=03e9dac09a737f47f1ce75b12826cebe320f2f77", "patch": "@@ -2,16 +2,15 @@\n \n import lib::llvm::True;\n import lib::llvm::llvm::ValueRef;\n-import middle::trans;\n-import middle::trans::get_tydesc;\n-import middle::trans_common::*;\n-import middle::ty;\n+import trans::base::get_tydesc;\n+import trans::common::*;\n+import trans::base;\n import option::none;\n import str;\n import driver::session::session;\n \n import lll = lib::llvm::llvm;\n-import bld = trans_build;\n+import bld = trans::build;\n \n type ctxt = @{mutable next_tydesc_num: uint};\n \n@@ -40,7 +39,7 @@ fn add_gc_root(cx: @block_ctxt, llval: ValueRef, ty: ty::t) -> @block_ctxt {\n \n     // FIXME (issue #839): For now, we are unconditionally zeroing out all\n     // GC-relevant types. Eventually we should use typestate for this.\n-    bcx = trans::zero_alloca(bcx, llval, ty);\n+    bcx = base::zero_alloca(bcx, llval, ty);\n \n     let ti = none;\n     let td_r = get_tydesc(bcx, ty, false, ti);\n@@ -53,10 +52,10 @@ fn add_gc_root(cx: @block_ctxt, llval: ValueRef, ty: ty::t) -> @block_ctxt {\n     alt td_r.kind {\n       tk_derived {\n         // It's a derived type descriptor. First, spill it.\n-        let lltydescptr = trans::alloca(bcx, val_ty(lltydesc));\n+        let lltydescptr = base::alloca(bcx, val_ty(lltydesc));\n \n         let llderivedtydescs =\n-            trans::llderivedtydescs_block_ctxt(bcx_fcx(bcx));\n+            base::llderivedtydescs_block_ctxt(bcx_fcx(bcx));\n         bld::Store(llderivedtydescs, lltydesc, lltydescptr);\n \n         let number = gc_cx.next_tydesc_num;"}, {"sha": "7612148df4534e3e9218ad4f7047a487493745e0", "filename": "src/comp/middle/shape.rs", "status": "modified", "additions": 26, "deletions": 29, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/03e9dac09a737f47f1ce75b12826cebe320f2f77/src%2Fcomp%2Fmiddle%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03e9dac09a737f47f1ce75b12826cebe320f2f77/src%2Fcomp%2Fmiddle%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fshape.rs?ref=03e9dac09a737f47f1ce75b12826cebe320f2f77", "patch": "@@ -6,20 +6,20 @@ import lib::llvm::{True, False};\n import lib::llvm::llvm::{ModuleRef, TypeRef, ValueRef};\n import driver::session;\n import driver::session::session;\n-import middle::{trans, trans_common};\n-import middle::trans_common::{crate_ctxt, val_ty, C_bytes, C_int,\n-                              C_named_struct, C_struct, T_enum_variant,\n-                              block_ctxt, result, rslt, bcx_ccx, bcx_tcx,\n-                              type_has_static_size, umax, umin, align_to,\n-                              tydesc_info};\n+import trans::base;\n+import middle::trans::common::{crate_ctxt, val_ty, C_bytes, C_int,\n+                               C_named_struct, C_struct, T_enum_variant,\n+                               block_ctxt, result, rslt, bcx_ccx, bcx_tcx,\n+                               type_has_static_size, umax, umin, align_to,\n+                               tydesc_info};\n import back::abi;\n import middle::ty;\n import middle::ty::field;\n import syntax::ast;\n import syntax::ast_util::dummy_sp;\n import syntax::util::interner;\n import util::common;\n-import trans_build::{Load, Store, Add, GEPi};\n+import trans::build::{Load, Store, Add, GEPi};\n import syntax::codemap::span;\n \n import core::{vec, str};\n@@ -68,7 +68,7 @@ const shape_tydesc: u8 = 28u8;\n const shape_send_tydesc: u8 = 29u8;\n \n // FIXME: This is a bad API in trans_common.\n-fn C_u8(n: u8) -> ValueRef { ret trans_common::C_u8(n as uint); }\n+fn C_u8(n: u8) -> ValueRef { ret trans::common::C_u8(n as uint); }\n \n fn hash_res_info(ri: res_info) -> uint {\n     let h = 5381u;\n@@ -134,8 +134,8 @@ fn largest_variants(ccx: @crate_ctxt, tag_id: ast::def_id) -> [uint] {\n                 // follow from how elem_t doesn't contain params.\n                 // (Could add a postcondition to type_contains_params,\n                 // once we implement Issue #586.)\n-                check (trans_common::type_has_static_size(ccx, elem_t));\n-                let llty = trans::type_of(ccx, elem_t);\n+                check (trans::common::type_has_static_size(ccx, elem_t));\n+                let llty = base::type_of(ccx, elem_t);\n                 min_size += llsize_of_real(ccx, llty);\n                 min_align += llalign_of_real(ccx, llty);\n             }\n@@ -213,11 +213,11 @@ fn compute_static_enum_size(ccx: @crate_ctxt, largest_variants: [uint],\n             // FIXME: there should really be a postcondition\n             // on enum_variants that would obviate the need for\n             // this check. (Issue #586)\n-            check (trans_common::type_has_static_size(ccx, typ));\n-            lltys += [trans::type_of(ccx, typ)];\n+            check (trans::common::type_has_static_size(ccx, typ));\n+            lltys += [base::type_of(ccx, typ)];\n         }\n \n-        let llty = trans_common::T_struct(lltys);\n+        let llty = trans::common::T_struct(lltys);\n         let dp = llsize_of_real(ccx, llty) as u16;\n         let variant_align = llalign_of_real(ccx, llty) as u8;\n \n@@ -294,13 +294,10 @@ fn s_send_tydesc(_tcx: ty_ctxt) -> u8 {\n }\n \n fn mk_ctxt(llmod: ModuleRef) -> ctxt {\n-    let llshapetablesty = trans_common::T_named_struct(\"shapes\");\n-    let llshapetables =\n-        str::as_buf(\"shapes\",\n-                    {|buf|\n-                        lib::llvm::llvm::LLVMAddGlobal(llmod, llshapetablesty,\n-                                                       buf)\n-                    });\n+    let llshapetablesty = trans::common::T_named_struct(\"shapes\");\n+    let llshapetables = str::as_buf(\"shapes\", {|buf|\n+        lib::llvm::llvm::LLVMAddGlobal(llmod, llshapetablesty, buf)\n+    });\n \n     ret {mutable next_tag_id: 0u16,\n          pad: 0u16,\n@@ -584,7 +581,7 @@ fn gen_resource_shapes(ccx: @crate_ctxt) -> ValueRef {\n     let len = interner::len(ccx.shape_cx.resources);\n     while i < len {\n         let ri = interner::get(ccx.shape_cx.resources, i);\n-        dtors += [trans_common::get_res_dtor(ccx, ri.did, ri.t)];\n+        dtors += [trans::common::get_res_dtor(ccx, ri.did, ri.t)];\n         i += 1u;\n     }\n \n@@ -594,9 +591,9 @@ fn gen_resource_shapes(ccx: @crate_ctxt) -> ValueRef {\n fn gen_shape_tables(ccx: @crate_ctxt) {\n     let lltagstable = gen_enum_shapes(ccx);\n     let llresourcestable = gen_resource_shapes(ccx);\n-    trans_common::set_struct_body(ccx.shape_cx.llshapetablesty,\n-                                  [val_ty(lltagstable),\n-                                   val_ty(llresourcestable)]);\n+    trans::common::set_struct_body(ccx.shape_cx.llshapetablesty,\n+                                   [val_ty(lltagstable),\n+                                    val_ty(llresourcestable)]);\n \n     let lltables =\n         C_named_struct(ccx.shape_cx.llshapetablesty,\n@@ -627,7 +624,7 @@ type tag_metrics = {\n fn size_of(bcx: @block_ctxt, t: ty::t) -> result {\n     let ccx = bcx_ccx(bcx);\n     if check type_has_static_size(ccx, t) {\n-        rslt(bcx, llsize_of(ccx, trans::type_of(ccx, t)))\n+        rslt(bcx, llsize_of(ccx, base::type_of(ccx, t)))\n     } else {\n         let { bcx, sz, align: _ } = dynamic_metrics(bcx, t);\n         rslt(bcx, sz)\n@@ -637,7 +634,7 @@ fn size_of(bcx: @block_ctxt, t: ty::t) -> result {\n fn align_of(bcx: @block_ctxt, t: ty::t) -> result {\n     let ccx = bcx_ccx(bcx);\n     if check type_has_static_size(ccx, t) {\n-        rslt(bcx, llalign_of(ccx, trans::type_of(ccx, t)))\n+        rslt(bcx, llalign_of(ccx, base::type_of(ccx, t)))\n     } else {\n         let { bcx, sz: _, align } = dynamic_metrics(bcx, t);\n         rslt(bcx, align)\n@@ -647,7 +644,7 @@ fn align_of(bcx: @block_ctxt, t: ty::t) -> result {\n fn metrics(bcx: @block_ctxt, t: ty::t) -> metrics {\n     let ccx = bcx_ccx(bcx);\n     if check type_has_static_size(ccx, t) {\n-        let llty = trans::type_of(ccx, t);\n+        let llty = base::type_of(ccx, t);\n         { bcx: bcx, sz: llsize_of(ccx, llty), align: llalign_of(ccx, llty) }\n     } else {\n         dynamic_metrics(bcx, t)\n@@ -696,7 +693,7 @@ fn static_size_of_enum(cx: @crate_ctxt, t: ty::t)\n             // express that with constrained types.\n             check (type_has_static_size(cx, tup_ty));\n             let this_size =\n-                llsize_of_real(cx, trans::type_of(cx, tup_ty));\n+                llsize_of_real(cx, base::type_of(cx, tup_ty));\n             if max_size < this_size { max_size = this_size; }\n         }\n         cx.enum_sizes.insert(t, max_size);\n@@ -735,7 +732,7 @@ fn dynamic_metrics(cx: @block_ctxt, t: ty::t) -> metrics {\n     alt ty::struct(bcx_tcx(cx), t) {\n       ty::ty_param(p, _) {\n         let ti = none::<@tydesc_info>;\n-        let {bcx, val: tydesc} = trans::get_tydesc(cx, t, false, ti).result;\n+        let {bcx, val: tydesc} = base::get_tydesc(cx, t, false, ti).result;\n         let szptr = GEPi(bcx, tydesc, [0, abi::tydesc_field_size]);\n         let aptr = GEPi(bcx, tydesc, [0, abi::tydesc_field_align]);\n         {bcx: bcx, sz: Load(bcx, szptr), align: Load(bcx, aptr)}"}, {"sha": "9cca779a37b783ca4f4ead3d1f81933bf1187372", "filename": "src/comp/middle/trans/alt.rs", "status": "renamed", "additions": 38, "deletions": 39, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/03e9dac09a737f47f1ce75b12826cebe320f2f77/src%2Fcomp%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03e9dac09a737f47f1ce75b12826cebe320f2f77/src%2Fcomp%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Falt.rs?ref=03e9dac09a737f47f1ce75b12826cebe320f2f77", "patch": "@@ -5,16 +5,16 @@ import driver::session::session;\n import lib::llvm::llvm;\n import lib::llvm::llvm::{ValueRef, BasicBlockRef};\n import pat_util::*;\n-import trans_build::*;\n-import trans::{new_sub_block_ctxt, new_scope_block_ctxt, load_if_immediate};\n+import build::*;\n+import base::{new_sub_block_ctxt, new_scope_block_ctxt, load_if_immediate};\n import syntax::ast;\n import syntax::ast_util;\n import syntax::ast_util::{dummy_sp};\n import syntax::ast::def_id;\n import syntax::codemap::span;\n import syntax::print::pprust::pat_to_str;\n \n-import trans_common::*;\n+import common::*;\n \n // An option identifying a branch (either a literal, a enum variant or a\n // range)\n@@ -46,21 +46,21 @@ fn trans_opt(bcx: @block_ctxt, o: opt) -> opt_result {\n         alt l.node {\n           ast::expr_lit(@{node: ast::lit_str(s), _}) {\n             let strty = ty::mk_str(bcx_tcx(bcx));\n-            let cell = trans::empty_dest_cell();\n-            bcx = trans_vec::trans_str(bcx, s, trans::by_val(cell));\n+            let cell = base::empty_dest_cell();\n+            bcx = tvec::trans_str(bcx, s, base::by_val(cell));\n             add_clean_temp(bcx, *cell, strty);\n             ret single_result(rslt(bcx, *cell));\n           }\n           _ {\n             ret single_result(\n-                rslt(bcx, trans::trans_const_expr(ccx, l)));\n+                rslt(bcx, base::trans_const_expr(ccx, l)));\n           }\n         }\n       }\n       var(disr_val, _) { ret single_result(rslt(bcx, C_int(ccx, disr_val))); }\n       range(l1, l2) {\n-        ret range_result(rslt(bcx, trans::trans_const_expr(ccx, l1)),\n-                         rslt(bcx, trans::trans_const_expr(ccx, l2)));\n+        ret range_result(rslt(bcx, base::trans_const_expr(ccx, l1)),\n+                         rslt(bcx, base::trans_const_expr(ccx, l2)));\n       }\n     }\n }\n@@ -274,7 +274,7 @@ fn extract_variant_args(bcx: @block_ctxt, pat_id: ast::node_id,\n         vec::len(ty::enum_variant_with_id(ccx.tcx, vdefs.tg, vdefs.var).args);\n     if size > 0u && vec::len(*variants) != 1u {\n         let enumptr =\n-            PointerCast(bcx, val, trans_common::T_opaque_enum_ptr(ccx));\n+            PointerCast(bcx, val, T_opaque_enum_ptr(ccx));\n         blobptr = GEPi(bcx, enumptr, [0, 1]);\n     }\n     let i = 0u;\n@@ -286,7 +286,7 @@ fn extract_variant_args(bcx: @block_ctxt, pat_id: ast::node_id,\n             // invariant needed:\n             // how do we know it even makes sense to pass in ty_param_substs\n             // here? What if it's [] and the enum type has variables in it?\n-            trans::GEP_enum(bcx, blobptr, vdefs_tg, vdefs_var,\n+            base::GEP_enum(bcx, blobptr, vdefs_tg, vdefs_var,\n                             ty_param_substs, i);\n         bcx = r.bcx;\n         args += [r.val];\n@@ -381,8 +381,8 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n                 bcx.fcx.lllocals.insert(val, local);\n             };\n             let {bcx: guard_bcx, val: guard_val} =\n-                trans::trans_temp_expr(guard_cx, e);\n-            guard_bcx = trans::trans_block_cleanups(guard_bcx, guard_cx);\n+                base::trans_temp_expr(guard_cx, e);\n+            guard_bcx = base::trans_block_cleanups(guard_bcx, guard_cx);\n             let next_cx = new_sub_block_ctxt(guard_cx, \"submatch_next\");\n             let else_cx = new_sub_block_ctxt(guard_cx, \"submatch_else\");\n             CondBr(guard_bcx, guard_val, next_cx.llbb, else_cx.llbb);\n@@ -426,7 +426,7 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n             let ix = option::get(ty::field_idx(field_name, fields));\n             // not sure how to get rid of this check\n             check type_is_tup_like(bcx, rec_ty);\n-            let r = trans::GEP_tup_like(bcx, rec_ty, val, [0, ix as int]);\n+            let r = base::GEP_tup_like(bcx, rec_ty, val, [0, ix as int]);\n             rec_vals += [r.val];\n             bcx = r.bcx;\n         }\n@@ -445,7 +445,7 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n         while i < n_tup_elts {\n             // how to get rid of this check?\n             check type_is_tup_like(bcx, tup_ty);\n-            let r = trans::GEP_tup_like(bcx, tup_ty, val, [0, i as int]);\n+            let r = base::GEP_tup_like(bcx, tup_ty, val, [0, i as int]);\n             tup_vals += [r.val];\n             bcx = r.bcx;\n             i += 1u;\n@@ -483,8 +483,7 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n                 kind = single;\n             } else {\n                 let enumptr =\n-                    PointerCast(bcx, val,\n-                                trans_common::T_opaque_enum_ptr(ccx));\n+                    PointerCast(bcx, val, T_opaque_enum_ptr(ccx));\n                 let discrimptr = GEPi(bcx, enumptr, [0, 0]);\n                 test_val = Load(bcx, discrimptr);\n                 kind = switch;\n@@ -546,22 +545,22 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n               single_result(r) {\n                 bcx = r.bcx;\n                 let eq =\n-                    trans::trans_compare(bcx, ast::eq, test_val, t, r.val, t);\n-                let cleanup_cx = trans::trans_block_cleanups(\n+                    base::trans_compare(bcx, ast::eq, test_val, t, r.val, t);\n+                let cleanup_cx = base::trans_block_cleanups(\n                     eq.bcx, compare_cx);\n                 bcx = new_sub_block_ctxt(bcx, \"compare_next\");\n                 CondBr(cleanup_cx, eq.val, opt_cx.llbb, bcx.llbb);\n               }\n               range_result(rbegin, rend) {\n                 bcx = rend.bcx;\n-                let ge = trans::trans_compare(bcx, ast::ge, test_val, t,\n+                let ge = base::trans_compare(bcx, ast::ge, test_val, t,\n                                               rbegin.val, t);\n-                let le = trans::trans_compare(ge.bcx, ast::le, test_val, t,\n+                let le = base::trans_compare(ge.bcx, ast::le, test_val, t,\n                                               rend.val, t);\n                 let in_range = rslt(le.bcx, And(le.bcx, ge.val, le.val));\n                 bcx = in_range.bcx;\n                 let cleanup_cx =\n-                    trans::trans_block_cleanups(bcx, compare_cx);\n+                    base::trans_block_cleanups(bcx, compare_cx);\n                 bcx = new_sub_block_ctxt(bcx, \"compare_next\");\n                 CondBr(cleanup_cx, in_range.val, opt_cx.llbb, bcx.llbb);\n               }\n@@ -621,8 +620,8 @@ fn make_phi_bindings(bcx: @block_ctxt, map: [exit_node],\n                   local_mem(x) { x }\n                 };\n                 let e_ty = ty::node_id_to_type(bcx_tcx(bcx), node_id);\n-                let {bcx: abcx, val: alloc} = trans::alloc_ty(bcx, e_ty);\n-                bcx = trans::copy_val(abcx, trans::INIT, alloc,\n+                let {bcx: abcx, val: alloc} = base::alloc_ty(bcx, e_ty);\n+                bcx = base::copy_val(abcx, base::INIT, alloc,\n                                       load_if_immediate(abcx, local, e_ty),\n                                       e_ty);\n                 add_clean(bcx, alloc, e_ty);\n@@ -636,13 +635,13 @@ fn make_phi_bindings(bcx: @block_ctxt, map: [exit_node],\n }\n \n fn trans_alt(cx: @block_ctxt, expr: @ast::expr, arms_: [ast::arm],\n-             dest: trans::dest) -> @block_ctxt {\n+             dest: base::dest) -> @block_ctxt {\n     let bodies = [];\n     let match: match = [];\n     let alt_cx = new_scope_block_ctxt(cx, \"alt\");\n     Br(cx, alt_cx.llbb);\n \n-    let er = trans::trans_temp_expr(alt_cx, expr);\n+    let er = base::trans_temp_expr(alt_cx, expr);\n     if er.bcx.unreachable { ret er.bcx; }\n \n     /*\n@@ -669,14 +668,14 @@ fn trans_alt(cx: @block_ctxt, expr: @ast::expr, arms_: [ast::arm],\n                done: @mutable option::t<BasicBlockRef>) -> BasicBlockRef {\n         alt *done { some(bb) { ret bb; } _ { } }\n         let fail_cx = new_sub_block_ctxt(cx, \"case_fallthrough\");\n-        trans::trans_fail(fail_cx, some(sp), \"non-exhaustive match failure\");;\n+        base::trans_fail(fail_cx, some(sp), \"non-exhaustive match failure\");;\n         *done = some(fail_cx.llbb);\n         ret fail_cx.llbb;\n     }\n \n     let exit_map = [];\n-    let t = trans::node_id_type(cx.fcx.lcx.ccx, expr.id);\n-    let vr = trans::spill_if_immediate(er.bcx, er.val, t);\n+    let t = base::node_id_type(cx.fcx.lcx.ccx, expr.id);\n+    let vr = base::spill_if_immediate(er.bcx, er.val, t);\n     compile_submatch(vr.bcx, match, [vr.val],\n                      bind mk_fail(alt_cx, expr.span, fail_cx), exit_map);\n \n@@ -686,14 +685,14 @@ fn trans_alt(cx: @block_ctxt, expr: @ast::expr, arms_: [ast::arm],\n         if make_phi_bindings(body_cx, exit_map,\n                              pat_util::pat_id_map(bcx_tcx(cx),\n                                                   a.pats[0])) {\n-            let arm_dest = trans::dup_for_join(dest);\n+            let arm_dest = base::dup_for_join(dest);\n             arm_dests += [arm_dest];\n-            arm_cxs += [trans::trans_block_dps(body_cx, a.body, arm_dest)];\n+            arm_cxs += [base::trans_block_dps(body_cx, a.body, arm_dest)];\n         }\n         i += 1u;\n     }\n-    let after_cx = trans::join_returns(cx, arm_cxs, arm_dests, dest);\n-    after_cx = trans::trans_block_cleanups(after_cx, alt_cx);\n+    let after_cx = base::join_returns(cx, arm_cxs, arm_dests, dest);\n+    after_cx = base::trans_block_cleanups(after_cx, alt_cx);\n     let next_cx = new_sub_block_ctxt(after_cx, \"next\");\n     Br(after_cx, next_cx.llbb);\n     ret next_cx;\n@@ -713,12 +712,12 @@ fn bind_irrefutable_pat(bcx: @block_ctxt, pat: @ast::pat, val: ValueRef,\n             // check unnecessary.\n             check (type_has_static_size(ccx, ty));\n             check non_ty_var(ccx, ty);\n-            let llty = trans::type_of(ccx, ty);\n-            let alloc = trans::alloca(bcx, llty);\n-            bcx = trans::copy_val(bcx, trans::INIT, alloc,\n-                                  trans::load_if_immediate(bcx, val, ty), ty);\n+            let llty = base::type_of(ccx, ty);\n+            let alloc = base::alloca(bcx, llty);\n+            bcx = base::copy_val(bcx, base::INIT, alloc,\n+                                  base::load_if_immediate(bcx, val, ty), ty);\n             bcx.fcx.lllocals.insert(pat.id, local_mem(alloc));\n-            trans_common::add_clean(bcx, alloc, ty);\n+            add_clean(bcx, alloc, ty);\n         } else { bcx.fcx.lllocals.insert(pat.id, local_mem(val)); }\n         alt inner {\n           some(pat) { bcx = bind_irrefutable_pat(bcx, pat, val, true); }\n@@ -743,7 +742,7 @@ fn bind_irrefutable_pat(bcx: @block_ctxt, pat: @ast::pat, val: ValueRef,\n             let ix = option::get(ty::field_idx(f.ident, rec_fields));\n             // how to get rid of this check?\n             check type_is_tup_like(bcx, rec_ty);\n-            let r = trans::GEP_tup_like(bcx, rec_ty, val, [0, ix as int]);\n+            let r = base::GEP_tup_like(bcx, rec_ty, val, [0, ix as int]);\n             bcx = bind_irrefutable_pat(r.bcx, f.pat, r.val, make_copy);\n         }\n       }\n@@ -753,7 +752,7 @@ fn bind_irrefutable_pat(bcx: @block_ctxt, pat: @ast::pat, val: ValueRef,\n         for elem in elems {\n             // how to get rid of this check?\n             check type_is_tup_like(bcx, tup_ty);\n-            let r = trans::GEP_tup_like(bcx, tup_ty, val, [0, i as int]);\n+            let r = base::GEP_tup_like(bcx, tup_ty, val, [0, i as int]);\n             bcx = bind_irrefutable_pat(r.bcx, elem, r.val, make_copy);\n             i += 1u;\n         }", "previous_filename": "src/comp/middle/trans_alt.rs"}, {"sha": "bcee44962caa4d20b4fb652da25b4495fe7dc9b1", "filename": "src/comp/middle/trans/base.rs", "status": "renamed", "additions": 43, "deletions": 46, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/03e9dac09a737f47f1ce75b12826cebe320f2f77/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03e9dac09a737f47f1ce75b12826cebe320f2f77/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs?ref=03e9dac09a737f47f1ce75b12826cebe320f2f77", "patch": "@@ -42,9 +42,8 @@ import link::{mangle_internal_name_by_type_only,\n import metadata::{csearch, cstore};\n import util::ppaux::{ty_to_str, ty_to_short_str};\n \n-import trans_common::*;\n-import trans_build::*;\n-import tvec = trans_vec;\n+import common::*;\n+import build::*;\n \n fn type_of_1(bcx: @block_ctxt, t: ty::t) -> TypeRef {\n     let cx = bcx_ccx(bcx);\n@@ -1243,8 +1242,8 @@ fn make_take_glue(cx: @block_ctxt, v: ValueRef, t: ty::t) {\n         incr_refcnt_of_boxed(bcx, Load(bcx, v))\n       }\n       ty::ty_uniq(_) {\n-        check trans_uniq::type_is_unique_box(bcx, t);\n-        let r = trans_uniq::duplicate(bcx, Load(bcx, v), t);\n+        check uniq::type_is_unique_box(bcx, t);\n+        let r = uniq::duplicate(bcx, Load(bcx, v), t);\n         Store(r.bcx, r.val, v);\n         r.bcx\n       }\n@@ -1262,10 +1261,10 @@ fn make_take_glue(cx: @block_ctxt, v: ValueRef, t: ty::t) {\n         bcx\n       }\n       ty::ty_fn(_) {\n-        trans_closure::make_fn_glue(bcx, v, t, take_ty)\n+        closure::make_fn_glue(bcx, v, t, take_ty)\n       }\n       ty::ty_opaque_closure_ptr(ck) {\n-        trans_closure::make_opaque_cbox_take_glue(bcx, ck, v)\n+        closure::make_opaque_cbox_take_glue(bcx, ck, v)\n       }\n       _ if ty::type_is_structural(bcx_tcx(bcx), t) {\n         iter_structural_ty(bcx, v, t, take_ty)\n@@ -1308,9 +1307,9 @@ fn make_free_glue(bcx: @block_ctxt, v: ValueRef, t: ty::t) {\n         free_box(bcx, v, t)\n       }\n       ty::ty_uniq(content_mt) {\n-        check trans_uniq::type_is_unique_box(bcx, t);\n+        check uniq::type_is_unique_box(bcx, t);\n         let v = PointerCast(bcx, v, type_of_1(bcx, t));\n-        trans_uniq::make_free_glue(bcx, v, t)\n+        uniq::make_free_glue(bcx, v, t)\n       }\n       ty::ty_vec(_) | ty::ty_str {\n         tvec::make_free_glue(bcx, PointerCast(bcx, v, type_of_1(bcx, t)), t)\n@@ -1338,10 +1337,10 @@ fn make_free_glue(bcx: @block_ctxt, v: ValueRef, t: ty::t) {\n         bcx\n       }\n       ty::ty_fn(_) {\n-        trans_closure::make_fn_glue(bcx, v, t, free_ty)\n+        closure::make_fn_glue(bcx, v, t, free_ty)\n       }\n       ty::ty_opaque_closure_ptr(ck) {\n-        trans_closure::make_opaque_cbox_free_glue(bcx, ck, v)\n+        closure::make_opaque_cbox_free_glue(bcx, ck, v)\n       }\n       _ { bcx }\n     };\n@@ -1363,10 +1362,10 @@ fn make_drop_glue(bcx: @block_ctxt, v0: ValueRef, t: ty::t) {\n             trans_res_drop(bcx, v0, did, inner, tps)\n           }\n           ty::ty_fn(_) {\n-            trans_closure::make_fn_glue(bcx, v0, t, drop_ty)\n+            closure::make_fn_glue(bcx, v0, t, drop_ty)\n           }\n           ty::ty_opaque_closure_ptr(ck) {\n-            trans_closure::make_opaque_cbox_drop_glue(bcx, ck, v0)\n+            closure::make_opaque_cbox_drop_glue(bcx, ck, v0)\n           }\n           _ {\n             if ty::type_needs_drop(ccx.tcx, t) &&\n@@ -1398,7 +1397,7 @@ fn trans_res_drop(cx: @block_ctxt, rs: ValueRef, did: ast::def_id,\n     let val = GEP_tup_like(cx, tup_ty, rs, [0, 1]);\n     cx = val.bcx;\n     // Find and call the actual destructor.\n-    let dtor_addr = trans_common::get_res_dtor(ccx, did, inner_t);\n+    let dtor_addr = common::get_res_dtor(ccx, did, inner_t);\n     let args = [cx.fcx.llretptr, null_env_ptr(cx)];\n     for tp: ty::t in tps {\n         let ti: option::t<@tydesc_info> = none;\n@@ -1865,8 +1864,8 @@ fn take_ty_immediate(bcx: @block_ctxt, v: ValueRef, t: ty::t) -> result {\n         rslt(incr_refcnt_of_boxed(bcx, v), v)\n       }\n       ty::ty_uniq(_) {\n-        check trans_uniq::type_is_unique_box(bcx, t);\n-        trans_uniq::duplicate(bcx, v, t)\n+        check uniq::type_is_unique_box(bcx, t);\n+        uniq::duplicate(bcx, v, t)\n       }\n       ty::ty_str | ty::ty_vec(_) { tvec::duplicate(bcx, v, t) }\n       _ { rslt(bcx, v) }\n@@ -2060,7 +2059,7 @@ fn trans_unary(bcx: @block_ctxt, op: ast::unop, e: @ast::expr,\n         let callee_id = ast_util::op_expr_callee_id(un_expr);\n         let fty = ty::node_id_to_monotype(bcx_tcx(bcx), callee_id);\n         ret trans_call_inner(bcx, fty, {|bcx|\n-            trans_impl::trans_method_callee(bcx, callee_id, e, origin)\n+            impl::trans_method_callee(bcx, callee_id, e, origin)\n         }, [], un_expr.id, dest);\n       }\n       _ {}\n@@ -2096,7 +2095,7 @@ fn trans_unary(bcx: @block_ctxt, op: ast::unop, e: @ast::expr,\n         ret store_in_dest(bcx, box, dest);\n       }\n       ast::uniq(_) {\n-        ret trans_uniq::trans_uniq(bcx, e, un_expr.id, dest);\n+        ret uniq::trans_uniq(bcx, e, un_expr.id, dest);\n       }\n       ast::deref {\n         bcx_ccx(bcx).sess.bug(\"deref expressions should have been \\\n@@ -2199,7 +2198,7 @@ fn trans_assign_op(bcx: @block_ctxt, ex: @ast::expr, op: ast::binop,\n         let fty = ty::node_id_to_monotype(bcx_tcx(bcx), callee_id);\n         ret trans_call_inner(bcx, fty, {|bcx|\n             // FIXME provide the already-computed address, not the expr\n-            trans_impl::trans_method_callee(bcx, callee_id, dst, origin)\n+            impl::trans_method_callee(bcx, callee_id, dst, origin)\n         }, [src], ex.id, save_in(lhs_res.val));\n       }\n       _ {}\n@@ -2251,8 +2250,8 @@ fn autoderef(cx: @block_ctxt, v: ValueRef, t: ty::t) -> result_t {\n             } else { v1 = body; }\n           }\n           ty::ty_uniq(_) {\n-            check trans_uniq::type_is_unique_box(cx, t1);\n-            let derefed = trans_uniq::autoderef(cx, v1, t1);\n+            check uniq::type_is_unique_box(cx, t1);\n+            let derefed = uniq::autoderef(cx, v1, t1);\n             t1 = derefed.t;\n             v1 = derefed.v;\n           }\n@@ -2320,7 +2319,7 @@ fn trans_binary(bcx: @block_ctxt, op: ast::binop, lhs: @ast::expr,\n         let callee_id = ast_util::op_expr_callee_id(ex);\n         let fty = ty::node_id_to_monotype(bcx_tcx(bcx), callee_id);\n         ret trans_call_inner(bcx, fty, {|bcx|\n-            trans_impl::trans_method_callee(bcx, callee_id, lhs, origin)\n+            impl::trans_method_callee(bcx, callee_id, lhs, origin)\n         }, [rhs], ex.id, dest);\n       }\n       _ {}\n@@ -2446,7 +2445,7 @@ fn trans_for(cx: @block_ctxt, local: @ast::local, seq: @ast::expr,\n                                       outer_next_cx, \"for loop scope\");\n         Br(bcx, scope_cx.llbb);\n         let curr = PointerCast(bcx, curr, T_ptr(type_of_or_i8(bcx, t)));\n-        let bcx = trans_alt::bind_irrefutable_pat(scope_cx, local.node.pat,\n+        let bcx = alt::bind_irrefutable_pat(scope_cx, local.node.pat,\n                                                   curr, false);\n         bcx = trans_block_dps(bcx, body, ignore);\n         Br(bcx, next_cx.llbb);\n@@ -2764,7 +2763,7 @@ fn trans_callee(bcx: @block_ctxt, e: @ast::expr) -> lval_maybe_callee {\n         if !expr_is_lval(bcx, e) {\n             alt bcx_ccx(bcx).method_map.find(e.id) {\n               some(origin) { // An impl method\n-                ret trans_impl::trans_method_callee(bcx, e.id, base, origin);\n+                ret impl::trans_method_callee(bcx, e.id, base, origin);\n               }\n             }\n         }\n@@ -2846,7 +2845,7 @@ fn lval_maybe_callee_to_lval(c: lval_maybe_callee, ty: ty::t) -> lval_result {\n         let n_args = vec::len(ty::ty_fn_args(bcx_tcx(c.bcx), ty));\n         let args = vec::init_elt(n_args, none::<@ast::expr>);\n         let space = alloc_ty(c.bcx, ty);\n-        let bcx = trans_closure::trans_bind_1(space.bcx, ty, c, args, ty,\n+        let bcx = closure::trans_bind_1(space.bcx, ty, c, args, ty,\n                                               save_in(space.val));\n         add_clean_temp(bcx, space.val, ty);\n         ret {bcx: bcx, val: space.val, kind: temporary};\n@@ -2887,7 +2886,7 @@ fn trans_cast(cx: @block_ctxt, e: @ast::expr, id: ast::node_id,\n     let ccx = bcx_ccx(cx);\n     let t_out = node_id_type(ccx, id);\n     alt ty::struct(ccx.tcx, t_out) {\n-      ty::ty_iface(_, _) { ret trans_impl::trans_cast(cx, e, id, dest); }\n+      ty::ty_iface(_, _) { ret impl::trans_cast(cx, e, id, dest); }\n       _ {}\n     }\n     let e_res = trans_temp_expr(cx, e);\n@@ -3065,7 +3064,7 @@ fn trans_args(cx: @block_ctxt, llenv: ValueRef,\n             for bound in *param {\n                 alt bound {\n                   ty::bound_iface(_) {\n-                    let res = trans_impl::get_dict(\n+                    let res = impl::get_dict(\n                         bcx, option::get(g.origins)[n_orig]);\n                     lltydescs += [res.val];\n                     bcx = res.bcx;\n@@ -3477,7 +3476,7 @@ fn trans_expr(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n       }\n       ast::expr_alt(expr, arms) {\n           //          tcx.sess.span_note(e.span, \"about to call trans_alt\");\n-        ret trans_alt::trans_alt(bcx, expr, arms, dest);\n+        ret alt::trans_alt(bcx, expr, arms, dest);\n       }\n       ast::expr_block(blk) {\n         let sub_cx = new_scope_block_ctxt(bcx, \"block-expr body\");\n@@ -3502,7 +3501,7 @@ fn trans_expr(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n         ret trans_unary(bcx, op, x, e, dest);\n       }\n       ast::expr_fn(proto, decl, body, cap_clause) {\n-        ret trans_closure::trans_expr_fn(\n+        ret closure::trans_expr_fn(\n             bcx, proto, decl, body, e.span, e.id, *cap_clause, dest);\n       }\n       ast::expr_fn_block(decl, body) {\n@@ -3511,7 +3510,7 @@ fn trans_expr(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n             #debug(\"translating fn_block %s with type %s\",\n                    expr_to_str(e), ty_to_str(tcx, ty::expr_ty(tcx, e)));\n             let cap_clause = { copies: [], moves: [] };\n-            ret trans_closure::trans_expr_fn(\n+            ret closure::trans_expr_fn(\n                 bcx, proto, decl, body, e.span, e.id, cap_clause, dest);\n           }\n           _ {\n@@ -3520,7 +3519,7 @@ fn trans_expr(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n         }\n       }\n       ast::expr_bind(f, args) {\n-        ret trans_closure::trans_bind(\n+        ret closure::trans_bind(\n             bcx, f, args, e.id, dest);\n       }\n       ast::expr_copy(a) {\n@@ -3542,7 +3541,7 @@ fn trans_expr(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n         let callee_id = ast_util::op_expr_callee_id(e);\n         let fty = ty::node_id_to_monotype(tcx, callee_id);\n         ret trans_call_inner(bcx, fty, {|bcx|\n-            trans_impl::trans_method_callee(bcx, callee_id, base, origin)\n+            impl::trans_method_callee(bcx, callee_id, base, origin)\n         }, [idx], e.id, dest);\n       }\n \n@@ -3948,7 +3947,7 @@ fn init_local(bcx: @block_ctxt, local: @ast::local) -> @block_ctxt {\n     }\n     // Make a note to drop this slot on the way out.\n     add_clean(bcx, llptr, ty);\n-    ret trans_alt::bind_irrefutable_pat(bcx, local.node.pat, llptr, false);\n+    ret alt::bind_irrefutable_pat(bcx, local.node.pat, llptr, false);\n }\n \n fn init_ref_local(bcx: @block_ctxt, local: @ast::local) -> @block_ctxt {\n@@ -3958,7 +3957,7 @@ fn init_ref_local(bcx: @block_ctxt, local: @ast::local) -> @block_ctxt {\n       owned_imm { val = do_spill_noroot(bcx, val); }\n       owned {}\n     }\n-    ret trans_alt::bind_irrefutable_pat(bcx, local.node.pat, val, false);\n+    ret alt::bind_irrefutable_pat(bcx, local.node.pat, val, false);\n }\n \n fn zero_alloca(cx: @block_ctxt, llptr: ValueRef, t: ty::t)\n@@ -4888,7 +4887,7 @@ fn trans_item(cx: @local_ctxt, item: ast::item) {\n         }\n       }\n       ast::item_impl(tps, _, _, ms) {\n-        trans_impl::trans_impl(cx, item.ident, ms, item.id, tps);\n+        impl::trans_impl(cx, item.ident, ms, item.id, tps);\n       }\n       ast::item_res(decl, tps, body, dtor_id, ctor_id) {\n         trans_res_ctor(cx, decl, ctor_id, tps);\n@@ -5267,10 +5266,10 @@ fn trans_constant(ccx: @crate_ctxt, it: @ast::item, &&pt: [str],\n       }\n       ast::item_impl(tps, some(@{node: ast::ty_path(_, id), _}), _, ms) {\n         let i_did = ast_util::def_id_of_def(ccx.tcx.def_map.get(id));\n-        trans_impl::trans_impl_vtable(ccx, pt, i_did, ms, tps, it);\n+        impl::trans_impl_vtable(ccx, pt, i_did, ms, tps, it);\n       }\n       ast::item_iface(_, _) {\n-        trans_impl::trans_iface_vtable(ccx, pt, it);\n+        impl::trans_iface_vtable(ccx, pt, it);\n       }\n       _ { }\n     }\n@@ -5414,16 +5413,14 @@ fn fill_crate_map(ccx: @crate_ctxt, map: ValueRef) {\n fn write_metadata(cx: @crate_ctxt, crate: @ast::crate) {\n     if !cx.sess.building_library { ret; }\n     let llmeta = C_postr(metadata::encoder::encode_metadata(cx, crate));\n-    let llconst = trans_common::C_struct([llmeta]);\n-    let llglobal =\n-        str::as_buf(\"rust_metadata\",\n-                    {|buf|\n-                        llvm::LLVMAddGlobal(cx.llmod, val_ty(llconst), buf)\n-                    });\n+    let llconst = C_struct([llmeta]);\n+    let llglobal = str::as_buf(\"rust_metadata\", {|buf|\n+        llvm::LLVMAddGlobal(cx.llmod, val_ty(llconst), buf)\n+    });\n     llvm::LLVMSetInitializer(llglobal, llconst);\n-    let _: () =\n-        str::as_buf(cx.sess.targ_cfg.target_strs.meta_sect_name,\n-                    {|buf| llvm::LLVMSetSection(llglobal, buf) });\n+    str::as_buf(cx.sess.targ_cfg.target_strs.meta_sect_name, {|buf|\n+        llvm::LLVMSetSection(llglobal, buf)\n+    });\n     llvm::LLVMSetLinkage(llglobal,\n                          lib::llvm::LLVMInternalLinkage as llvm::Linkage);\n ", "previous_filename": "src/comp/middle/trans.rs"}, {"sha": "981c3d7d19ee7caf653dddc467c6addc00cf9812", "filename": "src/comp/middle/trans/build.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/03e9dac09a737f47f1ce75b12826cebe320f2f77/src%2Fcomp%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03e9dac09a737f47f1ce75b12826cebe320f2f77/src%2Fcomp%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fbuild.rs?ref=03e9dac09a737f47f1ce75b12826cebe320f2f77", "patch": "@@ -6,8 +6,8 @@ import syntax::codemap;\n import codemap::span;\n import llvm::{ValueRef, TypeRef, BasicBlockRef, BuilderRef, Opcode,\n               ModuleRef};\n-import trans_common::{block_ctxt, T_ptr, T_nil, T_i8, T_i1, T_void,\n-                      T_fn, val_ty, bcx_ccx, C_i32};\n+import common::{block_ctxt, T_ptr, T_nil, T_i8, T_i1, T_void,\n+                T_fn, val_ty, bcx_ccx, C_i32};\n \n fn B(cx: @block_ctxt) -> BuilderRef {\n     let b = *cx.fcx.lcx.ccx.builder;", "previous_filename": "src/comp/middle/trans_build.rs"}, {"sha": "710f0ecc54a5e5804fd706d8e368053c5b448a75", "filename": "src/comp/middle/trans/closure.rs", "status": "renamed", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/03e9dac09a737f47f1ce75b12826cebe320f2f77/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03e9dac09a737f47f1ce75b12826cebe320f2f77/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs?ref=03e9dac09a737f47f1ce75b12826cebe320f2f77", "patch": "@@ -3,9 +3,9 @@ import syntax::ast;\n import syntax::ast_util;\n import lib::llvm::llvm;\n import llvm::{ValueRef, TypeRef};\n-import trans_common::*;\n-import trans_build::*;\n-import trans::*;\n+import common::*;\n+import build::*;\n+import base::*;\n import middle::freevars::{get_freevars, freevar_info};\n import option::{some, none};\n import back::abi;\n@@ -15,7 +15,7 @@ import back::link::{\n     mangle_internal_name_by_path,\n     mangle_internal_name_by_path_and_seq};\n import util::ppaux::ty_to_str;\n-import trans::{\n+import base::{\n     trans_shared_malloc,\n     type_of_inner,\n     node_id_type,\n@@ -70,7 +70,7 @@ import shape::{size_of};\n // closure\".\n //\n // Typically an opaque closure suffices because I only manipulate it\n-// by ptr.  The routine trans_common::T_opaque_cbox_ptr() returns an\n+// by ptr.  The routine common::T_opaque_cbox_ptr() returns an\n // appropriate type for such an opaque closure; it allows access to the\n // first two fields, but not the others.\n //\n@@ -246,7 +246,7 @@ fn allocate_cbox(bcx: @block_ctxt,\n         (bcx, box, 0x12345678) // use arbitrary value for debugging\n       }\n       ty::ck_block {\n-        let {bcx, val: box} = trans::alloc_ty(bcx, cbox_ty);\n+        let {bcx, val: box} = base::alloc_ty(bcx, cbox_ty);\n         (bcx, box, 0x12345678) // use arbitrary value for debugging\n       }\n     };\n@@ -316,10 +316,10 @@ fn store_environment(\n         let ti = none;\n \n         let {result:closure_td, _} =\n-            trans::get_tydesc(bcx, cbox_ty, true, ti);\n-        trans::lazily_emit_tydesc_glue(bcx, abi::tydesc_field_take_glue, ti);\n-        trans::lazily_emit_tydesc_glue(bcx, abi::tydesc_field_drop_glue, ti);\n-        trans::lazily_emit_tydesc_glue(bcx, abi::tydesc_field_free_glue, ti);\n+            base::get_tydesc(bcx, cbox_ty, true, ti);\n+        base::lazily_emit_tydesc_glue(bcx, abi::tydesc_field_take_glue, ti);\n+        base::lazily_emit_tydesc_glue(bcx, abi::tydesc_field_drop_glue, ti);\n+        base::lazily_emit_tydesc_glue(bcx, abi::tydesc_field_free_glue, ti);\n         bcx = closure_td.bcx;\n         let td = maybe_clone_tydesc(bcx, ck, closure_td.val);\n         Store(bcx, td, bound_tydesc);\n@@ -367,16 +367,16 @@ fn store_environment(\n         let bound_data = bound_data.val;\n         alt bv {\n           env_expr(e) {\n-            bcx = trans::trans_expr_save_in(bcx, e, bound_data);\n+            bcx = base::trans_expr_save_in(bcx, e, bound_data);\n             add_clean_temp_mem(bcx, bound_data, bound_tys[i]);\n             temp_cleanups += [bound_data];\n           }\n           env_copy(val, ty, owned) {\n             let val1 = load_if_immediate(bcx, val, ty);\n-            bcx = trans::copy_val(bcx, INIT, bound_data, val1, ty);\n+            bcx = base::copy_val(bcx, INIT, bound_data, val1, ty);\n           }\n           env_copy(val, ty, owned_imm) {\n-            bcx = trans::copy_val(bcx, INIT, bound_data, val, ty);\n+            bcx = base::copy_val(bcx, INIT, bound_data, val, ty);\n           }\n           env_copy(_, _, temporary) {\n             fail \"Cannot capture temporary upvar\";\n@@ -572,7 +572,7 @@ fn trans_bind_1(cx: @block_ctxt, outgoing_fty: ty::t,\n             for bound in *bounds {\n                 alt bound {\n                   ty::bound_iface(_) {\n-                    let dict = trans_impl::get_dict(\n+                    let dict = impl::get_dict(\n                         bcx, option::get(ginfo.origins)[orig]);\n                     tds += [PointerCast(bcx, dict.val, val_ty(td))];\n                     orig += 1u;", "previous_filename": "src/comp/middle/trans_closure.rs"}, {"sha": "38b10d26b555ae7c7f06c5f2fc1c8c45d8ec366b", "filename": "src/comp/middle/trans/common.rs", "status": "renamed", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/03e9dac09a737f47f1ce75b12826cebe320f2f77/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03e9dac09a737f47f1ce75b12826cebe320f2f77/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs?ref=03e9dac09a737f47f1ce75b12826cebe320f2f77", "patch": "@@ -22,7 +22,7 @@ import lib::llvm::{True, False, Bool};\n import metadata::{csearch};\n \n // FIXME: These should probably be pulled in here too.\n-import trans::{type_of_fn, drop_ty};\n+import base::{type_of_fn, drop_ty};\n \n type namegen = fn@(str) -> str;\n fn new_namegen() -> namegen {\n@@ -258,7 +258,7 @@ fn add_clean_temp(cx: @block_ctxt, val: ValueRef, ty: ty::t) {\n     fn do_drop(bcx: @block_ctxt, val: ValueRef, ty: ty::t) ->\n        @block_ctxt {\n         if ty::type_is_immediate(bcx_tcx(bcx), ty) {\n-            ret trans::drop_ty_immediate(bcx, val, ty);\n+            ret base::drop_ty_immediate(bcx, val, ty);\n         } else {\n             ret drop_ty(bcx, val, ty);\n         }\n@@ -276,8 +276,8 @@ fn add_clean_temp_mem(cx: @block_ctxt, val: ValueRef, ty: ty::t) {\n }\n fn add_clean_free(cx: @block_ctxt, ptr: ValueRef, shared: bool) {\n     let scope_cx = find_scope_cx(cx);\n-    let free_fn = if shared { bind trans::trans_shared_free(_, ptr) }\n-                  else { bind trans::trans_free_if_not_gc(_, ptr) };\n+    let free_fn = if shared { bind base::trans_shared_free(_, ptr) }\n+                  else { bind base::trans_free_if_not_gc(_, ptr) };\n     scope_cx.cleanups += [clean_temp(ptr, free_fn)];\n     scope_cx.lpad_dirty = true;\n }\n@@ -325,7 +325,7 @@ fn get_res_dtor(ccx: @crate_ctxt, did: ast::def_id, inner_t: ty::t)\n     check non_ty_var(ccx, nil_res);\n     let f_t = type_of_fn(ccx, [{mode: ast::by_ref, ty: inner_t}],\n                          nil_res, *param_bounds);\n-    ret trans::get_extern_const(ccx.externs, ccx.llmod,\n+    ret base::get_extern_const(ccx.externs, ccx.llmod,\n                                 csearch::get_symbol(ccx.sess.cstore,\n                                                     did), f_t);\n }\n@@ -420,10 +420,6 @@ fn find_scope_cx(cx: @block_ctxt) -> @block_ctxt {\n     if cx.kind != NON_SCOPE_BLOCK { ret cx; }\n     alt cx.parent {\n       parent_some(b) { ret find_scope_cx(b); }\n-      parent_none {\n-        cx.fcx.lcx.ccx.sess.bug(\"trans::find_scope_cx() \" +\n-                                    \"called on parentless block_ctxt\");\n-      }\n     }\n }\n \n@@ -901,19 +897,19 @@ fn hash_dict_id(&&dp: dict_id) -> uint {\n }\n \n fn umax(cx: @block_ctxt, a: ValueRef, b: ValueRef) -> ValueRef {\n-    let cond = trans_build::ICmp(cx, lib::llvm::LLVMIntULT, a, b);\n-    ret trans_build::Select(cx, cond, b, a);\n+    let cond = build::ICmp(cx, lib::llvm::LLVMIntULT, a, b);\n+    ret build::Select(cx, cond, b, a);\n }\n \n fn umin(cx: @block_ctxt, a: ValueRef, b: ValueRef) -> ValueRef {\n-    let cond = trans_build::ICmp(cx, lib::llvm::LLVMIntULT, a, b);\n-    ret trans_build::Select(cx, cond, a, b);\n+    let cond = build::ICmp(cx, lib::llvm::LLVMIntULT, a, b);\n+    ret build::Select(cx, cond, a, b);\n }\n \n fn align_to(cx: @block_ctxt, off: ValueRef, align: ValueRef) -> ValueRef {\n-    let mask = trans_build::Sub(cx, align, C_int(bcx_ccx(cx), 1));\n-    let bumped = trans_build::Add(cx, off, mask);\n-    ret trans_build::And(cx, bumped, trans_build::Not(cx, mask));\n+    let mask = build::Sub(cx, align, C_int(bcx_ccx(cx), 1));\n+    let bumped = build::Add(cx, off, mask);\n+    ret build::And(cx, bumped, build::Not(cx, mask));\n }\n \n //", "previous_filename": "src/comp/middle/trans_common.rs"}, {"sha": "bbac0172f9695716835fcb4a0dd890b9d8924f35", "filename": "src/comp/middle/trans/impl.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/03e9dac09a737f47f1ce75b12826cebe320f2f77/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03e9dac09a737f47f1ce75b12826cebe320f2f77/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs?ref=03e9dac09a737f47f1ce75b12826cebe320f2f77", "patch": "@@ -1,7 +1,7 @@\n import core::ctypes::c_uint;\n-import trans::*;\n-import trans_common::*;\n-import trans_build::*;\n+import base::*;\n+import common::*;\n+import build::*;\n import option::{some, none};\n import syntax::{ast, ast_util};\n import metadata::csearch;", "previous_filename": "src/comp/middle/trans_impl.rs"}, {"sha": "91af1ffb8454fde80238e0ed47adbd2a084eb195", "filename": "src/comp/middle/trans/tvec.rs", "status": "renamed", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/03e9dac09a737f47f1ce75b12826cebe320f2f77/src%2Fcomp%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03e9dac09a737f47f1ce75b12826cebe320f2f77/src%2Fcomp%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Ftvec.rs?ref=03e9dac09a737f47f1ce75b12826cebe320f2f77", "patch": "@@ -3,13 +3,13 @@ import option::none;\n import syntax::ast;\n import lib::llvm::llvm::{ValueRef, TypeRef};\n import back::abi;\n-import trans::{call_memmove, trans_shared_malloc, type_of_or_i8,\n+import base::{call_memmove, trans_shared_malloc, type_of_or_i8,\n                INIT, copy_val, load_if_immediate, get_tydesc,\n                node_id_type, new_sub_block_ctxt, do_spill_noroot,\n                dest};\n import shape::{llsize_of, size_of};\n-import trans_build::*;\n-import trans_common::*;\n+import build::*;\n+import common::*;\n \n fn get_fill(bcx: @block_ctxt, vptr: ValueRef) -> ValueRef {\n     Load(bcx, GEPi(bcx, vptr, [0, abi::vec_elt_fill]))\n@@ -77,7 +77,7 @@ fn duplicate(bcx: @block_ctxt, vptr: ValueRef, vec_ty: ty::t) -> result {\n     let unit_ty = ty::sequence_element_type(bcx_tcx(bcx), vec_ty);\n     Store(bcx, fill, GEPi(bcx, newptr, [0, abi::vec_elt_alloc]));\n     if ty::type_needs_drop(bcx_tcx(bcx), unit_ty) {\n-        bcx = iter_vec(bcx, newptr, vec_ty, trans::take_ty);\n+        bcx = iter_vec(bcx, newptr, vec_ty, base::take_ty);\n     }\n     ret rslt(bcx, newptr);\n }\n@@ -89,19 +89,19 @@ fn make_free_glue(bcx: @block_ctxt, vptr: ValueRef, vec_ty: ty::t) ->\n     let null_test = IsNull(bcx, vptr);\n     CondBr(bcx, null_test, next_cx.llbb, drop_cx.llbb);\n     if ty::type_needs_drop(bcx_tcx(bcx), unit_ty) {\n-        drop_cx = iter_vec(drop_cx, vptr, vec_ty, trans::drop_ty);\n+        drop_cx = iter_vec(drop_cx, vptr, vec_ty, base::drop_ty);\n     }\n-    drop_cx = trans::trans_shared_free(drop_cx, vptr);\n+    drop_cx = base::trans_shared_free(drop_cx, vptr);\n     Br(drop_cx, next_cx.llbb);\n     ret next_cx;\n }\n \n fn trans_vec(bcx: @block_ctxt, args: [@ast::expr], id: ast::node_id,\n              dest: dest) -> @block_ctxt {\n     let ccx = bcx_ccx(bcx), bcx = bcx;\n-    if dest == trans::ignore {\n+    if dest == base::ignore {\n         for arg in args {\n-            bcx = trans::trans_expr(bcx, arg, trans::ignore);\n+            bcx = base::trans_expr(bcx, arg, base::ignore);\n         }\n         ret bcx;\n     }\n@@ -121,13 +121,13 @@ fn trans_vec(bcx: @block_ctxt, args: [@ast::expr], id: ast::node_id,\n         let lleltptr = if ty::type_has_dynamic_size(bcx_tcx(bcx), unit_ty) {\n             InBoundsGEP(bcx, dataptr, [Mul(bcx, C_uint(ccx, i), llunitsz)])\n         } else { InBoundsGEP(bcx, dataptr, [C_uint(ccx, i)]) };\n-        bcx = trans::trans_expr_save_in(bcx, e, lleltptr);\n+        bcx = base::trans_expr_save_in(bcx, e, lleltptr);\n         add_clean_temp_mem(bcx, lleltptr, unit_ty);\n         temp_cleanups += [lleltptr];\n         i += 1u;\n     }\n     for cln in temp_cleanups { revoke_clean(bcx, cln); }\n-    ret trans::store_in_dest(bcx, vptr, dest);\n+    ret base::store_in_dest(bcx, vptr, dest);\n }\n \n fn trans_str(bcx: @block_ctxt, s: str, dest: dest) -> @block_ctxt {\n@@ -140,7 +140,7 @@ fn trans_str(bcx: @block_ctxt, s: str, dest: dest) -> @block_ctxt {\n     let bcx =\n         call_memmove(bcx, get_dataptr(bcx, sptr, T_i8()), llcstr,\n                      C_uint(ccx, veclen)).bcx;\n-    ret trans::store_in_dest(bcx, sptr, dest);\n+    ret base::store_in_dest(bcx, sptr, dest);\n }\n \n fn trans_append(cx: @block_ctxt, vec_ty: ty::t, lhsptr: ValueRef,\n@@ -202,13 +202,13 @@ fn trans_append_literal(bcx: @block_ctxt, vptrptr: ValueRef, vec_ty: ty::t,\n     let ti = none;\n     let {bcx: bcx, val: td} =\n         get_tydesc(bcx, elt_ty, false, ti).result;\n-    trans::lazily_emit_tydesc_glue(bcx, abi::tydesc_field_take_glue, ti);\n+    base::lazily_emit_tydesc_glue(bcx, abi::tydesc_field_take_glue, ti);\n     let opaque_v = PointerCast(bcx, vptrptr,\n                                T_ptr(T_ptr(ccx.opaque_vec_type)));\n     for val in vals {\n-        let {bcx: e_bcx, val: elt} = trans::trans_temp_expr(bcx, val);\n+        let {bcx: e_bcx, val: elt} = base::trans_temp_expr(bcx, val);\n         bcx = e_bcx;\n-        let r = trans::spill_if_immediate(bcx, elt, elt_ty);\n+        let r = base::spill_if_immediate(bcx, elt, elt_ty);\n         let spilled = r.val;\n         bcx = r.bcx;\n         Call(bcx, bcx_ccx(bcx).upcalls.vec_push,\n@@ -253,7 +253,7 @@ fn trans_add(bcx: @block_ctxt, vec_ty: ty::t, lhs: ValueRef,\n \n     let bcx = iter_vec_raw(bcx, lhs, vec_ty, lhs_fill, copy_fn);\n     bcx = iter_vec_raw(bcx, rhs, vec_ty, rhs_fill, copy_fn);\n-    ret trans::store_in_dest(bcx, new_vec_ptr, dest);\n+    ret base::store_in_dest(bcx, new_vec_ptr, dest);\n }\n \n type val_and_ty_fn = fn@(@block_ctxt, ValueRef, ty::t) -> result;", "previous_filename": "src/comp/middle/trans_vec.rs"}, {"sha": "8cff8794081f6b9d2a52adb5271671a550da9e2e", "filename": "src/comp/middle/trans/uniq.rs", "status": "renamed", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/03e9dac09a737f47f1ce75b12826cebe320f2f77/src%2Fcomp%2Fmiddle%2Ftrans%2Funiq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03e9dac09a737f47f1ce75b12826cebe320f2f77/src%2Fcomp%2Fmiddle%2Ftrans%2Funiq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Funiq.rs?ref=03e9dac09a737f47f1ce75b12826cebe320f2f77", "patch": "@@ -1,8 +1,8 @@\n import syntax::ast;\n import lib::llvm::llvm::ValueRef;\n-import trans_common::*;\n-import trans_build::*;\n-import trans::{\n+import common::*;\n+import build::*;\n+import base::{\n     trans_shared_malloc,\n     type_of_inner,\n     node_id_type,\n@@ -28,9 +28,9 @@ fn trans_uniq(bcx: @block_ctxt, contents: @ast::expr,\n     check type_is_unique_box(bcx, uniq_ty);\n     let {bcx, val: llptr} = alloc_uniq(bcx, uniq_ty);\n     add_clean_free(bcx, llptr, true);\n-    bcx = trans::trans_expr_save_in(bcx, contents, llptr);\n+    bcx = base::trans_expr_save_in(bcx, contents, llptr);\n     revoke_clean(bcx, llptr);\n-    ret trans::store_in_dest(bcx, llptr, dest);\n+    ret base::store_in_dest(bcx, llptr, dest);\n }\n \n fn alloc_uniq(cx: @block_ctxt, uniq_ty: ty::t)\n@@ -92,6 +92,6 @@ fn duplicate(bcx: @block_ctxt, v: ValueRef, t: ty::t)\n \n     let src = load_if_immediate(bcx, v, content_ty);\n     let dst = llptr;\n-    let bcx = trans::copy_val(bcx, INIT, dst, src, content_ty);\n+    let bcx = base::copy_val(bcx, INIT, dst, src, content_ty);\n     ret rslt(bcx, dst);\n }\n\\ No newline at end of file", "previous_filename": "src/comp/middle/trans_uniq.rs"}, {"sha": "f655054ab1feda85a446424c58d52655ef40ecbb", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/03e9dac09a737f47f1ce75b12826cebe320f2f77/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/03e9dac09a737f47f1ce75b12826cebe320f2f77/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=03e9dac09a737f47f1ce75b12826cebe320f2f77", "patch": "@@ -14,14 +14,16 @@ use std (name = \"std\",\n          url = \"http://rust-lang.org/src/std\");\n \n mod middle {\n-    mod trans_common;\n-    mod trans_build;\n-    mod trans;\n-    mod trans_alt;\n-    mod trans_uniq;\n-    mod trans_closure;\n-    mod trans_vec;\n-    mod trans_impl;\n+    mod trans {\n+        mod common;\n+        mod build;\n+        mod base;\n+        mod alt;\n+        mod uniq;\n+        mod closure;\n+        mod tvec;\n+        mod impl;\n+    }\n     mod ty;\n     mod ast_map;\n     mod resolve;"}]}