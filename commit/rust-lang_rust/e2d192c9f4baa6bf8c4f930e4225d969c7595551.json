{"sha": "e2d192c9f4baa6bf8c4f930e4225d969c7595551", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyZDE5MmM5ZjRiYWE2YmY4YzRmOTMwZTQyMjVkOTY5Yzc1OTU1NTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-03T16:21:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-03T16:21:26Z"}, "message": "auto merge of #10777 : alexcrichton/rust/issue-10743, r=luqmana\n\nCommit messages have the fun details, the focus of this is closing #10743 though", "tree": {"sha": "4c65f9134577357779ede732a2297a06ca95990e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4c65f9134577357779ede732a2297a06ca95990e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e2d192c9f4baa6bf8c4f930e4225d969c7595551", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e2d192c9f4baa6bf8c4f930e4225d969c7595551", "html_url": "https://github.com/rust-lang/rust/commit/e2d192c9f4baa6bf8c4f930e4225d969c7595551", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e2d192c9f4baa6bf8c4f930e4225d969c7595551/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a9db409e5d6eb81009e627b91e5425ce39fa52d", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a9db409e5d6eb81009e627b91e5425ce39fa52d", "html_url": "https://github.com/rust-lang/rust/commit/6a9db409e5d6eb81009e627b91e5425ce39fa52d"}, {"sha": "0dc9f6277939a661011a07fbc88f0f0449ac276c", "url": "https://api.github.com/repos/rust-lang/rust/commits/0dc9f6277939a661011a07fbc88f0f0449ac276c", "html_url": "https://github.com/rust-lang/rust/commit/0dc9f6277939a661011a07fbc88f0f0449ac276c"}], "stats": {"total": 198, "additions": 121, "deletions": 77}, "files": [{"sha": "e19e8638331ebffea13307a2cd614416e6e5f721", "filename": "mk/tests.mk", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e2d192c9f4baa6bf8c4f930e4225d969c7595551/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/e2d192c9f4baa6bf8c4f930e4225d969c7595551/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=e2d192c9f4baa6bf8c4f930e4225d969c7595551", "patch": "@@ -920,11 +920,11 @@ $$(call TEST_OK_FILE,$(1),$(2),$(3),rmake): \\\n \n $(3)/test/run-make/%-$(1)-T-$(2)-H-$(3).ok: \\\n \t\t$(S)src/test/run-make/%/Makefile \\\n-\t\t$$(HBIN$(1)_H_$(3))/rustc$$(X_$(3))\n+\t\t$$(HSREQ$(1)_H_$(3))\n \t@rm -rf $(3)/test/run-make/$$*\n \t@mkdir -p $(3)/test/run-make/$$*\n \t@echo maketest: $$*\n-\t$$(Q)python $(S)src/etc/maketest.py $$(dir $$<) \\\n+\t$$(Q)$$(CFG_PYTHON) $(S)src/etc/maketest.py $$(dir $$<) \\\n \t    $$(HBIN$(1)_H_$(3))/rustc$$(X_$(3)) \\\n \t    $(3)/test/run-make/$$* \\\n \t    \"$$(CC_$(3)) $$(CFG_GCCISH_CFLAGS_$(3))\""}, {"sha": "cf8fd77b47a50803c1ad8611202646b074c59df7", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 73, "deletions": 54, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/e2d192c9f4baa6bf8c4f930e4225d969c7595551/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2d192c9f4baa6bf8c4f930e4225d969c7595551/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=e2d192c9f4baa6bf8c4f930e4225d969c7595551", "patch": "@@ -1127,8 +1127,9 @@ fn link_args(sess: Session,\n         }\n     }\n \n-    add_upstream_rust_crates(&mut args, sess, dylib);\n     add_local_native_libraries(&mut args, sess);\n+    add_upstream_rust_crates(&mut args, sess, dylib);\n+    add_upstream_native_libraries(&mut args, sess);\n \n     // # Telling the linker what we're doing\n \n@@ -1168,6 +1169,42 @@ fn link_args(sess: Session,\n     return args;\n }\n \n+// # Native library linking\n+//\n+// User-supplied library search paths (-L on the cammand line) These are\n+// the same paths used to find Rust crates, so some of them may have been\n+// added already by the previous crate linking code. This only allows them\n+// to be found at compile time so it is still entirely up to outside\n+// forces to make sure that library can be found at runtime.\n+//\n+// Also note that the native libraries linked here are only the ones located\n+// in the current crate. Upstream crates with native library dependencies\n+// may have their native library pulled in above.\n+fn add_local_native_libraries(args: &mut ~[~str], sess: Session) {\n+    for path in sess.opts.addl_lib_search_paths.iter() {\n+        // FIXME (#9639): This needs to handle non-utf8 paths\n+        args.push(\"-L\" + path.as_str().unwrap().to_owned());\n+    }\n+\n+    let rustpath = filesearch::rust_path();\n+    for path in rustpath.iter() {\n+        // FIXME (#9639): This needs to handle non-utf8 paths\n+        args.push(\"-L\" + path.as_str().unwrap().to_owned());\n+    }\n+\n+    for &(ref l, kind) in cstore::get_used_libraries(sess.cstore).iter() {\n+        match kind {\n+            cstore::NativeUnknown | cstore::NativeStatic => {\n+                args.push(\"-l\" + *l);\n+            }\n+            cstore::NativeFramework => {\n+                args.push(~\"-framework\");\n+                args.push(l.to_owned());\n+            }\n+        }\n+    }\n+}\n+\n // # Rust Crate linking\n //\n // Rust crates are not considered at all when creating an rlib output. All\n@@ -1197,30 +1234,11 @@ fn add_upstream_rust_crates(args: &mut ~[~str], sess: Session,\n         // all dynamic libaries require dynamic dependencies (see above), so\n         // it's satisfactory to include either all static libraries or all\n         // dynamic libraries.\n-        let crates = cstore::get_used_crates(cstore,\n-                                             cstore::RequireStatic);\n+        let crates = cstore::get_used_crates(cstore, cstore::RequireStatic);\n         if crates.iter().all(|&(_, ref p)| p.is_some()) {\n-            for &(cnum, ref path) in crates.iter() {\n-                let cratepath = path.clone().unwrap();\n-\n-                // If we're linking to the static version of the crate, then\n-                // we're mostly good to go. The caveat here is that we need to\n-                // pull in the static crate's native dependencies.\n-                args.push(cratepath.as_str().unwrap().to_owned());\n-\n-                let libs = csearch::get_native_libraries(sess.cstore, cnum);\n-                for &(kind, ref lib) in libs.iter() {\n-                    match kind {\n-                        cstore::NativeUnknown => args.push(\"-l\" + *lib),\n-                        cstore::NativeFramework => {\n-                            args.push(~\"-framework\");\n-                            args.push(lib.to_owned());\n-                        }\n-                        cstore::NativeStatic => {\n-                            sess.bug(\"statics shouldn't be propagated\");\n-                        }\n-                    }\n-                }\n+            for (_, path) in crates.move_iter() {\n+                let path = path.unwrap();\n+                args.push(path.as_str().unwrap().to_owned());\n             }\n             return;\n         }\n@@ -1253,38 +1271,39 @@ fn add_upstream_rust_crates(args: &mut ~[~str], sess: Session,\n     }\n }\n \n-// # Native library linking\n+// Link in all of our upstream crates' native dependencies. Remember that\n+// all of these upstream native depenencies are all non-static\n+// dependencies. We've got two cases then:\n //\n-// User-supplied library search paths (-L on the cammand line) These are\n-// the same paths used to find Rust crates, so some of them may have been\n-// added already by the previous crate linking code. This only allows them\n-// to be found at compile time so it is still entirely up to outside\n-// forces to make sure that library can be found at runtime.\n+// 1. The upstream crate is an rlib. In this case we *must* link in the\n+//    native dependency because the rlib is just an archive.\n //\n-// Also note that the native libraries linked here are only the ones located\n-// in the current crate. Upstream crates with native library dependencies\n-// may have their native library pulled in above.\n-fn add_local_native_libraries(args: &mut ~[~str], sess: Session) {\n-    for path in sess.opts.addl_lib_search_paths.iter() {\n-        // FIXME (#9639): This needs to handle non-utf8 paths\n-        args.push(\"-L\" + path.as_str().unwrap().to_owned());\n-    }\n-\n-    let rustpath = filesearch::rust_path();\n-    for path in rustpath.iter() {\n-        // FIXME (#9639): This needs to handle non-utf8 paths\n-        args.push(\"-L\" + path.as_str().unwrap().to_owned());\n-    }\n-\n-    for &(ref l, kind) in cstore::get_used_libraries(sess.cstore).iter() {\n-        match kind {\n-            cstore::NativeUnknown | cstore::NativeStatic => {\n-                args.push(\"-l\" + *l);\n-            }\n-            cstore::NativeFramework => {\n-                args.push(~\"-framework\");\n-                args.push(l.to_owned());\n+// 2. The upstream crate is a dylib. In order to use the dylib, we have to\n+//    have the dependency present on the system somewhere. Thus, we don't\n+//    gain a whole lot from not linking in the dynamic dependency to this\n+//    crate as well.\n+//\n+// The use case for this is a little subtle. In theory the native\n+// dependencies of a crate a purely an implementation detail of the crate\n+// itself, but the problem arises with generic and inlined functions. If a\n+// generic function calls a native function, then the generic function must\n+// be instantiated in the target crate, meaning that the native symbol must\n+// also be resolved in the target crate.\n+fn add_upstream_native_libraries(args: &mut ~[~str], sess: Session) {\n+    let cstore = sess.cstore;\n+    cstore::iter_crate_data(cstore, |cnum, _| {\n+        let libs = csearch::get_native_libraries(cstore, cnum);\n+        for &(kind, ref lib) in libs.iter() {\n+            match kind {\n+                cstore::NativeUnknown => args.push(\"-l\" + *lib),\n+                cstore::NativeFramework => {\n+                    args.push(~\"-framework\");\n+                    args.push(lib.to_owned());\n+                }\n+                cstore::NativeStatic => {\n+                    sess.bug(\"statics shouldn't be propagated\");\n+                }\n             }\n         }\n-    }\n+    });\n }"}, {"sha": "85d702d577ea3a9aa4d8497a15e9ca8996d83451", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 40, "deletions": 12, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/e2d192c9f4baa6bf8c4f930e4225d969c7595551/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2d192c9f4baa6bf8c4f930e4225d969c7595551/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=e2d192c9f4baa6bf8c4f930e4225d969c7595551", "patch": "@@ -128,25 +128,44 @@ impl Visitor<()> for MarkSymbolVisitor {\n                 };\n \n                 let def_id = def_id_of_def(def);\n-                if ReachableContext::\n-                    def_id_represents_local_inlined_item(self.tcx, def_id) {\n-                        self.worklist.push(def_id.node)\n+                if is_local(def_id) {\n+                    if ReachableContext::\n+                        def_id_represents_local_inlined_item(self.tcx, def_id) {\n+                            self.worklist.push(def_id.node)\n+                    } else {\n+                        match def {\n+                            // If this path leads to a static, then we may have\n+                            // to do some work to figure out whether the static\n+                            // is indeed reachable (address_insignificant\n+                            // statics are *never* reachable).\n+                            ast::DefStatic(..) => {\n+                                self.worklist.push(def_id.node);\n+                            }\n+\n+                            // If this wasn't a static, then this destination is\n+                            // surely reachable.\n+                            _ => {\n+                                self.reachable_symbols.insert(def_id.node);\n+                            }\n+                        }\n                     }\n-                self.reachable_symbols.insert(def_id.node);\n+                }\n             }\n             ast::ExprMethodCall(..) => {\n                 match self.method_map.find(&expr.id) {\n                     Some(&typeck::method_map_entry {\n                         origin: typeck::method_static(def_id),\n                         ..\n                     }) => {\n-                        if ReachableContext::\n-                            def_id_represents_local_inlined_item(\n-                                self.tcx,\n-                                def_id) {\n-                                self.worklist.push(def_id.node)\n-                            }\n-                        self.reachable_symbols.insert(def_id.node);\n+                        if is_local(def_id) {\n+                            if ReachableContext::\n+                                def_id_represents_local_inlined_item(\n+                                    self.tcx,\n+                                    def_id) {\n+                                    self.worklist.push(def_id.node)\n+                                }\n+                            self.reachable_symbols.insert(def_id.node);\n+                        }\n                     }\n                     Some(_) => {}\n                     None => {\n@@ -310,10 +329,19 @@ impl ReachableContext {\n                         }\n                     }\n \n+                    // Statics with insignificant addresses are not reachable\n+                    // because they're inlined specially into all other crates.\n+                    ast::item_static(..) => {\n+                        if attr::contains_name(item.attrs,\n+                                               \"address_insignificant\") {\n+                            self.reachable_symbols.remove(&search_item);\n+                        }\n+                    }\n+\n                     // These are normal, nothing reachable about these\n                     // inherently and their children are already in the\n                     // worklist, as determined by the privacy pass\n-                    ast::item_static(..) | ast::item_ty(..) |\n+                    ast::item_ty(..) |\n                     ast::item_mod(..) | ast::item_foreign_mod(..) |\n                     ast::item_impl(..) | ast::item_trait(..) |\n                     ast::item_struct(..) | ast::item_enum(..) => {}"}, {"sha": "d4586fc59905bd0244655da3ca6084f949dc7e50", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e2d192c9f4baa6bf8c4f930e4225d969c7595551/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2d192c9f4baa6bf8c4f930e4225d969c7595551/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=e2d192c9f4baa6bf8c4f930e4225d969c7595551", "patch": "@@ -2521,9 +2521,12 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::NodeId) -> ValueRef {\n                                 // requested\n                                 if attr::contains_name(i.attrs,\n                                                        \"address_insignificant\"){\n+                                    if ccx.reachable.contains(&id) {\n+                                        ccx.sess.span_bug(i.span,\n+                                            \"insignificant static is \\\n+                                             reachable\");\n+                                    }\n                                     lib::llvm::SetUnnamedAddr(g, true);\n-                                    lib::llvm::SetLinkage(g,\n-                                        lib::llvm::InternalLinkage);\n \n                                     // This is a curious case where we must make\n                                     // all of these statics inlineable. If a"}, {"sha": "cce7df565048902e1c64e6e423c2fe744ed02571", "filename": "src/test/auxiliary/anon-extern-mod-cross-crate-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e2d192c9f4baa6bf8c4f930e4225d969c7595551/src%2Ftest%2Fauxiliary%2Fanon-extern-mod-cross-crate-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2d192c9f4baa6bf8c4f930e4225d969c7595551/src%2Ftest%2Fauxiliary%2Fanon-extern-mod-cross-crate-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fanon-extern-mod-cross-crate-1.rs?ref=e2d192c9f4baa6bf8c4f930e4225d969c7595551", "patch": "@@ -14,7 +14,7 @@\n \n use std::libc;\n \n+#[link(name = \"rustrt\")]\n extern {\n-    #[link(name = \"rustrt\")]\n     pub fn rust_get_test_int() -> libc::intptr_t;\n }"}, {"sha": "e31f28ed7a20ed15d2d4f5fbe994a211dcbdeef1", "filename": "src/test/run-pass/anon-extern-mod-cross-crate-2.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e2d192c9f4baa6bf8c4f930e4225d969c7595551/src%2Ftest%2Frun-pass%2Fanon-extern-mod-cross-crate-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2d192c9f4baa6bf8c4f930e4225d969c7595551/src%2Ftest%2Frun-pass%2Fanon-extern-mod-cross-crate-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fanon-extern-mod-cross-crate-2.rs?ref=e2d192c9f4baa6bf8c4f930e4225d969c7595551", "patch": "@@ -15,9 +15,6 @@ extern mod anonexternmod;\n \n use anonexternmod::rust_get_test_int;\n \n-#[link(name = \"rustrt\")] // we have explicitly chosen to require this\n-extern {}\n-\n pub fn main() {\n     unsafe {\n         rust_get_test_int();"}, {"sha": "b48b8c3cd4599a6fa49730d5f7198e2c62135873", "filename": "src/test/run-pass/invoke-external-foreign.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e2d192c9f4baa6bf8c4f930e4225d969c7595551/src%2Ftest%2Frun-pass%2Finvoke-external-foreign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2d192c9f4baa6bf8c4f930e4225d969c7595551/src%2Ftest%2Frun-pass%2Finvoke-external-foreign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Finvoke-external-foreign.rs?ref=e2d192c9f4baa6bf8c4f930e4225d969c7595551", "patch": "@@ -18,9 +18,6 @@\n \n extern mod foreign_lib;\n \n-#[link(name = \"rustrt\")] // we have explicitly chosen to require this\n-extern {}\n-\n pub fn main() {\n     unsafe {\n         let _foo = foreign_lib::rustrt::rust_get_test_int();"}]}