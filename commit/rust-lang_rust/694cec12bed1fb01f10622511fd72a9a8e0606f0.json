{"sha": "694cec12bed1fb01f10622511fd72a9a8e0606f0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5NGNlYzEyYmVkMWZiMDFmMTA2MjI1MTFmZDcyYTlhOGUwNjA2ZjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-07T15:51:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-07T15:51:13Z"}, "message": "Auto merge of #6110 - rail-rain:care_enums_non_copy_const, r=llogiq\n\n\"Respect\" enums in `interior_mutable_const`\n\nfixes #3962\nfixes #3825\n\nHello,\n\nIt might not be a good idea to submit another relatively large PR while I have an opened PR; but, I've finished this anyway. This may be able to wait for months.\n\nNote: the code uses the MIR interpreter, which the author of #3962 thought unlikely to be a solution. This might be over-engineering; but, I think it's important to be able to work with the 'http' crate (#3825). (And, I don't want to write a MIR visitor)\n\n---\n\nchangelog: fix a false positive in two `interior_mutable_const` lints where a constant with enums gets linted\neven if it uses a clearly unfrozen variant", "tree": {"sha": "9d3e65506f556ce557c491965805dc58b50206e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d3e65506f556ce557c491965805dc58b50206e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/694cec12bed1fb01f10622511fd72a9a8e0606f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/694cec12bed1fb01f10622511fd72a9a8e0606f0", "html_url": "https://github.com/rust-lang/rust/commit/694cec12bed1fb01f10622511fd72a9a8e0606f0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/694cec12bed1fb01f10622511fd72a9a8e0606f0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4bbef42c4890f9b2d6a742872e525b7b548fd019", "url": "https://api.github.com/repos/rust-lang/rust/commits/4bbef42c4890f9b2d6a742872e525b7b548fd019", "html_url": "https://github.com/rust-lang/rust/commit/4bbef42c4890f9b2d6a742872e525b7b548fd019"}, {"sha": "f58a1695a67e2db741b7237992e696ff9a14d0ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/f58a1695a67e2db741b7237992e696ff9a14d0ab", "html_url": "https://github.com/rust-lang/rust/commit/f58a1695a67e2db741b7237992e696ff9a14d0ab"}], "stats": {"total": 1148, "additions": 969, "deletions": 179}, "files": [{"sha": "6b0d198edcffa647112af10cceccea3a3304f2d2", "filename": "clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 135, "deletions": 35, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/694cec12bed1fb01f10622511fd72a9a8e0606f0/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/694cec12bed1fb01f10622511fd72a9a8e0606f0/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=694cec12bed1fb01f10622511fd72a9a8e0606f0", "patch": "@@ -5,11 +5,15 @@\n use std::ptr;\n \n use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::{Expr, ExprKind, ImplItem, ImplItemKind, Item, ItemKind, Node, TraitItem, TraitItemKind, UnOp};\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::{\n+    BodyId, Expr, ExprKind, HirId, ImplItem, ImplItemKind, Item, ItemKind, Node, TraitItem, TraitItemKind, UnOp,\n+};\n use rustc_infer::traits::specialization_graph;\n use rustc_lint::{LateContext, LateLintPass, Lint};\n+use rustc_middle::mir::interpret::{ConstValue, ErrorHandled};\n use rustc_middle::ty::adjustment::Adjust;\n-use rustc_middle::ty::{AssocKind, Ty};\n+use rustc_middle::ty::{self, AssocKind, Const, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{InnerSpan, Span, DUMMY_SP};\n use rustc_typeck::hir_ty_to_ty;\n@@ -36,14 +40,17 @@ declare_clippy_lint! {\n     /// `std::sync::ONCE_INIT` constant). In this case the use of `const` is legit,\n     /// and this lint should be suppressed.\n     ///\n-    /// When an enum has variants with interior mutability, use of its non interior mutable\n-    /// variants can generate false positives. See issue\n-    /// [#3962](https://github.com/rust-lang/rust-clippy/issues/3962)\n+    /// Even though the lint avoids triggering on a constant whose type has enums that have variants\n+    /// with interior mutability, and its value uses non interior mutable variants (see\n+    /// [#3962](https://github.com/rust-lang/rust-clippy/issues/3962) and\n+    /// [#3825](https://github.com/rust-lang/rust-clippy/issues/3825) for examples);\n+    /// it complains about associated constants without default values only based on its types;\n+    /// which might not be preferable.\n+    /// There're other enums plus associated constants cases that the lint cannot handle.\n     ///\n     /// Types that have underlying or potential interior mutability trigger the lint whether\n     /// the interior mutable field is used or not. See issues\n     /// [#5812](https://github.com/rust-lang/rust-clippy/issues/5812) and\n-    /// [#3825](https://github.com/rust-lang/rust-clippy/issues/3825)\n     ///\n     /// **Example:**\n     /// ```rust\n@@ -105,6 +112,79 @@ declare_clippy_lint! {\n     \"referencing `const` with interior mutability\"\n }\n \n+fn is_unfrozen<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n+    // Ignore types whose layout is unknown since `is_freeze` reports every generic types as `!Freeze`,\n+    // making it indistinguishable from `UnsafeCell`. i.e. it isn't a tool to prove a type is\n+    // 'unfrozen'. However, this code causes a false negative in which\n+    // a type contains a layout-unknown type, but also a unsafe cell like `const CELL: Cell<T>`.\n+    // Yet, it's better than `ty.has_type_flags(TypeFlags::HAS_TY_PARAM | TypeFlags::HAS_PROJECTION)`\n+    // since it works when a pointer indirection involves (`Cell<*const T>`).\n+    // Making up a `ParamEnv` where every generic params and assoc types are `Freeze`is another option;\n+    // but I'm not sure whether it's a decent way, if possible.\n+    cx.tcx.layout_of(cx.param_env.and(ty)).is_ok() && !ty.is_freeze(cx.tcx.at(DUMMY_SP), cx.param_env)\n+}\n+\n+fn is_value_unfrozen_raw<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    result: Result<ConstValue<'tcx>, ErrorHandled>,\n+    ty: Ty<'tcx>,\n+) -> bool {\n+    fn inner<'tcx>(cx: &LateContext<'tcx>, val: &'tcx Const<'tcx>) -> bool {\n+        match val.ty.kind() {\n+            // the fact that we have to dig into every structs to search enums\n+            // leads us to the point checking `UnsafeCell` directly is the only option.\n+            ty::Adt(ty_def, ..) if Some(ty_def.did) == cx.tcx.lang_items().unsafe_cell_type() => true,\n+            ty::Array(..) | ty::Adt(..) | ty::Tuple(..) => {\n+                let val = cx.tcx.destructure_const(cx.param_env.and(val));\n+                val.fields.iter().any(|field| inner(cx, field))\n+            },\n+            _ => false,\n+        }\n+    }\n+\n+    result.map_or_else(\n+        |err| {\n+            // Consider `TooGeneric` cases as being unfrozen.\n+            // This causes a false positive where an assoc const whose type is unfrozen\n+            // have a value that is a frozen variant with a generic param (an example is\n+            // `declare_interior_mutable_const::enums::BothOfCellAndGeneric::GENERIC_VARIANT`).\n+            // However, it prevents a number of false negatives that is, I think, important:\n+            // 1. assoc consts in trait defs referring to consts of themselves\n+            //    (an example is `declare_interior_mutable_const::traits::ConcreteTypes::ANOTHER_ATOMIC`).\n+            // 2. a path expr referring to assoc consts whose type is doesn't have\n+            //    any frozen variants in trait defs (i.e. without substitute for `Self`).\n+            //    (e.g. borrowing `borrow_interior_mutable_const::trait::ConcreteTypes::ATOMIC`)\n+            // 3. similar to the false positive above;\n+            //    but the value is an unfrozen variant, or the type has no enums. (An example is\n+            //    `declare_interior_mutable_const::enums::BothOfCellAndGeneric::UNFROZEN_VARIANT`\n+            //    and `declare_interior_mutable_const::enums::BothOfCellAndGeneric::NO_ENUM`).\n+            // One might be able to prevent these FNs correctly, and replace this with `false`;\n+            // e.g. implementing `has_frozen_variant` described above, and not running this function\n+            // when the type doesn't have any frozen variants would be the 'correct' way for the 2nd\n+            // case (that actually removes another suboptimal behavior (I won't say 'false positive') where,\n+            // similar to 2., but with the a frozen variant) (e.g. borrowing\n+            // `borrow_interior_mutable_const::enums::AssocConsts::TO_BE_FROZEN_VARIANT`).\n+            // I chose this way because unfrozen enums as assoc consts are rare (or, hopefully, none).\n+            err == ErrorHandled::TooGeneric\n+        },\n+        |val| inner(cx, Const::from_value(cx.tcx, val, ty)),\n+    )\n+}\n+\n+fn is_value_unfrozen_poly<'tcx>(cx: &LateContext<'tcx>, body_id: BodyId, ty: Ty<'tcx>) -> bool {\n+    let result = cx.tcx.const_eval_poly(body_id.hir_id.owner.to_def_id());\n+    is_value_unfrozen_raw(cx, result, ty)\n+}\n+\n+fn is_value_unfrozen_expr<'tcx>(cx: &LateContext<'tcx>, hir_id: HirId, def_id: DefId, ty: Ty<'tcx>) -> bool {\n+    let substs = cx.typeck_results().node_substs(hir_id);\n+\n+    let result = cx\n+        .tcx\n+        .const_eval_resolve(cx.param_env, ty::WithOptConstParam::unknown(def_id), substs, None, None);\n+    is_value_unfrozen_raw(cx, result, ty)\n+}\n+\n #[derive(Copy, Clone)]\n enum Source {\n     Item { item: Span },\n@@ -130,19 +210,7 @@ impl Source {\n     }\n }\n \n-fn verify_ty_bound<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, source: Source) {\n-    // Ignore types whose layout is unknown since `is_freeze` reports every generic types as `!Freeze`,\n-    // making it indistinguishable from `UnsafeCell`. i.e. it isn't a tool to prove a type is\n-    // 'unfrozen'. However, this code causes a false negative in which\n-    // a type contains a layout-unknown type, but also a unsafe cell like `const CELL: Cell<T>`.\n-    // Yet, it's better than `ty.has_type_flags(TypeFlags::HAS_TY_PARAM | TypeFlags::HAS_PROJECTION)`\n-    // since it works when a pointer indirection involves (`Cell<*const T>`).\n-    // Making up a `ParamEnv` where every generic params and assoc types are `Freeze`is another option;\n-    // but I'm not sure whether it's a decent way, if possible.\n-    if cx.tcx.layout_of(cx.param_env.and(ty)).is_err() || ty.is_freeze(cx.tcx.at(DUMMY_SP), cx.param_env) {\n-        return;\n-    }\n-\n+fn lint(cx: &LateContext<'_>, source: Source) {\n     let (lint, msg, span) = source.lint();\n     span_lint_and_then(cx, lint, span, msg, |diag| {\n         if span.from_expansion() {\n@@ -165,24 +233,44 @@ declare_lint_pass!(NonCopyConst => [DECLARE_INTERIOR_MUTABLE_CONST, BORROW_INTER\n \n impl<'tcx> LateLintPass<'tcx> for NonCopyConst {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, it: &'tcx Item<'_>) {\n-        if let ItemKind::Const(hir_ty, ..) = &it.kind {\n+        if let ItemKind::Const(hir_ty, body_id) = it.kind {\n             let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n-            verify_ty_bound(cx, ty, Source::Item { item: it.span });\n+\n+            if is_unfrozen(cx, ty) && is_value_unfrozen_poly(cx, body_id, ty) {\n+                lint(cx, Source::Item { item: it.span });\n+            }\n         }\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'tcx>, trait_item: &'tcx TraitItem<'_>) {\n-        if let TraitItemKind::Const(hir_ty, ..) = &trait_item.kind {\n+        if let TraitItemKind::Const(hir_ty, body_id_opt) = &trait_item.kind {\n             let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n+\n             // Normalize assoc types because ones originated from generic params\n             // bounded other traits could have their bound.\n             let normalized = cx.tcx.normalize_erasing_regions(cx.param_env, ty);\n-            verify_ty_bound(cx, normalized, Source::Assoc { item: trait_item.span });\n+            if is_unfrozen(cx, normalized)\n+                // When there's no default value, lint it only according to its type;\n+                // in other words, lint consts whose value *could* be unfrozen, not definitely is.\n+                // This feels inconsistent with how the lint treats generic types,\n+                // which avoids linting types which potentially become unfrozen.\n+                // One could check whether a unfrozen type have a *frozen variant*\n+                // (like `body_id_opt.map_or_else(|| !has_frozen_variant(...), ...)`),\n+                // and do the same as the case of generic types at impl items.\n+                // Note that it isn't sufficient to check if it has an enum\n+                // since all of that enum's variants can be unfrozen:\n+                // i.e. having an enum doesn't necessary mean a type has a frozen variant.\n+                // And, implementing it isn't a trivial task; it'll probably end up\n+                // re-implementing the trait predicate evaluation specific to `Freeze`.\n+                && body_id_opt.map_or(true, |body_id| is_value_unfrozen_poly(cx, body_id, normalized))\n+            {\n+                lint(cx, Source::Assoc { item: trait_item.span });\n+            }\n         }\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext<'tcx>, impl_item: &'tcx ImplItem<'_>) {\n-        if let ImplItemKind::Const(hir_ty, ..) = &impl_item.kind {\n+        if let ImplItemKind::Const(hir_ty, body_id) = &impl_item.kind {\n             let item_hir_id = cx.tcx.hir().get_parent_node(impl_item.hir_id);\n             let item = cx.tcx.hir().expect_item(item_hir_id);\n \n@@ -209,24 +297,34 @@ impl<'tcx> LateLintPass<'tcx> for NonCopyConst {\n                                 ),\n                             ))\n                             .is_err();\n+                            // If there were a function like `has_frozen_variant` described above,\n+                            // we should use here as a frozen variant is a potential to be frozen\n+                            // similar to unknown layouts.\n+                            // e.g. `layout_of(...).is_err() || has_frozen_variant(...);`\n                         then {\n                             let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n                             let normalized = cx.tcx.normalize_erasing_regions(cx.param_env, ty);\n-                            verify_ty_bound(\n-                                cx,\n-                                normalized,\n-                                Source::Assoc {\n-                                    item: impl_item.span,\n-                                },\n-                            );\n+                            if is_unfrozen(cx, normalized)\n+                                && is_value_unfrozen_poly(cx, *body_id, normalized)\n+                            {\n+                                lint(\n+                                   cx,\n+                                   Source::Assoc {\n+                                       item: impl_item.span,\n+                                    },\n+                                );\n+                            }\n                         }\n                     }\n                 },\n                 ItemKind::Impl { of_trait: None, .. } => {\n                     let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n                     // Normalize assoc types originated from generic params.\n                     let normalized = cx.tcx.normalize_erasing_regions(cx.param_env, ty);\n-                    verify_ty_bound(cx, normalized, Source::Assoc { item: impl_item.span });\n+\n+                    if is_unfrozen(cx, ty) && is_value_unfrozen_poly(cx, *body_id, normalized) {\n+                        lint(cx, Source::Assoc { item: impl_item.span });\n+                    }\n                 },\n                 _ => (),\n             }\n@@ -241,8 +339,8 @@ impl<'tcx> LateLintPass<'tcx> for NonCopyConst {\n             }\n \n             // Make sure it is a const item.\n-            match qpath_res(cx, qpath, expr.hir_id) {\n-                Res::Def(DefKind::Const | DefKind::AssocConst, _) => {},\n+            let item_def_id = match qpath_res(cx, qpath, expr.hir_id) {\n+                Res::Def(DefKind::Const | DefKind::AssocConst, did) => did,\n                 _ => return,\n             };\n \n@@ -319,7 +417,9 @@ impl<'tcx> LateLintPass<'tcx> for NonCopyConst {\n                 cx.typeck_results().expr_ty(dereferenced_expr)\n             };\n \n-            verify_ty_bound(cx, ty, Source::Expr { expr: expr.span });\n+            if is_unfrozen(cx, ty) && is_value_unfrozen_expr(cx, expr.hir_id, item_def_id, ty) {\n+                lint(cx, Source::Expr { expr: expr.span });\n+            }\n         }\n     }\n }"}, {"sha": "2289f7875f04c7007e54cdf1666b5fc820cc01aa", "filename": "tests/ui/borrow_interior_mutable_const/auxiliary/helper.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/694cec12bed1fb01f10622511fd72a9a8e0606f0/tests%2Fui%2Fborrow_interior_mutable_const%2Fauxiliary%2Fhelper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/694cec12bed1fb01f10622511fd72a9a8e0606f0/tests%2Fui%2Fborrow_interior_mutable_const%2Fauxiliary%2Fhelper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrow_interior_mutable_const%2Fauxiliary%2Fhelper.rs?ref=694cec12bed1fb01f10622511fd72a9a8e0606f0", "patch": "@@ -0,0 +1,16 @@\n+// this file solely exists to test constants defined in foreign crates.\n+// As the most common case is the `http` crate, it replicates `http::HeadewrName`'s structure.\n+\n+#![allow(clippy::declare_interior_mutable_const)]\n+\n+use std::sync::atomic::AtomicUsize;\n+\n+enum Private<T> {\n+    ToBeUnfrozen(T),\n+    Frozen(usize),\n+}\n+\n+pub struct Wrapper(Private<AtomicUsize>);\n+\n+pub const WRAPPED_PRIVATE_UNFROZEN_VARIANT: Wrapper = Wrapper(Private::ToBeUnfrozen(AtomicUsize::new(6)));\n+pub const WRAPPED_PRIVATE_FROZEN_VARIANT: Wrapper = Wrapper(Private::Frozen(7));"}, {"sha": "5027db44561798d1ba05fe0e692af592da2612b5", "filename": "tests/ui/borrow_interior_mutable_const/enums.rs", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/694cec12bed1fb01f10622511fd72a9a8e0606f0/tests%2Fui%2Fborrow_interior_mutable_const%2Fenums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/694cec12bed1fb01f10622511fd72a9a8e0606f0/tests%2Fui%2Fborrow_interior_mutable_const%2Fenums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrow_interior_mutable_const%2Fenums.rs?ref=694cec12bed1fb01f10622511fd72a9a8e0606f0", "patch": "@@ -0,0 +1,101 @@\n+// aux-build:helper.rs\n+\n+#![warn(clippy::borrow_interior_mutable_const)]\n+#![allow(clippy::declare_interior_mutable_const)]\n+\n+// this file (mostly) replicates its `declare` counterpart. Please see it for more discussions.\n+\n+extern crate helper;\n+\n+use std::cell::Cell;\n+use std::sync::atomic::AtomicUsize;\n+\n+enum OptionalCell {\n+    Unfrozen(Cell<bool>),\n+    Frozen,\n+}\n+\n+const UNFROZEN_VARIANT: OptionalCell = OptionalCell::Unfrozen(Cell::new(true));\n+const FROZEN_VARIANT: OptionalCell = OptionalCell::Frozen;\n+\n+fn borrow_optional_cell() {\n+    let _ = &UNFROZEN_VARIANT; //~ ERROR interior mutability\n+    let _ = &FROZEN_VARIANT;\n+}\n+\n+trait AssocConsts {\n+    const TO_BE_UNFROZEN_VARIANT: OptionalCell;\n+    const TO_BE_FROZEN_VARIANT: OptionalCell;\n+\n+    const DEFAULTED_ON_UNFROZEN_VARIANT: OptionalCell = OptionalCell::Unfrozen(Cell::new(false));\n+    const DEFAULTED_ON_FROZEN_VARIANT: OptionalCell = OptionalCell::Frozen;\n+\n+    fn function() {\n+        // This is the \"suboptimal behavior\" mentioned in `is_value_unfrozen`\n+        // caused by a similar reason to unfrozen types without any default values\n+        // get linted even if it has frozen variants'.\n+        let _ = &Self::TO_BE_FROZEN_VARIANT; //~ ERROR interior mutable\n+\n+        // The lint ignores default values because an impl of this trait can set\n+        // an unfrozen variant to `DEFAULTED_ON_FROZEN_VARIANT` and use the default impl for `function`.\n+        let _ = &Self::DEFAULTED_ON_FROZEN_VARIANT; //~ ERROR interior mutable\n+    }\n+}\n+\n+impl AssocConsts for u64 {\n+    const TO_BE_UNFROZEN_VARIANT: OptionalCell = OptionalCell::Unfrozen(Cell::new(false));\n+    const TO_BE_FROZEN_VARIANT: OptionalCell = OptionalCell::Frozen;\n+\n+    fn function() {\n+        let _ = &<Self as AssocConsts>::TO_BE_UNFROZEN_VARIANT; //~ ERROR interior mutable\n+        let _ = &<Self as AssocConsts>::TO_BE_FROZEN_VARIANT;\n+        let _ = &Self::DEFAULTED_ON_UNFROZEN_VARIANT; //~ ERROR interior mutable\n+        let _ = &Self::DEFAULTED_ON_FROZEN_VARIANT;\n+    }\n+}\n+\n+trait AssocTypes {\n+    type ToBeUnfrozen;\n+\n+    const TO_BE_UNFROZEN_VARIANT: Option<Self::ToBeUnfrozen>;\n+    const TO_BE_FROZEN_VARIANT: Option<Self::ToBeUnfrozen>;\n+\n+    // there's no need to test here because it's the exactly same as `trait::AssocTypes`\n+    fn function();\n+}\n+\n+impl AssocTypes for u64 {\n+    type ToBeUnfrozen = AtomicUsize;\n+\n+    const TO_BE_UNFROZEN_VARIANT: Option<Self::ToBeUnfrozen> = Some(Self::ToBeUnfrozen::new(4)); //~ ERROR interior mutable\n+    const TO_BE_FROZEN_VARIANT: Option<Self::ToBeUnfrozen> = None;\n+\n+    fn function() {\n+        let _ = &<Self as AssocTypes>::TO_BE_UNFROZEN_VARIANT; //~ ERROR interior mutable\n+        let _ = &<Self as AssocTypes>::TO_BE_FROZEN_VARIANT;\n+    }\n+}\n+\n+enum BothOfCellAndGeneric<T> {\n+    Unfrozen(Cell<*const T>),\n+    Generic(*const T),\n+    Frozen(usize),\n+}\n+\n+impl<T> BothOfCellAndGeneric<T> {\n+    const UNFROZEN_VARIANT: BothOfCellAndGeneric<T> = BothOfCellAndGeneric::Unfrozen(Cell::new(std::ptr::null())); //~ ERROR interior mutable\n+    const GENERIC_VARIANT: BothOfCellAndGeneric<T> = BothOfCellAndGeneric::Generic(std::ptr::null()); //~ ERROR interior mutable\n+    const FROZEN_VARIANT: BothOfCellAndGeneric<T> = BothOfCellAndGeneric::Frozen(5);\n+\n+    fn function() {\n+        let _ = &Self::UNFROZEN_VARIANT; //~ ERROR interior mutability\n+        let _ = &Self::GENERIC_VARIANT; //~ ERROR interior mutability\n+        let _ = &Self::FROZEN_VARIANT;\n+    }\n+}\n+\n+fn main() {\n+    // constants defined in foreign crates\n+    let _ = &helper::WRAPPED_PRIVATE_UNFROZEN_VARIANT; //~ ERROR interior mutability\n+    let _ = &helper::WRAPPED_PRIVATE_FROZEN_VARIANT;\n+}"}, {"sha": "654a1ee7df659a402e4fb4404f43c65f00603cfe", "filename": "tests/ui/borrow_interior_mutable_const/enums.stderr", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/694cec12bed1fb01f10622511fd72a9a8e0606f0/tests%2Fui%2Fborrow_interior_mutable_const%2Fenums.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/694cec12bed1fb01f10622511fd72a9a8e0606f0/tests%2Fui%2Fborrow_interior_mutable_const%2Fenums.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrow_interior_mutable_const%2Fenums.stderr?ref=694cec12bed1fb01f10622511fd72a9a8e0606f0", "patch": "@@ -0,0 +1,75 @@\n+error: a `const` item with interior mutability should not be borrowed\n+  --> $DIR/enums.rs:22:14\n+   |\n+LL |     let _ = &UNFROZEN_VARIANT; //~ ERROR interior mutability\n+   |              ^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::borrow-interior-mutable-const` implied by `-D warnings`\n+   = help: assign this const to a local or static variable, and use the variable here\n+\n+error: a `const` item with interior mutability should not be borrowed\n+  --> $DIR/enums.rs:37:18\n+   |\n+LL |         let _ = &Self::TO_BE_FROZEN_VARIANT; //~ ERROR interior mutable\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: assign this const to a local or static variable, and use the variable here\n+\n+error: a `const` item with interior mutability should not be borrowed\n+  --> $DIR/enums.rs:41:18\n+   |\n+LL |         let _ = &Self::DEFAULTED_ON_FROZEN_VARIANT; //~ ERROR interior mutable\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: assign this const to a local or static variable, and use the variable here\n+\n+error: a `const` item with interior mutability should not be borrowed\n+  --> $DIR/enums.rs:50:18\n+   |\n+LL |         let _ = &<Self as AssocConsts>::TO_BE_UNFROZEN_VARIANT; //~ ERROR interior mutable\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: assign this const to a local or static variable, and use the variable here\n+\n+error: a `const` item with interior mutability should not be borrowed\n+  --> $DIR/enums.rs:52:18\n+   |\n+LL |         let _ = &Self::DEFAULTED_ON_UNFROZEN_VARIANT; //~ ERROR interior mutable\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: assign this const to a local or static variable, and use the variable here\n+\n+error: a `const` item with interior mutability should not be borrowed\n+  --> $DIR/enums.rs:74:18\n+   |\n+LL |         let _ = &<Self as AssocTypes>::TO_BE_UNFROZEN_VARIANT; //~ ERROR interior mutable\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: assign this const to a local or static variable, and use the variable here\n+\n+error: a `const` item with interior mutability should not be borrowed\n+  --> $DIR/enums.rs:91:18\n+   |\n+LL |         let _ = &Self::UNFROZEN_VARIANT; //~ ERROR interior mutability\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: assign this const to a local or static variable, and use the variable here\n+\n+error: a `const` item with interior mutability should not be borrowed\n+  --> $DIR/enums.rs:92:18\n+   |\n+LL |         let _ = &Self::GENERIC_VARIANT; //~ ERROR interior mutability\n+   |                  ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: assign this const to a local or static variable, and use the variable here\n+\n+error: a `const` item with interior mutability should not be borrowed\n+  --> $DIR/enums.rs:99:14\n+   |\n+LL |     let _ = &helper::WRAPPED_PRIVATE_UNFROZEN_VARIANT; //~ ERROR interior mutability\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: assign this const to a local or static variable, and use the variable here\n+\n+error: aborting due to 9 previous errors\n+"}, {"sha": "ea25729d11d4db08ae7c57c96bb0bf9bf09b05ff", "filename": "tests/ui/borrow_interior_mutable_const/others.rs", "status": "renamed", "additions": 2, "deletions": 31, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/694cec12bed1fb01f10622511fd72a9a8e0606f0/tests%2Fui%2Fborrow_interior_mutable_const%2Fothers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/694cec12bed1fb01f10622511fd72a9a8e0606f0/tests%2Fui%2Fborrow_interior_mutable_const%2Fothers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrow_interior_mutable_const%2Fothers.rs?ref=694cec12bed1fb01f10622511fd72a9a8e0606f0", "patch": "@@ -19,33 +19,7 @@ const NO_ANN: &dyn Display = &70;\n static STATIC_TUPLE: (AtomicUsize, String) = (ATOMIC, STRING);\n const ONCE_INIT: Once = Once::new();\n \n-trait Trait<T> {\n-    type AssocType;\n-\n-    const ATOMIC: AtomicUsize;\n-    const INPUT: T;\n-    const ASSOC: Self::AssocType;\n-\n-    fn function() {\n-        let _ = &Self::INPUT;\n-        let _ = &Self::ASSOC;\n-    }\n-}\n-\n-impl Trait<u32> for u64 {\n-    type AssocType = AtomicUsize;\n-\n-    const ATOMIC: AtomicUsize = AtomicUsize::new(9);\n-    const INPUT: u32 = 10;\n-    const ASSOC: Self::AssocType = AtomicUsize::new(11);\n-\n-    fn function() {\n-        let _ = &Self::INPUT;\n-        let _ = &Self::ASSOC; //~ ERROR interior mutability\n-    }\n-}\n-\n-// This is just a pointer that can be safely dereferended,\n+// This is just a pointer that can be safely dereferenced,\n // it's semantically the same as `&'static T`;\n // but it isn't allowed to make a static reference from an arbitrary integer value at the moment.\n // For more information, please see the issue #5918.\n@@ -100,7 +74,7 @@ fn main() {\n     let _ = &(&&&&ATOMIC_TUPLE).0; //~ ERROR interior mutability\n     let _ = &ATOMIC_TUPLE.0[0]; //~ ERROR interior mutability\n     let _ = ATOMIC_TUPLE.0[0].load(Ordering::SeqCst); //~ ERROR interior mutability\n-    let _ = &*ATOMIC_TUPLE.1; //~ ERROR interior mutability\n+    let _ = &*ATOMIC_TUPLE.1;\n     let _ = &ATOMIC_TUPLE.2;\n     let _ = (&&&&ATOMIC_TUPLE).0;\n     let _ = (&&&&ATOMIC_TUPLE).2;\n@@ -124,9 +98,6 @@ fn main() {\n     assert_eq!(STATIC_TUPLE.0.load(Ordering::SeqCst), 3);\n     assert!(STATIC_TUPLE.1.is_empty());\n \n-    u64::ATOMIC.store(5, Ordering::SeqCst); //~ ERROR interior mutability\n-    assert_eq!(u64::ATOMIC.load(Ordering::SeqCst), 9); //~ ERROR interior mutability\n-\n     assert_eq!(NO_ANN.to_string(), \"70\"); // should never lint this.\n \n     let _ = &CELL_REF.0;", "previous_filename": "tests/ui/borrow_interior_mutable_const.rs"}, {"sha": "9a908cf30e945cc100e1a98126448250704031f0", "filename": "tests/ui/borrow_interior_mutable_const/others.stderr", "status": "renamed", "additions": 16, "deletions": 40, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/694cec12bed1fb01f10622511fd72a9a8e0606f0/tests%2Fui%2Fborrow_interior_mutable_const%2Fothers.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/694cec12bed1fb01f10622511fd72a9a8e0606f0/tests%2Fui%2Fborrow_interior_mutable_const%2Fothers.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrow_interior_mutable_const%2Fothers.stderr?ref=694cec12bed1fb01f10622511fd72a9a8e0606f0", "patch": "@@ -1,139 +1,115 @@\n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:44:18\n-   |\n-LL |         let _ = &Self::ASSOC; //~ ERROR interior mutability\n-   |                  ^^^^^^^^^^^\n-   |\n-   = note: `-D clippy::borrow-interior-mutable-const` implied by `-D warnings`\n-   = help: assign this const to a local or static variable, and use the variable here\n-\n-error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:80:5\n+  --> $DIR/others.rs:54:5\n    |\n LL |     ATOMIC.store(1, Ordering::SeqCst); //~ ERROR interior mutability\n    |     ^^^^^^\n    |\n+   = note: `-D clippy::borrow-interior-mutable-const` implied by `-D warnings`\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:81:16\n+  --> $DIR/others.rs:55:16\n    |\n LL |     assert_eq!(ATOMIC.load(Ordering::SeqCst), 5); //~ ERROR interior mutability\n    |                ^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:84:22\n+  --> $DIR/others.rs:58:22\n    |\n LL |     let _once_ref = &ONCE_INIT; //~ ERROR interior mutability\n    |                      ^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:85:25\n+  --> $DIR/others.rs:59:25\n    |\n LL |     let _once_ref_2 = &&ONCE_INIT; //~ ERROR interior mutability\n    |                         ^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:86:27\n+  --> $DIR/others.rs:60:27\n    |\n LL |     let _once_ref_4 = &&&&ONCE_INIT; //~ ERROR interior mutability\n    |                           ^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:87:26\n+  --> $DIR/others.rs:61:26\n    |\n LL |     let _once_mut = &mut ONCE_INIT; //~ ERROR interior mutability\n    |                          ^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:98:14\n+  --> $DIR/others.rs:72:14\n    |\n LL |     let _ = &ATOMIC_TUPLE; //~ ERROR interior mutability\n    |              ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:99:14\n+  --> $DIR/others.rs:73:14\n    |\n LL |     let _ = &ATOMIC_TUPLE.0; //~ ERROR interior mutability\n    |              ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:100:19\n+  --> $DIR/others.rs:74:19\n    |\n LL |     let _ = &(&&&&ATOMIC_TUPLE).0; //~ ERROR interior mutability\n    |                   ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:101:14\n+  --> $DIR/others.rs:75:14\n    |\n LL |     let _ = &ATOMIC_TUPLE.0[0]; //~ ERROR interior mutability\n    |              ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:102:13\n+  --> $DIR/others.rs:76:13\n    |\n LL |     let _ = ATOMIC_TUPLE.0[0].load(Ordering::SeqCst); //~ ERROR interior mutability\n    |             ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:108:13\n+  --> $DIR/others.rs:82:13\n    |\n LL |     let _ = ATOMIC_TUPLE.0[0]; //~ ERROR interior mutability\n    |             ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:113:5\n+  --> $DIR/others.rs:87:5\n    |\n LL |     CELL.set(2); //~ ERROR interior mutability\n    |     ^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:114:16\n+  --> $DIR/others.rs:88:16\n    |\n LL |     assert_eq!(CELL.get(), 6); //~ ERROR interior mutability\n    |                ^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n-error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:127:5\n-   |\n-LL |     u64::ATOMIC.store(5, Ordering::SeqCst); //~ ERROR interior mutability\n-   |     ^^^^^^^^^^^\n-   |\n-   = help: assign this const to a local or static variable, and use the variable here\n-\n-error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:128:16\n-   |\n-LL |     assert_eq!(u64::ATOMIC.load(Ordering::SeqCst), 9); //~ ERROR interior mutability\n-   |                ^^^^^^^^^^^\n-   |\n-   = help: assign this const to a local or static variable, and use the variable here\n-\n-error: aborting due to 17 previous errors\n+error: aborting due to 14 previous errors\n ", "previous_filename": "tests/ui/borrow_interior_mutable_const.stderr"}, {"sha": "06b5d62e8f9a816706e03fb174c9a28a5e95189f", "filename": "tests/ui/borrow_interior_mutable_const/traits.rs", "status": "added", "additions": 202, "deletions": 0, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/694cec12bed1fb01f10622511fd72a9a8e0606f0/tests%2Fui%2Fborrow_interior_mutable_const%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/694cec12bed1fb01f10622511fd72a9a8e0606f0/tests%2Fui%2Fborrow_interior_mutable_const%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrow_interior_mutable_const%2Ftraits.rs?ref=694cec12bed1fb01f10622511fd72a9a8e0606f0", "patch": "@@ -0,0 +1,202 @@\n+#![warn(clippy::borrow_interior_mutable_const)]\n+#![allow(clippy::declare_interior_mutable_const)]\n+\n+// this file replicates its `declare` counterpart. Please see it for more discussions.\n+\n+use std::borrow::Cow;\n+use std::cell::Cell;\n+use std::sync::atomic::{AtomicUsize, Ordering};\n+\n+trait ConcreteTypes {\n+    const ATOMIC: AtomicUsize;\n+    const STRING: String;\n+\n+    fn function() {\n+        let _ = &Self::ATOMIC; //~ ERROR interior mutable\n+        let _ = &Self::STRING;\n+    }\n+}\n+\n+impl ConcreteTypes for u64 {\n+    const ATOMIC: AtomicUsize = AtomicUsize::new(9);\n+    const STRING: String = String::new();\n+\n+    fn function() {\n+        // Lint this again since implementers can choose not to borrow it.\n+        let _ = &Self::ATOMIC; //~ ERROR interior mutable\n+        let _ = &Self::STRING;\n+    }\n+}\n+\n+// a helper trait used below\n+trait ConstDefault {\n+    const DEFAULT: Self;\n+}\n+\n+trait GenericTypes<T, U> {\n+    const TO_REMAIN_GENERIC: T;\n+    const TO_BE_CONCRETE: U;\n+\n+    fn function() {\n+        let _ = &Self::TO_REMAIN_GENERIC;\n+    }\n+}\n+\n+impl<T: ConstDefault> GenericTypes<T, AtomicUsize> for Vec<T> {\n+    const TO_REMAIN_GENERIC: T = T::DEFAULT;\n+    const TO_BE_CONCRETE: AtomicUsize = AtomicUsize::new(11);\n+\n+    fn function() {\n+        let _ = &Self::TO_REMAIN_GENERIC;\n+        let _ = &Self::TO_BE_CONCRETE; //~ ERROR interior mutable\n+    }\n+}\n+\n+// a helper type used below\n+pub struct Wrapper<T>(T);\n+\n+trait AssocTypes {\n+    type ToBeFrozen;\n+    type ToBeUnfrozen;\n+    type ToBeGenericParam;\n+\n+    const TO_BE_FROZEN: Self::ToBeFrozen;\n+    const TO_BE_UNFROZEN: Self::ToBeUnfrozen;\n+    const WRAPPED_TO_BE_UNFROZEN: Wrapper<Self::ToBeUnfrozen>;\n+    const WRAPPED_TO_BE_GENERIC_PARAM: Wrapper<Self::ToBeGenericParam>;\n+\n+    fn function() {\n+        let _ = &Self::TO_BE_FROZEN;\n+        let _ = &Self::WRAPPED_TO_BE_UNFROZEN;\n+    }\n+}\n+\n+impl<T: ConstDefault> AssocTypes for Vec<T> {\n+    type ToBeFrozen = u16;\n+    type ToBeUnfrozen = AtomicUsize;\n+    type ToBeGenericParam = T;\n+\n+    const TO_BE_FROZEN: Self::ToBeFrozen = 12;\n+    const TO_BE_UNFROZEN: Self::ToBeUnfrozen = AtomicUsize::new(13);\n+    const WRAPPED_TO_BE_UNFROZEN: Wrapper<Self::ToBeUnfrozen> = Wrapper(AtomicUsize::new(14));\n+    const WRAPPED_TO_BE_GENERIC_PARAM: Wrapper<Self::ToBeGenericParam> = Wrapper(T::DEFAULT);\n+\n+    fn function() {\n+        let _ = &Self::TO_BE_FROZEN;\n+        let _ = &Self::TO_BE_UNFROZEN; //~ ERROR interior mutable\n+        let _ = &Self::WRAPPED_TO_BE_UNFROZEN; //~ ERROR interior mutable\n+        let _ = &Self::WRAPPED_TO_BE_GENERIC_PARAM;\n+    }\n+}\n+\n+// a helper trait used below\n+trait AssocTypesHelper {\n+    type NotToBeBounded;\n+    type ToBeBounded;\n+\n+    const NOT_TO_BE_BOUNDED: Self::NotToBeBounded;\n+}\n+\n+trait AssocTypesFromGenericParam<T>\n+where\n+    T: AssocTypesHelper<ToBeBounded = AtomicUsize>,\n+{\n+    const NOT_BOUNDED: T::NotToBeBounded;\n+    const BOUNDED: T::ToBeBounded;\n+\n+    fn function() {\n+        let _ = &Self::NOT_BOUNDED;\n+        let _ = &Self::BOUNDED; //~ ERROR interior mutable\n+    }\n+}\n+\n+impl<T> AssocTypesFromGenericParam<T> for Vec<T>\n+where\n+    T: AssocTypesHelper<ToBeBounded = AtomicUsize>,\n+{\n+    const NOT_BOUNDED: T::NotToBeBounded = T::NOT_TO_BE_BOUNDED;\n+    const BOUNDED: T::ToBeBounded = AtomicUsize::new(15);\n+\n+    fn function() {\n+        let _ = &Self::NOT_BOUNDED;\n+        let _ = &Self::BOUNDED; //~ ERROR interior mutable\n+    }\n+}\n+\n+trait SelfType: Sized {\n+    const SELF: Self;\n+    const WRAPPED_SELF: Option<Self>;\n+\n+    fn function() {\n+        let _ = &Self::SELF;\n+        let _ = &Self::WRAPPED_SELF;\n+    }\n+}\n+\n+impl SelfType for u64 {\n+    const SELF: Self = 16;\n+    const WRAPPED_SELF: Option<Self> = Some(20);\n+\n+    fn function() {\n+        let _ = &Self::SELF;\n+        let _ = &Self::WRAPPED_SELF;\n+    }\n+}\n+\n+impl SelfType for AtomicUsize {\n+    const SELF: Self = AtomicUsize::new(17);\n+    const WRAPPED_SELF: Option<Self> = Some(AtomicUsize::new(21));\n+\n+    fn function() {\n+        let _ = &Self::SELF; //~ ERROR interior mutable\n+        let _ = &Self::WRAPPED_SELF; //~ ERROR interior mutable\n+    }\n+}\n+\n+trait BothOfCellAndGeneric<T> {\n+    const DIRECT: Cell<T>;\n+    const INDIRECT: Cell<*const T>;\n+\n+    fn function() {\n+        let _ = &Self::DIRECT;\n+        let _ = &Self::INDIRECT; //~ ERROR interior mutable\n+    }\n+}\n+\n+impl<T: ConstDefault> BothOfCellAndGeneric<T> for Vec<T> {\n+    const DIRECT: Cell<T> = Cell::new(T::DEFAULT);\n+    const INDIRECT: Cell<*const T> = Cell::new(std::ptr::null());\n+\n+    fn function() {\n+        let _ = &Self::DIRECT;\n+        let _ = &Self::INDIRECT; //~ ERROR interior mutable\n+    }\n+}\n+\n+struct Local<T>(T);\n+\n+impl<T> Local<T>\n+where\n+    T: ConstDefault + AssocTypesHelper<ToBeBounded = AtomicUsize>,\n+{\n+    const ATOMIC: AtomicUsize = AtomicUsize::new(18);\n+    const COW: Cow<'static, str> = Cow::Borrowed(\"tuvwxy\");\n+\n+    const GENERIC_TYPE: T = T::DEFAULT;\n+\n+    const ASSOC_TYPE: T::NotToBeBounded = T::NOT_TO_BE_BOUNDED;\n+    const BOUNDED_ASSOC_TYPE: T::ToBeBounded = AtomicUsize::new(19);\n+\n+    fn function() {\n+        let _ = &Self::ATOMIC; //~ ERROR interior mutable\n+        let _ = &Self::COW;\n+        let _ = &Self::GENERIC_TYPE;\n+        let _ = &Self::ASSOC_TYPE;\n+        let _ = &Self::BOUNDED_ASSOC_TYPE; //~ ERROR interior mutable\n+    }\n+}\n+\n+fn main() {\n+    u64::ATOMIC.store(5, Ordering::SeqCst); //~ ERROR interior mutability\n+    assert_eq!(u64::ATOMIC.load(Ordering::SeqCst), 9); //~ ERROR interior mutability\n+}"}, {"sha": "8f26403abd3ee0444c0f05a52e4cad2677f0b065", "filename": "tests/ui/borrow_interior_mutable_const/traits.stderr", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/694cec12bed1fb01f10622511fd72a9a8e0606f0/tests%2Fui%2Fborrow_interior_mutable_const%2Ftraits.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/694cec12bed1fb01f10622511fd72a9a8e0606f0/tests%2Fui%2Fborrow_interior_mutable_const%2Ftraits.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrow_interior_mutable_const%2Ftraits.stderr?ref=694cec12bed1fb01f10622511fd72a9a8e0606f0", "patch": "@@ -0,0 +1,123 @@\n+error: a `const` item with interior mutability should not be borrowed\n+  --> $DIR/traits.rs:15:18\n+   |\n+LL |         let _ = &Self::ATOMIC; //~ ERROR interior mutable\n+   |                  ^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::borrow-interior-mutable-const` implied by `-D warnings`\n+   = help: assign this const to a local or static variable, and use the variable here\n+\n+error: a `const` item with interior mutability should not be borrowed\n+  --> $DIR/traits.rs:26:18\n+   |\n+LL |         let _ = &Self::ATOMIC; //~ ERROR interior mutable\n+   |                  ^^^^^^^^^^^^\n+   |\n+   = help: assign this const to a local or static variable, and use the variable here\n+\n+error: a `const` item with interior mutability should not be borrowed\n+  --> $DIR/traits.rs:51:18\n+   |\n+LL |         let _ = &Self::TO_BE_CONCRETE; //~ ERROR interior mutable\n+   |                  ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: assign this const to a local or static variable, and use the variable here\n+\n+error: a `const` item with interior mutability should not be borrowed\n+  --> $DIR/traits.rs:86:18\n+   |\n+LL |         let _ = &Self::TO_BE_UNFROZEN; //~ ERROR interior mutable\n+   |                  ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: assign this const to a local or static variable, and use the variable here\n+\n+error: a `const` item with interior mutability should not be borrowed\n+  --> $DIR/traits.rs:87:18\n+   |\n+LL |         let _ = &Self::WRAPPED_TO_BE_UNFROZEN; //~ ERROR interior mutable\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: assign this const to a local or static variable, and use the variable here\n+\n+error: a `const` item with interior mutability should not be borrowed\n+  --> $DIR/traits.rs:109:18\n+   |\n+LL |         let _ = &Self::BOUNDED; //~ ERROR interior mutable\n+   |                  ^^^^^^^^^^^^^\n+   |\n+   = help: assign this const to a local or static variable, and use the variable here\n+\n+error: a `const` item with interior mutability should not be borrowed\n+  --> $DIR/traits.rs:122:18\n+   |\n+LL |         let _ = &Self::BOUNDED; //~ ERROR interior mutable\n+   |                  ^^^^^^^^^^^^^\n+   |\n+   = help: assign this const to a local or static variable, and use the variable here\n+\n+error: a `const` item with interior mutability should not be borrowed\n+  --> $DIR/traits.rs:151:18\n+   |\n+LL |         let _ = &Self::SELF; //~ ERROR interior mutable\n+   |                  ^^^^^^^^^^\n+   |\n+   = help: assign this const to a local or static variable, and use the variable here\n+\n+error: a `const` item with interior mutability should not be borrowed\n+  --> $DIR/traits.rs:152:18\n+   |\n+LL |         let _ = &Self::WRAPPED_SELF; //~ ERROR interior mutable\n+   |                  ^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: assign this const to a local or static variable, and use the variable here\n+\n+error: a `const` item with interior mutability should not be borrowed\n+  --> $DIR/traits.rs:162:18\n+   |\n+LL |         let _ = &Self::INDIRECT; //~ ERROR interior mutable\n+   |                  ^^^^^^^^^^^^^^\n+   |\n+   = help: assign this const to a local or static variable, and use the variable here\n+\n+error: a `const` item with interior mutability should not be borrowed\n+  --> $DIR/traits.rs:172:18\n+   |\n+LL |         let _ = &Self::INDIRECT; //~ ERROR interior mutable\n+   |                  ^^^^^^^^^^^^^^\n+   |\n+   = help: assign this const to a local or static variable, and use the variable here\n+\n+error: a `const` item with interior mutability should not be borrowed\n+  --> $DIR/traits.rs:191:18\n+   |\n+LL |         let _ = &Self::ATOMIC; //~ ERROR interior mutable\n+   |                  ^^^^^^^^^^^^\n+   |\n+   = help: assign this const to a local or static variable, and use the variable here\n+\n+error: a `const` item with interior mutability should not be borrowed\n+  --> $DIR/traits.rs:195:18\n+   |\n+LL |         let _ = &Self::BOUNDED_ASSOC_TYPE; //~ ERROR interior mutable\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: assign this const to a local or static variable, and use the variable here\n+\n+error: a `const` item with interior mutability should not be borrowed\n+  --> $DIR/traits.rs:200:5\n+   |\n+LL |     u64::ATOMIC.store(5, Ordering::SeqCst); //~ ERROR interior mutability\n+   |     ^^^^^^^^^^^\n+   |\n+   = help: assign this const to a local or static variable, and use the variable here\n+\n+error: a `const` item with interior mutability should not be borrowed\n+  --> $DIR/traits.rs:201:16\n+   |\n+LL |     assert_eq!(u64::ATOMIC.load(Ordering::SeqCst), 9); //~ ERROR interior mutability\n+   |                ^^^^^^^^^^^\n+   |\n+   = help: assign this const to a local or static variable, and use the variable here\n+\n+error: aborting due to 15 previous errors\n+"}, {"sha": "f44518694b89c309bc4ae14326f112367a878ac5", "filename": "tests/ui/declare_interior_mutable_const/enums.rs", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/694cec12bed1fb01f10622511fd72a9a8e0606f0/tests%2Fui%2Fdeclare_interior_mutable_const%2Fenums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/694cec12bed1fb01f10622511fd72a9a8e0606f0/tests%2Fui%2Fdeclare_interior_mutable_const%2Fenums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdeclare_interior_mutable_const%2Fenums.rs?ref=694cec12bed1fb01f10622511fd72a9a8e0606f0", "patch": "@@ -0,0 +1,123 @@\n+#![warn(clippy::declare_interior_mutable_const)]\n+\n+use std::cell::Cell;\n+use std::sync::atomic::AtomicUsize;\n+\n+enum OptionalCell {\n+    Unfrozen(Cell<bool>),\n+    Frozen,\n+}\n+\n+// a constant with enums should be linted only when the used variant is unfrozen (#3962).\n+const UNFROZEN_VARIANT: OptionalCell = OptionalCell::Unfrozen(Cell::new(true)); //~ ERROR interior mutable\n+const FROZEN_VARIANT: OptionalCell = OptionalCell::Frozen;\n+\n+const fn unfrozen_variant() -> OptionalCell {\n+    OptionalCell::Unfrozen(Cell::new(false))\n+}\n+\n+const fn frozen_variant() -> OptionalCell {\n+    OptionalCell::Frozen\n+}\n+\n+const UNFROZEN_VARIANT_FROM_FN: OptionalCell = unfrozen_variant(); //~ ERROR interior mutable\n+const FROZEN_VARIANT_FROM_FN: OptionalCell = frozen_variant();\n+\n+enum NestedInnermost {\n+    Unfrozen(AtomicUsize),\n+    Frozen,\n+}\n+\n+struct NestedInner {\n+    inner: NestedInnermost,\n+}\n+\n+enum NestedOuter {\n+    NestedInner(NestedInner),\n+    NotNested(usize),\n+}\n+\n+struct NestedOutermost {\n+    outer: NestedOuter,\n+}\n+\n+// a constant with enums should be linted according to its value, no matter how structs involve.\n+const NESTED_UNFROZEN_VARIANT: NestedOutermost = NestedOutermost {\n+    outer: NestedOuter::NestedInner(NestedInner {\n+        inner: NestedInnermost::Unfrozen(AtomicUsize::new(2)),\n+    }),\n+}; //~ ERROR interior mutable\n+const NESTED_FROZEN_VARIANT: NestedOutermost = NestedOutermost {\n+    outer: NestedOuter::NestedInner(NestedInner {\n+        inner: NestedInnermost::Frozen,\n+    }),\n+};\n+\n+trait AssocConsts {\n+    // When there's no default value, lint it only according to its type.\n+    // Further details are on the corresponding code (`NonCopyConst::check_trait_item`).\n+    const TO_BE_UNFROZEN_VARIANT: OptionalCell; //~ ERROR interior mutable\n+    const TO_BE_FROZEN_VARIANT: OptionalCell; //~ ERROR interior mutable\n+\n+    // Lint default values accordingly.\n+    const DEFAULTED_ON_UNFROZEN_VARIANT: OptionalCell = OptionalCell::Unfrozen(Cell::new(false)); //~ ERROR interior mutable\n+    const DEFAULTED_ON_FROZEN_VARIANT: OptionalCell = OptionalCell::Frozen;\n+}\n+\n+// The lint doesn't trigger for an assoc constant in a trait impl with an unfrozen type even if it\n+// has enums. Further details are on the corresponding code in 'NonCopyConst::check_impl_item'.\n+impl AssocConsts for u64 {\n+    const TO_BE_UNFROZEN_VARIANT: OptionalCell = OptionalCell::Unfrozen(Cell::new(false));\n+    const TO_BE_FROZEN_VARIANT: OptionalCell = OptionalCell::Frozen;\n+\n+    // even if this sets an unfrozen variant, the lint ignores it.\n+    const DEFAULTED_ON_FROZEN_VARIANT: OptionalCell = OptionalCell::Unfrozen(Cell::new(false));\n+}\n+\n+// At first, I thought I'd need to check every patterns in `trait.rs`; but, what matters\n+// here are values; and I think substituted generics at definitions won't appear in MIR.\n+trait AssocTypes {\n+    type ToBeUnfrozen;\n+\n+    const TO_BE_UNFROZEN_VARIANT: Option<Self::ToBeUnfrozen>;\n+    const TO_BE_FROZEN_VARIANT: Option<Self::ToBeUnfrozen>;\n+}\n+\n+impl AssocTypes for u64 {\n+    type ToBeUnfrozen = AtomicUsize;\n+\n+    const TO_BE_UNFROZEN_VARIANT: Option<Self::ToBeUnfrozen> = Some(Self::ToBeUnfrozen::new(4)); //~ ERROR interior mutable\n+    const TO_BE_FROZEN_VARIANT: Option<Self::ToBeUnfrozen> = None;\n+}\n+\n+// Use raw pointers since direct generics have a false negative at the type level.\n+enum BothOfCellAndGeneric<T> {\n+    Unfrozen(Cell<*const T>),\n+    Generic(*const T),\n+    Frozen(usize),\n+}\n+\n+impl<T> BothOfCellAndGeneric<T> {\n+    const UNFROZEN_VARIANT: BothOfCellAndGeneric<T> = BothOfCellAndGeneric::Unfrozen(Cell::new(std::ptr::null())); //~ ERROR interior mutable\n+\n+    // This is a false positive. The argument about this is on `is_value_unfrozen_raw`\n+    const GENERIC_VARIANT: BothOfCellAndGeneric<T> = BothOfCellAndGeneric::Generic(std::ptr::null()); //~ ERROR interior mutable\n+\n+    const FROZEN_VARIANT: BothOfCellAndGeneric<T> = BothOfCellAndGeneric::Frozen(5);\n+\n+    // This is what is likely to be a false negative when one tries to fix\n+    // the `GENERIC_VARIANT` false positive.\n+    const NO_ENUM: Cell<*const T> = Cell::new(std::ptr::null()); //~ ERROR interior mutable\n+}\n+\n+// associated types here is basically the same as the one above.\n+trait BothOfCellAndGenericWithAssocType {\n+    type AssocType;\n+\n+    const UNFROZEN_VARIANT: BothOfCellAndGeneric<Self::AssocType> =\n+        BothOfCellAndGeneric::Unfrozen(Cell::new(std::ptr::null())); //~ ERROR interior mutable\n+    const GENERIC_VARIANT: BothOfCellAndGeneric<Self::AssocType> = BothOfCellAndGeneric::Generic(std::ptr::null()); //~ ERROR interior mutable\n+    const FROZEN_VARIANT: BothOfCellAndGeneric<Self::AssocType> = BothOfCellAndGeneric::Frozen(5);\n+}\n+\n+fn main() {}"}, {"sha": "84198d5461578ca4c1ff4e95ca895be899db748e", "filename": "tests/ui/declare_interior_mutable_const/enums.stderr", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/694cec12bed1fb01f10622511fd72a9a8e0606f0/tests%2Fui%2Fdeclare_interior_mutable_const%2Fenums.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/694cec12bed1fb01f10622511fd72a9a8e0606f0/tests%2Fui%2Fdeclare_interior_mutable_const%2Fenums.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdeclare_interior_mutable_const%2Fenums.stderr?ref=694cec12bed1fb01f10622511fd72a9a8e0606f0", "patch": "@@ -0,0 +1,89 @@\n+error: a `const` item should never be interior mutable\n+  --> $DIR/enums.rs:12:1\n+   |\n+LL | const UNFROZEN_VARIANT: OptionalCell = OptionalCell::Unfrozen(Cell::new(true)); //~ ERROR interior mutable\n+   | -----^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   | |\n+   | make this a static item (maybe with lazy_static)\n+   |\n+   = note: `-D clippy::declare-interior-mutable-const` implied by `-D warnings`\n+\n+error: a `const` item should never be interior mutable\n+  --> $DIR/enums.rs:23:1\n+   |\n+LL | const UNFROZEN_VARIANT_FROM_FN: OptionalCell = unfrozen_variant(); //~ ERROR interior mutable\n+   | -----^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   | |\n+   | make this a static item (maybe with lazy_static)\n+\n+error: a `const` item should never be interior mutable\n+  --> $DIR/enums.rs:45:1\n+   |\n+LL |   const NESTED_UNFROZEN_VARIANT: NestedOutermost = NestedOutermost {\n+   |   ^----\n+   |   |\n+   |  _make this a static item (maybe with lazy_static)\n+   | |\n+LL | |     outer: NestedOuter::NestedInner(NestedInner {\n+LL | |         inner: NestedInnermost::Unfrozen(AtomicUsize::new(2)),\n+LL | |     }),\n+LL | | }; //~ ERROR interior mutable\n+   | |__^\n+\n+error: a `const` item should never be interior mutable\n+  --> $DIR/enums.rs:59:5\n+   |\n+LL |     const TO_BE_UNFROZEN_VARIANT: OptionalCell; //~ ERROR interior mutable\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: a `const` item should never be interior mutable\n+  --> $DIR/enums.rs:60:5\n+   |\n+LL |     const TO_BE_FROZEN_VARIANT: OptionalCell; //~ ERROR interior mutable\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: a `const` item should never be interior mutable\n+  --> $DIR/enums.rs:63:5\n+   |\n+LL |     const DEFAULTED_ON_UNFROZEN_VARIANT: OptionalCell = OptionalCell::Unfrozen(Cell::new(false)); //~ ERROR interior mutable\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: a `const` item should never be interior mutable\n+  --> $DIR/enums.rs:89:5\n+   |\n+LL |     const TO_BE_UNFROZEN_VARIANT: Option<Self::ToBeUnfrozen> = Some(Self::ToBeUnfrozen::new(4)); //~ ERROR interior mutable\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: a `const` item should never be interior mutable\n+  --> $DIR/enums.rs:101:5\n+   |\n+LL |     const UNFROZEN_VARIANT: BothOfCellAndGeneric<T> = BothOfCellAndGeneric::Unfrozen(Cell::new(std::ptr::null())); //~ ERROR interior mut...\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: a `const` item should never be interior mutable\n+  --> $DIR/enums.rs:104:5\n+   |\n+LL |     const GENERIC_VARIANT: BothOfCellAndGeneric<T> = BothOfCellAndGeneric::Generic(std::ptr::null()); //~ ERROR interior mutable\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: a `const` item should never be interior mutable\n+  --> $DIR/enums.rs:110:5\n+   |\n+LL |     const NO_ENUM: Cell<*const T> = Cell::new(std::ptr::null()); //~ ERROR interior mutable\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: a `const` item should never be interior mutable\n+  --> $DIR/enums.rs:117:5\n+   |\n+LL | /     const UNFROZEN_VARIANT: BothOfCellAndGeneric<Self::AssocType> =\n+LL | |         BothOfCellAndGeneric::Unfrozen(Cell::new(std::ptr::null())); //~ ERROR interior mutable\n+   | |____________________________________________________________________^\n+\n+error: a `const` item should never be interior mutable\n+  --> $DIR/enums.rs:119:5\n+   |\n+LL |     const GENERIC_VARIANT: BothOfCellAndGeneric<Self::AssocType> = BothOfCellAndGeneric::Generic(std::ptr::null()); //~ ERROR interior mu...\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 12 previous errors\n+"}, {"sha": "48c5e9537d6d088111316151823a6c838e55e5c4", "filename": "tests/ui/declare_interior_mutable_const/others.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/694cec12bed1fb01f10622511fd72a9a8e0606f0/tests%2Fui%2Fdeclare_interior_mutable_const%2Fothers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/694cec12bed1fb01f10622511fd72a9a8e0606f0/tests%2Fui%2Fdeclare_interior_mutable_const%2Fothers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdeclare_interior_mutable_const%2Fothers.rs?ref=694cec12bed1fb01f10622511fd72a9a8e0606f0", "patch": "@@ -0,0 +1,34 @@\n+#![warn(clippy::declare_interior_mutable_const)]\n+\n+use std::borrow::Cow;\n+use std::cell::Cell;\n+use std::fmt::Display;\n+use std::sync::atomic::AtomicUsize;\n+use std::sync::Once;\n+\n+const ATOMIC: AtomicUsize = AtomicUsize::new(5); //~ ERROR interior mutable\n+const CELL: Cell<usize> = Cell::new(6); //~ ERROR interior mutable\n+const ATOMIC_TUPLE: ([AtomicUsize; 1], Vec<AtomicUsize>, u8) = ([ATOMIC], Vec::new(), 7);\n+//~^ ERROR interior mutable\n+\n+macro_rules! declare_const {\n+    ($name:ident: $ty:ty = $e:expr) => {\n+        const $name: $ty = $e;\n+    };\n+}\n+declare_const!(_ONCE: Once = Once::new()); //~ ERROR interior mutable\n+\n+// const ATOMIC_REF: &AtomicUsize = &AtomicUsize::new(7); // This will simply trigger E0492.\n+\n+const INTEGER: u8 = 8;\n+const STRING: String = String::new();\n+const STR: &str = \"012345\";\n+const COW: Cow<str> = Cow::Borrowed(\"abcdef\");\n+//^ note: a const item of Cow is used in the `postgres` package.\n+\n+const NO_ANN: &dyn Display = &70;\n+\n+static STATIC_TUPLE: (AtomicUsize, String) = (ATOMIC, STRING);\n+//^ there should be no lints on this line\n+\n+fn main() {}"}, {"sha": "6153c96edc4f425e254084377242028e490203cb", "filename": "tests/ui/declare_interior_mutable_const/others.stderr", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/694cec12bed1fb01f10622511fd72a9a8e0606f0/tests%2Fui%2Fdeclare_interior_mutable_const%2Fothers.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/694cec12bed1fb01f10622511fd72a9a8e0606f0/tests%2Fui%2Fdeclare_interior_mutable_const%2Fothers.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdeclare_interior_mutable_const%2Fothers.stderr?ref=694cec12bed1fb01f10622511fd72a9a8e0606f0", "patch": "@@ -0,0 +1,39 @@\n+error: a `const` item should never be interior mutable\n+  --> $DIR/others.rs:9:1\n+   |\n+LL | const ATOMIC: AtomicUsize = AtomicUsize::new(5); //~ ERROR interior mutable\n+   | -----^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   | |\n+   | make this a static item (maybe with lazy_static)\n+   |\n+   = note: `-D clippy::declare-interior-mutable-const` implied by `-D warnings`\n+\n+error: a `const` item should never be interior mutable\n+  --> $DIR/others.rs:10:1\n+   |\n+LL | const CELL: Cell<usize> = Cell::new(6); //~ ERROR interior mutable\n+   | -----^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   | |\n+   | make this a static item (maybe with lazy_static)\n+\n+error: a `const` item should never be interior mutable\n+  --> $DIR/others.rs:11:1\n+   |\n+LL | const ATOMIC_TUPLE: ([AtomicUsize; 1], Vec<AtomicUsize>, u8) = ([ATOMIC], Vec::new(), 7);\n+   | -----^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   | |\n+   | make this a static item (maybe with lazy_static)\n+\n+error: a `const` item should never be interior mutable\n+  --> $DIR/others.rs:16:9\n+   |\n+LL |         const $name: $ty = $e;\n+   |         ^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL | declare_const!(_ONCE: Once = Once::new()); //~ ERROR interior mutable\n+   | ------------------------------------------ in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "535147ccc645121259280495102cb985c4905d15", "filename": "tests/ui/declare_interior_mutable_const/traits.rs", "status": "renamed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/694cec12bed1fb01f10622511fd72a9a8e0606f0/tests%2Fui%2Fdeclare_interior_mutable_const%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/694cec12bed1fb01f10622511fd72a9a8e0606f0/tests%2Fui%2Fdeclare_interior_mutable_const%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdeclare_interior_mutable_const%2Ftraits.rs?ref=694cec12bed1fb01f10622511fd72a9a8e0606f0", "patch": "@@ -2,37 +2,13 @@\n \n use std::borrow::Cow;\n use std::cell::Cell;\n-use std::fmt::Display;\n use std::sync::atomic::AtomicUsize;\n-use std::sync::Once;\n-\n-const ATOMIC: AtomicUsize = AtomicUsize::new(5); //~ ERROR interior mutable\n-const CELL: Cell<usize> = Cell::new(6); //~ ERROR interior mutable\n-const ATOMIC_TUPLE: ([AtomicUsize; 1], Vec<AtomicUsize>, u8) = ([ATOMIC], Vec::new(), 7);\n-//~^ ERROR interior mutable\n \n macro_rules! declare_const {\n     ($name:ident: $ty:ty = $e:expr) => {\n         const $name: $ty = $e;\n     };\n }\n-declare_const!(_ONCE: Once = Once::new()); //~ ERROR interior mutable\n-\n-// const ATOMIC_REF: &AtomicUsize = &AtomicUsize::new(7); // This will simply trigger E0492.\n-\n-const INTEGER: u8 = 8;\n-const STRING: String = String::new();\n-const STR: &str = \"012345\";\n-const COW: Cow<str> = Cow::Borrowed(\"abcdef\");\n-//^ note: a const item of Cow is used in the `postgres` package.\n-\n-const NO_ANN: &dyn Display = &70;\n-\n-static STATIC_TUPLE: (AtomicUsize, String) = (ATOMIC, STRING);\n-//^ there should be no lints on this line\n-\n-#[allow(clippy::declare_interior_mutable_const)]\n-const ONCE_INIT: Once = Once::new();\n \n // a constant whose type is a concrete type should be linted at the definition site.\n trait ConcreteTypes {", "previous_filename": "tests/ui/declare_interior_mutable_const.rs"}, {"sha": "bb77f39b62c1f668a2729b871c728ecb66567816", "filename": "tests/ui/declare_interior_mutable_const/traits.stderr", "status": "renamed", "additions": 14, "deletions": 49, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/694cec12bed1fb01f10622511fd72a9a8e0606f0/tests%2Fui%2Fdeclare_interior_mutable_const%2Ftraits.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/694cec12bed1fb01f10622511fd72a9a8e0606f0/tests%2Fui%2Fdeclare_interior_mutable_const%2Ftraits.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdeclare_interior_mutable_const%2Ftraits.stderr?ref=694cec12bed1fb01f10622511fd72a9a8e0606f0", "patch": "@@ -1,48 +1,13 @@\n error: a `const` item should never be interior mutable\n-  --> $DIR/declare_interior_mutable_const.rs:9:1\n-   |\n-LL | const ATOMIC: AtomicUsize = AtomicUsize::new(5); //~ ERROR interior mutable\n-   | -----^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   | |\n-   | make this a static item (maybe with lazy_static)\n-   |\n-   = note: `-D clippy::declare-interior-mutable-const` implied by `-D warnings`\n-\n-error: a `const` item should never be interior mutable\n-  --> $DIR/declare_interior_mutable_const.rs:10:1\n-   |\n-LL | const CELL: Cell<usize> = Cell::new(6); //~ ERROR interior mutable\n-   | -----^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   | |\n-   | make this a static item (maybe with lazy_static)\n-\n-error: a `const` item should never be interior mutable\n-  --> $DIR/declare_interior_mutable_const.rs:11:1\n-   |\n-LL | const ATOMIC_TUPLE: ([AtomicUsize; 1], Vec<AtomicUsize>, u8) = ([ATOMIC], Vec::new(), 7);\n-   | -----^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   | |\n-   | make this a static item (maybe with lazy_static)\n-\n-error: a `const` item should never be interior mutable\n-  --> $DIR/declare_interior_mutable_const.rs:16:9\n-   |\n-LL |         const $name: $ty = $e;\n-   |         ^^^^^^^^^^^^^^^^^^^^^^\n-...\n-LL | declare_const!(_ONCE: Once = Once::new()); //~ ERROR interior mutable\n-   | ------------------------------------------ in this macro invocation\n-   |\n-   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error: a `const` item should never be interior mutable\n-  --> $DIR/declare_interior_mutable_const.rs:39:5\n+  --> $DIR/traits.rs:15:5\n    |\n LL |     const ATOMIC: AtomicUsize; //~ ERROR interior mutable\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::declare-interior-mutable-const` implied by `-D warnings`\n \n error: a `const` item should never be interior mutable\n-  --> $DIR/declare_interior_mutable_const.rs:16:9\n+  --> $DIR/traits.rs:9:9\n    |\n LL |         const $name: $ty = $e;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n@@ -53,58 +18,58 @@ LL |     declare_const!(ANOTHER_ATOMIC: AtomicUsize = Self::ATOMIC); //~ ERROR i\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: a `const` item should never be interior mutable\n-  --> $DIR/declare_interior_mutable_const.rs:67:5\n+  --> $DIR/traits.rs:43:5\n    |\n LL |     const TO_BE_CONCRETE: AtomicUsize = AtomicUsize::new(11); //~ ERROR interior mutable\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: a `const` item should never be interior mutable\n-  --> $DIR/declare_interior_mutable_const.rs:92:5\n+  --> $DIR/traits.rs:68:5\n    |\n LL |     const TO_BE_UNFROZEN: Self::ToBeUnfrozen = AtomicUsize::new(13); //~ ERROR interior mutable\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: a `const` item should never be interior mutable\n-  --> $DIR/declare_interior_mutable_const.rs:93:5\n+  --> $DIR/traits.rs:69:5\n    |\n LL |     const WRAPPED_TO_BE_UNFROZEN: Wrapper<Self::ToBeUnfrozen> = Wrapper(AtomicUsize::new(14)); //~ ERROR interior mutable\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: a `const` item should never be interior mutable\n-  --> $DIR/declare_interior_mutable_const.rs:112:5\n+  --> $DIR/traits.rs:88:5\n    |\n LL |     const BOUNDED: T::ToBeBounded; //~ ERROR interior mutable\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: a `const` item should never be interior mutable\n-  --> $DIR/declare_interior_mutable_const.rs:140:5\n+  --> $DIR/traits.rs:116:5\n    |\n LL |     const SELF: Self = AtomicUsize::new(17); //~ ERROR interior mutable\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: a `const` item should never be interior mutable\n-  --> $DIR/declare_interior_mutable_const.rs:141:5\n+  --> $DIR/traits.rs:117:5\n    |\n LL |     const WRAPPED_SELF: Option<Self> = Some(AtomicUsize::new(21)); //~ ERROR interior mutable\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: a `const` item should never be interior mutable\n-  --> $DIR/declare_interior_mutable_const.rs:149:5\n+  --> $DIR/traits.rs:125:5\n    |\n LL |     const INDIRECT: Cell<*const T>; //~ ERROR interior mutable\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: a `const` item should never be interior mutable\n-  --> $DIR/declare_interior_mutable_const.rs:165:5\n+  --> $DIR/traits.rs:141:5\n    |\n LL |     const ATOMIC: AtomicUsize = AtomicUsize::new(18); //~ ERROR interior mutable\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: a `const` item should never be interior mutable\n-  --> $DIR/declare_interior_mutable_const.rs:171:5\n+  --> $DIR/traits.rs:147:5\n    |\n LL |     const BOUNDED_ASSOC_TYPE: T::ToBeBounded = AtomicUsize::new(19); //~ ERROR interior mutable\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 15 previous errors\n+error: aborting due to 11 previous errors\n ", "previous_filename": "tests/ui/declare_interior_mutable_const.stderr"}]}