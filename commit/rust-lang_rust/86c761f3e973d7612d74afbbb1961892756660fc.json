{"sha": "86c761f3e973d7612d74afbbb1961892756660fc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2Yzc2MWYzZTk3M2Q3NjEyZDc0YWZiYmIxOTYxODkyNzU2NjYwZmM=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2019-02-07T05:57:56Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-02-07T05:57:56Z"}, "message": "Rollup merge of #58236 - taiki-e:librustc_resolve-2018, r=Centril\n\nlibrustc_resolve => 2018\n\nTransitions `librustc_resolve` to Rust 2018; cc #58099\n\nr? @Centril", "tree": {"sha": "bcbcd88c9d05caa0ba37362a70618c56e18eeb53", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bcbcd88c9d05caa0ba37362a70618c56e18eeb53"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/86c761f3e973d7612d74afbbb1961892756660fc", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcW8jkCRBK7hj4Ov3rIwAAdHIIADRBJoLUnzxWlhGOegx0DZFc\nPhx1bD76vTOuvygX4a/kE5GQVEtK5GY1CklV+1PKqFSwii48uzrpOlmDlQZjLfLw\nPSeFG71Jv12JK7UlqXFgTPZPHP6uNeYBp6dCez2eaWSXVwCA5AO+C8PQtB0uBY6H\nrMuIysaD2PWnGtTNleTgM8nh1zD6SClWDbc0kidiImTnsQf1U+CZawjP4ub2XtGA\nmxkCnTuKVcDfn3Wp0LIQtQ2B/nie4uCr4WGhv4IdT6jGlxxxzscuPrtAX0jSF2Do\naHXRF3sVeYpjWjGAyA2lYkPoAfddSbM5BeyL4F46maQC4Py2s8Oag3Eq82TqdJ8=\n=ATzG\n-----END PGP SIGNATURE-----\n", "payload": "tree bcbcd88c9d05caa0ba37362a70618c56e18eeb53\nparent 73458cd1ad9ad5606015eed868d768ad3fae6e68\nparent edbd8a36c8820fb8a128675859c1fa76feab2bea\nauthor kennytm <kennytm@gmail.com> 1549519076 +0800\ncommitter GitHub <noreply@github.com> 1549519076 +0800\n\nRollup merge of #58236 - taiki-e:librustc_resolve-2018, r=Centril\n\nlibrustc_resolve => 2018\n\nTransitions `librustc_resolve` to Rust 2018; cc #58099\n\nr? @Centril\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/86c761f3e973d7612d74afbbb1961892756660fc", "html_url": "https://github.com/rust-lang/rust/commit/86c761f3e973d7612d74afbbb1961892756660fc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/86c761f3e973d7612d74afbbb1961892756660fc/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "73458cd1ad9ad5606015eed868d768ad3fae6e68", "url": "https://api.github.com/repos/rust-lang/rust/commits/73458cd1ad9ad5606015eed868d768ad3fae6e68", "html_url": "https://github.com/rust-lang/rust/commit/73458cd1ad9ad5606015eed868d768ad3fae6e68"}, {"sha": "edbd8a36c8820fb8a128675859c1fa76feab2bea", "url": "https://api.github.com/repos/rust-lang/rust/commits/edbd8a36c8820fb8a128675859c1fa76feab2bea", "html_url": "https://github.com/rust-lang/rust/commit/edbd8a36c8820fb8a128675859c1fa76feab2bea"}], "stats": {"total": 185, "additions": 96, "deletions": 89}, "files": [{"sha": "0ce82f2ce521b306c56a547e8ade92c53708cddb", "filename": "src/librustc_resolve/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/86c761f3e973d7612d74afbbb1961892756660fc/src%2Flibrustc_resolve%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/86c761f3e973d7612d74afbbb1961892756660fc/src%2Flibrustc_resolve%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2FCargo.toml?ref=86c761f3e973d7612d74afbbb1961892756660fc", "patch": "@@ -2,6 +2,7 @@\n authors = [\"The Rust Project Developers\"]\n name = \"rustc_resolve\"\n version = \"0.0.0\"\n+edition = \"2018\"\n \n [lib]\n name = \"rustc_resolve\""}, {"sha": "750eb35a9885493a8c2597676dffd12ffcc0533f", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/86c761f3e973d7612d74afbbb1961892756660fc/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86c761f3e973d7612d74afbbb1961892756660fc/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=86c761f3e973d7612d74afbbb1961892756660fc", "patch": "@@ -3,14 +3,15 @@\n //! Here we build the \"reduced graph\": the graph of the module tree without\n //! any imports resolved.\n \n-use macros::{InvocationData, ParentScope, LegacyScope};\n-use resolve_imports::ImportDirective;\n-use resolve_imports::ImportDirectiveSubclass::{self, GlobImport, SingleImport};\n-use {Module, ModuleData, ModuleKind, NameBinding, NameBindingKind, Segment, ToNameBinding};\n-use {ModuleOrUniformRoot, PerNS, Resolver, ResolverArenas, ExternPreludeEntry};\n-use Namespace::{self, TypeNS, ValueNS, MacroNS};\n-use {resolve_error, resolve_struct_error, ResolutionError};\n-\n+use crate::macros::{InvocationData, ParentScope, LegacyScope};\n+use crate::resolve_imports::ImportDirective;\n+use crate::resolve_imports::ImportDirectiveSubclass::{self, GlobImport, SingleImport};\n+use crate::{Module, ModuleData, ModuleKind, NameBinding, NameBindingKind, Segment, ToNameBinding};\n+use crate::{ModuleOrUniformRoot, PerNS, Resolver, ResolverArenas, ExternPreludeEntry};\n+use crate::Namespace::{self, TypeNS, ValueNS, MacroNS};\n+use crate::{resolve_error, resolve_struct_error, ResolutionError};\n+\n+use rustc::bug;\n use rustc::hir::def::*;\n use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, LOCAL_CRATE, DefId};\n use rustc::ty;\n@@ -21,7 +22,7 @@ use std::cell::Cell;\n use std::ptr;\n use rustc_data_structures::sync::Lrc;\n \n-use errors::Applicability;\n+use crate::errors::Applicability;\n \n use syntax::ast::{Name, Ident};\n use syntax::attr;\n@@ -34,12 +35,15 @@ use syntax::ext::hygiene::Mark;\n use syntax::ext::tt::macro_rules;\n use syntax::feature_gate::is_builtin_attr;\n use syntax::parse::token::{self, Token};\n+use syntax::span_err;\n use syntax::std_inject::injected_crate_name;\n use syntax::symbol::keywords;\n use syntax::visit::{self, Visitor};\n \n use syntax_pos::{Span, DUMMY_SP};\n \n+use log::debug;\n+\n impl<'a> ToNameBinding<'a> for (Module<'a>, ty::Visibility, Span, Mark) {\n     fn to_name_binding(self, arenas: &'a ResolverArenas<'a>) -> &'a NameBinding<'a> {\n         arenas.alloc_name_binding(NameBinding {"}, {"sha": "639960827c99636918f80fcd2849c43cdbfb95c2", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/86c761f3e973d7612d74afbbb1961892756660fc/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86c761f3e973d7612d74afbbb1961892756660fc/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=86c761f3e973d7612d74afbbb1961892756660fc", "patch": "@@ -10,8 +10,8 @@\n \n use std::ops::{Deref, DerefMut};\n \n-use Resolver;\n-use resolve_imports::ImportDirectiveSubclass;\n+use crate::Resolver;\n+use crate::resolve_imports::ImportDirectiveSubclass;\n \n use rustc::{lint, ty};\n use rustc::util::nodemap::NodeMap;\n@@ -113,7 +113,7 @@ impl<'a, 'b> Visitor<'a> for UnusedImportCheckVisitor<'a, 'b> {\n     }\n }\n \n-pub fn check_crate(resolver: &mut Resolver, krate: &ast::Crate) {\n+pub fn check_crate(resolver: &mut Resolver<'_>, krate: &ast::Crate) {\n     for directive in resolver.potentially_unused_imports.iter() {\n         match directive.subclass {\n             _ if directive.used.get() ||"}, {"sha": "0db8689c0c17c27f855390636c7ba83099d27ad1", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/86c761f3e973d7612d74afbbb1961892756660fc/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86c761f3e973d7612d74afbbb1961892756660fc/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=86c761f3e973d7612d74afbbb1961892756660fc", "patch": "@@ -1,5 +1,7 @@\n #![allow(non_snake_case)]\n \n+use syntax::{register_diagnostic, register_diagnostics, register_long_diagnostics};\n+\n // Error messages for EXXXX errors.  Each message should start and end with a\n // new line, and be wrapped to 80 characters.  In vim you can `:set tw=80` and\n // use `gq` to wrap paragraphs. Use `:set tw=0` to disable."}, {"sha": "b131a6b62f9bf1dd2704c99522ae3c27e02ff01b", "filename": "src/librustc_resolve/error_reporting.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/86c761f3e973d7612d74afbbb1961892756660fc/src%2Flibrustc_resolve%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86c761f3e973d7612d74afbbb1961892756660fc/src%2Flibrustc_resolve%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Ferror_reporting.rs?ref=86c761f3e973d7612d74afbbb1961892756660fc", "patch": "@@ -1,10 +1,12 @@\n-use {CrateLint, PathResult, Segment};\n-use macros::ParentScope;\n+use crate::{CrateLint, PathResult, Segment};\n+use crate::macros::ParentScope;\n+use crate::resolve_imports::ImportResolver;\n \n use syntax::symbol::keywords;\n use syntax_pos::Span;\n \n-use resolve_imports::ImportResolver;\n+use log::debug;\n+\n use std::cmp::Reverse;\n \n impl<'a, 'b:'a> ImportResolver<'a, 'b> {"}, {"sha": "b166b1be02f459e563bdfdc30194ca630043bbd3", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 43, "deletions": 50, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/86c761f3e973d7612d74afbbb1961892756660fc/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86c761f3e973d7612d74afbbb1961892756660fc/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=86c761f3e973d7612d74afbbb1961892756660fc", "patch": "@@ -4,30 +4,19 @@\n \n #![feature(crate_visibility_modifier)]\n #![feature(label_break_value)]\n-#![feature(nll)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(slice_sort_by_cached_key)]\n \n #![recursion_limit=\"256\"]\n \n-#[macro_use]\n-extern crate bitflags;\n-#[macro_use]\n-extern crate log;\n-#[macro_use]\n-extern crate syntax;\n-extern crate syntax_pos;\n-extern crate rustc_errors as errors;\n-extern crate arena;\n-#[macro_use]\n-extern crate rustc;\n-extern crate rustc_data_structures;\n-extern crate rustc_metadata;\n+#![deny(rust_2018_idioms)]\n+\n+use rustc_errors as errors;\n \n pub use rustc::hir::def::{Namespace, PerNS};\n \n-use self::TypeParameters::*;\n-use self::RibKind::*;\n+use TypeParameters::*;\n+use RibKind::*;\n \n use rustc::hir::map::{Definitions, DefCollector};\n use rustc::hir::{self, PrimTy, Bool, Char, Float, Int, Uint, Str};\n@@ -41,6 +30,7 @@ use rustc::hir::{Freevar, FreevarMap, TraitCandidate, TraitMap, GlobMap};\n use rustc::session::config::nightly_options;\n use rustc::ty;\n use rustc::util::nodemap::{NodeMap, NodeSet, FxHashMap, FxHashSet, DefIdMap};\n+use rustc::{bug, span_bug};\n \n use rustc_metadata::creader::CrateLoader;\n use rustc_metadata::cstore::CStore;\n@@ -62,10 +52,13 @@ use syntax::ast::{Item, ItemKind, ImplItem, ImplItemKind};\n use syntax::ast::{Label, Local, Mutability, Pat, PatKind, Path};\n use syntax::ast::{QSelf, TraitItemKind, TraitRef, Ty, TyKind};\n use syntax::ptr::P;\n+use syntax::{span_err, struct_span_err, unwrap_or, walk_list};\n \n use syntax_pos::{BytePos, Span, DUMMY_SP, MultiSpan};\n use errors::{Applicability, DiagnosticBuilder, DiagnosticId};\n \n+use log::debug;\n+\n use std::cell::{Cell, RefCell};\n use std::{cmp, fmt, iter, mem, ptr};\n use std::collections::BTreeSet;\n@@ -191,13 +184,13 @@ enum ResolutionError<'a> {\n ///\n /// This takes the error provided, combines it with the span and any additional spans inside the\n /// error and emits it.\n-fn resolve_error<'sess, 'a>(resolver: &'sess Resolver,\n+fn resolve_error<'sess, 'a>(resolver: &'sess Resolver<'_>,\n                             span: Span,\n                             resolution_error: ResolutionError<'a>) {\n     resolve_struct_error(resolver, span, resolution_error).emit();\n }\n \n-fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver,\n+fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver<'_>,\n                                    span: Span,\n                                    resolution_error: ResolutionError<'a>)\n                                    -> DiagnosticBuilder<'sess> {\n@@ -1192,7 +1185,7 @@ impl<'a> ModuleData<'a> {\n }\n \n impl<'a> fmt::Debug for ModuleData<'a> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"{:?}\", self.def())\n     }\n }\n@@ -1416,7 +1409,7 @@ impl<'a> NameBinding<'a> {\n     // in some later round and screw up our previously found resolution.\n     // See more detailed explanation in\n     // https://github.com/rust-lang/rust/pull/53778#issuecomment-419224049\n-    fn may_appear_after(&self, invoc_parent_expansion: Mark, binding: &NameBinding) -> bool {\n+    fn may_appear_after(&self, invoc_parent_expansion: Mark, binding: &NameBinding<'_>) -> bool {\n         // self > max(invoc, binding) => !(self <= invoc || self <= binding)\n         // Expansions are partially ordered, so \"may appear after\" is an inversion of\n         // \"certainly appears before or simultaneously\" and includes unordered cases.\n@@ -1630,14 +1623,14 @@ impl<'a> ResolverArenas<'a> {\n         }\n         module\n     }\n-    fn local_modules(&'a self) -> ::std::cell::Ref<'a, Vec<Module<'a>>> {\n+    fn local_modules(&'a self) -> std::cell::Ref<'a, Vec<Module<'a>>> {\n         self.local_modules.borrow()\n     }\n     fn alloc_name_binding(&'a self, name_binding: NameBinding<'a>) -> &'a NameBinding<'a> {\n         self.name_bindings.alloc(name_binding)\n     }\n     fn alloc_import_directive(&'a self, import_directive: ImportDirective<'a>)\n-                              -> &'a ImportDirective {\n+                              -> &'a ImportDirective<'_> {\n         self.import_directives.alloc(import_directive)\n     }\n     fn alloc_name_resolution(&'a self) -> &'a RefCell<NameResolution<'a>> {\n@@ -1754,7 +1747,7 @@ impl<'a> Resolver<'a> {\n         is_value: bool,\n         error_callback: F,\n     ) -> hir::Path\n-        where F: for<'c, 'b> FnOnce(&'c mut Resolver, Span, ResolutionError<'b>)\n+        where F: for<'c, 'b> FnOnce(&'c mut Resolver<'_>, Span, ResolutionError<'b>)\n     {\n         let namespace = if is_value { ValueNS } else { TypeNS };\n         let span = path.span;\n@@ -1819,7 +1812,7 @@ impl<'a> Resolver<'a> {\n         DefCollector::new(&mut definitions, Mark::root())\n             .collect_root(crate_name, session.local_crate_disambiguator());\n \n-        let mut extern_prelude: FxHashMap<Ident, ExternPreludeEntry> =\n+        let mut extern_prelude: FxHashMap<Ident, ExternPreludeEntry<'_>> =\n             session.opts.externs.iter().map(|kv| (Ident::from_str(kv.0), Default::default()))\n                                        .collect();\n \n@@ -2315,7 +2308,7 @@ impl<'a> Resolver<'a> {\n     // implementations thus found, for compatibility with old resolve pass.\n \n     pub fn with_scope<F, T>(&mut self, id: NodeId, f: F) -> T\n-        where F: FnOnce(&mut Resolver) -> T\n+        where F: FnOnce(&mut Resolver<'_>) -> T\n     {\n         let id = self.definitions.local_def_id(id);\n         let module = self.module_map.get(&id).cloned(); // clones a reference\n@@ -2342,7 +2335,7 @@ impl<'a> Resolver<'a> {\n     ///\n     /// Stops after meeting a closure.\n     fn search_label<P, R>(&self, mut ident: Ident, pred: P) -> Option<R>\n-        where P: Fn(&Rib, Ident) -> Option<R>\n+        where P: Fn(&Rib<'_>, Ident) -> Option<R>\n     {\n         for rib in self.label_ribs.iter().rev() {\n             match rib.kind {\n@@ -2527,7 +2520,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn with_type_parameter_rib<'b, F>(&'b mut self, type_parameters: TypeParameters<'a, 'b>, f: F)\n-        where F: FnOnce(&mut Resolver)\n+        where F: FnOnce(&mut Resolver<'_>)\n     {\n         match type_parameters {\n             HasTypeParameters(generics, rib_kind) => {\n@@ -2573,15 +2566,15 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn with_label_rib<F>(&mut self, f: F)\n-        where F: FnOnce(&mut Resolver)\n+        where F: FnOnce(&mut Resolver<'_>)\n     {\n         self.label_ribs.push(Rib::new(NormalRibKind));\n         f(self);\n         self.label_ribs.pop();\n     }\n \n     fn with_item_rib<F>(&mut self, f: F)\n-        where F: FnOnce(&mut Resolver)\n+        where F: FnOnce(&mut Resolver<'_>)\n     {\n         self.ribs[ValueNS].push(Rib::new(ItemRibKind));\n         self.ribs[TypeNS].push(Rib::new(ItemRibKind));\n@@ -2591,7 +2584,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn with_constant_rib<F>(&mut self, f: F)\n-        where F: FnOnce(&mut Resolver)\n+        where F: FnOnce(&mut Resolver<'_>)\n     {\n         self.ribs[ValueNS].push(Rib::new(ConstantItemRibKind));\n         self.label_ribs.push(Rib::new(ConstantItemRibKind));\n@@ -2601,7 +2594,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn with_current_self_type<T, F>(&mut self, self_type: &Ty, f: F) -> T\n-        where F: FnOnce(&mut Resolver) -> T\n+        where F: FnOnce(&mut Resolver<'_>) -> T\n     {\n         // Handle nested impls (inside fn bodies)\n         let previous_value = replace(&mut self.current_self_type, Some(self_type.clone()));\n@@ -2611,7 +2604,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn with_current_self_item<T, F>(&mut self, self_item: &Item, f: F) -> T\n-        where F: FnOnce(&mut Resolver) -> T\n+        where F: FnOnce(&mut Resolver<'_>) -> T\n     {\n         let previous_value = replace(&mut self.current_self_item, Some(self_item.id));\n         let result = f(self);\n@@ -2621,7 +2614,7 @@ impl<'a> Resolver<'a> {\n \n     /// This is called to resolve a trait reference from an `impl` (i.e., `impl Trait for Foo`)\n     fn with_optional_trait_ref<T, F>(&mut self, opt_trait_ref: Option<&TraitRef>, f: F) -> T\n-        where F: FnOnce(&mut Resolver, Option<DefId>) -> T\n+        where F: FnOnce(&mut Resolver<'_>, Option<DefId>) -> T\n     {\n         let mut new_val = None;\n         let mut new_id = None;\n@@ -2658,7 +2651,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn with_self_rib<F>(&mut self, self_def: Def, f: F)\n-        where F: FnOnce(&mut Resolver)\n+        where F: FnOnce(&mut Resolver<'_>)\n     {\n         let mut self_type_rib = Rib::new(NormalRibKind);\n \n@@ -2670,7 +2663,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn with_self_struct_ctor_rib<F>(&mut self, impl_id: DefId, f: F)\n-        where F: FnOnce(&mut Resolver)\n+        where F: FnOnce(&mut Resolver<'_>)\n     {\n         let self_def = Def::SelfCtor(impl_id);\n         let mut self_type_rib = Rib::new(NormalRibKind);\n@@ -2771,7 +2764,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn check_trait_item<F>(&mut self, ident: Ident, ns: Namespace, span: Span, err: F)\n-        where F: FnOnce(Name, &str) -> ResolutionError\n+        where F: FnOnce(Name, &str) -> ResolutionError<'_>\n     {\n         // If there is a TraitRef in scope for an impl, then the method must be in the\n         // trait.\n@@ -3102,7 +3095,7 @@ impl<'a> Resolver<'a> {\n                           id: NodeId,\n                           qself: Option<&QSelf>,\n                           path: &Path,\n-                          source: PathSource)\n+                          source: PathSource<'_>)\n                           -> PathResolution {\n         self.smart_resolve_path_with_crate_lint(id, qself, path, source, CrateLint::SimplePath(id))\n     }\n@@ -3120,7 +3113,7 @@ impl<'a> Resolver<'a> {\n         id: NodeId,\n         qself: Option<&QSelf>,\n         path: &Path,\n-        source: PathSource,\n+        source: PathSource<'_>,\n         crate_lint: CrateLint\n     ) -> PathResolution {\n         self.smart_resolve_path_fragment(\n@@ -3138,7 +3131,7 @@ impl<'a> Resolver<'a> {\n                                    qself: Option<&QSelf>,\n                                    path: &[Segment],\n                                    span: Span,\n-                                   source: PathSource,\n+                                   source: PathSource<'_>,\n                                    crate_lint: CrateLint)\n                                    -> PathResolution {\n         let ident_span = path.last().map_or(span, |ident| ident.ident.span);\n@@ -3581,7 +3574,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn type_ascription_suggestion(&self,\n-                                  err: &mut DiagnosticBuilder,\n+                                  err: &mut DiagnosticBuilder<'_>,\n                                   base_span: Span) {\n         debug!(\"type_ascription_suggetion {:?}\", base_span);\n         let cm = self.session.source_map();\n@@ -4040,7 +4033,7 @@ impl<'a> Resolver<'a> {\n         crate_lint: CrateLint,\n         path: &[Segment],\n         path_span: Span,\n-        second_binding: Option<&NameBinding>,\n+        second_binding: Option<&NameBinding<'_>>,\n     ) {\n         let (diag_id, diag_span) = match crate_lint {\n             CrateLint::No => return,\n@@ -4266,7 +4259,7 @@ impl<'a> Resolver<'a> {\n     where\n         FilterFn: Fn(Def) -> bool,\n     {\n-        let add_module_candidates = |module: Module, names: &mut Vec<TypoSuggestion>| {\n+        let add_module_candidates = |module: Module<'_>, names: &mut Vec<TypoSuggestion>| {\n             for (&(ident, _), resolution) in module.resolutions.borrow().iter() {\n                 if let Some(binding) = resolution.borrow().binding {\n                     if filter_fn(binding.def()) {\n@@ -4361,7 +4354,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn with_resolved_label<F>(&mut self, label: Option<Label>, id: NodeId, f: F)\n-        where F: FnOnce(&mut Resolver)\n+        where F: FnOnce(&mut Resolver<'_>)\n     {\n         if let Some(label) = label {\n             self.unused_labels.insert(id, label.ident.span);\n@@ -4950,7 +4943,7 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn binding_description(&self, b: &NameBinding, ident: Ident, from_prelude: bool) -> String {\n+    fn binding_description(&self, b: &NameBinding<'_>, ident: Ident, from_prelude: bool) -> String {\n         if b.span.is_dummy() {\n             let add_built_in = match b.def() {\n                 // These already contain the \"built-in\" prefix or look bad with it.\n@@ -4978,7 +4971,7 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn report_ambiguity_error(&self, ambiguity_error: &AmbiguityError) {\n+    fn report_ambiguity_error(&self, ambiguity_error: &AmbiguityError<'_>) {\n         let AmbiguityError { kind, ident, b1, b2, misc1, misc2 } = *ambiguity_error;\n         let (b1, b2, misc1, misc2, swapped) = if b2.span.is_dummy() && !b1.span.is_dummy() {\n             // We have to print the span-less alternative first, otherwise formatting looks bad.\n@@ -4992,7 +4985,7 @@ impl<'a> Resolver<'a> {\n                                        ident = ident, why = kind.descr());\n         err.span_label(ident.span, \"ambiguous name\");\n \n-        let mut could_refer_to = |b: &NameBinding, misc: AmbiguityErrorMisc, also: &str| {\n+        let mut could_refer_to = |b: &NameBinding<'_>, misc: AmbiguityErrorMisc, also: &str| {\n             let what = self.binding_description(b, ident, misc == AmbiguityErrorMisc::FromPrelude);\n             let note_msg = format!(\"`{ident}` could{also} refer to {what}\",\n                                    ident = ident, also = also, what = what);\n@@ -5073,7 +5066,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn report_conflict<'b>(&mut self,\n-                       parent: Module,\n+                       parent: Module<'_>,\n                        ident: Ident,\n                        ns: Namespace,\n                        new_binding: &NameBinding<'b>,\n@@ -5451,7 +5444,7 @@ fn import_candidate_to_enum_paths(suggestion: &ImportSuggestion) -> (String, Str\n /// When an entity with a given name is not available in scope, we search for\n /// entities with that name in all crates. This method allows outputting the\n /// results of this search in a programmer-friendly way\n-fn show_candidates(err: &mut DiagnosticBuilder,\n+fn show_candidates(err: &mut DiagnosticBuilder<'_>,\n                    // This is `None` if all placement locations are inside expansions\n                    span: Option<Span>,\n                    candidates: &[ImportSuggestion],\n@@ -5500,10 +5493,10 @@ fn show_candidates(err: &mut DiagnosticBuilder,\n }\n \n /// A somewhat inefficient routine to obtain the name of a module.\n-fn module_to_string(module: Module) -> Option<String> {\n+fn module_to_string(module: Module<'_>) -> Option<String> {\n     let mut names = Vec::new();\n \n-    fn collect_mod(names: &mut Vec<Ident>, module: Module) {\n+    fn collect_mod(names: &mut Vec<Ident>, module: Module<'_>) {\n         if let ModuleKind::Def(_, name) = module.kind {\n             if let Some(parent) = module.parent {\n                 names.push(Ident::with_empty_ctxt(name));"}, {"sha": "c8c0847a28eac023dbb3d3e9160ea121f227be96", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/86c761f3e973d7612d74afbbb1961892756660fc/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86c761f3e973d7612d74afbbb1961892756660fc/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=86c761f3e973d7612d74afbbb1961892756660fc", "patch": "@@ -1,16 +1,17 @@\n-use {AmbiguityError, AmbiguityKind, AmbiguityErrorMisc};\n-use {CrateLint, Resolver, ResolutionError, ScopeSet, Weak};\n-use {Module, ModuleKind, NameBinding, NameBindingKind, PathResult, Segment, ToNameBinding};\n-use {is_known_tool, resolve_error};\n-use ModuleOrUniformRoot;\n-use Namespace::*;\n-use build_reduced_graph::{BuildReducedGraphVisitor, IsMacroExport};\n-use resolve_imports::ImportResolver;\n+use crate::{AmbiguityError, AmbiguityKind, AmbiguityErrorMisc};\n+use crate::{CrateLint, Resolver, ResolutionError, ScopeSet, Weak};\n+use crate::{Module, ModuleKind, NameBinding, NameBindingKind, PathResult, Segment, ToNameBinding};\n+use crate::{is_known_tool, resolve_error};\n+use crate::ModuleOrUniformRoot;\n+use crate::Namespace::*;\n+use crate::build_reduced_graph::{BuildReducedGraphVisitor, IsMacroExport};\n+use crate::resolve_imports::ImportResolver;\n use rustc::hir::def_id::{DefId, CRATE_DEF_INDEX, DefIndex,\n                          CrateNum, DefIndexAddressSpace};\n use rustc::hir::def::{Def, NonMacroAttrKind};\n use rustc::hir::map::{self, DefCollector};\n use rustc::{ty, lint};\n+use rustc::{bug, span_bug};\n use syntax::ast::{self, Ident};\n use syntax::attr;\n use syntax::errors::DiagnosticBuilder;\n@@ -26,7 +27,7 @@ use syntax::symbol::{Symbol, keywords};\n use syntax::visit::Visitor;\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax_pos::{Span, DUMMY_SP};\n-use errors::Applicability;\n+use crate::errors::Applicability;\n \n use std::cell::Cell;\n use std::{mem, ptr};\n@@ -530,7 +531,7 @@ impl<'a> Resolver<'a> {\n             BuiltinTypes,\n         }\n \n-        bitflags! {\n+        bitflags::bitflags! {\n             struct Flags: u8 {\n                 const MACRO_RULES        = 1 << 0;\n                 const MODULE             = 1 << 1;\n@@ -560,7 +561,7 @@ impl<'a> Resolver<'a> {\n         // }\n         // So we have to save the innermost solution and continue searching in outer scopes\n         // to detect potential ambiguities.\n-        let mut innermost_result: Option<(&NameBinding, Flags)> = None;\n+        let mut innermost_result: Option<(&NameBinding<'_>, Flags)> = None;\n \n         // Go through all the scopes and try to resolve the name.\n         let rust_2015 = orig_ident.span.rust_2015();"}, {"sha": "712871408fa04e7c0e2675140b3e9d0bb8936651", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/86c761f3e973d7612d74afbbb1961892756660fc/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86c761f3e973d7612d74afbbb1961892756660fc/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=86c761f3e973d7612d74afbbb1961892756660fc", "patch": "@@ -1,13 +1,13 @@\n-use self::ImportDirectiveSubclass::*;\n+use ImportDirectiveSubclass::*;\n \n-use {AmbiguityError, AmbiguityKind, AmbiguityErrorMisc};\n-use {CrateLint, Module, ModuleOrUniformRoot, PerNS, ScopeSet, Weak};\n-use Namespace::{self, TypeNS, MacroNS};\n-use {NameBinding, NameBindingKind, ToNameBinding, PathResult, PrivacyError};\n-use {Resolver, Segment};\n-use {names_to_string, module_to_string};\n-use {resolve_error, ResolutionError};\n-use macros::ParentScope;\n+use crate::{AmbiguityError, AmbiguityKind, AmbiguityErrorMisc};\n+use crate::{CrateLint, Module, ModuleOrUniformRoot, PerNS, ScopeSet, Weak};\n+use crate::Namespace::{self, TypeNS, MacroNS};\n+use crate::{NameBinding, NameBindingKind, ToNameBinding, PathResult, PrivacyError};\n+use crate::{Resolver, Segment};\n+use crate::{names_to_string, module_to_string};\n+use crate::{resolve_error, ResolutionError};\n+use crate::macros::ParentScope;\n \n use rustc_data_structures::ptr_key::PtrKey;\n use rustc::ty;\n@@ -17,14 +17,18 @@ use rustc::hir::def_id::{CrateNum, DefId};\n use rustc::hir::def::*;\n use rustc::session::DiagnosticMessageId;\n use rustc::util::nodemap::FxHashSet;\n+use rustc::{bug, span_bug};\n \n use syntax::ast::{self, Ident, Name, NodeId, CRATE_NODE_ID};\n use syntax::ext::base::Determinacy::{self, Determined, Undetermined};\n use syntax::ext::hygiene::Mark;\n use syntax::symbol::keywords;\n use syntax::util::lev_distance::find_best_match_for_name;\n+use syntax::{struct_span_err, unwrap_or};\n use syntax_pos::{MultiSpan, Span};\n \n+use log::debug;\n+\n use std::cell::{Cell, RefCell};\n use std::{mem, ptr};\n \n@@ -623,14 +627,14 @@ pub struct ImportResolver<'a, 'b: 'a> {\n     pub resolver: &'a mut Resolver<'b>,\n }\n \n-impl<'a, 'b: 'a> ::std::ops::Deref for ImportResolver<'a, 'b> {\n+impl<'a, 'b: 'a> std::ops::Deref for ImportResolver<'a, 'b> {\n     type Target = Resolver<'b>;\n     fn deref(&self) -> &Resolver<'b> {\n         self.resolver\n     }\n }\n \n-impl<'a, 'b: 'a> ::std::ops::DerefMut for ImportResolver<'a, 'b> {\n+impl<'a, 'b: 'a> std::ops::DerefMut for ImportResolver<'a, 'b> {\n     fn deref_mut(&mut self) -> &mut Resolver<'b> {\n         self.resolver\n     }\n@@ -1316,7 +1320,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n }\n \n fn import_path_to_string(names: &[Ident],\n-                         subclass: &ImportDirectiveSubclass,\n+                         subclass: &ImportDirectiveSubclass<'_>,\n                          span: Span) -> String {\n     let pos = names.iter()\n         .position(|p| span == p.span && p.name != keywords::PathRoot.name());\n@@ -1336,7 +1340,7 @@ fn import_path_to_string(names: &[Ident],\n     }\n }\n \n-fn import_directive_subclass_to_string(subclass: &ImportDirectiveSubclass) -> String {\n+fn import_directive_subclass_to_string(subclass: &ImportDirectiveSubclass<'_>) -> String {\n     match *subclass {\n         SingleImport { source, .. } => source.to_string(),\n         GlobImport { .. } => \"*\".to_string(),"}]}