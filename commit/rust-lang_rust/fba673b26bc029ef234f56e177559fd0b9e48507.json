{"sha": "fba673b26bc029ef234f56e177559fd0b9e48507", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiYTY3M2IyNmJjMDI5ZWYyMzRmNTZlMTc3NTU5ZmQwYjllNDg1MDc=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-09-05T01:28:22Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-09-05T01:30:27Z"}, "message": "rustc: Implement private methods.\n\nDoesn't work cross-crate yet.", "tree": {"sha": "2a21c1ea78a14b76233af8ec4da4852f21bdd4a3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a21c1ea78a14b76233af8ec4da4852f21bdd4a3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fba673b26bc029ef234f56e177559fd0b9e48507", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fba673b26bc029ef234f56e177559fd0b9e48507", "html_url": "https://github.com/rust-lang/rust/commit/fba673b26bc029ef234f56e177559fd0b9e48507", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fba673b26bc029ef234f56e177559fd0b9e48507/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a618d0d7ce913e5c7f1393561149ada6f7c32ff3", "url": "https://api.github.com/repos/rust-lang/rust/commits/a618d0d7ce913e5c7f1393561149ada6f7c32ff3", "html_url": "https://github.com/rust-lang/rust/commit/a618d0d7ce913e5c7f1393561149ada6f7c32ff3"}], "stats": {"total": 189, "additions": 157, "deletions": 32}, "files": [{"sha": "ceed0718f6b6affec73522bd7eb2d635e57ce4e7", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fba673b26bc029ef234f56e177559fd0b9e48507/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba673b26bc029ef234f56e177559fd0b9e48507/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=fba673b26bc029ef234f56e177559fd0b9e48507", "patch": "@@ -1041,8 +1041,7 @@ type method = {ident: ident, attrs: ~[attribute],\n                tps: ~[ty_param], self_ty: self_ty,\n                purity: purity, decl: fn_decl, body: blk,\n                id: node_id, span: span, self_id: node_id,\n-               vis: visibility};  // always public, unless it's a\n-                                  // class method\n+               vis: visibility};\n \n #[auto_serialize]\n type _mod = {view_items: ~[@view_item], items: ~[@item]};"}, {"sha": "367fb9a1bdeedb1d304c11d9ca290ee09dfb1214", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fba673b26bc029ef234f56e177559fd0b9e48507/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba673b26bc029ef234f56e177559fd0b9e48507/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=fba673b26bc029ef234f56e177559fd0b9e48507", "patch": "@@ -2533,7 +2533,8 @@ struct parser {\n         let mut meths = ~[];\n         self.expect(token::LBRACE);\n         while !self.eat(token::RBRACE) {\n-            vec::push(meths, self.parse_method(public));\n+            let vis = self.parse_visibility();\n+            vec::push(meths, self.parse_method(vis));\n         }\n         (ident, item_impl(tps, traits, ty, meths), None)\n     }"}, {"sha": "024452302da7e340d854201662477f433ee536b3", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fba673b26bc029ef234f56e177559fd0b9e48507/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba673b26bc029ef234f56e177559fd0b9e48507/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=fba673b26bc029ef234f56e177559fd0b9e48507", "patch": "@@ -222,7 +222,7 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n     if upto == cu_typeck { return {crate: crate, tcx: Some(ty_cx)}; }\n \n     time(time_passes, ~\"privacy checking\", ||\n-        middle::privacy::check_crate(ty_cx, crate));\n+        middle::privacy::check_crate(ty_cx, &method_map, crate));\n \n     time(time_passes, ~\"loop checking\", ||\n         middle::check_loop::check_crate(ty_cx, crate));"}, {"sha": "b4b48f214056e6f8cff86afe042b47ce6980dc7b", "filename": "src/rustc/middle/privacy.rs", "status": "modified", "additions": 138, "deletions": 28, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/fba673b26bc029ef234f56e177559fd0b9e48507/src%2Frustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba673b26bc029ef234f56e177559fd0b9e48507/src%2Frustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fprivacy.rs?ref=fba673b26bc029ef234f56e177559fd0b9e48507", "patch": "@@ -3,23 +3,26 @@\n \n use /*mod*/ syntax::ast;\n use /*mod*/ syntax::visit;\n-use syntax::ast::{expr_field, ident, item_class, local_crate, node_id};\n-use syntax::ast::{private};\n+use syntax::ast::{expr_field, ident, item_class, item_impl, item_trait};\n+use syntax::ast::{local_crate, node_id, private, provided, required};\n+use syntax::ast_map::{node_item, node_method};\n use ty::ty_class;\n+use typeck::{method_map, method_origin, method_param, method_static};\n+use typeck::{method_trait};\n \n use core::util::ignore;\n use dvec::DVec;\n-use send_map::linear::LinearMap;\n \n-fn check_crate(tcx: ty::ctxt, crate: @ast::crate) {\n-    let privileged_structs = @DVec();\n+fn check_crate(tcx: ty::ctxt, method_map: &method_map, crate: @ast::crate) {\n+    let privileged_items = @DVec();\n \n-    let add_privileged_structs = |items: &[@ast::item]| {\n+    // Adds structs that are privileged to this scope.\n+    let add_privileged_items = |items: &[@ast::item]| {\n         let mut count = 0;\n         for items.each |item| {\n             match item.node {\n-                item_class(*) => {\n-                    privileged_structs.push(item.id);\n+                item_class(*) | item_trait(*) | item_impl(*) => {\n+                    privileged_items.push(item.id);\n                     count += 1;\n                 }\n                 _ => {}\n@@ -28,36 +31,143 @@ fn check_crate(tcx: ty::ctxt, crate: @ast::crate) {\n         count\n     };\n \n+    // Checks that a private field is in scope.\n+    let check_field = |span, id, ident| {\n+        let fields = ty::lookup_class_fields(tcx, id);\n+        for fields.each |field| {\n+            if field.ident != ident { again; }\n+            if field.vis == private {\n+                tcx.sess.span_err(span, fmt!(\"field `%s` is private\",\n+                                             *tcx.sess.parse_sess.interner\n+                                                 .get(ident)));\n+            }\n+            break;\n+        }\n+    };\n+\n+    // Checks that a private method is in scope.\n+    let check_method = |span, origin: &method_origin| {\n+        match *origin {\n+            method_static(method_id) => {\n+                if method_id.crate == local_crate {\n+                    match tcx.items.find(method_id.node) {\n+                        Some(node_method(method, impl_id, _)) => {\n+                            if method.vis == private &&\n+                                    (impl_id.crate != local_crate ||\n+                                     !privileged_items\n+                                     .contains(impl_id.node)) {\n+                                tcx.sess.span_err(span,\n+                                                  fmt!(\"method `%s` is \\\n+                                                        private\",\n+                                                       *tcx.sess\n+                                                           .parse_sess\n+                                                           .interner\n+                                                           .get(method\n+                                                                .ident)));\n+                            }\n+                        }\n+                        Some(_) => {\n+                            tcx.sess.span_bug(span, ~\"method wasn't \\\n+                                                      actually a method?!\");\n+                        }\n+                        None => {\n+                            tcx.sess.span_bug(span, ~\"method not found in \\\n+                                                      AST map?!\");\n+                        }\n+                    }\n+                } else {\n+                    // XXX: External crates.\n+                }\n+            }\n+            method_param({trait_id: trait_id, method_num: method_num, _}) |\n+            method_trait(trait_id, method_num) => {\n+                if trait_id.crate == local_crate {\n+                    match tcx.items.find(trait_id.node) {\n+                        Some(node_item(item, _)) => {\n+                            match item.node {\n+                                item_trait(_, _, methods) => {\n+                                    if method_num >= methods.len() {\n+                                        tcx.sess.span_bug(span, ~\"method \\\n+                                                                  number \\\n+                                                                  out of \\\n+                                                                  range?!\");\n+                                    }\n+                                    match methods[method_num] {\n+                                        provided(method)\n+                                                if method.vis == private &&\n+                                                !privileged_items\n+                                                .contains(trait_id.node) => {\n+                                            tcx.sess.span_err(span,\n+                                                              fmt!(\"method\n+                                                                    `%s` \\\n+                                                                    is \\\n+                                                                    private\",\n+                                                                   *tcx\n+                                                                   .sess\n+                                                                   .parse_sess\n+                                                                   .interner\n+                                                                   .get\n+                                                                   (method\n+                                                                    .ident)));\n+                                        }\n+                                        provided(_) | required(_) => {\n+                                            // Required methods can't be\n+                                            // private.\n+                                        }\n+                                    }\n+                                }\n+                                _ => {\n+                                    tcx.sess.span_bug(span, ~\"trait wasn't \\\n+                                                              actually a \\\n+                                                              trait?!\");\n+                                }\n+                            }\n+                        }\n+                        Some(_) => {\n+                            tcx.sess.span_bug(span, ~\"trait wasn't an \\\n+                                                      item?!\");\n+                        }\n+                        None => {\n+                            tcx.sess.span_bug(span, ~\"trait item wasn't \\\n+                                                      found in the AST \\\n+                                                      map?!\");\n+                        }\n+                    }\n+                } else {\n+                    // XXX: External crates.\n+                }\n+            }\n+        }\n+    };\n+\n     let visitor = visit::mk_vt(@{\n-        visit_mod: |the_module, span, node_id, env, visitor| {\n-            let n_added = add_privileged_structs(the_module.items);\n+        visit_mod: |the_module, span, node_id, method_map, visitor| {\n+            let n_added = add_privileged_items(the_module.items);\n \n-            visit::visit_mod(the_module, span, node_id, env, visitor);\n+            visit::visit_mod(the_module, span, node_id, method_map, visitor);\n \n             for n_added.times {\n-                ignore(privileged_structs.pop());\n+                ignore(privileged_items.pop());\n             }\n         },\n-        visit_expr: |expr, env, visitor| {\n+        visit_expr: |expr, method_map: &method_map, visitor| {\n             match expr.node {\n                 expr_field(base, ident, _) => {\n                     match ty::get(ty::expr_ty(tcx, base)).struct {\n                         ty_class(id, _)\n                         if id.crate != local_crate ||\n-                           !privileged_structs.contains(id.node) => {\n-                            let fields = ty::lookup_class_fields(tcx, id);\n-                            for fields.each |field| {\n-                                if field.ident != ident { again; }\n-                                if field.vis == private {\n-                                    tcx.sess.span_err(expr.span,\n-                                                      fmt!(\"field `%s` is \\\n-                                                            private\",\n-                                                           *tcx.sess\n-                                                               .parse_sess\n-                                                               .interner\n-                                                               .get(ident)));\n+                           !privileged_items.contains(id.node) => {\n+                            match method_map.find(expr.id) {\n+                                None => {\n+                                    debug!(\"(privacy checking) checking \\\n+                                            field\");\n+                                    check_field(expr.span, id, ident);\n+                                }\n+                                Some(entry) => {\n+                                    debug!(\"(privacy checking) checking \\\n+                                            impl method\");\n+                                    check_method(expr.span, &entry.origin);\n                                 }\n-                                break;\n                             }\n                         }\n                         _ => {}\n@@ -66,10 +176,10 @@ fn check_crate(tcx: ty::ctxt, crate: @ast::crate) {\n                 _ => {}\n             }\n \n-            visit::visit_expr(expr, env, visitor);\n+            visit::visit_expr(expr, method_map, visitor);\n         },\n         .. *visit::default_visitor()\n     });\n-    visit::visit_crate(*crate, (), visitor);\n+    visit::visit_crate(*crate, method_map, visitor);\n }\n "}, {"sha": "2d6047b36470ecb63cdb487e68c846f40da9b2ea", "filename": "src/test/compile-fail/private-impl-method.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fba673b26bc029ef234f56e177559fd0b9e48507/src%2Ftest%2Fcompile-fail%2Fprivate-impl-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba673b26bc029ef234f56e177559fd0b9e48507/src%2Ftest%2Fcompile-fail%2Fprivate-impl-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-impl-method.rs?ref=fba673b26bc029ef234f56e177559fd0b9e48507", "patch": "@@ -0,0 +1,15 @@\n+mod a {\n+    struct Foo {\n+        x: int\n+    }\n+\n+    impl Foo {\n+        priv fn foo() {}\n+    }\n+}\n+\n+fn main() {\n+    let s = a::Foo { x: 1 };\n+    s.foo();    //~ ERROR method `foo` is private\n+}\n+"}]}