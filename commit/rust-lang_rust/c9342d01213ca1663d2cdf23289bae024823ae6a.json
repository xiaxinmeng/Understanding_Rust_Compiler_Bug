{"sha": "c9342d01213ca1663d2cdf23289bae024823ae6a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5MzQyZDAxMjEzY2ExNjYzZDJjZGYyMzI4OWJhZTAyNDgyM2FlNmE=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-01-04T04:26:12Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-01-04T04:26:12Z"}, "message": "fmt clippy", "tree": {"sha": "505829eeee2dc85b41f7e2aa7cc44df3d9862a9e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/505829eeee2dc85b41f7e2aa7cc44df3d9862a9e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c9342d01213ca1663d2cdf23289bae024823ae6a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c9342d01213ca1663d2cdf23289bae024823ae6a", "html_url": "https://github.com/rust-lang/rust/commit/c9342d01213ca1663d2cdf23289bae024823ae6a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c9342d01213ca1663d2cdf23289bae024823ae6a/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "839ad09689e417d1d9e84eb24c627226765f8322", "url": "https://api.github.com/repos/rust-lang/rust/commits/839ad09689e417d1d9e84eb24c627226765f8322", "html_url": "https://github.com/rust-lang/rust/commit/839ad09689e417d1d9e84eb24c627226765f8322"}], "stats": {"total": 3673, "additions": 2186, "deletions": 1487}, "files": [{"sha": "2c8779ae7376137c09cd3a38d6a6743f7ca190e4", "filename": "src/approx_const.rs", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Fapprox_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Fapprox_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fapprox_const.rs?ref=c9342d01213ca1663d2cdf23289bae024823ae6a", "patch": "@@ -21,24 +21,22 @@ declare_lint! {\n }\n \n // Tuples are of the form (constant, name, min_digits)\n-const KNOWN_CONSTS : &'static [(f64, &'static str, usize)] = &[\n-    (f64::E, \"E\", 4),\n-    (f64::FRAC_1_PI, \"FRAC_1_PI\", 4),\n-    (f64::FRAC_1_SQRT_2, \"FRAC_1_SQRT_2\", 5),\n-    (f64::FRAC_2_PI, \"FRAC_2_PI\", 5),\n-    (f64::FRAC_2_SQRT_PI, \"FRAC_2_SQRT_PI\", 5),\n-    (f64::FRAC_PI_2, \"FRAC_PI_2\", 5),\n-    (f64::FRAC_PI_3, \"FRAC_PI_3\", 5),\n-    (f64::FRAC_PI_4, \"FRAC_PI_4\", 5),\n-    (f64::FRAC_PI_6, \"FRAC_PI_6\", 5),\n-    (f64::FRAC_PI_8, \"FRAC_PI_8\", 5),\n-    (f64::LN_10, \"LN_10\", 5),\n-    (f64::LN_2, \"LN_2\", 5),\n-    (f64::LOG10_E, \"LOG10_E\", 5),\n-    (f64::LOG2_E, \"LOG2_E\", 5),\n-    (f64::PI, \"PI\", 3),\n-    (f64::SQRT_2, \"SQRT_2\", 5),\n-];\n+const KNOWN_CONSTS: &'static [(f64, &'static str, usize)] = &[(f64::E, \"E\", 4),\n+                                                              (f64::FRAC_1_PI, \"FRAC_1_PI\", 4),\n+                                                              (f64::FRAC_1_SQRT_2, \"FRAC_1_SQRT_2\", 5),\n+                                                              (f64::FRAC_2_PI, \"FRAC_2_PI\", 5),\n+                                                              (f64::FRAC_2_SQRT_PI, \"FRAC_2_SQRT_PI\", 5),\n+                                                              (f64::FRAC_PI_2, \"FRAC_PI_2\", 5),\n+                                                              (f64::FRAC_PI_3, \"FRAC_PI_3\", 5),\n+                                                              (f64::FRAC_PI_4, \"FRAC_PI_4\", 5),\n+                                                              (f64::FRAC_PI_6, \"FRAC_PI_6\", 5),\n+                                                              (f64::FRAC_PI_8, \"FRAC_PI_8\", 5),\n+                                                              (f64::LN_10, \"LN_10\", 5),\n+                                                              (f64::LN_2, \"LN_2\", 5),\n+                                                              (f64::LOG10_E, \"LOG10_E\", 5),\n+                                                              (f64::LOG2_E, \"LOG2_E\", 5),\n+                                                              (f64::PI, \"PI\", 3),\n+                                                              (f64::SQRT_2, \"SQRT_2\", 5)];\n \n #[derive(Copy,Clone)]\n pub struct ApproxConstant;\n@@ -61,19 +59,19 @@ fn check_lit(cx: &LateContext, lit: &Lit, e: &Expr) {\n     match lit.node {\n         LitFloat(ref s, TyF32) => check_known_consts(cx, e, s, \"f32\"),\n         LitFloat(ref s, TyF64) => check_known_consts(cx, e, s, \"f64\"),\n-        LitFloatUnsuffixed(ref s) =>\n-            check_known_consts(cx, e, s, \"f{32, 64}\"),\n-        _ => ()\n+        LitFloatUnsuffixed(ref s) => check_known_consts(cx, e, s, \"f{32, 64}\"),\n+        _ => (),\n     }\n }\n \n fn check_known_consts(cx: &LateContext, e: &Expr, s: &str, module: &str) {\n     if let Ok(_) = s.parse::<f64>() {\n         for &(constant, name, min_digits) in KNOWN_CONSTS {\n             if is_approx_const(constant, s, min_digits) {\n-                span_lint(cx, APPROX_CONSTANT, e.span, &format!(\n-                    \"approximate value of `{}::{}` found. \\\n-                    Consider using it directly\", module, &name));\n+                span_lint(cx,\n+                          APPROX_CONSTANT,\n+                          e.span,\n+                          &format!(\"approximate value of `{}::{}` found. Consider using it directly\", module, &name));\n                 return;\n             }\n         }"}, {"sha": "cfa52f390d294f5fa2d3429c615697352f15db62", "filename": "src/array_indexing.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Farray_indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Farray_indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Farray_indexing.rs?ref=c9342d01213ca1663d2cdf23289bae024823ae6a", "patch": "@@ -42,8 +42,7 @@ impl LateLintPass for ArrayIndexing {\n                 let index = eval_const_expr_partial(cx.tcx, &index, ExprTypeChecked, None);\n                 if let Ok(ConstVal::Uint(index)) = index {\n                     if size as u64 <= index {\n-                        span_lint(cx, OUT_OF_BOUNDS_INDEXING, e.span,\n-                                  \"const index-expr is out of bounds\");\n+                        span_lint(cx, OUT_OF_BOUNDS_INDEXING, e.span, \"const index-expr is out of bounds\");\n                     }\n                 }\n             }"}, {"sha": "ec2cfcb0efc2819f276592c4feb71c858bb9d63b", "filename": "src/attrs.rs", "status": "modified", "additions": 24, "deletions": 14, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fattrs.rs?ref=c9342d01213ca1663d2cdf23289bae024823ae6a", "patch": "@@ -57,21 +57,23 @@ impl LateLintPass for AttrPass {\n fn is_relevant_item(item: &Item) -> bool {\n     if let ItemFn(_, _, _, _, _, ref block) = item.node {\n         is_relevant_block(block)\n-    } else { false }\n+    } else {\n+        false\n+    }\n }\n \n fn is_relevant_impl(item: &ImplItem) -> bool {\n     match item.node {\n         ImplItemKind::Method(_, ref block) => is_relevant_block(block),\n-        _ => false\n+        _ => false,\n     }\n }\n \n fn is_relevant_trait(item: &TraitItem) -> bool {\n     match item.node {\n         MethodTraitItem(_, None) => true,\n         MethodTraitItem(_, Some(ref block)) => is_relevant_block(block),\n-        _ => false\n+        _ => false,\n     }\n }\n \n@@ -95,25 +97,33 @@ fn is_relevant_expr(expr: &Expr) -> bool {\n         ExprCall(ref path_expr, _) => {\n             if let ExprPath(_, ref path) = path_expr.node {\n                 !match_path(path, &BEGIN_UNWIND)\n-            } else { true }\n+            } else {\n+                true\n+            }\n         }\n-        _ => true\n+        _ => true,\n     }\n }\n \n-fn check_attrs(cx: &LateContext, span: Span, name: &Name,\n-        attrs: &[Attribute]) {\n-    if in_macro(cx, span) { return; }\n+fn check_attrs(cx: &LateContext, span: Span, name: &Name, attrs: &[Attribute]) {\n+    if in_macro(cx, span) {\n+        return;\n+    }\n \n     for attr in attrs {\n         if let MetaList(ref inline, ref values) = attr.node.value.node {\n-            if values.len() != 1 || inline != &\"inline\" { continue; }\n+            if values.len() != 1 || inline != &\"inline\" {\n+                continue;\n+            }\n             if let MetaWord(ref always) = values[0].node {\n-                if always != &\"always\" { continue; }\n-                span_lint(cx, INLINE_ALWAYS, attr.span, &format!(\n-                    \"you have declared `#[inline(always)]` on `{}`. This \\\n-                     is usually a bad idea\",\n-                    name));\n+                if always != &\"always\" {\n+                    continue;\n+                }\n+                span_lint(cx,\n+                          INLINE_ALWAYS,\n+                          attr.span,\n+                          &format!(\"you have declared `#[inline(always)]` on `{}`. This is usually a bad idea\",\n+                                   name));\n             }\n         }\n     }"}, {"sha": "c2fd37420663dfd129524f828733aad7ef7dab7e", "filename": "src/bit_mask.rs", "status": "modified", "additions": 137, "deletions": 88, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbit_mask.rs?ref=c9342d01213ca1663d2cdf23289bae024823ae6a", "patch": "@@ -95,26 +95,30 @@ impl LateLintPass for BitMask {\n     fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n         if let ExprBinary(ref cmp, ref left, ref right) = e.node {\n             if is_comparison_binop(cmp.node) {\n-                fetch_int_literal(cx, right).map_or_else(||\n-                    fetch_int_literal(cx, left).map_or((), |cmp_val|\n-                        check_compare(cx, right, invert_cmp(cmp.node),\n-                                      cmp_val, &e.span)),\n-                    |cmp_opt| check_compare(cx, left, cmp.node, cmp_opt,\n-                                            &e.span))\n+                fetch_int_literal(cx, right).map_or_else(|| {\n+                                                             fetch_int_literal(cx, left).map_or((), |cmp_val| {\n+                                                                 check_compare(cx,\n+                                                                               right,\n+                                                                               invert_cmp(cmp.node),\n+                                                                               cmp_val,\n+                                                                               &e.span)\n+                                                             })\n+                                                         },\n+                                                         |cmp_opt| check_compare(cx, left, cmp.node, cmp_opt, &e.span))\n             }\n         }\n     }\n }\n \n-fn invert_cmp(cmp : BinOp_) -> BinOp_ {\n+fn invert_cmp(cmp: BinOp_) -> BinOp_ {\n     match cmp {\n         BiEq => BiEq,\n         BiNe => BiNe,\n         BiLt => BiGt,\n         BiGt => BiLt,\n         BiLe => BiGe,\n         BiGe => BiLe,\n-        _ => BiOr // Dummy\n+        _ => BiOr, // Dummy\n     }\n }\n \n@@ -124,114 +128,159 @@ fn check_compare(cx: &LateContext, bit_op: &Expr, cmp_op: BinOp_, cmp_value: u64\n         if op.node != BiBitAnd && op.node != BiBitOr {\n             return;\n         }\n-        fetch_int_literal(cx, right).or_else(|| fetch_int_literal(\n-            cx, left)).map_or((), |mask| check_bit_mask(cx, op.node,\n-                                                        cmp_op, mask, cmp_value, span))\n+        fetch_int_literal(cx, right)\n+            .or_else(|| fetch_int_literal(cx, left))\n+            .map_or((), |mask| check_bit_mask(cx, op.node, cmp_op, mask, cmp_value, span))\n     }\n }\n \n-fn check_bit_mask(cx: &LateContext, bit_op: BinOp_, cmp_op: BinOp_,\n-                  mask_value: u64, cmp_value: u64, span: &Span) {\n+fn check_bit_mask(cx: &LateContext, bit_op: BinOp_, cmp_op: BinOp_, mask_value: u64, cmp_value: u64, span: &Span) {\n     match cmp_op {\n-        BiEq | BiNe => match bit_op {\n-            BiBitAnd => if mask_value & cmp_value != cmp_value {\n-                if cmp_value != 0 {\n-                    span_lint(cx, BAD_BIT_MASK, *span, &format!(\n-                        \"incompatible bit mask: `_ & {}` can never be equal to `{}`\",\n-                        mask_value, cmp_value));\n+        BiEq | BiNe => {\n+            match bit_op {\n+                BiBitAnd => {\n+                    if mask_value & cmp_value != cmp_value {\n+                        if cmp_value != 0 {\n+                            span_lint(cx,\n+                                      BAD_BIT_MASK,\n+                                      *span,\n+                                      &format!(\"incompatible bit mask: `_ & {}` can never be equal to `{}`\",\n+                                               mask_value,\n+                                               cmp_value));\n+                        }\n+                    } else {\n+                        if mask_value == 0 {\n+                            span_lint(cx, BAD_BIT_MASK, *span, \"&-masking with zero\");\n+                        }\n+                    }\n                 }\n-            } else {\n-                if mask_value == 0 {\n-                    span_lint(cx, BAD_BIT_MASK, *span, \"&-masking with zero\");\n+                BiBitOr => {\n+                    if mask_value | cmp_value != cmp_value {\n+                        span_lint(cx,\n+                                  BAD_BIT_MASK,\n+                                  *span,\n+                                  &format!(\"incompatible bit mask: `_ | {}` can never be equal to `{}`\",\n+                                           mask_value,\n+                                           cmp_value));\n+                    }\n                 }\n-            },\n-            BiBitOr => if mask_value | cmp_value != cmp_value {\n-                span_lint(cx, BAD_BIT_MASK, *span, &format!(\n-                    \"incompatible bit mask: `_ | {}` can never be equal to `{}`\",\n-                    mask_value, cmp_value));\n-            },\n-            _ => ()\n-        },\n-        BiLt | BiGe => match bit_op {\n-            BiBitAnd => if mask_value < cmp_value {\n-                span_lint(cx, BAD_BIT_MASK, *span, &format!(\n-                    \"incompatible bit mask: `_ & {}` will always be lower than `{}`\",\n-                    mask_value, cmp_value));\n-            } else {\n-                if mask_value == 0 {\n-                    span_lint(cx, BAD_BIT_MASK, *span, \"&-masking with zero\");\n+                _ => (),\n+            }\n+        }\n+        BiLt | BiGe => {\n+            match bit_op {\n+                BiBitAnd => {\n+                    if mask_value < cmp_value {\n+                        span_lint(cx,\n+                                  BAD_BIT_MASK,\n+                                  *span,\n+                                  &format!(\"incompatible bit mask: `_ & {}` will always be lower than `{}`\",\n+                                           mask_value,\n+                                           cmp_value));\n+                    } else {\n+                        if mask_value == 0 {\n+                            span_lint(cx, BAD_BIT_MASK, *span, \"&-masking with zero\");\n+                        }\n+                    }\n                 }\n-            },\n-            BiBitOr => if mask_value >= cmp_value {\n-                span_lint(cx, BAD_BIT_MASK, *span, &format!(\n-                    \"incompatible bit mask: `_ | {}` will never be lower than `{}`\",\n-                    mask_value, cmp_value));\n-            } else {\n-                check_ineffective_lt(cx, *span, mask_value, cmp_value, \"|\");\n-            },\n-            BiBitXor =>\n-                check_ineffective_lt(cx, *span, mask_value, cmp_value, \"^\"),\n-            _ => ()\n-        },\n-        BiLe | BiGt => match bit_op {\n-            BiBitAnd => if mask_value <= cmp_value {\n-                span_lint(cx, BAD_BIT_MASK, *span, &format!(\n-                    \"incompatible bit mask: `_ & {}` will never be higher than `{}`\",\n-                    mask_value, cmp_value));\n-            } else {\n-                if mask_value == 0 {\n-                    span_lint(cx, BAD_BIT_MASK, *span, \"&-masking with zero\");\n+                BiBitOr => {\n+                    if mask_value >= cmp_value {\n+                        span_lint(cx,\n+                                  BAD_BIT_MASK,\n+                                  *span,\n+                                  &format!(\"incompatible bit mask: `_ | {}` will never be lower than `{}`\",\n+                                           mask_value,\n+                                           cmp_value));\n+                    } else {\n+                        check_ineffective_lt(cx, *span, mask_value, cmp_value, \"|\");\n+                    }\n                 }\n-            },\n-            BiBitOr => if mask_value > cmp_value {\n-                span_lint(cx, BAD_BIT_MASK, *span, &format!(\n-                    \"incompatible bit mask: `_ | {}` will always be higher than `{}`\",\n-                    mask_value, cmp_value));\n-            } else {\n-                check_ineffective_gt(cx, *span, mask_value, cmp_value, \"|\");\n-            },\n-            BiBitXor =>\n-                check_ineffective_gt(cx, *span, mask_value, cmp_value, \"^\"),\n-            _ => ()\n-        },\n-        _ => ()\n+                BiBitXor => check_ineffective_lt(cx, *span, mask_value, cmp_value, \"^\"),\n+                _ => (),\n+            }\n+        }\n+        BiLe | BiGt => {\n+            match bit_op {\n+                BiBitAnd => {\n+                    if mask_value <= cmp_value {\n+                        span_lint(cx,\n+                                  BAD_BIT_MASK,\n+                                  *span,\n+                                  &format!(\"incompatible bit mask: `_ & {}` will never be higher than `{}`\",\n+                                           mask_value,\n+                                           cmp_value));\n+                    } else {\n+                        if mask_value == 0 {\n+                            span_lint(cx, BAD_BIT_MASK, *span, \"&-masking with zero\");\n+                        }\n+                    }\n+                }\n+                BiBitOr => {\n+                    if mask_value > cmp_value {\n+                        span_lint(cx,\n+                                  BAD_BIT_MASK,\n+                                  *span,\n+                                  &format!(\"incompatible bit mask: `_ | {}` will always be higher than `{}`\",\n+                                           mask_value,\n+                                           cmp_value));\n+                    } else {\n+                        check_ineffective_gt(cx, *span, mask_value, cmp_value, \"|\");\n+                    }\n+                }\n+                BiBitXor => check_ineffective_gt(cx, *span, mask_value, cmp_value, \"^\"),\n+                _ => (),\n+            }\n+        }\n+        _ => (),\n     }\n }\n \n fn check_ineffective_lt(cx: &LateContext, span: Span, m: u64, c: u64, op: &str) {\n     if c.is_power_of_two() && m < c {\n-        span_lint(cx, INEFFECTIVE_BIT_MASK, span, &format!(\n-            \"ineffective bit mask: `x {} {}` compared to `{}`, is the same as x compared directly\",\n-            op, m, c));\n+        span_lint(cx,\n+                  INEFFECTIVE_BIT_MASK,\n+                  span,\n+                  &format!(\"ineffective bit mask: `x {} {}` compared to `{}`, is the same as x compared directly\",\n+                           op,\n+                           m,\n+                           c));\n     }\n }\n \n fn check_ineffective_gt(cx: &LateContext, span: Span, m: u64, c: u64, op: &str) {\n     if (c + 1).is_power_of_two() && m <= c {\n-        span_lint(cx, INEFFECTIVE_BIT_MASK, span, &format!(\n-            \"ineffective bit mask: `x {} {}` compared to `{}`, is the same as x compared directly\",\n-            op, m, c));\n+        span_lint(cx,\n+                  INEFFECTIVE_BIT_MASK,\n+                  span,\n+                  &format!(\"ineffective bit mask: `x {} {}` compared to `{}`, is the same as x compared directly\",\n+                           op,\n+                           m,\n+                           c));\n     }\n }\n \n-fn fetch_int_literal(cx: &LateContext, lit : &Expr) -> Option<u64> {\n+fn fetch_int_literal(cx: &LateContext, lit: &Expr) -> Option<u64> {\n     match lit.node {\n         ExprLit(ref lit_ptr) => {\n             if let LitInt(value, _) = lit_ptr.node {\n                 Some(value) //TODO: Handle sign\n-            } else { None }\n+            } else {\n+                None\n+            }\n         }\n         ExprPath(_, _) => {\n-            // Important to let the borrow expire before the const lookup to avoid double\n-            // borrowing.\n-            let def_map = cx.tcx.def_map.borrow();\n-            match def_map.get(&lit.id) {\n-                Some(&PathResolution { base_def: DefConst(def_id), ..}) => Some(def_id),\n-                _ => None\n+            {\n+                // Important to let the borrow expire before the const lookup to avoid double\n+                // borrowing.\n+                let def_map = cx.tcx.def_map.borrow();\n+                match def_map.get(&lit.id) {\n+                    Some(&PathResolution { base_def: DefConst(def_id), ..}) => Some(def_id),\n+                    _ => None,\n+                }\n             }\n+            .and_then(|def_id| lookup_const_by_id(cx.tcx, def_id, None))\n+            .and_then(|l| fetch_int_literal(cx, l))\n         }\n-        .and_then(|def_id| lookup_const_by_id(cx.tcx, def_id, None))\n-        .and_then(|l| fetch_int_literal(cx, l)),\n-        _ => None\n+        _ => None,\n     }\n }"}, {"sha": "f7d8c95ee76a05c8742e524c815775deacbafd98", "filename": "src/block_in_if_condition.rs", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Fblock_in_if_condition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Fblock_in_if_condition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fblock_in_if_condition.rs?ref=c9342d01213ca1663d2cdf23289bae024823ae6a", "patch": "@@ -38,7 +38,7 @@ impl LintPass for BlockInIfCondition {\n }\n \n struct ExVisitor<'v> {\n-    found_block: Option<&'v Expr>\n+    found_block: Option<&'v Expr>,\n }\n \n impl<'v> Visitor<'v> for ExVisitor<'v> {\n@@ -51,24 +51,25 @@ impl<'v> Visitor<'v> for ExVisitor<'v> {\n                     if let Some(ref ex) = block.expr {\n                         match ex.node {\n                             ExprBlock(_) => true,\n-                            _ => false\n+                            _ => false,\n                         }\n                     } else {\n                         false\n                     }\n                 }\n             };\n             if complex {\n-                self.found_block = Some(& expr);\n+                self.found_block = Some(&expr);\n                 return;\n             }\n         }\n         walk_expr(self, expr);\n     }\n }\n \n-const BRACED_EXPR_MESSAGE:&'static str = \"omit braces around single expression condition\";\n-const COMPLEX_BLOCK_MESSAGE:&'static str = \"in an 'if' condition, avoid complex blocks or closures with blocks; instead, move the block or closure higher and bind it with a 'let'\";\n+const BRACED_EXPR_MESSAGE: &'static str = \"omit braces around single expression condition\";\n+const COMPLEX_BLOCK_MESSAGE: &'static str = \"in an 'if' condition, avoid complex blocks or closures with blocks; \\\n+                                             instead, move the block or closure higher and bind it with a 'let'\";\n \n impl LateLintPass for BlockInIfCondition {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n@@ -82,29 +83,33 @@ impl LateLintPass for BlockInIfCondition {\n                             if differing_macro_contexts(expr.span, ex.span) {\n                                 return;\n                             }\n-                            span_help_and_lint(cx, BLOCK_IN_IF_CONDITION_EXPR, check.span,\n-                                BRACED_EXPR_MESSAGE,\n-                                &format!(\"try\\nif {} {} ... \", snippet_block(cx, ex.span, \"..\"),\n-                                snippet_block(cx, then.span, \"..\")));\n+                            span_help_and_lint(cx,\n+                                               BLOCK_IN_IF_CONDITION_EXPR,\n+                                               check.span,\n+                                               BRACED_EXPR_MESSAGE,\n+                                               &format!(\"try\\nif {} {} ... \",\n+                                                        snippet_block(cx, ex.span, \"..\"),\n+                                                        snippet_block(cx, then.span, \"..\")));\n                         }\n                     } else {\n                         if differing_macro_contexts(expr.span, block.stmts[0].span) {\n                             return;\n                         }\n                         // move block higher\n-                        span_help_and_lint(cx, BLOCK_IN_IF_CONDITION_STMT, check.span,\n-                            COMPLEX_BLOCK_MESSAGE,\n-                            &format!(\"try\\nlet res = {};\\nif res {} ... \",\n-                            snippet_block(cx, block.span, \"..\"),\n-                            snippet_block(cx, then.span, \"..\")));\n+                        span_help_and_lint(cx,\n+                                           BLOCK_IN_IF_CONDITION_STMT,\n+                                           check.span,\n+                                           COMPLEX_BLOCK_MESSAGE,\n+                                           &format!(\"try\\nlet res = {};\\nif res {} ... \",\n+                                                    snippet_block(cx, block.span, \"..\"),\n+                                                    snippet_block(cx, then.span, \"..\")));\n                     }\n                 }\n             } else {\n                 let mut visitor = ExVisitor { found_block: None };\n                 walk_expr(&mut visitor, check);\n                 if let Some(ref block) = visitor.found_block {\n-                    span_help_and_lint(cx, BLOCK_IN_IF_CONDITION_STMT, block.span,\n-                        COMPLEX_BLOCK_MESSAGE, \"\");\n+                    span_help_and_lint(cx, BLOCK_IN_IF_CONDITION_STMT, block.span, COMPLEX_BLOCK_MESSAGE, \"\");\n                 }\n             }\n         }"}, {"sha": "4a17d3a4608dc12efe2f5d12e71ecf8acf4c362e", "filename": "src/collapsible_if.rs", "status": "modified", "additions": 27, "deletions": 14, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Fcollapsible_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Fcollapsible_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcollapsible_if.rs?ref=c9342d01213ca1663d2cdf23289bae024823ae6a", "patch": "@@ -52,23 +52,26 @@ impl LateLintPass for CollapsibleIf {\n fn check_if(cx: &LateContext, e: &Expr) {\n     if let ExprIf(ref check, ref then, None) = e.node {\n         if let Some(&Expr{ node: ExprIf(ref check_inner, ref content, None), span: sp, ..}) =\n-            single_stmt_of_block(then) {\n-                if e.span.expn_id != sp.expn_id {\n-                    return;\n-                }\n-                span_help_and_lint(cx, COLLAPSIBLE_IF, e.span,\n-                    \"this if statement can be collapsed\",\n-                    &format!(\"try\\nif {} && {} {}\",\n-                             check_to_string(cx, check), check_to_string(cx, check_inner),\n-                             snippet_block(cx, content.span, \"..\")));\n+               single_stmt_of_block(then) {\n+            if e.span.expn_id != sp.expn_id {\n+                return;\n             }\n+            span_help_and_lint(cx,\n+                               COLLAPSIBLE_IF,\n+                               e.span,\n+                               \"this if statement can be collapsed\",\n+                               &format!(\"try\\nif {} && {} {}\",\n+                                        check_to_string(cx, check),\n+                                        check_to_string(cx, check_inner),\n+                                        snippet_block(cx, content.span, \"..\")));\n+        }\n     }\n }\n \n fn requires_brackets(e: &Expr) -> bool {\n     match e.node {\n         ExprBinary(Spanned {node: n, ..}, _, _) if n == BiEq => false,\n-        _ => true\n+        _ => true,\n     }\n }\n \n@@ -84,16 +87,26 @@ fn single_stmt_of_block(block: &Block) -> Option<&Expr> {\n     if block.stmts.len() == 1 && block.expr.is_none() {\n         if let StmtExpr(ref expr, _) = block.stmts[0].node {\n             single_stmt_of_expr(expr)\n-        } else { None }\n+        } else {\n+            None\n+        }\n     } else {\n         if block.stmts.is_empty() {\n-            if let Some(ref p) = block.expr { Some(p) } else { None }\n-        } else { None }\n+            if let Some(ref p) = block.expr {\n+                Some(p)\n+            } else {\n+                None\n+            }\n+        } else {\n+            None\n+        }\n     }\n }\n \n fn single_stmt_of_expr(expr: &Expr) -> Option<&Expr> {\n     if let ExprBlock(ref block) = expr.node {\n         single_stmt_of_block(block)\n-    } else { Some(expr) }\n+    } else {\n+        Some(expr)\n+    }\n }"}, {"sha": "171ba6f27f053d7b241ad0d5b61f293b94ecd9a5", "filename": "src/consts.rs", "status": "modified", "additions": 278, "deletions": 165, "changes": 443, "blob_url": "https://github.com/rust-lang/rust/blob/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconsts.rs?ref=c9342d01213ca1663d2cdf23289bae024823ae6a", "patch": "@@ -28,7 +28,7 @@ use syntax::ast::Sign::{self, Plus, Minus};\n pub enum FloatWidth {\n     Fw32,\n     Fw64,\n-    FwAny\n+    FwAny,\n }\n \n impl From<FloatTy> for FloatWidth {\n@@ -85,24 +85,29 @@ impl Constant {\n         match *self {\n             ConstantByte(b) => Some(b as f64),\n             ConstantFloat(ref s, _) => s.parse().ok(),\n-            ConstantInt(i, ty) => Some(if is_negative(ty) {\n-                -(i as f64) } else { i as f64 }),\n-            _ => None\n+            ConstantInt(i, ty) => {\n+                Some(if is_negative(ty) {\n+                    -(i as f64)\n+                } else {\n+                    i as f64\n+                })\n+            }\n+            _ => None,\n         }\n     }\n }\n \n impl PartialEq for Constant {\n     fn eq(&self, other: &Constant) -> bool {\n         match (self, other) {\n-            (&ConstantStr(ref ls, ref lsty), &ConstantStr(ref rs, ref rsty)) =>\n-                ls == rs && lsty == rsty,\n+            (&ConstantStr(ref ls, ref lsty), &ConstantStr(ref rs, ref rsty)) => ls == rs && lsty == rsty,\n             (&ConstantBinary(ref l), &ConstantBinary(ref r)) => l == r,\n             (&ConstantByte(l), &ConstantByte(r)) => l == r,\n             (&ConstantChar(l), &ConstantChar(r)) => l == r,\n-            (&ConstantInt(lv, lty), &ConstantInt(rv, rty)) => lv == rv &&\n-               (is_negative(lty) & (lv != 0)) == (is_negative(rty) & (rv != 0)),\n-            (&ConstantFloat(ref ls, lw), &ConstantFloat(ref rs, rw)) =>\n+            (&ConstantInt(lv, lty), &ConstantInt(rv, rty)) => {\n+                lv == rv && (is_negative(lty) & (lv != 0)) == (is_negative(rty) & (rv != 0))\n+            }\n+            (&ConstantFloat(ref ls, lw), &ConstantFloat(ref rs, rw)) => {\n                 if match (lw, rw) {\n                     (FwAny, _) | (_, FwAny) | (Fw32, Fw32) | (Fw64, Fw64) => true,\n                     _ => false,\n@@ -111,11 +116,13 @@ impl PartialEq for Constant {\n                         (Ok(l), Ok(r)) => l.eq(&r),\n                         _ => false,\n                     }\n-                } else { false },\n+                } else {\n+                    false\n+                }\n+            }\n             (&ConstantBool(l), &ConstantBool(r)) => l == r,\n             (&ConstantVec(ref l), &ConstantVec(ref r)) => l == r,\n-            (&ConstantRepeat(ref lv, ref ls), &ConstantRepeat(ref rv, ref rs)) =>\n-                ls == rs && lv == rv,\n+            (&ConstantRepeat(ref lv, ref ls), &ConstantRepeat(ref rv, ref rs)) => ls == rs && lv == rv,\n             (&ConstantTuple(ref l), &ConstantTuple(ref r)) => l == r,\n             _ => false, //TODO: Are there inter-type equalities?\n         }\n@@ -125,19 +132,24 @@ impl PartialEq for Constant {\n impl PartialOrd for Constant {\n     fn partial_cmp(&self, other: &Constant) -> Option<Ordering> {\n         match (self, other) {\n-            (&ConstantStr(ref ls, ref lsty), &ConstantStr(ref rs, ref rsty)) =>\n-                if lsty != rsty { None } else { Some(ls.cmp(rs)) },\n+            (&ConstantStr(ref ls, ref lsty), &ConstantStr(ref rs, ref rsty)) => {\n+                if lsty != rsty {\n+                    None\n+                } else {\n+                    Some(ls.cmp(rs))\n+                }\n+            }\n             (&ConstantByte(ref l), &ConstantByte(ref r)) => Some(l.cmp(r)),\n             (&ConstantChar(ref l), &ConstantChar(ref r)) => Some(l.cmp(r)),\n-            (&ConstantInt(ref lv, lty), &ConstantInt(ref rv, rty)) =>\n-                Some(match (is_negative(lty) && *lv != 0,\n-                            is_negative(rty) && *rv != 0) {\n+            (&ConstantInt(ref lv, lty), &ConstantInt(ref rv, rty)) => {\n+                Some(match (is_negative(lty) && *lv != 0, is_negative(rty) && *rv != 0) {\n                     (true, true) => rv.cmp(lv),\n                     (false, false) => lv.cmp(rv),\n                     (true, false) => Less,\n                     (false, true) => Greater,\n-                }),\n-            (&ConstantFloat(ref ls, lw), &ConstantFloat(ref rs, rw)) =>\n+                })\n+            }\n+            (&ConstantFloat(ref ls, lw), &ConstantFloat(ref rs, rw)) => {\n                 if match (lw, rw) {\n                     (FwAny, _) | (_, FwAny) | (Fw32, Fw32) | (Fw64, Fw64) => true,\n                     _ => false,\n@@ -146,17 +158,21 @@ impl PartialOrd for Constant {\n                         (Ok(ref l), Ok(ref r)) => l.partial_cmp(r),\n                         _ => None,\n                     }\n-                } else { None },\n+                } else {\n+                    None\n+                }\n+            }\n             (&ConstantBool(ref l), &ConstantBool(ref r)) => Some(l.cmp(r)),\n             (&ConstantVec(ref l), &ConstantVec(ref r)) => l.partial_cmp(&r),\n-            (&ConstantRepeat(ref lv, ref ls), &ConstantRepeat(ref rv, ref rs)) =>\n+            (&ConstantRepeat(ref lv, ref ls), &ConstantRepeat(ref rv, ref rs)) => {\n                 match lv.partial_cmp(rv) {\n                     Some(Equal) => Some(ls.cmp(rs)),\n                     x => x,\n-                },\n+                }\n+            }\n             (&ConstantTuple(ref l), &ConstantTuple(ref r)) => l.partial_cmp(r),\n-             _ => None, //TODO: Are there any useful inter-type orderings?\n-         }\n+            _ => None, //TODO: Are there any useful inter-type orderings?\n+        }\n     }\n }\n \n@@ -178,9 +194,11 @@ impl fmt::Display for Constant {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             ConstantStr(ref s, _) => write!(fmt, \"{:?}\", s),\n-            ConstantByte(ref b) =>\n-                write!(fmt, \"b'\").and_then(|_| format_byte(fmt, *b))\n-                                 .and_then(|_| write!(fmt, \"'\")),\n+            ConstantByte(ref b) => {\n+                write!(fmt, \"b'\")\n+                    .and_then(|_| format_byte(fmt, *b))\n+                    .and_then(|_| write!(fmt, \"'\"))\n+            }\n             ConstantBinary(ref bs) => {\n                 try!(write!(fmt, \"b\\\"\"));\n                 for b in bs.iter() {\n@@ -191,14 +209,23 @@ impl fmt::Display for Constant {\n             ConstantChar(ref c) => write!(fmt, \"'{}'\", c),\n             ConstantInt(ref i, ref ity) => {\n                 let (sign, suffix) = match *ity {\n-                    LitIntType::SignedIntLit(ref sity, ref sign) =>\n-                        (if let Sign::Minus = *sign { \"-\" } else { \"\" },\n-                         sity.ty_to_string()),\n-                    LitIntType::UnsignedIntLit(ref uity) =>\n-                        (\"\", uity.ty_to_string()),\n-                    LitIntType::UnsuffixedIntLit(ref sign) =>\n-                        (if let Sign::Minus = *sign { \"-\" } else { \"\" },\n-                         \"\".into()),\n+                    LitIntType::SignedIntLit(ref sity, ref sign) => {\n+                        (if let Sign::Minus = *sign {\n+                            \"-\"\n+                        } else {\n+                            \"\"\n+                        },\n+                         sity.ty_to_string())\n+                    }\n+                    LitIntType::UnsignedIntLit(ref uity) => (\"\", uity.ty_to_string()),\n+                    LitIntType::UnsuffixedIntLit(ref sign) => {\n+                        (if let Sign::Minus = *sign {\n+                            \"-\"\n+                        } else {\n+                            \"\"\n+                        },\n+                         \"\".into())\n+                    }\n                 };\n                 write!(fmt, \"{}{}{}\", sign, i, suffix)\n             }\n@@ -212,12 +239,22 @@ impl fmt::Display for Constant {\n             }\n             ConstantBool(ref b) => write!(fmt, \"{}\", b),\n             ConstantRepeat(ref c, ref n) => write!(fmt, \"[{}; {}]\", c, n),\n-            ConstantVec(ref v) => write!(fmt, \"[{}]\",\n-                                         v.iter().map(|i| format!(\"{}\", i))\n-                                                 .collect::<Vec<_>>().join(\", \")),\n-            ConstantTuple(ref t) => write!(fmt, \"({})\",\n-                                           t.iter().map(|i| format!(\"{}\", i))\n-                                                   .collect::<Vec<_>>().join(\", \")),\n+            ConstantVec(ref v) => {\n+                write!(fmt,\n+                       \"[{}]\",\n+                       v.iter()\n+                        .map(|i| format!(\"{}\", i))\n+                        .collect::<Vec<_>>()\n+                        .join(\", \"))\n+            }\n+            ConstantTuple(ref t) => {\n+                write!(fmt,\n+                       \"({})\",\n+                       t.iter()\n+                        .map(|i| format!(\"{}\", i))\n+                        .collect::<Vec<_>>()\n+                        .join(\", \"))\n+            }\n         }\n     }\n }\n@@ -242,7 +279,9 @@ fn constant_not(o: Constant) -> Option<Constant> {\n         ConstantInt(value, ty) => {\n             let (nvalue, nty) = match ty {\n                 SignedIntLit(ity, Plus) => {\n-                    if value == ::std::u64::MAX { return None; }\n+                    if value == ::std::u64::MAX {\n+                        return None;\n+                    }\n                     (value + 1, SignedIntLit(ity, Minus))\n                 }\n                 SignedIntLit(ity, Minus) => {\n@@ -258,30 +297,40 @@ fn constant_not(o: Constant) -> Option<Constant> {\n                         UintTy::TyU16 => ::std::u16::MAX as u64,\n                         UintTy::TyU32 => ::std::u32::MAX as u64,\n                         UintTy::TyU64 => ::std::u64::MAX,\n-                        UintTy::TyUs => { return None; }  // refuse to guess\n+                        UintTy::TyUs => {\n+                            return None;\n+                        }  // refuse to guess\n                     };\n                     (!value & mask, UnsignedIntLit(ity))\n                 }\n-                UnsuffixedIntLit(_) => { return None; }  // refuse to guess\n+                UnsuffixedIntLit(_) => {\n+                    return None;\n+                }  // refuse to guess\n             };\n             ConstantInt(nvalue, nty)\n         }\n-        _ => { return None; }\n+        _ => {\n+            return None;\n+        }\n     })\n }\n \n fn constant_negate(o: Constant) -> Option<Constant> {\n     Some(match o {\n-        ConstantInt(value, ty) =>\n-            ConstantInt(value, match ty {\n-                SignedIntLit(ity, sign) =>\n-                    SignedIntLit(ity, neg_sign(sign)),\n-                UnsuffixedIntLit(sign) => UnsuffixedIntLit(neg_sign(sign)),\n-                _ => { return None; }\n-            }),\n-        ConstantFloat(is, ty) =>\n-            ConstantFloat(neg_float_str(is), ty),\n-        _ => { return None; }\n+        ConstantInt(value, ty) => {\n+            ConstantInt(value,\n+                        match ty {\n+                            SignedIntLit(ity, sign) => SignedIntLit(ity, neg_sign(sign)),\n+                            UnsuffixedIntLit(sign) => UnsuffixedIntLit(neg_sign(sign)),\n+                            _ => {\n+                                return None;\n+                            }\n+                        })\n+        }\n+        ConstantFloat(is, ty) => ConstantFloat(neg_float_str(is), ty),\n+        _ => {\n+            return None;\n+        }\n     })\n }\n \n@@ -316,96 +365,123 @@ pub fn is_negative(ty: LitIntType) -> bool {\n \n fn unify_int_type(l: LitIntType, r: LitIntType, s: Sign) -> Option<LitIntType> {\n     match (l, r) {\n-        (SignedIntLit(lty, _), SignedIntLit(rty, _)) => if lty == rty {\n-            Some(SignedIntLit(lty, s)) } else { None },\n-        (UnsignedIntLit(lty), UnsignedIntLit(rty)) =>\n+        (SignedIntLit(lty, _), SignedIntLit(rty, _)) => {\n+            if lty == rty {\n+                Some(SignedIntLit(lty, s))\n+            } else {\n+                None\n+            }\n+        }\n+        (UnsignedIntLit(lty), UnsignedIntLit(rty)) => {\n             if s == Plus && lty == rty {\n                 Some(UnsignedIntLit(lty))\n-            } else { None },\n+            } else {\n+                None\n+            }\n+        }\n         (UnsuffixedIntLit(_), UnsuffixedIntLit(_)) => Some(UnsuffixedIntLit(s)),\n         (SignedIntLit(lty, _), UnsuffixedIntLit(_)) => Some(SignedIntLit(lty, s)),\n-        (UnsignedIntLit(lty), UnsuffixedIntLit(rs)) => if rs == Plus {\n-            Some(UnsignedIntLit(lty)) } else { None },\n+        (UnsignedIntLit(lty), UnsuffixedIntLit(rs)) => {\n+            if rs == Plus {\n+                Some(UnsignedIntLit(lty))\n+            } else {\n+                None\n+            }\n+        }\n         (UnsuffixedIntLit(_), SignedIntLit(rty, _)) => Some(SignedIntLit(rty, s)),\n-        (UnsuffixedIntLit(ls), UnsignedIntLit(rty)) => if ls == Plus {\n-            Some(UnsignedIntLit(rty)) } else { None },\n+        (UnsuffixedIntLit(ls), UnsignedIntLit(rty)) => {\n+            if ls == Plus {\n+                Some(UnsignedIntLit(rty))\n+            } else {\n+                None\n+            }\n+        }\n         _ => None,\n     }\n }\n \n-fn add_neg_int(pos: u64, pty: LitIntType, neg: u64, nty: LitIntType) ->\n-        Option<Constant> {\n+fn add_neg_int(pos: u64, pty: LitIntType, neg: u64, nty: LitIntType) -> Option<Constant> {\n     if neg > pos {\n         unify_int_type(nty, pty, Minus).map(|ty| ConstantInt(neg - pos, ty))\n     } else {\n         unify_int_type(nty, pty, Plus).map(|ty| ConstantInt(pos - neg, ty))\n     }\n }\n \n-fn sub_int(l: u64, lty: LitIntType, r: u64, rty: LitIntType, neg: bool) ->\n-        Option<Constant> {\n-     unify_int_type(lty, rty, if neg { Minus } else { Plus }).and_then(\n-        |ty| l.checked_sub(r).map(|v| ConstantInt(v, ty)))\n+fn sub_int(l: u64, lty: LitIntType, r: u64, rty: LitIntType, neg: bool) -> Option<Constant> {\n+    unify_int_type(lty,\n+                   rty,\n+                   if neg {\n+                       Minus\n+                   } else {\n+                       Plus\n+                   })\n+        .and_then(|ty| l.checked_sub(r).map(|v| ConstantInt(v, ty)))\n }\n \n \n pub fn constant(lcx: &LateContext, e: &Expr) -> Option<(Constant, bool)> {\n-    let mut cx = ConstEvalLateContext { lcx: Some(lcx), needed_resolution: false };\n+    let mut cx = ConstEvalLateContext {\n+        lcx: Some(lcx),\n+        needed_resolution: false,\n+    };\n     cx.expr(e).map(|cst| (cst, cx.needed_resolution))\n }\n \n pub fn constant_simple(e: &Expr) -> Option<Constant> {\n-    let mut cx = ConstEvalLateContext { lcx: None, needed_resolution: false };\n+    let mut cx = ConstEvalLateContext {\n+        lcx: None,\n+        needed_resolution: false,\n+    };\n     cx.expr(e)\n }\n \n struct ConstEvalLateContext<'c, 'cc: 'c> {\n     lcx: Option<&'c LateContext<'c, 'cc>>,\n-    needed_resolution: bool\n+    needed_resolution: bool,\n }\n \n impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n-\n     /// simple constant folding: Insert an expression, get a constant or none.\n     fn expr(&mut self, e: &Expr) -> Option<Constant> {\n         match e.node {\n             ExprPath(_, _) => self.fetch_path(e),\n             ExprBlock(ref block) => self.block(block),\n-            ExprIf(ref cond, ref then, ref otherwise) =>\n-                self.ifthenelse(cond, then, otherwise),\n+            ExprIf(ref cond, ref then, ref otherwise) => self.ifthenelse(cond, then, otherwise),\n             ExprLit(ref lit) => Some(lit_to_constant(&lit.node)),\n             ExprVec(ref vec) => self.multi(vec).map(ConstantVec),\n             ExprTup(ref tup) => self.multi(tup).map(ConstantTuple),\n-            ExprRepeat(ref value, ref number) =>\n-                self.binop_apply(value, number, |v, n|\n-                    Some(ConstantRepeat(Box::new(v), n.as_u64() as usize))),\n-            ExprUnary(op, ref operand) => self.expr(operand).and_then(\n-                |o| match op {\n-                    UnNot => constant_not(o),\n-                    UnNeg => constant_negate(o),\n-                    UnDeref => Some(o),\n-                }),\n-            ExprBinary(op, ref left, ref right) =>\n-                self.binop(op, left, right),\n-            //TODO: add other expressions\n+            ExprRepeat(ref value, ref number) => {\n+                self.binop_apply(value, number, |v, n| Some(ConstantRepeat(Box::new(v), n.as_u64() as usize)))\n+            }\n+            ExprUnary(op, ref operand) => {\n+                self.expr(operand).and_then(|o| {\n+                    match op {\n+                        UnNot => constant_not(o),\n+                        UnNeg => constant_negate(o),\n+                        UnDeref => Some(o),\n+                    }\n+                })\n+            }\n+            ExprBinary(op, ref left, ref right) => self.binop(op, left, right),\n+            // TODO: add other expressions\n             _ => None,\n         }\n     }\n \n     /// create `Some(Vec![..])` of all constants, unless there is any\n     /// non-constant part\n-    fn multi<E: Deref<Target=Expr> + Sized>(&mut self, vec: &[E]) ->\n-            Option<Vec<Constant>> {\n-        vec.iter().map(|elem| self.expr(elem))\n-                  .collect::<Option<_>>()\n+    fn multi<E: Deref<Target = Expr> + Sized>(&mut self, vec: &[E]) -> Option<Vec<Constant>> {\n+        vec.iter()\n+           .map(|elem| self.expr(elem))\n+           .collect::<Option<_>>()\n     }\n \n     /// lookup a possibly constant expression from a ExprPath\n     fn fetch_path(&mut self, e: &Expr) -> Option<Constant> {\n         if let Some(lcx) = self.lcx {\n             let mut maybe_id = None;\n-            if let Some(&PathResolution { base_def: DefConst(id), ..}) =\n-                lcx.tcx.def_map.borrow().get(&e.id) {\n+            if let Some(&PathResolution { base_def: DefConst(id), ..}) = lcx.tcx.def_map.borrow().get(&e.id) {\n                 maybe_id = Some(id);\n             }\n             // separate if lets to avoid doubleborrowing the defmap\n@@ -426,134 +502,171 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n     fn block(&mut self, block: &Block) -> Option<Constant> {\n         if block.stmts.is_empty() {\n             block.expr.as_ref().and_then(|ref b| self.expr(b))\n-        } else { None }\n+        } else {\n+            None\n+        }\n     }\n \n-    fn ifthenelse(&mut self, cond: &Expr, then: &Block, otherwise: &Option<P<Expr>>)\n-                  -> Option<Constant> {\n+    fn ifthenelse(&mut self, cond: &Expr, then: &Block, otherwise: &Option<P<Expr>>) -> Option<Constant> {\n         if let Some(ConstantBool(b)) = self.expr(cond) {\n             if b {\n                 self.block(then)\n             } else {\n                 otherwise.as_ref().and_then(|expr| self.expr(expr))\n             }\n-        } else { None }\n+        } else {\n+            None\n+        }\n     }\n \n     fn binop(&mut self, op: BinOp, left: &Expr, right: &Expr) -> Option<Constant> {\n         match op.node {\n-            BiAdd => self.binop_apply(left, right, |l, r|\n-                match (l, r) {\n-                    (ConstantByte(l8), ConstantByte(r8)) =>\n-                        l8.checked_add(r8).map(ConstantByte),\n-                    (ConstantInt(l64, lty), ConstantInt(r64, rty)) => {\n-                        let (ln, rn) = (is_negative(lty), is_negative(rty));\n-                        if ln == rn {\n-                            unify_int_type(lty, rty, if ln { Minus } else { Plus })\n-                                .and_then(|ty| l64.checked_add(r64).map(\n-                                    |v| ConstantInt(v, ty)))\n-                        } else {\n-                            if ln {\n-                                add_neg_int(r64, rty, l64, lty)\n+            BiAdd => {\n+                self.binop_apply(left, right, |l, r| {\n+                    match (l, r) {\n+                        (ConstantByte(l8), ConstantByte(r8)) => l8.checked_add(r8).map(ConstantByte),\n+                        (ConstantInt(l64, lty), ConstantInt(r64, rty)) => {\n+                            let (ln, rn) = (is_negative(lty), is_negative(rty));\n+                            if ln == rn {\n+                                unify_int_type(lty,\n+                                               rty,\n+                                               if ln {\n+                                                   Minus\n+                                               } else {\n+                                                   Plus\n+                                               })\n+                                    .and_then(|ty| l64.checked_add(r64).map(|v| ConstantInt(v, ty)))\n                             } else {\n-                                add_neg_int(l64, lty, r64, rty)\n+                                if ln {\n+                                    add_neg_int(r64, rty, l64, lty)\n+                                } else {\n+                                    add_neg_int(l64, lty, r64, rty)\n+                                }\n                             }\n                         }\n+                        // TODO: float (would need bignum library?)\n+                        _ => None,\n                     }\n-                    // TODO: float (would need bignum library?)\n-                    _ => None\n-                }),\n-            BiSub => self.binop_apply(left, right, |l, r|\n-                match (l, r) {\n-                    (ConstantByte(l8), ConstantByte(r8)) => if r8 > l8 {\n-                        None } else { Some(ConstantByte(l8 - r8)) },\n-                    (ConstantInt(l64, lty), ConstantInt(r64, rty)) =>\n-                        match (is_negative(lty), is_negative(rty)) {\n-                            (false, false) => sub_int(l64, lty, r64, rty, r64 > l64),\n-                            (true, true) => sub_int(l64, lty, r64, rty, l64 > r64),\n-                            (true, false) => unify_int_type(lty, rty, Minus)\n-                                .and_then(|ty| l64.checked_add(r64).map(\n-                                    |v| ConstantInt(v, ty))),\n-                            (false, true) => unify_int_type(lty, rty, Plus)\n-                                .and_then(|ty| l64.checked_add(r64).map(\n-                                    |v| ConstantInt(v, ty))),\n-                        },\n-                    _ => None,\n-                }),\n+                })\n+            }\n+            BiSub => {\n+                self.binop_apply(left, right, |l, r| {\n+                    match (l, r) {\n+                        (ConstantByte(l8), ConstantByte(r8)) => {\n+                            if r8 > l8 {\n+                                None\n+                            } else {\n+                                Some(ConstantByte(l8 - r8))\n+                            }\n+                        }\n+                        (ConstantInt(l64, lty), ConstantInt(r64, rty)) => {\n+                            match (is_negative(lty), is_negative(rty)) {\n+                                (false, false) => sub_int(l64, lty, r64, rty, r64 > l64),\n+                                (true, true) => sub_int(l64, lty, r64, rty, l64 > r64),\n+                                (true, false) => {\n+                                    unify_int_type(lty, rty, Minus)\n+                                        .and_then(|ty| l64.checked_add(r64).map(|v| ConstantInt(v, ty)))\n+                                }\n+                                (false, true) => {\n+                                    unify_int_type(lty, rty, Plus)\n+                                        .and_then(|ty| l64.checked_add(r64).map(|v| ConstantInt(v, ty)))\n+                                }\n+                            }\n+                        }\n+                        _ => None,\n+                    }\n+                })\n+            }\n             BiMul => self.divmul(left, right, u64::checked_mul),\n             BiDiv => self.divmul(left, right, u64::checked_div),\n-            //BiRem,\n+            // BiRem,\n             BiAnd => self.short_circuit(left, right, false),\n             BiOr => self.short_circuit(left, right, true),\n             BiBitXor => self.bitop(left, right, |x, y| x ^ y),\n             BiBitAnd => self.bitop(left, right, |x, y| x & y),\n             BiBitOr => self.bitop(left, right, |x, y| (x | y)),\n             BiShl => self.bitop(left, right, |x, y| x << y),\n             BiShr => self.bitop(left, right, |x, y| x >> y),\n-            BiEq => self.binop_apply(left, right,\n-                |l, r| Some(ConstantBool(l == r))),\n-            BiNe => self.binop_apply(left, right,\n-                |l, r| Some(ConstantBool(l != r))),\n+            BiEq => self.binop_apply(left, right, |l, r| Some(ConstantBool(l == r))),\n+            BiNe => self.binop_apply(left, right, |l, r| Some(ConstantBool(l != r))),\n             BiLt => self.cmp(left, right, Less, true),\n             BiLe => self.cmp(left, right, Greater, false),\n             BiGe => self.cmp(left, right, Less, false),\n             BiGt => self.cmp(left, right, Greater, true),\n-            _ => None\n+            _ => None,\n         }\n     }\n \n-    fn divmul<F>(&mut self, left: &Expr, right: &Expr, f: F)\n-            -> Option<Constant> where F: Fn(u64, u64) -> Option<u64> {\n-        self.binop_apply(left, right, |l, r|\n+    fn divmul<F>(&mut self, left: &Expr, right: &Expr, f: F) -> Option<Constant>\n+        where F: Fn(u64, u64) -> Option<u64>\n+    {\n+        self.binop_apply(left, right, |l, r| {\n             match (l, r) {\n                 (ConstantInt(l64, lty), ConstantInt(r64, rty)) => {\n-                    f(l64, r64).and_then(|value|\n-                        unify_int_type(lty, rty, if is_negative(lty) ==\n-                                is_negative(rty) { Plus } else { Minus })\n-                            .map(|ty| ConstantInt(value, ty)))\n+                    f(l64, r64).and_then(|value| {\n+                        unify_int_type(lty,\n+                                       rty,\n+                                       if is_negative(lty) == is_negative(rty) {\n+                                           Plus\n+                                       } else {\n+                                           Minus\n+                                       })\n+                            .map(|ty| ConstantInt(value, ty))\n+                    })\n                 }\n                 _ => None,\n-            })\n+            }\n+        })\n     }\n \n-    fn bitop<F>(&mut self, left: &Expr, right: &Expr, f: F)\n-            -> Option<Constant> where F: Fn(u64, u64) -> u64 {\n-        self.binop_apply(left, right, |l, r| match (l, r) {\n-            (ConstantBool(l), ConstantBool(r)) =>\n-                Some(ConstantBool(f(l as u64, r as u64) != 0)),\n-            (ConstantByte(l8), ConstantByte(r8)) =>\n-                Some(ConstantByte(f(l8 as u64, r8 as u64) as u8)),\n-            (ConstantInt(l, lty), ConstantInt(r, rty)) =>\n-                unify_int_type(lty, rty, Plus).map(|ty| ConstantInt(f(l, r), ty)),\n-            _ => None\n+    fn bitop<F>(&mut self, left: &Expr, right: &Expr, f: F) -> Option<Constant>\n+        where F: Fn(u64, u64) -> u64\n+    {\n+        self.binop_apply(left, right, |l, r| {\n+            match (l, r) {\n+                (ConstantBool(l), ConstantBool(r)) => Some(ConstantBool(f(l as u64, r as u64) != 0)),\n+                (ConstantByte(l8), ConstantByte(r8)) => Some(ConstantByte(f(l8 as u64, r8 as u64) as u8)),\n+                (ConstantInt(l, lty), ConstantInt(r, rty)) => {\n+                    unify_int_type(lty, rty, Plus).map(|ty| ConstantInt(f(l, r), ty))\n+                }\n+                _ => None,\n+            }\n         })\n     }\n \n     fn cmp(&mut self, left: &Expr, right: &Expr, ordering: Ordering, b: bool) -> Option<Constant> {\n-        self.binop_apply(left, right, |l, r| l.partial_cmp(&r).map(|o|\n-            ConstantBool(b == (o == ordering))))\n+        self.binop_apply(left,\n+                         right,\n+                         |l, r| l.partial_cmp(&r).map(|o| ConstantBool(b == (o == ordering))))\n     }\n \n     fn binop_apply<F>(&mut self, left: &Expr, right: &Expr, op: F) -> Option<Constant>\n-    where F: Fn(Constant, Constant) -> Option<Constant> {\n+        where F: Fn(Constant, Constant) -> Option<Constant>\n+    {\n         if let (Some(lc), Some(rc)) = (self.expr(left), self.expr(right)) {\n             op(lc, rc)\n-        } else { None }\n+        } else {\n+            None\n+        }\n     }\n \n     fn short_circuit(&mut self, left: &Expr, right: &Expr, b: bool) -> Option<Constant> {\n-        self.expr(left).and_then(|left|\n+        self.expr(left).and_then(|left| {\n             if let ConstantBool(lbool) = left {\n                 if lbool == b {\n                     Some(left)\n                 } else {\n-                    self.expr(right).and_then(|right|\n+                    self.expr(right).and_then(|right| {\n                         if let ConstantBool(_) = right {\n                             Some(right)\n-                        } else { None }\n-                    )\n+                        } else {\n+                            None\n+                        }\n+                    })\n                 }\n-            } else { None }\n-        )\n+            } else {\n+                None\n+            }\n+        })\n     }\n }"}, {"sha": "d4375abcd05cccf7ff1d9d0f95b5fbdd029ae86c", "filename": "src/cyclomatic_complexity.rs", "status": "modified", "additions": 24, "deletions": 15, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Fcyclomatic_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Fcyclomatic_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcyclomatic_complexity.rs?ref=c9342d01213ca1663d2cdf23289bae024823ae6a", "patch": "@@ -27,9 +27,7 @@ pub struct CyclomaticComplexity {\n \n impl CyclomaticComplexity {\n     pub fn new(limit: u64) -> Self {\n-        CyclomaticComplexity {\n-            limit: LimitStack::new(limit),\n-        }\n+        CyclomaticComplexity { limit: LimitStack::new(limit) }\n     }\n }\n \n@@ -41,7 +39,9 @@ impl LintPass for CyclomaticComplexity {\n \n impl CyclomaticComplexity {\n     fn check<'a, 'tcx>(&mut self, cx: &'a LateContext<'a, 'tcx>, block: &Block, span: Span) {\n-        if in_macro(cx, span) { return; }\n+        if in_macro(cx, span) {\n+            return;\n+        }\n         let cfg = CFG::new(cx.tcx, block);\n         let n = cfg.graph.len_nodes() as u64;\n         let e = cfg.graph.len_edges() as u64;\n@@ -59,9 +59,11 @@ impl CyclomaticComplexity {\n         } else {\n             let rust_cc = cc + divergence - narms;\n             if rust_cc > self.limit.limit() {\n-                span_help_and_lint(cx, CYCLOMATIC_COMPLEXITY, span,\n-                &format!(\"The function has a cyclomatic complexity of {}\", rust_cc),\n-                \"You could split it up into multiple smaller functions\");\n+                span_help_and_lint(cx,\n+                                   CYCLOMATIC_COMPLEXITY,\n+                                   span,\n+                                   &format!(\"The function has a cyclomatic complexity of {}\", rust_cc),\n+                                   \"You could split it up into multiple smaller functions\");\n             }\n         }\n     }\n@@ -105,8 +107,8 @@ impl<'a> Visitor<'a> for MatchArmCounter {\n                 if arms_n > 1 {\n                     self.0 += arms_n - 2;\n                 }\n-            },\n-            ExprClosure(..) => {},\n+            }\n+            ExprClosure(..) => {}\n             _ => walk_expr(self, e),\n         }\n     }\n@@ -125,24 +127,31 @@ impl<'a, 'b, 'tcx> Visitor<'a> for DivergenceCounter<'b, 'tcx> {\n                         self.0 += 1;\n                     }\n                 }\n-            },\n-            ExprClosure(..) => {},\n+            }\n+            ExprClosure(..) => {}\n             _ => walk_expr(self, e),\n         }\n     }\n }\n \n #[cfg(feature=\"debugging\")]\n fn report_cc_bug(cx: &LateContext, cc: u64, narms: u64, div: u64, span: Span) {\n-    cx.sess().span_bug(span, &format!(\"Clippy encountered a bug calculating cyclomatic complexity: \\\n-                                       cc = {}, arms = {}, div = {}. Please file a bug report.\", cc, narms, div));;\n+    cx.sess().span_bug(span,\n+                       &format!(\"Clippy encountered a bug calculating cyclomatic complexity: cc = {}, arms = {}, \\\n+                                 div = {}. Please file a bug report.\",\n+                                cc,\n+                                narms,\n+                                div));;\n }\n #[cfg(not(feature=\"debugging\"))]\n fn report_cc_bug(cx: &LateContext, cc: u64, narms: u64, div: u64, span: Span) {\n     if cx.current_level(CYCLOMATIC_COMPLEXITY) != Level::Allow {\n         cx.sess().span_note_without_error(span,\n                                           &format!(\"Clippy encountered a bug calculating cyclomatic complexity \\\n-                                                    (hide this message with `#[allow(cyclomatic_complexity)]`): \\\n-                                                    cc = {}, arms = {}, div = {}. Please file a bug report.\", cc, narms, div));\n+                                                    (hide this message with `#[allow(cyclomatic_complexity)]`): cc \\\n+                                                    = {}, arms = {}, div = {}. Please file a bug report.\",\n+                                                   cc,\n+                                                   narms,\n+                                                   div));\n     }\n }"}, {"sha": "31dc094385f707a00eb927e6dd015e5ed33dbe87", "filename": "src/eq_op.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feq_op.rs?ref=c9342d01213ca1663d2cdf23289bae024823ae6a", "patch": "@@ -30,19 +30,29 @@ impl LateLintPass for EqOp {\n     fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n         if let ExprBinary(ref op, ref left, ref right) = e.node {\n             if is_cmp_or_bit(op) && is_exp_equal(cx, left, right) {\n-                span_lint(cx, EQ_OP, e.span, &format!(\n-                    \"equal expressions as operands to {}\",\n-                        ast_util::binop_to_string(op.node)));\n+                span_lint(cx,\n+                          EQ_OP,\n+                          e.span,\n+                          &format!(\"equal expressions as operands to {}\", ast_util::binop_to_string(op.node)));\n             }\n         }\n     }\n }\n \n \n-fn is_cmp_or_bit(op : &BinOp) -> bool {\n+fn is_cmp_or_bit(op: &BinOp) -> bool {\n     match op.node {\n-        BiEq | BiLt | BiLe | BiGt | BiGe | BiNe | BiAnd | BiOr |\n-        BiBitXor | BiBitAnd | BiBitOr => true,\n-        _ => false\n+        BiEq |\n+        BiLt |\n+        BiLe |\n+        BiGt |\n+        BiGe |\n+        BiNe |\n+        BiAnd |\n+        BiOr |\n+        BiBitXor |\n+        BiBitAnd |\n+        BiBitOr => true,\n+        _ => false,\n     }\n }"}, {"sha": "079fdcf09a031e2660c5e07073fd7cce8935e36f", "filename": "src/escape.rs", "status": "modified", "additions": 13, "deletions": 27, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fescape.rs?ref=c9342d01213ca1663d2cdf23289bae024823ae6a", "patch": "@@ -43,13 +43,7 @@ impl LintPass for EscapePass {\n }\n \n impl LateLintPass for EscapePass {\n-    fn check_fn(&mut self,\n-                cx: &LateContext,\n-                _: visit::FnKind,\n-                decl: &FnDecl,\n-                body: &Block,\n-                _: Span,\n-                id: NodeId) {\n+    fn check_fn(&mut self, cx: &LateContext, _: visit::FnKind, decl: &FnDecl, body: &Block, _: Span, id: NodeId) {\n         let param_env = ty::ParameterEnvironment::for_item(cx.tcx, id);\n         let infcx = infer::new_infer_ctxt(cx.tcx, &cx.tcx.tables, Some(param_env), false);\n         let mut v = EscapeDelegate {\n@@ -70,11 +64,7 @@ impl LateLintPass for EscapePass {\n }\n \n impl<'a, 'tcx: 'a> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n-    fn consume(&mut self,\n-               _: NodeId,\n-               _: Span,\n-               cmt: cmt<'tcx>,\n-               mode: ConsumeMode) {\n+    fn consume(&mut self, _: NodeId, _: Span, cmt: cmt<'tcx>, mode: ConsumeMode) {\n \n         if let Categorization::Local(lid) = cmt.cat {\n             if self.set.contains(&lid) {\n@@ -119,12 +109,7 @@ impl<'a, 'tcx: 'a> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n         }\n \n     }\n-    fn borrow(&mut self,\n-              borrow_id: NodeId,\n-              _: Span,\n-              cmt: cmt<'tcx>,\n-              _: ty::Region,\n-              _: ty::BorrowKind,\n+    fn borrow(&mut self, borrow_id: NodeId, _: Span, cmt: cmt<'tcx>, _: ty::Region, _: ty::BorrowKind,\n               loan_cause: LoanCause) {\n \n         if let Categorization::Local(lid) = cmt.cat {\n@@ -145,9 +130,15 @@ impl<'a, 'tcx: 'a> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n                     }\n                 } else if LoanCause::AddrOf == loan_cause {\n                     // &x\n-                    if let Some(&AutoAdjustment::AdjustDerefRef(adj)) =\n-                           self.cx.tcx.tables.borrow().adjustments\n-                               .get(&self.cx.tcx.map.get_parent_node(borrow_id)) {\n+                    if let Some(&AutoAdjustment::AdjustDerefRef(adj)) = self.cx\n+                                                                            .tcx\n+                                                                            .tables\n+                                                                            .borrow()\n+                                                                            .adjustments\n+                                                                            .get(&self.cx\n+                                                                                      .tcx\n+                                                                                      .map\n+                                                                                      .get_parent_node(borrow_id)) {\n                         if adj.autoderefs <= 1 {\n                             // foo(&x) where no extra autoreffing is happening\n                             self.set.remove(&lid);\n@@ -162,10 +153,5 @@ impl<'a, 'tcx: 'a> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n         }\n     }\n     fn decl_without_init(&mut self, _: NodeId, _: Span) {}\n-    fn mutate(&mut self,\n-              _: NodeId,\n-              _: Span,\n-              _: cmt<'tcx>,\n-              _: MutateMode) {\n-    }\n+    fn mutate(&mut self, _: NodeId, _: Span, _: cmt<'tcx>, _: MutateMode) {}\n }"}, {"sha": "46c458c6bcb6ec6b07b35e08613076ef67f4c7aa", "filename": "src/eta_reduction.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feta_reduction.rs?ref=c9342d01213ca1663d2cdf23289bae024823ae6a", "patch": "@@ -73,22 +73,18 @@ fn check_closure(cx: &LateContext, expr: &Expr) {\n                             }\n                             if p.segments[0].identifier != ident.node {\n                                 // The two idents should be the same\n-                                return\n+                                return;\n                             }\n                         } else {\n-                            return\n+                            return;\n                         }\n                     } else {\n-                        return\n+                        return;\n                     }\n                 }\n-                span_lint_and_then(cx, REDUNDANT_CLOSURE, expr.span,\n-                                   \"redundant closure found\",\n-                                   |db| {\n+                span_lint_and_then(cx, REDUNDANT_CLOSURE, expr.span, \"redundant closure found\", |db| {\n                     if let Some(snippet) = snippet_opt(cx, caller.span) {\n-                        db.span_suggestion(expr.span,\n-                                                  \"remove closure as shown:\",\n-                                                  snippet);\n+                        db.span_suggestion(expr.span, \"remove closure as shown:\", snippet);\n                     }\n                 });\n             }"}, {"sha": "fd5071d40130ddf8008dd1088fc46bb50195f8c6", "filename": "src/identity_op.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fidentity_op.rs?ref=c9342d01213ca1663d2cdf23289bae024823ae6a", "patch": "@@ -27,26 +27,26 @@ impl LintPass for IdentityOp {\n \n impl LateLintPass for IdentityOp {\n     fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n-        if in_macro(cx, e.span) { return; }\n+        if in_macro(cx, e.span) {\n+            return;\n+        }\n         if let ExprBinary(ref cmp, ref left, ref right) = e.node {\n             match cmp.node {\n                 BiAdd | BiBitOr | BiBitXor => {\n                     check(cx, left, 0, e.span, right.span);\n                     check(cx, right, 0, e.span, left.span);\n                 }\n-                BiShl | BiShr | BiSub =>\n-                    check(cx, right, 0, e.span, left.span),\n+                BiShl | BiShr | BiSub => check(cx, right, 0, e.span, left.span),\n                 BiMul => {\n                     check(cx, left, 1, e.span, right.span);\n                     check(cx, right, 1, e.span, left.span);\n                 }\n-                BiDiv =>\n-                    check(cx, right, 1, e.span, left.span),\n+                BiDiv => check(cx, right, 1, e.span, left.span),\n                 BiBitAnd => {\n                     check(cx, left, -1, e.span, right.span);\n                     check(cx, right, -1, e.span, left.span);\n                 }\n-                _ => ()\n+                _ => (),\n             }\n         }\n     }\n@@ -61,9 +61,11 @@ fn check(cx: &LateContext, e: &Expr, m: i8, span: Span, arg: Span) {\n             1 => !is_negative(ty) && v == 1,\n             _ => unreachable!(),\n         } {\n-            span_lint(cx, IDENTITY_OP, span, &format!(\n-                \"the operation is ineffective. Consider reducing it to `{}`\",\n-               snippet(cx, arg, \"..\")));\n+            span_lint(cx,\n+                      IDENTITY_OP,\n+                      span,\n+                      &format!(\"the operation is ineffective. Consider reducing it to `{}`\",\n+                               snippet(cx, arg, \"..\")));\n         }\n     }\n }"}, {"sha": "6bc5bc4bf014e1427286c3145255b8ed0a0c42e7", "filename": "src/len_zero.rs", "status": "modified", "additions": 76, "deletions": 52, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flen_zero.rs?ref=c9342d01213ca1663d2cdf23289bae024823ae6a", "patch": "@@ -49,59 +49,71 @@ impl LintPass for LenZero {\n impl LateLintPass for LenZero {\n     fn check_item(&mut self, cx: &LateContext, item: &Item) {\n         match item.node {\n-            ItemTrait(_, _, _, ref trait_items) =>\n-                check_trait_items(cx, item, trait_items),\n-            ItemImpl(_, _, _, None, _, ref impl_items) => // only non-trait\n-                check_impl_items(cx, item, impl_items),\n-            _ => ()\n+            ItemTrait(_, _, _, ref trait_items) => check_trait_items(cx, item, trait_items),\n+            ItemImpl(_, _, _, None, _, ref impl_items) => check_impl_items(cx, item, impl_items),\n+            _ => (),\n         }\n     }\n \n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n-        if let ExprBinary(Spanned{node: cmp, ..}, ref left, ref right) =\n-                expr.node {\n+        if let ExprBinary(Spanned{node: cmp, ..}, ref left, ref right) = expr.node {\n             match cmp {\n                 BiEq => check_cmp(cx, expr.span, left, right, \"\"),\n                 BiGt | BiNe => check_cmp(cx, expr.span, left, right, \"!\"),\n-                _ => ()\n+                _ => (),\n             }\n         }\n     }\n }\n \n fn check_trait_items(cx: &LateContext, item: &Item, trait_items: &[TraitItem]) {\n     fn is_named_self(item: &TraitItem, name: &str) -> bool {\n-        item.name.as_str() == name && if let MethodTraitItem(ref sig, _) =\n-            item.node { is_self_sig(sig) } else { false }\n+        item.name.as_str() == name &&\n+        if let MethodTraitItem(ref sig, _) = item.node {\n+            is_self_sig(sig)\n+        } else {\n+            false\n+        }\n     }\n \n     if !trait_items.iter().any(|i| is_named_self(i, \"is_empty\")) {\n-        //span_lint(cx, LEN_WITHOUT_IS_EMPTY, item.span, &format!(\"trait {}\", item.ident));\n+        // span_lint(cx, LEN_WITHOUT_IS_EMPTY, item.span, &format!(\"trait {}\", item.ident));\n         for i in trait_items {\n             if is_named_self(i, \"len\") {\n-                span_lint(cx, LEN_WITHOUT_IS_EMPTY, i.span,\n-                          &format!(\"trait `{}` has a `.len(_: &Self)` method, but no \\\n-                                    `.is_empty(_: &Self)` method. Consider adding one\",\n+                span_lint(cx,\n+                          LEN_WITHOUT_IS_EMPTY,\n+                          i.span,\n+                          &format!(\"trait `{}` has a `.len(_: &Self)` method, but no `.is_empty(_: &Self)` method. \\\n+                                    Consider adding one\",\n                                    item.name));\n             }\n-        };\n+        }\n     }\n }\n \n fn check_impl_items(cx: &LateContext, item: &Item, impl_items: &[ImplItem]) {\n     fn is_named_self(item: &ImplItem, name: &str) -> bool {\n-        item.name.as_str() == name && if let ImplItemKind::Method(ref sig, _) =\n-            item.node { is_self_sig(sig) } else { false }\n+        item.name.as_str() == name &&\n+        if let ImplItemKind::Method(ref sig, _) = item.node {\n+            is_self_sig(sig)\n+        } else {\n+            false\n+        }\n     }\n \n     if !impl_items.iter().any(|i| is_named_self(i, \"is_empty\")) {\n         for i in impl_items {\n             if is_named_self(i, \"len\") {\n                 let s = i.span;\n-                span_lint(cx, LEN_WITHOUT_IS_EMPTY,\n-                          Span{ lo: s.lo, hi: s.lo, expn_id: s.expn_id },\n-                          &format!(\"item `{}` has a `.len(_: &Self)` method, but no \\\n-                                    `.is_empty(_: &Self)` method. Consider adding one\",\n+                span_lint(cx,\n+                          LEN_WITHOUT_IS_EMPTY,\n+                          Span {\n+                              lo: s.lo,\n+                              hi: s.lo,\n+                              expn_id: s.expn_id,\n+                          },\n+                          &format!(\"item `{}` has a `.len(_: &Self)` method, but no `.is_empty(_: &Self)` method. \\\n+                                    Consider adding one\",\n                                    item.name));\n                 return;\n             }\n@@ -111,32 +123,40 @@ fn check_impl_items(cx: &LateContext, item: &Item, impl_items: &[ImplItem]) {\n \n fn is_self_sig(sig: &MethodSig) -> bool {\n     if let SelfStatic = sig.explicit_self.node {\n-        false } else { sig.decl.inputs.len() == 1 }\n+        false\n+    } else {\n+        sig.decl.inputs.len() == 1\n+    }\n }\n \n fn check_cmp(cx: &LateContext, span: Span, left: &Expr, right: &Expr, op: &str) {\n     // check if we are in an is_empty() method\n     if let Some(name) = get_item_name(cx, left) {\n-        if name.as_str() == \"is_empty\" { return; }\n+        if name.as_str() == \"is_empty\" {\n+            return;\n+        }\n     }\n     match (&left.node, &right.node) {\n-        (&ExprLit(ref lit), &ExprMethodCall(ref method, _, ref args)) =>\n-            check_len_zero(cx, span, &method.node, args, lit, op),\n-        (&ExprMethodCall(ref method, _, ref args), &ExprLit(ref lit)) =>\n-            check_len_zero(cx, span, &method.node, args, lit, op),\n-        _ => ()\n+        (&ExprLit(ref lit), &ExprMethodCall(ref method, _, ref args)) => {\n+            check_len_zero(cx, span, &method.node, args, lit, op)\n+        }\n+        (&ExprMethodCall(ref method, _, ref args), &ExprLit(ref lit)) => {\n+            check_len_zero(cx, span, &method.node, args, lit, op)\n+        }\n+        _ => (),\n     }\n }\n \n-fn check_len_zero(cx: &LateContext, span: Span, name: &Name,\n-                  args: &[P<Expr>], lit: &Lit, op: &str) {\n+fn check_len_zero(cx: &LateContext, span: Span, name: &Name, args: &[P<Expr>], lit: &Lit, op: &str) {\n     if let Spanned{node: LitInt(0, _), ..} = *lit {\n-        if name.as_str() == \"len\" && args.len() == 1 &&\n-            has_is_empty(cx, &args[0]) {\n-                span_lint(cx, LEN_ZERO, span, &format!(\n-                    \"consider replacing the len comparison with `{}{}.is_empty()`\",\n-                    op, snippet(cx, args[0].span, \"_\")));\n-            }\n+        if name.as_str() == \"len\" && args.len() == 1 && has_is_empty(cx, &args[0]) {\n+            span_lint(cx,\n+                      LEN_ZERO,\n+                      span,\n+                      &format!(\"consider replacing the len comparison with `{}{}.is_empty()`\",\n+                               op,\n+                               snippet(cx, args[0].span, \"_\")));\n+        }\n     }\n }\n \n@@ -145,31 +165,35 @@ fn has_is_empty(cx: &LateContext, expr: &Expr) -> bool {\n     /// get a ImplOrTraitItem and return true if it matches is_empty(self)\n     fn is_is_empty(cx: &LateContext, id: &ImplOrTraitItemId) -> bool {\n         if let MethodTraitItemId(def_id) = *id {\n-            if let ty::MethodTraitItem(ref method) =\n-                cx.tcx.impl_or_trait_item(def_id) {\n-                    method.name.as_str() == \"is_empty\"\n-                        && method.fty.sig.skip_binder().inputs.len() == 1\n-                } else { false }\n-        } else { false }\n+            if let ty::MethodTraitItem(ref method) = cx.tcx.impl_or_trait_item(def_id) {\n+                method.name.as_str() == \"is_empty\" && method.fty.sig.skip_binder().inputs.len() == 1\n+            } else {\n+                false\n+            }\n+        } else {\n+            false\n+        }\n     }\n \n     /// check the inherent impl's items for an is_empty(self) method\n     fn has_is_empty_impl(cx: &LateContext, id: &DefId) -> bool {\n         let impl_items = cx.tcx.impl_items.borrow();\n-        cx.tcx.inherent_impls.borrow().get(id).map_or(false,\n-            |ids| ids.iter().any(|iid| impl_items.get(iid).map_or(false,\n-                |iids| iids.iter().any(|i| is_is_empty(cx, i)))))\n+        cx.tcx.inherent_impls.borrow().get(id).map_or(false, |ids| {\n+            ids.iter().any(|iid| impl_items.get(iid).map_or(false, |iids| iids.iter().any(|i| is_is_empty(cx, i))))\n+        })\n     }\n \n     let ty = &walk_ptrs_ty(&cx.tcx.expr_ty(expr));\n     match ty.sty {\n-        ty::TyTrait(_) => cx.tcx.trait_item_def_ids.borrow().get(\n-            &ty.ty_to_def_id().expect(\"trait impl not found\")).map_or(false,\n-                |ids| ids.iter().any(|i| is_is_empty(cx, i))),\n-        ty::TyProjection(_) => ty.ty_to_def_id().map_or(false,\n-            |id| has_is_empty_impl(cx, &id)),\n-        ty::TyEnum(ref id, _) | ty::TyStruct(ref id, _) =>\n-            has_is_empty_impl(cx, &id.did),\n+        ty::TyTrait(_) => {\n+            cx.tcx\n+              .trait_item_def_ids\n+              .borrow()\n+              .get(&ty.ty_to_def_id().expect(\"trait impl not found\"))\n+              .map_or(false, |ids| ids.iter().any(|i| is_is_empty(cx, i)))\n+        }\n+        ty::TyProjection(_) => ty.ty_to_def_id().map_or(false, |id| has_is_empty_impl(cx, &id)),\n+        ty::TyEnum(ref id, _) | ty::TyStruct(ref id, _) => has_is_empty_impl(cx, &id.did),\n         ty::TyArray(..) => true,\n         _ => false,\n     }"}, {"sha": "2ac8e9044db85961f81b09dc6b8500c82d65479c", "filename": "src/lib.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=c9342d01213ca1663d2cdf23289bae024823ae6a", "patch": "@@ -5,7 +5,9 @@\n \n // this only exists to allow the \"dogfood\" integration test to work\n #[allow(dead_code)]\n-fn main() { println!(\"What are you doing? Don't run clippy as an executable\"); }\n+fn main() {\n+    println!(\"What are you doing? Don't run clippy as an executable\");\n+}\n \n #[macro_use]\n extern crate syntax;\n@@ -128,7 +130,8 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_late_lint_pass(box array_indexing::ArrayIndexing);\n     reg.register_late_lint_pass(box panic::PanicPass);\n \n-    reg.register_lint_group(\"clippy_pedantic\", vec![\n+    reg.register_lint_group(\"clippy_pedantic\",\n+                            vec![\n         methods::OPTION_UNWRAP_USED,\n         methods::RESULT_UNWRAP_USED,\n         methods::WRONG_PUB_SELF_CONVENTION,\n@@ -147,7 +150,8 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         unicode::UNICODE_NOT_NFC,\n     ]);\n \n-    reg.register_lint_group(\"clippy\", vec![\n+    reg.register_lint_group(\"clippy\",\n+                            vec![\n         approx_const::APPROX_CONSTANT,\n         array_indexing::OUT_OF_BOUNDS_INDEXING,\n         attrs::INLINE_ALWAYS,"}, {"sha": "2de916cfebc4e7b1146ff33b62aafb41dfe32477", "filename": "src/lifetimes.rs", "status": "modified", "additions": 28, "deletions": 26, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flifetimes.rs?ref=c9342d01213ca1663d2cdf23289bae024823ae6a", "patch": "@@ -47,15 +47,13 @@ impl LateLintPass for LifetimePass {\n \n     fn check_impl_item(&mut self, cx: &LateContext, item: &ImplItem) {\n         if let ImplItemKind::Method(ref sig, _) = item.node {\n-            check_fn_inner(cx, &sig.decl, Some(&sig.explicit_self),\n-                           &sig.generics, item.span);\n+            check_fn_inner(cx, &sig.decl, Some(&sig.explicit_self), &sig.generics, item.span);\n         }\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext, item: &TraitItem) {\n         if let MethodTraitItem(ref sig, _) = item.node {\n-            check_fn_inner(cx, &sig.decl, Some(&sig.explicit_self),\n-                           &sig.generics, item.span);\n+            check_fn_inner(cx, &sig.decl, Some(&sig.explicit_self), &sig.generics, item.span);\n         }\n     }\n }\n@@ -69,20 +67,20 @@ enum RefLt {\n }\n use self::RefLt::*;\n \n-fn check_fn_inner(cx: &LateContext, decl: &FnDecl, slf: Option<&ExplicitSelf>,\n-                  generics: &Generics, span: Span) {\n+fn check_fn_inner(cx: &LateContext, decl: &FnDecl, slf: Option<&ExplicitSelf>, generics: &Generics, span: Span) {\n     if in_external_macro(cx, span) || has_where_lifetimes(cx, &generics.where_clause) {\n         return;\n     }\n     if could_use_elision(cx, decl, slf, &generics.lifetimes) {\n-        span_lint(cx, NEEDLESS_LIFETIMES, span,\n+        span_lint(cx,\n+                  NEEDLESS_LIFETIMES,\n+                  span,\n                   \"explicit lifetimes given in parameter types where they could be elided\");\n     }\n     report_extra_lifetimes(cx, decl, &generics);\n }\n \n-fn could_use_elision(cx: &LateContext, func: &FnDecl, slf: Option<&ExplicitSelf>,\n-                     named_lts: &[LifetimeDef]) -> bool {\n+fn could_use_elision(cx: &LateContext, func: &FnDecl, slf: Option<&ExplicitSelf>, named_lts: &[LifetimeDef]) -> bool {\n     // There are two scenarios where elision works:\n     // * no output references, all input references have different LT\n     // * output references, exactly one input reference with same LT\n@@ -102,7 +100,7 @@ fn could_use_elision(cx: &LateContext, func: &FnDecl, slf: Option<&ExplicitSelf>\n         match slf.node {\n             SelfRegion(ref opt_lt, _, _) => input_visitor.record(opt_lt),\n             SelfExplicit(ref ty, _) => walk_ty(&mut input_visitor, ty),\n-            _ => { }\n+            _ => {}\n         }\n     }\n     // extract lifetimes in input argument types\n@@ -147,8 +145,8 @@ fn could_use_elision(cx: &LateContext, func: &FnDecl, slf: Option<&ExplicitSelf>\n                 (&Named(n1), &Named(n2)) if n1 == n2 => true,\n                 (&Named(_), &Unnamed) => true,\n                 (&Unnamed, &Named(_)) => true,\n-                _ => false // already elided, different named lifetimes\n-                           // or something static going on\n+                _ => false, // already elided, different named lifetimes\n+                // or something static going on\n             }\n         } else {\n             false\n@@ -176,12 +174,15 @@ fn unique_lifetimes(lts: &[RefLt]) -> usize {\n /// A visitor usable for rustc_front::visit::walk_ty().\n struct RefVisitor<'v, 't: 'v> {\n     cx: &'v LateContext<'v, 't>, // context reference\n-    lts: Vec<RefLt>\n+    lts: Vec<RefLt>,\n }\n \n-impl <'v, 't> RefVisitor<'v, 't>  {\n+impl<'v, 't> RefVisitor<'v, 't> {\n     fn new(cx: &'v LateContext<'v, 't>) -> RefVisitor<'v, 't> {\n-        RefVisitor { cx: cx, lts: Vec::new() }\n+        RefVisitor {\n+            cx: cx,\n+            lts: Vec::new(),\n+        }\n     }\n \n     fn record(&mut self, lifetime: &Option<Lifetime>) {\n@@ -211,13 +212,13 @@ impl <'v, 't> RefVisitor<'v, 't>  {\n                             for _ in type_scheme.generics.regions.as_slice() {\n                                 self.record(&None);\n                             }\n-                        },\n+                        }\n                         DefTrait(def_id) => {\n                             let trait_def = self.cx.tcx.trait_defs.borrow()[&def_id];\n                             for _ in &trait_def.generics.regions {\n                                 self.record(&None);\n                             }\n-                        },\n+                        }\n                         _ => {}\n                     }\n                 }\n@@ -227,7 +228,6 @@ impl <'v, 't> RefVisitor<'v, 't>  {\n }\n \n impl<'v, 't> Visitor<'v> for RefVisitor<'v, 't> {\n-\n     // for lifetimes as parameters of generics\n     fn visit_lifetime(&mut self, lifetime: &'v Lifetime) {\n         self.record(&Some(*lifetime));\n@@ -258,7 +258,9 @@ fn has_where_lifetimes(cx: &LateContext, where_clause: &WhereClause) -> bool {\n                 let mut visitor = RefVisitor::new(cx);\n                 // walk the type F, it may not contain LT refs\n                 walk_ty(&mut visitor, &pred.bounded_ty);\n-                if !visitor.lts.is_empty() { return true; }\n+                if !visitor.lts.is_empty() {\n+                    return true;\n+                }\n                 // if the bounds define new lifetimes, they are fine to occur\n                 let allowed_lts = allowed_lts_from(&pred.bound_lifetimes);\n                 // now walk the bounds\n@@ -275,7 +277,9 @@ fn has_where_lifetimes(cx: &LateContext, where_clause: &WhereClause) -> bool {\n             WherePredicate::EqPredicate(ref pred) => {\n                 let mut visitor = RefVisitor::new(cx);\n                 walk_ty(&mut visitor, &pred.ty);\n-                if !visitor.lts.is_empty() { return true; }\n+                if !visitor.lts.is_empty() {\n+                    return true;\n+                }\n             }\n         }\n     }\n@@ -285,7 +289,6 @@ fn has_where_lifetimes(cx: &LateContext, where_clause: &WhereClause) -> bool {\n struct LifetimeChecker(HashMap<Name, Span>);\n \n impl<'v> Visitor<'v> for LifetimeChecker {\n-\n     // for lifetimes as parameters of generics\n     fn visit_lifetime(&mut self, lifetime: &'v Lifetime) {\n         self.0.remove(&lifetime.name);\n@@ -300,16 +303,15 @@ impl<'v> Visitor<'v> for LifetimeChecker {\n     }\n }\n \n-fn report_extra_lifetimes(cx: &LateContext, func: &FnDecl,\n-                          generics: &Generics) {\n-    let hs = generics.lifetimes.iter()\n+fn report_extra_lifetimes(cx: &LateContext, func: &FnDecl, generics: &Generics) {\n+    let hs = generics.lifetimes\n+                     .iter()\n                      .map(|lt| (lt.lifetime.name, lt.lifetime.span))\n                      .collect();\n     let mut checker = LifetimeChecker(hs);\n     walk_generics(&mut checker, generics);\n     walk_fn_decl(&mut checker, func);\n     for (_, v) in checker.0 {\n-        span_lint(cx, UNUSED_LIFETIMES, v,\n-                  \"this lifetime isn't used in the function definition\");\n+        span_lint(cx, UNUSED_LIFETIMES, v, \"this lifetime isn't used in the function definition\");\n     }\n }"}, {"sha": "91bb898629f955de83ad685a5f094025ca871422", "filename": "src/loops.rs", "status": "modified", "additions": 212, "deletions": 162, "changes": 374, "blob_url": "https://github.com/rust-lang/rust/blob/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Floops.rs?ref=c9342d01213ca1663d2cdf23289bae024823ae6a", "patch": "@@ -5,14 +5,13 @@ use rustc_front::intravisit::{Visitor, walk_expr, walk_block, walk_decl};\n use rustc::middle::ty;\n use rustc::middle::def::DefLocal;\n use consts::{constant_simple, Constant};\n-use rustc::front::map::Node::{NodeBlock};\n+use rustc::front::map::Node::NodeBlock;\n use std::borrow::Cow;\n-use std::collections::{HashSet,HashMap};\n+use std::collections::{HashSet, HashMap};\n use syntax::ast::Lit_::*;\n \n-use utils::{snippet, span_lint, get_parent_expr, match_trait_method, match_type,\n-            in_external_macro, expr_block, span_help_and_lint, is_integer_literal,\n-            get_enclosing_block};\n+use utils::{snippet, span_lint, get_parent_expr, match_trait_method, match_type, in_external_macro, expr_block,\n+            span_help_and_lint, is_integer_literal, get_enclosing_block};\n use utils::{HASHMAP_PATH, VEC_PATH, LL_PATH};\n \n /// **What it does:** This lint checks for looping over the range of `0..len` of some collection just to get the values by index. It is `Warn` by default.\n@@ -128,9 +127,14 @@ pub struct LoopsPass;\n \n impl LintPass for LoopsPass {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(NEEDLESS_RANGE_LOOP, EXPLICIT_ITER_LOOP, ITER_NEXT_LOOP,\n-                    WHILE_LET_LOOP, UNUSED_COLLECT, REVERSE_RANGE_LOOP,\n-                    EXPLICIT_COUNTER_LOOP, EMPTY_LOOP,\n+        lint_array!(NEEDLESS_RANGE_LOOP,\n+                    EXPLICIT_ITER_LOOP,\n+                    ITER_NEXT_LOOP,\n+                    WHILE_LET_LOOP,\n+                    UNUSED_COLLECT,\n+                    REVERSE_RANGE_LOOP,\n+                    EXPLICIT_COUNTER_LOOP,\n+                    EMPTY_LOOP,\n                     WHILE_LET_ON_ITERATOR)\n     }\n }\n@@ -146,10 +150,11 @@ impl LateLintPass for LoopsPass {\n         if let ExprLoop(ref block, _) = expr.node {\n             // also check for empty `loop {}` statements\n             if block.stmts.is_empty() && block.expr.is_none() {\n-                span_lint(cx, EMPTY_LOOP, expr.span,\n-                          \"empty `loop {}` detected. You may want to either \\\n-                           use `panic!()` or add `std::thread::sleep(..);` to \\\n-                           the loop body.\");\n+                span_lint(cx,\n+                          EMPTY_LOOP,\n+                          expr.span,\n+                          \"empty `loop {}` detected. You may want to either use `panic!()` or add \\\n+                           `std::thread::sleep(..);` to the loop body.\");\n             }\n \n             // extract the expression from the first statement (if any) in a block\n@@ -159,11 +164,10 @@ impl LateLintPass for LoopsPass {\n                 if let ExprMatch(ref matchexpr, ref arms, ref source) = inner.node {\n                     // collect the remaining statements below the match\n                     let mut other_stuff = block.stmts\n-                                  .iter()\n-                                  .skip(1)\n-                                  .map(|stmt| {\n-                                      format!(\"{}\", snippet(cx, stmt.span, \"..\"))\n-                                  }).collect::<Vec<String>>();\n+                                               .iter()\n+                                               .skip(1)\n+                                               .map(|stmt| format!(\"{}\", snippet(cx, stmt.span, \"..\")))\n+                                               .collect::<Vec<String>>();\n                     if inner_stmt_expr.is_some() {\n                         // if we have a statement which has a match,\n                         if let Some(ref expr) = block.expr {\n@@ -174,51 +178,52 @@ impl LateLintPass for LoopsPass {\n \n                     // ensure \"if let\" compatible match structure\n                     match *source {\n-                        MatchSource::Normal | MatchSource::IfLetDesugar{..} => if\n-                            arms.len() == 2 &&\n-                            arms[0].pats.len() == 1 && arms[0].guard.is_none() &&\n-                            arms[1].pats.len() == 1 && arms[1].guard.is_none() &&\n-                            // finally, check for \"break\" in the second clause\n-                            is_break_expr(&arms[1].body)\n-                        {\n-                            if in_external_macro(cx, expr.span) { return; }\n-                            let loop_body = if inner_stmt_expr.is_some() {\n-                                // FIXME: should probably be an ellipsis\n-                                // tabbing and newline is probably a bad idea, especially for large blocks\n-                                Cow::Owned(format!(\"{{\\n    {}\\n}}\", other_stuff.join(\"\\n    \")))\n-                            } else {\n-                                expr_block(cx, &arms[0].body, Some(other_stuff.join(\"\\n    \")), \"..\")\n-                            };\n-                            span_help_and_lint(cx, WHILE_LET_LOOP, expr.span,\n-                                               \"this loop could be written as a `while let` loop\",\n-                                               &format!(\"try\\nwhile let {} = {} {}\",\n-                                                        snippet(cx, arms[0].pats[0].span, \"..\"),\n-                                                        snippet(cx, matchexpr.span, \"..\"),\n-                                                        loop_body));\n-                        },\n-                        _ => ()\n+                        MatchSource::Normal | MatchSource::IfLetDesugar{..} => {\n+                            if arms.len() == 2 && arms[0].pats.len() == 1 && arms[0].guard.is_none() &&\n+                               arms[1].pats.len() == 1 && arms[1].guard.is_none() &&\n+                               is_break_expr(&arms[1].body) {\n+                                if in_external_macro(cx, expr.span) {\n+                                    return;\n+                                }\n+                                let loop_body = if inner_stmt_expr.is_some() {\n+                                    // FIXME: should probably be an ellipsis\n+                                    // tabbing and newline is probably a bad idea, especially for large blocks\n+                                    Cow::Owned(format!(\"{{\\n    {}\\n}}\", other_stuff.join(\"\\n    \")))\n+                                } else {\n+                                    expr_block(cx, &arms[0].body, Some(other_stuff.join(\"\\n    \")), \"..\")\n+                                };\n+                                span_help_and_lint(cx,\n+                                                   WHILE_LET_LOOP,\n+                                                   expr.span,\n+                                                   \"this loop could be written as a `while let` loop\",\n+                                                   &format!(\"try\\nwhile let {} = {} {}\",\n+                                                            snippet(cx, arms[0].pats[0].span, \"..\"),\n+                                                            snippet(cx, matchexpr.span, \"..\"),\n+                                                            loop_body));\n+                            }\n+                        }\n+                        _ => (),\n                     }\n                 }\n             }\n         }\n         if let ExprMatch(ref match_expr, ref arms, MatchSource::WhileLetDesugar) = expr.node {\n             let pat = &arms[0].pats[0].node;\n             if let (&PatEnum(ref path, Some(ref pat_args)),\n-                    &ExprMethodCall(method_name, _, ref method_args)) =\n-                        (pat, &match_expr.node) {\n+                    &ExprMethodCall(method_name, _, ref method_args)) = (pat, &match_expr.node) {\n                 let iter_expr = &method_args[0];\n                 if let Some(lhs_constructor) = path.segments.last() {\n                     if method_name.node.as_str() == \"next\" &&\n-                            match_trait_method(cx, match_expr, &[\"core\", \"iter\", \"Iterator\"]) &&\n-                            lhs_constructor.identifier.name.as_str() == \"Some\" &&\n-                            !is_iterator_used_after_while_let(cx, iter_expr) {\n+                       match_trait_method(cx, match_expr, &[\"core\", \"iter\", \"Iterator\"]) &&\n+                       lhs_constructor.identifier.name.as_str() == \"Some\" &&\n+                       !is_iterator_used_after_while_let(cx, iter_expr) {\n                         let iterator = snippet(cx, method_args[0].span, \"_\");\n                         let loop_var = snippet(cx, pat_args[0].span, \"_\");\n-                        span_help_and_lint(cx, WHILE_LET_ON_ITERATOR, expr.span,\n+                        span_help_and_lint(cx,\n+                                           WHILE_LET_ON_ITERATOR,\n+                                           expr.span,\n                                            \"this loop could be written as a `for` loop\",\n-                                           &format!(\"try\\nfor {} in {} {{...}}\",\n-                                                    loop_var,\n-                                                    iterator));\n+                                           &format!(\"try\\nfor {} in {} {{...}}\", loop_var, iterator));\n                     }\n                 }\n             }\n@@ -229,10 +234,12 @@ impl LateLintPass for LoopsPass {\n         if let StmtSemi(ref expr, _) = stmt.node {\n             if let ExprMethodCall(ref method, _, ref args) = expr.node {\n                 if args.len() == 1 && method.node.as_str() == \"collect\" &&\n-                        match_trait_method(cx, expr, &[\"core\", \"iter\", \"Iterator\"]) {\n-                    span_lint(cx, UNUSED_COLLECT, expr.span, &format!(\n-                        \"you are collect()ing an iterator and throwing away the result. \\\n-                         Consider using an explicit for loop to exhaust the iterator\"));\n+                   match_trait_method(cx, expr, &[\"core\", \"iter\", \"Iterator\"]) {\n+                    span_lint(cx,\n+                              UNUSED_COLLECT,\n+                              expr.span,\n+                              &format!(\"you are collect()ing an iterator and throwing away the result. Consider \\\n+                                        using an explicit for loop to exhaust the iterator\"));\n                 }\n             }\n         }\n@@ -249,23 +256,38 @@ fn check_for_loop(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Expr, expr: &E\n \n                 // the var must be a single name\n                 if let PatIdent(_, ref ident, _) = pat.node {\n-                    let mut visitor = VarVisitor { cx: cx, var: ident.node.name,\n-                                                   indexed: HashSet::new(), nonindex: false };\n+                    let mut visitor = VarVisitor {\n+                        cx: cx,\n+                        var: ident.node.name,\n+                        indexed: HashSet::new(),\n+                        nonindex: false,\n+                    };\n                     walk_expr(&mut visitor, body);\n                     // linting condition: we only indexed one variable\n                     if visitor.indexed.len() == 1 {\n-                        let indexed = visitor.indexed.into_iter().next().expect(\n-                            \"Len was nonzero, but no contents found\");\n+                        let indexed = visitor.indexed\n+                                             .into_iter()\n+                                             .next()\n+                                             .expect(\"Len was nonzero, but no contents found\");\n                         if visitor.nonindex {\n-                            span_lint(cx, NEEDLESS_RANGE_LOOP, expr.span, &format!(\n-                                \"the loop variable `{}` is used to index `{}`. Consider using \\\n-                                 `for ({}, item) in {}.iter().enumerate()` or similar iterators\",\n-                                ident.node.name, indexed, ident.node.name, indexed));\n+                            span_lint(cx,\n+                                      NEEDLESS_RANGE_LOOP,\n+                                      expr.span,\n+                                      &format!(\"the loop variable `{}` is used to index `{}`. Consider using `for \\\n+                                                ({}, item) in {}.iter().enumerate()` or similar iterators\",\n+                                               ident.node.name,\n+                                               indexed,\n+                                               ident.node.name,\n+                                               indexed));\n                         } else {\n-                            span_lint(cx, NEEDLESS_RANGE_LOOP, expr.span, &format!(\n-                                \"the loop variable `{}` is only used to index `{}`. \\\n-                                 Consider using `for item in &{}` or similar iterators\",\n-                                ident.node.name, indexed, indexed));\n+                            span_lint(cx,\n+                                      NEEDLESS_RANGE_LOOP,\n+                                      expr.span,\n+                                      &format!(\"the loop variable `{}` is only used to index `{}`. Consider using \\\n+                                                `for item in &{}` or similar iterators\",\n+                                               ident.node.name,\n+                                               indexed,\n+                                               indexed));\n                         }\n                     }\n                 }\n@@ -283,15 +305,21 @@ fn check_for_loop(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Expr, expr: &E\n                 // who think that this will iterate from the larger value to the\n                 // smaller value.\n                 if start_idx > stop_idx {\n-                    span_help_and_lint(cx, REVERSE_RANGE_LOOP, expr.span,\n-                        \"this range is empty so this for loop will never run\",\n-                        &format!(\"Consider using `({}..{}).rev()` if you are attempting to \\\n-                        iterate over this range in reverse\", stop_idx, start_idx));\n+                    span_help_and_lint(cx,\n+                                       REVERSE_RANGE_LOOP,\n+                                       expr.span,\n+                                       \"this range is empty so this for loop will never run\",\n+                                       &format!(\"Consider using `({}..{}).rev()` if you are attempting to iterate \\\n+                                                 over this range in reverse\",\n+                                                stop_idx,\n+                                                start_idx));\n                 } else if start_idx == stop_idx {\n                     // if they are equal, it's also problematic - this loop\n                     // will never run.\n-                    span_lint(cx, REVERSE_RANGE_LOOP, expr.span,\n-                        \"this range is empty so this for loop will never run\");\n+                    span_lint(cx,\n+                              REVERSE_RANGE_LOOP,\n+                              expr.span,\n+                              \"this range is empty so this for loop will never run\");\n                 }\n             }\n         }\n@@ -305,46 +333,65 @@ fn check_for_loop(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Expr, expr: &E\n             if method_name.as_str() == \"iter\" || method_name.as_str() == \"iter_mut\" {\n                 if is_ref_iterable_type(cx, &args[0]) {\n                     let object = snippet(cx, args[0].span, \"_\");\n-                    span_lint(cx, EXPLICIT_ITER_LOOP, expr.span, &format!(\n-                        \"it is more idiomatic to loop over `&{}{}` instead of `{}.{}()`\",\n-                        if method_name.as_str() == \"iter_mut\" { \"mut \" } else { \"\" },\n-                        object, object, method_name));\n+                    span_lint(cx,\n+                              EXPLICIT_ITER_LOOP,\n+                              expr.span,\n+                              &format!(\"it is more idiomatic to loop over `&{}{}` instead of `{}.{}()`\",\n+                                       if method_name.as_str() == \"iter_mut\" {\n+                                           \"mut \"\n+                                       } else {\n+                                           \"\"\n+                                       },\n+                                       object,\n+                                       object,\n+                                       method_name));\n                 }\n-            }\n-            // check for looping over Iterator::next() which is not what you want\n-            else if method_name.as_str() == \"next\" &&\n-                    match_trait_method(cx, arg, &[\"core\", \"iter\", \"Iterator\"]) {\n-                span_lint(cx, ITER_NEXT_LOOP, expr.span,\n-                          \"you are iterating over `Iterator::next()` which is an Option; \\\n-                           this will compile but is probably not what you want\");\n+            } else if method_name.as_str() == \"next\" && match_trait_method(cx, arg, &[\"core\", \"iter\", \"Iterator\"]) {\n+                span_lint(cx,\n+                          ITER_NEXT_LOOP,\n+                          expr.span,\n+                          \"you are iterating over `Iterator::next()` which is an Option; this will compile but is \\\n+                           probably not what you want\");\n             }\n         }\n     }\n \n     // Look for variables that are incremented once per loop iteration.\n-    let mut visitor = IncrementVisitor { cx: cx, states: HashMap::new(), depth: 0, done: false };\n+    let mut visitor = IncrementVisitor {\n+        cx: cx,\n+        states: HashMap::new(),\n+        depth: 0,\n+        done: false,\n+    };\n     walk_expr(&mut visitor, body);\n \n     // For each candidate, check the parent block to see if\n     // it's initialized to zero at the start of the loop.\n     let map = &cx.tcx.map;\n-    let parent_scope = map.get_enclosing_scope(expr.id).and_then(|id| map.get_enclosing_scope(id) );\n+    let parent_scope = map.get_enclosing_scope(expr.id).and_then(|id| map.get_enclosing_scope(id));\n     if let Some(parent_id) = parent_scope {\n         if let NodeBlock(block) = map.get(parent_id) {\n-            for (id, _) in visitor.states.iter().filter( |&(_,v)| *v == VarState::IncrOnce) {\n-                let mut visitor2 = InitializeVisitor { cx: cx, end_expr: expr, var_id: id.clone(),\n-                                                       state: VarState::IncrOnce, name: None,\n-                                                       depth: 0,\n-                                                       past_loop: false };\n+            for (id, _) in visitor.states.iter().filter(|&(_, v)| *v == VarState::IncrOnce) {\n+                let mut visitor2 = InitializeVisitor {\n+                    cx: cx,\n+                    end_expr: expr,\n+                    var_id: id.clone(),\n+                    state: VarState::IncrOnce,\n+                    name: None,\n+                    depth: 0,\n+                    past_loop: false,\n+                };\n                 walk_block(&mut visitor2, block);\n \n                 if visitor2.state == VarState::Warn {\n                     if let Some(name) = visitor2.name {\n-                        span_lint(cx, EXPLICIT_COUNTER_LOOP, expr.span,\n-                                  &format!(\"the variable `{0}` is used as a loop counter. Consider \\\n-                                            using `for ({0}, item) in {1}.enumerate()` \\\n-                                            or similar iterators\",\n-                                           name, snippet(cx, arg.span, \"_\")));\n+                        span_lint(cx,\n+                                  EXPLICIT_COUNTER_LOOP,\n+                                  expr.span,\n+                                  &format!(\"the variable `{0}` is used as a loop counter. Consider using `for ({0}, \\\n+                                            item) in {1}.enumerate()` or similar iterators\",\n+                                           name,\n+                                           snippet(cx, arg.span, \"_\")));\n                     }\n                 }\n             }\n@@ -378,9 +425,9 @@ fn recover_for_loop(expr: &Expr) -> Option<(&Pat, &Expr, &Expr)> {\n \n struct VarVisitor<'v, 't: 'v> {\n     cx: &'v LateContext<'v, 't>, // context reference\n-    var: Name,               // var name to look for as index\n-    indexed: HashSet<Name>,  // indexed variables\n-    nonindex: bool,          // has the var been used otherwise?\n+    var: Name, // var name to look for as index\n+    indexed: HashSet<Name>, // indexed variables\n+    nonindex: bool, // has the var been used otherwise?\n }\n \n impl<'v, 't> Visitor<'v> for VarVisitor<'v, 't> {\n@@ -411,14 +458,14 @@ impl<'v, 't> Visitor<'v> for VarVisitor<'v, 't> {\n fn is_iterator_used_after_while_let(cx: &LateContext, iter_expr: &Expr) -> bool {\n     let def_id = match var_def_id(cx, iter_expr) {\n         Some(id) => id,\n-        None => return false\n+        None => return false,\n     };\n     let mut visitor = VarUsedAfterLoopVisitor {\n         cx: cx,\n         def_id: def_id,\n         iter_expr_id: iter_expr.id,\n         past_while_let: false,\n-        var_used_after_while_let: false\n+        var_used_after_while_let: false,\n     };\n     if let Some(enclosing_block) = get_enclosing_block(cx, def_id) {\n         walk_block(&mut visitor, enclosing_block);\n@@ -431,10 +478,10 @@ struct VarUsedAfterLoopVisitor<'v, 't: 'v> {\n     def_id: NodeId,\n     iter_expr_id: NodeId,\n     past_while_let: bool,\n-    var_used_after_while_let: bool\n+    var_used_after_while_let: bool,\n }\n \n-impl <'v, 't> Visitor<'v> for VarUsedAfterLoopVisitor<'v, 't> {\n+impl<'v, 't> Visitor<'v> for VarUsedAfterLoopVisitor<'v, 't> {\n     fn visit_expr(&mut self, expr: &'v Expr) {\n         if self.past_while_let {\n             if Some(self.def_id) == var_def_id(self.cx, expr) {\n@@ -454,43 +501,52 @@ fn is_ref_iterable_type(cx: &LateContext, e: &Expr) -> bool {\n     // no walk_ptrs_ty: calling iter() on a reference can make sense because it\n     // will allow further borrows afterwards\n     let ty = cx.tcx.expr_ty(e);\n-    is_iterable_array(ty) ||\n-        match_type(cx, ty, &VEC_PATH) ||\n-        match_type(cx, ty, &LL_PATH) ||\n-        match_type(cx, ty, &HASHMAP_PATH) ||\n-        match_type(cx, ty, &[\"std\", \"collections\", \"hash\", \"set\", \"HashSet\"]) ||\n-        match_type(cx, ty, &[\"collections\", \"vec_deque\", \"VecDeque\"]) ||\n-        match_type(cx, ty, &[\"collections\", \"binary_heap\", \"BinaryHeap\"]) ||\n-        match_type(cx, ty, &[\"collections\", \"btree\", \"map\", \"BTreeMap\"]) ||\n-        match_type(cx, ty, &[\"collections\", \"btree\", \"set\", \"BTreeSet\"])\n+    is_iterable_array(ty) || match_type(cx, ty, &VEC_PATH) || match_type(cx, ty, &LL_PATH) ||\n+    match_type(cx, ty, &HASHMAP_PATH) || match_type(cx, ty, &[\"std\", \"collections\", \"hash\", \"set\", \"HashSet\"]) ||\n+    match_type(cx, ty, &[\"collections\", \"vec_deque\", \"VecDeque\"]) ||\n+    match_type(cx, ty, &[\"collections\", \"binary_heap\", \"BinaryHeap\"]) ||\n+    match_type(cx, ty, &[\"collections\", \"btree\", \"map\", \"BTreeMap\"]) ||\n+    match_type(cx, ty, &[\"collections\", \"btree\", \"set\", \"BTreeSet\"])\n }\n \n fn is_iterable_array(ty: ty::Ty) -> bool {\n     // IntoIterator is currently only implemented for array sizes <= 32 in rustc\n     match ty.sty {\n         ty::TyArray(_, 0...32) => true,\n-        _ => false\n+        _ => false,\n     }\n }\n \n /// If a block begins with a statement (possibly a `let` binding) and has an expression, return it.\n fn extract_expr_from_first_stmt(block: &Block) -> Option<&Expr> {\n-    if block.stmts.is_empty() { return None; }\n+    if block.stmts.is_empty() {\n+        return None;\n+    }\n     if let StmtDecl(ref decl, _) = block.stmts[0].node {\n         if let DeclLocal(ref local) = decl.node {\n-            if let Some(ref expr) = local.init { Some(expr) } else { None }\n-        } else { None }\n-    } else { None }\n+            if let Some(ref expr) = local.init {\n+                Some(expr)\n+            } else {\n+                None\n+            }\n+        } else {\n+            None\n+        }\n+    } else {\n+        None\n+    }\n }\n \n /// If a block begins with an expression (with or without semicolon), return it.\n fn extract_first_expr(block: &Block) -> Option<&Expr> {\n     match block.expr {\n         Some(ref expr) => Some(expr),\n-        None if !block.stmts.is_empty() => match block.stmts[0].node {\n-            StmtExpr(ref expr, _) | StmtSemi(ref expr, _) => Some(expr),\n-            _ => None,\n-        },\n+        None if !block.stmts.is_empty() => {\n+            match block.stmts[0].node {\n+                StmtExpr(ref expr, _) | StmtSemi(ref expr, _) => Some(expr),\n+                _ => None,\n+            }\n+        }\n         _ => None,\n     }\n }\n@@ -500,10 +556,12 @@ fn is_break_expr(expr: &Expr) -> bool {\n     match expr.node {\n         ExprBreak(None) => true,\n         // there won't be a `let <pat> = break` and so we can safely ignore the StmtDecl case\n-        ExprBlock(ref b) => match extract_first_expr(b) {\n-            Some(ref subexpr) => is_break_expr(subexpr),\n-            None => false,\n-        },\n+        ExprBlock(ref b) => {\n+            match extract_first_expr(b) {\n+                Some(ref subexpr) => is_break_expr(subexpr),\n+                None => false,\n+            }\n+        }\n         _ => false,\n     }\n }\n@@ -513,19 +571,19 @@ fn is_break_expr(expr: &Expr) -> bool {\n // at the start of the loop.\n #[derive(PartialEq)]\n enum VarState {\n-    Initial,      // Not examined yet\n-    IncrOnce,     // Incremented exactly once, may be a loop counter\n-    Declared,     // Declared but not (yet) initialized to zero\n+    Initial, // Not examined yet\n+    IncrOnce, // Incremented exactly once, may be a loop counter\n+    Declared, // Declared but not (yet) initialized to zero\n     Warn,\n-    DontWarn\n+    DontWarn,\n }\n \n // Scan a for loop for variables that are incremented exactly once.\n struct IncrementVisitor<'v, 't: 'v> {\n-    cx: &'v LateContext<'v, 't>,      // context reference\n-    states: HashMap<NodeId, VarState>,  // incremented variables\n-    depth: u32,                         // depth of conditional expressions\n-    done: bool\n+    cx: &'v LateContext<'v, 't>, // context reference\n+    states: HashMap<NodeId, VarState>, // incremented variables\n+    depth: u32, // depth of conditional expressions\n+    done: bool,\n }\n \n impl<'v, 't> Visitor<'v> for IncrementVisitor<'v, 't> {\n@@ -540,33 +598,29 @@ impl<'v, 't> Visitor<'v> for IncrementVisitor<'v, 't> {\n                 let state = self.states.entry(def_id).or_insert(VarState::Initial);\n \n                 match parent.node {\n-                    ExprAssignOp(op, ref lhs, ref rhs) =>\n+                    ExprAssignOp(op, ref lhs, ref rhs) => {\n                         if lhs.id == expr.id {\n                             if op.node == BiAdd && is_integer_literal(rhs, 1) {\n                                 *state = match *state {\n                                     VarState::Initial if self.depth == 0 => VarState::IncrOnce,\n-                                    _ => VarState::DontWarn\n+                                    _ => VarState::DontWarn,\n                                 };\n-                            }\n-                            else {\n+                            } else {\n                                 // Assigned some other value\n                                 *state = VarState::DontWarn;\n                             }\n-                        },\n+                        }\n+                    }\n                     ExprAssign(ref lhs, _) if lhs.id == expr.id => *state = VarState::DontWarn,\n-                    ExprAddrOf(mutability,_) if mutability == MutMutable => *state = VarState::DontWarn,\n-                    _ => ()\n+                    ExprAddrOf(mutability, _) if mutability == MutMutable => *state = VarState::DontWarn,\n+                    _ => (),\n                 }\n             }\n-        }\n-        // Give up if there are nested loops\n-        else if is_loop(expr) {\n+        } else if is_loop(expr) {\n             self.states.clear();\n             self.done = true;\n             return;\n-        }\n-        // Keep track of whether we're inside a conditional expression\n-        else if is_conditional(expr) {\n+        } else if is_conditional(expr) {\n             self.depth += 1;\n             walk_expr(self, expr);\n             self.depth -= 1;\n@@ -579,12 +633,12 @@ impl<'v, 't> Visitor<'v> for IncrementVisitor<'v, 't> {\n // Check whether a variable is initialized to zero at the start of a loop.\n struct InitializeVisitor<'v, 't: 'v> {\n     cx: &'v LateContext<'v, 't>, // context reference\n-    end_expr: &'v Expr,      // the for loop. Stop scanning here.\n+    end_expr: &'v Expr, // the for loop. Stop scanning here.\n     var_id: NodeId,\n     state: VarState,\n     name: Option<Name>,\n-    depth: u32,              // depth of conditional expressions\n-    past_loop: bool\n+    depth: u32, // depth of conditional expressions\n+    past_loop: bool,\n }\n \n impl<'v, 't> Visitor<'v> for InitializeVisitor<'v, 't> {\n@@ -601,8 +655,7 @@ impl<'v, 't> Visitor<'v> for InitializeVisitor<'v, 't> {\n                         } else {\n                             VarState::Declared\n                         }\n-                    }\n-                    else {\n+                    } else {\n                         VarState::Declared\n                     }\n                 }\n@@ -637,24 +690,21 @@ impl<'v, 't> Visitor<'v> for InitializeVisitor<'v, 't> {\n                             VarState::Warn\n                         } else {\n                             VarState::DontWarn\n-                        }}\n-                    ExprAddrOf(mutability,_) if mutability == MutMutable => self.state = VarState::DontWarn,\n-                    _ => ()\n+                        }\n+                    }\n+                    ExprAddrOf(mutability, _) if mutability == MutMutable => self.state = VarState::DontWarn,\n+                    _ => (),\n                 }\n             }\n \n             if self.past_loop {\n                 self.state = VarState::DontWarn;\n                 return;\n             }\n-        }\n-        // If there are other loops between the declaration and the target loop, give up\n-        else if !self.past_loop && is_loop(expr) {\n+        } else if !self.past_loop && is_loop(expr) {\n             self.state = VarState::DontWarn;\n             return;\n-        }\n-        // Keep track of whether we're inside a conditional expression\n-        else if is_conditional(expr) {\n+        } else if is_conditional(expr) {\n             self.depth += 1;\n             walk_expr(self, expr);\n             self.depth -= 1;\n@@ -667,22 +717,22 @@ impl<'v, 't> Visitor<'v> for InitializeVisitor<'v, 't> {\n fn var_def_id(cx: &LateContext, expr: &Expr) -> Option<NodeId> {\n     if let Some(path_res) = cx.tcx.def_map.borrow().get(&expr.id) {\n         if let DefLocal(_, node_id) = path_res.base_def {\n-            return Some(node_id)\n+            return Some(node_id);\n         }\n     }\n     None\n }\n \n fn is_loop(expr: &Expr) -> bool {\n     match expr.node {\n-        ExprLoop(..) | ExprWhile(..)  => true,\n-        _ => false\n+        ExprLoop(..) | ExprWhile(..) => true,\n+        _ => false,\n     }\n }\n \n fn is_conditional(expr: &Expr) -> bool {\n     match expr.node {\n         ExprIf(..) | ExprMatch(..) => true,\n-        _ => false\n+        _ => false,\n     }\n }"}, {"sha": "9db97a1b9f2d90e3f1cd2a30663a3e4b4933493b", "filename": "src/map_clone.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmap_clone.rs?ref=c9342d01213ca1663d2cdf23289bae024823ae6a", "patch": "@@ -65,10 +65,13 @@ impl LateLintPass for MapClonePass {\n                     ExprPath(_, ref path) => {\n                         if match_path(path, &CLONE_PATH) {\n                             let type_name = get_type_name(cx, expr, &args[0]).unwrap_or(\"_\");\n-                            span_help_and_lint(cx, MAP_CLONE, expr.span, &format!(\n-                                \"you seem to be using .map() to clone the contents of an {}, consider \\\n-                                using `.cloned()`\", type_name),\n-                                &format!(\"try\\n{}.cloned()\", snippet(cx, args[0].span, \"..\")));\n+                            span_help_and_lint(cx,\n+                                               MAP_CLONE,\n+                                               expr.span,\n+                                               &format!(\"you seem to be using .map() to clone the contents of an \\\n+                                                         {}, consider using `.cloned()`\",\n+                                                        type_name),\n+                                               &format!(\"try\\n{}.cloned()\", snippet(cx, args[0].span, \"..\")));\n                         }\n                     }\n                     _ => (),\n@@ -81,7 +84,10 @@ impl LateLintPass for MapClonePass {\n fn expr_eq_ident(expr: &Expr, id: Ident) -> bool {\n     match expr.node {\n         ExprPath(None, ref path) => {\n-            let arg_segment = [PathSegment { identifier: id, parameters: PathParameters::none() }];\n+            let arg_segment = [PathSegment {\n+                                   identifier: id,\n+                                   parameters: PathParameters::none(),\n+                               }];\n             !path.global && path.segments[..] == arg_segment\n         }\n         _ => false,\n@@ -108,9 +114,7 @@ fn get_arg_name(pat: &Pat) -> Option<Ident> {\n \n fn only_derefs(cx: &LateContext, expr: &Expr, id: Ident) -> bool {\n     match expr.node {\n-        ExprUnary(UnDeref, ref subexpr) if !is_adjusted(cx, subexpr) => {\n-            only_derefs(cx, subexpr, id)\n-        }\n+        ExprUnary(UnDeref, ref subexpr) if !is_adjusted(cx, subexpr) => only_derefs(cx, subexpr, id),\n         _ => expr_eq_ident(expr, id),\n     }\n }"}, {"sha": "5e207093c1580a3accfc63ba3e5278c28770f2c7", "filename": "src/matches.rs", "status": "modified", "additions": 126, "deletions": 108, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmatches.rs?ref=c9342d01213ca1663d2cdf23289bae024823ae6a", "patch": "@@ -94,7 +94,9 @@ impl LintPass for MatchPass {\n \n impl LateLintPass for MatchPass {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n-        if in_external_macro(cx, expr.span) { return; }\n+        if in_external_macro(cx, expr.span) {\n+            return;\n+        }\n         if let ExprMatch(ref ex, ref arms, MatchSource::Normal) = expr.node {\n             check_single_match(cx, ex, arms, expr);\n             check_match_bool(cx, ex, arms, expr);\n@@ -107,23 +109,14 @@ impl LateLintPass for MatchPass {\n }\n \n fn check_single_match(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n-    if arms.len() == 2 &&\n-        // both of the arms have a single pattern and no guard\n-        arms[0].pats.len() == 1 && arms[0].guard.is_none() &&\n-        arms[1].pats.len() == 1 && arms[1].guard.is_none() &&\n-        // and the second pattern is a `_` wildcard: this is not strictly necessary,\n-        // since the exhaustiveness check will ensure the last one is a catch-all,\n-        // but in some cases, an explicit match is preferred to catch situations\n-        // when an enum is extended, so we don't consider these cases\n-        arms[1].pats[0].node == PatWild &&\n-        // we don't want any content in the second arm (unit or empty block)\n-        is_unit_expr(&arms[1].body) &&\n-        // finally, MATCH_BOOL doesn't apply here\n-        (cx.tcx.expr_ty(ex).sty != ty::TyBool || cx.current_level(MATCH_BOOL) == Allow)\n-    {\n-        span_help_and_lint(cx, SINGLE_MATCH, expr.span,\n-                           \"you seem to be trying to use match for destructuring a \\\n-                            single pattern. Consider using `if let`\",\n+    if arms.len() == 2 && arms[0].pats.len() == 1 && arms[0].guard.is_none() && arms[1].pats.len() == 1 &&\n+       arms[1].guard.is_none() && arms[1].pats[0].node == PatWild && is_unit_expr(&arms[1].body) &&\n+       (cx.tcx.expr_ty(ex).sty != ty::TyBool || cx.current_level(MATCH_BOOL) == Allow) {\n+        span_help_and_lint(cx,\n+                           SINGLE_MATCH,\n+                           expr.span,\n+                           \"you seem to be trying to use match for destructuring a single pattern. Consider using \\\n+                            `if let`\",\n                            &format!(\"try\\nif let {} = {} {}\",\n                                     snippet(cx, arms[0].pats[0].span, \"..\"),\n                                     snippet(cx, ex.span, \"..\"),\n@@ -134,62 +127,76 @@ fn check_single_match(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n fn check_match_bool(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n     // type of expression == bool\n     if cx.tcx.expr_ty(ex).sty == ty::TyBool {\n-        if arms.len() == 2 && arms[0].pats.len() == 1 { // no guards\n+        if arms.len() == 2 && arms[0].pats.len() == 1 {\n+            // no guards\n             let exprs = if let PatLit(ref arm_bool) = arms[0].pats[0].node {\n                 if let ExprLit(ref lit) = arm_bool.node {\n                     match lit.node {\n                         LitBool(true) => Some((&*arms[0].body, &*arms[1].body)),\n                         LitBool(false) => Some((&*arms[1].body, &*arms[0].body)),\n                         _ => None,\n                     }\n-                } else { None }\n-            } else { None };\n+                } else {\n+                    None\n+                }\n+            } else {\n+                None\n+            };\n             if let Some((ref true_expr, ref false_expr)) = exprs {\n                 if !is_unit_expr(true_expr) {\n                     if !is_unit_expr(false_expr) {\n-                        span_help_and_lint(cx, MATCH_BOOL, expr.span,\n-                            \"you seem to be trying to match on a boolean expression. \\\n-                           Consider using an if..else block:\",\n-                           &format!(\"try\\nif {} {} else {}\",\n-                                snippet(cx, ex.span, \"b\"),\n-                                expr_block(cx, true_expr, None, \"..\"),\n-                                expr_block(cx, false_expr, None, \"..\")));\n+                        span_help_and_lint(cx,\n+                                           MATCH_BOOL,\n+                                           expr.span,\n+                                           \"you seem to be trying to match on a boolean expression. Consider using \\\n+                                            an if..else block:\",\n+                                           &format!(\"try\\nif {} {} else {}\",\n+                                                    snippet(cx, ex.span, \"b\"),\n+                                                    expr_block(cx, true_expr, None, \"..\"),\n+                                                    expr_block(cx, false_expr, None, \"..\")));\n                     } else {\n-                        span_help_and_lint(cx, MATCH_BOOL, expr.span,\n-                            \"you seem to be trying to match on a boolean expression. \\\n-                           Consider using an if..else block:\",\n-                           &format!(\"try\\nif {} {}\",\n-                                snippet(cx, ex.span, \"b\"),\n-                                expr_block(cx, true_expr, None, \"..\")));\n+                        span_help_and_lint(cx,\n+                                           MATCH_BOOL,\n+                                           expr.span,\n+                                           \"you seem to be trying to match on a boolean expression. Consider using \\\n+                                            an if..else block:\",\n+                                           &format!(\"try\\nif {} {}\",\n+                                                    snippet(cx, ex.span, \"b\"),\n+                                                    expr_block(cx, true_expr, None, \"..\")));\n                     }\n                 } else if !is_unit_expr(false_expr) {\n-                    span_help_and_lint(cx, MATCH_BOOL, expr.span,\n-                        \"you seem to be trying to match on a boolean expression. \\\n-                       Consider using an if..else block:\",\n-                       &format!(\"try\\nif !{} {}\",\n-                            snippet(cx, ex.span, \"b\"),\n-                            expr_block(cx, false_expr, None, \"..\")));\n+                    span_help_and_lint(cx,\n+                                       MATCH_BOOL,\n+                                       expr.span,\n+                                       \"you seem to be trying to match on a boolean expression. Consider using an \\\n+                                        if..else block:\",\n+                                       &format!(\"try\\nif !{} {}\",\n+                                                snippet(cx, ex.span, \"b\"),\n+                                                expr_block(cx, false_expr, None, \"..\")));\n                 } else {\n-                    span_lint(cx, MATCH_BOOL, expr.span,\n-                           \"you seem to be trying to match on a boolean expression. \\\n-                           Consider using an if..else block\");\n+                    span_lint(cx,\n+                              MATCH_BOOL,\n+                              expr.span,\n+                              \"you seem to be trying to match on a boolean expression. Consider using an if..else \\\n+                               block\");\n                 }\n             } else {\n-                span_lint(cx, MATCH_BOOL, expr.span,\n-                    \"you seem to be trying to match on a boolean expression. \\\n-                    Consider using an if..else block\");\n+                span_lint(cx,\n+                          MATCH_BOOL,\n+                          expr.span,\n+                          \"you seem to be trying to match on a boolean expression. Consider using an if..else block\");\n             }\n         } else {\n-            span_lint(cx, MATCH_BOOL, expr.span,\n-                \"you seem to be trying to match on a boolean expression. \\\n-                Consider using an if..else block\");\n+            span_lint(cx,\n+                      MATCH_BOOL,\n+                      expr.span,\n+                      \"you seem to be trying to match on a boolean expression. Consider using an if..else block\");\n         }\n     }\n }\n \n fn check_overlapping_arms(cx: &LateContext, ex: &Expr, arms: &[Arm]) {\n-    if arms.len() >= 2 &&\n-       cx.tcx.expr_ty(ex).is_integral() {\n+    if arms.len() >= 2 && cx.tcx.expr_ty(ex).is_integral() {\n         let ranges = all_ranges(cx, arms);\n         let overlap = match type_ranges(&ranges) {\n             TypedRanges::IntRanges(ranges) => overlapping(&ranges).map(|(start, end)| (start.span, end.span)),\n@@ -198,9 +205,12 @@ fn check_overlapping_arms(cx: &LateContext, ex: &Expr, arms: &[Arm]) {\n         };\n \n         if let Some((start, end)) = overlap {\n-            span_note_and_lint(cx, MATCH_OVERLAPPING_ARM, start,\n+            span_note_and_lint(cx,\n+                               MATCH_OVERLAPPING_ARM,\n+                               start,\n                                \"some ranges overlap\",\n-                               end, \"overlaps with this\");\n+                               end,\n+                               \"overlaps with this\");\n         }\n     }\n }\n@@ -209,14 +219,18 @@ fn check_match_ref_pats(cx: &LateContext, ex: &Expr, arms: &[Arm], source: Match\n     if has_only_ref_pats(arms) {\n         if let ExprAddrOf(Mutability::MutImmutable, ref inner) = ex.node {\n             let template = match_template(cx, expr.span, source, \"\", inner);\n-            span_lint(cx, MATCH_REF_PATS, expr.span, &format!(\n-                \"you don't need to add `&` to both the expression \\\n-                 and the patterns: use `{}`\", template));\n+            span_lint(cx,\n+                      MATCH_REF_PATS,\n+                      expr.span,\n+                      &format!(\"you don't need to add `&` to both the expression and the patterns: use `{}`\",\n+                               template));\n         } else {\n             let template = match_template(cx, expr.span, source, \"*\", ex);\n-            span_lint(cx, MATCH_REF_PATS, expr.span, &format!(\n-                \"instead of prefixing all patterns with `&`, you can dereference the \\\n-                 expression: `{}`\", template));\n+            span_lint(cx,\n+                      MATCH_REF_PATS,\n+                      expr.span,\n+                      &format!(\"instead of prefixing all patterns with `&`, you can dereference the expression: `{}`\",\n+                               template));\n         }\n     }\n }\n@@ -244,8 +258,7 @@ fn all_ranges(cx: &LateContext, arms: &[Arm]) -> Vec<SpannedRange<ConstVal>> {\n \n                     None\n                 }))\n-            }\n-            else {\n+            } else {\n                 None\n             }\n         })\n@@ -271,29 +284,36 @@ enum TypedRanges {\n fn type_ranges(ranges: &[SpannedRange<ConstVal>]) -> TypedRanges {\n     if ranges.is_empty() {\n         TypedRanges::None\n-    }\n-    else {\n+    } else {\n         match ranges[0].node {\n             (Int(_), Int(_)) => {\n-                TypedRanges::IntRanges(ranges.iter().filter_map(|range| {\n-                    if let (Int(start), Int(end)) = range.node {\n-                        Some(SpannedRange { span: range.span, node: (start, end) })\n-                    }\n-                    else {\n-                        None\n-                    }\n-                }).collect())\n-            },\n+                TypedRanges::IntRanges(ranges.iter()\n+                                             .filter_map(|range| {\n+                                                 if let (Int(start), Int(end)) = range.node {\n+                                                     Some(SpannedRange {\n+                                                         span: range.span,\n+                                                         node: (start, end),\n+                                                     })\n+                                                 } else {\n+                                                     None\n+                                                 }\n+                                             })\n+                                             .collect())\n+            }\n             (Uint(_), Uint(_)) => {\n-                TypedRanges::UintRanges(ranges.iter().filter_map(|range| {\n-                    if let (Uint(start), Uint(end)) = range.node {\n-                        Some(SpannedRange { span: range.span, node: (start, end) })\n-                    }\n-                    else {\n-                        None\n-                    }\n-                }).collect())\n-            },\n+                TypedRanges::UintRanges(ranges.iter()\n+                                              .filter_map(|range| {\n+                                                  if let (Uint(start), Uint(end)) = range.node {\n+                                                      Some(SpannedRange {\n+                                                          span: range.span,\n+                                                          node: (start, end),\n+                                                      })\n+                                                  } else {\n+                                                      None\n+                                                  }\n+                                              })\n+                                              .collect())\n+            }\n             _ => TypedRanges::None,\n         }\n     }\n@@ -308,39 +328,33 @@ fn is_unit_expr(expr: &Expr) -> bool {\n }\n \n fn has_only_ref_pats(arms: &[Arm]) -> bool {\n-    let mapped = arms.iter().flat_map(|a| &a.pats).map(|p| match p.node {\n-        PatRegion(..) => Some(true),  // &-patterns\n-        PatWild => Some(false),   // an \"anything\" wildcard is also fine\n-        _ => None,                    // any other pattern is not fine\n-    }).collect::<Option<Vec<bool>>>();\n+    let mapped = arms.iter()\n+                     .flat_map(|a| &a.pats)\n+                     .map(|p| {\n+                         match p.node {\n+                             PatRegion(..) => Some(true),  // &-patterns\n+                             PatWild => Some(false),   // an \"anything\" wildcard is also fine\n+                             _ => None,                    // any other pattern is not fine\n+                         }\n+                     })\n+                     .collect::<Option<Vec<bool>>>();\n     // look for Some(v) where there's at least one true element\n     mapped.map_or(false, |v| v.iter().any(|el| *el))\n }\n \n-fn match_template(cx: &LateContext,\n-                  span: Span,\n-                  source: MatchSource,\n-                  op: &str,\n-                  expr: &Expr) -> String {\n+fn match_template(cx: &LateContext, span: Span, source: MatchSource, op: &str, expr: &Expr) -> String {\n     let expr_snippet = snippet(cx, expr.span, \"..\");\n     match source {\n-        MatchSource::Normal => {\n-            format!(\"match {}{} {{ ...\", op, expr_snippet)\n-        }\n-        MatchSource::IfLetDesugar { .. } => {\n-            format!(\"if let ... = {}{} {{\", op, expr_snippet)\n-        }\n-        MatchSource::WhileLetDesugar => {\n-            format!(\"while let ... = {}{} {{\", op, expr_snippet)\n-        }\n-        MatchSource::ForLoopDesugar => {\n-            cx.sess().span_bug(span, \"for loop desugared to match with &-patterns!\")\n-        }\n+        MatchSource::Normal => format!(\"match {}{} {{ ...\", op, expr_snippet),\n+        MatchSource::IfLetDesugar { .. } => format!(\"if let ... = {}{} {{\", op, expr_snippet),\n+        MatchSource::WhileLetDesugar => format!(\"while let ... = {}{} {{\", op, expr_snippet),\n+        MatchSource::ForLoopDesugar => cx.sess().span_bug(span, \"for loop desugared to match with &-patterns!\"),\n     }\n }\n \n pub fn overlapping<T>(ranges: &[SpannedRange<T>]) -> Option<(&SpannedRange<T>, &SpannedRange<T>)>\n-    where T: Copy + Ord {\n+    where T: Copy + Ord\n+{\n     #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n     enum Kind<'a, T: 'a> {\n         Start(T, &'a SpannedRange<T>),\n@@ -350,13 +364,13 @@ pub fn overlapping<T>(ranges: &[SpannedRange<T>]) -> Option<(&SpannedRange<T>, &\n     impl<'a, T: Copy> Kind<'a, T> {\n         fn range(&self) -> &'a SpannedRange<T> {\n             match *self {\n-                Kind::Start(_, r) | Kind::End(_, r) => r\n+                Kind::Start(_, r) | Kind::End(_, r) => r,\n             }\n         }\n \n         fn value(self) -> T {\n             match self {\n-                Kind::Start(t, _) | Kind::End(t, _) => t\n+                Kind::Start(t, _) | Kind::End(t, _) => t,\n             }\n         }\n     }\n@@ -373,7 +387,7 @@ pub fn overlapping<T>(ranges: &[SpannedRange<T>]) -> Option<(&SpannedRange<T>, &\n         }\n     }\n \n-    let mut values = Vec::with_capacity(2*ranges.len());\n+    let mut values = Vec::with_capacity(2 * ranges.len());\n \n     for r in ranges {\n         values.push(Kind::Start(r.node.0, &r));\n@@ -384,7 +398,11 @@ pub fn overlapping<T>(ranges: &[SpannedRange<T>]) -> Option<(&SpannedRange<T>, &\n \n     for (a, b) in values.iter().zip(values.iter().skip(1)) {\n         match (a, b) {\n-            (&Kind::Start(_, ra), &Kind::End(_, rb)) => if ra.node != rb.node { return Some((ra, rb)) },\n+            (&Kind::Start(_, ra), &Kind::End(_, rb)) => {\n+                if ra.node != rb.node {\n+                    return Some((ra, rb));\n+                }\n+            }\n             (&Kind::End(a, _), &Kind::Start(b, _)) if a != b => (),\n             _ => return Some((&a.range(), &b.range())),\n         }"}, {"sha": "83b9e60f4beeffa4c93badbe46b2fd7c4ac5fae7", "filename": "src/methods.rs", "status": "modified", "additions": 280, "deletions": 140, "changes": 420, "blob_url": "https://github.com/rust-lang/rust/blob/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmethods.rs?ref=c9342d01213ca1663d2cdf23289bae024823ae6a", "patch": "@@ -5,8 +5,8 @@ use rustc::middle::subst::{Subst, TypeSpace};\n use std::iter;\n use std::borrow::Cow;\n \n-use utils::{snippet, span_lint, span_note_and_lint, match_path, match_type, method_chain_args,\n-            match_trait_method, walk_ptrs_ty_depth, walk_ptrs_ty};\n+use utils::{snippet, span_lint, span_note_and_lint, match_path, match_type, method_chain_args, match_trait_method,\n+            walk_ptrs_ty_depth, walk_ptrs_ty};\n use utils::{OPTION_PATH, RESULT_PATH, STRING_PATH};\n use utils::MethodArgs;\n \n@@ -172,9 +172,16 @@ declare_lint!(pub SEARCH_IS_SOME, Warn,\n \n impl LintPass for MethodsPass {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(OPTION_UNWRAP_USED, RESULT_UNWRAP_USED, STR_TO_STRING, STRING_TO_STRING,\n-                    SHOULD_IMPLEMENT_TRAIT, WRONG_SELF_CONVENTION, WRONG_PUB_SELF_CONVENTION,\n-                    OK_EXPECT, OPTION_MAP_UNWRAP_OR, OPTION_MAP_UNWRAP_OR_ELSE)\n+        lint_array!(OPTION_UNWRAP_USED,\n+                    RESULT_UNWRAP_USED,\n+                    STR_TO_STRING,\n+                    STRING_TO_STRING,\n+                    SHOULD_IMPLEMENT_TRAIT,\n+                    WRONG_SELF_CONVENTION,\n+                    WRONG_PUB_SELF_CONVENTION,\n+                    OK_EXPECT,\n+                    OPTION_MAP_UNWRAP_OR,\n+                    OPTION_MAP_UNWRAP_OR_ELSE)\n     }\n }\n \n@@ -183,29 +190,21 @@ impl LateLintPass for MethodsPass {\n         if let ExprMethodCall(_, _, _) = expr.node {\n             if let Some(arglists) = method_chain_args(expr, &[\"unwrap\"]) {\n                 lint_unwrap(cx, expr, arglists[0]);\n-            }\n-            else if let Some(arglists) = method_chain_args(expr, &[\"to_string\"]) {\n+            } else if let Some(arglists) = method_chain_args(expr, &[\"to_string\"]) {\n                 lint_to_string(cx, expr, arglists[0]);\n-            }\n-            else if let Some(arglists) = method_chain_args(expr, &[\"ok\", \"expect\"]) {\n+            } else if let Some(arglists) = method_chain_args(expr, &[\"ok\", \"expect\"]) {\n                 lint_ok_expect(cx, expr, arglists[0]);\n-            }\n-            else if let Some(arglists) = method_chain_args(expr, &[\"map\", \"unwrap_or\"]) {\n+            } else if let Some(arglists) = method_chain_args(expr, &[\"map\", \"unwrap_or\"]) {\n                 lint_map_unwrap_or(cx, expr, arglists[0], arglists[1]);\n-            }\n-            else if let Some(arglists) = method_chain_args(expr, &[\"map\", \"unwrap_or_else\"]) {\n+            } else if let Some(arglists) = method_chain_args(expr, &[\"map\", \"unwrap_or_else\"]) {\n                 lint_map_unwrap_or_else(cx, expr, arglists[0], arglists[1]);\n-            }\n-            else if let Some(arglists) = method_chain_args(expr, &[\"filter\", \"next\"]) {\n+            } else if let Some(arglists) = method_chain_args(expr, &[\"filter\", \"next\"]) {\n                 lint_filter_next(cx, expr, arglists[0]);\n-            }\n-            else if let Some(arglists) = method_chain_args(expr, &[\"find\", \"is_some\"]) {\n+            } else if let Some(arglists) = method_chain_args(expr, &[\"find\", \"is_some\"]) {\n                 lint_search_is_some(cx, expr, \"find\", arglists[0], arglists[1]);\n-            }\n-            else if let Some(arglists) = method_chain_args(expr, &[\"position\", \"is_some\"]) {\n+            } else if let Some(arglists) = method_chain_args(expr, &[\"position\", \"is_some\"]) {\n                 lint_search_is_some(cx, expr, \"position\", arglists[0], arglists[1]);\n-            }\n-            else if let Some(arglists) = method_chain_args(expr, &[\"rposition\", \"is_some\"]) {\n+            } else if let Some(arglists) = method_chain_args(expr, &[\"rposition\", \"is_some\"]) {\n                 lint_search_is_some(cx, expr, \"rposition\", arglists[0], arglists[1]);\n             }\n         }\n@@ -235,16 +234,22 @@ impl LateLintPass for MethodsPass {\n                     let is_copy = is_copy(cx, &ty, &item);\n                     for &(prefix, self_kinds) in &CONVENTIONS {\n                         if name.as_str().starts_with(prefix) &&\n-                                !self_kinds.iter().any(|k| k.matches(&sig.explicit_self.node, is_copy)) {\n+                           !self_kinds.iter().any(|k| k.matches(&sig.explicit_self.node, is_copy)) {\n                             let lint = if item.vis == Visibility::Public {\n                                 WRONG_PUB_SELF_CONVENTION\n                             } else {\n                                 WRONG_SELF_CONVENTION\n                             };\n-                            span_lint(cx, lint, sig.explicit_self.span, &format!(\n-                                \"methods called `{}*` usually take {}; consider choosing a less \\\n-                                 ambiguous name\", prefix,\n-                                &self_kinds.iter().map(|k| k.description()).collect::<Vec<_>>().join(\" or \")));\n+                            span_lint(cx,\n+                                      lint,\n+                                      sig.explicit_self.span,\n+                                      &format!(\"methods called `{}*` usually take {}; consider choosing a less \\\n+                                                ambiguous name\",\n+                                               prefix,\n+                                               &self_kinds.iter()\n+                                                          .map(|k| k.description())\n+                                                          .collect::<Vec<_>>()\n+                                                          .join(\" or \")));\n                         }\n                     }\n                 }\n@@ -253,160 +258,175 @@ impl LateLintPass for MethodsPass {\n     }\n }\n \n-#[allow(ptr_arg)] // Type of MethodArgs is potentially a Vec\n+#[allow(ptr_arg)]\n+// Type of MethodArgs is potentially a Vec\n /// lint use of `unwrap()` for `Option`s and `Result`s\n fn lint_unwrap(cx: &LateContext, expr: &Expr, unwrap_args: &MethodArgs) {\n     let (obj_ty, _) = walk_ptrs_ty_depth(cx.tcx.expr_ty(&unwrap_args[0]));\n \n     let mess = if match_type(cx, obj_ty, &OPTION_PATH) {\n         Some((OPTION_UNWRAP_USED, \"an Option\", \"None\"))\n-    }\n-    else if match_type(cx, obj_ty, &RESULT_PATH) {\n+    } else if match_type(cx, obj_ty, &RESULT_PATH) {\n         Some((RESULT_UNWRAP_USED, \"a Result\", \"Err\"))\n-    }\n-    else {\n+    } else {\n         None\n     };\n \n     if let Some((lint, kind, none_value)) = mess {\n-        span_lint(cx, lint, expr.span,\n-                  &format!(\"used unwrap() on {} value. If you don't want to handle the {} \\\n-                            case gracefully, consider using expect() to provide a better panic\n-                            message\", kind, none_value));\n+        span_lint(cx,\n+                  lint,\n+                  expr.span,\n+                  &format!(\"used unwrap() on {} value. If you don't want to handle the {} case gracefully, consider \\\n+                            using expect() to provide a better panic\n+                            message\",\n+                           kind,\n+                           none_value));\n     }\n }\n \n-#[allow(ptr_arg)] // Type of MethodArgs is potentially a Vec\n+#[allow(ptr_arg)]\n+// Type of MethodArgs is potentially a Vec\n /// lint use of `to_string()` for `&str`s and `String`s\n fn lint_to_string(cx: &LateContext, expr: &Expr, to_string_args: &MethodArgs) {\n     let (obj_ty, ptr_depth) = walk_ptrs_ty_depth(cx.tcx.expr_ty(&to_string_args[0]));\n \n     if obj_ty.sty == ty::TyStr {\n         let mut arg_str = snippet(cx, to_string_args[0].span, \"_\");\n         if ptr_depth > 1 {\n-            arg_str = Cow::Owned(format!(\n-                \"({}{})\",\n-                iter::repeat('*').take(ptr_depth - 1).collect::<String>(),\n-                arg_str));\n+            arg_str = Cow::Owned(format!(\"({}{})\", iter::repeat('*').take(ptr_depth - 1).collect::<String>(), arg_str));\n         }\n-        span_lint(cx, STR_TO_STRING, expr.span,\n-                  &format!(\"`{}.to_owned()` is faster\", arg_str));\n-    }\n-    else if match_type(cx, obj_ty, &STRING_PATH) {\n-        span_lint(cx, STRING_TO_STRING, expr.span,\n+        span_lint(cx, STR_TO_STRING, expr.span, &format!(\"`{}.to_owned()` is faster\", arg_str));\n+    } else if match_type(cx, obj_ty, &STRING_PATH) {\n+        span_lint(cx,\n+                  STRING_TO_STRING,\n+                  expr.span,\n                   \"`String.to_string()` is a no-op; use `clone()` to make a copy\");\n     }\n }\n \n-#[allow(ptr_arg)] // Type of MethodArgs is potentially a Vec\n+#[allow(ptr_arg)]\n+// Type of MethodArgs is potentially a Vec\n /// lint use of `ok().expect()` for `Result`s\n fn lint_ok_expect(cx: &LateContext, expr: &Expr, ok_args: &MethodArgs) {\n     // lint if the caller of `ok()` is a `Result`\n     if match_type(cx, cx.tcx.expr_ty(&ok_args[0]), &RESULT_PATH) {\n         let result_type = cx.tcx.expr_ty(&ok_args[0]);\n         if let Some(error_type) = get_error_type(cx, result_type) {\n             if has_debug_impl(error_type, cx) {\n-                span_lint(cx, OK_EXPECT, expr.span,\n-                          \"called `ok().expect()` on a Result value. You can call `expect` \\\n-                           directly on the `Result`\");\n+                span_lint(cx,\n+                          OK_EXPECT,\n+                          expr.span,\n+                          \"called `ok().expect()` on a Result value. You can call `expect` directly on the `Result`\");\n             }\n         }\n     }\n }\n \n-#[allow(ptr_arg)] // Type of MethodArgs is potentially a Vec\n+#[allow(ptr_arg)]\n+// Type of MethodArgs is potentially a Vec\n /// lint use of `map().unwrap_or()` for `Option`s\n-fn lint_map_unwrap_or(cx: &LateContext, expr: &Expr, map_args: &MethodArgs,\n-                      unwrap_args: &MethodArgs) {\n+fn lint_map_unwrap_or(cx: &LateContext, expr: &Expr, map_args: &MethodArgs, unwrap_args: &MethodArgs) {\n     // lint if the caller of `map()` is an `Option`\n     if match_type(cx, cx.tcx.expr_ty(&map_args[0]), &OPTION_PATH) {\n         // lint message\n-        let msg = \"called `map(f).unwrap_or(a)` on an Option value. This can be done more \\\n-                   directly by calling `map_or(a, f)` instead\";\n+        let msg = \"called `map(f).unwrap_or(a)` on an Option value. This can be done more directly by calling \\\n+                   `map_or(a, f)` instead\";\n         // get snippets for args to map() and unwrap_or()\n         let map_snippet = snippet(cx, map_args[1].span, \"..\");\n         let unwrap_snippet = snippet(cx, unwrap_args[1].span, \"..\");\n         // lint, with note if neither arg is > 1 line and both map() and\n         // unwrap_or() have the same span\n-        let multiline = map_snippet.lines().count() > 1\n-                        || unwrap_snippet.lines().count() > 1;\n+        let multiline = map_snippet.lines().count() > 1 || unwrap_snippet.lines().count() > 1;\n         let same_span = map_args[1].span.expn_id == unwrap_args[1].span.expn_id;\n         if same_span && !multiline {\n-            span_note_and_lint(\n-                cx, OPTION_MAP_UNWRAP_OR, expr.span, msg, expr.span,\n-                &format!(\"replace `map({0}).unwrap_or({1})` with `map_or({1}, {0})`\", map_snippet,\n-                         unwrap_snippet)\n-            );\n-        }\n-        else if same_span && multiline {\n+            span_note_and_lint(cx,\n+                               OPTION_MAP_UNWRAP_OR,\n+                               expr.span,\n+                               msg,\n+                               expr.span,\n+                               &format!(\"replace `map({0}).unwrap_or({1})` with `map_or({1}, {0})`\",\n+                                        map_snippet,\n+                                        unwrap_snippet));\n+        } else if same_span && multiline {\n             span_lint(cx, OPTION_MAP_UNWRAP_OR, expr.span, msg);\n         };\n     }\n }\n \n-#[allow(ptr_arg)] // Type of MethodArgs is potentially a Vec\n+#[allow(ptr_arg)]\n+// Type of MethodArgs is potentially a Vec\n /// lint use of `map().unwrap_or_else()` for `Option`s\n-fn lint_map_unwrap_or_else(cx: &LateContext, expr: &Expr, map_args: &MethodArgs,\n-                           unwrap_args: &MethodArgs) {\n+fn lint_map_unwrap_or_else(cx: &LateContext, expr: &Expr, map_args: &MethodArgs, unwrap_args: &MethodArgs) {\n     // lint if the caller of `map()` is an `Option`\n     if match_type(cx, cx.tcx.expr_ty(&map_args[0]), &OPTION_PATH) {\n         // lint message\n-        let msg = \"called `map(f).unwrap_or_else(g)` on an Option value. This can be done more \\\n-                   directly by calling `map_or_else(g, f)` instead\";\n+        let msg = \"called `map(f).unwrap_or_else(g)` on an Option value. This can be done more directly by calling \\\n+                   `map_or_else(g, f)` instead\";\n         // get snippets for args to map() and unwrap_or_else()\n         let map_snippet = snippet(cx, map_args[1].span, \"..\");\n         let unwrap_snippet = snippet(cx, unwrap_args[1].span, \"..\");\n         // lint, with note if neither arg is > 1 line and both map() and\n         // unwrap_or_else() have the same span\n-        let multiline = map_snippet.lines().count() > 1\n-                        || unwrap_snippet.lines().count() > 1;\n+        let multiline = map_snippet.lines().count() > 1 || unwrap_snippet.lines().count() > 1;\n         let same_span = map_args[1].span.expn_id == unwrap_args[1].span.expn_id;\n         if same_span && !multiline {\n-            span_note_and_lint(\n-                cx, OPTION_MAP_UNWRAP_OR_ELSE, expr.span, msg, expr.span,\n-                &format!(\"replace `map({0}).unwrap_or_else({1})` with `with map_or_else({1}, {0})`\",\n-                          map_snippet, unwrap_snippet)\n-            );\n-        }\n-        else if same_span && multiline {\n+            span_note_and_lint(cx,\n+                               OPTION_MAP_UNWRAP_OR_ELSE,\n+                               expr.span,\n+                               msg,\n+                               expr.span,\n+                               &format!(\"replace `map({0}).unwrap_or_else({1})` with `with map_or_else({1}, {0})`\",\n+                                        map_snippet,\n+                                        unwrap_snippet));\n+        } else if same_span && multiline {\n             span_lint(cx, OPTION_MAP_UNWRAP_OR_ELSE, expr.span, msg);\n         };\n     }\n }\n \n-#[allow(ptr_arg)] // Type of MethodArgs is potentially a Vec\n+#[allow(ptr_arg)]\n+// Type of MethodArgs is potentially a Vec\n /// lint use of `filter().next() for Iterators`\n fn lint_filter_next(cx: &LateContext, expr: &Expr, filter_args: &MethodArgs) {\n     // lint if caller of `.filter().next()` is an Iterator\n     if match_trait_method(cx, expr, &[\"core\", \"iter\", \"Iterator\"]) {\n-        let msg = \"called `filter(p).next()` on an Iterator. This is more succinctly expressed by \\\n-                   calling `.find(p)` instead.\";\n+        let msg = \"called `filter(p).next()` on an Iterator. This is more succinctly expressed by calling `.find(p)` \\\n+                   instead.\";\n         let filter_snippet = snippet(cx, filter_args[1].span, \"..\");\n-        if filter_snippet.lines().count() <= 1 { // add note if not multi-line\n-            span_note_and_lint(cx, FILTER_NEXT, expr.span, msg, expr.span,\n-                &format!(\"replace `filter({0}).next()` with `find({0})`\", filter_snippet));\n-        }\n-        else {\n+        if filter_snippet.lines().count() <= 1 {\n+            // add note if not multi-line\n+            span_note_and_lint(cx,\n+                               FILTER_NEXT,\n+                               expr.span,\n+                               msg,\n+                               expr.span,\n+                               &format!(\"replace `filter({0}).next()` with `find({0})`\", filter_snippet));\n+        } else {\n             span_lint(cx, FILTER_NEXT, expr.span, msg);\n         }\n     }\n }\n \n-#[allow(ptr_arg)] // Type of MethodArgs is potentially a Vec\n+#[allow(ptr_arg)]\n+// Type of MethodArgs is potentially a Vec\n /// lint searching an Iterator followed by `is_some()`\n fn lint_search_is_some(cx: &LateContext, expr: &Expr, search_method: &str, search_args: &MethodArgs,\n                        is_some_args: &MethodArgs) {\n     // lint if caller of search is an Iterator\n     if match_trait_method(cx, &*is_some_args[0], &[\"core\", \"iter\", \"Iterator\"]) {\n-        let msg = format!(\"called `is_some()` after searching an iterator with {}. This is more \\\n-                           succinctly expressed by calling `any()`.\", search_method);\n+        let msg = format!(\"called `is_some()` after searching an iterator with {}. This is more succinctly expressed \\\n+                           by calling `any()`.\",\n+                          search_method);\n         let search_snippet = snippet(cx, search_args[1].span, \"..\");\n-        if search_snippet.lines().count() <= 1 { // add note if not multi-line\n-            span_note_and_lint(cx, SEARCH_IS_SOME, expr.span, &msg, expr.span,\n-                &format!(\"replace `{0}({1}).is_some()` with `any({1})`\", search_method,\n-                         search_snippet));\n-        }\n-        else {\n+        if search_snippet.lines().count() <= 1 {\n+            // add note if not multi-line\n+            span_note_and_lint(cx,\n+                               SEARCH_IS_SOME,\n+                               expr.span,\n+                               &msg,\n+                               expr.span,\n+                               &format!(\"replace `{0}({1}).is_some()` with `any({1})`\", search_method, search_snippet));\n+        } else {\n             span_lint(cx, SEARCH_IS_SOME, expr.span, &msg);\n         }\n     }\n@@ -432,7 +452,7 @@ fn has_debug_impl<'a, 'b>(ty: ty::Ty<'a>, cx: &LateContext<'b, 'a>) -> bool {\n     let no_ref_ty = walk_ptrs_ty(ty);\n     let debug = match cx.tcx.lang_items.debug_trait() {\n         Some(debug) => debug,\n-        None => return false\n+        None => return false,\n     };\n     let debug_def = cx.tcx.lookup_trait_def(debug);\n     let mut debug_impl_exists = false;\n@@ -447,46 +467,162 @@ fn has_debug_impl<'a, 'b>(ty: ty::Ty<'a>, cx: &LateContext<'b, 'a>) -> bool {\n     debug_impl_exists\n }\n \n-const CONVENTIONS: [(&'static str, &'static [SelfKind]); 5] = [\n-    (\"into_\", &[ValueSelf]),\n-    (\"to_\",   &[RefSelf]),\n-    (\"as_\",   &[RefSelf, RefMutSelf]),\n-    (\"is_\",   &[RefSelf, NoSelf]),\n-    (\"from_\", &[NoSelf]),\n-];\n-\n-const TRAIT_METHODS: [(&'static str, usize, SelfKind, OutType, &'static str); 30] = [\n-    (\"add\",        2, ValueSelf,  AnyType,  \"std::ops::Add\"),\n-    (\"sub\",        2, ValueSelf,  AnyType,  \"std::ops::Sub\"),\n-    (\"mul\",        2, ValueSelf,  AnyType,  \"std::ops::Mul\"),\n-    (\"div\",        2, ValueSelf,  AnyType,  \"std::ops::Div\"),\n-    (\"rem\",        2, ValueSelf,  AnyType,  \"std::ops::Rem\"),\n-    (\"shl\",        2, ValueSelf,  AnyType,  \"std::ops::Shl\"),\n-    (\"shr\",        2, ValueSelf,  AnyType,  \"std::ops::Shr\"),\n-    (\"bitand\",     2, ValueSelf,  AnyType,  \"std::ops::BitAnd\"),\n-    (\"bitor\",      2, ValueSelf,  AnyType,  \"std::ops::BitOr\"),\n-    (\"bitxor\",     2, ValueSelf,  AnyType,  \"std::ops::BitXor\"),\n-    (\"neg\",        1, ValueSelf,  AnyType,  \"std::ops::Neg\"),\n-    (\"not\",        1, ValueSelf,  AnyType,  \"std::ops::Not\"),\n-    (\"drop\",       1, RefMutSelf, UnitType, \"std::ops::Drop\"),\n-    (\"index\",      2, RefSelf,    RefType,  \"std::ops::Index\"),\n-    (\"index_mut\",  2, RefMutSelf, RefType,  \"std::ops::IndexMut\"),\n-    (\"deref\",      1, RefSelf,    RefType,  \"std::ops::Deref\"),\n-    (\"deref_mut\",  1, RefMutSelf, RefType,  \"std::ops::DerefMut\"),\n-    (\"clone\",      1, RefSelf,    AnyType,  \"std::clone::Clone\"),\n-    (\"borrow\",     1, RefSelf,    RefType,  \"std::borrow::Borrow\"),\n-    (\"borrow_mut\", 1, RefMutSelf, RefType,  \"std::borrow::BorrowMut\"),\n-    (\"as_ref\",     1, RefSelf,    RefType,  \"std::convert::AsRef\"),\n-    (\"as_mut\",     1, RefMutSelf, RefType,  \"std::convert::AsMut\"),\n-    (\"eq\",         2, RefSelf,    BoolType, \"std::cmp::PartialEq\"),\n-    (\"cmp\",        2, RefSelf,    AnyType,  \"std::cmp::Ord\"),\n-    (\"default\",    0, NoSelf,     AnyType,  \"std::default::Default\"),\n-    (\"hash\",       2, RefSelf,    UnitType, \"std::hash::Hash\"),\n-    (\"next\",       1, RefMutSelf, AnyType,  \"std::iter::Iterator\"),\n-    (\"into_iter\",  1, ValueSelf,  AnyType,  \"std::iter::IntoIterator\"),\n-    (\"from_iter\",  1, NoSelf,     AnyType,  \"std::iter::FromIterator\"),\n-    (\"from_str\",   1, NoSelf,     AnyType,  \"std::str::FromStr\"),\n-];\n+const CONVENTIONS: [(&'static str, &'static [SelfKind]); 5] = [(\"into_\", &[ValueSelf]),\n+                                                               (\"to_\", &[RefSelf]),\n+                                                               (\"as_\", &[RefSelf, RefMutSelf]),\n+                                                               (\"is_\", &[RefSelf, NoSelf]),\n+                                                               (\"from_\", &[NoSelf])];\n+\n+const TRAIT_METHODS: [(&'static str, usize, SelfKind, OutType, &'static str); 30] = [(\"add\",\n+                                                                                      2,\n+                                                                                      ValueSelf,\n+                                                                                      AnyType,\n+                                                                                      \"std::ops::Add\"),\n+                                                                                     (\"sub\",\n+                                                                                      2,\n+                                                                                      ValueSelf,\n+                                                                                      AnyType,\n+                                                                                      \"std::ops::Sub\"),\n+                                                                                     (\"mul\",\n+                                                                                      2,\n+                                                                                      ValueSelf,\n+                                                                                      AnyType,\n+                                                                                      \"std::ops::Mul\"),\n+                                                                                     (\"div\",\n+                                                                                      2,\n+                                                                                      ValueSelf,\n+                                                                                      AnyType,\n+                                                                                      \"std::ops::Div\"),\n+                                                                                     (\"rem\",\n+                                                                                      2,\n+                                                                                      ValueSelf,\n+                                                                                      AnyType,\n+                                                                                      \"std::ops::Rem\"),\n+                                                                                     (\"shl\",\n+                                                                                      2,\n+                                                                                      ValueSelf,\n+                                                                                      AnyType,\n+                                                                                      \"std::ops::Shl\"),\n+                                                                                     (\"shr\",\n+                                                                                      2,\n+                                                                                      ValueSelf,\n+                                                                                      AnyType,\n+                                                                                      \"std::ops::Shr\"),\n+                                                                                     (\"bitand\",\n+                                                                                      2,\n+                                                                                      ValueSelf,\n+                                                                                      AnyType,\n+                                                                                      \"std::ops::BitAnd\"),\n+                                                                                     (\"bitor\",\n+                                                                                      2,\n+                                                                                      ValueSelf,\n+                                                                                      AnyType,\n+                                                                                      \"std::ops::BitOr\"),\n+                                                                                     (\"bitxor\",\n+                                                                                      2,\n+                                                                                      ValueSelf,\n+                                                                                      AnyType,\n+                                                                                      \"std::ops::BitXor\"),\n+                                                                                     (\"neg\",\n+                                                                                      1,\n+                                                                                      ValueSelf,\n+                                                                                      AnyType,\n+                                                                                      \"std::ops::Neg\"),\n+                                                                                     (\"not\",\n+                                                                                      1,\n+                                                                                      ValueSelf,\n+                                                                                      AnyType,\n+                                                                                      \"std::ops::Not\"),\n+                                                                                     (\"drop\",\n+                                                                                      1,\n+                                                                                      RefMutSelf,\n+                                                                                      UnitType,\n+                                                                                      \"std::ops::Drop\"),\n+                                                                                     (\"index\",\n+                                                                                      2,\n+                                                                                      RefSelf,\n+                                                                                      RefType,\n+                                                                                      \"std::ops::Index\"),\n+                                                                                     (\"index_mut\",\n+                                                                                      2,\n+                                                                                      RefMutSelf,\n+                                                                                      RefType,\n+                                                                                      \"std::ops::IndexMut\"),\n+                                                                                     (\"deref\",\n+                                                                                      1,\n+                                                                                      RefSelf,\n+                                                                                      RefType,\n+                                                                                      \"std::ops::Deref\"),\n+                                                                                     (\"deref_mut\",\n+                                                                                      1,\n+                                                                                      RefMutSelf,\n+                                                                                      RefType,\n+                                                                                      \"std::ops::DerefMut\"),\n+                                                                                     (\"clone\",\n+                                                                                      1,\n+                                                                                      RefSelf,\n+                                                                                      AnyType,\n+                                                                                      \"std::clone::Clone\"),\n+                                                                                     (\"borrow\",\n+                                                                                      1,\n+                                                                                      RefSelf,\n+                                                                                      RefType,\n+                                                                                      \"std::borrow::Borrow\"),\n+                                                                                     (\"borrow_mut\",\n+                                                                                      1,\n+                                                                                      RefMutSelf,\n+                                                                                      RefType,\n+                                                                                      \"std::borrow::BorrowMut\"),\n+                                                                                     (\"as_ref\",\n+                                                                                      1,\n+                                                                                      RefSelf,\n+                                                                                      RefType,\n+                                                                                      \"std::convert::AsRef\"),\n+                                                                                     (\"as_mut\",\n+                                                                                      1,\n+                                                                                      RefMutSelf,\n+                                                                                      RefType,\n+                                                                                      \"std::convert::AsMut\"),\n+                                                                                     (\"eq\",\n+                                                                                      2,\n+                                                                                      RefSelf,\n+                                                                                      BoolType,\n+                                                                                      \"std::cmp::PartialEq\"),\n+                                                                                     (\"cmp\",\n+                                                                                      2,\n+                                                                                      RefSelf,\n+                                                                                      AnyType,\n+                                                                                      \"std::cmp::Ord\"),\n+                                                                                     (\"default\",\n+                                                                                      0,\n+                                                                                      NoSelf,\n+                                                                                      AnyType,\n+                                                                                      \"std::default::Default\"),\n+                                                                                     (\"hash\",\n+                                                                                      2,\n+                                                                                      RefSelf,\n+                                                                                      UnitType,\n+                                                                                      \"std::hash::Hash\"),\n+                                                                                     (\"next\",\n+                                                                                      1,\n+                                                                                      RefMutSelf,\n+                                                                                      AnyType,\n+                                                                                      \"std::iter::Iterator\"),\n+                                                                                     (\"into_iter\",\n+                                                                                      1,\n+                                                                                      ValueSelf,\n+                                                                                      AnyType,\n+                                                                                      \"std::iter::IntoIterator\"),\n+                                                                                     (\"from_iter\",\n+                                                                                      1,\n+                                                                                      NoSelf,\n+                                                                                      AnyType,\n+                                                                                      \"std::iter::FromIterator\"),\n+                                                                                     (\"from_str\",\n+                                                                                      1,\n+                                                                                      NoSelf,\n+                                                                                      AnyType,\n+                                                                                      \"std::str::FromStr\")];\n \n #[derive(Clone, Copy)]\n enum SelfKind {\n@@ -506,7 +642,7 @@ impl SelfKind {\n             (&RefMutSelf, &SelfValue(_)) => allow_value_for_ref,\n             (&NoSelf, &SelfStatic) => true,\n             (_, &SelfExplicit(ref ty, _)) => self.matches_explicit_type(ty, allow_value_for_ref),\n-            _ => false\n+            _ => false,\n         }\n     }\n \n@@ -517,7 +653,7 @@ impl SelfKind {\n             (&RefMutSelf, &TyRptr(_, MutTy { mutbl: Mutability::MutMutable, .. })) => true,\n             (&RefSelf, &TyPath(..)) => allow_value_for_ref,\n             (&RefMutSelf, &TyPath(..)) => allow_value_for_ref,\n-            _ => false\n+            _ => false,\n         }\n     }\n \n@@ -545,11 +681,15 @@ impl OutType {\n             (&UnitType, &DefaultReturn(_)) => true,\n             (&UnitType, &Return(ref ty)) if ty.node == TyTup(vec![].into()) => true,\n             (&BoolType, &Return(ref ty)) if is_bool(ty) => true,\n-            (&AnyType, &Return(ref ty)) if ty.node != TyTup(vec![].into())  => true,\n+            (&AnyType, &Return(ref ty)) if ty.node != TyTup(vec![].into()) => true,\n             (&RefType, &Return(ref ty)) => {\n-                if let TyRptr(_, _) = ty.node { true } else { false }\n+                if let TyRptr(_, _) = ty.node {\n+                    true\n+                } else {\n+                    false\n+                }\n             }\n-            _ => false\n+            _ => false,\n         }\n     }\n }"}, {"sha": "2cce36f2a9c9a610f8af59995a265f0609e1a827", "filename": "src/minmax.rs", "status": "modified", "additions": 23, "deletions": 12, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fminmax.rs?ref=c9342d01213ca1663d2cdf23289bae024823ae6a", "patch": "@@ -32,12 +32,13 @@ impl LateLintPass for MinMaxPass {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if let Some((outer_max, outer_c, oe)) = min_max(cx, expr) {\n             if let Some((inner_max, inner_c, _)) = min_max(cx, oe) {\n-                if outer_max == inner_max { return; }\n+                if outer_max == inner_max {\n+                    return;\n+                }\n                 match (outer_max, outer_c.partial_cmp(&inner_c)) {\n                     (_, None) | (Max, Some(Less)) | (Min, Some(Greater)) => (),\n                     _ => {\n-                        span_lint(cx, MIN_MAX, expr.span,\n-                            \"this min/max combination leads to constant result\");\n+                        span_lint(cx, MIN_MAX, expr.span, \"this min/max combination leads to constant result\");\n                     }\n                 }\n             }\n@@ -65,20 +66,30 @@ fn min_max<'a>(cx: &LateContext, expr: &'a Expr) -> Option<(MinMax, Constant, &'\n                     None\n                 }\n             }\n-        } else { None }\n-    } else { None }\n- }\n+        } else {\n+            None\n+        }\n+    } else {\n+        None\n+    }\n+}\n \n-fn fetch_const(args: &[P<Expr>], m: MinMax) ->\n-        Option<(MinMax, Constant, &Expr)> {\n-    if args.len() != 2 { return None }\n+fn fetch_const(args: &[P<Expr>], m: MinMax) -> Option<(MinMax, Constant, &Expr)> {\n+    if args.len() != 2 {\n+        return None;\n+    }\n     if let Some(c) = constant_simple(&args[0]) {\n-        if let None = constant_simple(&args[1]) { // otherwise ignore\n+        if let None = constant_simple(&args[1]) {\n+            // otherwise ignore\n             Some((m, c, &args[1]))\n-        } else { None }\n+        } else {\n+            None\n+        }\n     } else {\n         if let Some(c) = constant_simple(&args[1]) {\n             Some((m, c, &args[0]))\n-        } else { None }\n+        } else {\n+            None\n+        }\n     }\n }"}, {"sha": "1b7f2a921b965a7a2dbfacad2e820df67c7cd059", "filename": "src/misc.rs", "status": "modified", "additions": 83, "deletions": 62, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmisc.rs?ref=c9342d01213ca1663d2cdf23289bae024823ae6a", "patch": "@@ -40,15 +40,14 @@ impl LateLintPass for TopLevelRefPass {\n     fn check_fn(&mut self, cx: &LateContext, k: FnKind, decl: &FnDecl, _: &Block, _: Span, _: NodeId) {\n         if let FnKind::Closure = k {\n             // Does not apply to closures\n-            return\n+            return;\n         }\n         for ref arg in &decl.inputs {\n             if let PatIdent(BindByRef(_), _, _) = arg.pat.node {\n                 span_lint(cx,\n-                    TOPLEVEL_REF_ARG,\n-                    arg.pat.span,\n-                    \"`ref` directly on a function argument is ignored. Consider using a reference type instead.\"\n-                );\n+                          TOPLEVEL_REF_ARG,\n+                          arg.pat.span,\n+                          \"`ref` directly on a function argument is ignored. Consider using a reference type instead.\");\n             }\n         }\n     }\n@@ -112,9 +111,13 @@ impl LateLintPass for CmpNan {\n }\n \n fn check_nan(cx: &LateContext, path: &Path, span: Span) {\n-    path.segments.last().map(|seg| if seg.identifier.name.as_str() == \"NAN\" {\n-        span_lint(cx, CMP_NAN, span,\n-            \"doomed comparison with NAN, use `std::{f32,f64}::is_nan()` instead\");\n+    path.segments.last().map(|seg| {\n+        if seg.identifier.name.as_str() == \"NAN\" {\n+            span_lint(cx,\n+                      CMP_NAN,\n+                      span,\n+                      \"doomed comparison with NAN, use `std::{f32,f64}::is_nan()` instead\");\n+        }\n     });\n }\n \n@@ -144,20 +147,24 @@ impl LateLintPass for FloatCmp {\n         if let ExprBinary(ref cmp, ref left, ref right) = expr.node {\n             let op = cmp.node;\n             if (op == BiEq || op == BiNe) && (is_float(cx, left) || is_float(cx, right)) {\n-                if is_allowed(cx, left) || is_allowed(cx, right) { return; }\n+                if is_allowed(cx, left) || is_allowed(cx, right) {\n+                    return;\n+                }\n                 if let Some(name) = get_item_name(cx, expr) {\n                     let name = name.as_str();\n-                    if name == \"eq\" || name == \"ne\" || name == \"is_nan\" ||\n-                            name.starts_with(\"eq_\") ||\n-                            name.ends_with(\"_eq\") {\n+                    if name == \"eq\" || name == \"ne\" || name == \"is_nan\" || name.starts_with(\"eq_\") ||\n+                       name.ends_with(\"_eq\") {\n                         return;\n                     }\n                 }\n-                span_lint(cx, FLOAT_CMP, expr.span, &format!(\n-                    \"{}-comparison of f32 or f64 detected. Consider changing this to \\\n-                     `abs({} - {}) < epsilon` for some suitable value of epsilon\",\n-                    binop_to_string(op), snippet(cx, left.span, \"..\"),\n-                    snippet(cx, right.span, \"..\")));\n+                span_lint(cx,\n+                          FLOAT_CMP,\n+                          expr.span,\n+                          &format!(\"{}-comparison of f32 or f64 detected. Consider changing this to `abs({} - {}) < \\\n+                                    epsilon` for some suitable value of epsilon\",\n+                                   binop_to_string(op),\n+                                   snippet(cx, left.span, \"..\"),\n+                                   snippet(cx, right.span, \"..\")));\n             }\n         }\n     }\n@@ -167,7 +174,9 @@ fn is_allowed(cx: &LateContext, expr: &Expr) -> bool {\n     let res = eval_const_expr_partial(cx.tcx, expr, ExprTypeChecked, None);\n     if let Ok(Float(val)) = res {\n         val == 0.0 || val == ::std::f64::INFINITY || val == ::std::f64::NEG_INFINITY\n-    } else { false }\n+    } else {\n+        false\n+    }\n }\n \n fn is_float(cx: &LateContext, expr: &Expr) -> bool {\n@@ -211,44 +220,54 @@ impl LateLintPass for CmpOwned {\n fn check_to_owned(cx: &LateContext, expr: &Expr, other_span: Span, left: bool, op: Span) {\n     let snip = match expr.node {\n         ExprMethodCall(Spanned{node: ref name, ..}, _, ref args) if args.len() == 1 => {\n-            if name.as_str() == \"to_string\" ||\n-                name.as_str() == \"to_owned\" && is_str_arg(cx, args) {\n-                    snippet(cx, args[0].span, \"..\")\n-                } else {\n-                    return\n-                }\n+            if name.as_str() == \"to_string\" || name.as_str() == \"to_owned\" && is_str_arg(cx, args) {\n+                snippet(cx, args[0].span, \"..\")\n+            } else {\n+                return;\n+            }\n         }\n         ExprCall(ref path, ref v) if v.len() == 1 => {\n             if let ExprPath(None, ref path) = path.node {\n-                if match_path(path, &[\"String\", \"from_str\"]) ||\n-                    match_path(path, &[\"String\", \"from\"]) {\n-                            snippet(cx, v[0].span, \"..\")\n-                    } else {\n-                        return\n-                    }\n+                if match_path(path, &[\"String\", \"from_str\"]) || match_path(path, &[\"String\", \"from\"]) {\n+                    snippet(cx, v[0].span, \"..\")\n+                } else {\n+                    return;\n+                }\n             } else {\n-                return\n+                return;\n             }\n         }\n-        _ => return\n+        _ => return,\n     };\n     if left {\n-        span_lint(cx, CMP_OWNED, expr.span, &format!(\n-        \"this creates an owned instance just for comparison. Consider using \\\n-        `{} {} {}` to compare without allocation\", snip,\n-        snippet(cx, op, \"==\"), snippet(cx, other_span, \"..\")));\n+        span_lint(cx,\n+                  CMP_OWNED,\n+                  expr.span,\n+                  &format!(\"this creates an owned instance just for comparison. Consider using `{} {} {}` to \\\n+                            compare without allocation\",\n+                           snip,\n+                           snippet(cx, op, \"==\"),\n+                           snippet(cx, other_span, \"..\")));\n     } else {\n-        span_lint(cx, CMP_OWNED, expr.span, &format!(\n-        \"this creates an owned instance just for comparison. Consider using \\\n-        `{} {} {}` to compare without allocation\",\n-        snippet(cx, other_span, \"..\"), snippet(cx, op, \"==\"),  snip));\n+        span_lint(cx,\n+                  CMP_OWNED,\n+                  expr.span,\n+                  &format!(\"this creates an owned instance just for comparison. Consider using `{} {} {}` to \\\n+                            compare without allocation\",\n+                           snippet(cx, other_span, \"..\"),\n+                           snippet(cx, op, \"==\"),\n+                           snip));\n     }\n \n }\n \n fn is_str_arg(cx: &LateContext, args: &[P<Expr>]) -> bool {\n-    args.len() == 1 && if let ty::TyStr =\n-        walk_ptrs_ty(cx.tcx.expr_ty(&args[0])).sty { true } else { false }\n+    args.len() == 1 &&\n+    if let ty::TyStr = walk_ptrs_ty(cx.tcx.expr_ty(&args[0])).sty {\n+        true\n+    } else {\n+        false\n+    }\n }\n \n /// **What it does:** This lint checks for getting the remainder of a division by one. It is `Warn` by default.\n@@ -309,9 +328,11 @@ impl LateLintPass for PatternPass {\n     fn check_pat(&mut self, cx: &LateContext, pat: &Pat) {\n         if let PatIdent(_, ref ident, Some(ref right)) = pat.node {\n             if right.node == PatWild {\n-                cx.span_lint(REDUNDANT_PATTERN, pat.span, &format!(\n-                    \"the `{} @ _` pattern can be written as just `{}`\",\n-                    ident.node.name, ident.node.name));\n+                cx.span_lint(REDUNDANT_PATTERN,\n+                             pat.span,\n+                             &format!(\"the `{} @ _` pattern can be written as just `{}`\",\n+                                      ident.node.name,\n+                                      ident.node.name));\n             }\n         }\n     }\n@@ -345,30 +366,31 @@ impl LintPass for UsedUnderscoreBinding {\n \n impl LateLintPass for UsedUnderscoreBinding {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n-        if in_attributes_expansion(cx, expr) { // Don't lint things expanded by #[derive(...)], etc\n+        if in_attributes_expansion(cx, expr) {\n+            // Don't lint things expanded by #[derive(...)], etc\n             return;\n         }\n         let needs_lint = match expr.node {\n             ExprPath(_, ref path) => {\n-                let ident = path.segments.last()\n+                let ident = path.segments\n+                                .last()\n                                 .expect(\"path should always have at least one segment\")\n                                 .identifier;\n-                ident.name.as_str().chars().next() == Some('_') //starts with '_'\n-                && ident.name.as_str().chars().skip(1).next() != Some('_') //doesn't start with \"__\"\n-                && ident.name != ident.unhygienic_name //not in bang macro\n-                && is_used(cx, expr)\n-            },\n+                ident.name.as_str().chars().next() == Some('_') &&\n+                ident.name.as_str().chars().skip(1).next() != Some('_') &&\n+                ident.name != ident.unhygienic_name && is_used(cx, expr)\n+            }\n             ExprField(_, spanned) => {\n                 let name = spanned.node.as_str();\n-                name.chars().next() == Some('_')\n-                && name.chars().skip(1).next() != Some('_')\n-            },\n-            _ => false\n+                name.chars().next() == Some('_') && name.chars().skip(1).next() != Some('_')\n+            }\n+            _ => false,\n         };\n         if needs_lint {\n-            cx.span_lint(USED_UNDERSCORE_BINDING, expr.span,\n-                         \"used binding which is prefixed with an underscore. A leading underscore \\\n-                          signals that a binding will not be used.\");\n+            cx.span_lint(USED_UNDERSCORE_BINDING,\n+                         expr.span,\n+                         \"used binding which is prefixed with an underscore. A leading underscore signals that a \\\n+                          binding will not be used.\");\n         }\n     }\n }\n@@ -380,10 +402,9 @@ fn is_used(cx: &LateContext, expr: &Expr) -> bool {\n         match parent.node {\n             ExprAssign(_, ref rhs) => **rhs == *expr,\n             ExprAssignOp(_, _, ref rhs) => **rhs == *expr,\n-            _ => is_used(cx, &parent)\n+            _ => is_used(cx, &parent),\n         }\n-    }\n-    else {\n+    } else {\n         true\n     }\n }"}, {"sha": "a90c901df8f943ac5849020b2c5127b24403c4cf", "filename": "src/misc_early.rs", "status": "modified", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Fmisc_early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Fmisc_early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmisc_early.rs?ref=c9342d01213ca1663d2cdf23289bae024823ae6a", "patch": "@@ -52,15 +52,15 @@ impl EarlyLintPass for MiscEarly {\n                 }\n             }\n             if !pfields.is_empty() && wilds == pfields.len() {\n-                span_help_and_lint(cx, UNNEEDED_FIELD_PATTERN, pat.span,\n-                                   \"All the struct fields are matched to a wildcard pattern, \\\n-                                    consider using `..`.\",\n-                                   &format!(\"Try with `{} {{ .. }}` instead\",\n-                                            type_name));\n+                span_help_and_lint(cx,\n+                                   UNNEEDED_FIELD_PATTERN,\n+                                   pat.span,\n+                                   \"All the struct fields are matched to a wildcard pattern, consider using `..`.\",\n+                                   &format!(\"Try with `{} {{ .. }}` instead\", type_name));\n                 return;\n             }\n             if wilds > 0 {\n-                let mut normal = vec!();\n+                let mut normal = vec![];\n \n                 for field in pfields {\n                     if field.node.pat.node != PatWild {\n@@ -73,13 +73,16 @@ impl EarlyLintPass for MiscEarly {\n                     if field.node.pat.node == PatWild {\n                         wilds -= 1;\n                         if wilds > 0 {\n-                            span_lint(cx, UNNEEDED_FIELD_PATTERN, field.span,\n-                                      \"You matched a field with a wildcard pattern. \\\n-                                       Consider using `..` instead\");\n+                            span_lint(cx,\n+                                      UNNEEDED_FIELD_PATTERN,\n+                                      field.span,\n+                                      \"You matched a field with a wildcard pattern. Consider using `..` instead\");\n                         } else {\n-                            span_help_and_lint(cx, UNNEEDED_FIELD_PATTERN, field.span,\n-                                               \"You matched a field with a wildcard pattern. \\\n-                                                Consider using `..` instead\",\n+                            span_help_and_lint(cx,\n+                                               UNNEEDED_FIELD_PATTERN,\n+                                               field.span,\n+                                               \"You matched a field with a wildcard pattern. Consider using `..` \\\n+                                                instead\",\n                                                &format!(\"Try with `{} {{ {}, .. }}`\",\n                                                         type_name,\n                                                         normal[..].join(\", \")));\n@@ -91,18 +94,20 @@ impl EarlyLintPass for MiscEarly {\n     }\n \n     fn check_fn(&mut self, cx: &EarlyContext, _: FnKind, decl: &FnDecl, _: &Block, _: Span, _: NodeId) {\n-        let mut registered_names : HashMap<String, Span> = HashMap::new();\n+        let mut registered_names: HashMap<String, Span> = HashMap::new();\n \n         for ref arg in &decl.inputs {\n             if let PatIdent(_, sp_ident, None) = arg.pat.node {\n                 let arg_name = sp_ident.node.to_string();\n \n                 if arg_name.starts_with(\"_\") {\n                     if let Some(correspondance) = registered_names.get(&arg_name[1..]) {\n-                        span_lint(cx, DUPLICATE_UNDERSCORE_ARGUMENT, *correspondance,\n-                                  &format!(\"`{}` already exists, having another argument having almost \\\n-                                            the same name makes code comprehension and documentation \\\n-                                            more difficult\", arg_name[1..].to_owned()));\n+                        span_lint(cx,\n+                                  DUPLICATE_UNDERSCORE_ARGUMENT,\n+                                  *correspondance,\n+                                  &format!(\"`{}` already exists, having another argument having almost the same \\\n+                                            name makes code comprehension and documentation more difficult\",\n+                                           arg_name[1..].to_owned()));\n                     }\n                 } else {\n                     registered_names.insert(arg_name, arg.pat.span.clone());"}, {"sha": "1bdb4e9a3d6f7064ad3b25cf5d6e618d68fb277f", "filename": "src/mut_mut.rs", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmut_mut.rs?ref=c9342d01213ca1663d2cdf23289bae024823ae6a", "patch": "@@ -30,42 +30,46 @@ impl LateLintPass for MutMut {\n     }\n \n     fn check_ty(&mut self, cx: &LateContext, ty: &Ty) {\n-        unwrap_mut(ty).and_then(unwrap_mut).map_or((), |_| { span_lint(cx, MUT_MUT,\n-            ty.span, \"generally you want to avoid `&mut &mut _` if possible\"); });\n+        unwrap_mut(ty).and_then(unwrap_mut).map_or((), |_| {\n+            span_lint(cx, MUT_MUT, ty.span, \"generally you want to avoid `&mut &mut _` if possible\");\n+        });\n     }\n }\n \n fn check_expr_mut(cx: &LateContext, expr: &Expr) {\n-    if in_external_macro(cx, expr.span) { return; }\n+    if in_external_macro(cx, expr.span) {\n+        return;\n+    }\n \n     fn unwrap_addr(expr: &Expr) -> Option<&Expr> {\n         match expr.node {\n             ExprAddrOf(MutMutable, ref e) => Some(e),\n-            _ => None\n+            _ => None,\n         }\n     }\n \n     unwrap_addr(expr).map_or((), |e| {\n-        unwrap_addr(e).map_or_else(\n-            || {\n-                if let TyRef(_, TypeAndMut{mutbl: MutMutable, ..}) =\n-                    cx.tcx.expr_ty(e).sty {\n-                        span_lint(cx, MUT_MUT, expr.span,\n-                                  \"this expression mutably borrows a mutable reference. \\\n-                                   Consider reborrowing\");\n-                }\n-            },\n-            |_| {\n-                span_lint(cx, MUT_MUT, expr.span,\n-                          \"generally you want to avoid `&mut &mut _` if possible\");\n-            }\n-        )\n+        unwrap_addr(e).map_or_else(|| {\n+                                       if let TyRef(_, TypeAndMut{mutbl: MutMutable, ..}) = cx.tcx.expr_ty(e).sty {\n+                                           span_lint(cx,\n+                                                     MUT_MUT,\n+                                                     expr.span,\n+                                                     \"this expression mutably borrows a mutable reference. Consider \\\n+                                                      reborrowing\");\n+                                       }\n+                                   },\n+                                   |_| {\n+                                       span_lint(cx,\n+                                                 MUT_MUT,\n+                                                 expr.span,\n+                                                 \"generally you want to avoid `&mut &mut _` if possible\");\n+                                   })\n     })\n }\n \n fn unwrap_mut(ty: &Ty) -> Option<&Ty> {\n     match ty.node {\n         TyRptr(_, MutTy{ ty: ref pty, mutbl: MutMutable }) => Some(pty),\n-        _ => None\n+        _ => None,\n     }\n }"}, {"sha": "d92e449e7f2f7a7e3db3c510ffb4ff2d5d46c1bc", "filename": "src/mut_reference.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmut_reference.rs?ref=c9342d01213ca1663d2cdf23289bae024823ae6a", "patch": "@@ -36,22 +36,22 @@ impl LateLintPass for UnnecessaryMutPassed {\n                 match borrowed_table.node_types.get(&fn_expr.id) {\n                     Some(function_type) => {\n                         if let ExprPath(_, ref path) = fn_expr.node {\n-                            check_arguments(cx, &arguments, function_type,\n-                                            &format!(\"{}\", path));\n+                            check_arguments(cx, &arguments, function_type, &format!(\"{}\", path));\n                         }\n                     }\n                     None => unreachable!(), // A function with unknown type is called.\n-                                            // If this happened the compiler would have aborted the\n-                                            // compilation long ago.\n+                    // If this happened the compiler would have aborted the\n+                    // compilation long ago.\n                 };\n \n \n             }\n             ExprMethodCall(ref name, _, ref arguments) => {\n                 let method_call = MethodCall::expr(e.id);\n                 match borrowed_table.method_map.get(&method_call) {\n-                    Some(method_type) => check_arguments(cx, &arguments, method_type.ty,\n-                                                         &format!(\"{}\", name.node.as_str())),\n+                    Some(method_type) => {\n+                        check_arguments(cx, &arguments, method_type.ty, &format!(\"{}\", name.node.as_str()))\n+                    }\n                     None => unreachable!(), // Just like above, this should never happen.\n                 };\n             }\n@@ -68,10 +68,10 @@ fn check_arguments(cx: &LateContext, arguments: &[P<Expr>], type_definition: &Ty\n                 TypeVariants::TyRef(_, TypeAndMut {mutbl: MutImmutable, ..}) |\n                 TypeVariants::TyRawPtr(TypeAndMut {mutbl: MutImmutable, ..}) => {\n                     if let ExprAddrOf(MutMutable, _) = argument.node {\n-                        span_lint(cx, UNNECESSARY_MUT_PASSED,\n-                                  argument.span, &format!(\"The function/method \\\"{}\\\" \\\n-                                  doesn't need a mutable reference\",\n-                                  name));\n+                        span_lint(cx,\n+                                  UNNECESSARY_MUT_PASSED,\n+                                  argument.span,\n+                                  &format!(\"The function/method \\\"{}\\\" doesn't need a mutable reference\", name));\n                     }\n                 }\n                 _ => {}"}, {"sha": "7b75bd747bb9e34aacda18fefd5781441c1cca31", "filename": "src/mutex_atomic.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Fmutex_atomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Fmutex_atomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmutex_atomic.rs?ref=c9342d01213ca1663d2cdf23289bae024823ae6a", "patch": "@@ -52,17 +52,13 @@ impl LateLintPass for MutexAtomic {\n             if match_type(cx, ty, &MUTEX_PATH) {\n                 let mutex_param = &subst.types.get(ParamSpace::TypeSpace, 0).sty;\n                 if let Some(atomic_name) = get_atomic_name(mutex_param) {\n-                    let msg = format!(\"Consider using an {} instead of a \\\n-                                       Mutex here. If you just want the \\\n-                                       locking behaviour and not the internal \\\n-                                       type, consider using Mutex<()>.\",\n+                    let msg = format!(\"Consider using an {} instead of a Mutex here. If you just want the locking \\\n+                                       behaviour and not the internal type, consider using Mutex<()>.\",\n                                       atomic_name);\n                     match *mutex_param {\n-                        ty::TyUint(t) if t != ast::TyUs =>\n-                            span_lint(cx, MUTEX_INTEGER, expr.span, &msg),\n-                        ty::TyInt(t) if t != ast::TyIs =>\n-                            span_lint(cx, MUTEX_INTEGER, expr.span, &msg),\n-                        _ => span_lint(cx, MUTEX_ATOMIC, expr.span, &msg)\n+                        ty::TyUint(t) if t != ast::TyUs => span_lint(cx, MUTEX_INTEGER, expr.span, &msg),\n+                        ty::TyInt(t) if t != ast::TyIs => span_lint(cx, MUTEX_INTEGER, expr.span, &msg),\n+                        _ => span_lint(cx, MUTEX_ATOMIC, expr.span, &msg),\n                     };\n                 }\n             }\n@@ -76,6 +72,6 @@ fn get_atomic_name(ty: &ty::TypeVariants) -> Option<(&'static str)> {\n         ty::TyUint(_) => Some(\"AtomicUsize\"),\n         ty::TyInt(_) => Some(\"AtomicIsize\"),\n         ty::TyRawPtr(_) => Some(\"AtomicPtr\"),\n-        _ => None\n+        _ => None,\n     }\n }"}, {"sha": "22edbc272bddb69f55629ae81828da750c73c3ee", "filename": "src/needless_bool.rs", "status": "modified", "additions": 32, "deletions": 13, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fneedless_bool.rs?ref=c9342d01213ca1663d2cdf23289bae024823ae6a", "patch": "@@ -37,30 +37,42 @@ impl LateLintPass for NeedlessBool {\n         if let ExprIf(ref pred, ref then_block, Some(ref else_expr)) = e.node {\n             match (fetch_bool_block(then_block), fetch_bool_expr(else_expr)) {\n                 (Some(true), Some(true)) => {\n-                    span_lint(cx, NEEDLESS_BOOL, e.span,\n+                    span_lint(cx,\n+                              NEEDLESS_BOOL,\n+                              e.span,\n                               \"this if-then-else expression will always return true\");\n                 }\n                 (Some(false), Some(false)) => {\n-                    span_lint(cx, NEEDLESS_BOOL, e.span,\n+                    span_lint(cx,\n+                              NEEDLESS_BOOL,\n+                              e.span,\n                               \"this if-then-else expression will always return false\");\n                 }\n                 (Some(true), Some(false)) => {\n                     let pred_snip = snippet(cx, pred.span, \"..\");\n-                    let hint = if pred_snip == \"..\" { \"its predicate\".into() } else {\n+                    let hint = if pred_snip == \"..\" {\n+                        \"its predicate\".into()\n+                    } else {\n                         format!(\"`{}`\", pred_snip)\n                     };\n-                    span_lint(cx, NEEDLESS_BOOL, e.span, &format!(\n-                        \"you can reduce this if-then-else expression to just {}\", hint));\n+                    span_lint(cx,\n+                              NEEDLESS_BOOL,\n+                              e.span,\n+                              &format!(\"you can reduce this if-then-else expression to just {}\", hint));\n                 }\n                 (Some(false), Some(true)) => {\n                     let pred_snip = snippet(cx, pred.span, \"..\");\n-                    let hint = if pred_snip == \"..\" { \"`!` and its predicate\".into() } else {\n+                    let hint = if pred_snip == \"..\" {\n+                        \"`!` and its predicate\".into()\n+                    } else {\n                         format!(\"`!{}`\", pred_snip)\n                     };\n-                    span_lint(cx, NEEDLESS_BOOL, e.span, &format!(\n-                        \"you can reduce this if-then-else expression to just {}\", hint));\n+                    span_lint(cx,\n+                              NEEDLESS_BOOL,\n+                              e.span,\n+                              &format!(\"you can reduce this if-then-else expression to just {}\", hint));\n                 }\n-                _ => ()\n+                _ => (),\n             }\n         }\n     }\n@@ -69,14 +81,21 @@ impl LateLintPass for NeedlessBool {\n fn fetch_bool_block(block: &Block) -> Option<bool> {\n     if block.stmts.is_empty() {\n         block.expr.as_ref().and_then(|e| fetch_bool_expr(e))\n-    } else { None }\n+    } else {\n+        None\n+    }\n }\n \n fn fetch_bool_expr(expr: &Expr) -> Option<bool> {\n     match expr.node {\n         ExprBlock(ref block) => fetch_bool_block(block),\n-        ExprLit(ref lit_ptr) => if let LitBool(value) = lit_ptr.node {\n-            Some(value) } else { None },\n-        _ => None\n+        ExprLit(ref lit_ptr) => {\n+            if let LitBool(value) = lit_ptr.node {\n+                Some(value)\n+            } else {\n+                None\n+            }\n+        }\n+        _ => None,\n     }\n }"}, {"sha": "2c293d046005e35f015f7c3616acc1dd859ef363", "filename": "src/needless_features.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Fneedless_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Fneedless_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fneedless_features.rs?ref=c9342d01213ca1663d2cdf23289bae024823ae6a", "patch": "@@ -49,14 +49,16 @@ impl LateLintPass for NeedlessFeaturesPass {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if let ExprMethodCall(ref name, _, _) = expr.node {\n             if name.node.as_str() == \"as_slice\" && check_paths(cx, expr) {\n-                span_lint(cx, UNSTABLE_AS_SLICE, expr.span,\n-                          \"used as_slice() from the 'convert' nightly feature. Use &[..] \\\n-                           instead\");\n+                span_lint(cx,\n+                          UNSTABLE_AS_SLICE,\n+                          expr.span,\n+                          \"used as_slice() from the 'convert' nightly feature. Use &[..] instead\");\n             }\n             if name.node.as_str() == \"as_mut_slice\" && check_paths(cx, expr) {\n-                span_lint(cx, UNSTABLE_AS_MUT_SLICE, expr.span,\n-                          \"used as_mut_slice() from the 'convert' nightly feature. Use &mut [..] \\\n-                           instead\");\n+                span_lint(cx,\n+                          UNSTABLE_AS_MUT_SLICE,\n+                          expr.span,\n+                          \"used as_mut_slice() from the 'convert' nightly feature. Use &mut [..] instead\");\n             }\n         }\n     }"}, {"sha": "1b306df8eed540300769506be143ca2e78cf8cf0", "filename": "src/needless_update.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Fneedless_update.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Fneedless_update.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fneedless_update.rs?ref=c9342d01213ca1663d2cdf23289bae024823ae6a", "patch": "@@ -32,9 +32,10 @@ impl LateLintPass for NeedlessUpdatePass {\n             let ty = cx.tcx.expr_ty(expr);\n             if let TyStruct(def, _) = ty.sty {\n                 if fields.len() == def.struct_variant().fields.len() {\n-                    span_lint(cx, NEEDLESS_UPDATE, base.span,\n-                              \"struct update has no effect, all the fields \\\n-                              in the struct have already been specified\");\n+                    span_lint(cx,\n+                              NEEDLESS_UPDATE,\n+                              base.span,\n+                              \"struct update has no effect, all the fields in the struct have already been specified\");\n                 }\n             }\n         }"}, {"sha": "3b2d91fc78eaf57472fe80160fc3f8af21f30321", "filename": "src/no_effect.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fno_effect.rs?ref=c9342d01213ca1663d2cdf23289bae024823ae6a", "patch": "@@ -37,9 +37,7 @@ fn has_no_effect(cx: &LateContext, expr: &Expr) -> bool {\n             let def = cx.tcx.def_map.borrow().get(&callee.id).map(|d| d.full_def());\n             match def {\n                 Some(DefStruct(..)) |\n-                Some(DefVariant(..)) => {\n-                    args.iter().all(|arg| has_no_effect(cx, arg))\n-                }\n+                Some(DefVariant(..)) => args.iter().all(|arg| has_no_effect(cx, arg)),\n                 _ => false,\n             }\n         }\n@@ -60,8 +58,7 @@ impl LateLintPass for NoEffectPass {\n     fn check_stmt(&mut self, cx: &LateContext, stmt: &Stmt) {\n         if let StmtSemi(ref expr, _) = stmt.node {\n             if has_no_effect(cx, expr) {\n-                span_lint(cx, NO_EFFECT, stmt.span,\n-                          \"statement with no effect\");\n+                span_lint(cx, NO_EFFECT, stmt.span, \"statement with no effect\");\n             }\n         }\n     }"}, {"sha": "26784cb600893d3655a88a653cbd72f5efe250fd", "filename": "src/open_options.rs", "status": "modified", "additions": 119, "deletions": 32, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Fopen_options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Fopen_options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fopen_options.rs?ref=c9342d01213ca1663d2cdf23289bae024823ae6a", "patch": "@@ -31,7 +31,7 @@ impl LateLintPass for NonSensicalOpenOptions {\n     fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n         if let ExprMethodCall(ref name, _, ref arguments) = e.node {\n             let (obj_ty, _) = walk_ptrs_ty_depth(cx.tcx.expr_ty(&arguments[0]));\n-            if name.node.as_str() == \"open\" && match_type(cx, obj_ty, &OPEN_OPTIONS_PATH){\n+            if name.node.as_str() == \"open\" && match_type(cx, obj_ty, &OPEN_OPTIONS_PATH) {\n                 let mut options = Vec::new();\n                 get_open_options(cx, &arguments[0], &mut options);\n                 check_open_options(cx, &options, e.span);\n@@ -44,7 +44,7 @@ impl LateLintPass for NonSensicalOpenOptions {\n enum Argument {\n     True,\n     False,\n-    Unknown\n+    Unknown,\n }\n \n #[derive(Debug)]\n@@ -53,31 +53,33 @@ enum OpenOption {\n     Read,\n     Truncate,\n     Create,\n-    Append\n+    Append,\n }\n \n fn get_open_options(cx: &LateContext, argument: &Expr, options: &mut Vec<(OpenOption, Argument)>) {\n     if let ExprMethodCall(ref name, _, ref arguments) = argument.node {\n         let (obj_ty, _) = walk_ptrs_ty_depth(cx.tcx.expr_ty(&arguments[0]));\n-        \n+\n         // Only proceed if this is a call on some object of type std::fs::OpenOptions\n         if match_type(cx, obj_ty, &OPEN_OPTIONS_PATH) && arguments.len() >= 2 {\n-            \n+\n             let argument_option = match arguments[1].node {\n                 ExprLit(ref span) => {\n                     if let Spanned {node: LitBool(lit), ..} = **span {\n-                        if lit {Argument::True} else {Argument::False}\n+                        if lit {\n+                            Argument::True\n+                        } else {\n+                            Argument::False\n+                        }\n                     } else {\n                         return; // The function is called with a literal\n                                 // which is not a boolean literal. This is theoretically\n                                 // possible, but not very likely.\n                     }\n                 }\n-                _ => {\n-                    Argument::Unknown\n-                }\n+                _ => Argument::Unknown,\n             };\n-            \n+\n             match &*name.node.as_str() {\n                 \"create\" => {\n                     options.push((OpenOption::Create, argument_option));\n@@ -96,47 +98,132 @@ fn get_open_options(cx: &LateContext, argument: &Expr, options: &mut Vec<(OpenOp\n                 }\n                 _ => {}\n             }\n-            \n+\n             get_open_options(cx, &arguments[0], options);\n         }\n     }\n }\n \n fn check_for_duplicates(cx: &LateContext, options: &[(OpenOption, Argument)], span: Span) {\n     // This code is almost duplicated (oh, the irony), but I haven't found a way to unify it.\n-    if options.iter().filter(|o| if let (OpenOption::Create, _) = **o {true} else {false}).count() > 1 {\n-        span_lint(cx, NONSENSICAL_OPEN_OPTIONS, span, \"The method \\\"create\\\" \\\n-                                                       is called more than once\");\n+    if options.iter()\n+              .filter(|o| {\n+                  if let (OpenOption::Create, _) = **o {\n+                      true\n+                  } else {\n+                      false\n+                  }\n+              })\n+              .count() > 1 {\n+        span_lint(cx,\n+                  NONSENSICAL_OPEN_OPTIONS,\n+                  span,\n+                  \"The method \\\"create\\\" is called more than once\");\n     }\n-    if options.iter().filter(|o| if let (OpenOption::Append, _) = **o {true} else {false}).count() > 1 {\n-        span_lint(cx, NONSENSICAL_OPEN_OPTIONS, span, \"The method \\\"append\\\" \\\n-                                                       is called more than once\");\n+    if options.iter()\n+              .filter(|o| {\n+                  if let (OpenOption::Append, _) = **o {\n+                      true\n+                  } else {\n+                      false\n+                  }\n+              })\n+              .count() > 1 {\n+        span_lint(cx,\n+                  NONSENSICAL_OPEN_OPTIONS,\n+                  span,\n+                  \"The method \\\"append\\\" is called more than once\");\n     }\n-    if options.iter().filter(|o| if let (OpenOption::Truncate, _) = **o {true} else {false}).count() > 1 {\n-        span_lint(cx, NONSENSICAL_OPEN_OPTIONS, span, \"The method \\\"truncate\\\" \\\n-                                                       is called more than once\");\n+    if options.iter()\n+              .filter(|o| {\n+                  if let (OpenOption::Truncate, _) = **o {\n+                      true\n+                  } else {\n+                      false\n+                  }\n+              })\n+              .count() > 1 {\n+        span_lint(cx,\n+                  NONSENSICAL_OPEN_OPTIONS,\n+                  span,\n+                  \"The method \\\"truncate\\\" is called more than once\");\n     }\n-    if options.iter().filter(|o| if let (OpenOption::Read, _) = **o {true} else {false}).count() > 1 {\n-        span_lint(cx, NONSENSICAL_OPEN_OPTIONS, span, \"The method \\\"read\\\" \\\n-                                                       is called more than once\");\n+    if options.iter()\n+              .filter(|o| {\n+                  if let (OpenOption::Read, _) = **o {\n+                      true\n+                  } else {\n+                      false\n+                  }\n+              })\n+              .count() > 1 {\n+        span_lint(cx,\n+                  NONSENSICAL_OPEN_OPTIONS,\n+                  span,\n+                  \"The method \\\"read\\\" is called more than once\");\n     }\n-    if options.iter().filter(|o| if let (OpenOption::Write, _) = **o {true} else {false}).count() > 1 {\n-        span_lint(cx, NONSENSICAL_OPEN_OPTIONS, span, \"The method \\\"write\\\" \\\n-                                                       is called more than once\");\n+    if options.iter()\n+              .filter(|o| {\n+                  if let (OpenOption::Write, _) = **o {\n+                      true\n+                  } else {\n+                      false\n+                  }\n+              })\n+              .count() > 1 {\n+        span_lint(cx,\n+                  NONSENSICAL_OPEN_OPTIONS,\n+                  span,\n+                  \"The method \\\"write\\\" is called more than once\");\n     }\n }\n \n fn check_for_inconsistencies(cx: &LateContext, options: &[(OpenOption, Argument)], span: Span) {\n     // Truncate + read makes no sense.\n-    if options.iter().filter(|o| if let (OpenOption::Read, Argument::True) = **o {true} else {false}).count() > 0 &&\n-       options.iter().filter(|o| if let (OpenOption::Truncate, Argument::True) = **o {true} else {false}).count() > 0 {\n+    if options.iter()\n+              .filter(|o| {\n+                  if let (OpenOption::Read, Argument::True) = **o {\n+                      true\n+                  } else {\n+                      false\n+                  }\n+              })\n+              .count() > 0 &&\n+       options.iter()\n+              .filter(|o| {\n+                  if let (OpenOption::Truncate, Argument::True) = **o {\n+                      true\n+                  } else {\n+                      false\n+                  }\n+              })\n+              .count() > 0 {\n         span_lint(cx, NONSENSICAL_OPEN_OPTIONS, span, \"File opened with \\\"truncate\\\" and \\\"read\\\"\");\n     }\n-    \n+\n     // Append + truncate makes no sense.\n-    if options.iter().filter(|o| if let (OpenOption::Append, Argument::True) = **o {true} else {false}).count() > 0 &&\n-       options.iter().filter(|o| if let (OpenOption::Truncate, Argument::True) = **o {true} else {false}).count() > 0 {\n-        span_lint(cx, NONSENSICAL_OPEN_OPTIONS, span, \"File opened with \\\"append\\\" and \\\"truncate\\\"\");\n+    if options.iter()\n+              .filter(|o| {\n+                  if let (OpenOption::Append, Argument::True) = **o {\n+                      true\n+                  } else {\n+                      false\n+                  }\n+              })\n+              .count() > 0 &&\n+       options.iter()\n+              .filter(|o| {\n+                  if let (OpenOption::Truncate, Argument::True) = **o {\n+                      true\n+                  } else {\n+                      false\n+                  }\n+              })\n+              .count() > 0 {\n+        span_lint(cx,\n+                  NONSENSICAL_OPEN_OPTIONS,\n+                  span,\n+                  \"File opened with \\\"append\\\" and \\\"truncate\\\"\");\n     }\n }\n "}, {"sha": "8253471f8b01f64b9d4a7091d12d27cba17f9951", "filename": "src/precedence.rs", "status": "modified", "additions": 40, "deletions": 28, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Fprecedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Fprecedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fprecedence.rs?ref=c9342d01213ca1663d2cdf23289bae024823ae6a", "patch": "@@ -31,29 +31,40 @@ impl LintPass for Precedence {\n impl EarlyLintPass for Precedence {\n     fn check_expr(&mut self, cx: &EarlyContext, expr: &Expr) {\n         if let ExprBinary(Spanned { node: op, ..}, ref left, ref right) = expr.node {\n-            if !is_bit_op(op) { return; }\n+            if !is_bit_op(op) {\n+                return;\n+            }\n             match (is_arith_expr(left), is_arith_expr(right)) {\n                 (true, true) => {\n-                    span_lint(cx, PRECEDENCE, expr.span, \n-                    &format!(\"operator precedence can trip the unwary. \\\n-                         Consider parenthesizing your expression:\\\n-                         `({}) {} ({})`\", snippet(cx, left.span, \"..\"),\n-                         op.to_string(), snippet(cx, right.span, \"..\")));\n-                },\n+                    span_lint(cx,\n+                              PRECEDENCE,\n+                              expr.span,\n+                              &format!(\"operator precedence can trip the unwary. Consider parenthesizing your \\\n+                                        expression:`({}) {} ({})`\",\n+                                       snippet(cx, left.span, \"..\"),\n+                                       op.to_string(),\n+                                       snippet(cx, right.span, \"..\")));\n+                }\n                 (true, false) => {\n-                    span_lint(cx, PRECEDENCE, expr.span, \n-                    &format!(\"operator precedence can trip the unwary. \\\n-                         Consider parenthesizing your expression:\\\n-                         `({}) {} {}`\", snippet(cx, left.span, \"..\"),\n-                         op.to_string(), snippet(cx, right.span, \"..\")));\n-                },\n+                    span_lint(cx,\n+                              PRECEDENCE,\n+                              expr.span,\n+                              &format!(\"operator precedence can trip the unwary. Consider parenthesizing your \\\n+                                        expression:`({}) {} {}`\",\n+                                       snippet(cx, left.span, \"..\"),\n+                                       op.to_string(),\n+                                       snippet(cx, right.span, \"..\")));\n+                }\n                 (false, true) => {\n-                    span_lint(cx, PRECEDENCE, expr.span, \n-                    &format!(\"operator precedence can trip the unwary. \\\n-                         Consider parenthesizing your expression:\\\n-                         `{} {} ({})`\", snippet(cx, left.span, \"..\"),\n-                         op.to_string(), snippet(cx, right.span, \"..\")));\n-                },\n+                    span_lint(cx,\n+                              PRECEDENCE,\n+                              expr.span,\n+                              &format!(\"operator precedence can trip the unwary. Consider parenthesizing your \\\n+                                        expression:`{} {} ({})`\",\n+                                       snippet(cx, left.span, \"..\"),\n+                                       op.to_string(),\n+                                       snippet(cx, right.span, \"..\")));\n+                }\n                 _ => (),\n             }\n         }\n@@ -64,13 +75,14 @@ impl EarlyLintPass for Precedence {\n                     if let ExprLit(ref lit) = slf.node {\n                         match lit.node {\n                             LitInt(..) | LitFloat(..) | LitFloatUnsuffixed(..) => {\n-                                span_lint(cx, PRECEDENCE, expr.span, &format!(\n-                                    \"unary minus has lower precedence than \\\n-                                     method call. Consider adding parentheses \\\n-                                     to clarify your intent: -({})\",\n-                                     snippet(cx, rhs.span, \"..\")));\n+                                span_lint(cx,\n+                                          PRECEDENCE,\n+                                          expr.span,\n+                                          &format!(\"unary minus has lower precedence than method call. Consider \\\n+                                                    adding parentheses to clarify your intent: -({})\",\n+                                                   snippet(cx, rhs.span, \"..\")));\n                             }\n-                            _ => ()\n+                            _ => (),\n                         }\n                     }\n                 }\n@@ -82,20 +94,20 @@ impl EarlyLintPass for Precedence {\n fn is_arith_expr(expr: &Expr) -> bool {\n     match expr.node {\n         ExprBinary(Spanned { node: op, ..}, _, _) => is_arith_op(op),\n-        _ => false\n+        _ => false,\n     }\n }\n \n fn is_bit_op(op: BinOp_) -> bool {\n     match op {\n         BiBitXor | BiBitAnd | BiBitOr | BiShl | BiShr => true,\n-        _ => false\n+        _ => false,\n     }\n }\n \n fn is_arith_op(op: BinOp_) -> bool {\n     match op {\n         BiAdd | BiSub | BiMul | BiDiv | BiRem => true,\n-        _ => false\n+        _ => false,\n     }\n }"}, {"sha": "2e1e16cf22bbd98e0927417348b1d2b18ede8ef2", "filename": "src/ptr_arg.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Fptr_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Fptr_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fptr_arg.rs?ref=c9342d01213ca1663d2cdf23289bae024823ae6a", "patch": "@@ -63,14 +63,17 @@ fn check_fn(cx: &LateContext, decl: &FnDecl) {\n         if let Some(ty) = cx.tcx.ast_ty_to_ty_cache.borrow().get(&arg.ty.id) {\n             if let ty::TyRef(_, ty::TypeAndMut { ty, mutbl: MutImmutable }) = ty.sty {\n                 if match_type(cx, ty, &VEC_PATH) {\n-                    span_lint(cx, PTR_ARG, arg.ty.span,\n-                              \"writing `&Vec<_>` instead of `&[_]` involves one more reference \\\n-                               and cannot be used with non-Vec-based slices. Consider changing \\\n-                               the type to `&[...]`\");\n+                    span_lint(cx,\n+                              PTR_ARG,\n+                              arg.ty.span,\n+                              \"writing `&Vec<_>` instead of `&[_]` involves one more reference and cannot be used \\\n+                               with non-Vec-based slices. Consider changing the type to `&[...]`\");\n                 } else if match_type(cx, ty, &STRING_PATH) {\n-                    span_lint(cx, PTR_ARG, arg.ty.span,\n-                              \"writing `&String` instead of `&str` involves a new object \\\n-                               where a slice will do. Consider changing the type to `&str`\");\n+                    span_lint(cx,\n+                              PTR_ARG,\n+                              arg.ty.span,\n+                              \"writing `&String` instead of `&str` involves a new object where a slice will do. \\\n+                               Consider changing the type to `&str`\");\n                 }\n             }\n         }"}, {"sha": "692a5a2da1db8e6b1f27e4b7ec0782cf2f27e7ba", "filename": "src/ranges.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Franges.rs?ref=c9342d01213ca1663d2cdf23289bae024823ae6a", "patch": "@@ -37,18 +37,15 @@ impl LintPass for StepByZero {\n \n impl LateLintPass for StepByZero {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n-        if let ExprMethodCall(Spanned { node: ref name, .. }, _,\n-                              ref args) = expr.node {\n+        if let ExprMethodCall(Spanned { node: ref name, .. }, _, ref args) = expr.node {\n             // Range with step_by(0).\n-            if name.as_str() == \"step_by\" && args.len() == 2 &&\n-                is_range(cx, &args[0]) && is_integer_literal(&args[1], 0) {\n-                cx.span_lint(RANGE_STEP_BY_ZERO, expr.span,\n-                             \"Range::step_by(0) produces an infinite iterator. \\\n-                              Consider using `std::iter::repeat()` instead\")\n-            }\n-\n-            // x.iter().zip(0..x.len())\n-            else if name.as_str() == \"zip\" && args.len() == 2 {\n+            if name.as_str() == \"step_by\" && args.len() == 2 && is_range(cx, &args[0]) &&\n+               is_integer_literal(&args[1], 0) {\n+                cx.span_lint(RANGE_STEP_BY_ZERO,\n+                             expr.span,\n+                             \"Range::step_by(0) produces an infinite iterator. Consider using `std::iter::repeat()` \\\n+                              instead\")\n+            } else if name.as_str() == \"zip\" && args.len() == 2 {\n                 let iter = &args[0].node;\n                 let zip_arg = &args[1].node;\n                 if_let_chain! {"}, {"sha": "e4745b8766f1bcadcefc947ebc65e00643bbb323", "filename": "src/returns.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Freturns.rs?ref=c9342d01213ca1663d2cdf23289bae024823ae6a", "patch": "@@ -1,6 +1,6 @@\n use rustc::lint::*;\n use syntax::ast::*;\n-//use reexport::*;\n+// use reexport::*;\n use syntax::codemap::{Span, Spanned};\n use syntax::visit::FnKind;\n \n@@ -67,19 +67,17 @@ impl ReturnPass {\n                     self.check_final_expr(cx, &arm.body);\n                 }\n             }\n-            _ => { }\n+            _ => {}\n         }\n     }\n \n     fn emit_return_lint(&mut self, cx: &EarlyContext, spans: (Span, Span)) {\n-        if in_external_macro(cx, spans.1) {return;}\n-        span_lint_and_then(cx, NEEDLESS_RETURN, spans.0,\n-                           \"unneeded return statement\",\n-                           |db| {\n+        if in_external_macro(cx, spans.1) {\n+            return;\n+        }\n+        span_lint_and_then(cx, NEEDLESS_RETURN, spans.0, \"unneeded return statement\", |db| {\n             if let Some(snippet) = snippet_opt(cx, spans.1) {\n-                db.span_suggestion(spans.0,\n-                                          \"remove `return` as shown:\",\n-                                          snippet);\n+                db.span_suggestion(spans.0, \"remove `return` as shown:\", snippet);\n             }\n         });\n     }\n@@ -104,13 +102,16 @@ impl ReturnPass {\n     }\n \n     fn emit_let_lint(&mut self, cx: &EarlyContext, lint_span: Span, note_span: Span) {\n-        if in_external_macro(cx, note_span) {return;}\n-        let mut db = span_lint(cx, LET_AND_RETURN, lint_span,\n-                  \"returning the result of a let binding from a block. \\\n-                   Consider returning the expression directly.\");\n+        if in_external_macro(cx, note_span) {\n+            return;\n+        }\n+        let mut db = span_lint(cx,\n+                               LET_AND_RETURN,\n+                               lint_span,\n+                               \"returning the result of a let binding from a block. Consider returning the \\\n+                                expression directly.\");\n         if cx.current_level(LET_AND_RETURN) != Level::Allow {\n-            db.span_note(note_span,\n-                                \"this expression can be directly returned\");\n+            db.span_note(note_span, \"this expression can be directly returned\");\n         }\n     }\n }\n@@ -122,8 +123,7 @@ impl LintPass for ReturnPass {\n }\n \n impl EarlyLintPass for ReturnPass {\n-    fn check_fn(&mut self, cx: &EarlyContext, _: FnKind, _: &FnDecl,\n-                block: &Block, _: Span, _: NodeId) {\n+    fn check_fn(&mut self, cx: &EarlyContext, _: FnKind, _: &FnDecl, block: &Block, _: Span, _: NodeId) {\n         self.check_block_return(cx, block);\n     }\n "}, {"sha": "2d3e423eacb93ebc64d30dc5c531e34109054a33", "filename": "src/shadow.rs", "status": "modified", "additions": 100, "deletions": 66, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshadow.rs?ref=c9342d01213ca1663d2cdf23289bae024823ae6a", "patch": "@@ -45,13 +45,13 @@ impl LintPass for ShadowPass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(SHADOW_SAME, SHADOW_REUSE, SHADOW_UNRELATED)\n     }\n-\n }\n \n impl LateLintPass for ShadowPass {\n-    fn check_fn(&mut self, cx: &LateContext, _: FnKind, decl: &FnDecl,\n-            block: &Block, _: Span, _: NodeId) {\n-        if in_external_macro(cx, block.span) { return; }\n+    fn check_fn(&mut self, cx: &LateContext, _: FnKind, decl: &FnDecl, block: &Block, _: Span, _: NodeId) {\n+        if in_external_macro(cx, block.span) {\n+            return;\n+        }\n         check_fn(cx, decl, block);\n     }\n }\n@@ -71,20 +71,27 @@ fn check_block(cx: &LateContext, block: &Block, bindings: &mut Vec<(Name, Span)>\n     for stmt in &block.stmts {\n         match stmt.node {\n             StmtDecl(ref decl, _) => check_decl(cx, decl, bindings),\n-            StmtExpr(ref e, _) | StmtSemi(ref e, _) =>\n-                check_expr(cx, e, bindings)\n+            StmtExpr(ref e, _) | StmtSemi(ref e, _) => check_expr(cx, e, bindings),\n         }\n     }\n-    if let Some(ref o) = block.expr { check_expr(cx, o, bindings); }\n+    if let Some(ref o) = block.expr {\n+        check_expr(cx, o, bindings);\n+    }\n     bindings.truncate(len);\n }\n \n fn check_decl(cx: &LateContext, decl: &Decl, bindings: &mut Vec<(Name, Span)>) {\n-    if in_external_macro(cx, decl.span) { return; }\n-    if is_from_for_desugar(decl) { return; }\n+    if in_external_macro(cx, decl.span) {\n+        return;\n+    }\n+    if is_from_for_desugar(decl) {\n+        return;\n+    }\n     if let DeclLocal(ref local) = decl.node {\n         let Local{ ref pat, ref ty, ref init, span, .. } = **local;\n-        if let Some(ref t) = *ty { check_ty(cx, t, bindings) }\n+        if let Some(ref t) = *ty {\n+            check_ty(cx, t, bindings)\n+        }\n         if let Some(ref o) = *init {\n             check_expr(cx, o, bindings);\n             check_pat(cx, pat, &Some(o), span, bindings);\n@@ -97,13 +104,12 @@ fn check_decl(cx: &LateContext, decl: &Decl, bindings: &mut Vec<(Name, Span)>) {\n fn is_binding(cx: &LateContext, pat: &Pat) -> bool {\n     match cx.tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def()) {\n         Some(DefVariant(..)) | Some(DefStruct(..)) => false,\n-        _ => true\n+        _ => true,\n     }\n }\n \n-fn check_pat(cx: &LateContext, pat: &Pat, init: &Option<&Expr>, span: Span,\n-        bindings: &mut Vec<(Name, Span)>) {\n-    //TODO: match more stuff / destructuring\n+fn check_pat(cx: &LateContext, pat: &Pat, init: &Option<&Expr>, span: Span, bindings: &mut Vec<(Name, Span)>) {\n+    // TODO: match more stuff / destructuring\n     match pat.node {\n         PatIdent(_, ref ident, ref inner) => {\n             let name = ident.node.unhygienic_name;\n@@ -121,17 +127,19 @@ fn check_pat(cx: &LateContext, pat: &Pat, init: &Option<&Expr>, span: Span,\n                     bindings.push((name, ident.span));\n                 }\n             }\n-            if let Some(ref p) = *inner { check_pat(cx, p, init, span, bindings); }\n+            if let Some(ref p) = *inner {\n+                check_pat(cx, p, init, span, bindings);\n+            }\n         }\n-        //PatEnum(Path, Option<Vec<P<Pat>>>),\n-        PatStruct(_, ref pfields, _) =>\n+        // PatEnum(Path, Option<Vec<P<Pat>>>),\n+        PatStruct(_, ref pfields, _) => {\n             if let Some(ref init_struct) = *init {\n                 if let ExprStruct(_, ref efields, _) = init_struct.node {\n                     for field in pfields {\n                         let name = field.node.name;\n                         let efield = efields.iter()\n-                            .find(|ref f| f.name.node == name)\n-                            .map(|f| &*f.expr);\n+                                            .find(|ref f| f.name.node == name)\n+                                            .map(|f| &*f.expr);\n                         check_pat(cx, &field.node.pat, &efield, span, bindings);\n                     }\n                 } else {\n@@ -143,8 +151,9 @@ fn check_pat(cx: &LateContext, pat: &Pat, init: &Option<&Expr>, span: Span,\n                 for field in pfields {\n                     check_pat(cx, &field.node.pat, &None, span, bindings);\n                 }\n-            },\n-        PatTup(ref inner) =>\n+            }\n+        }\n+        PatTup(ref inner) => {\n             if let Some(ref init_tup) = *init {\n                 if let ExprTup(ref tup) = init_tup.node {\n                     for (i, p) in inner.iter().enumerate() {\n@@ -159,7 +168,8 @@ fn check_pat(cx: &LateContext, pat: &Pat, init: &Option<&Expr>, span: Span,\n                 for p in inner {\n                     check_pat(cx, p, &None, span, bindings);\n                 }\n-            },\n+            }\n+        }\n         PatBox(ref inner) => {\n             if let Some(ref initp) = *init {\n                 if let ExprBox(ref inner_init) = initp.node {\n@@ -171,67 +181,85 @@ fn check_pat(cx: &LateContext, pat: &Pat, init: &Option<&Expr>, span: Span,\n                 check_pat(cx, inner, init, span, bindings);\n             }\n         }\n-        PatRegion(ref inner, _) =>\n-            check_pat(cx, inner, init, span, bindings),\n-        //PatVec(Vec<P<Pat>>, Option<P<Pat>>, Vec<P<Pat>>),\n+        PatRegion(ref inner, _) => check_pat(cx, inner, init, span, bindings),\n+        // PatVec(Vec<P<Pat>>, Option<P<Pat>>, Vec<P<Pat>>),\n         _ => (),\n     }\n }\n \n-fn lint_shadow<T>(cx: &LateContext, name: Name, span: Span, lspan: Span, init:\n-        &Option<T>, prev_span: Span) where T: Deref<Target=Expr> {\n+fn lint_shadow<T>(cx: &LateContext, name: Name, span: Span, lspan: Span, init: &Option<T>, prev_span: Span)\n+    where T: Deref<Target = Expr>\n+{\n     fn note_orig(cx: &LateContext, mut db: DiagnosticWrapper, lint: &'static Lint, span: Span) {\n         if cx.current_level(lint) != Level::Allow {\n             db.span_note(span, \"previous binding is here\");\n         }\n     }\n     if let Some(ref expr) = *init {\n         if is_self_shadow(name, expr) {\n-            let db = span_lint(cx, SHADOW_SAME, span, &format!(\n-                \"{} is shadowed by itself in {}\",\n-                snippet(cx, lspan, \"_\"),\n-                snippet(cx, expr.span, \"..\")));\n-                note_orig(cx, db, SHADOW_SAME, prev_span);\n+            let db = span_lint(cx,\n+                               SHADOW_SAME,\n+                               span,\n+                               &format!(\"{} is shadowed by itself in {}\",\n+                                        snippet(cx, lspan, \"_\"),\n+                                        snippet(cx, expr.span, \"..\")));\n+            note_orig(cx, db, SHADOW_SAME, prev_span);\n         } else {\n             if contains_self(name, expr) {\n-                let db = span_note_and_lint(cx, SHADOW_REUSE, lspan, &format!(\n-                    \"{} is shadowed by {} which reuses the original value\",\n-                    snippet(cx, lspan, \"_\"),\n-                    snippet(cx, expr.span, \"..\")),\n-                    expr.span, \"initialization happens here\");\n+                let db = span_note_and_lint(cx,\n+                                            SHADOW_REUSE,\n+                                            lspan,\n+                                            &format!(\"{} is shadowed by {} which reuses the original value\",\n+                                                     snippet(cx, lspan, \"_\"),\n+                                                     snippet(cx, expr.span, \"..\")),\n+                                            expr.span,\n+                                            \"initialization happens here\");\n                 note_orig(cx, db, SHADOW_REUSE, prev_span);\n             } else {\n-                let db = span_note_and_lint(cx, SHADOW_UNRELATED, lspan, &format!(\n-                    \"{} is shadowed by {}\",\n-                    snippet(cx, lspan, \"_\"),\n-                    snippet(cx, expr.span, \"..\")),\n-                    expr.span, \"initialization happens here\");\n+                let db = span_note_and_lint(cx,\n+                                            SHADOW_UNRELATED,\n+                                            lspan,\n+                                            &format!(\"{} is shadowed by {}\",\n+                                                     snippet(cx, lspan, \"_\"),\n+                                                     snippet(cx, expr.span, \"..\")),\n+                                            expr.span,\n+                                            \"initialization happens here\");\n                 note_orig(cx, db, SHADOW_UNRELATED, prev_span);\n             }\n         }\n     } else {\n-        let db = span_lint(cx, SHADOW_UNRELATED, span, &format!(\n-            \"{} shadows a previous declaration\", snippet(cx, lspan, \"_\")));\n+        let db = span_lint(cx,\n+                           SHADOW_UNRELATED,\n+                           span,\n+                           &format!(\"{} shadows a previous declaration\", snippet(cx, lspan, \"_\")));\n         note_orig(cx, db, SHADOW_UNRELATED, prev_span);\n     }\n }\n \n fn check_expr(cx: &LateContext, expr: &Expr, bindings: &mut Vec<(Name, Span)>) {\n-    if in_external_macro(cx, expr.span) { return; }\n+    if in_external_macro(cx, expr.span) {\n+        return;\n+    }\n     match expr.node {\n-        ExprUnary(_, ref e) | ExprField(ref e, _) |\n-        ExprTupField(ref e, _) | ExprAddrOf(_, ref e) | ExprBox(ref e)\n-            => { check_expr(cx, e, bindings) }\n-        ExprBlock(ref block) | ExprLoop(ref block, _) =>\n-            { check_block(cx, block, bindings) }\n-        //ExprCall\n-        //ExprMethodCall\n-        ExprVec(ref v) | ExprTup(ref v) =>\n-            for ref e in v { check_expr(cx, e, bindings) },\n+        ExprUnary(_, ref e) |\n+        ExprField(ref e, _) |\n+        ExprTupField(ref e, _) |\n+        ExprAddrOf(_, ref e) |\n+        ExprBox(ref e) => check_expr(cx, e, bindings),\n+        ExprBlock(ref block) | ExprLoop(ref block, _) => check_block(cx, block, bindings),\n+        // ExprCall\n+        // ExprMethodCall\n+        ExprVec(ref v) | ExprTup(ref v) => {\n+            for ref e in v {\n+                check_expr(cx, e, bindings)\n+            }\n+        }\n         ExprIf(ref cond, ref then, ref otherwise) => {\n             check_expr(cx, cond, bindings);\n             check_block(cx, then, bindings);\n-            if let Some(ref o) = *otherwise { check_expr(cx, o, bindings); }\n+            if let Some(ref o) = *otherwise {\n+                check_expr(cx, o, bindings);\n+            }\n         }\n         ExprWhile(ref cond, ref block, _) => {\n             check_expr(cx, cond, bindings);\n@@ -243,7 +271,7 @@ fn check_expr(cx: &LateContext, expr: &Expr, bindings: &mut Vec<(Name, Span)>) {\n             for ref arm in arms {\n                 for ref pat in &arm.pats {\n                     check_pat(cx, &pat, &Some(&**init), pat.span, bindings);\n-                    //This is ugly, but needed to get the right type\n+                    // This is ugly, but needed to get the right type\n                     if let Some(ref guard) = arm.guard {\n                         check_expr(cx, guard, bindings);\n                     }\n@@ -252,7 +280,7 @@ fn check_expr(cx: &LateContext, expr: &Expr, bindings: &mut Vec<(Name, Span)>) {\n                 }\n             }\n         }\n-        _ => ()\n+        _ => (),\n     }\n }\n \n@@ -266,7 +294,11 @@ fn check_ty(cx: &LateContext, ty: &Ty, bindings: &mut Vec<(Name, Span)>) {\n         }\n         TyPtr(MutTy{ ty: ref mty, .. }) |\n         TyRptr(_, MutTy{ ty: ref mty, .. }) => check_ty(cx, mty, bindings),\n-        TyTup(ref tup) => { for ref t in tup { check_ty(cx, t, bindings) } }\n+        TyTup(ref tup) => {\n+            for ref t in tup {\n+                check_ty(cx, t, bindings)\n+            }\n+        }\n         TyTypeof(ref expr) => check_expr(cx, expr, bindings),\n         _ => (),\n     }\n@@ -276,23 +308,22 @@ fn is_self_shadow(name: Name, expr: &Expr) -> bool {\n     match expr.node {\n         ExprBox(ref inner) |\n         ExprAddrOf(_, ref inner) => is_self_shadow(name, inner),\n-        ExprBlock(ref block) => block.stmts.is_empty() && block.expr.as_ref().\n-            map_or(false, |ref e| is_self_shadow(name, e)),\n-        ExprUnary(op, ref inner) => (UnDeref == op) &&\n-            is_self_shadow(name, inner),\n+        ExprBlock(ref block) => {\n+            block.stmts.is_empty() && block.expr.as_ref().map_or(false, |ref e| is_self_shadow(name, e))\n+        }\n+        ExprUnary(op, ref inner) => (UnDeref == op) && is_self_shadow(name, inner),\n         ExprPath(_, ref path) => path_eq_name(name, path),\n         _ => false,\n     }\n }\n \n fn path_eq_name(name: Name, path: &Path) -> bool {\n-    !path.global && path.segments.len() == 1 &&\n-        path.segments[0].identifier.unhygienic_name == name\n+    !path.global && path.segments.len() == 1 && path.segments[0].identifier.unhygienic_name == name\n }\n \n struct ContainsSelf {\n     name: Name,\n-    result: bool\n+    result: bool,\n }\n \n impl<'v> Visitor<'v> for ContainsSelf {\n@@ -304,7 +335,10 @@ impl<'v> Visitor<'v> for ContainsSelf {\n }\n \n fn contains_self(name: Name, expr: &Expr) -> bool {\n-    let mut cs = ContainsSelf { name: name, result: false };\n+    let mut cs = ContainsSelf {\n+        name: name,\n+        result: false,\n+    };\n     cs.visit_expr(expr);\n     cs.result\n }"}, {"sha": "55d1a0acf682300e2b6220204b5a621e8619396e", "filename": "src/strings.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstrings.rs?ref=c9342d01213ca1663d2cdf23289bae024823ae6a", "patch": "@@ -68,19 +68,24 @@ impl LateLintPass for StringAdd {\n                     if let Some(ref p) = parent {\n                         if let ExprAssign(ref target, _) = p.node {\n                             // avoid duplicate matches\n-                            if is_exp_equal(cx, target, left) { return; }\n+                            if is_exp_equal(cx, target, left) {\n+                                return;\n+                            }\n                         }\n                     }\n                 }\n-                span_lint(cx, STRING_ADD, e.span,\n-                    \"you added something to a string. \\\n-                     Consider using `String::push_str()` instead\");\n+                span_lint(cx,\n+                          STRING_ADD,\n+                          e.span,\n+                          \"you added something to a string. Consider using `String::push_str()` instead\");\n             }\n         } else if let ExprAssign(ref target, ref src) = e.node {\n             if is_string(cx, target) && is_add(cx, src, target) {\n-                span_lint(cx, STRING_ADD_ASSIGN, e.span,\n-                    \"you assigned the result of adding something to this string. \\\n-                     Consider using `String::push_str()` instead\");\n+                span_lint(cx,\n+                          STRING_ADD_ASSIGN,\n+                          e.span,\n+                          \"you assigned the result of adding something to this string. Consider using \\\n+                           `String::push_str()` instead\");\n             }\n         }\n     }\n@@ -92,11 +97,10 @@ fn is_string(cx: &LateContext, e: &Expr) -> bool {\n \n fn is_add(cx: &LateContext, src: &Expr, target: &Expr) -> bool {\n     match src.node {\n-        ExprBinary(Spanned{ node: BiAdd, .. }, ref left, _) =>\n-            is_exp_equal(cx, target, left),\n-        ExprBlock(ref block) => block.stmts.is_empty() &&\n-            block.expr.as_ref().map_or(false,\n-                |expr| is_add(cx, expr, target)),\n-        _ => false\n+        ExprBinary(Spanned{ node: BiAdd, .. }, ref left, _) => is_exp_equal(cx, target, left),\n+        ExprBlock(ref block) => {\n+            block.stmts.is_empty() && block.expr.as_ref().map_or(false, |expr| is_add(cx, expr, target))\n+        }\n+        _ => false,\n     }\n }"}, {"sha": "7d5057d8377864b47fb425f2bc95d8beec5fbc07", "filename": "src/temporary_assignment.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Ftemporary_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Ftemporary_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftemporary_assignment.rs?ref=c9342d01213ca1663d2cdf23289bae024823ae6a", "patch": "@@ -40,11 +40,10 @@ impl LateLintPass for TemporaryAssignmentPass {\n             match target.node {\n                 ExprField(ref base, _) | ExprTupField(ref base, _) => {\n                     if is_temporary(base) && !is_adjusted(cx, base) {\n-                        span_lint(cx, TEMPORARY_ASSIGNMENT, expr.span,\n-                                  \"assignment to temporary\");\n+                        span_lint(cx, TEMPORARY_ASSIGNMENT, expr.span, \"assignment to temporary\");\n                     }\n                 }\n-                _ => ()\n+                _ => (),\n             }\n         }\n     }"}, {"sha": "24af45bc68d1232877f94a100b5cdfd00c631c16", "filename": "src/transmute.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftransmute.rs?ref=c9342d01213ca1663d2cdf23289bae024823ae6a", "patch": "@@ -34,7 +34,8 @@ impl LateLintPass for UselessTransmute {\n                     let to_ty = cx.tcx.expr_ty(e);\n \n                     if from_ty == to_ty {\n-                        cx.span_lint(USELESS_TRANSMUTE, e.span,\n+                        cx.span_lint(USELESS_TRANSMUTE,\n+                                     e.span,\n                                      &format!(\"transmute from a type (`{}`) to itself\", from_ty));\n                     }\n                 }"}, {"sha": "6289e13c85aec09ee05f6207aead226ed59e4fef", "filename": "src/types.rs", "status": "modified", "additions": 160, "deletions": 93, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=c9342d01213ca1663d2cdf23289bae024823ae6a", "patch": "@@ -49,22 +49,23 @@ impl LintPass for TypePass {\n impl LateLintPass for TypePass {\n     fn check_ty(&mut self, cx: &LateContext, ast_ty: &Ty) {\n         if in_macro(cx, ast_ty.span) {\n-            return\n+            return;\n         }\n         if let Some(ty) = cx.tcx.ast_ty_to_ty_cache.borrow().get(&ast_ty.id) {\n             if let ty::TyBox(ref inner) = ty.sty {\n                 if match_type(cx, inner, &VEC_PATH) {\n-                    span_help_and_lint(\n-                        cx, BOX_VEC, ast_ty.span,\n-                        \"you seem to be trying to use `Box<Vec<T>>`. Consider using just `Vec<T>`\",\n-                        \"`Vec<T>` is already on the heap, `Box<Vec<T>>` makes an extra allocation.\");\n+                    span_help_and_lint(cx,\n+                                       BOX_VEC,\n+                                       ast_ty.span,\n+                                       \"you seem to be trying to use `Box<Vec<T>>`. Consider using just `Vec<T>`\",\n+                                       \"`Vec<T>` is already on the heap, `Box<Vec<T>>` makes an extra allocation.\");\n                 }\n-            }\n-            else if match_type(cx, ty, &LL_PATH) {\n-                span_help_and_lint(\n-                    cx, LINKEDLIST, ast_ty.span,\n-                    \"I see you're using a LinkedList! Perhaps you meant some other data structure?\",\n-                    \"a VecDeque might work\");\n+            } else if match_type(cx, ty, &LL_PATH) {\n+                span_help_and_lint(cx,\n+                                   LINKEDLIST,\n+                                   ast_ty.span,\n+                                   \"I see you're using a LinkedList! Perhaps you meant some other data structure?\",\n+                                   \"a VecDeque might work\");\n             }\n         }\n     }\n@@ -87,12 +88,17 @@ fn check_let_unit(cx: &LateContext, decl: &Decl) {\n     if let DeclLocal(ref local) = decl.node {\n         let bindtype = &cx.tcx.pat_ty(&local.pat).sty;\n         if *bindtype == ty::TyTuple(vec![]) {\n-            if in_external_macro(cx, decl.span) ||\n-                in_macro(cx, local.pat.span) { return; }\n-                if is_from_for_desugar(decl) { return; }\n-                span_lint(cx, LET_UNIT_VALUE, decl.span, &format!(\n-                    \"this let-binding has unit value. Consider omitting `let {} =`\",\n-                    snippet(cx, local.pat.span, \"..\")));\n+            if in_external_macro(cx, decl.span) || in_macro(cx, local.pat.span) {\n+                return;\n+            }\n+            if is_from_for_desugar(decl) {\n+                return;\n+            }\n+            span_lint(cx,\n+                      LET_UNIT_VALUE,\n+                      decl.span,\n+                      &format!(\"this let-binding has unit value. Consider omitting `let {} =`\",\n+                               snippet(cx, local.pat.span, \"..\")));\n         }\n     }\n }\n@@ -130,18 +136,23 @@ impl LintPass for UnitCmp {\n \n impl LateLintPass for UnitCmp {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n-        if in_macro(cx, expr.span) { return; }\n+        if in_macro(cx, expr.span) {\n+            return;\n+        }\n         if let ExprBinary(ref cmp, ref left, _) = expr.node {\n             let op = cmp.node;\n             let sty = &cx.tcx.expr_ty(left).sty;\n             if *sty == ty::TyTuple(vec![]) && is_comparison_binop(op) {\n                 let result = match op {\n                     BiEq | BiLe | BiGe => \"true\",\n-                    _ => \"false\"\n+                    _ => \"false\",\n                 };\n-                span_lint(cx, UNIT_CMP, expr.span, &format!(\n-                    \"{}-comparison of unit values detected. This will always be {}\",\n-                    binop_to_string(op), result));\n+                span_lint(cx,\n+                          UNIT_CMP,\n+                          expr.span,\n+                          &format!(\"{}-comparison of unit values detected. This will always be {}\",\n+                                   binop_to_string(op),\n+                                   result));\n             }\n         }\n     }\n@@ -192,83 +203,125 @@ declare_lint!(pub CAST_POSSIBLE_WRAP, Allow,\n /// Will return 0 if the type is not an int or uint variant\n fn int_ty_to_nbits(typ: &ty::TyS) -> usize {\n     let n = match typ.sty {\n-        ty::TyInt(i) =>  4 << (i as usize),\n+        ty::TyInt(i) => 4 << (i as usize),\n         ty::TyUint(u) => 4 << (u as usize),\n-        _ => 0\n+        _ => 0,\n     };\n     // n == 4 is the usize/isize case\n-    if n == 4 { ::std::usize::BITS } else { n }\n+    if n == 4 {\n+        ::std::usize::BITS\n+    } else {\n+        n\n+    }\n }\n \n fn is_isize_or_usize(typ: &ty::TyS) -> bool {\n     match typ.sty {\n         ty::TyInt(TyIs) | ty::TyUint(TyUs) => true,\n-        _ => false\n+        _ => false,\n     }\n }\n \n fn span_precision_loss_lint(cx: &LateContext, expr: &Expr, cast_from: &ty::TyS, cast_to_f64: bool) {\n-    let mantissa_nbits = if cast_to_f64 {52} else {23};\n+    let mantissa_nbits = if cast_to_f64 {\n+        52\n+    } else {\n+        23\n+    };\n     let arch_dependent = is_isize_or_usize(cast_from) && cast_to_f64;\n     let arch_dependent_str = \"on targets with 64-bit wide pointers \";\n-    let from_nbits_str = if arch_dependent {\"64\".to_owned()}\n-                         else if is_isize_or_usize(cast_from) {\"32 or 64\".to_owned()}\n-                         else {int_ty_to_nbits(cast_from).to_string()};\n-    span_lint(cx, CAST_PRECISION_LOSS, expr.span,\n-        &format!(\"casting {0} to {1} causes a loss of precision {2}\\\n-            ({0} is {3} bits wide, but {1}'s mantissa is only {4} bits wide)\",\n-            cast_from, if cast_to_f64 {\"f64\"} else {\"f32\"},\n-            if arch_dependent {arch_dependent_str} else {\"\"},\n-            from_nbits_str, mantissa_nbits));\n+    let from_nbits_str = if arch_dependent {\n+        \"64\".to_owned()\n+    } else if is_isize_or_usize(cast_from) {\n+        \"32 or 64\".to_owned()\n+    } else {\n+        int_ty_to_nbits(cast_from).to_string()\n+    };\n+    span_lint(cx,\n+              CAST_PRECISION_LOSS,\n+              expr.span,\n+              &format!(\"casting {0} to {1} causes a loss of precision {2}({0} is {3} bits wide, but {1}'s mantissa \\\n+                        is only {4} bits wide)\",\n+                       cast_from,\n+                       if cast_to_f64 {\n+                           \"f64\"\n+                       } else {\n+                           \"f32\"\n+                       },\n+                       if arch_dependent {\n+                           arch_dependent_str\n+                       } else {\n+                           \"\"\n+                       },\n+                       from_nbits_str,\n+                       mantissa_nbits));\n }\n \n enum ArchSuffix {\n-    _32, _64, None\n+    _32,\n+    _64,\n+    None,\n }\n \n fn check_truncation_and_wrapping(cx: &LateContext, expr: &Expr, cast_from: &ty::TyS, cast_to: &ty::TyS) {\n     let arch_64_suffix = \" on targets with 64-bit wide pointers\";\n     let arch_32_suffix = \" on targets with 32-bit wide pointers\";\n     let cast_unsigned_to_signed = !cast_from.is_signed() && cast_to.is_signed();\n     let (from_nbits, to_nbits) = (int_ty_to_nbits(cast_from), int_ty_to_nbits(cast_to));\n-    let (span_truncation, suffix_truncation, span_wrap, suffix_wrap) =\n-        match (is_isize_or_usize(cast_from), is_isize_or_usize(cast_to)) {\n-            (true, true) | (false, false) => (\n-                to_nbits < from_nbits,\n-                ArchSuffix::None,\n-                to_nbits == from_nbits && cast_unsigned_to_signed,\n+    let (span_truncation, suffix_truncation, span_wrap, suffix_wrap) = match (is_isize_or_usize(cast_from),\n+                                                                              is_isize_or_usize(cast_to)) {\n+        (true, true) | (false, false) => {\n+            (to_nbits < from_nbits,\n+             ArchSuffix::None,\n+             to_nbits == from_nbits && cast_unsigned_to_signed,\n+             ArchSuffix::None)\n+        }\n+        (true, false) => {\n+            (to_nbits <= 32,\n+             if to_nbits == 32 {\n+                ArchSuffix::_64\n+            } else {\n                 ArchSuffix::None\n-                ),\n-            (true, false) => (\n-                to_nbits <= 32,\n-                if to_nbits == 32 {ArchSuffix::_64} else {ArchSuffix::None},\n-                to_nbits <= 32 && cast_unsigned_to_signed,\n+            },\n+             to_nbits <= 32 && cast_unsigned_to_signed,\n+             ArchSuffix::_32)\n+        }\n+        (false, true) => {\n+            (from_nbits == 64,\n+             ArchSuffix::_32,\n+             cast_unsigned_to_signed,\n+             if from_nbits == 64 {\n+                ArchSuffix::_64\n+            } else {\n                 ArchSuffix::_32\n-                ),\n-            (false, true) => (\n-                from_nbits == 64,\n-                ArchSuffix::_32,\n-                cast_unsigned_to_signed,\n-                if from_nbits == 64 {ArchSuffix::_64} else {ArchSuffix::_32}\n-                ),\n-        };\n+            })\n+        }\n+    };\n     if span_truncation {\n-        span_lint(cx, CAST_POSSIBLE_TRUNCATION, expr.span,\n-            &format!(\"casting {} to {} may truncate the value{}\",\n-               cast_from, cast_to,\n-               match suffix_truncation {\n-                   ArchSuffix::_32 => arch_32_suffix,\n-                   ArchSuffix::_64 => arch_64_suffix,\n-                   ArchSuffix::None => \"\" }));\n+        span_lint(cx,\n+                  CAST_POSSIBLE_TRUNCATION,\n+                  expr.span,\n+                  &format!(\"casting {} to {} may truncate the value{}\",\n+                           cast_from,\n+                           cast_to,\n+                           match suffix_truncation {\n+                               ArchSuffix::_32 => arch_32_suffix,\n+                               ArchSuffix::_64 => arch_64_suffix,\n+                               ArchSuffix::None => \"\",\n+                           }));\n     }\n     if span_wrap {\n-        span_lint(cx, CAST_POSSIBLE_WRAP, expr.span,\n-            &format!(\"casting {} to {} may wrap around the value{}\",\n-                cast_from, cast_to,\n-                match suffix_wrap {\n-                    ArchSuffix::_32 => arch_32_suffix,\n-                    ArchSuffix::_64 => arch_64_suffix,\n-                    ArchSuffix::None => \"\" }));\n+        span_lint(cx,\n+                  CAST_POSSIBLE_WRAP,\n+                  expr.span,\n+                  &format!(\"casting {} to {} may wrap around the value{}\",\n+                           cast_from,\n+                           cast_to,\n+                           match suffix_wrap {\n+                               ArchSuffix::_32 => arch_32_suffix,\n+                               ArchSuffix::_64 => arch_64_suffix,\n+                               ArchSuffix::None => \"\",\n+                           }));\n     }\n }\n \n@@ -289,35 +342,42 @@ impl LateLintPass for CastPass {\n                 match (cast_from.is_integral(), cast_to.is_integral()) {\n                     (true, false) => {\n                         let from_nbits = int_ty_to_nbits(cast_from);\n-                        let to_nbits = if let ty::TyFloat(TyF32) = cast_to.sty {32} else {64};\n+                        let to_nbits = if let ty::TyFloat(TyF32) = cast_to.sty {\n+                            32\n+                        } else {\n+                            64\n+                        };\n                         if is_isize_or_usize(cast_from) || from_nbits >= to_nbits {\n                             span_precision_loss_lint(cx, expr, cast_from, to_nbits == 64);\n                         }\n                     }\n                     (false, true) => {\n-                        span_lint(cx, CAST_POSSIBLE_TRUNCATION, expr.span,\n-                            &format!(\"casting {} to {} may truncate the value\",\n-                                  cast_from, cast_to));\n+                        span_lint(cx,\n+                                  CAST_POSSIBLE_TRUNCATION,\n+                                  expr.span,\n+                                  &format!(\"casting {} to {} may truncate the value\", cast_from, cast_to));\n                         if !cast_to.is_signed() {\n-                            span_lint(cx, CAST_SIGN_LOSS, expr.span,\n-                                &format!(\"casting {} to {} may lose the sign of the value\",\n-                                    cast_from, cast_to));\n+                            span_lint(cx,\n+                                      CAST_SIGN_LOSS,\n+                                      expr.span,\n+                                      &format!(\"casting {} to {} may lose the sign of the value\", cast_from, cast_to));\n                         }\n                     }\n                     (true, true) => {\n                         if cast_from.is_signed() && !cast_to.is_signed() {\n-                            span_lint(cx, CAST_SIGN_LOSS, expr.span,\n-                                &format!(\"casting {} to {} may lose the sign of the value\",\n-                                    cast_from, cast_to));\n+                            span_lint(cx,\n+                                      CAST_SIGN_LOSS,\n+                                      expr.span,\n+                                      &format!(\"casting {} to {} may lose the sign of the value\", cast_from, cast_to));\n                         }\n                         check_truncation_and_wrapping(cx, expr, cast_from, cast_to);\n                     }\n                     (false, false) => {\n-                        if let (&ty::TyFloat(TyF64),\n-                                &ty::TyFloat(TyF32)) = (&cast_from.sty, &cast_to.sty) {\n-                            span_lint(cx, CAST_POSSIBLE_TRUNCATION,\n-                                expr.span,\n-                                \"casting f64 to f32 may truncate the value\");\n+                        if let (&ty::TyFloat(TyF64), &ty::TyFloat(TyF32)) = (&cast_from.sty, &cast_to.sty) {\n+                            span_lint(cx,\n+                                      CAST_POSSIBLE_TRUNCATION,\n+                                      expr.span,\n+                                      \"casting f64 to f32 may truncate the value\");\n                         }\n                     }\n                 }\n@@ -360,7 +420,7 @@ impl LateLintPass for TypeComplexityPass {\n             ItemStatic(ref ty, _, _) |\n             ItemConst(ref ty, _) => check_type(cx, ty),\n             // functions, enums, structs, impls and traits are covered\n-            _ => ()\n+            _ => (),\n         }\n     }\n \n@@ -370,7 +430,7 @@ impl LateLintPass for TypeComplexityPass {\n             TypeTraitItem(_, Some(ref ty)) => check_type(cx, ty),\n             MethodTraitItem(MethodSig { ref decl, .. }, None) => check_fndecl(cx, decl),\n             // methods with default impl are covered by check_fn\n-            _ => ()\n+            _ => (),\n         }\n     }\n \n@@ -379,7 +439,7 @@ impl LateLintPass for TypeComplexityPass {\n             ImplItemKind::Const(ref ty, _) |\n             ImplItemKind::Type(ref ty) => check_type(cx, ty),\n             // methods are covered by check_fn\n-            _ => ()\n+            _ => (),\n         }\n     }\n \n@@ -400,16 +460,23 @@ fn check_fndecl(cx: &LateContext, decl: &FnDecl) {\n }\n \n fn check_type(cx: &LateContext, ty: &Ty) {\n-    if in_macro(cx, ty.span) { return; }\n+    if in_macro(cx, ty.span) {\n+        return;\n+    }\n     let score = {\n-        let mut visitor = TypeComplexityVisitor { score: 0, nest: 1 };\n+        let mut visitor = TypeComplexityVisitor {\n+            score: 0,\n+            nest: 1,\n+        };\n         visitor.visit_ty(ty);\n         visitor.score\n     };\n     // println!(\"{:?} --> {}\", ty, score);\n     if score > 250 {\n-        span_lint(cx, TYPE_COMPLEXITY, ty.span, &format!(\n-            \"very complex type used. Consider factoring parts into `type` definitions\"));\n+        span_lint(cx,\n+                  TYPE_COMPLEXITY,\n+                  ty.span,\n+                  &format!(\"very complex type used. Consider factoring parts into `type` definitions\"));\n     }\n }\n \n@@ -442,7 +509,7 @@ impl<'v> Visitor<'v> for TypeComplexityVisitor {\n             TyBareFn(..) |\n             TyPolyTraitRef(..) => (50 * self.nest, 1),\n \n-            _ => (0, 0)\n+            _ => (0, 0),\n         };\n         self.score += add_score;\n         self.nest += sub_nest;"}, {"sha": "d5ea7199e1048846570c5d2079b673321d646502", "filename": "src/unicode.rs", "status": "modified", "additions": 26, "deletions": 20, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Funicode.rs?ref=c9342d01213ca1663d2cdf23289bae024823ae6a", "patch": "@@ -58,11 +58,13 @@ impl LateLintPass for Unicode {\n     }\n }\n \n-fn escape<T: Iterator<Item=char>>(s: T) -> String {\n+fn escape<T: Iterator<Item = char>>(s: T) -> String {\n     let mut result = String::new();\n     for c in s {\n         if c as u32 > 0x7F {\n-            for d in c.escape_unicode() { result.push(d) };\n+            for d in c.escape_unicode() {\n+                result.push(d)\n+            }\n         } else {\n             result.push(c);\n         }\n@@ -73,26 +75,30 @@ fn escape<T: Iterator<Item=char>>(s: T) -> String {\n fn check_str(cx: &LateContext, span: Span) {\n     let string = snippet(cx, span, \"\");\n     if string.contains('\\u{200B}') {\n-        span_help_and_lint(cx, ZERO_WIDTH_SPACE, span,\n-            \"zero-width space detected\",\n-            &format!(\"Consider replacing the string with:\\n\\\"{}\\\"\",\n-                string.replace(\"\\u{200B}\", \"\\\\u{200B}\")));\n+        span_help_and_lint(cx,\n+                           ZERO_WIDTH_SPACE,\n+                           span,\n+                           \"zero-width space detected\",\n+                           &format!(\"Consider replacing the string with:\\n\\\"{}\\\"\",\n+                                    string.replace(\"\\u{200B}\", \"\\\\u{200B}\")));\n     }\n     if string.chars().any(|c| c as u32 > 0x7F) {\n-        span_help_and_lint(cx, NON_ASCII_LITERAL, span,\n-            \"literal non-ASCII character detected\",\n-            &format!(\"Consider replacing the string with:\\n\\\"{}\\\"\",\n-                if cx.current_level(UNICODE_NOT_NFC) == Level::Allow {\n-                    escape(string.chars())\n-                } else {\n-                    escape(string.nfc())\n-                }));\n+        span_help_and_lint(cx,\n+                           NON_ASCII_LITERAL,\n+                           span,\n+                           \"literal non-ASCII character detected\",\n+                           &format!(\"Consider replacing the string with:\\n\\\"{}\\\"\",\n+                                    if cx.current_level(UNICODE_NOT_NFC) == Level::Allow {\n+                                        escape(string.chars())\n+                                    } else {\n+                                        escape(string.nfc())\n+                                    }));\n     }\n-    if cx.current_level(NON_ASCII_LITERAL) == Level::Allow &&\n-            string.chars().zip(string.nfc()).any(|(a, b)| a != b) {\n-        span_help_and_lint(cx, UNICODE_NOT_NFC, span,\n-            \"non-nfc unicode sequence detected\",\n-            &format!(\"Consider replacing the string with:\\n\\\"{}\\\"\",\n-                string.nfc().collect::<String>()));\n+    if cx.current_level(NON_ASCII_LITERAL) == Level::Allow && string.chars().zip(string.nfc()).any(|(a, b)| a != b) {\n+        span_help_and_lint(cx,\n+                           UNICODE_NOT_NFC,\n+                           span,\n+                           \"non-nfc unicode sequence detected\",\n+                           &format!(\"Consider replacing the string with:\\n\\\"{}\\\"\", string.nfc().collect::<String>()));\n     }\n }"}, {"sha": "74a15927ad11f1d31fceb63cb62356e6484e0f05", "filename": "src/utils.rs", "status": "modified", "additions": 151, "deletions": 150, "changes": 301, "blob_url": "https://github.com/rust-lang/rust/blob/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9342d01213ca1663d2cdf23289bae024823ae6a/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=c9342d01213ca1663d2cdf23289bae024823ae6a", "patch": "@@ -19,15 +19,15 @@ use std::ops::{Deref, DerefMut};\n pub type MethodArgs = HirVec<P<Expr>>;\n \n // module DefPaths for certain structs/enums we check for\n-pub const OPTION_PATH:  [&'static str; 3] = [\"core\", \"option\", \"Option\"];\n-pub const RESULT_PATH:  [&'static str; 3] = [\"core\", \"result\", \"Result\"];\n-pub const STRING_PATH:  [&'static str; 3] = [\"collections\", \"string\", \"String\"];\n-pub const VEC_PATH:     [&'static str; 3] = [\"collections\", \"vec\", \"Vec\"];\n-pub const LL_PATH:      [&'static str; 3] = [\"collections\", \"linked_list\", \"LinkedList\"];\n+pub const OPTION_PATH: [&'static str; 3] = [\"core\", \"option\", \"Option\"];\n+pub const RESULT_PATH: [&'static str; 3] = [\"core\", \"result\", \"Result\"];\n+pub const STRING_PATH: [&'static str; 3] = [\"collections\", \"string\", \"String\"];\n+pub const VEC_PATH: [&'static str; 3] = [\"collections\", \"vec\", \"Vec\"];\n+pub const LL_PATH: [&'static str; 3] = [\"collections\", \"linked_list\", \"LinkedList\"];\n pub const HASHMAP_PATH: [&'static str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"HashMap\"];\n pub const OPEN_OPTIONS_PATH: [&'static str; 3] = [\"std\", \"fs\", \"OpenOptions\"];\n-pub const MUTEX_PATH:   [&'static str; 4] = [\"std\", \"sync\", \"mutex\", \"Mutex\"];\n-pub const CLONE_PATH:   [&'static str; 2] = [\"Clone\", \"clone\"];\n+pub const MUTEX_PATH: [&'static str; 4] = [\"std\", \"sync\", \"mutex\", \"Mutex\"];\n+pub const CLONE_PATH: [&'static str; 2] = [\"Clone\", \"clone\"];\n pub const BEGIN_UNWIND: [&'static str; 3] = [\"std\", \"rt\", \"begin_unwind\"];\n \n /// Produce a nested chain of if-lets and ifs from the patterns:\n@@ -82,8 +82,7 @@ pub fn differing_macro_contexts(sp1: Span, sp2: Span) -> bool {\n }\n /// returns true if this expn_info was expanded by any macro\n pub fn in_macro<T: LintContext>(cx: &T, span: Span) -> bool {\n-    cx.sess().codemap().with_expn_info(span.expn_id,\n-            |info| info.is_some())\n+    cx.sess().codemap().with_expn_info(span.expn_id, |info| info.is_some())\n }\n \n /// returns true if the macro that expanded the crate was outside of\n@@ -95,52 +94,48 @@ pub fn in_external_macro<T: LintContext>(cx: &T, span: Span) -> bool {\n         // no ExpnInfo = no macro\n         opt_info.map_or(false, |info| {\n             if let ExpnFormat::MacroAttribute(..) = info.callee.format {\n-                    // these are all plugins\n-                    return true;\n+                // these are all plugins\n+                return true;\n             }\n             // no span for the callee = external macro\n             info.callee.span.map_or(true, |span| {\n                 // no snippet = external macro or compiler-builtin expansion\n-                cx.sess().codemap().span_to_snippet(span).ok().map_or(true, |code|\n-                    // macro doesn't start with \"macro_rules\"\n-                    // = compiler plugin\n-                    !code.starts_with(\"macro_rules\")\n-                )\n+                cx.sess().codemap().span_to_snippet(span).ok().map_or(true, |code| !code.starts_with(\"macro_rules\"))\n             })\n         })\n     }\n \n-    cx.sess().codemap().with_expn_info(span.expn_id,\n-            |info| in_macro_ext(cx, info))\n+    cx.sess().codemap().with_expn_info(span.expn_id, |info| in_macro_ext(cx, info))\n }\n \n /// check if a DefId's path matches the given absolute type path\n /// usage e.g. with\n /// `match_def_path(cx, id, &[\"core\", \"option\", \"Option\"])`\n pub fn match_def_path(cx: &LateContext, def_id: DefId, path: &[&str]) -> bool {\n-    cx.tcx.with_path(def_id, |iter| iter.zip(path)\n-                                        .all(|(nm, p)| nm.name().as_str() == *p))\n+    cx.tcx.with_path(def_id, |iter| {\n+        iter.zip(path)\n+            .all(|(nm, p)| nm.name().as_str() == *p)\n+    })\n }\n \n /// check if type is struct or enum type with given def path\n pub fn match_type(cx: &LateContext, ty: ty::Ty, path: &[&str]) -> bool {\n     match ty.sty {\n-        ty::TyEnum(ref adt, _) | ty::TyStruct(ref adt, _) => {\n-            match_def_path(cx, adt.did, path)\n-        }\n-        _ => {\n-            false\n-        }\n+        ty::TyEnum(ref adt, _) | ty::TyStruct(ref adt, _) => match_def_path(cx, adt.did, path),\n+        _ => false,\n     }\n }\n \n /// check if method call given in \"expr\" belongs to given trait\n pub fn match_impl_method(cx: &LateContext, expr: &Expr, path: &[&str]) -> bool {\n     let method_call = ty::MethodCall::expr(expr.id);\n \n-    let trt_id = cx.tcx.tables\n-                       .borrow().method_map.get(&method_call)\n-                       .and_then(|callee| cx.tcx.impl_of_method(callee.def_id));\n+    let trt_id = cx.tcx\n+                   .tables\n+                   .borrow()\n+                   .method_map\n+                   .get(&method_call)\n+                   .and_then(|callee| cx.tcx.impl_of_method(callee.def_id));\n     if let Some(trt_id) = trt_id {\n         match_def_path(cx, trt_id, path)\n     } else {\n@@ -151,9 +146,12 @@ pub fn match_impl_method(cx: &LateContext, expr: &Expr, path: &[&str]) -> bool {\n /// check if method call given in \"expr\" belongs to given trait\n pub fn match_trait_method(cx: &LateContext, expr: &Expr, path: &[&str]) -> bool {\n     let method_call = ty::MethodCall::expr(expr.id);\n-    let trt_id = cx.tcx.tables\n-                       .borrow().method_map.get(&method_call)\n-                       .and_then(|callee| cx.tcx.trait_of_item(callee.def_id));\n+    let trt_id = cx.tcx\n+                   .tables\n+                   .borrow()\n+                   .method_map\n+                   .get(&method_call)\n+                   .and_then(|callee| cx.tcx.trait_of_item(callee.def_id));\n     if let Some(trt_id) = trt_id {\n         match_def_path(cx, trt_id, path)\n     } else {\n@@ -164,15 +162,13 @@ pub fn match_trait_method(cx: &LateContext, expr: &Expr, path: &[&str]) -> bool\n /// match a Path against a slice of segment string literals, e.g.\n /// `match_path(path, &[\"std\", \"rt\", \"begin_unwind\"])`\n pub fn match_path(path: &Path, segments: &[&str]) -> bool {\n-    path.segments.iter().rev().zip(segments.iter().rev()).all(\n-        |(a, b)| a.identifier.name.as_str() == *b)\n+    path.segments.iter().rev().zip(segments.iter().rev()).all(|(a, b)| a.identifier.name.as_str() == *b)\n }\n \n /// match a Path against a slice of segment string literals, e.g.\n /// `match_path(path, &[\"std\", \"rt\", \"begin_unwind\"])`\n pub fn match_path_ast(path: &ast::Path, segments: &[&str]) -> bool {\n-    path.segments.iter().rev().zip(segments.iter().rev()).all(\n-        |(a, b)| a.identifier.name.as_str() == *b)\n+    path.segments.iter().rev().zip(segments.iter().rev()).all(|(a, b)| a.identifier.name.as_str() == *b)\n }\n \n /// match an Expr against a chain of methods, and return the matched Exprs. For example, if `expr`\n@@ -181,17 +177,16 @@ pub fn match_path_ast(path: &ast::Path, segments: &[&str]) -> bool {\n pub fn method_chain_args<'a>(expr: &'a Expr, methods: &[&str]) -> Option<Vec<&'a MethodArgs>> {\n     let mut current = expr;\n     let mut matched = Vec::with_capacity(methods.len());\n-    for method_name in methods.iter().rev() { // method chains are stored last -> first\n+    for method_name in methods.iter().rev() {\n+        // method chains are stored last -> first\n         if let ExprMethodCall(ref name, _, ref args) = current.node {\n             if name.node.as_str() == *method_name {\n                 matched.push(args); // build up `matched` backwards\n                 current = &args[0] // go to parent expression\n-            }\n-            else {\n+            } else {\n                 return None;\n             }\n-        }\n-        else {\n+        } else {\n             return None;\n         }\n     }\n@@ -206,9 +201,7 @@ pub fn get_item_name(cx: &LateContext, expr: &Expr) -> Option<Name> {\n     match cx.tcx.map.find(parent_id) {\n         Some(NodeItem(&Item{ ref name, .. })) |\n         Some(NodeTraitItem(&TraitItem{ ref name, .. })) |\n-        Some(NodeImplItem(&ImplItem{ ref name, .. })) => {\n-            Some(*name)\n-        }\n+        Some(NodeImplItem(&ImplItem{ ref name, .. })) => Some(*name),\n         _ => None,\n     }\n }\n@@ -249,9 +242,7 @@ pub fn snippet_block<'a, T: LintContext>(cx: &T, span: Span, default: &'a str) -\n \n /// Like snippet_block, but add braces if the expr is not an ExprBlock\n /// Also takes an Option<String> which can be put inside the braces\n-pub fn expr_block<'a, T: LintContext>(cx: &T, expr: &Expr,\n-                                      option: Option<String>,\n-                                      default: &'a str) -> Cow<'a, str> {\n+pub fn expr_block<'a, T: LintContext>(cx: &T, expr: &Expr, option: Option<String>, default: &'a str) -> Cow<'a, str> {\n     let code = snippet_block(cx, expr.span, default);\n     let string = option.map_or(\"\".to_owned(), |s| s);\n     if let ExprBlock(_) = expr.node {\n@@ -272,21 +263,33 @@ pub fn trim_multiline(s: Cow<str>, ignore_first: bool) -> Cow<str> {\n }\n \n fn trim_multiline_inner(s: Cow<str>, ignore_first: bool, ch: char) -> Cow<str> {\n-    let x = s.lines().skip(ignore_first as usize)\n-             .filter_map(|l| { if l.len() > 0 { // ignore empty lines\n-                                Some(l.char_indices()\n-                                      .find(|&(_,x)| x != ch)\n-                                      .unwrap_or((l.len(), ch)).0)\n-                               } else {None}})\n-             .min().unwrap_or(0);\n+    let x = s.lines()\n+             .skip(ignore_first as usize)\n+             .filter_map(|l| {\n+                 if l.len() > 0 {\n+                     // ignore empty lines\n+                     Some(l.char_indices()\n+                           .find(|&(_, x)| x != ch)\n+                           .unwrap_or((l.len(), ch))\n+                           .0)\n+                 } else {\n+                     None\n+                 }\n+             })\n+             .min()\n+             .unwrap_or(0);\n     if x > 0 {\n-        Cow::Owned(s.lines().enumerate().map(|(i,l)| if (ignore_first && i == 0) ||\n-                                                         l.len() == 0 {\n-                                                        l\n-                                                     } else {\n-                                                        l.split_at(x).1\n-                                                     }).collect::<Vec<_>>()\n-                                       .join(\"\\n\"))\n+        Cow::Owned(s.lines()\n+                    .enumerate()\n+                    .map(|(i, l)| {\n+                        if (ignore_first && i == 0) || l.len() == 0 {\n+                            l\n+                        } else {\n+                            l.split_at(x).1\n+                        }\n+                    })\n+                    .collect::<Vec<_>>()\n+                    .join(\"\\n\"))\n     } else {\n         s\n     }\n@@ -295,11 +298,18 @@ fn trim_multiline_inner(s: Cow<str>, ignore_first: bool, ch: char) -> Cow<str> {\n /// get a parent expr if any \u2013 this is useful to constrain a lint\n pub fn get_parent_expr<'c>(cx: &'c LateContext, e: &Expr) -> Option<&'c Expr> {\n     let map = &cx.tcx.map;\n-    let node_id : NodeId = e.id;\n-    let parent_id : NodeId = map.get_parent_node(node_id);\n-    if node_id == parent_id { return None; }\n-    map.find(parent_id).and_then(|node|\n-        if let NodeExpr(parent) = node { Some(parent) } else { None } )\n+    let node_id: NodeId = e.id;\n+    let parent_id: NodeId = map.get_parent_node(node_id);\n+    if node_id == parent_id {\n+        return None;\n+    }\n+    map.find(parent_id).and_then(|node| {\n+        if let NodeExpr(parent) = node {\n+            Some(parent)\n+        } else {\n+            None\n+        }\n+    })\n }\n \n pub fn get_enclosing_block<'c>(cx: &'c LateContext, node: NodeId) -> Option<&'c Block> {\n@@ -310,9 +320,11 @@ pub fn get_enclosing_block<'c>(cx: &'c LateContext, node: NodeId) -> Option<&'c\n         match node {\n             NodeBlock(ref block) => Some(block),\n             NodeItem(&Item{ node: ItemFn(_, _, _, _, _, ref block), .. }) => Some(block),\n-            _ => None\n+            _ => None,\n         }\n-    } else { None }\n+    } else {\n+        None\n+    }\n }\n \n pub struct DiagnosticWrapper<'a>(pub DiagnosticBuilder<'a>);\n@@ -326,78 +338,81 @@ impl<'a> Drop for DiagnosticWrapper<'a> {\n impl<'a> DerefMut for DiagnosticWrapper<'a> {\n     fn deref_mut(&mut self) -> &mut DiagnosticBuilder<'a> {\n         &mut self.0\n-    } \n+    }\n }\n \n impl<'a> Deref for DiagnosticWrapper<'a> {\n     type Target = DiagnosticBuilder<'a>;\n     fn deref(&self) -> &DiagnosticBuilder<'a> {\n         &self.0\n-    } \n+    }\n }\n \n #[cfg(not(feature=\"structured_logging\"))]\n-pub fn span_lint<'a, T: LintContext>(cx: &'a T, lint: &'static Lint,\n-                                     sp: Span, msg: &str) -> DiagnosticWrapper<'a> {\n+pub fn span_lint<'a, T: LintContext>(cx: &'a T, lint: &'static Lint, sp: Span, msg: &str) -> DiagnosticWrapper<'a> {\n     let mut db = cx.struct_span_lint(lint, sp, msg);\n     if cx.current_level(lint) != Level::Allow {\n-        db.fileline_help(sp, &format!(\"for further information visit \\\n-            https://github.com/Manishearth/rust-clippy/wiki#{}\",\n-            lint.name_lower()));\n+        db.fileline_help(sp,\n+                         &format!(\"for further information visit https://github.com/Manishearth/rust-clippy/wiki#{}\",\n+                                  lint.name_lower()));\n     }\n     DiagnosticWrapper(db)\n }\n \n #[cfg(feature=\"structured_logging\")]\n-pub fn span_lint<'a, T: LintContext>(cx: &'a T, lint: &'static Lint,\n-                                     sp: Span, msg: &str) -> DiagnosticWrapper<'a> {\n+pub fn span_lint<'a, T: LintContext>(cx: &'a T, lint: &'static Lint, sp: Span, msg: &str) -> DiagnosticWrapper<'a> {\n     // lint.name / lint.desc is can give details of the lint\n     // cx.sess().codemap() has all these nice functions for line/column/snippet details\n     // http://doc.rust-lang.org/syntax/codemap/struct.CodeMap.html#method.span_to_string\n     let mut db = cx.struct_span_lint(lint, sp, msg);\n     if cx.current_level(lint) != Level::Allow {\n-        db.fileline_help(sp, &format!(\"for further information visit \\\n-            https://github.com/Manishearth/rust-clippy/wiki#{}\",\n-            lint.name_lower()));\n+        db.fileline_help(sp,\n+                         &format!(\"for further information visit https://github.com/Manishearth/rust-clippy/wiki#{}\",\n+                                  lint.name_lower()));\n     }\n     DiagnosticWrapper(db)\n }\n \n-pub fn span_help_and_lint<'a, T: LintContext>(cx: &'a T, lint: &'static Lint, span: Span,\n-        msg: &str, help: &str) -> DiagnosticWrapper<'a> {\n+pub fn span_help_and_lint<'a, T: LintContext>(cx: &'a T, lint: &'static Lint, span: Span, msg: &str, help: &str)\n+                                              -> DiagnosticWrapper<'a> {\n     let mut db = cx.struct_span_lint(lint, span, msg);\n     if cx.current_level(lint) != Level::Allow {\n-        db.fileline_help(span, &format!(\"{}\\nfor further information \\\n-            visit https://github.com/Manishearth/rust-clippy/wiki#{}\",\n-            help, lint.name_lower()));\n+        db.fileline_help(span,\n+                         &format!(\"{}\\nfor further information visit \\\n+                                   https://github.com/Manishearth/rust-clippy/wiki#{}\",\n+                                  help,\n+                                  lint.name_lower()));\n     }\n     DiagnosticWrapper(db)\n }\n \n-pub fn span_note_and_lint<'a, T: LintContext>(cx: &'a T, lint: &'static Lint, span: Span,\n-        msg: &str, note_span: Span, note: &str) -> DiagnosticWrapper<'a> {\n+pub fn span_note_and_lint<'a, T: LintContext>(cx: &'a T, lint: &'static Lint, span: Span, msg: &str, note_span: Span,\n+                                              note: &str)\n+                                              -> DiagnosticWrapper<'a> {\n     let mut db = cx.struct_span_lint(lint, span, msg);\n     if cx.current_level(lint) != Level::Allow {\n         if note_span == span {\n             db.fileline_note(note_span, note);\n         } else {\n             db.span_note(note_span, note);\n         }\n-        db.fileline_help(span, &format!(\"for further information visit \\\n-            https://github.com/Manishearth/rust-clippy/wiki#{}\",\n-            lint.name_lower()));\n+        db.fileline_help(span,\n+                         &format!(\"for further information visit https://github.com/Manishearth/rust-clippy/wiki#{}\",\n+                                  lint.name_lower()));\n     }\n     DiagnosticWrapper(db)\n }\n \n-pub fn span_lint_and_then<'a, T: LintContext, F>(cx: &'a T, lint: &'static Lint, sp: Span,\n-        msg: &str, f: F) -> DiagnosticWrapper<'a> where F: Fn(&mut DiagnosticWrapper) {\n+pub fn span_lint_and_then<'a, T: LintContext, F>(cx: &'a T, lint: &'static Lint, sp: Span, msg: &str, f: F)\n+                                                 -> DiagnosticWrapper<'a>\n+    where F: Fn(&mut DiagnosticWrapper)\n+{\n     let mut db = DiagnosticWrapper(cx.struct_span_lint(lint, sp, msg));\n     if cx.current_level(lint) != Level::Allow {\n         f(&mut db);\n-        db.fileline_help(sp, &format!(\"for further information visit \\\n-            https://github.com/Manishearth/rust-clippy/wiki#{}\",\n-            lint.name_lower()));\n+        db.fileline_help(sp,\n+                         &format!(\"for further information visit https://github.com/Manishearth/rust-clippy/wiki#{}\",\n+                                  lint.name_lower()));\n     }\n     db\n }\n@@ -406,7 +421,7 @@ pub fn span_lint_and_then<'a, T: LintContext, F>(cx: &'a T, lint: &'static Lint,\n pub fn walk_ptrs_ty(ty: ty::Ty) -> ty::Ty {\n     match ty.sty {\n         ty::TyRef(_, ref tm) | ty::TyRawPtr(ref tm) => walk_ptrs_ty(tm.ty),\n-        _ => ty\n+        _ => ty,\n     }\n }\n \n@@ -415,14 +430,13 @@ pub fn walk_ptrs_ty_depth(ty: ty::Ty) -> (ty::Ty, usize) {\n     fn inner(ty: ty::Ty, depth: usize) -> (ty::Ty, usize) {\n         match ty.sty {\n             ty::TyRef(_, ref tm) | ty::TyRawPtr(ref tm) => inner(tm.ty, depth + 1),\n-            _ => (ty, depth)\n+            _ => (ty, depth),\n         }\n     }\n     inner(ty, 0)\n }\n \n-pub fn is_integer_literal(expr: &Expr, value: u64) -> bool\n-{\n+pub fn is_integer_literal(expr: &Expr, value: u64) -> bool {\n     // FIXME: use constant folding\n     if let ExprLit(ref spanned) = expr.node {\n         if let LitInt(v, _) = spanned.node {\n@@ -448,37 +462,27 @@ impl Drop for LimitStack {\n \n impl LimitStack {\n     pub fn new(limit: u64) -> LimitStack {\n-        LimitStack {\n-            stack: vec![limit],\n-        }\n+        LimitStack { stack: vec![limit] }\n     }\n     pub fn limit(&self) -> u64 {\n         *self.stack.last().expect(\"there should always be a value in the stack\")\n     }\n     pub fn push_attrs(&mut self, sess: &Session, attrs: &[ast::Attribute], name: &'static str) {\n         let stack = &mut self.stack;\n-        parse_attrs(\n-            sess,\n-            attrs,\n-            name,\n-            |val| stack.push(val),\n-        );\n+        parse_attrs(sess, attrs, name, |val| stack.push(val));\n     }\n     pub fn pop_attrs(&mut self, sess: &Session, attrs: &[ast::Attribute], name: &'static str) {\n         let stack = &mut self.stack;\n-        parse_attrs(\n-            sess,\n-            attrs,\n-            name,\n-            |val| assert_eq!(stack.pop(), Some(val)),\n-        );\n+        parse_attrs(sess, attrs, name, |val| assert_eq!(stack.pop(), Some(val)));\n     }\n }\n \n fn parse_attrs<F: FnMut(u64)>(sess: &Session, attrs: &[ast::Attribute], name: &'static str, mut f: F) {\n     for attr in attrs {\n         let attr = &attr.node;\n-        if attr.is_sugared_doc { continue; }\n+        if attr.is_sugared_doc {\n+            continue;\n+        }\n         if let ast::MetaNameValue(ref key, ref value) = attr.value.node {\n             if *key == name {\n                 if let LitStr(ref s, _) = value.node {\n@@ -495,70 +499,67 @@ fn parse_attrs<F: FnMut(u64)>(sess: &Session, attrs: &[ast::Attribute], name: &'\n     }\n }\n \n-pub fn is_exp_equal(cx: &LateContext, left : &Expr, right : &Expr) -> bool {\n+pub fn is_exp_equal(cx: &LateContext, left: &Expr, right: &Expr) -> bool {\n     if let (Some(l), Some(r)) = (constant(cx, left), constant(cx, right)) {\n         if l == r {\n             return true;\n         }\n     }\n     match (&left.node, &right.node) {\n-        (&ExprField(ref lfexp, ref lfident),\n-                &ExprField(ref rfexp, ref rfident)) =>\n-            lfident.node == rfident.node && is_exp_equal(cx, lfexp, rfexp),\n+        (&ExprField(ref lfexp, ref lfident), &ExprField(ref rfexp, ref rfident)) => {\n+            lfident.node == rfident.node && is_exp_equal(cx, lfexp, rfexp)\n+        }\n         (&ExprLit(ref l), &ExprLit(ref r)) => l.node == r.node,\n-        (&ExprPath(ref lqself, ref lsubpath),\n-                &ExprPath(ref rqself, ref rsubpath)) =>\n-            both(lqself, rqself, is_qself_equal) &&\n-                is_path_equal(lsubpath, rsubpath),\n-        (&ExprTup(ref ltup), &ExprTup(ref rtup)) =>\n-            is_exps_equal(cx, ltup, rtup),\n+        (&ExprPath(ref lqself, ref lsubpath), &ExprPath(ref rqself, ref rsubpath)) => {\n+            both(lqself, rqself, is_qself_equal) && is_path_equal(lsubpath, rsubpath)\n+        }\n+        (&ExprTup(ref ltup), &ExprTup(ref rtup)) => is_exps_equal(cx, ltup, rtup),\n         (&ExprVec(ref l), &ExprVec(ref r)) => is_exps_equal(cx, l, r),\n-        (&ExprCast(ref lx, ref lt), &ExprCast(ref rx, ref rt)) =>\n-            is_exp_equal(cx, lx, rx) && is_cast_ty_equal(lt, rt),\n-        _ => false\n+        (&ExprCast(ref lx, ref lt), &ExprCast(ref rx, ref rt)) => is_exp_equal(cx, lx, rx) && is_cast_ty_equal(lt, rt),\n+        _ => false,\n     }\n }\n \n-fn is_exps_equal(cx: &LateContext, left : &[P<Expr>], right : &[P<Expr>]) -> bool {\n+fn is_exps_equal(cx: &LateContext, left: &[P<Expr>], right: &[P<Expr>]) -> bool {\n     over(left, right, |l, r| is_exp_equal(cx, l, r))\n }\n \n-fn is_path_equal(left : &Path, right : &Path) -> bool {\n+fn is_path_equal(left: &Path, right: &Path) -> bool {\n     // The == of idents doesn't work with different contexts,\n     // we have to be explicit about hygiene\n-    left.global == right.global && over(&left.segments, &right.segments,\n-        |l, r| l.identifier.name == r.identifier.name\n-               && l.parameters == r.parameters)\n+    left.global == right.global &&\n+    over(&left.segments,\n+         &right.segments,\n+         |l, r| l.identifier.name == r.identifier.name && l.parameters == r.parameters)\n }\n \n-fn is_qself_equal(left : &QSelf, right : &QSelf) -> bool {\n+fn is_qself_equal(left: &QSelf, right: &QSelf) -> bool {\n     left.ty.node == right.ty.node && left.position == right.position\n }\n \n fn over<X, F>(left: &[X], right: &[X], mut eq_fn: F) -> bool\n-        where F: FnMut(&X, &X) -> bool {\n-    left.len() == right.len() && left.iter().zip(right).all(|(x, y)|\n-        eq_fn(x, y))\n+    where F: FnMut(&X, &X) -> bool\n+{\n+    left.len() == right.len() && left.iter().zip(right).all(|(x, y)| eq_fn(x, y))\n }\n \n-fn both<X, F>(l: &Option<X>, r: &Option<X>, mut eq_fn : F) -> bool\n-        where F: FnMut(&X, &X) -> bool {\n-    l.as_ref().map_or_else(|| r.is_none(), |x| r.as_ref().map_or(false,\n-        |y| eq_fn(x, y)))\n+fn both<X, F>(l: &Option<X>, r: &Option<X>, mut eq_fn: F) -> bool\n+    where F: FnMut(&X, &X) -> bool\n+{\n+    l.as_ref().map_or_else(|| r.is_none(), |x| r.as_ref().map_or(false, |y| eq_fn(x, y)))\n }\n \n fn is_cast_ty_equal(left: &Ty, right: &Ty) -> bool {\n     match (&left.node, &right.node) {\n         (&TyVec(ref lvec), &TyVec(ref rvec)) => is_cast_ty_equal(lvec, rvec),\n-        (&TyPtr(ref lmut), &TyPtr(ref rmut)) =>\n-            lmut.mutbl == rmut.mutbl &&\n-            is_cast_ty_equal(&*lmut.ty, &*rmut.ty),\n-        (&TyRptr(_, ref lrmut), &TyRptr(_, ref rrmut)) =>\n-            lrmut.mutbl == rrmut.mutbl &&\n-            is_cast_ty_equal(&*lrmut.ty, &*rrmut.ty),\n-        (&TyPath(ref lq, ref lpath), &TyPath(ref rq, ref rpath)) =>\n-            both(lq, rq, is_qself_equal) && is_path_equal(lpath, rpath),\n+        (&TyPtr(ref lmut), &TyPtr(ref rmut)) => lmut.mutbl == rmut.mutbl && is_cast_ty_equal(&*lmut.ty, &*rmut.ty),\n+        (&TyRptr(_, ref lrmut), &TyRptr(_, ref rrmut)) => {\n+            lrmut.mutbl == rrmut.mutbl && is_cast_ty_equal(&*lrmut.ty, &*rrmut.ty)\n+        }\n+        (&TyPath(ref lq, ref lpath), &TyPath(ref rq, ref rpath)) => {\n+            both(lq, rq, is_qself_equal) && is_path_equal(lpath, rpath)\n+        }\n         (&TyInfer, &TyInfer) => true,\n-        _ => false\n+        _ => false,\n     }\n }"}]}