{"sha": "7b3c4aa77170e10ddc78e4661392d02feb5e5cd7", "node_id": "C_kwDOAAsO6NoAKDdiM2M0YWE3NzE3MGUxMGRkYzc4ZTQ2NjEzOTJkMDJmZWI1ZTVjZDc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-21T18:59:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-21T18:59:03Z"}, "message": "Auto merge of #10520 - Nilstrieb:uninit, r=Alexendoo\n\nUse uninit checking from rustc\n\nrustc has proper heuristics for actually checking whether a type allows being left uninitialized (by asking CTFE). We can now use this for our helper instead of rolling our own bad version with false positives.\n\nI added this in rustc in rust-lang/rust#108669\n\nFix #10407\n\nchangelog: [`uninit_vec`]: fix false positives\nchangelog: [`uninit_assumed_init`]: fix false positives", "tree": {"sha": "e30ab187f12c3deaed21a764d97a5cbe63dbe469", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e30ab187f12c3deaed21a764d97a5cbe63dbe469"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7b3c4aa77170e10ddc78e4661392d02feb5e5cd7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7b3c4aa77170e10ddc78e4661392d02feb5e5cd7", "html_url": "https://github.com/rust-lang/rust/commit/7b3c4aa77170e10ddc78e4661392d02feb5e5cd7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7b3c4aa77170e10ddc78e4661392d02feb5e5cd7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0a77f4c5b1e33170e8ae9b70eded428ba20c5d9b", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a77f4c5b1e33170e8ae9b70eded428ba20c5d9b", "html_url": "https://github.com/rust-lang/rust/commit/0a77f4c5b1e33170e8ae9b70eded428ba20c5d9b"}, {"sha": "84b6049eb9502cd9ba2f1518c26b6525b2fb2752", "url": "https://api.github.com/repos/rust-lang/rust/commits/84b6049eb9502cd9ba2f1518c26b6525b2fb2752", "html_url": "https://github.com/rust-lang/rust/commit/84b6049eb9502cd9ba2f1518c26b6525b2fb2752"}], "stats": {"total": 114, "additions": 83, "deletions": 31}, "files": [{"sha": "0b47234647fb6120240578d2ec43c60b81ce07d7", "filename": "clippy_utils/src/ty.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7b3c4aa77170e10ddc78e4661392d02feb5e5cd7/clippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b3c4aa77170e10ddc78e4661392d02feb5e5cd7/clippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fty.rs?ref=7b3c4aa77170e10ddc78e4661392d02feb5e5cd7", "patch": "@@ -16,9 +16,9 @@ use rustc_infer::infer::{\n use rustc_lint::LateContext;\n use rustc_middle::mir::interpret::{ConstValue, Scalar};\n use rustc_middle::ty::{\n-    self, AdtDef, AliasTy, AssocKind, Binder, BoundRegion, FnSig, IntTy, List, ParamEnv, Predicate, PredicateKind,\n-    Region, RegionKind, SubstsRef, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable, TypeVisitableExt, TypeVisitor,\n-    UintTy, VariantDef, VariantDiscr,\n+    self, layout::ValidityRequirement, AdtDef, AliasTy, AssocKind, Binder, BoundRegion, FnSig, IntTy, List, ParamEnv,\n+    Predicate, PredicateKind, Region, RegionKind, SubstsRef, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable,\n+    TypeVisitableExt, TypeVisitor, UintTy, VariantDef, VariantDiscr,\n };\n use rustc_middle::ty::{GenericArg, GenericArgKind};\n use rustc_span::symbol::Ident;\n@@ -538,13 +538,12 @@ pub fn same_type_and_consts<'tcx>(a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n }\n \n /// Checks if a given type looks safe to be uninitialized.\n-pub fn is_uninit_value_valid_for_ty(cx: &LateContext<'_>, ty: Ty<'_>) -> bool {\n-    match *ty.kind() {\n-        ty::Array(component, _) => is_uninit_value_valid_for_ty(cx, component),\n-        ty::Tuple(types) => types.iter().all(|ty| is_uninit_value_valid_for_ty(cx, ty)),\n-        ty::Adt(adt, _) => cx.tcx.lang_items().maybe_uninit() == Some(adt.did()),\n-        _ => false,\n-    }\n+pub fn is_uninit_value_valid_for_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n+    cx.tcx\n+        .check_validity_requirement((ValidityRequirement::Uninit, cx.param_env.and(ty)))\n+        // For types containing generic parameters we cannot get a layout to check.\n+        // Therefore, we are conservative and assume that they don't allow uninit.\n+        .unwrap_or(false)\n }\n \n /// Gets an iterator over all predicates which apply to the given item."}, {"sha": "412b36b4ee8f1b1631fe1f071d1be10888007bac", "filename": "tests/ui/uninit.rs", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7b3c4aa77170e10ddc78e4661392d02feb5e5cd7/tests%2Fui%2Funinit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b3c4aa77170e10ddc78e4661392d02feb5e5cd7/tests%2Fui%2Funinit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funinit.rs?ref=7b3c4aa77170e10ddc78e4661392d02feb5e5cd7", "patch": "@@ -3,13 +3,15 @@\n \n use std::mem::{self, MaybeUninit};\n \n+union MyOwnMaybeUninit {\n+    value: u8,\n+    uninit: (),\n+}\n+\n fn main() {\n     let _: usize = unsafe { MaybeUninit::uninit().assume_init() };\n \n-    // edge case: For now we lint on empty arrays\n-    let _: [u8; 0] = unsafe { MaybeUninit::uninit().assume_init() };\n-\n-    // edge case: For now we accept unit tuples\n+    // This is OK, because ZSTs do not contain data.\n     let _: () = unsafe { MaybeUninit::uninit().assume_init() };\n \n     // This is OK, because `MaybeUninit` allows uninitialized data.\n@@ -21,6 +23,19 @@ fn main() {\n     // This is OK, because all constitutent types are uninit-compatible.\n     let _: (MaybeUninit<usize>, [MaybeUninit<bool>; 2]) = unsafe { MaybeUninit::uninit().assume_init() };\n \n+    // This is OK, because our own MaybeUninit is just as fine as the one from core.\n+    let _: MyOwnMaybeUninit = unsafe { MaybeUninit::uninit().assume_init() };\n+\n+    // This is OK, because empty arrays don't contain data.\n+    let _: [u8; 0] = unsafe { MaybeUninit::uninit().assume_init() };\n+\n     // Was a false negative.\n     let _: usize = unsafe { mem::MaybeUninit::uninit().assume_init() };\n+\n+    polymorphic::<()>();\n+\n+    fn polymorphic<T>() {\n+        // We are conservative around polymorphic types.\n+        let _: T = unsafe { mem::MaybeUninit::uninit().assume_init() };\n+    }\n }"}, {"sha": "9e01b9a4aa816b3e28845631954af8471b290e19", "filename": "tests/ui/uninit.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7b3c4aa77170e10ddc78e4661392d02feb5e5cd7/tests%2Fui%2Funinit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7b3c4aa77170e10ddc78e4661392d02feb5e5cd7/tests%2Fui%2Funinit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funinit.stderr?ref=7b3c4aa77170e10ddc78e4661392d02feb5e5cd7", "patch": "@@ -1,21 +1,21 @@\n error: this call for this type may be undefined behavior\n-  --> $DIR/uninit.rs:7:29\n+  --> $DIR/uninit.rs:12:29\n    |\n LL |     let _: usize = unsafe { MaybeUninit::uninit().assume_init() };\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `#[deny(clippy::uninit_assumed_init)]` on by default\n \n error: this call for this type may be undefined behavior\n-  --> $DIR/uninit.rs:10:31\n+  --> $DIR/uninit.rs:33:29\n    |\n-LL |     let _: [u8; 0] = unsafe { MaybeUninit::uninit().assume_init() };\n-   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     let _: usize = unsafe { mem::MaybeUninit::uninit().assume_init() };\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: this call for this type may be undefined behavior\n-  --> $DIR/uninit.rs:25:29\n+  --> $DIR/uninit.rs:39:29\n    |\n-LL |     let _: usize = unsafe { mem::MaybeUninit::uninit().assume_init() };\n+LL |         let _: T = unsafe { mem::MaybeUninit::uninit().assume_init() };\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 3 previous errors"}, {"sha": "59ec64a7ab1b9e3a28da817514b10155787a9400", "filename": "tests/ui/uninit_vec.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7b3c4aa77170e10ddc78e4661392d02feb5e5cd7/tests%2Fui%2Funinit_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b3c4aa77170e10ddc78e4661392d02feb5e5cd7/tests%2Fui%2Funinit_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funinit_vec.rs?ref=7b3c4aa77170e10ddc78e4661392d02feb5e5cd7", "patch": "@@ -7,6 +7,11 @@ struct MyVec {\n     vec: Vec<u8>,\n }\n \n+union MyOwnMaybeUninit {\n+    value: u8,\n+    uninit: (),\n+}\n+\n fn main() {\n     // with_capacity() -> set_len() should be detected\n     let mut vec: Vec<u8> = Vec::with_capacity(1000);\n@@ -97,4 +102,26 @@ fn main() {\n     unsafe {\n         vec.set_len(0);\n     }\n+\n+    // ZSTs should not be detected\n+    let mut vec: Vec<()> = Vec::with_capacity(1000);\n+    unsafe {\n+        vec.set_len(10);\n+    }\n+\n+    // unions should not be detected\n+    let mut vec: Vec<MyOwnMaybeUninit> = Vec::with_capacity(1000);\n+    unsafe {\n+        vec.set_len(10);\n+    }\n+\n+    polymorphic::<()>();\n+\n+    fn polymorphic<T>() {\n+        // We are conservative around polymorphic types.\n+        let mut vec: Vec<T> = Vec::with_capacity(1000);\n+        unsafe {\n+            vec.set_len(10);\n+        }\n+    }\n }"}, {"sha": "9cdf0c95ad9f108d4bc0a144658ac222cb98c6e9", "filename": "tests/ui/uninit_vec.stderr", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7b3c4aa77170e10ddc78e4661392d02feb5e5cd7/tests%2Fui%2Funinit_vec.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7b3c4aa77170e10ddc78e4661392d02feb5e5cd7/tests%2Fui%2Funinit_vec.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funinit_vec.stderr?ref=7b3c4aa77170e10ddc78e4661392d02feb5e5cd7", "patch": "@@ -1,5 +1,5 @@\n error: calling `set_len()` immediately after reserving a buffer creates uninitialized values\n-  --> $DIR/uninit_vec.rs:12:5\n+  --> $DIR/uninit_vec.rs:17:5\n    |\n LL |     let mut vec: Vec<u8> = Vec::with_capacity(1000);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -11,7 +11,7 @@ LL |         vec.set_len(200);\n    = note: `-D clippy::uninit-vec` implied by `-D warnings`\n \n error: calling `set_len()` immediately after reserving a buffer creates uninitialized values\n-  --> $DIR/uninit_vec.rs:18:5\n+  --> $DIR/uninit_vec.rs:23:5\n    |\n LL |     vec.reserve(1000);\n    |     ^^^^^^^^^^^^^^^^^^\n@@ -22,7 +22,7 @@ LL |         vec.set_len(200);\n    = help: initialize the buffer or wrap the content in `MaybeUninit`\n \n error: calling `set_len()` on empty `Vec` creates out-of-bound values\n-  --> $DIR/uninit_vec.rs:24:5\n+  --> $DIR/uninit_vec.rs:29:5\n    |\n LL |     let mut vec: Vec<u8> = Vec::new();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -31,7 +31,7 @@ LL |         vec.set_len(200);\n    |         ^^^^^^^^^^^^^^^^\n \n error: calling `set_len()` on empty `Vec` creates out-of-bound values\n-  --> $DIR/uninit_vec.rs:30:5\n+  --> $DIR/uninit_vec.rs:35:5\n    |\n LL |     let mut vec: Vec<u8> = Default::default();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -40,7 +40,7 @@ LL |         vec.set_len(200);\n    |         ^^^^^^^^^^^^^^^^\n \n error: calling `set_len()` on empty `Vec` creates out-of-bound values\n-  --> $DIR/uninit_vec.rs:35:5\n+  --> $DIR/uninit_vec.rs:40:5\n    |\n LL |     let mut vec: Vec<u8> = Vec::default();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -49,7 +49,7 @@ LL |         vec.set_len(200);\n    |         ^^^^^^^^^^^^^^^^\n \n error: calling `set_len()` immediately after reserving a buffer creates uninitialized values\n-  --> $DIR/uninit_vec.rs:49:5\n+  --> $DIR/uninit_vec.rs:54:5\n    |\n LL |     let mut vec: Vec<u8> = Vec::with_capacity(1000);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -60,7 +60,7 @@ LL |         vec.set_len(200);\n    = help: initialize the buffer or wrap the content in `MaybeUninit`\n \n error: calling `set_len()` immediately after reserving a buffer creates uninitialized values\n-  --> $DIR/uninit_vec.rs:58:5\n+  --> $DIR/uninit_vec.rs:63:5\n    |\n LL |     my_vec.vec.reserve(1000);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -71,7 +71,7 @@ LL |         my_vec.vec.set_len(200);\n    = help: initialize the buffer or wrap the content in `MaybeUninit`\n \n error: calling `set_len()` immediately after reserving a buffer creates uninitialized values\n-  --> $DIR/uninit_vec.rs:63:5\n+  --> $DIR/uninit_vec.rs:68:5\n    |\n LL |     my_vec.vec = Vec::with_capacity(1000);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -82,7 +82,7 @@ LL |         my_vec.vec.set_len(200);\n    = help: initialize the buffer or wrap the content in `MaybeUninit`\n \n error: calling `set_len()` immediately after reserving a buffer creates uninitialized values\n-  --> $DIR/uninit_vec.rs:42:9\n+  --> $DIR/uninit_vec.rs:47:9\n    |\n LL |         let mut vec: Vec<u8> = Vec::with_capacity(1000);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -92,7 +92,7 @@ LL |         vec.set_len(200);\n    = help: initialize the buffer or wrap the content in `MaybeUninit`\n \n error: calling `set_len()` immediately after reserving a buffer creates uninitialized values\n-  --> $DIR/uninit_vec.rs:45:9\n+  --> $DIR/uninit_vec.rs:50:9\n    |\n LL |         vec.reserve(1000);\n    |         ^^^^^^^^^^^^^^^^^^\n@@ -101,5 +101,16 @@ LL |         vec.set_len(200);\n    |\n    = help: initialize the buffer or wrap the content in `MaybeUninit`\n \n-error: aborting due to 10 previous errors\n+error: calling `set_len()` immediately after reserving a buffer creates uninitialized values\n+  --> $DIR/uninit_vec.rs:122:9\n+   |\n+LL |         let mut vec: Vec<T> = Vec::with_capacity(1000);\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |         unsafe {\n+LL |             vec.set_len(10);\n+   |             ^^^^^^^^^^^^^^^\n+   |\n+   = help: initialize the buffer or wrap the content in `MaybeUninit`\n+\n+error: aborting due to 11 previous errors\n "}]}