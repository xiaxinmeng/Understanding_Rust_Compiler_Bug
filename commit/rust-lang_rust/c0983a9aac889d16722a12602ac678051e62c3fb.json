{"sha": "c0983a9aac889d16722a12602ac678051e62c3fb", "node_id": "C_kwDOAAsO6NoAKGMwOTgzYTlhYWM4ODlkMTY3MjJhMTI2MDJhYzY3ODA1MWU2MmMzZmI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-12T17:48:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-12T17:48:31Z"}, "message": "Auto merge of #102975 - Dylan-DPC:rollup-vzuwsh2, r=Dylan-DPC\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #102623 (translation: eager translation)\n - #102719 (Enforce alphabetical sorting with tidy)\n - #102830 (Unify `tcx.constness` query and param env constness checks)\n - #102883 (Fix stabilization of `feature(half_open_range_patterns)`)\n - #102927 (Fix `let` keyword removal suggestion in structs)\n - #102936 (rustdoc: remove unused CSS `nav.sum`)\n - #102940 (Update books)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "69917ea3c0bba48597bde38e8736912d184be91a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/69917ea3c0bba48597bde38e8736912d184be91a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c0983a9aac889d16722a12602ac678051e62c3fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c0983a9aac889d16722a12602ac678051e62c3fb", "html_url": "https://github.com/rust-lang/rust/commit/c0983a9aac889d16722a12602ac678051e62c3fb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c0983a9aac889d16722a12602ac678051e62c3fb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "538f118da1409759ba198acc0ff62070bc6d2dce", "url": "https://api.github.com/repos/rust-lang/rust/commits/538f118da1409759ba198acc0ff62070bc6d2dce", "html_url": "https://github.com/rust-lang/rust/commit/538f118da1409759ba198acc0ff62070bc6d2dce"}, {"sha": "f2c48105ce6f0889c18648160f8f0f03b69bc4a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2c48105ce6f0889c18648160f8f0f03b69bc4a4", "html_url": "https://github.com/rust-lang/rust/commit/f2c48105ce6f0889c18648160f8f0f03b69bc4a4"}], "stats": {"total": 1416, "additions": 957, "deletions": 459}, "files": [{"sha": "60b7f2e4c2223e4a89c0dee3f9f7490a0928843e", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=c0983a9aac889d16722a12602ac678051e62c3fb", "patch": "@@ -3039,7 +3039,7 @@ pub type ForeignItem = Item<ForeignItemKind>;\n mod size_asserts {\n     use super::*;\n     use rustc_data_structures::static_assert_size;\n-    // These are in alphabetical order, which is easy to maintain.\n+    // tidy-alphabetical-start\n     static_assert_size!(AssocItem, 104);\n     static_assert_size!(AssocItemKind, 32);\n     static_assert_size!(Attribute, 32);\n@@ -3060,11 +3060,12 @@ mod size_asserts {\n     static_assert_size!(Local, 72);\n     static_assert_size!(Param, 40);\n     static_assert_size!(Pat, 120);\n-    static_assert_size!(PatKind, 96);\n     static_assert_size!(Path, 40);\n     static_assert_size!(PathSegment, 24);\n+    static_assert_size!(PatKind, 96);\n     static_assert_size!(Stmt, 32);\n     static_assert_size!(StmtKind, 16);\n     static_assert_size!(Ty, 96);\n     static_assert_size!(TyKind, 72);\n+    // tidy-alphabetical-end\n }"}, {"sha": "83b10d906e297980ff3b96095bbd1db7a6cd18eb", "filename": "compiler/rustc_ast/src/token.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs?ref=c0983a9aac889d16722a12602ac678051e62c3fb", "patch": "@@ -889,10 +889,11 @@ where\n mod size_asserts {\n     use super::*;\n     use rustc_data_structures::static_assert_size;\n-    // These are in alphabetical order, which is easy to maintain.\n+    // tidy-alphabetical-start\n     static_assert_size!(Lit, 12);\n     static_assert_size!(LitKind, 2);\n     static_assert_size!(Nonterminal, 16);\n     static_assert_size!(Token, 24);\n     static_assert_size!(TokenKind, 16);\n+    // tidy-alphabetical-end\n }"}, {"sha": "015f5c1ee8ae5ab817d7d081d212feeead02ea8f", "filename": "compiler/rustc_ast/src/tokenstream.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs?ref=c0983a9aac889d16722a12602ac678051e62c3fb", "patch": "@@ -646,10 +646,11 @@ impl DelimSpan {\n mod size_asserts {\n     use super::*;\n     use rustc_data_structures::static_assert_size;\n-    // These are in alphabetical order, which is easy to maintain.\n+    // tidy-alphabetical-start\n     static_assert_size!(AttrTokenStream, 8);\n     static_assert_size!(AttrTokenTree, 32);\n     static_assert_size!(LazyAttrTokenStream, 8);\n     static_assert_size!(TokenStream, 8);\n     static_assert_size!(TokenTree, 32);\n+    // tidy-alphabetical-end\n }"}, {"sha": "c6c85ffa84dd720a55a51305e9cb4f2e227e3ea0", "filename": "compiler/rustc_ast_lowering/src/errors.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_ast_lowering%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_ast_lowering%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Ferrors.rs?ref=c0983a9aac889d16722a12602ac678051e62c3fb", "patch": "@@ -1,4 +1,7 @@\n-use rustc_errors::{fluent, AddToDiagnostic, Applicability, Diagnostic, DiagnosticArgFromDisplay};\n+use rustc_errors::{\n+    fluent, AddToDiagnostic, Applicability, Diagnostic, DiagnosticArgFromDisplay,\n+    SubdiagnosticMessage,\n+};\n use rustc_macros::{Diagnostic, Subdiagnostic};\n use rustc_span::{symbol::Ident, Span, Symbol};\n \n@@ -19,7 +22,10 @@ pub struct UseAngleBrackets {\n }\n \n impl AddToDiagnostic for UseAngleBrackets {\n-    fn add_to_diagnostic(self, diag: &mut Diagnostic) {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, _: F)\n+    where\n+        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n+    {\n         diag.multipart_suggestion(\n             fluent::ast_lowering::use_angle_brackets,\n             vec![(self.open_param, String::from(\"<\")), (self.close_param, String::from(\">\"))],\n@@ -69,7 +75,10 @@ pub enum AssocTyParenthesesSub {\n }\n \n impl AddToDiagnostic for AssocTyParenthesesSub {\n-    fn add_to_diagnostic(self, diag: &mut Diagnostic) {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, _: F)\n+    where\n+        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n+    {\n         match self {\n             Self::Empty { parentheses_span } => diag.multipart_suggestion(\n                 fluent::ast_lowering::remove_parentheses,"}, {"sha": "ba2ed24fc08fc08095d240d45d6c90f334c6371c", "filename": "compiler/rustc_ast_passes/src/errors.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_ast_passes%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_ast_passes%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ferrors.rs?ref=c0983a9aac889d16722a12602ac678051e62c3fb", "patch": "@@ -1,6 +1,6 @@\n //! Errors emitted by ast_passes.\n \n-use rustc_errors::{fluent, AddToDiagnostic, Applicability, Diagnostic};\n+use rustc_errors::{fluent, AddToDiagnostic, Applicability, Diagnostic, SubdiagnosticMessage};\n use rustc_macros::{Diagnostic, Subdiagnostic};\n use rustc_span::{Span, Symbol};\n \n@@ -17,7 +17,10 @@ pub struct ForbiddenLet {\n }\n \n impl AddToDiagnostic for ForbiddenLetReason {\n-    fn add_to_diagnostic(self, diag: &mut Diagnostic) {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, _: F)\n+    where\n+        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n+    {\n         match self {\n             Self::GenericForbidden => {}\n             Self::NotSupportedOr(span) => {\n@@ -228,7 +231,10 @@ pub struct ExternBlockSuggestion {\n }\n \n impl AddToDiagnostic for ExternBlockSuggestion {\n-    fn add_to_diagnostic(self, diag: &mut Diagnostic) {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, _: F)\n+    where\n+        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n+    {\n         let start_suggestion = if let Some(abi) = self.abi {\n             format!(\"extern \\\"{}\\\" {{\", abi)\n         } else {"}, {"sha": "a292bfce31eb86a9c15c35d22b04760394b9cc6f", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=c0983a9aac889d16722a12602ac678051e62c3fb", "patch": "@@ -15,7 +15,10 @@ use rustc_data_structures::profiling::TimingGuard;\n use rustc_data_structures::profiling::VerboseTimingGuard;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::emitter::Emitter;\n-use rustc_errors::{translation::Translate, DiagnosticId, FatalError, Handler, Level};\n+use rustc_errors::{\n+    translation::{to_fluent_args, Translate},\n+    DiagnosticId, FatalError, Handler, Level,\n+};\n use rustc_fs_util::link_or_copy;\n use rustc_hir::def_id::{CrateNum, LOCAL_CRATE};\n use rustc_incremental::{\n@@ -1740,7 +1743,7 @@ impl Translate for SharedEmitter {\n \n impl Emitter for SharedEmitter {\n     fn emit_diagnostic(&mut self, diag: &rustc_errors::Diagnostic) {\n-        let fluent_args = self.to_fluent_args(diag.args());\n+        let fluent_args = to_fluent_args(diag.args());\n         drop(self.sender.send(SharedEmitterMessage::Diagnostic(Diagnostic {\n             msg: self.translate_messages(&diag.message, &fluent_args).to_string(),\n             code: diag.code.clone(),"}, {"sha": "cdcebb61c2e8c3a186ad06010a51499d5e410ef0", "filename": "compiler/rustc_const_eval/src/const_eval/fn_queries.rs", "status": "modified", "additions": 56, "deletions": 16, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ffn_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ffn_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ffn_queries.rs?ref=c0983a9aac889d16722a12602ac678051e62c3fb", "patch": "@@ -25,12 +25,10 @@ pub fn is_parent_const_impl_raw(tcx: TyCtxt<'_>, def_id: LocalDefId) -> bool {\n /// report whether said intrinsic has a `rustc_const_{un,}stable` attribute. Otherwise, return\n /// `Constness::NotConst`.\n fn constness(tcx: TyCtxt<'_>, def_id: DefId) -> hir::Constness {\n-    let def_id = def_id.expect_local();\n-    let node = tcx.hir().get_by_def_id(def_id);\n-\n-    match node {\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n+    match tcx.hir().get(hir_id) {\n         hir::Node::Ctor(_) => hir::Constness::Const,\n-        hir::Node::Item(hir::Item { kind: hir::ItemKind::Impl(impl_), .. }) => impl_.constness,\n+\n         hir::Node::ForeignItem(hir::ForeignItem { kind: hir::ForeignItemKind::Fn(..), .. }) => {\n             // Intrinsics use `rustc_const_{un,}stable` attributes to indicate constness. All other\n             // foreign items cannot be evaluated at compile-time.\n@@ -41,20 +39,62 @@ fn constness(tcx: TyCtxt<'_>, def_id: DefId) -> hir::Constness {\n             };\n             if is_const { hir::Constness::Const } else { hir::Constness::NotConst }\n         }\n-        _ => {\n-            if let Some(fn_kind) = node.fn_kind() {\n-                if fn_kind.constness() == hir::Constness::Const {\n-                    return hir::Constness::Const;\n-                }\n \n-                // If the function itself is not annotated with `const`, it may still be a `const fn`\n-                // if it resides in a const trait impl.\n-                let is_const = is_parent_const_impl_raw(tcx, def_id);\n-                if is_const { hir::Constness::Const } else { hir::Constness::NotConst }\n-            } else {\n-                hir::Constness::NotConst\n+        hir::Node::TraitItem(hir::TraitItem { kind: hir::TraitItemKind::Fn(..), .. })\n+            if tcx.is_const_default_method(def_id) =>\n+        {\n+            hir::Constness::Const\n+        }\n+\n+        hir::Node::Item(hir::Item { kind: hir::ItemKind::Const(..), .. })\n+        | hir::Node::Item(hir::Item { kind: hir::ItemKind::Static(..), .. })\n+        | hir::Node::TraitItem(hir::TraitItem { kind: hir::TraitItemKind::Const(..), .. })\n+        | hir::Node::AnonConst(_)\n+        | hir::Node::ImplItem(hir::ImplItem { kind: hir::ImplItemKind::Const(..), .. })\n+        | hir::Node::ImplItem(hir::ImplItem {\n+            kind:\n+                hir::ImplItemKind::Fn(\n+                    hir::FnSig {\n+                        header: hir::FnHeader { constness: hir::Constness::Const, .. },\n+                        ..\n+                    },\n+                    ..,\n+                ),\n+            ..\n+        }) => hir::Constness::Const,\n+\n+        hir::Node::ImplItem(hir::ImplItem {\n+            kind: hir::ImplItemKind::Type(..) | hir::ImplItemKind::Fn(..),\n+            ..\n+        }) => {\n+            let parent_hir_id = tcx.hir().get_parent_node(hir_id);\n+            match tcx.hir().get(parent_hir_id) {\n+                hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::Impl(hir::Impl { constness, .. }),\n+                    ..\n+                }) => *constness,\n+                _ => span_bug!(\n+                    tcx.def_span(parent_hir_id.owner),\n+                    \"impl item's parent node is not an impl\",\n+                ),\n             }\n         }\n+\n+        hir::Node::Item(hir::Item {\n+            kind: hir::ItemKind::Fn(hir::FnSig { header: hir::FnHeader { constness, .. }, .. }, ..),\n+            ..\n+        })\n+        | hir::Node::TraitItem(hir::TraitItem {\n+            kind:\n+                hir::TraitItemKind::Fn(hir::FnSig { header: hir::FnHeader { constness, .. }, .. }, ..),\n+            ..\n+        })\n+        | hir::Node::Item(hir::Item {\n+            kind: hir::ItemKind::Impl(hir::Impl { constness, .. }),\n+            ..\n+        }) => *constness,\n+\n+        _ => hir::Constness::NotConst,\n     }\n }\n "}, {"sha": "719588a936ce377b5e8b3dc27f5d7318e9d31216", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=c0983a9aac889d16722a12602ac678051e62c3fb", "patch": "@@ -788,9 +788,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n mod size_asserts {\n     use super::*;\n     use rustc_data_structures::static_assert_size;\n-    // These are in alphabetical order, which is easy to maintain.\n+    // tidy-alphabetical-start\n     static_assert_size!(Immediate, 48);\n     static_assert_size!(ImmTy<'_>, 64);\n     static_assert_size!(Operand, 56);\n     static_assert_size!(OpTy<'_>, 80);\n+    // tidy-alphabetical-end\n }"}, {"sha": "b0625b5f412e03ad900f57d5ef7c77130e6dca9c", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=c0983a9aac889d16722a12602ac678051e62c3fb", "patch": "@@ -892,10 +892,11 @@ where\n mod size_asserts {\n     use super::*;\n     use rustc_data_structures::static_assert_size;\n-    // These are in alphabetical order, which is easy to maintain.\n-    static_assert_size!(MemPlaceMeta, 24);\n+    // tidy-alphabetical-start\n     static_assert_size!(MemPlace, 40);\n+    static_assert_size!(MemPlaceMeta, 24);\n     static_assert_size!(MPlaceTy<'_>, 64);\n     static_assert_size!(Place, 40);\n     static_assert_size!(PlaceTy<'_>, 64);\n+    // tidy-alphabetical-end\n }"}, {"sha": "870e824039cb6a86abe94b83344c74dd327dbc1c", "filename": "compiler/rustc_error_messages/locales/en-US/query_system.ftl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fquery_system.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fquery_system.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fquery_system.ftl?ref=c0983a9aac889d16722a12602ac678051e62c3fb", "patch": "@@ -12,6 +12,8 @@ query_system_cycle_usage = cycle used when {$usage}\n \n query_system_cycle_stack_single = ...which immediately requires {$stack_bottom} again\n \n+query_system_cycle_stack_middle = ...which requires {$desc}...\n+\n query_system_cycle_stack_multiple = ...which again requires {$stack_bottom}, completing the cycle\n \n query_system_cycle_recursive_ty_alias = type aliases cannot be recursive"}, {"sha": "a6024044ad82fb17bb522fb78119ec5f0cee3dd4", "filename": "compiler/rustc_error_messages/src/lib.rs", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs?ref=c0983a9aac889d16722a12602ac678051e62c3fb", "patch": "@@ -35,6 +35,7 @@ pub use unic_langid::{langid, LanguageIdentifier};\n \n // Generates `DEFAULT_LOCALE_RESOURCES` static and `fluent_generated` module.\n fluent_messages! {\n+    // tidy-alphabetical-start\n     ast_lowering => \"../locales/en-US/ast_lowering.ftl\",\n     ast_passes => \"../locales/en-US/ast_passes.ftl\",\n     attr => \"../locales/en-US/attr.ftl\",\n@@ -64,6 +65,7 @@ fluent_messages! {\n     symbol_mangling => \"../locales/en-US/symbol_mangling.ftl\",\n     trait_selection => \"../locales/en-US/trait_selection.ftl\",\n     ty_utils => \"../locales/en-US/ty_utils.ftl\",\n+    // tidy-alphabetical-end\n }\n \n pub use fluent_generated::{self as fluent, DEFAULT_LOCALE_RESOURCES};\n@@ -277,6 +279,18 @@ pub enum SubdiagnosticMessage {\n     /// Non-translatable diagnostic message.\n     // FIXME(davidtwco): can a `Cow<'static, str>` be used here?\n     Str(String),\n+    /// Translatable message which has already been translated eagerly.\n+    ///\n+    /// Some diagnostics have repeated subdiagnostics where the same interpolated variables would\n+    /// be instantiated multiple times with different values. As translation normally happens\n+    /// immediately prior to emission, after the diagnostic and subdiagnostic derive logic has run,\n+    /// the setting of diagnostic arguments in the derived code will overwrite previous variable\n+    /// values and only the final value will be set when translation occurs - resulting in\n+    /// incorrect diagnostics. Eager translation results in translation for a subdiagnostic\n+    /// happening immediately after the subdiagnostic derive's logic has been run. This variant\n+    /// stores messages which have been translated eagerly.\n+    // FIXME(#100717): can a `Cow<'static, str>` be used here?\n+    Eager(String),\n     /// Identifier of a Fluent message. Instances of this variant are generated by the\n     /// `Subdiagnostic` derive.\n     FluentIdentifier(FluentId),\n@@ -304,8 +318,20 @@ impl<S: Into<String>> From<S> for SubdiagnosticMessage {\n #[rustc_diagnostic_item = \"DiagnosticMessage\"]\n pub enum DiagnosticMessage {\n     /// Non-translatable diagnostic message.\n-    // FIXME(davidtwco): can a `Cow<'static, str>` be used here?\n+    // FIXME(#100717): can a `Cow<'static, str>` be used here?\n     Str(String),\n+    /// Translatable message which has already been translated eagerly.\n+    ///\n+    /// Some diagnostics have repeated subdiagnostics where the same interpolated variables would\n+    /// be instantiated multiple times with different values. As translation normally happens\n+    /// immediately prior to emission, after the diagnostic and subdiagnostic derive logic has run,\n+    /// the setting of diagnostic arguments in the derived code will overwrite previous variable\n+    /// values and only the final value will be set when translation occurs - resulting in\n+    /// incorrect diagnostics. Eager translation results in translation for a subdiagnostic\n+    /// happening immediately after the subdiagnostic derive's logic has been run. This variant\n+    /// stores messages which have been translated eagerly.\n+    // FIXME(#100717): can a `Cow<'static, str>` be used here?\n+    Eager(String),\n     /// Identifier for a Fluent message (with optional attribute) corresponding to the diagnostic\n     /// message.\n     ///\n@@ -324,6 +350,7 @@ impl DiagnosticMessage {\n     pub fn with_subdiagnostic_message(&self, sub: SubdiagnosticMessage) -> Self {\n         let attr = match sub {\n             SubdiagnosticMessage::Str(s) => return DiagnosticMessage::Str(s),\n+            SubdiagnosticMessage::Eager(s) => return DiagnosticMessage::Eager(s),\n             SubdiagnosticMessage::FluentIdentifier(id) => {\n                 return DiagnosticMessage::FluentIdentifier(id, None);\n             }\n@@ -332,6 +359,7 @@ impl DiagnosticMessage {\n \n         match self {\n             DiagnosticMessage::Str(s) => DiagnosticMessage::Str(s.clone()),\n+            DiagnosticMessage::Eager(s) => DiagnosticMessage::Eager(s.clone()),\n             DiagnosticMessage::FluentIdentifier(id, _) => {\n                 DiagnosticMessage::FluentIdentifier(id.clone(), Some(attr))\n             }\n@@ -367,6 +395,7 @@ impl Into<SubdiagnosticMessage> for DiagnosticMessage {\n     fn into(self) -> SubdiagnosticMessage {\n         match self {\n             DiagnosticMessage::Str(s) => SubdiagnosticMessage::Str(s),\n+            DiagnosticMessage::Eager(s) => SubdiagnosticMessage::Eager(s),\n             DiagnosticMessage::FluentIdentifier(id, None) => {\n                 SubdiagnosticMessage::FluentIdentifier(id)\n             }"}, {"sha": "f14b8ee3254f33608b0bbe0b16c6374ec0c5ad9e", "filename": "compiler/rustc_errors/src/annotate_snippet_emitter_writer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_errors%2Fsrc%2Fannotate_snippet_emitter_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_errors%2Fsrc%2Fannotate_snippet_emitter_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fannotate_snippet_emitter_writer.rs?ref=c0983a9aac889d16722a12602ac678051e62c3fb", "patch": "@@ -7,7 +7,7 @@\n \n use crate::emitter::FileWithAnnotatedLines;\n use crate::snippet::Line;\n-use crate::translation::Translate;\n+use crate::translation::{to_fluent_args, Translate};\n use crate::{\n     CodeSuggestion, Diagnostic, DiagnosticId, DiagnosticMessage, Emitter, FluentBundle,\n     LazyFallbackBundle, Level, MultiSpan, Style, SubDiagnostic,\n@@ -46,7 +46,7 @@ impl Translate for AnnotateSnippetEmitterWriter {\n impl Emitter for AnnotateSnippetEmitterWriter {\n     /// The entry point for the diagnostics generation\n     fn emit_diagnostic(&mut self, diag: &Diagnostic) {\n-        let fluent_args = self.to_fluent_args(diag.args());\n+        let fluent_args = to_fluent_args(diag.args());\n \n         let mut children = diag.children.clone();\n         let (mut primary_span, suggestions) = self.primary_span_formatted(&diag, &fluent_args);"}, {"sha": "3e0840caaa6938ee5d6a985a0cc2b636a4aa114e", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 46, "deletions": 11, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=c0983a9aac889d16722a12602ac678051e62c3fb", "patch": "@@ -27,7 +27,11 @@ pub struct SuggestionsDisabled;\n /// Simplified version of `FluentArg` that can implement `Encodable` and `Decodable`. Collection of\n /// `DiagnosticArg` are converted to `FluentArgs` (consuming the collection) at the start of\n /// diagnostic emission.\n-pub type DiagnosticArg<'source> = (Cow<'source, str>, DiagnosticArgValue<'source>);\n+pub type DiagnosticArg<'iter, 'source> =\n+    (&'iter DiagnosticArgName<'source>, &'iter DiagnosticArgValue<'source>);\n+\n+/// Name of a diagnostic argument.\n+pub type DiagnosticArgName<'source> = Cow<'source, str>;\n \n /// Simplified version of `FluentValue` that can implement `Encodable` and `Decodable`. Converted\n /// to a `FluentValue` by the emitter to be used in diagnostic translation.\n@@ -199,9 +203,20 @@ impl IntoDiagnosticArg for ast::token::TokenKind {\n /// `#[derive(Subdiagnostic)]` -- see [rustc_macros::Subdiagnostic].\n #[cfg_attr(bootstrap, rustc_diagnostic_item = \"AddSubdiagnostic\")]\n #[cfg_attr(not(bootstrap), rustc_diagnostic_item = \"AddToDiagnostic\")]\n-pub trait AddToDiagnostic {\n+pub trait AddToDiagnostic\n+where\n+    Self: Sized,\n+{\n     /// Add a subdiagnostic to an existing diagnostic.\n-    fn add_to_diagnostic(self, diag: &mut Diagnostic);\n+    fn add_to_diagnostic(self, diag: &mut Diagnostic) {\n+        self.add_to_diagnostic_with(diag, |_, m| m);\n+    }\n+\n+    /// Add a subdiagnostic to an existing diagnostic where `f` is invoked on every message used\n+    /// (to optionally perform eager translation).\n+    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, f: F)\n+    where\n+        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage;\n }\n \n /// Trait implemented by lint types. This should not be implemented manually. Instead, use\n@@ -229,7 +244,7 @@ pub struct Diagnostic {\n     pub span: MultiSpan,\n     pub children: Vec<SubDiagnostic>,\n     pub suggestions: Result<Vec<CodeSuggestion>, SuggestionsDisabled>,\n-    args: Vec<DiagnosticArg<'static>>,\n+    args: FxHashMap<DiagnosticArgName<'static>, DiagnosticArgValue<'static>>,\n \n     /// This is not used for highlighting or rendering any error message.  Rather, it can be used\n     /// as a sort key to sort a buffer of diagnostics.  By default, it is the primary span of\n@@ -321,7 +336,7 @@ impl Diagnostic {\n             span: MultiSpan::new(),\n             children: vec![],\n             suggestions: Ok(vec![]),\n-            args: vec![],\n+            args: Default::default(),\n             sort_span: DUMMY_SP,\n             is_lint: false,\n         }\n@@ -917,13 +932,30 @@ impl Diagnostic {\n         self\n     }\n \n-    /// Add a subdiagnostic from a type that implements `Subdiagnostic` - see\n-    /// [rustc_macros::Subdiagnostic].\n+    /// Add a subdiagnostic from a type that implements `Subdiagnostic` (see\n+    /// [rustc_macros::Subdiagnostic]).\n     pub fn subdiagnostic(&mut self, subdiagnostic: impl AddToDiagnostic) -> &mut Self {\n         subdiagnostic.add_to_diagnostic(self);\n         self\n     }\n \n+    /// Add a subdiagnostic from a type that implements `Subdiagnostic` (see\n+    /// [rustc_macros::Subdiagnostic]). Performs eager translation of any translatable messages\n+    /// used in the subdiagnostic, so suitable for use with repeated messages (i.e. re-use of\n+    /// interpolated variables).\n+    pub fn eager_subdiagnostic(\n+        &mut self,\n+        handler: &crate::Handler,\n+        subdiagnostic: impl AddToDiagnostic,\n+    ) -> &mut Self {\n+        subdiagnostic.add_to_diagnostic_with(self, |diag, msg| {\n+            let args = diag.args();\n+            let msg = diag.subdiagnostic_message_to_diagnostic_message(msg);\n+            handler.eagerly_translate(msg, args)\n+        });\n+        self\n+    }\n+\n     pub fn set_span<S: Into<MultiSpan>>(&mut self, sp: S) -> &mut Self {\n         self.span = sp.into();\n         if let Some(span) = self.span.primary_span() {\n@@ -956,16 +988,19 @@ impl Diagnostic {\n         self\n     }\n \n-    pub fn args(&self) -> &[DiagnosticArg<'static>] {\n-        &self.args\n+    // Exact iteration order of diagnostic arguments shouldn't make a difference to output because\n+    // they're only used in interpolation.\n+    #[allow(rustc::potential_query_instability)]\n+    pub fn args<'a>(&'a self) -> impl Iterator<Item = DiagnosticArg<'a, 'static>> {\n+        self.args.iter()\n     }\n \n     pub fn set_arg(\n         &mut self,\n         name: impl Into<Cow<'static, str>>,\n         arg: impl IntoDiagnosticArg,\n     ) -> &mut Self {\n-        self.args.push((name.into(), arg.into_diagnostic_arg()));\n+        self.args.insert(name.into(), arg.into_diagnostic_arg());\n         self\n     }\n \n@@ -976,7 +1011,7 @@ impl Diagnostic {\n     /// Helper function that takes a `SubdiagnosticMessage` and returns a `DiagnosticMessage` by\n     /// combining it with the primary message of the diagnostic (if translatable, otherwise it just\n     /// passes the user's string along).\n-    fn subdiagnostic_message_to_diagnostic_message(\n+    pub(crate) fn subdiagnostic_message_to_diagnostic_message(\n         &self,\n         attr: impl Into<SubdiagnosticMessage>,\n     ) -> DiagnosticMessage {"}, {"sha": "cd6413bc3ec622de739180b0d7a012fa8619ebbb", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=c0983a9aac889d16722a12602ac678051e62c3fb", "patch": "@@ -14,7 +14,7 @@ use rustc_span::{FileLines, SourceFile, Span};\n \n use crate::snippet::{Annotation, AnnotationType, Line, MultilineAnnotation, Style, StyledString};\n use crate::styled_buffer::StyledBuffer;\n-use crate::translation::Translate;\n+use crate::translation::{to_fluent_args, Translate};\n use crate::{\n     CodeSuggestion, Diagnostic, DiagnosticId, DiagnosticMessage, FluentBundle, Handler,\n     LazyFallbackBundle, Level, MultiSpan, SubDiagnostic, SubstitutionHighlight, SuggestionStyle,\n@@ -535,7 +535,7 @@ impl Emitter for EmitterWriter {\n     }\n \n     fn emit_diagnostic(&mut self, diag: &Diagnostic) {\n-        let fluent_args = self.to_fluent_args(diag.args());\n+        let fluent_args = to_fluent_args(diag.args());\n \n         let mut children = diag.children.clone();\n         let (mut primary_span, suggestions) = self.primary_span_formatted(&diag, &fluent_args);"}, {"sha": "4cc7be47fc2c69c79d2d53c7f24cae7271cbde3f", "filename": "compiler/rustc_errors/src/json.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_errors%2Fsrc%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_errors%2Fsrc%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fjson.rs?ref=c0983a9aac889d16722a12602ac678051e62c3fb", "patch": "@@ -13,7 +13,7 @@ use rustc_span::source_map::{FilePathMapping, SourceMap};\n \n use crate::emitter::{Emitter, HumanReadableErrorType};\n use crate::registry::Registry;\n-use crate::translation::Translate;\n+use crate::translation::{to_fluent_args, Translate};\n use crate::DiagnosticId;\n use crate::{\n     CodeSuggestion, FluentBundle, LazyFallbackBundle, MultiSpan, SpanLabel, SubDiagnostic,\n@@ -312,7 +312,7 @@ struct UnusedExterns<'a, 'b, 'c> {\n \n impl Diagnostic {\n     fn from_errors_diagnostic(diag: &crate::Diagnostic, je: &JsonEmitter) -> Diagnostic {\n-        let args = je.to_fluent_args(diag.args());\n+        let args = to_fluent_args(diag.args());\n         let sugg = diag.suggestions.iter().flatten().map(|sugg| {\n             let translated_message = je.translate_message(&sugg.msg, &args);\n             Diagnostic {"}, {"sha": "b16c54e0aacaae438dd33ea2ed26c3322d55f5fc", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=c0983a9aac889d16722a12602ac678051e62c3fb", "patch": "@@ -598,6 +598,17 @@ impl Handler {\n         }\n     }\n \n+    /// Translate `message` eagerly with `args`.\n+    pub fn eagerly_translate<'a>(\n+        &self,\n+        message: DiagnosticMessage,\n+        args: impl Iterator<Item = DiagnosticArg<'a, 'static>>,\n+    ) -> SubdiagnosticMessage {\n+        let inner = self.inner.borrow();\n+        let args = crate::translation::to_fluent_args(args);\n+        SubdiagnosticMessage::Eager(inner.emitter.translate_message(&message, &args).to_string())\n+    }\n+\n     // This is here to not allow mutation of flags;\n     // as of this writing it's only used in tests in librustc_middle.\n     pub fn can_emit_warnings(&self) -> bool {"}, {"sha": "a7737b467b75bd89dc266a03a78c941b96cb76eb", "filename": "compiler/rustc_errors/src/translation.rs", "status": "modified", "additions": 24, "deletions": 10, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_errors%2Fsrc%2Ftranslation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_errors%2Fsrc%2Ftranslation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Ftranslation.rs?ref=c0983a9aac889d16722a12602ac678051e62c3fb", "patch": "@@ -4,6 +4,27 @@ use rustc_data_structures::sync::Lrc;\n use rustc_error_messages::FluentArgs;\n use std::borrow::Cow;\n \n+/// Convert diagnostic arguments (a rustc internal type that exists to implement\n+/// `Encodable`/`Decodable`) into `FluentArgs` which is necessary to perform translation.\n+///\n+/// Typically performed once for each diagnostic at the start of `emit_diagnostic` and then\n+/// passed around as a reference thereafter.\n+pub fn to_fluent_args<'iter, 'arg: 'iter>(\n+    iter: impl Iterator<Item = DiagnosticArg<'iter, 'arg>>,\n+) -> FluentArgs<'arg> {\n+    let mut args = if let Some(size) = iter.size_hint().1 {\n+        FluentArgs::with_capacity(size)\n+    } else {\n+        FluentArgs::new()\n+    };\n+\n+    for (k, v) in iter {\n+        args.set(k.clone(), v.clone());\n+    }\n+\n+    args\n+}\n+\n pub trait Translate {\n     /// Return `FluentBundle` with localized diagnostics for the locale requested by the user. If no\n     /// language was requested by the user then this will be `None` and `fallback_fluent_bundle`\n@@ -15,15 +36,6 @@ pub trait Translate {\n     /// unavailable for the requested locale.\n     fn fallback_fluent_bundle(&self) -> &FluentBundle;\n \n-    /// Convert diagnostic arguments (a rustc internal type that exists to implement\n-    /// `Encodable`/`Decodable`) into `FluentArgs` which is necessary to perform translation.\n-    ///\n-    /// Typically performed once for each diagnostic at the start of `emit_diagnostic` and then\n-    /// passed around as a reference thereafter.\n-    fn to_fluent_args<'arg>(&self, args: &[DiagnosticArg<'arg>]) -> FluentArgs<'arg> {\n-        FromIterator::from_iter(args.iter().cloned())\n-    }\n-\n     /// Convert `DiagnosticMessage`s to a string, performing translation if necessary.\n     fn translate_messages(\n         &self,\n@@ -43,7 +55,9 @@ pub trait Translate {\n     ) -> Cow<'_, str> {\n         trace!(?message, ?args);\n         let (identifier, attr) = match message {\n-            DiagnosticMessage::Str(msg) => return Cow::Borrowed(&msg),\n+            DiagnosticMessage::Str(msg) | DiagnosticMessage::Eager(msg) => {\n+                return Cow::Borrowed(&msg);\n+            }\n             DiagnosticMessage::FluentIdentifier(identifier, attr) => (identifier, attr),\n         };\n "}, {"sha": "5ea433e6b3d3e3de47f393ab105e2faf77f6505f", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=c0983a9aac889d16722a12602ac678051e62c3fb", "patch": "@@ -412,8 +412,6 @@ declare_features! (\n     (incomplete, generic_associated_types_extended, \"1.61.0\", Some(95451), None),\n     /// Allows non-trivial generic constants which have to have wfness manually propagated to callers\n     (incomplete, generic_const_exprs, \"1.56.0\", Some(76560), None),\n-    /// Allows using `..X`, `..=X`, `...X`, and `X..` as a pattern.\n-    (active, half_open_range_patterns, \"1.41.0\", Some(67264), None),\n     /// Allows using `..=X` as a patterns in slices.\n     (active, half_open_range_patterns_in_slices, \"CURRENT_RUSTC_VERSION\", Some(67264), None),\n     /// Allows `if let` guard in match arms."}, {"sha": "bc149e48d89e842b8333989350810b0988a752fc", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=c0983a9aac889d16722a12602ac678051e62c3fb", "patch": "@@ -3514,7 +3514,7 @@ impl<'hir> Node<'hir> {\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n mod size_asserts {\n     use super::*;\n-    // These are in alphabetical order, which is easy to maintain.\n+    // tidy-alphabetical-start\n     static_assert_size!(Block<'_>, 48);\n     static_assert_size!(Body<'_>, 32);\n     static_assert_size!(Expr<'_>, 64);\n@@ -3533,9 +3533,9 @@ mod size_asserts {\n     static_assert_size!(Local<'_>, 64);\n     static_assert_size!(Param<'_>, 32);\n     static_assert_size!(Pat<'_>, 72);\n-    static_assert_size!(PatKind<'_>, 48);\n     static_assert_size!(Path<'_>, 40);\n     static_assert_size!(PathSegment<'_>, 48);\n+    static_assert_size!(PatKind<'_>, 48);\n     static_assert_size!(QPath<'_>, 24);\n     static_assert_size!(Res, 12);\n     static_assert_size!(Stmt<'_>, 32);\n@@ -3544,4 +3544,5 @@ mod size_asserts {\n     static_assert_size!(TraitItemKind<'_>, 48);\n     static_assert_size!(Ty<'_>, 48);\n     static_assert_size!(TyKind<'_>, 32);\n+    // tidy-alphabetical-end\n }"}, {"sha": "500900d3d4a74b7310be4483c3a7a87e01ffff45", "filename": "compiler/rustc_infer/src/errors/mod.rs", "status": "modified", "additions": 26, "deletions": 7, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs?ref=c0983a9aac889d16722a12602ac678051e62c3fb", "patch": "@@ -1,6 +1,7 @@\n use hir::GenericParamKind;\n use rustc_errors::{\n-    fluent, AddToDiagnostic, Applicability, DiagnosticMessage, DiagnosticStyledString, MultiSpan,\n+    fluent, AddToDiagnostic, Applicability, Diagnostic, DiagnosticMessage, DiagnosticStyledString,\n+    MultiSpan, SubdiagnosticMessage,\n };\n use rustc_hir as hir;\n use rustc_hir::{FnRetTy, Ty};\n@@ -229,7 +230,10 @@ pub enum RegionOriginNote<'a> {\n }\n \n impl AddToDiagnostic for RegionOriginNote<'_> {\n-    fn add_to_diagnostic(self, diag: &mut rustc_errors::Diagnostic) {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, _: F)\n+    where\n+        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n+    {\n         let mut label_or_note = |span, msg: DiagnosticMessage| {\n             let sub_count = diag.children.iter().filter(|d| d.span.is_dummy()).count();\n             let expanded_sub_count = diag.children.iter().filter(|d| !d.span.is_dummy()).count();\n@@ -290,7 +294,10 @@ pub enum LifetimeMismatchLabels {\n }\n \n impl AddToDiagnostic for LifetimeMismatchLabels {\n-    fn add_to_diagnostic(self, diag: &mut rustc_errors::Diagnostic) {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, _: F)\n+    where\n+        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n+    {\n         match self {\n             LifetimeMismatchLabels::InRet { param_span, ret_span, span, label_var1 } => {\n                 diag.span_label(param_span, fluent::infer::declared_different);\n@@ -340,7 +347,10 @@ pub struct AddLifetimeParamsSuggestion<'a> {\n }\n \n impl AddToDiagnostic for AddLifetimeParamsSuggestion<'_> {\n-    fn add_to_diagnostic(self, diag: &mut rustc_errors::Diagnostic) {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, _: F)\n+    where\n+        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n+    {\n         let mut mk_suggestion = || {\n             let (\n                 hir::Ty { kind: hir::TyKind::Rptr(lifetime_sub, _), .. },\n@@ -439,7 +449,10 @@ pub struct IntroducesStaticBecauseUnmetLifetimeReq {\n }\n \n impl AddToDiagnostic for IntroducesStaticBecauseUnmetLifetimeReq {\n-    fn add_to_diagnostic(mut self, diag: &mut rustc_errors::Diagnostic) {\n+    fn add_to_diagnostic_with<F>(mut self, diag: &mut Diagnostic, _: F)\n+    where\n+        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n+    {\n         self.unmet_requirements\n             .push_span_label(self.binding_span, fluent::infer::msl_introduces_static);\n         diag.span_note(self.unmet_requirements, fluent::infer::msl_unmet_req);\n@@ -451,7 +464,10 @@ pub struct ImplNote {\n }\n \n impl AddToDiagnostic for ImplNote {\n-    fn add_to_diagnostic(self, diag: &mut rustc_errors::Diagnostic) {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, _: F)\n+    where\n+        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n+    {\n         match self.impl_span {\n             Some(span) => diag.span_note(span, fluent::infer::msl_impl_note),\n             None => diag.note(fluent::infer::msl_impl_note),\n@@ -466,7 +482,10 @@ pub enum TraitSubdiag {\n \n // FIXME(#100717) used in `Vec<TraitSubdiag>` so requires eager translation/list support\n impl AddToDiagnostic for TraitSubdiag {\n-    fn add_to_diagnostic(self, diag: &mut rustc_errors::Diagnostic) {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, _: F)\n+    where\n+        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n+    {\n         match self {\n             TraitSubdiag::Note { span } => {\n                 diag.span_note(span, \"this has an implicit `'static` lifetime requirement\");"}, {"sha": "201a3c7100cc8da1c57654a2d0e208cece4f2dec", "filename": "compiler/rustc_infer/src/errors/note_and_explain.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs?ref=c0983a9aac889d16722a12602ac678051e62c3fb", "patch": "@@ -1,5 +1,7 @@\n use crate::infer::error_reporting::nice_region_error::find_anon_type;\n-use rustc_errors::{self, fluent, AddToDiagnostic, IntoDiagnosticArg};\n+use rustc_errors::{\n+    self, fluent, AddToDiagnostic, Diagnostic, IntoDiagnosticArg, SubdiagnosticMessage,\n+};\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_span::{symbol::kw, Span};\n \n@@ -159,7 +161,10 @@ impl RegionExplanation<'_> {\n }\n \n impl AddToDiagnostic for RegionExplanation<'_> {\n-    fn add_to_diagnostic(self, diag: &mut rustc_errors::Diagnostic) {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, _: F)\n+    where\n+        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n+    {\n         if let Some(span) = self.desc.span {\n             diag.span_note(span, fluent::infer::region_explanation);\n         } else {"}, {"sha": "d64cdcdbaa9db70b8f4ced2bc7f5bf6ca56594be", "filename": "compiler/rustc_interface/src/tests.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ftests.rs?ref=c0983a9aac889d16722a12602ac678051e62c3fb", "patch": "@@ -540,7 +540,7 @@ fn test_codegen_options_tracking_hash() {\n     }\n \n     // Make sure that changing an [UNTRACKED] option leaves the hash unchanged.\n-    // This list is in alphabetical order.\n+    // tidy-alphabetical-start\n     untracked!(ar, String::from(\"abc\"));\n     untracked!(codegen_units, Some(42));\n     untracked!(default_linker_libraries, true);\n@@ -556,6 +556,7 @@ fn test_codegen_options_tracking_hash() {\n     untracked!(rpath, true);\n     untracked!(save_temps, true);\n     untracked!(strip, Strip::Debuginfo);\n+    // tidy-alphabetical-end\n \n     macro_rules! tracked {\n         ($name: ident, $non_default_value: expr) => {\n@@ -567,7 +568,7 @@ fn test_codegen_options_tracking_hash() {\n     }\n \n     // Make sure that changing a [TRACKED] option changes the hash.\n-    // This list is in alphabetical order.\n+    // tidy-alphabetical-start\n     tracked!(code_model, Some(CodeModel::Large));\n     tracked!(control_flow_guard, CFGuard::Checks);\n     tracked!(debug_assertions, Some(true));\n@@ -577,8 +578,8 @@ fn test_codegen_options_tracking_hash() {\n     tracked!(force_unwind_tables, Some(true));\n     tracked!(inline_threshold, Some(0xf007ba11));\n     tracked!(instrument_coverage, Some(InstrumentCoverage::All));\n-    tracked!(linker_plugin_lto, LinkerPluginLto::LinkerPluginAuto);\n     tracked!(link_dead_code, Some(true));\n+    tracked!(linker_plugin_lto, LinkerPluginLto::LinkerPluginAuto);\n     tracked!(llvm_args, vec![String::from(\"1\"), String::from(\"2\")]);\n     tracked!(lto, LtoCli::Fat);\n     tracked!(metadata, vec![String::from(\"A\"), String::from(\"B\")]);\n@@ -599,6 +600,7 @@ fn test_codegen_options_tracking_hash() {\n     tracked!(symbol_mangling_version, Some(SymbolManglingVersion::V0));\n     tracked!(target_cpu, Some(String::from(\"abc\")));\n     tracked!(target_feature, String::from(\"all the features, all of them\"));\n+    // tidy-alphabetical-end\n }\n \n #[test]\n@@ -619,12 +621,13 @@ fn test_top_level_options_tracked_no_crate() {\n     }\n \n     // Make sure that changing a [TRACKED_NO_CRATE_HASH] option leaves the crate hash unchanged but changes the incremental hash.\n-    // This list is in alphabetical order.\n-    tracked!(remap_path_prefix, vec![(\"/home/bors/rust\".into(), \"src\".into())]);\n+    // tidy-alphabetical-start\n     tracked!(\n         real_rust_source_base_dir,\n         Some(\"/home/bors/rust/.rustup/toolchains/nightly/lib/rustlib/src/rust\".into())\n     );\n+    tracked!(remap_path_prefix, vec![(\"/home/bors/rust\".into(), \"src\".into())]);\n+    // tidy-alphabetical-end\n }\n \n #[test]\n@@ -641,7 +644,7 @@ fn test_unstable_options_tracking_hash() {\n     }\n \n     // Make sure that changing an [UNTRACKED] option leaves the hash unchanged.\n-    // This list is in alphabetical order.\n+    // tidy-alphabetical-start\n     untracked!(assert_incr_state, Some(String::from(\"loaded\")));\n     untracked!(deduplicate_diagnostics, false);\n     untracked!(dep_tasks, true);\n@@ -678,12 +681,12 @@ fn test_unstable_options_tracking_hash() {\n     untracked!(perf_stats, true);\n     // `pre_link_arg` is omitted because it just forwards to `pre_link_args`.\n     untracked!(pre_link_args, vec![String::from(\"abc\"), String::from(\"def\")]);\n-    untracked!(profile_closures, true);\n     untracked!(print_llvm_passes, true);\n     untracked!(print_mono_items, Some(String::from(\"abc\")));\n     untracked!(print_type_sizes, true);\n     untracked!(proc_macro_backtrace, true);\n     untracked!(proc_macro_execution_strategy, ProcMacroExecutionStrategy::CrossThread);\n+    untracked!(profile_closures, true);\n     untracked!(query_dep_graph, true);\n     untracked!(save_analysis, true);\n     untracked!(self_profile, SwitchWithOptPath::Enabled(None));\n@@ -701,6 +704,7 @@ fn test_unstable_options_tracking_hash() {\n     untracked!(unstable_options, true);\n     untracked!(validate_mir, true);\n     untracked!(verbose, true);\n+    // tidy-alphabetical-end\n \n     macro_rules! tracked {\n         ($name: ident, $non_default_value: expr) => {\n@@ -712,7 +716,7 @@ fn test_unstable_options_tracking_hash() {\n     }\n \n     // Make sure that changing a [TRACKED] option changes the hash.\n-    // This list is in alphabetical order.\n+    // tidy-alphabetical-start\n     tracked!(allow_features, Some(vec![String::from(\"lang_items\")]));\n     tracked!(always_encode_mir, true);\n     tracked!(asm_comments, true);\n@@ -733,10 +737,10 @@ fn test_unstable_options_tracking_hash() {\n     tracked!(debug_macros, true);\n     tracked!(dep_info_omit_d_target, true);\n     tracked!(drop_tracking, true);\n-    tracked!(export_executable_symbols, true);\n     tracked!(dual_proc_macros, true);\n     tracked!(dwarf_version, Some(5));\n     tracked!(emit_thin_lto, false);\n+    tracked!(export_executable_symbols, true);\n     tracked!(fewer_names, Some(true));\n     tracked!(force_unstable_if_unmarked, true);\n     tracked!(fuel, Some((\"abc\".to_string(), 99)));\n@@ -759,8 +763,8 @@ fn test_unstable_options_tracking_hash() {\n     tracked!(mutable_noalias, Some(true));\n     tracked!(no_generate_arange_section, true);\n     tracked!(no_link, true);\n-    tracked!(no_unique_section_names, true);\n     tracked!(no_profiler_runtime, true);\n+    tracked!(no_unique_section_names, true);\n     tracked!(oom, OomStrategy::Panic);\n     tracked!(osx_rpath_install_name, true);\n     tracked!(packed_bundled_libs, true);\n@@ -773,8 +777,8 @@ fn test_unstable_options_tracking_hash() {\n     tracked!(print_fuel, Some(\"abc\".to_string()));\n     tracked!(profile, true);\n     tracked!(profile_emit, Some(PathBuf::from(\"abc\")));\n-    tracked!(profiler_runtime, \"abc\".to_string());\n     tracked!(profile_sample_use, Some(PathBuf::from(\"abc\")));\n+    tracked!(profiler_runtime, \"abc\".to_string());\n     tracked!(relax_elf_relocations, Some(true));\n     tracked!(relro_level, Some(RelroLevel::Full));\n     tracked!(remap_cwd_prefix, Some(PathBuf::from(\"abc\")));\n@@ -803,6 +807,7 @@ fn test_unstable_options_tracking_hash() {\n     tracked!(verify_llvm_ir, true);\n     tracked!(virtual_function_elimination, true);\n     tracked!(wasi_exec_model, Some(WasiExecModel::Reactor));\n+    // tidy-alphabetical-end\n \n     macro_rules! tracked_no_crate_hash {\n         ($name: ident, $non_default_value: expr) => {"}, {"sha": "97d012fb611d036e6eb81b61e728636df73241f3", "filename": "compiler/rustc_lint/src/errors.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_lint%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_lint%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ferrors.rs?ref=c0983a9aac889d16722a12602ac678051e62c3fb", "patch": "@@ -1,4 +1,7 @@\n-use rustc_errors::{fluent, AddToDiagnostic, ErrorGuaranteed, Handler, IntoDiagnostic};\n+use rustc_errors::{\n+    fluent, AddToDiagnostic, Diagnostic, ErrorGuaranteed, Handler, IntoDiagnostic,\n+    SubdiagnosticMessage,\n+};\n use rustc_macros::{Diagnostic, Subdiagnostic};\n use rustc_session::lint::Level;\n use rustc_span::{Span, Symbol};\n@@ -23,7 +26,10 @@ pub enum OverruledAttributeSub {\n }\n \n impl AddToDiagnostic for OverruledAttributeSub {\n-    fn add_to_diagnostic(self, diag: &mut rustc_errors::Diagnostic) {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, _: F)\n+    where\n+        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n+    {\n         match self {\n             OverruledAttributeSub::DefaultSource { id } => {\n                 diag.note(fluent::lint::default_source);\n@@ -88,7 +94,10 @@ pub struct RequestedLevel {\n }\n \n impl AddToDiagnostic for RequestedLevel {\n-    fn add_to_diagnostic(self, diag: &mut rustc_errors::Diagnostic) {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, _: F)\n+    where\n+        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n+    {\n         diag.note(fluent::lint::requested_level);\n         diag.set_arg(\n             \"level\","}, {"sha": "8cf307df5a565c47957512832a90d6de06111f79", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic.rs", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs?ref=c0983a9aac889d16722a12602ac678051e62c3fb", "patch": "@@ -10,27 +10,31 @@ use synstructure::Structure;\n /// The central struct for constructing the `into_diagnostic` method from an annotated struct.\n pub(crate) struct DiagnosticDerive<'a> {\n     structure: Structure<'a>,\n-    handler: syn::Ident,\n     builder: DiagnosticDeriveBuilder,\n }\n \n impl<'a> DiagnosticDerive<'a> {\n     pub(crate) fn new(diag: syn::Ident, handler: syn::Ident, structure: Structure<'a>) -> Self {\n         Self {\n-            builder: DiagnosticDeriveBuilder { diag, kind: DiagnosticDeriveKind::Diagnostic },\n-            handler,\n+            builder: DiagnosticDeriveBuilder {\n+                diag,\n+                kind: DiagnosticDeriveKind::Diagnostic { handler },\n+            },\n             structure,\n         }\n     }\n \n     pub(crate) fn into_tokens(self) -> TokenStream {\n-        let DiagnosticDerive { mut structure, handler, mut builder } = self;\n+        let DiagnosticDerive { mut structure, mut builder } = self;\n \n         let implementation = builder.each_variant(&mut structure, |mut builder, variant| {\n             let preamble = builder.preamble(&variant);\n             let body = builder.body(&variant);\n \n             let diag = &builder.parent.diag;\n+            let DiagnosticDeriveKind::Diagnostic { handler } = &builder.parent.kind else {\n+                unreachable!()\n+            };\n             let init = match builder.slug.value_ref() {\n                 None => {\n                     span_err(builder.span, \"diagnostic slug not specified\")\n@@ -48,14 +52,17 @@ impl<'a> DiagnosticDerive<'a> {\n                 }\n             };\n \n+            let formatting_init = &builder.formatting_init;\n             quote! {\n                 #init\n+                #formatting_init\n                 #preamble\n                 #body\n                 #diag\n             }\n         });\n \n+        let DiagnosticDeriveKind::Diagnostic { handler } = &builder.kind else { unreachable!() };\n         structure.gen_impl(quote! {\n             gen impl<'__diagnostic_handler_sess, G>\n                     rustc_errors::IntoDiagnostic<'__diagnostic_handler_sess, G>\n@@ -96,17 +103,18 @@ impl<'a> LintDiagnosticDerive<'a> {\n             let body = builder.body(&variant);\n \n             let diag = &builder.parent.diag;\n-\n+            let formatting_init = &builder.formatting_init;\n             quote! {\n                 #preamble\n+                #formatting_init\n                 #body\n                 #diag\n             }\n         });\n \n         let msg = builder.each_variant(&mut structure, |mut builder, variant| {\n-            // HACK(wafflelapkin): initialize slug (???)\n-            let _preamble = builder.preamble(&variant);\n+            // Collect the slug by generating the preamble.\n+            let _ = builder.preamble(&variant);\n \n             match builder.slug.value_ref() {\n                 None => {\n@@ -125,7 +133,10 @@ impl<'a> LintDiagnosticDerive<'a> {\n         let diag = &builder.diag;\n         structure.gen_impl(quote! {\n             gen impl<'__a> rustc_errors::DecorateLint<'__a, ()> for @Self {\n-                fn decorate_lint<'__b>(self, #diag: &'__b mut rustc_errors::DiagnosticBuilder<'__a, ()>) -> &'__b mut rustc_errors::DiagnosticBuilder<'__a, ()> {\n+                fn decorate_lint<'__b>(\n+                    self,\n+                    #diag: &'__b mut rustc_errors::DiagnosticBuilder<'__a, ()>\n+                ) -> &'__b mut rustc_errors::DiagnosticBuilder<'__a, ()> {\n                     use rustc_errors::IntoDiagnosticArg;\n                     #implementation\n                 }"}, {"sha": "dcbe89251cb36048705773f90d3cc51e62a3c4d9", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic_builder.rs", "status": "modified", "additions": 90, "deletions": 60, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs?ref=c0983a9aac889d16722a12602ac678051e62c3fb", "patch": "@@ -5,9 +5,9 @@ use crate::diagnostics::error::{\n     DiagnosticDeriveError,\n };\n use crate::diagnostics::utils::{\n-    bind_style_of_field, build_field_mapping, report_error_if_not_applied_to_span,\n-    report_type_error, should_generate_set_arg, type_is_unit, type_matches_path, FieldInfo,\n-    FieldInnerTy, FieldMap, HasFieldMap, SetOnce, SpannedOption, SubdiagnosticKind,\n+    build_field_mapping, report_error_if_not_applied_to_span, report_type_error,\n+    should_generate_set_arg, type_is_unit, type_matches_path, FieldInfo, FieldInnerTy, FieldMap,\n+    HasFieldMap, SetOnce, SpannedOption, SubdiagnosticKind,\n };\n use proc_macro2::{Ident, Span, TokenStream};\n use quote::{format_ident, quote};\n@@ -17,9 +17,9 @@ use syn::{\n use synstructure::{BindingInfo, Structure, VariantInfo};\n \n /// What kind of diagnostic is being derived - a fatal/error/warning or a lint?\n-#[derive(Copy, Clone, PartialEq, Eq)]\n+#[derive(Clone, PartialEq, Eq)]\n pub(crate) enum DiagnosticDeriveKind {\n-    Diagnostic,\n+    Diagnostic { handler: syn::Ident },\n     LintDiagnostic,\n }\n \n@@ -40,6 +40,9 @@ pub(crate) struct DiagnosticDeriveVariantBuilder<'parent> {\n     /// The parent builder for the entire type.\n     pub parent: &'parent DiagnosticDeriveBuilder,\n \n+    /// Initialization of format strings for code suggestions.\n+    pub formatting_init: TokenStream,\n+\n     /// Span of the struct or the enum variant.\n     pub span: proc_macro::Span,\n \n@@ -88,19 +91,7 @@ impl DiagnosticDeriveBuilder {\n             }\n         }\n \n-        for variant in structure.variants_mut() {\n-            // First, change the binding style of each field based on the code that will be\n-            // generated for the field - e.g. `set_arg` calls needs by-move bindings, whereas\n-            // `set_primary_span` only needs by-ref.\n-            variant.bind_with(|bi| bind_style_of_field(bi.ast()).0);\n-\n-            // Then, perform a stable sort on bindings which generates code for by-ref bindings\n-            // before code generated for by-move bindings. Any code generated for the by-ref\n-            // bindings which creates a reference to the by-move fields will happen before the\n-            // by-move bindings move those fields and make them inaccessible.\n-            variant.bindings_mut().sort_by_cached_key(|bi| bind_style_of_field(bi.ast()));\n-        }\n-\n+        structure.bind_with(|_| synstructure::BindStyle::Move);\n         let variants = structure.each_variant(|variant| {\n             let span = match structure.ast().data {\n                 syn::Data::Struct(..) => span,\n@@ -112,6 +103,7 @@ impl DiagnosticDeriveBuilder {\n                 parent: &self,\n                 span,\n                 field_map: build_field_mapping(variant),\n+                formatting_init: TokenStream::new(),\n                 slug: None,\n                 code: None,\n             };\n@@ -143,16 +135,14 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n \n     /// Generates calls to `span_label` and similar functions based on the attributes on fields or\n     /// calls to `set_arg` when no attributes are present.\n-    ///\n-    /// Expects use of `Self::each_variant` which will have sorted bindings so that by-ref bindings\n-    /// (which may create references to by-move bindings) have their code generated first -\n-    /// necessary as code for suggestions uses formatting machinery and the value of other fields\n-    /// (any given field can be referenced multiple times, so must be accessed through a borrow);\n-    /// and when passing fields to `add_subdiagnostic` or `set_arg` for Fluent, fields must be\n-    /// accessed by-move.\n     pub fn body<'s>(&mut self, variant: &VariantInfo<'s>) -> TokenStream {\n         let mut body = quote! {};\n-        for binding in variant.bindings() {\n+        // Generate `set_arg` calls first..\n+        for binding in variant.bindings().iter().filter(|bi| should_generate_set_arg(bi.ast())) {\n+            body.extend(self.generate_field_code(binding));\n+        }\n+        // ..and then subdiagnostic additions.\n+        for binding in variant.bindings().iter().filter(|bi| !should_generate_set_arg(bi.ast())) {\n             body.extend(self.generate_field_attrs_code(binding));\n         }\n         body\n@@ -274,24 +264,27 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n         }\n     }\n \n-    fn generate_field_attrs_code(&mut self, binding_info: &BindingInfo<'_>) -> TokenStream {\n+    fn generate_field_code(&mut self, binding_info: &BindingInfo<'_>) -> TokenStream {\n+        let diag = &self.parent.diag;\n+\n         let field = binding_info.ast();\n         let field_binding = &binding_info.binding;\n \n-        if should_generate_set_arg(&field) {\n-            let diag = &self.parent.diag;\n-            let ident = field.ident.as_ref().unwrap();\n-            // strip `r#` prefix, if present\n-            let ident = format_ident!(\"{}\", ident);\n-            return quote! {\n-                #diag.set_arg(\n-                    stringify!(#ident),\n-                    #field_binding\n-                );\n-            };\n+        let ident = field.ident.as_ref().unwrap();\n+        let ident = format_ident!(\"{}\", ident); // strip `r#` prefix, if present\n+\n+        quote! {\n+            #diag.set_arg(\n+                stringify!(#ident),\n+                #field_binding\n+            );\n         }\n+    }\n+\n+    fn generate_field_attrs_code(&mut self, binding_info: &BindingInfo<'_>) -> TokenStream {\n+        let field = binding_info.ast();\n+        let field_binding = &binding_info.binding;\n \n-        let needs_move = bind_style_of_field(&field).is_move();\n         let inner_ty = FieldInnerTy::from_type(&field.ty);\n \n         field\n@@ -304,10 +297,8 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n                 let (binding, needs_destructure) = if needs_clone {\n                     // `primary_span` can accept a `Vec<Span>` so don't destructure that.\n                     (quote! { #field_binding.clone() }, false)\n-                } else if needs_move {\n-                    (quote! { #field_binding }, true)\n                 } else {\n-                    (quote! { *#field_binding }, true)\n+                    (quote! { #field_binding }, true)\n                 };\n \n                 let generated_code = self\n@@ -340,18 +331,15 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n         let diag = &self.parent.diag;\n         let meta = attr.parse_meta()?;\n \n-        if let Meta::Path(_) = meta {\n-            let ident = &attr.path.segments.last().unwrap().ident;\n-            let name = ident.to_string();\n-            let name = name.as_str();\n-            match name {\n-                \"skip_arg\" => {\n-                    // Don't need to do anything - by virtue of the attribute existing, the\n-                    // `set_arg` call will not be generated.\n-                    return Ok(quote! {});\n-                }\n-                \"primary_span\" => match self.parent.kind {\n-                    DiagnosticDeriveKind::Diagnostic => {\n+        let ident = &attr.path.segments.last().unwrap().ident;\n+        let name = ident.to_string();\n+        match (&meta, name.as_str()) {\n+            // Don't need to do anything - by virtue of the attribute existing, the\n+            // `set_arg` call will not be generated.\n+            (Meta::Path(_), \"skip_arg\") => return Ok(quote! {}),\n+            (Meta::Path(_), \"primary_span\") => {\n+                match self.parent.kind {\n+                    DiagnosticDeriveKind::Diagnostic { .. } => {\n                         report_error_if_not_applied_to_span(attr, &info)?;\n \n                         return Ok(quote! {\n@@ -363,10 +351,50 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n                             diag.help(\"the `primary_span` field attribute is not valid for lint diagnostics\")\n                         })\n                     }\n-                },\n-                \"subdiagnostic\" => return Ok(quote! { #diag.subdiagnostic(#binding); }),\n-                _ => {}\n+                }\n+            }\n+            (Meta::Path(_), \"subdiagnostic\") => {\n+                return Ok(quote! { #diag.subdiagnostic(#binding); });\n+            }\n+            (Meta::NameValue(_), \"subdiagnostic\") => {\n+                throw_invalid_attr!(attr, &meta, |diag| {\n+                    diag.help(\"`eager` is the only supported nested attribute for `subdiagnostic`\")\n+                })\n+            }\n+            (Meta::List(MetaList { ref nested, .. }), \"subdiagnostic\") => {\n+                if nested.len() != 1 {\n+                    throw_invalid_attr!(attr, &meta, |diag| {\n+                        diag.help(\n+                            \"`eager` is the only supported nested attribute for `subdiagnostic`\",\n+                        )\n+                    })\n+                }\n+\n+                let handler = match &self.parent.kind {\n+                    DiagnosticDeriveKind::Diagnostic { handler } => handler,\n+                    DiagnosticDeriveKind::LintDiagnostic => {\n+                        throw_invalid_attr!(attr, &meta, |diag| {\n+                            diag.help(\"eager subdiagnostics are not supported on lints\")\n+                        })\n+                    }\n+                };\n+\n+                let nested_attr = nested.first().expect(\"pop failed for single element list\");\n+                match nested_attr {\n+                    NestedMeta::Meta(meta @ Meta::Path(_))\n+                        if meta.path().segments.last().unwrap().ident.to_string().as_str()\n+                            == \"eager\" =>\n+                    {\n+                        return Ok(quote! { #diag.eager_subdiagnostic(#handler, #binding); });\n+                    }\n+                    _ => {\n+                        throw_invalid_nested_attr!(attr, nested_attr, |diag| {\n+                            diag.help(\"`eager` is the only supported nested attribute for `subdiagnostic`\")\n+                        })\n+                    }\n+                }\n             }\n+            _ => (),\n         }\n \n         let (subdiag, slug) = self.parse_subdiag_attribute(attr)?;\n@@ -389,7 +417,8 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n             SubdiagnosticKind::Suggestion {\n                 suggestion_kind,\n                 applicability: static_applicability,\n-                code,\n+                code_field,\n+                code_init,\n             } => {\n                 let (span_field, mut applicability) = self.span_and_applicability_of_ty(info)?;\n \n@@ -402,11 +431,12 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n                     .unwrap_or_else(|| quote! { rustc_errors::Applicability::Unspecified });\n                 let style = suggestion_kind.to_suggestion_style();\n \n+                self.formatting_init.extend(code_init);\n                 Ok(quote! {\n                     #diag.span_suggestion_with_style(\n                         #span_field,\n                         rustc_errors::fluent::#slug,\n-                        #code,\n+                        #code_field,\n                         #applicability,\n                         #style\n                     );\n@@ -451,7 +481,7 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n             // If `ty` is `Span` w/out applicability, then use `Applicability::Unspecified`.\n             ty @ Type::Path(..) if type_matches_path(ty, &[\"rustc_span\", \"Span\"]) => {\n                 let binding = &info.binding.binding;\n-                Ok((quote!(*#binding), None))\n+                Ok((quote!(#binding), None))\n             }\n             // If `ty` is `(Span, Applicability)` then return tokens accessing those.\n             Type::Tuple(tup) => {"}, {"sha": "f98cc66e9e93e706e68c39263a473b54ace24b70", "filename": "compiler/rustc_macros/src/diagnostics/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=c0983a9aac889d16722a12602ac678051e62c3fb", "patch": "@@ -9,7 +9,7 @@ use diagnostic::{DiagnosticDerive, LintDiagnosticDerive};\n pub(crate) use fluent::fluent_messages;\n use proc_macro2::TokenStream;\n use quote::format_ident;\n-use subdiagnostic::SubdiagnosticDerive;\n+use subdiagnostic::SubdiagnosticDeriveBuilder;\n use synstructure::Structure;\n \n /// Implements `#[derive(Diagnostic)]`, which allows for errors to be specified as a struct,\n@@ -155,5 +155,5 @@ pub fn lint_diagnostic_derive(s: Structure<'_>) -> TokenStream {\n /// diag.subdiagnostic(RawIdentifierSuggestion { span, applicability, ident });\n /// ```\n pub fn session_subdiagnostic_derive(s: Structure<'_>) -> TokenStream {\n-    SubdiagnosticDerive::new(s).into_tokens()\n+    SubdiagnosticDeriveBuilder::new().into_tokens(s)\n }"}, {"sha": "3d4c3ab9fd7c9f1db983eed8de0db0f0afdebfe8", "filename": "compiler/rustc_macros/src/diagnostics/subdiagnostic.rs", "status": "modified", "additions": 66, "deletions": 29, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs?ref=c0983a9aac889d16722a12602ac678051e62c3fb", "patch": "@@ -5,7 +5,7 @@ use crate::diagnostics::error::{\n     DiagnosticDeriveError,\n };\n use crate::diagnostics::utils::{\n-    build_field_mapping, report_error_if_not_applied_to_applicability,\n+    build_field_mapping, new_code_ident, report_error_if_not_applied_to_applicability,\n     report_error_if_not_applied_to_span, FieldInfo, FieldInnerTy, FieldMap, HasFieldMap, SetOnce,\n     SpannedOption, SubdiagnosticKind,\n };\n@@ -15,19 +15,19 @@ use syn::{spanned::Spanned, Attribute, Meta, MetaList, MetaNameValue, NestedMeta\n use synstructure::{BindingInfo, Structure, VariantInfo};\n \n /// The central struct for constructing the `add_to_diagnostic` method from an annotated struct.\n-pub(crate) struct SubdiagnosticDerive<'a> {\n-    structure: Structure<'a>,\n+pub(crate) struct SubdiagnosticDeriveBuilder {\n     diag: syn::Ident,\n+    f: syn::Ident,\n }\n \n-impl<'a> SubdiagnosticDerive<'a> {\n-    pub(crate) fn new(structure: Structure<'a>) -> Self {\n+impl SubdiagnosticDeriveBuilder {\n+    pub(crate) fn new() -> Self {\n         let diag = format_ident!(\"diag\");\n-        Self { structure, diag }\n+        let f = format_ident!(\"f\");\n+        Self { diag, f }\n     }\n \n-    pub(crate) fn into_tokens(self) -> TokenStream {\n-        let SubdiagnosticDerive { mut structure, diag } = self;\n+    pub(crate) fn into_tokens<'a>(self, mut structure: Structure<'a>) -> TokenStream {\n         let implementation = {\n             let ast = structure.ast();\n             let span = ast.span().unwrap();\n@@ -53,10 +53,11 @@ impl<'a> SubdiagnosticDerive<'a> {\n \n             structure.bind_with(|_| synstructure::BindStyle::Move);\n             let variants_ = structure.each_variant(|variant| {\n-                let mut builder = SubdiagnosticDeriveBuilder {\n-                    diag: &diag,\n+                let mut builder = SubdiagnosticDeriveVariantBuilder {\n+                    parent: &self,\n                     variant,\n                     span,\n+                    formatting_init: TokenStream::new(),\n                     fields: build_field_mapping(variant),\n                     span_field: None,\n                     applicability: None,\n@@ -72,9 +73,17 @@ impl<'a> SubdiagnosticDerive<'a> {\n             }\n         };\n \n+        let diag = &self.diag;\n+        let f = &self.f;\n         let ret = structure.gen_impl(quote! {\n             gen impl rustc_errors::AddToDiagnostic for @Self {\n-                fn add_to_diagnostic(self, #diag: &mut rustc_errors::Diagnostic) {\n+                fn add_to_diagnostic_with<__F>(self, #diag: &mut rustc_errors::Diagnostic, #f: __F)\n+                where\n+                    __F: Fn(\n+                        &mut rustc_errors::Diagnostic,\n+                        rustc_errors::SubdiagnosticMessage\n+                    ) -> rustc_errors::SubdiagnosticMessage,\n+                {\n                     use rustc_errors::{Applicability, IntoDiagnosticArg};\n                     #implementation\n                 }\n@@ -88,15 +97,18 @@ impl<'a> SubdiagnosticDerive<'a> {\n /// for the final generated method. This is a separate struct to `SubdiagnosticDerive`\n /// only to be able to destructure and split `self.builder` and the `self.structure` up to avoid a\n /// double mut borrow later on.\n-struct SubdiagnosticDeriveBuilder<'a> {\n+struct SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n     /// The identifier to use for the generated `DiagnosticBuilder` instance.\n-    diag: &'a syn::Ident,\n+    parent: &'parent SubdiagnosticDeriveBuilder,\n \n     /// Info for the current variant (or the type if not an enum).\n     variant: &'a VariantInfo<'a>,\n     /// Span for the entire type.\n     span: proc_macro::Span,\n \n+    /// Initialization of format strings for code suggestions.\n+    formatting_init: TokenStream,\n+\n     /// Store a map of field name to its corresponding field. This is built on construction of the\n     /// derive builder.\n     fields: FieldMap,\n@@ -112,7 +124,7 @@ struct SubdiagnosticDeriveBuilder<'a> {\n     has_suggestion_parts: bool,\n }\n \n-impl<'a> HasFieldMap for SubdiagnosticDeriveBuilder<'a> {\n+impl<'parent, 'a> HasFieldMap for SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n     fn get_field_binding(&self, field: &String) -> Option<&TokenStream> {\n         self.fields.get(field)\n     }\n@@ -156,7 +168,7 @@ impl<'a> FromIterator<&'a SubdiagnosticKind> for KindsStatistics {\n     }\n }\n \n-impl<'a> SubdiagnosticDeriveBuilder<'a> {\n+impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n     fn identify_kind(&mut self) -> Result<Vec<(SubdiagnosticKind, Path)>, DiagnosticDeriveError> {\n         let mut kind_slugs = vec![];\n \n@@ -187,7 +199,7 @@ impl<'a> SubdiagnosticDeriveBuilder<'a> {\n         let ast = binding.ast();\n         assert_eq!(ast.attrs.len(), 0, \"field with attribute used as diagnostic arg\");\n \n-        let diag = &self.diag;\n+        let diag = &self.parent.diag;\n         let ident = ast.ident.as_ref().unwrap();\n         // strip `r#` prefix, if present\n         let ident = format_ident!(\"{}\", ident);\n@@ -222,7 +234,7 @@ impl<'a> SubdiagnosticDeriveBuilder<'a> {\n                 };\n \n                 let generated = self\n-                    .generate_field_code_inner(kind_stats, attr, info)\n+                    .generate_field_code_inner(kind_stats, attr, info, inner_ty.will_iterate())\n                     .unwrap_or_else(|v| v.to_compile_error());\n \n                 inner_ty.with(binding, generated)\n@@ -235,13 +247,18 @@ impl<'a> SubdiagnosticDeriveBuilder<'a> {\n         kind_stats: KindsStatistics,\n         attr: &Attribute,\n         info: FieldInfo<'_>,\n+        clone_suggestion_code: bool,\n     ) -> Result<TokenStream, DiagnosticDeriveError> {\n         let meta = attr.parse_meta()?;\n         match meta {\n             Meta::Path(path) => self.generate_field_code_inner_path(kind_stats, attr, info, path),\n-            Meta::List(list @ MetaList { .. }) => {\n-                self.generate_field_code_inner_list(kind_stats, attr, info, list)\n-            }\n+            Meta::List(list @ MetaList { .. }) => self.generate_field_code_inner_list(\n+                kind_stats,\n+                attr,\n+                info,\n+                list,\n+                clone_suggestion_code,\n+            ),\n             _ => throw_invalid_attr!(attr, &meta),\n         }\n     }\n@@ -345,6 +362,7 @@ impl<'a> SubdiagnosticDeriveBuilder<'a> {\n         attr: &Attribute,\n         info: FieldInfo<'_>,\n         list: MetaList,\n+        clone_suggestion_code: bool,\n     ) -> Result<TokenStream, DiagnosticDeriveError> {\n         let span = attr.span().unwrap();\n         let ident = &list.path.segments.last().unwrap().ident;\n@@ -382,22 +400,29 @@ impl<'a> SubdiagnosticDeriveBuilder<'a> {\n                     match nested_name {\n                         \"code\" => {\n                             let formatted_str = self.build_format(&value.value(), value.span());\n-                            code.set_once(formatted_str, span);\n+                            let code_field = new_code_ident();\n+                            code.set_once((code_field, formatted_str), span);\n                         }\n                         _ => throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n                             diag.help(\"`code` is the only valid nested attribute\")\n                         }),\n                     }\n                 }\n \n-                let Some((code, _)) = code else {\n+                let Some((code_field, formatted_str)) = code.value() else {\n                     span_err(span, \"`#[suggestion_part(...)]` attribute without `code = \\\"...\\\"`\")\n                         .emit();\n                     return Ok(quote! {});\n                 };\n                 let binding = info.binding;\n \n-                Ok(quote! { suggestions.push((#binding, #code)); })\n+                self.formatting_init.extend(quote! { let #code_field = #formatted_str; });\n+                let code_field = if clone_suggestion_code {\n+                    quote! { #code_field.clone() }\n+                } else {\n+                    quote! { #code_field }\n+                };\n+                Ok(quote! { suggestions.push((#binding, #code_field)); })\n             }\n             _ => throw_invalid_attr!(attr, &Meta::List(list), |diag| {\n                 let mut span_attrs = vec![];\n@@ -442,13 +467,23 @@ impl<'a> SubdiagnosticDeriveBuilder<'a> {\n \n         let span_field = self.span_field.value_ref();\n \n-        let diag = &self.diag;\n+        let diag = &self.parent.diag;\n+        let f = &self.parent.f;\n         let mut calls = TokenStream::new();\n         for (kind, slug) in kind_slugs {\n+            let message = format_ident!(\"__message\");\n+            calls.extend(quote! { let #message = #f(#diag, rustc_errors::fluent::#slug.into()); });\n+\n             let name = format_ident!(\"{}{}\", if span_field.is_some() { \"span_\" } else { \"\" }, kind);\n-            let message = quote! { rustc_errors::fluent::#slug };\n             let call = match kind {\n-                SubdiagnosticKind::Suggestion { suggestion_kind, applicability, code } => {\n+                SubdiagnosticKind::Suggestion {\n+                    suggestion_kind,\n+                    applicability,\n+                    code_init,\n+                    code_field,\n+                } => {\n+                    self.formatting_init.extend(code_init);\n+\n                     let applicability = applicability\n                         .value()\n                         .map(|a| quote! { #a })\n@@ -457,8 +492,7 @@ impl<'a> SubdiagnosticDeriveBuilder<'a> {\n \n                     if let Some(span) = span_field {\n                         let style = suggestion_kind.to_suggestion_style();\n-\n-                        quote! { #diag.#name(#span, #message, #code, #applicability, #style); }\n+                        quote! { #diag.#name(#span, #message, #code_field, #applicability, #style); }\n                     } else {\n                         span_err(self.span, \"suggestion without `#[primary_span]` field\").emit();\n                         quote! { unreachable!(); }\n@@ -499,6 +533,7 @@ impl<'a> SubdiagnosticDeriveBuilder<'a> {\n                     }\n                 }\n             };\n+\n             calls.extend(call);\n         }\n \n@@ -510,11 +545,13 @@ impl<'a> SubdiagnosticDeriveBuilder<'a> {\n             .map(|binding| self.generate_field_set_arg(binding))\n             .collect();\n \n+        let formatting_init = &self.formatting_init;\n         Ok(quote! {\n             #init\n+            #formatting_init\n             #attr_args\n-            #calls\n             #plain_args\n+            #calls\n         })\n     }\n }"}, {"sha": "4fd4adc5112679ab7044a252ca2cc0d144a544a6", "filename": "compiler/rustc_macros/src/diagnostics/utils.rs", "status": "modified", "additions": 40, "deletions": 68, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs?ref=c0983a9aac889d16722a12602ac678051e62c3fb", "patch": "@@ -4,16 +4,29 @@ use crate::diagnostics::error::{\n use proc_macro::Span;\n use proc_macro2::TokenStream;\n use quote::{format_ident, quote, ToTokens};\n-use std::cmp::Ordering;\n+use std::cell::RefCell;\n use std::collections::{BTreeSet, HashMap};\n use std::fmt;\n use std::str::FromStr;\n use syn::{spanned::Spanned, Attribute, Field, Meta, Type, TypeTuple};\n use syn::{MetaList, MetaNameValue, NestedMeta, Path};\n-use synstructure::{BindStyle, BindingInfo, VariantInfo};\n+use synstructure::{BindingInfo, VariantInfo};\n \n use super::error::invalid_nested_attr;\n \n+thread_local! {\n+    pub static CODE_IDENT_COUNT: RefCell<u32> = RefCell::new(0);\n+}\n+\n+/// Returns an ident of the form `__code_N` where `N` is incremented once with every call.\n+pub(crate) fn new_code_ident() -> syn::Ident {\n+    CODE_IDENT_COUNT.with(|count| {\n+        let ident = format_ident!(\"__code_{}\", *count.borrow());\n+        *count.borrow_mut() += 1;\n+        ident\n+    })\n+}\n+\n /// Checks whether the type name of `ty` matches `name`.\n ///\n /// Given some struct at `a::b::c::Foo`, this will return true for `c::Foo`, `b::c::Foo`, or\n@@ -142,6 +155,15 @@ impl<'ty> FieldInnerTy<'ty> {\n         unreachable!();\n     }\n \n+    /// Returns `true` if `FieldInnerTy::with` will result in iteration for this inner type (i.e.\n+    /// that cloning might be required for values moved in the loop body).\n+    pub(crate) fn will_iterate(&self) -> bool {\n+        match self {\n+            FieldInnerTy::Vec(..) => true,\n+            FieldInnerTy::Option(..) | FieldInnerTy::None => false,\n+        }\n+    }\n+\n     /// Returns `Option` containing inner type if there is one.\n     pub(crate) fn inner_type(&self) -> Option<&'ty Type> {\n         match self {\n@@ -434,7 +456,12 @@ pub(super) enum SubdiagnosticKind {\n     Suggestion {\n         suggestion_kind: SuggestionKind,\n         applicability: SpannedOption<Applicability>,\n-        code: TokenStream,\n+        /// Identifier for variable used for formatted code, e.g. `___code_0`. Enables separation\n+        /// of formatting and diagnostic emission so that `set_arg` calls can happen in-between..\n+        code_field: syn::Ident,\n+        /// Initialization logic for `code_field`'s variable, e.g.\n+        /// `let __formatted_code = /* whatever */;`\n+        code_init: TokenStream,\n     },\n     /// `#[multipart_suggestion{,_short,_hidden,_verbose}]`\n     MultipartSuggestion {\n@@ -469,7 +496,8 @@ impl SubdiagnosticKind {\n                     SubdiagnosticKind::Suggestion {\n                         suggestion_kind,\n                         applicability: None,\n-                        code: TokenStream::new(),\n+                        code_field: new_code_ident(),\n+                        code_init: TokenStream::new(),\n                     }\n                 } else if let Some(suggestion_kind) =\n                     name.strip_prefix(\"multipart_suggestion\").and_then(|s| s.parse().ok())\n@@ -548,9 +576,10 @@ impl SubdiagnosticKind {\n             };\n \n             match (nested_name, &mut kind) {\n-                (\"code\", SubdiagnosticKind::Suggestion { .. }) => {\n+                (\"code\", SubdiagnosticKind::Suggestion { code_field, .. }) => {\n                     let formatted_str = fields.build_format(&value.value(), value.span());\n-                    code.set_once(formatted_str, span);\n+                    let code_init = quote! { let #code_field = #formatted_str; };\n+                    code.set_once(code_init, span);\n                 }\n                 (\n                     \"applicability\",\n@@ -582,13 +611,13 @@ impl SubdiagnosticKind {\n         }\n \n         match kind {\n-            SubdiagnosticKind::Suggestion { code: ref mut code_field, .. } => {\n-                *code_field = if let Some((code, _)) = code {\n-                    code\n+            SubdiagnosticKind::Suggestion { ref code_field, ref mut code_init, .. } => {\n+                *code_init = if let Some(init) = code.value() {\n+                    init\n                 } else {\n                     span_err(span, \"suggestion without `code = \\\"...\\\"`\").emit();\n-                    quote! { \"\" }\n-                }\n+                    quote! { let #code_field: String = unreachable!(); }\n+                };\n             }\n             SubdiagnosticKind::Label\n             | SubdiagnosticKind::Note\n@@ -620,65 +649,8 @@ impl quote::IdentFragment for SubdiagnosticKind {\n     }\n }\n \n-/// Wrapper around `synstructure::BindStyle` which implements `Ord`.\n-#[derive(PartialEq, Eq)]\n-pub(super) struct OrderedBindStyle(pub(super) BindStyle);\n-\n-impl OrderedBindStyle {\n-    /// Is `BindStyle::Move` or `BindStyle::MoveMut`?\n-    pub(super) fn is_move(&self) -> bool {\n-        matches!(self.0, BindStyle::Move | BindStyle::MoveMut)\n-    }\n-}\n-\n-impl Ord for OrderedBindStyle {\n-    fn cmp(&self, other: &Self) -> Ordering {\n-        match (self.is_move(), other.is_move()) {\n-            // If both `self` and `other` are the same, then ordering is equal.\n-            (true, true) | (false, false) => Ordering::Equal,\n-            // If `self` is not a move then it should be considered less than `other` (so that\n-            // references are sorted first).\n-            (false, _) => Ordering::Less,\n-            // If `self` is a move then it must be greater than `other` (again, so that references\n-            // are sorted first).\n-            (true, _) => Ordering::Greater,\n-        }\n-    }\n-}\n-\n-impl PartialOrd for OrderedBindStyle {\n-    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n-        Some(self.cmp(other))\n-    }\n-}\n-\n /// Returns `true` if `field` should generate a `set_arg` call rather than any other diagnostic\n /// call (like `span_label`).\n pub(super) fn should_generate_set_arg(field: &Field) -> bool {\n     field.attrs.is_empty()\n }\n-\n-/// Returns `true` if `field` needs to have code generated in the by-move branch of the\n-/// generated derive rather than the by-ref branch.\n-pub(super) fn bind_style_of_field(field: &Field) -> OrderedBindStyle {\n-    let generates_set_arg = should_generate_set_arg(field);\n-    let is_multispan = type_matches_path(&field.ty, &[\"rustc_errors\", \"MultiSpan\"]);\n-    // FIXME(davidtwco): better support for one field needing to be in the by-move and\n-    // by-ref branches.\n-    let is_subdiagnostic = field\n-        .attrs\n-        .iter()\n-        .map(|attr| attr.path.segments.last().unwrap().ident.to_string())\n-        .any(|attr| attr == \"subdiagnostic\");\n-\n-    // `set_arg` calls take their argument by-move..\n-    let needs_move = generates_set_arg\n-        // If this is a `MultiSpan` field then it needs to be moved to be used by any\n-        // attribute..\n-        || is_multispan\n-        // If this a `#[subdiagnostic]` then it needs to be moved as the other diagnostic is\n-        // unlikely to be `Copy`..\n-        || is_subdiagnostic;\n-\n-    OrderedBindStyle(if needs_move { BindStyle::Move } else { BindStyle::Ref })\n-}"}, {"sha": "68119598285c5978421d6ade2ae3081b046cbb07", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 41, "deletions": 15, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=c0983a9aac889d16722a12602ac678051e62c3fb", "patch": "@@ -1059,6 +1059,43 @@ fn should_encode_const(def_kind: DefKind) -> bool {\n     }\n }\n \n+fn should_encode_constness(def_kind: DefKind) -> bool {\n+    match def_kind {\n+        DefKind::Struct\n+        | DefKind::Union\n+        | DefKind::Enum\n+        | DefKind::Trait\n+        | DefKind::AssocTy\n+        | DefKind::Fn\n+        | DefKind::Const\n+        | DefKind::Static(..)\n+        | DefKind::Ctor(..)\n+        | DefKind::AssocFn\n+        | DefKind::AssocConst\n+        | DefKind::AnonConst\n+        | DefKind::InlineConst\n+        | DefKind::OpaqueTy\n+        | DefKind::ImplTraitPlaceholder\n+        | DefKind::Impl\n+        | DefKind::Closure\n+        | DefKind::Generator\n+        | DefKind::TyAlias => true,\n+        DefKind::Variant\n+        | DefKind::TraitAlias\n+        | DefKind::ForeignTy\n+        | DefKind::Field\n+        | DefKind::TyParam\n+        | DefKind::Mod\n+        | DefKind::ForeignMod\n+        | DefKind::ConstParam\n+        | DefKind::Macro(..)\n+        | DefKind::Use\n+        | DefKind::LifetimeParam\n+        | DefKind::GlobalAsm\n+        | DefKind::ExternCrate => false,\n+    }\n+}\n+\n fn should_encode_trait_impl_trait_tys<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> bool {\n     if tcx.def_kind(def_id) != DefKind::AssocFn {\n         return false;\n@@ -1165,6 +1202,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             {\n                 record!(self.tables.trait_impl_trait_tys[def_id] <- table);\n             }\n+            if should_encode_constness(def_kind) {\n+                self.tables.constness.set(def_id.index, tcx.constness(def_id));\n+            }\n         }\n         let inherent_impls = tcx.crate_inherent_impls(());\n         for (def_id, implementations) in inherent_impls.inherent_impls.iter() {\n@@ -1192,7 +1232,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         };\n \n         record!(self.tables.variant_data[def_id] <- data);\n-        self.tables.constness.set(def_id.index, hir::Constness::Const);\n         record_array!(self.tables.children[def_id] <- variant.fields.iter().map(|f| {\n             assert!(f.did.is_local());\n             f.did.index\n@@ -1220,7 +1259,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         };\n \n         record!(self.tables.variant_data[def_id] <- data);\n-        self.tables.constness.set(def_id.index, hir::Constness::Const);\n         if variant.ctor_kind == CtorKind::Fn {\n             record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n         }\n@@ -1284,7 +1322,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         record!(self.tables.repr_options[def_id] <- adt_def.repr());\n         record!(self.tables.variant_data[def_id] <- data);\n-        self.tables.constness.set(def_id.index, hir::Constness::Const);\n         if variant.ctor_kind == CtorKind::Fn {\n             record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n         }\n@@ -1320,7 +1357,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                     }\n                 };\n                 self.tables.asyncness.set(def_id.index, m_sig.header.asyncness);\n-                self.tables.constness.set(def_id.index, hir::Constness::NotConst);\n             }\n             ty::AssocKind::Type => {\n                 self.encode_explicit_item_bounds(def_id);\n@@ -1345,13 +1381,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 let hir::ImplItemKind::Fn(ref sig, body) = ast_item.kind else { bug!() };\n                 self.tables.asyncness.set(def_id.index, sig.header.asyncness);\n                 record_array!(self.tables.fn_arg_names[def_id] <- self.tcx.hir().body_param_names(body));\n-                // Can be inside `impl const Trait`, so using sig.header.constness is not reliable\n-                let constness = if self.tcx.is_const_fn_raw(def_id) {\n-                    hir::Constness::Const\n-                } else {\n-                    hir::Constness::NotConst\n-                };\n-                self.tables.constness.set(def_id.index, constness);\n             }\n             ty::AssocKind::Const | ty::AssocKind::Type => {}\n         }\n@@ -1474,7 +1503,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             hir::ItemKind::Fn(ref sig, .., body) => {\n                 self.tables.asyncness.set(def_id.index, sig.header.asyncness);\n                 record_array!(self.tables.fn_arg_names[def_id] <- self.tcx.hir().body_param_names(body));\n-                self.tables.constness.set(def_id.index, sig.header.constness);\n             }\n             hir::ItemKind::Macro(ref macro_def, _) => {\n                 if macro_def.macro_rules {\n@@ -1495,7 +1523,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             hir::ItemKind::Struct(ref struct_def, _) => {\n                 let adt_def = self.tcx.adt_def(def_id);\n                 record!(self.tables.repr_options[def_id] <- adt_def.repr());\n-                self.tables.constness.set(def_id.index, hir::Constness::Const);\n \n                 // Encode def_ids for each field and method\n                 // for methods, write all the stuff get_trait_method\n@@ -1524,9 +1551,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                     is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n                 });\n             }\n-            hir::ItemKind::Impl(hir::Impl { defaultness, constness, .. }) => {\n+            hir::ItemKind::Impl(hir::Impl { defaultness, .. }) => {\n                 self.tables.impl_defaultness.set(def_id.index, *defaultness);\n-                self.tables.constness.set(def_id.index, *constness);\n \n                 let trait_ref = self.tcx.impl_trait_ref(def_id);\n                 if let Some(trait_ref) = trait_ref {"}, {"sha": "d4258151ff3f33a853dd025a1691d18406d293fa", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=c0983a9aac889d16722a12602ac678051e62c3fb", "patch": "@@ -2946,11 +2946,12 @@ impl Location {\n mod size_asserts {\n     use super::*;\n     use rustc_data_structures::static_assert_size;\n-    // These are in alphabetical order, which is easy to maintain.\n+    // tidy-alphabetical-start\n     static_assert_size!(BasicBlockData<'_>, 144);\n     static_assert_size!(LocalDecl<'_>, 56);\n     static_assert_size!(Statement<'_>, 32);\n     static_assert_size!(StatementKind<'_>, 16);\n     static_assert_size!(Terminator<'_>, 112);\n     static_assert_size!(TerminatorKind<'_>, 96);\n+    // tidy-alphabetical-end\n }"}, {"sha": "85ef51f129bbdde75834a4b1ddc11ae3706dda66", "filename": "compiler/rustc_middle/src/mir/syntax.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs?ref=c0983a9aac889d16722a12602ac678051e62c3fb", "patch": "@@ -1245,10 +1245,11 @@ pub enum BinOp {\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n mod size_asserts {\n     use super::*;\n-    // These are in alphabetical order, which is easy to maintain.\n+    // tidy-alphabetical-start\n     static_assert_size!(AggregateKind<'_>, 40);\n     static_assert_size!(Operand<'_>, 24);\n     static_assert_size!(Place<'_>, 16);\n     static_assert_size!(PlaceElem<'_>, 24);\n     static_assert_size!(Rvalue<'_>, 40);\n+    // tidy-alphabetical-end\n }"}, {"sha": "ea7a507d7a43ceb499a1f4c87b571d716fff02ab", "filename": "compiler/rustc_middle/src/thir.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir.rs?ref=c0983a9aac889d16722a12602ac678051e62c3fb", "patch": "@@ -848,12 +848,13 @@ impl<'tcx> fmt::Display for Pat<'tcx> {\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n mod size_asserts {\n     use super::*;\n-    // These are in alphabetical order, which is easy to maintain.\n+    // tidy-alphabetical-start\n     static_assert_size!(Block, 56);\n     static_assert_size!(Expr<'_>, 64);\n     static_assert_size!(ExprKind<'_>, 40);\n     static_assert_size!(Pat<'_>, 72);\n     static_assert_size!(PatKind<'_>, 56);\n     static_assert_size!(Stmt<'_>, 48);\n     static_assert_size!(StmtKind<'_>, 40);\n+    // tidy-alphabetical-end\n }"}, {"sha": "12d24d6751e27c1d0e1ac1dfe3e86033602a6c18", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=c0983a9aac889d16722a12602ac678051e62c3fb", "patch": "@@ -2668,8 +2668,9 @@ pub struct DestructuredConst<'tcx> {\n mod size_asserts {\n     use super::*;\n     use rustc_data_structures::static_assert_size;\n-    // These are in alphabetical order, which is easy to maintain.\n+    // tidy-alphabetical-start\n     static_assert_size!(PredicateS<'_>, 48);\n     static_assert_size!(TyS<'_>, 40);\n     static_assert_size!(WithStableHash<TyS<'_>>, 56);\n+    // tidy-alphabetical-end\n }"}, {"sha": "81c051b8f35e4843916857857fc4d8a830e60755", "filename": "compiler/rustc_parse/src/parser/attr_wrapper.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs?ref=c0983a9aac889d16722a12602ac678051e62c3fb", "patch": "@@ -459,7 +459,8 @@ fn make_token_stream(\n mod size_asserts {\n     use super::*;\n     use rustc_data_structures::static_assert_size;\n-    // These are in alphabetical order, which is easy to maintain.\n+    // tidy-alphabetical-start\n     static_assert_size!(AttrWrapper, 16);\n     static_assert_size!(LazyAttrTokenStreamImpl, 144);\n+    // tidy-alphabetical-end\n }"}, {"sha": "ebcbc75ba32c385504df668434567f8bbb9546ba", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=c0983a9aac889d16722a12602ac678051e62c3fb", "patch": "@@ -1789,20 +1789,25 @@ impl<'a> Parser<'a> {\n                 }\n             } else {\n                 let mut err = self.expected_ident_found();\n-                if let Some((ident, _)) = self.token.ident() && ident.as_str() == \"let\" {\n-                    self.bump(); // `let`\n-                    let span = self.prev_token.span.until(self.token.span);\n+                if self.eat_keyword_noexpect(kw::Let)\n+                    && let removal_span = self.prev_token.span.until(self.token.span)\n+                    && let Ok(ident) = self.parse_ident_common(false)\n+                        // Cancel this error, we don't need it.\n+                        .map_err(|err| err.cancel())\n+                    && self.token.kind == TokenKind::Colon\n+                {\n                     err.span_suggestion(\n-                        span,\n-                        \"remove the let, the `let` keyword is not allowed in struct field definitions\",\n+                        removal_span,\n+                        \"remove this `let` keyword\",\n                         String::new(),\n                         Applicability::MachineApplicable,\n                     );\n                     err.note(\"the `let` keyword is not allowed in `struct` fields\");\n                     err.note(\"see <https://doc.rust-lang.org/book/ch05-01-defining-structs.html> for more information\");\n                     err.emit();\n-                    self.bump();\n                     return Ok(ident);\n+                } else {\n+                    self.restore_snapshot(snapshot);\n                 }\n                 err\n             };"}, {"sha": "1e74e0e299099728c5997c1621cd51b085679fb3", "filename": "compiler/rustc_query_system/src/error.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_query_system%2Fsrc%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_query_system%2Fsrc%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Ferror.rs?ref=c0983a9aac889d16722a12602ac678051e62c3fb", "patch": "@@ -1,19 +1,15 @@\n-use rustc_errors::AddToDiagnostic;\n use rustc_macros::{Diagnostic, Subdiagnostic};\n use rustc_session::Limit;\n use rustc_span::{Span, Symbol};\n \n+#[derive(Subdiagnostic)]\n+#[note(query_system::cycle_stack_middle)]\n pub struct CycleStack {\n+    #[primary_span]\n     pub span: Span,\n     pub desc: String,\n }\n \n-impl AddToDiagnostic for CycleStack {\n-    fn add_to_diagnostic(self, diag: &mut rustc_errors::Diagnostic) {\n-        diag.span_note(self.span, &format!(\"...which requires {}...\", self.desc));\n-    }\n-}\n-\n #[derive(Copy, Clone)]\n pub enum HandleCycleError {\n     Error,\n@@ -53,7 +49,7 @@ pub struct Cycle {\n     #[primary_span]\n     pub span: Span,\n     pub stack_bottom: String,\n-    #[subdiagnostic]\n+    #[subdiagnostic(eager)]\n     pub cycle_stack: Vec<CycleStack>,\n     #[subdiagnostic]\n     pub stack_count: StackCount,"}, {"sha": "f47760e9ae6c8aa5818c875f8396ce4a6ff43b1d", "filename": "compiler/rustc_query_system/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_query_system%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_query_system%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Flib.rs?ref=c0983a9aac889d16722a12602ac678051e62c3fb", "patch": "@@ -4,7 +4,7 @@\n #![feature(min_specialization)]\n #![feature(extern_types)]\n #![allow(rustc::potential_query_instability)]\n-// #![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::untranslatable_diagnostic)]\n #![deny(rustc::diagnostic_outside_of_impl)]\n \n #[macro_use]"}, {"sha": "102df3a4d7eade10d358a6e9b092f757201511d9", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 51, "deletions": 55, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=c0983a9aac889d16722a12602ac678051e62c3fb", "patch": "@@ -1075,12 +1075,11 @@ mod parse {\n options! {\n     CodegenOptions, CG_OPTIONS, cgopts, \"C\", \"codegen\",\n \n-    // This list is in alphabetical order.\n-    //\n     // If you add a new option, please update:\n     // - compiler/rustc_interface/src/tests.rs\n     // - src/doc/rustc/src/codegen-options/index.md\n \n+    // tidy-alphabetical-start\n     ar: String = (String::new(), parse_string, [UNTRACKED],\n         \"this option is deprecated and does nothing\"),\n     #[rustc_lint_opt_deny_field_access(\"use `Session::code_model` instead of this field\")]\n@@ -1195,9 +1194,8 @@ options! {\n     target_feature: String = (String::new(), parse_target_feature, [TRACKED],\n         \"target specific attributes. (`rustc --print target-features` for details). \\\n         This feature is unsafe.\"),\n+    // tidy-alphabetical-end\n \n-    // This list is in alphabetical order.\n-    //\n     // If you add a new option, please update:\n     // - compiler/rustc_interface/src/tests.rs\n     // - src/doc/rustc/src/codegen-options/index.md\n@@ -1206,24 +1204,23 @@ options! {\n options! {\n     UnstableOptions, Z_OPTIONS, dbopts, \"Z\", \"unstable\",\n \n-    // This list is in alphabetical order.\n-    //\n     // If you add a new option, please update:\n     // - compiler/rustc_interface/src/tests.rs\n     // - src/doc/unstable-book/src/compiler-flags\n \n+    // tidy-alphabetical-start\n     allow_features: Option<Vec<String>> = (None, parse_opt_comma_list, [TRACKED],\n         \"only allow the listed language features to be enabled in code (space separated)\"),\n     always_encode_mir: bool = (false, parse_bool, [TRACKED],\n         \"encode MIR of all functions into the crate metadata (default: no)\"),\n-    assume_incomplete_release: bool = (false, parse_bool, [TRACKED],\n-        \"make cfg(version) treat the current version as incomplete (default: no)\"),\n     #[rustc_lint_opt_deny_field_access(\"use `Session::asm_comments` instead of this field\")]\n     asm_comments: bool = (false, parse_bool, [TRACKED],\n         \"generate comments into the assembly (may change behavior) (default: no)\"),\n     assert_incr_state: Option<String> = (None, parse_opt_string, [UNTRACKED],\n         \"assert that the incremental cache is in given state: \\\n          either `loaded` or `not-loaded`.\"),\n+    assume_incomplete_release: bool = (false, parse_bool, [TRACKED],\n+        \"make cfg(version) treat the current version as incomplete (default: no)\"),\n     #[rustc_lint_opt_deny_field_access(\"use `Session::binary_dep_depinfo` instead of this field\")]\n     binary_dep_depinfo: bool = (false, parse_bool, [TRACKED],\n         \"include artifacts (sysroot, crate dependencies) used during compilation in dep-info \\\n@@ -1256,6 +1253,8 @@ options! {\n     dep_tasks: bool = (false, parse_bool, [UNTRACKED],\n         \"print tasks that execute and the color their dep node gets (requires debug build) \\\n         (default: no)\"),\n+    diagnostic_width: Option<usize> = (None, parse_opt_number, [UNTRACKED],\n+        \"set the current output width for diagnostic truncation\"),\n     dlltool: Option<PathBuf> = (None, parse_opt_pathbuf, [UNTRACKED],\n         \"import library generation tool (windows-gnu only)\"),\n     dont_buffer_diagnostics: bool = (false, parse_bool, [UNTRACKED],\n@@ -1337,16 +1336,16 @@ options! {\n         \"hash spans relative to their parent item for incr. comp. (default: no)\"),\n     incremental_verify_ich: bool = (false, parse_bool, [UNTRACKED],\n         \"verify incr. comp. hashes of green query instances (default: no)\"),\n+    inline_in_all_cgus: Option<bool> = (None, parse_opt_bool, [TRACKED],\n+        \"control whether `#[inline]` functions are in all CGUs\"),\n     inline_llvm: bool = (true, parse_bool, [TRACKED],\n         \"enable LLVM inlining (default: yes)\"),\n     inline_mir: Option<bool> = (None, parse_opt_bool, [TRACKED],\n         \"enable MIR inlining (default: no)\"),\n-    inline_mir_threshold: Option<usize> = (None, parse_opt_number, [TRACKED],\n-        \"a default MIR inlining threshold (default: 50)\"),\n     inline_mir_hint_threshold: Option<usize> = (None, parse_opt_number, [TRACKED],\n         \"inlining threshold for functions with inline hint (default: 100)\"),\n-    inline_in_all_cgus: Option<bool> = (None, parse_opt_bool, [TRACKED],\n-        \"control whether `#[inline]` functions are in all CGUs\"),\n+    inline_mir_threshold: Option<usize> = (None, parse_opt_number, [TRACKED],\n+        \"a default MIR inlining threshold (default: 50)\"),\n     input_stats: bool = (false, parse_bool, [UNTRACKED],\n         \"gather statistics about the input (default: no)\"),\n     #[rustc_lint_opt_deny_field_access(\"use `Session::instrument_coverage` instead of this field\")]\n@@ -1363,6 +1362,8 @@ options! {\n         \"insert function instrument code for mcount-based tracing (default: no)\"),\n     keep_hygiene_data: bool = (false, parse_bool, [UNTRACKED],\n         \"keep hygiene data after analysis (default: no)\"),\n+    layout_seed: Option<u64> = (None, parse_opt_number, [TRACKED],\n+        \"seed layout randomization\"),\n     link_native_libraries: bool = (true, parse_bool, [UNTRACKED],\n         \"link native libraries in the linker invocation (default: yes)\"),\n     link_only: bool = (false, parse_bool, [TRACKED],\n@@ -1392,11 +1393,11 @@ options! {\n         \"use like `-Zmir-enable-passes=+DestProp,-InstCombine`. Forces the specified passes to be \\\n         enabled, overriding all other checks. Passes that are not specified are enabled or \\\n         disabled by other flags as usual.\"),\n-    mir_pretty_relative_line_numbers: bool = (false, parse_bool, [UNTRACKED],\n-        \"use line numbers relative to the function in mir pretty printing\"),\n     #[rustc_lint_opt_deny_field_access(\"use `Session::mir_opt_level` instead of this field\")]\n     mir_opt_level: Option<usize> = (None, parse_opt_number, [TRACKED],\n         \"MIR optimization level (0-4; default: 1 in non optimized builds and 2 in optimized builds)\"),\n+    mir_pretty_relative_line_numbers: bool = (false, parse_bool, [UNTRACKED],\n+        \"use line numbers relative to the function in mir pretty printing\"),\n     move_size_limit: Option<usize> = (None, parse_opt_number, [TRACKED],\n         \"the size at which the `large_assignments` lint starts to be emitted\"),\n     mutable_noalias: Option<bool> = (None, parse_opt_bool, [TRACKED],\n@@ -1419,18 +1420,16 @@ options! {\n         \"compile without linking\"),\n     no_parallel_llvm: bool = (false, parse_no_flag, [UNTRACKED],\n         \"run LLVM in non-parallel mode (while keeping codegen-units and ThinLTO)\"),\n-    no_unique_section_names: bool = (false, parse_bool, [TRACKED],\n-        \"do not use unique names for text and data sections when -Z function-sections is used\"),\n     no_profiler_runtime: bool = (false, parse_no_flag, [TRACKED],\n         \"prevent automatic injection of the profiler_builtins crate\"),\n+    no_unique_section_names: bool = (false, parse_bool, [TRACKED],\n+        \"do not use unique names for text and data sections when -Z function-sections is used\"),\n     normalize_docs: bool = (false, parse_bool, [TRACKED],\n         \"normalize associated items in rustdoc when generating documentation\"),\n     oom: OomStrategy = (OomStrategy::Abort, parse_oom_strategy, [TRACKED],\n         \"panic strategy for out-of-memory handling\"),\n     osx_rpath_install_name: bool = (false, parse_bool, [TRACKED],\n         \"pass `-install_name @rpath/...` to the macOS linker (default: no)\"),\n-    diagnostic_width: Option<usize> = (None, parse_opt_number, [UNTRACKED],\n-        \"set the current output width for diagnostic truncation\"),\n     packed_bundled_libs: bool = (false, parse_bool, [TRACKED],\n         \"change rlib format to store native libraries as archives\"),\n     panic_abort_tests: bool = (false, parse_bool, [TRACKED],\n@@ -1480,25 +1479,20 @@ options! {\n     profile_emit: Option<PathBuf> = (None, parse_opt_pathbuf, [TRACKED],\n         \"file path to emit profiling data at runtime when using 'profile' \\\n         (default based on relative source path)\"),\n-    profiler_runtime: String = (String::from(\"profiler_builtins\"), parse_string, [TRACKED],\n-        \"name of the profiler runtime crate to automatically inject (default: `profiler_builtins`)\"),\n     profile_sample_use: Option<PathBuf> = (None, parse_opt_pathbuf, [TRACKED],\n         \"use the given `.prof` file for sampled profile-guided optimization (also known as AutoFDO)\"),\n+    profiler_runtime: String = (String::from(\"profiler_builtins\"), parse_string, [TRACKED],\n+        \"name of the profiler runtime crate to automatically inject (default: `profiler_builtins`)\"),\n     query_dep_graph: bool = (false, parse_bool, [UNTRACKED],\n         \"enable queries of the dependency graph for regression testing (default: no)\"),\n     randomize_layout: bool = (false, parse_bool, [TRACKED],\n         \"randomize the layout of types (default: no)\"),\n-    layout_seed: Option<u64> = (None, parse_opt_number, [TRACKED],\n-        \"seed layout randomization\"),\n     relax_elf_relocations: Option<bool> = (None, parse_opt_bool, [TRACKED],\n         \"whether ELF relocations can be relaxed\"),\n     relro_level: Option<RelroLevel> = (None, parse_relro_level, [TRACKED],\n         \"choose which RELRO level to use\"),\n     remap_cwd_prefix: Option<PathBuf> = (None, parse_opt_pathbuf, [TRACKED],\n         \"remap paths under the current working directory to this path prefix\"),\n-    simulate_remapped_rust_src_base: Option<PathBuf> = (None, parse_opt_pathbuf, [TRACKED],\n-        \"simulate the effect of remap-debuginfo = true at bootstrapping by remapping path \\\n-        to rust's source base directory. only meant for testing purposes\"),\n     report_delayed_bugs: bool = (false, parse_bool, [TRACKED],\n         \"immediately print bugs registered with `delay_span_bug` (default: no)\"),\n     sanitizer: SanitizerSet = (SanitizerSet::empty(), parse_sanitizers, [TRACKED],\n@@ -1516,27 +1510,41 @@ options! {\n     self_profile: SwitchWithOptPath = (SwitchWithOptPath::Disabled,\n         parse_switch_with_opt_path, [UNTRACKED],\n         \"run the self profiler and output the raw event data\"),\n-    /// keep this in sync with the event filter names in librustc_data_structures/profiling.rs\n-    self_profile_events: Option<Vec<String>> = (None, parse_opt_comma_list, [UNTRACKED],\n-        \"specify the events recorded by the self profiler;\n-        for example: `-Z self-profile-events=default,query-keys`\n-        all options: none, all, default, generic-activity, query-provider, query-cache-hit\n-                     query-blocked, incr-cache-load, incr-result-hashing, query-keys, function-args, args, llvm, artifact-sizes\"),\n     self_profile_counter: String = (\"wall-time\".to_string(), parse_string, [UNTRACKED],\n         \"counter used by the self profiler (default: `wall-time`), one of:\n         `wall-time` (monotonic clock, i.e. `std::time::Instant`)\n         `instructions:u` (retired instructions, userspace-only)\n         `instructions-minus-irqs:u` (subtracting hardware interrupt counts for extra accuracy)\"\n     ),\n+    /// keep this in sync with the event filter names in librustc_data_structures/profiling.rs\n+    self_profile_events: Option<Vec<String>> = (None, parse_opt_comma_list, [UNTRACKED],\n+        \"specify the events recorded by the self profiler;\n+        for example: `-Z self-profile-events=default,query-keys`\n+        all options: none, all, default, generic-activity, query-provider, query-cache-hit\n+                     query-blocked, incr-cache-load, incr-result-hashing, query-keys, function-args, args, llvm, artifact-sizes\"),\n     share_generics: Option<bool> = (None, parse_opt_bool, [TRACKED],\n         \"make the current crate share its generic instantiations\"),\n     show_span: Option<String> = (None, parse_opt_string, [TRACKED],\n         \"show spans for compiler debugging (expr|pat|ty)\"),\n+    simulate_remapped_rust_src_base: Option<PathBuf> = (None, parse_opt_pathbuf, [TRACKED],\n+        \"simulate the effect of remap-debuginfo = true at bootstrapping by remapping path \\\n+        to rust's source base directory. only meant for testing purposes\"),\n     span_debug: bool = (false, parse_bool, [UNTRACKED],\n         \"forward proc_macro::Span's `Debug` impl to `Span`\"),\n     /// o/w tests have closure@path\n     span_free_formats: bool = (false, parse_bool, [UNTRACKED],\n         \"exclude spans when debug-printing compiler state (default: no)\"),\n+    split_dwarf_inlining: bool = (true, parse_bool, [TRACKED],\n+        \"provide minimal debug info in the object/executable to facilitate online \\\n+         symbolication/stack traces in the absence of .dwo/.dwp files when using Split DWARF\"),\n+    split_dwarf_kind: SplitDwarfKind = (SplitDwarfKind::Split, parse_split_dwarf_kind, [TRACKED],\n+        \"split dwarf variant (only if -Csplit-debuginfo is enabled and on relevant platform)\n+        (default: `split`)\n+\n+        `split`: sections which do not require relocation are written into a DWARF object (`.dwo`)\n+                 file which is ignored by the linker\n+        `single`: sections which do not require relocation are written into object file but ignored\n+                  by the linker\"),\n     src_hash_algorithm: Option<SourceFileHashAlgorithm> = (None, parse_src_file_hash, [TRACKED],\n         \"hash algorithm of source files in debug info (`md5`, `sha1`, or `sha256`)\"),\n     #[rustc_lint_opt_deny_field_access(\"use `Session::stack_protector` instead of this field\")]\n@@ -1546,17 +1554,6 @@ options! {\n         \"control if mem::uninitialized and mem::zeroed panic on more UB\"),\n     strip: Strip = (Strip::None, parse_strip, [UNTRACKED],\n         \"tell the linker which information to strip (`none` (default), `debuginfo` or `symbols`)\"),\n-    split_dwarf_kind: SplitDwarfKind = (SplitDwarfKind::Split, parse_split_dwarf_kind, [TRACKED],\n-        \"split dwarf variant (only if -Csplit-debuginfo is enabled and on relevant platform)\n-        (default: `split`)\n-\n-        `split`: sections which do not require relocation are written into a DWARF object (`.dwo`)\n-                 file which is ignored by the linker\n-        `single`: sections which do not require relocation are written into object file but ignored\n-                  by the linker\"),\n-    split_dwarf_inlining: bool = (true, parse_bool, [TRACKED],\n-        \"provide minimal debug info in the object/executable to facilitate online \\\n-         symbolication/stack traces in the absence of .dwo/.dwp files when using Split DWARF\"),\n     symbol_mangling_version: Option<SymbolManglingVersion> = (None,\n         parse_symbol_mangling_version, [TRACKED],\n         \"which mangling version to use for symbol names ('legacy' (default) or 'v0')\"),\n@@ -1565,17 +1562,6 @@ options! {\n         \"show extended diagnostic help (default: no)\"),\n     temps_dir: Option<String> = (None, parse_opt_string, [UNTRACKED],\n         \"the directory the intermediate files are written to\"),\n-    // Diagnostics are considered side-effects of a query (see `QuerySideEffects`) and are saved\n-    // alongside query results and changes to translation options can affect diagnostics - so\n-    // translation options should be tracked.\n-    translate_lang: Option<LanguageIdentifier> = (None, parse_opt_langid, [TRACKED],\n-        \"language identifier for diagnostic output\"),\n-    translate_additional_ftl: Option<PathBuf> = (None, parse_opt_pathbuf, [TRACKED],\n-        \"additional fluent translation to preferentially use (for testing translation)\"),\n-    translate_directionality_markers: bool = (false, parse_bool, [TRACKED],\n-        \"emit directionality isolation markers in translated diagnostics\"),\n-    tune_cpu: Option<String> = (None, parse_opt_string, [TRACKED],\n-        \"select processor to schedule for (`rustc --print target-cpus` for details)\"),\n     #[rustc_lint_opt_deny_field_access(\"use `Session::lto` instead of this field\")]\n     thinlto: Option<bool> = (None, parse_opt_bool, [TRACKED],\n         \"enable ThinLTO when possible\"),\n@@ -1599,6 +1585,15 @@ options! {\n         \"choose the TLS model to use (`rustc --print tls-models` for details)\"),\n     trace_macros: bool = (false, parse_bool, [UNTRACKED],\n         \"for every macro invocation, print its name and arguments (default: no)\"),\n+    // Diagnostics are considered side-effects of a query (see `QuerySideEffects`) and are saved\n+    // alongside query results and changes to translation options can affect diagnostics - so\n+    // translation options should be tracked.\n+    translate_additional_ftl: Option<PathBuf> = (None, parse_opt_pathbuf, [TRACKED],\n+        \"additional fluent translation to preferentially use (for testing translation)\"),\n+    translate_directionality_markers: bool = (false, parse_bool, [TRACKED],\n+        \"emit directionality isolation markers in translated diagnostics\"),\n+    translate_lang: Option<LanguageIdentifier> = (None, parse_opt_langid, [TRACKED],\n+        \"language identifier for diagnostic output\"),\n     translate_remapped_path_to_local_path: bool = (true, parse_bool, [TRACKED],\n         \"translate remapped paths into local paths when possible (default: yes)\"),\n     trap_unreachable: Option<bool> = (None, parse_opt_bool, [TRACKED],\n@@ -1607,6 +1602,8 @@ options! {\n         \"treat error number `val` that occurs as bug\"),\n     trim_diagnostic_paths: bool = (true, parse_bool, [UNTRACKED],\n         \"in diagnostics, use heuristics to shorten paths referring to items\"),\n+    tune_cpu: Option<String> = (None, parse_opt_string, [TRACKED],\n+        \"select processor to schedule for (`rustc --print target-cpus` for details)\"),\n     ui_testing: bool = (false, parse_bool, [UNTRACKED],\n         \"emit compiler diagnostics in a form suitable for UI testing (default: no)\"),\n     uninit_const_chunk_threshold: usize = (16, parse_number, [TRACKED],\n@@ -1647,9 +1644,8 @@ options! {\n         Requires `-Clto[=[fat,yes]]`\"),\n     wasi_exec_model: Option<WasiExecModel> = (None, parse_wasi_exec_model, [TRACKED],\n         \"whether to build a wasi command or reactor\"),\n+    // tidy-alphabetical-end\n \n-    // This list is in alphabetical order.\n-    //\n     // If you add a new option, please update:\n     // - compiler/rustc_interface/src/tests.rs\n }"}, {"sha": "9fe7da3f29ec132d04b338b67c208dff5a31eaec", "filename": "compiler/rustc_target/src/abi/call/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs?ref=c0983a9aac889d16722a12602ac678051e62c3fb", "patch": "@@ -740,7 +740,8 @@ impl<'a, Ty> FnAbi<'a, Ty> {\n mod size_asserts {\n     use super::*;\n     use rustc_data_structures::static_assert_size;\n-    // These are in alphabetical order, which is easy to maintain.\n+    // tidy-alphabetical-start\n     static_assert_size!(ArgAbi<'_, usize>, 56);\n     static_assert_size!(FnAbi<'_, usize>, 80);\n+    // tidy-alphabetical-end\n }"}, {"sha": "196d70614e7c93fdffa66a9040011d11e713509f", "filename": "compiler/rustc_ty_utils/src/ty.rs", "status": "modified", "additions": 1, "deletions": 68, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0983a9aac889d16722a12602ac678051e62c3fb/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs?ref=c0983a9aac889d16722a12602ac678051e62c3fb", "patch": "@@ -137,77 +137,10 @@ fn param_env(tcx: TyCtxt<'_>, def_id: DefId) -> ty::ParamEnv<'_> {\n     let local_did = def_id.as_local();\n     let hir_id = local_did.map(|def_id| tcx.hir().local_def_id_to_hir_id(def_id));\n \n-    let constness = match hir_id {\n-        Some(hir_id) => match tcx.hir().get(hir_id) {\n-            hir::Node::TraitItem(hir::TraitItem { kind: hir::TraitItemKind::Fn(..), .. })\n-                if tcx.is_const_default_method(def_id) =>\n-            {\n-                hir::Constness::Const\n-            }\n-\n-            hir::Node::Item(hir::Item { kind: hir::ItemKind::Const(..), .. })\n-            | hir::Node::Item(hir::Item { kind: hir::ItemKind::Static(..), .. })\n-            | hir::Node::TraitItem(hir::TraitItem {\n-                kind: hir::TraitItemKind::Const(..), ..\n-            })\n-            | hir::Node::AnonConst(_)\n-            | hir::Node::ImplItem(hir::ImplItem { kind: hir::ImplItemKind::Const(..), .. })\n-            | hir::Node::ImplItem(hir::ImplItem {\n-                kind:\n-                    hir::ImplItemKind::Fn(\n-                        hir::FnSig {\n-                            header: hir::FnHeader { constness: hir::Constness::Const, .. },\n-                            ..\n-                        },\n-                        ..,\n-                    ),\n-                ..\n-            }) => hir::Constness::Const,\n-\n-            hir::Node::ImplItem(hir::ImplItem {\n-                kind: hir::ImplItemKind::Type(..) | hir::ImplItemKind::Fn(..),\n-                ..\n-            }) => {\n-                let parent_hir_id = tcx.hir().get_parent_node(hir_id);\n-                match tcx.hir().get(parent_hir_id) {\n-                    hir::Node::Item(hir::Item {\n-                        kind: hir::ItemKind::Impl(hir::Impl { constness, .. }),\n-                        ..\n-                    }) => *constness,\n-                    _ => span_bug!(\n-                        tcx.def_span(parent_hir_id.owner),\n-                        \"impl item's parent node is not an impl\",\n-                    ),\n-                }\n-            }\n-\n-            hir::Node::Item(hir::Item {\n-                kind:\n-                    hir::ItemKind::Fn(hir::FnSig { header: hir::FnHeader { constness, .. }, .. }, ..),\n-                ..\n-            })\n-            | hir::Node::TraitItem(hir::TraitItem {\n-                kind:\n-                    hir::TraitItemKind::Fn(\n-                        hir::FnSig { header: hir::FnHeader { constness, .. }, .. },\n-                        ..,\n-                    ),\n-                ..\n-            })\n-            | hir::Node::Item(hir::Item {\n-                kind: hir::ItemKind::Impl(hir::Impl { constness, .. }),\n-                ..\n-            }) => *constness,\n-\n-            _ => hir::Constness::NotConst,\n-        },\n-        None => hir::Constness::NotConst,\n-    };\n-\n     let unnormalized_env = ty::ParamEnv::new(\n         tcx.intern_predicates(&predicates),\n         traits::Reveal::UserFacing,\n-        constness,\n+        tcx.constness(def_id),\n     );\n \n     let body_id ="}, {"sha": "c533348edd69f11a8f4225d633a05d7093fddbf3", "filename": "src/doc/embedded-book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fembedded-book?ref=c0983a9aac889d16722a12602ac678051e62c3fb", "patch": "@@ -1 +1 @@\n-Subproject commit 4ce51cb7441a6f02b5bf9b07b2eb755c21ab7954\n+Subproject commit c533348edd69f11a8f4225d633a05d7093fddbf3"}, {"sha": "9c73283775466d22208a0b28afcab44db4c0cc10", "filename": "src/doc/nomicon", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon?ref=c0983a9aac889d16722a12602ac678051e62c3fb", "patch": "@@ -1 +1 @@\n-Subproject commit f53bfa056929217870a5d2df1366d2e7ba35096d\n+Subproject commit 9c73283775466d22208a0b28afcab44db4c0cc10"}, {"sha": "f6ed74f582bddcec73f753eafaab3749c4f7df61", "filename": "src/doc/reference", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference?ref=c0983a9aac889d16722a12602ac678051e62c3fb", "patch": "@@ -1 +1 @@\n-Subproject commit a7cdac33ca7356ad49d5c2b5e2c5010889b33eee\n+Subproject commit f6ed74f582bddcec73f753eafaab3749c4f7df61"}, {"sha": "5e7b296d6c345addbd748f242aae28c42555c015", "filename": "src/doc/rust-by-example", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust-by-example?ref=c0983a9aac889d16722a12602ac678051e62c3fb", "patch": "@@ -1 +1 @@\n-Subproject commit 767a6bd9727a596d7cfdbaeee475e65b2670ea3a\n+Subproject commit 5e7b296d6c345addbd748f242aae28c42555c015"}, {"sha": "7518c3445dc02df0d196f5f84e568d633c5141fb", "filename": "src/doc/rustc-dev-guide", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc-dev-guide?ref=c0983a9aac889d16722a12602ac678051e62c3fb", "patch": "@@ -1 +1 @@\n-Subproject commit 9a86c0467bbe42056f73fdf5b03fff757d7c4a9b\n+Subproject commit 7518c3445dc02df0d196f5f84e568d633c5141fb"}, {"sha": "894c7328b5f89405db54bc6ab65d1c18b2c5ab55", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c0983a9aac889d16722a12602ac678051e62c3fb/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/c0983a9aac889d16722a12602ac678051e62c3fb/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=c0983a9aac889d16722a12602ac678051e62c3fb", "patch": "@@ -563,8 +563,6 @@ h2.location a {\n .rustdoc .example-wrap {\n \tdisplay: flex;\n \tposition: relative;\n-}\n-.rustdoc .example-wrap {\n \tmargin-bottom: 10px;\n }\n /* For the last child of a div, the margin will be taken care of\n@@ -718,7 +716,6 @@ nav.sub {\n .source nav.sub {\n \tmargin-left: 32px;\n }\n-nav.sum { text-align: right; }\n nav.sub form { display: inline; }\n \n a {"}, {"sha": "2e651b5387419fa2441abbda60e515a66b00e4c1", "filename": "src/librustdoc/passes/check_code_block_syntax.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c0983a9aac889d16722a12602ac678051e62c3fb/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0983a9aac889d16722a12602ac678051e62c3fb/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs?ref=c0983a9aac889d16722a12602ac678051e62c3fb", "patch": "@@ -1,8 +1,9 @@\n //! Validates syntax inside Rust code blocks (\\`\\`\\`rust).\n use rustc_data_structures::sync::{Lock, Lrc};\n use rustc_errors::{\n-    emitter::Emitter, translation::Translate, Applicability, Diagnostic, Handler,\n-    LazyFallbackBundle,\n+    emitter::Emitter,\n+    translation::{to_fluent_args, Translate},\n+    Applicability, Diagnostic, Handler, LazyFallbackBundle,\n };\n use rustc_parse::parse_stream_from_source_str;\n use rustc_session::parse::ParseSess;\n@@ -193,7 +194,7 @@ impl Emitter for BufferEmitter {\n     fn emit_diagnostic(&mut self, diag: &Diagnostic) {\n         let mut buffer = self.buffer.borrow_mut();\n \n-        let fluent_args = self.to_fluent_args(diag.args());\n+        let fluent_args = to_fluent_args(diag.args());\n         let translated_main_message = self.translate_message(&diag.message[0].0, &fluent_args);\n \n         buffer.messages.push(format!(\"error from rustc: {}\", translated_main_message));"}, {"sha": "dbf3a8f00ee6d0e7a307f5fe00543e73cb823c70", "filename": "src/test/rustdoc-ui/z-help.stdout", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/c0983a9aac889d16722a12602ac678051e62c3fb/src%2Ftest%2Frustdoc-ui%2Fz-help.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/c0983a9aac889d16722a12602ac678051e62c3fb/src%2Ftest%2Frustdoc-ui%2Fz-help.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fz-help.stdout?ref=c0983a9aac889d16722a12602ac678051e62c3fb", "patch": "@@ -1,8 +1,8 @@\n     -Z                          allow-features=val -- only allow the listed language features to be enabled in code (space separated)\n     -Z                       always-encode-mir=val -- encode MIR of all functions into the crate metadata (default: no)\n-    -Z               assume-incomplete-release=val -- make cfg(version) treat the current version as incomplete (default: no)\n     -Z                            asm-comments=val -- generate comments into the assembly (may change behavior) (default: no)\n     -Z                       assert-incr-state=val -- assert that the incremental cache is in given state: either `loaded` or `not-loaded`.\n+    -Z               assume-incomplete-release=val -- make cfg(version) treat the current version as incomplete (default: no)\n     -Z                      binary-dep-depinfo=val -- include artifacts (sysroot, crate dependencies) used during compilation in dep-info (default: no)\n     -Z                             box-noalias=val -- emit noalias metadata for box (default: yes)\n     -Z                       branch-protection=val -- set options for branch target identification and pointer authentication on AArch64\n@@ -17,6 +17,7 @@\n     -Z                 deduplicate-diagnostics=val -- deduplicate identical diagnostics (default: yes)\n     -Z                  dep-info-omit-d-target=val -- in dep-info output, omit targets for tracking dependencies of the dep-info files themselves (default: no)\n     -Z                               dep-tasks=val -- print tasks that execute and the color their dep node gets (requires debug build) (default: no)\n+    -Z                        diagnostic-width=val -- set the current output width for diagnostic truncation\n     -Z                                 dlltool=val -- import library generation tool (windows-gnu only)\n     -Z                 dont-buffer-diagnostics=val -- emit diagnostics rather than buffering (breaks NLL error downgrading, sorting) (default: no)\n     -Z                           drop-tracking=val -- enables drop tracking in generators (default: no)\n@@ -54,11 +55,11 @@\n     -Z                        incremental-info=val -- print high-level information about incremental reuse (or the lack thereof) (default: no)\n     -Z              incremental-relative-spans=val -- hash spans relative to their parent item for incr. comp. (default: no)\n     -Z                  incremental-verify-ich=val -- verify incr. comp. hashes of green query instances (default: no)\n+    -Z                      inline-in-all-cgus=val -- control whether `#[inline]` functions are in all CGUs\n     -Z                             inline-llvm=val -- enable LLVM inlining (default: yes)\n     -Z                              inline-mir=val -- enable MIR inlining (default: no)\n-    -Z                    inline-mir-threshold=val -- a default MIR inlining threshold (default: 50)\n     -Z               inline-mir-hint-threshold=val -- inlining threshold for functions with inline hint (default: 100)\n-    -Z                      inline-in-all-cgus=val -- control whether `#[inline]` functions are in all CGUs\n+    -Z                    inline-mir-threshold=val -- a default MIR inlining threshold (default: 50)\n     -Z                             input-stats=val -- gather statistics about the input (default: no)\n     -Z                     instrument-coverage=val -- instrument the generated code to support LLVM source-based code coverage reports (note, the compiler build config must include `profiler = true`); implies `-C symbol-mangling-version=v0`. Optional values are:\n         `=all` (implicit value)\n@@ -67,6 +68,7 @@\n         `=off` (default)\n     -Z                       instrument-mcount=val -- insert function instrument code for mcount-based tracing (default: no)\n     -Z                       keep-hygiene-data=val -- keep hygiene data after analysis (default: no)\n+    -Z                             layout-seed=val -- seed layout randomization\n     -Z                   link-native-libraries=val -- link native libraries in the linker invocation (default: yes)\n     -Z                               link-only=val -- link the `.rlink` file generated by `-Z no-link` (default: no)\n     -Z                            llvm-plugins=val -- a list LLVM plugins to enable (space separated)\n@@ -78,8 +80,8 @@\n     -Z                              meta-stats=val -- gather metadata statistics (default: no)\n     -Z                          mir-emit-retag=val -- emit Retagging MIR statements, interpreted e.g., by miri; implies -Zmir-opt-level=0 (default: no)\n     -Z                       mir-enable-passes=val -- use like `-Zmir-enable-passes=+DestProp,-InstCombine`. Forces the specified passes to be enabled, overriding all other checks. Passes that are not specified are enabled or disabled by other flags as usual.\n-    -Z        mir-pretty-relative-line-numbers=val -- use line numbers relative to the function in mir pretty printing\n     -Z                           mir-opt-level=val -- MIR optimization level (0-4; default: 1 in non optimized builds and 2 in optimized builds)\n+    -Z        mir-pretty-relative-line-numbers=val -- use line numbers relative to the function in mir pretty printing\n     -Z                         move-size-limit=val -- the size at which the `large_assignments` lint starts to be emitted\n     -Z                         mutable-noalias=val -- emit noalias metadata for mutable references (default: yes)\n     -Z                               nll-facts=val -- dump facts from NLL analysis into side files (default: no)\n@@ -91,12 +93,11 @@\n     -Z                           no-leak-check=val -- disable the 'leak check' for subtyping; unsound, but useful for tests\n     -Z                                 no-link=val -- compile without linking\n     -Z                        no-parallel-llvm=val -- run LLVM in non-parallel mode (while keeping codegen-units and ThinLTO)\n-    -Z                 no-unique-section-names=val -- do not use unique names for text and data sections when -Z function-sections is used\n     -Z                     no-profiler-runtime=val -- prevent automatic injection of the profiler_builtins crate\n+    -Z                 no-unique-section-names=val -- do not use unique names for text and data sections when -Z function-sections is used\n     -Z                          normalize-docs=val -- normalize associated items in rustdoc when generating documentation\n     -Z                                     oom=val -- panic strategy for out-of-memory handling\n     -Z                  osx-rpath-install-name=val -- pass `-install_name @rpath/...` to the macOS linker (default: no)\n-    -Z                        diagnostic-width=val -- set the current output width for diagnostic truncation\n     -Z                     packed-bundled-libs=val -- change rlib format to store native libraries as archives\n     -Z                       panic-abort-tests=val -- support compiling tests with panic=abort (default: no)\n     -Z                           panic-in-drop=val -- panic strategy for panics in drops\n@@ -120,64 +121,63 @@\n     -Z                                 profile=val -- insert profiling code (default: no)\n     -Z                        profile-closures=val -- profile size of closures\n     -Z                            profile-emit=val -- file path to emit profiling data at runtime when using 'profile' (default based on relative source path)\n-    -Z                        profiler-runtime=val -- name of the profiler runtime crate to automatically inject (default: `profiler_builtins`)\n     -Z                      profile-sample-use=val -- use the given `.prof` file for sampled profile-guided optimization (also known as AutoFDO)\n+    -Z                        profiler-runtime=val -- name of the profiler runtime crate to automatically inject (default: `profiler_builtins`)\n     -Z                         query-dep-graph=val -- enable queries of the dependency graph for regression testing (default: no)\n     -Z                        randomize-layout=val -- randomize the layout of types (default: no)\n-    -Z                             layout-seed=val -- seed layout randomization\n     -Z                   relax-elf-relocations=val -- whether ELF relocations can be relaxed\n     -Z                             relro-level=val -- choose which RELRO level to use\n     -Z                        remap-cwd-prefix=val -- remap paths under the current working directory to this path prefix\n-    -Z         simulate-remapped-rust-src-base=val -- simulate the effect of remap-debuginfo = true at bootstrapping by remapping path to rust's source base directory. only meant for testing purposes\n     -Z                     report-delayed-bugs=val -- immediately print bugs registered with `delay_span_bug` (default: no)\n     -Z                               sanitizer=val -- use a sanitizer\n     -Z          sanitizer-memory-track-origins=val -- enable origins tracking in MemorySanitizer\n     -Z                       sanitizer-recover=val -- enable recovery for selected sanitizers\n     -Z                  saturating-float-casts=val -- make float->int casts UB-free: numbers outside the integer type's range are clipped to the max/min integer respectively, and NaN is mapped to 0 (default: yes)\n     -Z                           save-analysis=val -- write syntax and type analysis (in JSON format) information, in addition to normal output (default: no)\n     -Z                            self-profile=val -- run the self profiler and output the raw event data\n-    -Z                     self-profile-events=val -- specify the events recorded by the self profiler;\n-        for example: `-Z self-profile-events=default,query-keys`\n-        all options: none, all, default, generic-activity, query-provider, query-cache-hit\n-                     query-blocked, incr-cache-load, incr-result-hashing, query-keys, function-args, args, llvm, artifact-sizes\n     -Z                    self-profile-counter=val -- counter used by the self profiler (default: `wall-time`), one of:\n         `wall-time` (monotonic clock, i.e. `std::time::Instant`)\n         `instructions:u` (retired instructions, userspace-only)\n         `instructions-minus-irqs:u` (subtracting hardware interrupt counts for extra accuracy)\n+    -Z                     self-profile-events=val -- specify the events recorded by the self profiler;\n+        for example: `-Z self-profile-events=default,query-keys`\n+        all options: none, all, default, generic-activity, query-provider, query-cache-hit\n+                     query-blocked, incr-cache-load, incr-result-hashing, query-keys, function-args, args, llvm, artifact-sizes\n     -Z                          share-generics=val -- make the current crate share its generic instantiations\n     -Z                               show-span=val -- show spans for compiler debugging (expr|pat|ty)\n+    -Z         simulate-remapped-rust-src-base=val -- simulate the effect of remap-debuginfo = true at bootstrapping by remapping path to rust's source base directory. only meant for testing purposes\n     -Z                              span-debug=val -- forward proc_macro::Span's `Debug` impl to `Span`\n     -Z                       span-free-formats=val -- exclude spans when debug-printing compiler state (default: no)\n-    -Z                      src-hash-algorithm=val -- hash algorithm of source files in debug info (`md5`, `sha1`, or `sha256`)\n-    -Z                         stack-protector=val -- control stack smash protection strategy (`rustc --print stack-protector-strategies` for details)\n-    -Z                      strict-init-checks=val -- control if mem::uninitialized and mem::zeroed panic on more UB\n-    -Z                                   strip=val -- tell the linker which information to strip (`none` (default), `debuginfo` or `symbols`)\n+    -Z                    split-dwarf-inlining=val -- provide minimal debug info in the object/executable to facilitate online symbolication/stack traces in the absence of .dwo/.dwp files when using Split DWARF\n     -Z                        split-dwarf-kind=val -- split dwarf variant (only if -Csplit-debuginfo is enabled and on relevant platform)\n         (default: `split`)\n \n         `split`: sections which do not require relocation are written into a DWARF object (`.dwo`)\n                  file which is ignored by the linker\n         `single`: sections which do not require relocation are written into object file but ignored\n                   by the linker\n-    -Z                    split-dwarf-inlining=val -- provide minimal debug info in the object/executable to facilitate online symbolication/stack traces in the absence of .dwo/.dwp files when using Split DWARF\n+    -Z                      src-hash-algorithm=val -- hash algorithm of source files in debug info (`md5`, `sha1`, or `sha256`)\n+    -Z                         stack-protector=val -- control stack smash protection strategy (`rustc --print stack-protector-strategies` for details)\n+    -Z                      strict-init-checks=val -- control if mem::uninitialized and mem::zeroed panic on more UB\n+    -Z                                   strip=val -- tell the linker which information to strip (`none` (default), `debuginfo` or `symbols`)\n     -Z                 symbol-mangling-version=val -- which mangling version to use for symbol names ('legacy' (default) or 'v0')\n     -Z                                   teach=val -- show extended diagnostic help (default: no)\n     -Z                               temps-dir=val -- the directory the intermediate files are written to\n-    -Z                          translate-lang=val -- language identifier for diagnostic output\n-    -Z                translate-additional-ftl=val -- additional fluent translation to preferentially use (for testing translation)\n-    -Z        translate-directionality-markers=val -- emit directionality isolation markers in translated diagnostics\n-    -Z                                tune-cpu=val -- select processor to schedule for (`rustc --print target-cpus` for details)\n     -Z                                 thinlto=val -- enable ThinLTO when possible\n     -Z                           thir-unsafeck=val -- use the THIR unsafety checker (default: no)\n     -Z                                 threads=val -- use a thread pool with N threads\n     -Z                        time-llvm-passes=val -- measure time of each LLVM pass (default: no)\n     -Z                             time-passes=val -- measure time of each rustc pass (default: no)\n     -Z                               tls-model=val -- choose the TLS model to use (`rustc --print tls-models` for details)\n     -Z                            trace-macros=val -- for every macro invocation, print its name and arguments (default: no)\n+    -Z                translate-additional-ftl=val -- additional fluent translation to preferentially use (for testing translation)\n+    -Z        translate-directionality-markers=val -- emit directionality isolation markers in translated diagnostics\n+    -Z                          translate-lang=val -- language identifier for diagnostic output\n     -Z   translate-remapped-path-to-local-path=val -- translate remapped paths into local paths when possible (default: yes)\n     -Z                        trap-unreachable=val -- generate trap instructions for unreachable intrinsics (default: use target setting, usually yes)\n     -Z                        treat-err-as-bug=val -- treat error number `val` that occurs as bug\n     -Z                   trim-diagnostic-paths=val -- in diagnostics, use heuristics to shorten paths referring to items\n+    -Z                                tune-cpu=val -- select processor to schedule for (`rustc --print target-cpus` for details)\n     -Z                              ui-testing=val -- emit compiler diagnostics in a form suitable for UI testing (default: no)\n     -Z            uninit-const-chunk-threshold=val -- allow generating const initializers with mixed init/uninit chunks, and set the maximum number of chunks for which this is allowed (default: 16)\n     -Z          unleash-the-miri-inside-of-you=val -- take the brakes off const evaluation. NOTE: this is unsound (default: no)"}, {"sha": "462f5e78498495503b9ca17e6e4ff3bd773e15ed", "filename": "src/test/ui-fulldeps/internal-lints/diagnostics.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c0983a9aac889d16722a12602ac678051e62c3fb/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0983a9aac889d16722a12602ac678051e62c3fb/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fdiagnostics.rs?ref=c0983a9aac889d16722a12602ac678051e62c3fb", "patch": "@@ -13,7 +13,7 @@ extern crate rustc_span;\n \n use rustc_errors::{\n     AddToDiagnostic, IntoDiagnostic, Diagnostic, DiagnosticBuilder,\n-    ErrorGuaranteed, Handler, fluent\n+    ErrorGuaranteed, Handler, fluent, SubdiagnosticMessage,\n };\n use rustc_macros::{Diagnostic, Subdiagnostic};\n use rustc_span::Span;\n@@ -52,7 +52,10 @@ impl<'a> IntoDiagnostic<'a, ErrorGuaranteed> for TranslatableInIntoDiagnostic {\n pub struct UntranslatableInAddToDiagnostic;\n \n impl AddToDiagnostic for UntranslatableInAddToDiagnostic {\n-    fn add_to_diagnostic(self, diag: &mut Diagnostic) {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, _: F)\n+    where\n+        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n+    {\n         diag.note(\"untranslatable diagnostic\");\n         //~^ ERROR diagnostics should be created using translatable messages\n     }\n@@ -61,7 +64,10 @@ impl AddToDiagnostic for UntranslatableInAddToDiagnostic {\n pub struct TranslatableInAddToDiagnostic;\n \n impl AddToDiagnostic for TranslatableInAddToDiagnostic {\n-    fn add_to_diagnostic(self, diag: &mut Diagnostic) {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, _: F)\n+    where\n+        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n+    {\n         diag.note(fluent::compiletest::note);\n     }\n }"}, {"sha": "ac820a79db274b8888880b5ddad43cdd79ba8090", "filename": "src/test/ui-fulldeps/internal-lints/diagnostics.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c0983a9aac889d16722a12602ac678051e62c3fb/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fdiagnostics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0983a9aac889d16722a12602ac678051e62c3fb/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fdiagnostics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fdiagnostics.stderr?ref=c0983a9aac889d16722a12602ac678051e62c3fb", "patch": "@@ -11,13 +11,13 @@ LL | #![deny(rustc::untranslatable_diagnostic)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: diagnostics should be created using translatable messages\n-  --> $DIR/diagnostics.rs:56:14\n+  --> $DIR/diagnostics.rs:59:14\n    |\n LL |         diag.note(\"untranslatable diagnostic\");\n    |              ^^^^\n \n error: diagnostics should only be created in `IntoDiagnostic`/`AddToDiagnostic` impls\n-  --> $DIR/diagnostics.rs:70:25\n+  --> $DIR/diagnostics.rs:76:25\n    |\n LL |     let _diag = handler.struct_err(fluent::compiletest::example);\n    |                         ^^^^^^^^^^\n@@ -29,13 +29,13 @@ LL | #![deny(rustc::diagnostic_outside_of_impl)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: diagnostics should only be created in `IntoDiagnostic`/`AddToDiagnostic` impls\n-  --> $DIR/diagnostics.rs:73:25\n+  --> $DIR/diagnostics.rs:79:25\n    |\n LL |     let _diag = handler.struct_err(\"untranslatable diagnostic\");\n    |                         ^^^^^^^^^^\n \n error: diagnostics should be created using translatable messages\n-  --> $DIR/diagnostics.rs:73:25\n+  --> $DIR/diagnostics.rs:79:25\n    |\n LL |     let _diag = handler.struct_err(\"untranslatable diagnostic\");\n    |                         ^^^^^^^^^^"}, {"sha": "e873c36e0b39a14f3adbdd86f9b189df92fd2519", "filename": "src/test/ui-fulldeps/session-diagnostic/diagnostic-derive.rs", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/c0983a9aac889d16722a12602ac678051e62c3fb/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0983a9aac889d16722a12602ac678051e62c3fb/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs?ref=c0983a9aac889d16722a12602ac678051e62c3fb", "patch": "@@ -678,3 +678,74 @@ enum ExampleEnum {\n struct RawIdentDiagnosticArg {\n     pub r#type: String,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(compiletest::example)]\n+struct SubdiagnosticBad {\n+    #[subdiagnostic(bad)]\n+//~^ ERROR `#[subdiagnostic(bad)]` is not a valid attribute\n+    note: Note,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(compiletest::example)]\n+struct SubdiagnosticBadStr {\n+    #[subdiagnostic = \"bad\"]\n+//~^ ERROR `#[subdiagnostic = ...]` is not a valid attribute\n+    note: Note,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(compiletest::example)]\n+struct SubdiagnosticBadTwice {\n+    #[subdiagnostic(bad, bad)]\n+//~^ ERROR `#[subdiagnostic(...)]` is not a valid attribute\n+    note: Note,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(compiletest::example)]\n+struct SubdiagnosticBadLitStr {\n+    #[subdiagnostic(\"bad\")]\n+//~^ ERROR `#[subdiagnostic(\"...\")]` is not a valid attribute\n+    note: Note,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(compiletest::example)]\n+struct SubdiagnosticEagerLint {\n+    #[subdiagnostic(eager)]\n+//~^ ERROR `#[subdiagnostic(...)]` is not a valid attribute\n+    note: Note,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(compiletest::example)]\n+struct SubdiagnosticEagerCorrect {\n+    #[subdiagnostic(eager)]\n+    note: Note,\n+}\n+\n+// Check that formatting of `correct` in suggestion doesn't move the binding for that field, making\n+// the `set_arg` call a compile error; and that isn't worked around by moving the `set_arg` call\n+// after the `span_suggestion` call - which breaks eager translation.\n+\n+#[derive(Subdiagnostic)]\n+#[suggestion_short(\n+    parser::use_instead,\n+    applicability = \"machine-applicable\",\n+    code = \"{correct}\"\n+)]\n+pub(crate) struct SubdiagnosticWithSuggestion {\n+    #[primary_span]\n+    span: Span,\n+    invalid: String,\n+    correct: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(compiletest::example)]\n+struct SubdiagnosticEagerSuggestion {\n+    #[subdiagnostic(eager)]\n+    sub: SubdiagnosticWithSuggestion,\n+}"}, {"sha": "7a42d618707ad99cbd5ee22390378ca0a8bdc749", "filename": "src/test/ui-fulldeps/session-diagnostic/diagnostic-derive.stderr", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/c0983a9aac889d16722a12602ac678051e62c3fb/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0983a9aac889d16722a12602ac678051e62c3fb/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr?ref=c0983a9aac889d16722a12602ac678051e62c3fb", "patch": "@@ -533,6 +533,46 @@ LL | #[label]\n    |\n    = help: `#[label]` and `#[suggestion]` can only be applied to fields\n \n+error: `#[subdiagnostic(bad)]` is not a valid attribute\n+  --> $DIR/diagnostic-derive.rs:685:21\n+   |\n+LL |     #[subdiagnostic(bad)]\n+   |                     ^^^\n+   |\n+   = help: `eager` is the only supported nested attribute for `subdiagnostic`\n+\n+error: `#[subdiagnostic = ...]` is not a valid attribute\n+  --> $DIR/diagnostic-derive.rs:693:5\n+   |\n+LL |     #[subdiagnostic = \"bad\"]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: `eager` is the only supported nested attribute for `subdiagnostic`\n+\n+error: `#[subdiagnostic(...)]` is not a valid attribute\n+  --> $DIR/diagnostic-derive.rs:701:5\n+   |\n+LL |     #[subdiagnostic(bad, bad)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: `eager` is the only supported nested attribute for `subdiagnostic`\n+\n+error: `#[subdiagnostic(\"...\")]` is not a valid attribute\n+  --> $DIR/diagnostic-derive.rs:709:21\n+   |\n+LL |     #[subdiagnostic(\"bad\")]\n+   |                     ^^^^^\n+   |\n+   = help: `eager` is the only supported nested attribute for `subdiagnostic`\n+\n+error: `#[subdiagnostic(...)]` is not a valid attribute\n+  --> $DIR/diagnostic-derive.rs:717:5\n+   |\n+LL |     #[subdiagnostic(eager)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: eager subdiagnostics are not supported on lints\n+\n error: cannot find attribute `nonsense` in this scope\n   --> $DIR/diagnostic-derive.rs:55:3\n    |\n@@ -607,7 +647,7 @@ LL |         arg: impl IntoDiagnosticArg,\n    |                   ^^^^^^^^^^^^^^^^^ required by this bound in `DiagnosticBuilder::<'a, G>::set_arg`\n    = note: this error originates in the derive macro `Diagnostic` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: aborting due to 75 previous errors\n+error: aborting due to 80 previous errors\n \n Some errors have detailed explanations: E0277, E0425.\n For more information about an error, try `rustc --explain E0277`."}, {"sha": "fec2bc25617acca615a7793f4d6936776fb33b5b", "filename": "src/test/ui/parser/bad-let-as-field.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0983a9aac889d16722a12602ac678051e62c3fb/src%2Ftest%2Fui%2Fparser%2Fbad-let-as-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0983a9aac889d16722a12602ac678051e62c3fb/src%2Ftest%2Fui%2Fparser%2Fbad-let-as-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fbad-let-as-field.rs?ref=c0983a9aac889d16722a12602ac678051e62c3fb", "patch": "@@ -0,0 +1,6 @@\n+struct Foo {\n+    let: i32,\n+    //~^ ERROR expected identifier, found keyword\n+}\n+\n+fn main() {}"}, {"sha": "57def42b1ee30d408edd97381bf522a2effdc5ee", "filename": "src/test/ui/parser/bad-let-as-field.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c0983a9aac889d16722a12602ac678051e62c3fb/src%2Ftest%2Fui%2Fparser%2Fbad-let-as-field.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0983a9aac889d16722a12602ac678051e62c3fb/src%2Ftest%2Fui%2Fparser%2Fbad-let-as-field.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fbad-let-as-field.stderr?ref=c0983a9aac889d16722a12602ac678051e62c3fb", "patch": "@@ -0,0 +1,15 @@\n+error: expected identifier, found keyword `let`\n+  --> $DIR/bad-let-as-field.rs:2:5\n+   |\n+LL | struct Foo {\n+   |        --- while parsing this struct\n+LL |     let: i32,\n+   |     ^^^ expected identifier, found keyword\n+   |\n+help: escape `let` to use it as an identifier\n+   |\n+LL |     r#let: i32,\n+   |     ++\n+\n+error: aborting due to previous error\n+"}, {"sha": "7ff91b476aeb59b5c428a327bc1a49dd2e98c4ca", "filename": "src/test/ui/parser/removed-syntax-field-let-2.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c0983a9aac889d16722a12602ac678051e62c3fb/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-field-let-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0983a9aac889d16722a12602ac678051e62c3fb/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-field-let-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-field-let-2.rs?ref=c0983a9aac889d16722a12602ac678051e62c3fb", "patch": "@@ -0,0 +1,12 @@\n+struct Foo {\n+    let x: i32,\n+    //~^ ERROR expected identifier, found keyword\n+    let y: i32,\n+    //~^ ERROR expected identifier, found keyword\n+}\n+\n+fn main() {\n+    let _ = Foo {\n+        //~^ ERROR missing fields `x` and `y` in initializer of `Foo`\n+    };\n+}"}, {"sha": "fda0919b9b647cae3289362c6b370679830bfb8f", "filename": "src/test/ui/parser/removed-syntax-field-let-2.stderr", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/c0983a9aac889d16722a12602ac678051e62c3fb/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-field-let-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0983a9aac889d16722a12602ac678051e62c3fb/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-field-let-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-field-let-2.stderr?ref=c0983a9aac889d16722a12602ac678051e62c3fb", "patch": "@@ -0,0 +1,33 @@\n+error: expected identifier, found keyword `let`\n+  --> $DIR/removed-syntax-field-let-2.rs:2:5\n+   |\n+LL |     let x: i32,\n+   |     ^^^-\n+   |     |\n+   |     expected identifier, found keyword\n+   |     help: remove this `let` keyword\n+   |\n+   = note: the `let` keyword is not allowed in `struct` fields\n+   = note: see <https://doc.rust-lang.org/book/ch05-01-defining-structs.html> for more information\n+\n+error: expected identifier, found keyword `let`\n+  --> $DIR/removed-syntax-field-let-2.rs:4:5\n+   |\n+LL |     let y: i32,\n+   |     ^^^-\n+   |     |\n+   |     expected identifier, found keyword\n+   |     help: remove this `let` keyword\n+   |\n+   = note: the `let` keyword is not allowed in `struct` fields\n+   = note: see <https://doc.rust-lang.org/book/ch05-01-defining-structs.html> for more information\n+\n+error[E0063]: missing fields `x` and `y` in initializer of `Foo`\n+  --> $DIR/removed-syntax-field-let-2.rs:9:13\n+   |\n+LL |     let _ = Foo {\n+   |             ^^^ missing `x` and `y`\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0063`."}, {"sha": "9bc18dabd6ead99511954f1543385db52f54e1bb", "filename": "src/test/ui/parser/removed-syntax-field-let.stderr", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c0983a9aac889d16722a12602ac678051e62c3fb/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-field-let.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0983a9aac889d16722a12602ac678051e62c3fb/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-field-let.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-field-let.stderr?ref=c0983a9aac889d16722a12602ac678051e62c3fb", "patch": "@@ -2,15 +2,13 @@ error: expected identifier, found keyword `let`\n   --> $DIR/removed-syntax-field-let.rs:2:5\n    |\n LL |     let foo: (),\n-   |     ^^^ expected identifier, found keyword\n+   |     ^^^-\n+   |     |\n+   |     expected identifier, found keyword\n+   |     help: remove this `let` keyword\n    |\n    = note: the `let` keyword is not allowed in `struct` fields\n    = note: see <https://doc.rust-lang.org/book/ch05-01-defining-structs.html> for more information\n-help: remove the let, the `let` keyword is not allowed in struct field definitions\n-   |\n-LL -     let foo: (),\n-LL +     foo: (),\n-   |\n \n error: aborting due to previous error\n "}, {"sha": "c9f1dfb707f3f1efa514afea89e1a0c2f2b91e3f", "filename": "src/tools/tidy/src/alphabetical.rs", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/c0983a9aac889d16722a12602ac678051e62c3fb/src%2Ftools%2Ftidy%2Fsrc%2Falphabetical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0983a9aac889d16722a12602ac678051e62c3fb/src%2Ftools%2Ftidy%2Fsrc%2Falphabetical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Falphabetical.rs?ref=c0983a9aac889d16722a12602ac678051e62c3fb", "patch": "@@ -0,0 +1,113 @@\n+//! Checks that a list of items is in alphabetical order\n+//!\n+//! To use, use the following annotation in the code:\n+//! ```rust\n+//! // tidy-alphabetical-start\n+//! fn aaa() {}\n+//! fn eee() {}\n+//! fn z() {}\n+//! // tidy-alphabetical-end\n+//! ```\n+//!\n+//! The following lines are ignored:\n+//! - Lines that are indented with more or less spaces than the first line\n+//! - Lines starting with `//`, `#[`, `)`, `]`, `}` if the comment has the same indentation as\n+//!   the first line\n+//!\n+//! If a line ends with an opening bracket, the line is ignored and the next line will have\n+//! its extra indentation ignored.\n+\n+use std::{fmt::Display, path::Path};\n+\n+use crate::walk::{filter_dirs, walk};\n+\n+fn indentation(line: &str) -> usize {\n+    line.find(|c| c != ' ').unwrap_or(0)\n+}\n+\n+fn is_close_bracket(c: char) -> bool {\n+    matches!(c, ')' | ']' | '}')\n+}\n+\n+const START_COMMENT: &str = \"// tidy-alphabetical-start\";\n+const END_COMMENT: &str = \"// tidy-alphabetical-end\";\n+\n+fn check_section<'a>(\n+    file: impl Display,\n+    lines: impl Iterator<Item = (usize, &'a str)>,\n+    bad: &mut bool,\n+) {\n+    let content_lines = lines.take_while(|(_, line)| !line.contains(END_COMMENT));\n+\n+    let mut prev_line = String::new();\n+    let mut first_indent = None;\n+    let mut in_split_line = None;\n+\n+    for (line_idx, line) in content_lines {\n+        if line.contains(START_COMMENT) {\n+            tidy_error!(\n+                bad,\n+                \"{file}:{} found `// tidy-alphabetical-start` expecting `// tidy-alphabetical-end`\",\n+                line_idx\n+            )\n+        }\n+\n+        let indent = first_indent.unwrap_or_else(|| {\n+            let indent = indentation(line);\n+            first_indent = Some(indent);\n+            indent\n+        });\n+\n+        let line = if let Some(prev_split_line) = in_split_line {\n+            in_split_line = None;\n+            format!(\"{prev_split_line}{}\", line.trim_start())\n+        } else {\n+            line.to_string()\n+        };\n+\n+        if indentation(&line) != indent {\n+            continue;\n+        }\n+\n+        let trimmed_line = line.trim_start_matches(' ');\n+\n+        if trimmed_line.starts_with(\"//\")\n+            || trimmed_line.starts_with(\"#[\")\n+            || trimmed_line.starts_with(is_close_bracket)\n+        {\n+            continue;\n+        }\n+\n+        if line.trim_end().ends_with('(') {\n+            in_split_line = Some(line);\n+            continue;\n+        }\n+\n+        let prev_line_trimmed_lowercase = prev_line.trim_start_matches(' ').to_lowercase();\n+\n+        if trimmed_line.to_lowercase() < prev_line_trimmed_lowercase {\n+            tidy_error!(bad, \"{file}:{}: line not in alphabetical order\", line_idx + 1,);\n+        }\n+\n+        prev_line = line;\n+    }\n+}\n+\n+pub fn check(path: &Path, bad: &mut bool) {\n+    walk(path, &mut filter_dirs, &mut |entry, contents| {\n+        let file = &entry.path().display();\n+\n+        let mut lines = contents.lines().enumerate().peekable();\n+        while let Some((_, line)) = lines.next() {\n+            if line.contains(START_COMMENT) {\n+                check_section(file, &mut lines, bad);\n+                if lines.peek().is_none() {\n+                    tidy_error!(\n+                        bad,\n+                        \"{file}: reached end of file expecting `// tidy-alphabetical-end`\"\n+                    )\n+                }\n+            }\n+        }\n+    });\n+}"}, {"sha": "fc0bce585723329bbeb827803412fbbcbbb4e4b9", "filename": "src/tools/tidy/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c0983a9aac889d16722a12602ac678051e62c3fb/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0983a9aac889d16722a12602ac678051e62c3fb/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs?ref=c0983a9aac889d16722a12602ac678051e62c3fb", "patch": "@@ -38,6 +38,7 @@ macro_rules! tidy_error {\n     });\n }\n \n+pub mod alphabetical;\n pub mod bins;\n pub mod debug_artifacts;\n pub mod deps;"}, {"sha": "8fe361c45a263fc8856f4b862be7dbb86083a7ca", "filename": "src/tools/tidy/src/main.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0983a9aac889d16722a12602ac678051e62c3fb/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0983a9aac889d16722a12602ac678051e62c3fb/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs?ref=c0983a9aac889d16722a12602ac678051e62c3fb", "patch": "@@ -90,6 +90,8 @@ fn main() {\n         check!(edition, &compiler_path);\n         check!(edition, &library_path);\n \n+        check!(alphabetical, &compiler_path);\n+\n         let collected = {\n             while handles.len() >= concurrency.get() {\n                 handles.pop_front().unwrap().join().unwrap();"}]}