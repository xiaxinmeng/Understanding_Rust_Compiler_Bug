{"sha": "baf98e7515c4736821f99a263e777fd4a7f18cbf", "node_id": "C_kwDOAAsO6NoAKGJhZjk4ZTc1MTVjNDczNjgyMWY5OWEyNjNlNzc3ZmQ0YTdmMThjYmY", "commit": {"author": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2023-04-20T06:14:28Z"}, "committer": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2023-04-20T06:17:35Z"}, "message": "Add transmute optimization tests and some extra comments", "tree": {"sha": "e75271466b2c22ac9f8c279bafe1c01e33584ecd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e75271466b2c22ac9f8c279bafe1c01e33584ecd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/baf98e7515c4736821f99a263e777fd4a7f18cbf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/baf98e7515c4736821f99a263e777fd4a7f18cbf", "html_url": "https://github.com/rust-lang/rust/commit/baf98e7515c4736821f99a263e777fd4a7f18cbf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/baf98e7515c4736821f99a263e777fd4a7f18cbf/comments", "author": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1bcb0ec28cd169e1e80efffc824287287d374147", "url": "https://api.github.com/repos/rust-lang/rust/commits/1bcb0ec28cd169e1e80efffc824287287d374147", "html_url": "https://github.com/rust-lang/rust/commit/1bcb0ec28cd169e1e80efffc824287287d374147"}], "stats": {"total": 118, "additions": 118, "deletions": 0}, "files": [{"sha": "bd11d47500a55474168b33162cb90a5374ebd8c9", "filename": "compiler/rustc_codegen_ssa/src/mir/rvalue.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/baf98e7515c4736821f99a263e777fd4a7f18cbf/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baf98e7515c4736821f99a263e777fd4a7f18cbf/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs?ref=baf98e7515c4736821f99a263e777fd4a7f18cbf", "patch": "@@ -290,7 +290,13 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         use abi::Primitive::*;\n         imm = bx.from_immediate(imm);\n+\n+        // When scalars are passed by value, there's no metadata recording their\n+        // valid ranges. For example, `char`s are passed as just `i32`, with no\n+        // way for LLVM to know that they're 0x10FFFF at most. Thus we assume\n+        // the range of the input value too, not just the output range.\n         self.assume_scalar_range(bx, imm, from_scalar, from_backend_ty);\n+\n         imm = match (from_scalar.primitive(), to_scalar.primitive()) {\n             (Int(..) | F32 | F64, Int(..) | F32 | F64) => bx.bitcast(imm, to_backend_ty),\n             (Pointer(..), Pointer(..)) => bx.pointercast(imm, to_backend_ty),\n@@ -318,6 +324,9 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         backend_ty: Bx::Type,\n     ) {\n         if matches!(self.cx.sess().opts.optimize, OptLevel::No | OptLevel::Less)\n+            // For now, the critical niches are all over `Int`eger values.\n+            // Should floating-point values or pointers ever get more complex\n+            // niches, then this code will probably want to handle them too.\n             || !matches!(scalar.primitive(), abi::Primitive::Int(..))\n             || scalar.is_always_valid(self.cx)\n         {"}, {"sha": "461dd550cd7e879c1cb7d49787bd12404710bab1", "filename": "tests/codegen/transmute-optimized.rs", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/baf98e7515c4736821f99a263e777fd4a7f18cbf/tests%2Fcodegen%2Ftransmute-optimized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baf98e7515c4736821f99a263e777fd4a7f18cbf/tests%2Fcodegen%2Ftransmute-optimized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Ftransmute-optimized.rs?ref=baf98e7515c4736821f99a263e777fd4a7f18cbf", "patch": "@@ -0,0 +1,109 @@\n+// compile-flags: -O -Z merge-functions=disabled\n+// min-llvm-version: 15.0 # this test uses `ptr`s\n+// ignore-debug\n+\n+#![crate_type = \"lib\"]\n+\n+// This tests that LLVM can optimize based on the niches in the source or\n+// destination types for transmutes.\n+\n+#[repr(u32)]\n+pub enum AlwaysZero32 { X = 0 }\n+\n+// CHECK-LABEL: i32 @issue_109958(i32\n+#[no_mangle]\n+pub fn issue_109958(x: AlwaysZero32) -> i32 {\n+    // CHECK: ret i32 0\n+    unsafe { std::mem::transmute(x) }\n+}\n+\n+// CHECK-LABEL: i1 @reference_is_null(ptr\n+#[no_mangle]\n+pub fn reference_is_null(x: &i32) -> bool {\n+    // CHECK: ret i1 false\n+    let p: *const i32 = unsafe { std::mem::transmute(x) };\n+    p.is_null()\n+}\n+\n+// CHECK-LABEL: i1 @non_null_is_null(ptr\n+#[no_mangle]\n+pub fn non_null_is_null(x: std::ptr::NonNull<i32>) -> bool {\n+    // CHECK: ret i1 false\n+    let p: *const i32 = unsafe { std::mem::transmute(x) };\n+    p.is_null()\n+}\n+\n+// CHECK-LABEL: i1 @non_zero_is_null(\n+#[no_mangle]\n+pub fn non_zero_is_null(x: std::num::NonZeroUsize) -> bool {\n+    // CHECK: ret i1 false\n+    let p: *const i32 = unsafe { std::mem::transmute(x) };\n+    p.is_null()\n+}\n+\n+// CHECK-LABEL: i1 @non_null_is_zero(ptr\n+#[no_mangle]\n+pub fn non_null_is_zero(x: std::ptr::NonNull<i32>) -> bool {\n+    // CHECK: ret i1 false\n+    let a: isize = unsafe { std::mem::transmute(x) };\n+    a == 0\n+}\n+\n+// CHECK-LABEL: i1 @bool_ordering_is_ge(i1\n+#[no_mangle]\n+pub fn bool_ordering_is_ge(x: bool) -> bool {\n+    // CHECK: ret i1 true\n+    let y: std::cmp::Ordering = unsafe { std::mem::transmute(x) };\n+    y.is_ge()\n+}\n+\n+// CHECK-LABEL: i1 @ordering_is_ge_then_transmute_to_bool(i8\n+#[no_mangle]\n+pub fn ordering_is_ge_then_transmute_to_bool(x: std::cmp::Ordering) -> bool {\n+    let r = x.is_ge();\n+    let _: bool = unsafe { std::mem::transmute(x) };\n+    r\n+}\n+\n+// CHECK-LABEL: i32 @normal_div(i32\n+#[no_mangle]\n+pub fn normal_div(a: u32, b: u32) -> u32 {\n+    // CHECK: call core::panicking::panic\n+    a / b\n+}\n+\n+// CHECK-LABEL: i32 @div_transmute_nonzero(i32\n+#[no_mangle]\n+pub fn div_transmute_nonzero(a: u32, b: std::num::NonZeroI32) -> u32 {\n+    // CHECK-NOT: call core::panicking::panic\n+    // CHECK: %[[R:.+]] = udiv i32 %a, %b\n+    // CHECK-NEXT: ret i32 %[[R]]\n+    // CHECK-NOT: call core::panicking::panic\n+    let d: u32 = unsafe { std::mem::transmute(b) };\n+    a / d\n+}\n+\n+#[repr(i8)]\n+pub enum OneTwoThree { One = 1, Two = 2, Three = 3 }\n+\n+// CHECK-LABEL: i8 @ordering_transmute_onetwothree(i8\n+#[no_mangle]\n+pub unsafe fn ordering_transmute_onetwothree(x: std::cmp::Ordering) -> OneTwoThree {\n+    // CHECK: ret i8 1\n+    std::mem::transmute(x)\n+}\n+\n+// CHECK-LABEL: i8 @onetwothree_transmute_ordering(i8\n+#[no_mangle]\n+pub unsafe fn onetwothree_transmute_ordering(x: OneTwoThree) -> std::cmp::Ordering {\n+    // CHECK: ret i8 1\n+    std::mem::transmute(x)\n+}\n+\n+// CHECK-LABEL: i1 @char_is_negative(i32\n+#[no_mangle]\n+pub fn char_is_negative(c: char) -> bool {\n+    // CHECK: ret i1 false\n+    let x: i32 = unsafe { std::mem::transmute(c) };\n+    x < 0\n+}"}]}