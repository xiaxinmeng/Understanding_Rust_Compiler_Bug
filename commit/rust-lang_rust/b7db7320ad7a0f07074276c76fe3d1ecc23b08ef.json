{"sha": "b7db7320ad7a0f07074276c76fe3d1ecc23b08ef", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3ZGI3MzIwYWQ3YTBmMDcwNzQyNzZjNzZmZTNkMWVjYzIzYjA4ZWY=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-03-24T15:43:50Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-03-25T14:53:53Z"}, "message": "go back to infix ops for Size", "tree": {"sha": "7b7181f3da4930f9491789fe1a2b0799400f6604", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7b7181f3da4930f9491789fe1a2b0799400f6604"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b7db7320ad7a0f07074276c76fe3d1ecc23b08ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b7db7320ad7a0f07074276c76fe3d1ecc23b08ef", "html_url": "https://github.com/rust-lang/rust/commit/b7db7320ad7a0f07074276c76fe3d1ecc23b08ef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b7db7320ad7a0f07074276c76fe3d1ecc23b08ef/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d67ca00a1b2f667068e24d4f98676f3ec62de42", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d67ca00a1b2f667068e24d4f98676f3ec62de42", "html_url": "https://github.com/rust-lang/rust/commit/1d67ca00a1b2f667068e24d4f98676f3ec62de42"}], "stats": {"total": 63, "additions": 30, "deletions": 33}, "files": [{"sha": "4791c2fed9981de8cc17fd38ba2867a5f664dd83", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b7db7320ad7a0f07074276c76fe3d1ecc23b08ef/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7db7320ad7a0f07074276c76fe3d1ecc23b08ef/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=b7db7320ad7a0f07074276c76fe3d1ecc23b08ef", "patch": "@@ -3,7 +3,7 @@\n use std::borrow::Cow;\n use std::convert::TryFrom;\n use std::iter;\n-use std::ops::{Add, Deref, DerefMut, Mul, Range, Sub};\n+use std::ops::{Deref, DerefMut, Range};\n \n use rustc_ast::ast::Mutability;\n use rustc_data_structures::sorted_map::SortedMap;\n@@ -183,7 +183,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     /// Returns the range of this allocation that was meant.\n     #[inline]\n     fn check_bounds(&self, offset: Size, size: Size) -> Range<usize> {\n-        let end = Size::add(offset, size); // This does overflow checking.\n+        let end = offset + size; // This does overflow checking.\n         let end = usize::try_from(end.bytes()).expect(\"access too big for this host architecture\");\n         assert!(\n             end <= self.len(),\n@@ -293,7 +293,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         let offset = usize::try_from(ptr.offset.bytes()).unwrap();\n         Ok(match self.bytes[offset..].iter().position(|&c| c == 0) {\n             Some(size) => {\n-                let size_with_null = Size::add(Size::from_bytes(size), Size::from_bytes(1));\n+                let size_with_null = Size::from_bytes(size) + Size::from_bytes(1);\n                 // Go through `get_bytes` for checks and AllocationExtra hooks.\n                 // We read the null, so we include it in the request, but we want it removed\n                 // from the result, so we do subslicing.\n@@ -474,7 +474,7 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n         // We have to go back `pointer_size - 1` bytes, as that one would still overlap with\n         // the beginning of this range.\n         let start = ptr.offset.bytes().saturating_sub(cx.data_layout().pointer_size.bytes() - 1);\n-        let end = Size::add(ptr.offset, size); // This does overflow checking.\n+        let end = ptr.offset + size; // This does overflow checking.\n         self.relocations.range(Size::from_bytes(start)..end)\n     }\n \n@@ -519,7 +519,7 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n             )\n         };\n         let start = ptr.offset;\n-        let end = Size::add(start, size);\n+        let end = start + size; // `Size` addition\n \n         // Mark parts of the outermost relocations as undefined if they partially fall outside the\n         // given range.\n@@ -558,15 +558,15 @@ impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n     #[inline]\n     fn check_defined(&self, ptr: Pointer<Tag>, size: Size) -> InterpResult<'tcx> {\n         self.undef_mask\n-            .is_range_defined(ptr.offset, Size::add(ptr.offset, size))\n+            .is_range_defined(ptr.offset, ptr.offset + size) // `Size` addition\n             .or_else(|idx| throw_ub!(InvalidUndefBytes(Some(Pointer::new(ptr.alloc_id, idx)))))\n     }\n \n     pub fn mark_definedness(&mut self, ptr: Pointer<Tag>, size: Size, new_state: bool) {\n         if size.bytes() == 0 {\n             return;\n         }\n-        self.undef_mask.set_range(ptr.offset, Size::add(ptr.offset, size), new_state);\n+        self.undef_mask.set_range(ptr.offset, ptr.offset + size, new_state);\n     }\n }\n \n@@ -611,7 +611,7 @@ impl<Tag, Extra> Allocation<Tag, Extra> {\n \n         for i in 1..size.bytes() {\n             // FIXME: optimize to bitshift the current undef block's bits and read the top bit.\n-            if self.undef_mask.get(Size::add(src.offset, Size::from_bytes(i))) == cur {\n+            if self.undef_mask.get(src.offset + Size::from_bytes(i)) == cur {\n                 cur_len += 1;\n             } else {\n                 ranges.push(cur_len);\n@@ -638,7 +638,7 @@ impl<Tag, Extra> Allocation<Tag, Extra> {\n         if defined.ranges.len() <= 1 {\n             self.undef_mask.set_range_inbounds(\n                 dest.offset,\n-                Size::add(dest.offset, Size::mul(size, repeat)),\n+                dest.offset + size * repeat, // `Size` operations\n                 defined.initial,\n             );\n             return;\n@@ -716,10 +716,10 @@ impl<Tag: Copy, Extra> Allocation<Tag, Extra> {\n         for i in 0..length {\n             new_relocations.extend(relocations.iter().map(|&(offset, reloc)| {\n                 // compute offset for current repetition\n-                let dest_offset = Size::add(dest.offset, Size::mul(size, i));\n+                let dest_offset = dest.offset + size * i; // `Size` operations\n                 (\n                     // shift offsets from source allocation to destination allocation\n-                    Size::sub(Size::add(offset, dest_offset), src.offset),\n+                    (offset + dest_offset) - src.offset, // `Size` operations\n                     reloc,\n                 )\n             }));\n@@ -867,7 +867,7 @@ impl UndefMask {\n         }\n         let start = self.len;\n         self.len += amount;\n-        self.set_range_inbounds(start, Size::add(start, amount), new_state);\n+        self.set_range_inbounds(start, start + amount, new_state); // `Size` operation\n     }\n }\n "}, {"sha": "c2baabf4233ce6157c59faddb0ea07e56cf8295e", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b7db7320ad7a0f07074276c76fe3d1ecc23b08ef/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7db7320ad7a0f07074276c76fe3d1ecc23b08ef/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=b7db7320ad7a0f07074276c76fe3d1ecc23b08ef", "patch": "@@ -1,7 +1,6 @@\n use std::cell::Cell;\n use std::fmt::Write;\n use std::mem;\n-use std::ops::Add;\n \n use rustc::ich::StableHashingContext;\n use rustc::mir;\n@@ -454,7 +453,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // here. But this is where the add would go.)\n \n                 // Return the sum of sizes and max of aligns.\n-                let size = Size::add(sized_size, unsized_size);\n+                let size = sized_size + unsized_size; // `Size` addition\n \n                 // Choose max of two known alignments (combined value must\n                 // be aligned according to more restrictive of the two)."}, {"sha": "2bd6b05a005c63c303ee8a28298f07de12a6df35", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b7db7320ad7a0f07074276c76fe3d1ecc23b08ef/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7db7320ad7a0f07074276c76fe3d1ecc23b08ef/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=b7db7320ad7a0f07074276c76fe3d1ecc23b08ef", "patch": "@@ -9,7 +9,6 @@\n use std::borrow::Cow;\n use std::collections::VecDeque;\n use std::convert::TryFrom;\n-use std::ops::{Add, Mul};\n use std::ptr;\n \n use rustc::ty::layout::{Align, HasDataLayout, Size, TargetDataLayout};\n@@ -880,7 +879,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         let src_bytes =\n             self.get_raw(src.alloc_id)?.get_bytes_with_undef_and_ptr(&tcx, src, size)?.as_ptr();\n         let dest_bytes =\n-            self.get_raw_mut(dest.alloc_id)?.get_bytes_mut(&tcx, dest, Size::mul(size, length))?;\n+            self.get_raw_mut(dest.alloc_id)?.get_bytes_mut(&tcx, dest, size * length)?; // `Size` multiplication\n \n         // If `dest_bytes` is empty we just optimize to not run anything for zsts.\n         // See #67539\n@@ -901,7 +900,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             // touched if the bytes stay undef for the whole interpreter execution. On contemporary\n             // operating system this can avoid physically allocating the page.\n             let dest_alloc = self.get_raw_mut(dest.alloc_id)?;\n-            dest_alloc.mark_definedness(dest, Size::mul(size, length), false);\n+            dest_alloc.mark_definedness(dest, size * length, false); // `Size` multiplication\n             dest_alloc.mark_relocation_range(relocations);\n             return Ok(());\n         }\n@@ -914,8 +913,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         unsafe {\n             if src.alloc_id == dest.alloc_id {\n                 if nonoverlapping {\n-                    if (src.offset <= dest.offset && Size::add(src.offset, size) > dest.offset)\n-                        || (dest.offset <= src.offset && Size::add(dest.offset, size) > src.offset)\n+                    // `Size` additions\n+                    if (src.offset <= dest.offset && src.offset + size > dest.offset)\n+                        || (dest.offset <= src.offset && dest.offset + size > src.offset)\n                     {\n                         throw_ub_format!(\"copy_nonoverlapping called on overlapping ranges\")\n                     }\n@@ -924,15 +924,15 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 for i in 0..length {\n                     ptr::copy(\n                         src_bytes,\n-                        dest_bytes.offset(isize::try_from(Size::mul(size, i).bytes()).unwrap()),\n+                        dest_bytes.offset(isize::try_from((size * i).bytes()).unwrap()), // `Size` multiplication\n                         usize::try_from(size.bytes()).unwrap(),\n                     );\n                 }\n             } else {\n                 for i in 0..length {\n                     ptr::copy_nonoverlapping(\n                         src_bytes,\n-                        dest_bytes.offset(isize::try_from(Size::mul(size, i).bytes()).unwrap()),\n+                        dest_bytes.offset(isize::try_from((size * i).bytes()).unwrap()), // `Size` multiplication\n                         usize::try_from(size.bytes()).unwrap(),\n                     );\n                 }"}, {"sha": "5cf267c257d84d2b03b29e556c022c69e19ad72d", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b7db7320ad7a0f07074276c76fe3d1ecc23b08ef/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7db7320ad7a0f07074276c76fe3d1ecc23b08ef/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=b7db7320ad7a0f07074276c76fe3d1ecc23b08ef", "patch": "@@ -4,7 +4,6 @@\n \n use std::convert::TryFrom;\n use std::hash::Hash;\n-use std::ops::Mul;\n \n use rustc::mir;\n use rustc::mir::interpret::truncate;\n@@ -444,7 +443,7 @@ where\n                     // This can only be reached in ConstProp and non-rustc-MIR.\n                     throw_ub!(BoundsCheckFailed { len, index });\n                 }\n-                let offset = Size::mul(stride, index);\n+                let offset = stride * index; // `Size` multiplication\n                 // All fields have the same layout.\n                 let field_layout = base.layout.field(self, 0)?;\n \n@@ -469,7 +468,8 @@ where\n         };\n         let layout = base.layout.field(self, 0)?;\n         let dl = &self.tcx.data_layout;\n-        Ok((0..len).map(move |i| base.offset(Size::mul(stride, i), MemPlaceMeta::None, layout, dl)))\n+        // `Size` multiplication\n+        Ok((0..len).map(move |i| base.offset(stride * i, MemPlaceMeta::None, layout, dl)))\n     }\n \n     fn mplace_subslice(\n@@ -493,7 +493,7 @@ where\n         // Not using layout method because that works with usize, and does not work with slices\n         // (that have count 0 in their layout).\n         let from_offset = match base.layout.fields {\n-            layout::FieldPlacement::Array { stride, .. } => Size::mul(stride, from), // `Size` multiplication is checked\n+            layout::FieldPlacement::Array { stride, .. } => stride * from, // `Size` multiplication is checked\n             _ => bug!(\"Unexpected layout of index access: {:#?}\", base.layout),\n         };\n "}, {"sha": "1e63766b85d42b065004ad6bef4d531f2e182d58", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b7db7320ad7a0f07074276c76fe3d1ecc23b08ef/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7db7320ad7a0f07074276c76fe3d1ecc23b08ef/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=b7db7320ad7a0f07074276c76fe3d1ecc23b08ef", "patch": "@@ -1,5 +1,4 @@\n use std::convert::TryFrom;\n-use std::ops::Mul;\n \n use rustc::mir::interpret::{InterpResult, Pointer, PointerArithmetic, Scalar};\n use rustc::ty::layout::{Align, HasDataLayout, LayoutOf, Size};\n@@ -57,7 +56,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // `get_vtable` in `rust_codegen_llvm/meth.rs`.\n         // /////////////////////////////////////////////////////////////////////////////////////////\n         let vtable = self.memory.allocate(\n-            Size::mul(ptr_size, u64::try_from(methods.len()).unwrap().checked_add(3).unwrap()),\n+            ptr_size * u64::try_from(methods.len()).unwrap().checked_add(3).unwrap(),\n             ptr_align,\n             MemoryKind::Vtable,\n         );\n@@ -110,8 +109,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     ) -> InterpResult<'tcx, FnVal<'tcx, M::ExtraFnVal>> {\n         let ptr_size = self.pointer_size();\n         // Skip over the 'drop_ptr', 'size', and 'align' fields.\n-        let vtable_slot =\n-            vtable.ptr_offset(Size::mul(ptr_size, idx.checked_add(3).unwrap()), self)?;\n+        let vtable_slot = vtable.ptr_offset(ptr_size * idx.checked_add(3).unwrap(), self)?;\n         let vtable_slot = self\n             .memory\n             .check_ptr_access(vtable_slot, ptr_size, self.tcx.data_layout.pointer_align.abi)?"}, {"sha": "a355a22748010c951fcb755706e25725beb83dd8", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b7db7320ad7a0f07074276c76fe3d1ecc23b08ef/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7db7320ad7a0f07074276c76fe3d1ecc23b08ef/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=b7db7320ad7a0f07074276c76fe3d1ecc23b08ef", "patch": "@@ -6,10 +6,10 @@\n \n use std::convert::TryFrom;\n use std::fmt::Write;\n-use std::ops::{Mul, RangeInclusive};\n+use std::ops::RangeInclusive;\n \n use rustc::ty;\n-use rustc::ty::layout::{self, LayoutOf, Size, TyLayout, VariantIdx};\n+use rustc::ty::layout::{self, LayoutOf, TyLayout, VariantIdx};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n use rustc_span::symbol::{sym, Symbol};\n@@ -747,8 +747,8 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 }\n                 // This is the element type size.\n                 let layout = self.ecx.layout_of(tys)?;\n-                // This is the size in bytes of the whole array.\n-                let size = Size::mul(layout.size, len);\n+                // This is the size in bytes of the whole array. (This checks for overflow.)\n+                let size = layout.size * len;\n                 // Size is not 0, get a pointer.\n                 let ptr = self.ecx.force_ptr(mplace.ptr)?;\n "}]}