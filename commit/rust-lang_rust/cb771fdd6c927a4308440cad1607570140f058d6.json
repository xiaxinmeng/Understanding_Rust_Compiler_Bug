{"sha": "cb771fdd6c927a4308440cad1607570140f058d6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiNzcxZmRkNmM5MjdhNDMwODQ0MGNhZDE2MDc1NzAxNDBmMDU4ZDY=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-09-14T18:54:16Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-09-14T18:59:03Z"}, "message": "feature_gate: Eliminate `check::Context`\n\nUse `PostExpansionVisitor` directly instead", "tree": {"sha": "110b24610cf8f32c94d3857010bc52e6aa4cedb8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/110b24610cf8f32c94d3857010bc52e6aa4cedb8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cb771fdd6c927a4308440cad1607570140f058d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cb771fdd6c927a4308440cad1607570140f058d6", "html_url": "https://github.com/rust-lang/rust/commit/cb771fdd6c927a4308440cad1607570140f058d6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cb771fdd6c927a4308440cad1607570140f058d6/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a01ba39b4b47e8dd397ccb5b6c0363ee168107b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/a01ba39b4b47e8dd397ccb5b6c0363ee168107b2", "html_url": "https://github.com/rust-lang/rust/commit/a01ba39b4b47e8dd397ccb5b6c0363ee168107b2"}], "stats": {"total": 110, "additions": 51, "deletions": 59}, "files": [{"sha": "b4491a87f0600c93b5d42f3f51377f54a547fcde", "filename": "src/libsyntax/feature_gate/check.rs", "status": "modified", "additions": 51, "deletions": 59, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/cb771fdd6c927a4308440cad1607570140f058d6/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb771fdd6c927a4308440cad1607570140f058d6/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs?ref=cb771fdd6c927a4308440cad1607570140f058d6", "patch": "@@ -32,15 +32,10 @@ pub enum Stability {\n     Deprecated(&'static str, Option<&'static str>),\n }\n \n-struct Context<'a> {\n-    parse_sess: &'a ParseSess,\n-    features: &'a Features,\n-}\n-\n macro_rules! gate_feature_fn {\n     ($cx: expr, $has_feature: expr, $span: expr, $name: expr, $explain: expr, $level: expr) => {{\n         let (cx, has_feature, span,\n-             name, explain, level) = ($cx, $has_feature, $span, $name, $explain, $level);\n+             name, explain, level) = (&*$cx, $has_feature, $span, $name, $explain, $level);\n         let has_feature: bool = has_feature(&$cx.features);\n         debug!(\"gate_feature(feature = {:?}, span = {:?}); has? {}\", name, span, has_feature);\n         if !has_feature && !span.allows_unstable($name) {\n@@ -62,45 +57,7 @@ macro_rules! gate_feature {\n }\n \n crate fn check_attribute(attr: &ast::Attribute, parse_sess: &ParseSess, features: &Features) {\n-    let cx = &Context { parse_sess, features };\n-    let attr_info =\n-        attr.ident().and_then(|ident| BUILTIN_ATTRIBUTE_MAP.get(&ident.name)).map(|a| **a);\n-    // Check feature gates for built-in attributes.\n-    if let Some((.., AttributeGate::Gated(_, name, descr, has_feature))) = attr_info {\n-        gate_feature_fn!(cx, has_feature, attr.span, name, descr, GateStrength::Hard);\n-    }\n-    // Check input tokens for built-in and key-value attributes.\n-    match attr_info {\n-        // `rustc_dummy` doesn't have any restrictions specific to built-in attributes.\n-        Some((name, _, template, _)) if name != sym::rustc_dummy =>\n-            check_builtin_attribute(parse_sess, attr, name, template),\n-        _ => if let Some(TokenTree::Token(token)) = attr.tokens.trees().next() {\n-            if token == token::Eq {\n-                // All key-value attributes are restricted to meta-item syntax.\n-                attr.parse_meta(parse_sess).map_err(|mut err| err.emit()).ok();\n-            }\n-        }\n-    }\n-    // Check unstable flavors of the `#[doc]` attribute.\n-    if attr.check_name(sym::doc) {\n-        for nested_meta in attr.meta_item_list().unwrap_or_default() {\n-            macro_rules! gate_doc { ($($name:ident => $feature:ident)*) => {\n-                $(if nested_meta.check_name(sym::$name) {\n-                    let msg = concat!(\"`#[doc(\", stringify!($name), \")]` is experimental\");\n-                    gate_feature!(cx, $feature, attr.span, msg);\n-                })*\n-            }}\n-\n-            gate_doc!(\n-                include => external_doc\n-                cfg => doc_cfg\n-                masked => doc_masked\n-                spotlight => doc_spotlight\n-                alias => doc_alias\n-                keyword => doc_keyword\n-            );\n-        }\n-    }\n+    PostExpansionVisitor { parse_sess, features }.visit_attribute(attr)\n }\n \n fn find_lang_feature_issue(feature: Symbol) -> Option<u32> {\n@@ -215,20 +172,21 @@ pub const EXPLAIN_UNSIZED_TUPLE_COERCION: &str =\n     \"unsized tuple coercion is not stable enough for use and is subject to change\";\n \n struct PostExpansionVisitor<'a> {\n-    context: &'a Context<'a>,\n+    parse_sess: &'a ParseSess,\n+    features: &'a Features,\n }\n \n macro_rules! gate_feature_post {\n     ($cx: expr, $feature: ident, $span: expr, $explain: expr) => {{\n         let (cx, span) = ($cx, $span);\n         if !span.allows_unstable(sym::$feature) {\n-            gate_feature!(cx.context, $feature, span, $explain)\n+            gate_feature!(cx, $feature, span, $explain)\n         }\n     }};\n     ($cx: expr, $feature: ident, $span: expr, $explain: expr, $level: expr) => {{\n         let (cx, span) = ($cx, $span);\n         if !span.allows_unstable(sym::$feature) {\n-            gate_feature!(cx.context, $feature, span, $explain, $level)\n+            gate_feature!(cx, $feature, span, $explain, $level)\n         }\n     }}\n }\n@@ -292,15 +250,52 @@ impl<'a> PostExpansionVisitor<'a> {\n \n impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n     fn visit_attribute(&mut self, attr: &ast::Attribute) {\n-        check_attribute(attr, self.context.parse_sess, self.context.features);\n+        let attr_info =\n+            attr.ident().and_then(|ident| BUILTIN_ATTRIBUTE_MAP.get(&ident.name)).map(|a| **a);\n+        // Check feature gates for built-in attributes.\n+        if let Some((.., AttributeGate::Gated(_, name, descr, has_feature))) = attr_info {\n+            gate_feature_fn!(self, has_feature, attr.span, name, descr, GateStrength::Hard);\n+        }\n+        // Check input tokens for built-in and key-value attributes.\n+        match attr_info {\n+            // `rustc_dummy` doesn't have any restrictions specific to built-in attributes.\n+            Some((name, _, template, _)) if name != sym::rustc_dummy =>\n+                check_builtin_attribute(self.parse_sess, attr, name, template),\n+            _ => if let Some(TokenTree::Token(token)) = attr.tokens.trees().next() {\n+                if token == token::Eq {\n+                    // All key-value attributes are restricted to meta-item syntax.\n+                    attr.parse_meta(self.parse_sess).map_err(|mut err| err.emit()).ok();\n+                }\n+            }\n+        }\n+        // Check unstable flavors of the `#[doc]` attribute.\n+        if attr.check_name(sym::doc) {\n+            for nested_meta in attr.meta_item_list().unwrap_or_default() {\n+                macro_rules! gate_doc { ($($name:ident => $feature:ident)*) => {\n+                    $(if nested_meta.check_name(sym::$name) {\n+                        let msg = concat!(\"`#[doc(\", stringify!($name), \")]` is experimental\");\n+                        gate_feature!(self, $feature, attr.span, msg);\n+                    })*\n+                }}\n+\n+                gate_doc!(\n+                    include => external_doc\n+                    cfg => doc_cfg\n+                    masked => doc_masked\n+                    spotlight => doc_spotlight\n+                    alias => doc_alias\n+                    keyword => doc_keyword\n+                );\n+            }\n+        }\n     }\n \n     fn visit_name(&mut self, sp: Span, name: ast::Name) {\n         if !name.as_str().is_ascii() {\n             gate_feature_post!(\n                 &self,\n                 non_ascii_idents,\n-                self.context.parse_sess.source_map().def_span(sp),\n+                self.parse_sess.source_map().def_span(sp),\n                 \"non-ascii idents are not fully supported\"\n             );\n         }\n@@ -356,12 +351,9 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                     }\n                 }\n \n-                let has_feature = self.context.features.arbitrary_enum_discriminant;\n+                let has_feature = self.features.arbitrary_enum_discriminant;\n                 if !has_feature && !i.span.allows_unstable(sym::arbitrary_enum_discriminant) {\n-                    Parser::maybe_report_invalid_custom_discriminants(\n-                        self.context.parse_sess,\n-                        &variants,\n-                    );\n+                    Parser::maybe_report_invalid_custom_discriminants(self.parse_sess, &variants);\n                 }\n             }\n \n@@ -471,7 +463,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             ast::ExprKind::Type(..) => {\n                 // To avoid noise about type ascription in common syntax errors, only emit if it\n                 // is the *only* error.\n-                if self.context.parse_sess.span_diagnostic.err_count() == 0 {\n+                if self.parse_sess.span_diagnostic.err_count() == 0 {\n                     gate_feature_post!(&self, type_ascription, e.span,\n                                        \"type ascription is experimental\");\n                 }\n@@ -809,13 +801,13 @@ pub fn check_crate(krate: &ast::Crate,\n                    features: &Features,\n                    unstable: UnstableFeatures) {\n     maybe_stage_features(&parse_sess.span_diagnostic, krate, unstable);\n-    let ctx = Context { parse_sess, features };\n+    let mut visitor = PostExpansionVisitor { parse_sess, features };\n \n     macro_rules! gate_all {\n         ($gate:ident, $msg:literal) => { gate_all!($gate, $gate, $msg); };\n         ($spans:ident, $gate:ident, $msg:literal) => {\n             for span in &*parse_sess.gated_spans.$spans.borrow() {\n-                gate_feature!(&ctx, $gate, *span, $msg);\n+                gate_feature!(&visitor, $gate, *span, $msg);\n             }\n         }\n     }\n@@ -826,7 +818,7 @@ pub fn check_crate(krate: &ast::Crate,\n     gate_all!(yields, generators, \"yield syntax is experimental\");\n     gate_all!(or_patterns, \"or-patterns syntax is experimental\");\n \n-    visit::walk_crate(&mut PostExpansionVisitor { context: &ctx }, krate);\n+    visit::walk_crate(&mut visitor, krate);\n }\n \n #[derive(Clone, Copy, Hash)]"}]}