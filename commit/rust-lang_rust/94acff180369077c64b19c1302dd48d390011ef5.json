{"sha": "94acff180369077c64b19c1302dd48d390011ef5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0YWNmZjE4MDM2OTA3N2M2NGIxOWMxMzAyZGQ0OGQzOTAwMTFlZjU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-08-02T20:31:39Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-08-02T20:36:09Z"}, "message": "replace graph rewriting with detecting inlined ids\n\nWe now detect inlined id's earlier (in the HIR map) and rewrite a read\nof them to be a read of the metadata for the associated item.", "tree": {"sha": "81537c2de44b55b1335b5c149a92e4f68e1f4529", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/81537c2de44b55b1335b5c149a92e4f68e1f4529"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/94acff180369077c64b19c1302dd48d390011ef5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/94acff180369077c64b19c1302dd48d390011ef5", "html_url": "https://github.com/rust-lang/rust/commit/94acff180369077c64b19c1302dd48d390011ef5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/94acff180369077c64b19c1302dd48d390011ef5/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "903142aee32b90ec945f809358eec3849e328e39", "url": "https://api.github.com/repos/rust-lang/rust/commits/903142aee32b90ec945f809358eec3849e328e39", "html_url": "https://github.com/rust-lang/rust/commit/903142aee32b90ec945f809358eec3849e328e39"}], "stats": {"total": 283, "additions": 154, "deletions": 129}, "files": [{"sha": "f16a9b386bb8aeb3c985b6d227cc92a86fc45198", "filename": "src/librustc/dep_graph/README.md", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/94acff180369077c64b19c1302dd48d390011ef5/src%2Flibrustc%2Fdep_graph%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/94acff180369077c64b19c1302dd48d390011ef5/src%2Flibrustc%2Fdep_graph%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2FREADME.md?ref=94acff180369077c64b19c1302dd48d390011ef5", "patch": "@@ -134,6 +134,10 @@ to read from it. Similarly, reading from the `tcache` map for item `X`\n (which is a `DepTrackingMap`, described below) automatically invokes\n `dep_graph.read(ItemSignature(X))`.\n \n+**Note:** adding `Hir` nodes requires a bit of caution due to the\n+\"inlining\" that old trans and constant evaluation still use. See the\n+section on inlining below.\n+\n To make this strategy work, a certain amount of indirection is\n required. For example, modules in the HIR do not have direct pointers\n to the items that they contain. Rather, they contain node-ids -- one\n@@ -387,3 +391,24 @@ RUST_DEP_GRAPH_FILTER='Hir&foo -> TypeckItemBody & bar'\n This will dump out all the nodes that lead from `Hir(foo)` to\n `TypeckItemBody(bar)`, from which you can (hopefully) see the source\n of the erroneous edge.\n+\n+### Inlining of HIR nodes\n+\n+For the time being, at least, we still sometimes \"inline\" HIR nodes\n+from other crates into the current HIR map. This creates a weird\n+scenario where the same logical item (let's call it `X`) has two\n+def-ids: the original def-id `X` and a new, inlined one `X'`. `X'` is\n+in the current crate, but it's not like other HIR nodes: in\n+particular, when we restart compilation, it will not be available to\n+hash. Therefore, we do not want `Hir(X')` nodes appearing in our\n+graph.  Instead, we want a \"read\" of `Hir(X')` to be represented as a\n+read of `MetaData(X)`, since the metadata for `X` is where the inlined\n+representation originated in the first place.\n+\n+To achieve this, the HIR map will detect if the def-id originates in\n+an inlined node and add a dependency to a suitable `MetaData` node\n+instead. If you are reading a HIR node and are not sure if it may be\n+inlined or not, you can use `tcx.map.read(node_id)` and it will detect\n+whether the node is inlined or not and do the right thing.  You can\n+also use `tcx.map.is_inlined_def_id()` and\n+`tcx.map.is_inlined_node_id()` to test."}, {"sha": "d085c24036cef88ec83b52e4772ff4a0fdebaecd", "filename": "src/librustc/dep_graph/visit.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/94acff180369077c64b19c1302dd48d390011ef5/src%2Flibrustc%2Fdep_graph%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94acff180369077c64b19c1302dd48d390011ef5/src%2Flibrustc%2Fdep_graph%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fvisit.rs?ref=94acff180369077c64b19c1302dd48d390011ef5", "patch": "@@ -41,6 +41,7 @@ pub fn visit_all_items_in_krate<'a, 'tcx, V, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             let task_id = (self.dep_node_fn)(item_def_id);\n             let _task = self.tcx.dep_graph.in_task(task_id.clone());\n             debug!(\"Started task {:?}\", task_id);\n+            assert!(!self.tcx.map.is_inlined_def_id(item_def_id));\n             self.tcx.dep_graph.read(DepNode::Hir(item_def_id));\n             self.visitor.visit_item(i);\n             debug!(\"Ended task {:?}\", task_id);"}, {"sha": "86d29a6fc717fea971bcbd5d5b27c653cd188116", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 90, "deletions": 49, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/94acff180369077c64b19c1302dd48d390011ef5/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94acff180369077c64b19c1302dd48d390011ef5/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=94acff180369077c64b19c1302dd48d390011ef5", "patch": "@@ -226,60 +226,99 @@ impl<'ast> Map<'ast> {\n     /// otherwise have had access to those contents, and hence needs a\n     /// read recorded). If the function just returns a DefId or\n     /// NodeId, no actual content was returned, so no read is needed.\n-    fn read(&self, id: NodeId) {\n+    pub fn read(&self, id: NodeId) {\n         self.dep_graph.read(self.dep_node(id));\n     }\n \n     fn dep_node(&self, id0: NodeId) -> DepNode<DefId> {\n         let map = self.map.borrow();\n         let mut id = id0;\n-        loop {\n-            match map[id as usize] {\n-                EntryItem(_, item) => {\n-                    let def_id = self.local_def_id(item.id);\n-                    // NB                          ^~~~~~~\n-                    //\n-                    // You would expect that `item.id == id`, but this\n-                    // is not always the case. In particular, for a\n-                    // ViewPath item like `use self::{mem, foo}`, we\n-                    // map the ids for `mem` and `foo` to the\n-                    // enclosing view path item. This seems mega super\n-                    // ultra wrong, but then who am I to judge?\n-                    // -nmatsakis\n-                    return DepNode::Hir(def_id);\n-                }\n+        if !self.is_inlined_node_id(id) {\n+            loop {\n+                match map[id as usize] {\n+                    EntryItem(_, item) => {\n+                        let def_id = self.local_def_id(item.id);\n+                        // NB                          ^~~~~~~\n+                        //\n+                        // You would expect that `item.id == id`, but this\n+                        // is not always the case. In particular, for a\n+                        // ViewPath item like `use self::{mem, foo}`, we\n+                        // map the ids for `mem` and `foo` to the\n+                        // enclosing view path item. This seems mega super\n+                        // ultra wrong, but then who am I to judge?\n+                        // -nmatsakis\n+                        assert!(!self.is_inlined_def_id(def_id));\n+                        return DepNode::Hir(def_id);\n+                    }\n \n-                EntryForeignItem(p, _) |\n-                EntryTraitItem(p, _) |\n-                EntryImplItem(p, _) |\n-                EntryVariant(p, _) |\n-                EntryExpr(p, _) |\n-                EntryStmt(p, _) |\n-                EntryLocal(p, _) |\n-                EntryPat(p, _) |\n-                EntryBlock(p, _) |\n-                EntryStructCtor(p, _) |\n-                EntryLifetime(p, _) |\n-                EntryTyParam(p, _) =>\n-                    id = p,\n-\n-                RootCrate |\n-                RootInlinedParent(_) =>\n-                    // FIXME(#32015) clarify story about cross-crate dep tracking\n-                    return DepNode::Krate,\n-\n-                NotPresent =>\n-                    // Some nodes, notably struct fields, are not\n-                    // present in the map for whatever reason, but\n-                    // they *do* have def-ids. So if we encounter an\n-                    // empty hole, check for that case.\n-                    return self.opt_local_def_id(id)\n-                               .map(|def_id| DepNode::Hir(def_id))\n-                               .unwrap_or_else(|| {\n-                                   bug!(\"Walking parents from `{}` \\\n-                                         led to `NotPresent` at `{}`\",\n-                                        id0, id)\n-                               }),\n+                    EntryForeignItem(p, _) |\n+                    EntryTraitItem(p, _) |\n+                    EntryImplItem(p, _) |\n+                    EntryVariant(p, _) |\n+                    EntryExpr(p, _) |\n+                    EntryStmt(p, _) |\n+                    EntryLocal(p, _) |\n+                    EntryPat(p, _) |\n+                    EntryBlock(p, _) |\n+                    EntryStructCtor(p, _) |\n+                    EntryLifetime(p, _) |\n+                    EntryTyParam(p, _) =>\n+                        id = p,\n+\n+                    RootCrate =>\n+                        return DepNode::Krate,\n+\n+                    RootInlinedParent(_) =>\n+                        bug!(\"node {} has inlined ancestor but is not inlined\", id0),\n+\n+                    NotPresent =>\n+                        // Some nodes, notably struct fields, are not\n+                        // present in the map for whatever reason, but\n+                        // they *do* have def-ids. So if we encounter an\n+                        // empty hole, check for that case.\n+                        return self.opt_local_def_id(id)\n+                                   .map(|def_id| DepNode::Hir(def_id))\n+                                   .unwrap_or_else(|| {\n+                                       bug!(\"Walking parents from `{}` \\\n+                                             led to `NotPresent` at `{}`\",\n+                                            id0, id)\n+                                   }),\n+                }\n+            }\n+        } else {\n+            // reading from an inlined def-id is really a read out of\n+            // the metadata from which we loaded the item.\n+            loop {\n+                match map[id as usize] {\n+                    EntryItem(p, _) |\n+                    EntryForeignItem(p, _) |\n+                    EntryTraitItem(p, _) |\n+                    EntryImplItem(p, _) |\n+                    EntryVariant(p, _) |\n+                    EntryExpr(p, _) |\n+                    EntryStmt(p, _) |\n+                    EntryLocal(p, _) |\n+                    EntryPat(p, _) |\n+                    EntryBlock(p, _) |\n+                    EntryStructCtor(p, _) |\n+                    EntryLifetime(p, _) |\n+                    EntryTyParam(p, _) =>\n+                        id = p,\n+\n+                    RootInlinedParent(parent) => match *parent {\n+                        InlinedItem::Item(def_id, _) |\n+                        InlinedItem::TraitItem(def_id, _) |\n+                        InlinedItem::ImplItem(def_id, _) |\n+                        InlinedItem::Foreign(def_id, _) =>\n+                            return DepNode::MetaData(def_id)\n+                    },\n+\n+                    RootCrate =>\n+                        bug!(\"node {} has crate ancestor but is inlined\", id0),\n+\n+                    NotPresent =>\n+                        bug!(\"node {} is inlined but not present in map\", id0),\n+                }\n             }\n         }\n     }\n@@ -876,7 +915,8 @@ pub fn map_decoded_item<'ast, F: FoldOps>(map: &Map<'ast>,\n                                           -> &'ast InlinedItem {\n     let mut fld = IdAndSpanUpdater::new(fold_ops);\n     let ii = match ii {\n-        II::Item(i) => II::Item(i.map(|i| fld.fold_item(i))),\n+        II::Item(d, i) => II::Item(fld.fold_ops.new_def_id(d),\n+                                   i.map(|i| fld.fold_item(i))),\n         II::TraitItem(d, ti) => {\n             II::TraitItem(fld.fold_ops.new_def_id(d),\n                           ti.map(|ti| fld.fold_trait_item(ti)))\n@@ -885,7 +925,8 @@ pub fn map_decoded_item<'ast, F: FoldOps>(map: &Map<'ast>,\n             II::ImplItem(fld.fold_ops.new_def_id(d),\n                          ii.map(|ii| fld.fold_impl_item(ii)))\n         }\n-        II::Foreign(i) => II::Foreign(i.map(|i| fld.fold_foreign_item(i)))\n+        II::Foreign(d, i) => II::Foreign(fld.fold_ops.new_def_id(d),\n+                                         i.map(|i| fld.fold_foreign_item(i)))\n     };\n \n     let ii = map.forest.inlined_items.alloc(ii);"}, {"sha": "f1bb3a37e3c273c9ebbfbf39850cff2cd8a3b1f6", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/94acff180369077c64b19c1302dd48d390011ef5/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94acff180369077c64b19c1302dd48d390011ef5/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=94acff180369077c64b19c1302dd48d390011ef5", "patch": "@@ -94,19 +94,19 @@ pub enum DefLike {\n /// that we trans.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum InlinedItem {\n-    Item(P<hir::Item>),\n+    Item(DefId /* def-id in source crate */, P<hir::Item>),\n     TraitItem(DefId /* impl id */, P<hir::TraitItem>),\n     ImplItem(DefId /* impl id */, P<hir::ImplItem>),\n-    Foreign(P<hir::ForeignItem>),\n+    Foreign(DefId /* extern item */, P<hir::ForeignItem>),\n }\n \n /// A borrowed version of `hir::InlinedItem`.\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n pub enum InlinedItemRef<'a> {\n-    Item(&'a hir::Item),\n+    Item(DefId, &'a hir::Item),\n     TraitItem(DefId, &'a hir::TraitItem),\n     ImplItem(DefId, &'a hir::ImplItem),\n-    Foreign(&'a hir::ForeignItem)\n+    Foreign(DefId, &'a hir::ForeignItem)\n }\n \n /// Item definitions in the currently-compiled crate would have the CrateNum\n@@ -283,8 +283,8 @@ impl InlinedItem {\n         where V: Visitor<'ast>\n     {\n         match *self {\n-            InlinedItem::Item(ref i) => visitor.visit_item(&i),\n-            InlinedItem::Foreign(ref i) => visitor.visit_foreign_item(&i),\n+            InlinedItem::Item(_, ref i) => visitor.visit_item(&i),\n+            InlinedItem::Foreign(_, ref i) => visitor.visit_foreign_item(&i),\n             InlinedItem::TraitItem(_, ref ti) => visitor.visit_trait_item(ti),\n             InlinedItem::ImplItem(_, ref ii) => visitor.visit_impl_item(ii),\n         }"}, {"sha": "227aa7f67688f333d9b1e13d6b12d2fa14ce23c9", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/94acff180369077c64b19c1302dd48d390011ef5/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94acff180369077c64b19c1302dd48d390011ef5/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=94acff180369077c64b19c1302dd48d390011ef5", "patch": "@@ -142,7 +142,7 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n         let mut used_substs = false;\n         let expr_ty = match tcx.sess.cstore.maybe_get_item_ast(tcx, def_id) {\n-            Some((&InlinedItem::Item(ref item), _)) => match item.node {\n+            Some((&InlinedItem::Item(_, ref item), _)) => match item.node {\n                 hir::ItemConst(ref ty, ref const_expr) => {\n                     Some((&**const_expr, tcx.ast_ty_to_prim_ty(ty)))\n                 },\n@@ -198,7 +198,7 @@ fn inline_const_fn_from_external_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n \n     let fn_id = match tcx.sess.cstore.maybe_get_item_ast(tcx, def_id) {\n-        Some((&InlinedItem::Item(ref item), _)) => Some(item.id),\n+        Some((&InlinedItem::Item(_, ref item), _)) => Some(item.id),\n         Some((&InlinedItem::ImplItem(_, ref item), _)) => Some(item.id),\n         _ => None\n     };"}, {"sha": "a0827cf3bf4ddc9b64c39783360a9c73de3e2a30", "filename": "src/librustc_incremental/persist/hash.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/94acff180369077c64b19c1302dd48d390011ef5/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94acff180369077c64b19c1302dd48d390011ef5/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs?ref=94acff180369077c64b19c1302dd48d390011ef5", "patch": "@@ -70,6 +70,11 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n                 def_id,\n                 self.tcx.item_path_str(def_id));\n \n+        assert!(!self.tcx.map.is_inlined_def_id(def_id),\n+                \"cannot hash HIR for inlined def-id {:?} => {:?}\",\n+                def_id,\n+                self.tcx.item_path_str(def_id));\n+\n         // FIXME(#32753) -- should we use a distinct hash here\n         self.tcx.calculate_item_hash(def_id)\n     }"}, {"sha": "aa9d1f4c1536de88b417d42a9fc0b6d29c867c28", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 1, "deletions": 52, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/94acff180369077c64b19c1302dd48d390011ef5/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94acff180369077c64b19c1302dd48d390011ef5/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=94acff180369077c64b19c1302dd48d390011ef5", "patch": "@@ -106,7 +106,7 @@ pub fn encode_dep_graph<'a, 'tcx>(hcx: &mut HashContext<'a, 'tcx>,\n                                   encoder: &mut Encoder)\n                                   -> io::Result<()>\n {\n-    let (nodes, edges) = post_process_graph(hcx, query);\n+    let (nodes, edges) = (query.nodes(), query.edges());\n \n     // Create hashes for inputs.\n     let hashes =\n@@ -142,57 +142,6 @@ pub fn encode_dep_graph<'a, 'tcx>(hcx: &mut HashContext<'a, 'tcx>,\n     Ok(())\n }\n \n-pub fn post_process_graph<'a, 'tcx>(hcx: &mut HashContext<'a, 'tcx>,\n-                                    query: &DepGraphQuery<DefId>)\n-                                    -> (Vec<DepNode<DefId>>, Vec<(DepNode<DefId>, DepNode<DefId>)>)\n-{\n-    let tcx = hcx.tcx;\n-    let mut cache = FnvHashMap();\n-\n-    let mut uninline_def_id = |def_id: DefId| -> Option<DefId> {\n-        if tcx.map.is_inlined_def_id(def_id) {\n-            Some(\n-                cache.entry(def_id)\n-                     .or_insert_with(|| {\n-                         let def_path = tcx.def_path(def_id);\n-                         debug!(\"post_process_graph: uninlining def-id {:?} to yield {:?}\",\n-                                def_id, def_path);\n-                         let retraced_def_id = tcx.retrace_path(&def_path).unwrap();\n-                         debug!(\"post_process_graph: retraced to {:?}\", retraced_def_id);\n-                         retraced_def_id\n-                     })\n-                     .clone())\n-        } else {\n-            None\n-        }\n-    };\n-\n-    let mut uninline_metadata = |node: &DepNode<DefId>| -> DepNode<DefId> {\n-        match *node {\n-            DepNode::Hir(def_id) => {\n-                match uninline_def_id(def_id) {\n-                    Some(uninlined_def_id) => DepNode::MetaData(uninlined_def_id),\n-                    None => DepNode::Hir(def_id)\n-                }\n-            }\n-            _ => node.clone()\n-        }\n-    };\n-\n-    let nodes = query.nodes()\n-                     .into_iter()\n-                     .map(|node| uninline_metadata(node))\n-                     .collect();\n-\n-    let edges = query.edges()\n-                     .into_iter()\n-                     .map(|(from, to)| (uninline_metadata(from), uninline_metadata(to)))\n-                     .collect();\n-\n-    (nodes, edges)\n-}\n-\n-\n pub fn encode_metadata_hashes<'a, 'tcx>(hcx: &mut HashContext<'a, 'tcx>,\n                                         builder: &mut DefIdDirectoryBuilder,\n                                         query: &DepGraphQuery<DefId>,"}, {"sha": "e5aca1d1f5899d592a2d280b390e3c4c69d48381", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/94acff180369077c64b19c1302dd48d390011ef5/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94acff180369077c64b19c1302dd48d390011ef5/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=94acff180369077c64b19c1302dd48d390011ef5", "patch": "@@ -78,8 +78,8 @@ pub fn encode_inlined_item(ecx: &e::EncodeContext,\n                            rbml_w: &mut Encoder,\n                            ii: InlinedItemRef) {\n     let id = match ii {\n-        InlinedItemRef::Item(i) => i.id,\n-        InlinedItemRef::Foreign(i) => i.id,\n+        InlinedItemRef::Item(_, i) => i.id,\n+        InlinedItemRef::Foreign(_, i) => i.id,\n         InlinedItemRef::TraitItem(_, ti) => ti.id,\n         InlinedItemRef::ImplItem(_, ii) => ii.id,\n     };\n@@ -146,8 +146,8 @@ pub fn decode_inlined_item<'a, 'tcx>(cdata: &cstore::CrateMetadata,\n                                        decode_ast(ast_doc),\n                                        dcx);\n     let name = match *ii {\n-        InlinedItem::Item(ref i) => i.name,\n-        InlinedItem::Foreign(ref i) => i.name,\n+        InlinedItem::Item(_, ref i) => i.name,\n+        InlinedItem::Foreign(_, ref i) => i.name,\n         InlinedItem::TraitItem(_, ref ti) => ti.name,\n         InlinedItem::ImplItem(_, ref ii) => ii.name\n     };\n@@ -158,7 +158,7 @@ pub fn decode_inlined_item<'a, 'tcx>(cdata: &cstore::CrateMetadata,\n     region::resolve_inlined_item(&tcx.sess, &tcx.region_maps, ii);\n     decode_side_tables(dcx, ast_doc);\n     copy_item_types(dcx, ii, orig_did);\n-    if let InlinedItem::Item(ref i) = *ii {\n+    if let InlinedItem::Item(_, ref i) = *ii {\n         debug!(\">>> DECODED ITEM >>>\\n{}\\n<<< DECODED ITEM <<<\",\n                ::rustc::hir::print::item_to_string(&i));\n     }\n@@ -348,17 +348,17 @@ fn simplify_ast(ii: InlinedItemRef) -> (InlinedItem, IdRange) {\n \n     let ii = match ii {\n         // HACK we're not dropping items.\n-        InlinedItemRef::Item(i) => {\n-            InlinedItem::Item(P(fold::noop_fold_item(i.clone(), &mut fld)))\n+        InlinedItemRef::Item(d, i) => {\n+            InlinedItem::Item(d, P(fold::noop_fold_item(i.clone(), &mut fld)))\n         }\n         InlinedItemRef::TraitItem(d, ti) => {\n             InlinedItem::TraitItem(d, P(fold::noop_fold_trait_item(ti.clone(), &mut fld)))\n         }\n         InlinedItemRef::ImplItem(d, ii) => {\n             InlinedItem::ImplItem(d, P(fold::noop_fold_impl_item(ii.clone(), &mut fld)))\n         }\n-        InlinedItemRef::Foreign(i) => {\n-            InlinedItem::Foreign(P(fold::noop_fold_foreign_item(i.clone(), &mut fld)))\n+        InlinedItemRef::Foreign(d, i) => {\n+            InlinedItem::Foreign(d, P(fold::noop_fold_foreign_item(i.clone(), &mut fld)))\n         }\n     };\n \n@@ -1241,15 +1241,15 @@ fn copy_item_types(dcx: &DecodeContext, ii: &InlinedItem, orig_did: DefId) {\n     }\n     // copy the entry for the item itself\n     let item_node_id = match ii {\n-        &InlinedItem::Item(ref i) => i.id,\n+        &InlinedItem::Item(_, ref i) => i.id,\n         &InlinedItem::TraitItem(_, ref ti) => ti.id,\n         &InlinedItem::ImplItem(_, ref ii) => ii.id,\n-        &InlinedItem::Foreign(ref fi) => fi.id\n+        &InlinedItem::Foreign(_, ref fi) => fi.id\n     };\n     copy_item_type(dcx, item_node_id, orig_did);\n \n     // copy the entries of inner items\n-    if let &InlinedItem::Item(ref item) = ii {\n+    if let &InlinedItem::Item(_, ref item) = ii {\n         match item.node {\n             hir::ItemEnum(ref def, _) => {\n                 let orig_def = dcx.tcx.lookup_adt_def(orig_did);"}, {"sha": "7ee6e54a666d6d524520ee745440e422a50a56c3", "filename": "src/librustc_metadata/csearch.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/94acff180369077c64b19c1302dd48d390011ef5/src%2Flibrustc_metadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94acff180369077c64b19c1302dd48d390011ef5/src%2Flibrustc_metadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcsearch.rs?ref=94acff180369077c64b19c1302dd48d390011ef5", "patch": "@@ -546,11 +546,13 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n                     .borrow_mut()\n                     .insert(def_id, None);\n             }\n-            decoder::FoundAst::Found(&InlinedItem::Item(ref item)) => {\n+            decoder::FoundAst::Found(&InlinedItem::Item(d, ref item)) => {\n+                assert_eq!(d, def_id);\n                 let inlined_root_node_id = find_inlined_item_root(item.id);\n                 cache_inlined_item(def_id, item.id, inlined_root_node_id);\n             }\n-            decoder::FoundAst::Found(&InlinedItem::Foreign(ref item)) => {\n+            decoder::FoundAst::Found(&InlinedItem::Foreign(d, ref item)) => {\n+                assert_eq!(d, def_id);\n                 let inlined_root_node_id = find_inlined_item_root(item.id);\n                 cache_inlined_item(def_id, item.id, inlined_root_node_id);\n             }"}, {"sha": "a0f9af6830aa40b0f308581a694571c082184370", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94acff180369077c64b19c1302dd48d390011ef5/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94acff180369077c64b19c1302dd48d390011ef5/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=94acff180369077c64b19c1302dd48d390011ef5", "patch": "@@ -797,7 +797,7 @@ pub fn maybe_get_item_ast<'a, 'tcx>(cdata: Cmd, tcx: TyCtxt<'a, 'tcx, 'tcx>, id:\n                                          grandparent_def_id,\n                                          ast_doc,\n                                          parent_did);\n-            if let &InlinedItem::Item(ref i) = ii {\n+            if let &InlinedItem::Item(_, ref i) = ii {\n                 return FoundAst::FoundParent(parent_did, i);\n             }\n         }"}, {"sha": "ffd2a3535c332b0962390849ba5a14a11cc07399", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/94acff180369077c64b19c1302dd48d390011ef5/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94acff180369077c64b19c1302dd48d390011ef5/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=94acff180369077c64b19c1302dd48d390011ef5", "patch": "@@ -861,7 +861,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         encode_bounds_and_type_for_item(rbml_w, ecx, index, item.id);\n         encode_name(rbml_w, item.name);\n         encode_attributes(rbml_w, &item.attrs);\n-        encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(item));\n+        encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(def_id, item));\n         encode_mir(ecx, rbml_w, item.id);\n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n@@ -879,7 +879,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         encode_attributes(rbml_w, &item.attrs);\n         let needs_inline = tps_len > 0 || attr::requests_inline(&item.attrs);\n         if needs_inline || constness == hir::Constness::Const {\n-            encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(item));\n+            encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(def_id, item));\n             encode_mir(ecx, rbml_w, item.id);\n         }\n         encode_constness(rbml_w, constness);\n@@ -942,7 +942,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         for v in &enum_definition.variants {\n             encode_variant_id(rbml_w, ecx.tcx.map.local_def_id(v.node.data.id()));\n         }\n-        encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(item));\n+        encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(def_id, item));\n         encode_mir(ecx, rbml_w, item.id);\n \n         // Encode inherent implementations for this enumeration.\n@@ -989,7 +989,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         needs to know*/\n         encode_struct_fields(rbml_w, variant);\n \n-        encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(item));\n+        encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(def_id, item));\n         encode_mir(ecx, rbml_w, item.id);\n \n         // Encode inherent implementations for this structure.\n@@ -1311,7 +1311,7 @@ fn encode_info_for_foreign_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         encode_bounds_and_type_for_item(rbml_w, ecx, index, nitem.id);\n         encode_name(rbml_w, nitem.name);\n         if abi == Abi::RustIntrinsic || abi == Abi::PlatformIntrinsic {\n-            encode_inlined_item(ecx, rbml_w, InlinedItemRef::Foreign(nitem));\n+            encode_inlined_item(ecx, rbml_w, InlinedItemRef::Foreign(def_id, nitem));\n             encode_mir(ecx, rbml_w, nitem.id);\n         }\n         encode_attributes(rbml_w, &nitem.attrs);"}, {"sha": "9ed95fd5009bc31705eed8ad2ab9c553a2a489fe", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94acff180369077c64b19c1302dd48d390011ef5/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94acff180369077c64b19c1302dd48d390011ef5/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=94acff180369077c64b19c1302dd48d390011ef5", "patch": "@@ -1436,6 +1436,7 @@ fn type_scheme_of_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         // NB. Since the `memoized` function enters a new task, and we\n         // are giving this task access to the item `item`, we must\n         // register a read.\n+        assert!(!ccx.tcx.map.is_inlined_def_id(item_def_id));\n         ccx.tcx.dep_graph.read(DepNode::Hir(item_def_id));\n         compute_type_scheme_of_item(ccx, item)\n     })\n@@ -1563,6 +1564,7 @@ fn type_scheme_of_foreign_item<'a, 'tcx>(\n         // NB. Since the `memoized` function enters a new task, and we\n         // are giving this task access to the item `item`, we must\n         // register a read.\n+        assert!(!ccx.tcx.map.is_inlined_def_id(item_def_id));\n         ccx.tcx.dep_graph.read(DepNode::Hir(item_def_id));\n         compute_type_scheme_of_foreign_item(ccx, item, abi)\n     })"}]}