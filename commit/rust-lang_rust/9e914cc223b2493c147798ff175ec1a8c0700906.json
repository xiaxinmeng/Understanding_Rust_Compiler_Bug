{"sha": "9e914cc223b2493c147798ff175ec1a8c0700906", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllOTE0Y2MyMjNiMjQ5M2MxNDc3OThmZjE3NWVjMWE4YzA3MDA5MDY=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-05-19T15:40:58Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-05-19T15:40:58Z"}, "message": "Rollup merge of #50531 - iancormac84:merge-typeidhasher-cleanup, r=michaelwoerister\n\nCleanup uses of TypeIdHasher and replace them with StableHasher\n\nFixes #50424\n\nr? @michaelwoerister", "tree": {"sha": "e0ca39de5aae779d67156e366289a0f75da95cab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e0ca39de5aae779d67156e366289a0f75da95cab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9e914cc223b2493c147798ff175ec1a8c0700906", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbAEWKCRBK7hj4Ov3rIwAAdHIIABTO+4x0uRkeledXmG2whiIu\n38URlo9Gw+OgKLz1fDtxL2as2y5jmiuiHv/2ZwpyeKNkT01k2A5/1Dt096QtWMZs\n7OhbXsqpTe4Plbo7M3qPE2Yhv2Q4GdndTV9tzs+uTBOmWxcK7QESiiLcwfHcGmQs\nrp9invRXmlzGnR1rU8Q1K0ipjQNHEkVSYTiu4OC6kGC3iJomwiChjRqckrhzOcDh\nwN8vy91rugk1Io2Gvqr0eLDyC05z+LCAAg4xp9GhFg9uk5xsSYJ83FEk+kzcCxHK\nVhTOJyyUIlJPtv9TIq/c3BJyy+u7TlL8nJDzQgrg/fJlXEJIV/MkEt5t6cTySLo=\n=DlxJ\n-----END PGP SIGNATURE-----\n", "payload": "tree e0ca39de5aae779d67156e366289a0f75da95cab\nparent ef8ee647749ad2f0acf235aaf18debacb974a048\nparent 03493941fb5fa18d592da57530382f5c4b7cf2f9\nauthor kennytm <kennytm@gmail.com> 1526744458 +0800\ncommitter GitHub <noreply@github.com> 1526744458 +0800\n\nRollup merge of #50531 - iancormac84:merge-typeidhasher-cleanup, r=michaelwoerister\n\nCleanup uses of TypeIdHasher and replace them with StableHasher\n\nFixes #50424\n\nr? @michaelwoerister\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9e914cc223b2493c147798ff175ec1a8c0700906", "html_url": "https://github.com/rust-lang/rust/commit/9e914cc223b2493c147798ff175ec1a8c0700906", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9e914cc223b2493c147798ff175ec1a8c0700906/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef8ee647749ad2f0acf235aaf18debacb974a048", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef8ee647749ad2f0acf235aaf18debacb974a048", "html_url": "https://github.com/rust-lang/rust/commit/ef8ee647749ad2f0acf235aaf18debacb974a048"}, {"sha": "03493941fb5fa18d592da57530382f5c4b7cf2f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/03493941fb5fa18d592da57530382f5c4b7cf2f9", "html_url": "https://github.com/rust-lang/rust/commit/03493941fb5fa18d592da57530382f5c4b7cf2f9"}], "stats": {"total": 306, "additions": 86, "deletions": 220}, "files": [{"sha": "eb672e9ed4b974f49967b673efef1a4bcb6e7bb2", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e914cc223b2493c147798ff175ec1a8c0700906/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e914cc223b2493c147798ff175ec1a8c0700906/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=9e914cc223b2493c147798ff175ec1a8c0700906", "patch": "@@ -132,7 +132,7 @@ for ty::RegionKind {\n             ty::ReLateBound(..) |\n             ty::ReVar(..) |\n             ty::ReSkolemized(..) => {\n-                bug!(\"TypeIdHasher: unexpected region {:?}\", *self)\n+                bug!(\"StableHasher: unexpected region {:?}\", *self)\n             }\n         }\n     }"}, {"sha": "7cfcbcb86af98a62ba67d17dbdbd92bfe0d4a1fc", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 1, "deletions": 150, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/9e914cc223b2493c147798ff175ec1a8c0700906/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e914cc223b2493c147798ff175ec1a8c0700906/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=9e914cc223b2493c147798ff175ec1a8c0700906", "patch": "@@ -15,23 +15,18 @@ use hir::def_id::DefId;\n use hir::map::{DefPathData, Node};\n use hir;\n use ich::NodeIdHashingMode;\n-use middle::const_val::ConstVal;\n use traits::{self, ObligationCause};\n use ty::{self, Ty, TyCtxt, GenericParamDefKind, TypeFoldable};\n-use ty::fold::TypeVisitor;\n use ty::subst::{Substs, UnpackedKind};\n use ty::maps::TyCtxtAt;\n use ty::TypeVariants::*;\n use ty::layout::{Integer, IntegerExt};\n use util::common::ErrorReported;\n use middle::lang_items;\n \n-use rustc_data_structures::stable_hasher::{StableHasher, StableHasherResult,\n-                                           HashStable};\n+use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n use rustc_data_structures::fx::FxHashMap;\n use std::{cmp, fmt};\n-use std::hash::Hash;\n-use std::intrinsics;\n use syntax::ast;\n use syntax::attr::{self, SignedInt, UnsignedInt};\n use syntax_pos::{Span, DUMMY_SP};\n@@ -615,150 +610,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-pub struct TypeIdHasher<'a, 'gcx: 'a+'tcx, 'tcx: 'a, W> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    state: StableHasher<W>,\n-}\n-\n-impl<'a, 'gcx, 'tcx, W> TypeIdHasher<'a, 'gcx, 'tcx, W>\n-    where W: StableHasherResult\n-{\n-    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Self {\n-        TypeIdHasher { tcx: tcx, state: StableHasher::new() }\n-    }\n-\n-    pub fn finish(self) -> W {\n-        self.state.finish()\n-    }\n-\n-    pub fn hash<T: Hash>(&mut self, x: T) {\n-        x.hash(&mut self.state);\n-    }\n-\n-    fn hash_discriminant_u8<T>(&mut self, x: &T) {\n-        let v = unsafe {\n-            intrinsics::discriminant_value(x)\n-        };\n-        let b = v as u8;\n-        assert_eq!(v, b as u64);\n-        self.hash(b)\n-    }\n-\n-    fn def_id(&mut self, did: DefId) {\n-        // Hash the DefPath corresponding to the DefId, which is independent\n-        // of compiler internal state. We already have a stable hash value of\n-        // all DefPaths available via tcx.def_path_hash(), so we just feed that\n-        // into the hasher.\n-        let hash = self.tcx.def_path_hash(did);\n-        self.hash(hash);\n-    }\n-}\n-\n-impl<'a, 'gcx, 'tcx, W> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tcx, W>\n-    where W: StableHasherResult\n-{\n-    fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n-        // Distinguish between the Ty variants uniformly.\n-        self.hash_discriminant_u8(&ty.sty);\n-\n-        match ty.sty {\n-            TyInt(i) => self.hash(i),\n-            TyUint(u) => self.hash(u),\n-            TyFloat(f) => self.hash(f),\n-            TyArray(_, n) => {\n-                self.hash_discriminant_u8(&n.val);\n-                match n.val {\n-                    ConstVal::Value(alloc) => self.hash(alloc),\n-                    ConstVal::Unevaluated(def_id, _) => self.def_id(def_id),\n-                }\n-            }\n-            TyRawPtr(m) => self.hash(m.mutbl),\n-            TyRef(_, _, mutbl) => self.hash(mutbl),\n-            TyClosure(def_id, _) |\n-            TyGenerator(def_id, _, _) |\n-            TyAnon(def_id, _) |\n-            TyFnDef(def_id, _) => self.def_id(def_id),\n-            TyAdt(d, _) => self.def_id(d.did),\n-            TyForeign(def_id) => self.def_id(def_id),\n-            TyFnPtr(f) => {\n-                self.hash(f.unsafety());\n-                self.hash(f.abi());\n-                self.hash(f.variadic());\n-                self.hash(f.inputs().skip_binder().len());\n-            }\n-            TyDynamic(ref data, ..) => {\n-                if let Some(p) = data.principal() {\n-                    self.def_id(p.def_id());\n-                }\n-                for d in data.auto_traits() {\n-                    self.def_id(d);\n-                }\n-            }\n-            TyGeneratorWitness(tys) => {\n-                self.hash(tys.skip_binder().len());\n-            }\n-            TyTuple(tys) => {\n-                self.hash(tys.len());\n-            }\n-            TyParam(p) => {\n-                self.hash(p.idx);\n-                self.hash(p.name);\n-            }\n-            TyProjection(ref data) => {\n-                self.def_id(data.item_def_id);\n-            }\n-            TyNever |\n-            TyBool |\n-            TyChar |\n-            TyStr |\n-            TySlice(_) => {}\n-\n-            TyError |\n-            TyInfer(_) => bug!(\"TypeIdHasher: unexpected type {}\", ty)\n-        }\n-\n-        ty.super_visit_with(self)\n-    }\n-\n-    fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n-        self.hash_discriminant_u8(r);\n-        match *r {\n-            ty::ReErased |\n-            ty::ReStatic |\n-            ty::ReEmpty => {\n-                // No variant fields to hash for these ...\n-            }\n-            ty::ReCanonical(c) => {\n-                self.hash(c);\n-            }\n-            ty::ReLateBound(db, ty::BrAnon(i)) => {\n-                self.hash(db.depth);\n-                self.hash(i);\n-            }\n-            ty::ReEarlyBound(ty::EarlyBoundRegion { def_id, .. }) => {\n-                self.def_id(def_id);\n-            }\n-\n-            ty::ReClosureBound(..) |\n-            ty::ReLateBound(..) |\n-            ty::ReFree(..) |\n-            ty::ReScope(..) |\n-            ty::ReVar(..) |\n-            ty::ReSkolemized(..) => {\n-                bug!(\"TypeIdHasher: unexpected region {:?}\", r)\n-            }\n-        }\n-        false\n-    }\n-\n-    fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, x: &ty::Binder<T>) -> bool {\n-        // Anonymize late-bound regions so that, for example:\n-        // `for<'a, b> fn(&'a &'b T)` and `for<'a, b> fn(&'b &'a T)`\n-        // result in the same TypeId (the two types are equivalent).\n-        self.tcx.anonymize_late_bound_regions(x).super_visit_with(self)\n-    }\n-}\n-\n impl<'a, 'tcx> ty::TyS<'tcx> {\n     pub fn moves_by_default(&'tcx self,\n                             tcx: TyCtxt<'a, 'tcx, 'tcx>,"}, {"sha": "ae0f6067f476767b4bfed440552ae42abd128e88", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9e914cc223b2493c147798ff175ec1a8c0700906/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e914cc223b2493c147798ff175ec1a8c0700906/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=9e914cc223b2493c147798ff175ec1a8c0700906", "patch": "@@ -23,12 +23,11 @@ use llvm::{self, ValueRef};\n use llvm::debuginfo::{DIType, DIFile, DIScope, DIDescriptor,\n                       DICompositeType, DILexicalBlock, DIFlags};\n \n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc::hir::CodegenFnAttrFlags;\n use rustc::hir::def::CtorKind;\n use rustc::hir::def_id::{DefId, CrateNum, LOCAL_CRATE};\n-use rustc::ty::fold::TypeVisitor;\n-use rustc::ty::util::TypeIdHasher;\n-use rustc::ich::Fingerprint;\n+use rustc::ich::{Fingerprint, NodeIdHashingMode};\n use rustc::ty::Instance;\n use common::CodegenCx;\n use rustc::ty::{self, AdtKind, ParamEnv, Ty, TyCtxt};\n@@ -144,9 +143,15 @@ impl<'tcx> TypeMap<'tcx> {\n \n         // The hasher we are using to generate the UniqueTypeId. We want\n         // something that provides more than the 64 bits of the DefaultHasher.\n-        let mut type_id_hasher = TypeIdHasher::<Fingerprint>::new(cx.tcx);\n-        type_id_hasher.visit_ty(type_);\n-        let unique_type_id = type_id_hasher.finish().to_hex();\n+        let mut hasher = StableHasher::<Fingerprint>::new();\n+        let mut hcx = cx.tcx.create_stable_hashing_context();\n+        let type_ = cx.tcx.erase_regions(&type_);\n+        hcx.while_hashing_spans(false, |hcx| {\n+            hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n+                type_.hash_stable(hcx, &mut hasher);\n+            });\n+        });\n+        let unique_type_id = hasher.finish().to_hex();\n \n         let key = self.unique_id_interner.intern(&unique_type_id);\n         self.type_to_unique_id.insert(type_, UniqueTypeId(key));"}, {"sha": "2063db6dc533103ece971c98f1372aadb6d10447", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 73, "deletions": 63, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/9e914cc223b2493c147798ff175ec1a8c0700906/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e914cc223b2493c147798ff175ec1a8c0700906/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=9e914cc223b2493c147798ff175ec1a8c0700906", "patch": "@@ -97,18 +97,19 @@\n //! virtually impossible. Thus, symbol hash generation exclusively relies on\n //! DefPaths which are much more robust in the face of changes to the code base.\n \n-use rustc::middle::weak_lang_items;\n-use rustc_mir::monomorphize::Instance;\n-use rustc_mir::monomorphize::item::{MonoItem, MonoItemExt, InstantiationMode};\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::hir::map as hir_map;\n-use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n-use rustc::ty::fold::TypeVisitor;\n+use rustc::hir::map::definitions::DefPathData;\n+use rustc::ich::NodeIdHashingMode;\n+use rustc::middle::weak_lang_items;\n use rustc::ty::item_path::{self, ItemPathBuffer, RootMode};\n use rustc::ty::maps::Providers;\n use rustc::ty::subst::Substs;\n-use rustc::hir::map::definitions::DefPathData;\n+use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::util::common::record_time;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_mir::monomorphize::item::{InstantiationMode, MonoItem, MonoItemExt};\n+use rustc_mir::monomorphize::Instance;\n \n use syntax::attr;\n use syntax_pos::symbol::Symbol;\n@@ -124,51 +125,60 @@ pub fn provide(providers: &mut Providers) {\n     };\n }\n \n-fn get_symbol_hash<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn get_symbol_hash<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n-                             // the DefId of the item this name is for\n-                             def_id: DefId,\n+    // the DefId of the item this name is for\n+    def_id: DefId,\n \n-                             // instance this name will be for\n-                             instance: Instance<'tcx>,\n+    // instance this name will be for\n+    instance: Instance<'tcx>,\n \n-                             // type of the item, without any generic\n-                             // parameters substituted; this is\n-                             // included in the hash as a kind of\n-                             // safeguard.\n-                             item_type: Ty<'tcx>,\n+    // type of the item, without any generic\n+    // parameters substituted; this is\n+    // included in the hash as a kind of\n+    // safeguard.\n+    item_type: Ty<'tcx>,\n \n-                             // values for generic type parameters,\n-                             // if any.\n-                             substs: &'tcx Substs<'tcx>)\n-                             -> u64 {\n-    debug!(\"get_symbol_hash(def_id={:?}, parameters={:?})\", def_id, substs);\n+    // values for generic type parameters,\n+    // if any.\n+    substs: &'tcx Substs<'tcx>,\n+) -> u64 {\n+    debug!(\n+        \"get_symbol_hash(def_id={:?}, parameters={:?})\",\n+        def_id, substs\n+    );\n \n-    let mut hasher = ty::util::TypeIdHasher::<u64>::new(tcx);\n+    let mut hasher = StableHasher::<u64>::new();\n+    let mut hcx = tcx.create_stable_hashing_context();\n \n     record_time(&tcx.sess.perf_stats.symbol_hash_time, || {\n         // the main symbol name is not necessarily unique; hash in the\n         // compiler's internal def-path, guaranteeing each symbol has a\n         // truly unique path\n-        hasher.hash(tcx.def_path_hash(def_id));\n+        tcx.def_path_hash(def_id).hash_stable(&mut hcx, &mut hasher);\n \n         // Include the main item-type. Note that, in this case, the\n         // assertions about `needs_subst` may not hold, but this item-type\n         // ought to be the same for every reference anyway.\n         assert!(!item_type.has_erasable_regions());\n-        hasher.visit_ty(item_type);\n+        hcx.while_hashing_spans(false, |hcx| {\n+            hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n+                item_type.hash_stable(hcx, &mut hasher);\n+            });\n+        });\n \n         // If this is a function, we hash the signature as well.\n         // This is not *strictly* needed, but it may help in some\n         // situations, see the `run-make/a-b-a-linker-guard` test.\n         if let ty::TyFnDef(..) = item_type.sty {\n-            item_type.fn_sig(tcx).visit_with(&mut hasher);\n+            item_type.fn_sig(tcx).hash_stable(&mut hcx, &mut hasher);\n         }\n \n         // also include any type parameters (for generic items)\n         assert!(!substs.has_erasable_regions());\n         assert!(!substs.needs_subst());\n-        substs.visit_with(&mut hasher);\n+        substs.hash_stable(&mut hcx, &mut hasher);\n \n         let is_generic = substs.types().next().is_some();\n         let avoid_cross_crate_conflicts =\n@@ -194,52 +204,47 @@ fn get_symbol_hash<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 if !def_id.is_local() && tcx.share_generics() {\n                     // If we are re-using a monomorphization from another crate,\n                     // we have to compute the symbol hash accordingly.\n-                    let upstream_monomorphizations =\n-                        tcx.upstream_monomorphizations_for(def_id);\n+                    let upstream_monomorphizations = tcx.upstream_monomorphizations_for(def_id);\n \n-                    upstream_monomorphizations.and_then(|monos| monos.get(&substs)\n-                                                                     .cloned())\n-                                              .unwrap_or(LOCAL_CRATE)\n+                    upstream_monomorphizations\n+                        .and_then(|monos| monos.get(&substs).cloned())\n+                        .unwrap_or(LOCAL_CRATE)\n                 } else {\n                     LOCAL_CRATE\n                 }\n             } else {\n                 LOCAL_CRATE\n             };\n \n-            hasher.hash(&tcx.original_crate_name(instantiating_crate).as_str()[..]);\n-            hasher.hash(&tcx.crate_disambiguator(instantiating_crate));\n+            (&tcx.original_crate_name(instantiating_crate).as_str()[..])\n+                .hash_stable(&mut hcx, &mut hasher);\n+            (&tcx.crate_disambiguator(instantiating_crate)).hash_stable(&mut hcx, &mut hasher);\n         }\n     });\n \n     // 64 bits should be enough to avoid collisions.\n     hasher.finish()\n }\n \n-fn def_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n-                             -> ty::SymbolName\n-{\n+fn def_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> ty::SymbolName {\n     let mut buffer = SymbolPathBuffer::new();\n     item_path::with_forced_absolute_paths(|| {\n         tcx.push_item_path(&mut buffer, def_id);\n     });\n     buffer.into_interned()\n }\n \n-fn symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance<'tcx>)\n-                         -> ty::SymbolName\n-{\n-    ty::SymbolName { name: Symbol::intern(&compute_symbol_name(tcx, instance)).as_interned_str() }\n+fn symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance<'tcx>) -> ty::SymbolName {\n+    ty::SymbolName {\n+        name: Symbol::intern(&compute_symbol_name(tcx, instance)).as_interned_str(),\n+    }\n }\n \n-fn compute_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance<'tcx>)\n-    -> String\n-{\n+fn compute_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance<'tcx>) -> String {\n     let def_id = instance.def_id();\n     let substs = instance.substs;\n \n-    debug!(\"symbol_name(def_id={:?}, substs={:?})\",\n-           def_id, substs);\n+    debug!(\"symbol_name(def_id={:?}, substs={:?})\", def_id, substs);\n \n     let node_id = tcx.hir.as_local_node_id(def_id);\n \n@@ -259,7 +264,7 @@ fn compute_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance\n     let is_foreign = if let Some(id) = node_id {\n         match tcx.hir.get(id) {\n             hir_map::NodeForeignItem(_) => true,\n-            _ => false\n+            _ => false,\n         }\n     } else {\n         tcx.is_foreign_item(def_id)\n@@ -296,8 +301,7 @@ fn compute_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance\n     loop {\n         let key = tcx.def_key(ty_def_id);\n         match key.disambiguated_data.data {\n-            DefPathData::TypeNs(_) |\n-            DefPathData::ValueNs(_) => {\n+            DefPathData::TypeNs(_) | DefPathData::ValueNs(_) => {\n                 instance_ty = tcx.type_of(ty_def_id);\n                 break;\n             }\n@@ -306,8 +310,12 @@ fn compute_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance\n                 // to be a value or type-def or something in there\n                 // *somewhere*\n                 ty_def_id.index = key.parent.unwrap_or_else(|| {\n-                    bug!(\"finding type for {:?}, encountered def-id {:?} with no \\\n-                          parent\", def_id, ty_def_id);\n+                    bug!(\n+                        \"finding type for {:?}, encountered def-id {:?} with no \\\n+                         parent\",\n+                        def_id,\n+                        ty_def_id\n+                    );\n                 });\n             }\n         }\n@@ -337,14 +345,14 @@ fn compute_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance\n // use C++ name-mangling.\n struct SymbolPathBuffer {\n     result: String,\n-    temp_buf: String\n+    temp_buf: String,\n }\n \n impl SymbolPathBuffer {\n     fn new() -> Self {\n         let mut result = SymbolPathBuffer {\n             result: String::with_capacity(64),\n-            temp_buf: String::with_capacity(16)\n+            temp_buf: String::with_capacity(16),\n         };\n         result.result.push_str(\"_ZN\"); // _Z == Begin name-sequence, N == nested\n         result\n@@ -353,14 +361,16 @@ impl SymbolPathBuffer {\n     fn from_interned(symbol: ty::SymbolName) -> Self {\n         let mut result = SymbolPathBuffer {\n             result: String::with_capacity(64),\n-            temp_buf: String::with_capacity(16)\n+            temp_buf: String::with_capacity(16),\n         };\n         result.result.push_str(&symbol.name.as_str());\n         result\n     }\n \n     fn into_interned(self) -> ty::SymbolName {\n-        ty::SymbolName { name: Symbol::intern(&self.result).as_interned_str() }\n+        ty::SymbolName {\n+            name: Symbol::intern(&self.result).as_interned_str(),\n+        }\n     }\n \n     fn finish(mut self, hash: u64) -> String {\n@@ -379,7 +389,11 @@ impl ItemPathBuffer for SymbolPathBuffer {\n     fn push(&mut self, text: &str) {\n         self.temp_buf.clear();\n         let need_underscore = sanitize(&mut self.temp_buf, text);\n-        let _ = write!(self.result, \"{}\", self.temp_buf.len() + (need_underscore as usize));\n+        let _ = write!(\n+            self.result,\n+            \"{}\",\n+            self.temp_buf.len() + (need_underscore as usize)\n+        );\n         if need_underscore {\n             self.result.push('_');\n         }\n@@ -410,16 +424,13 @@ pub fn sanitize(result: &mut String, s: &str) -> bool {\n             '-' | ':' => result.push('.'),\n \n             // These are legal symbols\n-            'a' ... 'z'\n-            | 'A' ... 'Z'\n-            | '0' ... '9'\n-            | '_' | '.' | '$' => result.push(c),\n+            'a'...'z' | 'A'...'Z' | '0'...'9' | '_' | '.' | '$' => result.push(c),\n \n             _ => {\n                 result.push('$');\n                 for c in c.escape_unicode().skip(1) {\n                     match c {\n-                        '{' => {},\n+                        '{' => {}\n                         '}' => result.push('$'),\n                         c => result.push(c),\n                     }\n@@ -429,7 +440,6 @@ pub fn sanitize(result: &mut String, s: &str) -> bool {\n     }\n \n     // Underscore-qualify anything that didn't start as an ident.\n-    !result.is_empty() &&\n-        result.as_bytes()[0] != '_' as u8 &&\n-        ! (result.as_bytes()[0] as char).is_xid_start()\n+    !result.is_empty() && result.as_bytes()[0] != '_' as u8\n+        && !(result.as_bytes()[0] as char).is_xid_start()\n }"}]}