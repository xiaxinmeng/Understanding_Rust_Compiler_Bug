{"sha": "edddb62099056abae853aa1157919d3ec112eeb4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkZGRiNjIwOTkwNTZhYmFlODUzYWExMTU3OTE5ZDNlYzExMmVlYjQ=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-01-17T21:15:03Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-02-14T22:40:03Z"}, "message": "Split `type_of` out of collect.rs", "tree": {"sha": "c9f0959b9066b3d588fee97526471c93a83443b8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c9f0959b9066b3d588fee97526471c93a83443b8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/edddb62099056abae853aa1157919d3ec112eeb4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/edddb62099056abae853aa1157919d3ec112eeb4", "html_url": "https://github.com/rust-lang/rust/commit/edddb62099056abae853aa1157919d3ec112eeb4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/edddb62099056abae853aa1157919d3ec112eeb4/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "223a2ee3061a4bfe31df8aee70c682618ef28fe1", "url": "https://api.github.com/repos/rust-lang/rust/commits/223a2ee3061a4bfe31df8aee70c682618ef28fe1", "html_url": "https://github.com/rust-lang/rust/commit/223a2ee3061a4bfe31df8aee70c682618ef28fe1"}], "stats": {"total": 1319, "additions": 666, "deletions": 653}, "files": [{"sha": "1a505a39e46379ecd747510a7d276dca845ee846", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 5, "deletions": 653, "changes": 658, "blob_url": "https://github.com/rust-lang/rust/blob/edddb62099056abae853aa1157919d3ec112eeb4/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edddb62099056abae853aa1157919d3ec112eeb4/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=edddb62099056abae853aa1157919d3ec112eeb4", "patch": "@@ -1,5 +1,3 @@\n-// ignore-tidy-filelength\n-\n //! \"Collection\" is the process of determining the type and other external\n //! details of each item in Rust. Collection is specifically concerned\n //! with *inter-procedural* things -- for example, for a function\n@@ -27,18 +25,16 @@ use rustc::hir::map::Map;\n use rustc::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n use rustc::mir::mono::Linkage;\n use rustc::session::parse::feature_err;\n-use rustc::traits;\n use rustc::ty::query::Providers;\n-use rustc::ty::subst::GenericArgKind;\n use rustc::ty::subst::{InternalSubsts, Subst};\n use rustc::ty::util::Discr;\n use rustc::ty::util::IntTypeExt;\n-use rustc::ty::{self, AdtKind, Const, DefIdTree, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable};\n+use rustc::ty::{self, AdtKind, Const, ToPolyTraitRef, Ty, TyCtxt};\n use rustc::ty::{ReprOptions, ToPredicate, WithConstness};\n use rustc_attr::{list_contains_name, mark_used, InlineAttr, OptimizeAttr};\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::{struct_span_err, Applicability, StashKey};\n+use rustc_errors::{struct_span_err, Applicability};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, DefKind, Res};\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n@@ -50,6 +46,8 @@ use rustc_target::spec::abi;\n use syntax::ast;\n use syntax::ast::{Ident, MetaItemKind};\n \n+mod type_of;\n+\n struct OnlySelfBounds(bool);\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -64,7 +62,7 @@ fn collect_mod_item_types(tcx: TyCtxt<'_>, module_def_id: DefId) {\n \n pub fn provide(providers: &mut Providers<'_>) {\n     *providers = Providers {\n-        type_of,\n+        type_of: type_of::type_of,\n         generics_of,\n         predicates_of,\n         predicates_defined_on,\n@@ -1329,652 +1327,6 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n     })\n }\n \n-fn report_assoc_ty_on_inherent_impl(tcx: TyCtxt<'_>, span: Span) {\n-    struct_span_err!(\n-        tcx.sess,\n-        span,\n-        E0202,\n-        \"associated types are not yet supported in inherent impls (see #8995)\"\n-    )\n-    .emit();\n-}\n-\n-fn infer_placeholder_type(\n-    tcx: TyCtxt<'_>,\n-    def_id: DefId,\n-    body_id: hir::BodyId,\n-    span: Span,\n-    item_ident: Ident,\n-) -> Ty<'_> {\n-    let ty = tcx.diagnostic_only_typeck_tables_of(def_id).node_type(body_id.hir_id);\n-\n-    // If this came from a free `const` or `static mut?` item,\n-    // then the user may have written e.g. `const A = 42;`.\n-    // In this case, the parser has stashed a diagnostic for\n-    // us to improve in typeck so we do that now.\n-    match tcx.sess.diagnostic().steal_diagnostic(span, StashKey::ItemNoType) {\n-        Some(mut err) => {\n-            // The parser provided a sub-optimal `HasPlaceholders` suggestion for the type.\n-            // We are typeck and have the real type, so remove that and suggest the actual type.\n-            err.suggestions.clear();\n-            err.span_suggestion(\n-                span,\n-                \"provide a type for the item\",\n-                format!(\"{}: {}\", item_ident, ty),\n-                Applicability::MachineApplicable,\n-            )\n-            .emit();\n-        }\n-        None => {\n-            let mut diag = bad_placeholder_type(tcx, vec![span]);\n-            if ty != tcx.types.err {\n-                diag.span_suggestion(\n-                    span,\n-                    \"replace `_` with the correct type\",\n-                    ty.to_string(),\n-                    Applicability::MaybeIncorrect,\n-                );\n-            }\n-            diag.emit();\n-        }\n-    }\n-\n-    ty\n-}\n-\n-fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n-    use rustc_hir::*;\n-\n-    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-\n-    let icx = ItemCtxt::new(tcx, def_id);\n-\n-    match tcx.hir().get(hir_id) {\n-        Node::TraitItem(item) => match item.kind {\n-            TraitItemKind::Method(..) => {\n-                let substs = InternalSubsts::identity_for_item(tcx, def_id);\n-                tcx.mk_fn_def(def_id, substs)\n-            }\n-            TraitItemKind::Const(ref ty, body_id) => body_id\n-                .and_then(|body_id| {\n-                    if is_suggestable_infer_ty(ty) {\n-                        Some(infer_placeholder_type(tcx, def_id, body_id, ty.span, item.ident))\n-                    } else {\n-                        None\n-                    }\n-                })\n-                .unwrap_or_else(|| icx.to_ty(ty)),\n-            TraitItemKind::Type(_, Some(ref ty)) => icx.to_ty(ty),\n-            TraitItemKind::Type(_, None) => {\n-                span_bug!(item.span, \"associated type missing default\");\n-            }\n-        },\n-\n-        Node::ImplItem(item) => match item.kind {\n-            ImplItemKind::Method(..) => {\n-                let substs = InternalSubsts::identity_for_item(tcx, def_id);\n-                tcx.mk_fn_def(def_id, substs)\n-            }\n-            ImplItemKind::Const(ref ty, body_id) => {\n-                if is_suggestable_infer_ty(ty) {\n-                    infer_placeholder_type(tcx, def_id, body_id, ty.span, item.ident)\n-                } else {\n-                    icx.to_ty(ty)\n-                }\n-            }\n-            ImplItemKind::OpaqueTy(_) => {\n-                if tcx.impl_trait_ref(tcx.hir().get_parent_did(hir_id)).is_none() {\n-                    report_assoc_ty_on_inherent_impl(tcx, item.span);\n-                }\n-\n-                find_opaque_ty_constraints(tcx, def_id)\n-            }\n-            ImplItemKind::TyAlias(ref ty) => {\n-                if tcx.impl_trait_ref(tcx.hir().get_parent_did(hir_id)).is_none() {\n-                    report_assoc_ty_on_inherent_impl(tcx, item.span);\n-                }\n-\n-                icx.to_ty(ty)\n-            }\n-        },\n-\n-        Node::Item(item) => {\n-            match item.kind {\n-                ItemKind::Static(ref ty, .., body_id) | ItemKind::Const(ref ty, body_id) => {\n-                    if is_suggestable_infer_ty(ty) {\n-                        infer_placeholder_type(tcx, def_id, body_id, ty.span, item.ident)\n-                    } else {\n-                        icx.to_ty(ty)\n-                    }\n-                }\n-                ItemKind::TyAlias(ref self_ty, _) | ItemKind::Impl { ref self_ty, .. } => {\n-                    icx.to_ty(self_ty)\n-                }\n-                ItemKind::Fn(..) => {\n-                    let substs = InternalSubsts::identity_for_item(tcx, def_id);\n-                    tcx.mk_fn_def(def_id, substs)\n-                }\n-                ItemKind::Enum(..) | ItemKind::Struct(..) | ItemKind::Union(..) => {\n-                    let def = tcx.adt_def(def_id);\n-                    let substs = InternalSubsts::identity_for_item(tcx, def_id);\n-                    tcx.mk_adt(def, substs)\n-                }\n-                ItemKind::OpaqueTy(hir::OpaqueTy { impl_trait_fn: None, .. }) => {\n-                    find_opaque_ty_constraints(tcx, def_id)\n-                }\n-                // Opaque types desugared from `impl Trait`.\n-                ItemKind::OpaqueTy(hir::OpaqueTy {\n-                    impl_trait_fn: Some(owner), origin, ..\n-                }) => {\n-                    let concrete_types = match origin {\n-                        hir::OpaqueTyOrigin::FnReturn | hir::OpaqueTyOrigin::AsyncFn => {\n-                            &tcx.mir_borrowck(owner).concrete_opaque_types\n-                        }\n-                        hir::OpaqueTyOrigin::Misc => {\n-                            // We shouldn't leak borrowck results through impl trait in bindings.\n-                            // For example, we shouldn't be able to tell if `x` in\n-                            // `let x: impl Sized + 'a = &()` has type `&'static ()` or `&'a ()`.\n-                            &tcx.typeck_tables_of(owner).concrete_opaque_types\n-                        }\n-                        hir::OpaqueTyOrigin::TypeAlias => {\n-                            span_bug!(item.span, \"Type alias impl trait shouldn't have an owner\")\n-                        }\n-                    };\n-                    let concrete_ty = concrete_types\n-                        .get(&def_id)\n-                        .map(|opaque| opaque.concrete_type)\n-                        .unwrap_or_else(|| {\n-                            tcx.sess.delay_span_bug(\n-                                DUMMY_SP,\n-                                &format!(\n-                                    \"owner {:?} has no opaque type for {:?} in its tables\",\n-                                    owner, def_id,\n-                                ),\n-                            );\n-                            if tcx.typeck_tables_of(owner).tainted_by_errors {\n-                                // Some error in the\n-                                // owner fn prevented us from populating\n-                                // the `concrete_opaque_types` table.\n-                                tcx.types.err\n-                            } else {\n-                                // We failed to resolve the opaque type or it\n-                                // resolves to itself. Return the non-revealed\n-                                // type, which should result in E0720.\n-                                tcx.mk_opaque(\n-                                    def_id,\n-                                    InternalSubsts::identity_for_item(tcx, def_id),\n-                                )\n-                            }\n-                        });\n-                    debug!(\"concrete_ty = {:?}\", concrete_ty);\n-                    if concrete_ty.has_erased_regions() {\n-                        // FIXME(impl_trait_in_bindings) Handle this case.\n-                        tcx.sess.span_fatal(\n-                            item.span,\n-                            \"lifetimes in impl Trait types in bindings are not currently supported\",\n-                        );\n-                    }\n-                    concrete_ty\n-                }\n-                ItemKind::Trait(..)\n-                | ItemKind::TraitAlias(..)\n-                | ItemKind::Mod(..)\n-                | ItemKind::ForeignMod(..)\n-                | ItemKind::GlobalAsm(..)\n-                | ItemKind::ExternCrate(..)\n-                | ItemKind::Use(..) => {\n-                    span_bug!(\n-                        item.span,\n-                        \"compute_type_of_item: unexpected item type: {:?}\",\n-                        item.kind\n-                    );\n-                }\n-            }\n-        }\n-\n-        Node::ForeignItem(foreign_item) => match foreign_item.kind {\n-            ForeignItemKind::Fn(..) => {\n-                let substs = InternalSubsts::identity_for_item(tcx, def_id);\n-                tcx.mk_fn_def(def_id, substs)\n-            }\n-            ForeignItemKind::Static(ref t, _) => icx.to_ty(t),\n-            ForeignItemKind::Type => tcx.mk_foreign(def_id),\n-        },\n-\n-        Node::Ctor(&ref def) | Node::Variant(hir::Variant { data: ref def, .. }) => match *def {\n-            VariantData::Unit(..) | VariantData::Struct(..) => {\n-                tcx.type_of(tcx.hir().get_parent_did(hir_id))\n-            }\n-            VariantData::Tuple(..) => {\n-                let substs = InternalSubsts::identity_for_item(tcx, def_id);\n-                tcx.mk_fn_def(def_id, substs)\n-            }\n-        },\n-\n-        Node::Field(field) => icx.to_ty(&field.ty),\n-\n-        Node::Expr(&hir::Expr { kind: hir::ExprKind::Closure(.., gen), .. }) => {\n-            if gen.is_some() {\n-                return tcx.typeck_tables_of(def_id).node_type(hir_id);\n-            }\n-\n-            let substs = InternalSubsts::identity_for_item(tcx, def_id);\n-            tcx.mk_closure(def_id, substs)\n-        }\n-\n-        Node::AnonConst(_) => {\n-            let parent_node = tcx.hir().get(tcx.hir().get_parent_node(hir_id));\n-            match parent_node {\n-                Node::Ty(&hir::Ty { kind: hir::TyKind::Array(_, ref constant), .. })\n-                | Node::Ty(&hir::Ty { kind: hir::TyKind::Typeof(ref constant), .. })\n-                | Node::Expr(&hir::Expr { kind: ExprKind::Repeat(_, ref constant), .. })\n-                    if constant.hir_id == hir_id =>\n-                {\n-                    tcx.types.usize\n-                }\n-\n-                Node::Variant(Variant { disr_expr: Some(ref e), .. }) if e.hir_id == hir_id => {\n-                    tcx.adt_def(tcx.hir().get_parent_did(hir_id)).repr.discr_type().to_ty(tcx)\n-                }\n-\n-                Node::Ty(&hir::Ty { kind: hir::TyKind::Path(_), .. })\n-                | Node::Expr(&hir::Expr { kind: ExprKind::Struct(..), .. })\n-                | Node::Expr(&hir::Expr { kind: ExprKind::Path(_), .. })\n-                | Node::TraitRef(..) => {\n-                    let path = match parent_node {\n-                        Node::Ty(&hir::Ty {\n-                            kind: hir::TyKind::Path(QPath::Resolved(_, ref path)),\n-                            ..\n-                        })\n-                        | Node::Expr(&hir::Expr {\n-                            kind: ExprKind::Path(QPath::Resolved(_, ref path)),\n-                            ..\n-                        }) => Some(&**path),\n-                        Node::Expr(&hir::Expr { kind: ExprKind::Struct(ref path, ..), .. }) => {\n-                            if let QPath::Resolved(_, ref path) = **path {\n-                                Some(&**path)\n-                            } else {\n-                                None\n-                            }\n-                        }\n-                        Node::TraitRef(&hir::TraitRef { ref path, .. }) => Some(&**path),\n-                        _ => None,\n-                    };\n-\n-                    if let Some(path) = path {\n-                        let arg_index = path\n-                            .segments\n-                            .iter()\n-                            .filter_map(|seg| seg.args.as_ref())\n-                            .map(|generic_args| generic_args.args.as_ref())\n-                            .find_map(|args| {\n-                                args.iter()\n-                                    .filter(|arg| arg.is_const())\n-                                    .enumerate()\n-                                    .filter(|(_, arg)| arg.id() == hir_id)\n-                                    .map(|(index, _)| index)\n-                                    .next()\n-                            })\n-                            .unwrap_or_else(|| {\n-                                bug!(\"no arg matching AnonConst in path\");\n-                            });\n-\n-                        // We've encountered an `AnonConst` in some path, so we need to\n-                        // figure out which generic parameter it corresponds to and return\n-                        // the relevant type.\n-                        let generics = match path.res {\n-                            Res::Def(DefKind::Ctor(..), def_id) => {\n-                                tcx.generics_of(tcx.parent(def_id).unwrap())\n-                            }\n-                            Res::Def(_, def_id) => tcx.generics_of(def_id),\n-                            Res::Err => return tcx.types.err,\n-                            res => {\n-                                tcx.sess.delay_span_bug(\n-                                    DUMMY_SP,\n-                                    &format!(\"unexpected const parent path def {:?}\", res,),\n-                                );\n-                                return tcx.types.err;\n-                            }\n-                        };\n-\n-                        generics\n-                            .params\n-                            .iter()\n-                            .filter(|param| {\n-                                if let ty::GenericParamDefKind::Const = param.kind {\n-                                    true\n-                                } else {\n-                                    false\n-                                }\n-                            })\n-                            .nth(arg_index)\n-                            .map(|param| tcx.type_of(param.def_id))\n-                            // This is no generic parameter associated with the arg. This is\n-                            // probably from an extra arg where one is not needed.\n-                            .unwrap_or(tcx.types.err)\n-                    } else {\n-                        tcx.sess.delay_span_bug(\n-                            DUMMY_SP,\n-                            &format!(\"unexpected const parent path {:?}\", parent_node,),\n-                        );\n-                        return tcx.types.err;\n-                    }\n-                }\n-\n-                x => {\n-                    tcx.sess.delay_span_bug(\n-                        DUMMY_SP,\n-                        &format!(\"unexpected const parent in type_of_def_id(): {:?}\", x),\n-                    );\n-                    tcx.types.err\n-                }\n-            }\n-        }\n-\n-        Node::GenericParam(param) => match &param.kind {\n-            hir::GenericParamKind::Type { default: Some(ref ty), .. } => icx.to_ty(ty),\n-            hir::GenericParamKind::Const { ty: ref hir_ty, .. } => {\n-                let ty = icx.to_ty(hir_ty);\n-                if !tcx.features().const_compare_raw_pointers {\n-                    let err = match ty.peel_refs().kind {\n-                        ty::FnPtr(_) => Some(\"function pointers\"),\n-                        ty::RawPtr(_) => Some(\"raw pointers\"),\n-                        _ => None,\n-                    };\n-                    if let Some(unsupported_type) = err {\n-                        feature_err(\n-                            &tcx.sess.parse_sess,\n-                            sym::const_compare_raw_pointers,\n-                            hir_ty.span,\n-                            &format!(\n-                                \"using {} as const generic parameters is unstable\",\n-                                unsupported_type\n-                            ),\n-                        )\n-                        .emit();\n-                    };\n-                }\n-                if traits::search_for_structural_match_violation(param.hir_id, param.span, tcx, ty)\n-                    .is_some()\n-                {\n-                    struct_span_err!(\n-                        tcx.sess,\n-                        hir_ty.span,\n-                        E0741,\n-                        \"the types of const generic parameters must derive `PartialEq` and `Eq`\",\n-                    )\n-                    .span_label(\n-                        hir_ty.span,\n-                        format!(\"`{}` doesn't derive both `PartialEq` and `Eq`\", ty),\n-                    )\n-                    .emit();\n-                }\n-                ty\n-            }\n-            x => bug!(\"unexpected non-type Node::GenericParam: {:?}\", x),\n-        },\n-\n-        x => {\n-            bug!(\"unexpected sort of node in type_of_def_id(): {:?}\", x);\n-        }\n-    }\n-}\n-\n-fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n-    use rustc_hir::{Expr, ImplItem, Item, TraitItem};\n-\n-    debug!(\"find_opaque_ty_constraints({:?})\", def_id);\n-\n-    struct ConstraintLocator<'tcx> {\n-        tcx: TyCtxt<'tcx>,\n-        def_id: DefId,\n-        // (first found type span, actual type, mapping from the opaque type's generic\n-        // parameters to the concrete type's generic parameters)\n-        //\n-        // The mapping is an index for each use site of a generic parameter in the concrete type\n-        //\n-        // The indices index into the generic parameters on the opaque type.\n-        found: Option<(Span, Ty<'tcx>, Vec<usize>)>,\n-    }\n-\n-    impl ConstraintLocator<'tcx> {\n-        fn check(&mut self, def_id: DefId) {\n-            // Don't try to check items that cannot possibly constrain the type.\n-            if !self.tcx.has_typeck_tables(def_id) {\n-                debug!(\n-                    \"find_opaque_ty_constraints: no constraint for `{:?}` at `{:?}`: no tables\",\n-                    self.def_id, def_id,\n-                );\n-                return;\n-            }\n-            // Calling `mir_borrowck` can lead to cycle errors through\n-            // const-checking, avoid calling it if we don't have to.\n-            if !self.tcx.typeck_tables_of(def_id).concrete_opaque_types.contains_key(&self.def_id) {\n-                debug!(\n-                    \"find_opaque_ty_constraints: no constraint for `{:?}` at `{:?}`\",\n-                    self.def_id, def_id,\n-                );\n-                return;\n-            }\n-            // Use borrowck to get the type with unerased regions.\n-            let ty = self.tcx.mir_borrowck(def_id).concrete_opaque_types.get(&self.def_id);\n-            if let Some(ty::ResolvedOpaqueTy { concrete_type, substs }) = ty {\n-                debug!(\n-                    \"find_opaque_ty_constraints: found constraint for `{:?}` at `{:?}`: {:?}\",\n-                    self.def_id, def_id, ty,\n-                );\n-\n-                // FIXME(oli-obk): trace the actual span from inference to improve errors.\n-                let span = self.tcx.def_span(def_id);\n-                // used to quickly look up the position of a generic parameter\n-                let mut index_map: FxHashMap<ty::ParamTy, usize> = FxHashMap::default();\n-                // Skipping binder is ok, since we only use this to find generic parameters and\n-                // their positions.\n-                for (idx, subst) in substs.iter().enumerate() {\n-                    if let GenericArgKind::Type(ty) = subst.unpack() {\n-                        if let ty::Param(p) = ty.kind {\n-                            if index_map.insert(p, idx).is_some() {\n-                                // There was already an entry for `p`, meaning a generic parameter\n-                                // was used twice.\n-                                self.tcx.sess.span_err(\n-                                    span,\n-                                    &format!(\n-                                        \"defining opaque type use restricts opaque \\\n-                                         type by using the generic parameter `{}` twice\",\n-                                        p,\n-                                    ),\n-                                );\n-                                return;\n-                            }\n-                        } else {\n-                            self.tcx.sess.delay_span_bug(\n-                                span,\n-                                &format!(\n-                                    \"non-defining opaque ty use in defining scope: {:?}, {:?}\",\n-                                    concrete_type, substs,\n-                                ),\n-                            );\n-                        }\n-                    }\n-                }\n-                // Compute the index within the opaque type for each generic parameter used in\n-                // the concrete type.\n-                let indices = concrete_type\n-                    .subst(self.tcx, substs)\n-                    .walk()\n-                    .filter_map(|t| match &t.kind {\n-                        ty::Param(p) => Some(*index_map.get(p).unwrap()),\n-                        _ => None,\n-                    })\n-                    .collect();\n-                let is_param = |ty: Ty<'_>| match ty.kind {\n-                    ty::Param(_) => true,\n-                    _ => false,\n-                };\n-                let bad_substs: Vec<_> = substs\n-                    .iter()\n-                    .enumerate()\n-                    .filter_map(|(i, k)| {\n-                        if let GenericArgKind::Type(ty) = k.unpack() { Some((i, ty)) } else { None }\n-                    })\n-                    .filter(|(_, ty)| !is_param(ty))\n-                    .collect();\n-\n-                if !bad_substs.is_empty() {\n-                    let identity_substs = InternalSubsts::identity_for_item(self.tcx, self.def_id);\n-                    for (i, bad_subst) in bad_substs {\n-                        self.tcx.sess.span_err(\n-                            span,\n-                            &format!(\n-                                \"defining opaque type use does not fully define opaque type: \\\n-                            generic parameter `{}` is specified as concrete type `{}`\",\n-                                identity_substs.type_at(i),\n-                                bad_subst\n-                            ),\n-                        );\n-                    }\n-                } else if let Some((prev_span, prev_ty, ref prev_indices)) = self.found {\n-                    let mut ty = concrete_type.walk().fuse();\n-                    let mut p_ty = prev_ty.walk().fuse();\n-                    let iter_eq = (&mut ty).zip(&mut p_ty).all(|(t, p)| match (&t.kind, &p.kind) {\n-                        // Type parameters are equal to any other type parameter for the purpose of\n-                        // concrete type equality, as it is possible to obtain the same type just\n-                        // by passing matching parameters to a function.\n-                        (ty::Param(_), ty::Param(_)) => true,\n-                        _ => t == p,\n-                    });\n-                    if !iter_eq || ty.next().is_some() || p_ty.next().is_some() {\n-                        debug!(\"find_opaque_ty_constraints: span={:?}\", span);\n-                        // Found different concrete types for the opaque type.\n-                        let mut err = self.tcx.sess.struct_span_err(\n-                            span,\n-                            \"concrete type differs from previous defining opaque type use\",\n-                        );\n-                        err.span_label(\n-                            span,\n-                            format!(\"expected `{}`, got `{}`\", prev_ty, concrete_type),\n-                        );\n-                        err.span_note(prev_span, \"previous use here\");\n-                        err.emit();\n-                    } else if indices != *prev_indices {\n-                        // Found \"same\" concrete types, but the generic parameter order differs.\n-                        let mut err = self.tcx.sess.struct_span_err(\n-                            span,\n-                            \"concrete type's generic parameters differ from previous defining use\",\n-                        );\n-                        use std::fmt::Write;\n-                        let mut s = String::new();\n-                        write!(s, \"expected [\").unwrap();\n-                        let list = |s: &mut String, indices: &Vec<usize>| {\n-                            let mut indices = indices.iter().cloned();\n-                            if let Some(first) = indices.next() {\n-                                write!(s, \"`{}`\", substs[first]).unwrap();\n-                                for i in indices {\n-                                    write!(s, \", `{}`\", substs[i]).unwrap();\n-                                }\n-                            }\n-                        };\n-                        list(&mut s, prev_indices);\n-                        write!(s, \"], got [\").unwrap();\n-                        list(&mut s, &indices);\n-                        write!(s, \"]\").unwrap();\n-                        err.span_label(span, s);\n-                        err.span_note(prev_span, \"previous use here\");\n-                        err.emit();\n-                    }\n-                } else {\n-                    self.found = Some((span, concrete_type, indices));\n-                }\n-            } else {\n-                debug!(\n-                    \"find_opaque_ty_constraints: no constraint for `{:?}` at `{:?}`\",\n-                    self.def_id, def_id,\n-                );\n-            }\n-        }\n-    }\n-\n-    impl<'tcx> intravisit::Visitor<'tcx> for ConstraintLocator<'tcx> {\n-        type Map = Map<'tcx>;\n-\n-        fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<'_, Self::Map> {\n-            intravisit::NestedVisitorMap::All(&self.tcx.hir())\n-        }\n-        fn visit_expr(&mut self, ex: &'tcx Expr<'tcx>) {\n-            if let hir::ExprKind::Closure(..) = ex.kind {\n-                let def_id = self.tcx.hir().local_def_id(ex.hir_id);\n-                self.check(def_id);\n-            }\n-            intravisit::walk_expr(self, ex);\n-        }\n-        fn visit_item(&mut self, it: &'tcx Item<'tcx>) {\n-            debug!(\"find_existential_constraints: visiting {:?}\", it);\n-            let def_id = self.tcx.hir().local_def_id(it.hir_id);\n-            // The opaque type itself or its children are not within its reveal scope.\n-            if def_id != self.def_id {\n-                self.check(def_id);\n-                intravisit::walk_item(self, it);\n-            }\n-        }\n-        fn visit_impl_item(&mut self, it: &'tcx ImplItem<'tcx>) {\n-            debug!(\"find_existential_constraints: visiting {:?}\", it);\n-            let def_id = self.tcx.hir().local_def_id(it.hir_id);\n-            // The opaque type itself or its children are not within its reveal scope.\n-            if def_id != self.def_id {\n-                self.check(def_id);\n-                intravisit::walk_impl_item(self, it);\n-            }\n-        }\n-        fn visit_trait_item(&mut self, it: &'tcx TraitItem<'tcx>) {\n-            debug!(\"find_existential_constraints: visiting {:?}\", it);\n-            let def_id = self.tcx.hir().local_def_id(it.hir_id);\n-            self.check(def_id);\n-            intravisit::walk_trait_item(self, it);\n-        }\n-    }\n-\n-    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-    let scope = tcx.hir().get_defining_scope(hir_id);\n-    let mut locator = ConstraintLocator { def_id, tcx, found: None };\n-\n-    debug!(\"find_opaque_ty_constraints: scope={:?}\", scope);\n-\n-    if scope == hir::CRATE_HIR_ID {\n-        intravisit::walk_crate(&mut locator, tcx.hir().krate());\n-    } else {\n-        debug!(\"find_opaque_ty_constraints: scope={:?}\", tcx.hir().get(scope));\n-        match tcx.hir().get(scope) {\n-            // We explicitly call `visit_*` methods, instead of using `intravisit::walk_*` methods\n-            // This allows our visitor to process the defining item itself, causing\n-            // it to pick up any 'sibling' defining uses.\n-            //\n-            // For example, this code:\n-            // ```\n-            // fn foo() {\n-            //     type Blah = impl Debug;\n-            //     let my_closure = || -> Blah { true };\n-            // }\n-            // ```\n-            //\n-            // requires us to explicitly process `foo()` in order\n-            // to notice the defining usage of `Blah`.\n-            Node::Item(ref it) => locator.visit_item(it),\n-            Node::ImplItem(ref it) => locator.visit_impl_item(it),\n-            Node::TraitItem(ref it) => locator.visit_trait_item(it),\n-            other => bug!(\"{:?} is not a valid scope for an opaque type item\", other),\n-        }\n-    }\n-\n-    match locator.found {\n-        Some((_, ty, _)) => ty,\n-        None => {\n-            let span = tcx.def_span(def_id);\n-            tcx.sess.span_err(span, \"could not find defining uses\");\n-            tcx.types.err\n-        }\n-    }\n-}\n-\n fn are_suggestable_generic_args(generic_args: &[hir::GenericArg<'_>]) -> bool {\n     generic_args\n         .iter()"}, {"sha": "8b6dba749a6ef2633c7fac1da443a4e8192af01a", "filename": "src/librustc_typeck/collect/type_of.rs", "status": "added", "additions": 661, "deletions": 0, "changes": 661, "blob_url": "https://github.com/rust-lang/rust/blob/edddb62099056abae853aa1157919d3ec112eeb4/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edddb62099056abae853aa1157919d3ec112eeb4/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs?ref=edddb62099056abae853aa1157919d3ec112eeb4", "patch": "@@ -0,0 +1,661 @@\n+use rustc::hir::map::Map;\n+use rustc::session::parse::feature_err;\n+use rustc::traits;\n+use rustc::ty::subst::{GenericArgKind, InternalSubsts, Subst};\n+use rustc::ty::util::IntTypeExt;\n+use rustc::ty::{self, DefIdTree, Ty, TyCtxt, TypeFoldable};\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_errors::{struct_span_err, Applicability, StashKey};\n+use rustc_hir as hir;\n+use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::intravisit;\n+use rustc_hir::intravisit::Visitor;\n+use rustc_hir::Node;\n+use rustc_span::symbol::{sym, Ident};\n+use rustc_span::{Span, DUMMY_SP};\n+\n+use super::ItemCtxt;\n+use super::{bad_placeholder_type, is_suggestable_infer_ty};\n+\n+pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n+    use rustc_hir::*;\n+\n+    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+\n+    let icx = ItemCtxt::new(tcx, def_id);\n+\n+    match tcx.hir().get(hir_id) {\n+        Node::TraitItem(item) => match item.kind {\n+            TraitItemKind::Method(..) => {\n+                let substs = InternalSubsts::identity_for_item(tcx, def_id);\n+                tcx.mk_fn_def(def_id, substs)\n+            }\n+            TraitItemKind::Const(ref ty, body_id) => body_id\n+                .and_then(|body_id| {\n+                    if is_suggestable_infer_ty(ty) {\n+                        Some(infer_placeholder_type(tcx, def_id, body_id, ty.span, item.ident))\n+                    } else {\n+                        None\n+                    }\n+                })\n+                .unwrap_or_else(|| icx.to_ty(ty)),\n+            TraitItemKind::Type(_, Some(ref ty)) => icx.to_ty(ty),\n+            TraitItemKind::Type(_, None) => {\n+                span_bug!(item.span, \"associated type missing default\");\n+            }\n+        },\n+\n+        Node::ImplItem(item) => match item.kind {\n+            ImplItemKind::Method(..) => {\n+                let substs = InternalSubsts::identity_for_item(tcx, def_id);\n+                tcx.mk_fn_def(def_id, substs)\n+            }\n+            ImplItemKind::Const(ref ty, body_id) => {\n+                if is_suggestable_infer_ty(ty) {\n+                    infer_placeholder_type(tcx, def_id, body_id, ty.span, item.ident)\n+                } else {\n+                    icx.to_ty(ty)\n+                }\n+            }\n+            ImplItemKind::OpaqueTy(_) => {\n+                if tcx.impl_trait_ref(tcx.hir().get_parent_did(hir_id)).is_none() {\n+                    report_assoc_ty_on_inherent_impl(tcx, item.span);\n+                }\n+\n+                find_opaque_ty_constraints(tcx, def_id)\n+            }\n+            ImplItemKind::TyAlias(ref ty) => {\n+                if tcx.impl_trait_ref(tcx.hir().get_parent_did(hir_id)).is_none() {\n+                    report_assoc_ty_on_inherent_impl(tcx, item.span);\n+                }\n+\n+                icx.to_ty(ty)\n+            }\n+        },\n+\n+        Node::Item(item) => {\n+            match item.kind {\n+                ItemKind::Static(ref ty, .., body_id) | ItemKind::Const(ref ty, body_id) => {\n+                    if is_suggestable_infer_ty(ty) {\n+                        infer_placeholder_type(tcx, def_id, body_id, ty.span, item.ident)\n+                    } else {\n+                        icx.to_ty(ty)\n+                    }\n+                }\n+                ItemKind::TyAlias(ref self_ty, _) | ItemKind::Impl { ref self_ty, .. } => {\n+                    icx.to_ty(self_ty)\n+                }\n+                ItemKind::Fn(..) => {\n+                    let substs = InternalSubsts::identity_for_item(tcx, def_id);\n+                    tcx.mk_fn_def(def_id, substs)\n+                }\n+                ItemKind::Enum(..) | ItemKind::Struct(..) | ItemKind::Union(..) => {\n+                    let def = tcx.adt_def(def_id);\n+                    let substs = InternalSubsts::identity_for_item(tcx, def_id);\n+                    tcx.mk_adt(def, substs)\n+                }\n+                ItemKind::OpaqueTy(OpaqueTy { impl_trait_fn: None, .. }) => {\n+                    find_opaque_ty_constraints(tcx, def_id)\n+                }\n+                // Opaque types desugared from `impl Trait`.\n+                ItemKind::OpaqueTy(OpaqueTy { impl_trait_fn: Some(owner), origin, .. }) => {\n+                    let concrete_types = match origin {\n+                        OpaqueTyOrigin::FnReturn | OpaqueTyOrigin::AsyncFn => {\n+                            &tcx.mir_borrowck(owner).concrete_opaque_types\n+                        }\n+                        OpaqueTyOrigin::Misc => {\n+                            // We shouldn't leak borrowck results through impl trait in bindings.\n+                            // For example, we shouldn't be able to tell if `x` in\n+                            // `let x: impl Sized + 'a = &()` has type `&'static ()` or `&'a ()`.\n+                            &tcx.typeck_tables_of(owner).concrete_opaque_types\n+                        }\n+                        OpaqueTyOrigin::TypeAlias => {\n+                            span_bug!(item.span, \"Type alias impl trait shouldn't have an owner\")\n+                        }\n+                    };\n+                    let concrete_ty = concrete_types\n+                        .get(&def_id)\n+                        .map(|opaque| opaque.concrete_type)\n+                        .unwrap_or_else(|| {\n+                            tcx.sess.delay_span_bug(\n+                                DUMMY_SP,\n+                                &format!(\n+                                    \"owner {:?} has no opaque type for {:?} in its tables\",\n+                                    owner, def_id,\n+                                ),\n+                            );\n+                            if tcx.typeck_tables_of(owner).tainted_by_errors {\n+                                // Some error in the\n+                                // owner fn prevented us from populating\n+                                // the `concrete_opaque_types` table.\n+                                tcx.types.err\n+                            } else {\n+                                // We failed to resolve the opaque type or it\n+                                // resolves to itself. Return the non-revealed\n+                                // type, which should result in E0720.\n+                                tcx.mk_opaque(\n+                                    def_id,\n+                                    InternalSubsts::identity_for_item(tcx, def_id),\n+                                )\n+                            }\n+                        });\n+                    debug!(\"concrete_ty = {:?}\", concrete_ty);\n+                    if concrete_ty.has_erased_regions() {\n+                        // FIXME(impl_trait_in_bindings) Handle this case.\n+                        tcx.sess.span_fatal(\n+                            item.span,\n+                            \"lifetimes in impl Trait types in bindings are not currently supported\",\n+                        );\n+                    }\n+                    concrete_ty\n+                }\n+                ItemKind::Trait(..)\n+                | ItemKind::TraitAlias(..)\n+                | ItemKind::Mod(..)\n+                | ItemKind::ForeignMod(..)\n+                | ItemKind::GlobalAsm(..)\n+                | ItemKind::ExternCrate(..)\n+                | ItemKind::Use(..) => {\n+                    span_bug!(\n+                        item.span,\n+                        \"compute_type_of_item: unexpected item type: {:?}\",\n+                        item.kind\n+                    );\n+                }\n+            }\n+        }\n+\n+        Node::ForeignItem(foreign_item) => match foreign_item.kind {\n+            ForeignItemKind::Fn(..) => {\n+                let substs = InternalSubsts::identity_for_item(tcx, def_id);\n+                tcx.mk_fn_def(def_id, substs)\n+            }\n+            ForeignItemKind::Static(ref t, _) => icx.to_ty(t),\n+            ForeignItemKind::Type => tcx.mk_foreign(def_id),\n+        },\n+\n+        Node::Ctor(&ref def) | Node::Variant(Variant { data: ref def, .. }) => match *def {\n+            VariantData::Unit(..) | VariantData::Struct(..) => {\n+                tcx.type_of(tcx.hir().get_parent_did(hir_id))\n+            }\n+            VariantData::Tuple(..) => {\n+                let substs = InternalSubsts::identity_for_item(tcx, def_id);\n+                tcx.mk_fn_def(def_id, substs)\n+            }\n+        },\n+\n+        Node::Field(field) => icx.to_ty(&field.ty),\n+\n+        Node::Expr(&Expr { kind: ExprKind::Closure(.., gen), .. }) => {\n+            if gen.is_some() {\n+                return tcx.typeck_tables_of(def_id).node_type(hir_id);\n+            }\n+\n+            let substs = InternalSubsts::identity_for_item(tcx, def_id);\n+            tcx.mk_closure(def_id, substs)\n+        }\n+\n+        Node::AnonConst(_) => {\n+            let parent_node = tcx.hir().get(tcx.hir().get_parent_node(hir_id));\n+            match parent_node {\n+                Node::Ty(&Ty { kind: TyKind::Array(_, ref constant), .. })\n+                | Node::Ty(&Ty { kind: TyKind::Typeof(ref constant), .. })\n+                | Node::Expr(&Expr { kind: ExprKind::Repeat(_, ref constant), .. })\n+                    if constant.hir_id == hir_id =>\n+                {\n+                    tcx.types.usize\n+                }\n+\n+                Node::Variant(Variant { disr_expr: Some(ref e), .. }) if e.hir_id == hir_id => {\n+                    tcx.adt_def(tcx.hir().get_parent_did(hir_id)).repr.discr_type().to_ty(tcx)\n+                }\n+\n+                Node::Ty(&Ty { kind: TyKind::Path(_), .. })\n+                | Node::Expr(&Expr { kind: ExprKind::Struct(..), .. })\n+                | Node::Expr(&Expr { kind: ExprKind::Path(_), .. })\n+                | Node::TraitRef(..) => {\n+                    let path = match parent_node {\n+                        Node::Ty(&Ty {\n+                            kind: TyKind::Path(QPath::Resolved(_, ref path)), ..\n+                        })\n+                        | Node::Expr(&Expr {\n+                            kind: ExprKind::Path(QPath::Resolved(_, ref path)),\n+                            ..\n+                        }) => Some(&**path),\n+                        Node::Expr(&Expr { kind: ExprKind::Struct(ref path, ..), .. }) => {\n+                            if let QPath::Resolved(_, ref path) = **path {\n+                                Some(&**path)\n+                            } else {\n+                                None\n+                            }\n+                        }\n+                        Node::TraitRef(&TraitRef { ref path, .. }) => Some(&**path),\n+                        _ => None,\n+                    };\n+\n+                    if let Some(path) = path {\n+                        let arg_index = path\n+                            .segments\n+                            .iter()\n+                            .filter_map(|seg| seg.args.as_ref())\n+                            .map(|generic_args| generic_args.args.as_ref())\n+                            .find_map(|args| {\n+                                args.iter()\n+                                    .filter(|arg| arg.is_const())\n+                                    .enumerate()\n+                                    .filter(|(_, arg)| arg.id() == hir_id)\n+                                    .map(|(index, _)| index)\n+                                    .next()\n+                            })\n+                            .unwrap_or_else(|| {\n+                                bug!(\"no arg matching AnonConst in path\");\n+                            });\n+\n+                        // We've encountered an `AnonConst` in some path, so we need to\n+                        // figure out which generic parameter it corresponds to and return\n+                        // the relevant type.\n+                        let generics = match path.res {\n+                            Res::Def(DefKind::Ctor(..), def_id) => {\n+                                tcx.generics_of(tcx.parent(def_id).unwrap())\n+                            }\n+                            Res::Def(_, def_id) => tcx.generics_of(def_id),\n+                            Res::Err => return tcx.types.err,\n+                            res => {\n+                                tcx.sess.delay_span_bug(\n+                                    DUMMY_SP,\n+                                    &format!(\"unexpected const parent path def {:?}\", res,),\n+                                );\n+                                return tcx.types.err;\n+                            }\n+                        };\n+\n+                        generics\n+                            .params\n+                            .iter()\n+                            .filter(|param| {\n+                                if let ty::GenericParamDefKind::Const = param.kind {\n+                                    true\n+                                } else {\n+                                    false\n+                                }\n+                            })\n+                            .nth(arg_index)\n+                            .map(|param| tcx.type_of(param.def_id))\n+                            // This is no generic parameter associated with the arg. This is\n+                            // probably from an extra arg where one is not needed.\n+                            .unwrap_or(tcx.types.err)\n+                    } else {\n+                        tcx.sess.delay_span_bug(\n+                            DUMMY_SP,\n+                            &format!(\"unexpected const parent path {:?}\", parent_node,),\n+                        );\n+                        return tcx.types.err;\n+                    }\n+                }\n+\n+                x => {\n+                    tcx.sess.delay_span_bug(\n+                        DUMMY_SP,\n+                        &format!(\"unexpected const parent in type_of_def_id(): {:?}\", x),\n+                    );\n+                    tcx.types.err\n+                }\n+            }\n+        }\n+\n+        Node::GenericParam(param) => match &param.kind {\n+            GenericParamKind::Type { default: Some(ref ty), .. } => icx.to_ty(ty),\n+            GenericParamKind::Const { ty: ref hir_ty, .. } => {\n+                let ty = icx.to_ty(hir_ty);\n+                if !tcx.features().const_compare_raw_pointers {\n+                    let err = match ty.peel_refs().kind {\n+                        ty::FnPtr(_) => Some(\"function pointers\"),\n+                        ty::RawPtr(_) => Some(\"raw pointers\"),\n+                        _ => None,\n+                    };\n+                    if let Some(unsupported_type) = err {\n+                        feature_err(\n+                            &tcx.sess.parse_sess,\n+                            sym::const_compare_raw_pointers,\n+                            hir_ty.span,\n+                            &format!(\n+                                \"using {} as const generic parameters is unstable\",\n+                                unsupported_type\n+                            ),\n+                        )\n+                        .emit();\n+                    };\n+                }\n+                if traits::search_for_structural_match_violation(param.hir_id, param.span, tcx, ty)\n+                    .is_some()\n+                {\n+                    struct_span_err!(\n+                        tcx.sess,\n+                        hir_ty.span,\n+                        E0741,\n+                        \"the types of const generic parameters must derive `PartialEq` and `Eq`\",\n+                    )\n+                    .span_label(\n+                        hir_ty.span,\n+                        format!(\"`{}` doesn't derive both `PartialEq` and `Eq`\", ty),\n+                    )\n+                    .emit();\n+                }\n+                ty\n+            }\n+            x => bug!(\"unexpected non-type Node::GenericParam: {:?}\", x),\n+        },\n+\n+        x => {\n+            bug!(\"unexpected sort of node in type_of_def_id(): {:?}\", x);\n+        }\n+    }\n+}\n+\n+fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n+    use rustc_hir::{Expr, ImplItem, Item, TraitItem};\n+\n+    debug!(\"find_opaque_ty_constraints({:?})\", def_id);\n+\n+    struct ConstraintLocator<'tcx> {\n+        tcx: TyCtxt<'tcx>,\n+        def_id: DefId,\n+        // (first found type span, actual type, mapping from the opaque type's generic\n+        // parameters to the concrete type's generic parameters)\n+        //\n+        // The mapping is an index for each use site of a generic parameter in the concrete type\n+        //\n+        // The indices index into the generic parameters on the opaque type.\n+        found: Option<(Span, Ty<'tcx>, Vec<usize>)>,\n+    }\n+\n+    impl ConstraintLocator<'_> {\n+        fn check(&mut self, def_id: DefId) {\n+            // Don't try to check items that cannot possibly constrain the type.\n+            if !self.tcx.has_typeck_tables(def_id) {\n+                debug!(\n+                    \"find_opaque_ty_constraints: no constraint for `{:?}` at `{:?}`: no tables\",\n+                    self.def_id, def_id,\n+                );\n+                return;\n+            }\n+            // Calling `mir_borrowck` can lead to cycle errors through\n+            // const-checking, avoid calling it if we don't have to.\n+            if !self.tcx.typeck_tables_of(def_id).concrete_opaque_types.contains_key(&self.def_id) {\n+                debug!(\n+                    \"find_opaque_ty_constraints: no constraint for `{:?}` at `{:?}`\",\n+                    self.def_id, def_id,\n+                );\n+                return;\n+            }\n+            // Use borrowck to get the type with unerased regions.\n+            let ty = self.tcx.mir_borrowck(def_id).concrete_opaque_types.get(&self.def_id);\n+            if let Some(ty::ResolvedOpaqueTy { concrete_type, substs }) = ty {\n+                debug!(\n+                    \"find_opaque_ty_constraints: found constraint for `{:?}` at `{:?}`: {:?}\",\n+                    self.def_id, def_id, ty,\n+                );\n+\n+                // FIXME(oli-obk): trace the actual span from inference to improve errors.\n+                let span = self.tcx.def_span(def_id);\n+                // used to quickly look up the position of a generic parameter\n+                let mut index_map: FxHashMap<ty::ParamTy, usize> = FxHashMap::default();\n+                // Skipping binder is ok, since we only use this to find generic parameters and\n+                // their positions.\n+                for (idx, subst) in substs.iter().enumerate() {\n+                    if let GenericArgKind::Type(ty) = subst.unpack() {\n+                        if let ty::Param(p) = ty.kind {\n+                            if index_map.insert(p, idx).is_some() {\n+                                // There was already an entry for `p`, meaning a generic parameter\n+                                // was used twice.\n+                                self.tcx.sess.span_err(\n+                                    span,\n+                                    &format!(\n+                                        \"defining opaque type use restricts opaque \\\n+                                         type by using the generic parameter `{}` twice\",\n+                                        p,\n+                                    ),\n+                                );\n+                                return;\n+                            }\n+                        } else {\n+                            self.tcx.sess.delay_span_bug(\n+                                span,\n+                                &format!(\n+                                    \"non-defining opaque ty use in defining scope: {:?}, {:?}\",\n+                                    concrete_type, substs,\n+                                ),\n+                            );\n+                        }\n+                    }\n+                }\n+                // Compute the index within the opaque type for each generic parameter used in\n+                // the concrete type.\n+                let indices = concrete_type\n+                    .subst(self.tcx, substs)\n+                    .walk()\n+                    .filter_map(|t| match &t.kind {\n+                        ty::Param(p) => Some(*index_map.get(p).unwrap()),\n+                        _ => None,\n+                    })\n+                    .collect();\n+                let is_param = |ty: Ty<'_>| match ty.kind {\n+                    ty::Param(_) => true,\n+                    _ => false,\n+                };\n+                let bad_substs: Vec<_> = substs\n+                    .iter()\n+                    .enumerate()\n+                    .filter_map(|(i, k)| {\n+                        if let GenericArgKind::Type(ty) = k.unpack() { Some((i, ty)) } else { None }\n+                    })\n+                    .filter(|(_, ty)| !is_param(ty))\n+                    .collect();\n+                if !bad_substs.is_empty() {\n+                    let identity_substs = InternalSubsts::identity_for_item(self.tcx, self.def_id);\n+                    for (i, bad_subst) in bad_substs {\n+                        self.tcx.sess.span_err(\n+                            span,\n+                            &format!(\n+                                \"defining opaque type use does not fully define opaque type: \\\n+                            generic parameter `{}` is specified as concrete type `{}`\",\n+                                identity_substs.type_at(i),\n+                                bad_subst\n+                            ),\n+                        );\n+                    }\n+                } else if let Some((prev_span, prev_ty, ref prev_indices)) = self.found {\n+                    let mut ty = concrete_type.walk().fuse();\n+                    let mut p_ty = prev_ty.walk().fuse();\n+                    let iter_eq = (&mut ty).zip(&mut p_ty).all(|(t, p)| match (&t.kind, &p.kind) {\n+                        // Type parameters are equal to any other type parameter for the purpose of\n+                        // concrete type equality, as it is possible to obtain the same type just\n+                        // by passing matching parameters to a function.\n+                        (ty::Param(_), ty::Param(_)) => true,\n+                        _ => t == p,\n+                    });\n+                    if !iter_eq || ty.next().is_some() || p_ty.next().is_some() {\n+                        debug!(\"find_opaque_ty_constraints: span={:?}\", span);\n+                        // Found different concrete types for the opaque type.\n+                        let mut err = self.tcx.sess.struct_span_err(\n+                            span,\n+                            \"concrete type differs from previous defining opaque type use\",\n+                        );\n+                        err.span_label(\n+                            span,\n+                            format!(\"expected `{}`, got `{}`\", prev_ty, concrete_type),\n+                        );\n+                        err.span_note(prev_span, \"previous use here\");\n+                        err.emit();\n+                    } else if indices != *prev_indices {\n+                        // Found \"same\" concrete types, but the generic parameter order differs.\n+                        let mut err = self.tcx.sess.struct_span_err(\n+                            span,\n+                            \"concrete type's generic parameters differ from previous defining use\",\n+                        );\n+                        use std::fmt::Write;\n+                        let mut s = String::new();\n+                        write!(s, \"expected [\").unwrap();\n+                        let list = |s: &mut String, indices: &Vec<usize>| {\n+                            let mut indices = indices.iter().cloned();\n+                            if let Some(first) = indices.next() {\n+                                write!(s, \"`{}`\", substs[first]).unwrap();\n+                                for i in indices {\n+                                    write!(s, \", `{}`\", substs[i]).unwrap();\n+                                }\n+                            }\n+                        };\n+                        list(&mut s, prev_indices);\n+                        write!(s, \"], got [\").unwrap();\n+                        list(&mut s, &indices);\n+                        write!(s, \"]\").unwrap();\n+                        err.span_label(span, s);\n+                        err.span_note(prev_span, \"previous use here\");\n+                        err.emit();\n+                    }\n+                } else {\n+                    self.found = Some((span, concrete_type, indices));\n+                }\n+            } else {\n+                debug!(\n+                    \"find_opaque_ty_constraints: no constraint for `{:?}` at `{:?}`\",\n+                    self.def_id, def_id,\n+                );\n+            }\n+        }\n+    }\n+\n+    impl<'tcx> intravisit::Visitor<'tcx> for ConstraintLocator<'tcx> {\n+        type Map = Map<'tcx>;\n+\n+        fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<'_, Self::Map> {\n+            intravisit::NestedVisitorMap::All(&self.tcx.hir())\n+        }\n+        fn visit_expr(&mut self, ex: &'tcx Expr<'tcx>) {\n+            if let hir::ExprKind::Closure(..) = ex.kind {\n+                let def_id = self.tcx.hir().local_def_id(ex.hir_id);\n+                self.check(def_id);\n+            }\n+            intravisit::walk_expr(self, ex);\n+        }\n+        fn visit_item(&mut self, it: &'tcx Item<'tcx>) {\n+            debug!(\"find_existential_constraints: visiting {:?}\", it);\n+            let def_id = self.tcx.hir().local_def_id(it.hir_id);\n+            // The opaque type itself or its children are not within its reveal scope.\n+            if def_id != self.def_id {\n+                self.check(def_id);\n+                intravisit::walk_item(self, it);\n+            }\n+        }\n+        fn visit_impl_item(&mut self, it: &'tcx ImplItem<'tcx>) {\n+            debug!(\"find_existential_constraints: visiting {:?}\", it);\n+            let def_id = self.tcx.hir().local_def_id(it.hir_id);\n+            // The opaque type itself or its children are not within its reveal scope.\n+            if def_id != self.def_id {\n+                self.check(def_id);\n+                intravisit::walk_impl_item(self, it);\n+            }\n+        }\n+        fn visit_trait_item(&mut self, it: &'tcx TraitItem<'tcx>) {\n+            debug!(\"find_existential_constraints: visiting {:?}\", it);\n+            let def_id = self.tcx.hir().local_def_id(it.hir_id);\n+            self.check(def_id);\n+            intravisit::walk_trait_item(self, it);\n+        }\n+    }\n+\n+    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let scope = tcx.hir().get_defining_scope(hir_id);\n+    let mut locator = ConstraintLocator { def_id, tcx, found: None };\n+\n+    debug!(\"find_opaque_ty_constraints: scope={:?}\", scope);\n+\n+    if scope == hir::CRATE_HIR_ID {\n+        intravisit::walk_crate(&mut locator, tcx.hir().krate());\n+    } else {\n+        debug!(\"find_opaque_ty_constraints: scope={:?}\", tcx.hir().get(scope));\n+        match tcx.hir().get(scope) {\n+            // We explicitly call `visit_*` methods, instead of using `intravisit::walk_*` methods\n+            // This allows our visitor to process the defining item itself, causing\n+            // it to pick up any 'sibling' defining uses.\n+            //\n+            // For example, this code:\n+            // ```\n+            // fn foo() {\n+            //     type Blah = impl Debug;\n+            //     let my_closure = || -> Blah { true };\n+            // }\n+            // ```\n+            //\n+            // requires us to explicitly process `foo()` in order\n+            // to notice the defining usage of `Blah`.\n+            Node::Item(ref it) => locator.visit_item(it),\n+            Node::ImplItem(ref it) => locator.visit_impl_item(it),\n+            Node::TraitItem(ref it) => locator.visit_trait_item(it),\n+            other => bug!(\"{:?} is not a valid scope for an opaque type item\", other),\n+        }\n+    }\n+\n+    match locator.found {\n+        Some((_, ty, _)) => ty,\n+        None => {\n+            let span = tcx.def_span(def_id);\n+            tcx.sess.span_err(span, \"could not find defining uses\");\n+            tcx.types.err\n+        }\n+    }\n+}\n+\n+fn infer_placeholder_type(\n+    tcx: TyCtxt<'_>,\n+    def_id: DefId,\n+    body_id: hir::BodyId,\n+    span: Span,\n+    item_ident: Ident,\n+) -> Ty<'_> {\n+    let ty = tcx.diagnostic_only_typeck_tables_of(def_id).node_type(body_id.hir_id);\n+\n+    // If this came from a free `const` or `static mut?` item,\n+    // then the user may have written e.g. `const A = 42;`.\n+    // In this case, the parser has stashed a diagnostic for\n+    // us to improve in typeck so we do that now.\n+    match tcx.sess.diagnostic().steal_diagnostic(span, StashKey::ItemNoType) {\n+        Some(mut err) => {\n+            // The parser provided a sub-optimal `HasPlaceholders` suggestion for the type.\n+            // We are typeck and have the real type, so remove that and suggest the actual type.\n+            err.suggestions.clear();\n+            err.span_suggestion(\n+                span,\n+                \"provide a type for the item\",\n+                format!(\"{}: {}\", item_ident, ty),\n+                Applicability::MachineApplicable,\n+            )\n+            .emit();\n+        }\n+        None => {\n+            let mut diag = bad_placeholder_type(tcx, vec![span]);\n+            if ty != tcx.types.err {\n+                diag.span_suggestion(\n+                    span,\n+                    \"replace `_` with the correct type\",\n+                    ty.to_string(),\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+            diag.emit();\n+        }\n+    }\n+\n+    ty\n+}\n+\n+fn report_assoc_ty_on_inherent_impl(tcx: TyCtxt<'_>, span: Span) {\n+    struct_span_err!(\n+        tcx.sess,\n+        span,\n+        E0202,\n+        \"associated types are not yet supported in inherent impls (see #8995)\"\n+    )\n+    .emit();\n+}"}]}