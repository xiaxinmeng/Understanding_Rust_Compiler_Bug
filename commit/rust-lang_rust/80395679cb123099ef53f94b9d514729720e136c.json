{"sha": "80395679cb123099ef53f94b9d514729720e136c", "node_id": "C_kwDOAAsO6NoAKDgwMzk1Njc5Y2IxMjMwOTllZjUzZjk0YjlkNTE0NzI5NzIwZTEzNmM", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-07-20T05:59:38Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-07-20T05:59:38Z"}, "message": "Rollup merge of #98916 - ChrisDenton:hiberfil.sys, r=thomcc\n\nWindows: Use `FindFirstFileW` for getting the metadata of locked system files\n\nFixes #96980\n\nUsually opening a file handle with access set to metadata only will always succeed, even if the file is locked. However some special system files, such as `C:\\hiberfil.sys`, are locked by the system in a way that denies even that. So as a fallback we try reading the cached metadata from the directory.\n\nNote that the test is a bit iffy. I don't know if `hiberfil.sys` actually exists in the CI.\n\nr? rust-lang/libs", "tree": {"sha": "d55f9b45f794a7097f359cd96e1d7fae7e299072", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d55f9b45f794a7097f359cd96e1d7fae7e299072"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/80395679cb123099ef53f94b9d514729720e136c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJi15nLCRBK7hj4Ov3rIwAA/M8IAJpkYfBnIfAO0HCN+qbe6XFH\nclIC2FcDdVlPIpPr33QIAdY3JEZ9Av67ciOU/Mx9dDHxAEIFWjowbOEyafiz+SiO\n3XPgxW3xLf7JrYPtjn+32n5MYVxmjWMq3k7TokjdcPrrExBMFeY2GnZ75u6hfQ7u\n24s8vfC/kLUKMHi94O7nhqLaxFpi69Op/F3Q9MOK6DnAuSgdzycmG/DfNTFQzlTe\nCcC47gCTRX1TRNS/cEsIw1Ybg/zdpUcWrp9cUWP01ZkgcltZCTSWPdR4oXedwcWB\nh/8STbOsiFb4c1g9KiLnE0oWMARN6F94pngKdkP8Jq1pOH95re+Ru4nyJz45uIA=\n=WcDk\n-----END PGP SIGNATURE-----\n", "payload": "tree d55f9b45f794a7097f359cd96e1d7fae7e299072\nparent 97c9f16a45c0ebda9facf38180549f896a81cf32\nparent eee8ca9a44e89d56ed63cf5a76de64cc6cb23c23\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1658296778 +0530\ncommitter GitHub <noreply@github.com> 1658296778 +0530\n\nRollup merge of #98916 - ChrisDenton:hiberfil.sys, r=thomcc\n\nWindows: Use `FindFirstFileW` for getting the metadata of locked system files\n\nFixes #96980\n\nUsually opening a file handle with access set to metadata only will always succeed, even if the file is locked. However some special system files, such as `C:\\hiberfil.sys`, are locked by the system in a way that denies even that. So as a fallback we try reading the cached metadata from the directory.\n\nNote that the test is a bit iffy. I don't know if `hiberfil.sys` actually exists in the CI.\n\nr? rust-lang/libs\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/80395679cb123099ef53f94b9d514729720e136c", "html_url": "https://github.com/rust-lang/rust/commit/80395679cb123099ef53f94b9d514729720e136c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/80395679cb123099ef53f94b9d514729720e136c/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "97c9f16a45c0ebda9facf38180549f896a81cf32", "url": "https://api.github.com/repos/rust-lang/rust/commits/97c9f16a45c0ebda9facf38180549f896a81cf32", "html_url": "https://github.com/rust-lang/rust/commit/97c9f16a45c0ebda9facf38180549f896a81cf32"}, {"sha": "eee8ca9a44e89d56ed63cf5a76de64cc6cb23c23", "url": "https://api.github.com/repos/rust-lang/rust/commits/eee8ca9a44e89d56ed63cf5a76de64cc6cb23c23", "html_url": "https://github.com/rust-lang/rust/commit/eee8ca9a44e89d56ed63cf5a76de64cc6cb23c23"}], "stats": {"total": 125, "additions": 99, "deletions": 26}, "files": [{"sha": "b8959316de170e568de3fc7a366ed478158855dc", "filename": "library/std/src/fs/tests.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/80395679cb123099ef53f94b9d514729720e136c/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80395679cb123099ef53f94b9d514729720e136c/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs?ref=80395679cb123099ef53f94b9d514729720e136c", "patch": "@@ -1534,3 +1534,20 @@ fn read_large_dir() {\n         entry.unwrap();\n     }\n }\n+\n+/// Test the fallback for getting the metadata of files like hiberfil.sys that\n+/// Windows holds a special lock on, preventing normal means of querying\n+/// metadata. See #96980.\n+///\n+/// Note this fails in CI because `hiberfil.sys` does not actually exist there.\n+/// Therefore it's marked as ignored.\n+#[test]\n+#[ignore]\n+#[cfg(windows)]\n+fn hiberfil_sys() {\n+    let hiberfil = Path::new(r\"C:\\hiberfil.sys\");\n+    assert_eq!(true, hiberfil.try_exists().unwrap());\n+    fs::symlink_metadata(hiberfil).unwrap();\n+    fs::metadata(hiberfil).unwrap();\n+    assert_eq!(true, hiberfil.exists());\n+}"}, {"sha": "4d3162f1254628e6560265c95c387dcb263ea395", "filename": "library/std/src/sys/windows/fs.rs", "status": "modified", "additions": 82, "deletions": 26, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/80395679cb123099ef53f94b9d514729720e136c/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80395679cb123099ef53f94b9d514729720e136c/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs?ref=80395679cb123099ef53f94b9d514729720e136c", "patch": "@@ -155,22 +155,7 @@ impl DirEntry {\n     }\n \n     pub fn metadata(&self) -> io::Result<FileAttr> {\n-        Ok(FileAttr {\n-            attributes: self.data.dwFileAttributes,\n-            creation_time: self.data.ftCreationTime,\n-            last_access_time: self.data.ftLastAccessTime,\n-            last_write_time: self.data.ftLastWriteTime,\n-            file_size: ((self.data.nFileSizeHigh as u64) << 32) | (self.data.nFileSizeLow as u64),\n-            reparse_tag: if self.data.dwFileAttributes & c::FILE_ATTRIBUTE_REPARSE_POINT != 0 {\n-                // reserved unless this is a reparse point\n-                self.data.dwReserved0\n-            } else {\n-                0\n-            },\n-            volume_serial_number: None,\n-            number_of_links: None,\n-            file_index: None,\n-        })\n+        Ok(self.data.into())\n     }\n }\n \n@@ -879,6 +864,26 @@ impl FileAttr {\n         self.file_index\n     }\n }\n+impl From<c::WIN32_FIND_DATAW> for FileAttr {\n+    fn from(wfd: c::WIN32_FIND_DATAW) -> Self {\n+        FileAttr {\n+            attributes: wfd.dwFileAttributes,\n+            creation_time: wfd.ftCreationTime,\n+            last_access_time: wfd.ftLastAccessTime,\n+            last_write_time: wfd.ftLastWriteTime,\n+            file_size: ((wfd.nFileSizeHigh as u64) << 32) | (wfd.nFileSizeLow as u64),\n+            reparse_tag: if wfd.dwFileAttributes & c::FILE_ATTRIBUTE_REPARSE_POINT != 0 {\n+                // reserved unless this is a reparse point\n+                wfd.dwReserved0\n+            } else {\n+                0\n+            },\n+            volume_serial_number: None,\n+            number_of_links: None,\n+            file_index: None,\n+        }\n+    }\n+}\n \n fn to_u64(ft: &c::FILETIME) -> u64 {\n     (ft.dwLowDateTime as u64) | ((ft.dwHighDateTime as u64) << 32)\n@@ -1145,22 +1150,73 @@ pub fn link(_original: &Path, _link: &Path) -> io::Result<()> {\n }\n \n pub fn stat(path: &Path) -> io::Result<FileAttr> {\n-    let mut opts = OpenOptions::new();\n-    // No read or write permissions are necessary\n-    opts.access_mode(0);\n-    // This flag is so we can open directories too\n-    opts.custom_flags(c::FILE_FLAG_BACKUP_SEMANTICS);\n-    let file = File::open(path, &opts)?;\n-    file.file_attr()\n+    metadata(path, ReparsePoint::Follow)\n }\n \n pub fn lstat(path: &Path) -> io::Result<FileAttr> {\n+    metadata(path, ReparsePoint::Open)\n+}\n+\n+#[repr(u32)]\n+#[derive(Clone, Copy, PartialEq, Eq)]\n+enum ReparsePoint {\n+    Follow = 0,\n+    Open = c::FILE_FLAG_OPEN_REPARSE_POINT,\n+}\n+impl ReparsePoint {\n+    fn as_flag(self) -> u32 {\n+        self as u32\n+    }\n+}\n+\n+fn metadata(path: &Path, reparse: ReparsePoint) -> io::Result<FileAttr> {\n     let mut opts = OpenOptions::new();\n     // No read or write permissions are necessary\n     opts.access_mode(0);\n-    opts.custom_flags(c::FILE_FLAG_BACKUP_SEMANTICS | c::FILE_FLAG_OPEN_REPARSE_POINT);\n-    let file = File::open(path, &opts)?;\n-    file.file_attr()\n+    opts.custom_flags(c::FILE_FLAG_BACKUP_SEMANTICS | reparse.as_flag());\n+\n+    // Attempt to open the file normally.\n+    // If that fails with `ERROR_SHARING_VIOLATION` then retry using `FindFirstFileW`.\n+    // If the fallback fails for any reason we return the original error.\n+    match File::open(path, &opts) {\n+        Ok(file) => file.file_attr(),\n+        Err(e) if e.raw_os_error() == Some(c::ERROR_SHARING_VIOLATION as _) => {\n+            // `ERROR_SHARING_VIOLATION` will almost never be returned.\n+            // Usually if a file is locked you can still read some metadata.\n+            // However, there are special system files, such as\n+            // `C:\\hiberfil.sys`, that are locked in a way that denies even that.\n+            unsafe {\n+                let path = maybe_verbatim(path)?;\n+\n+                // `FindFirstFileW` accepts wildcard file names.\n+                // Fortunately wildcards are not valid file names and\n+                // `ERROR_SHARING_VIOLATION` means the file exists (but is locked)\n+                // therefore it's safe to assume the file name given does not\n+                // include wildcards.\n+                let mut wfd = mem::zeroed();\n+                let handle = c::FindFirstFileW(path.as_ptr(), &mut wfd);\n+\n+                if handle == c::INVALID_HANDLE_VALUE {\n+                    // This can fail if the user does not have read access to the\n+                    // directory.\n+                    Err(e)\n+                } else {\n+                    // We no longer need the find handle.\n+                    c::FindClose(handle);\n+\n+                    // `FindFirstFileW` reads the cached file information from the\n+                    // directory. The downside is that this metadata may be outdated.\n+                    let attrs = FileAttr::from(wfd);\n+                    if reparse == ReparsePoint::Follow && attrs.file_type().is_symlink() {\n+                        Err(e)\n+                    } else {\n+                        Ok(attrs)\n+                    }\n+                }\n+            }\n+        }\n+        Err(e) => Err(e),\n+    }\n }\n \n pub fn set_perm(p: &Path, perm: FilePermissions) -> io::Result<()> {"}]}