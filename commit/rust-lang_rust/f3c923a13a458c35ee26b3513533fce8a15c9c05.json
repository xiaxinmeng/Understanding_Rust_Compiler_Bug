{"sha": "f3c923a13a458c35ee26b3513533fce8a15c9c05", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzYzkyM2ExM2E0NThjMzVlZTI2YjM1MTM1MzNmY2U4YTE1YzljMDU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-17T19:23:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-17T19:23:58Z"}, "message": "Auto merge of #76645 - fusion-engineering-forks:windows-lock, r=kennytm\n\n Small cleanups in Windows Mutex.\n\n - Move `held` into the boxed part, since the SRW lock implementation does not use this. This makes the Mutex 50% smaller.\n - Use `Cell` instead of `UnsafeCell` for `held`, such that `.replace()` can be used.\n - Add some comments.\n - Avoid creating multiple `&mut`s to the critical section object in `ReentrantMutex`.", "tree": {"sha": "14fcec7aff0a007300065d99482ce964e887bb03", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/14fcec7aff0a007300065d99482ce964e887bb03"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f3c923a13a458c35ee26b3513533fce8a15c9c05", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f3c923a13a458c35ee26b3513533fce8a15c9c05", "html_url": "https://github.com/rust-lang/rust/commit/f3c923a13a458c35ee26b3513533fce8a15c9c05", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f3c923a13a458c35ee26b3513533fce8a15c9c05/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7bdb5dee7bac15458b10b148e9e24968e633053e", "url": "https://api.github.com/repos/rust-lang/rust/commits/7bdb5dee7bac15458b10b148e9e24968e633053e", "html_url": "https://github.com/rust-lang/rust/commit/7bdb5dee7bac15458b10b148e9e24968e633053e"}, {"sha": "0bb96e7490299977abf2d3af16dd752d67ca43a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/0bb96e7490299977abf2d3af16dd752d67ca43a9", "html_url": "https://github.com/rust-lang/rust/commit/0bb96e7490299977abf2d3af16dd752d67ca43a9"}], "stats": {"total": 85, "additions": 42, "deletions": 43}, "files": [{"sha": "5333d75ec1bc5ac17aff7d32ccebc43b08b49a6c", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f3c923a13a458c35ee26b3513533fce8a15c9c05/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c923a13a458c35ee26b3513533fce8a15c9c05/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=f3c923a13a458c35ee26b3513533fce8a15c9c05", "patch": "@@ -315,6 +315,7 @@\n #![feature(try_reserve)]\n #![feature(unboxed_closures)]\n #![feature(unsafe_block_in_unsafe_fn)]\n+#![feature(unsafe_cell_raw_get)]\n #![feature(untagged_unions)]\n #![feature(unwind_attributes)]\n #![feature(vec_into_raw_parts)]"}, {"sha": "1e09b95c8728587555719f98df1cd9884e307c0e", "filename": "library/std/src/sys/windows/mutex.rs", "status": "modified", "additions": 41, "deletions": 43, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/f3c923a13a458c35ee26b3513533fce8a15c9c05/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c923a13a458c35ee26b3513533fce8a15c9c05/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmutex.rs?ref=f3c923a13a458c35ee26b3513533fce8a15c9c05", "patch": "@@ -19,20 +19,25 @@\n //! CriticalSection is used and we keep track of who's holding the mutex to\n //! detect recursive locks.\n \n-use crate::cell::UnsafeCell;\n+use crate::cell::{Cell, UnsafeCell};\n use crate::mem::{self, MaybeUninit};\n use crate::sync::atomic::{AtomicUsize, Ordering};\n use crate::sys::c;\n use crate::sys::compat;\n \n pub struct Mutex {\n+    // This is either directly an SRWLOCK (if supported), or a Box<Inner> otherwise.\n     lock: AtomicUsize,\n-    held: UnsafeCell<bool>,\n }\n \n unsafe impl Send for Mutex {}\n unsafe impl Sync for Mutex {}\n \n+struct Inner {\n+    remutex: ReentrantMutex,\n+    held: Cell<bool>,\n+}\n+\n #[derive(Clone, Copy)]\n enum Kind {\n     SRWLock = 1,\n@@ -51,7 +56,6 @@ impl Mutex {\n             // This works because SRWLOCK_INIT is 0 (wrapped in a struct), so we are also properly\n             // initializing an SRWLOCK here.\n             lock: AtomicUsize::new(0),\n-            held: UnsafeCell::new(false),\n         }\n     }\n     #[inline]\n@@ -60,10 +64,11 @@ impl Mutex {\n         match kind() {\n             Kind::SRWLock => c::AcquireSRWLockExclusive(raw(self)),\n             Kind::CriticalSection => {\n-                let re = self.remutex();\n-                (*re).lock();\n-                if !self.flag_locked() {\n-                    (*re).unlock();\n+                let inner = &*self.inner();\n+                inner.remutex.lock();\n+                if inner.held.replace(true) {\n+                    // It was already locked, so we got a recursive lock which we do not want.\n+                    inner.remutex.unlock();\n                     panic!(\"cannot recursively lock a mutex\");\n                 }\n             }\n@@ -73,62 +78,55 @@ impl Mutex {\n         match kind() {\n             Kind::SRWLock => c::TryAcquireSRWLockExclusive(raw(self)) != 0,\n             Kind::CriticalSection => {\n-                let re = self.remutex();\n-                if !(*re).try_lock() {\n+                let inner = &*self.inner();\n+                if !inner.remutex.try_lock() {\n                     false\n-                } else if self.flag_locked() {\n-                    true\n-                } else {\n-                    (*re).unlock();\n+                } else if inner.held.replace(true) {\n+                    // It was already locked, so we got a recursive lock which we do not want.\n+                    inner.remutex.unlock();\n                     false\n+                } else {\n+                    true\n                 }\n             }\n         }\n     }\n     pub unsafe fn unlock(&self) {\n-        *self.held.get() = false;\n         match kind() {\n             Kind::SRWLock => c::ReleaseSRWLockExclusive(raw(self)),\n-            Kind::CriticalSection => (*self.remutex()).unlock(),\n+            Kind::CriticalSection => {\n+                let inner = &*(self.lock.load(Ordering::SeqCst) as *const Inner);\n+                inner.held.set(false);\n+                inner.remutex.unlock();\n+            }\n         }\n     }\n     pub unsafe fn destroy(&self) {\n         match kind() {\n             Kind::SRWLock => {}\n             Kind::CriticalSection => match self.lock.load(Ordering::SeqCst) {\n                 0 => {}\n-                n => {\n-                    Box::from_raw(n as *mut ReentrantMutex).destroy();\n-                }\n+                n => Box::from_raw(n as *mut Inner).remutex.destroy(),\n             },\n         }\n     }\n \n-    unsafe fn remutex(&self) -> *mut ReentrantMutex {\n+    unsafe fn inner(&self) -> *const Inner {\n         match self.lock.load(Ordering::SeqCst) {\n             0 => {}\n-            n => return n as *mut _,\n+            n => return n as *const _,\n         }\n-        let re = box ReentrantMutex::uninitialized();\n-        re.init();\n-        let re = Box::into_raw(re);\n-        match self.lock.compare_and_swap(0, re as usize, Ordering::SeqCst) {\n-            0 => re,\n+        let inner = box Inner { remutex: ReentrantMutex::uninitialized(), held: Cell::new(false) };\n+        inner.remutex.init();\n+        let inner = Box::into_raw(inner);\n+        match self.lock.compare_and_swap(0, inner as usize, Ordering::SeqCst) {\n+            0 => inner,\n             n => {\n-                Box::from_raw(re).destroy();\n-                n as *mut _\n+                Box::from_raw(inner).remutex.destroy();\n+                n as *const _\n             }\n         }\n     }\n-\n-    unsafe fn flag_locked(&self) -> bool {\n-        if *self.held.get() {\n-            false\n-        } else {\n-            *self.held.get() = true;\n-            true\n-        }\n-    }\n }\n \n fn kind() -> Kind {\n@@ -150,35 +148,35 @@ fn kind() -> Kind {\n }\n \n pub struct ReentrantMutex {\n-    inner: UnsafeCell<MaybeUninit<c::CRITICAL_SECTION>>,\n+    inner: MaybeUninit<UnsafeCell<c::CRITICAL_SECTION>>,\n }\n \n unsafe impl Send for ReentrantMutex {}\n unsafe impl Sync for ReentrantMutex {}\n \n impl ReentrantMutex {\n     pub const fn uninitialized() -> ReentrantMutex {\n-        ReentrantMutex { inner: UnsafeCell::new(MaybeUninit::uninit()) }\n+        ReentrantMutex { inner: MaybeUninit::uninit() }\n     }\n \n     pub unsafe fn init(&self) {\n-        c::InitializeCriticalSection((&mut *self.inner.get()).as_mut_ptr());\n+        c::InitializeCriticalSection(UnsafeCell::raw_get(self.inner.as_ptr()));\n     }\n \n     pub unsafe fn lock(&self) {\n-        c::EnterCriticalSection((&mut *self.inner.get()).as_mut_ptr());\n+        c::EnterCriticalSection(UnsafeCell::raw_get(self.inner.as_ptr()));\n     }\n \n     #[inline]\n     pub unsafe fn try_lock(&self) -> bool {\n-        c::TryEnterCriticalSection((&mut *self.inner.get()).as_mut_ptr()) != 0\n+        c::TryEnterCriticalSection(UnsafeCell::raw_get(self.inner.as_ptr())) != 0\n     }\n \n     pub unsafe fn unlock(&self) {\n-        c::LeaveCriticalSection((&mut *self.inner.get()).as_mut_ptr());\n+        c::LeaveCriticalSection(UnsafeCell::raw_get(self.inner.as_ptr()));\n     }\n \n     pub unsafe fn destroy(&self) {\n-        c::DeleteCriticalSection((&mut *self.inner.get()).as_mut_ptr());\n+        c::DeleteCriticalSection(UnsafeCell::raw_get(self.inner.as_ptr()));\n     }\n }"}]}