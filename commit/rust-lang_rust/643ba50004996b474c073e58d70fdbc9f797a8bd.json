{"sha": "643ba50004996b474c073e58d70fdbc9f797a8bd", "node_id": "C_kwDOAAsO6NoAKDY0M2JhNTAwMDQ5OTZiNDc0YzA3M2U1OGQ3MGZkYmM5Zjc5N2E4YmQ", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-03-03T00:04:04Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-03-03T10:45:52Z"}, "message": "Introduce `MatcherPosRepetition`.\n\nThere are three `Option` fields in `MatcherPos` that are only used in\ntandem. This commit combines them, making the code slightly easier to\nread. (It also makes clear that the `sep` field arguably should have\nbeen `Option<Option<Token>>`!)", "tree": {"sha": "9f364925885c75a348aef2421726b38e8903d73a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9f364925885c75a348aef2421726b38e8903d73a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/643ba50004996b474c073e58d70fdbc9f797a8bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/643ba50004996b474c073e58d70fdbc9f797a8bd", "html_url": "https://github.com/rust-lang/rust/commit/643ba50004996b474c073e58d70fdbc9f797a8bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/643ba50004996b474c073e58d70fdbc9f797a8bd/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b9fabc3f9cce1e29cd54f1809b4ac8dc3c52980f", "url": "https://api.github.com/repos/rust-lang/rust/commits/b9fabc3f9cce1e29cd54f1809b4ac8dc3c52980f", "html_url": "https://github.com/rust-lang/rust/commit/b9fabc3f9cce1e29cd54f1809b4ac8dc3c52980f"}], "stats": {"total": 50, "additions": 27, "deletions": 23}, "files": [{"sha": "aff0c8a96642ab3493754160dff028d570a69360", "filename": "compiler/rustc_expand/src/mbe/macro_parser.rs", "status": "modified", "additions": 27, "deletions": 23, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/643ba50004996b474c073e58d70fdbc9f797a8bd/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/643ba50004996b474c073e58d70fdbc9f797a8bd/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs?ref=643ba50004996b474c073e58d70fdbc9f797a8bd", "patch": "@@ -184,17 +184,8 @@ struct MatcherPos<'root, 'tt> {\n     /// in this matcher.\n     match_hi: usize,\n \n-    // The following fields are used if we are matching a repetition. If we aren't, they should be\n-    // `None`.\n-    /// The KleeneOp of this sequence if we are in a repetition.\n-    seq_op: Option<mbe::KleeneOp>,\n-\n-    /// The separator if we are in a repetition.\n-    sep: Option<Token>,\n-\n-    /// The \"parent\" matcher position if we are in a repetition. That is, the matcher position just\n-    /// before we enter the sequence.\n-    up: Option<MatcherPosHandle<'root, 'tt>>,\n+    /// This field is only used if we are matching a repetition.\n+    repetition: Option<MatcherPosRepetition<'root, 'tt>>,\n \n     /// Specifically used to \"unzip\" token trees. By \"unzip\", we mean to unwrap the delimiters from\n     /// a delimited token tree (e.g., something wrapped in `(` `)`) or to get the contents of a doc\n@@ -219,6 +210,19 @@ impl<'root, 'tt> MatcherPos<'root, 'tt> {\n     }\n }\n \n+#[derive(Clone)]\n+struct MatcherPosRepetition<'root, 'tt> {\n+    /// The KleeneOp of this sequence.\n+    seq_op: mbe::KleeneOp,\n+\n+    /// The separator.\n+    sep: Option<Token>,\n+\n+    /// The \"parent\" matcher position. That is, the matcher position just before we enter the\n+    /// sequence.\n+    up: MatcherPosHandle<'root, 'tt>,\n+}\n+\n // Lots of MatcherPos instances are created at runtime. Allocating them on the\n // heap is slow. Furthermore, using SmallVec<MatcherPos> to allocate them all\n // on the stack is also slow, because MatcherPos is quite a large type and\n@@ -326,10 +330,8 @@ fn initial_matcher_pos<'root, 'tt>(ms: &'tt [TokenTree]) -> MatcherPos<'root, 't\n         // Haven't descended into any delimiters, so empty stack\n         stack: smallvec![],\n \n-        // Haven't descended into any sequences, so both of these are `None`.\n-        seq_op: None,\n-        sep: None,\n-        up: None,\n+        // Haven't descended into any sequences, so this is `None`.\n+        repetition: None,\n     }\n }\n \n@@ -476,7 +478,7 @@ fn inner_parse_loop<'root, 'tt>(\n             // We are repeating iff there is a parent. If the matcher is inside of a repetition,\n             // then we could be at the end of a sequence or at the beginning of the next\n             // repetition.\n-            if item.up.is_some() {\n+            if let Some(repetition) = &item.repetition {\n                 // At this point, regardless of whether there is a separator, we should add all\n                 // matches from the complete repetition of the sequence to the shared, top-level\n                 // `matches` list (actually, `up.matches`, which could itself not be the top-level,\n@@ -487,7 +489,7 @@ fn inner_parse_loop<'root, 'tt>(\n                 // NOTE: removing the condition `idx == len` allows trailing separators.\n                 if idx == len {\n                     // Get the `up` matcher\n-                    let mut new_pos = item.up.clone().unwrap();\n+                    let mut new_pos = repetition.up.clone();\n \n                     // Add matches from this repetition to the `matches` of `up`\n                     for idx in item.match_lo..item.match_hi {\n@@ -502,14 +504,14 @@ fn inner_parse_loop<'root, 'tt>(\n                 }\n \n                 // Check if we need a separator.\n-                if idx == len && item.sep.is_some() {\n+                if idx == len && repetition.sep.is_some() {\n                     // We have a separator, and it is the current token. We can advance past the\n                     // separator token.\n-                    if item.sep.as_ref().map_or(false, |sep| token_name_eq(token, sep)) {\n+                    if repetition.sep.as_ref().map_or(false, |sep| token_name_eq(token, sep)) {\n                         item.idx += 1;\n                         next_items.push(item);\n                     }\n-                } else if item.seq_op != Some(mbe::KleeneOp::ZeroOrOne) {\n+                } else if repetition.seq_op != mbe::KleeneOp::ZeroOrOne {\n                     // We don't need a separator. Move the \"dot\" back to the beginning of the\n                     // matcher and try to match again UNLESS we are only allowed to have _one_\n                     // repetition.\n@@ -548,14 +550,16 @@ fn inner_parse_loop<'root, 'tt>(\n                     let matches = create_matches(item.matches.len());\n                     cur_items.push(MatcherPosHandle::Box(Box::new(MatcherPos {\n                         stack: smallvec![],\n-                        sep: seq.separator.clone(),\n-                        seq_op: Some(seq.kleene.op),\n                         idx: 0,\n                         matches,\n                         match_lo: item.match_cur,\n                         match_cur: item.match_cur,\n                         match_hi: item.match_cur + seq.num_captures,\n-                        up: Some(item),\n+                        repetition: Some(MatcherPosRepetition {\n+                            up: item,\n+                            sep: seq.separator.clone(),\n+                            seq_op: seq.kleene.op,\n+                        }),\n                         top_elts: Tt(TokenTree::Sequence(sp, seq)),\n                     })));\n                 }"}]}