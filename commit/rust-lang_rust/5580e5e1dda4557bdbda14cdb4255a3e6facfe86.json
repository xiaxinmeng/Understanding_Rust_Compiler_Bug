{"sha": "5580e5e1dda4557bdbda14cdb4255a3e6facfe86", "node_id": "C_kwDOAAsO6NoAKDU1ODBlNWUxZGRhNDU1N2JkYmRhMTRjZGI0MjU1YTNlNmZhY2ZlODY", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2021-12-24T21:36:33Z"}, "committer": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2022-01-05T15:13:28Z"}, "message": "Ensure that `Fingerprint` caching respects hashing configuration\n\nFixes #92266\n\nIn some `HashStable` impls, we use a cache to avoid re-computing\nthe same `Fingerprint` from the same structure (e.g. an `AdtDef`).\nHowever, the `StableHashingContext` used can be configured to\nperform hashing in different ways (e.g. skipping `Span`s). This\nconfiguration information is not included in the cache key,\nwhich will cause an incorrect `Fingerprint` to be used if\nwe hash the same structure with different `StableHashingContext`\nsettings.\n\nTo fix this, the configuration settings of `StableHashingContext`\nare split out into a separate `HashingControls` struct. This\nstruct is used as part of the cache key, ensuring that our caches\nalways produce the correct result for the given settings.\n\nWith this in place, we now turn off `Span` hashing during the\nentire process of computing the hash included in legacy symbols.\nThis current has no effect, but will matter when a future PR\nstarts hashing more `Span`s that we currently skip.", "tree": {"sha": "eefcdd83dd525a4b1596e727b046c7308ac817e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eefcdd83dd525a4b1596e727b046c7308ac817e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5580e5e1dda4557bdbda14cdb4255a3e6facfe86", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7J9Gc3TfBwj2K399tAh+UQ6YsWQFAmHVtZgACgkQtAh+UQ6Y\nsWQn4A//Yhi9XrCnkcT/SxwXSuA1TLxr/4DIxv0utgoiMBPc+cFrELtHtuoQLSfP\n6Hud7qZ5zNl6BxRKEQ2EyosedCD7bNKZMTd64sVw8KirOaDB5zuLHFOiXayLXHJd\nXsrY7o/uGpr9yJGPU4wCT82GxjLUyuAcDdSKaN87qxMkdQnFV+H0oRuOksoigT9c\n2oIlBx8B1WxPLjcCZjKVAkd7Mce4LkilyehTOFVPrJvN1DFHf8m/56bEaYfDTXW3\nVK9UIWidBM0z/8FBxJbpGFWxsQ5xc0spvvGCKpC6FhbB1g0jEE2HE3uDDCLhyO6E\nDekwPYjLnacskF2THGSZDed7c4EmCQxCihKB8UVTlk1kWZKO3JA75cuAVS2dafEE\nlw+gIDmsb+/rGJOvtunv+Lu89PnbBex31ft7xgWKUfcM1sxNRNZKKnq1EP/vNCt7\nifmmxIUCmfK62AqlkX7yDjR7rKMUIFDtchHD2+dYKleY/FJv+Vuv8DyA3xFdw0aD\nMqnYGz+tl/vWlDq4RsaEeYApXaOSHdplPrWk8e1dKFJTUP8NNZ8L3+Q718dLEUiI\niK7JHfmkSj/4l/XdC09ZbAkelpnD8tOA78qDM9Wped+hbCLuIWbQ4Q46Ust/pln7\nNAqyCi0yMPOZfP5LZTFLlQyGAcpRIuR+21hlYmqzp+ze64raaoc=\n=JRxk\n-----END PGP SIGNATURE-----", "payload": "tree eefcdd83dd525a4b1596e727b046c7308ac817e4\nparent 936ce3dab7fd042101767c439362310f8355e859\nauthor Aaron Hill <aa1ronham@gmail.com> 1640381793 -0500\ncommitter Aaron Hill <aa1ronham@gmail.com> 1641395608 -0500\n\nEnsure that `Fingerprint` caching respects hashing configuration\n\nFixes #92266\n\nIn some `HashStable` impls, we use a cache to avoid re-computing\nthe same `Fingerprint` from the same structure (e.g. an `AdtDef`).\nHowever, the `StableHashingContext` used can be configured to\nperform hashing in different ways (e.g. skipping `Span`s). This\nconfiguration information is not included in the cache key,\nwhich will cause an incorrect `Fingerprint` to be used if\nwe hash the same structure with different `StableHashingContext`\nsettings.\n\nTo fix this, the configuration settings of `StableHashingContext`\nare split out into a separate `HashingControls` struct. This\nstruct is used as part of the cache key, ensuring that our caches\nalways produce the correct result for the given settings.\n\nWith this in place, we now turn off `Span` hashing during the\nentire process of computing the hash included in legacy symbols.\nThis current has no effect, but will matter when a future PR\nstarts hashing more `Span`s that we currently skip.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5580e5e1dda4557bdbda14cdb4255a3e6facfe86", "html_url": "https://github.com/rust-lang/rust/commit/5580e5e1dda4557bdbda14cdb4255a3e6facfe86", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5580e5e1dda4557bdbda14cdb4255a3e6facfe86/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "936ce3dab7fd042101767c439362310f8355e859", "url": "https://api.github.com/repos/rust-lang/rust/commits/936ce3dab7fd042101767c439362310f8355e859", "html_url": "https://github.com/rust-lang/rust/commit/936ce3dab7fd042101767c439362310f8355e859"}], "stats": {"total": 145, "additions": 99, "deletions": 46}, "files": [{"sha": "9c09a7f5f822e94c1abfa75918b1a2993b401a9b", "filename": "compiler/rustc_data_structures/src/stable_hasher.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5580e5e1dda4557bdbda14cdb4255a3e6facfe86/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5580e5e1dda4557bdbda14cdb4255a3e6facfe86/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs?ref=5580e5e1dda4557bdbda14cdb4255a3e6facfe86", "patch": "@@ -583,3 +583,22 @@ fn stable_hash_reduce<HCX, I, C, F>(\n         }\n     }\n }\n+\n+#[derive(PartialEq, Eq, Clone, Copy, Hash, Debug)]\n+pub enum NodeIdHashingMode {\n+    Ignore,\n+    HashDefPath,\n+}\n+\n+/// Controls what data we do or not not hash.\n+/// Whenever a `HashStable` implementation caches its\n+/// result, it needs to include `HashingControls` as part\n+/// of the key, to ensure that is does not produce an incorrect\n+/// result (for example, using a `Fingerprint` produced while\n+/// hashing `Span`s when a `Fingeprint` without `Span`s is\n+/// being requested)\n+#[derive(Clone, Hash, Eq, PartialEq, Debug)]\n+pub struct HashingControls {\n+    pub hash_spans: bool,\n+    pub node_id_hashing_mode: NodeIdHashingMode,\n+}"}, {"sha": "6cec75d36e2c2f2063ff543c34dce6f9aca9b178", "filename": "compiler/rustc_middle/src/ty/adt.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5580e5e1dda4557bdbda14cdb4255a3e6facfe86/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5580e5e1dda4557bdbda14cdb4255a3e6facfe86/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs?ref=5580e5e1dda4557bdbda14cdb4255a3e6facfe86", "patch": "@@ -4,6 +4,7 @@ use crate::ty::util::{Discr, IntTypeExt};\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::stable_hasher::HashingControls;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n@@ -136,12 +137,13 @@ impl Hash for AdtDef {\n impl<'a> HashStable<StableHashingContext<'a>> for AdtDef {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         thread_local! {\n-            static CACHE: RefCell<FxHashMap<usize, Fingerprint>> = Default::default();\n+            static CACHE: RefCell<FxHashMap<(usize, HashingControls), Fingerprint>> = Default::default();\n         }\n \n         let hash: Fingerprint = CACHE.with(|cache| {\n             let addr = self as *const AdtDef as usize;\n-            *cache.borrow_mut().entry(addr).or_insert_with(|| {\n+            let hashing_controls = hcx.hashing_controls();\n+            *cache.borrow_mut().entry((addr, hashing_controls)).or_insert_with(|| {\n                 let ty::AdtDef { did, ref variants, ref flags, ref repr } = *self;\n \n                 let mut hasher = StableHasher::new();"}, {"sha": "00ce15bea3f28cb54acf0bfaf65f58d9b69d7b3a", "filename": "compiler/rustc_middle/src/ty/impls_ty.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5580e5e1dda4557bdbda14cdb4255a3e6facfe86/compiler%2Frustc_middle%2Fsrc%2Fty%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5580e5e1dda4557bdbda14cdb4255a3e6facfe86/compiler%2Frustc_middle%2Fsrc%2Fty%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fimpls_ty.rs?ref=5580e5e1dda4557bdbda14cdb4255a3e6facfe86", "patch": "@@ -6,6 +6,7 @@ use crate::mir;\n use crate::ty;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::stable_hasher::HashingControls;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher, ToStableHashKey};\n use rustc_query_system::ich::StableHashingContext;\n use std::cell::RefCell;\n@@ -17,12 +18,12 @@ where\n {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         thread_local! {\n-            static CACHE: RefCell<FxHashMap<(usize, usize), Fingerprint>> =\n+            static CACHE: RefCell<FxHashMap<(usize, usize, HashingControls), Fingerprint>> =\n                 RefCell::new(Default::default());\n         }\n \n         let hash = CACHE.with(|cache| {\n-            let key = (self.as_ptr() as usize, self.len());\n+            let key = (self.as_ptr() as usize, self.len(), hcx.hashing_controls());\n             if let Some(&hash) = cache.borrow().get(&key) {\n                 return hash;\n             }"}, {"sha": "9f9de707e7ab1f4d4417084d17d3a3e760c4f028", "filename": "compiler/rustc_query_system/src/ich/hcx.rs", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/5580e5e1dda4557bdbda14cdb4255a3e6facfe86/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5580e5e1dda4557bdbda14cdb4255a3e6facfe86/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fhcx.rs?ref=5580e5e1dda4557bdbda14cdb4255a3e6facfe86", "patch": "@@ -3,6 +3,7 @@ use rustc_ast as ast;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sorted_map::SortedMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_data_structures::stable_hasher::{HashingControls, NodeIdHashingMode};\n use rustc_data_structures::sync::Lrc;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n@@ -27,19 +28,11 @@ pub struct StableHashingContext<'a> {\n     definitions: &'a Definitions,\n     cstore: &'a dyn CrateStore,\n     pub(super) body_resolver: BodyResolver<'a>,\n-    hash_spans: bool,\n-    pub(super) node_id_hashing_mode: NodeIdHashingMode,\n-\n     // Very often, we are hashing something that does not need the\n     // `CachingSourceMapView`, so we initialize it lazily.\n     raw_source_map: &'a SourceMap,\n     caching_source_map: Option<CachingSourceMapView<'a>>,\n-}\n-\n-#[derive(PartialEq, Eq, Clone, Copy)]\n-pub enum NodeIdHashingMode {\n-    Ignore,\n-    HashDefPath,\n+    pub(super) hashing_controls: HashingControls,\n }\n \n /// The `BodyResolver` allows mapping a `BodyId` to the corresponding `hir::Body`.\n@@ -72,8 +65,10 @@ impl<'a> StableHashingContext<'a> {\n             cstore,\n             caching_source_map: None,\n             raw_source_map: sess.source_map(),\n-            hash_spans: hash_spans_initial,\n-            node_id_hashing_mode: NodeIdHashingMode::HashDefPath,\n+            hashing_controls: HashingControls {\n+                hash_spans: hash_spans_initial,\n+                node_id_hashing_mode: NodeIdHashingMode::HashDefPath,\n+            },\n         }\n     }\n \n@@ -133,10 +128,10 @@ impl<'a> StableHashingContext<'a> {\n \n     #[inline]\n     pub fn while_hashing_spans<F: FnOnce(&mut Self)>(&mut self, hash_spans: bool, f: F) {\n-        let prev_hash_spans = self.hash_spans;\n-        self.hash_spans = hash_spans;\n+        let prev_hash_spans = self.hashing_controls.hash_spans;\n+        self.hashing_controls.hash_spans = hash_spans;\n         f(self);\n-        self.hash_spans = prev_hash_spans;\n+        self.hashing_controls.hash_spans = prev_hash_spans;\n     }\n \n     #[inline]\n@@ -145,10 +140,10 @@ impl<'a> StableHashingContext<'a> {\n         mode: NodeIdHashingMode,\n         f: F,\n     ) {\n-        let prev = self.node_id_hashing_mode;\n-        self.node_id_hashing_mode = mode;\n+        let prev = self.hashing_controls.node_id_hashing_mode;\n+        self.hashing_controls.node_id_hashing_mode = mode;\n         f(self);\n-        self.node_id_hashing_mode = prev;\n+        self.hashing_controls.node_id_hashing_mode = prev;\n     }\n \n     #[inline]\n@@ -183,6 +178,10 @@ impl<'a> StableHashingContext<'a> {\n         }\n         IGNORED_ATTRIBUTES.with(|attrs| attrs.contains(&name))\n     }\n+\n+    pub fn hashing_controls(&self) -> HashingControls {\n+        self.hashing_controls.clone()\n+    }\n }\n \n impl<'a> HashStable<StableHashingContext<'a>> for ast::NodeId {\n@@ -195,7 +194,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for ast::NodeId {\n impl<'a> rustc_span::HashStableContext for StableHashingContext<'a> {\n     #[inline]\n     fn hash_spans(&self) -> bool {\n-        self.hash_spans\n+        self.hashing_controls.hash_spans\n     }\n \n     #[inline]\n@@ -215,6 +214,11 @@ impl<'a> rustc_span::HashStableContext for StableHashingContext<'a> {\n     ) -> Option<(Lrc<SourceFile>, usize, BytePos, usize, BytePos)> {\n         self.source_map().span_data_to_lines_and_cols(span)\n     }\n+\n+    #[inline]\n+    fn hashing_controls(&self) -> HashingControls {\n+        self.hashing_controls.clone()\n+    }\n }\n \n impl<'a> rustc_session::HashStableContext for StableHashingContext<'a> {}"}, {"sha": "bf3cf6a48fd03d706f11ebba2f091d0bc2aa446f", "filename": "compiler/rustc_query_system/src/ich/impls_hir.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5580e5e1dda4557bdbda14cdb4255a3e6facfe86/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5580e5e1dda4557bdbda14cdb4255a3e6facfe86/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fimpls_hir.rs?ref=5580e5e1dda4557bdbda14cdb4255a3e6facfe86", "patch": "@@ -11,7 +11,7 @@ impl<'ctx> rustc_hir::HashStableContext for StableHashingContext<'ctx> {\n     #[inline]\n     fn hash_hir_id(&mut self, hir_id: hir::HirId, hasher: &mut StableHasher) {\n         let hcx = self;\n-        match hcx.node_id_hashing_mode {\n+        match hcx.hashing_controls.node_id_hashing_mode {\n             NodeIdHashingMode::Ignore => {\n                 // Don't do anything.\n             }\n@@ -89,12 +89,12 @@ impl<'ctx> rustc_hir::HashStableContext for StableHashingContext<'ctx> {\n \n     #[inline]\n     fn hash_hir_item_like<F: FnOnce(&mut Self)>(&mut self, f: F) {\n-        let prev_hash_node_ids = self.node_id_hashing_mode;\n-        self.node_id_hashing_mode = NodeIdHashingMode::Ignore;\n+        let prev_hash_node_ids = self.hashing_controls.node_id_hashing_mode;\n+        self.hashing_controls.node_id_hashing_mode = NodeIdHashingMode::Ignore;\n \n         f(self);\n \n-        self.node_id_hashing_mode = prev_hash_node_ids;\n+        self.hashing_controls.node_id_hashing_mode = prev_hash_node_ids;\n     }\n \n     #[inline]"}, {"sha": "c42fcc9c82e1eeda9d437d744b47df8a4c720b6f", "filename": "compiler/rustc_query_system/src/ich/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5580e5e1dda4557bdbda14cdb4255a3e6facfe86/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5580e5e1dda4557bdbda14cdb4255a3e6facfe86/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fmod.rs?ref=5580e5e1dda4557bdbda14cdb4255a3e6facfe86", "patch": "@@ -1,6 +1,7 @@\n //! ICH - Incremental Compilation Hash\n \n-pub use self::hcx::{NodeIdHashingMode, StableHashingContext};\n+pub use self::hcx::StableHashingContext;\n+pub use rustc_data_structures::stable_hasher::NodeIdHashingMode;\n use rustc_span::symbol::{sym, Symbol};\n \n mod hcx;"}, {"sha": "6bb4f31cbffb1b15d7e9b06e9f27ed63c7db5f1a", "filename": "compiler/rustc_span/src/hygiene.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5580e5e1dda4557bdbda14cdb4255a3e6facfe86/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5580e5e1dda4557bdbda14cdb4255a3e6facfe86/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs?ref=5580e5e1dda4557bdbda14cdb4255a3e6facfe86", "patch": "@@ -32,6 +32,7 @@ use crate::{HashStableContext, Span, DUMMY_SP};\n use crate::def_id::{CrateNum, DefId, StableCrateId, CRATE_DEF_ID, LOCAL_CRATE};\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::stable_hasher::HashingControls;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::{Lock, Lrc};\n use rustc_data_structures::unhash::UnhashMap;\n@@ -88,6 +89,27 @@ rustc_index::newtype_index! {\n     }\n }\n \n+// Assert that the provided `HashStableContext` is configured with the 'default'\n+// `HashingControls`. We should always have bailed out before getting to here\n+// with a non-default mode. With this check in place, we can avoid the need\n+// to maintain separate versions of `ExpnData` hashes for each permutation\n+// of `HashingControls` settings.\n+fn assert_default_hashing_controls<CTX: HashStableContext>(ctx: &CTX, msg: &str) {\n+    match ctx.hashing_controls() {\n+        // Ideally, we would also check that `node_id_hashing_mode` was always\n+        // `NodeIdHashingMode::HashDefPath`. However, we currently end up hashing\n+        // `Span`s in this mode, and there's not an easy way to change that.\n+        // All of the span-related data that we hash is pretty self-contained\n+        // (in particular, we don't hash any `HirId`s), so this shouldn't result\n+        // in any caching problems.\n+        // FIXME: Enforce that we don't end up transitively hashing any `HirId`s,\n+        // or ensure that this method is always invoked with the same\n+        // `NodeIdHashingMode`\n+        HashingControls { hash_spans: true, node_id_hashing_mode: _ } => {}\n+        other => panic!(\"Attempted hashing of {msg} with non-default HashingControls: {:?}\", other),\n+    }\n+}\n+\n /// A unique hash value associated to an expansion.\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, Encodable, Decodable, HashStable_Generic)]\n pub struct ExpnHash(Fingerprint);\n@@ -1444,6 +1466,7 @@ fn update_disambiguator(expn_data: &mut ExpnData, mut ctx: impl HashStableContex\n         \"Already set disambiguator for ExpnData: {:?}\",\n         expn_data\n     );\n+    assert_default_hashing_controls(&ctx, \"ExpnData (disambiguator)\");\n     let mut expn_hash = expn_data.hash_expn(&mut ctx);\n \n     let disambiguator = HygieneData::with(|data| {\n@@ -1493,6 +1516,7 @@ impl<CTX: HashStableContext> HashStable<CTX> for SyntaxContext {\n \n impl<CTX: HashStableContext> HashStable<CTX> for ExpnId {\n     fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n+        assert_default_hashing_controls(ctx, \"ExpnId\");\n         let hash = if *self == ExpnId::root() {\n             // Avoid fetching TLS storage for a trivial often-used value.\n             Fingerprint::ZERO"}, {"sha": "4d60ca481a0544da17624c6e0f2f351e83d8908e", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5580e5e1dda4557bdbda14cdb4255a3e6facfe86/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5580e5e1dda4557bdbda14cdb4255a3e6facfe86/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=5580e5e1dda4557bdbda14cdb4255a3e6facfe86", "patch": "@@ -42,6 +42,7 @@ pub mod hygiene;\n use hygiene::Transparency;\n pub use hygiene::{DesugaringKind, ExpnKind, MacroKind};\n pub use hygiene::{ExpnData, ExpnHash, ExpnId, LocalExpnId, SyntaxContext};\n+use rustc_data_structures::stable_hasher::HashingControls;\n pub mod def_id;\n use def_id::{CrateNum, DefId, DefPathHash, LocalDefId, LOCAL_CRATE};\n pub mod lev_distance;\n@@ -2062,6 +2063,7 @@ pub trait HashStableContext {\n         &mut self,\n         span: &SpanData,\n     ) -> Option<(Lrc<SourceFile>, usize, BytePos, usize, BytePos)>;\n+    fn hashing_controls(&self) -> HashingControls;\n }\n \n impl<CTX> HashStable<CTX> for Span"}, {"sha": "6d02d04fe80e751d8af642010eeedffaf699a20c", "filename": "compiler/rustc_symbol_mangling/src/legacy.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/5580e5e1dda4557bdbda14cdb4255a3e6facfe86/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5580e5e1dda4557bdbda14cdb4255a3e6facfe86/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs?ref=5580e5e1dda4557bdbda14cdb4255a3e6facfe86", "patch": "@@ -113,29 +113,29 @@ fn get_symbol_hash<'tcx>(\n         hcx.while_hashing_spans(false, |hcx| {\n             hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n                 item_type.hash_stable(hcx, &mut hasher);\n-            });\n-        });\n \n-        // If this is a function, we hash the signature as well.\n-        // This is not *strictly* needed, but it may help in some\n-        // situations, see the `run-make/a-b-a-linker-guard` test.\n-        if let ty::FnDef(..) = item_type.kind() {\n-            item_type.fn_sig(tcx).hash_stable(&mut hcx, &mut hasher);\n-        }\n+                // If this is a function, we hash the signature as well.\n+                // This is not *strictly* needed, but it may help in some\n+                // situations, see the `run-make/a-b-a-linker-guard` test.\n+                if let ty::FnDef(..) = item_type.kind() {\n+                    item_type.fn_sig(tcx).hash_stable(hcx, &mut hasher);\n+                }\n \n-        // also include any type parameters (for generic items)\n-        substs.hash_stable(&mut hcx, &mut hasher);\n+                // also include any type parameters (for generic items)\n+                substs.hash_stable(hcx, &mut hasher);\n \n-        if let Some(instantiating_crate) = instantiating_crate {\n-            tcx.def_path_hash(instantiating_crate.as_def_id())\n-                .stable_crate_id()\n-                .hash_stable(&mut hcx, &mut hasher);\n-        }\n+                if let Some(instantiating_crate) = instantiating_crate {\n+                    tcx.def_path_hash(instantiating_crate.as_def_id())\n+                        .stable_crate_id()\n+                        .hash_stable(hcx, &mut hasher);\n+                }\n \n-        // We want to avoid accidental collision between different types of instances.\n-        // Especially, `VtableShim`s and `ReifyShim`s may overlap with their original\n-        // instances without this.\n-        discriminant(&instance.def).hash_stable(&mut hcx, &mut hasher);\n+                // We want to avoid accidental collision between different types of instances.\n+                // Especially, `VtableShim`s and `ReifyShim`s may overlap with their original\n+                // instances without this.\n+                discriminant(&instance.def).hash_stable(hcx, &mut hasher);\n+            });\n+        });\n     });\n \n     // 64 bits should be enough to avoid collisions."}]}