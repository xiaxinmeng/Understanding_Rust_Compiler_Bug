{"sha": "ffc879c2e46c8ffd7dc35b9d3169286fca609bc3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmYzg3OWMyZTQ2YzhmZmQ3ZGMzNWI5ZDMxNjkyODZmY2E2MDliYzM=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2013-07-23T00:42:45Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2013-07-24T00:06:33Z"}, "message": "Major rework of how calls to self and super methods work.\n\nEliminates method_super, method_self, and vtable_self, merging all of\nthem into the param cases.\nCloes #4396. Closes #7301.", "tree": {"sha": "49784bba8c7ac730ce9d3fe2d2ea49378a9f91c5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/49784bba8c7ac730ce9d3fe2d2ea49378a9f91c5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ffc879c2e46c8ffd7dc35b9d3169286fca609bc3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ffc879c2e46c8ffd7dc35b9d3169286fca609bc3", "html_url": "https://github.com/rust-lang/rust/commit/ffc879c2e46c8ffd7dc35b9d3169286fca609bc3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ffc879c2e46c8ffd7dc35b9d3169286fca609bc3/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "79f8a7fee5c82d6b5d108f9930d9445fb0e6c94a", "url": "https://api.github.com/repos/rust-lang/rust/commits/79f8a7fee5c82d6b5d108f9930d9445fb0e6c94a", "html_url": "https://github.com/rust-lang/rust/commit/79f8a7fee5c82d6b5d108f9930d9445fb0e6c94a"}], "stats": {"total": 412, "additions": 120, "deletions": 292}, "files": [{"sha": "bf39be407c522f1585961ffb1bcaef3327b68f02", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 2, "deletions": 22, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ffc879c2e46c8ffd7dc35b9d3169286fca609bc3/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffc879c2e46c8ffd7dc35b9d3169286fca609bc3/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=ffc879c2e46c8ffd7dc35b9d3169286fca609bc3", "patch": "@@ -590,12 +590,6 @@ impl tr for method_origin {\n           typeck::method_trait(did, m, vstore) => {\n               typeck::method_trait(did.tr(xcx), m, vstore)\n           }\n-          typeck::method_self(did, m) => {\n-              typeck::method_self(did.tr(xcx), m)\n-          }\n-          typeck::method_super(trait_did, m) => {\n-              typeck::method_super(trait_did.tr(xcx), m)\n-          }\n         }\n     }\n }\n@@ -645,20 +639,13 @@ pub fn encode_vtable_origin(ecx: &e::EncodeContext,\n           typeck::vtable_param(pn, bn) => {\n             do ebml_w.emit_enum_variant(\"vtable_param\", 1u, 2u) |ebml_w| {\n                 do ebml_w.emit_enum_variant_arg(0u) |ebml_w| {\n-                    ebml_w.emit_uint(pn);\n+                    pn.encode(ebml_w);\n                 }\n                 do ebml_w.emit_enum_variant_arg(1u) |ebml_w| {\n                     ebml_w.emit_uint(bn);\n                 }\n             }\n           }\n-          typeck::vtable_self(def_id) => {\n-            do ebml_w.emit_enum_variant(\"vtable_self\", 2u, 1u) |ebml_w| {\n-                do ebml_w.emit_enum_variant_arg(0u) |ebml_w| {\n-                    ebml_w.emit_def_id(def_id)\n-                }\n-            }\n-          }\n         }\n     }\n }\n@@ -715,20 +702,13 @@ impl vtable_decoder_helpers for reader::Decoder {\n                   1 => {\n                     typeck::vtable_param(\n                         do this.read_enum_variant_arg(0u) |this| {\n-                            this.read_uint()\n+                            Decodable::decode(this)\n                         },\n                         do this.read_enum_variant_arg(1u) |this| {\n                             this.read_uint()\n                         }\n                     )\n                   }\n-                  2 => {\n-                    typeck::vtable_self(\n-                        do this.read_enum_variant_arg(0u) |this| {\n-                            this.read_def_id_noxcx(cdata)\n-                        }\n-                    )\n-                  }\n                   // hard to avoid - user input\n                   _ => fail!(\"bad enum variant\")\n                 }"}, {"sha": "e768a6d687c2ebf2e78180f4d21a9a262457588f", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ffc879c2e46c8ffd7dc35b9d3169286fca609bc3/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffc879c2e46c8ffd7dc35b9d3169286fca609bc3/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=ffc879c2e46c8ffd7dc35b9d3169286fca609bc3", "patch": "@@ -15,8 +15,7 @@\n use metadata::csearch;\n use middle::ty::{ty_struct, ty_enum};\n use middle::ty;\n-use middle::typeck::{method_map, method_origin, method_param, method_self};\n-use middle::typeck::{method_super};\n+use middle::typeck::{method_map, method_origin, method_param};\n use middle::typeck::{method_static, method_trait};\n \n use std::util::ignore;\n@@ -291,9 +290,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                  method_num: method_num,\n                  _\n             }) |\n-            method_trait(trait_id, method_num, _) |\n-            method_self(trait_id, method_num) |\n-            method_super(trait_id, method_num) => {\n+            method_trait(trait_id, method_num, _) => {\n                 if trait_id.crate == local_crate {\n                     match tcx.items.find(&trait_id.node) {\n                         Some(&node_item(item, _)) => {"}, {"sha": "40c47632188460fb7b18d2f7910ab04af1f5224a", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 10, "deletions": 17, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ffc879c2e46c8ffd7dc35b9d3169286fca609bc3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffc879c2e46c8ffd7dc35b9d3169286fca609bc3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=ffc879c2e46c8ffd7dc35b9d3169286fca609bc3", "patch": "@@ -1096,32 +1096,25 @@ pub fn resolve_vtable_under_param_substs(tcx: ty::ctxt,\n                 }\n             }\n         }\n-        typeck::vtable_self(_trait_id) => {\n-            match param_substs {\n-                Some(@param_substs\n-                     {self_vtables: Some(self_vtables), _}) => {\n-                    self_vtables[0].clone()\n-                }\n-                _ => {\n-                    tcx.sess.bug(fmt!(\n-                        \"resolve_vtable_in_fn_ctxt: asked to lookup but \\\n-                         no self_vtable in the fn_ctxt!\"))\n-                }\n-            }\n-        }\n     }\n }\n \n pub fn find_vtable(tcx: ty::ctxt,\n                    ps: &param_substs,\n-                   n_param: uint,\n+                   n_param: typeck::param_index,\n                    n_bound: uint)\n                    -> typeck::vtable_origin {\n-    debug!(\"find_vtable(n_param=%u, n_bound=%u, ps=%s)\",\n+    debug!(\"find_vtable(n_param=%?, n_bound=%u, ps=%s)\",\n            n_param, n_bound, ps.repr(tcx));\n \n-    let tables = ps.vtables.expect(\"vtables missing where they are needed\");\n-    let param_bounds = tables[n_param];\n+    let param_bounds = match n_param {\n+        typeck::param_self => ps.self_vtables.expect(\"self vtables missing\"),\n+        typeck::param_numbered(n) => {\n+            let tables = ps.vtables\n+                .expect(\"vtables missing where they are needed\");\n+            tables[n]\n+        }\n+    };\n     param_bounds[n_bound].clone()\n }\n "}, {"sha": "9228f20513bb6119336c60a996ec19bbcbf74f91", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 3, "deletions": 60, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/ffc879c2e46c8ffd7dc35b9d3169286fca609bc3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffc879c2e46c8ffd7dc35b9d3169286fca609bc3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=ffc879c2e46c8ffd7dc35b9d3169286fca609bc3", "patch": "@@ -147,46 +147,13 @@ pub fn trans_method_callee(bcx: @mut Block,\n                            mentry: typeck::method_map_entry)\n                            -> Callee {\n     let _icx = push_ctxt(\"impl::trans_method_callee\");\n-    let tcx = bcx.tcx();\n \n     debug!(\"trans_method_callee(callee_id=%?, this=%s, mentry=%s)\",\n            callee_id,\n            bcx.expr_to_str(this),\n            mentry.repr(bcx.tcx()));\n \n-    // Replace method_self with method_static here.\n-    let mut origin = mentry.origin;\n-    match origin {\n-        typeck::method_super(trait_id, method_index) => {\n-            // <self_ty> is the self type for this method call\n-            let self_ty = node_id_type(bcx, this.id);\n-            // <impl_id> is the ID of the implementation of\n-            // trait <trait_id> for type <self_ty>\n-            let impl_id = ty::bogus_get_impl_id_from_ty(tcx, trait_id, self_ty);\n-            // Get the supertrait's methods\n-            let supertrait_method_def_ids = ty::trait_method_def_ids(tcx, trait_id);\n-            // Make sure to fail with a readable error message if\n-            // there's some internal error here\n-            if !(method_index < supertrait_method_def_ids.len()) {\n-                tcx.sess.bug(\"trans_method_callee: supertrait method \\\n-                              index is out of bounds\");\n-            }\n-            // Get the method name using the method index in the origin\n-            let method_name =\n-                ty::method(tcx, supertrait_method_def_ids[method_index]).ident;\n-            // Now that we know the impl ID, we can look up the method\n-            // ID from its name\n-            origin = typeck::method_static(\n-                method_with_name(bcx.ccx(), impl_id, method_name));\n-        }\n-        typeck::method_self(*) |\n-        typeck::method_static(*) | typeck::method_param(*) |\n-        typeck::method_trait(*) => {}\n-    }\n-\n-    debug!(\"origin=%?\", origin);\n-\n-    match origin {\n+    match mentry.origin {\n         typeck::method_static(did) => {\n             let callee_fn = callee::trans_fn_ref(bcx, did, callee_id);\n             let mut temp_cleanups = ~[];\n@@ -210,7 +177,8 @@ pub fn trans_method_callee(bcx: @mut Block,\n         }) => {\n             match bcx.fcx.param_substs {\n                 Some(substs) => {\n-                    let vtbl = find_vtable(bcx.tcx(), substs, p, b);\n+                    let vtbl = find_vtable(bcx.tcx(), substs,\n+                                           p, b);\n                     trans_monomorphized_callee(bcx, callee_id, this, mentry,\n                                                trait_id, off, vtbl)\n                 }\n@@ -219,25 +187,6 @@ pub fn trans_method_callee(bcx: @mut Block,\n             }\n         }\n \n-        typeck::method_self(trait_id, method_index) => {\n-            match bcx.fcx.param_substs {\n-                Some(@param_substs\n-                     {self_vtables: Some(vtbls), _}) => {\n-                    let vtbl = vtbls[0].clone();\n-                    trans_monomorphized_callee(bcx,\n-                                               callee_id,\n-                                               this,\n-                                               mentry,\n-                                               trait_id,\n-                                               method_index,\n-                                               vtbl)\n-                }\n-                _ => {\n-                    fail!(\"trans_method_callee: missing self_vtable\")\n-                }\n-            }\n-        }\n-\n         typeck::method_trait(_, off, store) => {\n             trans_trait_callee(bcx,\n                                callee_id,\n@@ -246,9 +195,6 @@ pub fn trans_method_callee(bcx: @mut Block,\n                                store,\n                                mentry.explicit_self)\n         }\n-        typeck::method_super(*) => {\n-            fail!(\"method_super should have been handled above\")\n-        }\n     }\n }\n \n@@ -403,9 +349,6 @@ pub fn trans_monomorphized_callee(bcx: @mut Block,\n       typeck::vtable_param(*) => {\n           fail!(\"vtable_param left in monomorphized function's vtable substs\");\n       }\n-      typeck::vtable_self(*) => {\n-          fail!(\"vtable_self left in monomorphized function's vtable substs\");\n-      }\n     };\n \n }"}, {"sha": "aa19af01893ca5a113c2623bf6c989dda7ce28a5", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ffc879c2e46c8ffd7dc35b9d3169286fca609bc3/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffc879c2e46c8ffd7dc35b9d3169286fca609bc3/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=ffc879c2e46c8ffd7dc35b9d3169286fca609bc3", "patch": "@@ -274,13 +274,12 @@ pub fn mark_for_method_call(cx: &Context, e_id: node_id, callee_id: node_id) {\n                   opt_static_did = Some(did);\n               }\n               typeck::method_param(typeck::method_param {\n-                  param_num: param,\n+                  param_num: typeck::param_numbered(param),\n                   _\n               }) => {\n                 cx.uses[param] |= use_tydesc;\n               }\n-              typeck::method_trait(*) | typeck::method_self(*)\n-                  | typeck::method_super(*) => (),\n+              _ => (),\n             }\n         }\n     }"}, {"sha": "2381cb069e5952786d3907a6af50b435ba3d2d55", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 28, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ffc879c2e46c8ffd7dc35b9d3169286fca609bc3/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffc879c2e46c8ffd7dc35b9d3169286fca609bc3/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=ffc879c2e46c8ffd7dc35b9d3169286fca609bc3", "patch": "@@ -3065,9 +3065,7 @@ pub fn method_call_type_param_defs(tcx: ctxt,\n           typeck::method_param(typeck::method_param {\n               trait_id: trt_id,\n               method_num: n_mth, _}) |\n-          typeck::method_trait(trt_id, n_mth, _) |\n-          typeck::method_self(trt_id, n_mth) |\n-          typeck::method_super(trt_id, n_mth) => {\n+          typeck::method_trait(trt_id, n_mth, _) => {\n             // ...trait methods bounds, in contrast, include only the\n             // method bounds, so we must preprend the tps from the\n             // trait itself.  This ought to be harmonized.\n@@ -4401,31 +4399,6 @@ pub fn count_traits_and_supertraits(tcx: ctxt,\n     return total;\n }\n \n-// Given a trait and a type, returns the impl of that type.\n-// This is broken, of course, by parametric impls. This used to use\n-// a table specifically for this mapping, but I removed that table.\n-// This is only used when calling a supertrait method from a default method,\n-// and should go away once I fix how that works. -sully\n-pub fn bogus_get_impl_id_from_ty(tcx: ctxt,\n-                                 trait_id: def_id, self_ty: t) -> def_id {\n-    match tcx.trait_impls.find(&trait_id) {\n-        Some(ty_to_impl) => {\n-            for ty_to_impl.iter().advance |imp| {\n-                let impl_ty = tcx.tcache.get_copy(&imp.did);\n-                if impl_ty.ty == self_ty { return imp.did; }\n-            }\n-            // try autoderef!\n-            match deref(tcx, self_ty, false) {\n-                Some(some_ty) =>\n-                  bogus_get_impl_id_from_ty(tcx, trait_id, some_ty.ty),\n-                None => tcx.sess.bug(\"get_impl_id: no impl of trait for \\\n-                                      this type\")\n-            }\n-        },\n-        None => tcx.sess.bug(\"get_impl_id: trait isn't in trait_impls\")\n-    }\n-}\n-\n pub fn get_tydesc_ty(tcx: ctxt) -> Result<t, ~str> {\n     do tcx.lang_items.require(TyDescStructLangItem).map |tydesc_lang_item| {\n         tcx.intrinsic_defs.find_copy(tydesc_lang_item)"}, {"sha": "545a16a7993c7895df936e20baddb90b8749b0ff", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 84, "deletions": 121, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/ffc879c2e46c8ffd7dc35b9d3169286fca609bc3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffc879c2e46c8ffd7dc35b9d3169286fca609bc3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=ffc879c2e46c8ffd7dc35b9d3169286fca609bc3", "patch": "@@ -90,7 +90,8 @@ use middle::typeck::check::vtable;\n use middle::typeck::check;\n use middle::typeck::infer;\n use middle::typeck::{method_map_entry, method_origin, method_param};\n-use middle::typeck::{method_self, method_static, method_trait, method_super};\n+use middle::typeck::{method_static, method_trait};\n+use middle::typeck::{param_numbered, param_self, param_index};\n use middle::typeck::check::regionmanip::replace_bound_regions_in_fn_sig;\n use util::common::indenter;\n \n@@ -342,64 +343,6 @@ impl<'self> LookupContext<'self> {\n         }\n     }\n \n-    pub fn push_inherent_candidates_from_param(&self,\n-                                               rcvr_ty: ty::t,\n-                                               param_ty: param_ty) {\n-        debug!(\"push_inherent_candidates_from_param(param_ty=%?)\",\n-               param_ty);\n-        let _indenter = indenter();\n-\n-        let tcx = self.tcx();\n-        let mut next_bound_idx = 0; // count only trait bounds\n-        let type_param_def = match tcx.ty_param_defs.find(&param_ty.def_id.node) {\n-            Some(t) => t,\n-            None => {\n-                tcx.sess.span_bug(\n-                    self.expr.span,\n-                    fmt!(\"No param def for %?\", param_ty));\n-            }\n-        };\n-\n-        for ty::each_bound_trait_and_supertraits(tcx, type_param_def.bounds)\n-            |bound_trait_ref|\n-        {\n-            let this_bound_idx = next_bound_idx;\n-            next_bound_idx += 1;\n-\n-            let trait_methods = ty::trait_methods(tcx, bound_trait_ref.def_id);\n-            let pos = {\n-                match trait_methods.iter().position(|m| {\n-                    m.explicit_self != ast::sty_static &&\n-                        m.ident == self.m_name })\n-                {\n-                    Some(pos) => pos,\n-                    None => {\n-                        debug!(\"trait doesn't contain method: %?\",\n-                               bound_trait_ref.def_id);\n-                        loop; // check next trait or bound\n-                    }\n-                }\n-            };\n-            let method = trait_methods[pos];\n-\n-            let cand = Candidate {\n-                rcvr_ty: rcvr_ty,\n-                rcvr_substs: bound_trait_ref.substs.clone(),\n-                method_ty: method,\n-                origin: method_param(\n-                    method_param {\n-                        trait_id: bound_trait_ref.def_id,\n-                        method_num: pos,\n-                        param_num: param_ty.idx,\n-                        bound_num: this_bound_idx,\n-                    })\n-            };\n-\n-            debug!(\"pushing inherent candidate for param: %?\", cand);\n-            self.inherent_candidates.push(cand);\n-        }\n-    }\n-\n     pub fn push_inherent_candidates_from_trait(&self,\n                                                self_ty: ty::t,\n                                                did: def_id,\n@@ -452,69 +395,91 @@ impl<'self> LookupContext<'self> {\n         });\n     }\n \n+    pub fn push_inherent_candidates_from_param(&self,\n+                                               rcvr_ty: ty::t,\n+                                               param_ty: param_ty) {\n+        debug!(\"push_inherent_candidates_from_param(param_ty=%?)\",\n+               param_ty);\n+        let _indenter = indenter();\n+\n+        let tcx = self.tcx();\n+        let type_param_def = match tcx.ty_param_defs.find(&param_ty.def_id.node) {\n+            Some(t) => t,\n+            None => {\n+                tcx.sess.span_bug(\n+                    self.expr.span,\n+                    fmt!(\"No param def for %?\", param_ty));\n+            }\n+        };\n+\n+        self.push_inherent_candidates_from_bounds(\n+            rcvr_ty, &*type_param_def.bounds, param_numbered(param_ty.idx));\n+    }\n+\n+\n     pub fn push_inherent_candidates_from_self(&self,\n                                               self_ty: ty::t,\n                                               did: def_id) {\n-        struct MethodInfo {\n-            method_ty: @ty::Method,\n-            trait_def_id: ast::def_id,\n-            index: uint,\n-            trait_ref: @ty::TraitRef\n-        }\n+        let tcx = self.tcx();\n \n+        let trait_ref = ty::lookup_trait_def(tcx, did).trait_ref;\n+        let bounds = ParamBounds {\n+            builtin_bounds: EmptyBuiltinBounds(),\n+            trait_bounds: ~[trait_ref]\n+        };\n+\n+        self.push_inherent_candidates_from_bounds(\n+            self_ty, &bounds, param_self);\n+    }\n+\n+    pub fn push_inherent_candidates_from_bounds(&self,\n+                                                self_ty: ty::t,\n+                                                bounds: &ParamBounds,\n+                                                param: param_index) {\n         let tcx = self.tcx();\n-        // First, try self methods\n-        let mut method_info: Option<MethodInfo> = None;\n-        let methods = ty::trait_methods(tcx, did);\n-        match methods.iter().position(|m| m.ident == self.m_name) {\n-            Some(i) => {\n-                method_info = Some(MethodInfo {\n-                    method_ty: methods[i],\n-                    index: i,\n-                    trait_def_id: did,\n-                    trait_ref: ty::lookup_trait_def(tcx, did).trait_ref\n-                });\n-            }\n-            None => ()\n-        }\n-        // No method found yet? Check each supertrait\n-        if method_info.is_none() {\n-            for ty::trait_supertraits(tcx, did).iter().advance |trait_ref| {\n-                let supertrait_methods =\n-                    ty::trait_methods(tcx, trait_ref.def_id);\n-                match supertrait_methods.iter().position(|m| m.ident == self.m_name) {\n-                    Some(i) => {\n-                        method_info = Some(MethodInfo {\n-                            method_ty: supertrait_methods[i],\n-                            index: i,\n-                            trait_def_id: trait_ref.def_id,\n-                            trait_ref: *trait_ref\n-                        });\n-                        break;\n+        let mut next_bound_idx = 0; // count only trait bounds\n+\n+        for ty::each_bound_trait_and_supertraits(tcx, bounds)\n+            |bound_trait_ref|\n+        {\n+            let this_bound_idx = next_bound_idx;\n+            next_bound_idx += 1;\n+\n+            let trait_methods = ty::trait_methods(tcx, bound_trait_ref.def_id);\n+            let pos = {\n+                match trait_methods.iter().position(|m| {\n+                    m.explicit_self != ast::sty_static &&\n+                        m.ident == self.m_name })\n+                {\n+                    Some(pos) => pos,\n+                    None => {\n+                        debug!(\"trait doesn't contain method: %?\",\n+                               bound_trait_ref.def_id);\n+                        loop; // check next trait or bound\n                     }\n-                    None => ()\n                 }\n-            }\n-        }\n-        match method_info {\n-            Some(ref info) => {\n-                // We've found a method -- return it\n-                let origin = if did == info.trait_def_id {\n-                    method_self(info.trait_def_id, info.index)\n-                } else {\n-                    method_super(info.trait_def_id, info.index)\n-                };\n-                self.inherent_candidates.push(Candidate {\n-                    rcvr_ty: self_ty,\n-                    rcvr_substs: info.trait_ref.substs.clone(),\n-                    method_ty: info.method_ty,\n-                    origin: origin\n-                });\n-            }\n-            _ => return\n+            };\n+            let method = trait_methods[pos];\n+\n+            let cand = Candidate {\n+                rcvr_ty: self_ty,\n+                rcvr_substs: bound_trait_ref.substs.clone(),\n+                method_ty: method,\n+                origin: method_param(\n+                    method_param {\n+                        trait_id: bound_trait_ref.def_id,\n+                        method_num: pos,\n+                        param_num: param,\n+                        bound_num: this_bound_idx,\n+                    })\n+            };\n+\n+            debug!(\"pushing inherent candidate for param: %?\", cand);\n+            self.inherent_candidates.push(cand);\n         }\n     }\n \n+\n     pub fn push_inherent_impl_candidates_for_type(&self, did: def_id) {\n         let opt_impl_infos = self.tcx().inherent_impls.find(&did);\n         for opt_impl_infos.iter().advance |impl_infos| {\n@@ -1019,14 +984,13 @@ impl<'self> LookupContext<'self> {\n         /*!\n          *\n          * There are some limitations to calling functions through a\n-         * traint instance, because (a) the self type is not known\n+         * trait instance, because (a) the self type is not known\n          * (that's the whole point of a trait instance, after all, to\n          * obscure the self type) and (b) the call must go through a\n          * vtable and hence cannot be monomorphized. */\n \n         match candidate.origin {\n-            method_static(*) | method_param(*) |\n-                method_self(*) | method_super(*) => {\n+            method_static(*) | method_param(*) => {\n                 return; // not a call to a trait instance\n             }\n             method_trait(*) => {}\n@@ -1050,10 +1014,11 @@ impl<'self> LookupContext<'self> {\n         // No code can call the finalize method explicitly.\n         let bad;\n         match candidate.origin {\n-            method_static(method_id) | method_self(method_id, _)\n-                | method_super(method_id, _) => {\n+            method_static(method_id) => {\n                 bad = self.tcx().destructors.contains(&method_id);\n             }\n+            // XXX: does this properly enforce this on everything now\n+            // that self has been merged in? -sully\n             method_param(method_param { trait_id: trait_id, _ }) |\n             method_trait(trait_id, _, _) => {\n                 bad = self.tcx().destructor_for_type.contains_key(&trait_id);\n@@ -1172,8 +1137,7 @@ impl<'self> LookupContext<'self> {\n             method_param(ref mp) => {\n                 type_of_trait_method(self.tcx(), mp.trait_id, mp.method_num)\n             }\n-            method_trait(did, idx, _) | method_self(did, idx) |\n-                method_super(did, idx) => {\n+            method_trait(did, idx, _) => {\n                 type_of_trait_method(self.tcx(), did, idx)\n             }\n         };\n@@ -1194,8 +1158,7 @@ impl<'self> LookupContext<'self> {\n             method_param(ref mp) => {\n                 self.report_param_candidate(idx, (*mp).trait_id)\n             }\n-            method_trait(trait_did, _, _) | method_self(trait_did, _)\n-                | method_super(trait_did, _) => {\n+            method_trait(trait_did, _, _) => {\n                 self.report_trait_candidate(idx, trait_did)\n             }\n         }"}, {"sha": "056b330e9c5207036b3ead1d8afae13168606730", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ffc879c2e46c8ffd7dc35b9d3169286fca609bc3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffc879c2e46c8ffd7dc35b9d3169286fca609bc3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=ffc879c2e46c8ffd7dc35b9d3169286fca609bc3", "patch": "@@ -17,7 +17,8 @@ use middle::typeck::infer::fixup_err_to_str;\n use middle::typeck::infer::{resolve_and_force_all_but_regions, resolve_type};\n use middle::typeck::infer;\n use middle::typeck::{CrateCtxt, vtable_origin, vtable_res, vtable_param_res};\n-use middle::typeck::{vtable_static, vtable_param, vtable_self, impl_res};\n+use middle::typeck::{vtable_static, vtable_param, impl_res};\n+use middle::typeck::{param_numbered, param_self};\n use middle::subst::Subst;\n use util::common::indenter;\n use util::ppaux;\n@@ -239,7 +240,7 @@ fn lookup_vtable(vcx: &VtableContext,\n             // The type has unconstrained type variables in it, so we can't\n             // do early resolution on it. Return some completely bogus vtable\n             // information: we aren't storing it anyways.\n-            return Some(vtable_param(0, 0));\n+            return Some(vtable_param(param_self, 0));\n         }\n     };\n \n@@ -257,7 +258,7 @@ fn lookup_vtable(vcx: &VtableContext,\n                                       location_info,\n                                       bound_trait_ref,\n                                       trait_ref);\n-                    let vtable = vtable_param(n, n_bound);\n+                    let vtable = vtable_param(param_numbered(n), n_bound);\n                     debug!(\"found param vtable: %?\",\n                            vtable);\n                     return Some(vtable);\n@@ -272,7 +273,7 @@ fn lookup_vtable(vcx: &VtableContext,\n                    trait_ref.def_id, trait_id);\n \n             if trait_id == trait_ref.def_id {\n-                let vtable = vtable_self(trait_id);\n+                let vtable = vtable_param(param_self, 0);\n                 debug!(\"found self vtable: %?\", vtable);\n                 return Some(vtable);\n             }\n@@ -403,7 +404,7 @@ fn search_for_vtable(vcx: &VtableContext,\n             None => {\n                 assert!(is_early);\n                 // Bail out with a bogus answer\n-                return Some(vtable_param(0, 0));\n+                return Some(vtable_param(param_self, 0));\n             }\n         };\n "}, {"sha": "a7319d4b0081f9a962306638c2713268debcbae4", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ffc879c2e46c8ffd7dc35b9d3169286fca609bc3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffc879c2e46c8ffd7dc35b9d3169286fca609bc3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=ffc879c2e46c8ffd7dc35b9d3169286fca609bc3", "patch": "@@ -20,7 +20,7 @@ use middle::typeck::infer::{force_all, resolve_all, resolve_region};\n use middle::typeck::infer::resolve_type;\n use middle::typeck::infer;\n use middle::typeck::{vtable_res, vtable_origin};\n-use middle::typeck::{vtable_static, vtable_param, vtable_self};\n+use middle::typeck::{vtable_static, vtable_param};\n use middle::typeck::method_map_entry;\n use middle::typeck::write_substs_to_tcx;\n use middle::typeck::write_ty_to_tcx;\n@@ -109,9 +109,6 @@ fn resolve_vtable_map_entry(fcx: @mut FnCtxt, sp: span, id: ast::node_id) {\n             &vtable_param(n, b) => {\n                 vtable_param(n, b)\n             }\n-            &vtable_self(def_id) => {\n-                vtable_self(def_id)\n-            }\n         }\n     }\n }"}, {"sha": "0ea00e15863d8f1b2ccb3bc3b854b349b4a4cba9", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 9, "deletions": 20, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ffc879c2e46c8ffd7dc35b9d3169286fca609bc3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffc879c2e46c8ffd7dc35b9d3169286fca609bc3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=ffc879c2e46c8ffd7dc35b9d3169286fca609bc3", "patch": "@@ -75,14 +75,14 @@ pub mod infer;\n pub mod collect;\n pub mod coherence;\n \n+#[deriving(Clone, Encodable, Decodable, Eq, Ord)]\n+pub enum param_index {\n+    param_numbered(uint),\n+    param_self\n+}\n+\n #[deriving(Clone, Encodable, Decodable)]\n pub enum method_origin {\n-    // supertrait method invoked on \"self\" inside a default method\n-    // first field is supertrait ID;\n-    // second field is method index (relative to the *supertrait*\n-    // method list)\n-    method_super(ast::def_id, uint),\n-\n     // fully statically resolved method\n     method_static(ast::def_id),\n \n@@ -92,9 +92,6 @@ pub enum method_origin {\n     // method invoked on a trait instance\n     method_trait(ast::def_id, uint, ty::TraitStore),\n \n-    // method invoked on \"self\" inside a default method\n-    method_self(ast::def_id, uint)\n-\n }\n \n // details for a method invoked with a receiver whose type is a type parameter\n@@ -109,7 +106,7 @@ pub struct method_param {\n \n     // index of the type parameter (from those that are in scope) that is\n     // the type of the receiver\n-    param_num: uint,\n+    param_num: param_index,\n \n     // index of the bound for this type parameter which specifies the trait\n     bound_num: uint,\n@@ -153,15 +150,10 @@ pub enum vtable_origin {\n       fn foo<T:quux,baz,bar>(a: T) -- a's vtable would have a\n       vtable_param origin\n \n-      The first uint is the param number (identifying T in the example),\n+      The first argument is the param index (identifying T in the example),\n       and the second is the bound number (identifying baz)\n      */\n-    vtable_param(uint, uint),\n-\n-    /*\n-     Dynamic vtable, comes from self.\n-    */\n-    vtable_self(ast::def_id)\n+    vtable_param(param_index, uint),\n }\n \n impl Repr for vtable_origin {\n@@ -178,9 +170,6 @@ impl Repr for vtable_origin {\n             vtable_param(x, y) => {\n                 fmt!(\"vtable_param(%?, %?)\", x, y)\n             }\n-            vtable_self(def_id) => {\n-                fmt!(\"vtable_self(%?)\", def_id)\n-            }\n         }\n     }\n }"}, {"sha": "932648d4f9b9efe313cc6527270d217812a4be60", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ffc879c2e46c8ffd7dc35b9d3169286fca609bc3/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffc879c2e46c8ffd7dc35b9d3169286fca609bc3/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=ffc879c2e46c8ffd7dc35b9d3169286fca609bc3", "patch": "@@ -715,10 +715,6 @@ impl Repr for typeck::method_map_entry {\n impl Repr for typeck::method_origin {\n     fn repr(&self, tcx: ctxt) -> ~str {\n         match self {\n-            &typeck::method_super(def_id, n) => {\n-                fmt!(\"method_super(%s, %?)\",\n-                     def_id.repr(tcx), n)\n-            }\n             &typeck::method_static(def_id) => {\n                 fmt!(\"method_static(%s)\", def_id.repr(tcx))\n             }\n@@ -729,9 +725,6 @@ impl Repr for typeck::method_origin {\n                 fmt!(\"method_trait(%s, %?, %s)\", def_id.repr(tcx), n,\n                      st.repr(tcx))\n             }\n-            &typeck::method_self(def_id, n) => {\n-                fmt!(\"method_self(%s, %?)\", def_id.repr(tcx), n)\n-            }\n         }\n     }\n }"}]}