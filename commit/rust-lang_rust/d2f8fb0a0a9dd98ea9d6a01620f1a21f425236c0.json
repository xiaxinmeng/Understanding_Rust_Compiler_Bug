{"sha": "d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyZjhmYjBhMGE5ZGQ5OGVhOWQ2YTAxNjIwZjFhMjFmNDI1MjM2YzA=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-11-16T08:21:52Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-11-20T23:40:20Z"}, "message": "Move `syntax::util::interner` -> `syntax::symbol`, cleanup.", "tree": {"sha": "941a81af819b4ff81b47fd0f50241477e9090d2d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/941a81af819b4ff81b47fd0f50241477e9090d2d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "html_url": "https://github.com/rust-lang/rust/commit/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f177a00ac92b871add90ca559a8591c4647a3c7e", "url": "https://api.github.com/repos/rust-lang/rust/commits/f177a00ac92b871add90ca559a8591c4647a3c7e", "html_url": "https://github.com/rust-lang/rust/commit/f177a00ac92b871add90ca559a8591c4647a3c7e"}], "stats": {"total": 1558, "additions": 752, "deletions": 806}, "files": [{"sha": "1ae906e0aa4e013016661fda77517168ec7903d1", "filename": "src/libproc_macro_plugin/qquote.rs", "status": "modified", "additions": 28, "deletions": 24, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibproc_macro_plugin%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibproc_macro_plugin%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro_plugin%2Fqquote.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -34,8 +34,9 @@ use syntax::codemap::Span;\n use syntax::ext::base::*;\n use syntax::ext::base;\n use syntax::ext::proc_macro_shim::build_block_emitter;\n-use syntax::parse::token::{self, Token, gensym_ident, str_to_ident};\n+use syntax::parse::token::{self, Token};\n use syntax::print::pprust;\n+use syntax::symbol::Symbol;\n use syntax::tokenstream::{TokenTree, TokenStream};\n \n // ____________________________________________________________________________________________\n@@ -124,7 +125,7 @@ fn qquote_iter<'cx>(cx: &'cx mut ExtCtxt, depth: i64, ts: TokenStream) -> (Bindi\n                     } // produce an error or something first\n                     let exp = vec![exp.unwrap().to_owned()];\n                     debug!(\"RHS: {:?}\", exp.clone());\n-                    let new_id = gensym_ident(\"tmp\");\n+                    let new_id = Ident::with_empty_ctxt(Symbol::gensym(\"tmp\"));\n                     debug!(\"RHS TS: {:?}\", TokenStream::from_tts(exp.clone()));\n                     debug!(\"RHS TS TT: {:?}\", TokenStream::from_tts(exp.clone()).to_vec());\n                     bindings.push((new_id, TokenStream::from_tts(exp)));\n@@ -179,7 +180,7 @@ fn unravel_concats(tss: Vec<TokenStream>) -> TokenStream {\n     };\n \n     while let Some(ts) = pushes.pop() {\n-        output = build_fn_call(str_to_ident(\"concat\"),\n+        output = build_fn_call(Ident::from_str(\"concat\"),\n                                concat(concat(ts,\n                                              from_tokens(vec![Token::Comma])),\n                                       output));\n@@ -209,18 +210,19 @@ fn convert_complex_tts<'cx>(cx: &'cx mut ExtCtxt, tts: Vec<QTT>) -> (Bindings, T\n             // FIXME handle sequence repetition tokens\n             QTT::QDL(qdl) => {\n                 debug!(\"  QDL: {:?} \", qdl.tts);\n-                let new_id = gensym_ident(\"qdl_tmp\");\n+                let new_id = Ident::with_empty_ctxt(Symbol::gensym(\"qdl_tmp\"));\n                 let mut cct_rec = convert_complex_tts(cx, qdl.tts);\n                 bindings.append(&mut cct_rec.0);\n                 bindings.push((new_id, cct_rec.1));\n \n                 let sep = build_delim_tok(qdl.delim);\n \n-                pushes.push(build_mod_call(vec![str_to_ident(\"proc_macro_tokens\"),\n-                                               str_to_ident(\"build\"),\n-                                               str_to_ident(\"build_delimited\")],\n-                                          concat(from_tokens(vec![Token::Ident(new_id)]),\n-                                                 concat(lex(\",\"), sep))));\n+                pushes.push(build_mod_call(\n+                    vec![Ident::from_str(\"proc_macro_tokens\"),\n+                         Ident::from_str(\"build\"),\n+                         Ident::from_str(\"build_delimited\")],\n+                    concat(from_tokens(vec![Token::Ident(new_id)]), concat(lex(\",\"), sep)),\n+                ));\n             }\n             QTT::QIdent(t) => {\n                 pushes.push(TokenStream::from_tts(vec![t]));\n@@ -250,13 +252,13 @@ fn unravel(binds: Bindings) -> TokenStream {\n \n /// Checks if the Ident is `unquote`.\n fn is_unquote(id: Ident) -> bool {\n-    let qq = str_to_ident(\"unquote\");\n+    let qq = Ident::from_str(\"unquote\");\n     id.name == qq.name  // We disregard context; unquote is _reserved_\n }\n \n /// Checks if the Ident is `quote`.\n fn is_qquote(id: Ident) -> bool {\n-    let qq = str_to_ident(\"qquote\");\n+    let qq = Ident::from_str(\"qquote\");\n     id.name == qq.name  // We disregard context; qquote is _reserved_\n }\n \n@@ -266,7 +268,8 @@ mod int_build {\n \n     use syntax::ast::{self, Ident};\n     use syntax::codemap::{DUMMY_SP};\n-    use syntax::parse::token::{self, Token, keywords, str_to_ident};\n+    use syntax::parse::token::{self, Token, Lit};\n+    use syntax::symbol::keywords;\n     use syntax::tokenstream::{TokenTree, TokenStream};\n \n     // ____________________________________________________________________________________________\n@@ -277,19 +280,19 @@ mod int_build {\n                build_paren_delimited(build_vec(build_token_tt(t))))\n     }\n \n-    pub fn emit_lit(l: token::Lit, n: Option<ast::Name>) -> TokenStream {\n+    pub fn emit_lit(l: Lit, n: Option<ast::Name>) -> TokenStream {\n         let suf = match n {\n-            Some(n) => format!(\"Some(ast::Name({}))\", n.0),\n+            Some(n) => format!(\"Some(ast::Name({}))\", n.as_u32()),\n             None => \"None\".to_string(),\n         };\n \n         let lit = match l {\n-            token::Lit::Byte(n) => format!(\"Lit::Byte(token::intern(\\\"{}\\\"))\", n.to_string()),\n-            token::Lit::Char(n) => format!(\"Lit::Char(token::intern(\\\"{}\\\"))\", n.to_string()),\n-            token::Lit::Integer(n) => format!(\"Lit::Integer(token::intern(\\\"{}\\\"))\", n.to_string()),\n-            token::Lit::Float(n) => format!(\"Lit::Float(token::intern(\\\"{}\\\"))\", n.to_string()),\n-            token::Lit::Str_(n) => format!(\"Lit::Str_(token::intern(\\\"{}\\\"))\", n.to_string()),\n-            token::Lit::ByteStr(n) => format!(\"Lit::ByteStr(token::intern(\\\"{}\\\"))\", n.to_string()),\n+            Lit::Byte(n) => format!(\"Lit::Byte(Symbol::intern(\\\"{}\\\"))\", n.to_string()),\n+            Lit::Char(n) => format!(\"Lit::Char(Symbol::intern(\\\"{}\\\"))\", n.to_string()),\n+            Lit::Float(n) => format!(\"Lit::Float(Symbol::intern(\\\"{}\\\"))\", n.to_string()),\n+            Lit::Str_(n) => format!(\"Lit::Str_(Symbol::intern(\\\"{}\\\"))\", n.to_string()),\n+            Lit::Integer(n) => format!(\"Lit::Integer(Symbol::intern(\\\"{}\\\"))\", n.to_string()),\n+            Lit::ByteStr(n) => format!(\"Lit::ByteStr(Symbol::intern(\\\"{}\\\"))\", n.to_string()),\n             _ => panic!(\"Unsupported literal\"),\n         };\n \n@@ -388,9 +391,10 @@ mod int_build {\n             Token::Underscore => lex(\"_\"),\n             Token::Literal(lit, sfx) => emit_lit(lit, sfx),\n             // fix ident expansion information... somehow\n-            Token::Ident(ident) => lex(&format!(\"Token::Ident(str_to_ident(\\\"{}\\\"))\", ident.name)),\n-            Token::Lifetime(ident) => lex(&format!(\"Token::Ident(str_to_ident(\\\"{}\\\"))\",\n-                                                   ident.name)),\n+            Token::Ident(ident) =>\n+                lex(&format!(\"Token::Ident(Ident::from_str(\\\"{}\\\"))\", ident.name)),\n+            Token::Lifetime(ident) =>\n+                lex(&format!(\"Token::Ident(Ident::from_str(\\\"{}\\\"))\", ident.name)),\n             _ => panic!(\"Unhandled case!\"),\n         }\n     }\n@@ -408,7 +412,7 @@ mod int_build {\n \n     /// Takes `input` and returns `vec![input]`.\n     pub fn build_vec(ts: TokenStream) -> TokenStream {\n-        build_mac_call(str_to_ident(\"vec\"), ts)\n+        build_mac_call(Ident::from_str(\"vec\"), ts)\n         // tts.clone().to_owned()\n     }\n "}, {"sha": "d39aba0aa7787a26854decbcca1675dbee84b9f3", "filename": "src/libproc_macro_tokens/build.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibproc_macro_tokens%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibproc_macro_tokens%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro_tokens%2Fbuild.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -13,7 +13,8 @@ extern crate syntax_pos;\n \n use syntax::ast::Ident;\n use syntax::codemap::DUMMY_SP;\n-use syntax::parse::token::{self, Token, keywords, str_to_ident};\n+use syntax::parse::token::{self, Token};\n+use syntax::symbol::keywords;\n use syntax::tokenstream::{self, TokenTree, TokenStream};\n use std::rc::Rc;\n \n@@ -43,13 +44,13 @@ pub fn ident_eq(tident: &TokenTree, id: Ident) -> bool {\n \n /// Convert a `&str` into a Token.\n pub fn str_to_token_ident(s: &str) -> Token {\n-    Token::Ident(str_to_ident(s))\n+    Token::Ident(Ident::from_str(s))\n }\n \n /// Converts a keyword (from `syntax::parse::token::keywords`) into a Token that\n /// corresponds to it.\n pub fn keyword_to_token_ident(kw: keywords::Keyword) -> Token {\n-    Token::Ident(str_to_ident(&kw.name().as_str()[..]))\n+    Token::Ident(Ident::from_str(&kw.name().as_str()[..]))\n }\n \n // ____________________________________________________________________________________________"}, {"sha": "9547e09afe0035a6942c1caca56b38afa2e28897", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -53,8 +53,8 @@ use syntax::ast::*;\n use syntax::errors;\n use syntax::ptr::P;\n use syntax::codemap::{respan, Spanned};\n-use syntax::parse::token;\n use syntax::std_inject;\n+use syntax::symbol::{Symbol, keywords};\n use syntax::visit::{self, Visitor};\n use syntax_pos::Span;\n \n@@ -149,7 +149,7 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn str_to_ident(&self, s: &'static str) -> Name {\n-        token::gensym(s)\n+        Symbol::gensym(s)\n     }\n \n     fn with_parent_def<T, F>(&mut self, parent_id: NodeId, f: F) -> T\n@@ -400,8 +400,8 @@ impl<'a> LoweringContext<'a> {\n         // Don't expose `Self` (recovered \"keyword used as ident\" parse error).\n         // `rustc::ty` expects `Self` to be only used for a trait's `Self`.\n         // Instead, use gensym(\"Self\") to create a distinct name that looks the same.\n-        if name == token::keywords::SelfType.name() {\n-            name = token::gensym(\"Self\");\n+        if name == keywords::SelfType.name() {\n+            name = Symbol::gensym(\"Self\");\n         }\n \n         hir::TyParam {\n@@ -540,7 +540,7 @@ impl<'a> LoweringContext<'a> {\n         hir::StructField {\n             span: f.span,\n             id: f.id,\n-            name: f.ident.map(|ident| ident.name).unwrap_or(token::intern(&index.to_string())),\n+            name: f.ident.map(|ident| ident.name).unwrap_or(Symbol::intern(&index.to_string())),\n             vis: self.lower_visibility(&f.vis),\n             ty: self.lower_ty(&f.ty),\n             attrs: self.lower_attrs(&f.attrs),\n@@ -1189,7 +1189,7 @@ impl<'a> LoweringContext<'a> {\n                                                                           e.span,\n                                                                           hir::PopUnstableBlock,\n                                                                           ThinVec::new());\n-                                this.field(token::intern(s), signal_block, ast_expr.span)\n+                                this.field(Symbol::intern(s), signal_block, ast_expr.span)\n                             }).collect();\n                             let attrs = ast_expr.attrs.clone();\n \n@@ -1953,9 +1953,9 @@ impl<'a> LoweringContext<'a> {\n     fn std_path_components(&mut self, components: &[&str]) -> Vec<Name> {\n         let mut v = Vec::new();\n         if let Some(s) = self.crate_root {\n-            v.push(token::intern(s));\n+            v.push(Symbol::intern(s));\n         }\n-        v.extend(components.iter().map(|s| token::intern(s)));\n+        v.extend(components.iter().map(|s| Symbol::intern(s)));\n         return v;\n     }\n "}, {"sha": "0d4c0c9689f27096762cdd3ee2c459f48ee15e53", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -19,7 +19,7 @@ use middle::cstore::InlinedItem;\n use syntax::ast::*;\n use syntax::ext::hygiene::Mark;\n use syntax::visit;\n-use syntax::parse::token::{self, keywords};\n+use syntax::symbol::{Symbol, keywords};\n \n /// Creates def ids for nodes in the HIR.\n pub struct DefCollector<'a> {\n@@ -169,7 +169,7 @@ impl<'a> visit::Visitor for DefCollector<'a> {\n                         this.with_parent(variant_def_index, |this| {\n                             for (index, field) in v.node.data.fields().iter().enumerate() {\n                                 let name = field.ident.map(|ident| ident.name)\n-                                    .unwrap_or_else(|| token::intern(&index.to_string()));\n+                                    .unwrap_or_else(|| Symbol::intern(&index.to_string()));\n                                 this.create_def(field.id, DefPathData::Field(name.as_str()));\n                             }\n \n@@ -188,7 +188,7 @@ impl<'a> visit::Visitor for DefCollector<'a> {\n \n                     for (index, field) in struct_def.fields().iter().enumerate() {\n                         let name = field.ident.map(|ident| ident.name.as_str())\n-                            .unwrap_or(token::intern(&index.to_string()).as_str());\n+                            .unwrap_or(Symbol::intern(&index.to_string()).as_str());\n                         this.create_def(field.id, DefPathData::Field(name));\n                     }\n                 }"}, {"sha": "eafcb8b6f43949e92f20e4fcd86f1849386a02c0", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -14,7 +14,7 @@ use std::fmt::Write;\n use std::hash::{Hash, Hasher};\n use std::collections::hash_map::DefaultHasher;\n use syntax::ast;\n-use syntax::parse::token::{self, InternedString};\n+use syntax::symbol::{Symbol, InternedString};\n use ty::TyCtxt;\n use util::nodemap::NodeMap;\n \n@@ -328,7 +328,7 @@ impl DefPathData {\n             LifetimeDef(ref name) |\n             EnumVariant(ref name) |\n             Binding(ref name) |\n-            Field(ref name) => Some(token::intern(name)),\n+            Field(ref name) => Some(Symbol::intern(name)),\n \n             Impl |\n             CrateRoot |"}, {"sha": "9d8f6bb5c95d34ad241842313e6485d6a7dac2a5", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -40,8 +40,8 @@ use syntax::codemap::{self, respan, Spanned};\n use syntax::abi::Abi;\n use syntax::ast::{Name, NodeId, DUMMY_NODE_ID, AsmDialect};\n use syntax::ast::{Attribute, Lit, StrStyle, FloatTy, IntTy, UintTy, MetaItem};\n-use syntax::parse::token::{keywords, InternedString};\n use syntax::ptr::P;\n+use syntax::symbol::{keywords, InternedString};\n use syntax::tokenstream::TokenTree;\n use syntax::util::ThinVec;\n "}, {"sha": "ccb43644b3152dec6ef3072f02007bf69196974a", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -13,13 +13,14 @@ pub use self::AnnNode::*;\n use syntax::abi::Abi;\n use syntax::ast;\n use syntax::codemap::{CodeMap, Spanned};\n-use syntax::parse::token::{self, keywords, BinOpToken};\n+use syntax::parse::token::{self, BinOpToken};\n use syntax::parse::lexer::comments;\n use syntax::print::pp::{self, break_offset, word, space, hardbreak};\n use syntax::print::pp::{Breaks, eof};\n use syntax::print::pp::Breaks::{Consistent, Inconsistent};\n use syntax::print::pprust::{self as ast_pp, PrintState};\n use syntax::ptr::P;\n+use syntax::symbol::keywords;\n use syntax_pos::{self, BytePos};\n use errors;\n "}, {"sha": "8db09d0b73d32485d1e2ba0f48f56e26f4a48a4c", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -91,8 +91,8 @@ use std::cell::{Cell, RefCell};\n use std::char::from_u32;\n use std::fmt;\n use syntax::ast;\n-use syntax::parse::token;\n use syntax::ptr::P;\n+use syntax::symbol::Symbol;\n use syntax_pos::{self, Pos, Span};\n use errors::DiagnosticBuilder;\n \n@@ -1219,7 +1219,7 @@ impl<'a, 'gcx, 'tcx> Rebuilder<'a, 'gcx, 'tcx> {\n                 names.push(lt_name);\n             }\n             names.sort();\n-            let name = token::intern(&names[0]);\n+            let name = Symbol::intern(&names[0]);\n             return (name_to_dummy_lifetime(name), Kept);\n         }\n         return (self.life_giver.give_lifetime(), Fresh);\n@@ -1931,7 +1931,7 @@ impl LifeGiver {\n             let mut s = String::from(\"'\");\n             s.push_str(&num_to_string(self.counter.get()));\n             if !self.taken.contains(&s) {\n-                lifetime = name_to_dummy_lifetime(token::intern(&s[..]));\n+                lifetime = name_to_dummy_lifetime(Symbol::intern(&s));\n                 self.generated.borrow_mut().push(lifetime);\n                 break;\n             }"}, {"sha": "9677082a43a3c2d03dcef9faa383e804abc54c8b", "filename": "src/librustc/middle/const_val.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_val.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use syntax::parse::token::InternedString;\n+use syntax::symbol::InternedString;\n use syntax::ast;\n use std::rc::Rc;\n use hir::def_id::DefId;"}, {"sha": "fea0a6edffe4f76614614fc16cc0cfc3a11d0eeb", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -39,7 +39,7 @@ use syntax::ast;\n use syntax::attr;\n use syntax::ext::base::SyntaxExtension;\n use syntax::ptr::P;\n-use syntax::parse::token::InternedString;\n+use syntax::symbol::InternedString;\n use syntax_pos::Span;\n use rustc_back::target::Target;\n use hir;"}, {"sha": "1b61163574e0bcb5d28f8a4fdcf3c490d96133af", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -30,7 +30,7 @@ use middle::weak_lang_items;\n use util::nodemap::FxHashMap;\n \n use syntax::ast;\n-use syntax::parse::token::InternedString;\n+use syntax::symbol::InternedString;\n use hir::itemlikevisit::ItemLikeVisitor;\n use hir;\n "}, {"sha": "cf53fcf2dac86658b82a24721743fdd5d397e42b", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -123,8 +123,8 @@ use std::io::prelude::*;\n use std::io;\n use std::rc::Rc;\n use syntax::ast::{self, NodeId};\n-use syntax::parse::token::keywords;\n use syntax::ptr::P;\n+use syntax::symbol::keywords;\n use syntax_pos::Span;\n \n use hir::Expr;"}, {"sha": "a0043d0a886208c5e475d1cf75fa92a876a4ad7b", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -27,7 +27,7 @@ use middle::region;\n use ty;\n use std::mem::replace;\n use syntax::ast;\n-use syntax::parse::token::keywords;\n+use syntax::symbol::keywords;\n use syntax_pos::Span;\n use util::nodemap::NodeMap;\n "}, {"sha": "4b8433e3bf60613e073ecd904bde182b8bde67f7", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -21,7 +21,7 @@ use hir::def::Def;\n use hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId, DefIndex, LOCAL_CRATE};\n use ty::{self, TyCtxt, AdtKind};\n use middle::privacy::AccessLevels;\n-use syntax::parse::token::InternedString;\n+use syntax::symbol::InternedString;\n use syntax_pos::{Span, DUMMY_SP};\n use syntax::ast;\n use syntax::ast::{NodeId, Attribute};"}, {"sha": "bee049df98580bade5843befc1d81652c8a3a559", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -16,7 +16,7 @@ use middle::lang_items;\n \n use rustc_back::PanicStrategy;\n use syntax::ast;\n-use syntax::parse::token::InternedString;\n+use syntax::symbol::InternedString;\n use syntax_pos::Span;\n use hir::intravisit::Visitor;\n use hir::intravisit;"}, {"sha": "9fd80acea89016029ac019bfffb6a3cbe7496ed2", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -25,8 +25,8 @@ use lint;\n use middle::cstore;\n \n use syntax::ast::{self, IntTy, UintTy};\n-use syntax::parse::{self, token};\n-use syntax::parse::token::InternedString;\n+use syntax::parse;\n+use syntax::symbol::{Symbol, InternedString};\n use syntax::feature_gate::UnstableFeatures;\n \n use errors::{ColorConfig, FatalError, Handler};\n@@ -927,7 +927,7 @@ pub fn default_lib_output() -> CrateType {\n }\n \n pub fn default_configuration(sess: &Session) -> ast::CrateConfig {\n-    use syntax::parse::token::intern_and_get_ident as intern;\n+    use syntax::symbol::intern_and_get_ident as intern;\n \n     let end = &sess.target.target.target_endian;\n     let arch = &sess.target.target.arch;\n@@ -947,33 +947,33 @@ pub fn default_configuration(sess: &Session) -> ast::CrateConfig {\n \n     let mut ret = HashSet::new();\n     // Target bindings.\n-    ret.insert((token::intern(\"target_os\"), Some(intern(os))));\n-    ret.insert((token::intern(\"target_family\"), Some(fam.clone())));\n-    ret.insert((token::intern(\"target_arch\"), Some(intern(arch))));\n-    ret.insert((token::intern(\"target_endian\"), Some(intern(end))));\n-    ret.insert((token::intern(\"target_pointer_width\"), Some(intern(wordsz))));\n-    ret.insert((token::intern(\"target_env\"), Some(intern(env))));\n-    ret.insert((token::intern(\"target_vendor\"), Some(intern(vendor))));\n+    ret.insert((Symbol::intern(\"target_os\"), Some(intern(os))));\n+    ret.insert((Symbol::intern(\"target_family\"), Some(fam.clone())));\n+    ret.insert((Symbol::intern(\"target_arch\"), Some(intern(arch))));\n+    ret.insert((Symbol::intern(\"target_endian\"), Some(intern(end))));\n+    ret.insert((Symbol::intern(\"target_pointer_width\"), Some(intern(wordsz))));\n+    ret.insert((Symbol::intern(\"target_env\"), Some(intern(env))));\n+    ret.insert((Symbol::intern(\"target_vendor\"), Some(intern(vendor))));\n     if &fam == \"windows\" || &fam == \"unix\" {\n-        ret.insert((token::intern(&fam), None));\n+        ret.insert((Symbol::intern(&fam), None));\n     }\n     if sess.target.target.options.has_elf_tls {\n-        ret.insert((token::intern(\"target_thread_local\"), None));\n+        ret.insert((Symbol::intern(\"target_thread_local\"), None));\n     }\n     for &i in &[8, 16, 32, 64, 128] {\n         if i <= max_atomic_width {\n             let s = i.to_string();\n-            ret.insert((token::intern(\"target_has_atomic\"), Some(intern(&s))));\n+            ret.insert((Symbol::intern(\"target_has_atomic\"), Some(intern(&s))));\n             if &s == wordsz {\n-                ret.insert((token::intern(\"target_has_atomic\"), Some(intern(\"ptr\"))));\n+                ret.insert((Symbol::intern(\"target_has_atomic\"), Some(intern(\"ptr\"))));\n             }\n         }\n     }\n     if sess.opts.debug_assertions {\n-        ret.insert((token::intern(\"debug_assertions\"), None));\n+        ret.insert((Symbol::intern(\"debug_assertions\"), None));\n     }\n     if sess.opts.crate_types.contains(&CrateTypeProcMacro) {\n-        ret.insert((token::intern(\"proc_macro\"), None));\n+        ret.insert((Symbol::intern(\"proc_macro\"), None));\n     }\n     return ret;\n }\n@@ -986,7 +986,7 @@ pub fn build_configuration(sess: &Session,\n     let default_cfg = default_configuration(sess);\n     // If the user wants a test runner, then add the test cfg\n     if sess.opts.test {\n-        user_cfg.insert((token::intern(\"test\"), None));\n+        user_cfg.insert((Symbol::intern(\"test\"), None));\n     }\n     user_cfg.extend(default_cfg.iter().cloned());\n     user_cfg"}, {"sha": "a9a4553f17670f20390bcfd56432ebef7c4bd050", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -28,7 +28,7 @@ use syntax::json::JsonEmitter;\n use syntax::feature_gate;\n use syntax::parse;\n use syntax::parse::ParseSess;\n-use syntax::parse::token;\n+use syntax::symbol::{Symbol, InternedString};\n use syntax::{ast, codemap};\n use syntax::feature_gate::AttributeType;\n use syntax_pos::{Span, MultiSpan};\n@@ -89,7 +89,7 @@ pub struct Session {\n     // forms a unique global identifier for the crate. It is used to allow\n     // multiple crates with the same name to coexist. See the\n     // trans::back::symbol_names module for more information.\n-    pub crate_disambiguator: RefCell<token::InternedString>,\n+    pub crate_disambiguator: RefCell<InternedString>,\n     pub features: RefCell<feature_gate::Features>,\n \n     /// The maximum recursion limit for potentially infinitely recursive\n@@ -129,7 +129,7 @@ pub struct PerfStats {\n }\n \n impl Session {\n-    pub fn local_crate_disambiguator(&self) -> token::InternedString {\n+    pub fn local_crate_disambiguator(&self) -> InternedString {\n         self.crate_disambiguator.borrow().clone()\n     }\n     pub fn struct_span_warn<'a, S: Into<MultiSpan>>(&'a self,\n@@ -610,7 +610,7 @@ pub fn build_session_(sopts: config::Options,\n         plugin_attributes: RefCell::new(Vec::new()),\n         crate_types: RefCell::new(Vec::new()),\n         dependency_formats: RefCell::new(FxHashMap()),\n-        crate_disambiguator: RefCell::new(token::intern(\"\").as_str()),\n+        crate_disambiguator: RefCell::new(Symbol::intern(\"\").as_str()),\n         features: RefCell::new(feature_gate::Features::new()),\n         recursion_limit: Cell::new(64),\n         next_node_id: Cell::new(NodeId::new(1)),"}, {"sha": "76bead99343a7f01daa0b586ce348c2fcdcd7483", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -26,8 +26,8 @@ use super::util;\n use hir::def_id::DefId;\n use infer::InferOk;\n use rustc_data_structures::snapshot_map::{Snapshot, SnapshotMap};\n-use syntax::parse::token;\n use syntax::ast;\n+use syntax::symbol::Symbol;\n use ty::subst::Subst;\n use ty::{self, ToPredicate, ToPolyTraitRef, Ty, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder};\n@@ -1245,7 +1245,7 @@ fn confirm_callable_candidate<'cx, 'gcx, 'tcx>(\n     let predicate = ty::Binder(ty::ProjectionPredicate { // (1) recreate binder here\n         projection_ty: ty::ProjectionTy {\n             trait_ref: trait_ref,\n-            item_name: token::intern(FN_OUTPUT_NAME),\n+            item_name: Symbol::intern(FN_OUTPUT_NAME),\n         },\n         ty: ret_type\n     });"}, {"sha": "d187fed732c9eb34d4604b1e8361803a8d28756e", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -49,7 +49,7 @@ use std::rc::Rc;\n use std::iter;\n use syntax::ast::{self, Name, NodeId};\n use syntax::attr;\n-use syntax::parse::token::{self, keywords};\n+use syntax::symbol::{InternedString, intern_and_get_ident, keywords};\n \n use hir;\n \n@@ -561,7 +561,7 @@ pub struct GlobalCtxt<'tcx> {\n \n     /// The definite name of the current crate after taking into account\n     /// attributes, commandline parameters, etc.\n-    pub crate_name: token::InternedString,\n+    pub crate_name: InternedString,\n \n     /// Data layout specification for the current target.\n     pub data_layout: TargetDataLayout,\n@@ -574,7 +574,7 @@ pub struct GlobalCtxt<'tcx> {\n \n     /// Map from function to the `#[derive]` mode that it's defining. Only used\n     /// by `proc-macro` crates.\n-    pub derive_macros: RefCell<NodeMap<token::InternedString>>,\n+    pub derive_macros: RefCell<NodeMap<InternedString>>,\n }\n \n impl<'tcx> GlobalCtxt<'tcx> {\n@@ -588,23 +588,23 @@ impl<'tcx> GlobalCtxt<'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    pub fn crate_name(self, cnum: CrateNum) -> token::InternedString {\n+    pub fn crate_name(self, cnum: CrateNum) -> InternedString {\n         if cnum == LOCAL_CRATE {\n             self.crate_name.clone()\n         } else {\n             self.sess.cstore.crate_name(cnum)\n         }\n     }\n \n-    pub fn original_crate_name(self, cnum: CrateNum) -> token::InternedString {\n+    pub fn original_crate_name(self, cnum: CrateNum) -> InternedString {\n         if cnum == LOCAL_CRATE {\n             self.crate_name.clone()\n         } else {\n             self.sess.cstore.original_crate_name(cnum)\n         }\n     }\n \n-    pub fn crate_disambiguator(self, cnum: CrateNum) -> token::InternedString {\n+    pub fn crate_disambiguator(self, cnum: CrateNum) -> InternedString {\n         if cnum == LOCAL_CRATE {\n             self.sess.local_crate_disambiguator()\n         } else {\n@@ -835,7 +835,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             custom_coerce_unsized_kinds: RefCell::new(DefIdMap()),\n             cast_kinds: RefCell::new(NodeMap()),\n             fragment_infos: RefCell::new(DefIdMap()),\n-            crate_name: token::intern_and_get_ident(crate_name),\n+            crate_name: intern_and_get_ident(crate_name),\n             data_layout: data_layout,\n             layout_cache: RefCell::new(FxHashMap()),\n             layout_depth: Cell::new(0),"}, {"sha": "92d5b734f17d2b133a5bd87f9b02b634236d7532", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -12,7 +12,7 @@ use hir::map::DefPathData;\n use hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use ty::{self, Ty, TyCtxt};\n use syntax::ast;\n-use syntax::parse::token;\n+use syntax::symbol::Symbol;\n \n use std::cell::Cell;\n \n@@ -136,7 +136,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n             cur_path.push(self.sess.cstore.def_key(cur_def)\n                               .disambiguated_data.data.get_opt_name().unwrap_or_else(||\n-                token::intern(\"<unnamed>\")));\n+                Symbol::intern(\"<unnamed>\")));\n             match visible_parent_map.get(&cur_def) {\n                 Some(&def) => cur_def = def,\n                 None => return false,"}, {"sha": "f7f34c0af3a1aa6597e318c8c3dde350b457478d", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -44,7 +44,7 @@ use std::vec::IntoIter;\n use std::mem;\n use syntax::ast::{self, Name, NodeId};\n use syntax::attr;\n-use syntax::parse::token::{self, InternedString};\n+use syntax::symbol::{Symbol, InternedString};\n use syntax_pos::{DUMMY_SP, Span};\n \n use rustc_const_math::ConstInt;\n@@ -2344,7 +2344,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         if let Some(id) = self.map.as_local_node_id(id) {\n             self.map.name(id)\n         } else if id.index == CRATE_DEF_INDEX {\n-            token::intern(&self.sess.cstore.original_crate_name(id.krate))\n+            Symbol::intern(&self.sess.cstore.original_crate_name(id.krate))\n         } else {\n             let def_key = self.sess.cstore.def_key(id);\n             // The name of a StructCtor is that of its struct parent."}, {"sha": "81896ecfb53411446b42aa2bc17e7b5ab70f4f76", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -23,7 +23,7 @@ use std::fmt;\n use std::ops;\n use syntax::abi;\n use syntax::ast::{self, Name};\n-use syntax::parse::token::{keywords, InternedString};\n+use syntax::symbol::{keywords, InternedString};\n \n use serialize;\n "}, {"sha": "d04825d560444facbc47d19960a4fb9b0b26f306", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -25,8 +25,8 @@ use std::fmt;\n use std::usize;\n \n use syntax::abi::Abi;\n-use syntax::parse::token;\n use syntax::ast::CRATE_NODE_ID;\n+use syntax::symbol::Symbol;\n use hir;\n \n pub fn verbose() -> bool {\n@@ -284,7 +284,7 @@ fn in_binder<'a, 'gcx, 'tcx, T, U>(f: &mut fmt::Formatter,\n             ty::BrAnon(_) |\n             ty::BrFresh(_) |\n             ty::BrEnv => {\n-                let name = token::intern(\"'r\");\n+                let name = Symbol::intern(\"'r\");\n                 let _ = write!(f, \"{}\", name);\n                 ty::BrNamed(tcx.map.local_def_id(CRATE_NODE_ID),\n                             name,"}, {"sha": "f864f08340259981eb52c9543135dd9f35ce69f9", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -53,7 +53,8 @@ use std::path::{Path, PathBuf};\n use syntax::{ast, diagnostics, visit};\n use syntax::attr;\n use syntax::ext::base::ExtCtxt;\n-use syntax::parse::{self, PResult, token};\n+use syntax::parse::{self, PResult};\n+use syntax::symbol::{self, Symbol};\n use syntax::util::node_count::NodeCounter;\n use syntax;\n use syntax_ext;\n@@ -561,7 +562,7 @@ pub fn phase_2_configure_and_expand<'a, F>(sess: &Session,\n \n     *sess.crate_types.borrow_mut() = collect_crate_types(sess, &krate.attrs);\n     *sess.crate_disambiguator.borrow_mut() =\n-        token::intern(&compute_crate_disambiguator(sess)).as_str();\n+        Symbol::intern(&compute_crate_disambiguator(sess)).as_str();\n \n     time(time_passes, \"recursion limit\", || {\n         middle::recursion_limit::update_recursion_limit(sess, &krate);\n@@ -1360,6 +1361,6 @@ pub fn build_output_filenames(input: &Input,\n pub fn reset_thread_local_state() {\n     // These may be left in an incoherent state after a previous compile.\n     syntax::ext::hygiene::reset_hygiene_data();\n-    // `clear_ident_interner` can be used to free memory, but it does not restore the initial state.\n-    token::reset_ident_interner();\n+    // `clear_interner` can be used to free memory, but it does not restore the initial state.\n+    symbol::reset_interner();\n }"}, {"sha": "6c99c9d71b81585da2090b0be656b88873703bf5", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -450,15 +450,15 @@ impl<'ast> PrinterSupport<'ast> for HygieneAnnotation<'ast> {\n impl<'ast> pprust::PpAnn for HygieneAnnotation<'ast> {\n     fn post(&self, s: &mut pprust::State, node: pprust::AnnNode) -> io::Result<()> {\n         match node {\n-            pprust::NodeIdent(&ast::Ident { name: ast::Name(nm), ctxt }) => {\n+            pprust::NodeIdent(&ast::Ident { name, ctxt }) => {\n                 pp::space(&mut s.s)?;\n                 // FIXME #16420: this doesn't display the connections\n                 // between syntax contexts\n-                s.synth_comment(format!(\"{}{:?}\", nm, ctxt))\n+                s.synth_comment(format!(\"{}{:?}\", name.as_u32(), ctxt))\n             }\n-            pprust::NodeName(&ast::Name(nm)) => {\n+            pprust::NodeName(&name) => {\n                 pp::space(&mut s.s)?;\n-                s.synth_comment(nm.to_string())\n+                s.synth_comment(name.as_u32().to_string())\n             }\n             _ => Ok(()),\n         }"}, {"sha": "677b9bca9761e8e215fc401944b474818ce75d9e", "filename": "src/librustc_driver/target_features.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_driver%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_driver%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftarget_features.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -13,7 +13,7 @@ use llvm::LLVMRustHasFeature;\n use rustc::session::Session;\n use rustc_trans::back::write::create_target_machine;\n use syntax::feature_gate::UnstableFeatures;\n-use syntax::parse::token::{self, intern_and_get_ident as intern};\n+use syntax::symbol::{Symbol, intern_and_get_ident as intern};\n use libc::c_char;\n \n // WARNING: the features must be known to LLVM or the feature\n@@ -40,7 +40,7 @@ pub fn add_configuration(cfg: &mut ast::CrateConfig, sess: &Session) {\n         _ => &[],\n     };\n \n-    let tf = token::intern(\"target_feature\");\n+    let tf = Symbol::intern(\"target_feature\");\n     for feat in whitelist {\n         assert_eq!(feat.chars().last(), Some('\\0'));\n         if unsafe { LLVMRustHasFeature(target_machine, feat.as_ptr() as *const c_char) } {"}, {"sha": "91646aa7f5d75e565d0f8e53a5a89e8f6c8bc1b9", "filename": "src/librustc_incremental/calculate_svh/svh_visitor.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -18,6 +18,7 @@ use syntax::abi::Abi;\n use syntax::ast::{self, Name, NodeId};\n use syntax::attr;\n use syntax::parse::token;\n+use syntax::symbol::InternedString;\n use syntax_pos::{Span, NO_EXPANSION, COMMAND_LINE_EXPN, BytePos};\n use syntax::tokenstream;\n use rustc::hir;\n@@ -169,8 +170,8 @@ enum SawAbiComponent<'a> {\n \n     // FIXME (#14132): should we include (some function of)\n     // ident.ctxt as well?\n-    SawIdent(token::InternedString),\n-    SawStructDef(token::InternedString),\n+    SawIdent(InternedString),\n+    SawStructDef(InternedString),\n \n     SawLifetime,\n     SawLifetimeDef(usize),\n@@ -232,11 +233,11 @@ enum SawAbiComponent<'a> {\n #[derive(Hash)]\n enum SawExprComponent<'a> {\n \n-    SawExprLoop(Option<token::InternedString>),\n-    SawExprField(token::InternedString),\n+    SawExprLoop(Option<InternedString>),\n+    SawExprField(InternedString),\n     SawExprTupField(usize),\n-    SawExprBreak(Option<token::InternedString>),\n-    SawExprAgain(Option<token::InternedString>),\n+    SawExprBreak(Option<InternedString>),\n+    SawExprAgain(Option<InternedString>),\n \n     SawExprBox,\n     SawExprArray,"}, {"sha": "4d759b666175dfd3b1ff5b5fdcad19c4b5f923fe", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -48,7 +48,7 @@ use rustc::hir::def_id::DefId;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use syntax::ast::{self, Attribute, NestedMetaItem};\n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n-use syntax::parse::token;\n+use syntax::symbol::Symbol;\n use syntax_pos::Span;\n use rustc::ty::TyCtxt;\n use ich::Fingerprint;\n@@ -286,7 +286,7 @@ fn check_config(tcx: TyCtxt, attr: &ast::Attribute) -> bool {\n \n fn expect_associated_value(tcx: TyCtxt, item: &NestedMetaItem) -> ast::Name {\n     if let Some(value) = item.value_str() {\n-        token::intern(&value)\n+        Symbol::intern(&value)\n     } else {\n         let msg = if let Some(name) = item.name() {\n             format!(\"associated value expected for `{}`\", name)"}, {"sha": "535c8094bed955333e7f7b4cc4ab0743f9a3ab8b", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -20,7 +20,7 @@ use std::collections::hash_map::Entry::{Occupied, Vacant};\n use syntax::ast;\n use syntax::attr;\n use syntax::feature_gate::{BUILTIN_ATTRIBUTES, AttributeType};\n-use syntax::parse::token::keywords;\n+use syntax::symbol::keywords;\n use syntax::ptr::P;\n use syntax_pos::Span;\n \n@@ -48,7 +48,7 @@ impl UnusedMut {\n                 let name = path1.node;\n                 if let hir::BindByValue(hir::MutMutable) = mode {\n                     if !name.as_str().starts_with(\"_\") {\n-                        match mutables.entry(name.0 as usize) {\n+                        match mutables.entry(name) {\n                             Vacant(entry) => {\n                                 entry.insert(vec![id]);\n                             }"}, {"sha": "3b162f31a94e6ad37bb1cc2b95c7390998bdd060", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -37,7 +37,7 @@ use syntax::abi::Abi;\n use syntax::attr;\n use syntax::ext::base::SyntaxExtension;\n use syntax::feature_gate::{self, GateIssue};\n-use syntax::parse::token::{self, InternedString};\n+use syntax::symbol::{Symbol, InternedString};\n use syntax_pos::{Span, DUMMY_SP};\n use log;\n \n@@ -582,11 +582,11 @@ impl<'a> CrateLoader<'a> {\n                                       trait_name: &str,\n                                       expand: fn(TokenStream) -> TokenStream,\n                                       attributes: &[&'static str]) {\n-                let attrs = attributes.iter().cloned().map(token::intern).collect();\n+                let attrs = attributes.iter().cloned().map(Symbol::intern).collect();\n                 let derive = SyntaxExtension::CustomDerive(\n                     Box::new(CustomDerive::new(expand, attrs))\n                 );\n-                self.0.push((token::intern(trait_name), Rc::new(derive)));\n+                self.0.push((Symbol::intern(trait_name), Rc::new(derive)));\n             }\n         }\n "}, {"sha": "7ab7a32bbc41d42c61f56f3fe772a42ddedbe400", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -31,7 +31,8 @@ use rustc_back::PanicStrategy;\n use std::path::PathBuf;\n use syntax::ast;\n use syntax::attr;\n-use syntax::parse::{token, new_parser_from_source_str};\n+use syntax::parse::new_parser_from_source_str;\n+use syntax::symbol::{InternedString, intern_and_get_ident};\n use syntax_pos::mk_sp;\n use rustc::hir::svh::Svh;\n use rustc_back::target::Target;\n@@ -262,14 +263,14 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         self.get_crate_data(cnum).panic_strategy()\n     }\n \n-    fn crate_name(&self, cnum: CrateNum) -> token::InternedString\n+    fn crate_name(&self, cnum: CrateNum) -> InternedString\n     {\n-        token::intern_and_get_ident(&self.get_crate_data(cnum).name[..])\n+        intern_and_get_ident(&self.get_crate_data(cnum).name[..])\n     }\n \n-    fn original_crate_name(&self, cnum: CrateNum) -> token::InternedString\n+    fn original_crate_name(&self, cnum: CrateNum) -> InternedString\n     {\n-        token::intern_and_get_ident(&self.get_crate_data(cnum).name())\n+        intern_and_get_ident(&self.get_crate_data(cnum).name())\n     }\n \n     fn extern_crate(&self, cnum: CrateNum) -> Option<ExternCrate>\n@@ -282,9 +283,9 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         self.get_crate_hash(cnum)\n     }\n \n-    fn crate_disambiguator(&self, cnum: CrateNum) -> token::InternedString\n+    fn crate_disambiguator(&self, cnum: CrateNum) -> InternedString\n     {\n-        token::intern_and_get_ident(&self.get_crate_data(cnum).disambiguator())\n+        intern_and_get_ident(&self.get_crate_data(cnum).disambiguator())\n     }\n \n     fn plugin_registrar_fn(&self, cnum: CrateNum) -> Option<DefId>"}, {"sha": "c11694e561a7c990099f892019d86331cd9058be", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -34,7 +34,7 @@ use std::rc::Rc;\n use std::u32;\n use syntax::ast::{self, CRATE_NODE_ID};\n use syntax::attr;\n-use syntax;\n+use syntax::symbol::Symbol;\n use syntax_pos;\n \n use rustc::hir::{self, PatKind};\n@@ -600,7 +600,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             if let PatKind::Binding(_, ref path1, _) = arg.pat.node {\n                 path1.node\n             } else {\n-                syntax::parse::token::intern(\"\")\n+                Symbol::intern(\"\")\n             }\n         }))\n     }\n@@ -1119,7 +1119,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let deps = get_ordered_deps(self.cstore);\n         self.lazy_seq(deps.iter().map(|&(_, ref dep)| {\n             CrateDep {\n-                name: syntax::parse::token::intern(dep.name()),\n+                name: Symbol::intern(dep.name()),\n                 hash: dep.hash(),\n                 kind: dep.dep_kind.get(),\n             }"}, {"sha": "d281b2a32d045619b08460aa394a904b8d2bb92e", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -18,7 +18,7 @@ use rustc::util::nodemap::NodeMap;\n use rustc::hir;\n use syntax::abi::Abi;\n use syntax::ast;\n-use syntax::parse::token::keywords;\n+use syntax::symbol::keywords;\n use syntax_pos::Span;\n \n use rustc_data_structures::indexed_vec::{IndexVec, Idx};"}, {"sha": "83809ba76358945d62530c7e677bf105a343c1c4", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -29,7 +29,7 @@ use rustc::hir::map::blocks::FnLikeNode;\n use rustc::infer::InferCtxt;\n use rustc::ty::subst::Subst;\n use rustc::ty::{self, Ty, TyCtxt};\n-use syntax::parse::token;\n+use syntax::symbol::{Symbol, InternedString};\n use rustc::hir;\n use rustc_const_math::{ConstInt, ConstUsize};\n \n@@ -121,7 +121,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         self.tcx.mk_nil()\n     }\n \n-    pub fn str_literal(&mut self, value: token::InternedString) -> Literal<'tcx> {\n+    pub fn str_literal(&mut self, value: InternedString) -> Literal<'tcx> {\n         Literal::Value { value: ConstVal::Str(value) }\n     }\n \n@@ -145,7 +145,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n                         self_ty: Ty<'tcx>,\n                         params: &[Ty<'tcx>])\n                         -> (Ty<'tcx>, Literal<'tcx>) {\n-        let method_name = token::intern(method_name);\n+        let method_name = Symbol::intern(method_name);\n         let substs = self.tcx.mk_substs_trait(self_ty, params);\n         for item in self.tcx.associated_items(trait_def_id) {\n             if item.kind == ty::AssociatedKind::Method && item.name == method_name {"}, {"sha": "7c6dc6b08801bd446df9a75e761ed41b68d3bd8b", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -21,7 +21,8 @@ use rustc::session::Session;\n use syntax::ast::*;\n use syntax::attr;\n use syntax::codemap::Spanned;\n-use syntax::parse::token::{self, keywords};\n+use syntax::parse::token;\n+use syntax::symbol::keywords;\n use syntax::visit::{self, Visitor};\n use syntax_pos::Span;\n use errors;"}, {"sha": "d9fd89b4a776a89c7c6e8aec9c3ea92fbacf11b2", "filename": "src/librustc_plugin/registry.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_plugin%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_plugin%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fregistry.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -17,7 +17,7 @@ use rustc::mir::transform::MirMapPass;\n \n use syntax::ext::base::{SyntaxExtension, NamedSyntaxExtension, NormalTT, IdentTT};\n use syntax::ext::base::MacroExpanderFn;\n-use syntax::parse::token;\n+use syntax::symbol::Symbol;\n use syntax::ast;\n use syntax::feature_gate::AttributeType;\n use syntax_pos::Span;\n@@ -121,7 +121,7 @@ impl<'a> Registry<'a> {\n     /// It builds for you a `NormalTT` that calls `expander`,\n     /// and also takes care of interning the macro's name.\n     pub fn register_macro(&mut self, name: &str, expander: MacroExpanderFn) {\n-        self.register_syntax_extension(token::intern(name),\n+        self.register_syntax_extension(Symbol::intern(name),\n                                        NormalTT(Box::new(expander), None, false));\n     }\n "}, {"sha": "6ec825a06374bdf4edb20c8845c0aa5caa290a31", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -40,7 +40,7 @@ use syntax::ext::base::Determinacy::Undetermined;\n use syntax::ext::expand::mark_tts;\n use syntax::ext::hygiene::Mark;\n use syntax::ext::tt::macro_rules;\n-use syntax::parse::token::keywords;\n+use syntax::symbol::keywords;\n use syntax::visit::{self, Visitor};\n \n use syntax_pos::{Span, DUMMY_SP};"}, {"sha": "ec6e762100d99a6033b3d0e22d4f659ba9ac4869", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -57,7 +57,7 @@ use syntax::ext::hygiene::{Mark, SyntaxContext};\n use syntax::ast::{self, FloatTy};\n use syntax::ast::{CRATE_NODE_ID, Name, NodeId, Ident, SpannedIdent, IntTy, UintTy};\n use syntax::ext::base::SyntaxExtension;\n-use syntax::parse::token::{self, keywords};\n+use syntax::symbol::{Symbol, InternedString, keywords};\n use syntax::util::lev_distance::find_best_match_for_name;\n \n use syntax::visit::{self, FnKind, Visitor};\n@@ -90,7 +90,7 @@ mod resolve_imports;\n \n enum SuggestionType {\n     Macro(String),\n-    Function(token::InternedString),\n+    Function(InternedString),\n     NotFound,\n }\n \n@@ -1039,7 +1039,7 @@ impl PrimitiveTypeTable {\n     }\n \n     fn intern(&mut self, string: &str, primitive_type: PrimTy) {\n-        self.primitive_types.insert(token::intern(string), primitive_type);\n+        self.primitive_types.insert(Symbol::intern(string), primitive_type);\n     }\n }\n \n@@ -3606,7 +3606,7 @@ fn module_to_string(module: Module) -> String {\n             }\n         } else {\n             // danger, shouldn't be ident?\n-            names.push(token::str_to_ident(\"<opaque>\"));\n+            names.push(Ident::from_str(\"<opaque>\"));\n             collect_mod(names, module.parent.unwrap());\n         }\n     }"}, {"sha": "87b2b88fe33fccb7dac9494aecc7a86ac805cf97", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -39,7 +39,8 @@ use std::collections::hash_map::DefaultHasher;\n use std::hash::*;\n \n use syntax::ast::{self, NodeId, PatKind, Attribute, CRATE_NODE_ID};\n-use syntax::parse::token::{self, keywords};\n+use syntax::parse::token;\n+use syntax::symbol::keywords;\n use syntax::visit::{self, Visitor};\n use syntax::print::pprust::{path_to_string, ty_to_string, bounds_to_string, generics_to_string};\n use syntax::ptr::P;"}, {"sha": "563d87a09b85fe285ec4ceb1890040c4419a3160", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -54,7 +54,8 @@ use std::path::{Path, PathBuf};\n \n use syntax::ast::{self, NodeId, PatKind, Attribute, CRATE_NODE_ID};\n use syntax::parse::lexer::comments::strip_doc_comment_decoration;\n-use syntax::parse::token::{self, keywords};\n+use syntax::parse::token;\n+use syntax::symbol::{Symbol, keywords};\n use syntax::visit::{self, Visitor};\n use syntax::print::pprust::{ty_to_string, arg_to_string};\n use syntax::codemap::MacroAttribute;\n@@ -728,7 +729,7 @@ impl Visitor for PathCollector {\n }\n \n fn docs_for_attrs(attrs: &[Attribute]) -> String {\n-    let doc = token::intern(\"doc\");\n+    let doc = Symbol::intern(\"doc\");\n     let mut result = String::new();\n \n     for attr in attrs {"}, {"sha": "e06aefd865f1ba6486c1dadf5ab4bb10081f0f84", "filename": "src/librustc_save_analysis/span_utils.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fspan_utils.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -18,7 +18,8 @@ use std::path::Path;\n \n use syntax::ast;\n use syntax::parse::lexer::{self, Reader, StringReader};\n-use syntax::parse::token::{self, keywords, Token};\n+use syntax::parse::token::{self, Token};\n+use syntax::symbol::keywords;\n use syntax_pos::*;\n \n #[derive(Clone)]"}, {"sha": "e3ebb0fabfccbf68fab56047ed722d8510a61a15", "filename": "src/librustc_trans/assert_module_sources.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_trans%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_trans%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fassert_module_sources.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -29,7 +29,7 @@\n \n use rustc::ty::TyCtxt;\n use syntax::ast;\n-use syntax::parse::token;\n+use syntax::symbol::Symbol;\n \n use {ModuleSource, ModuleTranslation};\n \n@@ -117,7 +117,7 @@ impl<'a, 'tcx> AssertModuleSource<'a, 'tcx> {\n         for item in attr.meta_item_list().unwrap_or(&[]) {\n             if item.check_name(name) {\n                 if let Some(value) = item.value_str() {\n-                    return token::intern(&value);\n+                    return Symbol::intern(&value);\n                 } else {\n                     self.tcx.sess.span_fatal(\n                         item.span,"}, {"sha": "30143b335d6427066102f521ff8ec768e45f3bf5", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -113,7 +113,7 @@ use rustc::hir::map::definitions::{DefPath, DefPathData};\n use rustc::util::common::record_time;\n \n use syntax::attr;\n-use syntax::parse::token::{self, InternedString};\n+use syntax::symbol::{Symbol, InternedString, intern_and_get_ident};\n \n fn get_symbol_hash<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n \n@@ -275,7 +275,7 @@ impl ItemPathBuffer for SymbolPathBuffer {\n     }\n \n     fn push(&mut self, text: &str) {\n-        self.names.push(token::intern(text).as_str());\n+        self.names.push(Symbol::intern(text).as_str());\n     }\n }\n \n@@ -288,7 +288,7 @@ pub fn exported_name_from_type_and_prefix<'a, 'tcx>(scx: &SharedCrateContext<'a,\n         krate: LOCAL_CRATE,\n     };\n     let hash = get_symbol_hash(scx, &empty_def_path, t, None);\n-    let path = [token::intern_and_get_ident(prefix)];\n+    let path = [intern_and_get_ident(prefix)];\n     mangle(path.iter().cloned(), &hash)\n }\n "}, {"sha": "29925d964da253d4b7a26ae008b72575bbf920a1", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -52,8 +52,7 @@ use std::ffi::CString;\n use std::cell::{Cell, RefCell, Ref};\n \n use syntax::ast;\n-use syntax::parse::token::InternedString;\n-use syntax::parse::token;\n+use syntax::symbol::{Symbol, InternedString};\n use syntax_pos::{DUMMY_SP, Span};\n \n pub use context::{CrateContext, SharedCrateContext};\n@@ -225,7 +224,7 @@ impl<'a, 'tcx> VariantInfo<'tcx> {\n                 VariantInfo {\n                     discr: Disr(0),\n                     fields: v.iter().enumerate().map(|(i, &t)| {\n-                        Field(token::intern(&i.to_string()), t)\n+                        Field(Symbol::intern(&i.to_string()), t)\n                     }).collect()\n                 }\n             }"}, {"sha": "771c5ef6d9d28c019b45bdecc93be31b3d8293ad", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -42,7 +42,7 @@ use std::ptr;\n use std::rc::Rc;\n use std::str;\n use syntax::ast;\n-use syntax::parse::token::InternedString;\n+use syntax::symbol::InternedString;\n use abi::FnType;\n \n pub struct Stats {"}, {"sha": "cecf698fdc0add8768b56a61b493f46063ddb4e9", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -45,9 +45,8 @@ use std::fmt::Write;\n use std::path::Path;\n use std::ptr;\n use std::rc::Rc;\n-use syntax::util::interner::Interner;\n use syntax::ast;\n-use syntax::parse::token;\n+use syntax::symbol::{Interner, InternedString};\n use syntax_pos::{self, Span};\n \n \n@@ -1566,7 +1565,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     fn get_enum_discriminant_name(cx: &CrateContext,\n                                   def_id: DefId)\n-                                  -> token::InternedString {\n+                                  -> InternedString {\n         cx.tcx().item_name(def_id).as_str()\n     }\n }"}, {"sha": "98294cb8695ddae215694a4ee9ff9ef4361caa22", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -30,7 +30,7 @@ use rustc::ty::{self, Ty};\n use Disr;\n use rustc::hir;\n use syntax::ast;\n-use syntax::parse::token;\n+use syntax::symbol::intern_and_get_ident;\n \n use rustc::session::Session;\n use syntax_pos::{Span, DUMMY_SP};\n@@ -208,7 +208,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         }\n         (_, \"type_name\") => {\n             let tp_ty = substs.type_at(0);\n-            let ty_name = token::intern_and_get_ident(&tp_ty.to_string());\n+            let ty_name = intern_and_get_ident(&tp_ty.to_string());\n             C_str_slice(ccx, ty_name)\n         }\n         (_, \"type_id\") => {"}, {"sha": "ce1507e8181e4917a5a1f967286435166031e8cc", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -30,7 +30,7 @@ use glue;\n use type_::Type;\n \n use rustc_data_structures::fx::FxHashMap;\n-use syntax::parse::token;\n+use syntax::symbol::intern_and_get_ident;\n \n use super::{MirContext, LocalRef};\n use super::analyze::CleanupKind;\n@@ -321,7 +321,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n                 // Get the location information.\n                 let loc = bcx.sess().codemap().lookup_char_pos(span.lo);\n-                let filename = token::intern_and_get_ident(&loc.file.name);\n+                let filename = intern_and_get_ident(&loc.file.name);\n                 let filename = C_str_slice(bcx.ccx(), filename);\n                 let line = C_u32(bcx.ccx(), loc.line as u32);\n \n@@ -351,7 +351,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                          const_err)\n                     }\n                     mir::AssertMessage::Math(ref err) => {\n-                        let msg_str = token::intern_and_get_ident(err.description());\n+                        let msg_str = intern_and_get_ident(err.description());\n                         let msg_str = C_str_slice(bcx.ccx(), msg_str);\n                         let msg_file_line = C_struct(bcx.ccx(),\n                                                      &[msg_str, filename, line],"}, {"sha": "12cbfcef7d26b17cc50f2a699cfac7c55da2bc6a", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -21,7 +21,7 @@ use machine;\n use type_of;\n \n use syntax_pos::{DUMMY_SP, NO_EXPANSION, COMMAND_LINE_EXPN, BytePos};\n-use syntax::parse::token::keywords;\n+use syntax::symbol::keywords;\n \n use std::cell::Ref;\n use std::iter;"}, {"sha": "06b6c950293d9736a76236f3f594bee9f3fa5efa", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -132,7 +132,7 @@ use std::sync::Arc;\n use std::collections::hash_map::DefaultHasher;\n use symbol_map::SymbolMap;\n use syntax::ast::NodeId;\n-use syntax::parse::token::{self, InternedString};\n+use syntax::symbol::{InternedString, intern_and_get_ident};\n use trans_item::TransItem;\n use util::nodemap::{FxHashMap, FxHashSet};\n \n@@ -542,11 +542,11 @@ fn compute_codegen_unit_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         mod_path.push_str(\".volatile\");\n     }\n \n-    return token::intern_and_get_ident(&mod_path[..]);\n+    return intern_and_get_ident(&mod_path[..]);\n }\n \n fn numbered_codegen_unit_name(crate_name: &str, index: usize) -> InternedString {\n-    token::intern_and_get_ident(&format!(\"{}{}{}\",\n+    intern_and_get_ident(&format!(\"{}{}{}\",\n         crate_name,\n         NUMBERED_CODEGEN_UNIT_MARKER,\n         index)[..])"}, {"sha": "adb660c25aee9879d3264fb9011940629dc6f866", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -71,7 +71,7 @@ use util::nodemap::{NodeMap, FxHashSet};\n use std::cell::RefCell;\n use syntax::{abi, ast};\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n-use syntax::parse::token::{self, keywords};\n+use syntax::symbol::{Symbol, keywords};\n use syntax_pos::{Span, Pos};\n use errors::DiagnosticBuilder;\n \n@@ -645,7 +645,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         };\n \n         let output_binding = ConvertedBinding {\n-            item_name: token::intern(FN_OUTPUT_NAME),\n+            item_name: Symbol::intern(FN_OUTPUT_NAME),\n             ty: output,\n             span: output_span\n         };"}, {"sha": "e72dba858c562160dbc42da65d4a53cc8f60109e", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -20,7 +20,7 @@ use rustc::ty::{LvaluePreference, NoPreference, PreferMutLvalue};\n use rustc::hir;\n \n use syntax_pos::Span;\n-use syntax::parse::token;\n+use syntax::symbol::Symbol;\n \n #[derive(Copy, Clone, Debug)]\n enum AutoderefKind {\n@@ -120,7 +120,7 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n         let normalized = traits::normalize_projection_type(&mut selcx,\n                                                            ty::ProjectionTy {\n                                                                trait_ref: trait_ref,\n-                                                               item_name: token::intern(\"Target\"),\n+                                                               item_name: Symbol::intern(\"Target\"),\n                                                            },\n                                                            cause,\n                                                            0);\n@@ -198,7 +198,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             (PreferMutLvalue, Some(trait_did)) => {\n                 self.lookup_method_in_trait(span,\n                                             base_expr,\n-                                            token::intern(\"deref_mut\"),\n+                                            Symbol::intern(\"deref_mut\"),\n                                             trait_did,\n                                             base_ty,\n                                             None)\n@@ -211,7 +211,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             (None, Some(trait_did)) => {\n                 self.lookup_method_in_trait(span,\n                                             base_expr,\n-                                            token::intern(\"deref\"),\n+                                            Symbol::intern(\"deref\"),\n                                             trait_did,\n                                             base_ty,\n                                             None)"}, {"sha": "548f37cea06bcf9a2415c62a3533e4d091804b4c", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -16,7 +16,7 @@ use hir::def_id::{DefId, LOCAL_CRATE};\n use hir::print;\n use rustc::{infer, traits};\n use rustc::ty::{self, LvaluePreference, Ty};\n-use syntax::parse::token;\n+use syntax::symbol::Symbol;\n use syntax::ptr::P;\n use syntax_pos::Span;\n \n@@ -160,9 +160,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                   -> Option<ty::MethodCallee<'tcx>> {\n         // Try the options that are least restrictive on the caller first.\n         for &(opt_trait_def_id, method_name) in\n-            &[(self.tcx.lang_items.fn_trait(), token::intern(\"call\")),\n-              (self.tcx.lang_items.fn_mut_trait(), token::intern(\"call_mut\")),\n-              (self.tcx.lang_items.fn_once_trait(), token::intern(\"call_once\"))] {\n+            &[(self.tcx.lang_items.fn_trait(), Symbol::intern(\"call\")),\n+              (self.tcx.lang_items.fn_mut_trait(), Symbol::intern(\"call_mut\")),\n+              (self.tcx.lang_items.fn_once_trait(), Symbol::intern(\"call_once\"))] {\n             let trait_def_id = match opt_trait_def_id {\n                 Some(def_id) => def_id,\n                 None => continue,"}, {"sha": "a07573a7b9eab08c9578f7bfa36d835b412dc060", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -21,7 +21,7 @@ use {CrateCtxt, require_same_types};\n \n use syntax::abi::Abi;\n use syntax::ast;\n-use syntax::parse::token;\n+use syntax::symbol::Symbol;\n use syntax_pos::Span;\n \n use rustc::hir;\n@@ -75,7 +75,7 @@ fn equate_intrinsic_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n /// and in libcore/intrinsics.rs\n pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &hir::ForeignItem) {\n     fn param<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, n: u32) -> Ty<'tcx> {\n-        let name = token::intern(&format!(\"P{}\", n));\n+        let name = Symbol::intern(&format!(\"P{}\", n));\n         ccx.tcx.mk_param(n, name)\n     }\n \n@@ -326,7 +326,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &hir::ForeignItem) {\n pub fn check_platform_intrinsic_type(ccx: &CrateCtxt,\n                                      it: &hir::ForeignItem) {\n     let param = |n| {\n-        let name = token::intern(&format!(\"P{}\", n));\n+        let name = Symbol::intern(&format!(\"P{}\", n));\n         ccx.tcx.mk_param(n, name)\n     };\n "}, {"sha": "7f03c51b9ea345f226509422e940d5666d4c12d0", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -115,8 +115,8 @@ use syntax::ast;\n use syntax::attr;\n use syntax::codemap::{self, original_sp, Spanned};\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n-use syntax::parse::token::{self, InternedString, keywords};\n use syntax::ptr::P;\n+use syntax::symbol::{Symbol, InternedString, keywords};\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax_pos::{self, BytePos, Span};\n \n@@ -2369,7 +2369,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             (PreferMutLvalue, Some(trait_did)) => {\n                 self.lookup_method_in_trait_adjusted(expr.span,\n                                                      Some(&base_expr),\n-                                                     token::intern(\"index_mut\"),\n+                                                     Symbol::intern(\"index_mut\"),\n                                                      trait_did,\n                                                      autoderefs,\n                                                      unsize,\n@@ -2384,7 +2384,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             (None, Some(trait_did)) => {\n                 self.lookup_method_in_trait_adjusted(expr.span,\n                                                      Some(&base_expr),\n-                                                     token::intern(\"index\"),\n+                                                     Symbol::intern(\"index\"),\n                                                      trait_did,\n                                                      autoderefs,\n                                                      unsize,"}, {"sha": "adb8c6be42bc1ed6ed861e1e00b3c44938491f7b", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -14,7 +14,7 @@ use super::FnCtxt;\n use hir::def_id::DefId;\n use rustc::ty::{Ty, TypeFoldable, PreferMutLvalue};\n use syntax::ast;\n-use syntax::parse::token;\n+use syntax::symbol::Symbol;\n use rustc::hir;\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n@@ -182,7 +182,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let rhs_ty_var = self.next_ty_var();\n \n         let return_ty = match self.lookup_op_method(expr, lhs_ty, vec![rhs_ty_var],\n-                                                    token::intern(name), trait_def_id,\n+                                                    Symbol::intern(name), trait_def_id,\n                                                     lhs_expr) {\n             Ok(return_ty) => return_ty,\n             Err(()) => {\n@@ -248,9 +248,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                            -> Ty<'tcx>\n     {\n         assert!(op.is_by_value());\n-        match self.lookup_op_method(ex, operand_ty, vec![],\n-                                    token::intern(mname), trait_did,\n-                                    operand_expr) {\n+        let mname = Symbol::intern(mname);\n+        match self.lookup_op_method(ex, operand_ty, vec![], mname, trait_did, operand_expr) {\n             Ok(t) => t,\n             Err(()) => {\n                 self.type_error_message(ex.span, |actual| {"}, {"sha": "48d79a3ba4c87bb7b5fd932e0abbf7bb6f22d9ab", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -79,7 +79,7 @@ use rustc_const_math::ConstInt;\n use std::cell::RefCell;\n \n use syntax::{abi, ast, attr};\n-use syntax::parse::token::{self, keywords};\n+use syntax::symbol::{Symbol, keywords};\n use syntax_pos::Span;\n \n use rustc::hir::{self, map as hir_map, print as pprust};\n@@ -585,7 +585,7 @@ fn convert_closure<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let upvar_decls : Vec<_> = tcx.with_freevars(node_id, |fv| {\n         fv.iter().enumerate().map(|(i, _)| ty::TypeParameterDef {\n             index: (base_generics.count() as u32) + (i as u32),\n-            name: token::intern(\"<upvar>\"),\n+            name: Symbol::intern(\"<upvar>\"),\n             def_id: def_id,\n             default_def_id: base_def_id,\n             default: None,"}, {"sha": "a001985ded9ff8d02dcc234e4ee9b5e53510ec37", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 8, "deletions": 43, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -14,15 +14,16 @@ pub use self::TyParamBound::*;\n pub use self::UnsafeSource::*;\n pub use self::ViewPath_::*;\n pub use self::PathParameters::*;\n+pub use symbol::Symbol as Name;\n pub use util::ThinVec;\n \n use syntax_pos::{mk_sp, Span, DUMMY_SP, ExpnId};\n use codemap::{respan, Spanned};\n use abi::Abi;\n use ext::hygiene::SyntaxContext;\n-use parse::token::{self, keywords, InternedString};\n use print::pprust;\n use ptr::P;\n+use symbol::{Symbol, keywords, InternedString};\n use tokenstream::{TokenTree};\n \n use std::collections::HashSet;\n@@ -32,60 +33,24 @@ use std::u32;\n \n use serialize::{self, Encodable, Decodable, Encoder, Decoder};\n \n-/// A name is a part of an identifier, representing a string or gensym. It's\n-/// the result of interning.\n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub struct Name(pub u32);\n-\n /// An identifier contains a Name (index into the interner\n /// table) and a SyntaxContext to track renaming and\n /// macro expansion per Flatt et al., \"Macros That Work Together\"\n #[derive(Clone, Copy, PartialEq, Eq, Hash)]\n pub struct Ident {\n-    pub name: Name,\n+    pub name: Symbol,\n     pub ctxt: SyntaxContext\n }\n \n-impl Name {\n-    pub fn as_str(self) -> token::InternedString {\n-        token::InternedString::new_from_name(self)\n-    }\n-}\n-\n-impl fmt::Debug for Name {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}({})\", self, self.0)\n-    }\n-}\n-\n-impl fmt::Display for Name {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Display::fmt(&self.as_str(), f)\n-    }\n-}\n-\n-impl Encodable for Name {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_str(&self.as_str())\n-    }\n-}\n-\n-impl Decodable for Name {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<Name, D::Error> {\n-        Ok(token::intern(&d.read_str()?))\n-    }\n-}\n-\n-impl<'a> ::std::cmp::PartialEq<&'a str> for Name {\n-    fn eq(&self, other: &&str) -> bool {\n-        *self.as_str() == **other\n-    }\n-}\n-\n impl Ident {\n     pub const fn with_empty_ctxt(name: Name) -> Ident {\n         Ident { name: name, ctxt: SyntaxContext::empty() }\n     }\n+\n+   /// Maps a string to an identifier with an empty syntax context.\n+   pub fn from_str(s: &str) -> Ident {\n+       Ident::with_empty_ctxt(Symbol::intern(s))\n+   }\n }\n \n impl fmt::Debug for Ident {"}, {"sha": "4fce739efe22ab2fe3b7d56d113be294a4d14cd8", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -23,9 +23,9 @@ use syntax_pos::{Span, BytePos, DUMMY_SP};\n use errors::Handler;\n use feature_gate::{Features, GatedCfg};\n use parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n-use parse::token::InternedString;\n-use parse::{ParseSess, token};\n+use parse::ParseSess;\n use ptr::P;\n+use symbol::{self, Symbol, InternedString};\n use util::ThinVec;\n \n use std::cell::{RefCell, Cell};\n@@ -278,8 +278,8 @@ impl Attribute {\n         if self.is_sugared_doc {\n             let comment = self.value_str().unwrap();\n             let meta = mk_name_value_item_str(\n-                token::intern(\"doc\"),\n-                token::intern_and_get_ident(&strip_doc_comment_decoration(\n+                Symbol::intern(\"doc\"),\n+                symbol::intern_and_get_ident(&strip_doc_comment_decoration(\n                         &comment)));\n             if self.style == ast::AttrStyle::Outer {\n                 f(&mk_attr_outer(self.id, meta))\n@@ -392,7 +392,7 @@ pub fn mk_sugared_doc_attr(id: AttrId, text: InternedString, lo: BytePos, hi: By\n         style: style,\n         value: MetaItem {\n             span: mk_sp(lo, hi),\n-            name: token::intern(\"doc\"),\n+            name: Symbol::intern(\"doc\"),\n             node: MetaItemKind::NameValue(lit),\n         },\n         is_sugared_doc: true,"}, {"sha": "aa81d7afcb359c55bcc6938c1751e18a43166c0c", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -19,6 +19,7 @@ use ext::base::{ExtCtxt, MacEager, MacResult};\n use ext::build::AstBuilder;\n use parse::token;\n use ptr::P;\n+use symbol::Symbol;\n use tokenstream::{TokenTree};\n use util::small_vector::SmallVector;\n \n@@ -141,7 +142,7 @@ pub fn expand_register_diagnostic<'cx>(ecx: &'cx mut ExtCtxt,\n             ));\n         }\n     });\n-    let sym = Ident::with_empty_ctxt(token::gensym(&format!(\n+    let sym = Ident::with_empty_ctxt(Symbol::gensym(&format!(\n         \"__register_diagnostic_{}\", code\n     )));\n     MacEager::items(SmallVector::many(vec!["}, {"sha": "0fd360ba2e473549635a3ad18ddce50123b545f5", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -20,8 +20,8 @@ use ext::hygiene::Mark;\n use fold::{self, Folder};\n use parse::{self, parser};\n use parse::token;\n-use parse::token::{InternedString, str_to_ident};\n use ptr::P;\n+use symbol::{Symbol, InternedString};\n use util::small_vector::SmallVector;\n \n use std::path::PathBuf;\n@@ -735,7 +735,7 @@ impl<'a> ExtCtxt<'a> {\n         self.ecfg.trace_mac = x\n     }\n     pub fn ident_of(&self, st: &str) -> ast::Ident {\n-        str_to_ident(st)\n+        ast::Ident::from_str(st)\n     }\n     pub fn std_path(&self, components: &[&str]) -> Vec<ast::Ident> {\n         let mut v = Vec::new();\n@@ -746,7 +746,7 @@ impl<'a> ExtCtxt<'a> {\n         return v\n     }\n     pub fn name_of(&self, st: &str) -> ast::Name {\n-        token::intern(st)\n+        Symbol::intern(st)\n     }\n }\n "}, {"sha": "b96a46245080b88be58276dd147fece93d1011e8", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -14,8 +14,8 @@ use attr;\n use syntax_pos::{Span, DUMMY_SP, Pos};\n use codemap::{dummy_spanned, respan, Spanned};\n use ext::base::ExtCtxt;\n-use parse::token::{self, keywords, InternedString};\n use ptr::P;\n+use symbol::{intern_and_get_ident, keywords, InternedString};\n \n // Transitional reexports so qquote can find the paths it is looking for\n mod syntax {\n@@ -787,8 +787,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n \n     fn expr_fail(&self, span: Span, msg: InternedString) -> P<ast::Expr> {\n         let loc = self.codemap().lookup_char_pos(span.lo);\n-        let expr_file = self.expr_str(span,\n-                                      token::intern_and_get_ident(&loc.file.name));\n+        let expr_file = self.expr_str(span, intern_and_get_ident(&loc.file.name));\n         let expr_line = self.expr_u32(span, loc.line as u32);\n         let expr_file_line_tuple = self.expr_tuple(span, vec![expr_file, expr_line]);\n         let expr_file_line_ptr = self.expr_addr_of(span, expr_file_line_tuple);"}, {"sha": "f033b3400d0f2fc0b35bf9862b2e6d89e5444d9e", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -23,10 +23,11 @@ use fold;\n use fold::*;\n use parse::{ParseSess, PResult, lexer};\n use parse::parser::Parser;\n-use parse::token::{self, keywords};\n+use parse::token;\n use print::pprust;\n use ptr::P;\n use std_inject;\n+use symbol::keywords;\n use tokenstream::{TokenTree, TokenStream};\n use util::small_vector::SmallVector;\n use visit::Visitor;\n@@ -190,7 +191,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     pub fn expand_crate(&mut self, mut krate: ast::Crate) -> ast::Crate {\n         self.cx.crate_root = std_inject::injected_crate_name(&krate);\n         let mut module = ModuleData {\n-            mod_path: vec![token::str_to_ident(&self.cx.ecfg.crate_name)],\n+            mod_path: vec![Ident::from_str(&self.cx.ecfg.crate_name)],\n             directory: PathBuf::from(self.cx.codemap().span_to_filename(krate.span)),\n         };\n         module.directory.pop();\n@@ -246,7 +247,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     self.cx.resolver.resolve_macro(scope, &mac.node.path, force)\n                 }\n                 InvocationKind::Attr { ref attr, .. } => {\n-                    let ident = ast::Ident::with_empty_ctxt(attr.name());\n+                    let ident = Ident::with_empty_ctxt(attr.name());\n                     let path = ast::Path::from_ident(attr.span, ident);\n                     self.cx.resolver.resolve_macro(scope, &path, force)\n                 }"}, {"sha": "4fe57a8345e94e707c71192c0f5f0f3bb8b06cbf", "filename": "src/libsyntax/ext/placeholders.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fplaceholders.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -13,8 +13,8 @@ use codemap::{DUMMY_SP, dummy_spanned};\n use ext::base::ExtCtxt;\n use ext::expand::{Expansion, ExpansionKind};\n use fold::*;\n-use parse::token::{intern, keywords};\n use ptr::P;\n+use symbol::{Symbol, keywords};\n use util::move_map::MoveMap;\n use util::small_vector::SmallVector;\n \n@@ -227,7 +227,7 @@ pub fn reconstructed_macro_rules(def: &ast::MacroDef) -> Expansion {\n                     span: DUMMY_SP,\n                     global: false,\n                     segments: vec![ast::PathSegment {\n-                        identifier: ast::Ident::with_empty_ctxt(intern(\"macro_rules\")),\n+                        identifier: ast::Ident::with_empty_ctxt(Symbol::intern(\"macro_rules\")),\n                         parameters: ast::PathParameters::none(),\n                     }],\n                 },"}, {"sha": "21ce89a6dd5be7d54ec78a3d4dde8a87082e2048", "filename": "src/libsyntax/ext/proc_macro_shim.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax%2Fext%2Fproc_macro_shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax%2Fext%2Fproc_macro_shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fproc_macro_shim.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -66,6 +66,7 @@ pub mod prelude {\n     pub use ast::Ident;\n     pub use codemap::{DUMMY_SP, Span};\n     pub use ext::base::{ExtCtxt, MacResult};\n-    pub use parse::token::{self, Token, DelimToken, keywords, str_to_ident};\n+    pub use parse::token::{self, Token, DelimToken};\n+    pub use symbol::keywords;\n     pub use tokenstream::{TokenTree, TokenStream};\n }"}, {"sha": "0bd018603d2b9870f548dc3fc7619ecc8767cc42", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -33,6 +33,7 @@ pub mod rt {\n     use parse::{self, token, classify};\n     use ptr::P;\n     use std::rc::Rc;\n+    use symbol;\n \n     use tokenstream::{self, TokenTree};\n \n@@ -239,7 +240,7 @@ pub mod rt {\n     impl ToTokens for str {\n         fn to_tokens(&self, cx: &ExtCtxt) -> Vec<TokenTree> {\n             let lit = ast::LitKind::Str(\n-                token::intern_and_get_ident(self), ast::StrStyle::Cooked);\n+                symbol::intern_and_get_ident(self), ast::StrStyle::Cooked);\n             dummy_spanned(lit).to_tokens(cx)\n         }\n     }\n@@ -527,12 +528,12 @@ pub fn expand_quote_matcher(cx: &mut ExtCtxt,\n     base::MacEager::expr(expanded)\n }\n \n-fn ids_ext(strs: Vec<String> ) -> Vec<ast::Ident> {\n-    strs.iter().map(|str| str_to_ident(&(*str))).collect()\n+fn ids_ext(strs: Vec<String>) -> Vec<ast::Ident> {\n+    strs.iter().map(|s| ast::Ident::from_str(s)).collect()\n }\n \n-fn id_ext(str: &str) -> ast::Ident {\n-    str_to_ident(str)\n+fn id_ext(s: &str) -> ast::Ident {\n+    ast::Ident::from_str(s)\n }\n \n // Lift an ident to the expr that evaluates to that ident."}, {"sha": "7893ad839ead3c1f01e0445fef0df028803e1885", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -17,6 +17,7 @@ use parse::token;\n use parse;\n use print::pprust;\n use ptr::P;\n+use symbol;\n use tokenstream;\n use util::small_vector::SmallVector;\n \n@@ -60,15 +61,14 @@ pub fn expand_file(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n \n     let topmost = cx.expansion_cause();\n     let loc = cx.codemap().lookup_char_pos(topmost.lo);\n-    let filename = token::intern_and_get_ident(&loc.file.name);\n+    let filename = symbol::intern_and_get_ident(&loc.file.name);\n     base::MacEager::expr(cx.expr_str(topmost, filename))\n }\n \n pub fn expand_stringify(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n                         -> Box<base::MacResult+'static> {\n     let s = pprust::tts_to_string(tts);\n-    base::MacEager::expr(cx.expr_str(sp,\n-                                   token::intern_and_get_ident(&s[..])))\n+    base::MacEager::expr(cx.expr_str(sp, symbol::intern_and_get_ident(&s)))\n }\n \n pub fn expand_mod(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n@@ -77,9 +77,7 @@ pub fn expand_mod(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n     let mod_path = &cx.current_expansion.module.mod_path;\n     let string = mod_path.iter().map(|x| x.to_string()).collect::<Vec<String>>().join(\"::\");\n \n-    base::MacEager::expr(cx.expr_str(\n-            sp,\n-            token::intern_and_get_ident(&string[..])))\n+    base::MacEager::expr(cx.expr_str(sp, symbol::intern_and_get_ident(&string)))\n }\n \n /// include! : parse the given file as an expr\n@@ -144,7 +142,7 @@ pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenT\n             // Add this input file to the code map to make it available as\n             // dependency information\n             let filename = format!(\"{}\", file.display());\n-            let interned = token::intern_and_get_ident(&src[..]);\n+            let interned = symbol::intern_and_get_ident(&src);\n             cx.codemap().new_filemap_and_lines(&filename, None, &src);\n \n             base::MacEager::expr(cx.expr_str(sp, interned))"}, {"sha": "4c37a0a71e2f396cb1ab243484221013fb082b49", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -20,9 +20,10 @@ use ext::tt::macro_parser::{parse, parse_failure_msg};\n use parse::ParseSess;\n use parse::lexer::new_tt_reader;\n use parse::parser::{Parser, Restrictions};\n-use parse::token::{self, gensym_ident, NtTT, Token};\n+use parse::token::{self, NtTT, Token};\n use parse::token::Token::*;\n use print;\n+use symbol::Symbol;\n use tokenstream::{self, TokenTree};\n \n use std::collections::{HashMap};\n@@ -187,16 +188,16 @@ impl IdentMacroExpander for MacroRulesExpander {\n \n /// Converts a `macro_rules!` invocation into a syntax extension.\n pub fn compile(sess: &ParseSess, def: &ast::MacroDef) -> SyntaxExtension {\n-    let lhs_nm =  gensym_ident(\"lhs\");\n-    let rhs_nm =  gensym_ident(\"rhs\");\n+    let lhs_nm = ast::Ident::with_empty_ctxt(Symbol::gensym(\"lhs\"));\n+    let rhs_nm = ast::Ident::with_empty_ctxt(Symbol::gensym(\"rhs\"));\n \n     // The pattern that macro_rules matches.\n     // The grammar for macro_rules! is:\n     // $( $lhs:tt => $rhs:tt );+\n     // ...quasiquoting this would be nice.\n     // These spans won't matter, anyways\n-    let match_lhs_tok = MatchNt(lhs_nm, token::str_to_ident(\"tt\"));\n-    let match_rhs_tok = MatchNt(rhs_nm, token::str_to_ident(\"tt\"));\n+    let match_lhs_tok = MatchNt(lhs_nm, ast::Ident::from_str(\"tt\"));\n+    let match_rhs_tok = MatchNt(rhs_nm, ast::Ident::from_str(\"tt\"));\n     let argument_gram = vec![\n         TokenTree::Sequence(DUMMY_SP, Rc::new(tokenstream::SequenceRepetition {\n             tts: vec!["}, {"sha": "0f94018997cb727d4ac4b4c96b9a155a272b7f51", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -33,7 +33,7 @@ use syntax_pos::Span;\n use errors::{DiagnosticBuilder, Handler};\n use visit::{self, FnKind, Visitor};\n use parse::ParseSess;\n-use parse::token::InternedString;\n+use symbol::InternedString;\n \n use std::ascii::AsciiExt;\n use std::env;"}, {"sha": "44ce8668c549aaf93d8274c9a5f8cc5294663957", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -22,8 +22,9 @@ use ast::*;\n use ast;\n use syntax_pos::Span;\n use codemap::{Spanned, respan};\n-use parse::token::{self, keywords};\n+use parse::token;\n use ptr::P;\n+use symbol::keywords;\n use tokenstream::*;\n use util::small_vector::SmallVector;\n use util::move_map::MoveMap;"}, {"sha": "15b93a4864b3474022db84b56ebc59d991ca0838", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -83,7 +83,6 @@ pub mod diagnostics {\n pub mod diagnostic_list;\n \n pub mod util {\n-    pub mod interner;\n     pub mod lev_distance;\n     pub mod node_count;\n     pub mod parser;\n@@ -118,6 +117,7 @@ pub mod ptr;\n pub mod show_span;\n pub mod std_inject;\n pub mod str;\n+pub mod symbol;\n pub mod test;\n pub mod tokenstream;\n pub mod visit;"}, {"sha": "7048be1478b82d969f967970b6217be854ded0d8", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 34, "deletions": 33, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -8,13 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast;\n+use ast::{self, Ident};\n use syntax_pos::{self, BytePos, CharPos, Pos, Span};\n use codemap::CodeMap;\n use errors::{FatalError, Handler, DiagnosticBuilder};\n use ext::tt::transcribe::tt_next_token;\n-use parse::token::{self, keywords, str_to_ident};\n+use parse::token;\n use str::char_at;\n+use symbol::{Symbol, keywords};\n use rustc_unicode::property::Pattern_White_Space;\n \n use std::borrow::Cow;\n@@ -350,13 +351,13 @@ impl<'a> StringReader<'a> {\n     /// single-byte delimiter).\n     pub fn name_from(&self, start: BytePos) -> ast::Name {\n         debug!(\"taking an ident from {:?} to {:?}\", start, self.pos);\n-        self.with_str_from(start, token::intern)\n+        self.with_str_from(start, Symbol::intern)\n     }\n \n     /// As name_from, with an explicit endpoint.\n     pub fn name_from_to(&self, start: BytePos, end: BytePos) -> ast::Name {\n         debug!(\"taking an ident from {:?} to {:?}\", start, end);\n-        self.with_str_from_to(start, end, token::intern)\n+        self.with_str_from_to(start, end, Symbol::intern)\n     }\n \n     /// Calls `f` with a string slice of the source text spanning from `start`\n@@ -492,7 +493,7 @@ impl<'a> StringReader<'a> {\n             if string == \"_\" {\n                 None\n             } else {\n-                Some(token::intern(string))\n+                Some(Symbol::intern(string))\n             }\n         })\n     }\n@@ -540,7 +541,7 @@ impl<'a> StringReader<'a> {\n                         self.with_str_from(start_bpos, |string| {\n                             // comments with only more \"/\"s are not doc comments\n                             let tok = if is_doc_comment(string) {\n-                                token::DocComment(token::intern(string))\n+                                token::DocComment(Symbol::intern(string))\n                             } else {\n                                 token::Comment\n                             };\n@@ -669,7 +670,7 @@ impl<'a> StringReader<'a> {\n                 } else {\n                     string.into()\n                 };\n-                token::DocComment(token::intern(&string[..]))\n+                token::DocComment(Symbol::intern(&string[..]))\n             } else {\n                 token::Comment\n             };\n@@ -758,7 +759,7 @@ impl<'a> StringReader<'a> {\n             self.err_span_(start_bpos,\n                            self.pos,\n                            \"no valid digits found for number\");\n-            return token::Integer(token::intern(\"0\"));\n+            return token::Integer(Symbol::intern(\"0\"));\n         }\n \n         // might be a float, but don't be greedy if this is actually an\n@@ -1097,7 +1098,7 @@ impl<'a> StringReader<'a> {\n                     token::Underscore\n                 } else {\n                     // FIXME: perform NFKC normalization here. (Issue #2253)\n-                    token::Ident(str_to_ident(string))\n+                    token::Ident(Ident::from_str(string))\n                 }\n             }));\n         }\n@@ -1277,13 +1278,13 @@ impl<'a> StringReader<'a> {\n                     // expansion purposes. See #12512 for the gory details of why\n                     // this is necessary.\n                     let ident = self.with_str_from(start, |lifetime_name| {\n-                        str_to_ident(&format!(\"'{}\", lifetime_name))\n+                        Ident::from_str(&format!(\"'{}\", lifetime_name))\n                     });\n \n                     // Conjure up a \"keyword checking ident\" to make sure that\n                     // the lifetime name is not a keyword.\n                     let keyword_checking_ident = self.with_str_from(start, |lifetime_name| {\n-                        str_to_ident(lifetime_name)\n+                        Ident::from_str(lifetime_name)\n                     });\n                     let keyword_checking_token = &token::Ident(keyword_checking_ident);\n                     let last_bpos = self.pos;\n@@ -1310,7 +1311,7 @@ impl<'a> StringReader<'a> {\n                 let id = if valid {\n                     self.name_from(start)\n                 } else {\n-                    token::intern(\"0\")\n+                    Symbol::intern(\"0\")\n                 };\n                 self.bump(); // advance ch past token\n                 let suffix = self.scan_optional_raw_name();\n@@ -1352,7 +1353,7 @@ impl<'a> StringReader<'a> {\n                 let id = if valid {\n                     self.name_from(start_bpos + BytePos(1))\n                 } else {\n-                    token::intern(\"??\")\n+                    Symbol::intern(\"??\")\n                 };\n                 self.bump();\n                 let suffix = self.scan_optional_raw_name();\n@@ -1424,7 +1425,7 @@ impl<'a> StringReader<'a> {\n                 let id = if valid {\n                     self.name_from_to(content_start_bpos, content_end_bpos)\n                 } else {\n-                    token::intern(\"??\")\n+                    Symbol::intern(\"??\")\n                 };\n                 let suffix = self.scan_optional_raw_name();\n                 return Ok(token::Literal(token::StrRaw(id, hash_count), suffix));\n@@ -1551,7 +1552,7 @@ impl<'a> StringReader<'a> {\n         let id = if valid {\n             self.name_from(start)\n         } else {\n-            token::intern(\"?\")\n+            Symbol::intern(\"?\")\n         };\n         self.bump(); // advance ch past token\n         return token::Byte(id);\n@@ -1584,7 +1585,7 @@ impl<'a> StringReader<'a> {\n         let id = if valid {\n             self.name_from(start)\n         } else {\n-            token::intern(\"??\")\n+            Symbol::intern(\"??\")\n         };\n         self.bump();\n         return token::ByteStr(id);\n@@ -1700,11 +1701,11 @@ fn ident_continue(c: Option<char>) -> bool {\n mod tests {\n     use super::*;\n \n+    use ast::Ident;\n     use syntax_pos::{BytePos, Span, NO_EXPANSION};\n     use codemap::CodeMap;\n     use errors;\n     use parse::token;\n-    use parse::token::str_to_ident;\n     use std::io;\n     use std::rc::Rc;\n \n@@ -1732,7 +1733,7 @@ mod tests {\n                                       &sh,\n                                       \"/* my source file */ fn main() { println!(\\\"zebra\\\"); }\\n\"\n                                           .to_string());\n-        let id = str_to_ident(\"fn\");\n+        let id = Ident::from_str(\"fn\");\n         assert_eq!(string_reader.next_token().tok, token::Comment);\n         assert_eq!(string_reader.next_token().tok, token::Whitespace);\n         let tok1 = string_reader.next_token();\n@@ -1813,23 +1814,23 @@ mod tests {\n         let cm = Rc::new(CodeMap::new());\n         let sh = mk_sh(cm.clone());\n         assert_eq!(setup(&cm, &sh, \"'a'\".to_string()).next_token().tok,\n-                   token::Literal(token::Char(token::intern(\"a\")), None));\n+                   token::Literal(token::Char(Symbol::intern(\"a\")), None));\n     }\n \n     #[test]\n     fn character_space() {\n         let cm = Rc::new(CodeMap::new());\n         let sh = mk_sh(cm.clone());\n         assert_eq!(setup(&cm, &sh, \"' '\".to_string()).next_token().tok,\n-                   token::Literal(token::Char(token::intern(\" \")), None));\n+                   token::Literal(token::Char(Symbol::intern(\" \")), None));\n     }\n \n     #[test]\n     fn character_escaped() {\n         let cm = Rc::new(CodeMap::new());\n         let sh = mk_sh(cm.clone());\n         assert_eq!(setup(&cm, &sh, \"'\\\\n'\".to_string()).next_token().tok,\n-                   token::Literal(token::Char(token::intern(\"\\\\n\")), None));\n+                   token::Literal(token::Char(Symbol::intern(\"\\\\n\")), None));\n     }\n \n     #[test]\n@@ -1847,7 +1848,7 @@ mod tests {\n         assert_eq!(setup(&cm, &sh, \"r###\\\"\\\"#a\\\\b\\x00c\\\"\\\"###\".to_string())\n                        .next_token()\n                        .tok,\n-                   token::Literal(token::StrRaw(token::intern(\"\\\"#a\\\\b\\x00c\\\"\"), 3), None));\n+                   token::Literal(token::StrRaw(Symol::intern(\"\\\"#a\\\\b\\x00c\\\"\"), 3), None));\n     }\n \n     #[test]\n@@ -1857,11 +1858,11 @@ mod tests {\n         macro_rules! test {\n             ($input: expr, $tok_type: ident, $tok_contents: expr) => {{\n                 assert_eq!(setup(&cm, &sh, format!(\"{}suffix\", $input)).next_token().tok,\n-                           token::Literal(token::$tok_type(token::intern($tok_contents)),\n-                                          Some(token::intern(\"suffix\"))));\n+                           token::Literal(token::$tok_type(Symbol::intern($tok_contents)),\n+                                          Some(Symbol::intern(\"suffix\"))));\n                 // with a whitespace separator:\n                 assert_eq!(setup(&cm, &sh, format!(\"{} suffix\", $input)).next_token().tok,\n-                           token::Literal(token::$tok_type(token::intern($tok_contents)),\n+                           token::Literal(token::$tok_type(Symbol::intern($tok_contents)),\n                                           None));\n             }}\n         }\n@@ -1877,14 +1878,14 @@ mod tests {\n         test!(\"1.0e10\", Float, \"1.0e10\");\n \n         assert_eq!(setup(&cm, &sh, \"2us\".to_string()).next_token().tok,\n-                   token::Literal(token::Integer(token::intern(\"2\")),\n-                                  Some(token::intern(\"us\"))));\n+                   token::Literal(token::Integer(Symbol::intern(\"2\")),\n+                                  Some(Symbol::intern(\"us\"))));\n         assert_eq!(setup(&cm, &sh, \"r###\\\"raw\\\"###suffix\".to_string()).next_token().tok,\n-                   token::Literal(token::StrRaw(token::intern(\"raw\"), 3),\n-                                  Some(token::intern(\"suffix\"))));\n+                   token::Literal(token::StrRaw(Symbol::intern(\"raw\"), 3),\n+                                  Some(Symbol::intern(\"suffix\"))));\n         assert_eq!(setup(&cm, &sh, \"br###\\\"raw\\\"###suffix\".to_string()).next_token().tok,\n-                   token::Literal(token::ByteStrRaw(token::intern(\"raw\"), 3),\n-                                  Some(token::intern(\"suffix\"))));\n+                   token::Literal(token::ByteStrRaw(Symbol::intern(\"raw\"), 3),\n+                                  Some(Symbol::intern(\"suffix\"))));\n     }\n \n     #[test]\n@@ -1904,7 +1905,7 @@ mod tests {\n             _ => panic!(\"expected a comment!\"),\n         }\n         assert_eq!(lexer.next_token().tok,\n-                   token::Literal(token::Char(token::intern(\"a\")), None));\n+                   token::Literal(token::Char(Symbol::intern(\"a\")), None));\n     }\n \n     #[test]\n@@ -1917,6 +1918,6 @@ mod tests {\n         assert_eq!(comment.sp, ::syntax_pos::mk_sp(BytePos(0), BytePos(7)));\n         assert_eq!(lexer.next_token().tok, token::Whitespace);\n         assert_eq!(lexer.next_token().tok,\n-                   token::DocComment(token::intern(\"/// test\")));\n+                   token::DocComment(Symbol::intern(\"/// test\")));\n     }\n }"}, {"sha": "a44f78b3c3a459a0a041e3dc96692855c7afc5a4", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -16,9 +16,9 @@ use syntax_pos::{self, Span, FileMap};\n use errors::{Handler, ColorConfig, DiagnosticBuilder};\n use feature_gate::UnstableFeatures;\n use parse::parser::Parser;\n-use parse::token::InternedString;\n use ptr::P;\n use str::char_at;\n+use symbol::{self, InternedString};\n use tokenstream;\n \n use std::cell::RefCell;\n@@ -372,7 +372,7 @@ fn looks_like_width_suffix(first_chars: &[char], s: &str) -> bool {\n         s[1..].chars().all(|c| '0' <= c && c <= '9')\n }\n \n-fn filtered_float_lit(data: token::InternedString, suffix: Option<&str>,\n+fn filtered_float_lit(data: InternedString, suffix: Option<&str>,\n                       sd: &Handler, sp: Span) -> ast::LitKind {\n     debug!(\"filtered_float_lit: {}, {:?}\", data, suffix);\n     match suffix.as_ref().map(|s| &**s) {\n@@ -400,7 +400,7 @@ pub fn float_lit(s: &str, suffix: Option<InternedString>,\n     debug!(\"float_lit: {:?}, {:?}\", s, suffix);\n     // FIXME #2252: bounds checking float literals is deferred until trans\n     let s = s.chars().filter(|&c| c != '_').collect::<String>();\n-    let data = token::intern_and_get_ident(&s);\n+    let data = symbol::intern_and_get_ident(&s);\n     filtered_float_lit(data, suffix.as_ref().map(|s| &**s), sd, sp)\n }\n \n@@ -530,7 +530,7 @@ pub fn integer_lit(s: &str,\n                 2 => sd.span_err(sp, \"binary float literal is not supported\"),\n                 _ => ()\n             }\n-            let ident = token::intern_and_get_ident(&s);\n+            let ident = symbol::intern_and_get_ident(&s);\n             return filtered_float_lit(ident, Some(&suf), sd, sp)\n         }\n     }"}, {"sha": "13c701795a802ff8b5def2f39bb21aaeed8e53e9", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -48,13 +48,14 @@ use parse::classify;\n use parse::common::SeqSep;\n use parse::lexer::{Reader, TokenAndSpan};\n use parse::obsolete::ObsoleteSyntax;\n-use parse::token::{self, intern, keywords, MatchNt, SubstNt, InternedString};\n+use parse::token::{self, MatchNt, SubstNt};\n use parse::{new_sub_parser_from_file, ParseSess};\n use util::parser::{AssocOp, Fixity};\n use print::pprust;\n use ptr::P;\n use parse::PResult;\n use tokenstream::{self, Delimited, SequenceRepetition, TokenTree};\n+use symbol::{self, Symbol, keywords, InternedString};\n use util::ThinVec;\n \n use std::collections::HashSet;\n@@ -1537,13 +1538,13 @@ impl<'a> Parser<'a> {\n \n                     token::Str_(s) => {\n                         (true,\n-                         LitKind::Str(token::intern_and_get_ident(&parse::str_lit(&s.as_str())),\n+                         LitKind::Str(symbol::intern_and_get_ident(&parse::str_lit(&s.as_str())),\n                                       ast::StrStyle::Cooked))\n                     }\n                     token::StrRaw(s, n) => {\n                         (true,\n                          LitKind::Str(\n-                            token::intern_and_get_ident(&parse::raw_str_lit(&s.as_str())),\n+                            symbol::intern_and_get_ident(&parse::raw_str_lit(&s.as_str())),\n                             ast::StrStyle::Raw(n)))\n                     }\n                     token::ByteStr(i) =>\n@@ -2627,7 +2628,7 @@ impl<'a> Parser<'a> {\n                                       })));\n                 } else if self.token.is_keyword(keywords::Crate) {\n                     let ident = match self.token {\n-                        token::Ident(id) => ast::Ident { name: token::intern(\"$crate\"), ..id },\n+                        token::Ident(id) => ast::Ident { name: Symbol::intern(\"$crate\"), ..id },\n                         _ => unreachable!(),\n                     };\n                     self.bump();\n@@ -4835,7 +4836,7 @@ impl<'a> Parser<'a> {\n             Visibility::Inherited => (),\n             _ => {\n                 let is_macro_rules: bool = match self.token {\n-                    token::Ident(sid) => sid.name == intern(\"macro_rules\"),\n+                    token::Ident(sid) => sid.name == Symbol::intern(\"macro_rules\"),\n                     _ => false,\n                 };\n                 if is_macro_rules {"}, {"sha": "8ac39dd462e7cbf254667b21f5e12ae21329d352", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 267, "changes": 268, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -16,13 +16,10 @@ pub use self::Token::*;\n \n use ast::{self};\n use ptr::P;\n-use util::interner::Interner;\n+use symbol::keywords;\n use tokenstream;\n \n-use serialize::{Decodable, Decoder, Encodable, Encoder};\n-use std::cell::RefCell;\n use std::fmt;\n-use std::ops::Deref;\n use std::rc::Rc;\n \n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Debug, Copy)]\n@@ -335,266 +332,3 @@ impl fmt::Debug for Nonterminal {\n         }\n     }\n }\n-\n-// In this macro, there is the requirement that the name (the number) must be monotonically\n-// increasing by one in the special identifiers, starting at 0; the same holds for the keywords,\n-// except starting from the next number instead of zero.\n-macro_rules! declare_keywords {(\n-    $( ($index: expr, $konst: ident, $string: expr) )*\n-) => {\n-    pub mod keywords {\n-        use ast;\n-        #[derive(Clone, Copy, PartialEq, Eq)]\n-        pub struct Keyword {\n-            ident: ast::Ident,\n-        }\n-        impl Keyword {\n-            #[inline] pub fn ident(self) -> ast::Ident { self.ident }\n-            #[inline] pub fn name(self) -> ast::Name { self.ident.name }\n-        }\n-        $(\n-            #[allow(non_upper_case_globals)]\n-            pub const $konst: Keyword = Keyword {\n-                ident: ast::Ident::with_empty_ctxt(ast::Name($index))\n-            };\n-        )*\n-    }\n-\n-    fn mk_fresh_ident_interner() -> IdentInterner {\n-        Interner::prefill(&[$($string,)*])\n-    }\n-}}\n-\n-// NB: leaving holes in the ident table is bad! a different ident will get\n-// interned with the id from the hole, but it will be between the min and max\n-// of the reserved words, and thus tagged as \"reserved\".\n-// After modifying this list adjust `is_strict_keyword`/`is_reserved_keyword`,\n-// this should be rarely necessary though if the keywords are kept in alphabetic order.\n-declare_keywords! {\n-    // Invalid identifier\n-    (0,  Invalid,        \"\")\n-\n-    // Strict keywords used in the language.\n-    (1,  As,             \"as\")\n-    (2,  Box,            \"box\")\n-    (3,  Break,          \"break\")\n-    (4,  Const,          \"const\")\n-    (5,  Continue,       \"continue\")\n-    (6,  Crate,          \"crate\")\n-    (7,  Else,           \"else\")\n-    (8,  Enum,           \"enum\")\n-    (9,  Extern,         \"extern\")\n-    (10, False,          \"false\")\n-    (11, Fn,             \"fn\")\n-    (12, For,            \"for\")\n-    (13, If,             \"if\")\n-    (14, Impl,           \"impl\")\n-    (15, In,             \"in\")\n-    (16, Let,            \"let\")\n-    (17, Loop,           \"loop\")\n-    (18, Match,          \"match\")\n-    (19, Mod,            \"mod\")\n-    (20, Move,           \"move\")\n-    (21, Mut,            \"mut\")\n-    (22, Pub,            \"pub\")\n-    (23, Ref,            \"ref\")\n-    (24, Return,         \"return\")\n-    (25, SelfValue,      \"self\")\n-    (26, SelfType,       \"Self\")\n-    (27, Static,         \"static\")\n-    (28, Struct,         \"struct\")\n-    (29, Super,          \"super\")\n-    (30, Trait,          \"trait\")\n-    (31, True,           \"true\")\n-    (32, Type,           \"type\")\n-    (33, Unsafe,         \"unsafe\")\n-    (34, Use,            \"use\")\n-    (35, Where,          \"where\")\n-    (36, While,          \"while\")\n-\n-    // Keywords reserved for future use.\n-    (37, Abstract,       \"abstract\")\n-    (38, Alignof,        \"alignof\")\n-    (39, Become,         \"become\")\n-    (40, Do,             \"do\")\n-    (41, Final,          \"final\")\n-    (42, Macro,          \"macro\")\n-    (43, Offsetof,       \"offsetof\")\n-    (44, Override,       \"override\")\n-    (45, Priv,           \"priv\")\n-    (46, Proc,           \"proc\")\n-    (47, Pure,           \"pure\")\n-    (48, Sizeof,         \"sizeof\")\n-    (49, Typeof,         \"typeof\")\n-    (50, Unsized,        \"unsized\")\n-    (51, Virtual,        \"virtual\")\n-    (52, Yield,          \"yield\")\n-\n-    // Weak keywords, have special meaning only in specific contexts.\n-    (53, Default,        \"default\")\n-    (54, StaticLifetime, \"'static\")\n-    (55, Union,          \"union\")\n-}\n-\n-// looks like we can get rid of this completely...\n-pub type IdentInterner = Interner;\n-\n-// if an interner exists in TLS, return it. Otherwise, prepare a\n-// fresh one.\n-// FIXME(eddyb) #8726 This should probably use a thread-local reference.\n-pub fn with_ident_interner<T, F: FnOnce(&mut IdentInterner) -> T>(f: F) -> T {\n-    thread_local!(static KEY: RefCell<IdentInterner> = {\n-        RefCell::new(mk_fresh_ident_interner())\n-    });\n-    KEY.with(|interner| f(&mut *interner.borrow_mut()))\n-}\n-\n-/// Reset the ident interner to its initial state.\n-pub fn reset_ident_interner() {\n-    with_ident_interner(|interner| *interner = mk_fresh_ident_interner());\n-}\n-\n-/// Represents a string stored in the thread-local interner. Because the\n-/// interner lives for the life of the thread, this can be safely treated as an\n-/// immortal string, as long as it never crosses between threads.\n-///\n-/// FIXME(pcwalton): You must be careful about what you do in the destructors\n-/// of objects stored in TLS, because they may run after the interner is\n-/// destroyed. In particular, they must not access string contents. This can\n-/// be fixed in the future by just leaking all strings until thread death\n-/// somehow.\n-#[derive(Clone, PartialEq, Hash, PartialOrd, Eq, Ord)]\n-pub struct InternedString {\n-    string: Rc<str>,\n-}\n-\n-impl InternedString {\n-    #[inline]\n-    pub fn new(string: &'static str) -> InternedString {\n-        InternedString {\n-            string: Rc::__from_str(string),\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn new_from_name(name: ast::Name) -> InternedString {\n-        with_ident_interner(|interner| InternedString { string: interner.get(name) })\n-    }\n-}\n-\n-impl Deref for InternedString {\n-    type Target = str;\n-\n-    fn deref(&self) -> &str { &self.string }\n-}\n-\n-impl fmt::Debug for InternedString {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Debug::fmt(&self.string, f)\n-    }\n-}\n-\n-impl fmt::Display for InternedString {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Display::fmt(&self.string, f)\n-    }\n-}\n-\n-impl<'a> PartialEq<&'a str> for InternedString {\n-    #[inline(always)]\n-    fn eq(&self, other: & &'a str) -> bool {\n-        PartialEq::eq(&self.string[..], *other)\n-    }\n-    #[inline(always)]\n-    fn ne(&self, other: & &'a str) -> bool {\n-        PartialEq::ne(&self.string[..], *other)\n-    }\n-}\n-\n-impl<'a> PartialEq<InternedString> for &'a str {\n-    #[inline(always)]\n-    fn eq(&self, other: &InternedString) -> bool {\n-        PartialEq::eq(*self, &other.string[..])\n-    }\n-    #[inline(always)]\n-    fn ne(&self, other: &InternedString) -> bool {\n-        PartialEq::ne(*self, &other.string[..])\n-    }\n-}\n-\n-impl PartialEq<str> for InternedString {\n-    #[inline(always)]\n-    fn eq(&self, other: &str) -> bool {\n-        PartialEq::eq(&self.string[..], other)\n-    }\n-    #[inline(always)]\n-    fn ne(&self, other: &str) -> bool {\n-        PartialEq::ne(&self.string[..], other)\n-    }\n-}\n-\n-impl PartialEq<InternedString> for str {\n-    #[inline(always)]\n-    fn eq(&self, other: &InternedString) -> bool {\n-        PartialEq::eq(self, &other.string[..])\n-    }\n-    #[inline(always)]\n-    fn ne(&self, other: &InternedString) -> bool {\n-        PartialEq::ne(self, &other.string[..])\n-    }\n-}\n-\n-impl Decodable for InternedString {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<InternedString, D::Error> {\n-        Ok(intern(&d.read_str()?).as_str())\n-    }\n-}\n-\n-impl Encodable for InternedString {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_str(&self.string)\n-    }\n-}\n-\n-/// Interns and returns the string contents of an identifier, using the\n-/// thread-local interner.\n-#[inline]\n-pub fn intern_and_get_ident(s: &str) -> InternedString {\n-    intern(s).as_str()\n-}\n-\n-/// Maps a string to its interned representation.\n-#[inline]\n-pub fn intern(s: &str) -> ast::Name {\n-    with_ident_interner(|interner| interner.intern(s))\n-}\n-\n-/// gensym's a new usize, using the current interner.\n-#[inline]\n-pub fn gensym(s: &str) -> ast::Name {\n-    with_ident_interner(|interner| interner.gensym(s))\n-}\n-\n-/// Maps a string to an identifier with an empty syntax context.\n-#[inline]\n-pub fn str_to_ident(s: &str) -> ast::Ident {\n-    ast::Ident::with_empty_ctxt(intern(s))\n-}\n-\n-/// Maps a string to a gensym'ed identifier.\n-#[inline]\n-pub fn gensym_ident(s: &str) -> ast::Ident {\n-    ast::Ident::with_empty_ctxt(gensym(s))\n-}\n-\n-// create a fresh name that maps to the same string as the old one.\n-// note that this guarantees that str_ptr_eq(ident_to_string(src),interner_get(fresh_name(src)));\n-// that is, that the new name and the old one are connected to ptr_eq strings.\n-pub fn fresh_name(src: ast::Ident) -> ast::Name {\n-    with_ident_interner(|interner| interner.gensym_copy(src.name))\n-    // following: debug version. Could work in final except that it's incompatible with\n-    // good error messages and uses of struct names in ambiguous could-be-binding\n-    // locations. Also definitely destroys the guarantee given above about ptr_eq.\n-    /*let num = rand::thread_rng().gen_uint_range(0,0xffff);\n-    gensym(format!(\"{}_{}\",ident_to_string(src),num))*/\n-}"}, {"sha": "52ff17d1c1260c00a4fff47c62bf2479e7053e64", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -19,14 +19,15 @@ use attr;\n use codemap::{self, CodeMap};\n use syntax_pos::{self, BytePos};\n use errors;\n-use parse::token::{self, keywords, BinOpToken, Token};\n+use parse::token::{self, BinOpToken, Token};\n use parse::lexer::comments;\n use parse;\n use print::pp::{self, break_offset, word, space, zerobreak, hardbreak};\n use print::pp::{Breaks, eof};\n use print::pp::Breaks::{Consistent, Inconsistent};\n use ptr::P;\n use std_inject;\n+use symbol::{Symbol, keywords};\n use tokenstream::{self, TokenTree};\n \n use std::ascii;\n@@ -119,13 +120,13 @@ pub fn print_crate<'a>(cm: &'a CodeMap,\n         // of the feature gate, so we fake them up here.\n \n         // #![feature(prelude_import)]\n-        let prelude_import_meta = attr::mk_list_word_item(token::intern(\"prelude_import\"));\n-        let list = attr::mk_list_item(token::intern(\"feature\"), vec![prelude_import_meta]);\n+        let prelude_import_meta = attr::mk_list_word_item(Symbol::intern(\"prelude_import\"));\n+        let list = attr::mk_list_item(Symbol::intern(\"feature\"), vec![prelude_import_meta]);\n         let fake_attr = attr::mk_attr_inner(attr::mk_attr_id(), list);\n         try!(s.print_attribute(&fake_attr));\n \n         // #![no_std]\n-        let no_std_meta = attr::mk_word_item(token::intern(\"no_std\"));\n+        let no_std_meta = attr::mk_word_item(Symbol::intern(\"no_std\"));\n         let fake_attr = attr::mk_attr_inner(attr::mk_attr_id(), no_std_meta);\n         try!(s.print_attribute(&fake_attr));\n     }"}, {"sha": "6a291ad9c408a372ed1dbd9b7af1b8c59f9a0335", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -10,10 +10,10 @@\n \n use ast;\n use attr;\n+use symbol::{Symbol, keywords};\n use syntax_pos::{DUMMY_SP, Span};\n use codemap::{self, ExpnInfo, NameAndSpan, MacroAttribute};\n-use parse::token::{intern, keywords};\n-use parse::{token, ParseSess};\n+use parse::ParseSess;\n use ptr::P;\n \n /// Craft a span that will be ignored by the stability lint's\n@@ -23,7 +23,7 @@ fn ignored_span(sess: &ParseSess, sp: Span) -> Span {\n     let info = ExpnInfo {\n         call_site: DUMMY_SP,\n         callee: NameAndSpan {\n-            format: MacroAttribute(intern(\"std_inject\")),\n+            format: MacroAttribute(Symbol::intern(\"std_inject\")),\n             span: None,\n             allow_internal_unstable: true,\n         }\n@@ -53,14 +53,14 @@ pub fn maybe_inject_crates_ref(sess: &ParseSess,\n         None => return krate,\n     };\n \n-    let crate_name = token::intern(&alt_std_name.unwrap_or(name.to_string()));\n+    let crate_name = Symbol::intern(&alt_std_name.unwrap_or(name.to_string()));\n \n     krate.module.items.insert(0, P(ast::Item {\n         attrs: vec![attr::mk_attr_outer(attr::mk_attr_id(),\n-                                        attr::mk_word_item(token::intern(\"macro_use\")))],\n+                                        attr::mk_word_item(Symbol::intern(\"macro_use\")))],\n         vis: ast::Visibility::Inherited,\n         node: ast::ItemKind::ExternCrate(Some(crate_name)),\n-        ident: token::str_to_ident(name),\n+        ident: ast::Ident::from_str(name),\n         id: ast::DUMMY_NODE_ID,\n         span: DUMMY_SP,\n     }));\n@@ -70,7 +70,7 @@ pub fn maybe_inject_crates_ref(sess: &ParseSess,\n         attrs: vec![ast::Attribute {\n             style: ast::AttrStyle::Outer,\n             value: ast::MetaItem {\n-                name: token::intern(\"prelude_import\"),\n+                name: Symbol::intern(\"prelude_import\"),\n                 node: ast::MetaItemKind::Word,\n                 span: span,\n             },\n@@ -82,7 +82,7 @@ pub fn maybe_inject_crates_ref(sess: &ParseSess,\n         node: ast::ItemKind::Use(P(codemap::dummy_spanned(ast::ViewPathGlob(ast::Path {\n             global: false,\n             segments: vec![name, \"prelude\", \"v1\"].into_iter().map(|name| ast::PathSegment {\n-                identifier: token::str_to_ident(name),\n+                identifier: ast::Ident::from_str(name),\n                 parameters: ast::PathParameters::none(),\n             }).collect(),\n             span: span,"}, {"sha": "9620b8412b4fbe88e1153a2b087df532fc279e64", "filename": "src/libsyntax/symbol.rs", "status": "added", "additions": 339, "deletions": 0, "changes": 339, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsymbol.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -0,0 +1,339 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! An \"interner\" is a data structure that associates values with usize tags and\n+//! allows bidirectional lookup; i.e. given a value, one can easily find the\n+//! type, and vice versa.\n+\n+use serialize::{Decodable, Decoder, Encodable, Encoder};\n+use std::cell::RefCell;\n+use std::collections::HashMap;\n+use std::fmt;\n+use std::rc::Rc;\n+\n+/// A symbol is an interned or gensymed string.\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct Symbol(u32);\n+\n+impl Symbol {\n+    /// Maps a string to its interned representation.\n+    pub fn intern(string: &str) -> Self {\n+        with_interner(|interner| interner.intern(string))\n+    }\n+\n+    /// gensym's a new usize, using the current interner.\n+    pub fn gensym(string: &str) -> Self {\n+        with_interner(|interner| interner.gensym(string))\n+    }\n+\n+    pub fn as_str(self) -> InternedString {\n+        with_interner(|interner| InternedString { string: interner.get(self) })\n+    }\n+\n+    pub fn as_u32(self) -> u32 {\n+        self.0\n+    }\n+}\n+\n+impl fmt::Debug for Symbol {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}({})\", self, self.0)\n+    }\n+}\n+\n+impl fmt::Display for Symbol {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(&self.as_str(), f)\n+    }\n+}\n+\n+impl Encodable for Symbol {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        s.emit_str(&self.as_str())\n+    }\n+}\n+\n+impl Decodable for Symbol {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<Symbol, D::Error> {\n+        Ok(Symbol::intern(&d.read_str()?))\n+    }\n+}\n+\n+impl<'a> PartialEq<&'a str> for Symbol {\n+    fn eq(&self, other: &&str) -> bool {\n+        *self.as_str() == **other\n+    }\n+}\n+\n+#[derive(Default)]\n+pub struct Interner {\n+    names: HashMap<Rc<str>, Symbol>,\n+    strings: Vec<Rc<str>>,\n+}\n+\n+impl Interner {\n+    pub fn new() -> Self {\n+        Interner::default()\n+    }\n+\n+    fn prefill(init: &[&str]) -> Self {\n+        let mut this = Interner::new();\n+        for &string in init {\n+            this.intern(string);\n+        }\n+        this\n+    }\n+\n+    pub fn intern(&mut self, string: &str) -> Symbol {\n+        if let Some(&name) = self.names.get(string) {\n+            return name;\n+        }\n+\n+        let name = Symbol(self.strings.len() as u32);\n+        let string = Rc::__from_str(string);\n+        self.strings.push(string.clone());\n+        self.names.insert(string, name);\n+        name\n+    }\n+\n+    fn gensym(&mut self, string: &str) -> Symbol {\n+        let gensym = Symbol(self.strings.len() as u32);\n+        // leave out of `names` to avoid colliding\n+        self.strings.push(Rc::__from_str(string));\n+        gensym\n+    }\n+\n+    pub fn get(&self, name: Symbol) -> Rc<str> {\n+        self.strings[name.0 as usize].clone()\n+    }\n+}\n+\n+// In this macro, there is the requirement that the name (the number) must be monotonically\n+// increasing by one in the special identifiers, starting at 0; the same holds for the keywords,\n+// except starting from the next number instead of zero.\n+macro_rules! declare_keywords {(\n+    $( ($index: expr, $konst: ident, $string: expr) )*\n+) => {\n+    pub mod keywords {\n+        use ast;\n+        #[derive(Clone, Copy, PartialEq, Eq)]\n+        pub struct Keyword {\n+            ident: ast::Ident,\n+        }\n+        impl Keyword {\n+            #[inline] pub fn ident(self) -> ast::Ident { self.ident }\n+            #[inline] pub fn name(self) -> ast::Name { self.ident.name }\n+        }\n+        $(\n+            #[allow(non_upper_case_globals)]\n+            pub const $konst: Keyword = Keyword {\n+                ident: ast::Ident::with_empty_ctxt(ast::Name($index))\n+            };\n+        )*\n+    }\n+\n+    impl Interner {\n+        fn fresh() -> Self {\n+            Interner::prefill(&[$($string,)*])\n+        }\n+    }\n+}}\n+\n+// NB: leaving holes in the ident table is bad! a different ident will get\n+// interned with the id from the hole, but it will be between the min and max\n+// of the reserved words, and thus tagged as \"reserved\".\n+// After modifying this list adjust `is_strict_keyword`/`is_reserved_keyword`,\n+// this should be rarely necessary though if the keywords are kept in alphabetic order.\n+declare_keywords! {\n+    // Invalid identifier\n+    (0,  Invalid,        \"\")\n+\n+    // Strict keywords used in the language.\n+    (1,  As,             \"as\")\n+    (2,  Box,            \"box\")\n+    (3,  Break,          \"break\")\n+    (4,  Const,          \"const\")\n+    (5,  Continue,       \"continue\")\n+    (6,  Crate,          \"crate\")\n+    (7,  Else,           \"else\")\n+    (8,  Enum,           \"enum\")\n+    (9,  Extern,         \"extern\")\n+    (10, False,          \"false\")\n+    (11, Fn,             \"fn\")\n+    (12, For,            \"for\")\n+    (13, If,             \"if\")\n+    (14, Impl,           \"impl\")\n+    (15, In,             \"in\")\n+    (16, Let,            \"let\")\n+    (17, Loop,           \"loop\")\n+    (18, Match,          \"match\")\n+    (19, Mod,            \"mod\")\n+    (20, Move,           \"move\")\n+    (21, Mut,            \"mut\")\n+    (22, Pub,            \"pub\")\n+    (23, Ref,            \"ref\")\n+    (24, Return,         \"return\")\n+    (25, SelfValue,      \"self\")\n+    (26, SelfType,       \"Self\")\n+    (27, Static,         \"static\")\n+    (28, Struct,         \"struct\")\n+    (29, Super,          \"super\")\n+    (30, Trait,          \"trait\")\n+    (31, True,           \"true\")\n+    (32, Type,           \"type\")\n+    (33, Unsafe,         \"unsafe\")\n+    (34, Use,            \"use\")\n+    (35, Where,          \"where\")\n+    (36, While,          \"while\")\n+\n+    // Keywords reserved for future use.\n+    (37, Abstract,       \"abstract\")\n+    (38, Alignof,        \"alignof\")\n+    (39, Become,         \"become\")\n+    (40, Do,             \"do\")\n+    (41, Final,          \"final\")\n+    (42, Macro,          \"macro\")\n+    (43, Offsetof,       \"offsetof\")\n+    (44, Override,       \"override\")\n+    (45, Priv,           \"priv\")\n+    (46, Proc,           \"proc\")\n+    (47, Pure,           \"pure\")\n+    (48, Sizeof,         \"sizeof\")\n+    (49, Typeof,         \"typeof\")\n+    (50, Unsized,        \"unsized\")\n+    (51, Virtual,        \"virtual\")\n+    (52, Yield,          \"yield\")\n+\n+    // Weak keywords, have special meaning only in specific contexts.\n+    (53, Default,        \"default\")\n+    (54, StaticLifetime, \"'static\")\n+    (55, Union,          \"union\")\n+}\n+\n+// If an interner exists in TLS, return it. Otherwise, prepare a fresh one.\n+fn with_interner<T, F: FnOnce(&mut Interner) -> T>(f: F) -> T {\n+    thread_local!(static INTERNER: RefCell<Interner> = {\n+        RefCell::new(Interner::fresh())\n+    });\n+    INTERNER.with(|interner| f(&mut *interner.borrow_mut()))\n+}\n+\n+/// Reset the ident interner to its initial state.\n+pub fn reset_interner() {\n+    with_interner(|interner| *interner = Interner::fresh());\n+}\n+\n+/// Represents a string stored in the thread-local interner. Because the\n+/// interner lives for the life of the thread, this can be safely treated as an\n+/// immortal string, as long as it never crosses between threads.\n+///\n+/// FIXME(pcwalton): You must be careful about what you do in the destructors\n+/// of objects stored in TLS, because they may run after the interner is\n+/// destroyed. In particular, they must not access string contents. This can\n+/// be fixed in the future by just leaking all strings until thread death\n+/// somehow.\n+#[derive(Clone, PartialEq, Hash, PartialOrd, Eq, Ord)]\n+pub struct InternedString {\n+    string: Rc<str>,\n+}\n+\n+impl InternedString {\n+    pub fn new(string: &'static str) -> InternedString {\n+        InternedString {\n+            string: Rc::__from_str(string),\n+        }\n+    }\n+}\n+\n+impl ::std::ops::Deref for InternedString {\n+    type Target = str;\n+    fn deref(&self) -> &str { &self.string }\n+}\n+\n+impl fmt::Debug for InternedString {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Debug::fmt(&self.string, f)\n+    }\n+}\n+\n+impl fmt::Display for InternedString {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(&self.string, f)\n+    }\n+}\n+\n+impl<'a> PartialEq<&'a str> for InternedString {\n+    fn eq(&self, other: & &'a str) -> bool {\n+        PartialEq::eq(&self.string[..], *other)\n+    }\n+}\n+\n+impl<'a> PartialEq<InternedString> for &'a str {\n+    fn eq(&self, other: &InternedString) -> bool {\n+        PartialEq::eq(*self, &other.string[..])\n+    }\n+}\n+\n+impl PartialEq<str> for InternedString {\n+    fn eq(&self, other: &str) -> bool {\n+        PartialEq::eq(&self.string[..], other)\n+    }\n+}\n+\n+impl PartialEq<InternedString> for str {\n+    fn eq(&self, other: &InternedString) -> bool {\n+        PartialEq::eq(self, &other.string[..])\n+    }\n+}\n+\n+impl Decodable for InternedString {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<InternedString, D::Error> {\n+        Ok(Symbol::intern(&d.read_str()?).as_str())\n+    }\n+}\n+\n+impl Encodable for InternedString {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        s.emit_str(&self.string)\n+    }\n+}\n+\n+/// Interns and returns the string contents of an identifier, using the\n+/// thread-local interner.\n+#[inline]\n+pub fn intern_and_get_ident(s: &str) -> InternedString {\n+    Symbol::intern(s).as_str()\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use ast::Name;\n+\n+    #[test]\n+    fn interner_tests() {\n+        let mut i: Interner = Interner::new();\n+        // first one is zero:\n+        assert_eq!(i.intern(\"dog\"), Name(0));\n+        // re-use gets the same entry:\n+        assert_eq!(i.intern (\"dog\"), Name(0));\n+        // different string gets a different #:\n+        assert_eq!(i.intern(\"cat\"), Name(1));\n+        assert_eq!(i.intern(\"cat\"), Name(1));\n+        // dog is still at zero\n+        assert_eq!(i.intern(\"dog\"), Name(0));\n+        // gensym gets 3\n+        assert_eq!(i.gensym(\"zebra\"), Name(2));\n+        // gensym of same string gets new number :\n+        assert_eq!(i.gensym(\"zebra\"), Name(3));\n+        // gensym of *existing* string gets new number:\n+        assert_eq!(i.gensym(\"dog\"), Name(4));\n+    }\n+}"}, {"sha": "271de16e7ac2e68fd757d73a4eb5f20cfc68df46", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 33, "deletions": 29, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -34,11 +34,11 @@ use ext::expand::ExpansionConfig;\n use fold::Folder;\n use util::move_map::MoveMap;\n use fold;\n-use parse::token::{intern, keywords, InternedString};\n use parse::{token, ParseSess};\n use print::pprust;\n-use ast;\n+use ast::{self, Ident};\n use ptr::P;\n+use symbol::{self, Symbol, keywords, InternedString};\n use util::small_vector::SmallVector;\n \n enum ShouldPanic {\n@@ -48,7 +48,7 @@ enum ShouldPanic {\n \n struct Test {\n     span: Span,\n-    path: Vec<ast::Ident> ,\n+    path: Vec<Ident> ,\n     bench: bool,\n     ignore: bool,\n     should_panic: ShouldPanic\n@@ -57,14 +57,14 @@ struct Test {\n struct TestCtxt<'a> {\n     sess: &'a ParseSess,\n     span_diagnostic: &'a errors::Handler,\n-    path: Vec<ast::Ident>,\n+    path: Vec<Ident>,\n     ext_cx: ExtCtxt<'a>,\n     testfns: Vec<Test>,\n     reexport_test_harness_main: Option<InternedString>,\n     is_test_crate: bool,\n \n     // top-level re-export submodule, filled out after folding is finished\n-    toplevel_reexport: Option<ast::Ident>,\n+    toplevel_reexport: Option<Ident>,\n }\n \n // Traverse the crate, collecting all the test functions, eliding any\n@@ -91,10 +91,10 @@ pub fn modify_for_testing(sess: &ParseSess,\n \n struct TestHarnessGenerator<'a> {\n     cx: TestCtxt<'a>,\n-    tests: Vec<ast::Ident>,\n+    tests: Vec<Ident>,\n \n     // submodule name, gensym'd identifier for re-exports\n-    tested_submods: Vec<(ast::Ident, ast::Ident)>,\n+    tested_submods: Vec<(Ident, Ident)>,\n }\n \n impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n@@ -191,8 +191,8 @@ impl fold::Folder for EntryPointCleaner {\n             EntryPointType::MainAttr |\n             EntryPointType::Start =>\n                 folded.map(|ast::Item {id, ident, attrs, node, vis, span}| {\n-                    let allow_str = token::intern(\"allow\");\n-                    let dead_code_str = token::intern(\"dead_code\");\n+                    let allow_str = Symbol::intern(\"allow\");\n+                    let dead_code_str = Symbol::intern(\"dead_code\");\n                     let word_vec = vec![attr::mk_list_word_item(dead_code_str)];\n                     let allow_dead_code_item = attr::mk_list_item(allow_str, word_vec);\n                     let allow_dead_code = attr::mk_attr_outer(attr::mk_attr_id(),\n@@ -222,15 +222,18 @@ impl fold::Folder for EntryPointCleaner {\n     fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac { mac }\n }\n \n-fn mk_reexport_mod(cx: &mut TestCtxt, parent: ast::NodeId, tests: Vec<ast::Ident>,\n-                   tested_submods: Vec<(ast::Ident, ast::Ident)>) -> (P<ast::Item>, ast::Ident) {\n-    let super_ = token::str_to_ident(\"super\");\n+fn mk_reexport_mod(cx: &mut TestCtxt,\n+                   parent: ast::NodeId,\n+                   tests: Vec<Ident>,\n+                   tested_submods: Vec<(Ident, Ident)>)\n+                   -> (P<ast::Item>, Ident) {\n+    let super_ = Ident::from_str(\"super\");\n \n     // Generate imports with `#[allow(private_in_public)]` to work around issue #36768.\n     let allow_private_in_public = cx.ext_cx.attribute(DUMMY_SP, cx.ext_cx.meta_list(\n         DUMMY_SP,\n-        token::intern(\"allow\"),\n-        vec![cx.ext_cx.meta_list_item_word(DUMMY_SP, token::intern(\"private_in_public\"))],\n+        Symbol::intern(\"allow\"),\n+        vec![cx.ext_cx.meta_list_item_word(DUMMY_SP, Symbol::intern(\"private_in_public\"))],\n     ));\n     let items = tests.into_iter().map(|r| {\n         cx.ext_cx.item_use_simple(DUMMY_SP, ast::Visibility::Public,\n@@ -247,7 +250,7 @@ fn mk_reexport_mod(cx: &mut TestCtxt, parent: ast::NodeId, tests: Vec<ast::Ident\n         items: items,\n     };\n \n-    let sym = token::gensym_ident(\"__test_reexports\");\n+    let sym = Ident::with_empty_ctxt(Symbol::gensym(\"__test_reexports\"));\n     let parent = if parent == ast::DUMMY_NODE_ID { ast::CRATE_NODE_ID } else { parent };\n     cx.ext_cx.current_expansion.mark = cx.ext_cx.resolver.get_module_scope(parent);\n     let it = cx.ext_cx.monotonic_expander().fold_item(P(ast::Item {\n@@ -286,7 +289,7 @@ fn generate_test_harness(sess: &ParseSess,\n     cx.ext_cx.bt_push(ExpnInfo {\n         call_site: DUMMY_SP,\n         callee: NameAndSpan {\n-            format: MacroAttribute(intern(\"test\")),\n+            format: MacroAttribute(Symbol::intern(\"test\")),\n             span: None,\n             allow_internal_unstable: false,\n         }\n@@ -306,7 +309,7 @@ fn ignored_span(cx: &TestCtxt, sp: Span) -> Span {\n     let info = ExpnInfo {\n         call_site: DUMMY_SP,\n         callee: NameAndSpan {\n-            format: MacroAttribute(intern(\"test\")),\n+            format: MacroAttribute(Symbol::intern(\"test\")),\n             span: None,\n             allow_internal_unstable: true,\n         }\n@@ -456,7 +459,7 @@ mod __test {\n */\n \n fn mk_std(cx: &TestCtxt) -> P<ast::Item> {\n-    let id_test = token::str_to_ident(\"test\");\n+    let id_test = Ident::from_str(\"test\");\n     let (vi, vis, ident) = if cx.is_test_crate {\n         (ast::ItemKind::Use(\n             P(nospan(ast::ViewPathSimple(id_test,\n@@ -487,16 +490,17 @@ fn mk_main(cx: &mut TestCtxt) -> P<ast::Item> {\n     let ecx = &cx.ext_cx;\n \n     // test::test_main_static\n-    let test_main_path = ecx.path(sp, vec![token::str_to_ident(\"test\"),\n-                                           token::str_to_ident(\"test_main_static\")]);\n+    let test_main_path =\n+        ecx.path(sp, vec![Ident::from_str(\"test\"), Ident::from_str(\"test_main_static\")]);\n+\n     // test::test_main_static(...)\n     let test_main_path_expr = ecx.expr_path(test_main_path);\n-    let tests_ident_expr = ecx.expr_ident(sp, token::str_to_ident(\"TESTS\"));\n+    let tests_ident_expr = ecx.expr_ident(sp, Ident::from_str(\"TESTS\"));\n     let call_test_main = ecx.expr_call(sp, test_main_path_expr,\n                                        vec![tests_ident_expr]);\n     let call_test_main = ecx.stmt_expr(call_test_main);\n     // #![main]\n-    let main_meta = ecx.meta_word(sp, token::intern(\"main\"));\n+    let main_meta = ecx.meta_word(sp, Symbol::intern(\"main\"));\n     let main_attr = ecx.attribute(sp, main_meta);\n     // pub fn main() { ... }\n     let main_ret_ty = ecx.ty(sp, ast::TyKind::Tup(vec![]));\n@@ -506,7 +510,7 @@ fn mk_main(cx: &mut TestCtxt) -> P<ast::Item> {\n                            dummy_spanned(ast::Constness::NotConst),\n                            ::abi::Abi::Rust, ast::Generics::default(), main_body);\n     let main = P(ast::Item {\n-        ident: token::str_to_ident(\"main\"),\n+        ident: Ident::from_str(\"main\"),\n         attrs: vec![main_attr],\n         id: ast::DUMMY_NODE_ID,\n         node: main,\n@@ -533,7 +537,7 @@ fn mk_test_module(cx: &mut TestCtxt) -> (P<ast::Item>, Option<P<ast::Item>>) {\n         items: vec![import, mainfn, tests],\n     };\n     let item_ = ast::ItemKind::Mod(testmod);\n-    let mod_ident = token::gensym_ident(\"__test\");\n+    let mod_ident = Ident::with_empty_ctxt(Symbol::gensym(\"__test\"));\n \n     let mut expander = cx.ext_cx.monotonic_expander();\n     let item = expander.fold_item(P(ast::Item {\n@@ -546,11 +550,11 @@ fn mk_test_module(cx: &mut TestCtxt) -> (P<ast::Item>, Option<P<ast::Item>>) {\n     })).pop().unwrap();\n     let reexport = cx.reexport_test_harness_main.as_ref().map(|s| {\n         // building `use <ident> = __test::main`\n-        let reexport_ident = token::str_to_ident(&s);\n+        let reexport_ident = Ident::from_str(&s);\n \n         let use_path =\n             nospan(ast::ViewPathSimple(reexport_ident,\n-                                       path_node(vec![mod_ident, token::str_to_ident(\"main\")])));\n+                                       path_node(vec![mod_ident, Ident::from_str(\"main\")])));\n \n         expander.fold_item(P(ast::Item {\n             id: ast::DUMMY_NODE_ID,\n@@ -571,7 +575,7 @@ fn nospan<T>(t: T) -> codemap::Spanned<T> {\n     codemap::Spanned { node: t, span: DUMMY_SP }\n }\n \n-fn path_node(ids: Vec<ast::Ident> ) -> ast::Path {\n+fn path_node(ids: Vec<Ident>) -> ast::Path {\n     ast::Path {\n         span: DUMMY_SP,\n         global: false,\n@@ -582,7 +586,7 @@ fn path_node(ids: Vec<ast::Ident> ) -> ast::Path {\n     }\n }\n \n-fn path_name_i(idents: &[ast::Ident]) -> String {\n+fn path_name_i(idents: &[Ident]) -> String {\n     // FIXME: Bad copies (#2543 -- same for everything else that says \"bad\")\n     idents.iter().map(|i| i.to_string()).collect::<Vec<String>>().join(\"::\")\n }\n@@ -660,7 +664,7 @@ fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> P<ast::Expr> {\n \n     // path to the #[test] function: \"foo::bar::baz\"\n     let path_string = path_name_i(&path[..]);\n-    let name_expr = ecx.expr_str(span, token::intern_and_get_ident(&path_string[..]));\n+    let name_expr = ecx.expr_str(span, symbol::intern_and_get_ident(&path_string[..]));\n \n     // self::test::StaticTestName($name_expr)\n     let name_expr = ecx.expr_call(span,"}, {"sha": "7ca4650a3ae32ffdbc14d5cb77ed689ecc4a667d", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -34,6 +34,7 @@ use parse::lexer;\n use parse;\n use parse::token::{self, Token, Lit, Nonterminal};\n use print::pprust;\n+use symbol::{self, Symbol};\n \n use std::fmt;\n use std::iter::*;\n@@ -173,10 +174,10 @@ impl TokenTree {\n                 TokenTree::Delimited(sp, Rc::new(Delimited {\n                     delim: token::Bracket,\n                     open_span: sp,\n-                    tts: vec![TokenTree::Token(sp, token::Ident(token::str_to_ident(\"doc\"))),\n+                    tts: vec![TokenTree::Token(sp, token::Ident(ast::Ident::from_str(\"doc\"))),\n                               TokenTree::Token(sp, token::Eq),\n                               TokenTree::Token(sp, token::Literal(\n-                                  token::StrRaw(token::intern(&stripped), num_of_hashes), None))],\n+                                  token::StrRaw(Symbol::intern(&stripped), num_of_hashes), None))],\n                     close_span: sp,\n                 }))\n             }\n@@ -295,15 +296,15 @@ impl TokenTree {\n     pub fn maybe_str(&self) -> Option<ast::Lit> {\n         match *self {\n             TokenTree::Token(sp, Token::Literal(Lit::Str_(s), _)) => {\n-                let l = LitKind::Str(token::intern_and_get_ident(&parse::str_lit(&s.as_str())),\n+                let l = LitKind::Str(symbol::intern_and_get_ident(&parse::str_lit(&s.as_str())),\n                                      ast::StrStyle::Cooked);\n                 Some(Spanned {\n                     node: l,\n                     span: sp,\n                 })\n             }\n             TokenTree::Token(sp, Token::Literal(Lit::StrRaw(s, n), _)) => {\n-                let l = LitKind::Str(token::intern_and_get_ident(&parse::raw_str_lit(&s.as_str())),\n+                let l = LitKind::Str(symbol::intern_and_get_ident(&parse::raw_str_lit(&s.as_str())),\n                                      ast::StrStyle::Raw(n));\n                 Some(Spanned {\n                     node: l,"}, {"sha": "f56c6cedcd18678e4971d48d96b8392a0c6280a0", "filename": "src/libsyntax/util/interner.rs", "status": "removed", "additions": 0, "deletions": 111, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/f177a00ac92b871add90ca559a8591c4647a3c7e/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f177a00ac92b871add90ca559a8591c4647a3c7e/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=f177a00ac92b871add90ca559a8591c4647a3c7e", "patch": "@@ -1,111 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! An \"interner\" is a data structure that associates values with usize tags and\n-//! allows bidirectional lookup; i.e. given a value, one can easily find the\n-//! type, and vice versa.\n-\n-use ast::Name;\n-\n-use std::collections::HashMap;\n-use std::rc::Rc;\n-\n-#[derive(Default)]\n-pub struct Interner {\n-    names: HashMap<Rc<str>, Name>,\n-    strings: Vec<Rc<str>>,\n-}\n-\n-/// When traits can extend traits, we should extend index<Name,T> to get []\n-impl Interner {\n-    pub fn new() -> Self {\n-        Interner::default()\n-    }\n-\n-    pub fn prefill(init: &[&str]) -> Self {\n-        let mut this = Interner::new();\n-        for &string in init {\n-            this.intern(string);\n-        }\n-        this\n-    }\n-\n-    pub fn intern(&mut self, string: &str) -> Name {\n-        if let Some(&name) = self.names.get(string) {\n-            return name;\n-        }\n-\n-        let name = Name(self.strings.len() as u32);\n-        let string = Rc::__from_str(string);\n-        self.strings.push(string.clone());\n-        self.names.insert(string, name);\n-        name\n-    }\n-\n-    pub fn gensym(&mut self, string: &str) -> Name {\n-        let gensym = Name(self.strings.len() as u32);\n-        // leave out of `names` to avoid colliding\n-        self.strings.push(Rc::__from_str(string));\n-        gensym\n-    }\n-\n-    /// Create a gensym with the same name as an existing entry.\n-    pub fn gensym_copy(&mut self, name: Name) -> Name {\n-        let gensym = Name(self.strings.len() as u32);\n-        // leave out of `names` to avoid colliding\n-        let string = self.strings[name.0 as usize].clone();\n-        self.strings.push(string);\n-        gensym\n-    }\n-\n-    pub fn get(&self, name: Name) -> Rc<str> {\n-        self.strings[name.0 as usize].clone()\n-    }\n-\n-    pub fn find(&self, string: &str) -> Option<Name> {\n-        self.names.get(string).cloned()\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-    use ast::Name;\n-\n-    #[test]\n-    fn interner_tests() {\n-        let mut i: Interner = Interner::new();\n-        // first one is zero:\n-        assert_eq!(i.intern(\"dog\"), Name(0));\n-        // re-use gets the same entry:\n-        assert_eq!(i.intern (\"dog\"), Name(0));\n-        // different string gets a different #:\n-        assert_eq!(i.intern(\"cat\"), Name(1));\n-        assert_eq!(i.intern(\"cat\"), Name(1));\n-        // dog is still at zero\n-        assert_eq!(i.intern(\"dog\"), Name(0));\n-        // gensym gets 3\n-        assert_eq!(i.gensym(\"zebra\"), Name(2));\n-        // gensym of same string gets new number :\n-        assert_eq!(i.gensym(\"zebra\"), Name(3));\n-        // gensym of *existing* string gets new number:\n-        assert_eq!(i.gensym(\"dog\"), Name(4));\n-        // gensym tests again with gensym_copy:\n-        assert_eq!(i.gensym_copy(Name(2)), Name(5));\n-        assert_eq!(&*i.get(Name(5)), \"zebra\");\n-        assert_eq!(i.gensym_copy(Name(2)), Name(6));\n-        assert_eq!(&*i.get(Name(6)), \"zebra\");\n-        assert_eq!(&*i.get(Name(0)), \"dog\");\n-        assert_eq!(&*i.get(Name(1)), \"cat\");\n-        assert_eq!(&*i.get(Name(2)), \"zebra\");\n-        assert_eq!(&*i.get(Name(3)), \"zebra\");\n-        assert_eq!(&*i.get(Name(4)), \"dog\");\n-    }\n-}"}, {"sha": "0d6df2cfcb67faaf7fc2c9ab0a72aa1876bf9447", "filename": "src/libsyntax/util/lev_distance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax%2Futil%2Flev_distance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax%2Futil%2Flev_distance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Flev_distance.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -10,7 +10,7 @@\n \n use ast::Name;\n use std::cmp;\n-use parse::token::InternedString;\n+use symbol::InternedString;\n \n /// To find the Levenshtein distance between two strings\n pub fn lev_distance(a: &str, b: &str) -> usize {"}, {"sha": "ce24fe1eb61e241d6eee5830c982e01b49c20638", "filename": "src/libsyntax/util/parser.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax%2Futil%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -7,7 +7,8 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-use parse::token::{Token, BinOpToken, keywords};\n+use parse::token::{Token, BinOpToken};\n+use symbol::keywords;\n use ast::BinOpKind;\n \n /// Associative operator with precedence."}, {"sha": "58fd83e17e11337041b7476f4e0423f3b924cb18", "filename": "src/libsyntax_ext/asm.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax_ext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax_ext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fasm.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -17,9 +17,9 @@ use syntax::codemap;\n use syntax::ext::base;\n use syntax::ext::base::*;\n use syntax::feature_gate;\n-use syntax::parse::token::intern;\n use syntax::parse::{self, token};\n use syntax::ptr::P;\n+use syntax::symbol::{self, Symbol, InternedString};\n use syntax::ast::AsmDialect;\n use syntax_pos::Span;\n use syntax::tokenstream;\n@@ -73,7 +73,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt,\n         })\n         .unwrap_or(tts.len());\n     let mut p = cx.new_parser_from_tts(&tts[first_colon..]);\n-    let mut asm = token::InternedString::new(\"\");\n+    let mut asm = InternedString::new(\"\");\n     let mut asm_str_style = None;\n     let mut outputs = Vec::new();\n     let mut inputs = Vec::new();\n@@ -139,7 +139,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt,\n                     let output = match ch.next() {\n                         Some('=') => None,\n                         Some('+') => {\n-                            Some(token::intern_and_get_ident(&format!(\"={}\", ch.as_str())))\n+                            Some(symbol::intern_and_get_ident(&format!(\"={}\", ch.as_str())))\n                         }\n                         _ => {\n                             cx.span_err(span, \"output operand constraint lacks '=' or '+'\");\n@@ -242,7 +242,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt,\n     let expn_id = cx.codemap().record_expansion(codemap::ExpnInfo {\n         call_site: sp,\n         callee: codemap::NameAndSpan {\n-            format: codemap::MacroBang(intern(\"asm\")),\n+            format: codemap::MacroBang(Symbol::intern(\"asm\")),\n             span: None,\n             allow_internal_unstable: false,\n         },\n@@ -251,7 +251,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt,\n     MacEager::expr(P(ast::Expr {\n         id: ast::DUMMY_NODE_ID,\n         node: ast::ExprKind::InlineAsm(P(ast::InlineAsm {\n-            asm: token::intern_and_get_ident(&asm),\n+            asm: symbol::intern_and_get_ident(&asm),\n             asm_str_style: asm_str_style.unwrap(),\n             outputs: outputs,\n             inputs: inputs,"}, {"sha": "45df1ace985bd0e316a3cc1c41f083013a125818", "filename": "src/libsyntax_ext/concat.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax_ext%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax_ext%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fconcat.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -11,7 +11,7 @@\n use syntax::ast;\n use syntax::ext::base;\n use syntax::ext::build::AstBuilder;\n-use syntax::parse::token;\n+use syntax::symbol::intern_and_get_ident;\n use syntax_pos;\n use syntax::tokenstream;\n \n@@ -57,5 +57,5 @@ pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n             }\n         }\n     }\n-    base::MacEager::expr(cx.expr_str(sp, token::intern_and_get_ident(&accumulator[..])))\n+    base::MacEager::expr(cx.expr_str(sp, intern_and_get_ident(&accumulator[..])))\n }"}, {"sha": "b26e33eb384dc0017fc942a16ec9e62e0bf9e6c7", "filename": "src/libsyntax_ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax_ext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax_ext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fconcat_idents.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -13,7 +13,6 @@ use syntax::ext::base::*;\n use syntax::ext::base;\n use syntax::feature_gate;\n use syntax::parse::token;\n-use syntax::parse::token::str_to_ident;\n use syntax::ptr::P;\n use syntax_pos::Span;\n use syntax::tokenstream::TokenTree;\n@@ -51,7 +50,7 @@ pub fn expand_syntax_ext<'cx>(cx: &'cx mut ExtCtxt,\n             }\n         }\n     }\n-    let res = str_to_ident(&res_str);\n+    let res = ast::Ident::from_str(&res_str);\n \n     struct Result {\n         ident: ast::Ident,"}, {"sha": "d14b59d6c70e2f20bdaa0dde1ab1706501c10e22", "filename": "src/libsyntax_ext/deriving/clone.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -15,8 +15,8 @@ use syntax::ast::{self, Expr, Generics, ItemKind, MetaItem, VariantData};\n use syntax::attr;\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n-use syntax::parse::token::{self, keywords};\n use syntax::ptr::P;\n+use syntax::symbol::{Symbol, keywords};\n use syntax_pos::Span;\n \n pub fn expand_deriving_clone(cx: &mut ExtCtxt,\n@@ -74,7 +74,7 @@ pub fn expand_deriving_clone(cx: &mut ExtCtxt,\n         _ => cx.span_bug(span, \"#[derive(Clone)] on trait item or impl item\"),\n     }\n \n-    let inline = cx.meta_word(span, token::intern(\"inline\"));\n+    let inline = cx.meta_word(span, Symbol::intern(\"inline\"));\n     let attrs = vec![cx.attribute(span, inline)];\n     let trait_def = TraitDef {\n         span: span,"}, {"sha": "6ab5987a159cad3983df2818414950279f52523f", "filename": "src/libsyntax_ext/deriving/cmp/eq.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -14,18 +14,18 @@ use deriving::generic::ty::*;\n use syntax::ast::{self, Expr, MetaItem};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n-use syntax::parse::token;\n use syntax::ptr::P;\n+use syntax::symbol::Symbol;\n use syntax_pos::Span;\n \n pub fn expand_deriving_eq(cx: &mut ExtCtxt,\n                           span: Span,\n                           mitem: &MetaItem,\n                           item: &Annotatable,\n                           push: &mut FnMut(Annotatable)) {\n-    let inline = cx.meta_word(span, token::intern(\"inline\"));\n-    let hidden = cx.meta_list_item_word(span, token::intern(\"hidden\"));\n-    let doc = cx.meta_list(span, token::intern(\"doc\"), vec![hidden]);\n+    let inline = cx.meta_word(span, Symbol::intern(\"inline\"));\n+    let hidden = cx.meta_list_item_word(span, Symbol::intern(\"hidden\"));\n+    let doc = cx.meta_list(span, Symbol::intern(\"doc\"), vec![hidden]);\n     let attrs = vec![cx.attribute(span, inline), cx.attribute(span, doc)];\n     let trait_def = TraitDef {\n         span: span,"}, {"sha": "9fc3d997585d711abfbc3fb2403a554c0bfc1deb", "filename": "src/libsyntax_ext/deriving/cmp/ord.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -14,16 +14,16 @@ use deriving::generic::ty::*;\n use syntax::ast::{self, Expr, MetaItem};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n-use syntax::parse::token;\n use syntax::ptr::P;\n+use syntax::symbol::Symbol;\n use syntax_pos::Span;\n \n pub fn expand_deriving_ord(cx: &mut ExtCtxt,\n                            span: Span,\n                            mitem: &MetaItem,\n                            item: &Annotatable,\n                            push: &mut FnMut(Annotatable)) {\n-    let inline = cx.meta_word(span, token::intern(\"inline\"));\n+    let inline = cx.meta_word(span, Symbol::intern(\"inline\"));\n     let attrs = vec![cx.attribute(span, inline)];\n     let trait_def = TraitDef {\n         span: span,"}, {"sha": "f2a050ce971edc76d414d9998ccfaa70d0a414f7", "filename": "src/libsyntax_ext/deriving/cmp/partial_eq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -14,8 +14,8 @@ use deriving::generic::ty::*;\n use syntax::ast::{BinOpKind, Expr, MetaItem};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n-use syntax::parse::token;\n use syntax::ptr::P;\n+use syntax::symbol::Symbol;\n use syntax_pos::Span;\n \n pub fn expand_deriving_partial_eq(cx: &mut ExtCtxt,\n@@ -64,7 +64,7 @@ pub fn expand_deriving_partial_eq(cx: &mut ExtCtxt,\n \n     macro_rules! md {\n         ($name:expr, $f:ident) => { {\n-            let inline = cx.meta_word(span, token::intern(\"inline\"));\n+            let inline = cx.meta_word(span, Symbol::intern(\"inline\"));\n             let attrs = vec![cx.attribute(span, inline)];\n             MethodDef {\n                 name: $name,"}, {"sha": "ce4d549d696f4d344fb3f2e938f9e370db456fb8", "filename": "src/libsyntax_ext/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -16,8 +16,8 @@ use deriving::generic::ty::*;\n use syntax::ast::{self, BinOpKind, Expr, MetaItem};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n-use syntax::parse::token;\n use syntax::ptr::P;\n+use syntax::symbol::Symbol;\n use syntax_pos::Span;\n \n pub fn expand_deriving_partial_ord(cx: &mut ExtCtxt,\n@@ -27,7 +27,7 @@ pub fn expand_deriving_partial_ord(cx: &mut ExtCtxt,\n                                    push: &mut FnMut(Annotatable)) {\n     macro_rules! md {\n         ($name:expr, $op:expr, $equal:expr) => { {\n-            let inline = cx.meta_word(span, token::intern(\"inline\"));\n+            let inline = cx.meta_word(span, Symbol::intern(\"inline\"));\n             let attrs = vec![cx.attribute(span, inline)];\n             MethodDef {\n                 name: $name,\n@@ -51,7 +51,7 @@ pub fn expand_deriving_partial_ord(cx: &mut ExtCtxt,\n                                     vec![Box::new(ordering_ty)],\n                                     true));\n \n-    let inline = cx.meta_word(span, token::intern(\"inline\"));\n+    let inline = cx.meta_word(span, Symbol::intern(\"inline\"));\n     let attrs = vec![cx.attribute(span, inline)];\n \n     let partial_cmp_def = MethodDef {"}, {"sha": "4d181052d40db79ddcfb7ae8a7094c3328efc160", "filename": "src/libsyntax_ext/deriving/debug.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -11,11 +11,10 @@\n use deriving::generic::*;\n use deriving::generic::ty::*;\n \n-use syntax::ast;\n+use syntax::ast::{self, Ident};\n use syntax::ast::{Expr, MetaItem};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n-use syntax::parse::token;\n use syntax::ptr::P;\n use syntax_pos::{DUMMY_SP, Span};\n \n@@ -71,7 +70,7 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<E\n     let span = Span { expn_id: cx.backtrace(), ..span };\n     let name = cx.expr_lit(span,\n                            ast::LitKind::Str(ident.name.as_str(), ast::StrStyle::Cooked));\n-    let builder = token::str_to_ident(\"builder\");\n+    let builder = Ident::from_str(\"builder\");\n     let builder_expr = cx.expr_ident(span, builder.clone());\n \n     let fmt = substr.nonself_args[0].clone();\n@@ -83,7 +82,7 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<E\n             if !is_struct {\n                 // tuple struct/\"normal\" variant\n                 let expr =\n-                    cx.expr_method_call(span, fmt, token::str_to_ident(\"debug_tuple\"), vec![name]);\n+                    cx.expr_method_call(span, fmt, Ident::from_str(\"debug_tuple\"), vec![name]);\n                 stmts.push(cx.stmt_let(DUMMY_SP, true, builder, expr));\n \n                 for field in fields {\n@@ -93,7 +92,7 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<E\n \n                     let expr = cx.expr_method_call(span,\n                                                    builder_expr.clone(),\n-                                                   token::str_to_ident(\"field\"),\n+                                                   Ident::from_str(\"field\"),\n                                                    vec![field]);\n \n                     // Use `let _ = expr;` to avoid triggering the\n@@ -103,7 +102,7 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<E\n             } else {\n                 // normal struct/struct variant\n                 let expr =\n-                    cx.expr_method_call(span, fmt, token::str_to_ident(\"debug_struct\"), vec![name]);\n+                    cx.expr_method_call(span, fmt, Ident::from_str(\"debug_struct\"), vec![name]);\n                 stmts.push(cx.stmt_let(DUMMY_SP, true, builder, expr));\n \n                 for field in fields {\n@@ -116,7 +115,7 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<E\n                     let field = cx.expr_addr_of(field.span, field);\n                     let expr = cx.expr_method_call(span,\n                                                    builder_expr.clone(),\n-                                                   token::str_to_ident(\"field\"),\n+                                                   Ident::from_str(\"field\"),\n                                                    vec![name, field]);\n                     stmts.push(stmt_let_undescore(cx, span, expr));\n                 }\n@@ -126,7 +125,7 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<E\n         _ => unreachable!(),\n     };\n \n-    let expr = cx.expr_method_call(span, builder_expr, token::str_to_ident(\"finish\"), vec![]);\n+    let expr = cx.expr_method_call(span, builder_expr, Ident::from_str(\"finish\"), vec![]);\n \n     stmts.push(cx.stmt_expr(expr));\n     let block = cx.block(span, stmts);"}, {"sha": "4ce4edef2824f0cda2133d1d428a785d08fec01f", "filename": "src/libsyntax_ext/deriving/decodable.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -18,9 +18,9 @@ use syntax::ast;\n use syntax::ast::{Expr, MetaItem, Mutability};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n-use syntax::parse::token::InternedString;\n-use syntax::parse::token;\n use syntax::ptr::P;\n+use syntax::symbol::InternedString;\n+use syntax::symbol::intern_and_get_ident;\n use syntax_pos::Span;\n \n pub fn expand_deriving_rustc_decodable(cx: &mut ExtCtxt,\n@@ -202,10 +202,7 @@ fn decode_static_fields<F>(cx: &mut ExtCtxt,\n                 let fields = fields.iter()\n                     .enumerate()\n                     .map(|(i, &span)| {\n-                        getarg(cx,\n-                               span,\n-                               token::intern_and_get_ident(&format!(\"_field{}\", i)),\n-                               i)\n+                        getarg(cx, span, intern_and_get_ident(&format!(\"_field{}\", i)), i)\n                     })\n                     .collect();\n "}, {"sha": "69391f48c2288dd512119c79d23412b5423b53ba", "filename": "src/libsyntax_ext/deriving/default.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax_ext%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax_ext%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdefault.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -14,16 +14,16 @@ use deriving::generic::ty::*;\n use syntax::ast::{Expr, MetaItem};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n-use syntax::parse::token;\n use syntax::ptr::P;\n+use syntax::symbol::Symbol;\n use syntax_pos::Span;\n \n pub fn expand_deriving_default(cx: &mut ExtCtxt,\n                                span: Span,\n                                mitem: &MetaItem,\n                                item: &Annotatable,\n                                push: &mut FnMut(Annotatable)) {\n-    let inline = cx.meta_word(span, token::intern(\"inline\"));\n+    let inline = cx.meta_word(span, Symbol::intern(\"inline\"));\n     let attrs = vec![cx.attribute(span, inline)];\n     let trait_def = TraitDef {\n         span: span,"}, {"sha": "0a1397784835c4231e5777397b6526b59ab99fc0", "filename": "src/libsyntax_ext/deriving/encodable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -95,8 +95,8 @@ use deriving::generic::ty::*;\n use syntax::ast::{Expr, ExprKind, MetaItem, Mutability};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n-use syntax::parse::token;\n use syntax::ptr::P;\n+use syntax::symbol::intern_and_get_ident;\n use syntax_pos::Span;\n \n pub fn expand_deriving_rustc_encodable(cx: &mut ExtCtxt,\n@@ -193,7 +193,7 @@ fn encodable_substructure(cx: &mut ExtCtxt,\n             for (i, &FieldInfo { name, ref self_, span, .. }) in fields.iter().enumerate() {\n                 let name = match name {\n                     Some(id) => id.name.as_str(),\n-                    None => token::intern_and_get_ident(&format!(\"_field{}\", i)),\n+                    None => intern_and_get_ident(&format!(\"_field{}\", i)),\n                 };\n                 let self_ref = cx.expr_addr_of(span, self_.clone());\n                 let enc = cx.expr_call(span, fn_path.clone(), vec![self_ref, blkencoder.clone()]);"}, {"sha": "63cd7678321ef832686b8f68fe827d064e8839dd", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -198,8 +198,8 @@ use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n use syntax::codemap::{self, dummy_spanned, respan};\n use syntax::util::move_map::MoveMap;\n-use syntax::parse::token::{self, keywords};\n use syntax::ptr::P;\n+use syntax::symbol::{Symbol, keywords};\n use syntax_pos::{DUMMY_SP, Span};\n use errors::Handler;\n \n@@ -639,13 +639,13 @@ impl<'a> TraitDef<'a> {\n \n         let attr = cx.attribute(self.span,\n                                 cx.meta_word(self.span,\n-                                             token::intern(\"automatically_derived\")));\n+                                             Symbol::intern(\"automatically_derived\")));\n         // Just mark it now since we know that it'll end up used downstream\n         attr::mark_used(&attr);\n         let opt_trait_ref = Some(trait_ref);\n         let unused_qual = {\n-            let word = cx.meta_list_item_word(self.span, token::intern(\"unused_qualifications\"));\n-            cx.attribute(self.span, cx.meta_list(self.span, token::intern(\"allow\"), vec![word]))\n+            let word = cx.meta_list_item_word(self.span, Symbol::intern(\"unused_qualifications\"));\n+            cx.attribute(self.span, cx.meta_list(self.span, Symbol::intern(\"allow\"), vec![word]))\n         };\n \n         let mut a = vec![attr, unused_qual];"}, {"sha": "535d7de19e341aa5432f89d3a57512cd21f19f08", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -16,8 +16,8 @@ use syntax::codemap;\n use syntax::ext::base::{Annotatable, ExtCtxt, SyntaxExtension};\n use syntax::ext::build::AstBuilder;\n use syntax::feature_gate::{self, emit_feature_err};\n-use syntax::parse::token;\n use syntax::ptr::P;\n+use syntax::symbol::Symbol;\n use syntax_pos::Span;\n \n macro_rules! pathvec {\n@@ -80,7 +80,7 @@ fn allow_unstable(cx: &mut ExtCtxt, span: Span, attr_name: &str) -> Span {\n         expn_id: cx.codemap().record_expansion(codemap::ExpnInfo {\n             call_site: span,\n             callee: codemap::NameAndSpan {\n-                format: codemap::MacroAttribute(token::intern(attr_name)),\n+                format: codemap::MacroAttribute(Symbol::intern(attr_name)),\n                 span: Some(span),\n                 allow_internal_unstable: true,\n             },\n@@ -105,7 +105,7 @@ pub fn expand_derive(cx: &mut ExtCtxt,\n         }\n     };\n \n-    let derive = token::intern(\"derive\");\n+    let derive = Symbol::intern(\"derive\");\n     let mut derive_attrs = Vec::new();\n     item = item.map_attrs(|attrs| {\n         let partition = attrs.into_iter().partition(|attr| attr.name() == derive);\n@@ -176,7 +176,7 @@ pub fn expand_derive(cx: &mut ExtCtxt,\n                                            feature_gate::EXPLAIN_CUSTOM_DERIVE);\n         } else {\n             cx.span_warn(titem.span, feature_gate::EXPLAIN_DEPR_CUSTOM_DERIVE);\n-            let name = token::intern(&format!(\"derive_{}\", tname));\n+            let name = Symbol::intern(&format!(\"derive_{}\", tname));\n             let mitem = cx.meta_word(titem.span, name);\n             new_attributes.push(cx.attribute(mitem.span, mitem));\n         }\n@@ -251,10 +251,10 @@ pub fn expand_derive(cx: &mut ExtCtxt,\n \n     // RFC #1445. `#[derive(PartialEq, Eq)]` adds a (trusted)\n     // `#[structural_match]` attribute.\n-    let (partial_eq, eq) = (token::intern(\"PartialEq\"), token::intern(\"Eq\"));\n+    let (partial_eq, eq) = (Symbol::intern(\"PartialEq\"), Symbol::intern(\"Eq\"));\n     if traits.iter().any(|t| t.name() == Some(partial_eq)) &&\n        traits.iter().any(|t| t.name() == Some(eq)) {\n-        let structural_match = token::intern(\"structural_match\");\n+        let structural_match = Symbol::intern(\"structural_match\");\n         let span = allow_unstable(cx, span, \"derive(PartialEq, Eq)\");\n         let meta = cx.meta_word(span, structural_match);\n         item = item.map(|mut i| {\n@@ -267,10 +267,10 @@ pub fn expand_derive(cx: &mut ExtCtxt,\n     // the same as the copy implementation.\n     //\n     // Add a marker attribute here picked up during #[derive(Clone)]\n-    let (copy, clone) = (token::intern(\"Copy\"), token::intern(\"Clone\"));\n+    let (copy, clone) = (Symbol::intern(\"Copy\"), Symbol::intern(\"Clone\"));\n     if traits.iter().any(|t| t.name() == Some(clone)) &&\n        traits.iter().any(|t| t.name() == Some(copy)) {\n-        let marker = token::intern(\"rustc_copy_clone_marker\");\n+        let marker = Symbol::intern(\"rustc_copy_clone_marker\");\n         let span = allow_unstable(cx, span, \"derive(Copy, Clone)\");\n         let meta = cx.meta_word(span, marker);\n         item = item.map(|mut i| {\n@@ -282,14 +282,14 @@ pub fn expand_derive(cx: &mut ExtCtxt,\n     let mut items = Vec::new();\n     for titem in traits.iter() {\n         let tname = titem.word().unwrap().name();\n-        let name = token::intern(&format!(\"derive({})\", tname));\n+        let name = Symbol::intern(&format!(\"derive({})\", tname));\n         let mitem = cx.meta_word(titem.span, name);\n \n         let span = Span {\n             expn_id: cx.codemap().record_expansion(codemap::ExpnInfo {\n                 call_site: titem.span,\n                 callee: codemap::NameAndSpan {\n-                    format: codemap::MacroAttribute(token::intern(&format!(\"derive({})\", tname))),\n+                    format: codemap::MacroAttribute(Symbol::intern(&format!(\"derive({})\", tname))),\n                     span: Some(titem.span),\n                     allow_internal_unstable: true,\n                 },\n@@ -408,7 +408,7 @@ fn call_intrinsic(cx: &ExtCtxt,\n     span.expn_id = cx.codemap().record_expansion(codemap::ExpnInfo {\n         call_site: span,\n         callee: codemap::NameAndSpan {\n-            format: codemap::MacroAttribute(token::intern(\"derive\")),\n+            format: codemap::MacroAttribute(Symbol::intern(\"derive\")),\n             span: Some(span),\n             allow_internal_unstable: true,\n         },"}, {"sha": "f0cefe70ead17eff3273f8975b6a052460b6eef2", "filename": "src/libsyntax_ext/env.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax_ext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax_ext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fenv.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -17,7 +17,7 @@ use syntax::ast;\n use syntax::ext::base::*;\n use syntax::ext::base;\n use syntax::ext::build::AstBuilder;\n-use syntax::parse::token;\n+use syntax::symbol::intern_and_get_ident;\n use syntax_pos::Span;\n use syntax::tokenstream;\n \n@@ -49,7 +49,7 @@ pub fn expand_option_env<'cx>(cx: &'cx mut ExtCtxt,\n         Ok(s) => {\n             cx.expr_call_global(sp,\n                                 cx.std_path(&[\"option\", \"Option\", \"Some\"]),\n-                                vec![cx.expr_str(sp, token::intern_and_get_ident(&s[..]))])\n+                                vec![cx.expr_str(sp, intern_and_get_ident(&s[..]))])\n         }\n     };\n     MacEager::expr(e)\n@@ -73,7 +73,7 @@ pub fn expand_env<'cx>(cx: &'cx mut ExtCtxt,\n         Some((v, _style)) => v,\n     };\n     let msg = match exprs.next() {\n-        None => token::intern_and_get_ident(&format!(\"environment variable `{}` not defined\", var)),\n+        None => intern_and_get_ident(&format!(\"environment variable `{}` not defined\", var)),\n         Some(second) => {\n             match expr_to_string(cx, second, \"expected string literal\") {\n                 None => return DummyResult::expr(sp),\n@@ -92,7 +92,7 @@ pub fn expand_env<'cx>(cx: &'cx mut ExtCtxt,\n             cx.span_err(sp, &msg);\n             cx.expr_usize(sp, 0)\n         }\n-        Ok(s) => cx.expr_str(sp, token::intern_and_get_ident(&s)),\n+        Ok(s) => cx.expr_str(sp, intern_and_get_ident(&s)),\n     };\n     MacEager::expr(e)\n }"}, {"sha": "ed3271f01e7eb32881b7079430d61ace2747a57d", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -17,8 +17,9 @@ use syntax::ast;\n use syntax::ext::base::*;\n use syntax::ext::base;\n use syntax::ext::build::AstBuilder;\n-use syntax::parse::token::{self, keywords};\n+use syntax::parse::token;\n use syntax::ptr::P;\n+use syntax::symbol::{self, keywords};\n use syntax_pos::{Span, DUMMY_SP};\n use syntax::tokenstream;\n \n@@ -369,7 +370,7 @@ impl<'a, 'b> Context<'a, 'b> {\n     /// Translate the accumulated string literals to a literal expression\n     fn trans_literal_string(&mut self) -> P<ast::Expr> {\n         let sp = self.fmtsp;\n-        let s = token::intern_and_get_ident(&self.literal);\n+        let s = symbol::intern_and_get_ident(&self.literal);\n         self.literal.clear();\n         self.ecx.expr_str(sp, s)\n     }"}, {"sha": "e83fd55cd714bfe5032e593fd66e880d2d4b9040", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -53,7 +53,7 @@ use std::rc::Rc;\n use syntax::ast;\n use syntax::ext::base::{MacroExpanderFn, NormalTT, IdentTT, MultiModifier, NamedSyntaxExtension};\n use syntax::ext::tt::macro_rules::MacroRulesExpander;\n-use syntax::parse::token::intern;\n+use syntax::symbol::Symbol;\n \n pub fn register_builtins(resolver: &mut syntax::ext::base::Resolver,\n                          user_exts: Vec<NamedSyntaxExtension>,\n@@ -62,11 +62,11 @@ pub fn register_builtins(resolver: &mut syntax::ext::base::Resolver,\n         resolver.add_ext(ast::Ident::with_empty_ctxt(name), Rc::new(ext));\n     };\n \n-    register(intern(\"macro_rules\"), IdentTT(Box::new(MacroRulesExpander), None, false));\n+    register(Symbol::intern(\"macro_rules\"), IdentTT(Box::new(MacroRulesExpander), None, false));\n \n     macro_rules! register {\n         ($( $name:ident: $f:expr, )*) => { $(\n-            register(intern(stringify!($name)),\n+            register(Symbol::intern(stringify!($name)),\n                      NormalTT(Box::new($f as MacroExpanderFn), None, false));\n         )* }\n     }\n@@ -112,9 +112,10 @@ pub fn register_builtins(resolver: &mut syntax::ext::base::Resolver,\n     }\n \n     // format_args uses `unstable` things internally.\n-    register(intern(\"format_args\"), NormalTT(Box::new(format::expand_format_args), None, true));\n+    register(Symbol::intern(\"format_args\"),\n+             NormalTT(Box::new(format::expand_format_args), None, true));\n \n-    register(intern(\"derive\"), MultiModifier(Box::new(deriving::expand_derive)));\n+    register(Symbol::intern(\"derive\"), MultiModifier(Box::new(deriving::expand_derive)));\n \n     for (name, ext) in user_exts {\n         register(name, ext);"}, {"sha": "f9843cf72940313a1c0127f68ee160d9082c1af4", "filename": "src/libsyntax_ext/proc_macro_registrar.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -17,10 +17,10 @@ use syntax::ext::base::ExtCtxt;\n use syntax::ext::build::AstBuilder;\n use syntax::ext::expand::ExpansionConfig;\n use syntax::parse::ParseSess;\n-use syntax::parse::token;\n use syntax::feature_gate::Features;\n use syntax::fold::Folder;\n use syntax::ptr::P;\n+use syntax::symbol::Symbol;\n use syntax_pos::{Span, DUMMY_SP};\n use syntax::visit::{self, Visitor};\n \n@@ -271,23 +271,23 @@ fn mk_registrar(cx: &mut ExtCtxt,\n     let eid = cx.codemap().record_expansion(ExpnInfo {\n         call_site: DUMMY_SP,\n         callee: NameAndSpan {\n-            format: MacroAttribute(token::intern(\"proc_macro\")),\n+            format: MacroAttribute(Symbol::intern(\"proc_macro\")),\n             span: None,\n             allow_internal_unstable: true,\n         }\n     });\n     let span = Span { expn_id: eid, ..DUMMY_SP };\n \n-    let proc_macro = token::str_to_ident(\"proc_macro\");\n+    let proc_macro = Ident::from_str(\"proc_macro\");\n     let krate = cx.item(span,\n                         proc_macro,\n                         Vec::new(),\n                         ast::ItemKind::ExternCrate(None));\n \n-    let __internal = token::str_to_ident(\"__internal\");\n-    let registry = token::str_to_ident(\"Registry\");\n-    let registrar = token::str_to_ident(\"registrar\");\n-    let register_custom_derive = token::str_to_ident(\"register_custom_derive\");\n+    let __internal = Ident::from_str(\"__internal\");\n+    let registry = Ident::from_str(\"Registry\");\n+    let registrar = Ident::from_str(\"registrar\");\n+    let register_custom_derive = Ident::from_str(\"register_custom_derive\");\n     let stmts = custom_derives.iter().map(|cd| {\n         let path = cx.path_global(cd.span, vec![cd.function_name]);\n         let trait_name = cx.expr_str(cd.span, cd.trait_name.as_str());\n@@ -316,14 +316,14 @@ fn mk_registrar(cx: &mut ExtCtxt,\n                           cx.ty(span, ast::TyKind::Tup(Vec::new())),\n                           cx.block(span, stmts));\n \n-    let derive_registrar = cx.meta_word(span, token::intern(\"rustc_derive_registrar\"));\n+    let derive_registrar = cx.meta_word(span, Symbol::intern(\"rustc_derive_registrar\"));\n     let derive_registrar = cx.attribute(span, derive_registrar);\n     let func = func.map(|mut i| {\n         i.attrs.push(derive_registrar);\n         i.vis = ast::Visibility::Public;\n         i\n     });\n-    let ident = ast::Ident::with_empty_ctxt(token::gensym(\"registrar\"));\n+    let ident = ast::Ident::with_empty_ctxt(Symbol::gensym(\"registrar\"));\n     let module = cx.item_mod(span, span, ident, Vec::new(), vec![krate, func]).map(|mut i| {\n         i.vis = ast::Visibility::Public;\n         i"}, {"sha": "48be8e0c53c2ed2c41363da6e7c843efb8053135", "filename": "src/libsyntax_ext/trace_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax_ext%2Ftrace_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0/src%2Flibsyntax_ext%2Ftrace_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftrace_macros.rs?ref=d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "patch": "@@ -11,7 +11,7 @@\n use syntax::ext::base::ExtCtxt;\n use syntax::ext::base;\n use syntax::feature_gate;\n-use syntax::parse::token::keywords;\n+use syntax::symbol::keywords;\n use syntax_pos::Span;\n use syntax::tokenstream::TokenTree;\n "}]}