{"sha": "c20e3fc1e4186cc6c155b2d83b5e137195454b46", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyMGUzZmMxZTQxODZjYzZjMTU1YjJkODNiNWUxMzcxOTU0NTRiNDY=", "commit": {"author": {"name": "Kornel Lesin\u0301ski", "email": "kornel@geekhood.net", "date": "2015-07-25T15:01:48Z"}, "committer": {"name": "Kornel Lesin\u0301ski", "email": "kornel@geekhood.net", "date": "2015-07-25T15:01:48Z"}, "message": "Document Unicode complications in chars iterator", "tree": {"sha": "6970179c5d6d7e971a997a3101d45a7597e6f46a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6970179c5d6d7e971a997a3101d45a7597e6f46a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c20e3fc1e4186cc6c155b2d83b5e137195454b46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c20e3fc1e4186cc6c155b2d83b5e137195454b46", "html_url": "https://github.com/rust-lang/rust/commit/c20e3fc1e4186cc6c155b2d83b5e137195454b46", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c20e3fc1e4186cc6c155b2d83b5e137195454b46/comments", "author": {"login": "kornelski", "id": 72159, "node_id": "MDQ6VXNlcjcyMTU5", "avatar_url": "https://avatars.githubusercontent.com/u/72159?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kornelski", "html_url": "https://github.com/kornelski", "followers_url": "https://api.github.com/users/kornelski/followers", "following_url": "https://api.github.com/users/kornelski/following{/other_user}", "gists_url": "https://api.github.com/users/kornelski/gists{/gist_id}", "starred_url": "https://api.github.com/users/kornelski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kornelski/subscriptions", "organizations_url": "https://api.github.com/users/kornelski/orgs", "repos_url": "https://api.github.com/users/kornelski/repos", "events_url": "https://api.github.com/users/kornelski/events{/privacy}", "received_events_url": "https://api.github.com/users/kornelski/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kornelski", "id": 72159, "node_id": "MDQ6VXNlcjcyMTU5", "avatar_url": "https://avatars.githubusercontent.com/u/72159?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kornelski", "html_url": "https://github.com/kornelski", "followers_url": "https://api.github.com/users/kornelski/followers", "following_url": "https://api.github.com/users/kornelski/following{/other_user}", "gists_url": "https://api.github.com/users/kornelski/gists{/gist_id}", "starred_url": "https://api.github.com/users/kornelski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kornelski/subscriptions", "organizations_url": "https://api.github.com/users/kornelski/orgs", "repos_url": "https://api.github.com/users/kornelski/repos", "events_url": "https://api.github.com/users/kornelski/events{/privacy}", "received_events_url": "https://api.github.com/users/kornelski/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "04badd6a973d2499731b49365a121dbc4c9c468e", "url": "https://api.github.com/repos/rust-lang/rust/commits/04badd6a973d2499731b49365a121dbc4c9c468e", "html_url": "https://github.com/rust-lang/rust/commit/04badd6a973d2499731b49365a121dbc4c9c468e"}], "stats": {"total": 118, "additions": 71, "deletions": 47}, "files": [{"sha": "7c64dea3dc3381b6ce9a6361fd3aef4ba90670e2", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 71, "deletions": 47, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/c20e3fc1e4186cc6c155b2d83b5e137195454b46/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20e3fc1e4186cc6c155b2d83b5e137195454b46/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=c20e3fc1e4186cc6c155b2d83b5e137195454b46", "patch": "@@ -500,7 +500,7 @@ impl str {\n     ///\n     /// # Unsafety\n     ///\n-    /// Caller must check both UTF-8 character boundaries and the boundaries\n+    /// Caller must check both UTF-8 sequence boundaries and the boundaries\n     /// of the entire slice as\n     /// well.\n     ///\n@@ -526,15 +526,16 @@ impl str {\n         core_str::StrExt::slice_mut_unchecked(self, begin, end)\n     }\n \n-    /// Returns a slice of the string from the character range [`begin`..`end`).\n+    /// Returns a slice of the string from the range [`begin`..`end`) where indices\n+    /// are counted in code points.\n     ///\n     /// That is, start at the `begin`-th code point of the string and continue\n     /// to the `end`-th code point. This does not detect or handle edge cases\n-    /// such as leaving a combining character as the first code point of the\n+    /// such as leaving a combining character as the first `char` of the\n     /// string.\n     ///\n     /// Due to the design of UTF-8, this operation is `O(end)`. Use slicing\n-    /// syntax if you want to use byte indices rather than codepoint indices.\n+    /// syntax if you want to use `O(1)` byte indices instead.\n     ///\n     /// # Panics\n     ///\n@@ -556,26 +557,26 @@ impl str {\n         core_str::StrExt::slice_chars(self, begin, end)\n     }\n \n-    /// Given a byte position, return the next char and its index.\n+    /// Given a byte position, return the next code point and its index.\n     ///\n-    /// This can be used to iterate over the Unicode characters of a string.\n+    /// This can be used to iterate over the Unicode code points of a string.\n     ///\n     /// # Panics\n     ///\n     /// If `i` is greater than or equal to the length of the string.\n-    /// If `i` is not the index of the beginning of a valid UTF-8 character.\n+    /// If `i` is not the index of the beginning of a valid UTF-8 sequence.\n     ///\n     /// # Examples\n     ///\n-    /// This example manually iterates through the characters of a string;\n+    /// This example manually iterates through the code points of a string;\n     /// this should normally be\n     /// done by `.chars()` or `.char_indices()`.\n     ///\n     /// ```\n     /// # #![feature(str_char, core)]\n     /// use std::str::CharRange;\n     ///\n-    /// let s = \"\u4e2d\u534eVi\u1ec7t Nam\";\n+    /// let s = \"\u4e2d\u534eVie\u0323\u0302t Nam\";\n     /// let mut i = 0;\n     /// while i < s.len() {\n     ///     let CharRange {ch, next} = s.char_range_at(i);\n@@ -591,12 +592,14 @@ impl str {\n     /// 3: \u534e\n     /// 6: V\n     /// 7: i\n-    /// 8: \u1ec7\n-    /// 11: t\n-    /// 12:\n-    /// 13: N\n-    /// 14: a\n-    /// 15: m\n+    /// 8: e\n+    /// 9: \u0323\n+    /// 11: \u0302\n+    /// 13: t\n+    /// 14:\n+    /// 15: N\n+    /// 16: a\n+    /// 17: m\n     /// ```\n     #[unstable(feature = \"str_char\",\n                reason = \"often replaced by char_indices, this method may \\\n@@ -608,26 +611,29 @@ impl str {\n \n     /// Given a byte position, return the previous `char` and its position.\n     ///\n-    /// This function can be used to iterate over a Unicode string in reverse.\n+    /// This function can be used to iterate over a Unicode code points in reverse.\n+    ///\n+    /// Note that Unicode has many features, such as combining marks, ligatures,\n+    /// and direction marks, that need to be taken into account to correctly reverse a string.\n     ///\n     /// Returns 0 for next index if called on start index 0.\n     ///\n     /// # Panics\n     ///\n     /// If `i` is greater than the length of the string.\n-    /// If `i` is not an index following a valid UTF-8 character.\n+    /// If `i` is not an index following a valid UTF-8 sequence.\n     ///\n     /// # Examples\n     ///\n-    /// This example manually iterates through the characters of a string;\n+    /// This example manually iterates through the code points of a string;\n     /// this should normally be\n     /// done by `.chars().rev()` or `.char_indices()`.\n     ///\n     /// ```\n     /// # #![feature(str_char, core)]\n     /// use std::str::CharRange;\n     ///\n-    /// let s = \"\u4e2d\u534eVi\u1ec7t Nam\";\n+    /// let s = \"\u4e2d\u534eVie\u0323\u0302t Nam\";\n     /// let mut i = s.len();\n     /// while i > 0 {\n     ///     let CharRange {ch, next} = s.char_range_at_reverse(i);\n@@ -639,12 +645,14 @@ impl str {\n     /// This outputs:\n     ///\n     /// ```text\n-    /// 16: m\n-    /// 15: a\n-    /// 14: N\n-    /// 13:\n-    /// 12: t\n-    /// 11: \u1ec7\n+    /// 18: m\n+    /// 17: a\n+    /// 16: N\n+    /// 15:\n+    /// 14: t\n+    /// 13: \u0302\n+    /// 11: \u0323\n+    /// 9: e\n     /// 8: i\n     /// 7: V\n     /// 6: \u534e\n@@ -663,7 +671,7 @@ impl str {\n     /// # Panics\n     ///\n     /// If `i` is greater than or equal to the length of the string.\n-    /// If `i` is not the index of the beginning of a valid UTF-8 character.\n+    /// If `i` is not the index of the beginning of a valid UTF-8 sequence.\n     ///\n     /// # Examples\n     ///\n@@ -672,6 +680,7 @@ impl str {\n     /// let s = \"ab\u03c0c\";\n     /// assert_eq!(s.char_at(1), 'b');\n     /// assert_eq!(s.char_at(2), '\u03c0');\n+    /// assert_eq!(s.char_at(4), 'c');\n     /// ```\n     #[unstable(feature = \"str_char\",\n                reason = \"frequently replaced by the chars() iterator, this \\\n@@ -689,7 +698,7 @@ impl str {\n     /// # Panics\n     ///\n     /// If `i` is greater than the length of the string.\n-    /// If `i` is not an index following a valid UTF-8 character.\n+    /// If `i` is not an index following a valid UTF-8 sequence.\n     ///\n     /// # Examples\n     ///\n@@ -698,6 +707,7 @@ impl str {\n     /// let s = \"ab\u03c0c\";\n     /// assert_eq!(s.char_at_reverse(1), 'a');\n     /// assert_eq!(s.char_at_reverse(2), 'b');\n+    /// assert_eq!(s.char_at_reverse(3), '\u03c0');\n     /// ```\n     #[unstable(feature = \"str_char\",\n                reason = \"see char_at for more details, but reverse semantics \\\n@@ -707,28 +717,30 @@ impl str {\n         core_str::StrExt::char_at_reverse(self, i)\n     }\n \n-    /// Retrieves the first character from a `&str` and returns it.\n+    /// Retrieves the first code point from a `&str` and returns it.\n+    ///\n+    /// Note that a single Unicode character (grapheme cluster)\n+    /// can be composed of multiple `char`s.\n     ///\n     /// This does not allocate a new string; instead, it returns a slice that\n-    /// points one character\n-    /// beyond the character that was shifted.\n+    /// points one code point beyond the code point that was shifted.\n     ///\n-    /// If the slice does not contain any characters, None is returned instead.\n+    /// `None` is returned if the slice is empty.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// # #![feature(str_char)]\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    /// let s = \"\u0141o\u0301dz\u0301\"; // \\u{141}o\\u{301}dz\\u{301}\n     /// let (c, s1) = s.slice_shift_char().unwrap();\n     ///\n-    /// assert_eq!(c, 'L');\n-    /// assert_eq!(s1, \"\u00f6we \u8001\u864e L\u00e9opard\");\n+    /// assert_eq!(c, '\u0141');\n+    /// assert_eq!(s1, \"o\u0301dz\u0301\");\n     ///\n     /// let (c, s2) = s1.slice_shift_char().unwrap();\n     ///\n-    /// assert_eq!(c, '\u00f6');\n-    /// assert_eq!(s2, \"we \u8001\u864e L\u00e9opard\");\n+    /// assert_eq!(c, 'o');\n+    /// assert_eq!(s2, \"\\u{301}dz\\u{301}\");\n     /// ```\n     #[unstable(feature = \"str_char\",\n                reason = \"awaiting conventions about shifting and slices and \\\n@@ -741,14 +753,14 @@ impl str {\n     /// Divide one string slice into two at an index.\n     ///\n     /// The index `mid` is a byte offset from the start of the string\n-    /// that must be on a character boundary.\n+    /// that must be on a `char` boundary.\n     ///\n     /// Return slices `&self[..mid]` and `&self[mid..]`.\n     ///\n     /// # Panics\n     ///\n-    /// Panics if `mid` is beyond the last character of the string,\n-    /// or if it is not on a character boundary.\n+    /// Panics if `mid` is beyond the last code point of the string,\n+    /// or if it is not on a `char` boundary.\n     ///\n     /// # Examples\n     /// ```\n@@ -773,27 +785,39 @@ impl str {\n         core_str::StrExt::split_at_mut(self, mid)\n     }\n \n-    /// An iterator over the codepoints of `self`.\n+    /// An iterator over the code points of `self`.\n+    ///\n+    /// In Unicode relationship between code points and characters is complex.\n+    /// A single character may be composed of multiple code points\n+    /// (e.g. diacritical marks added to a letter), and a single code point\n+    /// (e.g. Hangul syllable) may contain multiple characters.\n+    ///\n+    /// For iteration over human-readable characters a grapheme cluster iterator\n+    /// may be more appropriate. See the [unicode-segmentation crate][1].\n+    ///\n+    /// [1]: https://crates.io/crates/unicode-segmentation\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// let v: Vec<char> = \"abc \u00e5\u00e4\u00f6\".chars().collect();\n+    /// let v: Vec<char> = \"ASCII z\u0307o\u0301\u0142c\u0301 \ud83c\udde8\ud83c\udded \ud55c\".chars().collect();\n     ///\n-    /// assert_eq!(v, ['a', 'b', 'c', ' ', '\u00e5', '\u00e4', '\u00f6']);\n+    /// assert_eq!(v, ['A', 'S', 'C', 'I', 'I', ' ',\n+    ///     'z', '\\u{307}', 'o', '\\u{301}', '\u0142', 'c', '\\u{301}', ' ',\n+    ///     '\\u{1f1e8}', '\\u{1f1ed}', ' ', '\ud55c']);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn chars(&self) -> Chars {\n         core_str::StrExt::chars(self)\n     }\n \n-    /// An iterator over the characters of `self` and their byte offsets.\n+    /// An iterator over the `char`s of `self` and their byte offsets.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// let v: Vec<(usize, char)> = \"abc\".char_indices().collect();\n-    /// let b = vec![(0, 'a'), (1, 'b'), (2, 'c')];\n+    /// let v: Vec<(usize, char)> = \"A\ud83c\udde8\ud83c\udded\".char_indices().collect();\n+    /// let b = vec![(0, 'A'), (1, '\\u{1f1e8}'), (5, '\\u{1f1ed}')];\n     ///\n     /// assert_eq!(v, b);\n     /// ```\n@@ -822,7 +846,7 @@ impl str {\n     /// # Examples\n     ///\n     /// ```\n-    /// let some_words = \" Mary   had\\ta little  \\n\\t lamb\";\n+    /// let some_words = \" Mary   had\\ta\\u{2009}little  \\n\\t lamb\";\n     /// let v: Vec<&str> = some_words.split_whitespace().collect();\n     ///\n     /// assert_eq!(v, [\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n@@ -840,7 +864,7 @@ impl str {\n     /// ```\n     /// # #![feature(str_words)]\n     /// # #![allow(deprecated)]\n-    /// let some_words = \" Mary   had\\ta little  \\n\\t lamb\";\n+    /// let some_words = \" Mary   had\\ta\\u{2009}little  \\n\\t lamb\";\n     /// let v: Vec<&str> = some_words.words().collect();\n     ///\n     /// assert_eq!(v, [\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);"}]}