{"sha": "399ff259e18c1061aa4ea60856fcecb486d36624", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5OWZmMjU5ZTE4YzEwNjFhYTRlYTYwODU2ZmNlY2I0ODZkMzY2MjQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-20T00:27:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-20T00:27:07Z"}, "message": "auto merge of #19118 : jakub-/rust/roll-up, r=jakub-", "tree": {"sha": "c5a9ea6a35b79ae1f79b3c35fb844b2cba1b36c2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c5a9ea6a35b79ae1f79b3c35fb844b2cba1b36c2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/399ff259e18c1061aa4ea60856fcecb486d36624", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/399ff259e18c1061aa4ea60856fcecb486d36624", "html_url": "https://github.com/rust-lang/rust/commit/399ff259e18c1061aa4ea60856fcecb486d36624", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/399ff259e18c1061aa4ea60856fcecb486d36624/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a24b44483a4983c18645ed85c60b2af3bf358976", "url": "https://api.github.com/repos/rust-lang/rust/commits/a24b44483a4983c18645ed85c60b2af3bf358976", "html_url": "https://github.com/rust-lang/rust/commit/a24b44483a4983c18645ed85c60b2af3bf358976"}, {"sha": "ee66c841655c3abb528841704d991c4a5a67ff9d", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee66c841655c3abb528841704d991c4a5a67ff9d", "html_url": "https://github.com/rust-lang/rust/commit/ee66c841655c3abb528841704d991c4a5a67ff9d"}], "stats": {"total": 2730, "additions": 1629, "deletions": 1101}, "files": [{"sha": "35bba159208f83e6b9a59d17dff71b273c525be6", "filename": "configure", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/configure", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -1031,6 +1031,7 @@ do\n     make_dir $h/test/doc-guide-tasks\n     make_dir $h/test/doc-guide-plugin\n     make_dir $h/test/doc-guide-crates\n+    make_dir $h/test/doc-guide-error-handling\n     make_dir $h/test/doc-rust\n done\n "}, {"sha": "48eb9e81c20a4d8a751e830eedc1a73beb2de635", "filename": "mk/docs.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/mk%2Fdocs.mk", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/mk%2Fdocs.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdocs.mk?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -27,7 +27,7 @@\n ######################################################################\n DOCS := index intro tutorial guide guide-ffi guide-macros guide-lifetimes \\\n \tguide-tasks guide-container guide-pointers guide-testing \\\n-\tguide-plugin guide-crates complement-bugreport \\\n+\tguide-plugin guide-crates complement-bugreport guide-error-handling \\\n \tcomplement-lang-faq complement-design-faq complement-project-faq \\\n     rustdoc guide-unsafe guide-strings reference\n "}, {"sha": "a9f45907b8110b50716f02bbe0ebefd43fcb00b5", "filename": "mk/grammar.mk", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/mk%2Fgrammar.mk", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/mk%2Fgrammar.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fgrammar.mk?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -30,17 +30,25 @@ endef\n $(BG):\n \t$(Q)mkdir -p $(BG)\n \n-$(BG)RustLexer.class: $(SG)RustLexer.g4\n+$(BG)RustLexer.class: $(BG) $(SG)RustLexer.g4\n \t$(Q)$(CFG_ANTLR4) -o $(B)grammar $(SG)RustLexer.g4\n \t$(Q)$(CFG_JAVAC) -d $(BG) $(BG)RustLexer.java\n \n-$(BG)verify: $(SG)verify.rs rustc-stage2-H-$(CFG_BUILD) $(LD)stamp.regex_macros $(LD)stamp.rustc\n-\t$(Q)$(RUSTC) -O --out-dir $(BG) -L $(L) $(SG)verify.rs\n+check-build-lexer-verifier: $(BG)verify\n+\n+ifeq ($(NO_REBUILD),)\n+VERIFY_DEPS :=  rustc-stage2-H-$(CFG_BUILD) $(LD)stamp.regex_macros $(LD)stamp.rustc\n+else\n+VERIFY_DEPS :=\n+endif\n+\n+$(BG)verify: $(BG) $(SG)verify.rs $(VERIFY_DEPS)\n+\t$(Q)$(RUSTC) --out-dir $(BG) -L $(L) $(SG)verify.rs\n \n ifdef CFG_JAVAC\n ifdef CFG_ANTLR4\n ifdef CFG_GRUN\n-check-lexer: $(BG) $(BG)RustLexer.class $(BG)verify\n+check-lexer: $(BG) $(BG)RustLexer.class check-build-lexer-verifier\n \t$(info Verifying libsyntax against the reference lexer ...)\n \t$(Q)$(SG)check.sh $(S) \"$(BG)\" \\\n \t\t\"$(CFG_GRUN)\" \"$(BG)verify\" \"$(BG)RustLexer.tokens\""}, {"sha": "63a34e0f01007a4376058bf7c4b66940c2016e9c", "filename": "mk/tests.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -199,7 +199,7 @@ check-docs: cleantestlibs cleantmptestlogs check-stage2-docs\n \n # Some less critical tests that are not prone to breakage.\n # Not run as part of the normal test suite, but tested by bors on checkin.\n-check-secondary: check-build-compiletest check-lexer check-pretty\n+check-secondary: check-build-compiletest check-build-lexer-verifier check-lexer check-pretty\n \n # check + check-secondary.\n #"}, {"sha": "e2a706e59f0f12436f75e185ebd9a7c35c6f2ebe", "filename": "src/doc/guide-error-handling.md", "status": "added", "additions": 228, "deletions": 0, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Fdoc%2Fguide-error-handling.md", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Fdoc%2Fguide-error-handling.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-error-handling.md?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -0,0 +1,228 @@\n+% Error Handling in Rust\n+\n+> The best-laid plans of mice and men\n+> Often go awry\n+> \n+> \"Tae a Moose\", Robert Burns\n+\n+Sometimes, things just go wrong. It's important to have a plan for when the\n+inevitable happens. Rust has rich support for handling errors that may (let's\n+be honest: will) occur in your programs.\n+\n+There are two main kinds of errors that can occur in your programs: failures,\n+and panics. Let's talk about the difference between the two, and then discuss\n+how to handle each. Then, we'll discuss upgrading failures to panics.\n+\n+# Failure vs. Panic\n+\n+Rust uses two terms to differentiate between two forms of error: failure, and\n+panic. A **failure** is an error that can be recovered from in some way. A\n+**panic** is an error that cannot be recovered from.\n+\n+What do we mean by 'recover'? Well, in most cases, the possibility of an error\n+is expected. For example, consider the `from_str` function:\n+\n+```{rust,ignore}\n+from_str(\"5\");\n+```\n+\n+This function takes a string argument and converts it into another type. But\n+because it's a string, you can't be sure that the conversion actually works.\n+For example, what should this convert to?\n+\n+```{rust,ignore}\n+from_str(\"hello5world\");\n+```\n+\n+This won't work. So we know that this function will only work properly for some\n+inputs. It's expected behavior. We call this kind of error 'failure.'\n+\n+On the other hand, sometimes, there are errors that are unexpected, or which\n+we cannot recover from. A classic example is an `assert!`:\n+\n+```{rust,ignore}\n+assert!(x == 5);\n+```\n+\n+We use `assert!` to declare that something is true. If it's not true, something\n+is very wrong. Wrong enough that we can't continue with things in the current\n+state. Another example is using the `unreachable!()` macro\n+\n+```{rust,ignore}\n+enum Event {\n+    NewRelease,\n+}\n+\n+fn probability(_: &Event) -> f64 {\n+    // real implementation would be more complex, of course\n+    0.95\n+}\n+\n+fn descriptive_probability(event: Event) -> &'static str {\n+    match probability(&event) {\n+        1.00          => \"certain\",\n+        0.00          => \"impossible\",\n+        0.00 ... 0.25 => \"very unlikely\",\n+        0.25 ... 0.50 => \"unlikely\",\n+        0.50 ... 0.75 => \"likely\",\n+        0.75 ... 1.00  => \"very likely\",\n+    }\n+}\n+\n+fn main() {\n+    std::io::println(descriptive_probability(NewRelease));\n+}\n+```\n+\n+This will give us an error:\n+\n+```{notrust,ignore}\n+error: non-exhaustive patterns: `_` not covered [E0004]\n+```\n+\n+While we know that we've covered all possible cases, Rust can't tell. It\n+doesn't know that probability is between 0.0 and 1.0. So we add another case:\n+\n+```rust\n+use Event::NewRelease;\n+\n+enum Event {\n+    NewRelease,\n+}\n+\n+fn probability(_: &Event) -> f64 {\n+    // real implementation would be more complex, of course\n+    0.95\n+}\n+\n+fn descriptive_probability(event: Event) -> &'static str {\n+    match probability(&event) {\n+        1.00          => \"certain\",\n+        0.00          => \"impossible\",\n+        0.00 ... 0.25 => \"very unlikely\",\n+        0.25 ... 0.50 => \"unlikely\",\n+        0.50 ... 0.75 => \"likely\",\n+        0.75 ... 1.00  => \"very likely\",\n+        _ => unreachable!()\n+    }\n+}\n+\n+fn main() {\n+    println!(\"{}\", descriptive_probability(NewRelease));\n+}\n+```\n+\n+We shouldn't ever hit the `_` case, so we use the `unreachable!()` macro to\n+indicate this. `unreachable!()` gives a different kind of error than `Result`.\n+Rust calls these sorts of errors 'panics.'\n+\n+# Handling errors with `Option` and `Result`\n+\n+The simplest way to indicate that a function may fail is to use the `Option<T>`\n+type. Remember our `from_str()` example? Here's its type signature:\n+\n+```{rust,ignore}\n+pub fn from_str<A: FromStr>(s: &str) -> Option<A>\n+```\n+\n+`from_str()` returns an `Option<A>`. If the conversion succeeds, it will return\n+`Some(value)`, and if it fails, it will return `None`.\n+\n+This is appropriate for the simplest of cases, but doesn't give us a lot of\n+information in the failure case. What if we wanted to know _why_ the conversion\n+failed? For this, we can use the `Result<T, E>` type. It looks like this:\n+\n+```rust\n+enum Result<T, E> {\n+   Ok(T),\n+   Err(E)\n+}\n+```\n+\n+This enum is provided by Rust itself, so you don't need to define it to use it\n+in your code. The `Ok(T)` variant represents a success, and the `Err(E)` variant\n+represents a failure. Returning a `Result` instead of an `Option` is recommended\n+for all but the most trivial of situations.\n+\n+Here's an example of using `Result`:\n+\n+```rust\n+#[deriving(Show)]\n+enum Version { Version1, Version2 }\n+\n+#[deriving(Show)]\n+enum ParseError { InvalidHeaderLength, InvalidVersion }\n+\n+fn parse_version(header: &[u8]) -> Result<Version, ParseError> {\n+    if header.len() < 1 {\n+        return Err(ParseError::InvalidHeaderLength);\n+    }\n+    match header[0] {\n+        1 => Ok(Version::Version1),\n+        2 => Ok(Version::Version2),\n+        _ => Err(ParseError::InvalidVersion)\n+    }\n+}\n+\n+let version = parse_version(&[1, 2, 3, 4]);\n+match version {\n+    Ok(v) => {\n+        println!(\"working with version: {}\", v);\n+    }\n+    Err(e) => {\n+        println!(\"error parsing header: {}\", e);\n+    }\n+}\n+```\n+\n+This function makes use of an enum, `ParseError`, to enumerate the various\n+errors that can occur.\n+\n+# Non-recoverable errors with `panic!`\n+\n+In the case of an error that is unexpected and not recoverable, the `panic!`\n+macro will induce a panic. This will crash the current task, and give an error:\n+\n+```{rust,ignore}\n+panic!(\"boom\");\n+```\n+\n+gives\n+\n+```{notrust,ignore}\n+task '<main>' panicked at 'boom', hello.rs:2\n+```\n+\n+when you run it.\n+\n+Because these kinds of situations are relatively rare, use panics sparingly.\n+\n+# Upgrading failures to panics\n+\n+In certain circumstances, even though a function may fail, we may want to treat\n+it as a panic instead. For example, `io::stdin().read_line()` returns an\n+`IoResult<String>`, a form of `Result`, when there is an error reading the\n+line. This allows us to handle and possibly recover from this sort of error.\n+\n+If we don't want to handle this error, and would rather just abort the program,\n+we can use the `unwrap()` method:\n+\n+```{rust,ignore}\n+io::stdin().read_line().unwrap();\n+```\n+\n+`unwrap()` will `panic!` if the `Option` is `None`. This basically says \"Give\n+me the value, and if something goes wrong, just crash.\" This is less reliable\n+than matching the error and attempting to recover, but is also significantly\n+shorter. Sometimes, just crashing is appropriate.\n+\n+There's another way of doing this that's a bit nicer than `unwrap()`:\n+\n+```{rust,ignore}\n+let input = io::stdin().read_line()\n+                       .ok()\n+                       .expect(\"Failed to read line\");\n+```\n+`ok()` converts the `IoResult` into an `Option`, and `expect()` does the same\n+thing as `unwrap()`, but takes a message. This message is passed along to the\n+underlying `panic!`, providing a better error message if the code errors."}, {"sha": "715842a6d05051233d09a1485a93924ae8cb59ea", "filename": "src/doc/guide.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Fdoc%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Fdoc%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide.md?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -159,6 +159,8 @@ $ ./main # or main.exe on Windows\n Hello, world!\n ```\n \n+You can also run these examples on [play.rust-lang.org](http://play.rust-lang.org/) by clicking on the arrow that appears in the upper right of the example when you mouse over the code.\n+\n Success! Let's go over what just happened in detail.\n \n ```{rust}"}, {"sha": "7d4d48e80a38334f6e56da6ceccaec7708751432", "filename": "src/doc/index.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Fdoc%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Fdoc%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Findex.md?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -59,6 +59,7 @@ a guide that can help you out:\n * [References and Lifetimes](guide-lifetimes.html)\n * [Crates and modules](guide-crates.html)\n * [Tasks and Communication](guide-tasks.html)\n+* [Error Handling](guide-error-handling.html)\n * [Foreign Function Interface](guide-ffi.html)\n * [Writing Unsafe and Low-Level Code](guide-unsafe.html)\n * [Macros](guide-macros.html)"}, {"sha": "4fbb3c210165ad830847722243e52264f7b57f18", "filename": "src/doc/po4a.conf", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Fdoc%2Fpo4a.conf", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Fdoc%2Fpo4a.conf", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fpo4a.conf?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -20,6 +20,7 @@\n [type: text] src/doc/guide-testing.md $lang:doc/l10n/$lang/guide-testing.md\n [type: text] src/doc/guide-unsafe.md $lang:doc/l10n/$lang/guide-unsafe.md\n [type: text] src/doc/guide-crates.md $lang:doc/l10n/$lang/guide-crates.md\n+[type: text] src/doc/guide-error-handling.md $lang:doc/l10n/$lang/guide-error-handling.md\n [type: text] src/doc/guide.md $lang:doc/l10n/$lang/guide.md\n [type: text] src/doc/index.md $lang:doc/l10n/$lang/index.md\n [type: text] src/doc/intro.md $lang:doc/l10n/$lang/intro.md"}, {"sha": "d21d877c458b62f275af7fed75bcfb86f41bfe78", "filename": "src/doc/reference.md", "status": "modified", "additions": 26, "deletions": 29, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -216,9 +216,15 @@ rather than referring to it by name or some other evaluation rule. A literal is\n a form of constant expression, so is evaluated (primarily) at compile time.\n \n ```{.ebnf .gram}\n-literal : string_lit | char_lit | byte_string_lit | byte_lit | num_lit ;\n+lit_suffix : ident;\n+literal : [ string_lit | char_lit | byte_string_lit | byte_lit | num_lit ] lit_suffix ?;\n ```\n \n+The optional suffix is only used for certain numeric literals, but is\n+reserved for future extension, that is, the above gives the lexical\n+grammar, but a Rust parser will reject everything but the 12 special\n+cases mentioned in [Number literals](#number-literals) below.\n+\n #### Character and string literals\n \n ```{.ebnf .gram}\n@@ -371,27 +377,20 @@ b\"\\\\x52\"; br\"\\x52\";                  // \\x52\n #### Number literals\n \n ```{.ebnf .gram}\n-num_lit : nonzero_dec [ dec_digit | '_' ] * num_suffix ?\n-        | '0' [       [ dec_digit | '_' ] * num_suffix ?\n-              | 'b'   [ '1' | '0' | '_' ] + int_suffix ?\n-              | 'o'   [ oct_digit | '_' ] + int_suffix ?\n-              | 'x'   [ hex_digit | '_' ] + int_suffix ? ] ;\n-\n-num_suffix : int_suffix | float_suffix ;\n+num_lit : nonzero_dec [ dec_digit | '_' ] * float_suffix ?\n+        | '0' [       [ dec_digit | '_' ] * float_suffix ?\n+              | 'b'   [ '1' | '0' | '_' ] +\n+              | 'o'   [ oct_digit | '_' ] +\n+              | 'x'   [ hex_digit | '_' ] +  ] ;\n \n-int_suffix : 'u' int_suffix_size ?\n-           | 'i' int_suffix_size ? ;\n-int_suffix_size : [ '8' | \"16\" | \"32\" | \"64\" ] ;\n+float_suffix : [ exponent | '.' dec_lit exponent ? ] ? ;\n \n-float_suffix : [ exponent | '.' dec_lit exponent ? ] ? float_suffix_ty ? ;\n-float_suffix_ty : 'f' [ \"32\" | \"64\" ] ;\n exponent : ['E' | 'e'] ['-' | '+' ] ? dec_lit ;\n dec_lit : [ dec_digit | '_' ] + ;\n ```\n \n A _number literal_ is either an _integer literal_ or a _floating-point\n-literal_. The grammar for recognizing the two kinds of literals is mixed, as\n-they are differentiated by suffixes.\n+literal_. The grammar for recognizing the two kinds of literals is mixed.\n \n ##### Integer literals\n \n@@ -406,9 +405,9 @@ An _integer literal_ has one of four forms:\n * A _binary literal_ starts with the character sequence `U+0030` `U+0062`\n   (`0b`) and continues as any mixture of binary digits and underscores.\n \n-An integer literal may be followed (immediately, without any spaces) by an\n-_integer suffix_, which changes the type of the literal. There are two kinds of\n-integer literal suffix:\n+Like any literal, an integer literal may be followed (immediately,\n+without any spaces) by an _integer suffix_, which forcibly sets the\n+type of the literal. There are 10 valid values for an integer suffix:\n \n * The `i` and `u` suffixes give the literal type `int` or `uint`,\n   respectively.\n@@ -443,11 +442,9 @@ A _floating-point literal_ has one of two forms:\n * A single _decimal literal_ followed by an _exponent_.\n \n By default, a floating-point literal has a generic type, and, like integer\n-literals, the type must be uniquely determined from the context. A\n-floating-point literal may be followed (immediately, without any spaces) by a\n-_floating-point suffix_, which changes the type of the literal. There are two\n-floating-point suffixes: `f32`, and `f64` (the 32-bit and 64-bit floating point\n-types).\n+literals, the type must be uniquely determined from the context. There are two valid\n+_floating-point suffixes_, `f32` and `f64` (the 32-bit and 64-bit floating point\n+types), which explicitly determine the type of the literal.\n \n Examples of floating-point literals of various forms:\n \n@@ -3433,7 +3430,7 @@ use to avoid conflicts is simply to name variants with upper-case letters, and\n local variables with lower-case letters.\n \n Multiple match patterns may be joined with the `|` operator. A range of values\n-may be specified with `..`. For example:\n+may be specified with `...`. For example:\n \n ```\n # let x = 2i;\n@@ -4042,19 +4039,19 @@ initialized; this is enforced by the compiler.\n \n ### Boxes\n \n-An  _box_ is a reference to a heap allocation holding another value, which is\n+A _box_ is a reference to a heap allocation holding another value, which is\n constructed by the prefix operator `box`. When the standard library is in use,\n-the type of an box is `std::owned::Box<T>`.\n+the type of a box is `std::owned::Box<T>`.\n \n-An example of an box type and value:\n+An example of a box type and value:\n \n ```\n let x: Box<int> = box 10;\n ```\n \n-Box values exist in 1:1 correspondence with their heap allocation, copying an\n+Box values exist in 1:1 correspondence with their heap allocation, copying a\n box value makes a shallow copy of the pointer. Rust will consider a shallow\n-copy of an box to move ownership of the value. After a value has been moved,\n+copy of a box to move ownership of the value. After a value has been moved,\n the source location cannot be used unless it is reinitialized.\n \n ```"}, {"sha": "0ff9af7aca133625e3b98670951babfeafc3b1b0", "filename": "src/grammar/RustLexer.g4", "status": "modified", "additions": 15, "deletions": 29, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Fgrammar%2FRustLexer.g4", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Fgrammar%2FRustLexer.g4", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2FRustLexer.g4?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -92,49 +92,35 @@ fragment CHAR_ESCAPE\n   | 'U' HEXIT HEXIT HEXIT HEXIT HEXIT HEXIT HEXIT HEXIT\n   ;\n \n-LIT_CHAR\n-  : '\\'' ( '\\\\' CHAR_ESCAPE | ~[\\\\'\\n\\t\\r] ) '\\''\n+fragment SUFFIX\n+  : IDENT\n   ;\n \n-LIT_BYTE\n-  : 'b\\'' ( '\\\\' ( [xX] HEXIT HEXIT | [nrt\\\\'\"0] ) | ~[\\\\'\\n\\t\\r] ) '\\''\n+LIT_CHAR\n+  : '\\'' ( '\\\\' CHAR_ESCAPE | ~[\\\\'\\n\\t\\r] ) '\\'' SUFFIX?\n   ;\n \n-fragment INT_SUFFIX\n-  : 'i'\n-  | 'i8'\n-  | 'i16'\n-  | 'i32'\n-  | 'i64'\n-  | 'u'\n-  | 'u8'\n-  | 'u16'\n-  | 'u32'\n-  | 'u64'\n+LIT_BYTE\n+  : 'b\\'' ( '\\\\' ( [xX] HEXIT HEXIT | [nrt\\\\'\"0] ) | ~[\\\\'\\n\\t\\r] ) '\\'' SUFFIX?\n   ;\n \n LIT_INTEGER\n-  : [0-9][0-9_]* INT_SUFFIX?\n-  | '0b' [01][01_]* INT_SUFFIX?\n-  | '0o' [0-7][0-7_]* INT_SUFFIX?\n-  | '0x' [0-9a-fA-F][0-9a-fA-F_]* INT_SUFFIX?\n-  ;\n-\n-fragment FLOAT_SUFFIX\n-  : 'f32'\n-  | 'f64'\n+  : [0-9][0-9_]* SUFFIX?\n+  | '0b' [01][01_]* SUFFIX?\n+  | '0o' [0-7][0-7_]* SUFFIX?\n+  | '0x' [0-9a-fA-F][0-9a-fA-F_]* SUFFIX?\n   ;\n \n LIT_FLOAT\n-  : [0-9][0-9_]* ('.' | ('.' [0-9][0-9_]*)? ([eE] [-+]? [0-9][0-9_]*)? FLOAT_SUFFIX?)\n+  : [0-9][0-9_]* ('.' | ('.' [0-9][0-9_]*)? ([eE] [-+]? [0-9][0-9_]*)? SUFFIX?)\n   ;\n \n LIT_STR\n-  : '\"' ('\\\\\\n' | '\\\\\\r\\n' | '\\\\' CHAR_ESCAPE | .)*? '\"'\n+  : '\"' ('\\\\\\n' | '\\\\\\r\\n' | '\\\\' CHAR_ESCAPE | .)*? '\"' SUFFIX?\n   ;\n \n-LIT_BINARY : 'b' LIT_STR ;\n-LIT_BINARY_RAW : 'rb' LIT_STR_RAW ;\n+LIT_BINARY : 'b' LIT_STR SUFFIX?;\n+LIT_BINARY_RAW : 'rb' LIT_STR_RAW SUFFIX?;\n \n /* this is a bit messy */\n \n@@ -148,7 +134,7 @@ fragment LIT_STR_RAW_INNER2\n   ;\n \n LIT_STR_RAW\n-  : 'r' LIT_STR_RAW_INNER\n+  : 'r' LIT_STR_RAW_INNER SUFFIX?\n   ;\n \n IDENT : XID_start XID_continue* ;"}, {"sha": "e3ff20f7874bf88239f76197eda765a377d7ecf7", "filename": "src/grammar/verify.rs", "status": "modified", "additions": 47, "deletions": 44, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Fgrammar%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Fgrammar%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fverify.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -26,21 +26,21 @@ use std::io::File;\n \n use syntax::parse;\n use syntax::parse::lexer;\n-use rustc::driver::{session, config};\n+use rustc::session::{mod, config};\n \n use syntax::ast;\n use syntax::ast::Name;\n use syntax::parse::token;\n use syntax::parse::lexer::TokenAndSpan;\n \n-fn parse_token_list(file: &str) -> HashMap<String, Token> {\n-    fn id() -> Token {\n+fn parse_token_list(file: &str) -> HashMap<String, token::Token> {\n+    fn id() -> token::Token {\n         token::Ident(ast::Ident { name: Name(0), ctxt: 0, }, token::Plain)\n     }\n \n     let mut res = HashMap::new();\n \n-    res.insert(\"-1\".to_string(), EOF);\n+    res.insert(\"-1\".to_string(), token::Eof);\n \n     for line in file.split('\\n') {\n         let eq = match line.trim().rfind('=') {\n@@ -60,8 +60,8 @@ fn parse_token_list(file: &str) -> HashMap<String, Token> {\n             \"INT_SUFFIX\"        => id(),\n             \"SHL\"               => token::BinOp(token::Shl),\n             \"LBRACE\"            => token::OpenDelim(token::Brace),\n-            \"RARROW\"            => token::Rarrow,\n-            \"LIT_STR\"           => token::LitStr(Name(0)),\n+            \"RARROW\"            => token::RArrow,\n+            \"LIT_STR\"           => token::Literal(token::Str_(Name(0))),\n             \"DOTDOT\"            => token::DotDot,\n             \"MOD_SEP\"           => token::ModSep,\n             \"DOTDOTDOT\"         => token::DotDotDot,\n@@ -71,17 +71,17 @@ fn parse_token_list(file: &str) -> HashMap<String, Token> {\n             \"ANDAND\"            => token::AndAnd,\n             \"AT\"                => token::At,\n             \"LBRACKET\"          => token::OpenDelim(token::Bracket),\n-            \"LIT_STR_RAW\"       => token::LitStrRaw(Name(0), 0),\n+            \"LIT_STR_RAW\"       => token::Literal(token::StrRaw(Name(0), 0)),\n             \"RPAREN\"            => token::CloseDelim(token::Paren),\n             \"SLASH\"             => token::BinOp(token::Slash),\n             \"COMMA\"             => token::Comma,\n             \"LIFETIME\"          => token::Lifetime(ast::Ident { name: Name(0), ctxt: 0 }),\n             \"CARET\"             => token::BinOp(token::Caret),\n             \"TILDE\"             => token::Tilde,\n-            \"IDENT\"             => token::Id(),\n+            \"IDENT\"             => id(),\n             \"PLUS\"              => token::BinOp(token::Plus),\n-            \"LIT_CHAR\"          => token::LitChar(Name(0)),\n-            \"LIT_BYTE\"          => token::LitByte(Name(0)),\n+            \"LIT_CHAR\"          => token::Literal(token::Char(Name(0))),\n+            \"LIT_BYTE\"          => token::Literal(token::Byte(Name(0))),\n             \"EQ\"                => token::Eq,\n             \"RBRACKET\"          => token::CloseDelim(token::Bracket),\n             \"COMMENT\"           => token::Comment,\n@@ -95,9 +95,9 @@ fn parse_token_list(file: &str) -> HashMap<String, Token> {\n             \"BINOP\"             => token::BinOp(token::Plus),\n             \"POUND\"             => token::Pound,\n             \"OROR\"              => token::OrOr,\n-            \"LIT_INTEGER\"       => token::LitInteger(Name(0)),\n+            \"LIT_INTEGER\"       => token::Literal(token::Integer(Name(0))),\n             \"BINOPEQ\"           => token::BinOpEq(token::Plus),\n-            \"LIT_FLOAT\"         => token::LitFloat(Name(0)),\n+            \"LIT_FLOAT\"         => token::Literal(token::Float(Name(0))),\n             \"WHITESPACE\"        => token::Whitespace,\n             \"UNDERSCORE\"        => token::Underscore,\n             \"MINUS\"             => token::BinOp(token::Minus),\n@@ -107,8 +107,8 @@ fn parse_token_list(file: &str) -> HashMap<String, Token> {\n             \"OR\"                => token::BinOp(token::Or),\n             \"GT\"                => token::Gt,\n             \"LE\"                => token::Le,\n-            \"LIT_BINARY\"        => token::LitBinary(Name(0)),\n-            \"LIT_BINARY_RAW\"    => token::LitBinaryRaw(Name(0), 0),\n+            \"LIT_BINARY\"        => token::Literal(token::Binary(Name(0))),\n+            \"LIT_BINARY_RAW\"    => token::Literal(token::BinaryRaw(Name(0), 0)),\n             _                   => continue,\n         };\n \n@@ -119,7 +119,7 @@ fn parse_token_list(file: &str) -> HashMap<String, Token> {\n     res\n }\n \n-fn str_to_binop(s: &str) -> BinOpToken {\n+fn str_to_binop(s: &str) -> token::BinOpToken {\n     match s {\n         \"+\"     => token::Plus,\n         \"/\"     => token::Slash,\n@@ -167,7 +167,7 @@ fn count(lit: &str) -> uint {\n     lit.chars().take_while(|c| *c == '#').count()\n }\n \n-fn parse_antlr_token(s: &str, tokens: &HashMap<String, Token>) -> TokenAndSpan {\n+fn parse_antlr_token(s: &str, tokens: &HashMap<String, token::Token>) -> TokenAndSpan {\n     let re = regex!(\n       r\"\\[@(?P<seq>\\d+),(?P<start>\\d+):(?P<end>\\d+)='(?P<content>.+?)',<(?P<toknum>-?\\d+)>,\\d+:\\d+]\"\n     );\n@@ -178,7 +178,7 @@ fn parse_antlr_token(s: &str, tokens: &HashMap<String, Token>) -> TokenAndSpan {\n     let toknum = m.name(\"toknum\");\n     let content = m.name(\"content\");\n \n-    let proto_tok = tokens.get(&toknum).expect(format!(\"didn't find token {} in the map\",\n+    let proto_tok = tokens.get(toknum).expect(format!(\"didn't find token {} in the map\",\n                                                               toknum).as_slice());\n \n     let nm = parse::token::intern(content);\n@@ -189,22 +189,25 @@ fn parse_antlr_token(s: &str, tokens: &HashMap<String, Token>) -> TokenAndSpan {\n         token::BinOp(..)           => token::BinOp(str_to_binop(content)),\n         token::BinOpEq(..)         => token::BinOpEq(str_to_binop(content.slice_to(\n                                                                     content.len() - 1))),\n-        token::LitStr(..)          => token::LitStr(fix(content)),\n-        token::LitStrRaw(..)       => token::LitStrRaw(fix(content), count(content)),\n-        token::LitChar(..)         => token::LitChar(fixchar(content)),\n-        token::LitByte(..)         => token::LitByte(fixchar(content)),\n+        token::Literal(token::Str_(..))      => token::Literal(token::Str_(fix(content))),\n+        token::Literal(token::StrRaw(..))    => token::Literal(token::StrRaw(fix(content),\n+                                                                             count(content))),\n+        token::Literal(token::Char(..))      => token::Literal(token::Char(fixchar(content))),\n+        token::Literal(token::Byte(..))      => token::Literal(token::Byte(fixchar(content))),\n         token::DocComment(..)      => token::DocComment(nm),\n-        token::LitInteger(..)      => token::LitInteger(nm),\n-        token::LitFloat(..)        => token::LitFloat(nm),\n-        token::LitBinary(..)       => token::LitBinary(nm),\n-        token::LitBinaryRaw(..)    => token::LitBinaryRaw(fix(content), count(content)),\n+        token::Literal(token::Integer(..))   => token::Literal(token::Integer(nm)),\n+        token::Literal(token::Float(..))     => token::Literal(token::Float(nm)),\n+        token::Literal(token::Binary(..))    => token::Literal(token::Binary(nm)),\n+        token::Literal(token::BinaryRaw(..)) => token::Literal(token::BinaryRaw(fix(content),\n+                                                                                count(content))),\n         token::Ident(..)           => token::Ident(ast::Ident { name: nm, ctxt: 0 },\n                                                    token::ModName),\n         token::Lifetime(..)        => token::Lifetime(ast::Ident { name: nm, ctxt: 0 }),\n         ref t => t.clone()\n     };\n \n-    let offset = if real_tok == EOF {\n+    let offset = if real_tok == token::Eof\n+ {\n         1\n     } else {\n         0\n@@ -222,7 +225,7 @@ fn parse_antlr_token(s: &str, tokens: &HashMap<String, Token>) -> TokenAndSpan {\n     }\n }\n \n-fn tok_cmp(a: &Token, b: &Token) -> bool {\n+fn tok_cmp(a: &token::Token, b: &token::Token) -> bool {\n     match a {\n         &token::Ident(id, _) => match b {\n                 &token::Ident(id2, _) => id == id2,\n@@ -240,25 +243,25 @@ fn main() {\n \n     let args = std::os::args();\n \n-    let mut token_file = File::open(&Path::new(args.get(2).as_slice()));\n+    let mut token_file = File::open(&Path::new(args[2].as_slice()));\n     let token_map = parse_token_list(token_file.read_to_string().unwrap().as_slice());\n \n     let mut stdin = std::io::stdin();\n     let mut antlr_tokens = stdin.lines().map(|l| parse_antlr_token(l.unwrap().as_slice().trim(),\n                                                                    &token_map));\n \n-    let code = File::open(&Path::new(args.get(1).as_slice())).unwrap().read_to_string().unwrap();\n+    let code = File::open(&Path::new(args[1].as_slice())).unwrap().read_to_string().unwrap();\n     let options = config::basic_options();\n     let session = session::build_session(options, None,\n-                                         syntax::diagnostics::registry::Registry::new([]));\n+                                         syntax::diagnostics::registry::Registry::new(&[]));\n     let filemap = parse::string_to_filemap(&session.parse_sess,\n                                            code,\n                                            String::from_str(\"<n/a>\"));\n     let mut lexer = lexer::StringReader::new(session.diagnostic(), filemap);\n \n     for antlr_tok in antlr_tokens {\n         let rustc_tok = next(&mut lexer);\n-        if rustc_tok.tok == EOF && antlr_tok.tok == EOF {\n+        if rustc_tok.tok == token::Eof && antlr_tok.tok == token::Eof {\n             continue\n         }\n \n@@ -284,19 +287,19 @@ fn main() {\n         )\n \n         matches!(\n-            LitByte(..),\n-            LitChar(..),\n-            LitInteger(..),\n-            LitFloat(..),\n-            LitStr(..),\n-            LitStrRaw(..),\n-            LitBinary(..),\n-            LitBinaryRaw(..),\n-            Ident(..),\n-            Lifetime(..),\n-            Interpolated(..),\n-            DocComment(..),\n-            Shebang(..)\n+            token::Literal(token::Byte(..)),\n+            token::Literal(token::Char(..)),\n+            token::Literal(token::Integer(..)),\n+            token::Literal(token::Float(..)),\n+            token::Literal(token::Str_(..)),\n+            token::Literal(token::StrRaw(..)),\n+            token::Literal(token::Binary(..)),\n+            token::Literal(token::BinaryRaw(..)),\n+            token::Ident(..),\n+            token::Lifetime(..),\n+            token::Interpolated(..),\n+            token::DocComment(..),\n+            token::Shebang(..)\n         );\n     }\n }"}, {"sha": "64abc78daf309c70f2e379ed445d9e053d7f5f70", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -1678,10 +1678,10 @@ impl<'a> Iterator<uint> for TwoBitPositions<'a> {\n mod tests {\n     use std::prelude::*;\n     use std::iter::range_step;\n-    use std::u32;\n     use std::rand;\n     use std::rand::Rng;\n-    use test::Bencher;\n+    use std::u32;\n+    use test::{Bencher, black_box};\n \n     use super::{Bitv, BitvSet, from_fn, from_bytes};\n     use bitv;\n@@ -2676,8 +2676,8 @@ mod tests {\n             for _ in range(0u, 100) {\n                 bitv |= 1 << ((r.next_u32() as uint) % u32::BITS);\n             }\n-            &bitv\n-        })\n+            black_box(&bitv)\n+        });\n     }\n \n     #[bench]\n@@ -2688,8 +2688,8 @@ mod tests {\n             for _ in range(0u, 100) {\n                 bitv.set((r.next_u32() as uint) % BENCH_BITS, true);\n             }\n-            &bitv\n-        })\n+            black_box(&bitv)\n+        });\n     }\n \n     #[bench]\n@@ -2700,8 +2700,8 @@ mod tests {\n             for _ in range(0u, 100) {\n                 bitv.set((r.next_u32() as uint) % BENCH_BITS, r.gen());\n             }\n-            &bitv\n-        })\n+            black_box(&bitv);\n+        });\n     }\n \n     #[bench]\n@@ -2712,8 +2712,8 @@ mod tests {\n             for _ in range(0u, 100) {\n                 bitv.set((r.next_u32() as uint) % u32::BITS, true);\n             }\n-            &bitv\n-        })\n+            black_box(&bitv);\n+        });\n     }\n \n     #[bench]\n@@ -2724,8 +2724,8 @@ mod tests {\n             for _ in range(0u, 100) {\n                 bitv.insert((r.next_u32() as uint) % u32::BITS);\n             }\n-            &bitv\n-        })\n+            black_box(&bitv);\n+        });\n     }\n \n     #[bench]\n@@ -2736,8 +2736,8 @@ mod tests {\n             for _ in range(0u, 100) {\n                 bitv.insert((r.next_u32() as uint) % BENCH_BITS);\n             }\n-            &bitv\n-        })\n+            black_box(&bitv);\n+        });\n     }\n \n     #[bench]"}, {"sha": "5e341ba8b04d3b2e90e19cb5717a5d3ee762915d", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -2084,7 +2084,7 @@ mod bench {\n     use std::rand::{weak_rng, Rng};\n     use std::mem;\n     use std::ptr;\n-    use test::Bencher;\n+    use test::{Bencher, black_box};\n \n     use vec::Vec;\n \n@@ -2140,8 +2140,8 @@ mod bench {\n         let mut vec: Vec<uint> = vec![];\n         b.iter(|| {\n             vec.push(0);\n-            &vec\n-        })\n+            black_box(&vec);\n+        });\n     }\n \n     #[bench]"}, {"sha": "e930f353b52258b14a3c7b4ca5fa170644275f7c", "filename": "src/libcore/atomic.rs", "status": "modified", "additions": 296, "deletions": 98, "changes": 394, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibcore%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibcore%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fatomic.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -18,28 +18,28 @@ use intrinsics;\n use std::kinds::marker;\n use cell::UnsafeCell;\n \n-/// An atomic boolean type.\n+/// A boolean type which can be safely shared between threads.\n #[stable]\n pub struct AtomicBool {\n     v: UnsafeCell<uint>,\n     nocopy: marker::NoCopy\n }\n \n-/// A signed atomic integer type, supporting basic atomic arithmetic operations\n+/// A signed integer type which can be safely shared between threads.\n #[stable]\n pub struct AtomicInt {\n     v: UnsafeCell<int>,\n     nocopy: marker::NoCopy\n }\n \n-/// An unsigned atomic integer type, supporting basic atomic arithmetic operations\n+/// An unsigned integer type which can be safely shared between threads.\n #[stable]\n pub struct AtomicUint {\n     v: UnsafeCell<uint>,\n     nocopy: marker::NoCopy\n }\n \n-/// An unsafe atomic pointer. Only supports basic atomic operations\n+/// A raw pointer type which can be safely shared between threads.\n #[stable]\n pub struct AtomicPtr<T> {\n     p: UnsafeCell<uint>,\n@@ -54,43 +54,42 @@ pub struct AtomicPtr<T> {\n /// to be moved either before or after the atomic operation; on the other end\n /// \"relaxed\" atomics allow all reorderings.\n ///\n-/// Rust's memory orderings are the same as in C++[1].\n-///\n-/// 1: http://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync\n+/// Rust's memory orderings are [the same as\n+/// C++'s](http://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync).\n #[stable]\n pub enum Ordering {\n-    /// No ordering constraints, only atomic operations\n+    /// No ordering constraints, only atomic operations.\n     #[stable]\n     Relaxed,\n     /// When coupled with a store, all previous writes become visible\n     /// to another thread that performs a load with `Acquire` ordering\n-    /// on the same value\n+    /// on the same value.\n     #[stable]\n     Release,\n     /// When coupled with a load, all subsequent loads will see data\n     /// written before a store with `Release` ordering on the same value\n-    /// in another thread\n+    /// in another thread.\n     #[stable]\n     Acquire,\n     /// When coupled with a load, uses `Acquire` ordering, and with a store\n-    /// `Release` ordering\n+    /// `Release` ordering.\n     #[stable]\n     AcqRel,\n     /// Like `AcqRel` with the additional guarantee that all threads see all\n     /// sequentially consistent operations in the same order.\n     #[stable]\n-    SeqCst\n+    SeqCst,\n }\n \n-/// An `AtomicBool` initialized to `false`\n+/// An `AtomicBool` initialized to `false`.\n #[unstable = \"may be renamed, pending conventions for static initalizers\"]\n pub const INIT_ATOMIC_BOOL: AtomicBool =\n         AtomicBool { v: UnsafeCell { value: 0 }, nocopy: marker::NoCopy };\n-/// An `AtomicInt` initialized to `0`\n+/// An `AtomicInt` initialized to `0`.\n #[unstable = \"may be renamed, pending conventions for static initalizers\"]\n pub const INIT_ATOMIC_INT: AtomicInt =\n         AtomicInt { v: UnsafeCell { value: 0 }, nocopy: marker::NoCopy };\n-/// An `AtomicUint` initialized to `0`\n+/// An `AtomicUint` initialized to `0`.\n #[unstable = \"may be renamed, pending conventions for static initalizers\"]\n pub const INIT_ATOMIC_UINT: AtomicUint =\n         AtomicUint { v: UnsafeCell { value: 0, }, nocopy: marker::NoCopy };\n@@ -99,26 +98,59 @@ pub const INIT_ATOMIC_UINT: AtomicUint =\n const UINT_TRUE: uint = -1;\n \n impl AtomicBool {\n-    /// Create a new `AtomicBool`\n+    /// Creates a new `AtomicBool`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomic::AtomicBool;\n+    ///\n+    /// let atomic_true  = AtomicBool::new(true);\n+    /// let atomic_false = AtomicBool::new(false);\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn new(v: bool) -> AtomicBool {\n         let val = if v { UINT_TRUE } else { 0 };\n         AtomicBool { v: UnsafeCell::new(val), nocopy: marker::NoCopy }\n     }\n \n-    /// Load the value\n+    /// Loads a value from the bool.\n+    ///\n+    /// `load` takes an `Ordering` argument which describes the memory ordering of this operation.\n     ///\n     /// # Panics\n     ///\n     /// Panics if `order` is `Release` or `AcqRel`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomic::{AtomicBool, Ordering};\n+    ///\n+    /// let some_bool = AtomicBool::new(true);\n+    ///\n+    /// let value = some_bool.load(Ordering::Relaxed);\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn load(&self, order: Ordering) -> bool {\n         unsafe { atomic_load(self.v.get() as *const uint, order) > 0 }\n     }\n \n-    /// Store the value\n+    /// Stores a value into the bool.\n+    ///\n+    /// `store` takes an `Ordering` argument which describes the memory ordering of this operation.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomic::{AtomicBool, Ordering};\n+    ///\n+    /// let some_bool = AtomicBool::new(true);\n+    ///\n+    /// some_bool.store(false, Ordering::Relaxed);\n+    /// ```\n     ///\n     /// # Panics\n     ///\n@@ -131,7 +163,19 @@ impl AtomicBool {\n         unsafe { atomic_store(self.v.get(), val, order); }\n     }\n \n-    /// Store a value, returning the old value\n+    /// Stores a value into the bool, returning the old value.\n+    ///\n+    /// `swap` takes an `Ordering` argument which describes the memory ordering of this operation.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomic::{AtomicBool, Ordering};\n+    ///\n+    /// let some_bool = AtomicBool::new(true);\n+    ///\n+    /// let value = some_bool.swap(false, Ordering::Relaxed);\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn swap(&self, val: bool, order: Ordering) -> bool {\n@@ -140,48 +184,21 @@ impl AtomicBool {\n         unsafe { atomic_swap(self.v.get(), val, order) > 0 }\n     }\n \n-    /// If the current value is the same as expected, store a new value\n+    /// Stores a value into the bool if the current value is the same as the expected value.\n     ///\n-    /// Compare the current value with `old`; if they are the same then\n-    /// replace the current value with `new`. Return the previous value.\n     /// If the return value is equal to `old` then the value was updated.\n     ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// use std::sync::Arc;\n-    /// use std::sync::atomic::{AtomicBool, SeqCst};\n-    /// use std::task::deschedule;\n-    ///\n-    /// fn main() {\n-    ///     let spinlock = Arc::new(AtomicBool::new(false));\n-    ///     let spinlock_clone = spinlock.clone();\n+    /// `swap` also takes an `Ordering` argument which describes the memory ordering of this\n+    /// operation.\n     ///\n-    ///     spawn(proc() {\n-    ///         with_lock(&spinlock, || println!(\"task 1 in lock\"));\n-    ///     });\n-    ///\n-    ///     spawn(proc() {\n-    ///         with_lock(&spinlock_clone, || println!(\"task 2 in lock\"));\n-    ///     });\n-    /// }\n+    /// # Examples\n     ///\n-    /// fn with_lock(spinlock: &Arc<AtomicBool>, f: || -> ()) {\n-    ///     // CAS loop until we are able to replace `false` with `true`\n-    ///     while spinlock.compare_and_swap(false, true, SeqCst) != false {\n-    ///         // Since tasks may not be preemptive (if they are green threads)\n-    ///         // yield to the scheduler to let the other task run. Low level\n-    ///         // concurrent code needs to take into account Rust's two threading\n-    ///         // models.\n-    ///         deschedule();\n-    ///     }\n+    /// ```\n+    /// use std::sync::atomic::{AtomicBool, Ordering};\n     ///\n-    ///     // Now we have the spinlock\n-    ///     f();\n+    /// let some_bool = AtomicBool::new(true);\n     ///\n-    ///     // Release the lock\n-    ///     spinlock.store(false, SeqCst);\n-    /// }\n+    /// let value = some_bool.store(false, Ordering::Relaxed);\n     /// ```\n     #[inline]\n     #[stable]\n@@ -192,10 +209,11 @@ impl AtomicBool {\n         unsafe { atomic_compare_and_swap(self.v.get(), old, new, order) > 0 }\n     }\n \n-    /// A logical \"and\" operation\n+    /// Logical \"and\" with a boolean value.\n+    ///\n+    /// Performs a logical \"and\" operation on the current value and the argument `val`, and sets\n+    /// the new value to the result.\n     ///\n-    /// Performs a logical \"and\" operation on the current value and the\n-    /// argument `val`, and sets the new value to the result.\n     /// Returns the previous value.\n     ///\n     /// # Examples\n@@ -223,10 +241,11 @@ impl AtomicBool {\n         unsafe { atomic_and(self.v.get(), val, order) > 0 }\n     }\n \n-    /// A logical \"nand\" operation\n+    /// Logical \"nand\" with a boolean value.\n+    ///\n+    /// Performs a logical \"nand\" operation on the current value and the argument `val`, and sets\n+    /// the new value to the result.\n     ///\n-    /// Performs a logical \"nand\" operation on the current value and the\n-    /// argument `val`, and sets the new value to the result.\n     /// Returns the previous value.\n     ///\n     /// # Examples\n@@ -255,10 +274,11 @@ impl AtomicBool {\n         unsafe { atomic_nand(self.v.get(), val, order) > 0 }\n     }\n \n-    /// A logical \"or\" operation\n+    /// Logical \"or\" with a boolean value.\n+    ///\n+    /// Performs a logical \"or\" operation on the current value and the argument `val`, and sets the\n+    /// new value to the result.\n     ///\n-    /// Performs a logical \"or\" operation on the current value and the\n-    /// argument `val`, and sets the new value to the result.\n     /// Returns the previous value.\n     ///\n     /// # Examples\n@@ -286,10 +306,11 @@ impl AtomicBool {\n         unsafe { atomic_or(self.v.get(), val, order) > 0 }\n     }\n \n-    /// A logical \"xor\" operation\n+    /// Logical \"xor\" with a boolean value.\n+    ///\n+    /// Performs a logical \"xor\" operation on the current value and the argument `val`, and sets\n+    /// the new value to the result.\n     ///\n-    /// Performs a logical \"xor\" operation on the current value and the\n-    /// argument `val`, and sets the new value to the result.\n     /// Returns the previous value.\n     ///\n     /// # Examples\n@@ -319,25 +340,57 @@ impl AtomicBool {\n }\n \n impl AtomicInt {\n-    /// Create a new `AtomicInt`\n+    /// Creates a new `AtomicInt`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomic::AtomicInt;\n+    ///\n+    /// let atomic_forty_two  = AtomicInt::new(42);\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn new(v: int) -> AtomicInt {\n         AtomicInt {v: UnsafeCell::new(v), nocopy: marker::NoCopy}\n     }\n \n-    /// Load the value\n+    /// Loads a value from the int.\n+    ///\n+    /// `load` takes an `Ordering` argument which describes the memory ordering of this operation.\n     ///\n     /// # Panics\n     ///\n     /// Panics if `order` is `Release` or `AcqRel`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomic::{AtomicInt, Ordering};\n+    ///\n+    /// let some_int = AtomicInt::new(5);\n+    ///\n+    /// let value = some_int.load(Ordering::Relaxed);\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn load(&self, order: Ordering) -> int {\n         unsafe { atomic_load(self.v.get() as *const int, order) }\n     }\n \n-    /// Store the value\n+    /// Stores a value into the int.\n+    ///\n+    /// `store` takes an `Ordering` argument which describes the memory ordering of this operation.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomic::{AtomicInt, Ordering};\n+    ///\n+    /// let some_int = AtomicInt::new(5);\n+    ///\n+    /// some_int.store(10, Ordering::Relaxed);\n+    /// ```\n     ///\n     /// # Panics\n     ///\n@@ -348,25 +401,48 @@ impl AtomicInt {\n         unsafe { atomic_store(self.v.get(), val, order); }\n     }\n \n-    /// Store a value, returning the old value\n+    /// Stores a value into the int, returning the old value.\n+    ///\n+    /// `swap` takes an `Ordering` argument which describes the memory ordering of this operation.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomic::{AtomicInt, Ordering};\n+    ///\n+    /// let some_int = AtomicInt::new(5);\n+    ///\n+    /// let value = some_int.swap(10, Ordering::Relaxed);\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn swap(&self, val: int, order: Ordering) -> int {\n         unsafe { atomic_swap(self.v.get(), val, order) }\n     }\n \n-    /// If the current value is the same as expected, store a new value\n+    /// Stores a value into the int if the current value is the same as the expected value.\n     ///\n-    /// Compare the current value with `old`; if they are the same then\n-    /// replace the current value with `new`. Return the previous value.\n     /// If the return value is equal to `old` then the value was updated.\n+    ///\n+    /// `compare_and_swap` also takes an `Ordering` argument which describes the memory ordering of\n+    /// this operation.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomic::{AtomicInt, Ordering};\n+    ///\n+    /// let some_int = AtomicInt::new(5);\n+    ///\n+    /// let value = some_int.compare_and_swap(5, 10, Ordering::Relaxed);\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn compare_and_swap(&self, old: int, new: int, order: Ordering) -> int {\n         unsafe { atomic_compare_and_swap(self.v.get(), old, new, order) }\n     }\n \n-    /// Add to the current value, returning the previous\n+    /// Add an int to the current value, returning the previous value.\n     ///\n     /// # Examples\n     ///\n@@ -383,7 +459,7 @@ impl AtomicInt {\n         unsafe { atomic_add(self.v.get(), val, order) }\n     }\n \n-    /// Subtract from the current value, returning the previous\n+    /// Subtract an int from the current value, returning the previous value.\n     ///\n     /// # Examples\n     ///\n@@ -400,7 +476,7 @@ impl AtomicInt {\n         unsafe { atomic_sub(self.v.get(), val, order) }\n     }\n \n-    /// Bitwise and with the current value, returning the previous\n+    /// Bitwise and with the current int, returning the previous value.\n     ///\n     /// # Examples\n     ///\n@@ -416,7 +492,7 @@ impl AtomicInt {\n         unsafe { atomic_and(self.v.get(), val, order) }\n     }\n \n-    /// Bitwise or with the current value, returning the previous\n+    /// Bitwise or with the current int, returning the previous value.\n     ///\n     /// # Examples\n     ///\n@@ -432,7 +508,7 @@ impl AtomicInt {\n         unsafe { atomic_or(self.v.get(), val, order) }\n     }\n \n-    /// Bitwise xor with the current value, returning the previous\n+    /// Bitwise xor with the current int, returning the previous value.\n     ///\n     /// # Examples\n     ///\n@@ -450,25 +526,57 @@ impl AtomicInt {\n }\n \n impl AtomicUint {\n-    /// Create a new `AtomicUint`\n+    /// Creates a new `AtomicUint`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomic::AtomicUint;\n+    ///\n+    /// let atomic_forty_two = AtomicUint::new(42u);\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn new(v: uint) -> AtomicUint {\n         AtomicUint { v: UnsafeCell::new(v), nocopy: marker::NoCopy }\n     }\n \n-    /// Load the value\n+    /// Loads a value from the uint.\n+    ///\n+    /// `load` takes an `Ordering` argument which describes the memory ordering of this operation.\n     ///\n     /// # Panics\n     ///\n     /// Panics if `order` is `Release` or `AcqRel`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomic::{AtomicUint, Ordering};\n+    ///\n+    /// let some_uint = AtomicUint::new(5);\n+    ///\n+    /// let value = some_uint.load(Ordering::Relaxed);\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn load(&self, order: Ordering) -> uint {\n         unsafe { atomic_load(self.v.get() as *const uint, order) }\n     }\n \n-    /// Store the value\n+    /// Stores a value into the uint.\n+    ///\n+    /// `store` takes an `Ordering` argument which describes the memory ordering of this operation.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomic::{AtomicUint, Ordering};\n+    ///\n+    /// let some_uint = AtomicUint::new(5);\n+    ///\n+    /// some_uint.store(10, Ordering::Relaxed);\n+    /// ```\n     ///\n     /// # Panics\n     ///\n@@ -479,25 +587,48 @@ impl AtomicUint {\n         unsafe { atomic_store(self.v.get(), val, order); }\n     }\n \n-    /// Store a value, returning the old value\n+    /// Stores a value into the uint, returning the old value.\n+    ///\n+    /// `swap` takes an `Ordering` argument which describes the memory ordering of this operation.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomic::{AtomicUint, Ordering};\n+    ///\n+    /// let some_uint = AtomicUint::new(5);\n+    ///\n+    /// let value = some_uint.swap(10, Ordering::Relaxed);\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn swap(&self, val: uint, order: Ordering) -> uint {\n         unsafe { atomic_swap(self.v.get(), val, order) }\n     }\n \n-    /// If the current value is the same as expected, store a new value\n+    /// Stores a value into the uint if the current value is the same as the expected value.\n     ///\n-    /// Compare the current value with `old`; if they are the same then\n-    /// replace the current value with `new`. Return the previous value.\n     /// If the return value is equal to `old` then the value was updated.\n+    ///\n+    /// `compare_and_swap` also takes an `Ordering` argument which describes the memory ordering of\n+    /// this operation.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomic::{AtomicUint, Ordering};\n+    ///\n+    /// let some_uint = AtomicUint::new(5);\n+    ///\n+    /// let value = some_uint.compare_and_swap(5, 10, Ordering::Relaxed);\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn compare_and_swap(&self, old: uint, new: uint, order: Ordering) -> uint {\n         unsafe { atomic_compare_and_swap(self.v.get(), old, new, order) }\n     }\n \n-    /// Add to the current value, returning the previous\n+    /// Add to the current uint, returning the previous value.\n     ///\n     /// # Examples\n     ///\n@@ -514,7 +645,7 @@ impl AtomicUint {\n         unsafe { atomic_add(self.v.get(), val, order) }\n     }\n \n-    /// Subtract from the current value, returning the previous\n+    /// Subtract from the current uint, returning the previous value.\n     ///\n     /// # Examples\n     ///\n@@ -531,7 +662,7 @@ impl AtomicUint {\n         unsafe { atomic_sub(self.v.get(), val, order) }\n     }\n \n-    /// Bitwise and with the current value, returning the previous\n+    /// Bitwise and with the current uint, returning the previous value.\n     ///\n     /// # Examples\n     ///\n@@ -547,7 +678,7 @@ impl AtomicUint {\n         unsafe { atomic_and(self.v.get(), val, order) }\n     }\n \n-    /// Bitwise or with the current value, returning the previous\n+    /// Bitwise or with the current uint, returning the previous value.\n     ///\n     /// # Examples\n     ///\n@@ -563,7 +694,7 @@ impl AtomicUint {\n         unsafe { atomic_or(self.v.get(), val, order) }\n     }\n \n-    /// Bitwise xor with the current value, returning the previous\n+    /// Bitwise xor with the current uint, returning the previous value.\n     ///\n     /// # Examples\n     ///\n@@ -581,18 +712,40 @@ impl AtomicUint {\n }\n \n impl<T> AtomicPtr<T> {\n-    /// Create a new `AtomicPtr`\n+    /// Creates a new `AtomicPtr`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomic::AtomicPtr;\n+    ///\n+    /// let ptr = &mut 5i;\n+    /// let atomic_ptr  = AtomicPtr::new(ptr);\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn new(p: *mut T) -> AtomicPtr<T> {\n         AtomicPtr { p: UnsafeCell::new(p as uint), nocopy: marker::NoCopy }\n     }\n \n-    /// Load the value\n+    /// Loads a value from the pointer.\n+    ///\n+    /// `load` takes an `Ordering` argument which describes the memory ordering of this operation.\n     ///\n     /// # Panics\n     ///\n     /// Panics if `order` is `Release` or `AcqRel`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomic::{AtomicPtr, Ordering};\n+    ///\n+    /// let ptr = &mut 5i;\n+    /// let some_ptr  = AtomicPtr::new(ptr);\n+    ///\n+    /// let value = some_ptr.load(Ordering::Relaxed);\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn load(&self, order: Ordering) -> *mut T {\n@@ -601,7 +754,22 @@ impl<T> AtomicPtr<T> {\n         }\n     }\n \n-    /// Store the value\n+    /// Stores a value into the pointer.\n+    ///\n+    /// `store` takes an `Ordering` argument which describes the memory ordering of this operation.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomic::{AtomicPtr, Ordering};\n+    ///\n+    /// let ptr = &mut 5i;\n+    /// let some_ptr  = AtomicPtr::new(ptr);\n+    ///\n+    /// let other_ptr = &mut 10i;\n+    ///\n+    /// some_ptr.store(other_ptr, Ordering::Relaxed);\n+    /// ```\n     ///\n     /// # Panics\n     ///\n@@ -612,18 +780,48 @@ impl<T> AtomicPtr<T> {\n         unsafe { atomic_store(self.p.get(), ptr as uint, order); }\n     }\n \n-    /// Store a value, returning the old value\n+    /// Stores a value into the pointer, returning the old value.\n+    ///\n+    /// `swap` takes an `Ordering` argument which describes the memory ordering of this operation.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomic::{AtomicPtr, Ordering};\n+    ///\n+    /// let ptr = &mut 5i;\n+    /// let some_ptr  = AtomicPtr::new(ptr);\n+    ///\n+    /// let other_ptr = &mut 10i;\n+    ///\n+    /// let value = some_ptr.swap(other_ptr, Ordering::Relaxed);\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn swap(&self, ptr: *mut T, order: Ordering) -> *mut T {\n         unsafe { atomic_swap(self.p.get(), ptr as uint, order) as *mut T }\n     }\n \n-    /// If the current value is the same as expected, store a new value\n+    /// Stores a value into the pointer if the current value is the same as the expected value.\n     ///\n-    /// Compare the current value with `old`; if they are the same then\n-    /// replace the current value with `new`. Return the previous value.\n     /// If the return value is equal to `old` then the value was updated.\n+    ///\n+    /// `compare_and_swap` also takes an `Ordering` argument which describes the memory ordering of\n+    /// this operation.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomic::{AtomicPtr, Ordering};\n+    ///\n+    /// let ptr = &mut 5i;\n+    /// let some_ptr  = AtomicPtr::new(ptr);\n+    ///\n+    /// let other_ptr   = &mut 10i;\n+    /// let another_ptr = &mut 10i;\n+    ///\n+    /// let value = some_ptr.compare_and_swap(other_ptr, another_ptr, Ordering::Relaxed);\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn compare_and_swap(&self, old: *mut T, new: *mut T, order: Ordering) -> *mut T {\n@@ -777,7 +975,7 @@ unsafe fn atomic_xor<T>(dst: *mut T, val: T, order: Ordering) -> T {\n ///\n /// # Panics\n ///\n-/// Panics if `order` is `Relaxed`\n+/// Panics if `order` is `Relaxed`.\n #[inline]\n #[stable]\n pub fn fence(order: Ordering) {"}, {"sha": "be8828b3ec833b6018ae09d9a70a20adde0e4877", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 67, "deletions": 82, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -12,8 +12,6 @@\n \n #![allow(unused_variables)]\n \n-pub use self::FormatError::*;\n-\n use any;\n use cell::{Cell, Ref, RefMut};\n use iter::{Iterator, range};\n@@ -23,10 +21,9 @@ use option::{Option, Some, None};\n use ops::Deref;\n use result::{Ok, Err};\n use result;\n-use slice::{AsSlice, SlicePrelude};\n+use slice::SlicePrelude;\n use slice;\n use str::StrPrelude;\n-use str;\n \n pub use self::num::radix;\n pub use self::num::Radix;\n@@ -36,18 +33,16 @@ mod num;\n mod float;\n pub mod rt;\n \n-pub type Result = result::Result<(), FormatError>;\n+#[experimental = \"core and I/O reconciliation may alter this definition\"]\n+pub type Result = result::Result<(), Error>;\n \n /// The error type which is returned from formatting a message into a stream.\n ///\n /// This type does not support transmission of an error other than that an error\n /// occurred. Any extra information must be arranged to be transmitted through\n /// some other means.\n-pub enum FormatError {\n-    /// A generic write error occurred during formatting, no other information\n-    /// is transmitted via this variant.\n-    WriteError,\n-}\n+#[experimental = \"core and I/O reconciliation may alter this definition\"]\n+pub struct Error;\n \n /// A collection of methods that are required to format a message into a stream.\n ///\n@@ -58,6 +53,7 @@ pub enum FormatError {\n /// This trait should generally not be implemented by consumers of the standard\n /// library. The `write!` macro accepts an instance of `io::Writer`, and the\n /// `io::Writer` trait is favored over implementing this trait.\n+#[experimental = \"waiting for core and I/O reconciliation\"]\n pub trait FormatWriter {\n     /// Writes a slice of bytes into this writer, returning whether the write\n     /// succeeded.\n@@ -81,17 +77,13 @@ pub trait FormatWriter {\n /// A struct to represent both where to emit formatting strings to and how they\n /// should be formatted. A mutable version of this is passed to all formatting\n /// traits.\n+#[unstable = \"name may change and implemented traits are also unstable\"]\n pub struct Formatter<'a> {\n-    /// Flags for formatting (packed version of rt::Flag)\n-    pub flags: uint,\n-    /// Character used as 'fill' whenever there is alignment\n-    pub fill: char,\n-    /// Boolean indication of whether the output should be left-aligned\n-    pub align: rt::Alignment,\n-    /// Optionally specified integer width that the output should be\n-    pub width: Option<uint>,\n-    /// Optionally specified precision for numeric types\n-    pub precision: Option<uint>,\n+    flags: uint,\n+    fill: char,\n+    align: rt::Alignment,\n+    width: Option<uint>,\n+    precision: Option<uint>,\n \n     buf: &'a mut FormatWriter+'a,\n     curarg: slice::Items<'a, Argument<'a>>,\n@@ -104,6 +96,7 @@ enum Void {}\n /// family of functions. It contains a function to format the given value. At\n /// compile time it is ensured that the function and the value have the correct\n /// types, and then this struct is used to canonicalize arguments to one type.\n+#[experimental = \"implementation detail of the `format_args!` macro\"]\n pub struct Argument<'a> {\n     formatter: extern \"Rust\" fn(&Void, &mut Formatter) -> Result,\n     value: &'a Void,\n@@ -115,6 +108,7 @@ impl<'a> Arguments<'a> {\n     /// which is valid because the compiler performs all necessary validation to\n     /// ensure that the resulting call to format/write would be safe.\n     #[doc(hidden)] #[inline]\n+    #[experimental = \"implementation detail of the `format_args!` macro\"]\n     pub unsafe fn new<'a>(pieces: &'static [&'static str],\n                           args: &'a [Argument<'a>]) -> Arguments<'a> {\n         Arguments {\n@@ -128,6 +122,7 @@ impl<'a> Arguments<'a> {\n     /// The `pieces` array must be at least as long as `fmt` to construct\n     /// a valid Arguments structure.\n     #[doc(hidden)] #[inline]\n+    #[experimental = \"implementation detail of the `format_args!` macro\"]\n     pub unsafe fn with_placeholders<'a>(pieces: &'static [&'static str],\n                                         fmt: &'static [rt::Argument<'static>],\n                                         args: &'a [Argument<'a>]) -> Arguments<'a> {\n@@ -148,6 +143,7 @@ impl<'a> Arguments<'a> {\n /// and pass it to a function or closure, passed as the first argument. The\n /// macro validates the format string at compile-time so usage of the `write`\n /// and `format` functions can be safely performed.\n+#[stable]\n pub struct Arguments<'a> {\n     // Format string pieces to print.\n     pieces: &'a [&'a str],\n@@ -169,84 +165,57 @@ impl<'a> Show for Arguments<'a> {\n /// When a format is not otherwise specified, types are formatted by ascribing\n /// to this trait. There is not an explicit way of selecting this trait to be\n /// used for formatting, it is only if no other format is specified.\n+#[unstable = \"I/O and core have yet to be reconciled\"]\n pub trait Show for Sized? {\n     /// Formats the value using the given formatter.\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n-/// Format trait for the `b` character\n-pub trait Bool for Sized? {\n-    /// Formats the value using the given formatter.\n-    fn fmt(&self, &mut Formatter) -> Result;\n-}\n-\n-/// Format trait for the `c` character\n-pub trait Char for Sized? {\n-    /// Formats the value using the given formatter.\n-    fn fmt(&self, &mut Formatter) -> Result;\n-}\n-\n-/// Format trait for the `i` and `d` characters\n-pub trait Signed for Sized? {\n-    /// Formats the value using the given formatter.\n-    fn fmt(&self, &mut Formatter) -> Result;\n-}\n-\n-/// Format trait for the `u` character\n-pub trait Unsigned for Sized? {\n-    /// Formats the value using the given formatter.\n-    fn fmt(&self, &mut Formatter) -> Result;\n-}\n \n /// Format trait for the `o` character\n+#[unstable = \"I/O and core have yet to be reconciled\"]\n pub trait Octal for Sized? {\n     /// Formats the value using the given formatter.\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n /// Format trait for the `t` character\n+#[unstable = \"I/O and core have yet to be reconciled\"]\n pub trait Binary for Sized? {\n     /// Formats the value using the given formatter.\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n /// Format trait for the `x` character\n+#[unstable = \"I/O and core have yet to be reconciled\"]\n pub trait LowerHex for Sized? {\n     /// Formats the value using the given formatter.\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n /// Format trait for the `X` character\n+#[unstable = \"I/O and core have yet to be reconciled\"]\n pub trait UpperHex for Sized? {\n     /// Formats the value using the given formatter.\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n-/// Format trait for the `s` character\n-pub trait String for Sized? {\n-    /// Formats the value using the given formatter.\n-    fn fmt(&self, &mut Formatter) -> Result;\n-}\n-\n /// Format trait for the `p` character\n+#[unstable = \"I/O and core have yet to be reconciled\"]\n pub trait Pointer for Sized? {\n     /// Formats the value using the given formatter.\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n-/// Format trait for the `f` character\n-pub trait Float for Sized? {\n-    /// Formats the value using the given formatter.\n-    fn fmt(&self, &mut Formatter) -> Result;\n-}\n-\n /// Format trait for the `e` character\n+#[unstable = \"I/O and core have yet to be reconciled\"]\n pub trait LowerExp for Sized? {\n     /// Formats the value using the given formatter.\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n /// Format trait for the `E` character\n+#[unstable = \"I/O and core have yet to be reconciled\"]\n pub trait UpperExp for Sized? {\n     /// Formats the value using the given formatter.\n     fn fmt(&self, &mut Formatter) -> Result;\n@@ -271,6 +240,8 @@ static DEFAULT_ARGUMENT: rt::Argument<'static> = rt::Argument {\n ///\n ///   * output - the buffer to write output to\n ///   * args - the precompiled arguments generated by `format_args!`\n+#[experimental = \"libcore and I/O have yet to be reconciled, and this is an \\\n+                  implementation detail which should not otherwise be exported\"]\n pub fn write(output: &mut FormatWriter, args: &Arguments) -> Result {\n     let mut formatter = Formatter {\n         flags: 0,\n@@ -368,6 +339,7 @@ impl<'a> Formatter<'a> {\n     ///\n     /// This function will correctly account for the flags provided as well as\n     /// the minimum width. It will not take precision into account.\n+    #[unstable = \"definition may change slightly over time\"]\n     pub fn pad_integral(&mut self,\n                         is_positive: bool,\n                         prefix: &str,\n@@ -440,6 +412,7 @@ impl<'a> Formatter<'a> {\n     ///               is longer than this length\n     ///\n     /// Notably this function ignored the `flag` parameters\n+    #[unstable = \"definition may change slightly over time\"]\n     pub fn pad(&mut self, s: &str) -> Result {\n         // Make sure there's a fast path up front\n         if self.width.is_none() && self.precision.is_none() {\n@@ -516,19 +489,48 @@ impl<'a> Formatter<'a> {\n \n     /// Writes some data to the underlying buffer contained within this\n     /// formatter.\n+    #[unstable = \"reconciling core and I/O may alter this definition\"]\n     pub fn write(&mut self, data: &[u8]) -> Result {\n         self.buf.write(data)\n     }\n \n     /// Writes some formatted information into this instance\n+    #[unstable = \"reconciling core and I/O may alter this definition\"]\n     pub fn write_fmt(&mut self, fmt: &Arguments) -> Result {\n         write(self.buf, fmt)\n     }\n+\n+    /// Flags for formatting (packed version of rt::Flag)\n+    #[experimental = \"return type may change and method was just created\"]\n+    pub fn flags(&self) -> uint { self.flags }\n+\n+    /// Character used as 'fill' whenever there is alignment\n+    #[unstable = \"method was just created\"]\n+    pub fn fill(&self) -> char { self.fill }\n+\n+    /// Flag indicating what form of alignment was requested\n+    #[unstable = \"method was just created\"]\n+    pub fn align(&self) -> rt::Alignment { self.align }\n+\n+    /// Optionally specified integer width that the output should be\n+    #[unstable = \"method was just created\"]\n+    pub fn width(&self) -> Option<uint> { self.width }\n+\n+    /// Optionally specified precision for numeric types\n+    #[unstable = \"method was just created\"]\n+    pub fn precision(&self) -> Option<uint> { self.precision }\n+}\n+\n+impl Show for Error {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        \"an error occurred when formatting an argument\".fmt(f)\n+    }\n }\n \n /// This is a function which calls are emitted to by the compiler itself to\n /// create the Argument structures that are passed into the `format` function.\n #[doc(hidden)] #[inline]\n+#[experimental = \"implementation detail of the `format_args!` macro\"]\n pub fn argument<'a, T>(f: extern \"Rust\" fn(&T, &mut Formatter) -> Result,\n                        t: &'a T) -> Argument<'a> {\n     unsafe {\n@@ -542,15 +544,17 @@ pub fn argument<'a, T>(f: extern \"Rust\" fn(&T, &mut Formatter) -> Result,\n /// When the compiler determines that the type of an argument *must* be a string\n /// (such as for select), then it invokes this method.\n #[doc(hidden)] #[inline]\n+#[experimental = \"implementation detail of the `format_args!` macro\"]\n pub fn argumentstr<'a>(s: &'a &str) -> Argument<'a> {\n-    argument(String::fmt, s)\n+    argument(Show::fmt, s)\n }\n \n /// When the compiler determines that the type of an argument *must* be a uint\n /// (such as for plural), then it invokes this method.\n #[doc(hidden)] #[inline]\n+#[experimental = \"implementation detail of the `format_args!` macro\"]\n pub fn argumentuint<'a>(s: &'a uint) -> Argument<'a> {\n-    argument(Unsigned::fmt, s)\n+    argument(Show::fmt, s)\n }\n \n // Implementations of the core formatting traits\n@@ -565,32 +569,26 @@ impl<'a> Show for &'a Show+'a {\n     fn fmt(&self, f: &mut Formatter) -> Result { (*self).fmt(f) }\n }\n \n-impl Bool for bool {\n-    fn fmt(&self, f: &mut Formatter) -> Result {\n-        String::fmt(if *self { \"true\" } else { \"false\" }, f)\n-    }\n-}\n-\n-impl<T: str::Str> String for T {\n+impl Show for bool {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n-        f.pad(self.as_slice())\n+        Show::fmt(if *self { \"true\" } else { \"false\" }, f)\n     }\n }\n \n-impl String for str {\n+impl Show for str {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         f.pad(self)\n     }\n }\n \n-impl Char for char {\n+impl Show for char {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         use char::Char;\n \n         let mut utf8 = [0u8, ..4];\n         let amt = self.encode_utf8(&mut utf8).unwrap_or(0);\n         let s: &str = unsafe { mem::transmute(utf8[..amt]) };\n-        String::fmt(s, f)\n+        Show::fmt(s, f)\n     }\n }\n \n@@ -620,7 +618,7 @@ impl<'a, T> Pointer for &'a mut T {\n }\n \n macro_rules! floating(($ty:ident) => {\n-    impl Float for $ty {\n+    impl Show for $ty {\n         fn fmt(&self, fmt: &mut Formatter) -> Result {\n             use num::Float;\n \n@@ -688,19 +686,6 @@ floating!(f64)\n \n // Implementation of Show for various core types\n \n-macro_rules! delegate(($ty:ty to $other:ident) => {\n-    impl Show for $ty {\n-        fn fmt(&self, f: &mut Formatter) -> Result {\n-            $other::fmt(self, f)\n-        }\n-    }\n-})\n-delegate!(str to String)\n-delegate!(bool to Bool)\n-delegate!(char to Char)\n-delegate!(f32 to Float)\n-delegate!(f64 to Float)\n-\n impl<T> Show for *const T {\n     fn fmt(&self, f: &mut Formatter) -> Result { Pointer::fmt(self, f) }\n }"}, {"sha": "1c856a6e20870cc18a280a830c83b93a51e90aaa", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -109,6 +109,7 @@ radix!(UpperHex, 16, \"0x\", x @  0 ...  9 => b'0' + x,\n \n /// A radix with in the range of `2..36`.\n #[deriving(Clone, PartialEq)]\n+#[unstable = \"may be renamed or move to a different module\"]\n pub struct Radix {\n     base: u8,\n }\n@@ -132,6 +133,7 @@ impl GenericRadix for Radix {\n }\n \n /// A helper type for formatting radixes.\n+#[unstable = \"may be renamed or move to a different module\"]\n pub struct RadixFmt<T, R>(T, R);\n \n /// Constructs a radix formatter in the range of `2..36`.\n@@ -142,6 +144,7 @@ pub struct RadixFmt<T, R>(T, R);\n /// use std::fmt::radix;\n /// assert_eq!(format!(\"{}\", radix(55i, 36)), \"1j\".to_string());\n /// ```\n+#[unstable = \"may be renamed or move to a different module\"]\n pub fn radix<T>(x: T, base: u8) -> RadixFmt<T, Radix> {\n     RadixFmt(x, Radix::new(base))\n }\n@@ -167,15 +170,13 @@ macro_rules! int_base {\n macro_rules! integer {\n     ($Int:ident, $Uint:ident) => {\n         int_base!(Show     for $Int as $Int   -> Decimal)\n-        int_base!(Signed   for $Int as $Int   -> Decimal)\n         int_base!(Binary   for $Int as $Uint  -> Binary)\n         int_base!(Octal    for $Int as $Uint  -> Octal)\n         int_base!(LowerHex for $Int as $Uint  -> LowerHex)\n         int_base!(UpperHex for $Int as $Uint  -> UpperHex)\n         radix_fmt!($Int as $Int, fmt_int)\n \n         int_base!(Show     for $Uint as $Uint -> Decimal)\n-        int_base!(Unsigned for $Uint as $Uint -> Decimal)\n         int_base!(Binary   for $Uint as $Uint -> Binary)\n         int_base!(Octal    for $Uint as $Uint -> Octal)\n         int_base!(LowerHex for $Uint as $Uint -> LowerHex)"}, {"sha": "145e78dc668eeebc1f446a81e6d07d0512582d36", "filename": "src/libcore/fmt/rt.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibcore%2Ffmt%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibcore%2Ffmt%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Frt.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -14,6 +14,8 @@\n //! These definitions are similar to their `ct` equivalents, but differ in that\n //! these can be statically allocated and are slightly optimized for the runtime\n \n+#![experimental = \"implementation detail of the `format_args!` macro\"]\n+\n pub use self::Alignment::*;\n pub use self::Count::*;\n pub use self::Position::*;"}, {"sha": "9016f40b1b8345a8cca9656e1cef3c812ca6c548", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -108,7 +108,10 @@ macro_rules! try(\n /// Writing a formatted string into a writer\n #[macro_export]\n macro_rules! write(\n-    ($dst:expr, $($arg:tt)*) => (format_args_method!($dst, write_fmt, $($arg)*))\n+    ($dst:expr, $($arg:tt)*) => ({\n+        let dst = &mut *$dst;\n+        format_args!(|args| { dst.write_fmt(args) }, $($arg)*)\n+    })\n )\n \n /// Writing a formatted string plus a newline into a writer\n@@ -119,15 +122,5 @@ macro_rules! writeln(\n     )\n )\n \n-/// Write some formatted data into a stream.\n-///\n-/// Identical to the macro in `std::macros`\n-#[macro_export]\n-macro_rules! write(\n-    ($dst:expr, $($arg:tt)*) => ({\n-        format_args_method!($dst, write_fmt, $($arg)*)\n-    })\n-)\n-\n #[macro_export]\n macro_rules! unreachable( () => (panic!(\"unreachable code\")) )"}, {"sha": "16798c039bac603cd49cfbf269c447844c5a195c", "filename": "src/libcore/result.rs", "status": "modified", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -227,52 +227,6 @@\n //! ```\n //!\n //! `try!` is imported by the prelude, and is available everywhere.\n-//!\n-//! # `Result` and `Option`\n-//!\n-//! The `Result` and [`Option`](../option/index.html) types are\n-//! similar and complementary: they are often employed to indicate a\n-//! lack of a return value; and they are trivially converted between\n-//! each other, so `Result`s are often handled by first converting to\n-//! `Option` with the [`ok`](type.Result.html#method.ok) and\n-//! [`err`](type.Result.html#method.ok) methods.\n-//!\n-//! Whereas `Option` only indicates the lack of a value, `Result` is\n-//! specifically for error reporting, and carries with it an error\n-//! value.  Sometimes `Option` is used for indicating errors, but this\n-//! is only for simple cases and is generally discouraged. Even when\n-//! there is no useful error value to return, prefer `Result<T, ()>`.\n-//!\n-//! Converting to an `Option` with `ok()` to handle an error:\n-//!\n-//! ```\n-//! use std::io::Timer;\n-//! let mut t = Timer::new().ok().expect(\"failed to create timer!\");\n-//! ```\n-//!\n-//! # `Result` vs. `panic!`\n-//!\n-//! `Result` is for recoverable errors; `panic!` is for unrecoverable\n-//! errors. Callers should always be able to avoid panics if they\n-//! take the proper precautions, for example, calling `is_some()`\n-//! on an `Option` type before calling `unwrap`.\n-//!\n-//! The suitability of `panic!` as an error handling mechanism is\n-//! limited by Rust's lack of any way to \"catch\" and resume execution\n-//! from a thrown exception. Therefore using panics for error\n-//! handling requires encapsulating code that may panic in a task.\n-//! Calling the `panic!` macro, or invoking `panic!` indirectly should be\n-//! avoided as an error reporting strategy. Panics is only for\n-//! unrecoverable errors and a panicking task is typically the sign of\n-//! a bug.\n-//!\n-//! A module that instead returns `Results` is alerting the caller\n-//! that failure is possible, and providing precise control over how\n-//! it is handled.\n-//!\n-//! Furthermore, panics may not be recoverable at all, depending on\n-//! the context. The caller of `panic!` should assume that execution\n-//! will not resume after the panic, that a panic is catastrophic.\n \n #![stable]\n "}, {"sha": "3b43d6ad33b4429c4b6b210938a2da05891eb020", "filename": "src/libcoretest/fmt/num.rs", "status": "modified", "additions": 37, "deletions": 44, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibcoretest%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibcoretest%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Ffmt%2Fnum.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -21,16 +21,16 @@ fn test_format_int() {\n     assert!(format!(\"{}\", 1i16).as_slice() == \"1\");\n     assert!(format!(\"{}\", 1i32).as_slice() == \"1\");\n     assert!(format!(\"{}\", 1i64).as_slice() == \"1\");\n-    assert!(format!(\"{:d}\", -1i).as_slice() == \"-1\");\n-    assert!(format!(\"{:d}\", -1i8).as_slice() == \"-1\");\n-    assert!(format!(\"{:d}\", -1i16).as_slice() == \"-1\");\n-    assert!(format!(\"{:d}\", -1i32).as_slice() == \"-1\");\n-    assert!(format!(\"{:d}\", -1i64).as_slice() == \"-1\");\n-    assert!(format!(\"{:t}\", 1i).as_slice() == \"1\");\n-    assert!(format!(\"{:t}\", 1i8).as_slice() == \"1\");\n-    assert!(format!(\"{:t}\", 1i16).as_slice() == \"1\");\n-    assert!(format!(\"{:t}\", 1i32).as_slice() == \"1\");\n-    assert!(format!(\"{:t}\", 1i64).as_slice() == \"1\");\n+    assert!(format!(\"{}\", -1i).as_slice() == \"-1\");\n+    assert!(format!(\"{}\", -1i8).as_slice() == \"-1\");\n+    assert!(format!(\"{}\", -1i16).as_slice() == \"-1\");\n+    assert!(format!(\"{}\", -1i32).as_slice() == \"-1\");\n+    assert!(format!(\"{}\", -1i64).as_slice() == \"-1\");\n+    assert!(format!(\"{:b}\", 1i).as_slice() == \"1\");\n+    assert!(format!(\"{:b}\", 1i8).as_slice() == \"1\");\n+    assert!(format!(\"{:b}\", 1i16).as_slice() == \"1\");\n+    assert!(format!(\"{:b}\", 1i32).as_slice() == \"1\");\n+    assert!(format!(\"{:b}\", 1i64).as_slice() == \"1\");\n     assert!(format!(\"{:x}\", 1i).as_slice() == \"1\");\n     assert!(format!(\"{:x}\", 1i8).as_slice() == \"1\");\n     assert!(format!(\"{:x}\", 1i16).as_slice() == \"1\");\n@@ -52,16 +52,11 @@ fn test_format_int() {\n     assert!(format!(\"{}\", 1u16).as_slice() == \"1\");\n     assert!(format!(\"{}\", 1u32).as_slice() == \"1\");\n     assert!(format!(\"{}\", 1u64).as_slice() == \"1\");\n-    assert!(format!(\"{:u}\", 1u).as_slice() == \"1\");\n-    assert!(format!(\"{:u}\", 1u8).as_slice() == \"1\");\n-    assert!(format!(\"{:u}\", 1u16).as_slice() == \"1\");\n-    assert!(format!(\"{:u}\", 1u32).as_slice() == \"1\");\n-    assert!(format!(\"{:u}\", 1u64).as_slice() == \"1\");\n-    assert!(format!(\"{:t}\", 1u).as_slice() == \"1\");\n-    assert!(format!(\"{:t}\", 1u8).as_slice() == \"1\");\n-    assert!(format!(\"{:t}\", 1u16).as_slice() == \"1\");\n-    assert!(format!(\"{:t}\", 1u32).as_slice() == \"1\");\n-    assert!(format!(\"{:t}\", 1u64).as_slice() == \"1\");\n+    assert!(format!(\"{:b}\", 1u).as_slice() == \"1\");\n+    assert!(format!(\"{:b}\", 1u8).as_slice() == \"1\");\n+    assert!(format!(\"{:b}\", 1u16).as_slice() == \"1\");\n+    assert!(format!(\"{:b}\", 1u32).as_slice() == \"1\");\n+    assert!(format!(\"{:b}\", 1u64).as_slice() == \"1\");\n     assert!(format!(\"{:x}\", 1u).as_slice() == \"1\");\n     assert!(format!(\"{:x}\", 1u8).as_slice() == \"1\");\n     assert!(format!(\"{:x}\", 1u16).as_slice() == \"1\");\n@@ -79,37 +74,35 @@ fn test_format_int() {\n     assert!(format!(\"{:o}\", 1u64).as_slice() == \"1\");\n \n     // Test a larger number\n-    assert!(format!(\"{:t}\", 55i).as_slice() == \"110111\");\n+    assert!(format!(\"{:b}\", 55i).as_slice() == \"110111\");\n     assert!(format!(\"{:o}\", 55i).as_slice() == \"67\");\n-    assert!(format!(\"{:d}\", 55i).as_slice() == \"55\");\n+    assert!(format!(\"{}\", 55i).as_slice() == \"55\");\n     assert!(format!(\"{:x}\", 55i).as_slice() == \"37\");\n     assert!(format!(\"{:X}\", 55i).as_slice() == \"37\");\n }\n \n #[test]\n fn test_format_int_zero() {\n     assert!(format!(\"{}\", 0i).as_slice() == \"0\");\n-    assert!(format!(\"{:d}\", 0i).as_slice() == \"0\");\n-    assert!(format!(\"{:t}\", 0i).as_slice() == \"0\");\n+    assert!(format!(\"{:b}\", 0i).as_slice() == \"0\");\n     assert!(format!(\"{:o}\", 0i).as_slice() == \"0\");\n     assert!(format!(\"{:x}\", 0i).as_slice() == \"0\");\n     assert!(format!(\"{:X}\", 0i).as_slice() == \"0\");\n \n     assert!(format!(\"{}\", 0u).as_slice() == \"0\");\n-    assert!(format!(\"{:u}\", 0u).as_slice() == \"0\");\n-    assert!(format!(\"{:t}\", 0u).as_slice() == \"0\");\n+    assert!(format!(\"{:b}\", 0u).as_slice() == \"0\");\n     assert!(format!(\"{:o}\", 0u).as_slice() == \"0\");\n     assert!(format!(\"{:x}\", 0u).as_slice() == \"0\");\n     assert!(format!(\"{:X}\", 0u).as_slice() == \"0\");\n }\n \n #[test]\n fn test_format_int_flags() {\n-    assert!(format!(\"{:3d}\", 1i).as_slice() == \"  1\");\n-    assert!(format!(\"{:>3d}\", 1i).as_slice() == \"  1\");\n-    assert!(format!(\"{:>+3d}\", 1i).as_slice() == \" +1\");\n-    assert!(format!(\"{:<3d}\", 1i).as_slice() == \"1  \");\n-    assert!(format!(\"{:#d}\", 1i).as_slice() == \"1\");\n+    assert!(format!(\"{:3}\", 1i).as_slice() == \"  1\");\n+    assert!(format!(\"{:>3}\", 1i).as_slice() == \"  1\");\n+    assert!(format!(\"{:>+3}\", 1i).as_slice() == \" +1\");\n+    assert!(format!(\"{:<3}\", 1i).as_slice() == \"1  \");\n+    assert!(format!(\"{:#}\", 1i).as_slice() == \"1\");\n     assert!(format!(\"{:#x}\", 10i).as_slice() == \"0xa\");\n     assert!(format!(\"{:#X}\", 10i).as_slice() == \"0xA\");\n     assert!(format!(\"{:#5x}\", 10i).as_slice() == \"  0xa\");\n@@ -119,25 +112,25 @@ fn test_format_int_flags() {\n     assert!(format!(\"{:<8x}\", 10i).as_slice() == \"a       \");\n     assert!(format!(\"{:>8x}\", 10i).as_slice() == \"       a\");\n     assert!(format!(\"{:#08x}\", 10i).as_slice() == \"0x00000a\");\n-    assert!(format!(\"{:08d}\", -10i).as_slice() == \"-0000010\");\n+    assert!(format!(\"{:08}\", -10i).as_slice() == \"-0000010\");\n     assert!(format!(\"{:x}\", -1u8).as_slice() == \"ff\");\n     assert!(format!(\"{:X}\", -1u8).as_slice() == \"FF\");\n-    assert!(format!(\"{:t}\", -1u8).as_slice() == \"11111111\");\n+    assert!(format!(\"{:b}\", -1u8).as_slice() == \"11111111\");\n     assert!(format!(\"{:o}\", -1u8).as_slice() == \"377\");\n     assert!(format!(\"{:#x}\", -1u8).as_slice() == \"0xff\");\n     assert!(format!(\"{:#X}\", -1u8).as_slice() == \"0xFF\");\n-    assert!(format!(\"{:#t}\", -1u8).as_slice() == \"0b11111111\");\n+    assert!(format!(\"{:#b}\", -1u8).as_slice() == \"0b11111111\");\n     assert!(format!(\"{:#o}\", -1u8).as_slice() == \"0o377\");\n }\n \n #[test]\n fn test_format_int_sign_padding() {\n-    assert!(format!(\"{:+5d}\", 1i).as_slice() == \"   +1\");\n-    assert!(format!(\"{:+5d}\", -1i).as_slice() == \"   -1\");\n-    assert!(format!(\"{:05d}\", 1i).as_slice() == \"00001\");\n-    assert!(format!(\"{:05d}\", -1i).as_slice() == \"-0001\");\n-    assert!(format!(\"{:+05d}\", 1i).as_slice() == \"+0001\");\n-    assert!(format!(\"{:+05d}\", -1i).as_slice() == \"-0001\");\n+    assert!(format!(\"{:+5}\", 1i).as_slice() == \"   +1\");\n+    assert!(format!(\"{:+5}\", -1i).as_slice() == \"   -1\");\n+    assert!(format!(\"{:05}\", 1i).as_slice() == \"00001\");\n+    assert!(format!(\"{:05}\", -1i).as_slice() == \"-0001\");\n+    assert!(format!(\"{:+05}\", 1i).as_slice() == \"+0001\");\n+    assert!(format!(\"{:+05}\", -1i).as_slice() == \"-0001\");\n }\n \n #[test]\n@@ -169,7 +162,7 @@ mod uint {\n     #[bench]\n     fn format_bin(b: &mut Bencher) {\n         let mut rng = weak_rng();\n-        b.iter(|| { format!(\"{:t}\", rng.gen::<uint>()); })\n+        b.iter(|| { format!(\"{:b}\", rng.gen::<uint>()); })\n     }\n \n     #[bench]\n@@ -181,7 +174,7 @@ mod uint {\n     #[bench]\n     fn format_dec(b: &mut Bencher) {\n         let mut rng = weak_rng();\n-        b.iter(|| { format!(\"{:u}\", rng.gen::<uint>()); })\n+        b.iter(|| { format!(\"{}\", rng.gen::<uint>()); })\n     }\n \n     #[bench]\n@@ -205,7 +198,7 @@ mod int {\n     #[bench]\n     fn format_bin(b: &mut Bencher) {\n         let mut rng = weak_rng();\n-        b.iter(|| { format!(\"{:t}\", rng.gen::<int>()); })\n+        b.iter(|| { format!(\"{:b}\", rng.gen::<int>()); })\n     }\n \n     #[bench]\n@@ -217,7 +210,7 @@ mod int {\n     #[bench]\n     fn format_dec(b: &mut Bencher) {\n         let mut rng = weak_rng();\n-        b.iter(|| { format!(\"{:d}\", rng.gen::<int>()); })\n+        b.iter(|| { format!(\"{}\", rng.gen::<int>()); })\n     }\n \n     #[bench]"}, {"sha": "568210118a8ae0f0aa071ed84d3b4463a31e9312", "filename": "src/libflate/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibflate%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibflate%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibflate%2Flib.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -130,7 +130,7 @@ mod tests {\n                    input.len());\n             let cmp = deflate_bytes(input.as_slice()).expect(\"deflation failed\");\n             let out = inflate_bytes(cmp.as_slice()).expect(\"inflation failed\");\n-            debug!(\"{} bytes deflated to {} ({:.1f}% size)\",\n+            debug!(\"{} bytes deflated to {} ({:.1}% size)\",\n                    input.len(), cmp.len(),\n                    100.0 * ((cmp.len() as f64) / (input.len() as f64)));\n             assert_eq!(input.as_slice(), out.as_slice());"}, {"sha": "df8cdabbcaa43251641877346dcdba4735d79860", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -221,7 +221,7 @@ pub fn render_to<W:Writer>(output: &mut W) {\n impl<'a> dot::Labeller<'a, Nd<'a>, Ed<'a>> for Graph {\n     fn graph_id(&'a self) -> dot::Id<'a> { dot::Id::new(\"example3\").unwrap() }\n     fn node_id(&'a self, n: &Nd<'a>) -> dot::Id<'a> {\n-        dot::Id::new(format!(\"N{:u}\", n.val0())).unwrap()\n+        dot::Id::new(format!(\"N{}\", n.val0())).unwrap()\n     }\n     fn node_label<'a>(&'a self, n: &Nd<'a>) -> dot::LabelText<'a> {\n         let &(i, _) = n;\n@@ -635,7 +635,7 @@ mod tests {\n     }\n \n     fn id_name<'a>(n: &Node) -> Id<'a> {\n-        Id::new(format!(\"N{:u}\", *n)).unwrap()\n+        Id::new(format!(\"N{}\", *n)).unwrap()\n     }\n \n     impl<'a> Labeller<'a, Node, &'a Edge> for LabelledGraph {"}, {"sha": "fd2d97d4deb5c1d8e6186e2681fb2be6d62f60c3", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -241,13 +241,6 @@ impl fmt::Show for LogLevel {\n     }\n }\n \n-impl fmt::Signed for LogLevel {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        let LogLevel(level) = *self;\n-        write!(fmt, \"{}\", level)\n-    }\n-}\n-\n impl Logger for DefaultLogger {\n     fn log(&mut self, record: &LogRecord) {\n         match writeln!(&mut self.handle,"}, {"sha": "d6a68dd07d76cfa08a90120bf925f8e8170d0267", "filename": "src/librand/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -237,7 +237,7 @@ pub trait Rng {\n     /// use std::rand::{task_rng, Rng};\n     ///\n     /// let mut rng = task_rng();\n-    /// println!(\"{:b}\", rng.gen_weighted_bool(3));\n+    /// println!(\"{}\", rng.gen_weighted_bool(3));\n     /// ```\n     fn gen_weighted_bool(&mut self, n: uint) -> bool {\n         n == 0 || self.gen_range(0, n) == 0"}, {"sha": "c763ac889c25d0c1cb2e9d0a021df0713329801e", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -994,7 +994,7 @@ impl LintPass for NonSnakeCase {\n         self.check_snake_case(cx, \"trait method\", t.ident, t.span);\n     }\n \n-    fn check_lifetime_decl(&mut self, cx: &Context, t: &ast::LifetimeDef) {\n+    fn check_lifetime_def(&mut self, cx: &Context, t: &ast::LifetimeDef) {\n         self.check_snake_case(cx, \"lifetime\", t.lifetime.name.ident(), t.lifetime.span);\n     }\n "}, {"sha": "1af65d184ed31b0e79db30fac5b037857914f943", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -725,8 +725,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n         run_lints!(self, check_lifetime_ref, lt);\n     }\n \n-    fn visit_lifetime_decl(&mut self, lt: &ast::LifetimeDef) {\n-        run_lints!(self, check_lifetime_decl, lt);\n+    fn visit_lifetime_def(&mut self, lt: &ast::LifetimeDef) {\n+        run_lints!(self, check_lifetime_def, lt);\n     }\n \n     fn visit_explicit_self(&mut self, es: &ast::ExplicitSelf) {"}, {"sha": "d6b83752cc50cc7c0f624f13f4e0045f5587c714", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -155,7 +155,7 @@ pub trait LintPass {\n     fn check_variant_post(&mut self, _: &Context, _: &ast::Variant, _: &ast::Generics) { }\n     fn check_opt_lifetime_ref(&mut self, _: &Context, _: Span, _: &Option<ast::Lifetime>) { }\n     fn check_lifetime_ref(&mut self, _: &Context, _: &ast::Lifetime) { }\n-    fn check_lifetime_decl(&mut self, _: &Context, _: &ast::LifetimeDef) { }\n+    fn check_lifetime_def(&mut self, _: &Context, _: &ast::LifetimeDef) { }\n     fn check_explicit_self(&mut self, _: &Context, _: &ast::ExplicitSelf) { }\n     fn check_mac(&mut self, _: &Context, _: &ast::Mac) { }\n     fn check_path(&mut self, _: &Context, _: &ast::Path, _: ast::NodeId) { }"}, {"sha": "1ab9baa1ac401fabf2d60766f240bc78e4df033c", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -102,7 +102,7 @@ pub fn check_crate(tcx: &ty::ctxt) {\n     fn make_stat(bccx: &BorrowckCtxt, stat: uint) -> String {\n         let total = bccx.stats.guaranteed_paths as f64;\n         let perc = if total == 0.0 { 0.0 } else { stat as f64 * 100.0 / total };\n-        format!(\"{} ({:.0f}%)\", stat, perc)\n+        format!(\"{} ({:.0}%)\", stat, perc)\n     }\n }\n "}, {"sha": "ba6dd2a5107a6c31f119d8c58a1691e7e86461b6", "filename": "src/librustc/middle/cfg/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -53,7 +53,7 @@ impl<'a, 'ast> dot::Labeller<'a, Node<'a>, Edge<'a>> for LabelledCFG<'a, 'ast> {\n     fn graph_id(&'a self) -> dot::Id<'a> { dot::Id::new(self.name.as_slice()).unwrap() }\n \n     fn node_id(&'a self, &(i,_): &Node<'a>) -> dot::Id<'a> {\n-        dot::Id::new(format!(\"N{:u}\", i.node_id())).unwrap()\n+        dot::Id::new(format!(\"N{}\", i.node_id())).unwrap()\n     }\n \n     fn node_label(&'a self, &(i, n): &Node<'a>) -> dot::LabelText<'a> {"}, {"sha": "099ac34d2f29f41dbe75cc6776af37d4df3f0038", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -81,8 +81,7 @@ impl<'a> fmt::Show for Matrix<'a> {\n             try!(write!(f, \"+\"));\n             for (column, pat_str) in row.into_iter().enumerate() {\n                 try!(write!(f, \" \"));\n-                f.width = Some(column_widths[column]);\n-                try!(f.pad(pat_str.as_slice()));\n+                try!(write!(f, \"{:1$}\", pat_str, column_widths[column]));\n                 try!(write!(f, \" +\"));\n             }\n             try!(write!(f, \"\\n\"));"}, {"sha": "141504cb6f7d50e530cd288a6986ef9001e0a258", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -194,7 +194,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n         let words_per_id = (bits_per_id + uint::BITS - 1) / uint::BITS;\n         let num_nodes = cfg.graph.all_nodes().len();\n \n-        debug!(\"DataFlowContext::new(analysis_name: {:s}, id_range={}, \\\n+        debug!(\"DataFlowContext::new(analysis_name: {}, id_range={}, \\\n                                      bits_per_id={}, words_per_id={}) \\\n                                      num_nodes: {}\",\n                analysis_name, id_range, bits_per_id, words_per_id,\n@@ -223,7 +223,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n \n     pub fn add_gen(&mut self, id: ast::NodeId, bit: uint) {\n         //! Indicates that `id` generates `bit`\n-        debug!(\"{:s} add_gen(id={}, bit={})\",\n+        debug!(\"{} add_gen(id={}, bit={})\",\n                self.analysis_name, id, bit);\n         assert!(self.nodeid_to_index.contains_key(&id));\n         assert!(self.bits_per_id > 0);\n@@ -236,7 +236,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n \n     pub fn add_kill(&mut self, id: ast::NodeId, bit: uint) {\n         //! Indicates that `id` kills `bit`\n-        debug!(\"{:s} add_kill(id={}, bit={})\",\n+        debug!(\"{} add_kill(id={}, bit={})\",\n                self.analysis_name, id, bit);\n         assert!(self.nodeid_to_index.contains_key(&id));\n         assert!(self.bits_per_id > 0);\n@@ -249,7 +249,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n \n     fn apply_gen_kill(&self, cfgidx: CFGIndex, bits: &mut [uint]) {\n         //! Applies the gen and kill sets for `cfgidx` to `bits`\n-        debug!(\"{:s} apply_gen_kill(cfgidx={}, bits={}) [before]\",\n+        debug!(\"{} apply_gen_kill(cfgidx={}, bits={}) [before]\",\n                self.analysis_name, cfgidx, mut_bits_to_string(bits));\n         assert!(self.bits_per_id > 0);\n \n@@ -259,7 +259,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n         let kills = self.kills.slice(start, end);\n         bitwise(bits, kills, &Subtract);\n \n-        debug!(\"{:s} apply_gen_kill(cfgidx={}, bits={}) [after]\",\n+        debug!(\"{} apply_gen_kill(cfgidx={}, bits={}) [after]\",\n                self.analysis_name, cfgidx, mut_bits_to_string(bits));\n     }\n \n@@ -316,7 +316,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n                 temp_bits.as_slice()\n             }\n         };\n-        debug!(\"{:s} each_bit_for_node({}, cfgidx={}) bits={}\",\n+        debug!(\"{} each_bit_for_node({}, cfgidx={}) bits={}\",\n                self.analysis_name, e, cfgidx, bits_to_string(slice));\n         self.each_bit(slice, f)\n     }\n@@ -337,7 +337,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n         let cfgidx = to_cfgidx_or_die(id, &self.nodeid_to_index);\n         let (start, end) = self.compute_id_range(cfgidx);\n         let gens = self.gens.slice(start, end);\n-        debug!(\"{:s} each_gen_bit(id={}, gens={})\",\n+        debug!(\"{} each_gen_bit(id={}, gens={})\",\n                self.analysis_name, id, bits_to_string(gens));\n         self.each_bit(gens, f)\n     }\n@@ -385,7 +385,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n         //! This is usually called (if it is called at all), after\n         //! all add_gen and add_kill calls, but before propagate.\n \n-        debug!(\"{:s} add_kills_from_flow_exits\", self.analysis_name);\n+        debug!(\"{} add_kills_from_flow_exits\", self.analysis_name);\n         if self.bits_per_id == 0 {\n             // Skip the surprisingly common degenerate case.  (Note\n             // compute_id_range requires self.words_per_id > 0.)\n@@ -408,7 +408,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n                         }\n                     }\n                     None => {\n-                        debug!(\"{:s} add_kills_from_flow_exits flow_exit={} \\\n+                        debug!(\"{} add_kills_from_flow_exits flow_exit={} \\\n                                 no cfg_idx for exiting_scope={}\",\n                                self.analysis_name, flow_exit, node_id);\n                     }\n@@ -417,10 +417,10 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n \n             if changed {\n                 let bits = self.kills.slice_mut(start, end);\n-                debug!(\"{:s} add_kills_from_flow_exits flow_exit={} bits={} [before]\",\n+                debug!(\"{} add_kills_from_flow_exits flow_exit={} bits={} [before]\",\n                        self.analysis_name, flow_exit, mut_bits_to_string(bits));\n                 bits.clone_from_slice(orig_kills.as_slice());\n-                debug!(\"{:s} add_kills_from_flow_exits flow_exit={} bits={} [after]\",\n+                debug!(\"{} add_kills_from_flow_exits flow_exit={} bits={} [after]\",\n                        self.analysis_name, flow_exit, mut_bits_to_string(bits));\n             }\n             true\n@@ -453,7 +453,7 @@ impl<'a, 'tcx, O:DataFlowOperator+Clone+'static> DataFlowContext<'a, 'tcx, O> {\n             }\n         }\n \n-        debug!(\"Dataflow result for {:s}:\", self.analysis_name);\n+        debug!(\"Dataflow result for {}:\", self.analysis_name);\n         debug!(\"{}\", {\n             self.pretty_print_to(box io::stderr(), blk).unwrap();\n             \"\"\n@@ -474,7 +474,7 @@ impl<'a, 'b, 'tcx, O:DataFlowOperator> PropagationContext<'a, 'b, 'tcx, O> {\n     fn walk_cfg(&mut self,\n                 cfg: &cfg::CFG,\n                 in_out: &mut [uint]) {\n-        debug!(\"DataFlowContext::walk_cfg(in_out={}) {:s}\",\n+        debug!(\"DataFlowContext::walk_cfg(in_out={}) {}\",\n                bits_to_string(in_out), self.dfcx.analysis_name);\n         assert!(self.dfcx.bits_per_id > 0);\n \n@@ -519,7 +519,7 @@ impl<'a, 'b, 'tcx, O:DataFlowOperator> PropagationContext<'a, 'b, 'tcx, O> {\n                                          edge: &cfg::CFGEdge) {\n         let source = edge.source();\n         let cfgidx = edge.target();\n-        debug!(\"{:s} propagate_bits_into_entry_set_for(pred_bits={}, {} to {})\",\n+        debug!(\"{} propagate_bits_into_entry_set_for(pred_bits={}, {} to {})\",\n                self.dfcx.analysis_name, bits_to_string(pred_bits), source, cfgidx);\n         assert!(self.dfcx.bits_per_id > 0);\n \n@@ -530,7 +530,7 @@ impl<'a, 'b, 'tcx, O:DataFlowOperator> PropagationContext<'a, 'b, 'tcx, O> {\n             bitwise(on_entry, pred_bits, &self.dfcx.oper)\n         };\n         if changed {\n-            debug!(\"{:s} changed entry set for {} to {}\",\n+            debug!(\"{} changed entry set for {} to {}\",\n                    self.dfcx.analysis_name, cfgidx,\n                    bits_to_string(self.dfcx.on_entry.slice(start, end)));\n             self.changed = true;"}, {"sha": "ac132477b8772d4ab4899c35ac8bc53dac8e903d", "filename": "src/librustc/middle/graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fgraph.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -36,7 +36,7 @@ be indexed by the direction (see the type `Direction`).\n \n #![allow(dead_code)] // still WIP\n \n-use std::fmt::{Formatter, FormatError, Show};\n+use std::fmt::{Formatter, Error, Show};\n use std::uint;\n \n pub struct Graph<N,E> {\n@@ -57,7 +57,7 @@ pub struct Edge<E> {\n }\n \n impl<E: Show> Show for Edge<E> {\n-    fn fmt(&self, f: &mut Formatter) -> Result<(), FormatError> {\n+    fn fmt(&self, f: &mut Formatter) -> Result<(), Error> {\n         write!(f, \"Edge {{ next_edge: [{}, {}], source: {}, target: {}, data: {} }}\",\n                self.next_edge[0], self.next_edge[1], self.source,\n                self.target, self.data)"}, {"sha": "f369f00a14e304d1d7719aa2ad08ea4af97c1ed9", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 4, "deletions": 59, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -633,6 +633,7 @@ enum TraitReferenceType {\n     TraitDerivation,                 // trait T : SomeTrait { ... }\n     TraitBoundingTypeParameter,      // fn f<T:SomeTrait>() { ... }\n     TraitObject,                     // Box<for<'a> SomeTrait>\n+    TraitQPath,                      // <T as SomeTrait>::\n }\n \n impl NameBindings {\n@@ -4532,6 +4533,7 @@ impl<'a> Resolver<'a> {\n                     TraitImplementation        => \"implement\",\n                     TraitDerivation            => \"derive\",\n                     TraitObject                => \"reference\",\n+                    TraitQPath                 => \"extract an associated type from\",\n                 };\n \n                 let msg = format!(\"attempt to {} a nonexistent trait `{}`\", usage_str, path_str);\n@@ -4969,65 +4971,8 @@ impl<'a> Resolver<'a> {\n             }\n \n             TyQPath(ref qpath) => {\n-                self.resolve_type(&*qpath.for_type);\n-\n-                let current_module = self.current_module.clone();\n-                let module_path: Vec<_> =\n-                    qpath.trait_name\n-                         .segments\n-                         .iter()\n-                         .map(|ps| ps.identifier.name)\n-                         .collect();\n-                match self.resolve_module_path(\n-                        current_module,\n-                        module_path.as_slice(),\n-                        UseLexicalScope,\n-                        qpath.trait_name.span,\n-                        PathSearch) {\n-                    Success((ref module, _)) if module.kind.get() ==\n-                            TraitModuleKind => {\n-                        match self.resolve_definition_of_name_in_module(\n-                                (*module).clone(),\n-                                qpath.item_name.name,\n-                                TypeNS) {\n-                            ChildNameDefinition(def, lp) |\n-                            ImportNameDefinition(def, lp) => {\n-                                match def {\n-                                    DefAssociatedTy(trait_type_id) => {\n-                                        let def = DefAssociatedTy(\n-                                            trait_type_id);\n-                                        self.record_def(ty.id, (def, lp));\n-                                    }\n-                                    _ => {\n-                                        self.resolve_error(\n-                                            ty.span,\n-                                            \"not an associated type\");\n-                                    }\n-                                }\n-                            }\n-                            NoNameDefinition => {\n-                                self.resolve_error(ty.span,\n-                                                   \"unresolved associated \\\n-                                                    type\");\n-                            }\n-                        }\n-                    }\n-                    Success(..) => self.resolve_error(ty.span, \"not a trait\"),\n-                    Indeterminate => {\n-                        self.session.span_bug(ty.span,\n-                                              \"indeterminate result when \\\n-                                               resolving associated type\")\n-                    }\n-                    Failed(error) => {\n-                        let (span, help) = match error {\n-                            Some((span, msg)) => (span, format!(\"; {}\", msg)),\n-                            None => (ty.span, String::new()),\n-                        };\n-                        self.resolve_error(span,\n-                                           format!(\"unresolved trait: {}\",\n-                                                   help).as_slice())\n-                    }\n-                }\n+                self.resolve_type(&*qpath.self_type);\n+                self.resolve_trait_reference(ty.id, &*qpath.trait_ref, TraitQPath);\n             }\n \n             TyClosure(ref c) | TyProc(ref c) => {"}, {"sha": "3fc92a84194243d08ad631a4250c65ec363dd2af", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -226,7 +226,7 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n         self.with(LateScope(&trait_ref.bound_lifetimes, self.scope), |this| {\n             this.check_lifetime_defs(&trait_ref.bound_lifetimes);\n             for lifetime in trait_ref.bound_lifetimes.iter() {\n-                this.visit_lifetime_decl(lifetime);\n+                this.visit_lifetime_def(lifetime);\n             }\n             this.visit_trait_ref(&trait_ref.trait_ref)\n         })"}, {"sha": "b030867fc841c5fbe6670ef76c2417d2c7e687ca", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -100,6 +100,10 @@ impl<'tcx> Substs<'tcx> {\n         regions_is_noop && self.types.is_empty()\n     }\n \n+    pub fn type_for_def(&self, ty_param_def: &ty::TypeParameterDef) -> Ty<'tcx> {\n+        *self.types.get(ty_param_def.space, ty_param_def.index)\n+    }\n+\n     pub fn has_regions_escaping_depth(&self, depth: uint) -> bool {\n         self.types.iter().any(|&t| ty::type_escapes_depth(t, depth)) || {\n             match self.regions {"}, {"sha": "d34d413225e808f89a91dee0f4e83a29b12271d4", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -25,6 +25,7 @@ use std::rc::Rc;\n use std::slice::Items;\n use syntax::ast;\n use syntax::codemap::{Span, DUMMY_SP};\n+use util::common::ErrorReported;\n \n pub use self::fulfill::FulfillmentContext;\n pub use self::select::SelectionContext;\n@@ -95,10 +96,6 @@ pub enum ObligationCauseCode<'tcx> {\n     FieldSized,\n }\n \n-// An error has already been reported to the user, so no need to continue checking.\n-#[deriving(Clone,Show)]\n-pub struct ErrorReported;\n-\n pub type Obligations<'tcx> = subst::VecPerParamSpace<Obligation<'tcx>>;\n \n pub type Selection<'tcx> = Vtable<'tcx, Obligation<'tcx>>;"}, {"sha": "9cb7023e1b59f777f99f9be3036aaa75b9cfba37", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -17,7 +17,6 @@ use self::Candidate::*;\n use self::BuiltinBoundConditions::*;\n use self::EvaluationResult::*;\n \n-use super::{ErrorReported};\n use super::{Obligation, ObligationCause};\n use super::{SelectionError, Unimplemented, Overflow,\n             OutputTypeParameterMismatch};\n@@ -38,6 +37,7 @@ use std::cell::RefCell;\n use std::collections::hash_map::HashMap;\n use std::rc::Rc;\n use syntax::ast;\n+use util::common::ErrorReported;\n use util::ppaux::Repr;\n \n pub struct SelectionContext<'cx, 'tcx:'cx> {"}, {"sha": "ec49d5010562b8d966a00e63bca3083794030a78", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -18,9 +18,10 @@ use std::fmt;\n use std::rc::Rc;\n use syntax::ast;\n use syntax::codemap::Span;\n+use util::common::ErrorReported;\n use util::ppaux::Repr;\n \n-use super::{ErrorReported, Obligation, ObligationCause, VtableImpl,\n+use super::{Obligation, ObligationCause, VtableImpl,\n             VtableParam, VtableParamData, VtableImplData};\n \n ///////////////////////////////////////////////////////////////////////////"}, {"sha": "15c292a6b2078e01c5b017f0824549999f7ea7c2", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -2635,9 +2635,14 @@ impl ops::Sub<TypeContents,TypeContents> for TypeContents {\n }\n \n impl fmt::Show for TypeContents {\n+    #[cfg(stage0)]\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"TypeContents({:t})\", self.bits)\n     }\n+    #[cfg(not(stage0))]\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"TypeContents({:b})\", self.bits)\n+    }\n }\n \n pub fn type_interior_is_unsafe<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> bool {"}, {"sha": "637c1f58157e20c29170d6682f0c27e925f3d3ee", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 38, "deletions": 90, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -207,7 +207,6 @@ fn ast_path_substs_for_ty<'tcx,AC,RS>(\n     decl_def_id: ast::DefId,\n     decl_generics: &ty::Generics<'tcx>,\n     self_ty: Option<Ty<'tcx>>,\n-    associated_ty: Option<Ty<'tcx>>,\n     path: &ast::Path)\n     -> Substs<'tcx>\n     where AC: AstConv<'tcx>, RS: RegionScope\n@@ -243,7 +242,7 @@ fn ast_path_substs_for_ty<'tcx,AC,RS>(\n     };\n \n     create_substs_for_ast_path(this, rscope, path.span, decl_def_id,\n-                               decl_generics, self_ty, types, regions, associated_ty)\n+                               decl_generics, self_ty, types, regions)\n }\n \n fn create_substs_for_ast_path<'tcx,AC,RS>(\n@@ -254,8 +253,7 @@ fn create_substs_for_ast_path<'tcx,AC,RS>(\n     decl_generics: &ty::Generics<'tcx>,\n     self_ty: Option<Ty<'tcx>>,\n     types: Vec<Ty<'tcx>>,\n-    regions: Vec<ty::Region>,\n-    associated_ty: Option<Ty<'tcx>>)\n+    regions: Vec<ty::Region>)\n     -> Substs<'tcx>\n     where AC: AstConv<'tcx>, RS: RegionScope\n {\n@@ -366,9 +364,9 @@ fn create_substs_for_ast_path<'tcx,AC,RS>(\n         substs.types.push(\n             AssocSpace,\n             this.associated_type_binding(span,\n-                                         associated_ty,\n+                                         self_ty,\n                                          decl_def_id,\n-                                         param.def_id))\n+                                         param.def_id));\n     }\n \n     return substs;\n@@ -417,19 +415,17 @@ pub fn instantiate_poly_trait_ref<'tcx,AC,RS>(\n     this: &AC,\n     rscope: &RS,\n     ast_trait_ref: &ast::PolyTraitRef,\n-    self_ty: Option<Ty<'tcx>>,\n-    associated_type: Option<Ty<'tcx>>)\n+    self_ty: Option<Ty<'tcx>>)\n     -> Rc<ty::TraitRef<'tcx>>\n     where AC: AstConv<'tcx>, RS: RegionScope\n {\n-    instantiate_trait_ref(this, rscope, &ast_trait_ref.trait_ref, self_ty, associated_type)\n+    instantiate_trait_ref(this, rscope, &ast_trait_ref.trait_ref, self_ty)\n }\n \n pub fn instantiate_trait_ref<'tcx,AC,RS>(this: &AC,\n                                          rscope: &RS,\n                                          ast_trait_ref: &ast::TraitRef,\n-                                         self_ty: Option<Ty<'tcx>>,\n-                                         associated_type: Option<Ty<'tcx>>)\n+                                         self_ty: Option<Ty<'tcx>>)\n                                          -> Rc<ty::TraitRef<'tcx>>\n                                          where AC: AstConv<'tcx>,\n                                                RS: RegionScope\n@@ -444,8 +440,8 @@ pub fn instantiate_trait_ref<'tcx,AC,RS>(this: &AC,\n                          ast_trait_ref.path.span,\n                          ast_trait_ref.ref_id) {\n         def::DefTrait(trait_def_id) => {\n-            let trait_ref = Rc::new(ast_path_to_trait_ref(this, rscope, trait_def_id, self_ty,\n-                                                          associated_type, &ast_trait_ref.path));\n+            let trait_ref = Rc::new(ast_path_to_trait_ref(this, rscope, trait_def_id,\n+                                                          self_ty, &ast_trait_ref.path));\n             this.tcx().trait_refs.borrow_mut().insert(ast_trait_ref.ref_id,\n                                                       trait_ref.clone());\n             trait_ref\n@@ -463,7 +459,6 @@ fn ast_path_to_trait_ref<'tcx,AC,RS>(\n     rscope: &RS,\n     trait_def_id: ast::DefId,\n     self_ty: Option<Ty<'tcx>>,\n-    associated_type: Option<Ty<'tcx>>,\n     path: &ast::Path)\n     -> ty::TraitRef<'tcx>\n     where AC: AstConv<'tcx>, RS: RegionScope\n@@ -493,8 +488,7 @@ fn ast_path_to_trait_ref<'tcx,AC,RS>(\n                                             &trait_def.generics,\n                                             self_ty,\n                                             types,\n-                                            regions,\n-                                            associated_type);\n+                                            regions);\n \n     ty::TraitRef::new(trait_def_id, substs)\n }\n@@ -517,7 +511,6 @@ pub fn ast_path_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                                         did,\n                                         &generics,\n                                         None,\n-                                        None,\n                                         path);\n     let ty = decl_ty.subst(tcx, &substs);\n     TypeAndSubsts { substs: substs, ty: ty }\n@@ -558,7 +551,7 @@ pub fn ast_path_to_ty_relaxed<'tcx,AC,RS>(\n         Substs::new(VecPerParamSpace::params_from_type(type_params),\n                     VecPerParamSpace::params_from_type(region_params))\n     } else {\n-        ast_path_substs_for_ty(this, rscope, did, &generics, None, None, path)\n+        ast_path_substs_for_ty(this, rscope, did, &generics, None, path)\n     };\n \n     let ty = decl_ty.subst(tcx, &substs);\n@@ -726,7 +719,6 @@ fn mk_pointer<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                                                        rscope,\n                                                        trait_def_id,\n                                                        None,\n-                                                       None,\n                                                        path);\n                     let empty_vec = [];\n                     let bounds = match *opt_bounds { None => empty_vec.as_slice(),\n@@ -750,61 +742,37 @@ fn mk_pointer<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n     constr(ast_ty_to_ty(this, rscope, a_seq_ty))\n }\n \n-fn associated_ty_to_ty<'tcx,AC,RS>(this: &AC,\n-                                   rscope: &RS,\n-                                   trait_path: &ast::Path,\n-                                   for_ast_type: &ast::Ty,\n-                                   trait_type_id: ast::DefId,\n-                                   span: Span)\n-                                   -> Ty<'tcx>\n-                                   where AC: AstConv<'tcx>, RS: RegionScope\n+fn qpath_to_ty<'tcx,AC,RS>(this: &AC,\n+                           rscope: &RS,\n+                           ast_ty: &ast::Ty, // the TyQPath\n+                           qpath: &ast::QPath)\n+                           -> Ty<'tcx>\n+    where AC: AstConv<'tcx>, RS: RegionScope\n {\n-    debug!(\"associated_ty_to_ty(trait_path={}, for_ast_type={}, trait_type_id={})\",\n-           trait_path.repr(this.tcx()),\n-           for_ast_type.repr(this.tcx()),\n-           trait_type_id.repr(this.tcx()));\n-\n-    // Find the trait that this associated type belongs to.\n-    let trait_did = match ty::impl_or_trait_item(this.tcx(),\n-                                                 trait_type_id).container() {\n-        ty::ImplContainer(_) => {\n-            this.tcx().sess.span_bug(span,\n-                                     \"associated_ty_to_ty(): impl associated \\\n-                                      types shouldn't go through this \\\n-                                      function\")\n-        }\n-        ty::TraitContainer(trait_id) => trait_id,\n-    };\n+    debug!(\"qpath_to_ty(ast_ty={})\",\n+           ast_ty.repr(this.tcx()));\n \n-    let for_type = ast_ty_to_ty(this, rscope, for_ast_type);\n-    if !this.associated_types_of_trait_are_valid(for_type, trait_did) {\n-        this.tcx().sess.span_err(span,\n-                                 \"this associated type is not \\\n-                                  allowed in this context\");\n-        return ty::mk_err()\n-    }\n+    let self_type = ast_ty_to_ty(this, rscope, &*qpath.self_type);\n+\n+    debug!(\"qpath_to_ty: self_type={}\", self_type.repr(this.tcx()));\n \n-    let trait_ref = ast_path_to_trait_ref(this,\n+    let trait_ref = instantiate_trait_ref(this,\n                                           rscope,\n-                                          trait_did,\n-                                          None,\n-                                          Some(for_type),\n-                                          trait_path);\n-\n-    debug!(\"associated_ty_to_ty(trait_ref={})\",\n-           trait_ref.repr(this.tcx()));\n-\n-    let trait_def = this.get_trait_def(trait_did);\n-    for type_parameter in trait_def.generics.types.iter() {\n-        if type_parameter.def_id == trait_type_id {\n-            debug!(\"associated_ty_to_ty(type_parameter={} substs={})\",\n-                   type_parameter.repr(this.tcx()),\n-                   trait_ref.substs.repr(this.tcx()));\n-            return *trait_ref.substs.types.get(type_parameter.space,\n-                                               type_parameter.index)\n+                                          &*qpath.trait_ref,\n+                                          Some(self_type));\n+\n+    debug!(\"qpath_to_ty: trait_ref={}\", trait_ref.repr(this.tcx()));\n+\n+    let trait_def = this.get_trait_def(trait_ref.def_id);\n+\n+    for ty_param_def in trait_def.generics.types.get_slice(AssocSpace).iter() {\n+        if ty_param_def.name == qpath.item_name.name {\n+            debug!(\"qpath_to_ty: corresponding ty_param_def={}\", ty_param_def);\n+            return trait_ref.substs.type_for_def(ty_param_def);\n         }\n     }\n-    this.tcx().sess.span_bug(span,\n+\n+    this.tcx().sess.span_bug(ast_ty.span,\n                              \"this associated type didn't get added \\\n                               as a parameter for some reason\")\n }\n@@ -931,7 +899,6 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                                                            rscope,\n                                                            trait_def_id,\n                                                            None,\n-                                                           None,\n                                                            path);\n                         let empty_bounds: &[ast::TyParamBound] = &[];\n                         let ast_bounds = match *bounds {\n@@ -996,26 +963,7 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                 }\n             }\n             ast::TyQPath(ref qpath) => {\n-                match tcx.def_map.borrow().get(&ast_ty.id) {\n-                    None => {\n-                        tcx.sess.span_bug(ast_ty.span,\n-                                          \"unbound qualified path\")\n-                    }\n-                    Some(&def::DefAssociatedTy(trait_type_id)) => {\n-                        associated_ty_to_ty(this,\n-                                            rscope,\n-                                            &qpath.trait_name,\n-                                            &*qpath.for_type,\n-                                            trait_type_id,\n-                                            ast_ty.span)\n-                    }\n-                    Some(_) => {\n-                        tcx.sess.span_err(ast_ty.span,\n-                                          \"this qualified path does not name \\\n-                                           an associated type\");\n-                        ty::mk_err()\n-                    }\n-                }\n+                qpath_to_ty(this, rscope, ast_ty, &**qpath)\n             }\n             ast::TyFixedLengthVec(ref ty, ref e) => {\n                 match const_eval::eval_const_expr_partial(tcx, &**e) {\n@@ -1411,7 +1359,7 @@ fn conv_ty_poly_trait_ref<'tcx, AC, RS>(\n \n     let main_trait_bound = match partitioned_bounds.trait_bounds.remove(0) {\n         Some(trait_bound) => {\n-            Some(instantiate_poly_trait_ref(this, rscope, trait_bound, None, None))\n+            Some(instantiate_poly_trait_ref(this, rscope, trait_bound, None))\n         }\n         None => {\n             this.tcx().sess.span_err("}, {"sha": "cdfd607d067103adb173d2a4af601ddfa9488a69", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -379,7 +379,8 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &ast::Pat,\n \n     let real_path_ty = fcx.node_ty(pat.id);\n     let (arg_tys, kind_name) = match real_path_ty.sty {\n-        ty::ty_enum(enum_def_id, ref expected_substs) => {\n+        ty::ty_enum(enum_def_id, ref expected_substs)\n+            if def == def::DefVariant(enum_def_id, def.def_id(), false) => {\n             let variant = ty::enum_variant_with_id(tcx, enum_def_id, def.def_id());\n             (variant.args.iter().map(|t| t.subst(tcx, expected_substs)).collect::<Vec<_>>(),\n                 \"variant\")\n@@ -392,7 +393,7 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &ast::Pat,\n         _ => {\n             let name = pprust::path_to_string(path);\n             span_err!(tcx.sess, pat.span, E0164,\n-                \"`{}` does not name a variant or a tuple struct\", name);\n+                \"`{}` does not name a non-struct variant or a tuple struct\", name);\n             fcx.write_error(pat.id);\n \n             if let Some(ref subpats) = *subpats {"}, {"sha": "c53befcc10d6b76a1541ac3f7f5f1826a5a0abfb", "filename": "src/librustc/middle/typeck/check/method/confirm.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -31,6 +31,7 @@ struct ConfirmContext<'a, 'tcx:'a> {\n     fcx: &'a FnCtxt<'a, 'tcx>,\n     span: Span,\n     self_expr: &'a ast::Expr,\n+    call_expr: &'a ast::Expr,\n }\n \n struct InstantiatedMethodSig<'tcx> {\n@@ -56,6 +57,7 @@ struct InstantiatedMethodSig<'tcx> {\n pub fn confirm<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                          span: Span,\n                          self_expr: &ast::Expr,\n+                         call_expr: &ast::Expr,\n                          unadjusted_self_ty: Ty<'tcx>,\n                          pick: probe::Pick<'tcx>,\n                          supplied_method_types: Vec<Ty<'tcx>>)\n@@ -66,17 +68,18 @@ pub fn confirm<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n            pick.repr(fcx.tcx()),\n            supplied_method_types.repr(fcx.tcx()));\n \n-    let mut confirm_cx = ConfirmContext::new(fcx, span, self_expr);\n+    let mut confirm_cx = ConfirmContext::new(fcx, span, self_expr, call_expr);\n     confirm_cx.confirm(unadjusted_self_ty, pick, supplied_method_types)\n }\n \n impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n     fn new(fcx: &'a FnCtxt<'a, 'tcx>,\n            span: Span,\n-           self_expr: &'a ast::Expr)\n+           self_expr: &'a ast::Expr,\n+           call_expr: &'a ast::Expr)\n            -> ConfirmContext<'a, 'tcx>\n     {\n-        ConfirmContext { fcx: fcx, span: span, self_expr: self_expr }\n+        ConfirmContext { fcx: fcx, span: span, self_expr: self_expr, call_expr: call_expr }\n     }\n \n     fn confirm(&mut self,\n@@ -469,6 +472,10 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n             traits::ObligationCause::misc(self.span),\n             method_bounds_substs,\n             method_bounds);\n+\n+        self.fcx.add_default_region_param_bounds(\n+            method_bounds_substs,\n+            self.call_expr);\n     }\n \n     ///////////////////////////////////////////////////////////////////////////"}, {"sha": "0f4152644adafb80b968de958dcf64b25406a4fd", "filename": "src/librustc/middle/typeck/check/method/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fmod.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -79,7 +79,7 @@ pub fn lookup<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                         method_name: ast::Name,\n                         self_ty: Ty<'tcx>,\n                         supplied_method_types: Vec<Ty<'tcx>>,\n-                        call_expr_id: ast::NodeId,\n+                        call_expr: &ast::Expr,\n                         self_expr: &ast::Expr)\n                         -> Result<MethodCallee<'tcx>, MethodError>\n {\n@@ -100,14 +100,14 @@ pub fn lookup<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n      * - `self_expr`:             the self expression (`foo`)\n      */\n \n-    debug!(\"lookup(method_name={}, self_ty={}, call_expr_id={}, self_expr={})\",\n+    debug!(\"lookup(method_name={}, self_ty={}, call_expr={}, self_expr={})\",\n            method_name.repr(fcx.tcx()),\n            self_ty.repr(fcx.tcx()),\n-           call_expr_id,\n+           call_expr.repr(fcx.tcx()),\n            self_expr.repr(fcx.tcx()));\n \n-    let pick = try!(probe::probe(fcx, span, method_name, self_ty, call_expr_id));\n-    Ok(confirm::confirm(fcx, span, self_expr, self_ty, pick, supplied_method_types))\n+    let pick = try!(probe::probe(fcx, span, method_name, self_ty, call_expr.id));\n+    Ok(confirm::confirm(fcx, span, self_expr, call_expr, self_ty, pick, supplied_method_types))\n }\n \n pub fn lookup_in_trait<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,"}, {"sha": "553d80852c28fb959117ebcb0465096c8f20f56d", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -2050,6 +2050,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n+    pub fn add_default_region_param_bounds(&self,\n+                                           substs: &Substs<'tcx>,\n+                                           expr: &ast::Expr)\n+    {\n+        for &ty in substs.types.iter() {\n+            let default_bound = ty::ReScope(expr.id);\n+            let origin = infer::RelateDefaultParamBound(expr.span, ty);\n+            self.register_region_obligation(origin, ty, default_bound);\n+        }\n+    }\n+\n     pub fn add_obligations_for_parameters(&self,\n                                           cause: traits::ObligationCause<'tcx>,\n                                           substs: &Substs<'tcx>,\n@@ -3180,7 +3191,7 @@ fn check_expr_with_unifier<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                          method_name.node.name,\n                                          expr_t,\n                                          tps,\n-                                         expr.id,\n+                                         expr,\n                                          rcvr) {\n             Ok(method) => {\n                 let method_ty = method.ty;\n@@ -4693,11 +4704,7 @@ fn constrain_path_type_parameters(fcx: &FnCtxt,\n                                   expr: &ast::Expr)\n {\n     fcx.opt_node_ty_substs(expr.id, |item_substs| {\n-        for &ty in item_substs.substs.types.iter() {\n-            let default_bound = ty::ReScope(expr.id);\n-            let origin = infer::RelateDefaultParamBound(expr.span, ty);\n-            fcx.register_region_obligation(origin, ty, default_bound);\n-        }\n+        fcx.add_default_region_param_bounds(&item_substs.substs, expr);\n     });\n }\n "}, {"sha": "90ad0d2f3e5e223d3537e2cc7a2eba022d92e830", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -684,7 +684,11 @@ fn find_associated_type_in_generics<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                           ty: Option<Ty<'tcx>>,\n                                           associated_type_id: ast::DefId,\n                                           generics: &ty::Generics<'tcx>)\n-                                          -> Ty<'tcx> {\n+                                          -> Ty<'tcx>\n+{\n+    debug!(\"find_associated_type_in_generics(ty={}, associated_type_id={}, generics={}\",\n+           ty.repr(tcx), associated_type_id.repr(tcx), generics.repr(tcx));\n+\n     let ty = match ty {\n         None => {\n             tcx.sess.span_bug(span,\n@@ -703,20 +707,22 @@ fn find_associated_type_in_generics<'tcx>(tcx: &ty::ctxt<'tcx>,\n             for type_parameter in generics.types.iter() {\n                 if type_parameter.def_id == associated_type_id\n                     && type_parameter.associated_with == Some(param_id) {\n-                    return ty::mk_param_from_def(tcx, type_parameter)\n+                    return ty::mk_param_from_def(tcx, type_parameter);\n                 }\n             }\n \n-            tcx.sess.span_bug(span,\n-                              \"find_associated_type_in_generics(): didn't \\\n-                               find associated type anywhere in the generics \\\n-                               list\")\n+            tcx.sess.span_err(\n+                span,\n+                format!(\"no suitable bound on `{}`\",\n+                        ty.user_string(tcx))[]);\n+            ty::mk_err()\n         }\n         _ => {\n-            tcx.sess.span_bug(span,\n-                              \"find_associated_type_in_generics(): self type \\\n-                               is not a parameter\")\n-\n+            tcx.sess.span_err(\n+                span,\n+                \"it is currently unsupported to access associated types except \\\n+                 through a type parameter; this restriction will be lifted in time\");\n+            ty::mk_err()\n         }\n     }\n }\n@@ -1155,7 +1161,7 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n \n             for trait_ref in opt_trait_ref.iter() {\n                 astconv::instantiate_trait_ref(&icx, &ExplicitRscope, trait_ref,\n-                                               Some(selfty), None);\n+                                               Some(selfty));\n             }\n         },\n         ast::ItemTrait(_, _, _, ref trait_methods) => {\n@@ -1627,7 +1633,7 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                         ccx,\n                         subst::AssocSpace,\n                         &associated_type.ty_param,\n-                        generics.types.len(subst::TypeSpace),\n+                        generics.types.len(subst::AssocSpace),\n                         &ast_generics.where_clause,\n                         Some(local_def(trait_id)));\n                 ccx.tcx.ty_param_defs.borrow_mut().insert(associated_type.ty_param.id,\n@@ -2019,7 +2025,6 @@ fn conv_param_bounds<'tcx,AC>(this: &AC,\n             astconv::instantiate_poly_trait_ref(this,\n                                                 &ExplicitRscope,\n                                                 bound,\n-                                                Some(param_ty.to_ty(this.tcx())),\n                                                 Some(param_ty.to_ty(this.tcx())))\n         })\n         .collect();"}, {"sha": "51b610dccce3846d0db52793c104f6b0a9511662", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -603,7 +603,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n             let is_inferred;\n             macro_rules! cannot_happen { () => { {\n-                panic!(\"invalid parent: {:s} for {:s}\",\n+                panic!(\"invalid parent: {} for {}\",\n                       tcx.map.node_to_string(parent_id),\n                       tcx.map.node_to_string(param_id));\n             } } }"}, {"sha": "cdbe107e11c9576fdd1f02ae540ccceabb9d6e97", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -20,6 +20,10 @@ use syntax::ast;\n use syntax::visit;\n use syntax::visit::Visitor;\n \n+// An error has already been reported to the user, so no need to continue checking.\n+#[deriving(Clone,Show)]\n+pub struct ErrorReported;\n+\n pub fn time<T, U>(do_it: bool, what: &str, u: U, f: |U| -> T) -> T {\n     local_data_key!(depth: uint);\n     if !do_it { return f(u); }"}, {"sha": "2cca63bd65d94a8b3ef207028d52033fdde1fd89", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -181,7 +181,7 @@ mod svh_visitor {\n         SawStructDef(token::InternedString),\n \n         SawLifetimeRef(token::InternedString),\n-        SawLifetimeDecl(token::InternedString),\n+        SawLifetimeDef(token::InternedString),\n \n         SawMod,\n         SawViewItem,\n@@ -414,8 +414,8 @@ mod svh_visitor {\n             SawLifetimeRef(content(l.name)).hash(self.st);\n         }\n \n-        fn visit_lifetime_decl(&mut self, l: &LifetimeDef) {\n-            SawLifetimeDecl(content(l.lifetime.name)).hash(self.st);\n+        fn visit_lifetime_def(&mut self, l: &LifetimeDef) {\n+            SawLifetimeDef(content(l.lifetime.name)).hash(self.st);\n         }\n \n         // We do recursively walk the bodies of functions/methods"}, {"sha": "47bba3e4327c1e7c40895884b3099fd982a00e4c", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -368,7 +368,7 @@ unsafe extern \"C\" fn diagnostic_handler(info: DiagnosticInfoRef, user: *mut c_vo\n \n             if enabled {\n                 let loc = llvm::debug_loc_to_string(llcx, opt.debug_loc);\n-                cgcx.handler.note(format!(\"optimization {:s} for {:s} at {:s}: {:s}\",\n+                cgcx.handler.note(format!(\"optimization {} for {} at {}: {}\",\n                                           opt.kind.describe(),\n                                           pass_name,\n                                           if loc.is_empty() { \"[unknown]\" } else { loc.as_slice() },"}, {"sha": "a73afdf68e33c5958092271b45832e1215c8bd19", "filename": "src/librustc_trans/driver/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustc_trans%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustc_trans%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdriver%2Fmod.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -224,13 +224,13 @@ Available lint options:\n     };\n \n     println!(\"Lint checks provided by rustc:\\n\");\n-    println!(\"    {}  {:7.7s}  {}\", padded(\"name\"), \"default\", \"meaning\");\n-    println!(\"    {}  {:7.7s}  {}\", padded(\"----\"), \"-------\", \"-------\");\n+    println!(\"    {}  {:7.7}  {}\", padded(\"name\"), \"default\", \"meaning\");\n+    println!(\"    {}  {:7.7}  {}\", padded(\"----\"), \"-------\", \"-------\");\n \n     let print_lints = |lints: Vec<&Lint>| {\n         for lint in lints.into_iter() {\n             let name = lint.name_lower().replace(\"_\", \"-\");\n-            println!(\"    {}  {:7.7s}  {}\",\n+            println!(\"    {}  {:7.7}  {}\",\n                      padded(name.as_slice()), lint.default_level.as_str(), lint.desc);\n         }\n         println!(\"\\n\");\n@@ -293,7 +293,7 @@ fn describe_debug_flags() {\n     for tuple in r.iter() {\n         match *tuple {\n             (ref name, ref desc, _) => {\n-                println!(\"    -Z {:>20s} -- {}\", *name, *desc);\n+                println!(\"    -Z {:>20} -- {}\", *name, *desc);\n             }\n         }\n     }\n@@ -306,7 +306,7 @@ fn describe_codegen_flags() {\n             Some(..) => (21, \"=val\"),\n             None => (25, \"\")\n         };\n-        println!(\"    -C {:>width$s}{} -- {}\", name.replace(\"_\", \"-\"),\n+        println!(\"    -C {:>width$}{} -- {}\", name.replace(\"_\", \"-\"),\n                  extra, desc, width=width);\n     }\n }"}, {"sha": "7bb83d7c2a8195134d1b5ebd843e15a6b2475f4d", "filename": "src/librustc_trans/driver/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustc_trans%2Fdriver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustc_trans%2Fdriver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdriver%2Fpretty.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -355,8 +355,8 @@ impl UserIdentifiedItem {\n     fn to_one_node_id(self, user_option: &str, sess: &Session, map: &ast_map::Map) -> ast::NodeId {\n         let fail_because = |is_wrong_because| -> ast::NodeId {\n             let message =\n-                format!(\"{:s} needs NodeId (int) or unique \\\n-                         path suffix (b::c::d); got {:s}, which {:s}\",\n+                format!(\"{} needs NodeId (int) or unique \\\n+                         path suffix (b::c::d); got {}, which {}\",\n                         user_option,\n                         self.reconstructed_input(),\n                         is_wrong_because);"}, {"sha": "d8cc475c1dfa08c6d580b040bf32a4724aac391a", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -3146,7 +3146,7 @@ pub fn trans_crate<'tcx>(analysis: CrateAnalysis<'tcx>)\n     }\n     if shared_ccx.sess().count_llvm_insns() {\n         for (k, v) in shared_ccx.stats().llvm_insns.borrow().iter() {\n-            println!(\"{:7u} {}\", *v, *k);\n+            println!(\"{:7} {}\", *v, *k);\n         }\n     }\n "}, {"sha": "d6124736586a5487af435361cfa845f01e29efe5", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -67,7 +67,7 @@ pub enum CleanupScopeKind<'blk, 'tcx: 'blk> {\n }\n \n impl<'blk, 'tcx: 'blk> fmt::Show for CleanupScopeKind<'blk, 'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::FormatError> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             CustomScopeKind => write!(f, \"CustomScopeKind\"),\n             AstScopeKind(nid) => write!(f, \"AstScopeKind({})\", nid),"}, {"sha": "111650f565cf6bb5643ab7117b5452655d206ee7", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -128,12 +128,17 @@ fn doit(sess: &parse::ParseSess, mut lexer: lexer::StringReader,\n                 }\n             }\n \n-            // text literals\n-            token::LitByte(..) | token::LitBinary(..) | token::LitBinaryRaw(..) |\n-                token::LitChar(..) | token::LitStr(..) | token::LitStrRaw(..) => \"string\",\n-\n-            // number literals\n-            token::LitInteger(..) | token::LitFloat(..) => \"number\",\n+            token::Literal(lit, _suf) => {\n+                match lit {\n+                    // text literals\n+                    token::Byte(..) | token::Char(..) |\n+                        token::Binary(..) | token::BinaryRaw(..) |\n+                        token::Str_(..) | token::StrRaw(..) => \"string\",\n+\n+                    // number literals\n+                    token::Integer(..) | token::Float(..) => \"number\",\n+                }\n+            }\n \n             // keywords are also included in the identifier set\n             token::Ident(ident, _is_mod_sep) => {"}, {"sha": "daa5f155d511e40cb23b4e9cdf155f860a051537", "filename": "src/librustdoc/html/item_type.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -75,12 +75,6 @@ impl fmt::Show for ItemType {\n     }\n }\n \n-impl fmt::Unsigned for ItemType {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        (*self as uint).fmt(f)\n-    }\n-}\n-\n pub fn shortty(item: &clean::Item) -> ItemType {\n     match item.inner {\n         clean::ModuleItem(..)          => Module,"}, {"sha": "5e4ac259e718007d29869cc9f325fbde06ff2ae3", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -437,8 +437,8 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> io::IoResult<String>\n         if i > 0 {\n             try!(write!(&mut w, \",\"));\n         }\n-        try!(write!(&mut w, r#\"[{:u},\"{}\",\"{}\",{}\"#,\n-                    item.ty, item.name, path,\n+        try!(write!(&mut w, r#\"[{},\"{}\",\"{}\",{}\"#,\n+                    item.ty as uint, item.name, path,\n                     item.desc.to_json().to_string()));\n         match item.parent {\n             Some(nodeid) => {\n@@ -457,8 +457,8 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> io::IoResult<String>\n         if i > 0 {\n             try!(write!(&mut w, \",\"));\n         }\n-        try!(write!(&mut w, r#\"[{:u},\"{}\"]\"#,\n-                    short, *fqp.last().unwrap()));\n+        try!(write!(&mut w, r#\"[{},\"{}\"]\"#,\n+                    short as uint, *fqp.last().unwrap()));\n     }\n \n     try!(write!(&mut w, \"]}};\"));\n@@ -2192,7 +2192,7 @@ impl<'a> fmt::Show for Source<'a> {\n         }\n         try!(write!(fmt, \"<pre class='line-numbers'>\"));\n         for i in range(1, lines + 1) {\n-            try!(write!(fmt, \"<span id='{0:u}'>{0:1$u}</span>\\n\", i, cols));\n+            try!(write!(fmt, \"<span id='{0}'>{0:1$}</span>\\n\", i, cols));\n         }\n         try!(write!(fmt, \"</pre>\"));\n         try!(write!(fmt, \"{}\", highlight::highlight(s.as_slice(), None, None)));"}, {"sha": "4a512ca33fc453d90c6944847583bc6f62b4155c", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -168,11 +168,11 @@ pub fn main_args(args: &[String]) -> int {\n     if matches.opt_strs(\"passes\").as_slice() == &[\"list\".to_string()] {\n         println!(\"Available passes for running rustdoc:\");\n         for &(name, _, description) in PASSES.iter() {\n-            println!(\"{:>20s} - {}\", name, description);\n+            println!(\"{:>20} - {}\", name, description);\n         }\n         println!(\"{}\", \"\\nDefault passes for rustdoc:\"); // FIXME: #9970\n         for &name in DEFAULT_PASSES.iter() {\n-            println!(\"{:>20s}\", name);\n+            println!(\"{:>20}\", name);\n         }\n         return 0;\n     }"}, {"sha": "10a3efbca10010b7322400af462a9865cc3e1f92", "filename": "src/librustrt/stack_overflow.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustrt%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibrustrt%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fstack_overflow.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -283,6 +283,7 @@ mod imp {\n     #[cfg(any(all(target_os = \"linux\", target_arch = \"x86\"), // may not match\n               all(target_os = \"linux\", target_arch = \"x86_64\"),\n               all(target_os = \"linux\", target_arch = \"arm\"), // may not match\n+              all(target_os = \"linux\", target_arch = \"mips\"), // may not match\n               target_os = \"android\"))] // may not match\n     mod signal {\n         use libc;"}, {"sha": "030ee1d4352b5d98fa96e8d4972d377bb668cd77", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -2403,7 +2403,7 @@ impl<A:ToJson> ToJson for Option<A> {\n impl fmt::Show for Json {\n     /// Encodes a json value into a string\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        self.to_writer(f).map_err(|_| fmt::WriteError)\n+        self.to_writer(f).map_err(|_| fmt::Error)\n     }\n }\n "}, {"sha": "2482fe63028d150e5612aa6b54ab021f072f1481", "filename": "src/libstd/fmt.rs", "status": "modified", "additions": 17, "deletions": 22, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibstd%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibstd%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -38,11 +38,11 @@ Some examples of the `format!` extension are:\n ```rust\n # fn main() {\n format!(\"Hello\");                  // => \"Hello\"\n-format!(\"Hello, {:s}!\", \"world\");  // => \"Hello, world!\"\n-format!(\"The number is {:d}\", 1i); // => \"The number is 1\"\n+format!(\"Hello, {}!\", \"world\");    // => \"Hello, world!\"\n+format!(\"The number is {}\", 1i);   // => \"The number is 1\"\n format!(\"{}\", (3i, 4i));           // => \"(3, 4)\"\n format!(\"{value}\", value=4i);      // => \"4\"\n-format!(\"{} {}\", 1i, 2i);          // => \"1 2\"\n+format!(\"{} {}\", 1i, 2u);          // => \"1 2\"\n # }\n ```\n \n@@ -94,9 +94,9 @@ For example, the following `format!` expressions all use named argument:\n \n ```rust\n # fn main() {\n-format!(\"{argument}\", argument = \"test\");        // => \"test\"\n-format!(\"{name} {}\", 1i, name = 2i);             // => \"2 1\"\n-format!(\"{a:s} {c:d} {b}\", a=\"a\", b=(), c=3i); // => \"a 3 ()\"\n+format!(\"{argument}\", argument = \"test\");   // => \"test\"\n+format!(\"{name} {}\", 1i, name = 2i);        // => \"2 1\"\n+format!(\"{a} {c} {b}\", a=\"a\", b=(), c=3i);  // => \"a 3 ()\"\n # }\n ```\n \n@@ -138,23 +138,16 @@ multiple actual types to be formatted via `{:d}` (like `i8` as well as `int`).\n The current mapping of types to traits is:\n \n * *nothing* \u21d2 `Show`\n-* `d` \u21d2 `Signed`\n-* `i` \u21d2 `Signed`\n-* `u` \u21d2 `Unsigned`\n-* `b` \u21d2 `Bool`\n-* `c` \u21d2 `Char`\n * `o` \u21d2 `Octal`\n * `x` \u21d2 `LowerHex`\n * `X` \u21d2 `UpperHex`\n-* `s` \u21d2 `String`\n * `p` \u21d2 `Pointer`\n-* `t` \u21d2 `Binary`\n-* `f` \u21d2 `Float`\n+* `b` \u21d2 `Binary`\n * `e` \u21d2 `LowerExp`\n * `E` \u21d2 `UpperExp`\n \n What this means is that any type of argument which implements the\n-`std::fmt::Binary` trait can then be formatted with `{:t}`. Implementations are\n+`std::fmt::Binary` trait can then be formatted with `{:b}`. Implementations are\n provided for these traits for a number of primitive types by the standard\n library as well. If no format is specified (as in `{}` or `{:6}`), then the\n format trait used is the `Show` trait. This is one of the more commonly\n@@ -216,7 +209,7 @@ impl fmt::Binary for Vector2D {\n         // Respect the formatting flags by using the helper method\n         // `pad_integral` on the Formatter object. See the method documentation\n         // for details, and the function `pad` can be used to pad strings.\n-        let decimals = f.precision.unwrap_or(3);\n+        let decimals = f.precision().unwrap_or(3);\n         let string = f64::to_str_exact(magnitude, decimals);\n         f.pad_integral(true, \"\", string.as_bytes())\n     }\n@@ -226,7 +219,7 @@ fn main() {\n     let myvector = Vector2D { x: 3, y: 4 };\n \n     println!(\"{}\", myvector);       // => \"(3, 4)\"\n-    println!(\"{:10.3t}\", myvector); // => \"     5.000\"\n+    println!(\"{:10.3b}\", myvector); // => \"     5.000\"\n }\n ```\n \n@@ -418,10 +411,10 @@ use string;\n use vec::Vec;\n \n pub use core::fmt::{Formatter, Result, FormatWriter, rt};\n-pub use core::fmt::{Show, Bool, Char, Signed, Unsigned, Octal, Binary};\n-pub use core::fmt::{LowerHex, UpperHex, String, Pointer};\n-pub use core::fmt::{Float, LowerExp, UpperExp};\n-pub use core::fmt::{FormatError, WriteError};\n+pub use core::fmt::{Show, Octal, Binary};\n+pub use core::fmt::{LowerHex, UpperHex, Pointer};\n+pub use core::fmt::{LowerExp, UpperExp};\n+pub use core::fmt::Error;\n pub use core::fmt::{Argument, Arguments, write, radix, Radix, RadixFmt};\n \n #[doc(hidden)]\n@@ -444,6 +437,8 @@ pub use core::fmt::{argument, argumentstr, argumentuint};\n /// let s = format_args!(fmt::format, \"Hello, {}!\", \"world\");\n /// assert_eq!(s, \"Hello, world!\".to_string());\n /// ```\n+#[experimental = \"this is an implementation detail of format! and should not \\\n+                  be called directly\"]\n pub fn format(args: &Arguments) -> string::String {\n     let mut output = Vec::new();\n     let _ = write!(&mut output as &mut Writer, \"{}\", args);\n@@ -454,7 +449,7 @@ impl<'a> Writer for Formatter<'a> {\n     fn write(&mut self, b: &[u8]) -> io::IoResult<()> {\n         match (*self).write(b) {\n             Ok(()) => Ok(()),\n-            Err(WriteError) => Err(io::standard_error(io::OtherIoError))\n+            Err(Error) => Err(io::standard_error(io::OtherIoError))\n         }\n     }\n }"}, {"sha": "681400e9db581f740d981fcdbca84920033a8ac3", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -1034,7 +1034,7 @@ pub trait Writer {\n                     Ok(()) => Ok(()),\n                     Err(e) => {\n                         self.error = Err(e);\n-                        Err(fmt::WriteError)\n+                        Err(fmt::Error)\n                     }\n                 }\n             }\n@@ -1081,13 +1081,13 @@ pub trait Writer {\n     /// Write the result of passing n through `int::to_str_bytes`.\n     #[inline]\n     fn write_int(&mut self, n: int) -> IoResult<()> {\n-        write!(self, \"{:d}\", n)\n+        write!(self, \"{}\", n)\n     }\n \n     /// Write the result of passing n through `uint::to_str_bytes`.\n     #[inline]\n     fn write_uint(&mut self, n: uint) -> IoResult<()> {\n-        write!(self, \"{:u}\", n)\n+        write!(self, \"{}\", n)\n     }\n \n     /// Write a little-endian uint (number of bytes depends on system).\n@@ -1896,10 +1896,8 @@ impl Default for FilePermission {\n }\n \n impl fmt::Show for FilePermission {\n-    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n-        formatter.fill = '0';\n-        formatter.width = Some(4);\n-        (&self.bits as &fmt::Octal).fmt(formatter)\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{:04o}\", self.bits)\n     }\n }\n "}, {"sha": "4e5dd5d8818f4c29b9ad7b441ea38d3d9bb004a6", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -240,6 +240,7 @@ macro_rules! unimplemented(\n /// format!(\"x = {}, y = {y}\", 10i, y = 30i);\n /// ```\n #[macro_export]\n+#[stable]\n macro_rules! format(\n     ($($arg:tt)*) => (\n         format_args!(::std::fmt::format, $($arg)*)\n@@ -259,15 +260,18 @@ macro_rules! format(\n /// write!(&mut w, \"formatted {}\", \"arguments\");\n /// ```\n #[macro_export]\n+#[stable]\n macro_rules! write(\n     ($dst:expr, $($arg:tt)*) => ({\n-        format_args_method!($dst, write_fmt, $($arg)*)\n+        let dst = &mut *$dst;\n+        format_args!(|args| { dst.write_fmt(args) }, $($arg)*)\n     })\n )\n \n /// Equivalent to the `write!` macro, except that a newline is appended after\n /// the message is written.\n #[macro_export]\n+#[stable]\n macro_rules! writeln(\n     ($dst:expr, $fmt:expr $($arg:tt)*) => (\n         write!($dst, concat!($fmt, \"\\n\") $($arg)*)\n@@ -277,6 +281,7 @@ macro_rules! writeln(\n /// Equivalent to the `println!` macro except that a newline is not printed at\n /// the end of the message.\n #[macro_export]\n+#[stable]\n macro_rules! print(\n     ($($arg:tt)*) => (format_args!(::std::io::stdio::print_args, $($arg)*))\n )\n@@ -294,6 +299,7 @@ macro_rules! print(\n /// println!(\"format {} arguments\", \"some\");\n /// ```\n #[macro_export]\n+#[stable]\n macro_rules! println(\n     ($($arg:tt)*) => (format_args!(::std::io::stdio::println_args, $($arg)*))\n )"}, {"sha": "68ddabfd48f279f2e420c851ffcb2e8b40a0fe8b", "filename": "src/libstd/os.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -1108,6 +1108,10 @@ extern \"system\" {\n /// Returns the arguments which this program was started with (normally passed\n /// via the command line).\n ///\n+/// The first element is traditionally the path to the executable, but it can be\n+/// set to arbitrary text, and it may not even exist, so this property should not\n+//  be relied upon for security purposes.\n+///\n /// The arguments are interpreted as utf-8, with invalid bytes replaced with \\uFFFD.\n /// See `String::from_utf8_lossy` for details.\n /// # Example"}, {"sha": "2a4d8347c30c9a68aa061f0118e1acd2de654777", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -212,12 +212,12 @@ mod imp {\n     impl Rng for OsRng {\n         fn next_u32(&mut self) -> u32 {\n             let mut v = [0u8, .. 4];\n-            self.fill_bytes(v);\n+            self.fill_bytes(&mut v);\n             unsafe { mem::transmute(v) }\n         }\n         fn next_u64(&mut self) -> u64 {\n             let mut v = [0u8, .. 8];\n-            self.fill_bytes(v);\n+            self.fill_bytes(&mut v);\n             unsafe { mem::transmute(v) }\n         }\n         fn fill_bytes(&mut self, v: &mut [u8]) {"}, {"sha": "e3058c0a248b708a1bdd6889f8960b45fe6c6ee1", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -95,7 +95,7 @@ impl Ident {\n     }\n \n     pub fn encode_with_hygiene(&self) -> String {\n-        format!(\"\\x00name_{:u},ctxt_{:u}\\x00\",\n+        format!(\"\\x00name_{},ctxt_{}\\x00\",\n                 self.name.uint(),\n                 self.ctxt)\n     }\n@@ -706,11 +706,11 @@ pub enum Expr_ {\n ///\n ///     <Vec<T> as SomeTrait>::SomeAssociatedItem\n ///      ^~~~~     ^~~~~~~~~   ^~~~~~~~~~~~~~~~~~\n-///      for_type  trait_name  item_name\n+///      self_type  trait_name  item_name\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct QPath {\n-    pub for_type: P<Ty>,\n-    pub trait_name: Path,\n+    pub self_type: P<Ty>,\n+    pub trait_ref: P<TraitRef>,\n     pub item_name: Ident,\n }\n \n@@ -838,7 +838,7 @@ impl TokenTree {\n                     tts: vec![TtToken(sp, token::Ident(token::str_to_ident(\"doc\"),\n                                                        token::Plain)),\n                               TtToken(sp, token::Eq),\n-                              TtToken(sp, token::LitStr(name))],\n+                              TtToken(sp, token::Literal(token::Str_(name), None))],\n                     close_span: sp,\n                 }))\n             }"}, {"sha": "472331bc9e15d645aec5592af9ea35abfbecf719", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -866,7 +866,7 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n         self.insert(lifetime.id, NodeLifetime(lifetime));\n     }\n \n-    fn visit_lifetime_decl(&mut self, def: &'ast LifetimeDef) {\n+    fn visit_lifetime_def(&mut self, def: &'ast LifetimeDef) {\n         self.visit_lifetime_ref(&def.lifetime);\n     }\n }"}, {"sha": "043e79bffd9e9cc7d574f5cc190ef66d631a88ad", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -535,7 +535,7 @@ impl<'a, 'v, O: IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O> {\n         self.operation.visit_id(lifetime.id);\n     }\n \n-    fn visit_lifetime_decl(&mut self, def: &'v LifetimeDef) {\n+    fn visit_lifetime_def(&mut self, def: &'v LifetimeDef) {\n         self.visit_lifetime_ref(&def.lifetime);\n     }\n }"}, {"sha": "281bde3129aba4e642a2479e827bd57f1328f952", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -87,7 +87,7 @@ pub fn expand_register_diagnostic<'cx>(ecx: &'cx mut ExtCtxt,\n         },\n         [ast::TtToken(_, token::Ident(ref code, _)),\n          ast::TtToken(_, token::Comma),\n-         ast::TtToken(_, token::LitStrRaw(description, _))] => {\n+         ast::TtToken(_, token::Literal(token::StrRaw(description, _), None))] => {\n             (code, Some(description))\n         }\n         _ => unreachable!()"}, {"sha": "8c70a95443bc92485d99594bf8c5988481fca90c", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -361,9 +361,6 @@ fn initial_syntax_expander_table(ecfg: &expand::ExpansionConfig) -> SyntaxEnv {\n     syntax_expanders.insert(intern(\"format_args\"),\n                             builtin_normal_expander(\n                                 ext::format::expand_format_args));\n-    syntax_expanders.insert(intern(\"format_args_method\"),\n-                            builtin_normal_expander(\n-                                ext::format::expand_format_args_method));\n     syntax_expanders.insert(intern(\"env\"),\n                             builtin_normal_expander(\n                                     ext::env::expand_env));"}, {"sha": "fcd4966683d3b3e16c4b971497ab973e6d7e1edd", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -335,7 +335,7 @@ pub fn combine_substructure<'a>(f: CombineSubstructureFunc<'a>)\n impl<'a> TraitDef<'a> {\n     pub fn expand(&self,\n                   cx: &mut ExtCtxt,\n-                  _mitem: &ast::MetaItem,\n+                  mitem: &ast::MetaItem,\n                   item: &ast::Item,\n                   push: |P<ast::Item>|) {\n         let newitem = match item.node {\n@@ -351,7 +351,10 @@ impl<'a> TraitDef<'a> {\n                                      item.ident,\n                                      generics)\n             }\n-            _ => return\n+            _ => {\n+                cx.span_err(mitem.span, \"`deriving` may only be applied to structs and enums\");\n+                return;\n+            }\n         };\n         // Keep the lint attributes of the previous item to control how the\n         // generated implementations are linted\n@@ -887,7 +890,7 @@ impl<'a> MethodDef<'a> {\n         // a series of let statements mapping each self_arg to a uint\n         // corresponding to its variant index.\n         let vi_idents: Vec<ast::Ident> = self_arg_names.iter()\n-            .map(|name| { let vi_suffix = format!(\"{:s}_vi\", name.as_slice());\n+            .map(|name| { let vi_suffix = format!(\"{}_vi\", name.as_slice());\n                           cx.ident_of(vi_suffix.as_slice()) })\n             .collect::<Vec<ast::Ident>>();\n "}, {"sha": "b04a800a32d2aace3c32eb1fb3a3a829a571d9fd", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 2, "deletions": 20, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -237,7 +237,7 @@ impl<'a, 'b> Context<'a, 'b> {\n         match arg {\n             Exact(arg) => {\n                 if self.args.len() <= arg {\n-                    let msg = format!(\"invalid reference to argument `{}` ({:s})\",\n+                    let msg = format!(\"invalid reference to argument `{}` ({})\",\n                                       arg, self.describe_num_args());\n \n                     self.ecx.span_err(self.fmtsp, msg.as_slice());\n@@ -670,17 +670,11 @@ impl<'a, 'b> Context<'a, 'b> {\n             Known(ref tyname) => {\n                 match tyname.as_slice() {\n                     \"\"  => \"Show\",\n-                    \"b\" => \"Bool\",\n-                    \"c\" => \"Char\",\n-                    \"d\" | \"i\" => \"Signed\",\n                     \"e\" => \"LowerExp\",\n                     \"E\" => \"UpperExp\",\n-                    \"f\" => \"Float\",\n                     \"o\" => \"Octal\",\n                     \"p\" => \"Pointer\",\n-                    \"s\" => \"String\",\n-                    \"t\" => \"Binary\",\n-                    \"u\" => \"Unsigned\",\n+                    \"b\" => \"Binary\",\n                     \"x\" => \"LowerHex\",\n                     \"X\" => \"UpperHex\",\n                     _ => {\n@@ -724,18 +718,6 @@ pub fn expand_format_args<'cx>(ecx: &'cx mut ExtCtxt, sp: Span,\n     }\n }\n \n-pub fn expand_format_args_method<'cx>(ecx: &'cx mut ExtCtxt, sp: Span,\n-                                      tts: &[ast::TokenTree]) -> Box<base::MacResult+'cx> {\n-\n-    match parse_args(ecx, sp, true, tts) {\n-        (invocation, Some((efmt, args, order, names))) => {\n-            MacExpr::new(expand_preparsed_format_args(ecx, sp, invocation, efmt,\n-                                                      args, order, names))\n-        }\n-        (_, None) => MacExpr::new(ecx.expr_uint(sp, 2))\n-    }\n-}\n-\n /// Take the various parts of `format_args!(extra, efmt, args...,\n /// name=names...)` and construct the appropriate formatting\n /// expression."}, {"sha": "2ddcab10cdafd7956888cdb465ae8fc0421a4b16", "filename": "src/libsyntax/ext/mtwt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibsyntax%2Fext%2Fmtwt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibsyntax%2Fext%2Fmtwt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmtwt.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -131,7 +131,7 @@ fn new_sctable_internal() -> SCTable {\n pub fn display_sctable(table: &SCTable) {\n     error!(\"SC table:\");\n     for (idx,val) in table.table.borrow().iter().enumerate() {\n-        error!(\"{:4u} : {}\",idx,val);\n+        error!(\"{:4} : {}\",idx,val);\n     }\n }\n "}, {"sha": "eaa3632cf499e558b77984b43c8242d9ffa7d447", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -542,6 +542,16 @@ fn mk_delim(cx: &ExtCtxt, sp: Span, delim: token::DelimToken) -> P<ast::Expr> {\n \n #[allow(non_upper_case_globals)]\n fn mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> P<ast::Expr> {\n+    macro_rules! mk_lit {\n+        ($name: expr, $suffix: expr, $($args: expr),*) => {{\n+            let inner = cx.expr_call(sp, mk_token_path(cx, sp, $name), vec![$($args),*]);\n+            let suffix = match $suffix {\n+                Some(name) => cx.expr_some(sp, mk_name(cx, sp, ast::Ident::new(name))),\n+                None => cx.expr_none(sp)\n+            };\n+            cx.expr_call(sp, mk_token_path(cx, sp, \"Literal\"), vec![inner, suffix])\n+        }}\n+    }\n     match *tok {\n         token::BinOp(binop) => {\n             return cx.expr_call(sp, mk_token_path(cx, sp, \"BinOp\"), vec!(mk_binop(cx, sp, binop)));\n@@ -560,38 +570,32 @@ fn mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> P<ast::Expr> {\n                                 vec![mk_delim(cx, sp, delim)]);\n         }\n \n-        token::LitByte(i) => {\n+        token::Literal(token::Byte(i), suf) => {\n             let e_byte = mk_name(cx, sp, i.ident());\n-\n-            return cx.expr_call(sp, mk_token_path(cx, sp, \"LitByte\"), vec!(e_byte));\n+            return mk_lit!(\"Byte\", suf, e_byte);\n         }\n \n-        token::LitChar(i) => {\n+        token::Literal(token::Char(i), suf) => {\n             let e_char = mk_name(cx, sp, i.ident());\n-\n-            return cx.expr_call(sp, mk_token_path(cx, sp, \"LitChar\"), vec!(e_char));\n+            return mk_lit!(\"Char\", suf, e_char);\n         }\n \n-        token::LitInteger(i) => {\n+        token::Literal(token::Integer(i), suf) => {\n             let e_int = mk_name(cx, sp, i.ident());\n-            return cx.expr_call(sp, mk_token_path(cx, sp, \"LitInteger\"), vec!(e_int));\n+            return mk_lit!(\"Integer\", suf, e_int);\n         }\n \n-        token::LitFloat(fident) => {\n+        token::Literal(token::Float(fident), suf) => {\n             let e_fident = mk_name(cx, sp, fident.ident());\n-            return cx.expr_call(sp, mk_token_path(cx, sp, \"LitFloat\"), vec!(e_fident));\n+            return mk_lit!(\"Float\", suf, e_fident);\n         }\n \n-        token::LitStr(ident) => {\n-            return cx.expr_call(sp,\n-                                mk_token_path(cx, sp, \"LitStr\"),\n-                                vec!(mk_name(cx, sp, ident.ident())));\n+        token::Literal(token::Str_(ident), suf) => {\n+            return mk_lit!(\"Str_\", suf, mk_name(cx, sp, ident.ident()))\n         }\n \n-        token::LitStrRaw(ident, n) => {\n-            return cx.expr_call(sp,\n-                                mk_token_path(cx, sp, \"LitStrRaw\"),\n-                                vec!(mk_name(cx, sp, ident.ident()), cx.expr_uint(sp, n)));\n+        token::Literal(token::StrRaw(ident, n), suf) => {\n+            return mk_lit!(\"StrRaw\", suf, mk_name(cx, sp, ident.ident()), cx.expr_uint(sp, n))\n         }\n \n         token::Ident(ident, style) => {"}, {"sha": "460a94a8d5aaa2a9ca1cdd76ffb5f3c1b45a44d3", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -141,8 +141,8 @@ impl<'a> Context<'a> {\n }\n \n impl<'a, 'v> Visitor<'v> for Context<'a> {\n-    fn visit_ident(&mut self, sp: Span, id: ast::Ident) {\n-        if !token::get_ident(id).get().is_ascii() {\n+    fn visit_name(&mut self, sp: Span, name: ast::Name) {\n+        if !token::get_name(name).get().is_ascii() {\n             self.gate_feature(\"non_ascii_idents\", sp,\n                               \"non-ascii idents are not fully supported.\");\n         }"}, {"sha": "2e6ee49f0ff72200c2ce9d239831274cbda5f661", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -142,6 +142,10 @@ pub trait Folder {\n         noop_fold_ty(t, self)\n     }\n \n+    fn fold_qpath(&mut self, t: P<QPath>) -> P<QPath> {\n+        noop_fold_qpath(t, self)\n+    }\n+\n     fn fold_mod(&mut self, m: Mod) -> Mod {\n         noop_fold_mod(m, self)\n     }\n@@ -435,12 +439,8 @@ pub fn noop_fold_ty<T: Folder>(t: P<Ty>, fld: &mut T) -> P<Ty> {\n                         fld.fold_opt_bounds(bounds),\n                         id)\n             }\n-            TyQPath(ref qpath) => {\n-                TyQPath(P(QPath {\n-                    for_type: fld.fold_ty(qpath.for_type.clone()),\n-                    trait_name: fld.fold_path(qpath.trait_name.clone()),\n-                    item_name: fld.fold_ident(qpath.item_name.clone()),\n-                }))\n+            TyQPath(qpath) => {\n+                TyQPath(fld.fold_qpath(qpath))\n             }\n             TyFixedLengthVec(ty, e) => {\n                 TyFixedLengthVec(fld.fold_ty(ty), fld.fold_expr(e))\n@@ -456,6 +456,16 @@ pub fn noop_fold_ty<T: Folder>(t: P<Ty>, fld: &mut T) -> P<Ty> {\n     })\n }\n \n+pub fn noop_fold_qpath<T: Folder>(qpath: P<QPath>, fld: &mut T) -> P<QPath> {\n+    qpath.map(|qpath| {\n+        QPath {\n+            self_type: fld.fold_ty(qpath.self_type),\n+            trait_ref: qpath.trait_ref.map(|tr| fld.fold_trait_ref(tr)),\n+            item_name: fld.fold_ident(qpath.item_name),\n+        }\n+    })\n+}\n+\n pub fn noop_fold_foreign_mod<T: Folder>(ForeignMod {abi, view_items, items}: ForeignMod,\n                                         fld: &mut T) -> ForeignMod {\n     ForeignMod {"}, {"sha": "fbca4868255ff92353af1b88584ea3bd4d4f0eb9", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 85, "deletions": 94, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -369,6 +369,25 @@ impl<'a> StringReader<'a> {\n         self.nextnextch() == Some(c)\n     }\n \n+    /// Eats <XID_start><XID_continue>*, if possible.\n+    fn scan_optional_raw_name(&mut self) -> Option<ast::Name> {\n+        if !ident_start(self.curr) {\n+            return None\n+        }\n+        let start = self.last_pos;\n+        while ident_continue(self.curr) {\n+            self.bump();\n+        }\n+\n+        self.with_str_from(start, |string| {\n+            if string == \"_\" {\n+                None\n+            } else {\n+                Some(token::intern(string))\n+            }\n+        })\n+    }\n+\n     /// PRECONDITION: self.curr is not whitespace\n     /// Eats any kind of comment.\n     fn scan_comment(&mut self) -> Option<TokenAndSpan> {\n@@ -638,7 +657,7 @@ impl<'a> StringReader<'a> {\n     }\n \n     /// Lex a LIT_INTEGER or a LIT_FLOAT\n-    fn scan_number(&mut self, c: char) -> token::Token {\n+    fn scan_number(&mut self, c: char) -> token::Lit {\n         let mut num_digits;\n         let mut base = 10;\n         let start_bpos = self.last_pos;\n@@ -653,19 +672,9 @@ impl<'a> StringReader<'a> {\n                 '0'...'9' | '_' | '.' => {\n                     num_digits = self.scan_digits(10) + 1;\n                 }\n-                'u' | 'i' => {\n-                    self.scan_int_suffix();\n-                    return token::LitInteger(self.name_from(start_bpos));\n-                },\n-                'f' => {\n-                    let last_pos = self.last_pos;\n-                    self.scan_float_suffix();\n-                    self.check_float_base(start_bpos, last_pos, base);\n-                    return token::LitFloat(self.name_from(start_bpos));\n-                }\n                 _ => {\n                     // just a 0\n-                    return token::LitInteger(self.name_from(start_bpos));\n+                    return token::Integer(self.name_from(start_bpos));\n                 }\n             }\n         } else if c.is_digit_radix(10) {\n@@ -676,9 +685,7 @@ impl<'a> StringReader<'a> {\n \n         if num_digits == 0 {\n             self.err_span_(start_bpos, self.last_pos, \"no valid digits found for number\");\n-            // eat any suffix\n-            self.scan_int_suffix();\n-            return token::LitInteger(token::intern(\"0\"));\n+            return token::Integer(token::intern(\"0\"));\n         }\n \n         // might be a float, but don't be greedy if this is actually an\n@@ -692,29 +699,20 @@ impl<'a> StringReader<'a> {\n             if self.curr.unwrap_or('\\0').is_digit_radix(10) {\n                 self.scan_digits(10);\n                 self.scan_float_exponent();\n-                self.scan_float_suffix();\n             }\n             let last_pos = self.last_pos;\n             self.check_float_base(start_bpos, last_pos, base);\n-            return token::LitFloat(self.name_from(start_bpos));\n-        } else if self.curr_is('f') {\n-            // or it might be an integer literal suffixed as a float\n-            self.scan_float_suffix();\n-            let last_pos = self.last_pos;\n-            self.check_float_base(start_bpos, last_pos, base);\n-            return token::LitFloat(self.name_from(start_bpos));\n+            return token::Float(self.name_from(start_bpos));\n         } else {\n             // it might be a float if it has an exponent\n             if self.curr_is('e') || self.curr_is('E') {\n                 self.scan_float_exponent();\n-                self.scan_float_suffix();\n                 let last_pos = self.last_pos;\n                 self.check_float_base(start_bpos, last_pos, base);\n-                return token::LitFloat(self.name_from(start_bpos));\n+                return token::Float(self.name_from(start_bpos));\n             }\n             // but we certainly have an integer!\n-            self.scan_int_suffix();\n-            return token::LitInteger(self.name_from(start_bpos));\n+            return token::Integer(self.name_from(start_bpos));\n         }\n     }\n \n@@ -850,55 +848,6 @@ impl<'a> StringReader<'a> {\n         true\n     }\n \n-    /// Scan over an int literal suffix.\n-    fn scan_int_suffix(&mut self) {\n-        match self.curr {\n-            Some('i') | Some('u') => {\n-                self.bump();\n-\n-                if self.curr_is('8') {\n-                    self.bump();\n-                } else if self.curr_is('1') {\n-                    if !self.nextch_is('6') {\n-                        self.err_span_(self.last_pos, self.pos,\n-                                      \"illegal int suffix\");\n-                    } else {\n-                        self.bump(); self.bump();\n-                    }\n-                } else if self.curr_is('3') {\n-                    if !self.nextch_is('2') {\n-                        self.err_span_(self.last_pos, self.pos,\n-                                      \"illegal int suffix\");\n-                    } else {\n-                        self.bump(); self.bump();\n-                    }\n-                } else if self.curr_is('6') {\n-                    if !self.nextch_is('4') {\n-                        self.err_span_(self.last_pos, self.pos,\n-                                      \"illegal int suffix\");\n-                    } else {\n-                        self.bump(); self.bump();\n-                    }\n-                }\n-            },\n-            _ => { }\n-        }\n-    }\n-\n-    /// Scan over a float literal suffix\n-    fn scan_float_suffix(&mut self) {\n-        if self.curr_is('f') {\n-            if (self.nextch_is('3') && self.nextnextch_is('2'))\n-            || (self.nextch_is('6') && self.nextnextch_is('4')) {\n-                self.bump();\n-                self.bump();\n-                self.bump();\n-            } else {\n-                self.err_span_(self.last_pos, self.pos, \"illegal float suffix\");\n-            }\n-        }\n-    }\n-\n     /// Scan over a float exponent.\n     fn scan_float_exponent(&mut self) {\n         if self.curr_is('e') || self.curr_is('E') {\n@@ -967,7 +916,10 @@ impl<'a> StringReader<'a> {\n         }\n \n         if is_dec_digit(c) {\n-            return self.scan_number(c.unwrap());\n+            let num = self.scan_number(c.unwrap());\n+            let suffix = self.scan_optional_raw_name();\n+            debug!(\"next_token_inner: scanned number {}, {}\", num, suffix);\n+            return token::Literal(num, suffix)\n         }\n \n         if self.read_embedded_ident {\n@@ -1126,17 +1078,19 @@ impl<'a> StringReader<'a> {\n             }\n             let id = if valid { self.name_from(start) } else { token::intern(\"0\") };\n             self.bump(); // advance curr past token\n-            return token::LitChar(id);\n+            let suffix = self.scan_optional_raw_name();\n+            return token::Literal(token::Char(id), suffix);\n           }\n           'b' => {\n             self.bump();\n-            return match self.curr {\n+            let lit = match self.curr {\n                 Some('\\'') => self.scan_byte(),\n                 Some('\"') => self.scan_byte_string(),\n                 Some('r') => self.scan_raw_byte_string(),\n                 _ => unreachable!()  // Should have been a token::Ident above.\n             };\n-\n+            let suffix = self.scan_optional_raw_name();\n+            return token::Literal(lit, suffix);\n           }\n           '\"' => {\n             let start_bpos = self.last_pos;\n@@ -1157,7 +1111,8 @@ impl<'a> StringReader<'a> {\n             let id = if valid { self.name_from(start_bpos + BytePos(1)) }\n                      else { token::intern(\"??\") };\n             self.bump();\n-            return token::LitStr(id);\n+            let suffix = self.scan_optional_raw_name();\n+            return token::Literal(token::Str_(id), suffix);\n           }\n           'r' => {\n             let start_bpos = self.last_pos;\n@@ -1224,7 +1179,8 @@ impl<'a> StringReader<'a> {\n             } else {\n                 token::intern(\"??\")\n             };\n-            return token::LitStrRaw(id, hash_count);\n+            let suffix = self.scan_optional_raw_name();\n+            return token::Literal(token::StrRaw(id, hash_count), suffix);\n           }\n           '-' => {\n             if self.nextch_is('>') {\n@@ -1293,7 +1249,7 @@ impl<'a> StringReader<'a> {\n      || (self.curr_is('#') && self.nextch_is('!') && !self.nextnextch_is('['))\n     }\n \n-    fn scan_byte(&mut self) -> token::Token {\n+    fn scan_byte(&mut self) -> token::Lit {\n         self.bump();\n         let start = self.last_pos;\n \n@@ -1314,10 +1270,10 @@ impl<'a> StringReader<'a> {\n \n         let id = if valid { self.name_from(start) } else { token::intern(\"??\") };\n         self.bump(); // advance curr past token\n-        return token::LitByte(id);\n+        return token::Byte(id);\n     }\n \n-    fn scan_byte_string(&mut self) -> token::Token {\n+    fn scan_byte_string(&mut self) -> token::Lit {\n         self.bump();\n         let start = self.last_pos;\n         let mut valid = true;\n@@ -1336,10 +1292,10 @@ impl<'a> StringReader<'a> {\n         }\n         let id = if valid { self.name_from(start) } else { token::intern(\"??\") };\n         self.bump();\n-        return token::LitBinary(id);\n+        return token::Binary(id);\n     }\n \n-    fn scan_raw_byte_string(&mut self) -> token::Token {\n+    fn scan_raw_byte_string(&mut self) -> token::Lit {\n         let start_bpos = self.last_pos;\n         self.bump();\n         let mut hash_count = 0u;\n@@ -1387,8 +1343,9 @@ impl<'a> StringReader<'a> {\n             self.bump();\n         }\n         self.bump();\n-        return token::LitBinaryRaw(self.name_from_to(content_start_bpos, content_end_bpos),\n-                                     hash_count);\n+        return token::BinaryRaw(self.name_from_to(content_start_bpos,\n+                                                  content_end_bpos),\n+                                hash_count);\n     }\n }\n \n@@ -1535,17 +1492,17 @@ mod test {\n \n     #[test] fn character_a() {\n         assert_eq!(setup(&mk_sh(), \"'a'\".to_string()).next_token().tok,\n-                   token::LitChar(token::intern(\"a\")));\n+                   token::Literal(token::Char(token::intern(\"a\")), None));\n     }\n \n     #[test] fn character_space() {\n         assert_eq!(setup(&mk_sh(), \"' '\".to_string()).next_token().tok,\n-                   token::LitChar(token::intern(\" \")));\n+                   token::Literal(token::Char(token::intern(\" \")), None));\n     }\n \n     #[test] fn character_escaped() {\n         assert_eq!(setup(&mk_sh(), \"'\\\\n'\".to_string()).next_token().tok,\n-                   token::LitChar(token::intern(\"\\\\n\")));\n+                   token::Literal(token::Char(token::intern(\"\\\\n\")), None));\n     }\n \n     #[test] fn lifetime_name() {\n@@ -1557,7 +1514,41 @@ mod test {\n         assert_eq!(setup(&mk_sh(),\n                          \"r###\\\"\\\"#a\\\\b\\x00c\\\"\\\"###\".to_string()).next_token()\n                                                                  .tok,\n-                   token::LitStrRaw(token::intern(\"\\\"#a\\\\b\\x00c\\\"\"), 3));\n+                   token::Literal(token::StrRaw(token::intern(\"\\\"#a\\\\b\\x00c\\\"\"), 3), None));\n+    }\n+\n+    #[test] fn literal_suffixes() {\n+        macro_rules! test {\n+            ($input: expr, $tok_type: ident, $tok_contents: expr) => {{\n+                assert_eq!(setup(&mk_sh(), format!(\"{}suffix\", $input)).next_token().tok,\n+                           token::Literal(token::$tok_type(token::intern($tok_contents)),\n+                                          Some(token::intern(\"suffix\"))));\n+                // with a whitespace separator:\n+                assert_eq!(setup(&mk_sh(), format!(\"{} suffix\", $input)).next_token().tok,\n+                           token::Literal(token::$tok_type(token::intern($tok_contents)),\n+                                          None));\n+            }}\n+        }\n+\n+        test!(\"'a'\", Char, \"a\");\n+        test!(\"b'a'\", Byte, \"a\");\n+        test!(\"\\\"a\\\"\", Str_, \"a\");\n+        test!(\"b\\\"a\\\"\", Binary, \"a\");\n+        test!(\"1234\", Integer, \"1234\");\n+        test!(\"0b101\", Integer, \"0b101\");\n+        test!(\"0xABC\", Integer, \"0xABC\");\n+        test!(\"1.0\", Float, \"1.0\");\n+        test!(\"1.0e10\", Float, \"1.0e10\");\n+\n+        assert_eq!(setup(&mk_sh(), \"2u\".to_string()).next_token().tok,\n+                   token::Literal(token::Integer(token::intern(\"2\")),\n+                                  Some(token::intern(\"u\"))));\n+        assert_eq!(setup(&mk_sh(), \"r###\\\"raw\\\"###suffix\".to_string()).next_token().tok,\n+                   token::Literal(token::StrRaw(token::intern(\"raw\"), 3),\n+                                  Some(token::intern(\"suffix\"))));\n+        assert_eq!(setup(&mk_sh(), \"br###\\\"raw\\\"###suffix\".to_string()).next_token().tok,\n+                   token::Literal(token::BinaryRaw(token::intern(\"raw\"), 3),\n+                                  Some(token::intern(\"suffix\"))));\n     }\n \n     #[test] fn line_doc_comments() {\n@@ -1573,7 +1564,7 @@ mod test {\n             token::Comment => { },\n             _ => panic!(\"expected a comment!\")\n         }\n-        assert_eq!(lexer.next_token().tok, token::LitChar(token::intern(\"a\")));\n+        assert_eq!(lexer.next_token().tok, token::Literal(token::Char(token::intern(\"a\")), None));\n     }\n \n }"}, {"sha": "96659031e6a37db4aa2c7bbfd424d1d84df8c124", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 76, "deletions": 69, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -511,28 +511,41 @@ pub fn raw_str_lit(lit: &str) -> String {\n     res\n }\n \n-pub fn float_lit(s: &str) -> ast::Lit_ {\n-    debug!(\"float_lit: {}\", s);\n-    // FIXME #2252: bounds checking float literals is defered until trans\n-    let s2 = s.chars().filter(|&c| c != '_').collect::<String>();\n-    let s = s2.as_slice();\n-\n-    let mut ty = None;\n-\n-    if s.ends_with(\"f32\") {\n-        ty = Some(ast::TyF32);\n-    } else if s.ends_with(\"f64\") {\n-        ty = Some(ast::TyF64);\n-    }\n+// check if `s` looks like i32 or u1234 etc.\n+fn looks_like_width_suffix(first_chars: &[char], s: &str) -> bool {\n+    s.len() > 1 &&\n+        first_chars.contains(&s.char_at(0)) &&\n+        s.slice_from(1).chars().all(|c| '0' <= c && c <= '9')\n+}\n \n+fn filtered_float_lit(data: token::InternedString, suffix: Option<&str>,\n+                      sd: &SpanHandler, sp: Span) -> ast::Lit_ {\n+    debug!(\"filtered_float_lit: {}, {}\", data, suffix);\n+    match suffix {\n+        Some(\"f32\") => ast::LitFloat(data, ast::TyF32),\n+        Some(\"f64\") => ast::LitFloat(data, ast::TyF64),\n+        Some(suf) => {\n+            if suf.len() >= 2 && looks_like_width_suffix(&['f'], suf) {\n+                // if it looks like a width, lets try to be helpful.\n+                sd.span_err(sp, &*format!(\"illegal width `{}` for float literal, \\\n+                                          valid widths are 32 and 64\", suf.slice_from(1)));\n+            } else {\n+                sd.span_err(sp, &*format!(\"illegal suffix `{}` for float literal, \\\n+                                          valid suffixes are `f32` and `f64`\", suf));\n+            }\n \n-    match ty {\n-        Some(t) => {\n-            ast::LitFloat(token::intern_and_get_ident(s.slice_to(s.len() - t.suffix_len())), t)\n-        },\n-        None => ast::LitFloatUnsuffixed(token::intern_and_get_ident(s))\n+            ast::LitFloatUnsuffixed(data)\n+        }\n+        None => ast::LitFloatUnsuffixed(data)\n     }\n }\n+pub fn float_lit(s: &str, suffix: Option<&str>, sd: &SpanHandler, sp: Span) -> ast::Lit_ {\n+    debug!(\"float_lit: {}, {}\", s, suffix);\n+    // FIXME #2252: bounds checking float literals is defered until trans\n+    let s = s.chars().filter(|&c| c != '_').collect::<String>();\n+    let data = token::intern_and_get_ident(&*s);\n+    filtered_float_lit(data, suffix, sd, sp)\n+}\n \n /// Parse a string representing a byte literal into its final form. Similar to `char_lit`\n pub fn byte_lit(lit: &str) -> (u8, uint) {\n@@ -626,24 +639,19 @@ pub fn binary_lit(lit: &str) -> Rc<Vec<u8>> {\n     Rc::new(res)\n }\n \n-pub fn integer_lit(s: &str, sd: &SpanHandler, sp: Span) -> ast::Lit_ {\n+pub fn integer_lit(s: &str, suffix: Option<&str>, sd: &SpanHandler, sp: Span) -> ast::Lit_ {\n     // s can only be ascii, byte indexing is fine\n \n     let s2 = s.chars().filter(|&c| c != '_').collect::<String>();\n     let mut s = s2.as_slice();\n \n-    debug!(\"parse_integer_lit: {}\", s);\n-\n-    if s.len() == 1 {\n-        let n = (s.char_at(0)).to_digit(10).unwrap();\n-        return ast::LitInt(n as u64, ast::UnsuffixedIntLit(ast::Sign::new(n)));\n-    }\n+    debug!(\"integer_lit: {}, {}\", s, suffix);\n \n     let mut base = 10;\n     let orig = s;\n     let mut ty = ast::UnsuffixedIntLit(ast::Plus);\n \n-    if s.char_at(0) == '0' {\n+    if s.char_at(0) == '0' && s.len() > 1 {\n         match s.char_at(1) {\n             'x' => base = 16,\n             'o' => base = 8,\n@@ -652,57 +660,56 @@ pub fn integer_lit(s: &str, sd: &SpanHandler, sp: Span) -> ast::Lit_ {\n         }\n     }\n \n+    // 1f64 and 2f32 etc. are valid float literals.\n+    match suffix {\n+        Some(suf) if looks_like_width_suffix(&['f'], suf) => {\n+            match base {\n+                16u => sd.span_err(sp, \"hexadecimal float literal is not supported\"),\n+                8u => sd.span_err(sp, \"octal float literal is not supported\"),\n+                2u => sd.span_err(sp, \"binary float literal is not supported\"),\n+                _ => ()\n+            }\n+            let ident = token::intern_and_get_ident(&*s);\n+            return filtered_float_lit(ident, suffix, sd, sp)\n+        }\n+        _ => {}\n+    }\n+\n     if base != 10 {\n         s = s.slice_from(2);\n     }\n \n-    let last = s.len() - 1;\n-    match s.char_at(last) {\n-        'i' => ty = ast::SignedIntLit(ast::TyI, ast::Plus),\n-        'u' => ty = ast::UnsignedIntLit(ast::TyU),\n-        '8' => {\n-            if s.len() > 2 {\n-                match s.char_at(last - 1) {\n-                    'i' => ty = ast::SignedIntLit(ast::TyI8, ast::Plus),\n-                    'u' => ty = ast::UnsignedIntLit(ast::TyU8),\n-                    _ => { }\n-                }\n-            }\n-        },\n-        '6' => {\n-            if s.len() > 3 && s.char_at(last - 1) == '1' {\n-                match s.char_at(last - 2) {\n-                    'i' => ty = ast::SignedIntLit(ast::TyI16, ast::Plus),\n-                    'u' => ty = ast::UnsignedIntLit(ast::TyU16),\n-                    _ => { }\n-                }\n-            }\n-        },\n-        '2' => {\n-            if s.len() > 3 && s.char_at(last - 1) == '3' {\n-                match s.char_at(last - 2) {\n-                    'i' => ty = ast::SignedIntLit(ast::TyI32, ast::Plus),\n-                    'u' => ty = ast::UnsignedIntLit(ast::TyU32),\n-                    _ => { }\n-                }\n-            }\n-        },\n-        '4' => {\n-            if s.len() > 3 && s.char_at(last - 1) == '6' {\n-                match s.char_at(last - 2) {\n-                    'i' => ty = ast::SignedIntLit(ast::TyI64, ast::Plus),\n-                    'u' => ty = ast::UnsignedIntLit(ast::TyU64),\n-                    _ => { }\n+    if let Some(suf) = suffix {\n+        if suf.is_empty() { sd.span_bug(sp, \"found empty literal suffix in Some\")}\n+        ty = match suf {\n+            \"i\"   => ast::SignedIntLit(ast::TyI, ast::Plus),\n+            \"i8\"  => ast::SignedIntLit(ast::TyI8, ast::Plus),\n+            \"i16\" => ast::SignedIntLit(ast::TyI16, ast::Plus),\n+            \"i32\" => ast::SignedIntLit(ast::TyI32, ast::Plus),\n+            \"i64\" => ast::SignedIntLit(ast::TyI64, ast::Plus),\n+            \"u\"   => ast::UnsignedIntLit(ast::TyU),\n+            \"u8\"  => ast::UnsignedIntLit(ast::TyU8),\n+            \"u16\" => ast::UnsignedIntLit(ast::TyU16),\n+            \"u32\" => ast::UnsignedIntLit(ast::TyU32),\n+            \"u64\" => ast::UnsignedIntLit(ast::TyU64),\n+            _ => {\n+                // i<digits> and u<digits> look like widths, so lets\n+                // give an error message along those lines\n+                if looks_like_width_suffix(&['i', 'u'], suf) {\n+                    sd.span_err(sp, &*format!(\"illegal width `{}` for integer literal; \\\n+                                              valid widths are 8, 16, 32 and 64\",\n+                                              suf.slice_from(1)));\n+                } else {\n+                    sd.span_err(sp, &*format!(\"illegal suffix `{}` for numeric literal\", suf));\n                 }\n+\n+                ty\n             }\n-        },\n-        _ => { }\n+        }\n     }\n \n-    debug!(\"The suffix is {}, base {}, the new string is {}, the original \\\n-           string was {}\", ty, base, s, orig);\n-\n-    s = s.slice_to(s.len() - ty.suffix_len());\n+    debug!(\"integer_lit: the type is {}, base {}, the new string is {}, the original \\\n+           string was {}, the original suffix was {}\", ty, base, s, orig, suffix);\n \n     let res: u64 = match ::std::num::from_str_radix(s, base) {\n         Some(r) => r,"}, {"sha": "a6fe3902395454803910ace6547023216846afe3", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 97, "deletions": 35, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -646,6 +646,20 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    pub fn expect_no_suffix(&mut self, sp: Span, kind: &str, suffix: Option<ast::Name>) {\n+        match suffix {\n+            None => {/* everything ok */}\n+            Some(suf) => {\n+                let text = suf.as_str();\n+                if text.is_empty() {\n+                    self.span_bug(sp, \"found empty literal suffix in Some\")\n+                }\n+                self.span_err(sp, &*format!(\"{} with a suffix is illegal\", kind));\n+            }\n+        }\n+    }\n+\n+\n     /// Attempt to consume a `<`. If `<<` is seen, replace it with a single\n     /// `<` and continue. If a `<` is not seen, return false.\n     ///\n@@ -968,6 +982,9 @@ impl<'a> Parser<'a> {\n     pub fn span_err(&mut self, sp: Span, m: &str) {\n         self.sess.span_diagnostic.span_err(sp, m)\n     }\n+    pub fn span_bug(&mut self, sp: Span, m: &str) -> ! {\n+        self.sess.span_diagnostic.span_bug(sp, m)\n+    }\n     pub fn abort_if_errors(&mut self) {\n         self.sess.span_diagnostic.handler().abort_if_errors();\n     }\n@@ -1502,17 +1519,17 @@ impl<'a> Parser<'a> {\n         } else if self.eat_keyword(keywords::Proc) {\n             self.parse_proc_type(Vec::new())\n         } else if self.token == token::Lt {\n-            // QUALIFIED PATH\n+            // QUALIFIED PATH `<TYPE as TRAIT_REF>::item`\n             self.bump();\n-            let for_type = self.parse_ty(true);\n+            let self_type = self.parse_ty(true);\n             self.expect_keyword(keywords::As);\n-            let trait_name = self.parse_path(LifetimeAndTypesWithoutColons);\n+            let trait_ref = self.parse_trait_ref();\n             self.expect(&token::Gt);\n             self.expect(&token::ModSep);\n             let item_name = self.parse_ident();\n             TyQPath(P(QPath {\n-                for_type: for_type,\n-                trait_name: trait_name.path,\n+                self_type: self_type,\n+                trait_ref: P(trait_ref),\n                 item_name: item_name,\n             }))\n         } else if self.token == token::ModSep ||\n@@ -1640,24 +1657,53 @@ impl<'a> Parser<'a> {\n     /// Matches token_lit = LIT_INTEGER | ...\n     pub fn lit_from_token(&mut self, tok: &token::Token) -> Lit_ {\n         match *tok {\n-            token::LitByte(i) => LitByte(parse::byte_lit(i.as_str()).val0()),\n-            token::LitChar(i) => LitChar(parse::char_lit(i.as_str()).val0()),\n-            token::LitInteger(s) => parse::integer_lit(s.as_str(),\n-                                                        &self.sess.span_diagnostic,\n-                                                       self.last_span),\n-            token::LitFloat(s) => parse::float_lit(s.as_str()),\n-            token::LitStr(s) => {\n-                LitStr(token::intern_and_get_ident(parse::str_lit(s.as_str()).as_slice()),\n-                       ast::CookedStr)\n-            }\n-            token::LitStrRaw(s, n) => {\n-                LitStr(token::intern_and_get_ident(parse::raw_str_lit(s.as_str()).as_slice()),\n-                       ast::RawStr(n))\n+            token::Literal(lit, suf) => {\n+                let (suffix_illegal, out) = match lit {\n+                    token::Byte(i) => (true, LitByte(parse::byte_lit(i.as_str()).val0())),\n+                    token::Char(i) => (true, LitChar(parse::char_lit(i.as_str()).val0())),\n+\n+                    // there are some valid suffixes for integer and\n+                    // float literals, so all the handling is done\n+                    // internally.\n+                    token::Integer(s) => {\n+                        (false, parse::integer_lit(s.as_str(),\n+                                                   suf.as_ref().map(|s| s.as_str()),\n+                                                   &self.sess.span_diagnostic,\n+                                                   self.last_span))\n+                    }\n+                    token::Float(s) => {\n+                        (false, parse::float_lit(s.as_str(),\n+                                                 suf.as_ref().map(|s| s.as_str()),\n+                                                  &self.sess.span_diagnostic,\n+                                                 self.last_span))\n+                    }\n+\n+                    token::Str_(s) => {\n+                        (true,\n+                         LitStr(token::intern_and_get_ident(parse::str_lit(s.as_str()).as_slice()),\n+                                ast::CookedStr))\n+                    }\n+                    token::StrRaw(s, n) => {\n+                        (true,\n+                         LitStr(\n+                            token::intern_and_get_ident(\n+                                parse::raw_str_lit(s.as_str()).as_slice()),\n+                            ast::RawStr(n)))\n+                    }\n+                    token::Binary(i) =>\n+                        (true, LitBinary(parse::binary_lit(i.as_str()))),\n+                    token::BinaryRaw(i, _) =>\n+                        (true,\n+                         LitBinary(Rc::new(i.as_str().as_bytes().iter().map(|&x| x).collect()))),\n+                };\n+\n+                if suffix_illegal {\n+                    let sp = self.last_span;\n+                    self.expect_no_suffix(sp, &*format!(\"{} literal\", lit.short_name()), suf)\n+                }\n+\n+                out\n             }\n-            token::LitBinary(i) =>\n-                LitBinary(parse::binary_lit(i.as_str())),\n-            token::LitBinaryRaw(i, _) =>\n-                LitBinary(Rc::new(i.as_str().as_bytes().iter().map(|&x| x).collect())),\n             _ => { self.unexpected_last(tok); }\n         }\n     }\n@@ -2424,7 +2470,10 @@ impl<'a> Parser<'a> {\n                         }\n                     }\n                   }\n-                  token::LitInteger(n) => {\n+                  token::Literal(token::Integer(n), suf) => {\n+                    let sp = self.span;\n+                    self.expect_no_suffix(sp, \"tuple index\", suf);\n+\n                     let index = n.as_str();\n                     let dot = self.last_span.hi;\n                     hi = self.span.hi;\n@@ -2449,7 +2498,7 @@ impl<'a> Parser<'a> {\n                         }\n                     }\n                   }\n-                  token::LitFloat(n) => {\n+                  token::Literal(token::Float(n), _suf) => {\n                     self.bump();\n                     let last_span = self.last_span;\n                     let fstr = n.as_str();\n@@ -5085,12 +5134,17 @@ impl<'a> Parser<'a> {\n                 self.expect(&token::Semi);\n                 (path, the_ident)\n             },\n-            token::LitStr(..) | token::LitStrRaw(..) => {\n-                let path = self.parse_str();\n+            token::Literal(token::Str_(..), suf) | token::Literal(token::StrRaw(..), suf) => {\n+                let sp = self.span;\n+                self.expect_no_suffix(sp, \"extern crate name\", suf);\n+                // forgo the internal suffix check of `parse_str` to\n+                // avoid repeats (this unwrap will always succeed due\n+                // to the restriction of the `match`)\n+                let (s, style, _) = self.parse_optional_str().unwrap();\n                 self.expect_keyword(keywords::As);\n                 let the_ident = self.parse_ident();\n                 self.expect(&token::Semi);\n-                (Some(path), the_ident)\n+                (Some((s, style)), the_ident)\n             },\n             _ => {\n                 let span = self.span;\n@@ -5267,7 +5321,9 @@ impl<'a> Parser<'a> {\n     /// the `extern` keyword, if one is found.\n     fn parse_opt_abi(&mut self) -> Option<abi::Abi> {\n         match self.token {\n-            token::LitStr(s) | token::LitStrRaw(s, _) => {\n+            token::Literal(token::Str_(s), suf) | token::Literal(token::StrRaw(s, _), suf) => {\n+                let sp = self.span;\n+                self.expect_no_suffix(sp, \"ABI spec\", suf);\n                 self.bump();\n                 let the_string = s.as_str();\n                 match abi::lookup(the_string) {\n@@ -5910,21 +5966,27 @@ impl<'a> Parser<'a> {\n     }\n \n     pub fn parse_optional_str(&mut self)\n-                              -> Option<(InternedString, ast::StrStyle)> {\n-        let (s, style) = match self.token {\n-            token::LitStr(s) => (self.id_to_interned_str(s.ident()), ast::CookedStr),\n-            token::LitStrRaw(s, n) => {\n-                (self.id_to_interned_str(s.ident()), ast::RawStr(n))\n+                              -> Option<(InternedString, ast::StrStyle, Option<ast::Name>)> {\n+        let ret = match self.token {\n+            token::Literal(token::Str_(s), suf) => {\n+                (self.id_to_interned_str(s.ident()), ast::CookedStr, suf)\n+            }\n+            token::Literal(token::StrRaw(s, n), suf) => {\n+                (self.id_to_interned_str(s.ident()), ast::RawStr(n), suf)\n             }\n             _ => return None\n         };\n         self.bump();\n-        Some((s, style))\n+        Some(ret)\n     }\n \n     pub fn parse_str(&mut self) -> (InternedString, StrStyle) {\n         match self.parse_optional_str() {\n-            Some(s) => { s }\n+            Some((s, style, suf)) => {\n+                let sp = self.last_span;\n+                self.expect_no_suffix(sp, \"str literal\", suf);\n+                (s, style)\n+            }\n             _ =>  self.fatal(\"expected string literal\")\n         }\n     }"}, {"sha": "4272b57a4dc5145f309f819802d4cf95929855ab", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 30, "deletions": 25, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -12,6 +12,7 @@ pub use self::BinOpToken::*;\n pub use self::Nonterminal::*;\n pub use self::DelimToken::*;\n pub use self::IdentStyle::*;\n+pub use self::Lit::*;\n pub use self::Token::*;\n \n use ast;\n@@ -59,6 +60,31 @@ pub enum IdentStyle {\n     Plain,\n }\n \n+#[deriving(Clone, Encodable, Decodable, PartialEq, Eq, Hash, Show)]\n+pub enum Lit {\n+    Byte(ast::Name),\n+    Char(ast::Name),\n+    Integer(ast::Name),\n+    Float(ast::Name),\n+    Str_(ast::Name),\n+    StrRaw(ast::Name, uint), /* raw str delimited by n hash symbols */\n+    Binary(ast::Name),\n+    BinaryRaw(ast::Name, uint), /* raw binary str delimited by n hash symbols */\n+}\n+\n+impl Lit {\n+    pub fn short_name(&self) -> &'static str {\n+        match *self {\n+            Byte(_) => \"byte\",\n+            Char(_) => \"char\",\n+            Integer(_) => \"integer\",\n+            Float(_) => \"float\",\n+            Str_(_) | StrRaw(..) => \"str\",\n+            Binary(_) | BinaryRaw(..) => \"binary str\"\n+        }\n+    }\n+}\n+\n #[allow(non_camel_case_types)]\n #[deriving(Clone, Encodable, Decodable, PartialEq, Eq, Hash, Show)]\n pub enum Token {\n@@ -98,14 +124,7 @@ pub enum Token {\n     CloseDelim(DelimToken),\n \n     /* Literals */\n-    LitByte(ast::Name),\n-    LitChar(ast::Name),\n-    LitInteger(ast::Name),\n-    LitFloat(ast::Name),\n-    LitStr(ast::Name),\n-    LitStrRaw(ast::Name, uint), /* raw str delimited by n hash symbols */\n-    LitBinary(ast::Name),\n-    LitBinaryRaw(ast::Name, uint), /* raw binary str delimited by n hash symbols */\n+    Literal(Lit, Option<ast::Name>),\n \n     /* Name components */\n     Ident(ast::Ident, IdentStyle),\n@@ -145,14 +164,7 @@ impl Token {\n             Ident(_, _)                 => true,\n             Underscore                  => true,\n             Tilde                       => true,\n-            LitByte(_)                  => true,\n-            LitChar(_)                  => true,\n-            LitInteger(_)               => true,\n-            LitFloat(_)                 => true,\n-            LitStr(_)                   => true,\n-            LitStrRaw(_, _)             => true,\n-            LitBinary(_)                => true,\n-            LitBinaryRaw(_, _)          => true,\n+            Literal(_, _)               => true,\n             Pound                       => true,\n             At                          => true,\n             Not                         => true,\n@@ -173,15 +185,8 @@ impl Token {\n     /// Returns `true` if the token is any literal\n     pub fn is_lit(&self) -> bool {\n         match *self {\n-            LitByte(_)          => true,\n-            LitChar(_)          => true,\n-            LitInteger(_)       => true,\n-            LitFloat(_)         => true,\n-            LitStr(_)           => true,\n-            LitStrRaw(_, _)     => true,\n-            LitBinary(_)        => true,\n-            LitBinaryRaw(_, _)  => true,\n-            _                   => false,\n+            Literal(_, _) => true,\n+            _          => false,\n         }\n     }\n "}, {"sha": "8e7804aaa713f4bcdb2836a8a1ba830ec4c118af", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 24, "deletions": 14, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -236,18 +236,28 @@ pub fn token_to_string(tok: &Token) -> String {\n         token::Question             => \"?\".into_string(),\n \n         /* Literals */\n-        token::LitByte(b)           => format!(\"b'{}'\", b.as_str()),\n-        token::LitChar(c)           => format!(\"'{}'\", c.as_str()),\n-        token::LitFloat(c)          => c.as_str().into_string(),\n-        token::LitInteger(c)        => c.as_str().into_string(),\n-        token::LitStr(s)            => format!(\"\\\"{}\\\"\", s.as_str()),\n-        token::LitStrRaw(s, n)      => format!(\"r{delim}\\\"{string}\\\"{delim}\",\n-                                               delim=\"#\".repeat(n),\n-                                               string=s.as_str()),\n-        token::LitBinary(v)         => format!(\"b\\\"{}\\\"\", v.as_str()),\n-        token::LitBinaryRaw(s, n)   => format!(\"br{delim}\\\"{string}\\\"{delim}\",\n-                                               delim=\"#\".repeat(n),\n-                                               string=s.as_str()),\n+        token::Literal(lit, suf) => {\n+            let mut out = match lit {\n+                token::Byte(b)           => format!(\"b'{}'\", b.as_str()),\n+                token::Char(c)           => format!(\"'{}'\", c.as_str()),\n+                token::Float(c)          => c.as_str().into_string(),\n+                token::Integer(c)        => c.as_str().into_string(),\n+                token::Str_(s)           => format!(\"\\\"{}\\\"\", s.as_str()),\n+                token::StrRaw(s, n)      => format!(\"r{delim}\\\"{string}\\\"{delim}\",\n+                                                    delim=\"#\".repeat(n),\n+                                                    string=s.as_str()),\n+                token::Binary(v)         => format!(\"b\\\"{}\\\"\", v.as_str()),\n+                token::BinaryRaw(s, n)   => format!(\"br{delim}\\\"{string}\\\"{delim}\",\n+                                                    delim=\"#\".repeat(n),\n+                                                    string=s.as_str()),\n+            };\n+\n+            if let Some(s) = suf {\n+                out.push_str(s.as_str())\n+            }\n+\n+            out\n+        }\n \n         /* Name components */\n         token::Ident(s, _)          => token::get_ident(s).get().into_string(),\n@@ -744,10 +754,10 @@ impl<'a> State<'a> {\n             }\n             ast::TyQPath(ref qpath) => {\n                 try!(word(&mut self.s, \"<\"));\n-                try!(self.print_type(&*qpath.for_type));\n+                try!(self.print_type(&*qpath.self_type));\n                 try!(space(&mut self.s));\n                 try!(self.word_space(\"as\"));\n-                try!(self.print_path(&qpath.trait_name, false));\n+                try!(self.print_trait_ref(&*qpath.trait_ref));\n                 try!(word(&mut self.s, \">\"));\n                 try!(word(&mut self.s, \"::\"));\n                 try!(self.print_ident(qpath.item_name));"}, {"sha": "41a7ce7d78e5709df508e59005f824dcee0a783f", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -55,8 +55,11 @@ pub enum FnKind<'a> {\n /// new default implementation gets introduced.)\n pub trait Visitor<'v> {\n \n-    fn visit_ident(&mut self, _sp: Span, _ident: Ident) {\n-        /*! Visit the idents */\n+    fn visit_name(&mut self, _span: Span, _name: Name) {\n+        // Nothing to do.\n+    }\n+    fn visit_ident(&mut self, span: Span, ident: Ident) {\n+        self.visit_name(span, ident.name);\n     }\n     fn visit_mod(&mut self, m: &'v Mod, _s: Span, _n: NodeId) { walk_mod(self, m) }\n     fn visit_view_item(&mut self, i: &'v ViewItem) { walk_view_item(self, i) }\n@@ -102,11 +105,11 @@ pub trait Visitor<'v> {\n             None => ()\n         }\n     }\n-    fn visit_lifetime_ref(&mut self, _lifetime: &'v Lifetime) {\n-        /*! Visits a reference to a lifetime */\n+    fn visit_lifetime_ref(&mut self, lifetime: &'v Lifetime) {\n+        self.visit_name(lifetime.span, lifetime.name)\n     }\n-    fn visit_lifetime_decl(&mut self, _lifetime: &'v LifetimeDef) {\n-        /*! Visits a declaration of a lifetime */\n+    fn visit_lifetime_def(&mut self, lifetime: &'v LifetimeDef) {\n+        walk_lifetime_def(self, lifetime)\n     }\n     fn visit_explicit_self(&mut self, es: &'v ExplicitSelf) {\n         walk_explicit_self(self, es)\n@@ -207,6 +210,14 @@ pub fn walk_local<'v, V: Visitor<'v>>(visitor: &mut V, local: &'v Local) {\n     walk_expr_opt(visitor, &local.init);\n }\n \n+pub fn walk_lifetime_def<'v, V: Visitor<'v>>(visitor: &mut V,\n+                                              lifetime_def: &'v LifetimeDef) {\n+    visitor.visit_name(lifetime_def.lifetime.span, lifetime_def.lifetime.name);\n+    for bound in lifetime_def.bounds.iter() {\n+        visitor.visit_lifetime_ref(bound);\n+    }\n+}\n+\n pub fn walk_explicit_self<'v, V: Visitor<'v>>(visitor: &mut V,\n                                               explicit_self: &'v ExplicitSelf) {\n     match explicit_self.node {\n@@ -403,8 +414,8 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n             }\n         }\n         TyQPath(ref qpath) => {\n-            visitor.visit_ty(&*qpath.for_type);\n-            visitor.visit_path(&qpath.trait_name, typ.id);\n+            visitor.visit_ty(&*qpath.self_type);\n+            visitor.visit_trait_ref(&*qpath.trait_ref);\n             visitor.visit_ident(typ.span, qpath.item_name);\n         }\n         TyFixedLengthVec(ref ty, ref expression) => {\n@@ -424,7 +435,7 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n pub fn walk_lifetime_decls_helper<'v, V: Visitor<'v>>(visitor: &mut V,\n                                                       lifetimes: &'v Vec<LifetimeDef>) {\n     for l in lifetimes.iter() {\n-        visitor.visit_lifetime_decl(l);\n+        visitor.visit_lifetime_def(l);\n     }\n }\n \n@@ -555,6 +566,7 @@ pub fn walk_ty_param_bound<'v, V: Visitor<'v>>(visitor: &mut V,\n \n pub fn walk_generics<'v, V: Visitor<'v>>(visitor: &mut V, generics: &'v Generics) {\n     for type_parameter in generics.ty_params.iter() {\n+        visitor.visit_ident(type_parameter.span, type_parameter.ident);\n         walk_ty_param_bounds_helper(visitor, &type_parameter.bounds);\n         match type_parameter.default {\n             Some(ref ty) => visitor.visit_ty(&**ty),"}, {"sha": "f910bfc5bd446099ac6e2fc432c36f5c9ee6eb3c", "filename": "src/libterm/terminfo/parm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -497,8 +497,8 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8> ,String> {\n     let mut s = match val {\n         Number(d) => {\n             let s = match (op, flags.sign) {\n-                (FormatDigit, true)  => format!(\"{:+d}\", d).into_bytes(),\n-                (FormatDigit, false) => format!(\"{:d}\", d).into_bytes(),\n+                (FormatDigit, true)  => format!(\"{:+}\", d).into_bytes(),\n+                (FormatDigit, false) => format!(\"{}\", d).into_bytes(),\n                 (FormatOctal, _)     => format!(\"{:o}\", d).into_bytes(),\n                 (FormatHex, _)       => format!(\"{:x}\", d).into_bytes(),\n                 (FormatHEX, _)       => format!(\"{:X}\", d).into_bytes(),"}, {"sha": "0ea8ca84ef8bd0f245e5f6525516f0da1d2465ee", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -687,14 +687,14 @@ impl<T: Writer> ConsoleTestState<T> {\n                     improved += 1;\n                     try!(self.write_plain(format!(\": {}\", *k).as_slice()));\n                     try!(self.write_improved());\n-                    try!(self.write_plain(format!(\" by {:.2f}%\\n\",\n+                    try!(self.write_plain(format!(\" by {:.2}%\\n\",\n                                                   pct as f64).as_slice()));\n                 }\n                 Regression(pct) => {\n                     regressed += 1;\n                     try!(self.write_plain(format!(\": {}\", *k).as_slice()));\n                     try!(self.write_regressed());\n-                    try!(self.write_plain(format!(\" by {:.2f}%\\n\",\n+                    try!(self.write_plain(format!(\" by {:.2}%\\n\",\n                                                   pct as f64).as_slice()));\n                 }\n             }"}, {"sha": "062035c23f9066eb2370ceb42fdba0a970d4e301", "filename": "src/libtime/lib.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibtime%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Flibtime%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtime%2Flib.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -602,8 +602,8 @@ impl<'a> fmt::Show for TmFmt<'a> {\n \n             match ch {\n                 'G' => write!(fmt, \"{}\", year),\n-                'g' => write!(fmt, \"{:02d}\", (year % 100 + 100) % 100),\n-                'V' => write!(fmt, \"{:02d}\", days / 7 + 1),\n+                'g' => write!(fmt, \"{:02}\", (year % 100 + 100) % 100),\n+                'V' => write!(fmt, \"{:02}\", days / 7 + 1),\n                 _ => Ok(())\n             }\n         }\n@@ -663,7 +663,7 @@ impl<'a> fmt::Show for TmFmt<'a> {\n                 11 => \"Dec\",\n                 _  => return die()\n               },\n-              'C' => return write!(fmt, \"{:02d}\", (tm.tm_year as int + 1900) / 100),\n+              'C' => return write!(fmt, \"{:02}\", (tm.tm_year as int + 1900) / 100),\n               'c' => {\n                     try!(parse_type(fmt, 'a', tm));\n                     try!(' '.fmt(fmt));\n@@ -682,9 +682,9 @@ impl<'a> fmt::Show for TmFmt<'a> {\n                     try!('/'.fmt(fmt));\n                     return parse_type(fmt, 'y', tm);\n               }\n-              'd' => return write!(fmt, \"{:02d}\", tm.tm_mday),\n-              'e' => return write!(fmt, \"{:2d}\", tm.tm_mday),\n-              'f' => return write!(fmt, \"{:09d}\", tm.tm_nsec),\n+              'd' => return write!(fmt, \"{:02}\", tm.tm_mday),\n+              'e' => return write!(fmt, \"{:2}\", tm.tm_mday),\n+              'f' => return write!(fmt, \"{:09}\", tm.tm_nsec),\n               'F' => {\n                     try!(parse_type(fmt, 'Y', tm));\n                     try!('-'.fmt(fmt));\n@@ -694,23 +694,23 @@ impl<'a> fmt::Show for TmFmt<'a> {\n               }\n               'G' => return iso_week(fmt, 'G', tm),\n               'g' => return iso_week(fmt, 'g', tm),\n-              'H' => return write!(fmt, \"{:02d}\", tm.tm_hour),\n+              'H' => return write!(fmt, \"{:02}\", tm.tm_hour),\n               'I' => {\n                 let mut h = tm.tm_hour;\n                 if h == 0 { h = 12 }\n                 if h > 12 { h -= 12 }\n-                return write!(fmt, \"{:02d}\", h)\n+                return write!(fmt, \"{:02}\", h)\n               }\n-              'j' => return write!(fmt, \"{:03d}\", tm.tm_yday + 1),\n-              'k' => return write!(fmt, \"{:2d}\", tm.tm_hour),\n+              'j' => return write!(fmt, \"{:03}\", tm.tm_yday + 1),\n+              'k' => return write!(fmt, \"{:2}\", tm.tm_hour),\n               'l' => {\n                 let mut h = tm.tm_hour;\n                 if h == 0 { h = 12 }\n                 if h > 12 { h -= 12 }\n-                return write!(fmt, \"{:2d}\", h)\n+                return write!(fmt, \"{:2}\", h)\n               }\n-              'M' => return write!(fmt, \"{:02d}\", tm.tm_min),\n-              'm' => return write!(fmt, \"{:02d}\", tm.tm_mon + 1),\n+              'M' => return write!(fmt, \"{:02}\", tm.tm_min),\n+              'm' => return write!(fmt, \"{:02}\", tm.tm_mon + 1),\n               'n' => \"\\n\",\n               'P' => if (tm.tm_hour as int) < 12 { \"am\" } else { \"pm\" },\n               'p' => if (tm.tm_hour as int) < 12 { \"AM\" } else { \"PM\" },\n@@ -728,7 +728,7 @@ impl<'a> fmt::Show for TmFmt<'a> {\n                     try!(' '.fmt(fmt));\n                     return parse_type(fmt, 'p', tm);\n               }\n-              'S' => return write!(fmt, \"{:02d}\", tm.tm_sec),\n+              'S' => return write!(fmt, \"{:02}\", tm.tm_sec),\n               's' => return write!(fmt, \"{}\", tm.to_timespec().sec),\n               'T' | 'X' => {\n                     try!(parse_type(fmt, 'H', tm));\n@@ -738,7 +738,7 @@ impl<'a> fmt::Show for TmFmt<'a> {\n                     return parse_type(fmt, 'S', tm);\n               }\n               't' => \"\\t\",\n-              'U' => return write!(fmt, \"{:02d}\", (tm.tm_yday - tm.tm_wday + 7) / 7),\n+              'U' => return write!(fmt, \"{:02}\", (tm.tm_yday - tm.tm_wday + 7) / 7),\n               'u' => {\n                 let i = tm.tm_wday as int;\n                 return (if i == 0 { 7 } else { i }).fmt(fmt);\n@@ -752,19 +752,19 @@ impl<'a> fmt::Show for TmFmt<'a> {\n                   return parse_type(fmt, 'Y', tm);\n               }\n               'W' => {\n-                  return write!(fmt, \"{:02d}\",\n+                  return write!(fmt, \"{:02}\",\n                                  (tm.tm_yday - (tm.tm_wday - 1 + 7) % 7 + 7) / 7)\n               }\n               'w' => return (tm.tm_wday as int).fmt(fmt),\n               'Y' => return (tm.tm_year as int + 1900).fmt(fmt),\n-              'y' => return write!(fmt, \"{:02d}\", (tm.tm_year as int + 1900) % 100),\n+              'y' => return write!(fmt, \"{:02}\", (tm.tm_year as int + 1900) % 100),\n               'Z' => if tm.tm_gmtoff == 0_i32 { \"GMT\"} else { \"\" }, // FIXME (#2350): support locale\n               'z' => {\n                 let sign = if tm.tm_gmtoff > 0_i32 { '+' } else { '-' };\n                 let mut m = tm.tm_gmtoff.abs() / 60_i32;\n                 let h = m / 60_i32;\n                 m -= h * 60_i32;\n-                return write!(fmt, \"{}{:02d}{:02d}\", sign, h, m);\n+                return write!(fmt, \"{}{:02}{:02}\", sign, h, m);\n               }\n               '+' => return tm.rfc3339().fmt(fmt),\n               '%' => \"%\",\n@@ -806,7 +806,7 @@ impl<'a> fmt::Show for TmFmt<'a> {\n                     let mut m = self.tm.tm_gmtoff.abs() / 60_i32;\n                     let h = m / 60_i32;\n                     m -= h * 60_i32;\n-                    write!(fmt, \"{}{}{:02d}:{:02d}\", s, sign, h as int, m as int)\n+                    write!(fmt, \"{}{}{:02}:{:02}\", s, sign, h as int, m as int)\n                 }\n             }\n         }"}, {"sha": "07300b73c85a7bcae3c1fbbbb2df63053f994528", "filename": "src/test/bench/core-set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Ftest%2Fbench%2Fcore-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Ftest%2Fbench%2Fcore-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-set.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -148,7 +148,7 @@ fn write_header(header: &str) {\n }\n \n fn write_row(label: &str, value: Duration) {\n-    println!(\"{:30s} {} s\\n\", label, value);\n+    println!(\"{:30} {} s\\n\", label, value);\n }\n \n fn write_results(label: &str, results: &Results) {"}, {"sha": "419e39b53cf81bc39e8b7202e2bb3d589eca2a46", "filename": "src/test/bench/noise.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Ftest%2Fbench%2Fnoise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Ftest%2Fbench%2Fnoise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fnoise.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -115,7 +115,7 @@ fn main() {\n     for y in range(0u, 256) {\n         for x in range(0u, 256) {\n             let idx = (pixels[y*256+x] / 0.2) as uint;\n-            print!(\"{:c}\", symbols[idx]);\n+            print!(\"{}\", symbols[idx]);\n         }\n         print!(\"\\n\");\n     }"}, {"sha": "4005c11e6b614a463d0570d9288e876fdd6ed5b9", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -63,7 +63,7 @@ fn sort_and_fmt(mm: &HashMap<Vec<u8> , uint>, total: uint) -> String {\n \n    let mut buffer = String::new();\n    for &(ref k, v) in pairs_sorted.iter() {\n-       buffer.push_str(format!(\"{} {:0.3f}\\n\",\n+       buffer.push_str(format!(\"{} {:0.3}\\n\",\n                                k.as_slice()\n                                .to_ascii()\n                                .to_uppercase()"}, {"sha": "b030e7bb93e87d71e5a929c4b59b2f3a0b50d046", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -266,7 +266,7 @@ fn print_frequencies(frequencies: &Table, frame: uint) {\n     }\n \n     for &(count, key) in vector.iter().rev() {\n-        println!(\"{} {:.3f}\",\n+        println!(\"{} {:.3}\",\n                  key.unpack(frame).as_slice(),\n                  (count as f32 * 100.0) / (total_count as f32));\n     }"}, {"sha": "b62504d7ba85d901c1c28a5b563037ab48a8b737", "filename": "src/test/bench/shootout-nbody.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-nbody.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -179,11 +179,11 @@ fn main() {\n     let mut bodies = BODIES;\n \n     offset_momentum(&mut bodies);\n-    println!(\"{:.9f}\", energy(&bodies));\n+    println!(\"{:.9}\", energy(&bodies));\n \n     advance(&mut bodies, 0.01, n);\n \n-    println!(\"{:.9f}\", energy(&bodies));\n+    println!(\"{:.9}\", energy(&bodies));\n }\n \n /// Pop a mutable reference off the head of a slice, mutating the slice to no"}, {"sha": "f76391b596bb3855021f9e2c7cd39df7f9a66bfc", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -59,7 +59,7 @@ fn main() {\n     } else {\n         from_str(args[1].as_slice()).unwrap()\n     });\n-    println!(\"{:.9f}\", answer);\n+    println!(\"{:.9}\", answer);\n }\n \n fn spectralnorm(n: uint) -> f64 {"}, {"sha": "24de1fa2f78444ecc6b40426dcf355fab96f8669", "filename": "src/test/compile-fail/associated-types-in-ambiguous-context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Ftest%2Fcompile-fail%2Fassociated-types-in-ambiguous-context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Ftest%2Fcompile-fail%2Fassociated-types-in-ambiguous-context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-in-ambiguous-context.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -20,12 +20,12 @@ fn get<T:Get,U:Get>(x: T, y: U) -> Get::Value {}\n \n trait Other {\n     fn uhoh<U:Get>(&self, foo: U, bar: <Self as Get>::Value) {}\n-    //~^ ERROR this associated type is not allowed in this context\n+    //~^ ERROR no suitable bound on `Self`\n }\n \n impl<T:Get> Other for T {\n     fn uhoh<U:Get>(&self, foo: U, bar: <(T, U) as Get>::Value) {}\n-    //~^ ERROR this associated type is not allowed in this context\n+    //~^ ERROR currently unsupported\n }\n \n trait Grab {"}, {"sha": "8cab2759ad55a319c34aa258e27bfd11e109c279", "filename": "src/test/compile-fail/associated-types-in-wrong-context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Ftest%2Fcompile-fail%2Fassociated-types-in-wrong-context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Ftest%2Fcompile-fail%2Fassociated-types-in-wrong-context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-in-wrong-context.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -16,15 +16,15 @@ trait Get {\n }\n \n fn get(x: int) -> <int as Get>::Value {}\n-//~^ ERROR this associated type is not allowed in this context\n+//~^ ERROR unsupported\n \n struct Struct {\n     x: int,\n }\n \n impl Struct {\n     fn uhoh<T>(foo: <T as Get>::Value) {}\n-    //~^ ERROR this associated type is not allowed in this context\n+    //~^ ERROR no suitable bound on `T`\n }\n \n fn main() {"}, {"sha": "d10337e768c71a06090136348d55510084fe5e0b", "filename": "src/test/compile-fail/bad-lit-suffixes.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Ftest%2Fcompile-fail%2Fbad-lit-suffixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Ftest%2Fcompile-fail%2Fbad-lit-suffixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-lit-suffixes.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+extern crate\n+    \"foo\"suffix //~ ERROR extern crate name with a suffix is illegal\n+     as foo;\n+\n+extern\n+    \"C\"suffix //~ ERROR ABI spec with a suffix is illegal\n+    fn foo() {}\n+\n+extern\n+    \"C\"suffix //~ ERROR ABI spec with a suffix is illegal\n+{}\n+\n+fn main() {\n+    \"\"suffix; //~ ERROR str literal with a suffix is illegal\n+    b\"\"suffix; //~ ERROR binary str literal with a suffix is illegal\n+    r#\"\"#suffix; //~ ERROR str literal with a suffix is illegal\n+    br#\"\"#suffix; //~ ERROR binary str literal with a suffix is illegal\n+    'a'suffix; //~ ERROR char literal with a suffix is illegal\n+    b'a'suffix; //~ ERROR byte literal with a suffix is illegal\n+\n+    1234u1024; //~ ERROR illegal width `1024` for integer literal\n+    1234i1024; //~ ERROR illegal width `1024` for integer literal\n+    1234f1024; //~ ERROR illegal width `1024` for float literal\n+    1234.5f1024; //~ ERROR illegal width `1024` for float literal\n+\n+    1234suffix; //~ ERROR illegal suffix `suffix` for numeric literal\n+    0b101suffix; //~ ERROR illegal suffix `suffix` for numeric literal\n+    1.0suffix; //~ ERROR illegal suffix `suffix` for float literal\n+    1.0e10suffix; //~ ERROR illegal suffix `suffix` for float literal\n+}"}, {"sha": "8226bba42b0e1f345d03f5ce440673965b8809b9", "filename": "src/test/compile-fail/deriving-non-type.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Ftest%2Fcompile-fail%2Fderiving-non-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Ftest%2Fcompile-fail%2Fderiving-non-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-non-type.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+\n+struct S;\n+\n+#[deriving(PartialEq)] //~ ERROR: `deriving` may only be applied to structs and enums\n+trait T { }\n+\n+#[deriving(PartialEq)] //~ ERROR: `deriving` may only be applied to structs and enums\n+impl S { }\n+\n+#[deriving(PartialEq)] //~ ERROR: `deriving` may only be applied to structs and enums\n+impl T for S { }\n+\n+#[deriving(PartialEq)] //~ ERROR: `deriving` may only be applied to structs and enums\n+static s: uint = 0u;\n+\n+#[deriving(PartialEq)] //~ ERROR: `deriving` may only be applied to structs and enums\n+const c: uint = 0u;\n+\n+#[deriving(PartialEq)] //~ ERROR: `deriving` may only be applied to structs and enums\n+mod m { }\n+\n+#[deriving(PartialEq)] //~ ERROR: `deriving` may only be applied to structs and enums\n+extern \"C\" { }\n+\n+#[deriving(PartialEq)] //~ ERROR: `deriving` may only be applied to structs and enums\n+type A = uint;\n+\n+#[deriving(PartialEq)] //~ ERROR: `deriving` may only be applied to structs and enums\n+fn main() { }"}, {"sha": "db7f49272aac8495296f83518a3e9f6ed7ac1585", "filename": "src/test/compile-fail/ifmt-bad-arg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Ftest%2Fcompile-fail%2Fifmt-bad-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Ftest%2Fcompile-fail%2Fifmt-bad-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fifmt-bad-arg.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -23,8 +23,8 @@ fn main() {\n     format!(\"{foo}\", 1, foo=2);        //~ ERROR: argument never used\n     format!(\"\", foo=2);                //~ ERROR: named argument never used\n \n-    format!(\"{0:d} {0:s}\", 1);         //~ ERROR: redeclared with type `s`\n-    format!(\"{foo:d} {foo:s}\", foo=1); //~ ERROR: redeclared with type `s`\n+    format!(\"{0:x} {0:X}\", 1);         //~ ERROR: redeclared with type `X`\n+    format!(\"{foo:x} {foo:X}\", foo=1); //~ ERROR: redeclared with type `X`\n \n     format!(\"{foo}\", foo=1, foo=2);    //~ ERROR: duplicate argument\n     format!(\"\", foo=1, 2);             //~ ERROR: positional arguments cannot follow"}, {"sha": "948040496bd392466bf689e266d3b7cce1688d1a", "filename": "src/test/compile-fail/ifmt-unimpl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Ftest%2Fcompile-fail%2Fifmt-unimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Ftest%2Fcompile-fail%2Fifmt-unimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fifmt-unimpl.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -9,6 +9,6 @@\n // except according to those terms.\n \n fn main() {\n-    format!(\"{:d}\", \"3\");\n-    //~^ ERROR: the trait `core::fmt::Signed` is not implemented\n+    format!(\"{:X}\", \"3\");\n+    //~^ ERROR: the trait `core::fmt::UpperHex` is not implemented\n }"}, {"sha": "234fa85c89afd83db9115a77bf4e84a2be91dc5f", "filename": "src/test/compile-fail/issue-1448-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Ftest%2Fcompile-fail%2Fissue-1448-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Ftest%2Fcompile-fail%2Fissue-1448-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-1448-2.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -13,5 +13,5 @@\n fn foo(a: uint) -> uint { a }\n \n fn main() {\n-    println!(\"{:u}\", foo(10i)); //~ ERROR mismatched types\n+    println!(\"{}\", foo(10i)); //~ ERROR mismatched types\n }"}, {"sha": "6515b34d964e1051ee05dfc26336e3d8c483b823", "filename": "src/test/compile-fail/issue-14853.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Ftest%2Fcompile-fail%2Fissue-14853.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Ftest%2Fcompile-fail%2Fissue-14853.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-14853.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -10,17 +10,18 @@\n \n use std::fmt::Show;\n \n+trait Str {}\n+\n trait Something {\n-    fn yay<T: Show>(_: Option<Self>, thing: &[T]) -> String {\n-    }\n+    fn yay<T: Show>(_: Option<Self>, thing: &[T]);\n }\n \n struct X { data: u32 }\n \n impl Something for X {\n-    fn yay<T: Str>(_:Option<X>, thing: &[T]) -> String {\n-//~^ ERROR in method `yay`, type parameter 0 requires bound `core::str::Str`, which is not required\n-        format!(\"{:s}\", thing[0])\n+    fn yay<T: Str>(_:Option<X>, thing: &[T]) {\n+//~^ ERROR in method `yay`, type parameter 0 requires bound `Str`, which is not required\n+\n     }\n }\n "}, {"sha": "692018594571ef6ff75b31ac3c0e80f5c76ecad3", "filename": "src/test/compile-fail/issue-19086.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Ftest%2Fcompile-fail%2Fissue-19086.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Ftest%2Fcompile-fail%2Fissue-19086.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-19086.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use Foo::FooB;\n+\n+enum Foo {\n+    FooB { x: i32, y: i32 }\n+}\n+\n+fn main() {\n+    let f = FooB { x: 3, y: 4 };\n+    match f {\n+        FooB(a, b) => println!(\"{} {}\", a, b),\n+//~^ ERROR `FooB` does not name a non-struct variant or a tuple struct\n+    }\n+}"}, {"sha": "f92c264784ae6a402dc6d8d60e69e29d63b4abdd", "filename": "src/test/compile-fail/regions-escape-method.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Ftest%2Fcompile-fail%2Fregions-escape-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Ftest%2Fcompile-fail%2Fregions-escape-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-escape-method.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test a method call where the parameter `B` would (illegally) be\n+// inferred to a region bound in the method argument. If this program\n+// were accepted, then the closure passed to `s.f` could escape its\n+// argument.\n+\n+struct S;\n+\n+impl S {\n+    fn f<B>(&self, _: |&i32| -> B) {\n+    }\n+}\n+\n+fn main() {\n+    let s = S;\n+    s.f(|p| p) //~ ERROR cannot infer\n+}"}, {"sha": "0c3c11ccd07b30389d492abb3ffc575172e3470f", "filename": "src/test/compile-fail/utf8_idents.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Ftest%2Fcompile-fail%2Futf8_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Ftest%2Fcompile-fail%2Futf8_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Futf8_idents.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+//\n+// ignore-lexer-test FIXME #15679\n+\n+fn foo<\n+    '\u03b2, //~ ERROR non-ascii idents are not fully supported.\n+    \u03b3  //~ ERROR non-ascii idents are not fully supported.\n+>() {}\n+\n+struct X {\n+    \u03b4: uint //~ ERROR non-ascii idents are not fully supported.\n+}\n+\n+pub fn main() {\n+    let \u03b1 = 0.00001f64; //~ ERROR non-ascii idents are not fully supported.\n+}"}, {"sha": "1b4eb2604a82bf4251ccfc5213b6af0c4ef04266", "filename": "src/test/run-pass/associated-types-qualified-path-with-trait-with-type-parameters.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Ftest%2Frun-pass%2Fassociated-types-qualified-path-with-trait-with-type-parameters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Ftest%2Frun-pass%2Fassociated-types-qualified-path-with-trait-with-type-parameters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-qualified-path-with-trait-with-type-parameters.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(associated_types)]\n+\n+trait Foo<T> {\n+    type Bar;\n+    fn get_bar() -> <Self as Foo<T>>::Bar;\n+}\n+\n+fn main() { }"}, {"sha": "b78371c51e432fde822d6031889459ba33a50a0b", "filename": "src/test/run-pass/ifmt.rs", "status": "modified", "additions": 50, "deletions": 50, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Ftest%2Frun-pass%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Ftest%2Frun-pass%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fifmt.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -22,12 +22,12 @@ struct A;\n struct B;\n struct C;\n \n-impl fmt::Signed for A {\n+impl fmt::LowerHex for A {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.write(\"aloha\".as_bytes())\n     }\n }\n-impl fmt::Signed for B {\n+impl fmt::UpperHex for B {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.write(\"adios\".as_bytes())\n     }\n@@ -55,71 +55,71 @@ pub fn main() {\n     t!(format!(\"{}\", 'a'), \"a\");\n \n     // At least exercise all the formats\n-    t!(format!(\"{:b}\", true), \"true\");\n-    t!(format!(\"{:c}\", '\u2603'), \"\u2603\");\n-    t!(format!(\"{:d}\", 10i), \"10\");\n-    t!(format!(\"{:i}\", 10i), \"10\");\n-    t!(format!(\"{:u}\", 10u), \"10\");\n+    t!(format!(\"{}\", true), \"true\");\n+    t!(format!(\"{}\", '\u2603'), \"\u2603\");\n+    t!(format!(\"{}\", 10i), \"10\");\n+    t!(format!(\"{}\", 10i), \"10\");\n+    t!(format!(\"{}\", 10u), \"10\");\n     t!(format!(\"{:o}\", 10u), \"12\");\n     t!(format!(\"{:x}\", 10u), \"a\");\n     t!(format!(\"{:X}\", 10u), \"A\");\n-    t!(format!(\"{:s}\", \"foo\"), \"foo\");\n-    t!(format!(\"{:s}\", \"foo\".to_string()), \"foo\");\n+    t!(format!(\"{}\", \"foo\"), \"foo\");\n+    t!(format!(\"{}\", \"foo\".to_string()), \"foo\");\n     t!(format!(\"{:p}\", 0x1234 as *const int), \"0x1234\");\n     t!(format!(\"{:p}\", 0x1234 as *mut int), \"0x1234\");\n-    t!(format!(\"{:d}\", A), \"aloha\");\n-    t!(format!(\"{:d}\", B), \"adios\");\n-    t!(format!(\"foo {:s} \u2603\u2603\u2603\u2603\u2603\u2603\", \"bar\"), \"foo bar \u2603\u2603\u2603\u2603\u2603\u2603\");\n+    t!(format!(\"{:x}\", A), \"aloha\");\n+    t!(format!(\"{:X}\", B), \"adios\");\n+    t!(format!(\"foo {} \u2603\u2603\u2603\u2603\u2603\u2603\", \"bar\"), \"foo bar \u2603\u2603\u2603\u2603\u2603\u2603\");\n     t!(format!(\"{1} {0}\", 0i, 1i), \"1 0\");\n     t!(format!(\"{foo} {bar}\", foo=0i, bar=1i), \"0 1\");\n     t!(format!(\"{foo} {1} {bar} {0}\", 0i, 1i, foo=2i, bar=3i), \"2 1 3 0\");\n     t!(format!(\"{} {0}\", \"a\"), \"a a\");\n     t!(format!(\"{foo_bar}\", foo_bar=1i), \"1\");\n-    t!(format!(\"{:d}\", 5i + 5i), \"10\");\n+    t!(format!(\"{}\", 5i + 5i), \"10\");\n     t!(format!(\"{:#4}\", C), \"\u2603123\");\n \n     let a: &fmt::Show = &1i;\n     t!(format!(\"{}\", a), \"1\");\n \n     // Formatting strings and their arguments\n-    t!(format!(\"{:s}\", \"a\"), \"a\");\n-    t!(format!(\"{:4s}\", \"a\"), \"a   \");\n-    t!(format!(\"{:4s}\", \"\u2603\"), \"\u2603   \");\n-    t!(format!(\"{:>4s}\", \"a\"), \"   a\");\n-    t!(format!(\"{:<4s}\", \"a\"), \"a   \");\n-    t!(format!(\"{:^5s}\", \"a\"),  \"  a  \");\n-    t!(format!(\"{:^5s}\", \"aa\"), \" aa  \");\n-    t!(format!(\"{:^4s}\", \"a\"),  \" a  \");\n-    t!(format!(\"{:^4s}\", \"aa\"), \" aa \");\n-    t!(format!(\"{:.4s}\", \"a\"), \"a\");\n-    t!(format!(\"{:4.4s}\", \"a\"), \"a   \");\n-    t!(format!(\"{:4.4s}\", \"aaaaaaaaaaaaaaaaaa\"), \"aaaa\");\n-    t!(format!(\"{:<4.4s}\", \"aaaaaaaaaaaaaaaaaa\"), \"aaaa\");\n-    t!(format!(\"{:>4.4s}\", \"aaaaaaaaaaaaaaaaaa\"), \"aaaa\");\n-    t!(format!(\"{:^4.4s}\", \"aaaaaaaaaaaaaaaaaa\"), \"aaaa\");\n-    t!(format!(\"{:>10.4s}\", \"aaaaaaaaaaaaaaaaaa\"), \"aaaa\");\n-    t!(format!(\"{:2.4s}\", \"aaaaa\"), \"aaaa\");\n-    t!(format!(\"{:2.4s}\", \"aaaa\"), \"aaaa\");\n-    t!(format!(\"{:2.4s}\", \"aaa\"), \"aaa\");\n-    t!(format!(\"{:2.4s}\", \"aa\"), \"aa\");\n-    t!(format!(\"{:2.4s}\", \"a\"), \"a \");\n-    t!(format!(\"{:0>2s}\", \"a\"), \"0a\");\n-    t!(format!(\"{:.*s}\", 4, \"aaaaaaaaaaaaaaaaaa\"), \"aaaa\");\n-    t!(format!(\"{:.1$s}\", \"aaaaaaaaaaaaaaaaaa\", 4), \"aaaa\");\n-    t!(format!(\"{:.a$s}\", \"aaaaaaaaaaaaaaaaaa\", a=4), \"aaaa\");\n-    t!(format!(\"{:1$s}\", \"a\", 4), \"a   \");\n-    t!(format!(\"{1:0$s}\", 4, \"a\"), \"a   \");\n-    t!(format!(\"{:a$s}\", \"a\", a=4), \"a   \");\n-    t!(format!(\"{:-#s}\", \"a\"), \"a\");\n-    t!(format!(\"{:+#s}\", \"a\"), \"a\");\n+    t!(format!(\"{}\", \"a\"), \"a\");\n+    t!(format!(\"{:4}\", \"a\"), \"a   \");\n+    t!(format!(\"{:4}\", \"\u2603\"), \"\u2603   \");\n+    t!(format!(\"{:>4}\", \"a\"), \"   a\");\n+    t!(format!(\"{:<4}\", \"a\"), \"a   \");\n+    t!(format!(\"{:^5}\", \"a\"),  \"  a  \");\n+    t!(format!(\"{:^5}\", \"aa\"), \" aa  \");\n+    t!(format!(\"{:^4}\", \"a\"),  \" a  \");\n+    t!(format!(\"{:^4}\", \"aa\"), \" aa \");\n+    t!(format!(\"{:.4}\", \"a\"), \"a\");\n+    t!(format!(\"{:4.4}\", \"a\"), \"a   \");\n+    t!(format!(\"{:4.4}\", \"aaaaaaaaaaaaaaaaaa\"), \"aaaa\");\n+    t!(format!(\"{:<4.4}\", \"aaaaaaaaaaaaaaaaaa\"), \"aaaa\");\n+    t!(format!(\"{:>4.4}\", \"aaaaaaaaaaaaaaaaaa\"), \"aaaa\");\n+    t!(format!(\"{:^4.4}\", \"aaaaaaaaaaaaaaaaaa\"), \"aaaa\");\n+    t!(format!(\"{:>10.4}\", \"aaaaaaaaaaaaaaaaaa\"), \"aaaa\");\n+    t!(format!(\"{:2.4}\", \"aaaaa\"), \"aaaa\");\n+    t!(format!(\"{:2.4}\", \"aaaa\"), \"aaaa\");\n+    t!(format!(\"{:2.4}\", \"aaa\"), \"aaa\");\n+    t!(format!(\"{:2.4}\", \"aa\"), \"aa\");\n+    t!(format!(\"{:2.4}\", \"a\"), \"a \");\n+    t!(format!(\"{:0>2}\", \"a\"), \"0a\");\n+    t!(format!(\"{:.*}\", 4, \"aaaaaaaaaaaaaaaaaa\"), \"aaaa\");\n+    t!(format!(\"{:.1$}\", \"aaaaaaaaaaaaaaaaaa\", 4), \"aaaa\");\n+    t!(format!(\"{:.a$}\", \"aaaaaaaaaaaaaaaaaa\", a=4), \"aaaa\");\n+    t!(format!(\"{:1$}\", \"a\", 4), \"a   \");\n+    t!(format!(\"{1:0$}\", 4, \"a\"), \"a   \");\n+    t!(format!(\"{:a$}\", \"a\", a=4), \"a   \");\n+    t!(format!(\"{:-#}\", \"a\"), \"a\");\n+    t!(format!(\"{:+#}\", \"a\"), \"a\");\n \n     // Some float stuff\n-    t!(format!(\"{:f}\", 1.0f32), \"1\");\n-    t!(format!(\"{:f}\", 1.0f64), \"1\");\n-    t!(format!(\"{:.3f}\", 1.0f64), \"1.000\");\n-    t!(format!(\"{:10.3f}\", 1.0f64),   \"     1.000\");\n-    t!(format!(\"{:+10.3f}\", 1.0f64),  \"    +1.000\");\n-    t!(format!(\"{:+10.3f}\", -1.0f64), \"    -1.000\");\n+    t!(format!(\"{:}\", 1.0f32), \"1\");\n+    t!(format!(\"{:}\", 1.0f64), \"1\");\n+    t!(format!(\"{:.3}\", 1.0f64), \"1.000\");\n+    t!(format!(\"{:10.3}\", 1.0f64),   \"     1.000\");\n+    t!(format!(\"{:+10.3}\", 1.0f64),  \"    +1.000\");\n+    t!(format!(\"{:+10.3}\", -1.0f64), \"    -1.000\");\n \n     t!(format!(\"{:e}\", 1.2345e6f32), \"1.2345e6\");\n     t!(format!(\"{:e}\", 1.2345e6f64), \"1.2345e6\");\n@@ -164,7 +164,7 @@ fn test_write() {\n     {\n         let w = &mut buf as &mut io::Writer;\n         write!(w, \"{foo}\", foo=4i);\n-        write!(w, \"{:s}\", \"hello\");\n+        write!(w, \"{}\", \"hello\");\n         writeln!(w, \"{}\", \"line\");\n         writeln!(w, \"{foo}\", foo=\"bar\");\n     }"}, {"sha": "a29ed712d400bcb9a606fd0d73c51b0bf14f1402", "filename": "src/test/run-pass/realloc-16687.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Ftest%2Frun-pass%2Frealloc-16687.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399ff259e18c1061aa4ea60856fcecb486d36624/src%2Ftest%2Frun-pass%2Frealloc-16687.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frealloc-16687.rs?ref=399ff259e18c1061aa4ea60856fcecb486d36624", "patch": "@@ -46,35 +46,35 @@ unsafe fn test_triangle() -> bool {\n     static PRINT : bool = false;\n \n     unsafe fn allocate(size: uint, align: uint) -> *mut u8 {\n-        if PRINT { println!(\"allocate(size={:u} align={:u})\", size, align); }\n+        if PRINT { println!(\"allocate(size={} align={})\", size, align); }\n \n         let ret = heap::allocate(size, align);\n         if ret.is_null() { alloc::oom() }\n \n-        if PRINT { println!(\"allocate(size={:u} align={:u}) ret: 0x{:010x}\",\n+        if PRINT { println!(\"allocate(size={} align={}) ret: 0x{:010x}\",\n                             size, align, ret as uint);\n         }\n \n         ret\n     }\n     unsafe fn deallocate(ptr: *mut u8, size: uint, align: uint) {\n-        if PRINT { println!(\"deallocate(ptr=0x{:010x} size={:u} align={:u})\",\n+        if PRINT { println!(\"deallocate(ptr=0x{:010x} size={} align={})\",\n                             ptr as uint, size, align);\n         }\n \n         heap::deallocate(ptr, size, align);\n     }\n     unsafe fn reallocate(ptr: *mut u8, old_size: uint, size: uint, align: uint) -> *mut u8 {\n         if PRINT {\n-            println!(\"reallocate(ptr=0x{:010x} old_size={:u} size={:u} align={:u})\",\n+            println!(\"reallocate(ptr=0x{:010x} old_size={} size={} align={})\",\n                      ptr as uint, old_size, size, align);\n         }\n \n         let ret = heap::reallocate(ptr, old_size, size, align);\n         if ret.is_null() { alloc::oom() }\n \n         if PRINT {\n-            println!(\"reallocate(ptr=0x{:010x} old_size={:u} size={:u} align={:u}) \\\n+            println!(\"reallocate(ptr=0x{:010x} old_size={} size={} align={}) \\\n                       ret: 0x{:010x}\",\n                      ptr as uint, old_size, size, align, ret as uint);\n         }"}]}