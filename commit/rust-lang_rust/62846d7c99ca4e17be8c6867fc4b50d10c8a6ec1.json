{"sha": "62846d7c99ca4e17be8c6867fc4b50d10c8a6ec1", "node_id": "C_kwDOAAsO6NoAKDYyODQ2ZDdjOTljYTRlMTdiZThjNjg2N2ZjNGI1MGQxMGM4YTZlYzE", "commit": {"author": {"name": "Alan Egerton", "email": "eggyal@gmail.com", "date": "2023-02-09T12:56:33Z"}, "committer": {"name": "Alan Egerton", "email": "eggyal@gmail.com", "date": "2023-02-13T10:24:45Z"}, "message": "Move folding & visiting traits to ir submodules", "tree": {"sha": "864a1ed313967064ef4fc0afda1d3fc715db2b9d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/864a1ed313967064ef4fc0afda1d3fc715db2b9d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/62846d7c99ca4e17be8c6867fc4b50d10c8a6ec1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQJFBAABCAAvFiEEvrRBFuOXsbT1OVTHfUwvbCISJTIFAmPqD+0RHGVnZ3lhbEBn\nbWFpbC5jb20ACgkQfUwvbCISJTIHzhAAzLzgTXYFwikxq+Tf9Cc7CbjovQ1Q1Vo9\nTIzrUZ3S/Cg5BJvxnXabLFxfN1WBgWpniCiTAri92j4XvityRgc9IaAcbmRtG0jA\nYDu4rLl/wJvVfcw59n+LnU7gdEIvbtoSIuad4SoDGhowk7hQ8o25fh2F4ixK26Cb\nMqXTj08HmjKgie3EPUeJ1fA09Oli6LRQMEpAtpbEkdEaqZvU/dzJ9LxhNCmjFm8j\nqHnsXleGQbVFmnnw2cpJsfpSMlgKs7WvY5QP/sEnmpVoDI0zllJOQ4xbYYGo1GX1\nPq+xR+YdU+KS9DnUc4DX0xSQvnnz6tkpB4LBmTQoDZKtJ77IC1PWOIqE2R8BpTkY\n/WXij2RrUrU2goYWgaZ4ho4CaVR+/8eeHQIkyjrdRlIY+5NiOvfP5vqFlaRx2qFn\nyc76KrlfgGPhjqjPog4sPGWLVqrhSMAFAuWU/avQ+83eeKB+6/BkJDYfZmvcy4YE\n/ZlyMnjveEilzMysz3YTWgg7ZyKmYxKe8wGqcpfwgCupUojKpJylHd1gGSPZZ5Dc\nf+aWuyLojxk39c8W1GpFRuBuEo0orII1DSZ0CBtG45P21MG8V9sLe5ebaALHYffG\nvrqNbHpbpzIA8cEZVzS9KNiOxiyOYdTACO6nyP/Htac44Ip9xD4/lvdMLXo29Dgu\nhsQ6rjZyTrU=\n=KRUE\n-----END PGP SIGNATURE-----", "payload": "tree 864a1ed313967064ef4fc0afda1d3fc715db2b9d\nparent 20081880ad2a98bbc8c8293f96c5b284d1584d86\nauthor Alan Egerton <eggyal@gmail.com> 1675947393 +0000\ncommitter Alan Egerton <eggyal@gmail.com> 1676283885 +0000\n\nMove folding & visiting traits to ir submodules\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/62846d7c99ca4e17be8c6867fc4b50d10c8a6ec1", "html_url": "https://github.com/rust-lang/rust/commit/62846d7c99ca4e17be8c6867fc4b50d10c8a6ec1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/62846d7c99ca4e17be8c6867fc4b50d10c8a6ec1/comments", "author": {"login": "eggyal", "id": 3089613, "node_id": "MDQ6VXNlcjMwODk2MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/3089613?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eggyal", "html_url": "https://github.com/eggyal", "followers_url": "https://api.github.com/users/eggyal/followers", "following_url": "https://api.github.com/users/eggyal/following{/other_user}", "gists_url": "https://api.github.com/users/eggyal/gists{/gist_id}", "starred_url": "https://api.github.com/users/eggyal/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eggyal/subscriptions", "organizations_url": "https://api.github.com/users/eggyal/orgs", "repos_url": "https://api.github.com/users/eggyal/repos", "events_url": "https://api.github.com/users/eggyal/events{/privacy}", "received_events_url": "https://api.github.com/users/eggyal/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eggyal", "id": 3089613, "node_id": "MDQ6VXNlcjMwODk2MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/3089613?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eggyal", "html_url": "https://github.com/eggyal", "followers_url": "https://api.github.com/users/eggyal/followers", "following_url": "https://api.github.com/users/eggyal/following{/other_user}", "gists_url": "https://api.github.com/users/eggyal/gists{/gist_id}", "starred_url": "https://api.github.com/users/eggyal/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eggyal/subscriptions", "organizations_url": "https://api.github.com/users/eggyal/orgs", "repos_url": "https://api.github.com/users/eggyal/repos", "events_url": "https://api.github.com/users/eggyal/events{/privacy}", "received_events_url": "https://api.github.com/users/eggyal/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "20081880ad2a98bbc8c8293f96c5b284d1584d86", "url": "https://api.github.com/repos/rust-lang/rust/commits/20081880ad2a98bbc8c8293f96c5b284d1584d86", "html_url": "https://github.com/rust-lang/rust/commit/20081880ad2a98bbc8c8293f96c5b284d1584d86"}], "stats": {"total": 614, "additions": 322, "deletions": 292}, "files": [{"sha": "1b8f6e12c3fe95678e76d59270373bd2f0221bcd", "filename": "compiler/rustc_middle/src/ty/fold.rs", "status": "modified", "additions": 142, "deletions": 130, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/62846d7c99ca4e17be8c6867fc4b50d10c8a6ec1/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62846d7c99ca4e17be8c6867fc4b50d10c8a6ec1/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs?ref=62846d7c99ca4e17be8c6867fc4b50d10c8a6ec1", "patch": "@@ -48,161 +48,173 @@ use rustc_hir::def_id::DefId;\n \n use std::collections::BTreeMap;\n \n-/// This trait is implemented for every type that can be folded,\n-/// providing the skeleton of the traversal.\n-///\n-/// To implement this conveniently, use the derive macro located in\n-/// `rustc_macros`.\n-pub trait TypeFoldable<'tcx>: TypeVisitable<'tcx> {\n-    /// The entry point for folding. To fold a value `t` with a folder `f`\n-    /// call: `t.try_fold_with(f)`.\n-    ///\n-    /// For most types, this just traverses the value, calling `try_fold_with`\n-    /// on each field/element.\n-    ///\n-    /// For types of interest (such as `Ty`), the implementation of method\n-    /// calls a folder method specifically for that type (such as\n-    /// `F::try_fold_ty`). This is where control transfers from `TypeFoldable`\n-    /// to `TypeFolder`.\n-    fn try_fold_with<F: FallibleTypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error>;\n-\n-    /// A convenient alternative to `try_fold_with` for use with infallible\n-    /// folders. Do not override this method, to ensure coherence with\n-    /// `try_fold_with`.\n-    fn fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n-        self.try_fold_with(folder).into_ok()\n-    }\n-}\n+pub use ir::{FallibleTypeFolder, TypeFoldable, TypeFolder, TypeSuperFoldable};\n \n-// This trait is implemented for types of interest.\n-pub trait TypeSuperFoldable<'tcx>: TypeFoldable<'tcx> {\n-    /// Provides a default fold for a type of interest. This should only be\n-    /// called within `TypeFolder` methods, when a non-custom traversal is\n-    /// desired for the value of the type of interest passed to that method.\n-    /// For example, in `MyFolder::try_fold_ty(ty)`, it is valid to call\n-    /// `ty.try_super_fold_with(self)`, but any other folding should be done\n-    /// with `xyz.try_fold_with(self)`.\n-    fn try_super_fold_with<F: FallibleTypeFolder<'tcx>>(\n-        self,\n-        folder: &mut F,\n-    ) -> Result<Self, F::Error>;\n-\n-    /// A convenient alternative to `try_super_fold_with` for use with\n-    /// infallible folders. Do not override this method, to ensure coherence\n-    /// with `try_super_fold_with`.\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n-        self.try_super_fold_with(folder).into_ok()\n-    }\n-}\n+pub mod ir {\n+    use crate::ty::{self, ir::TypeVisitable, Binder, Ty, TyCtxt};\n \n-/// This trait is implemented for every infallible folding traversal. There is\n-/// a fold method defined for every type of interest. Each such method has a\n-/// default that does an \"identity\" fold. Implementations of these methods\n-/// often fall back to a `super_fold_with` method if the primary argument\n-/// doesn't satisfy a particular condition.\n-///\n-/// A blanket implementation of [`FallibleTypeFolder`] will defer to\n-/// the infallible methods of this trait to ensure that the two APIs\n-/// are coherent.\n-pub trait TypeFolder<'tcx>: FallibleTypeFolder<'tcx, Error = !> {\n-    fn tcx(&self) -> TyCtxt<'tcx>;\n-\n-    fn fold_binder<T>(&mut self, t: Binder<'tcx, T>) -> Binder<'tcx, T>\n-    where\n-        T: TypeFoldable<'tcx>,\n-    {\n-        t.super_fold_with(self)\n-    }\n-\n-    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        t.super_fold_with(self)\n+    /// This trait is implemented for every type that can be folded,\n+    /// providing the skeleton of the traversal.\n+    ///\n+    /// To implement this conveniently, use the derive macro located in\n+    /// `rustc_macros`.\n+    pub trait TypeFoldable<'tcx>: TypeVisitable<'tcx> {\n+        /// The entry point for folding. To fold a value `t` with a folder `f`\n+        /// call: `t.try_fold_with(f)`.\n+        ///\n+        /// For most types, this just traverses the value, calling `try_fold_with`\n+        /// on each field/element.\n+        ///\n+        /// For types of interest (such as `Ty`), the implementation of method\n+        /// calls a folder method specifically for that type (such as\n+        /// `F::try_fold_ty`). This is where control transfers from `TypeFoldable`\n+        /// to `TypeFolder`.\n+        fn try_fold_with<F: FallibleTypeFolder<'tcx>>(\n+            self,\n+            folder: &mut F,\n+        ) -> Result<Self, F::Error>;\n+\n+        /// A convenient alternative to `try_fold_with` for use with infallible\n+        /// folders. Do not override this method, to ensure coherence with\n+        /// `try_fold_with`.\n+        fn fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+            self.try_fold_with(folder).into_ok()\n+        }\n     }\n \n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n-        r.super_fold_with(self)\n+    // This trait is implemented for types of interest.\n+    pub trait TypeSuperFoldable<'tcx>: TypeFoldable<'tcx> {\n+        /// Provides a default fold for a type of interest. This should only be\n+        /// called within `TypeFolder` methods, when a non-custom traversal is\n+        /// desired for the value of the type of interest passed to that method.\n+        /// For example, in `MyFolder::try_fold_ty(ty)`, it is valid to call\n+        /// `ty.try_super_fold_with(self)`, but any other folding should be done\n+        /// with `xyz.try_fold_with(self)`.\n+        fn try_super_fold_with<F: FallibleTypeFolder<'tcx>>(\n+            self,\n+            folder: &mut F,\n+        ) -> Result<Self, F::Error>;\n+\n+        /// A convenient alternative to `try_super_fold_with` for use with\n+        /// infallible folders. Do not override this method, to ensure coherence\n+        /// with `try_super_fold_with`.\n+        fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+            self.try_super_fold_with(folder).into_ok()\n+        }\n     }\n \n-    fn fold_const(&mut self, c: ty::Const<'tcx>) -> ty::Const<'tcx> {\n-        c.super_fold_with(self)\n-    }\n+    /// This trait is implemented for every infallible folding traversal. There is\n+    /// a fold method defined for every type of interest. Each such method has a\n+    /// default that does an \"identity\" fold. Implementations of these methods\n+    /// often fall back to a `super_fold_with` method if the primary argument\n+    /// doesn't satisfy a particular condition.\n+    ///\n+    /// A blanket implementation of [`FallibleTypeFolder`] will defer to\n+    /// the infallible methods of this trait to ensure that the two APIs\n+    /// are coherent.\n+    pub trait TypeFolder<'tcx>: FallibleTypeFolder<'tcx, Error = !> {\n+        fn tcx(&self) -> TyCtxt<'tcx>;\n+\n+        fn fold_binder<T>(&mut self, t: Binder<'tcx, T>) -> Binder<'tcx, T>\n+        where\n+            T: TypeFoldable<'tcx>,\n+        {\n+            t.super_fold_with(self)\n+        }\n \n-    fn fold_predicate(&mut self, p: ty::Predicate<'tcx>) -> ty::Predicate<'tcx> {\n-        p.super_fold_with(self)\n-    }\n-}\n+        fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+            t.super_fold_with(self)\n+        }\n \n-/// This trait is implemented for every folding traversal. There is a fold\n-/// method defined for every type of interest. Each such method has a default\n-/// that does an \"identity\" fold.\n-///\n-/// A blanket implementation of this trait (that defers to the relevant\n-/// method of [`TypeFolder`]) is provided for all infallible folders in\n-/// order to ensure the two APIs are coherent.\n-pub trait FallibleTypeFolder<'tcx>: Sized {\n-    type Error;\n+        fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+            r.super_fold_with(self)\n+        }\n \n-    fn tcx<'a>(&'a self) -> TyCtxt<'tcx>;\n+        fn fold_const(&mut self, c: ty::Const<'tcx>) -> ty::Const<'tcx> {\n+            c.super_fold_with(self)\n+        }\n \n-    fn try_fold_binder<T>(&mut self, t: Binder<'tcx, T>) -> Result<Binder<'tcx, T>, Self::Error>\n-    where\n-        T: TypeFoldable<'tcx>,\n-    {\n-        t.try_super_fold_with(self)\n+        fn fold_predicate(&mut self, p: ty::Predicate<'tcx>) -> ty::Predicate<'tcx> {\n+            p.super_fold_with(self)\n+        }\n     }\n \n-    fn try_fold_ty(&mut self, t: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n-        t.try_super_fold_with(self)\n-    }\n+    /// This trait is implemented for every folding traversal. There is a fold\n+    /// method defined for every type of interest. Each such method has a default\n+    /// that does an \"identity\" fold.\n+    ///\n+    /// A blanket implementation of this trait (that defers to the relevant\n+    /// method of [`TypeFolder`]) is provided for all infallible folders in\n+    /// order to ensure the two APIs are coherent.\n+    pub trait FallibleTypeFolder<'tcx>: Sized {\n+        type Error;\n \n-    fn try_fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n-        r.try_super_fold_with(self)\n-    }\n+        fn tcx<'a>(&'a self) -> TyCtxt<'tcx>;\n \n-    fn try_fold_const(&mut self, c: ty::Const<'tcx>) -> Result<ty::Const<'tcx>, Self::Error> {\n-        c.try_super_fold_with(self)\n-    }\n+        fn try_fold_binder<T>(&mut self, t: Binder<'tcx, T>) -> Result<Binder<'tcx, T>, Self::Error>\n+        where\n+            T: TypeFoldable<'tcx>,\n+        {\n+            t.try_super_fold_with(self)\n+        }\n \n-    fn try_fold_predicate(\n-        &mut self,\n-        p: ty::Predicate<'tcx>,\n-    ) -> Result<ty::Predicate<'tcx>, Self::Error> {\n-        p.try_super_fold_with(self)\n-    }\n-}\n+        fn try_fold_ty(&mut self, t: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n+            t.try_super_fold_with(self)\n+        }\n \n-// This blanket implementation of the fallible trait for infallible folders\n-// delegates to infallible methods to ensure coherence.\n-impl<'tcx, F> FallibleTypeFolder<'tcx> for F\n-where\n-    F: TypeFolder<'tcx>,\n-{\n-    type Error = !;\n+        fn try_fold_region(\n+            &mut self,\n+            r: ty::Region<'tcx>,\n+        ) -> Result<ty::Region<'tcx>, Self::Error> {\n+            r.try_super_fold_with(self)\n+        }\n \n-    fn tcx<'a>(&'a self) -> TyCtxt<'tcx> {\n-        TypeFolder::tcx(self)\n+        fn try_fold_const(&mut self, c: ty::Const<'tcx>) -> Result<ty::Const<'tcx>, Self::Error> {\n+            c.try_super_fold_with(self)\n+        }\n+\n+        fn try_fold_predicate(\n+            &mut self,\n+            p: ty::Predicate<'tcx>,\n+        ) -> Result<ty::Predicate<'tcx>, Self::Error> {\n+            p.try_super_fold_with(self)\n+        }\n     }\n \n-    fn try_fold_binder<T>(&mut self, t: Binder<'tcx, T>) -> Result<Binder<'tcx, T>, !>\n+    // This blanket implementation of the fallible trait for infallible folders\n+    // delegates to infallible methods to ensure coherence.\n+    impl<'tcx, F> FallibleTypeFolder<'tcx> for F\n     where\n-        T: TypeFoldable<'tcx>,\n+        F: TypeFolder<'tcx>,\n     {\n-        Ok(self.fold_binder(t))\n-    }\n+        type Error = !;\n \n-    fn try_fold_ty(&mut self, t: Ty<'tcx>) -> Result<Ty<'tcx>, !> {\n-        Ok(self.fold_ty(t))\n-    }\n+        fn tcx<'a>(&'a self) -> TyCtxt<'tcx> {\n+            TypeFolder::tcx(self)\n+        }\n \n-    fn try_fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, !> {\n-        Ok(self.fold_region(r))\n-    }\n+        fn try_fold_binder<T>(&mut self, t: Binder<'tcx, T>) -> Result<Binder<'tcx, T>, !>\n+        where\n+            T: TypeFoldable<'tcx>,\n+        {\n+            Ok(self.fold_binder(t))\n+        }\n \n-    fn try_fold_const(&mut self, c: ty::Const<'tcx>) -> Result<ty::Const<'tcx>, !> {\n-        Ok(self.fold_const(c))\n-    }\n+        fn try_fold_ty(&mut self, t: Ty<'tcx>) -> Result<Ty<'tcx>, !> {\n+            Ok(self.fold_ty(t))\n+        }\n+\n+        fn try_fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, !> {\n+            Ok(self.fold_region(r))\n+        }\n+\n+        fn try_fold_const(&mut self, c: ty::Const<'tcx>) -> Result<ty::Const<'tcx>, !> {\n+            Ok(self.fold_const(c))\n+        }\n \n-    fn try_fold_predicate(&mut self, p: ty::Predicate<'tcx>) -> Result<ty::Predicate<'tcx>, !> {\n-        Ok(self.fold_predicate(p))\n+        fn try_fold_predicate(&mut self, p: ty::Predicate<'tcx>) -> Result<ty::Predicate<'tcx>, !> {\n+            Ok(self.fold_predicate(p))\n+        }\n     }\n }\n "}, {"sha": "f378c6fd8adf3e7e06cc8bdd1a1d7bd5fb59259e", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/62846d7c99ca4e17be8c6867fc4b50d10c8a6ec1/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62846d7c99ca4e17be8c6867fc4b50d10c8a6ec1/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=62846d7c99ca4e17be8c6867fc4b50d10c8a6ec1", "patch": "@@ -146,6 +146,10 @@ mod structural_impls;\n mod sty;\n mod typeck_results;\n \n+pub mod ir {\n+    pub use super::{fold::ir::*, visit::ir::*};\n+}\n+\n // Data types\n \n pub type RegisteredTools = FxHashSet<Ident>;"}, {"sha": "fe3fc4c88c577f8e511117cb0ae0a6af993fbe27", "filename": "compiler/rustc_middle/src/ty/visit.rs", "status": "modified", "additions": 176, "deletions": 162, "changes": 338, "blob_url": "https://github.com/rust-lang/rust/blob/62846d7c99ca4e17be8c6867fc4b50d10c8a6ec1/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62846d7c99ca4e17be8c6867fc4b50d10c8a6ec1/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs?ref=62846d7c99ca4e17be8c6867fc4b50d10c8a6ec1", "patch": "@@ -39,189 +39,203 @@\n //! - u.visit_with(visitor)\n //! ```\n use crate::ty::{self, flags::FlagComputation, Binder, Ty, TyCtxt, TypeFlags};\n-use rustc_errors::ErrorGuaranteed;\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sso::SsoHashSet;\n-use std::fmt;\n use std::ops::ControlFlow;\n \n-/// This trait is implemented for every type that can be visited,\n-/// providing the skeleton of the traversal.\n-///\n-/// To implement this conveniently, use the derive macro located in\n-/// `rustc_macros`.\n-pub trait TypeVisitable<'tcx>: fmt::Debug + Clone {\n-    /// The entry point for visiting. To visit a value `t` with a visitor `v`\n-    /// call: `t.visit_with(v)`.\n-    ///\n-    /// For most types, this just traverses the value, calling `visit_with` on\n-    /// each field/element.\n-    ///\n-    /// For types of interest (such as `Ty`), the implementation of this method\n-    /// that calls a visitor method specifically for that type (such as\n-    /// `V::visit_ty`). This is where control transfers from `TypeFoldable` to\n-    /// `TypeVisitor`.\n-    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy>;\n-\n-    /// Returns `true` if `self` has any late-bound regions that are either\n-    /// bound by `binder` or bound by some binder outside of `binder`.\n-    /// If `binder` is `ty::INNERMOST`, this indicates whether\n-    /// there are any late-bound regions that appear free.\n-    fn has_vars_bound_at_or_above(&self, binder: ty::DebruijnIndex) -> bool {\n-        self.visit_with(&mut HasEscapingVarsVisitor { outer_index: binder }).is_break()\n-    }\n-\n-    /// Returns `true` if this type has any regions that escape `binder` (and\n-    /// hence are not bound by it).\n-    fn has_vars_bound_above(&self, binder: ty::DebruijnIndex) -> bool {\n-        self.has_vars_bound_at_or_above(binder.shifted_in(1))\n-    }\n-\n-    /// Return `true` if this type has regions that are not a part of the type.\n-    /// For example, `for<'a> fn(&'a i32)` return `false`, while `fn(&'a i32)`\n-    /// would return `true`. The latter can occur when traversing through the\n-    /// former.\n+pub use ir::{TypeSuperVisitable, TypeVisitable, TypeVisitor};\n+\n+pub mod ir {\n+    use crate::ty::{self, Binder, Ty, TypeFlags};\n+    use rustc_errors::ErrorGuaranteed;\n+\n+    use std::fmt;\n+    use std::ops::ControlFlow;\n+\n+    use super::{FoundFlags, HasEscapingVarsVisitor, HasTypeFlagsVisitor};\n+\n+    /// This trait is implemented for every type that can be visited,\n+    /// providing the skeleton of the traversal.\n     ///\n-    /// See [`HasEscapingVarsVisitor`] for more information.\n-    fn has_escaping_bound_vars(&self) -> bool {\n-        self.has_vars_bound_at_or_above(ty::INNERMOST)\n-    }\n+    /// To implement this conveniently, use the derive macro located in\n+    /// `rustc_macros`.\n+    pub trait TypeVisitable<'tcx>: fmt::Debug + Clone {\n+        /// The entry point for visiting. To visit a value `t` with a visitor `v`\n+        /// call: `t.visit_with(v)`.\n+        ///\n+        /// For most types, this just traverses the value, calling `visit_with` on\n+        /// each field/element.\n+        ///\n+        /// For types of interest (such as `Ty`), the implementation of this method\n+        /// that calls a visitor method specifically for that type (such as\n+        /// `V::visit_ty`). This is where control transfers from `TypeFoldable` to\n+        /// `TypeVisitor`.\n+        fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy>;\n+\n+        /// Returns `true` if `self` has any late-bound regions that are either\n+        /// bound by `binder` or bound by some binder outside of `binder`.\n+        /// If `binder` is `ty::INNERMOST`, this indicates whether\n+        /// there are any late-bound regions that appear free.\n+        fn has_vars_bound_at_or_above(&self, binder: ty::DebruijnIndex) -> bool {\n+            self.visit_with(&mut HasEscapingVarsVisitor { outer_index: binder }).is_break()\n+        }\n \n-    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n-        let res =\n-            self.visit_with(&mut HasTypeFlagsVisitor { flags }).break_value() == Some(FoundFlags);\n-        trace!(?self, ?flags, ?res, \"has_type_flags\");\n-        res\n-    }\n-    fn has_projections(&self) -> bool {\n-        self.has_type_flags(TypeFlags::HAS_PROJECTION)\n-    }\n-    fn has_opaque_types(&self) -> bool {\n-        self.has_type_flags(TypeFlags::HAS_TY_OPAQUE)\n-    }\n-    fn has_generators(&self) -> bool {\n-        self.has_type_flags(TypeFlags::HAS_TY_GENERATOR)\n-    }\n-    fn references_error(&self) -> bool {\n-        self.has_type_flags(TypeFlags::HAS_ERROR)\n-    }\n-    fn error_reported(&self) -> Result<(), ErrorGuaranteed> {\n-        if self.references_error() {\n-            if let Some(reported) = ty::tls::with(|tcx| tcx.sess.is_compilation_going_to_fail()) {\n-                Err(reported)\n+        /// Returns `true` if this type has any regions that escape `binder` (and\n+        /// hence are not bound by it).\n+        fn has_vars_bound_above(&self, binder: ty::DebruijnIndex) -> bool {\n+            self.has_vars_bound_at_or_above(binder.shifted_in(1))\n+        }\n+\n+        /// Return `true` if this type has regions that are not a part of the type.\n+        /// For example, `for<'a> fn(&'a i32)` return `false`, while `fn(&'a i32)`\n+        /// would return `true`. The latter can occur when traversing through the\n+        /// former.\n+        ///\n+        /// See [`HasEscapingVarsVisitor`] for more information.\n+        fn has_escaping_bound_vars(&self) -> bool {\n+            self.has_vars_bound_at_or_above(ty::INNERMOST)\n+        }\n+\n+        fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+            let res = self.visit_with(&mut HasTypeFlagsVisitor { flags }).break_value()\n+                == Some(FoundFlags);\n+            trace!(?self, ?flags, ?res, \"has_type_flags\");\n+            res\n+        }\n+        fn has_projections(&self) -> bool {\n+            self.has_type_flags(TypeFlags::HAS_PROJECTION)\n+        }\n+        fn has_opaque_types(&self) -> bool {\n+            self.has_type_flags(TypeFlags::HAS_TY_OPAQUE)\n+        }\n+        fn has_generators(&self) -> bool {\n+            self.has_type_flags(TypeFlags::HAS_TY_GENERATOR)\n+        }\n+        fn references_error(&self) -> bool {\n+            self.has_type_flags(TypeFlags::HAS_ERROR)\n+        }\n+        fn error_reported(&self) -> Result<(), ErrorGuaranteed> {\n+            if self.references_error() {\n+                if let Some(reported) = ty::tls::with(|tcx| tcx.sess.is_compilation_going_to_fail())\n+                {\n+                    Err(reported)\n+                } else {\n+                    bug!(\"expect tcx.sess.is_compilation_going_to_fail return `Some`\");\n+                }\n             } else {\n-                bug!(\"expect tcx.sess.is_compilation_going_to_fail return `Some`\");\n+                Ok(())\n             }\n-        } else {\n-            Ok(())\n         }\n-    }\n-    fn has_non_region_param(&self) -> bool {\n-        self.has_type_flags(TypeFlags::NEEDS_SUBST - TypeFlags::HAS_RE_PARAM)\n-    }\n-    fn has_infer_regions(&self) -> bool {\n-        self.has_type_flags(TypeFlags::HAS_RE_INFER)\n-    }\n-    fn has_infer_types(&self) -> bool {\n-        self.has_type_flags(TypeFlags::HAS_TY_INFER)\n-    }\n-    fn has_non_region_infer(&self) -> bool {\n-        self.has_type_flags(TypeFlags::NEEDS_INFER - TypeFlags::HAS_RE_INFER)\n-    }\n-    fn needs_infer(&self) -> bool {\n-        self.has_type_flags(TypeFlags::NEEDS_INFER)\n-    }\n-    fn has_placeholders(&self) -> bool {\n-        self.has_type_flags(\n-            TypeFlags::HAS_RE_PLACEHOLDER\n-                | TypeFlags::HAS_TY_PLACEHOLDER\n-                | TypeFlags::HAS_CT_PLACEHOLDER,\n-        )\n-    }\n-    fn needs_subst(&self) -> bool {\n-        self.has_type_flags(TypeFlags::NEEDS_SUBST)\n-    }\n-    /// \"Free\" regions in this context means that it has any region\n-    /// that is not (a) erased or (b) late-bound.\n-    fn has_free_regions(&self) -> bool {\n-        self.has_type_flags(TypeFlags::HAS_FREE_REGIONS)\n-    }\n+        fn has_non_region_param(&self) -> bool {\n+            self.has_type_flags(TypeFlags::NEEDS_SUBST - TypeFlags::HAS_RE_PARAM)\n+        }\n+        fn has_infer_regions(&self) -> bool {\n+            self.has_type_flags(TypeFlags::HAS_RE_INFER)\n+        }\n+        fn has_infer_types(&self) -> bool {\n+            self.has_type_flags(TypeFlags::HAS_TY_INFER)\n+        }\n+        fn has_non_region_infer(&self) -> bool {\n+            self.has_type_flags(TypeFlags::NEEDS_INFER - TypeFlags::HAS_RE_INFER)\n+        }\n+        fn needs_infer(&self) -> bool {\n+            self.has_type_flags(TypeFlags::NEEDS_INFER)\n+        }\n+        fn has_placeholders(&self) -> bool {\n+            self.has_type_flags(\n+                TypeFlags::HAS_RE_PLACEHOLDER\n+                    | TypeFlags::HAS_TY_PLACEHOLDER\n+                    | TypeFlags::HAS_CT_PLACEHOLDER,\n+            )\n+        }\n+        fn needs_subst(&self) -> bool {\n+            self.has_type_flags(TypeFlags::NEEDS_SUBST)\n+        }\n+        /// \"Free\" regions in this context means that it has any region\n+        /// that is not (a) erased or (b) late-bound.\n+        fn has_free_regions(&self) -> bool {\n+            self.has_type_flags(TypeFlags::HAS_FREE_REGIONS)\n+        }\n \n-    fn has_erased_regions(&self) -> bool {\n-        self.has_type_flags(TypeFlags::HAS_RE_ERASED)\n-    }\n+        fn has_erased_regions(&self) -> bool {\n+            self.has_type_flags(TypeFlags::HAS_RE_ERASED)\n+        }\n \n-    /// True if there are any un-erased free regions.\n-    fn has_erasable_regions(&self) -> bool {\n-        self.has_type_flags(TypeFlags::HAS_FREE_REGIONS)\n-    }\n+        /// True if there are any un-erased free regions.\n+        fn has_erasable_regions(&self) -> bool {\n+            self.has_type_flags(TypeFlags::HAS_FREE_REGIONS)\n+        }\n \n-    /// Indicates whether this value references only 'global'\n-    /// generic parameters that are the same regardless of what fn we are\n-    /// in. This is used for caching.\n-    fn is_global(&self) -> bool {\n-        !self.has_type_flags(TypeFlags::HAS_FREE_LOCAL_NAMES)\n-    }\n+        /// Indicates whether this value references only 'global'\n+        /// generic parameters that are the same regardless of what fn we are\n+        /// in. This is used for caching.\n+        fn is_global(&self) -> bool {\n+            !self.has_type_flags(TypeFlags::HAS_FREE_LOCAL_NAMES)\n+        }\n \n-    /// True if there are any late-bound regions\n-    fn has_late_bound_regions(&self) -> bool {\n-        self.has_type_flags(TypeFlags::HAS_RE_LATE_BOUND)\n-    }\n-    /// True if there are any late-bound non-region variables\n-    fn has_non_region_late_bound(&self) -> bool {\n-        self.has_type_flags(TypeFlags::HAS_LATE_BOUND - TypeFlags::HAS_RE_LATE_BOUND)\n-    }\n-    /// True if there are any late-bound variables\n-    fn has_late_bound_vars(&self) -> bool {\n-        self.has_type_flags(TypeFlags::HAS_LATE_BOUND)\n-    }\n+        /// True if there are any late-bound regions\n+        fn has_late_bound_regions(&self) -> bool {\n+            self.has_type_flags(TypeFlags::HAS_RE_LATE_BOUND)\n+        }\n+        /// True if there are any late-bound non-region variables\n+        fn has_non_region_late_bound(&self) -> bool {\n+            self.has_type_flags(TypeFlags::HAS_LATE_BOUND - TypeFlags::HAS_RE_LATE_BOUND)\n+        }\n+        /// True if there are any late-bound variables\n+        fn has_late_bound_vars(&self) -> bool {\n+            self.has_type_flags(TypeFlags::HAS_LATE_BOUND)\n+        }\n \n-    /// Indicates whether this value still has parameters/placeholders/inference variables\n-    /// which could be replaced later, in a way that would change the results of `impl`\n-    /// specialization.\n-    fn still_further_specializable(&self) -> bool {\n-        self.has_type_flags(TypeFlags::STILL_FURTHER_SPECIALIZABLE)\n+        /// Indicates whether this value still has parameters/placeholders/inference variables\n+        /// which could be replaced later, in a way that would change the results of `impl`\n+        /// specialization.\n+        fn still_further_specializable(&self) -> bool {\n+            self.has_type_flags(TypeFlags::STILL_FURTHER_SPECIALIZABLE)\n+        }\n     }\n-}\n-\n-pub trait TypeSuperVisitable<'tcx>: TypeVisitable<'tcx> {\n-    /// Provides a default visit for a type of interest. This should only be\n-    /// called within `TypeVisitor` methods, when a non-custom traversal is\n-    /// desired for the value of the type of interest passed to that method.\n-    /// For example, in `MyVisitor::visit_ty(ty)`, it is valid to call\n-    /// `ty.super_visit_with(self)`, but any other visiting should be done\n-    /// with `xyz.visit_with(self)`.\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy>;\n-}\n-\n-/// This trait is implemented for every visiting traversal. There is a visit\n-/// method defined for every type of interest. Each such method has a default\n-/// that recurses into the type's fields in a non-custom fashion.\n-pub trait TypeVisitor<'tcx>: Sized {\n-    type BreakTy = !;\n \n-    fn visit_binder<T: TypeVisitable<'tcx>>(\n-        &mut self,\n-        t: &Binder<'tcx, T>,\n-    ) -> ControlFlow<Self::BreakTy> {\n-        t.super_visit_with(self)\n-    }\n+    pub trait TypeSuperVisitable<'tcx>: TypeVisitable<'tcx> {\n+        /// Provides a default visit for a type of interest. This should only be\n+        /// called within `TypeVisitor` methods, when a non-custom traversal is\n+        /// desired for the value of the type of interest passed to that method.\n+        /// For example, in `MyVisitor::visit_ty(ty)`, it is valid to call\n+        /// `ty.super_visit_with(self)`, but any other visiting should be done\n+        /// with `xyz.visit_with(self)`.\n+        fn super_visit_with<V: TypeVisitor<'tcx>>(\n+            &self,\n+            visitor: &mut V,\n+        ) -> ControlFlow<V::BreakTy>;\n+    }\n+\n+    /// This trait is implemented for every visiting traversal. There is a visit\n+    /// method defined for every type of interest. Each such method has a default\n+    /// that recurses into the type's fields in a non-custom fashion.\n+    pub trait TypeVisitor<'tcx>: Sized {\n+        type BreakTy = !;\n+\n+        fn visit_binder<T: TypeVisitable<'tcx>>(\n+            &mut self,\n+            t: &Binder<'tcx, T>,\n+        ) -> ControlFlow<Self::BreakTy> {\n+            t.super_visit_with(self)\n+        }\n \n-    fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        t.super_visit_with(self)\n-    }\n+        fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n+            t.super_visit_with(self)\n+        }\n \n-    fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        r.super_visit_with(self)\n-    }\n+        fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n+            r.super_visit_with(self)\n+        }\n \n-    fn visit_const(&mut self, c: ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        c.super_visit_with(self)\n-    }\n+        fn visit_const(&mut self, c: ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n+            c.super_visit_with(self)\n+        }\n \n-    fn visit_predicate(&mut self, p: ty::Predicate<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        p.super_visit_with(self)\n+        fn visit_predicate(&mut self, p: ty::Predicate<'tcx>) -> ControlFlow<Self::BreakTy> {\n+            p.super_visit_with(self)\n+        }\n     }\n }\n "}]}