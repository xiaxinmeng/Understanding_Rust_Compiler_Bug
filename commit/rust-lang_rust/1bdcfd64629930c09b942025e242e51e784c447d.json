{"sha": "1bdcfd64629930c09b942025e242e51e784c447d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiZGNmZDY0NjI5OTMwYzA5Yjk0MjAyNWUyNDJlNTFlNzg0YzQ0N2Q=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-21T15:42:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-21T15:42:42Z"}, "message": "auto merge of #19961 : alexcrichton/rust/second-pass-result, r=aturon\n\nThis commit, like the second pass of `Option`, largely just stablizes the\r\nexisting functionality after renaming a few iterators.\r\n\r\nThe specific actions taken were:\r\n\r\n* The `Ok` and `Err` variants were marked `#[stable]` as the stability\r\n  inheritance was since removed.\r\n* The `as_mut` method is now stable.\r\n* The `map` method is now stable\r\n* The `map_err` method is now stable\r\n* The `iter`, `iter_mut`, and `into_iter` methods now returned structures named\r\n  after the method of iteration. The methods are also now all stable.\r\n* The `and_then` method is now stable.\r\n* The `or_else` method is now stable.\r\n* The `unwrap` family of functions are now all stable: `unwrap_or`,\r\n  `unwrap_or_else`, `unwrap`, and `unwrap_err`.\r\n\r\nThere is a possible open extension to `Result::{and, and_then}` to make the\r\nreturn type further generic over `FromError` (as proposed in #19078), but this\r\nis a backwards compatible change due to the usage of default type parameters,\r\nwhich makes the two functions safe to stabilize now regardless of the outcome of\r\nthat issue.", "tree": {"sha": "39961418219d2f2a9559afd46de749183cda66c1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/39961418219d2f2a9559afd46de749183cda66c1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1bdcfd64629930c09b942025e242e51e784c447d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1bdcfd64629930c09b942025e242e51e784c447d", "html_url": "https://github.com/rust-lang/rust/commit/1bdcfd64629930c09b942025e242e51e784c447d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1bdcfd64629930c09b942025e242e51e784c447d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c141f223d4fd4d8c8be8649877e08ddceaa43783", "url": "https://api.github.com/repos/rust-lang/rust/commits/c141f223d4fd4d8c8be8649877e08ddceaa43783", "html_url": "https://github.com/rust-lang/rust/commit/c141f223d4fd4d8c8be8649877e08ddceaa43783"}, {"sha": "a71686f4ea1a265f15adfbe850305f65453ef550", "url": "https://api.github.com/repos/rust-lang/rust/commits/a71686f4ea1a265f15adfbe850305f65453ef550", "html_url": "https://github.com/rust-lang/rust/commit/a71686f4ea1a265f15adfbe850305f65453ef550"}], "stats": {"total": 144, "additions": 90, "deletions": 54}, "files": [{"sha": "b59734a7d9881052bc27c1e61c898ed264efb77f", "filename": "src/libcore/result.rs", "status": "modified", "additions": 90, "deletions": 54, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/1bdcfd64629930c09b942025e242e51e784c447d/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bdcfd64629930c09b942025e242e51e784c447d/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=1bdcfd64629930c09b942025e242e51e784c447d", "patch": "@@ -230,15 +230,15 @@\n \n #![stable]\n \n-use self::Result::*;\n+use self::Result::{Ok, Err};\n \n-use std::fmt::Show;\n-use slice;\n-use slice::AsSlice;\n+use clone::Clone;\n+use fmt::Show;\n use iter::{Iterator, IteratorExt, DoubleEndedIterator, FromIterator, ExactSizeIterator};\n-use option::Option;\n-use option::Option::{None, Some};\n use ops::{FnMut, FnOnce};\n+use option::Option::{mod, None, Some};\n+use slice::AsSlice;\n+use slice;\n \n /// `Result` is a type that represents either success (`Ok`) or failure (`Err`).\n ///\n@@ -248,16 +248,19 @@ use ops::{FnMut, FnOnce};\n #[stable]\n pub enum Result<T, E> {\n     /// Contains the success value\n+    #[stable]\n     Ok(T),\n \n     /// Contains the error value\n+    #[stable]\n     Err(E)\n }\n \n /////////////////////////////////////////////////////////////////////////////\n // Type implementation\n /////////////////////////////////////////////////////////////////////////////\n \n+#[stable]\n impl<T, E> Result<T, E> {\n     /////////////////////////////////////////////////////////////////////////\n     // Querying the contained values\n@@ -300,7 +303,6 @@ impl<T, E> Result<T, E> {\n         !self.is_ok()\n     }\n \n-\n     /////////////////////////////////////////////////////////////////////////\n     // Adapter for each variant\n     /////////////////////////////////////////////////////////////////////////\n@@ -369,7 +371,7 @@ impl<T, E> Result<T, E> {\n     /// ```\n     #[inline]\n     #[stable]\n-    pub fn as_ref<'r>(&'r self) -> Result<&'r T, &'r E> {\n+    pub fn as_ref(&self) -> Result<&T, &E> {\n         match *self {\n             Ok(ref x) => Ok(x),\n             Err(ref x) => Err(x),\n@@ -395,8 +397,8 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.unwrap_err(), 0);\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for mut conventions\"]\n-    pub fn as_mut<'r>(&'r mut self) -> Result<&'r mut T, &'r mut E> {\n+    #[stable]\n+    pub fn as_mut(&mut self) -> Result<&mut T, &mut E> {\n         match *self {\n             Ok(ref mut x) => Ok(x),\n             Err(ref mut x) => Err(x),\n@@ -420,7 +422,7 @@ impl<T, E> Result<T, E> {\n     /// ```\n     #[inline]\n     #[unstable = \"waiting for mut conventions\"]\n-    pub fn as_mut_slice<'r>(&'r mut self) -> &'r mut [T] {\n+    pub fn as_mut_slice(&mut self) -> &mut [T] {\n         match *self {\n             Ok(ref mut x) => slice::mut_ref_slice(x),\n             Err(_) => {\n@@ -465,11 +467,11 @@ impl<T, E> Result<T, E> {\n     /// assert!(sum == 10);\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for unboxed closures\"]\n+    #[stable]\n     pub fn map<U, F: FnOnce(T) -> U>(self, op: F) -> Result<U,E> {\n         match self {\n-          Ok(t) => Ok(op(t)),\n-          Err(e) => Err(e)\n+            Ok(t) => Ok(op(t)),\n+            Err(e) => Err(e)\n         }\n     }\n \n@@ -491,15 +493,14 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.map_err(stringify), Err(\"error code: 13\".to_string()));\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for unboxed closures\"]\n+    #[stable]\n     pub fn map_err<F, O: FnOnce(E) -> F>(self, op: O) -> Result<T,F> {\n         match self {\n-          Ok(t) => Ok(t),\n-          Err(e) => Err(op(e))\n+            Ok(t) => Ok(t),\n+            Err(e) => Err(op(e))\n         }\n     }\n \n-\n     /////////////////////////////////////////////////////////////////////////\n     // Iterator constructors\n     /////////////////////////////////////////////////////////////////////////\n@@ -516,9 +517,9 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.iter().next(), None);\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for iterator conventions\"]\n-    pub fn iter<'r>(&'r self) -> Item<&'r T> {\n-        Item{opt: self.as_ref().ok()}\n+    #[stable]\n+    pub fn iter(&self) -> Iter<T> {\n+        Iter { inner: self.as_ref().ok() }\n     }\n \n     /// Returns a mutable iterator over the possibly contained value.\n@@ -537,9 +538,9 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.iter_mut().next(), None);\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for iterator conventions\"]\n-    pub fn iter_mut<'r>(&'r mut self) -> Item<&'r mut T> {\n-        Item{opt: self.as_mut().ok()}\n+    #[stable]\n+    pub fn iter_mut(&mut self) -> IterMut<T> {\n+        IterMut { inner: self.as_mut().ok() }\n     }\n \n     /// Returns a consuming iterator over the possibly contained value.\n@@ -556,9 +557,9 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(v, vec![]);\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for iterator conventions\"]\n-    pub fn into_iter(self) -> Item<T> {\n-        Item{opt: self.ok()}\n+    #[stable]\n+    pub fn into_iter(self) -> IntoIter<T> {\n+        IntoIter { inner: self.ok() }\n     }\n \n     ////////////////////////////////////////////////////////////////////////\n@@ -611,7 +612,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(Err(3).and_then(sq).and_then(sq), Err(3));\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for unboxed closures\"]\n+    #[stable]\n     pub fn and_then<U, F: FnOnce(T) -> Result<U, E>>(self, op: F) -> Result<U, E> {\n         match self {\n             Ok(t) => op(t),\n@@ -665,7 +666,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(Err(3).or_else(err).or_else(err), Err(3));\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for unboxed closures\"]\n+    #[stable]\n     pub fn or_else<F, O: FnOnce(E) -> Result<T, F>>(self, op: O) -> Result<T, F> {\n         match self {\n             Ok(t) => Ok(t),\n@@ -687,7 +688,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.unwrap_or(optb), optb);\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for conventions\"]\n+    #[stable]\n     pub fn unwrap_or(self, optb: T) -> T {\n         match self {\n             Ok(t) => t,\n@@ -707,7 +708,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(Err(\"foo\").unwrap_or_else(count), 3u);\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for conventions\"]\n+    #[stable]\n     pub fn unwrap_or_else<F: FnOnce(E) -> T>(self, op: F) -> T {\n         match self {\n             Ok(t) => t,\n@@ -716,6 +717,7 @@ impl<T, E> Result<T, E> {\n     }\n }\n \n+#[stable]\n impl<T, E: Show> Result<T, E> {\n     /// Unwraps a result, yielding the content of an `Ok`.\n     ///\n@@ -736,7 +738,7 @@ impl<T, E: Show> Result<T, E> {\n     /// x.unwrap(); // panics with `emergency failure`\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for conventions\"]\n+    #[stable]\n     pub fn unwrap(self) -> T {\n         match self {\n             Ok(t) => t,\n@@ -746,6 +748,7 @@ impl<T, E: Show> Result<T, E> {\n     }\n }\n \n+#[stable]\n impl<T: Show, E> Result<T, E> {\n     /// Unwraps a result, yielding the content of an `Err`.\n     ///\n@@ -766,7 +769,7 @@ impl<T: Show, E> Result<T, E> {\n     /// assert_eq!(x.unwrap_err(), \"emergency failure\");\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for conventions\"]\n+    #[stable]\n     pub fn unwrap_err(self) -> E {\n         match self {\n             Ok(t) =>\n@@ -797,42 +800,75 @@ impl<T, E> AsSlice<T> for Result<T, E> {\n }\n \n /////////////////////////////////////////////////////////////////////////////\n-// The Result Iterator\n+// The Result Iterators\n /////////////////////////////////////////////////////////////////////////////\n \n-/// A `Result` iterator that yields either one or zero elements\n-///\n-/// The `Item` iterator is returned by the `iter`, `iter_mut` and `into_iter`\n-/// methods on `Result`.\n-#[deriving(Clone)]\n-#[unstable = \"waiting for iterator conventions\"]\n-pub struct Item<T> {\n-    opt: Option<T>\n-}\n+/// An iterator over a reference to the `Ok` variant of a `Result`.\n+#[stable]\n+pub struct Iter<'a, T: 'a> { inner: Option<&'a T> }\n \n-impl<T> Iterator<T> for Item<T> {\n+impl<'a, T> Iterator<&'a T> for Iter<'a, T> {\n     #[inline]\n-    fn next(&mut self) -> Option<T> {\n-        self.opt.take()\n+    fn next(&mut self) -> Option<&'a T> { self.inner.take() }\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        let n = if self.inner.is_some() {1} else {0};\n+        (n, Some(n))\n     }\n+}\n+\n+impl<'a, T> DoubleEndedIterator<&'a T> for Iter<'a, T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a T> { self.inner.take() }\n+}\n+\n+impl<'a, T> ExactSizeIterator<&'a T> for Iter<'a, T> {}\n+\n+impl<'a, T> Clone for Iter<'a, T> {\n+    fn clone(&self) -> Iter<'a, T> { Iter { inner: self.inner } }\n+}\n+\n+/// An iterator over a mutable reference to the `Ok` variant of a `Result`.\n+#[stable]\n+pub struct IterMut<'a, T: 'a> { inner: Option<&'a mut T> }\n \n+impl<'a, T> Iterator<&'a mut T> for IterMut<'a, T> {\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a mut T> { self.inner.take() }\n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) {\n-        match self.opt {\n-            Some(_) => (1, Some(1)),\n-            None => (0, Some(0)),\n-        }\n+        let n = if self.inner.is_some() {1} else {0};\n+        (n, Some(n))\n     }\n }\n \n-impl<A> DoubleEndedIterator<A> for Item<A> {\n+impl<'a, T> DoubleEndedIterator<&'a mut T> for IterMut<'a, T> {\n     #[inline]\n-    fn next_back(&mut self) -> Option<A> {\n-        self.opt.take()\n+    fn next_back(&mut self) -> Option<&'a mut T> { self.inner.take() }\n+}\n+\n+impl<'a, T> ExactSizeIterator<&'a mut T> for IterMut<'a, T> {}\n+\n+/// An iterator over the value in a `Ok` variant of a `Result`.\n+#[stable]\n+pub struct IntoIter<T> { inner: Option<T> }\n+\n+impl<T> Iterator<T> for IntoIter<T> {\n+    #[inline]\n+    fn next(&mut self) -> Option<T> { self.inner.take() }\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        let n = if self.inner.is_some() {1} else {0};\n+        (n, Some(n))\n     }\n }\n \n-impl<A> ExactSizeIterator<A> for Item<A> {}\n+impl<T> DoubleEndedIterator<T> for IntoIter<T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<T> { self.inner.take() }\n+}\n+\n+impl<T> ExactSizeIterator<T> for IntoIter<T> {}\n \n /////////////////////////////////////////////////////////////////////////////\n // FromIterator"}]}