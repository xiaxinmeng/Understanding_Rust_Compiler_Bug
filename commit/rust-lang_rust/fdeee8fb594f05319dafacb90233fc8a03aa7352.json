{"sha": "fdeee8fb594f05319dafacb90233fc8a03aa7352", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkZWVlOGZiNTk0ZjA1MzE5ZGFmYWNiOTAyMzNmYzhhMDNhYTczNTI=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-03-29T07:10:05Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-03-29T07:10:05Z"}, "message": "Cleanup the diff", "tree": {"sha": "6f6cfafb408b0d73cda8a437e3fe4e921b177a47", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f6cfafb408b0d73cda8a437e3fe4e921b177a47"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fdeee8fb594f05319dafacb90233fc8a03aa7352", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fdeee8fb594f05319dafacb90233fc8a03aa7352", "html_url": "https://github.com/rust-lang/rust/commit/fdeee8fb594f05319dafacb90233fc8a03aa7352", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fdeee8fb594f05319dafacb90233fc8a03aa7352/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "065e9593b4f63889fad8b8cf29a52a4791fddc3f", "url": "https://api.github.com/repos/rust-lang/rust/commits/065e9593b4f63889fad8b8cf29a52a4791fddc3f", "html_url": "https://github.com/rust-lang/rust/commit/065e9593b4f63889fad8b8cf29a52a4791fddc3f"}], "stats": {"total": 45, "additions": 23, "deletions": 22}, "files": [{"sha": "bf5623e485bfeb01c771d77e2c07df6b0089148f", "filename": "src/terminator/intrinsic.rs", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/fdeee8fb594f05319dafacb90233fc8a03aa7352/src%2Fterminator%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdeee8fb594f05319dafacb90233fc8a03aa7352/src%2Fterminator%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fintrinsic.rs?ref=fdeee8fb594f05319dafacb90233fc8a03aa7352", "patch": "@@ -28,6 +28,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         let usize = self.tcx.types.usize;\n         let f32 = self.tcx.types.f32;\n         let f64 = self.tcx.types.f64;\n+        let substs = instance.substs;\n \n         let intrinsic_name = &self.tcx.item_name(instance.def_id()).as_str()[..];\n         match intrinsic_name {\n@@ -58,7 +59,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"atomic_load_relaxed\" |\n             \"atomic_load_acq\" |\n             \"volatile_load\" => {\n-                let ty = instance.substs.type_at(0);\n+                let ty = substs.type_at(0);\n                 let ptr = arg_vals[0].read_ptr(&self.memory)?;\n                 self.write_value(Value::ByRef(ptr), dest, ty)?;\n             }\n@@ -67,7 +68,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"atomic_store_relaxed\" |\n             \"atomic_store_rel\" |\n             \"volatile_store\" => {\n-                let ty = instance.substs.type_at(0);\n+                let ty = substs.type_at(0);\n                 let dest = arg_vals[0].read_ptr(&self.memory)?;\n                 self.write_value_to_ptr(arg_vals[1], dest, ty)?;\n             }\n@@ -77,7 +78,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             _ if intrinsic_name.starts_with(\"atomic_xchg\") => {\n-                let ty = instance.substs.type_at(0);\n+                let ty = substs.type_at(0);\n                 let ptr = arg_vals[0].read_ptr(&self.memory)?;\n                 let change = self.value_to_primval(arg_vals[1], ty)?;\n                 let old = self.read_value(ptr, ty)?;\n@@ -91,7 +92,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             _ if intrinsic_name.starts_with(\"atomic_cxchg\") => {\n-                let ty = instance.substs.type_at(0);\n+                let ty = substs.type_at(0);\n                 let ptr = arg_vals[0].read_ptr(&self.memory)?;\n                 let expect_old = self.value_to_primval(arg_vals[1], ty)?;\n                 let change = self.value_to_primval(arg_vals[2], ty)?;\n@@ -113,7 +114,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"atomic_and\" | \"atomic_and_acq\" | \"atomic_and_rel\" | \"atomic_and_acqrel\" | \"atomic_and_relaxed\" |\n             \"atomic_xadd\" | \"atomic_xadd_acq\" | \"atomic_xadd_rel\" | \"atomic_xadd_acqrel\" | \"atomic_xadd_relaxed\" |\n             \"atomic_xsub\" | \"atomic_xsub_acq\" | \"atomic_xsub_rel\" | \"atomic_xsub_acqrel\" | \"atomic_xsub_relaxed\" => {\n-                let ty = instance.substs.type_at(0);\n+                let ty = substs.type_at(0);\n                 let ptr = arg_vals[0].read_ptr(&self.memory)?;\n                 let change = self.value_to_primval(arg_vals[1], ty)?;\n                 let old = self.read_value(ptr, ty)?;\n@@ -142,7 +143,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"copy\" |\n             \"copy_nonoverlapping\" => {\n                 // FIXME: check whether overlapping occurs\n-                let elem_ty = instance.substs.type_at(0);\n+                let elem_ty = substs.type_at(0);\n                 let elem_size = self.type_size(elem_ty)?.expect(\"cannot copy unsized value\");\n                 let elem_align = self.type_align(elem_ty)?;\n                 let src = arg_vals[0].read_ptr(&self.memory)?;\n@@ -155,15 +156,15 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"cttz\" |\n             \"ctlz\" |\n             \"bswap\" => {\n-                let ty = instance.substs.type_at(0);\n+                let ty = substs.type_at(0);\n                 let num = self.value_to_primval(arg_vals[0], ty)?;\n                 let kind = self.ty_to_primval_kind(ty)?;\n                 let num = numeric_intrinsic(intrinsic_name, num, kind)?;\n                 self.write_primval(dest, num, ty)?;\n             }\n \n             \"discriminant_value\" => {\n-                let ty = instance.substs.type_at(0);\n+                let ty = substs.type_at(0);\n                 let adt_ptr = arg_vals[0].read_ptr(&self.memory)?;\n                 let discr_val = self.read_discriminant_value(adt_ptr, ty)?;\n                 self.write_primval(dest, PrimVal::Bytes(discr_val), dest_ty)?;\n@@ -216,7 +217,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             \"fadd_fast\" | \"fsub_fast\" | \"fmul_fast\" | \"fdiv_fast\" | \"frem_fast\" => {\n-                let ty = instance.substs.type_at(0);\n+                let ty = substs.type_at(0);\n                 let kind = self.ty_to_primval_kind(ty)?;\n                 let a = self.value_to_primval(arg_vals[0], ty)?;\n                 let b = self.value_to_primval(arg_vals[1], ty)?;\n@@ -248,7 +249,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         Value::ByVal(PrimVal::Undef) => match this.ty_to_primval_kind(dest_ty) {\n                             Ok(_) => Value::ByVal(PrimVal::Bytes(0)),\n                             Err(_) => {\n-                                let ptr = this.alloc_ptr_with_substs(dest_ty, instance.substs)?;\n+                                let ptr = this.alloc_ptr_with_substs(dest_ty, substs)?;\n                                 this.memory.write_repeat(ptr, 0, size)?;\n                                 Value::ByRef(ptr)\n                             }\n@@ -268,35 +269,35 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             \"min_align_of\" => {\n-                let elem_ty = instance.substs.type_at(0);\n+                let elem_ty = substs.type_at(0);\n                 let elem_align = self.type_align(elem_ty)?;\n                 let align_val = PrimVal::from_u128(elem_align as u128);\n                 self.write_primval(dest, align_val, dest_ty)?;\n             }\n \n             \"pref_align_of\" => {\n-                let ty = instance.substs.type_at(0);\n+                let ty = substs.type_at(0);\n                 let layout = self.type_layout(ty)?;\n                 let align = layout.align(&self.tcx.data_layout).pref();\n                 let align_val = PrimVal::from_u128(align as u128);\n                 self.write_primval(dest, align_val, dest_ty)?;\n             }\n \n             \"move_val_init\" => {\n-                let ty = instance.substs.type_at(0);\n+                let ty = substs.type_at(0);\n                 let ptr = arg_vals[0].read_ptr(&self.memory)?;\n                 self.write_value_to_ptr(arg_vals[1], ptr, ty)?;\n             }\n \n             \"needs_drop\" => {\n-                let ty = instance.substs.type_at(0);\n+                let ty = substs.type_at(0);\n                 let env = self.tcx.empty_parameter_environment();\n                 let needs_drop = self.tcx.type_needs_drop_given_env(ty, &env);\n                 self.write_primval(dest, PrimVal::from_bool(needs_drop), dest_ty)?;\n             }\n \n             \"offset\" => {\n-                let pointee_ty = instance.substs.type_at(0);\n+                let pointee_ty = substs.type_at(0);\n                 // FIXME: assuming here that type size is < i64::max_value()\n                 let pointee_size = self.type_size(pointee_ty)?.expect(\"cannot offset a pointer to an unsized type\") as i64;\n                 let offset = self.value_to_primval(arg_vals[1], isize)?.to_i128()? as i64;\n@@ -357,7 +358,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             \"size_of\" => {\n-                let ty = instance.substs.type_at(0);\n+                let ty = substs.type_at(0);\n                 // FIXME: change the `box_free` lang item to take `T: ?Sized` and have it use the\n                 // `size_of_val` intrinsic, then change this back to\n                 // .expect(\"size_of intrinsic called on unsized value\")\n@@ -367,32 +368,32 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             \"size_of_val\" => {\n-                let ty = instance.substs.type_at(0);\n+                let ty = substs.type_at(0);\n                 let (size, _) = self.size_and_align_of_dst(ty, arg_vals[0])?;\n                 self.write_primval(dest, PrimVal::from_u128(size as u128), dest_ty)?;\n             }\n \n             \"min_align_of_val\" |\n             \"align_of_val\" => {\n-                let ty = instance.substs.type_at(0);\n+                let ty = substs.type_at(0);\n                 let (_, align) = self.size_and_align_of_dst(ty, arg_vals[0])?;\n                 self.write_primval(dest, PrimVal::from_u128(align as u128), dest_ty)?;\n             }\n \n             \"type_name\" => {\n-                let ty = instance.substs.type_at(0);\n+                let ty = substs.type_at(0);\n                 let ty_name = ty.to_string();\n                 let s = self.str_to_value(&ty_name)?;\n                 self.write_value(s, dest, dest_ty)?;\n             }\n             \"type_id\" => {\n-                let ty = instance.substs.type_at(0);\n+                let ty = substs.type_at(0);\n                 let n = self.tcx.type_id_hash(ty);\n                 self.write_primval(dest, PrimVal::Bytes(n as u128), dest_ty)?;\n             }\n \n             \"transmute\" => {\n-                let dest_ty = instance.substs.type_at(1);\n+                let dest_ty = substs.type_at(1);\n                 self.write_value(arg_vals[0], dest, dest_ty)?;\n             }\n \n@@ -418,7 +419,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"write_bytes\" => {\n                 let u8 = self.tcx.types.u8;\n-                let ty = instance.substs.type_at(0);\n+                let ty = substs.type_at(0);\n                 let ty_align = self.type_align(ty)?;\n                 let val_byte = self.value_to_primval(arg_vals[1], u8)?.to_u128()? as u8;\n                 let size = self.type_size(ty)?.expect(\"write_bytes() type must be sized\");"}]}