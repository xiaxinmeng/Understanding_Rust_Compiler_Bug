{"sha": "82fb413d370f1f1094964ed07b65f97dba52cc30", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyZmI0MTNkMzcwZjFmMTA5NDk2NGVkMDdiNjVmOTdkYmE1MmNjMzA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-04T08:11:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-04T08:11:53Z"}, "message": "auto merge of #18596 : alexcrichton/rust/rollup, r=alexcrichton\n\nLet's see if we can clear out the queue entirely today!", "tree": {"sha": "4a282dbec3c595c1b9937566237cf79a851efba4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4a282dbec3c595c1b9937566237cf79a851efba4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/82fb413d370f1f1094964ed07b65f97dba52cc30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/82fb413d370f1f1094964ed07b65f97dba52cc30", "html_url": "https://github.com/rust-lang/rust/commit/82fb413d370f1f1094964ed07b65f97dba52cc30", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/82fb413d370f1f1094964ed07b65f97dba52cc30/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec28b4a6c8c0a249fe341afde55d026177aabac6", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec28b4a6c8c0a249fe341afde55d026177aabac6", "html_url": "https://github.com/rust-lang/rust/commit/ec28b4a6c8c0a249fe341afde55d026177aabac6"}, {"sha": "f2aa8c41876cce93c6bb4ada79600b8ef8e3d599", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2aa8c41876cce93c6bb4ada79600b8ef8e3d599", "html_url": "https://github.com/rust-lang/rust/commit/f2aa8c41876cce93c6bb4ada79600b8ef8e3d599"}], "stats": {"total": 2573, "additions": 1242, "deletions": 1331}, "files": [{"sha": "d98f7c393f03882f9df10ca4daacf5df4008450d", "filename": "src/doc/guide.md", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Fdoc%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Fdoc%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide.md?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -4467,18 +4467,19 @@ see why consumers matter.\n \n ## Iterators\n \n-As we've said before, an iterator is something that we can call the `.next()`\n-method on repeatedly, and it gives us a sequence of things. Because you need\n-to call the method, this means that iterators are **lazy**. This code, for\n-example, does not actually generate the numbers `1-100`, and just creates a\n-value that represents the sequence:\n+As we've said before, an iterator is something that we can call the\n+`.next()` method on repeatedly, and it gives us a sequence of things.\n+Because you need to call the method, this means that iterators\n+are **lazy** and don't need to generate all of the values upfront.\n+This code, for example, does not actually generate the numbers\n+`1-100`, and just creates a value that represents the sequence:\n \n ```{rust}\n let nums = range(1i, 100i);\n ```\n \n Since we didn't do anything with the range, it didn't generate the sequence.\n-Once we add the consumer:\n+Let's add the consumer:\n \n ```{rust}\n let nums = range(1i, 100i).collect::<Vec<int>>();\n@@ -4507,8 +4508,8 @@ std::iter::count(1i, 5i);\n ```\n \n This iterator counts up from one, adding five each time. It will give\n-you a new integer every time, forever. Well, technically, until the\n-maximum number that an `int` can represent. But since iterators are lazy,\n+you a new integer every time, forever (well, technically, until it reaches the\n+maximum number representable by an `int`). But since iterators are lazy,\n that's okay! You probably don't want to use `collect()` on it, though...\n \n That's enough about iterators. Iterator adapters are the last concept\n@@ -5251,8 +5252,8 @@ to do something that it can't currently do? You may be able to write a macro\n to extend Rust's capabilities.\n \n You've already used one macro extensively: `println!`. When we invoke\n-a Rust macro, we need to use the exclamation mark (`!`). There's two reasons\n-that this is true: the first is that it makes it clear when you're using a\n+a Rust macro, we need to use the exclamation mark (`!`). There are two reasons\n+why this is so: the first is that it makes it clear when you're using a\n macro. The second is that macros allow for flexible syntax, and so Rust must\n be able to tell where a macro starts and ends. The `!(...)` helps with this.\n \n@@ -5267,7 +5268,7 @@ println!(\"x is: {}\", x);\n \n The `println!` macro does a few things:\n \n-1. It parses the string to find any `{}`s\n+1. It parses the string to find any `{}`s.\n 2. It checks that the number of `{}`s matches the number of other arguments.\n 3. It generates a bunch of Rust code, taking this in mind.\n \n@@ -5276,8 +5277,8 @@ Rust will generate code that takes all of the types into account. If\n `println!` was a function, it could still do this type checking, but it\n would happen at run time rather than compile time.\n \n-We can check this out using a special flag to `rustc`. This code, in a file\n-`print.rs`:\n+We can check this out using a special flag to `rustc`. Put this code in a file\n+called `print.rs`:\n \n ```{rust}\n fn main() {\n@@ -5286,7 +5287,7 @@ fn main() {\n }\n ```\n \n-Can have its macros expanded like this: `rustc print.rs --pretty=expanded`, will\n+You can have the macros expanded like this: `rustc print.rs --pretty=expanded` \u2013 which will\n give us this huge result:\n \n ```{rust,ignore}\n@@ -5325,12 +5326,12 @@ invoke the `println_args` function with the generated arguments.\n This is the code that Rust actually compiles. You can see all of the extra\n information that's here. We get all of the type safety and options that it\n provides, but at compile time, and without needing to type all of this out.\n-This is how macros are powerful. Without them, you would need to type all of\n-this by hand to get a type checked `println`.\n+This is how macros are powerful: without them you would need to type all of\n+this by hand to get a type-checked `println`.\n \n For more on macros, please consult [the Macros Guide](guide-macros.html).\n-Macros are a very advanced and still slightly experimental feature, but don't\n-require a deep understanding to call, since they look just like functions. The\n+Macros are a very advanced and still slightly experimental feature, but they don't\n+require a deep understanding to be called, since they look just like functions. The\n Guide can help you if you want to write your own.\n \n # Unsafe\n@@ -5347,8 +5348,8 @@ keyword, which indicates that the function may not behave properly.\n \n Second, if you'd like to create some sort of shared-memory data structure, Rust\n won't allow it, because memory must be owned by a single owner. However, if\n-you're planning on making access to that shared memory safe, such as with a\n-mutex, _you_ know that it's safe, but Rust can't know. Writing an `unsafe`\n+you're planning on making access to that shared memory safe \u2013 such as with a\n+mutex \u2013 _you_ know that it's safe, but Rust can't know. Writing an `unsafe`\n block allows you to ask the compiler to trust you. In this case, the _internal_\n implementation of the mutex is considered unsafe, but the _external_ interface\n we present is safe. This allows it to be effectively used in normal Rust, while"}, {"sha": "96d6bece2307225243e1fce94913b16d144ddeb5", "filename": "src/doc/reference.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -831,7 +831,7 @@ mod math {\n }\n ```\n \n-Modules and types share the same namespace. Declaring a named type that has\n+Modules and types share the same namespace. Declaring a named type with\n the same name as a module in scope is forbidden: that is, a type definition,\n trait, struct, enumeration, or type parameter can't shadow the name of a module\n in scope, or vice versa.\n@@ -870,8 +870,8 @@ view_item : extern_crate_decl | use_decl ;\n ```\n \n A view item manages the namespace of a module. View items do not define new\n-items, but rather, simply change other items' visibility. There are several\n-kinds of view item:\n+items, but rather, simply change other items' visibility. There are two\n+kinds of view items:\n \n * [`extern crate` declarations](#extern-crate-declarations)\n * [`use` declarations](#use-declarations)\n@@ -896,7 +896,7 @@ external crate when it was compiled. If no `crateid` is provided, a default\n `name` attribute is assumed, equal to the `ident` given in the\n `extern_crate_decl`.\n \n-Four examples of `extern crate` declarations:\n+Three examples of `extern crate` declarations:\n \n ```{.ignore}\n extern crate pcre;"}, {"sha": "fe8e743e7826dae0055ed476667fd304a9588b73", "filename": "src/etc/vim/autoload/rust.vim", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Fetc%2Fvim%2Fautoload%2Frust.vim", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Fetc%2Fvim%2Fautoload%2Frust.vim", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvim%2Fautoload%2Frust.vim?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -178,14 +178,14 @@ function! s:WithPath(func, ...)\n \t\t\tcall mkdir(tmpdir)\n \n \t\t\tlet save_cwd = getcwd()\n-\t\t\tsilent exe 'lcd' tmpdir\n+\t\t\tsilent exe 'lcd' fnameescape(tmpdir)\n \n \t\t\tlet path = 'unnamed.rs'\n \n \t\t\tlet save_mod = &mod\n \t\t\tset nomod\n \n-\t\t\tsilent exe 'keepalt write! ' . path\n+\t\t\tsilent exe 'keepalt write! ' . fnameescape(path)\n \t\t\tif pathisempty\n \t\t\t\tsilent keepalt 0file\n \t\t\tendif\n@@ -195,10 +195,10 @@ function! s:WithPath(func, ...)\n \n \t\tcall call(a:func, [path] + a:000)\n \tfinally\n-\t\tif exists(\"save_mod\")   | let &mod = save_mod          | endif\n-\t\tif exists(\"save_write\") | let &write = save_write      | endif\n-\t\tif exists(\"save_cwd\")   | silent exe 'lcd' save_cwd    | endif\n-\t\tif exists(\"tmpdir\")     | silent call s:RmDir(tmpdir)  | endif\n+\t\tif exists(\"save_mod\")   | let &mod = save_mod                    | endif\n+\t\tif exists(\"save_write\") | let &write = save_write                | endif\n+\t\tif exists(\"save_cwd\")   | silent exe 'lcd' fnameescape(save_cwd) | endif\n+\t\tif exists(\"tmpdir\")     | silent call s:RmDir(tmpdir)            | endif\n \tendtry\n endfunction\n "}, {"sha": "5b75e98baefe241ea92d791be149d8d9549a7b60", "filename": "src/libcore/result.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -276,7 +276,6 @@\n \n #![stable]\n \n-use clone::Clone;\n use cmp::PartialEq;\n use std::fmt::Show;\n use slice;"}, {"sha": "8937f2a946a85b501b47d0ad4e6bf07c02bc3f4c", "filename": "src/libcore/str.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -19,7 +19,6 @@\n use mem;\n use char;\n use char::Char;\n-use clone::Clone;\n use cmp;\n use cmp::{PartialEq, Eq};\n use default::Default;"}, {"sha": "660603198915103cf7a5a0dbd4b72540ef8ffe46", "filename": "src/librand/distributions/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibrand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibrand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fmod.rs?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -227,6 +227,13 @@ fn ziggurat<R:Rng>(\n         // creating a f64), so we might as well reuse some to save\n         // generating a whole extra random number. (Seems to be 15%\n         // faster.)\n+        //\n+        // This unfortunately misses out on the benefits of direct\n+        // floating point generation if an RNG like dSMFT is\n+        // used. (That is, such RNGs create floats directly, highly\n+        // efficiently and overload next_f32/f64, so by not calling it\n+        // this may be slower than it would be otherwise.)\n+        // FIXME: investigate/optimise for the above.\n         let bits: u64 = rng.gen();\n         let i = (bits & 0xff) as uint;\n         let f = (bits >> 11) as f64 / SCALE;"}, {"sha": "3c528c564a7ae6ce0827db3fedd124474ce54f86", "filename": "src/librand/lib.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -78,6 +78,46 @@ pub trait Rng {\n         (self.next_u32() as u64 << 32) | (self.next_u32() as u64)\n     }\n \n+    /// Return the next random f32 selected from the half-open\n+    /// interval `[0, 1)`.\n+    ///\n+    /// By default this is implemented in terms of `next_u32`, but a\n+    /// random number generator which can generate numbers satisfying\n+    /// the requirements directly can overload this for performance.\n+    /// It is required that the return value lies in `[0, 1)`.\n+    ///\n+    /// See `Closed01` for the closed interval `[0,1]`, and\n+    /// `Open01` for the open interval `(0,1)`.\n+    fn next_f32(&mut self) -> f32 {\n+        const MANTISSA_BITS: uint = 24;\n+        const IGNORED_BITS: uint = 8;\n+        const SCALE: f32 = (1u64 << MANTISSA_BITS) as f32;\n+\n+        // using any more than `MANTISSA_BITS` bits will\n+        // cause (e.g.) 0xffff_ffff to correspond to 1\n+        // exactly, so we need to drop some (8 for f32, 11\n+        // for f64) to guarantee the open end.\n+        (self.next_u32() >> IGNORED_BITS) as f32 / SCALE\n+    }\n+\n+    /// Return the next random f64 selected from the half-open\n+    /// interval `[0, 1)`.\n+    ///\n+    /// By default this is implemented in terms of `next_u64`, but a\n+    /// random number generator which can generate numbers satisfying\n+    /// the requirements directly can overload this for performance.\n+    /// It is required that the return value lies in `[0, 1)`.\n+    ///\n+    /// See `Closed01` for the closed interval `[0,1]`, and\n+    /// `Open01` for the open interval `(0,1)`.\n+    fn next_f64(&mut self) -> f64 {\n+        const MANTISSA_BITS: uint = 53;\n+        const IGNORED_BITS: uint = 11;\n+        const SCALE: f64 = (1u64 << MANTISSA_BITS) as f64;\n+\n+        (self.next_u64() >> IGNORED_BITS) as f64 / SCALE\n+    }\n+\n     /// Fill `dest` with random data.\n     ///\n     /// This has a default implementation in terms of `next_u64` and"}, {"sha": "96f40bcc1565e48db09995a9bb6da6ee656ac8d9", "filename": "src/librand/rand_impls.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibrand%2Frand_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibrand%2Frand_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Frand_impls.rs?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -96,11 +96,11 @@ impl Rand for u64 {\n }\n \n macro_rules! float_impls {\n-    ($mod_name:ident, $ty:ty, $mantissa_bits:expr, $method_name:ident, $ignored_bits:expr) => {\n+    ($mod_name:ident, $ty:ty, $mantissa_bits:expr, $method_name:ident) => {\n         mod $mod_name {\n             use {Rand, Rng, Open01, Closed01};\n \n-            static SCALE: $ty = (1u64 << $mantissa_bits) as $ty;\n+            const SCALE: $ty = (1u64 << $mantissa_bits) as $ty;\n \n             impl Rand for $ty {\n                 /// Generate a floating point number in the half-open\n@@ -110,11 +110,7 @@ macro_rules! float_impls {\n                 /// and `Open01` for the open interval `(0,1)`.\n                 #[inline]\n                 fn rand<R: Rng>(rng: &mut R) -> $ty {\n-                    // using any more than `mantissa_bits` bits will\n-                    // cause (e.g.) 0xffff_ffff to correspond to 1\n-                    // exactly, so we need to drop some (8 for f32, 11\n-                    // for f64) to guarantee the open end.\n-                    (rng.$method_name() >> $ignored_bits) as $ty / SCALE\n+                    rng.$method_name()\n                 }\n             }\n             impl Rand for Open01<$ty> {\n@@ -124,23 +120,22 @@ macro_rules! float_impls {\n                     // the precision of f64/f32 at 1.0), so that small\n                     // numbers are larger than 0, but large numbers\n                     // aren't pushed to/above 1.\n-                    Open01(((rng.$method_name() >> $ignored_bits) as $ty + 0.25) / SCALE)\n+                    Open01(rng.$method_name() + 0.25 / SCALE)\n                 }\n             }\n             impl Rand for Closed01<$ty> {\n                 #[inline]\n                 fn rand<R: Rng>(rng: &mut R) -> Closed01<$ty> {\n-                    // divide by the maximum value of the numerator to\n-                    // get a non-zero probability of getting exactly\n-                    // 1.0.\n-                    Closed01((rng.$method_name() >> $ignored_bits) as $ty / (SCALE - 1.0))\n+                    // rescale so that 1.0 - epsilon becomes 1.0\n+                    // precisely.\n+                    Closed01(rng.$method_name() * SCALE / (SCALE - 1.0))\n                 }\n             }\n         }\n     }\n }\n-float_impls! { f64_rand_impls, f64, 53, next_u64, 11 }\n-float_impls! { f32_rand_impls, f32, 24, next_u32, 8 }\n+float_impls! { f64_rand_impls, f64, 53, next_f64 }\n+float_impls! { f32_rand_impls, f32, 24, next_f32 }\n \n impl Rand for char {\n     #[inline]"}, {"sha": "0c26981c2a068cdb00181fe6641b5b7d325eb727", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -39,7 +39,7 @@ use std::cmp;\n use std::collections::HashMap;\n use std::collections::hash_map::{Occupied, Vacant};\n use std::slice;\n-use std::{int, i8, i16, i32, i64, uint, u8, u16, u32, u64, f32, f64};\n+use std::{i8, i16, i32, i64, u8, u16, u32, u64, f32, f64};\n use syntax::abi;\n use syntax::ast_map;\n use syntax::ast_util::is_shift_binop;\n@@ -180,19 +180,19 @@ impl LintPass for TypeLimits {\n \n                 if is_shift_binop(binop) {\n                     let opt_ty_bits = match ty::get(ty::expr_ty(cx.tcx, &**l)).sty {\n-                        ty::ty_int(t) => Some(int_ty_bits(t)),\n-                        ty::ty_uint(t) => Some(uint_ty_bits(t)),\n+                        ty::ty_int(t) => Some(int_ty_bits(t, cx.sess().targ_cfg.int_type)),\n+                        ty::ty_uint(t) => Some(uint_ty_bits(t, cx.sess().targ_cfg.uint_type)),\n                         _ => None\n                     };\n \n                     if let Some(bits) = opt_ty_bits {\n                         let exceeding = if let ast::ExprLit(ref lit) = r.node {\n-                            if let ast::LitInt(shift, _) = lit.node { shift > bits }\n+                            if let ast::LitInt(shift, _) = lit.node { shift >= bits }\n                             else { false }\n                         } else {\n                             match eval_const_expr_partial(cx.tcx, &**r) {\n-                                Ok(const_int(shift)) => { shift as u64 > bits },\n-                                Ok(const_uint(shift)) => { shift > bits },\n+                                Ok(const_int(shift)) => { shift as u64 >= bits },\n+                                Ok(const_uint(shift)) => { shift >= bits },\n                                 _ => { false }\n                             }\n                         };\n@@ -312,19 +312,19 @@ impl LintPass for TypeLimits {\n             }\n         }\n \n-        fn int_ty_bits(int_ty: ast::IntTy) -> u64 {\n+        fn int_ty_bits(int_ty: ast::IntTy, target_int_ty: ast::IntTy) -> u64 {\n             match int_ty {\n-                ast::TyI =>    int::BITS as u64,\n+                ast::TyI =>    int_ty_bits(target_int_ty, target_int_ty),\n                 ast::TyI8 =>   i8::BITS  as u64,\n                 ast::TyI16 =>  i16::BITS as u64,\n                 ast::TyI32 =>  i32::BITS as u64,\n                 ast::TyI64 =>  i64::BITS as u64\n             }\n         }\n \n-        fn uint_ty_bits(uint_ty: ast::UintTy) -> u64 {\n+        fn uint_ty_bits(uint_ty: ast::UintTy, target_uint_ty: ast::UintTy) -> u64 {\n             match uint_ty {\n-                ast::TyU =>    uint::BITS as u64,\n+                ast::TyU =>    uint_ty_bits(target_uint_ty, target_uint_ty),\n                 ast::TyU8 =>   u8::BITS  as u64,\n                 ast::TyU16 =>  u16::BITS as u64,\n                 ast::TyU32 =>  u32::BITS as u64,"}, {"sha": "6da74eee8a3195383e65b430a9e49519556ab3ff", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -532,7 +532,7 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_ids(&self, f: |&mut ast_util::IdVisitor<Context>|) {\n+    fn visit_ids(&mut self, f: |&mut ast_util::IdVisitor<Context>|) {\n         let mut v = ast_util::IdVisitor {\n             operation: self,\n             pass_through_items: false,\n@@ -749,7 +749,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n \n // Output any lints that were previously added to the session.\n impl<'a, 'tcx> IdVisitingOperation for Context<'a, 'tcx> {\n-    fn visit_id(&self, id: ast::NodeId) {\n+    fn visit_id(&mut self, id: ast::NodeId) {\n         match self.tcx.sess.lints.borrow_mut().pop(&id) {\n             None => {}\n             Some(lints) => {"}, {"sha": "a04f94c31bfc50d139285c8a1aec7417991d3129", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -148,7 +148,7 @@ impl astencode_tag {\n     pub fn from_uint(value : uint) -> Option<astencode_tag> {\n         let is_a_tag = first_astencode_tag <= value && value <= last_astencode_tag;\n         if !is_a_tag { None } else {\n-            Some(unsafe { mem::transmute(value) })\n+            Some(unsafe { mem::transmute::<uint, astencode_tag>(value) })\n         }\n     }\n }\n@@ -247,4 +247,3 @@ pub const tag_type_param_def: uint = 0xa5;\n \n pub const tag_item_generics: uint = 0xa6;\n pub const tag_method_ty_generics: uint = 0xa7;\n-"}, {"sha": "92f3b888dcd523576ce3d755ec9f601314c943e5", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -36,7 +36,7 @@ use std::io::extensions::u64_from_be_bytes;\n use std::io;\n use std::collections::hash_map::HashMap;\n use std::rc::Rc;\n-use std::u64;\n+use std::str;\n use rbml::reader;\n use rbml;\n use serialize::Decodable;\n@@ -215,7 +215,9 @@ fn each_reexport(d: rbml::Doc, f: |rbml::Doc| -> bool) -> bool {\n \n fn variant_disr_val(d: rbml::Doc) -> Option<ty::Disr> {\n     reader::maybe_get_doc(d, tag_disr_val).and_then(|val_doc| {\n-        reader::with_doc_data(val_doc, |data| u64::parse_bytes(data, 10u))\n+        reader::with_doc_data(val_doc, |data| {\n+            str::from_utf8(data).and_then(from_str)\n+        })\n     })\n }\n "}, {"sha": "fd389c1f3142691472f133fdb118305dc54d4386", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 10, "deletions": 21, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -29,7 +29,6 @@ use serialize::Encodable;\n use std::cell::RefCell;\n use std::hash::Hash;\n use std::hash;\n-use std::mem;\n use std::collections::HashMap;\n use syntax::abi;\n use syntax::ast::*;\n@@ -1508,44 +1507,36 @@ fn my_visit_expr(_e: &Expr) { }\n \n fn my_visit_item(i: &Item,\n                  rbml_w: &mut Encoder,\n-                 ecx_ptr: *const int,\n+                 ecx: &EncodeContext,\n                  index: &mut Vec<entry<i64>>) {\n-    let mut rbml_w = unsafe { rbml_w.unsafe_clone() };\n-    // See above\n-    let ecx: &EncodeContext = unsafe { mem::transmute(ecx_ptr) };\n     ecx.tcx.map.with_path(i.id, |path| {\n-        encode_info_for_item(ecx, &mut rbml_w, i, index, path, i.vis);\n+        encode_info_for_item(ecx, rbml_w, i, index, path, i.vis);\n     });\n }\n \n fn my_visit_foreign_item(ni: &ForeignItem,\n                          rbml_w: &mut Encoder,\n-                         ecx_ptr:*const int,\n+                         ecx: &EncodeContext,\n                          index: &mut Vec<entry<i64>>) {\n-    // See above\n-    let ecx: &EncodeContext = unsafe { mem::transmute(ecx_ptr) };\n     debug!(\"writing foreign item {}::{}\",\n             ecx.tcx.map.path_to_string(ni.id),\n             token::get_ident(ni.ident));\n \n-    let mut rbml_w = unsafe {\n-        rbml_w.unsafe_clone()\n-    };\n     let abi = ecx.tcx.map.get_foreign_abi(ni.id);\n     ecx.tcx.map.with_path(ni.id, |path| {\n-        encode_info_for_foreign_item(ecx, &mut rbml_w,\n+        encode_info_for_foreign_item(ecx, rbml_w,\n                                      ni, index,\n                                      path, abi);\n     });\n }\n \n-struct EncodeVisitor<'a,'b:'a> {\n+struct EncodeVisitor<'a, 'b:'a, 'c:'a, 'tcx:'c> {\n     rbml_w_for_visit_item: &'a mut Encoder<'b>,\n-    ecx_ptr:*const int,\n+    ecx: &'a EncodeContext<'c,'tcx>,\n     index: &'a mut Vec<entry<i64>>,\n }\n \n-impl<'a, 'b, 'v> Visitor<'v> for EncodeVisitor<'a, 'b> {\n+impl<'a, 'b, 'c, 'tcx, 'v> Visitor<'v> for EncodeVisitor<'a, 'b, 'c, 'tcx> {\n     fn visit_expr(&mut self, ex: &Expr) {\n         visit::walk_expr(self, ex);\n         my_visit_expr(ex);\n@@ -1554,14 +1545,14 @@ impl<'a, 'b, 'v> Visitor<'v> for EncodeVisitor<'a, 'b> {\n         visit::walk_item(self, i);\n         my_visit_item(i,\n                       self.rbml_w_for_visit_item,\n-                      self.ecx_ptr,\n+                      self.ecx,\n                       self.index);\n     }\n     fn visit_foreign_item(&mut self, ni: &ForeignItem) {\n         visit::walk_foreign_item(self, ni);\n         my_visit_foreign_item(ni,\n                               self.rbml_w_for_visit_item,\n-                              self.ecx_ptr,\n+                              self.ecx,\n                               self.index);\n     }\n }\n@@ -1585,11 +1576,9 @@ fn encode_info_for_items(ecx: &EncodeContext,\n                         syntax::parse::token::special_idents::invalid,\n                         Public);\n \n-    // See comment in `encode_side_tables_for_ii` in astencode\n-    let ecx_ptr: *const int = unsafe { mem::transmute(ecx) };\n     visit::walk_crate(&mut EncodeVisitor {\n         index: &mut index,\n-        ecx_ptr: ecx_ptr,\n+        ecx: ecx,\n         rbml_w_for_visit_item: &mut *rbml_w,\n     }, krate);\n "}, {"sha": "738eeaae6a5f87c906ca92e74567b1314fb2ecfb", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 11, "deletions": 24, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -231,7 +231,6 @@ use std::c_str::ToCStr;\n use std::cmp;\n use std::io::fs::PathExtensions;\n use std::io;\n-use std::mem;\n use std::ptr;\n use std::slice;\n use std::string;\n@@ -287,8 +286,8 @@ pub struct Library {\n \n pub struct ArchiveMetadata {\n     _archive: ArchiveRO,\n-    // See comments in ArchiveMetadata::new for why this is static\n-    data: &'static [u8],\n+    // points into self._archive\n+    data: *const [u8],\n }\n \n pub struct CratePaths {\n@@ -709,33 +708,21 @@ pub fn note_crate_name(diag: &SpanHandler, name: &str) {\n \n impl ArchiveMetadata {\n     fn new(ar: ArchiveRO) -> Option<ArchiveMetadata> {\n-        let data: &'static [u8] = {\n-            let data = match ar.read(METADATA_FILENAME) {\n-                Some(data) => data,\n-                None => {\n-                    debug!(\"didn't find '{}' in the archive\", METADATA_FILENAME);\n-                    return None;\n-                }\n-            };\n-            // This data is actually a pointer inside of the archive itself, but\n-            // we essentially want to cache it because the lookup inside the\n-            // archive is a fairly expensive operation (and it's queried for\n-            // *very* frequently). For this reason, we transmute it to the\n-            // static lifetime to put into the struct. Note that the buffer is\n-            // never actually handed out with a static lifetime, but rather the\n-            // buffer is loaned with the lifetime of this containing object.\n-            // Hence, we're guaranteed that the buffer will never be used after\n-            // this object is dead, so this is a safe operation to transmute and\n-            // store the data as a static buffer.\n-            unsafe { mem::transmute(data) }\n+        let data = match ar.read(METADATA_FILENAME) {\n+            Some(data) => data as *const [u8],\n+            None => {\n+                debug!(\"didn't find '{}' in the archive\", METADATA_FILENAME);\n+                return None;\n+            }\n         };\n+\n         Some(ArchiveMetadata {\n             _archive: ar,\n             data: data,\n         })\n     }\n \n-    pub fn as_slice<'a>(&'a self) -> &'a [u8] { self.data }\n+    pub fn as_slice<'a>(&'a self) -> &'a [u8] { unsafe { &*self.data } }\n }\n \n // Just a small wrapper to time how long reading metadata takes.\n@@ -798,7 +785,7 @@ fn get_metadata_section_imp(os: abi::Os, filename: &Path) -> Result<MetadataBlob\n                 let csz = llvm::LLVMGetSectionSize(si.llsi) as uint;\n                 let mut found =\n                     Err(format!(\"metadata not found: '{}'\", filename.display()));\n-                let cvbuf: *const u8 = mem::transmute(cbuf);\n+                let cvbuf: *const u8 = cbuf as *const u8;\n                 let vlen = encoder::metadata_encoding_version.len();\n                 debug!(\"checking {} bytes of metadata-version stamp\",\n                        vlen);"}, {"sha": "6e7a6dfa0944898a46eecda2a23785eb5fdc95ae", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -23,7 +23,6 @@ use middle::ty;\n use std::rc::Rc;\n use std::str;\n use std::string::String;\n-use std::uint;\n use syntax::abi;\n use syntax::ast;\n use syntax::ast::*;\n@@ -615,12 +614,12 @@ pub fn parse_def_id(buf: &[u8]) -> ast::DefId {\n     let crate_part = buf[0u..colon_idx];\n     let def_part = buf[colon_idx + 1u..len];\n \n-    let crate_num = match uint::parse_bytes(crate_part, 10u) {\n+    let crate_num = match str::from_utf8(crate_part).and_then(from_str::<uint>) {\n        Some(cn) => cn as ast::CrateNum,\n        None => panic!(\"internal error: parse_def_id: crate number expected, found {}\",\n                      crate_part)\n     };\n-    let def_num = match uint::parse_bytes(def_part, 10u) {\n+    let def_num = match str::from_utf8(def_part).and_then(from_str::<uint>) {\n        Some(dn) => dn as ast::NodeId,\n        None => panic!(\"internal error: parse_def_id: id expected, found {}\",\n                      def_part)"}, {"sha": "0074c15defb0e28aa30fc95187aab024eb1fc618", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 14, "deletions": 36, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -38,9 +38,7 @@ use syntax::parse::token;\n use syntax::ptr::P;\n use syntax;\n \n-use libc;\n use std::io::Seek;\n-use std::mem;\n use std::rc::Rc;\n \n use rbml::io::SeekableMemWriter;\n@@ -81,7 +79,7 @@ pub fn encode_inlined_item(ecx: &e::EncodeContext,\n         e::IIForeignRef(i) => i.id,\n         e::IITraitItemRef(_, &ast::ProvidedMethod(ref m)) => m.id,\n         e::IITraitItemRef(_, &ast::RequiredMethod(ref m)) => m.id,\n-        e::IITraitItemRef(_, &ast::TypeTraitItem(ref ti)) => ti.id,\n+        e::IITraitItemRef(_, &ast::TypeTraitItem(ref ti)) => ti.ty_param.id,\n         e::IIImplItemRef(_, &ast::MethodImplItem(ref m)) => m.id,\n         e::IIImplItemRef(_, &ast::TypeImplItem(ref ti)) => ti.id,\n     };\n@@ -156,7 +154,7 @@ pub fn decode_inlined_item<'tcx>(cdata: &cstore::crate_metadata,\n                 match *ti {\n                     ast::ProvidedMethod(ref m) => m.pe_ident(),\n                     ast::RequiredMethod(ref ty_m) => ty_m.ident,\n-                    ast::TypeTraitItem(ref ti) => ti.ident,\n+                    ast::TypeTraitItem(ref ti) => ti.ty_param.ident,\n                 }\n             },\n             ast::IIImplItem(_, ref m) => {\n@@ -711,8 +709,9 @@ impl<'a> vtable_decoder_helpers for reader::Decoder<'a> {\n     {\n         let types = self.read_to_vec(|this| Ok(f(this))).unwrap();\n         let selfs = self.read_to_vec(|this| Ok(f(this))).unwrap();\n+        let assocs = self.read_to_vec(|this| Ok(f(this))).unwrap();\n         let fns = self.read_to_vec(|this| Ok(f(this))).unwrap();\n-        VecPerParamSpace::new(types, selfs, fns)\n+        VecPerParamSpace::new(types, selfs, assocs, fns)\n     }\n \n     fn read_vtable_res_with_key(&mut self,\n@@ -1122,46 +1121,25 @@ impl<'a> write_tag_and_id for Encoder<'a> {\n     }\n }\n \n-struct SideTableEncodingIdVisitor<'a,'b:'a> {\n-    ecx_ptr: *const libc::c_void,\n-    new_rbml_w: &'a mut Encoder<'b>,\n+struct SideTableEncodingIdVisitor<'a, 'b:'a, 'c:'a, 'tcx:'c> {\n+    ecx: &'a e::EncodeContext<'c, 'tcx>,\n+    rbml_w: &'a mut Encoder<'b>,\n }\n \n-impl<'a,'b> ast_util::IdVisitingOperation for\n-        SideTableEncodingIdVisitor<'a,'b> {\n-    fn visit_id(&self, id: ast::NodeId) {\n-        // Note: this will cause a copy of rbml_w, which is bad as\n-        // it is mutable. But I believe it's harmless since we generate\n-        // balanced EBML.\n-        //\n-        // FIXME(pcwalton): Don't copy this way.\n-        let mut new_rbml_w = unsafe {\n-            self.new_rbml_w.unsafe_clone()\n-        };\n-        // See above\n-        let ecx: &e::EncodeContext = unsafe {\n-            mem::transmute(self.ecx_ptr)\n-        };\n-        encode_side_tables_for_id(ecx, &mut new_rbml_w, id)\n+impl<'a, 'b, 'c, 'tcx> ast_util::IdVisitingOperation for\n+        SideTableEncodingIdVisitor<'a, 'b, 'c, 'tcx> {\n+    fn visit_id(&mut self, id: ast::NodeId) {\n+        encode_side_tables_for_id(self.ecx, self.rbml_w, id)\n     }\n }\n \n fn encode_side_tables_for_ii(ecx: &e::EncodeContext,\n                              rbml_w: &mut Encoder,\n                              ii: &ast::InlinedItem) {\n     rbml_w.start_tag(c::tag_table as uint);\n-    let mut new_rbml_w = unsafe {\n-        rbml_w.unsafe_clone()\n-    };\n-\n-    // Because the ast visitor uses @IdVisitingOperation, I can't pass in\n-    // ecx directly, but /I/ know that it'll be fine since the lifetime is\n-    // tied to the CrateContext that lives throughout this entire section.\n-    ast_util::visit_ids_for_inlined_item(ii, &SideTableEncodingIdVisitor {\n-        ecx_ptr: unsafe {\n-            mem::transmute(ecx)\n-        },\n-        new_rbml_w: &mut new_rbml_w,\n+    ast_util::visit_ids_for_inlined_item(ii, &mut SideTableEncodingIdVisitor {\n+        ecx: ecx,\n+        rbml_w: rbml_w\n     });\n     rbml_w.end_tag();\n }"}, {"sha": "b5847a94b8d9b9ccec3884050270e4593874ce7f", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -118,7 +118,6 @@ use util::nodemap::NodeMap;\n \n use std::fmt;\n use std::io;\n-use std::mem::transmute;\n use std::rc::Rc;\n use std::str;\n use std::uint;\n@@ -380,10 +379,7 @@ fn visit_fn(ir: &mut IrMaps,\n     // swap in a new set of IR maps for this function body:\n     let mut fn_maps = IrMaps::new(ir.tcx);\n \n-    unsafe {\n-        debug!(\"creating fn_maps: {}\",\n-               transmute::<&IrMaps, *const IrMaps>(&fn_maps));\n-    }\n+    debug!(\"creating fn_maps: {}\", &fn_maps as *const IrMaps);\n \n     for arg in decl.inputs.iter() {\n         pat_util::pat_bindings(&ir.tcx.def_map,"}, {"sha": "4fbffa2a819d55f9b4a74b751d05f73293d6d3c2", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -296,8 +296,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n                             self.exported_items.insert(m.id);\n                         }\n                         ast::TypeTraitItem(ref t) => {\n-                            debug!(\"typedef {}\", t.id);\n-                            self.exported_items.insert(t.id);\n+                            debug!(\"typedef {}\", t.ty_param.id);\n+                            self.exported_items.insert(t.ty_param.id);\n                         }\n                     }\n                 }"}, {"sha": "ed7d9296c701d2db5773998767ba2c3727a32677", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 42, "deletions": 31, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -627,7 +627,10 @@ impl NameBindings {\n                      sp: Span) {\n         // Merges the module with the existing type def or creates a new one.\n         let modifiers = if is_public { PUBLIC } else { DefModifiers::empty() } | IMPORTABLE;\n-        let module_ = Rc::new(Module::new(parent_link, def_id, kind, external,\n+        let module_ = Rc::new(Module::new(parent_link,\n+                                          def_id,\n+                                          kind,\n+                                          external,\n                                           is_public));\n         let type_def = self.type_def.borrow().clone();\n         match type_def {\n@@ -1372,6 +1375,8 @@ impl<'a> Resolver<'a> {\n                 // Create the module and add all methods.\n                 match ty.node {\n                     TyPath(ref path, _, _) if path.segments.len() == 1 => {\n+                        // FIXME(18446) we should distinguish between the name of\n+                        // a trait and the name of an impl of that trait.\n                         let mod_name = path.segments.last().unwrap().identifier.name;\n \n                         let parent_opt = parent.module().children.borrow()\n@@ -1380,8 +1385,8 @@ impl<'a> Resolver<'a> {\n                             // It already exists\n                             Some(ref child) if child.get_module_if_available()\n                                                 .is_some() &&\n-                                           child.get_module().kind.get() ==\n-                                                ImplModuleKind => {\n+                                           (child.get_module().kind.get() == ImplModuleKind ||\n+                                            child.get_module().kind.get() == TraitModuleKind) => {\n                                 ModuleReducedGraphParent(child.get_module())\n                             }\n                             Some(ref child) if child.get_module_if_available()\n@@ -1559,19 +1564,19 @@ impl<'a> Resolver<'a> {\n                         }\n                         ast::TypeTraitItem(ref associated_type) => {\n                             let def = DefAssociatedTy(local_def(\n-                                    associated_type.id));\n+                                    associated_type.ty_param.id));\n \n                             let name_bindings =\n-                                self.add_child(associated_type.ident.name,\n+                                self.add_child(associated_type.ty_param.ident.name,\n                                                module_parent.clone(),\n                                                ForbidDuplicateTypesAndValues,\n-                                               associated_type.span);\n+                                               associated_type.ty_param.span);\n                             // NB: not IMPORTABLE\n                             name_bindings.define_type(def,\n-                                                      associated_type.span,\n+                                                      associated_type.ty_param.span,\n                                                       PUBLIC);\n \n-                            (associated_type.ident.name, TypeTraitItemKind)\n+                            (associated_type.ty_param.ident.name, TypeTraitItemKind)\n                         }\n                     };\n \n@@ -4218,7 +4223,7 @@ impl<'a> Resolver<'a> {\n                                             impl_items.as_slice());\n             }\n \n-            ItemTrait(ref generics, ref unbound, ref bounds, ref methods) => {\n+            ItemTrait(ref generics, ref unbound, ref bounds, ref trait_items) => {\n                 // Create a new rib for the self type.\n                 let mut self_type_rib = Rib::new(ItemRibKind);\n \n@@ -4246,13 +4251,13 @@ impl<'a> Resolver<'a> {\n                         _ => {}\n                     }\n \n-                    for method in (*methods).iter() {\n-                        // Create a new rib for the method-specific type\n+                    for trait_item in (*trait_items).iter() {\n+                        // Create a new rib for the trait_item-specific type\n                         // parameters.\n                         //\n                         // FIXME #4951: Do we need a node ID here?\n \n-                        match *method {\n+                        match *trait_item {\n                           ast::RequiredMethod(ref ty_m) => {\n                             this.with_type_parameter_rib\n                                 (HasTypeParameters(&ty_m.generics,\n@@ -4287,8 +4292,9 @@ impl<'a> Resolver<'a> {\n                                                                 ProvidedMethod(m.id)),\n                                                   &**m)\n                           }\n-                          ast::TypeTraitItem(_) => {\n-                              visit::walk_trait_item(this, method);\n+                          ast::TypeTraitItem(ref data) => {\n+                              this.resolve_type_parameter(&data.ty_param);\n+                              visit::walk_trait_item(this, trait_item);\n                           }\n                         }\n                     }\n@@ -4477,20 +4483,25 @@ impl<'a> Resolver<'a> {\n     fn resolve_type_parameters(&mut self,\n                                type_parameters: &OwnedSlice<TyParam>) {\n         for type_parameter in type_parameters.iter() {\n-            for bound in type_parameter.bounds.iter() {\n-                self.resolve_type_parameter_bound(type_parameter.id, bound,\n-                                                  TraitBoundingTypeParameter);\n-            }\n-            match &type_parameter.unbound {\n-                &Some(ref unbound) =>\n-                    self.resolve_type_parameter_bound(\n-                        type_parameter.id, unbound, TraitBoundingTypeParameter),\n-                &None => {}\n-            }\n-            match type_parameter.default {\n-                Some(ref ty) => self.resolve_type(&**ty),\n-                None => {}\n-            }\n+            self.resolve_type_parameter(type_parameter);\n+        }\n+    }\n+\n+    fn resolve_type_parameter(&mut self,\n+                              type_parameter: &TyParam) {\n+        for bound in type_parameter.bounds.iter() {\n+            self.resolve_type_parameter_bound(type_parameter.id, bound,\n+                                              TraitBoundingTypeParameter);\n+        }\n+        match &type_parameter.unbound {\n+            &Some(ref unbound) =>\n+                self.resolve_type_parameter_bound(\n+                    type_parameter.id, unbound, TraitBoundingTypeParameter),\n+            &None => {}\n+        }\n+        match type_parameter.default {\n+            Some(ref ty) => self.resolve_type(&**ty),\n+            None => {}\n         }\n     }\n \n@@ -4577,14 +4588,14 @@ impl<'a> Resolver<'a> {\n                         self.resolve_error(trait_reference.path.span,\n                                            format!(\"`{}` is not a trait\",\n                                                    self.path_names_to_string(\n-                                                        &trait_reference.path)));\n+                                                       &trait_reference.path)));\n \n                         // If it's a typedef, give a note\n                         match def {\n                             DefTy(..) => {\n                                 self.session.span_note(\n-                                                trait_reference.path.span,\n-                                                format!(\"`type` aliases cannot \\\n+                                    trait_reference.path.span,\n+                                    format!(\"`type` aliases cannot \\\n                                                         be used for traits\")\n                                                         .as_slice());\n                             }"}, {"sha": "14d8bf0cfed5c2972ad9d82bca09fc6ae5ef803f", "filename": "src/librustc/middle/save/span_utils.rs", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibrustc%2Fmiddle%2Fsave%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibrustc%2Fmiddle%2Fsave%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsave%2Fspan_utils.rs?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -31,13 +31,16 @@ impl<'a> SpanUtils<'a> {\n     pub fn extent_str(&self, span: Span) -> String {\n         let lo_loc = self.sess.codemap().lookup_char_pos(span.lo);\n         let hi_loc = self.sess.codemap().lookup_char_pos(span.hi);\n-        let lo_pos = self.sess.codemap().lookup_byte_offset(span.lo).pos;\n-        let hi_pos = self.sess.codemap().lookup_byte_offset(span.hi).pos;\n-\n-        format!(\"file_name,{},file_line,{},file_col,{},extent_start,{},\\\n-                 file_line_end,{},file_col_end,{},extent_end,{}\",\n-                lo_loc.file.name, lo_loc.line, lo_loc.col.to_uint(), lo_pos.to_uint(),\n-                hi_loc.line, hi_loc.col.to_uint(), hi_pos.to_uint())\n+        let lo_pos = self.sess.codemap().bytepos_to_file_charpos(span.lo);\n+        let hi_pos = self.sess.codemap().bytepos_to_file_charpos(span.hi);\n+        let lo_pos_byte = self.sess.codemap().lookup_byte_offset(span.lo).pos;\n+        let hi_pos_byte = self.sess.codemap().lookup_byte_offset(span.hi).pos;\n+\n+        format!(\"file_name,{},file_line,{},file_col,{},extent_start,{},extent_start_bytes,{},\\\n+                 file_line_end,{},file_col_end,{},extent_end,{},extent_end_bytes,{}\",\n+                lo_loc.file.name,\n+                lo_loc.line, lo_loc.col.to_uint(), lo_pos.to_uint(), lo_pos_byte.to_uint(),\n+                hi_loc.line, hi_loc.col.to_uint(), hi_pos.to_uint(), hi_pos_byte.to_uint())\n     }\n \n     // sub_span starts at span.lo, so we need to adjust the positions etc.\n@@ -92,7 +95,7 @@ impl<'a> SpanUtils<'a> {\n         let mut toks = self.retokenise_span(span);\n         let mut bracket_count = 0u;\n         loop {\n-            let ts = toks.next_token();\n+            let ts = toks.real_token();\n             if ts.tok == token::Eof {\n                 return self.make_sub_span(span, result)\n             }\n@@ -115,7 +118,7 @@ impl<'a> SpanUtils<'a> {\n         let mut toks = self.retokenise_span(span);\n         let mut bracket_count = 0u;\n         loop {\n-            let ts = toks.next_token();\n+            let ts = toks.real_token();\n             if ts.tok == token::Eof {\n                 return None;\n             }\n@@ -137,13 +140,13 @@ impl<'a> SpanUtils<'a> {\n     // any brackets, or the last span.\n     pub fn sub_span_for_meth_name(&self, span: Span) -> Option<Span> {\n         let mut toks = self.retokenise_span(span);\n-        let mut prev = toks.next_token();\n+        let mut prev = toks.real_token();\n         let mut result = None;\n         let mut bracket_count = 0u;\n         let mut last_span = None;\n         while prev.tok != token::Eof {\n             last_span = None;\n-            let mut next = toks.next_token();\n+            let mut next = toks.real_token();\n \n             if (next.tok == token::OpenDelim(token::Paren) ||\n                 next.tok == token::Lt) &&\n@@ -156,7 +159,7 @@ impl<'a> SpanUtils<'a> {\n                 next.tok == token::ModSep {\n                 let old = prev;\n                 prev = next;\n-                next = toks.next_token();\n+                next = toks.real_token();\n                 if next.tok == token::Lt &&\n                    old.tok.is_ident() {\n                     result = Some(old.sp);\n@@ -185,11 +188,11 @@ impl<'a> SpanUtils<'a> {\n     // brackets, or the last span.\n     pub fn sub_span_for_type_name(&self, span: Span) -> Option<Span> {\n         let mut toks = self.retokenise_span(span);\n-        let mut prev = toks.next_token();\n+        let mut prev = toks.real_token();\n         let mut result = None;\n         let mut bracket_count = 0u;\n         loop {\n-            let next = toks.next_token();\n+            let next = toks.real_token();\n \n             if (next.tok == token::Lt ||\n                 next.tok == token::Colon) &&\n@@ -234,7 +237,7 @@ impl<'a> SpanUtils<'a> {\n         // We keep track of how many brackets we're nested in\n         let mut bracket_count = 0i;\n         loop {\n-            let ts = toks.next_token();\n+            let ts = toks.real_token();\n             if ts.tok == token::Eof {\n                 if bracket_count != 0 {\n                     let loc = self.sess.codemap().lookup_char_pos(span.lo);\n@@ -263,12 +266,12 @@ impl<'a> SpanUtils<'a> {\n \n     pub fn sub_span_before_token(&self, span: Span, tok: Token) -> Option<Span> {\n         let mut toks = self.retokenise_span(span);\n-        let mut prev = toks.next_token();\n+        let mut prev = toks.real_token();\n         loop {\n             if prev.tok == token::Eof {\n                 return None;\n             }\n-            let next = toks.next_token();\n+            let next = toks.real_token();\n             if next.tok == tok {\n                 return self.make_sub_span(span, Some(prev.sp));\n             }\n@@ -281,15 +284,16 @@ impl<'a> SpanUtils<'a> {\n                               keyword: keywords::Keyword) -> Option<Span> {\n         let mut toks = self.retokenise_span(span);\n         loop {\n-            let ts = toks.next_token();\n+            let ts = toks.real_token();\n             if ts.tok == token::Eof {\n                 return None;\n             }\n             if ts.tok.is_keyword(keyword) {\n-                let ts = toks.next_token();\n+                let ts = toks.real_token();\n                 if ts.tok == token::Eof {\n                     return None\n                 } else {\n+                    println!(\"found keyword: {} at {}\", ts, ts.sp);\n                     return self.make_sub_span(span, Some(ts.sp));\n                 }\n             }"}, {"sha": "7f6a73c83fa76fb804422d6e371001da8ac06063", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -86,7 +86,7 @@ impl<'v> Visitor<'v> for Annotator {\n                 }\n             }\n \n-            TypeTraitItem(ref typedef) => (typedef.id, &typedef.attrs),\n+            TypeTraitItem(ref typedef) => (typedef.ty_param.id, &typedef.attrs),\n         };\n         self.annotate(id, attrs, |v| visit::walk_trait_item(v, t));\n     }"}, {"sha": "a29f99236e0cdf91561ec4ea65a7a876ed5e3db6", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 75, "deletions": 102, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -16,66 +16,10 @@ use middle::ty_fold::{TypeFoldable, TypeFolder};\n use util::ppaux::Repr;\n \n use std::fmt;\n-use std::mem;\n-use std::raw;\n-use std::slice::{Items, MutItems};\n+use std::slice::Items;\n use std::vec::Vec;\n use syntax::codemap::{Span, DUMMY_SP};\n \n-///////////////////////////////////////////////////////////////////////////\n-// HomogeneousTuple3 trait\n-//\n-// This could be moved into standard library at some point.\n-\n-trait HomogeneousTuple3<T> {\n-    fn len(&self) -> uint;\n-    fn as_slice<'a>(&'a self) -> &'a [T];\n-    fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T];\n-    fn iter<'a>(&'a self) -> Items<'a, T>;\n-    fn iter_mut<'a>(&'a mut self) -> MutItems<'a, T>;\n-    fn get<'a>(&'a self, index: uint) -> Option<&'a T>;\n-    fn get_mut<'a>(&'a mut self, index: uint) -> Option<&'a mut T>;\n-}\n-\n-impl<T> HomogeneousTuple3<T> for (T, T, T) {\n-    fn len(&self) -> uint {\n-        3\n-    }\n-\n-    fn as_slice<'a>(&'a self) -> &'a [T] {\n-        unsafe {\n-            let ptr: *const T = mem::transmute(self);\n-            let slice = raw::Slice { data: ptr, len: 3 };\n-            mem::transmute(slice)\n-        }\n-    }\n-\n-    fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T] {\n-        unsafe {\n-            let ptr: *const T = mem::transmute(self);\n-            let slice = raw::Slice { data: ptr, len: 3 };\n-            mem::transmute(slice)\n-        }\n-    }\n-\n-    fn iter<'a>(&'a self) -> Items<'a, T> {\n-        let slice: &'a [T] = self.as_slice();\n-        slice.iter()\n-    }\n-\n-    fn iter_mut<'a>(&'a mut self) -> MutItems<'a, T> {\n-        self.as_mut_slice().iter_mut()\n-    }\n-\n-    fn get<'a>(&'a self, index: uint) -> Option<&'a T> {\n-        self.as_slice().get(index)\n-    }\n-\n-    fn get_mut<'a>(&'a mut self, index: uint) -> Option<&'a mut T> {\n-        Some(&mut self.as_mut_slice()[index]) // wrong: fallible\n-    }\n-}\n-\n ///////////////////////////////////////////////////////////////////////////\n \n /**\n@@ -112,17 +56,18 @@ impl Substs {\n                     r: Vec<ty::Region>)\n                     -> Substs\n     {\n-        Substs::new(VecPerParamSpace::new(t, Vec::new(), Vec::new()),\n-                    VecPerParamSpace::new(r, Vec::new(), Vec::new()))\n+        Substs::new(VecPerParamSpace::new(t, Vec::new(), Vec::new(), Vec::new()),\n+                    VecPerParamSpace::new(r, Vec::new(), Vec::new(), Vec::new()))\n     }\n \n     pub fn new_trait(t: Vec<ty::t>,\n                      r: Vec<ty::Region>,\n+                     a: Vec<ty::t>,\n                      s: ty::t)\n                     -> Substs\n     {\n-        Substs::new(VecPerParamSpace::new(t, vec!(s), Vec::new()),\n-                    VecPerParamSpace::new(r, Vec::new(), Vec::new()))\n+        Substs::new(VecPerParamSpace::new(t, vec!(s), a, Vec::new()),\n+                    VecPerParamSpace::new(r, Vec::new(), Vec::new(), Vec::new()))\n     }\n \n     pub fn erased(t: VecPerParamSpace<ty::t>) -> Substs\n@@ -226,29 +171,32 @@ impl RegionSubsts {\n #[deriving(PartialOrd, Ord, PartialEq, Eq,\n            Clone, Hash, Encodable, Decodable, Show)]\n pub enum ParamSpace {\n-    TypeSpace, // Type parameters attached to a type definition, trait, or impl\n-    SelfSpace, // Self parameter on a trait\n-    FnSpace,   // Type parameters attached to a method or fn\n+    TypeSpace,  // Type parameters attached to a type definition, trait, or impl\n+    SelfSpace,  // Self parameter on a trait\n+    AssocSpace, // Assoc types defined in a trait/impl\n+    FnSpace,    // Type parameters attached to a method or fn\n }\n \n impl ParamSpace {\n-    pub fn all() -> [ParamSpace, ..3] {\n-        [TypeSpace, SelfSpace, FnSpace]\n+    pub fn all() -> [ParamSpace, ..4] {\n+        [TypeSpace, SelfSpace, AssocSpace, FnSpace]\n     }\n \n     pub fn to_uint(self) -> uint {\n         match self {\n             TypeSpace => 0,\n             SelfSpace => 1,\n-            FnSpace => 2,\n+            AssocSpace => 2,\n+            FnSpace => 3,\n         }\n     }\n \n     pub fn from_uint(u: uint) -> ParamSpace {\n         match u {\n             0 => TypeSpace,\n             1 => SelfSpace,\n-            2 => FnSpace,\n+            2 => AssocSpace,\n+            3 => FnSpace,\n             _ => panic!(\"Invalid ParamSpace: {}\", u)\n         }\n     }\n@@ -268,14 +216,27 @@ pub struct VecPerParamSpace<T> {\n     // Here is how the representation corresponds to the abstraction\n     // i.e. the \"abstraction function\" AF:\n     //\n-    // AF(self) = (self.content.slice_to(self.type_limit),\n-    //             self.content.slice(self.type_limit, self.self_limit),\n-    //             self.content.slice_from(self.self_limit))\n+    // AF(self) = (self.content[..self.type_limit],\n+    //             self.content[self.type_limit..self.self_limit],\n+    //             self.content[self.self_limit..self.assoc_limit],\n+    //             self.content[self.assoc_limit..])\n     type_limit: uint,\n     self_limit: uint,\n+    assoc_limit: uint,\n     content: Vec<T>,\n }\n \n+/**\n+ * The `split` function converts one `VecPerParamSpace` into this\n+ * `SeparateVecsPerParamSpace` structure.\n+ */\n+pub struct SeparateVecsPerParamSpace<T> {\n+    pub types: Vec<T>,\n+    pub selfs: Vec<T>,\n+    pub assocs: Vec<T>,\n+    pub fns: Vec<T>,\n+}\n+\n impl<T:fmt::Show> fmt::Show for VecPerParamSpace<T> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(fmt, \"VecPerParamSpace {{\"));\n@@ -292,14 +253,16 @@ impl<T> VecPerParamSpace<T> {\n         match space {\n             TypeSpace => (0, self.type_limit),\n             SelfSpace => (self.type_limit, self.self_limit),\n-            FnSpace => (self.self_limit, self.content.len()),\n+            AssocSpace => (self.self_limit, self.assoc_limit),\n+            FnSpace => (self.assoc_limit, self.content.len()),\n         }\n     }\n \n     pub fn empty() -> VecPerParamSpace<T> {\n         VecPerParamSpace {\n             type_limit: 0,\n             self_limit: 0,\n+            assoc_limit: 0,\n             content: Vec::new()\n         }\n     }\n@@ -310,26 +273,33 @@ impl<T> VecPerParamSpace<T> {\n \n     /// `t` is the type space.\n     /// `s` is the self space.\n+    /// `a` is the assoc space.\n     /// `f` is the fn space.\n-    pub fn new(t: Vec<T>, s: Vec<T>, f: Vec<T>) -> VecPerParamSpace<T> {\n+    pub fn new(t: Vec<T>, s: Vec<T>, a: Vec<T>, f: Vec<T>) -> VecPerParamSpace<T> {\n         let type_limit = t.len();\n-        let self_limit = t.len() + s.len();\n+        let self_limit = type_limit + s.len();\n+        let assoc_limit = self_limit + a.len();\n+\n         let mut content = t;\n         content.extend(s.into_iter());\n+        content.extend(a.into_iter());\n         content.extend(f.into_iter());\n+\n         VecPerParamSpace {\n             type_limit: type_limit,\n             self_limit: self_limit,\n+            assoc_limit: assoc_limit,\n             content: content,\n         }\n     }\n \n-    fn new_internal(content: Vec<T>, type_limit: uint, self_limit: uint)\n+    fn new_internal(content: Vec<T>, type_limit: uint, self_limit: uint, assoc_limit: uint)\n                     -> VecPerParamSpace<T>\n     {\n         VecPerParamSpace {\n             type_limit: type_limit,\n             self_limit: self_limit,\n+            assoc_limit: assoc_limit,\n             content: content,\n         }\n     }\n@@ -341,9 +311,10 @@ impl<T> VecPerParamSpace<T> {\n     pub fn push(&mut self, space: ParamSpace, value: T) {\n         let (_, limit) = self.limits(space);\n         match space {\n-            TypeSpace => { self.type_limit += 1; self.self_limit += 1; }\n-            SelfSpace => { self.self_limit += 1; }\n-            FnSpace   => {}\n+            TypeSpace => { self.type_limit += 1; self.self_limit += 1; self.assoc_limit += 1; }\n+            SelfSpace => { self.self_limit += 1; self.assoc_limit += 1; }\n+            AssocSpace => { self.assoc_limit += 1; }\n+            FnSpace => { }\n         }\n         self.content.insert(limit, value);\n     }\n@@ -354,9 +325,10 @@ impl<T> VecPerParamSpace<T> {\n             None\n         } else {\n             match space {\n-                TypeSpace => { self.type_limit -= 1; self.self_limit -= 1; }\n-                SelfSpace => { self.self_limit -= 1; }\n-                FnSpace   => {}\n+                TypeSpace => { self.type_limit -= 1; self.self_limit -= 1; self.assoc_limit -= 1; }\n+                SelfSpace => { self.self_limit -= 1; self.assoc_limit -= 1; }\n+                AssocSpace => { self.assoc_limit -= 1; }\n+                FnSpace => {}\n             }\n             self.content.remove(limit - 1)\n         }\n@@ -442,35 +414,35 @@ impl<T> VecPerParamSpace<T> {\n         let result = self.iter().map(pred).collect();\n         VecPerParamSpace::new_internal(result,\n                                        self.type_limit,\n-                                       self.self_limit)\n+                                       self.self_limit,\n+                                       self.assoc_limit)\n     }\n \n     pub fn map_move<U>(self, pred: |T| -> U) -> VecPerParamSpace<U> {\n-        let (t, s, f) = self.split();\n+        let SeparateVecsPerParamSpace {\n+            types: t,\n+            selfs: s,\n+            assocs: a,\n+            fns: f\n+        } = self.split();\n+\n         VecPerParamSpace::new(t.into_iter().map(|p| pred(p)).collect(),\n                               s.into_iter().map(|p| pred(p)).collect(),\n+                              a.into_iter().map(|p| pred(p)).collect(),\n                               f.into_iter().map(|p| pred(p)).collect())\n     }\n \n-    pub fn split(self) -> (Vec<T>, Vec<T>, Vec<T>) {\n-        // FIXME (#15418): this does two traversals when in principle\n-        // one would suffice.  i.e. change to use `move_iter`.\n-        let VecPerParamSpace { type_limit, self_limit, content } = self;\n-        let mut i = 0;\n-        let (prefix, fn_vec) = content.partition(|_| {\n-            let on_left = i < self_limit;\n-            i += 1;\n-            on_left\n-        });\n+    pub fn split(self) -> SeparateVecsPerParamSpace<T> {\n+        let VecPerParamSpace { type_limit, self_limit, assoc_limit, content } = self;\n \n-        let mut i = 0;\n-        let (type_vec, self_vec) = prefix.partition(|_| {\n-            let on_left = i < type_limit;\n-            i += 1;\n-            on_left\n-        });\n+        let mut content_iter = content.into_iter();\n \n-        (type_vec, self_vec, fn_vec)\n+        SeparateVecsPerParamSpace {\n+            types: content_iter.by_ref().take(type_limit).collect(),\n+            selfs: content_iter.by_ref().take(self_limit - type_limit).collect(),\n+            assocs: content_iter.by_ref().take(assoc_limit - self_limit).collect(),\n+            fns: content_iter.collect()\n+        }\n     }\n \n     pub fn with_vec(mut self, space: ParamSpace, vec: Vec<T>)\n@@ -616,12 +588,13 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n                     this.tcx().sess.span_bug(\n                         span,\n                         format!(\"Type parameter `{}` ({}/{}/{}) out of range \\\n-                                 when substituting (root type={})\",\n+                                 when substituting (root type={}) substs={}\",\n                                 p.repr(this.tcx()),\n                                 source_ty.repr(this.tcx()),\n                                 space,\n                                 index,\n-                                this.root_ty.repr(this.tcx())).as_slice());\n+                                this.root_ty.repr(this.tcx()),\n+                                this.substs.repr(this.tcx())).as_slice());\n                 }\n             }\n         }"}, {"sha": "9a2d5b4d4dc0a44d209690893384acaaa3639a64", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -514,7 +514,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // and `Rc<Baz>`. (Note that it is not a *coherence violation*\n         // to have impls for both `Bar` and `Baz`, despite this\n         // ambiguity).  In this case, we report an error, listing all\n-        // the applicable impls.  The use can explicitly \"up-coerce\"\n+        // the applicable impls.  The user can explicitly \"up-coerce\"\n         // to the type they want.\n         //\n         // Note that this coercion step only considers actual impls\n@@ -1618,7 +1618,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             Ok(o) => o,\n             Err(ErrorReported) => Vec::new()\n         };\n-        let obligations = VecPerParamSpace::new(obligations, Vec::new(), Vec::new());\n+        let obligations = VecPerParamSpace::new(obligations, Vec::new(),\n+                                                Vec::new(), Vec::new());\n         VtableBuiltinData { nested: obligations }\n     }\n \n@@ -1693,6 +1694,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 vec![arguments_tuple.subst(self.tcx(), substs),\n                      new_signature.output.unwrap().subst(self.tcx(), substs)],\n                 vec![],\n+                vec![],\n                 obligation.self_ty())\n         });\n \n@@ -1942,7 +1944,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn all_impls(&self, trait_def_id: ast::DefId) -> Vec<ast::DefId> {\n         /*!\n-         * Returns se tof all impls for a given trait.\n+         * Returns set of all impls for a given trait.\n          */\n \n         ty::populate_implementations_for_trait_if_necessary(self.tcx(),"}, {"sha": "fbd4db959ce0cbbca74fb3b3f7e15ce841d3002c", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -205,7 +205,12 @@ pub fn trans_static_method_callee(bcx: Block,\n     // type parameters that belong to the trait but also some that\n     // belong to the method:\n     let rcvr_substs = node_id_substs(bcx, ExprId(expr_id));\n-    let (rcvr_type, rcvr_self, rcvr_method) = rcvr_substs.types.split();\n+    let subst::SeparateVecsPerParamSpace {\n+        types: rcvr_type,\n+        selfs: rcvr_self,\n+        assocs: rcvr_assoc,\n+        fns: rcvr_method\n+    } = rcvr_substs.types.split();\n \n     // Lookup the precise impl being called. To do that, we need to\n     // create a trait reference identifying the self type and other\n@@ -232,6 +237,7 @@ pub fn trans_static_method_callee(bcx: Block,\n     let trait_substs =\n         Substs::erased(VecPerParamSpace::new(rcvr_type,\n                                              rcvr_self,\n+                                             rcvr_assoc,\n                                              Vec::new()));\n     debug!(\"trait_substs={}\", trait_substs.repr(bcx.tcx()));\n     let trait_ref = Rc::new(ty::TraitRef { def_id: trait_id,\n@@ -265,10 +271,16 @@ pub fn trans_static_method_callee(bcx: Block,\n             // that with the `rcvr_method` from before, which tells us\n             // the type parameters from the *method*, to yield\n             // `callee_substs=[[T=int],[],[U=String]]`.\n-            let (impl_type, impl_self, _) = impl_substs.types.split();\n+            let subst::SeparateVecsPerParamSpace {\n+                types: impl_type,\n+                selfs: impl_self,\n+                assocs: impl_assoc,\n+                fns: _\n+            } = impl_substs.types.split();\n             let callee_substs =\n                 Substs::erased(VecPerParamSpace::new(impl_type,\n                                                      impl_self,\n+                                                     impl_assoc,\n                                                      rcvr_method));\n \n             let mth_id = method_with_name(ccx, impl_did, mname);\n@@ -397,12 +409,17 @@ fn combine_impl_and_methods_tps(bcx: Block,\n \n     // Break apart the type parameters from the node and type\n     // parameters from the receiver.\n-    let (_, _, node_method) = node_substs.types.split();\n-    let (rcvr_type, rcvr_self, rcvr_method) = rcvr_substs.types.clone().split();\n+    let node_method = node_substs.types.split().fns;\n+    let subst::SeparateVecsPerParamSpace {\n+        types: rcvr_type,\n+        selfs: rcvr_self,\n+        assocs: rcvr_assoc,\n+        fns: rcvr_method\n+    } = rcvr_substs.types.clone().split();\n     assert!(rcvr_method.is_empty());\n     subst::Substs {\n         regions: subst::ErasedRegions,\n-        types: subst::VecPerParamSpace::new(rcvr_type, rcvr_self, node_method)\n+        types: subst::VecPerParamSpace::new(rcvr_type, rcvr_self, rcvr_assoc, node_method)\n     }\n }\n "}, {"sha": "1746f78531161b1fae833a8bb45dff613f64bb43", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -27,6 +27,7 @@ use std::collections::HashMap;\n use libc::c_uint;\n \n #[deriving(Clone, PartialEq, Show)]\n+#[repr(C)]\n pub struct Type {\n     rf: TypeRef\n }\n@@ -283,9 +284,10 @@ impl Type {\n             if n_elts == 0 {\n                 return Vec::new();\n             }\n-            let mut elts = Vec::from_elem(n_elts, 0 as TypeRef);\n-            llvm::LLVMGetStructElementTypes(self.to_ref(), &mut elts[0]);\n-            mem::transmute(elts)\n+            let mut elts = Vec::from_elem(n_elts, Type { rf: 0 as TypeRef });\n+            llvm::LLVMGetStructElementTypes(self.to_ref(),\n+                                            elts.as_mut_ptr() as *mut TypeRef);\n+            elts\n         }\n     }\n \n@@ -296,9 +298,10 @@ impl Type {\n     pub fn func_params(&self) -> Vec<Type> {\n         unsafe {\n             let n_args = llvm::LLVMCountParamTypes(self.to_ref()) as uint;\n-            let args = Vec::from_elem(n_args, 0 as TypeRef);\n-            llvm::LLVMGetParamTypes(self.to_ref(), args.as_ptr());\n-            mem::transmute(args)\n+            let mut args = Vec::from_elem(n_args, Type { rf: 0 as TypeRef });\n+            llvm::LLVMGetParamTypes(self.to_ref(),\n+                                    args.as_mut_ptr() as *mut TypeRef);\n+            args\n         }\n     }\n "}, {"sha": "a94b188cb28bd55d52d8ed75468b29319c3fcc9f", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 10, "deletions": 17, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -573,10 +573,6 @@ pub struct ctxt<'tcx> {\n     /// Maps def IDs to true if and only if they're associated types.\n     pub associated_types: RefCell<DefIdMap<bool>>,\n \n-    /// Maps def IDs of traits to information about their associated types.\n-    pub trait_associated_types:\n-        RefCell<DefIdMap<Rc<Vec<AssociatedTypeInfo>>>>,\n-\n     /// Caches the results of trait selection. This cache is used\n     /// for things that do not have to do with the parameters in scope.\n     pub selection_cache: traits::SelectionCache,\n@@ -1564,7 +1560,6 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         stability: RefCell::new(stability),\n         capture_modes: capture_modes,\n         associated_types: RefCell::new(DefIdMap::new()),\n-        trait_associated_types: RefCell::new(DefIdMap::new()),\n         selection_cache: traits::SelectionCache::new(),\n         repr_hint_cache: RefCell::new(DefIdMap::new()),\n    }\n@@ -1994,6 +1989,16 @@ impl ItemSubsts {\n     }\n }\n \n+impl ParamBounds {\n+    pub fn empty() -> ParamBounds {\n+        ParamBounds {\n+            builtin_bounds: empty_builtin_bounds(),\n+            trait_bounds: Vec::new(),\n+            region_bounds: Vec::new(),\n+        }\n+    }\n+}\n+\n // Type utilities\n \n pub fn type_is_nil(ty: t) -> bool {\n@@ -4155,18 +4160,6 @@ impl Ord for AssociatedTypeInfo {\n     }\n }\n \n-/// Returns the associated types belonging to the given trait, in parameter\n-/// order.\n-pub fn associated_types_for_trait(cx: &ctxt, trait_id: ast::DefId)\n-                                  -> Rc<Vec<AssociatedTypeInfo>> {\n-    cx.trait_associated_types\n-      .borrow()\n-      .find(&trait_id)\n-      .expect(\"associated_types_for_trait(): trait not found, try calling \\\n-               ensure_associated_types()\")\n-      .clone()\n-}\n-\n pub fn trait_item_def_ids(cx: &ctxt, id: ast::DefId)\n                           -> Rc<Vec<ImplOrTraitItemId>> {\n     lookup_locally_or_in_crate_store(\"trait_item_def_ids\","}, {"sha": "7c8d9309df3b823898f5328117a5991fb06cb9a1", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 38, "deletions": 13, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -54,7 +54,7 @@ use middle::def;\n use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem};\n use middle::lang_items::{FnOnceTraitLangItem};\n use middle::resolve_lifetime as rl;\n-use middle::subst::{FnSpace, TypeSpace, SelfSpace, Subst, Substs};\n+use middle::subst::{FnSpace, TypeSpace, AssocSpace, SelfSpace, Subst, Substs};\n use middle::subst::{VecPerParamSpace};\n use middle::ty;\n use middle::typeck::lookup_def_tcx;\n@@ -215,7 +215,8 @@ fn ast_path_substs<'tcx,AC,RS>(\n                    associated_ty: Option<ty::t>,\n                    path: &ast::Path)\n                    -> Substs\n-                   where AC: AstConv<'tcx>, RS: RegionScope {\n+                   where AC: AstConv<'tcx>, RS: RegionScope\n+{\n     /*!\n      * Given a path `path` that refers to an item `I` with the\n      * declared generics `decl_generics`, returns an appropriate\n@@ -338,17 +339,21 @@ fn ast_path_substs<'tcx,AC,RS>(\n                 substs.types.push(TypeSpace, default);\n             }\n             None => {\n-                // This is an associated type.\n-                substs.types.push(\n-                    TypeSpace,\n-                    this.associated_type_binding(path.span,\n-                                                 associated_ty,\n-                                                 decl_def_id,\n-                                                 param.def_id))\n+                tcx.sess.span_bug(path.span,\n+                                  \"extra parameter without default\");\n             }\n         }\n     }\n \n+    for param in decl_generics.types.get_slice(AssocSpace).iter() {\n+        substs.types.push(\n+            AssocSpace,\n+            this.associated_type_binding(path.span,\n+                                         associated_ty,\n+                                         decl_def_id,\n+                                         param.def_id))\n+    }\n+\n     substs\n }\n \n@@ -628,9 +633,13 @@ fn mk_pointer<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n         a_seq_ty: &ast::Ty,\n         ptr_ty: PointerTy,\n         constr: |ty::t| -> ty::t)\n-        -> ty::t {\n+        -> ty::t\n+{\n     let tcx = this.tcx();\n-    debug!(\"mk_pointer(ptr_ty={})\", ptr_ty);\n+\n+    debug!(\"mk_pointer(ptr_ty={}, a_seq_ty={})\",\n+           ptr_ty,\n+           a_seq_ty.repr(tcx));\n \n     match a_seq_ty.node {\n         ast::TyVec(ref ty) => {\n@@ -730,7 +739,13 @@ fn associated_ty_to_ty<'tcx,AC,RS>(this: &AC,\n                                    trait_type_id: ast::DefId,\n                                    span: Span)\n                                    -> ty::t\n-                                   where AC: AstConv<'tcx>, RS: RegionScope {\n+                                   where AC: AstConv<'tcx>, RS: RegionScope\n+{\n+    debug!(\"associated_ty_to_ty(trait_path={}, for_ast_type={}, trait_type_id={})\",\n+           trait_path.repr(this.tcx()),\n+           for_ast_type.repr(this.tcx()),\n+           trait_type_id.repr(this.tcx()));\n+\n     // Find the trait that this associated type belongs to.\n     let trait_did = match ty::impl_or_trait_item(this.tcx(),\n                                                  trait_type_id).container() {\n@@ -757,9 +772,16 @@ fn associated_ty_to_ty<'tcx,AC,RS>(this: &AC,\n                                           None,\n                                           Some(for_type),\n                                           trait_path);\n+\n+    debug!(\"associated_ty_to_ty(trait_ref={})\",\n+           trait_ref.repr(this.tcx()));\n+\n     let trait_def = this.get_trait_def(trait_did);\n     for type_parameter in trait_def.generics.types.iter() {\n         if type_parameter.def_id == trait_type_id {\n+            debug!(\"associated_ty_to_ty(type_parameter={} substs={})\",\n+                   type_parameter.repr(this.tcx()),\n+                   trait_ref.substs.repr(this.tcx()));\n             return *trait_ref.substs.types.get(type_parameter.space,\n                                                type_parameter.index)\n         }\n@@ -772,7 +794,10 @@ fn associated_ty_to_ty<'tcx,AC,RS>(this: &AC,\n // Parses the programmer's textual representation of a type into our\n // internal notion of a type.\n pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n-        this: &AC, rscope: &RS, ast_ty: &ast::Ty) -> ty::t {\n+        this: &AC, rscope: &RS, ast_ty: &ast::Ty) -> ty::t\n+{\n+    debug!(\"ast_ty_to_ty(ast_ty={})\",\n+           ast_ty.repr(this.tcx()));\n \n     let tcx = this.tcx();\n "}, {"sha": "92b5b696e52211001a96f56cb1ebb9381c2df44d", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -2536,7 +2536,7 @@ fn check_argument_types<'a>(fcx: &FnCtxt,\n                 span_err!(tcx.sess, sp, E0059,\n                     \"cannot use call notation; the first type parameter \\\n                      for the function trait is neither a tuple nor unit\");\n-                err_args(supplied_arg_count)\n+                err_args(args.len())\n             }\n         }\n     } else if expected_arg_count == supplied_arg_count {"}, {"sha": "ac18f53de046599cc8ac9651e4c5a6e6ef3812ca", "filename": "src/librustc/middle/typeck/coherence/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -207,8 +207,8 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n         let impl_items = self.create_impl_from_item(item);\n \n         for associated_trait in associated_traits.iter() {\n-            let trait_ref = ty::node_id_to_trait_ref(\n-                self.crate_context.tcx, associated_trait.ref_id);\n+            let trait_ref = ty::node_id_to_trait_ref(self.crate_context.tcx,\n+                                                     associated_trait.ref_id);\n             debug!(\"(checking implementation) adding impl for trait '{}', item '{}'\",\n                    trait_ref.repr(self.crate_context.tcx),\n                    token::get_ident(item.ident));"}, {"sha": "3c4ad3473610cfd0509a956a6bba4b053ee7fa90", "filename": "src/librustc/middle/typeck/coherence/orphan.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Forphan.rs?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -41,7 +41,8 @@ impl<'cx, 'tcx,'v> visit::Visitor<'v> for OrphanChecker<'cx, 'tcx> {\n                 let self_ty = ty::lookup_item_type(self.tcx, def_id).ty;\n                 match ty::get(self_ty).sty {\n                     ty::ty_enum(def_id, _) |\n-                    ty::ty_struct(def_id, _) => {\n+                    ty::ty_struct(def_id, _) |\n+                    ty::ty_trait(box ty::TyTrait{ def_id, ..}) => {\n                         if def_id.krate != ast::LOCAL_CRATE {\n                             span_err!(self.tcx.sess, item.span, E0116,\n                                       \"cannot associate methods with a type outside the \\"}, {"sha": "863f09736ab2784f03de6aee31f8c11f0adc549f", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 192, "deletions": 235, "changes": 427, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -298,13 +298,19 @@ fn collect_trait_methods(ccx: &CrateCtxt,\n                                             &*m.pe_fn_decl())\n                                     }\n                                     ast::TypeTraitItem(ref at) => {\n-                                        tcx.sess.span_bug(at.span,\n+                                        tcx.sess.span_bug(at.ty_param.span,\n                                                           \"there shouldn't \\\n                                                            be a type trait \\\n                                                            item here\")\n                                     }\n                                 });\n \n+                                debug!(\"ty_method_of_trait_method yielded {} \\\n+                                        for method {} of trait {}\",\n+                                       ty_method.repr(ccx.tcx),\n+                                       trait_item.repr(ccx.tcx),\n+                                       local_def(trait_id).repr(ccx.tcx));\n+\n                                 make_method_ty(ccx, &*ty_method);\n \n                                 tcx.impl_or_trait_items\n@@ -315,9 +321,9 @@ fn collect_trait_methods(ccx: &CrateCtxt,\n                             ast::TypeTraitItem(ref ast_associated_type) => {\n                                 let trait_did = local_def(trait_id);\n                                 let associated_type = ty::AssociatedType {\n-                                    name: ast_associated_type.ident.name,\n+                                    name: ast_associated_type.ty_param.ident.name,\n                                     vis: ast::Public,\n-                                    def_id: local_def(ast_associated_type.id),\n+                                    def_id: local_def(ast_associated_type.ty_param.id),\n                                     container: TraitContainer(trait_did),\n                                 };\n \n@@ -345,7 +351,7 @@ fn collect_trait_methods(ccx: &CrateCtxt,\n                                             method.id))\n                                 }\n                                 ast::TypeTraitItem(ref typedef) => {\n-                                    ty::TypeTraitItemId(local_def(typedef.id))\n+                                    ty::TypeTraitItemId(local_def(typedef.ty_param.id))\n                                 }\n                             }\n                         }).collect());\n@@ -460,35 +466,35 @@ fn convert_associated_type(ccx: &CrateCtxt,\n     // associated type.\n     let type_parameter_def = trait_def.generics\n                                       .types\n-                                      .get_slice(subst::TypeSpace)\n+                                      .get_slice(subst::AssocSpace)\n                                       .iter()\n                                       .find(|def| {\n-        def.def_id == local_def(associated_type.id)\n+        def.def_id == local_def(associated_type.ty_param.id)\n     });\n     let type_parameter_def = match type_parameter_def {\n         Some(type_parameter_def) => type_parameter_def,\n         None => {\n-            ccx.tcx().sess.span_bug(associated_type.span,\n+            ccx.tcx().sess.span_bug(associated_type.ty_param.span,\n                                     \"`convert_associated_type()` didn't find \\\n                                      a type parameter ID corresponding to \\\n                                      this type\")\n         }\n     };\n     let param_type = ty::mk_param(ccx.tcx,\n-                                  subst::TypeSpace,\n+                                  type_parameter_def.space,\n                                   type_parameter_def.index,\n-                                  local_def(associated_type.id));\n-    ccx.tcx.tcache.borrow_mut().insert(local_def(associated_type.id),\n+                                  local_def(associated_type.ty_param.id));\n+    ccx.tcx.tcache.borrow_mut().insert(local_def(associated_type.ty_param.id),\n                                        Polytype {\n                                         generics: ty::Generics::empty(),\n                                         ty: param_type,\n                                        });\n-    write_ty_to_tcx(ccx.tcx, associated_type.id, param_type);\n+    write_ty_to_tcx(ccx.tcx, associated_type.ty_param.id, param_type);\n \n     let associated_type = Rc::new(ty::AssociatedType {\n-        name: associated_type.ident.name,\n+        name: associated_type.ty_param.ident.name,\n         vis: ast::Public,\n-        def_id: local_def(associated_type.id),\n+        def_id: local_def(associated_type.ty_param.id),\n         container: TraitContainer(trait_def.trait_ref.def_id),\n     });\n     ccx.tcx\n@@ -780,25 +786,18 @@ impl<'a,'tcx> AstConv<'tcx> for ImplCtxt<'a,'tcx> {\n                                ty: Option<ty::t>,\n                                trait_id: ast::DefId,\n                                associated_type_id: ast::DefId)\n-                               -> ty::t {\n-        ensure_associated_types(self, trait_id);\n-        let associated_type_ids = ty::associated_types_for_trait(self.ccx.tcx,\n-                                                                 trait_id);\n+                               -> ty::t\n+    {\n+        let trait_def = ty::lookup_trait_def(self.tcx(), trait_id);\n         match self.opt_trait_ref_id {\n             Some(trait_ref_id) if trait_ref_id == trait_id => {\n                 // It's an associated type on the trait that we're\n                 // implementing.\n-                let associated_type_id =\n-                    associated_type_ids.iter()\n-                                       .find(|id| {\n-                                           id.def_id == associated_type_id\n-                                       })\n-                                       .expect(\"associated_type_binding(): \\\n-                                                expected associated type ID \\\n-                                                in trait\");\n-                let associated_type =\n-                    ty::impl_or_trait_item(self.ccx.tcx,\n-                                           associated_type_id.def_id);\n+                assert!(trait_def.generics.types\n+                        .get_slice(subst::AssocSpace)\n+                        .iter()\n+                        .any(|type_param_def| type_param_def.def_id == associated_type_id));\n+                let associated_type = ty::impl_or_trait_item(self.ccx.tcx, associated_type_id);\n                 for impl_item in self.impl_items.iter() {\n                     match *impl_item {\n                         ast::MethodImplItem(_) => {}\n@@ -978,9 +977,9 @@ impl<'a,'tcx> AstConv<'tcx> for TraitMethodCtxt<'a,'tcx> {\n                 match *item {\n                     ast::RequiredMethod(_) | ast::ProvidedMethod(_) => {}\n                     ast::TypeTraitItem(ref item) => {\n-                        if local_def(item.id) == associated_type_id {\n+                        if local_def(item.ty_param.id) == associated_type_id {\n                             return ty::mk_param(self.tcx(),\n-                                                subst::TypeSpace,\n+                                                subst::AssocSpace,\n                                                 index,\n                                                 associated_type_id)\n                         }\n@@ -1451,7 +1450,8 @@ pub fn trait_def_of_item(ccx: &CrateCtxt, it: &ast::Item) -> Rc<ty::TraitDef> {\n                        trait_id: ast::NodeId,\n                        generics: &ast::Generics,\n                        items: &[ast::TraitItem])\n-                        -> subst::Substs {\n+                        -> subst::Substs\n+    {\n         // Creates a no-op substitution for the trait's type parameters.\n         let regions =\n             generics.lifetimes\n@@ -1464,32 +1464,35 @@ pub fn trait_def_of_item(ccx: &CrateCtxt, it: &ast::Item) -> Rc<ty::TraitDef> {\n                     .collect();\n \n         // Start with the generics in the type parameters...\n-        let mut types: Vec<_> =\n+        let types: Vec<_> =\n             generics.ty_params\n                     .iter()\n                     .enumerate()\n                     .map(|(i, def)| ty::mk_param(ccx.tcx, subst::TypeSpace,\n                                                  i, local_def(def.id)))\n                     .collect();\n \n-        // ...and add generics synthesized from the associated types.\n-        for item in items.iter() {\n-            match *item {\n+        // ...and also create generics synthesized from the associated types.\n+        let assoc_types: Vec<_> =\n+            items.iter()\n+            .flat_map(|item| match *item {\n                 ast::TypeTraitItem(ref trait_item) => {\n                     let index = types.len();\n-                    types.push(ty::mk_param(ccx.tcx,\n-                                            subst::TypeSpace,\n-                                            index,\n-                                            local_def(trait_item.id)))\n+                    Some(ty::mk_param(ccx.tcx,\n+                                      subst::AssocSpace,\n+                                      index,\n+                                      local_def(trait_item.ty_param.id))).into_iter()\n                 }\n-                ast::RequiredMethod(_) | ast::ProvidedMethod(_) => {}\n-            }\n-        }\n+                ast::RequiredMethod(_) | ast::ProvidedMethod(_) => {\n+                    None.into_iter()\n+                }\n+            })\n+            .collect();\n \n         let self_ty =\n             ty::mk_param(ccx.tcx, subst::SelfSpace, 0, local_def(trait_id));\n \n-        subst::Substs::new_trait(types, regions, self_ty)\n+        subst::Substs::new_trait(types, regions, assoc_types, self_ty)\n     }\n }\n \n@@ -1630,11 +1633,11 @@ fn ty_of_trait_item(ccx: &CrateCtxt, trait_item: &ast::TraitItem)\n                                   \"ty_of_trait_item() on provided method\")\n         }\n         ast::TypeTraitItem(ref associated_type) => {\n-            let parent = ccx.tcx.map.get_parent(associated_type.id);\n+            let parent = ccx.tcx.map.get_parent(associated_type.ty_param.id);\n             let trait_def = match ccx.tcx.map.get(parent) {\n                 ast_map::NodeItem(item) => trait_def_of_item(ccx, &*item),\n                 _ => {\n-                    ccx.tcx.sess.span_bug(associated_type.span,\n+                    ccx.tcx.sess.span_bug(associated_type.ty_param.span,\n                                           \"associated type's parent wasn't \\\n                                            an item?!\")\n                 }\n@@ -1661,38 +1664,33 @@ fn ty_generics_for_type(ccx: &CrateCtxt,\n fn ty_generics_for_trait(ccx: &CrateCtxt,\n                          trait_id: ast::NodeId,\n                          substs: &subst::Substs,\n-                         generics: &ast::Generics,\n+                         ast_generics: &ast::Generics,\n                          items: &[ast::TraitItem])\n                          -> ty::Generics {\n     let mut generics =\n         ty_generics(ccx,\n                     subst::TypeSpace,\n-                    generics.lifetimes.as_slice(),\n-                    generics.ty_params.as_slice(),\n+                    ast_generics.lifetimes.as_slice(),\n+                    ast_generics.ty_params.as_slice(),\n                     ty::Generics::empty(),\n-                    &generics.where_clause,\n+                    &ast_generics.where_clause,\n                     DontCreateTypeParametersForAssociatedTypes);\n \n     // Add in type parameters for any associated types.\n     for item in items.iter() {\n         match *item {\n             ast::TypeTraitItem(ref associated_type) => {\n-                let def = ty::TypeParameterDef {\n-                    space: subst::TypeSpace,\n-                    index: generics.types.len(subst::TypeSpace),\n-                    name: associated_type.ident.name,\n-                    def_id: local_def(associated_type.id),\n-                    bounds: ty::ParamBounds {\n-                        builtin_bounds: ty::empty_builtin_bounds(),\n-                        trait_bounds: Vec::new(),\n-                        region_bounds: Vec::new(),\n-                    },\n-                    associated_with: Some(local_def(trait_id)),\n-                    default: None,\n-                };\n-                ccx.tcx.ty_param_defs.borrow_mut().insert(associated_type.id,\n+                let def =\n+                    get_or_create_type_parameter_def(\n+                        ccx,\n+                        subst::AssocSpace,\n+                        &associated_type.ty_param,\n+                        generics.types.len(subst::TypeSpace),\n+                        &ast_generics.where_clause,\n+                        Some(local_def(trait_id)));\n+                ccx.tcx.ty_param_defs.borrow_mut().insert(associated_type.ty_param.id,\n                                                           def.clone());\n-                generics.types.push(subst::TypeSpace, def);\n+                generics.types.push(subst::AssocSpace, def);\n             }\n             ast::ProvidedMethod(_) | ast::RequiredMethod(_) => {}\n         }\n@@ -1791,86 +1789,17 @@ enum CreateTypeParametersForAssociatedTypesFlag {\n     CreateTypeParametersForAssociatedTypes,\n }\n \n-fn ensure_associated_types<'tcx,AC>(this: &AC, trait_id: ast::DefId)\n-                                    where AC: AstConv<'tcx> {\n-    if this.tcx().trait_associated_types.borrow().contains_key(&trait_id) {\n-        return\n-    }\n-\n-    if trait_id.krate == ast::LOCAL_CRATE {\n-        match this.tcx().map.find(trait_id.node) {\n-            Some(ast_map::NodeItem(item)) => {\n-                match item.node {\n-                    ast::ItemTrait(_, _, _, ref trait_items) => {\n-                        let mut result = Vec::new();\n-                        let mut index = 0;\n-                        for trait_item in trait_items.iter() {\n-                            match *trait_item {\n-                                ast::RequiredMethod(_) |\n-                                ast::ProvidedMethod(_) => {}\n-                                ast::TypeTraitItem(ref associated_type) => {\n-                                    let info = ty::AssociatedTypeInfo {\n-                                        def_id: local_def(associated_type.id),\n-                                        index: index,\n-                                        name: associated_type.ident.name,\n-                                    };\n-                                    result.push(info);\n-                                    index += 1;\n-                                }\n-                            }\n-                        }\n-                        this.tcx()\n-                            .trait_associated_types\n-                            .borrow_mut()\n-                            .insert(trait_id, Rc::new(result));\n-                        return\n-                    }\n-                    _ => {\n-                        this.tcx().sess.bug(\"ensure_associated_types() \\\n-                                             called on non-trait\")\n-                    }\n-                }\n-            }\n-            _ => {\n-                this.tcx().sess.bug(\"ensure_associated_types() called on \\\n-                                     non-trait\")\n-            }\n-        }\n-\n-    }\n-\n-    // Cross-crate case.\n-    let mut result = Vec::new();\n-    let mut index = 0;\n-    let trait_items = ty::trait_items(this.tcx(), trait_id);\n-    for trait_item in trait_items.iter() {\n-        match *trait_item {\n-            ty::MethodTraitItem(_) => {}\n-            ty::TypeTraitItem(ref associated_type) => {\n-                let info = ty::AssociatedTypeInfo {\n-                    def_id: associated_type.def_id,\n-                    index: index,\n-                    name: associated_type.name\n-                };\n-                result.push(info);\n-                index += 1;\n-            }\n-        }\n-    }\n-    this.tcx().trait_associated_types.borrow_mut().insert(trait_id,\n-                                                          Rc::new(result));\n-}\n-\n fn ty_generics<'tcx,AC>(this: &AC,\n                         space: subst::ParamSpace,\n                         lifetime_defs: &[ast::LifetimeDef],\n                         types: &[ast::TyParam],\n                         base_generics: ty::Generics,\n                         where_clause: &ast::WhereClause,\n-                        create_type_parameters_for_associated_types:\n+                        create_type_parameters_for_associated_types_flag:\n                         CreateTypeParametersForAssociatedTypesFlag)\n                         -> ty::Generics\n-                        where AC: AstConv<'tcx> {\n+                        where AC: AstConv<'tcx>\n+{\n     let mut result = base_generics;\n \n     for (i, l) in lifetime_defs.iter().enumerate() {\n@@ -1891,62 +1820,11 @@ fn ty_generics<'tcx,AC>(this: &AC,\n     // First, create the virtual type parameters for associated types if\n     // necessary.\n     let mut associated_types_generics = ty::Generics::empty();\n-    match create_type_parameters_for_associated_types {\n+    match create_type_parameters_for_associated_types_flag {\n         DontCreateTypeParametersForAssociatedTypes => {}\n         CreateTypeParametersForAssociatedTypes => {\n-            let mut index = 0;\n-            for param in types.iter() {\n-                for bound in param.bounds.iter() {\n-                    match *bound {\n-                        ast::TraitTyParamBound(ref trait_bound) => {\n-                            match lookup_def_tcx(this.tcx(),\n-                                                 trait_bound.path.span,\n-                                                 trait_bound.ref_id) {\n-                                def::DefTrait(trait_did) => {\n-                                    ensure_associated_types(this, trait_did);\n-                                    let associated_types =\n-                                        ty::associated_types_for_trait(\n-                                            this.tcx(),\n-                                            trait_did);\n-                                    for associated_type_info in\n-                                            associated_types.iter() {\n-                                        let associated_type_trait_item =\n-                                            ty::impl_or_trait_item(\n-                                                this.tcx(),\n-                                                associated_type_info.def_id);\n-                                        let def = ty::TypeParameterDef {\n-                                            name: associated_type_trait_item.name(),\n-                                            def_id: associated_type_info.def_id,\n-                                            space: space,\n-                                            index: types.len() + index,\n-                                            bounds: ty::ParamBounds {\n-                                                builtin_bounds:\n-                                                ty::empty_builtin_bounds(),\n-                                                trait_bounds: Vec::new(),\n-                                                region_bounds: Vec::new(),\n-                                            },\n-                                            associated_with: {\n-                                                Some(local_def(param.id))\n-                                            },\n-                                            default: None,\n-                                        };\n-                                        associated_types_generics.types\n-                                                                 .push(space,\n-                                                                       def);\n-                                        index += 1;\n-                                    }\n-                                }\n-                                _ => {\n-                                    this.tcx().sess.span_bug(trait_bound.path\n-                                                                        .span,\n-                                                             \"not a trait?!\")\n-                                }\n-                            }\n-                        }\n-                        _ => {}\n-                    }\n-                }\n-            }\n+            create_type_parameters_for_associated_types(this, space, types,\n+                                                        &mut associated_types_generics);\n         }\n     }\n \n@@ -1960,7 +1838,8 @@ fn ty_generics<'tcx,AC>(this: &AC,\n                                                    space,\n                                                    param,\n                                                    i,\n-                                                   where_clause);\n+                                                   where_clause,\n+                                                   None);\n         debug!(\"ty_generics: def for type param: {}, {}\",\n                def.repr(this.tcx()),\n                space);\n@@ -1981,62 +1860,140 @@ fn ty_generics<'tcx,AC>(this: &AC,\n \n     return result;\n \n-    fn get_or_create_type_parameter_def<'tcx,AC>(\n-                                        this: &AC,\n-                                        space: subst::ParamSpace,\n-                                        param: &ast::TyParam,\n-                                        index: uint,\n-                                        where_clause: &ast::WhereClause)\n-                                        -> ty::TypeParameterDef\n-                                        where AC: AstConv<'tcx> {\n-        match this.tcx().ty_param_defs.borrow().find(&param.id) {\n-            Some(d) => { return (*d).clone(); }\n-            None => { }\n+    fn create_type_parameters_for_associated_types<'tcx,AC>(\n+        this: &AC,\n+        space: subst::ParamSpace,\n+        types: &[ast::TyParam],\n+        associated_types_generics: &mut ty::Generics)\n+        where AC: AstConv<'tcx>\n+    {\n+        // The idea here is roughly as follows. We start with\n+        // an item that is paramerized by various type parameters\n+        // with bounds:\n+        //\n+        //    fn foo<T:Iterator>(t: T) { ... }\n+        //\n+        // The traits in those bounds declare associated types:\n+        //\n+        //    trait Iterator { type Elem; ... }\n+        //\n+        // And we rewrite the original function so that every associated\n+        // type is bound to some fresh type parameter:\n+        //\n+        //    fn foo<A,T:Iterator<Elem=A>>(t: T) { ... }\n+\n+        // Number of synthetic type parameters created thus far\n+        let mut index = 0;\n+\n+        // Iterate over the each type parameter `T` (from the example)\n+        for param in types.iter() {\n+            // Iterate over the bound `Iterator`\n+            for bound in param.bounds.iter() {\n+                // In the above example, `ast_trait_ref` is `Iterator`.\n+                let ast_trait_ref = match *bound {\n+                    ast::TraitTyParamBound(ref r) => r,\n+                    ast::UnboxedFnTyParamBound(..) => { continue; }\n+                    ast::RegionTyParamBound(..) => { continue; }\n+                };\n+\n+                let trait_def_id =\n+                    match lookup_def_tcx(this.tcx(),\n+                                         ast_trait_ref.path.span,\n+                                         ast_trait_ref.ref_id) {\n+                        def::DefTrait(trait_def_id) => trait_def_id,\n+                        _ => {\n+                            this.tcx().sess.span_bug(ast_trait_ref.path.span,\n+                                                     \"not a trait?!\")\n+                        }\n+                    };\n+\n+                // trait_def_id is def-id of `Iterator`\n+                let trait_def = ty::lookup_trait_def(this.tcx(), trait_def_id);\n+                let associated_type_defs = trait_def.generics.types.get_slice(subst::AssocSpace);\n+\n+                // Iterate over each associated type `Elem`\n+                for associated_type_def in associated_type_defs.iter() {\n+                    // Create the fresh type parameter `A`\n+                    let def = ty::TypeParameterDef {\n+                        name: associated_type_def.name,\n+                        def_id: associated_type_def.def_id,\n+                        space: space,\n+                        index: types.len() + index,\n+                        bounds: ty::ParamBounds {\n+                            builtin_bounds: associated_type_def.bounds.builtin_bounds,\n+\n+                            // FIXME(#18178) -- we should add the other bounds, but\n+                            // that requires subst and more logic\n+                            trait_bounds: Vec::new(),\n+                            region_bounds: Vec::new(),\n+                        },\n+                        associated_with: Some(local_def(param.id)),\n+                        default: None,\n+                    };\n+                    associated_types_generics.types.push(space, def);\n+                    index += 1;\n+                }\n+            }\n         }\n+    }\n+}\n \n-        let param_ty = ty::ParamTy::new(space, index, local_def(param.id));\n-        let bounds = compute_bounds(this,\n-                                    param.ident.name,\n-                                    param_ty,\n-                                    param.bounds.as_slice(),\n-                                    &param.unbound,\n-                                    param.span,\n-                                    where_clause);\n-        let default = match param.default {\n-            None => None,\n-            Some(ref path) => {\n-                let ty = ast_ty_to_ty(this, &ExplicitRscope, &**path);\n-                let cur_idx = index;\n-\n-                ty::walk_ty(ty, |t| {\n-                    match ty::get(t).sty {\n-                        ty::ty_param(p) => if p.idx > cur_idx {\n+fn get_or_create_type_parameter_def<'tcx,AC>(this: &AC,\n+                                             space: subst::ParamSpace,\n+                                             param: &ast::TyParam,\n+                                             index: uint,\n+                                             where_clause: &ast::WhereClause,\n+                                             associated_with: Option<ast::DefId>)\n+                                             -> ty::TypeParameterDef\n+    where AC: AstConv<'tcx>\n+{\n+    match this.tcx().ty_param_defs.borrow().find(&param.id) {\n+        Some(d) => { return (*d).clone(); }\n+        None => { }\n+    }\n+\n+    let param_ty = ty::ParamTy::new(space, index, local_def(param.id));\n+    let bounds = compute_bounds(this,\n+                                param.ident.name,\n+                                param_ty,\n+                                param.bounds.as_slice(),\n+                                &param.unbound,\n+                                param.span,\n+                                where_clause);\n+    let default = match param.default {\n+        None => None,\n+        Some(ref path) => {\n+            let ty = ast_ty_to_ty(this, &ExplicitRscope, &**path);\n+            let cur_idx = index;\n+\n+            ty::walk_ty(ty, |t| {\n+                match ty::get(t).sty {\n+                    ty::ty_param(p) => if p.idx > cur_idx {\n                         span_err!(this.tcx().sess, path.span, E0128,\n                                   \"type parameters with a default cannot use \\\n                                    forward declared identifiers\");\n                         },\n                         _ => {}\n                     }\n-                });\n+            });\n \n-                Some(ty)\n-            }\n-        };\n+            Some(ty)\n+        }\n+    };\n \n-        let def = ty::TypeParameterDef {\n-            space: space,\n-            index: index,\n-            name: param.ident.name,\n-            def_id: local_def(param.id),\n-            associated_with: None,\n-            bounds: bounds,\n-            default: default\n-        };\n+    let def = ty::TypeParameterDef {\n+        space: space,\n+        index: index,\n+        name: param.ident.name,\n+        def_id: local_def(param.id),\n+        associated_with: associated_with,\n+        bounds: bounds,\n+        default: default\n+    };\n \n-        this.tcx().ty_param_defs.borrow_mut().insert(param.id, def.clone());\n+    this.tcx().ty_param_defs.borrow_mut().insert(param.id, def.clone());\n \n-        def\n-    }\n+    def\n }\n \n fn compute_bounds<'tcx,AC>(this: &AC,"}, {"sha": "55c3c23685357e31e0ecc54e2fbd1092004c4cfc", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -774,10 +774,15 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         assert!(generics.regions.len(subst::FnSpace) == 0);\n \n         let type_parameter_count = generics.types.len(subst::TypeSpace);\n+        let type_parameters = self.next_ty_vars(type_parameter_count);\n+\n         let region_param_defs = generics.regions.get_slice(subst::TypeSpace);\n         let regions = self.region_vars_for_defs(span, region_param_defs);\n-        let type_parameters = self.next_ty_vars(type_parameter_count);\n-        subst::Substs::new_trait(type_parameters, regions, self_ty)\n+\n+        let assoc_type_parameter_count = generics.types.len(subst::AssocSpace);\n+        let assoc_type_parameters = self.next_ty_vars(assoc_type_parameter_count);\n+\n+        subst::Substs::new_trait(type_parameters, regions, assoc_type_parameters, self_ty)\n     }\n \n     pub fn fresh_bound_region(&self, binder_id: ast::NodeId) -> ty::Region {\n@@ -791,7 +796,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     pub fn ty_to_string(&self, t: ty::t) -> String {\n         ty_to_string(self.tcx,\n-                  self.resolve_type_vars_if_possible(t))\n+                     self.resolve_type_vars_if_possible(t))\n     }\n \n     pub fn tys_to_string(&self, ts: &[ty::t]) -> String {"}, {"sha": "fb80b9f30f5df8a3f48b1b8c8f50f4ba432cb227", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 46, "deletions": 20, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -425,7 +425,13 @@ pub fn ty_to_string(cx: &ctxt, typ: t) -> String {\n         }\n         ty_infer(infer_ty) => infer_ty_to_string(cx, infer_ty),\n         ty_err => \"[type error]\".to_string(),\n-        ty_param(ref param_ty) => param_ty.repr(cx),\n+        ty_param(ref param_ty) => {\n+            if cx.sess.verbose() {\n+                param_ty.repr(cx)\n+            } else {\n+                param_ty.user_string(cx)\n+            }\n+        }\n         ty_enum(did, ref substs) | ty_struct(did, ref substs) => {\n             let base = ty::item_path_str(cx, did);\n             let generics = ty::lookup_item_type(cx, did).generics;\n@@ -481,6 +487,17 @@ pub fn parameterized(cx: &ctxt,\n                      generics: &ty::Generics)\n                      -> String\n {\n+    if cx.sess.verbose() {\n+        if substs.is_noop() {\n+            return format!(\"{}\", base);\n+        } else {\n+            return format!(\"{}<{},{}>\",\n+                           base,\n+                           substs.regions.repr(cx),\n+                           substs.types.repr(cx));\n+        }\n+    }\n+\n     let mut strs = Vec::new();\n \n     match substs.regions {\n@@ -505,7 +522,7 @@ pub fn parameterized(cx: &ctxt,\n     let tps = substs.types.get_slice(subst::TypeSpace);\n     let ty_params = generics.types.get_slice(subst::TypeSpace);\n     let has_defaults = ty_params.last().map_or(false, |def| def.default.is_some());\n-    let num_defaults = if has_defaults && !cx.sess.verbose() {\n+    let num_defaults = if has_defaults {\n         ty_params.iter().zip(tps.iter()).rev().take_while(|&(def, &actual)| {\n             match def.default {\n                 Some(default) => default.subst(cx, substs) == actual,\n@@ -520,18 +537,6 @@ pub fn parameterized(cx: &ctxt,\n         strs.push(ty_to_string(cx, *t))\n     }\n \n-    if cx.sess.verbose() {\n-        for t in substs.types.get_slice(subst::SelfSpace).iter() {\n-            strs.push(format!(\"self {}\", t.repr(cx)));\n-        }\n-\n-        // generally there shouldn't be any substs in the fn param\n-        // space, but in verbose mode, print them out.\n-        for t in substs.types.get_slice(subst::FnSpace).iter() {\n-            strs.push(format!(\"fn {}\", t.repr(cx)));\n-        }\n-    }\n-\n     if strs.len() > 0u {\n         format!(\"{}<{}>\", base, strs.connect(\", \"))\n     } else {\n@@ -668,10 +673,11 @@ impl Repr for subst::Substs {\n \n impl<T:Repr> Repr for subst::VecPerParamSpace<T> {\n     fn repr(&self, tcx: &ctxt) -> String {\n-        format!(\"[{};{};{}]\",\n-                       self.get_slice(subst::TypeSpace).repr(tcx),\n-                       self.get_slice(subst::SelfSpace).repr(tcx),\n-                       self.get_slice(subst::FnSpace).repr(tcx))\n+        format!(\"[{};{};{};{}]\",\n+                self.get_slice(subst::TypeSpace).repr(tcx),\n+                self.get_slice(subst::SelfSpace).repr(tcx),\n+                self.get_slice(subst::AssocSpace).repr(tcx),\n+                self.get_slice(subst::FnSpace).repr(tcx))\n     }\n }\n \n@@ -726,7 +732,7 @@ impl Repr for ty::TraitRef {\n     fn repr(&self, tcx: &ctxt) -> String {\n         let base = ty::item_path_str(tcx, self.def_id);\n         let trait_def = ty::lookup_trait_def(tcx, self.def_id);\n-        format!(\"<{} as {}>\",\n+        format!(\"<{} : {}>\",\n                 self.substs.self_ty().repr(tcx),\n                 parameterized(tcx, base.as_slice(), &self.substs, &trait_def.generics))\n     }\n@@ -741,6 +747,19 @@ impl Repr for ty::TraitDef {\n     }\n }\n \n+impl Repr for ast::TraitItem {\n+    fn repr(&self, _tcx: &ctxt) -> String {\n+        match *self {\n+            ast::RequiredMethod(ref data) => format!(\"RequiredMethod({}, id={})\",\n+                                                     data.ident, data.id),\n+            ast::ProvidedMethod(ref data) => format!(\"ProvidedMethod(id={})\",\n+                                                     data.id),\n+            ast::TypeTraitItem(ref data) => format!(\"TypeTraitItem({}, id={})\",\n+                                                     data.ty_param.ident, data.ty_param.id),\n+        }\n+    }\n+}\n+\n impl Repr for ast::Expr {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         format!(\"expr({}: {})\", self.id, pprust::expr_to_string(self))\n@@ -759,6 +778,12 @@ impl UserString for ast::Path {\n     }\n }\n \n+impl Repr for ast::Ty {\n+    fn repr(&self, _tcx: &ctxt) -> String {\n+        format!(\"type({})\", pprust::ty_to_string(self))\n+    }\n+}\n+\n impl Repr for ast::Item {\n     fn repr(&self, tcx: &ctxt) -> String {\n         format!(\"item({})\", tcx.map.node_to_string(self.id))\n@@ -1262,7 +1287,8 @@ impl UserString for ParamTy {\n \n impl Repr for ParamTy {\n     fn repr(&self, tcx: &ctxt) -> String {\n-        self.user_string(tcx)\n+        let ident = self.user_string(tcx);\n+        format!(\"{}/{}.{}\", ident, self.space, self.idx)\n     }\n }\n "}, {"sha": "48e1e590058bb16dbac9522005b37e29d3f12fed", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -547,7 +547,7 @@ extern {\n     pub fn LLVMIsFunctionVarArg(FunctionTy: TypeRef) -> Bool;\n     pub fn LLVMGetReturnType(FunctionTy: TypeRef) -> TypeRef;\n     pub fn LLVMCountParamTypes(FunctionTy: TypeRef) -> c_uint;\n-    pub fn LLVMGetParamTypes(FunctionTy: TypeRef, Dest: *const TypeRef);\n+    pub fn LLVMGetParamTypes(FunctionTy: TypeRef, Dest: *mut TypeRef);\n \n     /* Operations on struct types */\n     pub fn LLVMStructTypeInContext(C: ContextRef,\n@@ -2195,4 +2195,3 @@ pub unsafe fn static_link_hack_this_sucks() {\n // Works to the above fix for #15460 to ensure LLVM dependencies that\n // are only used by rustllvm don't get stripped by the linker.\n mod llvmdeps;\n-"}, {"sha": "f96b3916f06dee31cdf5a2f6ae16b2f4a680ac8f", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -2203,12 +2203,12 @@ impl Clean<Stability> for attr::Stability {\n impl Clean<Item> for ast::AssociatedType {\n     fn clean(&self, cx: &DocContext) -> Item {\n         Item {\n-            source: self.span.clean(cx),\n-            name: Some(self.ident.clean(cx)),\n+            source: self.ty_param.span.clean(cx),\n+            name: Some(self.ty_param.ident.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             inner: AssociatedTypeItem,\n             visibility: None,\n-            def_id: ast_util::local_def(self.id),\n+            def_id: ast_util::local_def(self.ty_param.id),\n             stability: None,\n         }\n     }"}, {"sha": "e0d436f5e0eb60bc82b56b603a1371bcf12df676", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 39, "deletions": 17, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -203,6 +203,7 @@ use std::num::{FPNaN, FPInfinite};\n use std::str::ScalarValue;\n use std::string;\n use std::vec::Vec;\n+use std::ops;\n \n use Encodable;\n \n@@ -889,17 +890,17 @@ impl Json {\n \n      /// If the Json value is an Object, returns the value associated with the provided key.\n     /// Otherwise, returns None.\n-    pub fn find<'a>(&'a self, key: &string::String) -> Option<&'a Json>{\n+    pub fn find<'a>(&'a self, key: &str) -> Option<&'a Json>{\n         match self {\n-            &Object(ref map) => map.find(key),\n+            &Object(ref map) => map.find_with(|s| key.cmp(&s.as_slice())),\n             _ => None\n         }\n     }\n \n     /// Attempts to get a nested Json Object for each key in `keys`.\n     /// If any key is found not to exist, find_path will return None.\n     /// Otherwise, it will return the Json value associated with the final key.\n-    pub fn find_path<'a>(&'a self, keys: &[&string::String]) -> Option<&'a Json>{\n+    pub fn find_path<'a>(&'a self, keys: &[&str]) -> Option<&'a Json>{\n         let mut target = self;\n         for key in keys.iter() {\n             match target.find(*key) {\n@@ -913,20 +914,19 @@ impl Json {\n     /// If the Json value is an Object, performs a depth-first search until\n     /// a value associated with the provided key is found. If no value is found\n     /// or the Json value is not an Object, returns None.\n-    pub fn search<'a>(&'a self, key: &string::String) -> Option<&'a Json> {\n+    pub fn search<'a>(&'a self, key: &str) -> Option<&'a Json> {\n         match self {\n             &Object(ref map) => {\n-                match map.find(key) {\n+                match map.find_with(|s| key.cmp(&s.as_slice())) {\n                     Some(json_value) => Some(json_value),\n                     None => {\n-                        let mut value : Option<&'a Json> = None;\n                         for (_, v) in map.iter() {\n-                            value = v.search(key);\n-                            if value.is_some() {\n-                                break;\n+                            match v.search(key) {\n+                                x if x.is_some() => return x,\n+                                _ => ()\n                             }\n                         }\n-                        value\n+                        None\n                     }\n                 }\n             },\n@@ -1068,6 +1068,21 @@ impl Json {\n     }\n }\n \n+impl<'a> ops::Index<&'a str, Json>  for Json {\n+    fn index<'a>(&'a self, idx: & &str) -> &'a Json {\n+        self.find(*idx).unwrap()\n+    }\n+}\n+\n+impl ops::Index<uint, Json> for Json {\n+    fn index<'a>(&'a self, idx: &uint) -> &'a Json {\n+        match self {\n+            &List(ref v) => v.index(idx),\n+            _ => panic!(\"can only index Json with uint if it is a list\")\n+        }\n+    }\n+}\n+\n /// The output of the streaming parser.\n #[deriving(PartialEq, Clone, Show)]\n pub enum JsonEvent {\n@@ -3089,26 +3104,33 @@ mod tests {\n     #[test]\n     fn test_find(){\n         let json_value = from_str(\"{\\\"dog\\\" : \\\"cat\\\"}\").unwrap();\n-        let found_str = json_value.find(&\"dog\".to_string());\n-        assert!(found_str.is_some() && found_str.unwrap().as_string().unwrap() == \"cat\");\n+        let found_str = json_value.find(\"dog\");\n+        assert!(found_str.unwrap().as_string().unwrap() == \"cat\");\n     }\n \n     #[test]\n     fn test_find_path(){\n         let json_value = from_str(\"{\\\"dog\\\":{\\\"cat\\\": {\\\"mouse\\\" : \\\"cheese\\\"}}}\").unwrap();\n-        let found_str = json_value.find_path(&[&\"dog\".to_string(),\n-                                             &\"cat\".to_string(), &\"mouse\".to_string()]);\n-        assert!(found_str.is_some() && found_str.unwrap().as_string().unwrap() == \"cheese\");\n+        let found_str = json_value.find_path(&[\"dog\", \"cat\", \"mouse\"]);\n+        assert!(found_str.unwrap().as_string().unwrap() == \"cheese\");\n     }\n \n     #[test]\n     fn test_search(){\n         let json_value = from_str(\"{\\\"dog\\\":{\\\"cat\\\": {\\\"mouse\\\" : \\\"cheese\\\"}}}\").unwrap();\n-        let found_str = json_value.search(&\"mouse\".to_string()).and_then(|j| j.as_string());\n-        assert!(found_str.is_some());\n+        let found_str = json_value.search(\"mouse\").and_then(|j| j.as_string());\n         assert!(found_str.unwrap() == \"cheese\");\n     }\n \n+    #[test]\n+    fn test_index(){\n+        let json_value = from_str(\"{\\\"animals\\\":[\\\"dog\\\",\\\"cat\\\",\\\"mouse\\\"]}\").unwrap();\n+        let ref list = json_value[\"animals\"];\n+        assert_eq!(list[0].as_string().unwrap(), \"dog\");\n+        assert_eq!(list[1].as_string().unwrap(), \"cat\");\n+        assert_eq!(list[2].as_string().unwrap(), \"mouse\");\n+    }\n+\n     #[test]\n     fn test_is_object(){\n         let json_value = from_str(\"{}\").unwrap();"}, {"sha": "b9758e11bc784e95799135f0b6acb4db7cb4d718", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -10,7 +10,6 @@\n //\n // ignore-lexer-test FIXME #15883\n \n-use clone::Clone;\n use cmp::{Eq, Equiv, PartialEq};\n use core::kinds::Sized;\n use default::Default;"}, {"sha": "493e1b559d7b7d823c11eb186f8c831d6a522c5f", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -26,7 +26,6 @@ use rt::rtio;\n use c_str::CString;\n use collections::HashMap;\n use hash::Hash;\n-use clone::Clone;\n #[cfg(windows)]\n use std::hash::sip::SipState;\n "}, {"sha": "63c3956ef24121cee057eed930aea25036bda765", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 15, "deletions": 42, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -333,35 +333,10 @@ pub fn to_str_exp_digits(num: f32, dig: uint, upper: bool) -> String {\n     r\n }\n \n-/// Convert a string in base 16 to a float.\n-/// Accepts an optional binary exponent.\n-///\n-/// This function accepts strings such as\n-///\n-/// * 'a4.fe'\n-/// * '+a4.fe', equivalent to 'a4.fe'\n-/// * '-a4.fe'\n-/// * '2b.aP128', or equivalently, '2b.ap128'\n-/// * '2b.aP-128'\n-/// * '.' (understood as 0)\n-/// * 'c.'\n-/// * '.c', or, equivalently,  '0.c'\n-/// * '+inf', 'inf', '-inf', 'NaN'\n-///\n-/// Leading and trailing whitespace represent an error.\n-///\n-/// # Arguments\n-///\n-/// * num - A string\n-///\n-/// # Return value\n-///\n-/// `None` if the string did not represent a valid number.  Otherwise,\n-/// `Some(n)` where `n` is the floating-point number represented by `[num]`.\n #[inline]\n-pub fn from_str_hex(num: &str) -> Option<f32> {\n-    strconv::from_str_common(num, 16u, true, true, true,\n-                             strconv::ExpBin, false, false)\n+#[deprecated=\"Use `FromStrRadix::from_str_radix(src, 16)`\"]\n+pub fn from_str_hex(src: &str) -> Option<f32> {\n+    strconv::from_str_radix_float(src, 16)\n }\n \n impl FromStr for f32 {\n@@ -384,16 +359,15 @@ impl FromStr for f32 {\n     ///\n     /// # Arguments\n     ///\n-    /// * num - A string\n+    /// * src - A string\n     ///\n     /// # Return value\n     ///\n     /// `None` if the string did not represent a valid number.  Otherwise,\n-    /// `Some(n)` where `n` is the floating-point number represented by `num`.\n+    /// `Some(n)` where `n` is the floating-point number represented by `src`.\n     #[inline]\n-    fn from_str(val: &str) -> Option<f32> {\n-        strconv::from_str_common(val, 10u, true, true, true,\n-                                 strconv::ExpDec, false, false)\n+    fn from_str(src: &str) -> Option<f32> {\n+        strconv::from_str_radix_float(src, 10u)\n     }\n }\n \n@@ -408,17 +382,16 @@ impl num::FromStrRadix for f32 {\n     ///\n     /// # Arguments\n     ///\n-    /// * num - A string\n+    /// * src - A string\n     /// * radix - The base to use. Must lie in the range [2 .. 36]\n     ///\n     /// # Return value\n     ///\n     /// `None` if the string did not represent a valid number. Otherwise,\n-    /// `Some(n)` where `n` is the floating-point number represented by `num`.\n+    /// `Some(n)` where `n` is the floating-point number represented by `src`.\n     #[inline]\n-    fn from_str_radix(val: &str, rdx: uint) -> Option<f32> {\n-        strconv::from_str_common(val, rdx, true, true, false,\n-                                 strconv::ExpNone, false, false)\n+    fn from_str_radix(src: &str, radix: uint) -> Option<f32> {\n+        strconv::from_str_radix_float(src, radix)\n     }\n }\n \n@@ -710,8 +683,8 @@ mod tests {\n     fn test_ldexp() {\n         // We have to use from_str until base-2 exponents\n         // are supported in floating-point literals\n-        let f1: f32 = from_str_hex(\"1p-123\").unwrap();\n-        let f2: f32 = from_str_hex(\"1p-111\").unwrap();\n+        let f1: f32 = FromStrRadix::from_str_radix(\"1p-123\", 16).unwrap();\n+        let f2: f32 = FromStrRadix::from_str_radix(\"1p-111\", 16).unwrap();\n         assert_eq!(FloatMath::ldexp(1f32, -123), f1);\n         assert_eq!(FloatMath::ldexp(1f32, -111), f2);\n \n@@ -730,8 +703,8 @@ mod tests {\n     fn test_frexp() {\n         // We have to use from_str until base-2 exponents\n         // are supported in floating-point literals\n-        let f1: f32 = from_str_hex(\"1p-123\").unwrap();\n-        let f2: f32 = from_str_hex(\"1p-111\").unwrap();\n+        let f1: f32 = FromStrRadix::from_str_radix(\"1p-123\", 16).unwrap();\n+        let f2: f32 = FromStrRadix::from_str_radix(\"1p-111\", 16).unwrap();\n         let (x1, exp1) = f1.frexp();\n         let (x2, exp2) = f2.frexp();\n         assert_eq!((x1, exp1), (0.5f32, -122));"}, {"sha": "6e8e92eb91d03ce1080490d9f60618d3a203ba12", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 17, "deletions": 49, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -341,92 +341,60 @@ pub fn to_str_exp_digits(num: f64, dig: uint, upper: bool) -> String {\n     r\n }\n \n-/// Convert a string in base 16 to a float.\n-/// Accepts an optional binary exponent.\n-///\n-/// This function accepts strings such as\n-///\n-/// * 'a4.fe'\n-/// * '+a4.fe', equivalent to 'a4.fe'\n-/// * '-a4.fe'\n-/// * '2b.aP128', or equivalently, '2b.ap128'\n-/// * '2b.aP-128'\n-/// * '.' (understood as 0)\n-/// * 'c.'\n-/// * '.c', or, equivalently,  '0.c'\n-/// * '+inf', 'inf', '-inf', 'NaN'\n-///\n-/// Leading and trailing whitespace represent an error.\n-///\n-/// # Arguments\n-///\n-/// * num - A string\n-///\n-/// # Return value\n-///\n-/// `None` if the string did not represent a valid number.  Otherwise,\n-/// `Some(n)` where `n` is the floating-point number represented by `[num]`.\n #[inline]\n-pub fn from_str_hex(num: &str) -> Option<f64> {\n-    strconv::from_str_common(num, 16u, true, true, true,\n-                             strconv::ExpBin, false, false)\n+#[deprecated=\"Use `FromStrRadix::from_str_radix(src, 16)`\"]\n+pub fn from_str_hex(src: &str) -> Option<f64> {\n+    strconv::from_str_radix_float(src, 16)\n }\n \n impl FromStr for f64 {\n     /// Convert a string in base 10 to a float.\n     /// Accepts an optional decimal exponent.\n     ///\n-    /// This function accepts strings such as\n+    /// This function accepts strings such as:\n     ///\n     /// * '3.14'\n-    /// * '+3.14', equivalent to '3.14'\n     /// * '-3.14'\n     /// * '2.5E10', or equivalently, '2.5e10'\n     /// * '2.5E-10'\n     /// * '.' (understood as 0)\n     /// * '5.'\n     /// * '.5', or, equivalently,  '0.5'\n-    /// * '+inf', 'inf', '-inf', 'NaN'\n+    /// * inf', '-inf', 'NaN'\n     ///\n     /// Leading and trailing whitespace represent an error.\n     ///\n     /// # Arguments\n     ///\n-    /// * num - A string\n+    /// * src - A string\n     ///\n     /// # Return value\n     ///\n     /// `none` if the string did not represent a valid number.  Otherwise,\n-    /// `Some(n)` where `n` is the floating-point number represented by `num`.\n+    /// `Some(n)` where `n` is the floating-point number represented by `src`.\n     #[inline]\n-    fn from_str(val: &str) -> Option<f64> {\n-        strconv::from_str_common(val, 10u, true, true, true,\n-                                 strconv::ExpDec, false, false)\n+    fn from_str(src: &str) -> Option<f64> {\n+        strconv::from_str_radix_float(src, 10u)\n     }\n }\n \n impl num::FromStrRadix for f64 {\n     /// Convert a string in a given base to a float.\n     ///\n-    /// Due to possible conflicts, this function does **not** accept\n-    /// the special values `inf`, `-inf`, `+inf` and `NaN`, **nor**\n-    /// does it recognize exponents of any kind.\n-    ///\n     /// Leading and trailing whitespace represent an error.\n     ///\n     /// # Arguments\n     ///\n-    /// * num - A string\n+    /// * src - A string\n     /// * radix - The base to use. Must lie in the range [2 .. 36]\n     ///\n     /// # Return value\n     ///\n     /// `None` if the string did not represent a valid number. Otherwise,\n-    /// `Some(n)` where `n` is the floating-point number represented by `num`.\n+    /// `Some(n)` where `n` is the floating-point number represented by `src`.\n     #[inline]\n-    fn from_str_radix(val: &str, rdx: uint) -> Option<f64> {\n-        strconv::from_str_common(val, rdx, true, true, false,\n-                                 strconv::ExpNone, false, false)\n+    fn from_str_radix(src: &str, radix: uint) -> Option<f64> {\n+        strconv::from_str_radix_float(src, radix)\n     }\n }\n \n@@ -712,8 +680,8 @@ mod tests {\n     fn test_ldexp() {\n         // We have to use from_str until base-2 exponents\n         // are supported in floating-point literals\n-        let f1: f64 = from_str_hex(\"1p-123\").unwrap();\n-        let f2: f64 = from_str_hex(\"1p-111\").unwrap();\n+        let f1: f64 = FromStrRadix::from_str_radix(\"1p-123\", 16).unwrap();\n+        let f2: f64 = FromStrRadix::from_str_radix(\"1p-111\", 16).unwrap();\n         assert_eq!(FloatMath::ldexp(1f64, -123), f1);\n         assert_eq!(FloatMath::ldexp(1f64, -111), f2);\n \n@@ -732,8 +700,8 @@ mod tests {\n     fn test_frexp() {\n         // We have to use from_str until base-2 exponents\n         // are supported in floating-point literals\n-        let f1: f64 = from_str_hex(\"1p-123\").unwrap();\n-        let f2: f64 = from_str_hex(\"1p-111\").unwrap();\n+        let f1: f64 = FromStrRadix::from_str_radix(\"1p-123\", 16).unwrap();\n+        let f2: f64 = FromStrRadix::from_str_radix(\"1p-111\", 16).unwrap();\n         let (x1, exp1) = f1.frexp();\n         let (x2, exp2) = f2.frexp();\n         assert_eq!((x1, exp1), (0.5f64, -122));"}, {"sha": "9ae146c840ae884b96e31139013061888bed6a54", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 35, "deletions": 59, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -14,50 +14,26 @@\n \n macro_rules! int_module (($T:ty) => (\n \n-// String conversion functions and impl str -> num\n-\n-/// Parse a byte slice as a number in the given base\n-///\n-/// Yields an `Option` because `buf` may or may not actually be parseable.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// let num = std::i64::parse_bytes([49,50,51,52,53,54,55,56,57], 10);\n-/// assert!(num == Some(123456789));\n-/// ```\n-#[inline]\n-#[experimental = \"might need to return Result\"]\n-pub fn parse_bytes(buf: &[u8], radix: uint) -> Option<$T> {\n-    strconv::from_str_bytes_common(buf, radix, true, false, false,\n-                               strconv::ExpNone, false, false)\n-}\n-\n #[experimental = \"might need to return Result\"]\n impl FromStr for $T {\n     #[inline]\n     fn from_str(s: &str) -> Option<$T> {\n-        strconv::from_str_common(s, 10u, true, false, false,\n-                             strconv::ExpNone, false, false)\n+        strconv::from_str_radix_int(s, 10)\n     }\n }\n \n #[experimental = \"might need to return Result\"]\n impl FromStrRadix for $T {\n     #[inline]\n     fn from_str_radix(s: &str, radix: uint) -> Option<$T> {\n-        strconv::from_str_common(s, radix, true, false, false,\n-                             strconv::ExpNone, false, false)\n+        strconv::from_str_radix_int(s, radix)\n     }\n }\n \n #[cfg(test)]\n mod tests {\n     use prelude::*;\n-    use super::*;\n-\n-    use i32;\n-    use str::StrSlice;\n+    use num::FromStrRadix;\n \n     #[test]\n     fn test_from_str() {\n@@ -73,33 +49,33 @@ mod tests {\n         assert_eq!(from_str::<i32>(\"-123456789\"), Some(-123456789 as i32));\n         assert_eq!(from_str::<$T>(\"-00100\"), Some(-100 as $T));\n \n-        assert!(from_str::<$T>(\" \").is_none());\n-        assert!(from_str::<$T>(\"x\").is_none());\n+        assert_eq!(from_str::<$T>(\"\"), None);\n+        assert_eq!(from_str::<$T>(\" \"), None);\n+        assert_eq!(from_str::<$T>(\"x\"), None);\n     }\n \n     #[test]\n-    fn test_parse_bytes() {\n-        use str::StrSlice;\n-        assert_eq!(parse_bytes(\"123\".as_bytes(), 10u), Some(123 as $T));\n-        assert_eq!(parse_bytes(\"1001\".as_bytes(), 2u), Some(9 as $T));\n-        assert_eq!(parse_bytes(\"123\".as_bytes(), 8u), Some(83 as $T));\n-        assert_eq!(i32::parse_bytes(\"123\".as_bytes(), 16u), Some(291 as i32));\n-        assert_eq!(i32::parse_bytes(\"ffff\".as_bytes(), 16u), Some(65535 as i32));\n-        assert_eq!(i32::parse_bytes(\"FFFF\".as_bytes(), 16u), Some(65535 as i32));\n-        assert_eq!(parse_bytes(\"z\".as_bytes(), 36u), Some(35 as $T));\n-        assert_eq!(parse_bytes(\"Z\".as_bytes(), 36u), Some(35 as $T));\n-\n-        assert_eq!(parse_bytes(\"-123\".as_bytes(), 10u), Some(-123 as $T));\n-        assert_eq!(parse_bytes(\"-1001\".as_bytes(), 2u), Some(-9 as $T));\n-        assert_eq!(parse_bytes(\"-123\".as_bytes(), 8u), Some(-83 as $T));\n-        assert_eq!(i32::parse_bytes(\"-123\".as_bytes(), 16u), Some(-291 as i32));\n-        assert_eq!(i32::parse_bytes(\"-ffff\".as_bytes(), 16u), Some(-65535 as i32));\n-        assert_eq!(i32::parse_bytes(\"-FFFF\".as_bytes(), 16u), Some(-65535 as i32));\n-        assert_eq!(parse_bytes(\"-z\".as_bytes(), 36u), Some(-35 as $T));\n-        assert_eq!(parse_bytes(\"-Z\".as_bytes(), 36u), Some(-35 as $T));\n-\n-        assert!(parse_bytes(\"Z\".as_bytes(), 35u).is_none());\n-        assert!(parse_bytes(\"-9\".as_bytes(), 2u).is_none());\n+    fn test_from_str_radix() {\n+        assert_eq!(FromStrRadix::from_str_radix(\"123\", 10), Some(123 as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"1001\", 2), Some(9 as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"123\", 8), Some(83 as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"123\", 16), Some(291 as i32));\n+        assert_eq!(FromStrRadix::from_str_radix(\"ffff\", 16), Some(65535 as i32));\n+        assert_eq!(FromStrRadix::from_str_radix(\"FFFF\", 16), Some(65535 as i32));\n+        assert_eq!(FromStrRadix::from_str_radix(\"z\", 36), Some(35 as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"Z\", 36), Some(35 as $T));\n+\n+        assert_eq!(FromStrRadix::from_str_radix(\"-123\", 10), Some(-123 as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"-1001\", 2), Some(-9 as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"-123\", 8), Some(-83 as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"-123\", 16), Some(-291 as i32));\n+        assert_eq!(FromStrRadix::from_str_radix(\"-ffff\", 16), Some(-65535 as i32));\n+        assert_eq!(FromStrRadix::from_str_radix(\"-FFFF\", 16), Some(-65535 as i32));\n+        assert_eq!(FromStrRadix::from_str_radix(\"-z\", 36), Some(-35 as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"-Z\", 36), Some(-35 as $T));\n+\n+        assert_eq!(FromStrRadix::from_str_radix(\"Z\", 35), None::<$T>);\n+        assert_eq!(FromStrRadix::from_str_radix(\"-9\", 2), None::<$T>);\n     }\n \n     #[test]\n@@ -133,35 +109,35 @@ mod tests {\n     fn test_int_from_str_overflow() {\n         let mut i8_val: i8 = 127_i8;\n         assert_eq!(from_str::<i8>(\"127\"), Some(i8_val));\n-        assert!(from_str::<i8>(\"128\").is_none());\n+        assert_eq!(from_str::<i8>(\"128\"), None);\n \n         i8_val += 1 as i8;\n         assert_eq!(from_str::<i8>(\"-128\"), Some(i8_val));\n-        assert!(from_str::<i8>(\"-129\").is_none());\n+        assert_eq!(from_str::<i8>(\"-129\"), None);\n \n         let mut i16_val: i16 = 32_767_i16;\n         assert_eq!(from_str::<i16>(\"32767\"), Some(i16_val));\n-        assert!(from_str::<i16>(\"32768\").is_none());\n+        assert_eq!(from_str::<i16>(\"32768\"), None);\n \n         i16_val += 1 as i16;\n         assert_eq!(from_str::<i16>(\"-32768\"), Some(i16_val));\n-        assert!(from_str::<i16>(\"-32769\").is_none());\n+        assert_eq!(from_str::<i16>(\"-32769\"), None);\n \n         let mut i32_val: i32 = 2_147_483_647_i32;\n         assert_eq!(from_str::<i32>(\"2147483647\"), Some(i32_val));\n-        assert!(from_str::<i32>(\"2147483648\").is_none());\n+        assert_eq!(from_str::<i32>(\"2147483648\"), None);\n \n         i32_val += 1 as i32;\n         assert_eq!(from_str::<i32>(\"-2147483648\"), Some(i32_val));\n-        assert!(from_str::<i32>(\"-2147483649\").is_none());\n+        assert_eq!(from_str::<i32>(\"-2147483649\"), None);\n \n         let mut i64_val: i64 = 9_223_372_036_854_775_807_i64;\n         assert_eq!(from_str::<i64>(\"9223372036854775807\"), Some(i64_val));\n-        assert!(from_str::<i64>(\"9223372036854775808\").is_none());\n+        assert_eq!(from_str::<i64>(\"9223372036854775808\"), None);\n \n         i64_val += 1 as i64;\n         assert_eq!(from_str::<i64>(\"-9223372036854775808\"), Some(i64_val));\n-        assert!(from_str::<i64>(\"-9223372036854775809\").is_none());\n+        assert_eq!(from_str::<i64>(\"-9223372036854775809\"), None);\n     }\n }\n "}, {"sha": "7a02d8d77b0b1db19b9bbf8e1e6f903c7a231aba", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 186, "deletions": 346, "changes": 532, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -13,14 +13,14 @@\n #![allow(missing_docs)]\n \n use char;\n-use clone::Clone;\n-use num::{NumCast, Zero, One, cast, Int};\n-use num::{Float, FPNaN, FPInfinite, ToPrimitive};\n+use char::Char;\n+use from_str::from_str;\n+use iter::Iterator;\n use num;\n-use ops::{Add, Sub, Mul, Div, Rem, Neg};\n+use num::{Int, Bounded};\n+use num::{Float, FPNaN, FPInfinite, ToPrimitive};\n use option::{None, Option, Some};\n use slice::{ImmutableSlice, MutableSlice, CloneableVector};\n-use std::cmp::{PartialOrd, PartialEq};\n use str::StrSlice;\n use string::String;\n use vec::Vec;\n@@ -67,81 +67,6 @@ pub enum SignFormat {\n     SignAll,\n }\n \n-/// Encompasses functions used by the string converter.\n-pub trait NumStrConv {\n-    /// Returns the NaN value.\n-    fn nan()      -> Option<Self>;\n-\n-    /// Returns the infinite value.\n-    fn inf()      -> Option<Self>;\n-\n-    /// Returns the negative infinite value.\n-    fn neg_inf()  -> Option<Self>;\n-\n-    /// Returns -0.0.\n-    fn neg_zero() -> Option<Self>;\n-\n-    /// Rounds the number toward zero.\n-    fn round_to_zero(&self)   -> Self;\n-\n-    /// Returns the fractional part of the number.\n-    fn fractional_part(&self) -> Self;\n-}\n-\n-macro_rules! impl_NumStrConv_Floating (($t:ty) => (\n-    impl NumStrConv for $t {\n-        #[inline]\n-        fn nan()      -> Option<$t> { Some( 0.0 / 0.0) }\n-        #[inline]\n-        fn inf()      -> Option<$t> { Some( 1.0 / 0.0) }\n-        #[inline]\n-        fn neg_inf()  -> Option<$t> { Some(-1.0 / 0.0) }\n-        #[inline]\n-        fn neg_zero() -> Option<$t> { Some(-0.0      ) }\n-\n-        #[inline]\n-        fn round_to_zero(&self) -> $t { self.trunc() }\n-        #[inline]\n-        fn fractional_part(&self) -> $t { self.fract() }\n-    }\n-))\n-\n-macro_rules! impl_NumStrConv_Integer (($t:ty) => (\n-    impl NumStrConv for $t {\n-        #[inline] fn nan()      -> Option<$t> { None }\n-        #[inline] fn inf()      -> Option<$t> { None }\n-        #[inline] fn neg_inf()  -> Option<$t> { None }\n-        #[inline] fn neg_zero() -> Option<$t> { None }\n-\n-        #[inline] fn round_to_zero(&self)   -> $t { *self }\n-        #[inline] fn fractional_part(&self) -> $t {     0 }\n-    }\n-))\n-\n-// FIXME: #4955\n-// Replace by two generic impls for traits 'Integral' and 'Floating'\n-impl_NumStrConv_Floating!(f32)\n-impl_NumStrConv_Floating!(f64)\n-\n-impl_NumStrConv_Integer!(int)\n-impl_NumStrConv_Integer!(i8)\n-impl_NumStrConv_Integer!(i16)\n-impl_NumStrConv_Integer!(i32)\n-impl_NumStrConv_Integer!(i64)\n-\n-impl_NumStrConv_Integer!(uint)\n-impl_NumStrConv_Integer!(u8)\n-impl_NumStrConv_Integer!(u16)\n-impl_NumStrConv_Integer!(u32)\n-impl_NumStrConv_Integer!(u64)\n-\n-\n-// Special value strings as [u8] consts.\n-static INF_BUF:     [u8, ..3] = [b'i', b'n', b'f'];\n-static POS_INF_BUF: [u8, ..4] = [b'+', b'i', b'n', b'f'];\n-static NEG_INF_BUF: [u8, ..4] = [b'-', b'i', b'n', b'f'];\n-static NAN_BUF:     [u8, ..3] = [b'N', b'a', b'N'];\n-\n /**\n  * Converts an integral number to its string representation as a byte vector.\n  * This is meant to be a common base implementation for all integral string\n@@ -170,10 +95,10 @@ static NAN_BUF:     [u8, ..3] = [b'N', b'a', b'N'];\n fn int_to_str_bytes_common<T: Int>(num: T, radix: uint, sign: SignFormat, f: |u8|) {\n     assert!(2 <= radix && radix <= 36);\n \n-    let _0: T = Zero::zero();\n+    let _0: T = num::zero();\n \n     let neg = num < _0;\n-    let radix_gen: T = cast(radix).unwrap();\n+    let radix_gen: T = num::cast(radix).unwrap();\n \n     let mut deccum = num;\n     // This is just for integral types, the largest of which is a u64. The\n@@ -255,8 +180,7 @@ fn int_to_str_bytes_common<T: Int>(num: T, radix: uint, sign: SignFormat, f: |u8\n  * - Fails if `radix` > 25 and `exp_format` is `ExpBin` due to conflict\n  *   between digit and exponent sign `'p'`.\n  */\n-pub fn float_to_str_bytes_common<T:NumCast+Zero+One+PartialEq+PartialOrd+Float+\n-                                  Div<T,T>+Neg<T>+Rem<T,T>+Mul<T,T>>(\n+pub fn float_to_str_bytes_common<T: Float>(\n         num: T, radix: uint, negative_zero: bool,\n         sign: SignFormat, digits: SignificantDigits, exp_format: ExponentFormat, exp_upper: bool\n         ) -> (Vec<u8>, bool) {\n@@ -271,8 +195,8 @@ pub fn float_to_str_bytes_common<T:NumCast+Zero+One+PartialEq+PartialOrd+Float+\n         _ => ()\n     }\n \n-    let _0: T = Zero::zero();\n-    let _1: T = One::one();\n+    let _0: T = num::zero();\n+    let _1: T = num::one();\n \n     match num.classify() {\n         FPNaN => { return (b\"NaN\".to_vec(), true); }\n@@ -293,7 +217,7 @@ pub fn float_to_str_bytes_common<T:NumCast+Zero+One+PartialEq+PartialOrd+Float+\n \n     let neg = num < _0 || (negative_zero && _1 / num == Float::neg_infinity());\n     let mut buf = Vec::new();\n-    let radix_gen: T   = cast(radix as int).unwrap();\n+    let radix_gen: T = num::cast(radix as int).unwrap();\n \n     let (num, exp) = match exp_format {\n         ExpNone => (num, 0i32),\n@@ -302,12 +226,12 @@ pub fn float_to_str_bytes_common<T:NumCast+Zero+One+PartialEq+PartialOrd+Float+\n                 (num, 0i32)\n             } else {\n                 let (exp, exp_base) = match exp_format {\n-                    ExpDec => (num.abs().log10().floor(), cast::<f64, T>(10.0f64).unwrap()),\n-                    ExpBin => (num.abs().log2().floor(), cast::<f64, T>(2.0f64).unwrap()),\n+                    ExpDec => (num.abs().log10().floor(), num::cast::<f64, T>(10.0f64).unwrap()),\n+                    ExpBin => (num.abs().log2().floor(), num::cast::<f64, T>(2.0f64).unwrap()),\n                     ExpNone => unreachable!()\n                 };\n \n-                (num / exp_base.powf(exp), cast::<T, i32>(exp).unwrap())\n+                (num / exp_base.powf(exp), num::cast::<T, i32>(exp).unwrap())\n             }\n         }\n     };\n@@ -488,8 +412,7 @@ pub fn float_to_str_bytes_common<T:NumCast+Zero+One+PartialEq+PartialOrd+Float+\n  * `to_str_bytes_common()`, for details see there.\n  */\n #[inline]\n-pub fn float_to_str_common<T:NumCast+Zero+One+PartialEq+PartialOrd+NumStrConv+Float+\n-                             Div<T,T>+Neg<T>+Rem<T,T>+Mul<T,T>>(\n+pub fn float_to_str_common<T: Float>(\n         num: T, radix: uint, negative_zero: bool,\n         sign: SignFormat, digits: SignificantDigits, exp_format: ExponentFormat, exp_capital: bool\n         ) -> (String, bool) {\n@@ -501,311 +424,228 @@ pub fn float_to_str_common<T:NumCast+Zero+One+PartialEq+PartialOrd+NumStrConv+Fl\n // Some constants for from_str_bytes_common's input validation,\n // they define minimum radix values for which the character is a valid digit.\n static DIGIT_P_RADIX: uint = ('p' as uint) - ('a' as uint) + 11u;\n-static DIGIT_I_RADIX: uint = ('i' as uint) - ('a' as uint) + 11u;\n static DIGIT_E_RADIX: uint = ('e' as uint) - ('a' as uint) + 11u;\n \n-/**\n- * Parses a byte slice as a number. This is meant to\n- * be a common base implementation for all numeric string conversion\n- * functions like `from_str()` or `from_str_radix()`.\n- *\n- * # Arguments\n- * - `buf`        - The byte slice to parse.\n- * - `radix`      - Which base to parse the number as. Accepts 2-36.\n- * - `negative`   - Whether to accept negative numbers.\n- * - `fractional` - Whether to accept numbers with fractional parts.\n- * - `special`    - Whether to accept special values like `inf`\n- *                  and `NaN`. Can conflict with `radix`, see Failure.\n- * - `exponent`   - Which exponent format to accept. Options are:\n- *     - `ExpNone`: No Exponent, accepts just plain numbers like `42` or\n- *                  `-8.2`.\n- *     - `ExpDec`:  Accepts numbers with a decimal exponent like `42e5` or\n- *                  `8.2E-2`. The exponent string itself is always base 10.\n- *                  Can conflict with `radix`, see Failure.\n- *     - `ExpBin`:  Accepts numbers with a binary exponent like `42P-8` or\n- *                  `FFp128`. The exponent string itself is always base 10.\n- *                  Can conflict with `radix`, see Failure.\n- * - `empty_zero` - Whether to accept an empty `buf` as a 0 or not.\n- * - `ignore_underscores` - Whether all underscores within the string should\n- *                          be ignored.\n- *\n- * # Return value\n- * Returns `Some(n)` if `buf` parses to a number n without overflowing, and\n- * `None` otherwise, depending on the constraints set by the remaining\n- * arguments.\n- *\n- * # Failure\n- * - Fails if `radix` < 2 or `radix` > 36.\n- * - Fails if `radix` > 14 and `exponent` is `ExpDec` due to conflict\n- *   between digit and exponent sign `'e'`.\n- * - Fails if `radix` > 25 and `exponent` is `ExpBin` due to conflict\n- *   between digit and exponent sign `'p'`.\n- * - Fails if `radix` > 18 and `special == true` due to conflict\n- *   between digit and lowest first character in `inf` and `NaN`, the `'i'`.\n- */\n-pub fn from_str_bytes_common<T:NumCast+Zero+One+PartialEq+PartialOrd+Div<T,T>+\n-                                    Mul<T,T>+Sub<T,T>+Neg<T>+Add<T,T>+\n-                                    NumStrConv+Clone>(\n-        buf: &[u8], radix: uint, negative: bool, fractional: bool,\n-        special: bool, exponent: ExponentFormat, empty_zero: bool,\n-        ignore_underscores: bool\n-        ) -> Option<T> {\n-    match exponent {\n-        ExpDec if radix >= DIGIT_E_RADIX       // decimal exponent 'e'\n-          => panic!(\"from_str_bytes_common: radix {} incompatible with \\\n-                    use of 'e' as decimal exponent\", radix),\n-        ExpBin if radix >= DIGIT_P_RADIX       // binary exponent 'p'\n-          => panic!(\"from_str_bytes_common: radix {} incompatible with \\\n-                    use of 'p' as binary exponent\", radix),\n-        _ if special && radix >= DIGIT_I_RADIX // first digit of 'inf'\n-          => panic!(\"from_str_bytes_common: radix {} incompatible with \\\n-                    special values 'inf' and 'NaN'\", radix),\n-        _ if (radix as int) < 2\n-          => panic!(\"from_str_bytes_common: radix {} to low, \\\n-                    must lie in the range [2, 36]\", radix),\n-        _ if (radix as int) > 36\n-          => panic!(\"from_str_bytes_common: radix {} to high, \\\n-                    must lie in the range [2, 36]\", radix),\n-        _ => ()\n-    }\n-\n-    let _0: T = Zero::zero();\n-    let _1: T = One::one();\n-    let radix_gen: T = cast(radix as int).unwrap();\n-\n-    let len = buf.len();\n-\n-    if len == 0 {\n-        if empty_zero {\n-            return Some(_0);\n-        } else {\n-            return None;\n-        }\n+pub fn from_str_radix_float<T: Float>(src: &str, radix: uint) -> Option<T> {\n+   assert!(radix >= 2 && radix <= 36,\n+           \"from_str_radix_float: must lie in the range `[2, 36]` - found {}\",\n+           radix);\n+\n+    let _0: T = num::zero();\n+    let _1: T = num::one();\n+    let radix_t: T = num::cast(radix as int).unwrap();\n+\n+    // Special values\n+    match src {\n+        \"inf\"   => return Some(Float::infinity()),\n+        \"-inf\"  => return Some(Float::neg_infinity()),\n+        \"NaN\"   => return Some(Float::nan()),\n+        _       => {},\n     }\n \n-    if special {\n-        if buf == INF_BUF || buf == POS_INF_BUF {\n-            return NumStrConv::inf();\n-        } else if buf == NEG_INF_BUF {\n-            if negative {\n-                return NumStrConv::neg_inf();\n-            } else {\n-                return None;\n-            }\n-        } else if buf == NAN_BUF {\n-            return NumStrConv::nan();\n-        }\n-    }\n-\n-    let (start, accum_positive) = match buf[0] as char {\n-      '-' if !negative => return None,\n-      '-' => (1u, false),\n-      '+' => (1u, true),\n-       _  => (0u, true)\n+    let (is_positive, src) =  match src.slice_shift_char() {\n+        (None, _)        => return None,\n+        (Some('-'), \"\")  => return None,\n+        (Some('-'), src) => (false, src),\n+        (Some(_), _)     => (true,  src),\n     };\n \n-    // Initialize accumulator with signed zero for floating point parsing to\n-    // work\n-    let mut accum      = if accum_positive { _0.clone() } else { -_1 * _0};\n-    let mut last_accum = accum.clone(); // Necessary to detect overflow\n-    let mut i          = start;\n-    let mut exp_found  = false;\n-\n-    // Parse integer part of number\n-    while i < len {\n-        let c = buf[i] as char;\n-\n-        match char::to_digit(c, radix) {\n+    // The significand to accumulate\n+    let mut sig = if is_positive { _0 } else { -_1 };\n+    // Necessary to detect overflow\n+    let mut prev_sig = sig;\n+    let mut cs = src.chars().enumerate();\n+    // Exponent prefix and exponent index offset\n+    let mut exp_info = None::<(char, uint)>;\n+\n+    // Parse the integer part of the significand\n+    for (i, c) in cs {\n+        match c.to_digit(radix) {\n             Some(digit) => {\n-                // shift accum one digit left\n-                accum = accum * radix_gen.clone();\n+                // shift significand one digit left\n+                sig = sig * radix_t;\n \n                 // add/subtract current digit depending on sign\n-                if accum_positive {\n-                    accum = accum + cast(digit as int).unwrap();\n+                if is_positive {\n+                    sig = sig + num::cast(digit as int).unwrap();\n                 } else {\n-                    accum = accum - cast(digit as int).unwrap();\n+                    sig = sig - num::cast(digit as int).unwrap();\n                 }\n \n                 // Detect overflow by comparing to last value, except\n                 // if we've not seen any non-zero digits.\n-                if last_accum != _0 {\n-                    if accum_positive && accum <= last_accum { return NumStrConv::inf(); }\n-                    if !accum_positive && accum >= last_accum { return NumStrConv::neg_inf(); }\n+                if prev_sig != _0 {\n+                    if is_positive && sig <= prev_sig\n+                        { return Some(Float::infinity()); }\n+                    if !is_positive && sig >= prev_sig\n+                        { return Some(Float::neg_infinity()); }\n \n                     // Detect overflow by reversing the shift-and-add process\n-                    if accum_positive &&\n-                        (last_accum != ((accum - cast(digit as int).unwrap())/radix_gen.clone())) {\n-                        return NumStrConv::inf();\n-                    }\n-                    if !accum_positive &&\n-                        (last_accum != ((accum + cast(digit as int).unwrap())/radix_gen.clone())) {\n-                        return NumStrConv::neg_inf();\n-                    }\n+                    let digit: T = num::cast(digit as int).unwrap();\n+                    if is_positive && (prev_sig != ((sig - digit) / radix_t))\n+                        { return Some(Float::infinity()); }\n+                    if !is_positive && (prev_sig != ((sig + digit) / radix_t))\n+                        { return Some(Float::neg_infinity()); }\n                 }\n-                last_accum = accum.clone();\n-            }\n+                prev_sig = sig;\n+            },\n             None => match c {\n-                '_' if ignore_underscores => {}\n                 'e' | 'E' | 'p' | 'P' => {\n-                    exp_found = true;\n-                    break;                       // start of exponent\n-                }\n-                '.' if fractional => {\n-                    i += 1u;                     // skip the '.'\n-                    break;                       // start of fractional part\n-                }\n-                _ => return None                 // invalid number\n-            }\n+                    exp_info = Some((c, i + 1));\n+                    break;  // start of exponent\n+                },\n+                '.' => {\n+                    break;  // start of fractional part\n+                },\n+                _ => {\n+                    return None;\n+                },\n+            },\n         }\n-\n-        i += 1u;\n     }\n \n-    // Parse fractional part of number\n-    // Skip if already reached start of exponent\n-    if !exp_found {\n-        let mut power = _1.clone();\n-\n-        while i < len {\n-            let c = buf[i] as char;\n-\n-            match char::to_digit(c, radix) {\n+    // If we are not yet at the exponent parse the fractional\n+    // part of the significand\n+    if exp_info.is_none() {\n+        let mut power = _1;\n+        for (i, c) in cs {\n+            match c.to_digit(radix) {\n                 Some(digit) => {\n+                    let digit: T = num::cast(digit).unwrap();\n                     // Decrease power one order of magnitude\n-                    power = power / radix_gen;\n-\n-                    let digit_t: T = cast(digit).unwrap();\n-\n+                    power = power / radix_t;\n                     // add/subtract current digit depending on sign\n-                    if accum_positive {\n-                        accum = accum + digit_t * power;\n+                    sig = if is_positive {\n+                        sig + digit * power\n                     } else {\n-                        accum = accum - digit_t * power;\n-                    }\n-\n+                        sig - digit * power\n+                    };\n                     // Detect overflow by comparing to last value\n-                    if accum_positive && accum < last_accum { return NumStrConv::inf(); }\n-                    if !accum_positive && accum > last_accum { return NumStrConv::neg_inf(); }\n-                    last_accum = accum.clone();\n-                }\n+                    if is_positive && sig < prev_sig\n+                        { return Some(Float::infinity()); }\n+                    if !is_positive && sig > prev_sig\n+                        { return Some(Float::neg_infinity()); }\n+                    prev_sig = sig;\n+                },\n                 None => match c {\n-                    '_' if ignore_underscores => {}\n                     'e' | 'E' | 'p' | 'P' => {\n-                        exp_found = true;\n-                        break;                   // start of exponent\n-                    }\n-                    _ => return None             // invalid number\n-                }\n+                        exp_info = Some((c, i + 1));\n+                        break; // start of exponent\n+                    },\n+                    _ => {\n+                        return None; // invalid number\n+                    },\n+                },\n             }\n-\n-            i += 1u;\n         }\n     }\n \n-    // Special case: buf not empty, but does not contain any digit in front\n-    // of the exponent sign -> number is empty string\n-    if i == start {\n-        if empty_zero {\n-            return Some(_0);\n-        } else {\n-            return None;\n-        }\n-    }\n+    // Parse and calculate the exponent\n+    let exp = match exp_info {\n+        Some((c, offset)) => {\n+            let base: T = match c {\n+                'E' | 'e' if radix == 10 => num::cast(10u).unwrap(),\n+                'P' | 'p' if radix == 16 => num::cast(2u).unwrap(),\n+                _ => return None,\n+            };\n \n-    let mut multiplier = _1.clone();\n+            // Parse the exponent as decimal integer\n+            let src = src[offset..];\n+            let (is_positive, exp) = match src.slice_shift_char() {\n+                (Some('-'), src) => (false, from_str::<uint>(src)),\n+                (Some('+'), src) => (true,  from_str::<uint>(src)),\n+                (Some(_), _)     => (true,  from_str::<uint>(src)),\n+                (None, _)        => return None,\n+            };\n \n-    if exp_found {\n-        let c = buf[i] as char;\n-        let base: T = match (c, exponent) {\n-            // c is never _ so don't need to handle specially\n-            ('e', ExpDec) | ('E', ExpDec) => cast(10u).unwrap(),\n-            ('p', ExpBin) | ('P', ExpBin) => cast(2u).unwrap(),\n-            _ => return None // char doesn't fit given exponent format\n-        };\n+            match (is_positive, exp) {\n+                (true,  Some(exp)) => num::pow(base, exp),\n+                (false, Some(exp)) => _1 / num::pow(base, exp),\n+                (_, None)          => return None,\n+            }\n+        },\n+        None => _1, // no exponent\n+    };\n+\n+    Some(sig * exp)\n+}\n \n-        // parse remaining bytes as decimal integer,\n-        // skipping the exponent char\n-        let exp: Option<int> = from_str_bytes_common(\n-            buf[i+1..len], 10, true, false, false, ExpNone, false,\n-            ignore_underscores);\n+pub fn from_str_radix_int<T: Int>(src: &str, radix: uint) -> Option<T> {\n+   assert!(radix >= 2 && radix <= 36,\n+           \"from_str_radix_int: must lie in the range `[2, 36]` - found {}\",\n+           radix);\n \n-        match exp {\n-            Some(exp_pow) => {\n-                multiplier = if exp_pow < 0 {\n-                    _1 / num::pow(base, (-exp_pow.to_int().unwrap()) as uint)\n-                } else {\n-                    num::pow(base, exp_pow.to_int().unwrap() as uint)\n-                }\n-            }\n-            None => return None // invalid exponent -> invalid number\n-        }\n+    fn cast<T: Int>(x: uint) -> T {\n+        num::cast(x).unwrap()\n     }\n \n-    Some(accum * multiplier)\n-}\n+    let _0: T = num::zero();\n+    let _1: T = num::one();\n+    let is_signed = _0 > Bounded::min_value();\n \n-/**\n- * Parses a string as a number. This is a wrapper for\n- * `from_str_bytes_common()`, for details see there.\n- */\n-#[inline]\n-pub fn from_str_common<T:NumCast+Zero+One+PartialEq+PartialOrd+Div<T,T>+Mul<T,T>+\n-                              Sub<T,T>+Neg<T>+Add<T,T>+NumStrConv+Clone>(\n-        buf: &str, radix: uint, negative: bool, fractional: bool,\n-        special: bool, exponent: ExponentFormat, empty_zero: bool,\n-        ignore_underscores: bool\n-        ) -> Option<T> {\n-    from_str_bytes_common(buf.as_bytes(), radix, negative,\n-                          fractional, special, exponent, empty_zero,\n-                          ignore_underscores)\n+    let (is_positive, src) =  match src.slice_shift_char() {\n+        (Some('-'), src) if is_signed => (false, src),\n+        (Some(_), _) => (true, src),\n+        (None, _) => return None,\n+    };\n+\n+    let mut xs = src.chars().map(|c| {\n+        c.to_digit(radix).map(cast)\n+    });\n+    let radix = cast(radix);\n+    let mut result = _0;\n+\n+    if is_positive {\n+        for x in xs {\n+            let x = match x {\n+                Some(x) => x,\n+                None => return None,\n+            };\n+            result = match result.checked_mul(&radix) {\n+                Some(result) => result,\n+                None => return None,\n+            };\n+            result = match result.checked_add(&x) {\n+                Some(result) => result,\n+                None => return None,\n+            };\n+        }\n+    } else {\n+        for x in xs {\n+            let x = match x {\n+                Some(x) => x,\n+                None => return None,\n+            };\n+            result = match result.checked_mul(&radix) {\n+                Some(result) => result,\n+                None => return None,\n+            };\n+            result = match result.checked_sub(&x) {\n+                Some(result) => result,\n+                None => return None,\n+            };\n+        }\n+    }\n+\n+    Some(result)\n }\n \n #[cfg(test)]\n mod test {\n     use super::*;\n     use option::*;\n-\n-    #[test]\n-    fn from_str_ignore_underscores() {\n-        let s : Option<u8> = from_str_common(\"__1__\", 2, false, false, false,\n-                                             ExpNone, false, true);\n-        assert_eq!(s, Some(1u8));\n-\n-        let n : Option<u8> = from_str_common(\"__1__\", 2, false, false, false,\n-                                             ExpNone, false, false);\n-        assert_eq!(n, None);\n-\n-        let f : Option<f32> = from_str_common(\"_1_._5_e_1_\", 10, false, true, false,\n-                                              ExpDec, false, true);\n-        assert_eq!(f, Some(1.5e1f32));\n-    }\n-\n-    #[test]\n-    fn from_str_issue5770() {\n-        // try to parse 0b1_1111_1111 = 511 as a u8. Caused problems\n-        // since 255*2+1 == 255 (mod 256) so the overflow wasn't\n-        // detected.\n-        let n : Option<u8> = from_str_common(\"111111111\", 2, false, false, false,\n-                                             ExpNone, false, false);\n-        assert_eq!(n, None);\n-    }\n+    use num::Float;\n \n     #[test]\n     fn from_str_issue7588() {\n-        let u : Option<u8> = from_str_common(\"1000\", 10, false, false, false,\n-                                            ExpNone, false, false);\n+        let u : Option<u8> = from_str_radix_int(\"1000\", 10);\n         assert_eq!(u, None);\n-        let s : Option<i16> = from_str_common(\"80000\", 10, false, false, false,\n-                                             ExpNone, false, false);\n+        let s : Option<i16> = from_str_radix_int(\"80000\", 10);\n         assert_eq!(s, None);\n-        let f : Option<f32> = from_str_common(\n-            \"10000000000000000000000000000000000000000\", 10, false, false, false,\n-            ExpNone, false, false);\n-        assert_eq!(f, NumStrConv::inf())\n-        let fe : Option<f32> = from_str_common(\"1e40\", 10, false, false, false,\n-                                            ExpDec, false, false);\n-        assert_eq!(fe, NumStrConv::inf())\n+        let f : Option<f32> = from_str_radix_float(\"10000000000000000000000000000000000000000\", 10);\n+        assert_eq!(f, Some(Float::infinity()))\n+        let fe : Option<f32> = from_str_radix_float(\"1e40\", 10);\n+        assert_eq!(fe, Some(Float::infinity()))\n     }\n }\n "}, {"sha": "aa8e58bab0286a9b3cc5561d7d28b85e7e98329a", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 23, "deletions": 48, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -15,40 +15,19 @@\n \n macro_rules! uint_module (($T:ty) => (\n \n-// String conversion functions and impl str -> num\n-\n-/// Parse a byte slice as a number in the given base\n-///\n-/// Yields an `Option` because `buf` may or may not actually be parseable.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// let num = std::uint::parse_bytes([49,50,51,52,53,54,55,56,57], 10);\n-/// assert!(num == Some(123456789));\n-/// ```\n-#[inline]\n-#[experimental = \"might need to return Result\"]\n-pub fn parse_bytes(buf: &[u8], radix: uint) -> Option<$T> {\n-    strconv::from_str_bytes_common(buf, radix, false, false, false,\n-                                   strconv::ExpNone, false, false)\n-}\n-\n #[experimental = \"might need to return Result\"]\n impl FromStr for $T {\n     #[inline]\n     fn from_str(s: &str) -> Option<$T> {\n-        strconv::from_str_common(s, 10u, false, false, false,\n-                                 strconv::ExpNone, false, false)\n+        strconv::from_str_radix_int(s, 10)\n     }\n }\n \n #[experimental = \"might need to return Result\"]\n impl FromStrRadix for $T {\n     #[inline]\n     fn from_str_radix(s: &str, radix: uint) -> Option<$T> {\n-        strconv::from_str_common(s, radix, false, false, false,\n-                                 strconv::ExpNone, false, false)\n+        strconv::from_str_radix_int(s, radix)\n     }\n }\n \n@@ -85,10 +64,7 @@ pub fn to_str_bytes<U>(n: $T, radix: uint, f: |v: &[u8]| -> U) -> U {\n #[cfg(test)]\n mod tests {\n     use prelude::*;\n-    use super::*;\n-\n-    use str::StrSlice;\n-    use u16;\n+    use num::FromStrRadix;\n \n     #[test]\n     pub fn test_from_str() {\n@@ -98,23 +74,22 @@ mod tests {\n         assert_eq!(from_str::<u32>(\"123456789\"), Some(123456789 as u32));\n         assert_eq!(from_str::<$T>(\"00100\"), Some(100u as $T));\n \n-        assert!(from_str::<$T>(\"\").is_none());\n-        assert!(from_str::<$T>(\" \").is_none());\n-        assert!(from_str::<$T>(\"x\").is_none());\n+        assert_eq!(from_str::<$T>(\"\"), None);\n+        assert_eq!(from_str::<$T>(\" \"), None);\n+        assert_eq!(from_str::<$T>(\"x\"), None);\n     }\n \n     #[test]\n     pub fn test_parse_bytes() {\n-        use str::StrSlice;\n-        assert_eq!(parse_bytes(\"123\".as_bytes(), 10u), Some(123u as $T));\n-        assert_eq!(parse_bytes(\"1001\".as_bytes(), 2u), Some(9u as $T));\n-        assert_eq!(parse_bytes(\"123\".as_bytes(), 8u), Some(83u as $T));\n-        assert_eq!(u16::parse_bytes(\"123\".as_bytes(), 16u), Some(291u as u16));\n-        assert_eq!(u16::parse_bytes(\"ffff\".as_bytes(), 16u), Some(65535u as u16));\n-        assert_eq!(parse_bytes(\"z\".as_bytes(), 36u), Some(35u as $T));\n-\n-        assert!(parse_bytes(\"Z\".as_bytes(), 10u).is_none());\n-        assert!(parse_bytes(\"_\".as_bytes(), 2u).is_none());\n+        assert_eq!(FromStrRadix::from_str_radix(\"123\", 10), Some(123u as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"1001\", 2), Some(9u as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"123\", 8), Some(83u as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"123\", 16), Some(291u as u16));\n+        assert_eq!(FromStrRadix::from_str_radix(\"ffff\", 16), Some(65535u as u16));\n+        assert_eq!(FromStrRadix::from_str_radix(\"z\", 36), Some(35u as $T));\n+\n+        assert_eq!(FromStrRadix::from_str_radix(\"Z\", 10), None::<$T>);\n+        assert_eq!(FromStrRadix::from_str_radix(\"_\", 2), None::<$T>);\n     }\n \n     #[test]\n@@ -148,35 +123,35 @@ mod tests {\n     fn test_uint_from_str_overflow() {\n         let mut u8_val: u8 = 255_u8;\n         assert_eq!(from_str::<u8>(\"255\"), Some(u8_val));\n-        assert!(from_str::<u8>(\"256\").is_none());\n+        assert_eq!(from_str::<u8>(\"256\"), None);\n \n         u8_val += 1 as u8;\n         assert_eq!(from_str::<u8>(\"0\"), Some(u8_val));\n-        assert!(from_str::<u8>(\"-1\").is_none());\n+        assert_eq!(from_str::<u8>(\"-1\"), None);\n \n         let mut u16_val: u16 = 65_535_u16;\n         assert_eq!(from_str::<u16>(\"65535\"), Some(u16_val));\n-        assert!(from_str::<u16>(\"65536\").is_none());\n+        assert_eq!(from_str::<u16>(\"65536\"), None);\n \n         u16_val += 1 as u16;\n         assert_eq!(from_str::<u16>(\"0\"), Some(u16_val));\n-        assert!(from_str::<u16>(\"-1\").is_none());\n+        assert_eq!(from_str::<u16>(\"-1\"), None);\n \n         let mut u32_val: u32 = 4_294_967_295_u32;\n         assert_eq!(from_str::<u32>(\"4294967295\"), Some(u32_val));\n-        assert!(from_str::<u32>(\"4294967296\").is_none());\n+        assert_eq!(from_str::<u32>(\"4294967296\"), None);\n \n         u32_val += 1 as u32;\n         assert_eq!(from_str::<u32>(\"0\"), Some(u32_val));\n-        assert!(from_str::<u32>(\"-1\").is_none());\n+        assert_eq!(from_str::<u32>(\"-1\"), None);\n \n         let mut u64_val: u64 = 18_446_744_073_709_551_615_u64;\n         assert_eq!(from_str::<u64>(\"18446744073709551615\"), Some(u64_val));\n-        assert!(from_str::<u64>(\"18446744073709551616\").is_none());\n+        assert_eq!(from_str::<u64>(\"18446744073709551616\"), None);\n \n         u64_val += 1 as u64;\n         assert_eq!(from_str::<u64>(\"0\"), Some(u64_val));\n-        assert!(from_str::<u64>(\"-1\").is_none());\n+        assert_eq!(from_str::<u64>(\"-1\"), None);\n     }\n }\n "}, {"sha": "18fc970c218323ac017a464c0745ac0384d8cee7", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -119,7 +119,7 @@ impl Name {\n     pub fn as_str<'a>(&'a self) -> &'a str {\n         unsafe {\n             // FIXME #12938: can't use copy_lifetime since &str isn't a &T\n-            ::std::mem::transmute(token::get_name(*self).get())\n+            ::std::mem::transmute::<&str,&str>(token::get_name(*self).get())\n         }\n     }\n \n@@ -385,7 +385,7 @@ pub enum Pat_ {\n     PatLit(P<Expr>),\n     PatRange(P<Expr>, P<Expr>),\n     /// [a, b, ..i, y, z] is represented as:\n-    ///     PatVec(~[a, b], Some(i), ~[y, z])\n+    ///     PatVec(box [a, b], Some(i), box [y, z])\n     PatVec(Vec<P<Pat>>, Option<P<Pat>>, Vec<P<Pat>>),\n     PatMac(Mac),\n }\n@@ -861,10 +861,8 @@ pub enum ImplItem {\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct AssociatedType {\n-    pub id: NodeId,\n-    pub span: Span,\n-    pub ident: Ident,\n     pub attrs: Vec<Attribute>,\n+    pub ty_param: TyParam,\n }\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]"}, {"sha": "f049b964ff33d415d77acf27528c60ebd219de52", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -405,7 +405,9 @@ impl<'ast> Map<'ast> {\n                         MethMac(_) => panic!(\"no path elem for {}\", node),\n                     }\n                 }\n-                TypeTraitItem(ref m) => PathName(m.ident.name),\n+                TypeTraitItem(ref m) => {\n+                    PathName(m.ty_param.ident.name)\n+                }\n             },\n             NodeVariant(v) => PathName(v.node.name.name),\n             _ => panic!(\"no path elem for {}\", node)\n@@ -510,7 +512,7 @@ impl<'ast> Map<'ast> {\n                 match *trait_method {\n                     RequiredMethod(ref type_method) => type_method.span,\n                     ProvidedMethod(ref method) => method.span,\n-                    TypeTraitItem(ref typedef) => typedef.span,\n+                    TypeTraitItem(ref typedef) => typedef.ty_param.span,\n                 }\n             }\n             Some(NodeImplItem(ref impl_item)) => {\n@@ -650,7 +652,7 @@ impl Named for TraitItem {\n         match *self {\n             RequiredMethod(ref tm) => tm.ident.name,\n             ProvidedMethod(ref m) => m.name(),\n-            TypeTraitItem(ref at) => at.ident.name,\n+            TypeTraitItem(ref at) => at.ty_param.ident.name,\n         }\n     }\n }\n@@ -783,7 +785,7 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n                             self.insert(m.id, NodeTraitItem(tm));\n                         }\n                         TypeTraitItem(ref typ) => {\n-                            self.insert(typ.id, NodeTraitItem(tm));\n+                            self.insert(typ.ty_param.id, NodeTraitItem(tm));\n                         }\n                     }\n                 }\n@@ -976,7 +978,7 @@ pub fn map_decoded_item<'ast, F: FoldOps>(map: &Map<'ast>,\n             let trait_item_id = match *trait_item {\n                 ProvidedMethod(ref m) => m.id,\n                 RequiredMethod(ref m) => m.id,\n-                TypeTraitItem(ref ty) => ty.id,\n+                TypeTraitItem(ref ty) => ty.ty_param.id,\n             };\n \n             collector.insert(trait_item_id, NodeTraitItem(trait_item));\n@@ -1080,7 +1082,7 @@ fn node_id_to_string(map: &Map, id: NodeId) -> String {\n                 }\n                 TypeTraitItem(ref t) => {\n                     format!(\"type item {} in {} (id={})\",\n-                            token::get_ident(t.ident),\n+                            token::get_ident(t.ty_param.ident),\n                             map.path_to_string(id),\n                             id)\n                 }"}, {"sha": "3aa60236d709a6f7f7822ab6f3a6e1a23fa097ba", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -21,7 +21,6 @@ use ptr::P;\n use visit::Visitor;\n use visit;\n \n-use std::cell::Cell;\n use std::cmp;\n use std::u32;\n \n@@ -333,20 +332,20 @@ impl IdRange {\n }\n \n pub trait IdVisitingOperation {\n-    fn visit_id(&self, node_id: NodeId);\n+    fn visit_id(&mut self, node_id: NodeId);\n }\n \n /// A visitor that applies its operation to all of the node IDs\n /// in a visitable thing.\n \n pub struct IdVisitor<'a, O:'a> {\n-    pub operation: &'a O,\n+    pub operation: &'a mut O,\n     pub pass_through_items: bool,\n     pub visited_outermost: bool,\n }\n \n impl<'a, O: IdVisitingOperation> IdVisitor<'a, O> {\n-    fn visit_generics_helper(&self, generics: &Generics) {\n+    fn visit_generics_helper(&mut self, generics: &Generics) {\n         for type_parameter in generics.ty_params.iter() {\n             self.operation.visit_id(type_parameter.id)\n         }\n@@ -525,7 +524,7 @@ impl<'a, 'v, O: IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O> {\n         match *tm {\n             ast::RequiredMethod(ref m) => self.operation.visit_id(m.id),\n             ast::ProvidedMethod(ref m) => self.operation.visit_id(m.id),\n-            ast::TypeTraitItem(ref typ) => self.operation.visit_id(typ.id),\n+            ast::TypeTraitItem(ref typ) => self.operation.visit_id(typ.ty_param.id),\n         }\n         visit::walk_trait_item(self, tm);\n     }\n@@ -540,7 +539,7 @@ impl<'a, 'v, O: IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O> {\n }\n \n pub fn visit_ids_for_inlined_item<O: IdVisitingOperation>(item: &InlinedItem,\n-                                                          operation: &O) {\n+                                                          operation: &mut O) {\n     let mut id_visitor = IdVisitor {\n         operation: operation,\n         pass_through_items: true,\n@@ -551,23 +550,21 @@ pub fn visit_ids_for_inlined_item<O: IdVisitingOperation>(item: &InlinedItem,\n }\n \n struct IdRangeComputingVisitor {\n-    result: Cell<IdRange>,\n+    result: IdRange,\n }\n \n impl IdVisitingOperation for IdRangeComputingVisitor {\n-    fn visit_id(&self, id: NodeId) {\n-        let mut id_range = self.result.get();\n-        id_range.add(id);\n-        self.result.set(id_range)\n+    fn visit_id(&mut self, id: NodeId) {\n+        self.result.add(id);\n     }\n }\n \n pub fn compute_id_range_for_inlined_item(item: &InlinedItem) -> IdRange {\n-    let visitor = IdRangeComputingVisitor {\n-        result: Cell::new(IdRange::max())\n+    let mut visitor = IdRangeComputingVisitor {\n+        result: IdRange::max()\n     };\n-    visit_ids_for_inlined_item(item, &visitor);\n-    visitor.result.get()\n+    visit_ids_for_inlined_item(item, &mut visitor);\n+    visitor.result\n }\n \n pub fn compute_id_range_for_fn_body(fk: visit::FnKind,\n@@ -582,16 +579,16 @@ pub fn compute_id_range_for_fn_body(fk: visit::FnKind,\n      * ignoring nested items.\n      */\n \n-    let visitor = IdRangeComputingVisitor {\n-        result: Cell::new(IdRange::max())\n+    let mut visitor = IdRangeComputingVisitor {\n+        result: IdRange::max()\n     };\n     let mut id_visitor = IdVisitor {\n-        operation: &visitor,\n+        operation: &mut visitor,\n         pass_through_items: false,\n         visited_outermost: false,\n     };\n     id_visitor.visit_fn(fk, decl, body, sp, id);\n-    visitor.result.get()\n+    id_visitor.operation.result\n }\n \n pub fn walk_pat(pat: &Pat, it: |&Pat| -> bool) -> bool {"}, {"sha": "e653c8aebf447c03d41a7be48a61ea50b40a7e77", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -52,11 +52,19 @@ fn cs_clone(\n     name: &str,\n     cx: &mut ExtCtxt, trait_span: Span,\n     substr: &Substructure) -> P<Expr> {\n-    let clone_ident = substr.method_ident;\n     let ctor_ident;\n     let all_fields;\n-    let subcall = |field: &FieldInfo|\n-        cx.expr_method_call(field.span, field.self_.clone(), clone_ident, Vec::new());\n+    let fn_path = vec![\n+        cx.ident_of(\"std\"),\n+        cx.ident_of(\"clone\"),\n+        cx.ident_of(\"Clone\"),\n+        cx.ident_of(\"clone\"),\n+    ];\n+    let subcall = |field: &FieldInfo| {\n+        let args = vec![cx.expr_addr_of(field.span, field.self_.clone())];\n+\n+        cx.expr_call_global(field.span, fn_path.clone(), args)\n+    };\n \n     match *substr.fields {\n         Struct(ref af) => {"}, {"sha": "7701f495f726fcb72543f66d2761eb5901fc0607", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -260,7 +260,7 @@ impl<'a, 'v> Visitor<'v> for Context<'a> {\n             ast::RequiredMethod(_) | ast::ProvidedMethod(_) => {}\n             ast::TypeTraitItem(ref ti) => {\n                 self.gate_feature(\"associated_types\",\n-                                  ti.span,\n+                                  ti.ty_param.span,\n                                   \"associated types are experimental\")\n             }\n         }"}, {"sha": "6535c8e89fd4e79c22a2ca7d5265169982fb505a", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -793,19 +793,16 @@ pub fn noop_fold_typedef<T>(t: Typedef, folder: &mut T)\n \n pub fn noop_fold_associated_type<T>(at: AssociatedType, folder: &mut T)\n                                     -> AssociatedType\n-                                    where T: Folder {\n-    let new_id = folder.new_id(at.id);\n-    let new_span = folder.new_span(at.span);\n-    let new_ident = folder.fold_ident(at.ident);\n+                                    where T: Folder\n+{\n     let new_attrs = at.attrs\n                       .iter()\n                       .map(|attr| folder.fold_attribute((*attr).clone()))\n                       .collect();\n+    let new_param = folder.fold_ty_param(at.ty_param);\n     ast::AssociatedType {\n-        ident: new_ident,\n         attrs: new_attrs,\n-        id: new_id,\n-        span: new_span,\n+        ty_param: new_param,\n     }\n }\n "}, {"sha": "1bc1d42d888ddf1779f6e821e6b8b8797caf1a3e", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -35,6 +35,19 @@ pub trait Reader {\n     /// Report a non-fatal error with the current span.\n     fn err(&self, &str);\n     fn peek(&self) -> TokenAndSpan;\n+    /// Get a token the parser cares about.\n+    fn real_token(&mut self) -> TokenAndSpan {\n+        let mut t = self.next_token();\n+        loop {\n+            match t.tok {\n+                token::Whitespace | token::Comment | token::Shebang(_) => {\n+                    t = self.next_token();\n+                },\n+                _ => break\n+            }\n+        }\n+        t\n+    }\n }\n \n #[deriving(Clone, PartialEq, Eq, Show)]"}, {"sha": "8ad5bdac7e2c2a4fabcef6906fb009bc561421c1", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 7, "deletions": 24, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -338,27 +338,13 @@ fn is_plain_ident_or_underscore(t: &token::Token) -> bool {\n     t.is_plain_ident() || *t == token::Underscore\n }\n \n-/// Get a token the parser cares about\n-fn real_token(rdr: &mut Reader) -> TokenAndSpan {\n-    let mut t = rdr.next_token();\n-    loop {\n-        match t.tok {\n-            token::Whitespace | token::Comment | token::Shebang(_) => {\n-                t = rdr.next_token();\n-            },\n-            _ => break\n-        }\n-    }\n-    t\n-}\n-\n impl<'a> Parser<'a> {\n     pub fn new(sess: &'a ParseSess,\n                cfg: ast::CrateConfig,\n                mut rdr: Box<Reader+'a>)\n                -> Parser<'a>\n     {\n-        let tok0 = real_token(&mut *rdr);\n+        let tok0 = rdr.real_token();\n         let span = tok0.sp;\n         let placeholder = TokenAndSpan {\n             tok: token::Underscore,\n@@ -898,7 +884,7 @@ impl<'a> Parser<'a> {\n             None\n         };\n         let next = if self.buffer_start == self.buffer_end {\n-            real_token(&mut *self.reader)\n+            self.reader.real_token()\n         } else {\n             // Avoid token copies with `replace`.\n             let buffer_start = self.buffer_start as uint;\n@@ -942,7 +928,7 @@ impl<'a> Parser<'a> {\n                       -> R {\n         let dist = distance as int;\n         while self.buffer_length() < dist {\n-            self.buffer[self.buffer_end as uint] = real_token(&mut *self.reader);\n+            self.buffer[self.buffer_end as uint] = self.reader.real_token();\n             self.buffer_end = (self.buffer_end + 1) & 3;\n         }\n         f(&self.buffer[((self.buffer_start + dist - 1) & 3) as uint].tok)\n@@ -1229,16 +1215,13 @@ impl<'a> Parser<'a> {\n     /// Parses `type Foo;` in a trait declaration only. The `type` keyword has\n     /// already been parsed.\n     fn parse_associated_type(&mut self, attrs: Vec<Attribute>)\n-                             -> AssociatedType {\n-        let lo = self.span.lo;\n-        let ident = self.parse_ident();\n-        let hi = self.span.hi;\n+                             -> AssociatedType\n+    {\n+        let ty_param = self.parse_ty_param();\n         self.expect(&token::Semi);\n         AssociatedType {\n-            id: ast::DUMMY_NODE_ID,\n-            span: mk_sp(lo, hi),\n-            ident: ident,\n             attrs: attrs,\n+            ty_param: ty_param,\n         }\n     }\n "}, {"sha": "615cd34ca14df9b25f8d6ff9d0ec04a5c6c45f8d", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -668,12 +668,12 @@ impl InternedString {\n \n impl BytesContainer for InternedString {\n     fn container_as_bytes<'a>(&'a self) -> &'a [u8] {\n-        // FIXME(pcwalton): This is a workaround for the incorrect signature\n+        // FIXME #12938: This is a workaround for the incorrect signature\n         // of `BytesContainer`, which is itself a workaround for the lack of\n         // DST.\n         unsafe {\n             let this = self.get();\n-            mem::transmute(this.container_as_bytes())\n+            mem::transmute::<&[u8],&[u8]>(this.container_as_bytes())\n         }\n     }\n }"}, {"sha": "4cae3691f2ab66605b1665facf5b231090f26ef7", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 30, "deletions": 27, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -169,17 +169,14 @@ pub fn to_string(f: |&mut State| -> IoResult<()>) -> String {\n     let mut s = rust_printer(box MemWriter::new());\n     f(&mut s).unwrap();\n     eof(&mut s.s).unwrap();\n-    unsafe {\n+    let wr = unsafe {\n         // FIXME(pcwalton): A nasty function to extract the string from an `io::Writer`\n         // that we \"know\" to be a `MemWriter` that works around the lack of checked\n         // downcasts.\n-        let obj: TraitObject = mem::transmute_copy(&s.s.out);\n-        let wr: Box<MemWriter> = mem::transmute(obj.data);\n-        let result =\n-            String::from_utf8(wr.get_ref().as_slice().to_vec()).unwrap();\n-        mem::forget(wr);\n-        result.to_string()\n-    }\n+        let obj: &TraitObject = mem::transmute(&s.s.out);\n+        mem::transmute::<*mut (), &MemWriter>(obj.data)\n+    };\n+    String::from_utf8(wr.get_ref().to_vec()).unwrap()\n }\n \n pub fn binop_to_string(op: BinOpToken) -> &'static str {\n@@ -818,9 +815,11 @@ impl<'a> State<'a> {\n     }\n \n     fn print_associated_type(&mut self, typedef: &ast::AssociatedType)\n-                             -> IoResult<()> {\n+                             -> IoResult<()>\n+    {\n+        try!(self.print_outer_attributes(typedef.attrs[]));\n         try!(self.word_space(\"type\"));\n-        try!(self.print_ident(typedef.ident));\n+        try!(self.print_ty_param(&typedef.ty_param));\n         word(&mut self.s, \";\")\n     }\n \n@@ -2434,30 +2433,34 @@ impl<'a> State<'a> {\n             } else {\n                 let idx = idx - generics.lifetimes.len();\n                 let param = generics.ty_params.get(idx);\n-                match param.unbound {\n-                    Some(TraitTyParamBound(ref tref)) => {\n-                        try!(s.print_trait_ref(tref));\n-                        try!(s.word_space(\"?\"));\n-                    }\n-                    _ => {}\n-                }\n-                try!(s.print_ident(param.ident));\n-                try!(s.print_bounds(\":\", &param.bounds));\n-                match param.default {\n-                    Some(ref default) => {\n-                        try!(space(&mut s.s));\n-                        try!(s.word_space(\"=\"));\n-                        s.print_type(&**default)\n-                    }\n-                    _ => Ok(())\n-                }\n+                s.print_ty_param(param)\n             }\n         }));\n \n         try!(word(&mut self.s, \">\"));\n         Ok(())\n     }\n \n+    pub fn print_ty_param(&mut self, param: &ast::TyParam) -> IoResult<()> {\n+        match param.unbound {\n+            Some(TraitTyParamBound(ref tref)) => {\n+                try!(self.print_trait_ref(tref));\n+                try!(self.word_space(\"?\"));\n+            }\n+            _ => {}\n+        }\n+        try!(self.print_ident(param.ident));\n+        try!(self.print_bounds(\":\", &param.bounds));\n+        match param.default {\n+            Some(ref default) => {\n+                try!(space(&mut self.s));\n+                try!(self.word_space(\"=\"));\n+                self.print_type(&**default)\n+            }\n+            _ => Ok(())\n+        }\n+    }\n+\n     pub fn print_where_clause(&mut self, generics: &ast::Generics)\n                               -> IoResult<()> {\n         if generics.where_clause.predicates.len() == 0 {"}, {"sha": "86ee23d71a6b22dbc733098b8cd9b6e3eac850cf", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -596,7 +596,8 @@ pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_method: &'v Tr\n         RequiredMethod(ref method_type) => visitor.visit_ty_method(method_type),\n         ProvidedMethod(ref method) => walk_method_helper(visitor, &**method),\n         TypeTraitItem(ref associated_type) => {\n-            visitor.visit_ident(associated_type.span, associated_type.ident)\n+            visitor.visit_ident(associated_type.ty_param.span,\n+                                associated_type.ty_param.ident)\n         }\n     }\n }"}, {"sha": "9e3830c1f6090ca8c35d8ff8fdc2ffd8e323009a", "filename": "src/libunicode/u_str.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibunicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Flibunicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_str.rs?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -17,7 +17,6 @@\n  * methods provided by the UnicodeChar trait.\n  */\n \n-use core::clone::Clone;\n use core::cmp;\n use core::slice::ImmutableSlice;\n use core::iter::{Filter, AdditiveIterator, Iterator, DoubleEndedIterator};"}, {"sha": "7fa13d6074d43129835958260163b6f96be36e20", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -24,7 +24,6 @@ extern crate time;\n use std::os;\n use std::result::{Ok, Err};\n use std::task;\n-use std::uint;\n \n fn fib(n: int) -> int {\n     fn pfib(tx: &Sender<int>, n: int) {\n@@ -102,8 +101,7 @@ fn main() {\n     if opts.stress {\n         stress(2);\n     } else {\n-        let max = uint::parse_bytes(args[1].as_bytes(), 10u).unwrap() as\n-            int;\n+        let max = from_str::<uint>(args[1].as_slice()).unwrap() as int;\n \n         let num_trials = 10;\n "}, {"sha": "47ab09d279f62ab773d6bca5051af0ca9c80c307", "filename": "src/test/compile-fail/associated-types-unsized.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Ftest%2Fcompile-fail%2Fassociated-types-unsized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Ftest%2Fcompile-fail%2Fassociated-types-unsized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-unsized.rs?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(associated_types)]\n+\n+trait Get {\n+    type Sized? Value;\n+    fn get(&self) -> <Self as Get>::Value;\n+}\n+\n+fn foo<T:Get>(t: T) {\n+    let x = t.get(); //~ ERROR the trait `core::kinds::Sized` is not implemented\n+}\n+\n+fn main() {\n+}\n+"}, {"sha": "15a7bc01c3ae71f201aa2e292406346b8e096b5f", "filename": "src/test/compile-fail/deriving-no-inner-impl-error-message.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Ftest%2Fcompile-fail%2Fderiving-no-inner-impl-error-message.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Ftest%2Fcompile-fail%2Fderiving-no-inner-impl-error-message.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-no-inner-impl-error-message.rs?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -17,7 +17,8 @@ struct E {\n }\n #[deriving(Clone)]\n struct C {\n-    x: NoCloneOrEq //~ ERROR does not implement any method in scope named `clone`\n+    x: NoCloneOrEq\n+    //~^ ERROR the trait `core::clone::Clone` is not implemented for the type `NoCloneOrEq`\n }\n \n "}, {"sha": "a67f4c851bf8ab74f17c12f21ba792dc40a9b258", "filename": "src/test/compile-fail/issue-18532.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Ftest%2Fcompile-fail%2Fissue-18532.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Ftest%2Fcompile-fail%2Fissue-18532.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18532.rs?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that overloaded call parameter checking does not ICE\n+// when a type error or unconstrained type variable propagates\n+// into it.\n+\n+#![feature(overloaded_calls)]\n+\n+fn main() {\n+    (return)((),());\n+    //~^ ERROR the type of this value must be known\n+    //~^^ ERROR the type of this value must be known\n+    //~^^^ ERROR cannot use call notation\n+}"}, {"sha": "dbb65d8b7cefd6a3928455cd6e3f6e47d11562e3", "filename": "src/test/compile-fail/lint-exceeding-bitshifts.rs", "status": "modified", "additions": 42, "deletions": 38, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Ftest%2Fcompile-fail%2Flint-exceeding-bitshifts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Ftest%2Fcompile-fail%2Flint-exceeding-bitshifts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-exceeding-bitshifts.rs?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -10,49 +10,53 @@\n \n #![deny(exceeding_bitshifts)]\n #![allow(unused_variables)]\n+#![allow(dead_code)]\n \n fn main() {\n-      let n = 1u8 << 8;\n-      let n = 1u8 << 9;   //~ ERROR: bitshift exceeds the type's number of bits\n-      let n = 1u16 << 16;\n-      let n = 1u16 << 17; //~ ERROR: bitshift exceeds the type's number of bits\n-      let n = 1u32 << 32;\n-      let n = 1u32 << 33; //~ ERROR: bitshift exceeds the type's number of bits\n-      let n = 1u64 << 64;\n-      let n = 1u64 << 65; //~ ERROR: bitshift exceeds the type's number of bits\n-      let n = 1i8 << 8;\n-      let n = 1i8 << 9;   //~ ERROR: bitshift exceeds the type's number of bits\n-      let n = 1i16 << 16;\n-      let n = 1i16 << 17; //~ ERROR: bitshift exceeds the type's number of bits\n-      let n = 1i32 << 32;\n-      let n = 1i32 << 33; //~ ERROR: bitshift exceeds the type's number of bits\n-      let n = 1i64 << 64;\n-      let n = 1i64 << 65; //~ ERROR: bitshift exceeds the type's number of bits\n-\n-      let n = 1u8 >> 8;\n-      let n = 1u8 >> 9;   //~ ERROR: bitshift exceeds the type's number of bits\n-      let n = 1u16 >> 16;\n-      let n = 1u16 >> 17; //~ ERROR: bitshift exceeds the type's number of bits\n-      let n = 1u32 >> 32;\n-      let n = 1u32 >> 33; //~ ERROR: bitshift exceeds the type's number of bits\n-      let n = 1u64 >> 64;\n-      let n = 1u64 >> 65; //~ ERROR: bitshift exceeds the type's number of bits\n-      let n = 1i8 >> 8;\n-      let n = 1i8 >> 9;   //~ ERROR: bitshift exceeds the type's number of bits\n-      let n = 1i16 >> 16;\n-      let n = 1i16 >> 17; //~ ERROR: bitshift exceeds the type's number of bits\n-      let n = 1i32 >> 32;\n-      let n = 1i32 >> 33; //~ ERROR: bitshift exceeds the type's number of bits\n-      let n = 1i64 >> 64;\n-      let n = 1i64 >> 65; //~ ERROR: bitshift exceeds the type's number of bits\n+      let n = 1u8 << 7;\n+      let n = 1u8 << 8;   //~ ERROR: bitshift exceeds the type's number of bits\n+      let n = 1u16 << 15;\n+      let n = 1u16 << 16; //~ ERROR: bitshift exceeds the type's number of bits\n+      let n = 1u32 << 31;\n+      let n = 1u32 << 32; //~ ERROR: bitshift exceeds the type's number of bits\n+      let n = 1u64 << 63;\n+      let n = 1u64 << 64; //~ ERROR: bitshift exceeds the type's number of bits\n+      let n = 1i8 << 7;\n+      let n = 1i8 << 8;   //~ ERROR: bitshift exceeds the type's number of bits\n+      let n = 1i16 << 15;\n+      let n = 1i16 << 16; //~ ERROR: bitshift exceeds the type's number of bits\n+      let n = 1i32 << 31;\n+      let n = 1i32 << 32; //~ ERROR: bitshift exceeds the type's number of bits\n+      let n = 1i64 << 63;\n+      let n = 1i64 << 64; //~ ERROR: bitshift exceeds the type's number of bits\n+\n+      let n = 1u8 >> 7;\n+      let n = 1u8 >> 8;   //~ ERROR: bitshift exceeds the type's number of bits\n+      let n = 1u16 >> 15;\n+      let n = 1u16 >> 16; //~ ERROR: bitshift exceeds the type's number of bits\n+      let n = 1u32 >> 31;\n+      let n = 1u32 >> 32; //~ ERROR: bitshift exceeds the type's number of bits\n+      let n = 1u64 >> 63;\n+      let n = 1u64 >> 64; //~ ERROR: bitshift exceeds the type's number of bits\n+      let n = 1i8 >> 7;\n+      let n = 1i8 >> 8;   //~ ERROR: bitshift exceeds the type's number of bits\n+      let n = 1i16 >> 15;\n+      let n = 1i16 >> 16; //~ ERROR: bitshift exceeds the type's number of bits\n+      let n = 1i32 >> 31;\n+      let n = 1i32 >> 32; //~ ERROR: bitshift exceeds the type's number of bits\n+      let n = 1i64 >> 63;\n+      let n = 1i64 >> 64; //~ ERROR: bitshift exceeds the type's number of bits\n \n       let n = 1u8;\n-      let n = n << 8;\n-      let n = n << 9; //~ ERROR: bitshift exceeds the type's number of bits\n+      let n = n << 7;\n+      let n = n << 8; //~ ERROR: bitshift exceeds the type's number of bits\n+\n+      let n = 1u8 << -8; //~ ERROR: bitshift exceeds the type's number of bits\n \n-      let n = 1u8 << -9; //~ ERROR: bitshift exceeds the type's number of bits\n+      let n = 1u8 << (4+3);\n+      let n = 1u8 << (4+4); //~ ERROR: bitshift exceeds the type's number of bits\n \n-      let n = 1u8 << (4+4);\n-      let n = 1u8 << (4+5); //~ ERROR: bitshift exceeds the type's number of bits\n+      let n = 1i << std::int::BITS; //~ ERROR: bitshift exceeds the type's number of bits\n+      let n = 1u << std::uint::BITS; //~ ERROR: bitshift exceeds the type's number of bits\n }\n "}, {"sha": "5e2ebc3e620d631c5c3e951952ae8e625d1de8ff", "filename": "src/test/compile-fail/trait-impl-1.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Ftest%2Fcompile-fail%2Ftrait-impl-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Ftest%2Fcompile-fail%2Ftrait-impl-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-impl-1.rs?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test calling methods on an impl for a bare trait. This test checks that the\n+// trait impl is only applied to a trait object, not concrete types which implement\n+// the trait.\n+\n+trait T {}\n+\n+impl<'a> T+'a {\n+    fn foo(&self) {}\n+}\n+\n+impl T for int {}\n+\n+fn main() {\n+    let x = &42i;\n+    x.foo(); //~ERROR: type `&int` does not implement any method in scope named `foo`\n+}"}, {"sha": "303e3d937444d48612ce38b788e1f3168f20facb", "filename": "src/test/compile-fail/trait-impl-2.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Ftest%2Fcompile-fail%2Ftrait-impl-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Ftest%2Fcompile-fail%2Ftrait-impl-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-impl-2.rs?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test calling methods on an impl for a bare trait. This test checks trait impls\n+// must be in the same module as the trait.\n+\n+mod Foo {\n+    trait T {}\n+}\n+\n+mod Bar {\n+    impl<'a> ::Foo::T+'a { //~ERROR: inherent implementations may only be implemented in the same\n+        fn foo(&self) {}\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "48813ff142c1895c90d06c86e0fd3bf28a6ba71b", "filename": "src/test/compile-fail/variance-regions-direct.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Ftest%2Fcompile-fail%2Fvariance-regions-direct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Ftest%2Fcompile-fail%2Fvariance-regions-direct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-regions-direct.rs?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -14,7 +14,7 @@\n // Regions that just appear in normal spots are contravariant:\n \n #[rustc_variance]\n-struct Test2<'a, 'b, 'c> { //~ ERROR regions=[[-, -, -];[];[]]\n+struct Test2<'a, 'b, 'c> { //~ ERROR regions=[[-, -, -];[];[];[]]\n     x: &'a int,\n     y: &'b [int],\n     c: &'c str\n@@ -23,7 +23,7 @@ struct Test2<'a, 'b, 'c> { //~ ERROR regions=[[-, -, -];[];[]]\n // Those same annotations in function arguments become covariant:\n \n #[rustc_variance]\n-struct Test3<'a, 'b, 'c> { //~ ERROR regions=[[+, +, +];[];[]]\n+struct Test3<'a, 'b, 'c> { //~ ERROR regions=[[+, +, +];[];[];[]]\n     x: extern \"Rust\" fn(&'a int),\n     y: extern \"Rust\" fn(&'b [int]),\n     c: extern \"Rust\" fn(&'c str),\n@@ -32,15 +32,15 @@ struct Test3<'a, 'b, 'c> { //~ ERROR regions=[[+, +, +];[];[]]\n // Mutability induces invariance:\n \n #[rustc_variance]\n-struct Test4<'a, 'b:'a> { //~ ERROR regions=[[-, o];[];[]]\n+struct Test4<'a, 'b:'a> { //~ ERROR regions=[[-, o];[];[];[]]\n     x: &'a mut &'b int,\n }\n \n // Mutability induces invariance, even when in a\n // contravariant context:\n \n #[rustc_variance]\n-struct Test5<'a, 'b> { //~ ERROR regions=[[+, o];[];[]]\n+struct Test5<'a, 'b> { //~ ERROR regions=[[+, o];[];[];[]]\n     x: extern \"Rust\" fn(&'a mut &'b int),\n }\n \n@@ -50,21 +50,21 @@ struct Test5<'a, 'b> { //~ ERROR regions=[[+, o];[];[]]\n // argument list occurs in an invariant context.\n \n #[rustc_variance]\n-struct Test6<'a, 'b> { //~ ERROR regions=[[-, o];[];[]]\n+struct Test6<'a, 'b> { //~ ERROR regions=[[-, o];[];[];[]]\n     x: &'a mut extern \"Rust\" fn(&'b int),\n }\n \n // No uses at all is bivariant:\n \n #[rustc_variance]\n-struct Test7<'a> { //~ ERROR regions=[[*];[];[]]\n+struct Test7<'a> { //~ ERROR regions=[[*];[];[];[]]\n     x: int\n }\n \n // Try enums too.\n \n #[rustc_variance]\n-enum Test8<'a, 'b, 'c:'b> { //~ ERROR regions=[[+, -, o];[];[]]\n+enum Test8<'a, 'b, 'c:'b> { //~ ERROR regions=[[+, -, o];[];[];[]]\n     Test8A(extern \"Rust\" fn(&'a int)),\n     Test8B(&'b [int]),\n     Test8C(&'b mut &'c str),"}, {"sha": "0e8e52df456afc4142e5914821f5264bfae23565", "filename": "src/test/compile-fail/variance-regions-indirect.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Ftest%2Fcompile-fail%2Fvariance-regions-indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Ftest%2Fcompile-fail%2Fvariance-regions-indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-regions-indirect.rs?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -13,29 +13,29 @@\n // Try enums too.\n \n #[rustc_variance]\n-enum Base<'a, 'b, 'c:'b, 'd> { //~ ERROR regions=[[+, -, o, *];[];[]]\n+enum Base<'a, 'b, 'c:'b, 'd> { //~ ERROR regions=[[+, -, o, *];[];[];[]]\n     Test8A(extern \"Rust\" fn(&'a int)),\n     Test8B(&'b [int]),\n     Test8C(&'b mut &'c str),\n }\n \n #[rustc_variance]\n-struct Derived1<'w, 'x:'y, 'y, 'z> { //~ ERROR regions=[[*, o, -, +];[];[]]\n+struct Derived1<'w, 'x:'y, 'y, 'z> { //~ ERROR regions=[[*, o, -, +];[];[];[]]\n     f: Base<'z, 'y, 'x, 'w>\n }\n \n #[rustc_variance] // Combine - and + to yield o\n-struct Derived2<'a, 'b:'a, 'c> { //~ ERROR regions=[[o, o, *];[];[]]\n+struct Derived2<'a, 'b:'a, 'c> { //~ ERROR regions=[[o, o, *];[];[];[]]\n     f: Base<'a, 'a, 'b, 'c>\n }\n \n #[rustc_variance] // Combine + and o to yield o (just pay attention to 'a here)\n-struct Derived3<'a:'b, 'b, 'c> { //~ ERROR regions=[[o, -, *];[];[]]\n+struct Derived3<'a:'b, 'b, 'c> { //~ ERROR regions=[[o, -, *];[];[];[]]\n     f: Base<'a, 'b, 'a, 'c>\n }\n \n #[rustc_variance] // Combine + and * to yield + (just pay attention to 'a here)\n-struct Derived4<'a, 'b, 'c:'b> { //~ ERROR regions=[[+, -, o];[];[]]\n+struct Derived4<'a, 'b, 'c:'b> { //~ ERROR regions=[[+, -, o];[];[];[]]\n     f: Base<'a, 'b, 'c, 'a>\n }\n "}, {"sha": "c576c5e2edd6465e95111eef0b30c5422e32100c", "filename": "src/test/compile-fail/variance-trait-object-bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Ftest%2Fcompile-fail%2Fvariance-trait-object-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Ftest%2Fcompile-fail%2Fvariance-trait-object-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-trait-object-bound.rs?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -19,7 +19,7 @@ use std::mem;\n trait T { fn foo(); }\n \n #[rustc_variance]\n-struct TOption<'a> { //~ ERROR regions=[[-];[];[]]\n+struct TOption<'a> { //~ ERROR regions=[[-];[];[];[]]\n     v: Option<Box<T + 'a>>,\n }\n "}, {"sha": "026122d1259f697752896e0958952395067abc44", "filename": "src/test/run-pass/issue-15689-2.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Ftest%2Frun-pass%2Fissue-15689-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Ftest%2Frun-pass%2Fissue-15689-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15689-2.rs?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[deriving(Clone)]\n+enum Test<'a> {\n+    Slice(&'a int)\n+}\n+\n+fn main() {}"}, {"sha": "216a7ef33f54ce00ff9bfb71a996420947a95c26", "filename": "src/test/run-pass/trait-impl.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Ftest%2Frun-pass%2Ftrait-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fb413d370f1f1094964ed07b65f97dba52cc30/src%2Ftest%2Frun-pass%2Ftrait-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-impl.rs?ref=82fb413d370f1f1094964ed07b65f97dba52cc30", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test calling methods on an impl for a bare trait.\n+\n+static mut COUNT: uint = 1;\n+\n+trait T {}\n+\n+impl<'a> T+'a {\n+    fn foo(&self) {\n+        unsafe { COUNT *= 2; }\n+    }\n+    fn bar() {\n+        unsafe { COUNT *= 3; }\n+    }\n+}\n+\n+impl T for int {}\n+\n+fn main() {\n+    let x: &T = &42i;\n+\n+    x.foo();\n+    T::foo(x);\n+    T::bar();\n+\n+    unsafe { assert!(COUNT == 12); }\n+}"}]}