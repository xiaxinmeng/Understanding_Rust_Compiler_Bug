{"sha": "ef83742b2bf9cb26c54576dad76418d872b52a99", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmODM3NDJiMmJmOWNiMjZjNTQ1NzZkYWQ3NjQxOGQ4NzJiNTJhOTk=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-08-22T17:25:09Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-09-26T16:16:25Z"}, "message": "Delay bug for non-universal regions in member constraints", "tree": {"sha": "9ce3944bbf9e9aecf9ad13a8479eedae6473a0f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ce3944bbf9e9aecf9ad13a8479eedae6473a0f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef83742b2bf9cb26c54576dad76418d872b52a99", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef83742b2bf9cb26c54576dad76418d872b52a99", "html_url": "https://github.com/rust-lang/rust/commit/ef83742b2bf9cb26c54576dad76418d872b52a99", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef83742b2bf9cb26c54576dad76418d872b52a99/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f9a8a7f9b9732c55511d2a2a3914e8feafc7c52", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f9a8a7f9b9732c55511d2a2a3914e8feafc7c52", "html_url": "https://github.com/rust-lang/rust/commit/6f9a8a7f9b9732c55511d2a2a3914e8feafc7c52"}], "stats": {"total": 29, "additions": 19, "deletions": 10}, "files": [{"sha": "3dc082a4413b3631f58e335217a37b0efd0307c5", "filename": "compiler/rustc_mir/src/borrow_check/region_infer/mod.rs", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ef83742b2bf9cb26c54576dad76418d872b52a99/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef83742b2bf9cb26c54576dad76418d872b52a99/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fmod.rs?ref=ef83742b2bf9cb26c54576dad76418d872b52a99", "patch": "@@ -551,7 +551,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         mir_def_id: DefId,\n         polonius_output: Option<Rc<PoloniusOutput>>,\n     ) -> (Option<ClosureRegionRequirements<'tcx>>, RegionErrors<'tcx>) {\n-        self.propagate_constraints(body);\n+        self.propagate_constraints(body, infcx.tcx);\n \n         let mut errors_buffer = RegionErrors::new();\n \n@@ -599,7 +599,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// for each region variable until all the constraints are\n     /// satisfied. Note that some values may grow **too** large to be\n     /// feasible, but we check this later.\n-    fn propagate_constraints(&mut self, _body: &Body<'tcx>) {\n+    fn propagate_constraints(&mut self, _body: &Body<'tcx>, tcx: TyCtxt<'tcx>) {\n         debug!(\"propagate_constraints()\");\n \n         debug!(\"propagate_constraints: constraints={:#?}\", {\n@@ -617,7 +617,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // own.\n         let constraint_sccs = self.constraint_sccs.clone();\n         for scc in constraint_sccs.all_sccs() {\n-            self.compute_value_for_scc(scc);\n+            self.compute_value_for_scc(scc, tcx);\n         }\n \n         // Sort the applied member constraints so we can binary search\n@@ -629,7 +629,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// computed, by unioning the values of its successors.\n     /// Assumes that all successors have been computed already\n     /// (which is assured by iterating over SCCs in dependency order).\n-    fn compute_value_for_scc(&mut self, scc_a: ConstraintSccIndex) {\n+    fn compute_value_for_scc(&mut self, scc_a: ConstraintSccIndex, tcx: TyCtxt<'tcx>) {\n         let constraint_sccs = self.constraint_sccs.clone();\n \n         // Walk each SCC `B` such that `A: B`...\n@@ -652,7 +652,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // Now take member constraints into account.\n         let member_constraints = self.member_constraints.clone();\n         for m_c_i in member_constraints.indices(scc_a) {\n-            self.apply_member_constraint(scc_a, m_c_i, member_constraints.choice_regions(m_c_i));\n+            self.apply_member_constraint(\n+                tcx,\n+                scc_a,\n+                m_c_i,\n+                member_constraints.choice_regions(m_c_i),\n+            );\n         }\n \n         debug!(\n@@ -675,6 +680,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// If we make any changes, returns true, else false.\n     fn apply_member_constraint(\n         &mut self,\n+        tcx: TyCtxt<'tcx>,\n         scc: ConstraintSccIndex,\n         member_constraint_index: NllMemberConstraintIndex,\n         choice_regions: &[ty::RegionVid],\n@@ -688,12 +694,15 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             // `impl_trait_in_bindings`, I believe, and we are just\n             // opting not to handle it for now. See #61773 for\n             // details.\n-            bug!(\n-                \"member constraint for `{:?}` has an option region `{:?}` \\\n-                 that is not a universal region\",\n-                self.member_constraints[member_constraint_index].opaque_type_def_id,\n-                uh_oh,\n+            tcx.sess.delay_span_bug(\n+                self.member_constraints[member_constraint_index].definition_span,\n+                &format!(\n+                    \"member constraint for `{:?}` has an option region `{:?}` \\\n+                     that is not a universal region\",\n+                    self.member_constraints[member_constraint_index].opaque_type_def_id, uh_oh,\n+                ),\n             );\n+            return false;\n         }\n \n         // Create a mutable vector of the options. We'll try to winnow"}]}