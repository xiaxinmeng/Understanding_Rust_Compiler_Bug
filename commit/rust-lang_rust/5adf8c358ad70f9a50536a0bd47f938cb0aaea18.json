{"sha": "5adf8c358ad70f9a50536a0bd47f938cb0aaea18", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhZGY4YzM1OGFkNzBmOWE1MDUzNmEwYmQ0N2Y5MzhjYjBhYWVhMTg=", "commit": {"author": {"name": "Alexander Regueiro", "email": "alexreg@me.com", "date": "2018-12-26T16:38:35Z"}, "committer": {"name": "Alexander Regueiro", "email": "alexreg@me.com", "date": "2018-12-26T21:56:47Z"}, "message": "Changed resolution of enum variants to low priority.", "tree": {"sha": "2f44bec55577a5b88b36d0b57a4899629638ea2e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2f44bec55577a5b88b36d0b57a4899629638ea2e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5adf8c358ad70f9a50536a0bd47f938cb0aaea18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5adf8c358ad70f9a50536a0bd47f938cb0aaea18", "html_url": "https://github.com/rust-lang/rust/commit/5adf8c358ad70f9a50536a0bd47f938cb0aaea18", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5adf8c358ad70f9a50536a0bd47f938cb0aaea18/comments", "author": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ab239f37aaade0764ee1ace12828d2f766600296", "url": "https://api.github.com/repos/rust-lang/rust/commits/ab239f37aaade0764ee1ace12828d2f766600296", "html_url": "https://github.com/rust-lang/rust/commit/ab239f37aaade0764ee1ace12828d2f766600296"}], "stats": {"total": 101, "additions": 53, "deletions": 48}, "files": [{"sha": "1db7141917f98e7cfdfa386d11f39901e5b53e1d", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5adf8c358ad70f9a50536a0bd47f938cb0aaea18/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5adf8c358ad70f9a50536a0bd47f938cb0aaea18/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=5adf8c358ad70f9a50536a0bd47f938cb0aaea18", "patch": "@@ -1292,28 +1292,11 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n \n         self.prohibit_generics(slice::from_ref(item_segment));\n \n-        // Check if we have an enum variant here.\n-        match ty.sty {\n-            ty::Adt(adt_def, _) if adt_def.is_enum() => {\n-                let variant_def = adt_def.variants.iter().find(|vd| {\n-                    tcx.hygienic_eq(assoc_name, vd.ident, adt_def.did)\n-                });\n-                if let Some(variant_def) = variant_def {\n-                    check_type_alias_enum_variants_enabled(tcx, span);\n-\n-                    let def = Def::Variant(variant_def.did);\n-                    tcx.check_stability(def.def_id(), Some(ref_id), span);\n-                    return (ty, def);\n-                }\n-            },\n-            _ => (),\n-        }\n-\n         // Find the type of the associated item, and the trait where the associated\n         // item is declared.\n         let bound = match (&ty.sty, ty_path_def) {\n             (_, Def::SelfTy(Some(_), Some(impl_def_id))) => {\n-                // `Self` in an impl of a trait -- we have a concrete `self` type and a\n+                // `Self` in an impl of a trait -- we have a concrete self type and a\n                 // trait reference.\n                 let trait_ref = match tcx.impl_trait_ref(impl_def_id) {\n                     Some(trait_ref) => trait_ref,\n@@ -1365,6 +1348,23 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                 return (tcx.types.err, Def::Err);\n             }\n             _ => {\n+                // Check if we have an enum variant.\n+                match ty.sty {\n+                    ty::Adt(adt_def, _) if adt_def.is_enum() => {\n+                        let variant_def = adt_def.variants.iter().find(|vd| {\n+                            tcx.hygienic_eq(assoc_name, vd.ident, adt_def.did)\n+                        });\n+                        if let Some(variant_def) = variant_def {\n+                            check_type_alias_enum_variants_enabled(tcx, span);\n+\n+                            let def = Def::Variant(variant_def.did);\n+                            tcx.check_stability(def.def_id(), Some(ref_id), span);\n+                            return (ty, def);\n+                        }\n+                    },\n+                    _ => (),\n+                }\n+\n                 // Don't print `TyErr` to the user.\n                 if !ty.references_error() {\n                     self.report_ambiguous_associated_type(span,"}, {"sha": "fe5f43e3c01ef7cc56990d7d0a6dcda48e4d78b9", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 33, "deletions": 28, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/5adf8c358ad70f9a50536a0bd47f938cb0aaea18/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5adf8c358ad70f9a50536a0bd47f938cb0aaea18/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=5adf8c358ad70f9a50536a0bd47f938cb0aaea18", "patch": "@@ -371,38 +371,43 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let tcx = self.tcx;\n \n-        // Check if we have an enum variant here.\n-        match self_ty.sty {\n-            ty::Adt(adt_def, _) if adt_def.is_enum() => {\n-                let variant_def = adt_def.variants.iter().find(|vd| {\n-                    tcx.hygienic_eq(method_name, vd.ident, adt_def.did)\n-                });\n-                if let Some(variant_def) = variant_def {\n-                    check_type_alias_enum_variants_enabled(tcx, span);\n-\n-                    let def = Def::VariantCtor(variant_def.did, variant_def.ctor_kind);\n-                    tcx.check_stability(def.def_id(), Some(expr_id), span);\n-                    return Ok(def);\n+        let mode = probe::Mode::Path;\n+        match self.probe_for_name(span, mode, method_name, IsSuggestion(false),\n+                                  self_ty, expr_id, ProbeScope::TraitsInScope) {\n+            Ok(pick) => {\n+                if let Some(import_id) = pick.import_id {\n+                    let import_def_id = tcx.hir().local_def_id(import_id);\n+                    debug!(\"resolve_ufcs: used_trait_import: {:?}\", import_def_id);\n+                    Lrc::get_mut(&mut self.tables.borrow_mut().used_trait_imports)\n+                                                .unwrap().insert(import_def_id);\n                 }\n-            },\n-            _ => (),\n-        }\n \n-        let mode = probe::Mode::Path;\n-        let pick = self.probe_for_name(span, mode, method_name, IsSuggestion(false),\n-                                       self_ty, expr_id, ProbeScope::TraitsInScope)?;\n+                let def = pick.item.def();\n+                tcx.check_stability(def.def_id(), Some(expr_id), span);\n \n-        if let Some(import_id) = pick.import_id {\n-            let import_def_id = tcx.hir().local_def_id(import_id);\n-            debug!(\"resolve_ufcs: used_trait_import: {:?}\", import_def_id);\n-            Lrc::get_mut(&mut self.tables.borrow_mut().used_trait_imports)\n-                                         .unwrap().insert(import_def_id);\n-        }\n-\n-        let def = pick.item.def();\n-        tcx.check_stability(def.def_id(), Some(expr_id), span);\n+                Ok(def)\n+            }\n+            Err(err) => {\n+                // Check if we have an enum variant.\n+                match self_ty.sty {\n+                    ty::Adt(adt_def, _) if adt_def.is_enum() => {\n+                        let variant_def = adt_def.variants.iter().find(|vd| {\n+                            tcx.hygienic_eq(method_name, vd.ident, adt_def.did)\n+                        });\n+                        if let Some(variant_def) = variant_def {\n+                            check_type_alias_enum_variants_enabled(tcx, span);\n+\n+                            let def = Def::VariantCtor(variant_def.did, variant_def.ctor_kind);\n+                            tcx.check_stability(def.def_id(), Some(expr_id), span);\n+                            return Ok(def);\n+                        }\n+                    },\n+                    _ => (),\n+                }\n \n-        Ok(def)\n+                Err(err)\n+            }\n+        }\n     }\n \n     /// Find item with name `item_name` defined in impl/trait `def_id`"}, {"sha": "3750df841720c64efadedf61037598aa6c7b35a3", "filename": "src/test/ui/bogus-tag.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5adf8c358ad70f9a50536a0bd47f938cb0aaea18/src%2Ftest%2Fui%2Fbogus-tag.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5adf8c358ad70f9a50536a0bd47f938cb0aaea18/src%2Ftest%2Fui%2Fbogus-tag.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbogus-tag.stderr?ref=5adf8c358ad70f9a50536a0bd47f938cb0aaea18", "patch": "@@ -1,11 +1,11 @@\n error[E0599]: no variant named `Hsl` found for type `Color` in the current scope\n-  --> $DIR/bogus-tag.rs:7:9\n+  --> $DIR/bogus-tag.rs:7:16\n    |\n LL | enum Color { Rgb(isize, isize, isize), Rgba(isize, isize, isize, isize), }\n    | ---------- variant `Hsl` not found here\n ...\n LL |         Color::Hsl(h, s, l) => { println!(\"hsl\"); }\n-   |         ^^^^^^^^^^^^^^^^^^^ variant not found in `Color`\n+   |         -------^^^--------- variant not found in `Color`\n \n error: aborting due to previous error\n "}]}