{"sha": "2c9d81b2d47d1c8d0e4c771b778238948c269c20", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjOWQ4MWIyZDQ3ZDFjOGQwZTRjNzcxYjc3ODIzODk0OGMyNjljMjA=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-02-02T13:10:36Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-02-11T12:51:21Z"}, "message": "Added lifetime param to Arena.\n\nIt (1.) is invariant, (2.) must strictly outlive the arena itself,\n(3.) constrains the inputs to the arena so that their borrows must\nalso strictly outlive the arena itself.\n\nThis implies that, for now, one can no longer have cross-references\nbetween data allocated via the same `Arena` (even when the data is not\nsubject to the Drop Check rule).  Instead one must carry multiple\n`Arena` instances, or (more commonly), use one or more `TypedArena`\ninstances with enums encoding the different variants of allocated\ndata.", "tree": {"sha": "e1c6b8df6d8acb7549c7306afa4503ef4cd68932", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e1c6b8df6d8acb7549c7306afa4503ef4cd68932"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2c9d81b2d47d1c8d0e4c771b778238948c269c20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2c9d81b2d47d1c8d0e4c771b778238948c269c20", "html_url": "https://github.com/rust-lang/rust/commit/2c9d81b2d47d1c8d0e4c771b778238948c269c20", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2c9d81b2d47d1c8d0e4c771b778238948c269c20/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c1cda0793e4e7b92a73cc13ee6e4a6b14a1b633f", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1cda0793e4e7b92a73cc13ee6e4a6b14a1b633f", "html_url": "https://github.com/rust-lang/rust/commit/c1cda0793e4e7b92a73cc13ee6e4a6b14a1b633f"}], "stats": {"total": 65, "additions": 44, "deletions": 21}, "files": [{"sha": "4cd3d587580f05ed183efc54d8e268dbdb4ea051", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 44, "deletions": 21, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/2c9d81b2d47d1c8d0e4c771b778238948c269c20/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c9d81b2d47d1c8d0e4c771b778238948c269c20/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=2c9d81b2d47d1c8d0e4c771b778238948c269c20", "patch": "@@ -89,27 +89,29 @@ impl Chunk {\n /// than objects without destructors. This reduces overhead when initializing\n /// plain-old-data (`Copy` types) and means we don't need to waste time running\n /// their destructors.\n-pub struct Arena {\n+pub struct Arena<'longer_than_self> {\n     // The head is separated out from the list as a unbenchmarked\n     // microoptimization, to avoid needing to case on the list to access the\n     // head.\n     head: RefCell<Chunk>,\n     copy_head: RefCell<Chunk>,\n     chunks: RefCell<Vec<Chunk>>,\n+    _invariant: marker::InvariantLifetime<'longer_than_self>,\n }\n \n-impl Arena {\n+impl<'a> Arena<'a> {\n     /// Allocates a new Arena with 32 bytes preallocated.\n-    pub fn new() -> Arena {\n+    pub fn new() -> Arena<'a> {\n         Arena::new_with_size(32)\n     }\n \n     /// Allocates a new Arena with `initial_size` bytes preallocated.\n-    pub fn new_with_size(initial_size: usize) -> Arena {\n+    pub fn new_with_size(initial_size: usize) -> Arena<'a> {\n         Arena {\n             head: RefCell::new(chunk(initial_size, false)),\n             copy_head: RefCell::new(chunk(initial_size, true)),\n             chunks: RefCell::new(Vec::new()),\n+            _invariant: marker::InvariantLifetime,\n         }\n     }\n }\n@@ -123,7 +125,7 @@ fn chunk(size: usize, is_copy: bool) -> Chunk {\n }\n \n #[unsafe_destructor]\n-impl Drop for Arena {\n+impl<'longer_than_self> Drop for Arena<'longer_than_self> {\n     fn drop(&mut self) {\n         unsafe {\n             destroy_chunk(&*self.head.borrow());\n@@ -181,7 +183,7 @@ fn un_bitpack_tydesc_ptr(p: usize) -> (*const TyDesc, bool) {\n     ((p & !1) as *const TyDesc, p & 1 == 1)\n }\n \n-impl Arena {\n+impl<'longer_than_self> Arena<'longer_than_self> {\n     fn chunk_size(&self) -> usize {\n         self.copy_head.borrow().capacity()\n     }\n@@ -294,7 +296,7 @@ impl Arena {\n     /// Allocates a new item in the arena, using `op` to initialize the value,\n     /// and returns a reference to it.\n     #[inline]\n-    pub fn alloc<T, F>(&self, op: F) -> &mut T where F: FnOnce() -> T {\n+    pub fn alloc<T:'longer_than_self, F>(&self, op: F) -> &mut T where F: FnOnce() -> T {\n         unsafe {\n             if intrinsics::needs_drop::<T>() {\n                 self.alloc_noncopy(op)\n@@ -318,20 +320,6 @@ fn test_arena_destructors() {\n     }\n }\n \n-#[test]\n-fn test_arena_alloc_nested() {\n-    struct Inner { value: usize }\n-    struct Outer<'a> { inner: &'a Inner }\n-\n-    let arena = Arena::new();\n-\n-    let result = arena.alloc(|| Outer {\n-        inner: arena.alloc(|| Inner { value: 10 })\n-    });\n-\n-    assert_eq!(result.inner.value, 10);\n-}\n-\n #[test]\n #[should_fail]\n fn test_arena_destructors_fail() {\n@@ -529,6 +517,41 @@ mod tests {\n         z: i32,\n     }\n \n+    #[test]\n+    fn test_arena_alloc_nested() {\n+        struct Inner { value: u8 }\n+        struct Outer<'a> { inner: &'a Inner }\n+        enum EI<'e> { I(Inner), O(Outer<'e>) }\n+\n+        struct Wrap<'a>(TypedArena<EI<'a>>);\n+\n+        impl<'a> Wrap<'a> {\n+            fn alloc_inner<F:Fn() -> Inner>(&self, f: F) -> &Inner {\n+                let r: &EI = self.0.alloc(EI::I(f()));\n+                if let &EI::I(ref i) = r {\n+                    i\n+                } else {\n+                    panic!(\"mismatch\");\n+                }\n+            }\n+            fn alloc_outer<F:Fn() -> Outer<'a>>(&self, f: F) -> &Outer {\n+                let r: &EI = self.0.alloc(EI::O(f()));\n+                if let &EI::O(ref o) = r {\n+                    o\n+                } else {\n+                    panic!(\"mismatch\");\n+                }\n+            }\n+        }\n+\n+        let arena = Wrap(TypedArena::new());\n+\n+        let result = arena.alloc_outer(|| Outer {\n+            inner: arena.alloc_inner(|| Inner { value: 10 }) });\n+\n+        assert_eq!(result.inner.value, 10);\n+    }\n+\n     #[test]\n     pub fn test_copy() {\n         let arena = TypedArena::new();"}]}