{"sha": "aa5ca282b20391c6df51fdfa94e0de5672ccfac1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhNWNhMjgyYjIwMzkxYzZkZjUxZmRmYTk0ZTBkZTU2NzJjY2ZhYzE=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-05-01T04:05:02Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-05-01T05:14:52Z"}, "message": "Get tests passing", "tree": {"sha": "1fd6173e8a28f661250856b4367401c5eaec4534", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1fd6173e8a28f661250856b4367401c5eaec4534"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa5ca282b20391c6df51fdfa94e0de5672ccfac1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa5ca282b20391c6df51fdfa94e0de5672ccfac1", "html_url": "https://github.com/rust-lang/rust/commit/aa5ca282b20391c6df51fdfa94e0de5672ccfac1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa5ca282b20391c6df51fdfa94e0de5672ccfac1/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b2ddd937b20d8fc26132cb7ec665784422d92926", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2ddd937b20d8fc26132cb7ec665784422d92926", "html_url": "https://github.com/rust-lang/rust/commit/b2ddd937b20d8fc26132cb7ec665784422d92926"}], "stats": {"total": 116, "additions": 35, "deletions": 81}, "files": [{"sha": "4a54b36f8c4f35f831e2553a42e556a7fd69efd2", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aa5ca282b20391c6df51fdfa94e0de5672ccfac1/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5ca282b20391c6df51fdfa94e0de5672ccfac1/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=aa5ca282b20391c6df51fdfa94e0de5672ccfac1", "patch": "@@ -398,7 +398,8 @@ impl<'a> TraitDef<'a> {\n                                              generics)\n                     }\n                     _ => {\n-                        cx.span_err(mitem.span, \"`derive` may only be applied to structs and enums\");\n+                        cx.span_err(mitem.span,\n+                                    \"`derive` may only be applied to structs and enums\");\n                         return;\n                     }\n                 };\n@@ -417,7 +418,7 @@ impl<'a> TraitDef<'a> {\n                 })))\n             }\n             _ => {\n-                cx.span_err(mitem.span, \"`derive` may only be applied to structs and enums\");                \n+                cx.span_err(mitem.span, \"`derive` may only be applied to structs and enums\");\n             }\n         }\n     }"}, {"sha": "433a15795b3c65583601d30941bbfeb860582e94", "filename": "src/test/auxiliary/custom_derive_plugin.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/aa5ca282b20391c6df51fdfa94e0de5672ccfac1/src%2Ftest%2Fauxiliary%2Fcustom_derive_plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5ca282b20391c6df51fdfa94e0de5672ccfac1/src%2Ftest%2Fauxiliary%2Fcustom_derive_plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcustom_derive_plugin.rs?ref=aa5ca282b20391c6df51fdfa94e0de5672ccfac1", "patch": "@@ -19,7 +19,7 @@ extern crate rustc;\n \n use syntax::ast;\n use syntax::codemap::Span;\n-use syntax::ext::base::{Decorator, ExtCtxt};\n+use syntax::ext::base::{Decorator, ExtCtxt, Annotatable};\n use syntax::ext::build::AstBuilder;\n use syntax::ext::deriving::generic::{cs_fold, TraitDef, MethodDef, combine_substructure};\n use syntax::ext::deriving::generic::ty::{Literal, LifetimeBounds, Path, borrowed_explicit_self};\n@@ -70,5 +70,13 @@ fn expand(cx: &mut ExtCtxt,\n         ],\n     };\n \n-    trait_def.expand(cx, mitem, item, push)\n+    trait_def.expand(cx,\n+                     mitem,\n+                     Annotatable::Item(P(item.clone())),\n+                     &mut |i| {\n+                        match i {\n+                            Annotatable::Item(i) => push(i),\n+                            _ => panic!(\"Not an item\")\n+                        }\n+                     })\n }"}, {"sha": "53a6672d4888deb4cf5d6cbeb0ffd9206fc51bac", "filename": "src/test/auxiliary/macro_crate_test.rs", "status": "modified", "additions": 16, "deletions": 74, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/aa5ca282b20391c6df51fdfa94e0de5672ccfac1/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5ca282b20391c6df51fdfa94e0de5672ccfac1/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs?ref=aa5ca282b20391c6df51fdfa94e0de5672ccfac1", "patch": "@@ -10,13 +10,12 @@\n \n // force-host\n \n-#![feature(plugin_registrar, quote)]\n-#![feature(box_syntax, rustc_private)]\n+#![feature(plugin_registrar, quote, rustc_private)]\n \n extern crate syntax;\n extern crate rustc;\n \n-use syntax::ast::{self, TokenTree, Item, MetaItem, Method, ImplItem, TraitItem};\n+use syntax::ast::{self, TokenTree, Item, MetaItem, ImplItem, TraitItem};\n use syntax::codemap::Span;\n use syntax::ext::base::*;\n use syntax::parse::{self, token};\n@@ -25,7 +24,6 @@ use rustc::plugin::Registry;\n \n #[macro_export]\n macro_rules! exported_macro { () => (2) }\n-\n macro_rules! unexported_macro { () => (3) }\n \n #[plugin_registrar]\n@@ -42,7 +40,8 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         MultiModifier(Box::new(expand_into_foo_multi)));\n     reg.register_syntax_extension(\n         token::intern(\"duplicate\"),\n-        MultiDecorator(box expand_duplicate));\n+        // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n+        MultiDecorator(Box::new(expand_duplicate)));\n }\n \n fn expand_make_a_1(cx: &mut ExtCtxt, sp: Span, tts: &[TokenTree])\n@@ -109,13 +108,13 @@ fn expand_into_foo_multi(cx: &mut ExtCtxt,\n fn expand_duplicate(cx: &mut ExtCtxt,\n                     sp: Span,\n                     mi: &MetaItem,\n-                    it: &Annotatable,\n-                    mut push: Box<FnMut(Annotatable)>)\n+                    it: Annotatable,\n+                    push: &mut FnMut(Annotatable))\n {\n     let copy_name = match mi.node {\n         ast::MetaItem_::MetaList(_, ref xs) => {\n             if let ast::MetaItem_::MetaWord(ref w) = xs[0].node {\n-                token::str_to_ident(w.get())\n+                token::str_to_ident(&w)\n             } else {\n                 cx.span_err(mi.span, \"Expected word\");\n                 return;\n@@ -136,75 +135,18 @@ fn expand_duplicate(cx: &mut ExtCtxt,\n             push(Annotatable::Item(P(new_it)));\n         }\n         Annotatable::ImplItem(it) => {\n-            match it {\n-                ImplItem::MethodImplItem(m) => {\n-                    let mut new_m = (*m).clone();\n-                    new_m.attrs.clear();\n-                    replace_method_name(&mut new_m.node, copy_name);\n-                    push(Annotatable::ImplItem(ImplItem::MethodImplItem(P(new_m))));\n-                }\n-                ImplItem::TypeImplItem(t) => {\n-                    let mut new_t = (*t).clone();\n-                    new_t.attrs.clear();\n-                    new_t.ident = copy_name;\n-                    push(Annotatable::ImplItem(ImplItem::TypeImplItem(P(new_t))));\n-                }\n-            }\n-        }\n-        Annotatable::TraitItem(it) => {\n-            match it {\n-                TraitItem::RequiredMethod(rm) => {\n-                    let mut new_rm = rm.clone();\n-                    new_rm.attrs.clear();\n-                    new_rm.ident = copy_name;\n-                    push(Annotatable::TraitItem(TraitItem::RequiredMethod(new_rm)));\n-                }\n-                TraitItem::ProvidedMethod(pm) => {\n-                    let mut new_pm = (*pm).clone();\n-                    new_pm.attrs.clear();\n-                    replace_method_name(&mut new_pm.node, copy_name);\n-                    push(Annotatable::TraitItem(TraitItem::ProvidedMethod(P(new_pm))));\n-                }\n-                TraitItem::TypeTraitItem(t) => {\n-                    let mut new_t = (*t).clone();\n-                    new_t.attrs.clear();\n-                    new_t.ty_param.ident = copy_name;\n-                    push(Annotatable::TraitItem(TraitItem::TypeTraitItem(P(new_t))));\n-                }\n-            }\n+            let mut new_it = (*it).clone();\n+            new_it.attrs.clear();\n+            new_it.ident = copy_name;\n+            push(Annotatable::ImplItem(P(new_it)));\n         }\n-    }\n-\n-    fn replace_method_name(m: &mut ast::Method_, i: ast::Ident) {\n-        if let &mut ast::Method_::MethDecl(ref mut ident, _, _, _, _, _, _, _) = m {\n-            *ident = i\n+        Annotatable::TraitItem(tt) => {\n+            let mut new_it = (*tt).clone();\n+            new_it.attrs.clear();\n+            new_it.ident = copy_name;\n+            push(Annotatable::TraitItem(P(new_it)));\n         }\n     }\n }\n \n-fn expand_forged_ident(cx: &mut ExtCtxt, sp: Span, tts: &[TokenTree]) -> Box<MacResult+'static> {\n-    use syntax::ext::quote::rt::*;\n-\n-    if !tts.is_empty() {\n-        cx.span_fatal(sp, \"forged_ident takes no arguments\");\n-    }\n-\n-    // Most of this is modelled after the expansion of the `quote_expr!`\n-    // macro ...\n-    let parse_sess = cx.parse_sess();\n-    let cfg = cx.cfg();\n-\n-    // ... except this is where we inject a forged identifier,\n-    // and deliberately do not call `cx.parse_tts_with_hygiene`\n-    // (because we are testing that this will be *rejected*\n-    //  by the default parser).\n-\n-    let expr = {\n-        let tt = cx.parse_tts(\"\\x00name_2,ctxt_0\\x00\".to_string());\n-        let mut parser = new_parser_from_tts(parse_sess, cfg, tt);\n-        parser.parse_expr()\n-    };\n-    MacEager::expr(expr)\n-}\n-\n pub fn foo() {}"}, {"sha": "3c215b6ca48dd5a1e7a38397883977e914cbbbf5", "filename": "src/test/run-pass-fulldeps/macro-crate-multi-decorator.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/aa5ca282b20391c6df51fdfa94e0de5672ccfac1/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate-multi-decorator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5ca282b20391c6df51fdfa94e0de5672ccfac1/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate-multi-decorator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate-multi-decorator.rs?ref=aa5ca282b20391c6df51fdfa94e0de5672ccfac1", "patch": "@@ -11,12 +11,15 @@\n // aux-build:macro_crate_test.rs\n // ignore-stage1\n \n-#![feature(plugin)]\n+#![feature(plugin, custom_attribute)]\n+#![plugin(macro_crate_test)]\n \n-#[plugin] #[no_link]\n+#[macro_use]\n+#[no_link]\n extern crate macro_crate_test;\n \n-// The duplicate macro will create a copy of the item with the given identifier\n+// The duplicate macro will create a copy of the item with the given identifier.\n+\n #[duplicate(MyCopy)]\n struct MyStruct {\n     number: i32"}]}