{"sha": "1de0dd9531bfae1db458c0d88830a5c09203a100", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkZTBkZDk1MzFiZmFlMWRiNDU4YzBkODg4MzBhNWMwOTIwM2ExMDA=", "commit": {"author": {"name": "csmoe", "email": "csmoe@msn.com", "date": "2020-08-16T12:25:22Z"}, "committer": {"name": "csmoe", "email": "csmoe@msn.com", "date": "2020-08-25T06:00:49Z"}, "message": "suggest await on field access", "tree": {"sha": "08e7825ab56c86dec2c81e755f0dbc9d2ac80c95", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/08e7825ab56c86dec2c81e755f0dbc9d2ac80c95"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1de0dd9531bfae1db458c0d88830a5c09203a100", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1de0dd9531bfae1db458c0d88830a5c09203a100", "html_url": "https://github.com/rust-lang/rust/commit/1de0dd9531bfae1db458c0d88830a5c09203a100", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1de0dd9531bfae1db458c0d88830a5c09203a100/comments", "author": {"login": "csmoe", "id": 35686186, "node_id": "MDQ6VXNlcjM1Njg2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/35686186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/csmoe", "html_url": "https://github.com/csmoe", "followers_url": "https://api.github.com/users/csmoe/followers", "following_url": "https://api.github.com/users/csmoe/following{/other_user}", "gists_url": "https://api.github.com/users/csmoe/gists{/gist_id}", "starred_url": "https://api.github.com/users/csmoe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/csmoe/subscriptions", "organizations_url": "https://api.github.com/users/csmoe/orgs", "repos_url": "https://api.github.com/users/csmoe/repos", "events_url": "https://api.github.com/users/csmoe/events{/privacy}", "received_events_url": "https://api.github.com/users/csmoe/received_events", "type": "User", "site_admin": false}, "committer": {"login": "csmoe", "id": 35686186, "node_id": "MDQ6VXNlcjM1Njg2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/35686186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/csmoe", "html_url": "https://github.com/csmoe", "followers_url": "https://api.github.com/users/csmoe/followers", "following_url": "https://api.github.com/users/csmoe/following{/other_user}", "gists_url": "https://api.github.com/users/csmoe/gists{/gist_id}", "starred_url": "https://api.github.com/users/csmoe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/csmoe/subscriptions", "organizations_url": "https://api.github.com/users/csmoe/orgs", "repos_url": "https://api.github.com/users/csmoe/repos", "events_url": "https://api.github.com/users/csmoe/events{/privacy}", "received_events_url": "https://api.github.com/users/csmoe/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d30de6202ea38a204849191cf9723600e522416", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d30de6202ea38a204849191cf9723600e522416", "html_url": "https://github.com/rust-lang/rust/commit/1d30de6202ea38a204849191cf9723600e522416"}], "stats": {"total": 147, "additions": 106, "deletions": 41}, "files": [{"sha": "91f5757adf7c7eb2a08158b6eccac7ee3905db6d", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 73, "deletions": 1, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/1de0dd9531bfae1db458c0d88830a5c09203a100/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de0dd9531bfae1db458c0d88830a5c09203a100/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=1de0dd9531bfae1db458c0d88830a5c09203a100", "patch": "@@ -31,13 +31,14 @@ use rustc_infer::infer;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_middle::ty;\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, AllowTwoPhase};\n+use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::Ty;\n use rustc_middle::ty::TypeFoldable;\n use rustc_middle::ty::{AdtKind, Visibility};\n use rustc_span::hygiene::DesugaringKind;\n use rustc_span::source_map::Span;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n-use rustc_trait_selection::traits::{self, ObligationCauseCode};\n+use rustc_trait_selection::traits::{self, ObligationCauseCode, SelectionContext};\n \n use std::fmt::Display;\n \n@@ -1509,13 +1510,81 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.tcx().ty_error()\n     }\n \n+    fn suggest_await_on_field_access(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        field_ident: Ident,\n+        base: &'tcx hir::Expr<'tcx>,\n+        expr: &'tcx hir::Expr<'tcx>,\n+        def_id: DefId,\n+        substs: SubstsRef<'tcx>,\n+    ) {\n+        let param_env = self.tcx().param_env(def_id);\n+        let future_trait = self.tcx.require_lang_item(lang_items::FutureTraitLangItem, None);\n+        let future_trait_ref = ty::TraitRef { def_id: future_trait, substs };\n+        // Future::Output\n+        let future_projection = ty::ProjectionTy::from_ref_and_name(\n+            self.tcx,\n+            future_trait_ref,\n+            Ident::with_dummy_span(sym::Output),\n+        );\n+\n+        let mut projection_ty = None;\n+        for (predicate, _) in self.tcx.predicates_of(def_id).predicates {\n+            if let ty::PredicateAtom::Projection(projection_predicate) = predicate.skip_binders() {\n+                if future_projection.item_def_id == projection_predicate.projection_ty.item_def_id {\n+                    projection_ty = Some(projection_predicate.projection_ty);\n+                    break;\n+                }\n+            }\n+        }\n+        debug!(\"suggest_await_on_field_access: projection_ty={:?}\", projection_ty);\n+\n+        let cause = self.misc(expr.span);\n+        let mut selcx = SelectionContext::new(&self.infcx);\n+\n+        let mut obligations = vec![];\n+        if let Some(projection_ty) = projection_ty {\n+            let normalized_ty = rustc_trait_selection::traits::normalize_projection_type(\n+                &mut selcx,\n+                param_env,\n+                projection_ty,\n+                cause,\n+                0,\n+                &mut obligations,\n+            );\n+            debug!(\n+                \"suggest_await_on_field_access: normalized_ty={:?}, ty_kind={:?}\",\n+                self.resolve_vars_if_possible(&normalized_ty),\n+                normalized_ty.kind,\n+            );\n+            if let ty::Adt(def, _) = normalized_ty.kind {\n+                if def.non_enum_variant().fields.iter().any(|field| field.ident == field_ident) {\n+                    if let Ok(base) = self.tcx.sess.source_map().span_to_snippet(base.span) {\n+                        let suggestion = format!(\"{}.await.{}\", base, field_ident);\n+                        err.span_suggestion(\n+                            expr.span,\n+                            \"consider await before field access\",\n+                            suggestion,\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     fn ban_nonexisting_field(\n         &self,\n         field: Ident,\n         base: &'tcx hir::Expr<'tcx>,\n         expr: &'tcx hir::Expr<'tcx>,\n         expr_t: Ty<'tcx>,\n     ) {\n+        debug!(\n+            \"ban_nonexisting_field: field={:?}, base={:?}, expr={:?}, expr_ty={:?}\",\n+            field, base, expr, expr_t\n+        );\n         let mut err = self.no_such_field_err(field.span, field, expr_t);\n \n         match expr_t.peel_refs().kind {\n@@ -1531,6 +1600,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ty::Param(param_ty) => {\n                 self.point_at_param_definition(&mut err, param_ty);\n             }\n+            ty::Opaque(def_id, subts) => {\n+                self.suggest_await_on_field_access(&mut err, field, base, expr, def_id, subts);\n+            }\n             _ => {}\n         }\n "}, {"sha": "aead0ab438f20c3a0cd787bb52e56a7459ca828e", "filename": "src/test/ui/async-await/issue-61076.rs", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1de0dd9531bfae1db458c0d88830a5c09203a100/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de0dd9531bfae1db458c0d88830a5c09203a100/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.rs?ref=1de0dd9531bfae1db458c0d88830a5c09203a100", "patch": "@@ -6,14 +6,20 @@ use core::task::{Context, Poll};\n \n struct T;\n \n-struct UnionStruct(i32);\n+struct Tuple(i32);\n \n struct Struct {\n     a: i32\n }\n \n-enum Enum {\n-    A\n+impl Future for Struct {\n+    type Output = Struct;\n+    fn poll(self: Pin<&mut Self>, _: &mut Context<'_>) -> Poll<Self::Output> { Poll::Pending }\n+}\n+\n+impl Future for Tuple {\n+    type Output = Tuple;\n+    fn poll(self: Pin<&mut Self>, _: &mut Context<'_>) -> Poll<Self::Output> { Poll::Pending }\n }\n \n impl Future for T {\n@@ -33,19 +39,21 @@ async fn bar() -> Result<(), ()> {\n     Ok(())\n }\n \n+async fn struct_() -> Struct {\n+    Struct { a: 1 }\n+}\n+\n+async fn tuple() -> Tuple {\n+    Tuple(1i32)\n+}\n+\n async fn baz() -> Result<(), ()> {\n     let t = T;\n     t?; //~ ERROR the `?` operator can only be applied to values that implement `std::ops::Try`\n \n-    let _: i32 = async {\n-        UnionStruct(1i32)\n-    }.0; //~ ERROR no field `0`\n-\n-    let _: i32 = async {\n-        Struct { a: 1i32 }\n-    }.a; //~ ERROR no field `a`\n+    let _: i32 = tuple().0; //~ ERROR no field `0`\n \n-    if let Enum::A = async { Enum::A } {} //~ ERROR mismatched type\n+    let _: i32 = struct_().a; //~ ERROR no field `a`\n \n     Ok(())\n }"}, {"sha": "df4e2b8e810ddc53db3189ca0451d55eb2a33191", "filename": "src/test/ui/async-await/issue-61076.stderr", "status": "modified", "additions": 14, "deletions": 29, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/1de0dd9531bfae1db458c0d88830a5c09203a100/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1de0dd9531bfae1db458c0d88830a5c09203a100/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.stderr?ref=1de0dd9531bfae1db458c0d88830a5c09203a100", "patch": "@@ -1,5 +1,5 @@\n error[E0277]: the `?` operator can only be applied to values that implement `std::ops::Try`\n-  --> $DIR/issue-61076.rs:32:5\n+  --> $DIR/issue-61076.rs:38:5\n    |\n LL |     foo()?;\n    |     ^^^^^^\n@@ -11,7 +11,7 @@ LL |     foo()?;\n    = note: required by `std::ops::Try::into_result`\n \n error[E0277]: the `?` operator can only be applied to values that implement `std::ops::Try`\n-  --> $DIR/issue-61076.rs:38:5\n+  --> $DIR/issue-61076.rs:52:5\n    |\n LL |     t?;\n    |     ^^\n@@ -23,37 +23,22 @@ LL |     t?;\n    = note: required by `std::ops::Try::into_result`\n \n error[E0609]: no field `0` on type `impl std::future::Future`\n-  --> $DIR/issue-61076.rs:42:7\n+  --> $DIR/issue-61076.rs:54:26\n    |\n-LL |     }.0;\n-   |       ^\n+LL |     let _: i32 = tuple().0;\n+   |                  --------^\n+   |                  |\n+   |                  help: consider await before field access: `tuple().await.0`\n \n error[E0609]: no field `a` on type `impl std::future::Future`\n-  --> $DIR/issue-61076.rs:46:7\n-   |\n-LL |     }.a;\n-   |       ^\n-\n-error[E0308]: mismatched types\n-  --> $DIR/issue-61076.rs:48:12\n-   |\n-LL |     A\n-   |     - unit variant defined here\n-...\n-LL |     if let Enum::A = async { Enum::A } {}\n-   |            ^^^^^^^         ----------- the expected generator\n-   |            |\n-   |            expected opaque type, found enum `Enum`\n-   | \n-  ::: $SRC_DIR/libcore/future/mod.rs:LL:COL\n-   |\n-LL | pub const fn from_generator<T>(gen: T) -> impl Future<Output = T::Return>\n-   |                                           ------------------------------- the expected opaque type\n+  --> $DIR/issue-61076.rs:56:28\n    |\n-   = note: expected opaque type `impl std::future::Future`\n-                     found enum `Enum`\n+LL |     let _: i32 = struct_().a;\n+   |                  ----------^\n+   |                  |\n+   |                  help: consider await before field access: `struct_().await.a`\n \n-error: aborting due to 5 previous errors\n+error: aborting due to 4 previous errors\n \n-Some errors have detailed explanations: E0277, E0308, E0609.\n+Some errors have detailed explanations: E0277, E0609.\n For more information about an error, try `rustc --explain E0277`."}]}