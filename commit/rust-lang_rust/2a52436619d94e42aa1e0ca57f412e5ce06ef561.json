{"sha": "2a52436619d94e42aa1e0ca57f412e5ce06ef561", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhNTI0MzY2MTlkOTRlNDJhYTFlMGNhNTdmNDEyZTVjZTA2ZWY1NjE=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-03-18T19:30:02Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-03-26T08:22:45Z"}, "message": "Generalise QueryJobId.", "tree": {"sha": "0bd7de6b26b0e5983464490169a2df8a980a48c2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0bd7de6b26b0e5983464490169a2df8a980a48c2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2a52436619d94e42aa1e0ca57f412e5ce06ef561", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2a52436619d94e42aa1e0ca57f412e5ce06ef561", "html_url": "https://github.com/rust-lang/rust/commit/2a52436619d94e42aa1e0ca57f412e5ce06ef561", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2a52436619d94e42aa1e0ca57f412e5ce06ef561/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee9781cea03142b23ee609096b18d03aeaf1648b", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee9781cea03142b23ee609096b18d03aeaf1648b", "html_url": "https://github.com/rust-lang/rust/commit/ee9781cea03142b23ee609096b18d03aeaf1648b"}], "stats": {"total": 60, "additions": 30, "deletions": 30}, "files": [{"sha": "3d4806f53be7992a2abe460b69af336c11e3b371", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a52436619d94e42aa1e0ca57f412e5ce06ef561/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a52436619d94e42aa1e0ca57f412e5ce06ef561/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=2a52436619d94e42aa1e0ca57f412e5ce06ef561", "patch": "@@ -1603,7 +1603,7 @@ nop_list_lift! {substs; GenericArg<'a> => GenericArg<'tcx>}\n pub mod tls {\n     use super::{ptr_eq, GlobalCtxt, TyCtxt};\n \n-    use crate::dep_graph::TaskDeps;\n+    use crate::dep_graph::{DepKind, TaskDeps};\n     use crate::ty::query;\n     use rustc_data_structures::sync::{self, Lock};\n     use rustc_data_structures::thin_vec::ThinVec;\n@@ -1630,7 +1630,7 @@ pub mod tls {\n \n         /// The current query job, if any. This is updated by `JobOwner::start` in\n         /// `ty::query::plumbing` when executing a query.\n-        pub query: Option<query::QueryJobId>,\n+        pub query: Option<query::QueryJobId<DepKind>>,\n \n         /// Where to store diagnostics for the current query job, if any.\n         /// This is updated by `JobOwner::start` in `ty::query::plumbing` when executing a query."}, {"sha": "488615c7443f29f448dfd29e5062d38c4a085b3c", "filename": "src/librustc/ty/query/job.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/2a52436619d94e42aa1e0ca57f412e5ce06ef561/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a52436619d94e42aa1e0ca57f412e5ce06ef561/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs?ref=2a52436619d94e42aa1e0ca57f412e5ce06ef561", "patch": "@@ -34,26 +34,26 @@ pub struct QueryInfo<CTX: QueryContext> {\n     pub query: CTX::Query,\n }\n \n-type QueryMap<'tcx> = FxHashMap<QueryJobId, QueryJobInfo<TyCtxt<'tcx>>>;\n+type QueryMap<'tcx> = FxHashMap<QueryJobId<DepKind>, QueryJobInfo<TyCtxt<'tcx>>>;\n \n /// A value uniquely identifiying an active query job within a shard in the query cache.\n #[derive(Copy, Clone, Eq, PartialEq, Hash)]\n pub struct QueryShardJobId(pub NonZeroU32);\n \n /// A value uniquely identifiying an active query job.\n #[derive(Copy, Clone, Eq, PartialEq, Hash)]\n-pub struct QueryJobId {\n+pub struct QueryJobId<K> {\n     /// Which job within a shard is this\n     pub job: QueryShardJobId,\n \n     /// In which shard is this job\n     pub shard: u16,\n \n     /// What kind of query this job is\n-    pub kind: DepKind,\n+    pub kind: K,\n }\n \n-impl QueryJobId {\n+impl QueryJobId<DepKind> {\n     pub fn new(job: QueryShardJobId, shard: usize, kind: DepKind) -> Self {\n         QueryJobId { job, shard: u16::try_from(shard).unwrap(), kind }\n     }\n@@ -68,7 +68,7 @@ impl QueryJobId {\n     }\n \n     #[cfg(parallel_compiler)]\n-    fn parent(self, map: &QueryMap<'_>) -> Option<QueryJobId> {\n+    fn parent(self, map: &QueryMap<'_>) -> Option<QueryJobId<DepKind>> {\n         map.get(&self).unwrap().job.parent\n     }\n \n@@ -92,7 +92,7 @@ pub struct QueryJob<CTX: QueryContext> {\n     pub span: Span,\n \n     /// The parent query job which created this job and is implicitly waiting on it.\n-    pub parent: Option<QueryJobId>,\n+    pub parent: Option<QueryJobId<CTX::DepKind>>,\n \n     /// The latch that is used to wait on this job.\n     #[cfg(parallel_compiler)]\n@@ -103,7 +103,7 @@ pub struct QueryJob<CTX: QueryContext> {\n \n impl<CTX: QueryContext> QueryJob<CTX> {\n     /// Creates a new query job.\n-    pub fn new(id: QueryShardJobId, span: Span, parent: Option<QueryJobId>) -> Self {\n+    pub fn new(id: QueryShardJobId, span: Span, parent: Option<QueryJobId<CTX::DepKind>>) -> Self {\n         QueryJob {\n             id,\n             span,\n@@ -115,15 +115,15 @@ impl<CTX: QueryContext> QueryJob<CTX> {\n     }\n \n     #[cfg(parallel_compiler)]\n-    pub(super) fn latch(&mut self, _id: QueryJobId) -> QueryLatch<CTX> {\n+    pub(super) fn latch(&mut self, _id: QueryJobId<CTX::DepKind>) -> QueryLatch<CTX> {\n         if self.latch.is_none() {\n             self.latch = Some(QueryLatch::new());\n         }\n         self.latch.as_ref().unwrap().clone()\n     }\n \n     #[cfg(not(parallel_compiler))]\n-    pub(super) fn latch(&mut self, id: QueryJobId) -> QueryLatch<CTX> {\n+    pub(super) fn latch(&mut self, id: QueryJobId<CTX::DepKind>) -> QueryLatch<CTX> {\n         QueryLatch { id, dummy: PhantomData }\n     }\n \n@@ -139,8 +139,8 @@ impl<CTX: QueryContext> QueryJob<CTX> {\n \n #[cfg(not(parallel_compiler))]\n #[derive(Clone)]\n-pub(super) struct QueryLatch<CTX> {\n-    id: QueryJobId,\n+pub(super) struct QueryLatch<CTX: QueryContext> {\n+    id: QueryJobId<CTX::DepKind>,\n     dummy: PhantomData<CTX>,\n }\n \n@@ -187,7 +187,7 @@ impl<'tcx> QueryLatch<TyCtxt<'tcx>> {\n \n #[cfg(parallel_compiler)]\n struct QueryWaiter<CTX: QueryContext> {\n-    query: Option<QueryJobId>,\n+    query: Option<QueryJobId<CTX::DepKind>>,\n     condvar: Condvar,\n     span: Span,\n     cycle: Lock<Option<CycleError<CTX>>>,\n@@ -297,7 +297,7 @@ impl<CTX: QueryContext> QueryLatch<CTX> {\n \n /// A resumable waiter of a query. The usize is the index into waiters in the query's latch\n #[cfg(parallel_compiler)]\n-type Waiter = (QueryJobId, usize);\n+type Waiter = (QueryJobId<DepKind>, usize);\n \n /// Visits all the non-resumable and resumable waiters of a query.\n /// Only waiters in a query are visited.\n@@ -311,11 +311,11 @@ type Waiter = (QueryJobId, usize);\n #[cfg(parallel_compiler)]\n fn visit_waiters<'tcx, F>(\n     query_map: &QueryMap<'tcx>,\n-    query: QueryJobId,\n+    query: QueryJobId<DepKind>,\n     mut visit: F,\n ) -> Option<Option<Waiter>>\n where\n-    F: FnMut(Span, QueryJobId) -> Option<Option<Waiter>>,\n+    F: FnMut(Span, QueryJobId<DepKind>) -> Option<Option<Waiter>>,\n {\n     // Visit the parent query which is a non-resumable waiter since it's on the same stack\n     if let Some(parent) = query.parent(query_map) {\n@@ -346,10 +346,10 @@ where\n #[cfg(parallel_compiler)]\n fn cycle_check<'tcx>(\n     query_map: &QueryMap<'tcx>,\n-    query: QueryJobId,\n+    query: QueryJobId<DepKind>,\n     span: Span,\n-    stack: &mut Vec<(Span, QueryJobId)>,\n-    visited: &mut FxHashSet<QueryJobId>,\n+    stack: &mut Vec<(Span, QueryJobId<DepKind>)>,\n+    visited: &mut FxHashSet<QueryJobId<DepKind>>,\n ) -> Option<Option<Waiter>> {\n     if !visited.insert(query) {\n         return if let Some(p) = stack.iter().position(|q| q.1 == query) {\n@@ -387,8 +387,8 @@ fn cycle_check<'tcx>(\n #[cfg(parallel_compiler)]\n fn connected_to_root<'tcx>(\n     query_map: &QueryMap<'tcx>,\n-    query: QueryJobId,\n-    visited: &mut FxHashSet<QueryJobId>,\n+    query: QueryJobId<DepKind>,\n+    visited: &mut FxHashSet<QueryJobId<DepKind>>,\n ) -> bool {\n     // We already visited this or we're deliberately ignoring it\n     if !visited.insert(query) {\n@@ -408,7 +408,7 @@ fn connected_to_root<'tcx>(\n \n // Deterministically pick an query from a list\n #[cfg(parallel_compiler)]\n-fn pick_query<'a, 'tcx, T, F: Fn(&T) -> (Span, QueryJobId)>(\n+fn pick_query<'a, 'tcx, T, F: Fn(&T) -> (Span, QueryJobId<DepKind>)>(\n     query_map: &QueryMap<'tcx>,\n     tcx: TyCtxt<'tcx>,\n     queries: &'a [T],\n@@ -440,7 +440,7 @@ fn pick_query<'a, 'tcx, T, F: Fn(&T) -> (Span, QueryJobId)>(\n #[cfg(parallel_compiler)]\n fn remove_cycle<'tcx>(\n     query_map: &QueryMap<'tcx>,\n-    jobs: &mut Vec<QueryJobId>,\n+    jobs: &mut Vec<QueryJobId<DepKind>>,\n     wakelist: &mut Vec<Lrc<QueryWaiter<TyCtxt<'tcx>>>>,\n     tcx: TyCtxt<'tcx>,\n ) -> bool {\n@@ -495,7 +495,7 @@ fn remove_cycle<'tcx>(\n                     }\n                 }\n             })\n-            .collect::<Vec<(Span, QueryJobId, Option<(Span, QueryJobId)>)>>();\n+            .collect::<Vec<(Span, QueryJobId<DepKind>, Option<(Span, QueryJobId<DepKind>)>)>>();\n \n         // Deterministically pick an entry point\n         let (_, entry_point, usage) = pick_query(query_map, tcx, &entry_points, |e| (e.0, e.1));\n@@ -575,7 +575,7 @@ fn deadlock(tcx: TyCtxt<'_>, registry: &rayon_core::Registry) {\n \n     let mut wakelist = Vec::new();\n     let query_map = tcx.queries.try_collect_active_jobs().unwrap();\n-    let mut jobs: Vec<QueryJobId> = query_map.keys().cloned().collect();\n+    let mut jobs: Vec<QueryJobId<DepKind>> = query_map.keys().cloned().collect();\n \n     let mut found_cycle = false;\n "}, {"sha": "2d1614d6ccd94f63658cc16173878672d95f3db7", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2a52436619d94e42aa1e0ca57f412e5ce06ef561/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a52436619d94e42aa1e0ca57f412e5ce06ef561/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=2a52436619d94e42aa1e0ca57f412e5ce06ef561", "patch": "@@ -104,7 +104,7 @@ impl<CTX: QueryContext, C: QueryCache<CTX>> QueryState<CTX, C> {\n         &self,\n         kind: DepKind,\n         make_query: fn(C::Key) -> CTX::Query,\n-        jobs: &mut FxHashMap<QueryJobId, QueryJobInfo<CTX>>,\n+        jobs: &mut FxHashMap<QueryJobId<CTX::DepKind>, QueryJobInfo<CTX>>,\n     ) -> Option<()>\n     where\n         C::Key: Clone,\n@@ -158,7 +158,7 @@ where\n {\n     state: &'tcx QueryState<CTX, C>,\n     key: C::Key,\n-    id: QueryJobId,\n+    id: QueryJobId<CTX::DepKind>,\n }\n \n impl<'tcx, C> JobOwner<'tcx, TyCtxt<'tcx>, C>\n@@ -375,7 +375,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     #[inline(always)]\n     fn start_query<F, R>(\n         self,\n-        token: QueryJobId,\n+        token: QueryJobId<DepKind>,\n         diagnostics: Option<&Lock<ThinVec<Diagnostic>>>,\n         compute: F,\n     ) -> R\n@@ -1171,7 +1171,7 @@ macro_rules! define_queries_struct {\n \n             pub(crate) fn try_collect_active_jobs(\n                 &self\n-            ) -> Option<FxHashMap<QueryJobId, QueryJobInfo<TyCtxt<'tcx>>>> {\n+            ) -> Option<FxHashMap<QueryJobId<crate::dep_graph::DepKind>, QueryJobInfo<TyCtxt<'tcx>>>> {\n                 let mut jobs = FxHashMap::default();\n \n                 $("}]}