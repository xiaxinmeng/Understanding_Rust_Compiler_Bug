{"sha": "791f464ea02d017f6499627223a1981b6531ca48", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5MWY0NjRlYTAyZDAxN2Y2NDk5NjI3MjIzYTE5ODFiNjUzMWNhNDg=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-10-09T20:35:14Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-10-11T06:59:39Z"}, "message": "update for size_and_align considering extern types", "tree": {"sha": "072673655379ef7b8e06afaa679cd4a763499c59", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/072673655379ef7b8e06afaa679cd4a763499c59"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/791f464ea02d017f6499627223a1981b6531ca48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/791f464ea02d017f6499627223a1981b6531ca48", "html_url": "https://github.com/rust-lang/rust/commit/791f464ea02d017f6499627223a1981b6531ca48", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/791f464ea02d017f6499627223a1981b6531ca48/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ce5b183e8bbaa7a2fa7d20077808027e0cc5bd78", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce5b183e8bbaa7a2fa7d20077808027e0cc5bd78", "html_url": "https://github.com/rust-lang/rust/commit/ce5b183e8bbaa7a2fa7d20077808027e0cc5bd78"}], "stats": {"total": 14, "additions": 11, "deletions": 3}, "files": [{"sha": "2128ff5d7aca23856dc187ee3b44eeff7e9a6e1d", "filename": "src/intrinsic.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/791f464ea02d017f6499627223a1981b6531ca48/src%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791f464ea02d017f6499627223a1981b6531ca48/src%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic.rs?ref=791f464ea02d017f6499627223a1981b6531ca48", "patch": "@@ -238,7 +238,10 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n             \"init\" => {\n                 // Check fast path: we don't want to force an allocation in case the destination is a simple value,\n                 // but we also do not want to create a new allocation with 0s and then copy that over.\n-                if !dest.layout.is_zst() { // notzhing to do for ZST\n+                // FIXME: We do not properly validate in case of ZSTs and when doing it in memory!\n+                // However, this only affects direct calls of the intrinsic; calls to the stable\n+                // functions wrapping them do get their validation.\n+                if !dest.layout.is_zst() { // nothing to do for ZST\n                     match dest.layout.abi {\n                         layout::Abi::Scalar(ref s) => {\n                             let x = Scalar::from_int(0, s.value.size(&self));\n@@ -338,7 +341,8 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n \n             \"size_of_val\" => {\n                 let mplace = self.ref_to_mplace(self.read_value(args[0])?)?;\n-                let (size, _) = self.size_and_align_of_mplace(mplace)?;\n+                let (size, _) = self.size_and_align_of_mplace(mplace)?\n+                    .expect(\"size_of_val called on extern type\");\n                 let ptr_size = self.pointer_size();\n                 self.write_scalar(\n                     Scalar::from_uint(size.bytes() as u128, ptr_size),\n@@ -349,7 +353,8 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n             \"min_align_of_val\" |\n             \"align_of_val\" => {\n                 let mplace = self.ref_to_mplace(self.read_value(args[0])?)?;\n-                let (_, align) = self.size_and_align_of_mplace(mplace)?;\n+                let (_, align) = self.size_and_align_of_mplace(mplace)?\n+                    .expect(\"size_of_val called on extern type\");\n                 let ptr_size = self.pointer_size();\n                 self.write_scalar(\n                     Scalar::from_uint(align.abi(), ptr_size),\n@@ -397,6 +402,9 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n             \"uninit\" => {\n                 // Check fast path: we don't want to force an allocation in case the destination is a simple value,\n                 // but we also do not want to create a new allocation with 0s and then copy that over.\n+                // FIXME: We do not properly validate in case of ZSTs and when doing it in memory!\n+                // However, this only affects direct calls of the intrinsic; calls to the stable\n+                // functions wrapping them do get their validation.\n                 if !dest.layout.is_zst() { // nothing to do for ZST\n                     match dest.layout.abi {\n                         layout::Abi::Scalar(..) => {"}]}