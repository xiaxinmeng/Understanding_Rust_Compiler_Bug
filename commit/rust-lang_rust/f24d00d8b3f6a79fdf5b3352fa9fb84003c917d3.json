{"sha": "f24d00d8b3f6a79fdf5b3352fa9fb84003c917d3", "node_id": "C_kwDOAAsO6NoAKGYyNGQwMGQ4YjNmNmE3OWZkZjViMzM1MmZhOWZiODQwMDNjOTE3ZDM", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-10-04T10:41:01Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-10-04T10:41:01Z"}, "message": "Rollup merge of #101642 - SkiFire13:fix-inplace-collection-leak, r=the8472\n\nFix in-place collection leak when remaining element destructor panic\n\nFixes #101628\n\ncc `@the8472`\n\nI went for the drop guard route, placing it immediately before the `forget_allocation_drop_remaining` call and after the comment, as to signal they are closely related.\n\nI also updated the test to check for the leak, though the only change really needed was removing the leak clean up for miri since now that's no longer leaked.", "tree": {"sha": "a6049e3b000214a7cbb8fba530fe8993bcc8da79", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a6049e3b000214a7cbb8fba530fe8993bcc8da79"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f24d00d8b3f6a79fdf5b3352fa9fb84003c917d3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjPA29CRBK7hj4Ov3rIwAAa5sIACflA9OPEvAR1v1D/VGcJ1sk\ndLXQU/rwV0PhOJGzw67R49xsqzbaA1FpkRvic6etCxGqtn9TBeH/zXsrO3NrvzQn\nuJAXYCbXGbE+PjX/D3L9rVsKixlN52QrGoHvbTRC93Mo+UY83U7G/825lm1Hx6SQ\nusj3Ev/hSFHtk89sy17KaYAgIy5tPIgxoEXjpCix9c7AsqK8eKBTSEshy9Afgsn9\nxEw3XhLGGbE+ip3dG/dz4R4+sOo/yHPAMkR+bnQBvSTjfSOVUALxGaVYyqQJanbP\n5ARwv8rOzrCZl6aulZQiJ/cG7D4wSWF0+ITMVjrC1UUuG3GaWywanEYBuroU76U=\n=cYMV\n-----END PGP SIGNATURE-----\n", "payload": "tree a6049e3b000214a7cbb8fba530fe8993bcc8da79\nparent c1d400350608d880c4b66744e9905c7847fcf512\nparent 1750c7bdd36ec18324423bd30867e39d787d5977\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1664880061 +0530\ncommitter GitHub <noreply@github.com> 1664880061 +0530\n\nRollup merge of #101642 - SkiFire13:fix-inplace-collection-leak, r=the8472\n\nFix in-place collection leak when remaining element destructor panic\n\nFixes #101628\n\ncc `@the8472`\n\nI went for the drop guard route, placing it immediately before the `forget_allocation_drop_remaining` call and after the comment, as to signal they are closely related.\n\nI also updated the test to check for the leak, though the only change really needed was removing the leak clean up for miri since now that's no longer leaked.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f24d00d8b3f6a79fdf5b3352fa9fb84003c917d3", "html_url": "https://github.com/rust-lang/rust/commit/f24d00d8b3f6a79fdf5b3352fa9fb84003c917d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f24d00d8b3f6a79fdf5b3352fa9fb84003c917d3/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c1d400350608d880c4b66744e9905c7847fcf512", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1d400350608d880c4b66744e9905c7847fcf512", "html_url": "https://github.com/rust-lang/rust/commit/c1d400350608d880c4b66744e9905c7847fcf512"}, {"sha": "1750c7bdd36ec18324423bd30867e39d787d5977", "url": "https://api.github.com/repos/rust-lang/rust/commits/1750c7bdd36ec18324423bd30867e39d787d5977", "html_url": "https://github.com/rust-lang/rust/commit/1750c7bdd36ec18324423bd30867e39d787d5977"}], "stats": {"total": 103, "additions": 67, "deletions": 36}, "files": [{"sha": "87d61deb1eb2f9e2a7a2e6c55e63518a8866fb26", "filename": "library/alloc/src/vec/in_place_collect.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f24d00d8b3f6a79fdf5b3352fa9fb84003c917d3/library%2Falloc%2Fsrc%2Fvec%2Fin_place_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f24d00d8b3f6a79fdf5b3352fa9fb84003c917d3/library%2Falloc%2Fsrc%2Fvec%2Fin_place_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fin_place_collect.rs?ref=f24d00d8b3f6a79fdf5b3352fa9fb84003c917d3", "patch": "@@ -55,6 +55,9 @@\n //! This is handled by the [`InPlaceDrop`] guard for sink items (`U`) and by\n //! [`vec::IntoIter::forget_allocation_drop_remaining()`] for remaining source items (`T`).\n //!\n+//! If dropping any remaining source item (`T`) panics then [`InPlaceDstBufDrop`] will handle dropping\n+//! the already collected sink items (`U`) and freeing the allocation.\n+//!\n //! [`vec::IntoIter::forget_allocation_drop_remaining()`]: super::IntoIter::forget_allocation_drop_remaining()\n //!\n //! # O(1) collect\n@@ -138,7 +141,7 @@ use core::iter::{InPlaceIterable, SourceIter, TrustedRandomAccessNoCoerce};\n use core::mem::{self, ManuallyDrop, SizedTypeProperties};\n use core::ptr::{self};\n \n-use super::{InPlaceDrop, SpecFromIter, SpecFromIterNested, Vec};\n+use super::{InPlaceDrop, InPlaceDstBufDrop, SpecFromIter, SpecFromIterNested, Vec};\n \n /// Specialization marker for collecting an iterator pipeline into a Vec while reusing the\n /// source allocation, i.e. executing the pipeline in place.\n@@ -191,14 +194,17 @@ where\n             );\n         }\n \n-        // Drop any remaining values at the tail of the source but prevent drop of the allocation\n-        // itself once IntoIter goes out of scope.\n-        // If the drop panics then we also leak any elements collected into dst_buf.\n+        // The ownership of the allocation and the new `T` values is temporarily moved into `dst_guard`.\n+        // This is safe because `forget_allocation_drop_remaining` immediately forgets the allocation\n+        // before any panic can occur in order to avoid any double free, and then proceeds to drop\n+        // any remaining values at the tail of the source.\n         //\n         // Note: This access to the source wouldn't be allowed by the TrustedRandomIteratorNoCoerce\n         // contract (used by SpecInPlaceCollect below). But see the \"O(1) collect\" section in the\n         // module documenttation why this is ok anyway.\n+        let dst_guard = InPlaceDstBufDrop { ptr: dst_buf, len, cap };\n         src.forget_allocation_drop_remaining();\n+        mem::forget(dst_guard);\n \n         let vec = unsafe { Vec::from_raw_parts(dst_buf, len, cap) };\n "}, {"sha": "25ca33c6a7bf0576921f249fcf48782663bf6c87", "filename": "library/alloc/src/vec/in_place_drop.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f24d00d8b3f6a79fdf5b3352fa9fb84003c917d3/library%2Falloc%2Fsrc%2Fvec%2Fin_place_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f24d00d8b3f6a79fdf5b3352fa9fb84003c917d3/library%2Falloc%2Fsrc%2Fvec%2Fin_place_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fin_place_drop.rs?ref=f24d00d8b3f6a79fdf5b3352fa9fb84003c917d3", "patch": "@@ -22,3 +22,18 @@ impl<T> Drop for InPlaceDrop<T> {\n         }\n     }\n }\n+\n+// A helper struct for in-place collection that drops the destination allocation and elements,\n+// to avoid leaking them if some other destructor panics.\n+pub(super) struct InPlaceDstBufDrop<T> {\n+    pub(super) ptr: *mut T,\n+    pub(super) len: usize,\n+    pub(super) cap: usize,\n+}\n+\n+impl<T> Drop for InPlaceDstBufDrop<T> {\n+    #[inline]\n+    fn drop(&mut self) {\n+        unsafe { super::Vec::from_raw_parts(self.ptr, self.len, self.cap) };\n+    }\n+}"}, {"sha": "73d7c90cf78ec5f4008eaaa0083447a5c0d8fdf9", "filename": "library/alloc/src/vec/into_iter.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f24d00d8b3f6a79fdf5b3352fa9fb84003c917d3/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f24d00d8b3f6a79fdf5b3352fa9fb84003c917d3/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs?ref=f24d00d8b3f6a79fdf5b3352fa9fb84003c917d3", "patch": "@@ -95,13 +95,16 @@ impl<T, A: Allocator> IntoIter<T, A> {\n     }\n \n     /// Drops remaining elements and relinquishes the backing allocation.\n+    /// This method guarantees it won't panic before relinquishing\n+    /// the backing allocation.\n     ///\n     /// This is roughly equivalent to the following, but more efficient\n     ///\n     /// ```\n     /// # let mut into_iter = Vec::<u8>::with_capacity(10).into_iter();\n+    /// let mut into_iter = std::mem::replace(&mut into_iter, Vec::new().into_iter());\n     /// (&mut into_iter).for_each(core::mem::drop);\n-    /// unsafe { core::ptr::write(&mut into_iter, Vec::new().into_iter()); }\n+    /// std::mem::forget(into_iter);\n     /// ```\n     ///\n     /// This method is used by in-place iteration, refer to the vec::in_place_collect\n@@ -118,6 +121,8 @@ impl<T, A: Allocator> IntoIter<T, A> {\n         self.ptr = self.buf.as_ptr();\n         self.end = self.buf.as_ptr();\n \n+        // Dropping the remaining elements can panic, so this needs to be\n+        // done only after updating the other fields.\n         unsafe {\n             ptr::drop_in_place(remaining);\n         }"}, {"sha": "0332047e6b688538d26cafa50666f65c06485ff6", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f24d00d8b3f6a79fdf5b3352fa9fb84003c917d3/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f24d00d8b3f6a79fdf5b3352fa9fb84003c917d3/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=f24d00d8b3f6a79fdf5b3352fa9fb84003c917d3", "patch": "@@ -125,7 +125,7 @@ use self::set_len_on_drop::SetLenOnDrop;\n mod set_len_on_drop;\n \n #[cfg(not(no_global_oom_handling))]\n-use self::in_place_drop::InPlaceDrop;\n+use self::in_place_drop::{InPlaceDrop, InPlaceDstBufDrop};\n \n #[cfg(not(no_global_oom_handling))]\n mod in_place_drop;"}, {"sha": "e0271187044782cb30da6d6b30c57365827fdd23", "filename": "library/alloc/tests/vec.rs", "status": "modified", "additions": 35, "deletions": 30, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/f24d00d8b3f6a79fdf5b3352fa9fb84003c917d3/library%2Falloc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f24d00d8b3f6a79fdf5b3352fa9fb84003c917d3/library%2Falloc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fvec.rs?ref=f24d00d8b3f6a79fdf5b3352fa9fb84003c917d3", "patch": "@@ -1191,48 +1191,53 @@ fn test_from_iter_specialization_panic_during_iteration_drops() {\n }\n \n #[test]\n-fn test_from_iter_specialization_panic_during_drop_leaks() {\n-    static mut DROP_COUNTER: usize = 0;\n+fn test_from_iter_specialization_panic_during_drop_doesnt_leak() {\n+    static mut DROP_COUNTER_OLD: [usize; 5] = [0; 5];\n+    static mut DROP_COUNTER_NEW: [usize; 2] = [0; 2];\n \n     #[derive(Debug)]\n-    enum Droppable {\n-        DroppedTwice(Box<i32>),\n-        PanicOnDrop,\n-    }\n+    struct Old(usize);\n \n-    impl Drop for Droppable {\n+    impl Drop for Old {\n         fn drop(&mut self) {\n-            match self {\n-                Droppable::DroppedTwice(_) => {\n-                    unsafe {\n-                        DROP_COUNTER += 1;\n-                    }\n-                    println!(\"Dropping!\")\n-                }\n-                Droppable::PanicOnDrop => {\n-                    if !std::thread::panicking() {\n-                        panic!();\n-                    }\n-                }\n+            unsafe {\n+                DROP_COUNTER_OLD[self.0] += 1;\n+            }\n+\n+            if self.0 == 3 {\n+                panic!();\n             }\n+\n+            println!(\"Dropped Old: {}\", self.0);\n         }\n     }\n \n-    let mut to_free: *mut Droppable = core::ptr::null_mut();\n-    let mut cap = 0;\n+    #[derive(Debug)]\n+    struct New(usize);\n+\n+    impl Drop for New {\n+        fn drop(&mut self) {\n+            unsafe {\n+                DROP_COUNTER_NEW[self.0] += 1;\n+            }\n+\n+            println!(\"Dropped New: {}\", self.0);\n+        }\n+    }\n \n     let _ = std::panic::catch_unwind(AssertUnwindSafe(|| {\n-        let mut v = vec![Droppable::DroppedTwice(Box::new(123)), Droppable::PanicOnDrop];\n-        to_free = v.as_mut_ptr();\n-        cap = v.capacity();\n-        let _ = v.into_iter().take(0).collect::<Vec<_>>();\n+        let v = vec![Old(0), Old(1), Old(2), Old(3), Old(4)];\n+        let _ = v.into_iter().map(|x| New(x.0)).take(2).collect::<Vec<_>>();\n     }));\n \n-    assert_eq!(unsafe { DROP_COUNTER }, 1);\n-    // clean up the leak to keep miri happy\n-    unsafe {\n-        drop(Vec::from_raw_parts(to_free, 0, cap));\n-    }\n+    assert_eq!(unsafe { DROP_COUNTER_OLD[0] }, 1);\n+    assert_eq!(unsafe { DROP_COUNTER_OLD[1] }, 1);\n+    assert_eq!(unsafe { DROP_COUNTER_OLD[2] }, 1);\n+    assert_eq!(unsafe { DROP_COUNTER_OLD[3] }, 1);\n+    assert_eq!(unsafe { DROP_COUNTER_OLD[4] }, 1);\n+\n+    assert_eq!(unsafe { DROP_COUNTER_NEW[0] }, 1);\n+    assert_eq!(unsafe { DROP_COUNTER_NEW[1] }, 1);\n }\n \n // regression test for issue #85322. Peekable previously implemented InPlaceIterable,"}]}