{"sha": "1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmYzFhZWU3YmU2ZTdlNzFmMTJlYWNkNjBiOWIxMDQwZTc2NDBmZTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-17T21:15:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-17T21:15:48Z"}, "message": "Auto merge of #7565 - Jarcho:manual_split_once, r=llogiq\n\nNew lint `manual_split_once`\n\nThis is a WIP because it still needs to recognize more patterns. Currently handles:\n\n```rust\ns.splitn(2, ' ').next();\ns.splitn(2, ' ').nth(0)\ns.splitn(2, ' ').nth(1);\ns.splitn(2, ' ').skip(0).next();\ns.splitn(2, ' ').skip(1).next();\ns.splitn(2, ' ').next_tuple(); // from itertools\n\n// as well as `unwrap()` and `?` forms\n```\n\nStill to do:\n\n```rust\nlet mut iter = s.splitn(2, ' ');\n(iter.next().unwrap(), iter.next()?)\n\nlet mut iter = s.splitn(2, ' ');\nlet key = iter.next().unwrap();\nlet value = iter.next()?;\n```\n\nSuggestions on other patterns to check for would be useful. I've done a search on github for uses of `splitn`. Still have yet to actually look through the results.\n\nThere's also the question of whether the lint shouold trigger on all uses of `splitn` with two values, or only on recognized usages. The former could have false positives where it couldn't be replaced, but I'm not sure how common that would be.\n\nchangelog: Add lint `manual_split_once`", "tree": {"sha": "008276c6d2c7a85574eb446235521fe4f7facc29", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/008276c6d2c7a85574eb446235521fe4f7facc29"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4", "html_url": "https://github.com/rust-lang/rust/commit/1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cde7e6b8d3502f6eb6a11ba85af812161c2ac03a", "url": "https://api.github.com/repos/rust-lang/rust/commits/cde7e6b8d3502f6eb6a11ba85af812161c2ac03a", "html_url": "https://github.com/rust-lang/rust/commit/cde7e6b8d3502f6eb6a11ba85af812161c2ac03a"}, {"sha": "aab3267412bd23cae4fd58e860b6b9a36de42448", "url": "https://api.github.com/repos/rust-lang/rust/commits/aab3267412bd23cae4fd58e860b6b9a36de42448", "html_url": "https://github.com/rust-lang/rust/commit/aab3267412bd23cae4fd58e860b6b9a36de42448"}], "stats": {"total": 658, "additions": 538, "deletions": 120}, "files": [{"sha": "b9e67d361c0c34cc265eb98307209e64053e1f42", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4", "patch": "@@ -2754,6 +2754,7 @@ Released 2018-09-13\n [`manual_ok_or`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_ok_or\n [`manual_range_contains`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_range_contains\n [`manual_saturating_arithmetic`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_saturating_arithmetic\n+[`manual_split_once`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_split_once\n [`manual_str_repeat`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_str_repeat\n [`manual_strip`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_strip\n [`manual_swap`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_swap"}, {"sha": "a07cd5e5f4e53940be988f8fe12b8f968174d755", "filename": "clippy_lints/src/bytecount.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4/clippy_lints%2Fsrc%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4/clippy_lints%2Fsrc%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbytecount.rs?ref=1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::ty::match_type;\n-use clippy_utils::visitors::LocalUsedVisitor;\n+use clippy_utils::visitors::is_local_used;\n use clippy_utils::{path_to_local_id, paths, peel_ref_operators, remove_blocks, strip_pat_refs};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n@@ -65,7 +65,7 @@ impl<'tcx> LateLintPass<'tcx> for ByteCount {\n                 return;\n             };\n             if ty::Uint(UintTy::U8) == *cx.typeck_results().expr_ty(needle).peel_refs().kind();\n-            if !LocalUsedVisitor::new(cx, arg_id).check_expr(needle);\n+            if !is_local_used(cx, needle, arg_id);\n             then {\n                 let haystack = if let ExprKind::MethodCall(path, _, args, _) =\n                         filter_recv.kind {"}, {"sha": "bd8f9cc7343bfb554b826e59cb9fc5b086c817d4", "filename": "clippy_lints/src/collapsible_match.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4/clippy_lints%2Fsrc%2Fcollapsible_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4/clippy_lints%2Fsrc%2Fcollapsible_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcollapsible_match.rs?ref=1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::visitors::LocalUsedVisitor;\n+use clippy_utils::visitors::is_local_used;\n use clippy_utils::{is_lang_ctor, path_to_local, peel_ref_operators, SpanlessEq};\n use if_chain::if_chain;\n use rustc_hir::LangItem::OptionNone;\n@@ -83,13 +83,12 @@ fn check_arm<'tcx>(arm: &Arm<'tcx>, wild_outer_arm: &Arm<'tcx>, cx: &LateContext\n         // the \"wild-like\" branches must be equal\n         if SpanlessEq::new(cx).eq_expr(wild_inner_arm.body, wild_outer_arm.body);\n         // the binding must not be used in the if guard\n-        let mut used_visitor = LocalUsedVisitor::new(cx, binding_id);\n         if match arm.guard {\n             None => true,\n-            Some(Guard::If(expr) | Guard::IfLet(_, expr)) => !used_visitor.check_expr(expr),\n+            Some(Guard::If(expr) | Guard::IfLet(_, expr)) => !is_local_used(cx, expr, binding_id),\n         };\n         // ...or anywhere in the inner match\n-        if !arms_inner.iter().any(|arm| used_visitor.check_arm(arm));\n+        if !arms_inner.iter().any(|arm| is_local_used(cx, arm, binding_id));\n         then {\n             span_lint_and_then(\n                 cx,"}, {"sha": "834440e912dfa88ceb6a027bbd082de42488a43e", "filename": "clippy_lints/src/let_if_seq.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4/clippy_lints%2Fsrc%2Flet_if_seq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4/clippy_lints%2Fsrc%2Flet_if_seq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flet_if_seq.rs?ref=1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::source::snippet;\n-use clippy_utils::{path_to_local_id, visitors::LocalUsedVisitor};\n+use clippy_utils::{path_to_local_id, visitors::is_local_used};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n@@ -65,11 +65,10 @@ impl<'tcx> LateLintPass<'tcx> for LetIfSeq {\n                 if let hir::PatKind::Binding(mode, canonical_id, ident, None) = local.pat.kind;\n                 if let hir::StmtKind::Expr(if_) = expr.kind;\n                 if let hir::ExprKind::If(cond, then, ref else_) = if_.kind;\n-                let mut used_visitor = LocalUsedVisitor::new(cx, canonical_id);\n-                if !used_visitor.check_expr(cond);\n+                if !is_local_used(cx, cond, canonical_id);\n                 if let hir::ExprKind::Block(then, _) = then.kind;\n                 if let Some(value) = check_assign(cx, canonical_id, &*then);\n-                if !used_visitor.check_expr(value);\n+                if !is_local_used(cx, value, canonical_id);\n                 then {\n                     let span = stmt.span.to(if_.span);\n \n@@ -148,15 +147,13 @@ fn check_assign<'tcx>(\n         if let hir::ExprKind::Assign(var, value, _) = expr.kind;\n         if path_to_local_id(var, decl);\n         then {\n-            let mut v = LocalUsedVisitor::new(cx, decl);\n-\n-            if block.stmts.iter().take(block.stmts.len()-1).any(|stmt| v.check_stmt(stmt)) {\n-                return None;\n+            if block.stmts.iter().take(block.stmts.len()-1).any(|stmt| is_local_used(cx, stmt, decl)) {\n+                None\n+            } else {\n+                Some(value)\n             }\n-\n-            return Some(value);\n+        } else {\n+            None\n         }\n     }\n-\n-    None\n }"}, {"sha": "1fadaf4770a811cb6803e4a66de21e41c7262361", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4", "patch": "@@ -773,6 +773,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         methods::MANUAL_FILTER_MAP,\n         methods::MANUAL_FIND_MAP,\n         methods::MANUAL_SATURATING_ARITHMETIC,\n+        methods::MANUAL_SPLIT_ONCE,\n         methods::MANUAL_STR_REPEAT,\n         methods::MAP_COLLECT_RESULT_UNIT,\n         methods::MAP_FLATTEN,\n@@ -1319,6 +1320,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(methods::MANUAL_FILTER_MAP),\n         LintId::of(methods::MANUAL_FIND_MAP),\n         LintId::of(methods::MANUAL_SATURATING_ARITHMETIC),\n+        LintId::of(methods::MANUAL_SPLIT_ONCE),\n         LintId::of(methods::MANUAL_STR_REPEAT),\n         LintId::of(methods::MAP_COLLECT_RESULT_UNIT),\n         LintId::of(methods::MAP_IDENTITY),\n@@ -1617,6 +1619,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(methods::ITER_COUNT),\n         LintId::of(methods::MANUAL_FILTER_MAP),\n         LintId::of(methods::MANUAL_FIND_MAP),\n+        LintId::of(methods::MANUAL_SPLIT_ONCE),\n         LintId::of(methods::MAP_IDENTITY),\n         LintId::of(methods::OPTION_AS_REF_DEREF),\n         LintId::of(methods::OPTION_FILTER_MAP),"}, {"sha": "68bef2f4c8bbb351e808dcd6c78193e8896a5bc6", "filename": "clippy_lints/src/loops/for_kv_map.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4/clippy_lints%2Fsrc%2Floops%2Ffor_kv_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4/clippy_lints%2Fsrc%2Floops%2Ffor_kv_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Ffor_kv_map.rs?ref=1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4", "patch": "@@ -3,7 +3,7 @@ use clippy_utils::diagnostics::{multispan_sugg, span_lint_and_then};\n use clippy_utils::source::snippet;\n use clippy_utils::sugg;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::visitors::LocalUsedVisitor;\n+use clippy_utils::visitors::is_local_used;\n use rustc_hir::{BorrowKind, Expr, ExprKind, Mutability, Pat, PatKind};\n use rustc_lint::LateContext;\n use rustc_middle::ty;\n@@ -66,9 +66,7 @@ pub(super) fn check<'tcx>(\n fn pat_is_wild<'tcx>(cx: &LateContext<'tcx>, pat: &'tcx PatKind<'_>, body: &'tcx Expr<'_>) -> bool {\n     match *pat {\n         PatKind::Wild => true,\n-        PatKind::Binding(_, id, ident, None) if ident.as_str().starts_with('_') => {\n-            !LocalUsedVisitor::new(cx, id).check_expr(body)\n-        },\n+        PatKind::Binding(_, id, ident, None) if ident.as_str().starts_with('_') => !is_local_used(cx, body, id),\n         _ => false,\n     }\n }"}, {"sha": "2af6cfe35b54a6e48f6a2853c08df0153f9a78b4", "filename": "clippy_lints/src/loops/manual_flatten.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4/clippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4/clippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs?ref=1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4", "patch": "@@ -1,7 +1,7 @@\n use super::utils::make_iterator_snippet;\n use super::MANUAL_FLATTEN;\n use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::visitors::LocalUsedVisitor;\n+use clippy_utils::visitors::is_local_used;\n use clippy_utils::{is_lang_ctor, path_to_local_id};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n@@ -49,7 +49,7 @@ pub(super) fn check<'tcx>(\n             let ok_ctor = is_lang_ctor(cx, qpath, ResultOk);\n             if some_ctor || ok_ctor;\n             // Ensure epxr in `if let` is not used afterwards\n-            if !LocalUsedVisitor::new(cx, pat_hir_id).check_arm(true_arm);\n+            if !is_local_used(cx, true_arm, pat_hir_id);\n             then {\n                 let if_let_type = if some_ctor { \"Some\" } else { \"Ok\" };\n                 // Prepare the error message"}, {"sha": "fa33d068d3d88db28b1407161dbe3afee2e90896", "filename": "clippy_lints/src/loops/needless_range_loop.rs", "status": "modified", "additions": 8, "deletions": 17, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4/clippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4/clippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs?ref=1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4", "patch": "@@ -2,10 +2,8 @@ use super::NEEDLESS_RANGE_LOOP;\n use clippy_utils::diagnostics::{multispan_sugg, span_lint_and_then};\n use clippy_utils::source::snippet;\n use clippy_utils::ty::has_iter_method;\n-use clippy_utils::visitors::LocalUsedVisitor;\n-use clippy_utils::{\n-    contains_name, higher, is_integer_const, match_trait_method, path_to_local_id, paths, sugg, SpanlessEq,\n-};\n+use clippy_utils::visitors::is_local_used;\n+use clippy_utils::{contains_name, higher, is_integer_const, match_trait_method, paths, sugg, SpanlessEq};\n use if_chain::if_chain;\n use rustc_ast::ast;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n@@ -256,43 +254,36 @@ impl<'a, 'tcx> VarVisitor<'a, 'tcx> {\n             if let ExprKind::Path(ref seqpath) = seqexpr.kind;\n             if let QPath::Resolved(None, seqvar) = *seqpath;\n             if seqvar.segments.len() == 1;\n-            let index_used_directly = path_to_local_id(idx, self.var);\n-            let indexed_indirectly = {\n-                let mut used_visitor = LocalUsedVisitor::new(self.cx, self.var);\n-                walk_expr(&mut used_visitor, idx);\n-                used_visitor.used\n-            };\n-            if indexed_indirectly || index_used_directly;\n+            if is_local_used(self.cx, idx, self.var);\n             then {\n                 if self.prefer_mutable {\n                     self.indexed_mut.insert(seqvar.segments[0].ident.name);\n                 }\n+                let index_used_directly = matches!(idx.kind, ExprKind::Path(_));\n                 let res = self.cx.qpath_res(seqpath, seqexpr.hir_id);\n                 match res {\n                     Res::Local(hir_id) => {\n                         let parent_id = self.cx.tcx.hir().get_parent_item(expr.hir_id);\n                         let parent_def_id = self.cx.tcx.hir().local_def_id(parent_id);\n                         let extent = self.cx.tcx.region_scope_tree(parent_def_id).var_scope(hir_id.local_id);\n-                        if indexed_indirectly {\n-                            self.indexed_indirectly.insert(seqvar.segments[0].ident.name, Some(extent));\n-                        }\n                         if index_used_directly {\n                             self.indexed_directly.insert(\n                                 seqvar.segments[0].ident.name,\n                                 (Some(extent), self.cx.typeck_results().node_type(seqexpr.hir_id)),\n                             );\n+                        } else {\n+                            self.indexed_indirectly.insert(seqvar.segments[0].ident.name, Some(extent));\n                         }\n                         return false;  // no need to walk further *on the variable*\n                     }\n                     Res::Def(DefKind::Static | DefKind::Const, ..) => {\n-                        if indexed_indirectly {\n-                            self.indexed_indirectly.insert(seqvar.segments[0].ident.name, None);\n-                        }\n                         if index_used_directly {\n                             self.indexed_directly.insert(\n                                 seqvar.segments[0].ident.name,\n                                 (None, self.cx.typeck_results().node_type(seqexpr.hir_id)),\n                             );\n+                        } else {\n+                            self.indexed_indirectly.insert(seqvar.segments[0].ident.name, None);\n                         }\n                         return false;  // no need to walk further *on the variable*\n                     }"}, {"sha": "149c9bee9fbd5f6bc8f7016fe0bbad1cc91854ec", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4", "patch": "@@ -5,7 +5,7 @@ use clippy_utils::diagnostics::{\n use clippy_utils::source::{expr_block, indent_of, snippet, snippet_block, snippet_opt, snippet_with_applicability};\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::{implements_trait, is_type_diagnostic_item, match_type, peel_mid_ty_refs};\n-use clippy_utils::visitors::LocalUsedVisitor;\n+use clippy_utils::visitors::is_local_used;\n use clippy_utils::{\n     get_parent_expr, in_macro, is_expn_of, is_lang_ctor, is_lint_allowed, is_refutable, is_wild, meets_msrv, msrvs,\n     path_to_local, path_to_local_id, peel_hir_pat_refs, peel_n_hir_expr_refs, recurse_or_patterns, remove_blocks,\n@@ -953,9 +953,7 @@ fn check_wild_err_arm<'tcx>(cx: &LateContext<'tcx>, ex: &Expr<'tcx>, arms: &[Arm\n                         // Looking for unused bindings (i.e.: `_e`)\n                         for pat in inner.iter() {\n                             if let PatKind::Binding(_, id, ident, None) = pat.kind {\n-                                if ident.as_str().starts_with('_')\n-                                    && !LocalUsedVisitor::new(cx, id).check_expr(arm.body)\n-                                {\n+                                if ident.as_str().starts_with('_') && !is_local_used(cx, arm.body, id) {\n                                     ident_bind_name = (&ident.name.as_str()).to_string();\n                                     matching_wild = true;\n                                 }"}, {"sha": "e273186d0519022d5a7c1a9219cf1aa9625fd4a7", "filename": "clippy_lints/src/methods/manual_split_once.rs", "status": "added", "additions": 213, "deletions": 0, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4/clippy_lints%2Fsrc%2Fmethods%2Fmanual_split_once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4/clippy_lints%2Fsrc%2Fmethods%2Fmanual_split_once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmanual_split_once.rs?ref=1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4", "patch": "@@ -0,0 +1,213 @@\n+use clippy_utils::consts::{constant, Constant};\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet_with_context;\n+use clippy_utils::{is_diag_item_method, match_def_path, paths};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, ExprKind, HirId, LangItem, Node, QPath};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, adjustment::Adjust};\n+use rustc_span::{symbol::sym, Span, SyntaxContext};\n+\n+use super::MANUAL_SPLIT_ONCE;\n+\n+pub(super) fn check(cx: &LateContext<'_>, method_name: &str, expr: &Expr<'_>, self_arg: &Expr<'_>, pat_arg: &Expr<'_>) {\n+    if !cx.typeck_results().expr_ty_adjusted(self_arg).peel_refs().is_str() {\n+        return;\n+    }\n+\n+    let ctxt = expr.span.ctxt();\n+    let usage = match parse_iter_usage(cx, ctxt, cx.tcx.hir().parent_iter(expr.hir_id)) {\n+        Some(x) => x,\n+        None => return,\n+    };\n+    let (method_name, msg) = if method_name == \"splitn\" {\n+        (\"split_once\", \"manual implementation of `split_once`\")\n+    } else {\n+        (\"rsplit_once\", \"manual implementation of `rsplit_once`\")\n+    };\n+\n+    let mut app = Applicability::MachineApplicable;\n+    let self_snip = snippet_with_context(cx, self_arg.span, ctxt, \"..\", &mut app).0;\n+    let pat_snip = snippet_with_context(cx, pat_arg.span, ctxt, \"..\", &mut app).0;\n+\n+    match usage.kind {\n+        IterUsageKind::NextTuple => {\n+            span_lint_and_sugg(\n+                cx,\n+                MANUAL_SPLIT_ONCE,\n+                usage.span,\n+                msg,\n+                \"try this\",\n+                format!(\"{}.{}({})\", self_snip, method_name, pat_snip),\n+                app,\n+            );\n+        },\n+        IterUsageKind::Next => {\n+            let self_deref = {\n+                let adjust = cx.typeck_results().expr_adjustments(self_arg);\n+                if adjust.is_empty() {\n+                    String::new()\n+                } else if cx.typeck_results().expr_ty(self_arg).is_box()\n+                    || adjust\n+                        .iter()\n+                        .any(|a| matches!(a.kind, Adjust::Deref(Some(_))) || a.target.is_box())\n+                {\n+                    format!(\"&{}\", \"*\".repeat(adjust.len() - 1))\n+                } else {\n+                    \"*\".repeat(adjust.len() - 2)\n+                }\n+            };\n+            let sugg = if usage.unwrap_kind.is_some() {\n+                format!(\n+                    \"{}.{}({}).map_or({}{}, |x| x.0)\",\n+                    &self_snip, method_name, pat_snip, self_deref, &self_snip\n+                )\n+            } else {\n+                format!(\n+                    \"Some({}.{}({}).map_or({}{}, |x| x.0))\",\n+                    &self_snip, method_name, pat_snip, self_deref, &self_snip\n+                )\n+            };\n+\n+            span_lint_and_sugg(cx, MANUAL_SPLIT_ONCE, usage.span, msg, \"try this\", sugg, app);\n+        },\n+        IterUsageKind::Second => {\n+            let access_str = match usage.unwrap_kind {\n+                Some(UnwrapKind::Unwrap) => \".unwrap().1\",\n+                Some(UnwrapKind::QuestionMark) => \"?.1\",\n+                None => \".map(|x| x.1)\",\n+            };\n+            span_lint_and_sugg(\n+                cx,\n+                MANUAL_SPLIT_ONCE,\n+                usage.span,\n+                msg,\n+                \"try this\",\n+                format!(\"{}.{}({}){}\", self_snip, method_name, pat_snip, access_str),\n+                app,\n+            );\n+        },\n+    }\n+}\n+\n+enum IterUsageKind {\n+    Next,\n+    Second,\n+    NextTuple,\n+}\n+\n+enum UnwrapKind {\n+    Unwrap,\n+    QuestionMark,\n+}\n+\n+struct IterUsage {\n+    kind: IterUsageKind,\n+    unwrap_kind: Option<UnwrapKind>,\n+    span: Span,\n+}\n+\n+fn parse_iter_usage(\n+    cx: &LateContext<'tcx>,\n+    ctxt: SyntaxContext,\n+    mut iter: impl Iterator<Item = (HirId, Node<'tcx>)>,\n+) -> Option<IterUsage> {\n+    let (kind, span) = match iter.next() {\n+        Some((_, Node::Expr(e))) if e.span.ctxt() == ctxt => {\n+            let (name, args) = if let ExprKind::MethodCall(name, _, [_, args @ ..], _) = e.kind {\n+                (name, args)\n+            } else {\n+                return None;\n+            };\n+            let did = cx.typeck_results().type_dependent_def_id(e.hir_id)?;\n+            let iter_id = cx.tcx.get_diagnostic_item(sym::Iterator)?;\n+\n+            match (&*name.ident.as_str(), args) {\n+                (\"next\", []) if cx.tcx.trait_of_item(did) == Some(iter_id) => (IterUsageKind::Next, e.span),\n+                (\"next_tuple\", []) => {\n+                    if_chain! {\n+                        if match_def_path(cx, did, &paths::ITERTOOLS_NEXT_TUPLE);\n+                        if let ty::Adt(adt_def, subs) = cx.typeck_results().expr_ty(e).kind();\n+                        if cx.tcx.is_diagnostic_item(sym::option_type, adt_def.did);\n+                        if let ty::Tuple(subs) = subs.type_at(0).kind();\n+                        if subs.len() == 2;\n+                        then {\n+                            return Some(IterUsage { kind: IterUsageKind::NextTuple, span: e.span, unwrap_kind: None });\n+                        } else {\n+                            return None;\n+                        }\n+                    }\n+                },\n+                (\"nth\" | \"skip\", [idx_expr]) if cx.tcx.trait_of_item(did) == Some(iter_id) => {\n+                    if let Some((Constant::Int(idx), _)) = constant(cx, cx.typeck_results(), idx_expr) {\n+                        let span = if name.ident.as_str() == \"nth\" {\n+                            e.span\n+                        } else {\n+                            if_chain! {\n+                                if let Some((_, Node::Expr(next_expr))) = iter.next();\n+                                if let ExprKind::MethodCall(next_name, _, [_], _) = next_expr.kind;\n+                                if next_name.ident.name == sym::next;\n+                                if next_expr.span.ctxt() == ctxt;\n+                                if let Some(next_id) = cx.typeck_results().type_dependent_def_id(next_expr.hir_id);\n+                                if cx.tcx.trait_of_item(next_id) == Some(iter_id);\n+                                then {\n+                                    next_expr.span\n+                                } else {\n+                                    return None;\n+                                }\n+                            }\n+                        };\n+                        match idx {\n+                            0 => (IterUsageKind::Next, span),\n+                            1 => (IterUsageKind::Second, span),\n+                            _ => return None,\n+                        }\n+                    } else {\n+                        return None;\n+                    }\n+                },\n+                _ => return None,\n+            }\n+        },\n+        _ => return None,\n+    };\n+\n+    let (unwrap_kind, span) = if let Some((_, Node::Expr(e))) = iter.next() {\n+        match e.kind {\n+            ExprKind::Call(\n+                Expr {\n+                    kind: ExprKind::Path(QPath::LangItem(LangItem::TryTraitBranch, _)),\n+                    ..\n+                },\n+                _,\n+            ) => {\n+                let parent_span = e.span.parent().unwrap();\n+                if parent_span.ctxt() == ctxt {\n+                    (Some(UnwrapKind::QuestionMark), parent_span)\n+                } else {\n+                    (None, span)\n+                }\n+            },\n+            _ if e.span.ctxt() != ctxt => (None, span),\n+            ExprKind::MethodCall(name, _, [_], _)\n+                if name.ident.name == sym::unwrap\n+                    && cx\n+                        .typeck_results()\n+                        .type_dependent_def_id(e.hir_id)\n+                        .map_or(false, |id| is_diag_item_method(cx, id, sym::option_type)) =>\n+            {\n+                (Some(UnwrapKind::Unwrap), e.span)\n+            },\n+            _ => (None, span),\n+        }\n+    } else {\n+        (None, span)\n+    };\n+\n+    Some(IterUsage {\n+        kind,\n+        unwrap_kind,\n+        span,\n+    })\n+}"}, {"sha": "b6438bce8746e7c86deca4d61c35716dc9a5d33e", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 39, "deletions": 3, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4", "patch": "@@ -33,6 +33,7 @@ mod iter_nth_zero;\n mod iter_skip_next;\n mod iterator_step_by_zero;\n mod manual_saturating_arithmetic;\n+mod manual_split_once;\n mod manual_str_repeat;\n mod map_collect_result_unit;\n mod map_flatten;\n@@ -64,6 +65,7 @@ mod wrong_self_convention;\n mod zst_offset;\n \n use bind_instead_of_map::BindInsteadOfMap;\n+use clippy_utils::consts::{constant, Constant};\n use clippy_utils::diagnostics::{span_lint, span_lint_and_help};\n use clippy_utils::ty::{contains_adt_constructor, contains_ty, implements_trait, is_copy, is_type_diagnostic_item};\n use clippy_utils::{contains_return, get_trait_def_id, in_macro, iter_input_pats, meets_msrv, msrvs, paths, return_ty};\n@@ -1771,6 +1773,29 @@ declare_clippy_lint! {\n     \"manual implementation of `str::repeat`\"\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:** Checks for usages of `str::splitn(2, _)`\n+    ///\n+    /// **Why is this bad?** `split_once` is both clearer in intent and slightly more efficient.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust,ignore\n+    /// // Bad\n+    ///  let (key, value) = _.splitn(2, '=').next_tuple()?;\n+    ///  let value = _.splitn(2, '=').nth(1)?;\n+    ///\n+    /// // Good\n+    /// let (key, value) = _.split_once('=')?;\n+    /// let value = _.split_once('=')?.1;\n+    /// ```\n+    pub MANUAL_SPLIT_ONCE,\n+    complexity,\n+    \"replace `.splitn(2, pat)` with `.split_once(pat)`\"\n+}\n+\n pub struct Methods {\n     avoid_breaking_exported_api: bool,\n     msrv: Option<RustcVersion>,\n@@ -1848,7 +1873,8 @@ impl_lint_pass!(Methods => [\n     IMPLICIT_CLONE,\n     SUSPICIOUS_SPLITN,\n     MANUAL_STR_REPEAT,\n-    EXTEND_WITH_DRAIN\n+    EXTEND_WITH_DRAIN,\n+    MANUAL_SPLIT_ONCE\n ]);\n \n /// Extracts a method call name, args, and `Span` of the method name.\n@@ -2176,8 +2202,18 @@ fn check_methods<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, msrv: Optio\n                     unnecessary_lazy_eval::check(cx, expr, recv, arg, \"or\");\n                 }\n             },\n-            (\"splitn\" | \"splitn_mut\" | \"rsplitn\" | \"rsplitn_mut\", [count_arg, _]) => {\n-                suspicious_splitn::check(cx, name, expr, recv, count_arg);\n+            (\"splitn\" | \"rsplitn\", [count_arg, pat_arg]) => {\n+                if let Some((Constant::Int(count), _)) = constant(cx, cx.typeck_results(), count_arg) {\n+                    suspicious_splitn::check(cx, name, expr, recv, count);\n+                    if count == 2 && meets_msrv(msrv, &msrvs::STR_SPLIT_ONCE) {\n+                        manual_split_once::check(cx, name, expr, recv, pat_arg);\n+                    }\n+                }\n+            },\n+            (\"splitn_mut\" | \"rsplitn_mut\", [count_arg, _]) => {\n+                if let Some((Constant::Int(count), _)) = constant(cx, cx.typeck_results(), count_arg) {\n+                    suspicious_splitn::check(cx, name, expr, recv, count);\n+                }\n             },\n             (\"step_by\", [arg]) => iterator_step_by_zero::check(cx, expr, arg),\n             (\"to_os_string\" | \"to_owned\" | \"to_path_buf\" | \"to_vec\", []) => {"}, {"sha": "1c546a15bf62b331a5993e378aee11e7c832dc72", "filename": "clippy_lints/src/methods/suspicious_splitn.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4/clippy_lints%2Fsrc%2Fmethods%2Fsuspicious_splitn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4/clippy_lints%2Fsrc%2Fmethods%2Fsuspicious_splitn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fsuspicious_splitn.rs?ref=1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4", "patch": "@@ -1,4 +1,3 @@\n-use clippy_utils::consts::{constant, Constant};\n use clippy_utils::diagnostics::span_lint_and_note;\n use if_chain::if_chain;\n use rustc_ast::LitKind;\n@@ -8,25 +7,18 @@ use rustc_span::source_map::Spanned;\n \n use super::SUSPICIOUS_SPLITN;\n \n-pub(super) fn check(\n-    cx: &LateContext<'_>,\n-    method_name: &str,\n-    expr: &Expr<'_>,\n-    self_arg: &Expr<'_>,\n-    count_arg: &Expr<'_>,\n-) {\n+pub(super) fn check(cx: &LateContext<'_>, method_name: &str, expr: &Expr<'_>, self_arg: &Expr<'_>, count: u128) {\n     if_chain! {\n-        if let Some((Constant::Int(count), _)) = constant(cx, cx.typeck_results(), count_arg);\n         if count <= 1;\n         if let Some(call_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n         if let Some(impl_id) = cx.tcx.impl_of_method(call_id);\n         let lang_items = cx.tcx.lang_items();\n         if lang_items.slice_impl() == Some(impl_id) || lang_items.str_impl() == Some(impl_id);\n         then {\n             // Ignore empty slice and string literals when used with a literal count.\n-            if (matches!(self_arg.kind, ExprKind::Array([]))\n+            if matches!(self_arg.kind, ExprKind::Array([]))\n                 || matches!(self_arg.kind, ExprKind::Lit(Spanned { node: LitKind::Str(s, _), .. }) if s.is_empty())\n-            ) && matches!(count_arg.kind, ExprKind::Lit(_))\n+\n             {\n                 return;\n             }"}, {"sha": "e7e249c79a2fad0f6f97e1a8110d62b41f763029", "filename": "clippy_lints/src/unused_self.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4/clippy_lints%2Fsrc%2Funused_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4/clippy_lints%2Fsrc%2Funused_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_self.rs?ref=1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n-use clippy_utils::visitors::LocalUsedVisitor;\n+use clippy_utils::visitors::is_local_used;\n use if_chain::if_chain;\n use rustc_hir::{Impl, ImplItem, ImplItemKind, ItemKind};\n use rustc_lint::{LateContext, LateLintPass};\n@@ -50,8 +50,7 @@ impl<'tcx> LateLintPass<'tcx> for UnusedSelf {\n             if let ImplItemKind::Fn(.., body_id) = &impl_item.kind;\n             let body = cx.tcx.hir().body(*body_id);\n             if let [self_param, ..] = body.params;\n-            let self_hir_id = self_param.pat.hir_id;\n-            if !LocalUsedVisitor::new(cx, self_hir_id).check_body(body);\n+            if !is_local_used(cx, body, self_param.pat.hir_id);\n             then {\n                 span_lint_and_help(\n                     cx,"}, {"sha": "97062bcb28213dd96d034f83283a975c08c5046b", "filename": "clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4", "patch": "@@ -132,7 +132,7 @@ define_Conf! {\n     ///\n     /// Suppress lints whenever the suggested change would cause breakage for other crates.\n     (avoid_breaking_exported_api: bool = true),\n-    /// Lint: MANUAL_STR_REPEAT, CLONED_INSTEAD_OF_COPIED, REDUNDANT_FIELD_NAMES, REDUNDANT_STATIC_LIFETIMES, FILTER_MAP_NEXT, CHECKED_CONVERSIONS, MANUAL_RANGE_CONTAINS, USE_SELF, MEM_REPLACE_WITH_DEFAULT, MANUAL_NON_EXHAUSTIVE, OPTION_AS_REF_DEREF, MAP_UNWRAP_OR, MATCH_LIKE_MATCHES_MACRO, MANUAL_STRIP, MISSING_CONST_FOR_FN, UNNESTED_OR_PATTERNS, FROM_OVER_INTO, PTR_AS_PTR, IF_THEN_SOME_ELSE_NONE.\n+    /// Lint: MANUAL_SPLIT_ONCE, MANUAL_STR_REPEAT, CLONED_INSTEAD_OF_COPIED, REDUNDANT_FIELD_NAMES, REDUNDANT_STATIC_LIFETIMES, FILTER_MAP_NEXT, CHECKED_CONVERSIONS, MANUAL_RANGE_CONTAINS, USE_SELF, MEM_REPLACE_WITH_DEFAULT, MANUAL_NON_EXHAUSTIVE, OPTION_AS_REF_DEREF, MAP_UNWRAP_OR, MATCH_LIKE_MATCHES_MACRO, MANUAL_STRIP, MISSING_CONST_FOR_FN, UNNESTED_OR_PATTERNS, FROM_OVER_INTO, PTR_AS_PTR, IF_THEN_SOME_ELSE_NONE.\n     ///\n     /// The minimum rust version that the project supports\n     (msrv: Option<String> = None),"}, {"sha": "9302e5c21faa4f7606d485726bcbf256aba1cfb8", "filename": "clippy_utils/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4/clippy_utils%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4/clippy_utils%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fdiagnostics.rs?ref=1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4", "patch": "@@ -21,7 +21,7 @@ fn docs_link(diag: &mut DiagnosticBuilder<'_>, lint: &'static Lint) {\n                 \"for further information visit https://rust-lang.github.io/rust-clippy/{}/index.html#{}\",\n                 &option_env!(\"RUST_RELEASE_NUM\").map_or(\"master\".to_string(), |n| {\n                     // extract just major + minor version and ignore patch versions\n-                    format!(\"rust-{}\", n.rsplitn(2, '.').nth(1).unwrap())\n+                    format!(\"rust-{}\", n.rsplit_once('.').unwrap().1)\n                 }),\n                 lint\n             ));"}, {"sha": "603e831459d38df6cb13f450a35cefa0bc36d98a", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4", "patch": "@@ -2,6 +2,7 @@\n #![feature(in_band_lifetimes)]\n #![feature(iter_zip)]\n #![feature(rustc_private)]\n+#![feature(control_flow_enum)]\n #![recursion_limit = \"512\"]\n #![cfg_attr(feature = \"deny-warnings\", deny(warnings))]\n #![allow(clippy::missing_errors_doc, clippy::missing_panics_doc, clippy::must_use_candidate)]"}, {"sha": "14234d9c9cbf0d6ce4384f7ae8b97a9294afc387", "filename": "clippy_utils/src/msrvs.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4/clippy_utils%2Fsrc%2Fmsrvs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4/clippy_utils%2Fsrc%2Fmsrvs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fmsrvs.rs?ref=1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4", "patch": "@@ -13,6 +13,7 @@ macro_rules! msrv_aliases {\n // names may refer to stabilized feature flags or library items\n msrv_aliases! {\n     1,53,0 { OR_PATTERNS }\n+    1,52,0 { STR_SPLIT_ONCE }\n     1,50,0 { BOOL_THEN }\n     1,46,0 { CONST_IF_MATCH }\n     1,45,0 { STR_STRIP_PREFIX }"}, {"sha": "d7e46c2d3eb9d2826966f19fc3d8f98b058a150d", "filename": "clippy_utils/src/paths.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4/clippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4/clippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fpaths.rs?ref=1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4", "patch": "@@ -68,6 +68,7 @@ pub const IO_WRITE: [&str; 3] = [\"std\", \"io\", \"Write\"];\n pub const IPADDR_V4: [&str; 5] = [\"std\", \"net\", \"ip\", \"IpAddr\", \"V4\"];\n pub const IPADDR_V6: [&str; 5] = [\"std\", \"net\", \"ip\", \"IpAddr\", \"V6\"];\n pub const ITER_REPEAT: [&str; 5] = [\"core\", \"iter\", \"sources\", \"repeat\", \"repeat\"];\n+pub const ITERTOOLS_NEXT_TUPLE: [&str; 3] = [\"itertools\", \"Itertools\", \"next_tuple\"];\n #[cfg(feature = \"internal-lints\")]\n pub const KW_MODULE: [&str; 3] = [\"rustc_span\", \"symbol\", \"kw\"];\n #[cfg(feature = \"internal-lints\")]"}, {"sha": "503effbdad5725069eb4ddc268a08c80ae7b9014", "filename": "clippy_utils/src/visitors.rs", "status": "modified", "additions": 61, "deletions": 56, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4/clippy_utils%2Fsrc%2Fvisitors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4/clippy_utils%2Fsrc%2Fvisitors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fvisitors.rs?ref=1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4", "patch": "@@ -4,6 +4,7 @@ use rustc_hir::intravisit::{self, walk_expr, ErasedMap, NestedVisitorMap, Visito\n use rustc_hir::{def::Res, Arm, Block, Body, BodyId, Destination, Expr, ExprKind, HirId, Stmt};\n use rustc_lint::LateContext;\n use rustc_middle::hir::map::Map;\n+use std::ops::ControlFlow;\n \n /// returns `true` if expr contains match expr desugared from try\n fn contains_try(expr: &hir::Expr<'_>) -> bool {\n@@ -133,62 +134,6 @@ where\n     }\n }\n \n-pub struct LocalUsedVisitor<'hir> {\n-    hir: Map<'hir>,\n-    pub local_hir_id: HirId,\n-    pub used: bool,\n-}\n-\n-impl<'hir> LocalUsedVisitor<'hir> {\n-    pub fn new(cx: &LateContext<'hir>, local_hir_id: HirId) -> Self {\n-        Self {\n-            hir: cx.tcx.hir(),\n-            local_hir_id,\n-            used: false,\n-        }\n-    }\n-\n-    fn check<T>(&mut self, t: T, visit: fn(&mut Self, T)) -> bool {\n-        visit(self, t);\n-        std::mem::replace(&mut self.used, false)\n-    }\n-\n-    pub fn check_arm(&mut self, arm: &'hir Arm<'_>) -> bool {\n-        self.check(arm, Self::visit_arm)\n-    }\n-\n-    pub fn check_body(&mut self, body: &'hir Body<'_>) -> bool {\n-        self.check(body, Self::visit_body)\n-    }\n-\n-    pub fn check_expr(&mut self, expr: &'hir Expr<'_>) -> bool {\n-        self.check(expr, Self::visit_expr)\n-    }\n-\n-    pub fn check_stmt(&mut self, stmt: &'hir Stmt<'_>) -> bool {\n-        self.check(stmt, Self::visit_stmt)\n-    }\n-}\n-\n-impl<'v> Visitor<'v> for LocalUsedVisitor<'v> {\n-    type Map = Map<'v>;\n-\n-    fn visit_expr(&mut self, expr: &'v Expr<'v>) {\n-        if self.used {\n-            return;\n-        }\n-        if path_to_local_id(expr, self.local_hir_id) {\n-            self.used = true;\n-        } else {\n-            walk_expr(self, expr);\n-        }\n-    }\n-\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::OnlyBodies(self.hir)\n-    }\n-}\n-\n /// A type which can be visited.\n pub trait Visitable<'tcx> {\n     /// Calls the corresponding `visit_*` function on the visitor.\n@@ -203,7 +148,22 @@ macro_rules! visitable_ref {\n         }\n     };\n }\n+visitable_ref!(Arm, visit_arm);\n visitable_ref!(Block, visit_block);\n+visitable_ref!(Body, visit_body);\n+visitable_ref!(Expr, visit_expr);\n+visitable_ref!(Stmt, visit_stmt);\n+\n+// impl<'tcx, I: IntoIterator> Visitable<'tcx> for I\n+// where\n+//     I::Item: Visitable<'tcx>,\n+// {\n+//     fn visit<V: Visitor<'tcx>>(self, visitor: &mut V) {\n+//         for x in self {\n+//             x.visit(visitor);\n+//         }\n+//     }\n+// }\n \n /// Calls the given function for each break expression.\n pub fn visit_break_exprs<'tcx>(\n@@ -260,3 +220,48 @@ pub fn is_res_used(cx: &LateContext<'_>, res: Res, body: BodyId) -> bool {\n     v.visit_expr(&cx.tcx.hir().body(body).value);\n     v.found\n }\n+\n+/// Calls the given function for each usage of the given local.\n+pub fn for_each_local_usage<'tcx, B>(\n+    cx: &LateContext<'tcx>,\n+    visitable: impl Visitable<'tcx>,\n+    id: HirId,\n+    f: impl FnMut(&'tcx Expr<'tcx>) -> ControlFlow<B>,\n+) -> ControlFlow<B> {\n+    struct V<'tcx, B, F> {\n+        map: Map<'tcx>,\n+        id: HirId,\n+        f: F,\n+        res: ControlFlow<B>,\n+    }\n+    impl<'tcx, B, F: FnMut(&'tcx Expr<'tcx>) -> ControlFlow<B>> Visitor<'tcx> for V<'tcx, B, F> {\n+        type Map = Map<'tcx>;\n+        fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+            NestedVisitorMap::OnlyBodies(self.map)\n+        }\n+\n+        fn visit_expr(&mut self, e: &'tcx Expr<'_>) {\n+            if self.res.is_continue() {\n+                if path_to_local_id(e, self.id) {\n+                    self.res = (self.f)(e);\n+                } else {\n+                    walk_expr(self, e);\n+                }\n+            }\n+        }\n+    }\n+\n+    let mut v = V {\n+        map: cx.tcx.hir(),\n+        id,\n+        f,\n+        res: ControlFlow::CONTINUE,\n+    };\n+    visitable.visit(&mut v);\n+    v.res\n+}\n+\n+/// Checks if the given local is used.\n+pub fn is_local_used(cx: &LateContext<'tcx>, visitable: impl Visitable<'tcx>, id: HirId) -> bool {\n+    for_each_local_usage(cx, visitable, id, |_| ControlFlow::BREAK).is_break()\n+}"}, {"sha": "6116acffe07f4a4db75c12de2600a2f7547e8587", "filename": "tests/compile-test.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4/tests%2Fcompile-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4/tests%2Fcompile-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-test.rs?ref=1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4", "patch": "@@ -39,6 +39,7 @@ fn third_party_crates() -> String {\n         \"clippy_lints\",\n         \"clippy_utils\",\n         \"if_chain\",\n+        \"itertools\",\n         \"quote\",\n         \"regex\",\n         \"serde\","}, {"sha": "3a0332939d409a8237572e97d489bce948b44817", "filename": "tests/ui/manual_split_once.fixed", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4/tests%2Fui%2Fmanual_split_once.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4/tests%2Fui%2Fmanual_split_once.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_split_once.fixed?ref=1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4", "patch": "@@ -0,0 +1,50 @@\n+// run-rustfix\n+\n+#![feature(custom_inner_attributes)]\n+#![warn(clippy::manual_split_once)]\n+#![allow(clippy::iter_skip_next, clippy::iter_nth_zero)]\n+\n+extern crate itertools;\n+\n+#[allow(unused_imports)]\n+use itertools::Itertools;\n+\n+fn main() {\n+    let _ = Some(\"key=value\".split_once('=').map_or(\"key=value\", |x| x.0));\n+    let _ = \"key=value\".splitn(2, '=').nth(2);\n+    let _ = \"key=value\".split_once('=').map_or(\"key=value\", |x| x.0);\n+    let _ = \"key=value\".split_once('=').map_or(\"key=value\", |x| x.0);\n+    let _ = \"key=value\".split_once('=').unwrap().1;\n+    let _ = \"key=value\".split_once('=').unwrap().1;\n+    let (_, _) = \"key=value\".split_once('=').unwrap();\n+\n+    let s = String::from(\"key=value\");\n+    let _ = s.split_once('=').map_or(&*s, |x| x.0);\n+\n+    let s = Box::<str>::from(\"key=value\");\n+    let _ = s.split_once('=').map_or(&*s, |x| x.0);\n+\n+    let s = &\"key=value\";\n+    let _ = s.split_once('=').map_or(*s, |x| x.0);\n+\n+    fn _f(s: &str) -> Option<&str> {\n+        let _ = s.split_once(\"key=value\").map_or(s, |x| x.0);\n+        let _ = s.split_once(\"key=value\")?.1;\n+        let _ = s.split_once(\"key=value\")?.1;\n+        None\n+    }\n+\n+    // Don't lint, slices don't have `split_once`\n+    let _ = [0, 1, 2].splitn(2, |&x| x == 1).nth(1).unwrap();\n+}\n+\n+fn _msrv_1_51() {\n+    #![clippy::msrv = \"1.51\"]\n+    // `str::split_once` was stabilized in 1.16. Do not lint this\n+    let _ = \"key=value\".splitn(2, '=').nth(1).unwrap();\n+}\n+\n+fn _msrv_1_52() {\n+    #![clippy::msrv = \"1.52\"]\n+    let _ = \"key=value\".split_once('=').unwrap().1;\n+}"}, {"sha": "e6093b63fe8d428e348760d6a496a3ae4d433090", "filename": "tests/ui/manual_split_once.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4/tests%2Fui%2Fmanual_split_once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4/tests%2Fui%2Fmanual_split_once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_split_once.rs?ref=1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4", "patch": "@@ -0,0 +1,50 @@\n+// run-rustfix\n+\n+#![feature(custom_inner_attributes)]\n+#![warn(clippy::manual_split_once)]\n+#![allow(clippy::iter_skip_next, clippy::iter_nth_zero)]\n+\n+extern crate itertools;\n+\n+#[allow(unused_imports)]\n+use itertools::Itertools;\n+\n+fn main() {\n+    let _ = \"key=value\".splitn(2, '=').next();\n+    let _ = \"key=value\".splitn(2, '=').nth(2);\n+    let _ = \"key=value\".splitn(2, '=').next().unwrap();\n+    let _ = \"key=value\".splitn(2, '=').nth(0).unwrap();\n+    let _ = \"key=value\".splitn(2, '=').nth(1).unwrap();\n+    let _ = \"key=value\".splitn(2, '=').skip(1).next().unwrap();\n+    let (_, _) = \"key=value\".splitn(2, '=').next_tuple().unwrap();\n+\n+    let s = String::from(\"key=value\");\n+    let _ = s.splitn(2, '=').next().unwrap();\n+\n+    let s = Box::<str>::from(\"key=value\");\n+    let _ = s.splitn(2, '=').nth(0).unwrap();\n+\n+    let s = &\"key=value\";\n+    let _ = s.splitn(2, '=').skip(0).next().unwrap();\n+\n+    fn _f(s: &str) -> Option<&str> {\n+        let _ = s.splitn(2, \"key=value\").next()?;\n+        let _ = s.splitn(2, \"key=value\").nth(1)?;\n+        let _ = s.splitn(2, \"key=value\").skip(1).next()?;\n+        None\n+    }\n+\n+    // Don't lint, slices don't have `split_once`\n+    let _ = [0, 1, 2].splitn(2, |&x| x == 1).nth(1).unwrap();\n+}\n+\n+fn _msrv_1_51() {\n+    #![clippy::msrv = \"1.51\"]\n+    // `str::split_once` was stabilized in 1.16. Do not lint this\n+    let _ = \"key=value\".splitn(2, '=').nth(1).unwrap();\n+}\n+\n+fn _msrv_1_52() {\n+    #![clippy::msrv = \"1.52\"]\n+    let _ = \"key=value\".splitn(2, '=').nth(1).unwrap();\n+}"}, {"sha": "4f15196b469e1f73d713f527edca2c57b22af889", "filename": "tests/ui/manual_split_once.stderr", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4/tests%2Fui%2Fmanual_split_once.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4/tests%2Fui%2Fmanual_split_once.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_split_once.stderr?ref=1fc1aee7be6e7e71f12eacd60b9b1040e7640fe4", "patch": "@@ -0,0 +1,82 @@\n+error: manual implementation of `split_once`\n+  --> $DIR/manual_split_once.rs:13:13\n+   |\n+LL |     let _ = \"key=value\".splitn(2, '=').next();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `Some(\"key=value\".split_once('=').map_or(\"key=value\", |x| x.0))`\n+   |\n+   = note: `-D clippy::manual-split-once` implied by `-D warnings`\n+\n+error: manual implementation of `split_once`\n+  --> $DIR/manual_split_once.rs:15:13\n+   |\n+LL |     let _ = \"key=value\".splitn(2, '=').next().unwrap();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"key=value\".split_once('=').map_or(\"key=value\", |x| x.0)`\n+\n+error: manual implementation of `split_once`\n+  --> $DIR/manual_split_once.rs:16:13\n+   |\n+LL |     let _ = \"key=value\".splitn(2, '=').nth(0).unwrap();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"key=value\".split_once('=').map_or(\"key=value\", |x| x.0)`\n+\n+error: manual implementation of `split_once`\n+  --> $DIR/manual_split_once.rs:17:13\n+   |\n+LL |     let _ = \"key=value\".splitn(2, '=').nth(1).unwrap();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"key=value\".split_once('=').unwrap().1`\n+\n+error: manual implementation of `split_once`\n+  --> $DIR/manual_split_once.rs:18:13\n+   |\n+LL |     let _ = \"key=value\".splitn(2, '=').skip(1).next().unwrap();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"key=value\".split_once('=').unwrap().1`\n+\n+error: manual implementation of `split_once`\n+  --> $DIR/manual_split_once.rs:19:18\n+   |\n+LL |     let (_, _) = \"key=value\".splitn(2, '=').next_tuple().unwrap();\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"key=value\".split_once('=')`\n+\n+error: manual implementation of `split_once`\n+  --> $DIR/manual_split_once.rs:22:13\n+   |\n+LL |     let _ = s.splitn(2, '=').next().unwrap();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `s.split_once('=').map_or(&*s, |x| x.0)`\n+\n+error: manual implementation of `split_once`\n+  --> $DIR/manual_split_once.rs:25:13\n+   |\n+LL |     let _ = s.splitn(2, '=').nth(0).unwrap();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `s.split_once('=').map_or(&*s, |x| x.0)`\n+\n+error: manual implementation of `split_once`\n+  --> $DIR/manual_split_once.rs:28:13\n+   |\n+LL |     let _ = s.splitn(2, '=').skip(0).next().unwrap();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `s.split_once('=').map_or(*s, |x| x.0)`\n+\n+error: manual implementation of `split_once`\n+  --> $DIR/manual_split_once.rs:31:17\n+   |\n+LL |         let _ = s.splitn(2, \"key=value\").next()?;\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `s.split_once(\"key=value\").map_or(s, |x| x.0)`\n+\n+error: manual implementation of `split_once`\n+  --> $DIR/manual_split_once.rs:32:17\n+   |\n+LL |         let _ = s.splitn(2, \"key=value\").nth(1)?;\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `s.split_once(\"key=value\")?.1`\n+\n+error: manual implementation of `split_once`\n+  --> $DIR/manual_split_once.rs:33:17\n+   |\n+LL |         let _ = s.splitn(2, \"key=value\").skip(1).next()?;\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `s.split_once(\"key=value\")?.1`\n+\n+error: manual implementation of `split_once`\n+  --> $DIR/manual_split_once.rs:49:13\n+   |\n+LL |     let _ = \"key=value\".splitn(2, '=').nth(1).unwrap();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"key=value\".split_once('=').unwrap().1`\n+\n+error: aborting due to 13 previous errors\n+"}]}