{"sha": "dc2afae991892719b97b0e4b40d8483b43b08680", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjMmFmYWU5OTE4OTI3MTliOTdiMGU0YjQwZDg0ODNiNDNiMDg2ODA=", "commit": {"author": {"name": "Bernardo", "email": "berublan@gmail.com", "date": "2018-12-22T19:52:43Z"}, "committer": {"name": "Bernardo", "email": "berublan@gmail.com", "date": "2018-12-25T19:03:14Z"}, "message": "fix arbitrary offset generation, col translation working", "tree": {"sha": "67509ccaf4599caa102a494521e9597e1453f30f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/67509ccaf4599caa102a494521e9597e1453f30f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dc2afae991892719b97b0e4b40d8483b43b08680", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dc2afae991892719b97b0e4b40d8483b43b08680", "html_url": "https://github.com/rust-lang/rust/commit/dc2afae991892719b97b0e4b40d8483b43b08680", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dc2afae991892719b97b0e4b40d8483b43b08680/comments", "author": {"login": "vemoo", "id": 4866051, "node_id": "MDQ6VXNlcjQ4NjYwNTE=", "avatar_url": "https://avatars.githubusercontent.com/u/4866051?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vemoo", "html_url": "https://github.com/vemoo", "followers_url": "https://api.github.com/users/vemoo/followers", "following_url": "https://api.github.com/users/vemoo/following{/other_user}", "gists_url": "https://api.github.com/users/vemoo/gists{/gist_id}", "starred_url": "https://api.github.com/users/vemoo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vemoo/subscriptions", "organizations_url": "https://api.github.com/users/vemoo/orgs", "repos_url": "https://api.github.com/users/vemoo/repos", "events_url": "https://api.github.com/users/vemoo/events{/privacy}", "received_events_url": "https://api.github.com/users/vemoo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "vemoo", "id": 4866051, "node_id": "MDQ6VXNlcjQ4NjYwNTE=", "avatar_url": "https://avatars.githubusercontent.com/u/4866051?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vemoo", "html_url": "https://github.com/vemoo", "followers_url": "https://api.github.com/users/vemoo/followers", "following_url": "https://api.github.com/users/vemoo/following{/other_user}", "gists_url": "https://api.github.com/users/vemoo/gists{/gist_id}", "starred_url": "https://api.github.com/users/vemoo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vemoo/subscriptions", "organizations_url": "https://api.github.com/users/vemoo/orgs", "repos_url": "https://api.github.com/users/vemoo/repos", "events_url": "https://api.github.com/users/vemoo/events{/privacy}", "received_events_url": "https://api.github.com/users/vemoo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c8525ce4ae8bb969f2ac263bf14adad1c835c03", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c8525ce4ae8bb969f2ac263bf14adad1c835c03", "html_url": "https://github.com/rust-lang/rust/commit/5c8525ce4ae8bb969f2ac263bf14adad1c835c03"}], "stats": {"total": 131, "additions": 92, "deletions": 39}, "files": [{"sha": "b01760313cb7570e3b9aa638d217de0e4851e171", "filename": "crates/ra_editor/src/line_index.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/dc2afae991892719b97b0e4b40d8483b43b08680/crates%2Fra_editor%2Fsrc%2Fline_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc2afae991892719b97b0e4b40d8483b43b08680/crates%2Fra_editor%2Fsrc%2Fline_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fline_index.rs?ref=dc2afae991892719b97b0e4b40d8483b43b08680", "patch": "@@ -62,6 +62,12 @@ impl LineIndex {\n \n             curr_col += char_len;\n         }\n+\n+        // Save any utf-16 characters seen in the last line\n+        if utf16_chars.len() > 0 {\n+            utf16_lines.insert(line, utf16_chars);\n+        }\n+\n         LineIndex {\n             newlines,\n             utf16_lines,\n@@ -122,6 +128,28 @@ impl LineIndex {\n     }\n }\n \n+// for bench and test\n+pub fn to_line_col(text: &str, offset: TextUnit) -> LineCol {\n+    let mut res = LineCol {\n+        line: 0,\n+        col_utf16: 0,\n+    };\n+    for (i, c) in text.char_indices() {\n+        if i + c.len_utf8() > offset.to_usize() {\n+            // if it's an invalid offset, inside a multibyte char\n+            // return as if it was at the start of the char\n+            break;\n+        }\n+        if c == '\\n' {\n+            res.line += 1;\n+            res.col_utf16 = 0;\n+        } else {\n+            res.col_utf16 += 1;\n+        }\n+    }\n+    res\n+}\n+\n #[test]\n fn test_line_index() {\n     let text = \"hello\\nworld\";"}, {"sha": "913ca5b150f5d6d4ba82fb63b9d84608c4822210", "filename": "crates/ra_editor/src/line_index_utils.rs", "status": "modified", "additions": 64, "deletions": 39, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/dc2afae991892719b97b0e4b40d8483b43b08680/crates%2Fra_editor%2Fsrc%2Fline_index_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc2afae991892719b97b0e4b40d8483b43b08680/crates%2Fra_editor%2Fsrc%2Fline_index_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fline_index_utils.rs?ref=dc2afae991892719b97b0e4b40d8483b43b08680", "patch": "@@ -1,6 +1,6 @@\n use ra_text_edit::AtomTextEdit;\n use ra_syntax::{TextUnit, TextRange};\n-use crate::{LineIndex, LineCol, line_index::Utf16Char};\n+use crate::{LineIndex, LineCol, line_index::Utf16Char, line_index};\n use superslice::Ext;\n \n #[derive(Debug, Clone)]\n@@ -154,7 +154,7 @@ impl<'a, 'b> Edits<'a, 'b> {\n     fn next_step(&mut self, step: &Step) -> NextNewlines {\n         let step_pos = match step {\n             &Step::Newline(n) => n,\n-            &Step::Utf16Char(r) => r.start(),\n+            &Step::Utf16Char(r) => r.end(),\n         };\n         let res = match &mut self.current {\n             Some(edit) => {\n@@ -214,6 +214,40 @@ impl<'a, 'b> Edits<'a, 'b> {\n     }\n }\n \n+#[derive(Debug)]\n+struct RunningLineCol {\n+    line: u32,\n+    last_newline: TextUnit,\n+    col_adjust: TextUnit,\n+}\n+\n+impl RunningLineCol {\n+    fn new() -> RunningLineCol {\n+        RunningLineCol {\n+            line: 0,\n+            last_newline: TextUnit::from(0),\n+            col_adjust: TextUnit::from(0),\n+        }\n+    }\n+\n+    fn to_line_col(&self, offset: TextUnit) -> LineCol {\n+        LineCol {\n+            line: self.line,\n+            col_utf16: ((offset - self.last_newline) - self.col_adjust).into(),\n+        }\n+    }\n+\n+    fn add_line(&mut self, newline: TextUnit) {\n+        self.line += 1;\n+        self.last_newline = newline;\n+        self.col_adjust = TextUnit::from(0);\n+    }\n+\n+    fn adjust_col(&mut self, range: &TextRange) {\n+        self.col_adjust += range.len() - TextUnit::from(1);\n+    }\n+}\n+\n pub fn translate_offset_with_edit(\n     line_index: &LineIndex,\n     offset: TextUnit,\n@@ -228,49 +262,35 @@ pub fn translate_offset_with_edit(\n \n     let mut state = Edits::new(&sorted_edits);\n \n-    let mut pos: LineCol = LineCol {\n-        line: 0,\n-        col_utf16: 0,\n-    };\n-\n-    let mut last_newline: TextUnit = TextUnit::from(0);\n-    let mut col_adjust: TextUnit = TextUnit::from(0);\n+    let mut res = RunningLineCol::new();\n \n     macro_rules! test_step {\n         ($x:ident) => {\n             match &$x {\n                 Step::Newline(n) => {\n                     if offset < *n {\n-                        return_pos!();\n+                        return res.to_line_col(offset);\n                     } else if offset == *n {\n-                        pos.line += 1;\n-                        pos.col_utf16 = 0;\n-                        return pos;\n+                        res.add_line(*n);\n+                        return res.to_line_col(offset);\n                     } else {\n-                        pos.line += 1;\n-                        pos.col_utf16 = 0;\n-                        last_newline = *n;\n-                        col_adjust = TextUnit::from(0);\n+                        res.add_line(*n);\n                     }\n                 }\n                 Step::Utf16Char(x) => {\n                     if offset < x.end() {\n-                        return_pos!();\n+                        // if the offset is inside a multibyte char it's invalid\n+                        // clamp it to the start of the char\n+                        let clamp = offset.min(x.start());\n+                        return res.to_line_col(clamp);\n                     } else {\n-                        col_adjust += x.len() - TextUnit::from(1);\n+                        res.adjust_col(x);\n                     }\n                 }\n             }\n         };\n     }\n \n-    macro_rules! return_pos {\n-        () => {\n-            pos.col_utf16 = ((offset - last_newline) - col_adjust).into();\n-            return pos;\n-        };\n-    }\n-\n     for orig_step in LineIndexStepIter::from(line_index) {\n         loop {\n             let translated_step = state.translate_step(&orig_step);\n@@ -305,7 +325,7 @@ pub fn translate_offset_with_edit(\n         }\n     }\n \n-    return_pos!();\n+    res.to_line_col(offset)\n }\n \n // for bench\n@@ -315,8 +335,7 @@ pub fn translate_after_edit(\n     edits: Vec<AtomTextEdit>,\n ) -> LineCol {\n     let text = edit_text(pre_edit_text, edits);\n-    let line_index = LineIndex::new(&text);\n-    line_index.line_col(offset)\n+    line_index::to_line_col(&text, offset)\n }\n \n fn edit_text(pre_edit_text: &str, mut edits: Vec<AtomTextEdit>) -> String {\n@@ -343,32 +362,38 @@ mod test {\n     #[derive(Debug)]\n     struct ArbTextWithOffsetAndEdits {\n         text: String,\n+        edited_text: String,\n         offset: TextUnit,\n         edits: Vec<AtomTextEdit>,\n     }\n \n     fn arb_text_with_offset_and_edits() -> BoxedStrategy<ArbTextWithOffsetAndEdits> {\n         arb_text()\n             .prop_flat_map(|text| {\n-                (arb_offset(&text), arb_edits(&text), Just(text)).prop_map(\n-                    |(offset, edits, text)| ArbTextWithOffsetAndEdits {\n-                        text,\n-                        offset,\n-                        edits,\n-                    },\n-                )\n+                (arb_edits(&text), Just(text)).prop_flat_map(|(edits, text)| {\n+                    let edited_text = edit_text(&text, edits.clone());\n+                    let arb_offset = arb_offset(&edited_text);\n+                    (Just(text), Just(edited_text), Just(edits), arb_offset).prop_map(\n+                        |(text, edited_text, edits, offset)| ArbTextWithOffsetAndEdits {\n+                            text,\n+                            edits,\n+                            edited_text,\n+                            offset,\n+                        },\n+                    )\n+                })\n             })\n             .boxed()\n     }\n \n     proptest! {\n         #[test]\n         fn test_translate_offset_with_edit(x in arb_text_with_offset_and_edits()) {\n+            let expected = line_index::to_line_col(&x.edited_text, x.offset);\n             let line_index = LineIndex::new(&x.text);\n-            let expected = translate_after_edit(&x.text, x.offset, x.edits.clone());\n             let actual = translate_offset_with_edit(&line_index, x.offset, &x.edits);\n-            // assert_eq!(actual, expected);\n-            assert_eq!(actual.line, expected.line);\n+\n+            assert_eq!(actual, expected);\n         }\n     }\n }"}]}