{"sha": "22f1ad75e95500b3cab1d07c80d04c34d0f15f96", "node_id": "C_kwDOAAsO6NoAKDIyZjFhZDc1ZTk1NTAwYjNjYWIxZDA3YzgwZDA0YzM0ZDBmMTVmOTY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-10-30T04:12:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-10-30T04:12:40Z"}, "message": "Auto merge of #88268 - GuillaumeGomez:generics-search-index, r=notriddle,camelid,jyn514\n\nrustdoc: Fix generics generation in search index\n\nThe generics were not added to the search index as they should, instead they were added as arguments. I used this opportunity to allow generics to have generics themselves (will come in very handy for my current rewrite of the search engine!).\n\nr? `@jyn514`", "tree": {"sha": "ada98184608b4830994f375713d3a8d655cc1632", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ada98184608b4830994f375713d3a8d655cc1632"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/22f1ad75e95500b3cab1d07c80d04c34d0f15f96", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/22f1ad75e95500b3cab1d07c80d04c34d0f15f96", "html_url": "https://github.com/rust-lang/rust/commit/22f1ad75e95500b3cab1d07c80d04c34d0f15f96", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/22f1ad75e95500b3cab1d07c80d04c34d0f15f96/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "021947d37a30cbfc34695b5933833ecc23bc3aeb", "url": "https://api.github.com/repos/rust-lang/rust/commits/021947d37a30cbfc34695b5933833ecc23bc3aeb", "html_url": "https://github.com/rust-lang/rust/commit/021947d37a30cbfc34695b5933833ecc23bc3aeb"}, {"sha": "355e6eddfed1d2d30f04b2a6b3793a47bb432342", "url": "https://api.github.com/repos/rust-lang/rust/commits/355e6eddfed1d2d30f04b2a6b3793a47bb432342", "html_url": "https://github.com/rust-lang/rust/commit/355e6eddfed1d2d30f04b2a6b3793a47bb432342"}], "stats": {"total": 240, "additions": 147, "deletions": 93}, "files": [{"sha": "793db16faf38517dd5954e98b1bfaab9804bf425", "filename": "src/librustdoc/formats/item_type.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22f1ad75e95500b3cab1d07c80d04c34d0f15f96/src%2Flibrustdoc%2Fformats%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22f1ad75e95500b3cab1d07c80d04c34d0f15f96/src%2Flibrustdoc%2Fformats%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fitem_type.rs?ref=22f1ad75e95500b3cab1d07c80d04c34d0f15f96", "patch": "@@ -48,6 +48,7 @@ crate enum ItemType {\n     ProcAttribute = 23,\n     ProcDerive = 24,\n     TraitAlias = 25,\n+    Generic = 26,\n }\n \n impl Serialize for ItemType {\n@@ -173,6 +174,7 @@ impl ItemType {\n             ItemType::ProcAttribute => \"attr\",\n             ItemType::ProcDerive => \"derive\",\n             ItemType::TraitAlias => \"traitalias\",\n+            ItemType::Generic => \"generic\",\n         }\n     }\n }"}, {"sha": "37b2cf0262403638820dc550a8eb4b9d8f825343", "filename": "src/librustdoc/html/render/cache.rs", "status": "modified", "additions": 95, "deletions": 75, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/22f1ad75e95500b3cab1d07c80d04c34d0f15f96/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22f1ad75e95500b3cab1d07c80d04c34d0f15f96/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs?ref=22f1ad75e95500b3cab1d07c80d04c34d0f15f96", "patch": "@@ -1,7 +1,7 @@\n use std::collections::hash_map::Entry;\n use std::collections::BTreeMap;\n \n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::symbol::Symbol;\n use serde::ser::{Serialize, SerializeStruct, Serializer};\n@@ -192,32 +192,24 @@ crate fn get_index_search_type<'tcx>(\n     item: &clean::Item,\n     tcx: TyCtxt<'tcx>,\n ) -> Option<IndexItemFunctionType> {\n-    let (all_types, ret_types) = match *item.kind {\n+    let (mut inputs, mut output) = match *item.kind {\n         clean::FunctionItem(ref f) => get_all_types(&f.generics, &f.decl, tcx),\n         clean::MethodItem(ref m, _) => get_all_types(&m.generics, &m.decl, tcx),\n         clean::TyMethodItem(ref m) => get_all_types(&m.generics, &m.decl, tcx),\n         _ => return None,\n     };\n \n-    let inputs = all_types\n-        .iter()\n-        .map(|(ty, kind)| TypeWithKind::from((get_index_type(ty), *kind)))\n-        .filter(|a| a.ty.name.is_some())\n-        .collect();\n-    let output = ret_types\n-        .iter()\n-        .map(|(ty, kind)| TypeWithKind::from((get_index_type(ty), *kind)))\n-        .filter(|a| a.ty.name.is_some())\n-        .collect::<Vec<_>>();\n+    inputs.retain(|a| a.ty.name.is_some());\n+    output.retain(|a| a.ty.name.is_some());\n     let output = if output.is_empty() { None } else { Some(output) };\n \n     Some(IndexItemFunctionType { inputs, output })\n }\n \n-fn get_index_type(clean_type: &clean::Type) -> RenderType {\n+fn get_index_type(clean_type: &clean::Type, generics: Vec<TypeWithKind>) -> RenderType {\n     RenderType {\n         name: get_index_type_name(clean_type, true).map(|s| s.as_str().to_ascii_lowercase()),\n-        generics: get_generics(clean_type),\n+        generics: if generics.is_empty() { None } else { Some(generics) },\n     }\n }\n \n@@ -246,23 +238,6 @@ fn get_index_type_name(clean_type: &clean::Type, accept_generic: bool) -> Option\n     }\n }\n \n-/// Return a list of generic parameters for use in the search index.\n-///\n-/// This function replaces bounds with types, so that `T where T: Debug` just becomes `Debug`.\n-/// It does return duplicates, and that's intentional, since search queries like `Result<usize, usize>`\n-/// are supposed to match only results where both parameters are `usize`.\n-fn get_generics(clean_type: &clean::Type) -> Option<Vec<String>> {\n-    clean_type.generics().and_then(|types| {\n-        let r = types\n-            .iter()\n-            .filter_map(|t| {\n-                get_index_type_name(t, false).map(|name| name.as_str().to_ascii_lowercase())\n-            })\n-            .collect::<Vec<_>>();\n-        if r.is_empty() { None } else { Some(r) }\n-    })\n-}\n-\n /// The point of this function is to replace bounds with types.\n ///\n /// i.e. `[T, U]` when you have the following bounds: `T: Display, U: Option<T>` will return\n@@ -272,27 +247,77 @@ crate fn get_real_types<'tcx>(\n     generics: &Generics,\n     arg: &Type,\n     tcx: TyCtxt<'tcx>,\n-    recurse: i32,\n-    res: &mut FxHashSet<(Type, ItemType)>,\n-) -> usize {\n-    fn insert(res: &mut FxHashSet<(Type, ItemType)>, tcx: TyCtxt<'_>, ty: Type) -> usize {\n-        if let Some(kind) = ty.def_id_no_primitives().map(|did| tcx.def_kind(did).into()) {\n-            res.insert((ty, kind));\n-            1\n+    recurse: usize,\n+    res: &mut Vec<TypeWithKind>,\n+) {\n+    fn insert_ty(\n+        res: &mut Vec<TypeWithKind>,\n+        tcx: TyCtxt<'_>,\n+        ty: Type,\n+        mut generics: Vec<TypeWithKind>,\n+    ) {\n+        let is_full_generic = ty.is_full_generic();\n+\n+        if is_full_generic && generics.len() == 1 {\n+            // In this case, no need to go through an intermediate state if the generics\n+            // contains only one element.\n+            //\n+            // For example:\n+            //\n+            // fn foo<T: Display>(r: Option<T>) {}\n+            //\n+            // In this case, it would contain:\n+            //\n+            // ```\n+            // [{\n+            //     name: \"option\",\n+            //     generics: [{\n+            //         name: \"\",\n+            //         generics: [\n+            //             name: \"Display\",\n+            //             generics: []\n+            //         }]\n+            //     }]\n+            // }]\n+            // ```\n+            //\n+            // After removing the intermediate (unnecessary) full generic, it'll become:\n+            //\n+            // ```\n+            // [{\n+            //     name: \"option\",\n+            //     generics: [{\n+            //         name: \"Display\",\n+            //         generics: []\n+            //     }]\n+            // }]\n+            // ```\n+            //\n+            // To be noted that it can work if there is ONLY ONE generic, otherwise we still\n+            // need to keep it as is!\n+            res.push(generics.pop().unwrap());\n+            return;\n+        }\n+        let mut index_ty = get_index_type(&ty, generics);\n+        if index_ty.name.as_ref().map(|s| s.is_empty()).unwrap_or(true) {\n+            return;\n+        }\n+        if is_full_generic {\n+            // We remove the name of the full generic because we have no use for it.\n+            index_ty.name = Some(String::new());\n+            res.push(TypeWithKind::from((index_ty, ItemType::Generic)));\n+        } else if let Some(kind) = ty.def_id_no_primitives().map(|did| tcx.def_kind(did).into()) {\n+            res.push(TypeWithKind::from((index_ty, kind)));\n         } else if ty.is_primitive() {\n             // This is a primitive, let's store it as such.\n-            res.insert((ty, ItemType::Primitive));\n-            1\n-        } else {\n-            0\n+            res.push(TypeWithKind::from((index_ty, ItemType::Primitive)));\n         }\n     }\n \n     if recurse >= 10 {\n         // FIXME: remove this whole recurse thing when the recursion bug is fixed\n-        return 0;\n+        return;\n     }\n-    let mut nb_added = 0;\n \n     if let Type::Generic(arg_s) = *arg {\n         if let Some(where_pred) = generics.where_predicates.iter().find(|g| match g {\n@@ -301,6 +326,7 @@ crate fn get_real_types<'tcx>(\n             }\n             _ => false,\n         }) {\n+            let mut ty_generics = Vec::new();\n             let bounds = where_pred.get_bounds().unwrap_or_else(|| &[]);\n             for bound in bounds.iter() {\n                 if let GenericBound::TraitBound(poly_trait, _) = bound {\n@@ -309,41 +335,32 @@ crate fn get_real_types<'tcx>(\n                             continue;\n                         }\n                         if let Some(ty) = x.get_type() {\n-                            let adds = get_real_types(generics, &ty, tcx, recurse + 1, res);\n-                            nb_added += adds;\n-                            if adds == 0 && !ty.is_full_generic() {\n-                                nb_added += insert(res, tcx, ty);\n-                            }\n+                            get_real_types(generics, &ty, tcx, recurse + 1, &mut ty_generics);\n                         }\n                     }\n                 }\n             }\n+            insert_ty(res, tcx, arg.clone(), ty_generics);\n         }\n         if let Some(bound) = generics.params.iter().find(|g| g.is_type() && g.name == arg_s) {\n+            let mut ty_generics = Vec::new();\n             for bound in bound.get_bounds().unwrap_or(&[]) {\n                 if let Some(path) = bound.get_trait_path() {\n                     let ty = Type::ResolvedPath { did: path.def_id(), path };\n-                    let adds = get_real_types(generics, &ty, tcx, recurse + 1, res);\n-                    nb_added += adds;\n-                    if adds == 0 && !ty.is_full_generic() {\n-                        nb_added += insert(res, tcx, ty);\n-                    }\n+                    get_real_types(generics, &ty, tcx, recurse + 1, &mut ty_generics);\n                 }\n             }\n+            insert_ty(res, tcx, arg.clone(), ty_generics);\n         }\n     } else {\n-        nb_added += insert(res, tcx, arg.clone());\n-        if let Some(gens) = arg.generics() {\n-            for gen in gens.iter() {\n-                if gen.is_full_generic() {\n-                    nb_added += get_real_types(generics, gen, tcx, recurse + 1, res);\n-                } else {\n-                    nb_added += insert(res, tcx, (*gen).clone());\n-                }\n+        let mut ty_generics = Vec::new();\n+        if let Some(arg_generics) = arg.generics() {\n+            for gen in arg_generics.iter() {\n+                get_real_types(generics, gen, tcx, recurse + 1, &mut ty_generics);\n             }\n         }\n+        insert_ty(res, tcx, arg.clone(), ty_generics);\n     }\n-    nb_added\n }\n \n /// Return the full list of types when bounds have been resolved.\n@@ -354,38 +371,41 @@ crate fn get_all_types<'tcx>(\n     generics: &Generics,\n     decl: &FnDecl,\n     tcx: TyCtxt<'tcx>,\n-) -> (Vec<(Type, ItemType)>, Vec<(Type, ItemType)>) {\n-    let mut all_types = FxHashSet::default();\n+) -> (Vec<TypeWithKind>, Vec<TypeWithKind>) {\n+    let mut all_types = Vec::new();\n     for arg in decl.inputs.values.iter() {\n         if arg.type_.is_self_type() {\n             continue;\n         }\n-        let mut args = FxHashSet::default();\n+        // FIXME: performance wise, it'd be much better to move `args` declaration outside of the\n+        // loop and replace this line with `args.clear()`.\n+        let mut args = Vec::new();\n         get_real_types(generics, &arg.type_, tcx, 0, &mut args);\n         if !args.is_empty() {\n+            // FIXME: once back to performance improvements, replace this line with:\n+            // `all_types.extend(args.drain(..));`.\n             all_types.extend(args);\n         } else {\n             if let Some(kind) = arg.type_.def_id_no_primitives().map(|did| tcx.def_kind(did).into())\n             {\n-                all_types.insert((arg.type_.clone(), kind));\n+                all_types.push(TypeWithKind::from((get_index_type(&arg.type_, vec![]), kind)));\n             }\n         }\n     }\n \n-    let ret_types = match decl.output {\n+    let mut ret_types = Vec::new();\n+    match decl.output {\n         FnRetTy::Return(ref return_type) => {\n-            let mut ret = FxHashSet::default();\n-            get_real_types(generics, return_type, tcx, 0, &mut ret);\n-            if ret.is_empty() {\n+            get_real_types(generics, return_type, tcx, 0, &mut ret_types);\n+            if ret_types.is_empty() {\n                 if let Some(kind) =\n                     return_type.def_id_no_primitives().map(|did| tcx.def_kind(did).into())\n                 {\n-                    ret.insert((return_type.clone(), kind));\n+                    ret_types.push(TypeWithKind::from((get_index_type(return_type, vec![]), kind)));\n                 }\n             }\n-            ret.into_iter().collect()\n         }\n-        _ => Vec::new(),\n+        _ => {}\n     };\n-    (all_types.into_iter().collect(), ret_types)\n+    (all_types, ret_types)\n }"}, {"sha": "68b2dd1536b49ea64fe04ce08cfda0f0c5e67c1a", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/22f1ad75e95500b3cab1d07c80d04c34d0f15f96/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22f1ad75e95500b3cab1d07c80d04c34d0f15f96/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=22f1ad75e95500b3cab1d07c80d04c34d0f15f96", "patch": "@@ -108,7 +108,7 @@ crate struct IndexItem {\n #[derive(Debug)]\n crate struct RenderType {\n     name: Option<String>,\n-    generics: Option<Vec<String>>,\n+    generics: Option<Vec<TypeWithKind>>,\n }\n \n /// Full type of functions/methods in the search index.\n@@ -2387,6 +2387,7 @@ fn item_ty_to_strs(ty: ItemType) -> (&'static str, &'static str) {\n         ItemType::ProcAttribute => (\"attributes\", \"Attribute Macros\"),\n         ItemType::ProcDerive => (\"derives\", \"Derive Macros\"),\n         ItemType::TraitAlias => (\"trait-aliases\", \"Trait aliases\"),\n+        ItemType::Generic => unreachable!(),\n     }\n }\n "}, {"sha": "c2ea54abd2ea8390743b1af965dc9b3d17a02ca6", "filename": "src/librustdoc/html/static/js/search.js", "status": "modified", "additions": 24, "deletions": 13, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/22f1ad75e95500b3cab1d07c80d04c34d0f15f96/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "raw_url": "https://github.com/rust-lang/rust/raw/22f1ad75e95500b3cab1d07c80d04c34d0f15f96/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js?ref=22f1ad75e95500b3cab1d07c80d04c34d0f15f96", "patch": "@@ -299,10 +299,10 @@ window.initSearch = function(rawSearchIndex) {\n                     var elems = Object.create(null);\n                     var elength = obj[GENERICS_DATA].length;\n                     for (var x = 0; x < elength; ++x) {\n-                        if (!elems[obj[GENERICS_DATA][x]]) {\n-                            elems[obj[GENERICS_DATA][x]] = 0;\n+                        if (!elems[obj[GENERICS_DATA][x][NAME]]) {\n+                            elems[obj[GENERICS_DATA][x][NAME]] = 0;\n                         }\n-                        elems[obj[GENERICS_DATA][x]] += 1;\n+                        elems[obj[GENERICS_DATA][x][NAME]] += 1;\n                     }\n                     var total = 0;\n                     var done = 0;\n@@ -345,6 +345,7 @@ window.initSearch = function(rawSearchIndex) {\n         // Check for type name and type generics (if any).\n         function checkType(obj, val, literalSearch) {\n             var lev_distance = MAX_LEV_DISTANCE + 1;\n+            var tmp_lev = MAX_LEV_DISTANCE + 1;\n             var len, x, firstGeneric;\n             if (obj[NAME] === val.name) {\n                 if (literalSearch) {\n@@ -354,10 +355,10 @@ window.initSearch = function(rawSearchIndex) {\n                             var elems = Object.create(null);\n                             len = obj[GENERICS_DATA].length;\n                             for (x = 0; x < len; ++x) {\n-                                if (!elems[obj[GENERICS_DATA][x]]) {\n-                                    elems[obj[GENERICS_DATA][x]] = 0;\n+                                if (!elems[obj[GENERICS_DATA][x][NAME]]) {\n+                                    elems[obj[GENERICS_DATA][x][NAME]] = 0;\n                                 }\n-                                elems[obj[GENERICS_DATA][x]] += 1;\n+                                elems[obj[GENERICS_DATA][x][NAME]] += 1;\n                             }\n \n                             var allFound = true;\n@@ -382,7 +383,7 @@ window.initSearch = function(rawSearchIndex) {\n                     // If the type has generics but don't match, then it won't return at this point.\n                     // Otherwise, `checkGenerics` will return 0 and it'll return.\n                     if (obj.length > GENERICS_DATA && obj[GENERICS_DATA].length !== 0) {\n-                        var tmp_lev = checkGenerics(obj, val);\n+                        tmp_lev = checkGenerics(obj, val);\n                         if (tmp_lev <= MAX_LEV_DISTANCE) {\n                             return tmp_lev;\n                         }\n@@ -392,8 +393,8 @@ window.initSearch = function(rawSearchIndex) {\n                 if ((!val.generics || val.generics.length === 0) &&\n                       obj.length > GENERICS_DATA && obj[GENERICS_DATA].length > 0) {\n                     return obj[GENERICS_DATA].some(\n-                        function(name) {\n-                            return name === val.name;\n+                        function(gen) {\n+                            return gen[NAME] === val.name;\n                         });\n                 }\n                 return false;\n@@ -404,17 +405,27 @@ window.initSearch = function(rawSearchIndex) {\n                 // a levenshtein distance value that isn't *this* good so it goes\n                 // into the search results but not too high.\n                 lev_distance = Math.ceil((checkGenerics(obj, val) + lev_distance) / 2);\n-            } else if (obj.length > GENERICS_DATA && obj[GENERICS_DATA].length > 0) {\n+            }\n+            if (obj.length > GENERICS_DATA && obj[GENERICS_DATA].length > 0) {\n                 // We can check if the type we're looking for is inside the generics!\n                 var olength = obj[GENERICS_DATA].length;\n                 for (x = 0; x < olength; ++x) {\n-                    lev_distance = Math.min(levenshtein(obj[GENERICS_DATA][x], val.name),\n-                                            lev_distance);\n+                    tmp_lev = Math.min(levenshtein(obj[GENERICS_DATA][x][NAME], val.name), tmp_lev);\n+                }\n+                if (tmp_lev !== 0) {\n+                    // If we didn't find a good enough result, we go check inside the generics of\n+                    // the generics.\n+                    for (x = 0; x < olength && tmp_lev !== 0; ++x) {\n+                        tmp_lev = Math.min(\n+                            checkType(obj[GENERICS_DATA][x], val, literalSearch),\n+                            tmp_lev\n+                        );\n+                    }\n                 }\n             }\n             // Now whatever happens, the returned distance is \"less good\" so we should mark it\n             // as such, and so we add 1 to the distance to make it \"less good\".\n-            return lev_distance + 1;\n+            return Math.min(lev_distance, tmp_lev) + 1;\n         }\n \n         function findArg(obj, val, literalSearch, typeFilter) {"}, {"sha": "f740ecdbded74a9a2ed9cdfe01ca99f2f6b5fce4", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/22f1ad75e95500b3cab1d07c80d04c34d0f15f96/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22f1ad75e95500b3cab1d07c80d04c34d0f15f96/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=22f1ad75e95500b3cab1d07c80d04c34d0f15f96", "patch": "@@ -697,6 +697,7 @@ impl FromWithTcx<ItemType> for ItemKind {\n             TraitAlias => ItemKind::TraitAlias,\n             ProcAttribute => ItemKind::ProcAttribute,\n             ProcDerive => ItemKind::ProcDerive,\n+            Generic => unreachable!(),\n         }\n     }\n }"}, {"sha": "63a9ad5381244c635e80674ea8eafc11e04bd839", "filename": "src/test/rustdoc-js/generics.js", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/22f1ad75e95500b3cab1d07c80d04c34d0f15f96/src%2Ftest%2Frustdoc-js%2Fgenerics.js", "raw_url": "https://github.com/rust-lang/rust/raw/22f1ad75e95500b3cab1d07c80d04c34d0f15f96/src%2Ftest%2Frustdoc-js%2Fgenerics.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js%2Fgenerics.js?ref=22f1ad75e95500b3cab1d07c80d04c34d0f15f96", "patch": "@@ -1,10 +1,12 @@\n // exact-check\n \n const QUERY = [\n-  '\"R<P>\"',\n-  '\"P\"',\n-  'P',\n-  '\"ExtraCreditStructMulti<ExtraCreditInnerMulti, ExtraCreditInnerMulti>\"',\n+    '\"R<P>\"',\n+    '\"P\"',\n+    'P',\n+    '\"ExtraCreditStructMulti<ExtraCreditInnerMulti, ExtraCreditInnerMulti>\"',\n+    'TraitCat',\n+    'TraitDog',\n ];\n \n const EXPECTED = [\n@@ -30,9 +32,11 @@ const EXPECTED = [\n     {\n         'returned': [\n             { 'path': 'generics', 'name': 'alef' },\n+            { 'path': 'generics', 'name': 'bet' },\n         ],\n         'in_args': [\n             { 'path': 'generics', 'name': 'alpha' },\n+            { 'path': 'generics', 'name': 'beta' },\n         ],\n     },\n     {\n@@ -41,4 +45,14 @@ const EXPECTED = [\n         ],\n         'returned': [],\n     },\n+    {\n+        'in_args': [\n+            { 'path': 'generics', 'name': 'gamma' },\n+        ],\n+    },\n+    {\n+        'in_args': [\n+            { 'path': 'generics', 'name': 'gamma' },\n+        ],\n+    },\n ];"}, {"sha": "5e11a6d6018856f75daaa7e73cc43fe7cd03764e", "filename": "src/test/rustdoc-js/generics.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/22f1ad75e95500b3cab1d07c80d04c34d0f15f96/src%2Ftest%2Frustdoc-js%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22f1ad75e95500b3cab1d07c80d04c34d0f15f96/src%2Ftest%2Frustdoc-js%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js%2Fgenerics.rs?ref=22f1ad75e95500b3cab1d07c80d04c34d0f15f96", "patch": "@@ -19,3 +19,8 @@ pub fn extracreditlabhomework(\n pub fn redherringmatchforextracredit(\n     _param: ExtraCreditStructMulti<ExtraCreditInnerMulti, ()>\n ) { loop {} }\n+\n+pub trait TraitCat {}\n+pub trait TraitDog {}\n+\n+pub fn gamma<T: TraitCat + TraitDog>(t: T) {}"}]}