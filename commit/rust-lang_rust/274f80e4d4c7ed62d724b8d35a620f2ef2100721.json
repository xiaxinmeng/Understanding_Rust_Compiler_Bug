{"sha": "274f80e4d4c7ed62d724b8d35a620f2ef2100721", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3NGY4MGU0ZDRjN2VkNjJkNzI0YjhkMzVhNjIwZjJlZjIxMDA3MjE=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-04-02T11:47:27Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-04-02T11:47:27Z"}, "message": "Rollup merge of #59533 - Zoxc:arena-slices, r=michaelwoerister\n\nSupport allocating iterators with arenas\n\nSplit out from https://github.com/rust-lang/rust/pull/57173.\n\nr? @michaelwoerister", "tree": {"sha": "a533b50b65221c055a3d67a24c3c50c35c6b6913", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a533b50b65221c055a3d67a24c3c50c35c6b6913"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/274f80e4d4c7ed62d724b8d35a620f2ef2100721", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJco0vPCRBK7hj4Ov3rIwAAdHIIAJXrSa5kpLMOvJ6Xwyi0qiNT\nQ5v/zpL63J3QF4Bh4ZpJSGNCE0rP96cRVvNMf6TtcW3JDS4A1EThd4cMzMH5N/39\nAs3vQp0EUn4A4RloUsP2/i/Z45JzDYHM6ao6bD2mtoyM6HIPaJ/0w7MFL8e/ZsAr\nKXUQNnwFMnwh0d1aotu2QinmywvOVnMV9mtFIdGvspGdhoDbDaHsHskUTzprHMAa\nWlQmnHFUbyEBm/Lu044ragRTpwE6DhEB6Ghvn50o78VJrp9Cpliit3FpmtQuXpfb\ncmuJhCjLf7XIaYs+uej3HLuorezribI8bh2yZuOpJynPixnIs/3Iz0hAkeGYktI=\n=sUK2\n-----END PGP SIGNATURE-----\n", "payload": "tree a533b50b65221c055a3d67a24c3c50c35c6b6913\nparent e655b91b7a5c743d6f6778bcbd25c78149c3a603\nparent 59ff059cfc2d8a4b3edf72644668beffd7bbc6cd\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1554205647 +0200\ncommitter GitHub <noreply@github.com> 1554205647 +0200\n\nRollup merge of #59533 - Zoxc:arena-slices, r=michaelwoerister\n\nSupport allocating iterators with arenas\n\nSplit out from https://github.com/rust-lang/rust/pull/57173.\n\nr? @michaelwoerister\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/274f80e4d4c7ed62d724b8d35a620f2ef2100721", "html_url": "https://github.com/rust-lang/rust/commit/274f80e4d4c7ed62d724b8d35a620f2ef2100721", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/274f80e4d4c7ed62d724b8d35a620f2ef2100721/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e655b91b7a5c743d6f6778bcbd25c78149c3a603", "url": "https://api.github.com/repos/rust-lang/rust/commits/e655b91b7a5c743d6f6778bcbd25c78149c3a603", "html_url": "https://github.com/rust-lang/rust/commit/e655b91b7a5c743d6f6778bcbd25c78149c3a603"}, {"sha": "59ff059cfc2d8a4b3edf72644668beffd7bbc6cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/59ff059cfc2d8a4b3edf72644668beffd7bbc6cd", "html_url": "https://github.com/rust-lang/rust/commit/59ff059cfc2d8a4b3edf72644668beffd7bbc6cd"}], "stats": {"total": 157, "additions": 141, "deletions": 16}, "files": [{"sha": "c7007017078e64d583b75d9ff06d98a22bea5754", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/274f80e4d4c7ed62d724b8d35a620f2ef2100721/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/274f80e4d4c7ed62d724b8d35a620f2ef2100721/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=274f80e4d4c7ed62d724b8d35a620f2ef2100721", "patch": "@@ -54,6 +54,7 @@ name = \"arena\"\n version = \"0.0.0\"\n dependencies = [\n  \"rustc_data_structures 0.0.0\",\n+ \"smallvec 0.6.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]"}, {"sha": "aa1bf38b995976f2d26c424b697281384eb75474", "filename": "src/libarena/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/274f80e4d4c7ed62d724b8d35a620f2ef2100721/src%2Flibarena%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/274f80e4d4c7ed62d724b8d35a620f2ef2100721/src%2Flibarena%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2FCargo.toml?ref=274f80e4d4c7ed62d724b8d35a620f2ef2100721", "patch": "@@ -11,3 +11,4 @@ crate-type = [\"dylib\"]\n \n [dependencies]\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n+smallvec = { version = \"0.6.7\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "0a5b79c36aad86c1326f4959414a1bade713a24e", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 139, "deletions": 16, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/274f80e4d4c7ed62d724b8d35a620f2ef2100721/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/274f80e4d4c7ed62d724b8d35a620f2ef2100721/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=274f80e4d4c7ed62d724b8d35a620f2ef2100721", "patch": "@@ -23,7 +23,9 @@\n \n extern crate alloc;\n \n+use rustc_data_structures::cold_path;\n use rustc_data_structures::sync::MTLock;\n+use smallvec::SmallVec;\n \n use std::cell::{Cell, RefCell};\n use std::cmp;\n@@ -55,13 +57,16 @@ pub struct TypedArena<T> {\n struct TypedArenaChunk<T> {\n     /// The raw storage for the arena chunk.\n     storage: RawVec<T>,\n+    /// The number of valid entries in the chunk.\n+    entries: usize,\n }\n \n impl<T> TypedArenaChunk<T> {\n     #[inline]\n     unsafe fn new(capacity: usize) -> TypedArenaChunk<T> {\n         TypedArenaChunk {\n             storage: RawVec::with_capacity(capacity),\n+            entries: 0,\n         }\n     }\n \n@@ -149,6 +154,34 @@ impl<T> TypedArena<T> {\n         }\n     }\n \n+    #[inline]\n+    fn can_allocate(&self, len: usize) -> bool {\n+        let available_capacity_bytes = self.end.get() as usize - self.ptr.get() as usize;\n+        let at_least_bytes = len.checked_mul(mem::size_of::<T>()).unwrap();\n+        available_capacity_bytes >= at_least_bytes\n+    }\n+\n+    /// Ensures there's enough space in the current chunk to fit `len` objects.\n+    #[inline]\n+    fn ensure_capacity(&self, len: usize) {\n+        if !self.can_allocate(len) {\n+            self.grow(len);\n+            debug_assert!(self.can_allocate(len));\n+        }\n+    }\n+\n+    #[inline]\n+    unsafe fn alloc_raw_slice(&self, len: usize) -> *mut T {\n+        assert!(mem::size_of::<T>() != 0);\n+        assert!(len != 0);\n+\n+        self.ensure_capacity(len);\n+\n+        let start_ptr = self.ptr.get();\n+        self.ptr.set(start_ptr.add(len));\n+        start_ptr\n+    }\n+\n     /// Allocates a slice of objects that are copied into the `TypedArena`, returning a mutable\n     /// reference to it. Will panic if passed a zero-sized types.\n     ///\n@@ -161,21 +194,64 @@ impl<T> TypedArena<T> {\n     where\n         T: Copy,\n     {\n+        unsafe {\n+            let len = slice.len();\n+            let start_ptr = self.alloc_raw_slice(len);\n+            slice.as_ptr().copy_to_nonoverlapping(start_ptr, len);\n+            slice::from_raw_parts_mut(start_ptr, len)\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn alloc_from_iter<I: IntoIterator<Item = T>>(&self, iter: I) -> &mut [T] {\n         assert!(mem::size_of::<T>() != 0);\n-        assert!(slice.len() != 0);\n+        let mut iter = iter.into_iter();\n+        let size_hint = iter.size_hint();\n \n-        let available_capacity_bytes = self.end.get() as usize - self.ptr.get() as usize;\n-        let at_least_bytes = slice.len() * mem::size_of::<T>();\n-        if available_capacity_bytes < at_least_bytes {\n-            self.grow(slice.len());\n-        }\n+        match size_hint {\n+            (min, Some(max)) if min == max => {\n+                // We know the exact number of elements the iterator will produce here\n+                let len = min;\n \n-        unsafe {\n-            let start_ptr = self.ptr.get();\n-            let arena_slice = slice::from_raw_parts_mut(start_ptr, slice.len());\n-            self.ptr.set(start_ptr.add(arena_slice.len()));\n-            arena_slice.copy_from_slice(slice);\n-            arena_slice\n+                if len == 0 {\n+                    return &mut [];\n+                }\n+\n+                self.ensure_capacity(len);\n+\n+                let slice = self.ptr.get();\n+\n+                unsafe {\n+                    let mut ptr = self.ptr.get();\n+                    for _ in 0..len {\n+                        // Write into uninitialized memory.\n+                        ptr::write(ptr, iter.next().unwrap());\n+                        // Advance the pointer.\n+                        ptr = ptr.offset(1);\n+                        // Update the pointer per iteration so if `iter.next()` panics\n+                        // we destroy the correct amount\n+                        self.ptr.set(ptr);\n+                    }\n+                    slice::from_raw_parts_mut(slice, len)\n+                }\n+            }\n+            _ => {\n+                cold_path(move || -> &mut [T] {\n+                    let mut vec: SmallVec<[_; 8]> = iter.collect();\n+                    if vec.is_empty() {\n+                        return &mut [];\n+                    }\n+                    // Move the content to the arena by copying it and then forgetting\n+                    // the content of the SmallVec\n+                    unsafe {\n+                        let len = vec.len();\n+                        let start_ptr = self.alloc_raw_slice(len);\n+                        vec.as_ptr().copy_to_nonoverlapping(start_ptr, len);\n+                        vec.set_len(0);\n+                        slice::from_raw_parts_mut(start_ptr, len)\n+                    }\n+                })\n+            }\n         }\n     }\n \n@@ -189,6 +265,7 @@ impl<T> TypedArena<T> {\n             if let Some(last_chunk) = chunks.last_mut() {\n                 let used_bytes = self.ptr.get() as usize - last_chunk.start() as usize;\n                 let currently_used_cap = used_bytes / mem::size_of::<T>();\n+                last_chunk.entries = currently_used_cap;\n                 if last_chunk.storage.reserve_in_place(currently_used_cap, n) {\n                     self.end.set(last_chunk.end());\n                     return;\n@@ -222,8 +299,7 @@ impl<T> TypedArena<T> {\n                 let len = chunks_borrow.len();\n                 // If `T` is ZST, code below has no effect.\n                 for mut chunk in chunks_borrow.drain(..len-1) {\n-                    let cap = chunk.storage.cap();\n-                    chunk.destroy(cap);\n+                    chunk.destroy(chunk.entries);\n                 }\n             }\n         }\n@@ -265,8 +341,7 @@ unsafe impl<#[may_dangle] T> Drop for TypedArena<T> {\n                 self.clear_last_chunk(&mut last_chunk);\n                 // The last chunk will be dropped. Destroy all other chunks.\n                 for chunk in chunks_borrow.iter_mut() {\n-                    let cap = chunk.storage.cap();\n-                    chunk.destroy(cap);\n+                    chunk.destroy(chunk.entries);\n                 }\n             }\n             // RawVec handles deallocation of `last_chunk` and `self.chunks`.\n@@ -410,6 +485,54 @@ impl DroplessArena {\n             arena_slice\n         }\n     }\n+\n+    #[inline]\n+    pub fn alloc_from_iter<T, I: IntoIterator<Item = T>>(&self, iter: I) -> &mut [T] {\n+        let mut iter = iter.into_iter();\n+        assert!(mem::size_of::<T>() != 0);\n+        assert!(!mem::needs_drop::<T>());\n+\n+        let size_hint = iter.size_hint();\n+\n+        match size_hint {\n+            (min, Some(max)) if min == max => {\n+                // We know the exact number of elements the iterator will produce here\n+                let len = min;\n+\n+                if len == 0 {\n+                    return &mut []\n+                }\n+                let size = len.checked_mul(mem::size_of::<T>()).unwrap();\n+                let mem = self.alloc_raw(size, mem::align_of::<T>()) as *mut _ as *mut T;\n+                unsafe {\n+                    for i in 0..len {\n+                        ptr::write(mem.offset(i as isize), iter.next().unwrap())\n+                    }\n+                    slice::from_raw_parts_mut(mem, len)\n+                }\n+            }\n+            (_, _) => {\n+                cold_path(move || -> &mut [T] {\n+                    let mut vec: SmallVec<[_; 8]> = iter.collect();\n+                    if vec.is_empty() {\n+                        return &mut [];\n+                    }\n+                    // Move the content to the arena by copying it and then forgetting\n+                    // the content of the SmallVec\n+                    unsafe {\n+                        let len = vec.len();\n+                        let start_ptr = self.alloc_raw(\n+                            len * mem::size_of::<T>(),\n+                            mem::align_of::<T>()\n+                        ) as *mut _ as *mut T;\n+                        vec.as_ptr().copy_to_nonoverlapping(start_ptr, len);\n+                        vec.set_len(0);\n+                        slice::from_raw_parts_mut(start_ptr, len)\n+                    }\n+                })\n+            }\n+        }\n+    }\n }\n \n #[derive(Default)]"}]}