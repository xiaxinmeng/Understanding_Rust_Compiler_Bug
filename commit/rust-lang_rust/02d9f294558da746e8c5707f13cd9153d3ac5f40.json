{"sha": "02d9f294558da746e8c5707f13cd9153d3ac5f40", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyZDlmMjk0NTU4ZGE3NDZlOGM1NzA3ZjEzY2Q5MTUzZDNhYzVmNDA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-06T07:58:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-06T07:58:27Z"}, "message": "Auto merge of #29600 - Ryman:rustdoc_better_testnames, r=alexcrichton\n\nOld doctest names\n```bash\ntest sync::atomic::load_0 ... ok\ntest sync::atomic::load_0 ... ok\ntest sync::atomic::load_0 ... ok\ntest sync::atomic::load_0 ... ok\n```\n\nNew doctest names\n```bash\ntest sync::atomic::AtomicBool::load_0 ... ok\ntest sync::atomic::AtomicIsize::load_0 ... ok\ntest sync::atomic::AtomicPtr<T>::load_0 ... ok\ntest sync::atomic::AtomicUsize::load_0 ... ok\n```", "tree": {"sha": "96ead3dcf2836d1c6b323e40e583a8637faa1578", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/96ead3dcf2836d1c6b323e40e583a8637faa1578"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/02d9f294558da746e8c5707f13cd9153d3ac5f40", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/02d9f294558da746e8c5707f13cd9153d3ac5f40", "html_url": "https://github.com/rust-lang/rust/commit/02d9f294558da746e8c5707f13cd9153d3ac5f40", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/02d9f294558da746e8c5707f13cd9153d3ac5f40/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "98fa2ac1bce84136a129a260b1eb42b9a83d61a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/98fa2ac1bce84136a129a260b1eb42b9a83d61a0", "html_url": "https://github.com/rust-lang/rust/commit/98fa2ac1bce84136a129a260b1eb42b9a83d61a0"}, {"sha": "4202615e01df280009ae22514dd51d3ffe5bb330", "url": "https://api.github.com/repos/rust-lang/rust/commits/4202615e01df280009ae22514dd51d3ffe5bb330", "html_url": "https://github.com/rust-lang/rust/commit/4202615e01df280009ae22514dd51d3ffe5bb330"}], "stats": {"total": 71, "additions": 59, "deletions": 12}, "files": [{"sha": "34ddd5726d38525f67467ef2d688def91f3c8eef", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/02d9f294558da746e8c5707f13cd9153d3ac5f40/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02d9f294558da746e8c5707f13cd9153d3ac5f40/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=02d9f294558da746e8c5707f13cd9153d3ac5f40", "patch": "@@ -2568,8 +2568,18 @@ fn resolve_type(cx: &DocContext,\n     debug!(\"resolve_type({:?},{:?})\", path, id);\n     let tcx = match cx.tcx_opt() {\n         Some(tcx) => tcx,\n-        // If we're extracting tests, this return value doesn't matter.\n-        None => return Primitive(Bool),\n+        // If we're extracting tests, this return value's accuracy is not\n+        // important, all we want is a string representation to help people\n+        // figure out what doctests are failing.\n+        None => {\n+            let did = DefId::local(DefIndex::from_u32(0));\n+            return ResolvedPath {\n+                path: path,\n+                typarams: None,\n+                did: did,\n+                is_generic: false\n+            };\n+        }\n     };\n     let def = match tcx.def_map.borrow().get(&id) {\n         Some(k) => k.full_def(),"}, {"sha": "1ea30a8763e40df05c77540b8383f58a64a851be", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 47, "deletions": 10, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/02d9f294558da746e8c5707f13cd9153d3ac5f40/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02d9f294558da746e8c5707f13cd9153d3ac5f40/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=02d9f294558da746e8c5707f13cd9153d3ac5f40", "patch": "@@ -422,22 +422,59 @@ impl Collector {\n \n impl DocFolder for Collector {\n     fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n-        let pushed = match item.name {\n-            Some(ref name) if name.is_empty() => false,\n-            Some(ref name) => { self.names.push(name.to_string()); true }\n-            None => false\n+        let current_name = match item.name {\n+            Some(ref name) if !name.is_empty() => Some(name.clone()),\n+            _ => typename_if_impl(&item)\n         };\n-        match item.doc_value() {\n-            Some(doc) => {\n-                self.cnt = 0;\n-                markdown::find_testable_code(doc, &mut *self);\n-            }\n-            None => {}\n+\n+        let pushed = if let Some(name) = current_name {\n+            self.names.push(name);\n+            true\n+        } else {\n+            false\n+        };\n+\n+        if let Some(doc) = item.doc_value() {\n+            self.cnt = 0;\n+            markdown::find_testable_code(doc, &mut *self);\n         }\n+\n         let ret = self.fold_item_recur(item);\n         if pushed {\n             self.names.pop();\n         }\n+\n         return ret;\n+\n+        // FIXME: it would be better to not have the escaped version in the first place\n+        fn unescape_for_testname(mut s: String) -> String {\n+            // for refs `&foo`\n+            if s.contains(\"&amp;\") {\n+                s = s.replace(\"&amp;\", \"&\");\n+\n+                // `::&'a mut Foo::` looks weird, let's make it `::<&'a mut Foo>`::\n+                if let Some('&') = s.chars().nth(0) {\n+                    s = format!(\"<{}>\", s);\n+                }\n+            }\n+\n+            // either `<..>` or `->`\n+            if s.contains(\"&gt;\") {\n+                s.replace(\"&gt;\", \">\")\n+                 .replace(\"&lt;\", \"<\")\n+            } else {\n+                s\n+            }\n+        }\n+\n+        fn typename_if_impl(item: &clean::Item) -> Option<String> {\n+            if let clean::ItemEnum::ImplItem(ref impl_) = item.inner {\n+                let path = impl_.for_.to_string();\n+                let unescaped_path = unescape_for_testname(path);\n+                Some(unescaped_path)\n+            } else {\n+                None\n+            }\n+        }\n     }\n }"}]}