{"sha": "b8d1fa399402c71331aefd634d710004e00b73a6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4ZDFmYTM5OTQwMmM3MTMzMWFlZmQ2MzRkNzEwMDA0ZTAwYjczYTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-28T04:55:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-28T04:55:42Z"}, "message": "auto merge of #8645 : alexcrichton/rust/issue-6436-run-non-blocking, r=brson\n\nThis overhauls `std::run` to instead run on top of libuv. This is *not* in a mergeable state, I've been attempting to diagnose failures in the compiletest suite. I've managed to find a fair number of bugs so far, but I still  don't seem to be done yet.\r\n\r\nNotable changes:\r\n* This requires upgrading libuv. From the discussion on #6567, I took libuv master from a few days ago, applied one patch to fix process spawning with multiple event loops in libuv, and pushed to my own fork\r\n* The build system for libuv has changed since we last used it. There's some extra checkout from a google build system which apparently does all the magic if you don't want to require autotools, and the google system just requires python. I updated the Makefile to get this build system and build libuv with it instead. This is untested on windows and arm, and both will probably need to see some improvement.\r\n* This required adding some pipe bindings to libuv as well. Currently the support is pretty simple and probably completely unsafe for pipes, but you at least get read/write methods. This is necessary for capturing output of processes.\r\n* I didn't redesign `std::run` at all, I simply tried to reimplement all the existing functionality on top of libuv. Some functions ended up dying, but nothing major. All uses of `std::run` in the compiler still work just fine.\r\n\r\nI'm not quite sure how the rest of the runtime deals with this, but I marked process structures as `no_send` because the waiting/waking up has to happen in the same event loop right now. If processes start migrating between event loops then very bad things can happen. This may be what threadsafe I/O would fix, and I would be more than willing to rebase on that if it lands first.\r\n\r\nAnyway, for now I wanted to put this up for review, I'm still investigating the corruption/deadlock bugs, but this is in an *almost* workable state. Once I find the bugs I'll also rebase on the current master.", "tree": {"sha": "575c040a4b277c8ff0107fdf673ef5a516eaf866", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/575c040a4b277c8ff0107fdf673ef5a516eaf866"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b8d1fa399402c71331aefd634d710004e00b73a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b8d1fa399402c71331aefd634d710004e00b73a6", "html_url": "https://github.com/rust-lang/rust/commit/b8d1fa399402c71331aefd634d710004e00b73a6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b8d1fa399402c71331aefd634d710004e00b73a6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f22b4b169854c8a4ba86c16ee43327d6bcf94562", "url": "https://api.github.com/repos/rust-lang/rust/commits/f22b4b169854c8a4ba86c16ee43327d6bcf94562", "html_url": "https://github.com/rust-lang/rust/commit/f22b4b169854c8a4ba86c16ee43327d6bcf94562"}, {"sha": "4635644746034bd01306159cc952cbdda23b3703", "url": "https://api.github.com/repos/rust-lang/rust/commits/4635644746034bd01306159cc952cbdda23b3703", "html_url": "https://github.com/rust-lang/rust/commit/4635644746034bd01306159cc952cbdda23b3703"}], "stats": {"total": 2277, "additions": 1151, "deletions": 1126}, "files": [{"sha": "fa979b6d868ef4bebdcc7a79891e4f61e27ce328", "filename": ".gitmodules", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8d1fa399402c71331aefd634d710004e00b73a6/.gitmodules", "raw_url": "https://github.com/rust-lang/rust/raw/b8d1fa399402c71331aefd634d710004e00b73a6/.gitmodules", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitmodules?ref=b8d1fa399402c71331aefd634d710004e00b73a6", "patch": "@@ -4,5 +4,5 @@\n \tbranch = master\n [submodule \"src/libuv\"]\n \tpath = src/libuv\n-\turl = https://github.com/brson/libuv.git\n+\turl = https://github.com/alexcrichton/libuv.git\n \tbranch = master"}, {"sha": "3178c5791299bf5125b943d35d17efc56a7d37bb", "filename": "mk/rt.mk", "status": "modified", "additions": 29, "deletions": 10, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/b8d1fa399402c71331aefd634d710004e00b73a6/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/b8d1fa399402c71331aefd634d710004e00b73a6/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=b8d1fa399402c71331aefd634d710004e00b73a6", "patch": "@@ -163,34 +163,49 @@ LIBUV_DEPS := $$(wildcard \\\n               $$(S)src/libuv/*/*/*/*)\n endif\n \n+LIBUV_GYP := $$(S)src/libuv/build/gyp\n+LIBUV_MAKEFILE_$(1)_$(2) := $$(CFG_BUILD_DIR)rt/$(1)/stage$(2)/libuv/Makefile\n+LIBUV_NO_LOAD = run-benchmarks.target.mk run-tests.target.mk \\\n+\t\tuv_dtrace_header.target.mk uv_dtrace_provider.target.mk\n+\n+$$(LIBUV_MAKEFILE_$(1)_$(2)): $$(LIBUV_GYP)\n+\t(cd $(S)src/libuv/ && \\\n+\t ./gyp_uv -f make -Dtarget_arch=$$(HOST_$(1)) -D ninja \\\n+\t   -Goutput_dir=$$(@D) --generator-output $$(@D))\n+\n # XXX: Shouldn't need platform-specific conditions here\n ifdef CFG_WINDOWSY_$(1)\n $$(LIBUV_LIB_$(1)_$(2)): $$(LIBUV_DEPS)\n-\t$$(Q)$$(MAKE) -C $$(S)src/libuv/ \\\n-\t\tbuilddir_name=\"$$(CFG_BUILD_DIR)/rt/$(1)/stage$(2)/libuv\" \\\n-\t\tOS=mingw \\\n+\t$$(Q)rm -f $$(S)src/libuv/libuv.a\n+\t$$(Q)$$(MAKE) -C $$(S)src/libuv -f Makefile.mingw \\\n+\t\tCFLAGS=\"$$(CFG_GCCISH_CFLAGS) $$(LIBUV_FLAGS_$$(HOST_$(1))) $$(SNAP_DEFINES)\" \\\n+\t\tAR=\"$$(AR_$(1))\" \\\n \t\tV=$$(VERBOSE)\n+\t$$(Q)cp $$(S)src/libuv/libuv.a $$@\n else ifeq ($(OSTYPE_$(1)), linux-androideabi)\n-$$(LIBUV_LIB_$(1)_$(2)): $$(LIBUV_DEPS)\n-\t$$(Q)$$(MAKE) -C $$(S)src/libuv/ \\\n+$$(LIBUV_LIB_$(1)_$(2)): $$(LIBUV_DEPS) $$(LIBUV_MAKEFILE_$(1)_$(2))\n+\t$$(Q)$$(MAKE) -C $$(@D) \\\n \t\tCFLAGS=\"$$(CFG_GCCISH_CFLAGS) $$(LIBUV_FLAGS_$$(HOST_$(1))) $$(SNAP_DEFINES)\" \\\n \t\tLDFLAGS=\"$$(CFG_GCCISH_LINK_FLAGS) $$(LIBUV_FLAGS_$$(HOST_$(1)))\" \\\n \t\tCC=\"$$(CC_$(1))\" \\\n \t\tCXX=\"$$(CXX_$(1))\" \\\n \t\tAR=\"$$(AR_$(1))\" \\\n-\t\tBUILDTYPE=Release \\\n-\t\tbuilddir_name=\"$$(CFG_BUILD_DIR)/rt/$(1)/stage$(2)/libuv\" \\\n \t\thost=android OS=linux \\\n+\t\tbuilddir=\".\" \\\n+\t\tBUILDTYPE=Release \\\n+\t\tNO_LOAD=\"$$(LIBUV_NO_LOAD)\" \\\n \t\tV=$$(VERBOSE)\n else\n-$$(LIBUV_LIB_$(1)_$(2)): $$(LIBUV_DEPS)\n-\t$$(Q)$$(MAKE) -C $$(S)src/libuv/ \\\n+$$(LIBUV_LIB_$(1)_$(2)): $$(LIBUV_DEPS) $$(LIBUV_MAKEFILE_$(1)_$(2))\n+\t$$(Q)$$(MAKE) -C $$(@D) \\\n \t\tCFLAGS=\"$$(CFG_GCCISH_CFLAGS) $$(LIBUV_FLAGS_$$(HOST_$(1))) $$(SNAP_DEFINES)\" \\\n \t\tLDFLAGS=\"$$(CFG_GCCISH_LINK_FLAGS) $$(LIBUV_FLAGS_$$(HOST_$(1)))\" \\\n \t\tCC=\"$$(CC_$(1))\" \\\n \t\tCXX=\"$$(CXX_$(1))\" \\\n \t\tAR=\"$$(AR_$(1))\" \\\n-\t\tbuilddir_name=\"$$(CFG_BUILD_DIR)/rt/$(1)/stage$(2)/libuv\" \\\n+\t\tbuilddir=\".\" \\\n+\t\tBUILDTYPE=Release \\\n+\t\tNO_LOAD=\"$$(LIBUV_NO_LOAD)\" \\\n \t\tV=$$(VERBOSE)\n endif\n \n@@ -254,3 +269,7 @@ endef\n $(foreach stage,$(STAGES), \\\n \t$(foreach target,$(CFG_TARGET_TRIPLES), \\\n \t $(eval $(call DEF_RUNTIME_TARGETS,$(target),$(stage)))))\n+\n+$(LIBUV_GYP):\n+\tmkdir -p $(S)src/libuv/build\n+\tgit clone https://git.chromium.org/external/gyp.git $(S)src/libuv/build/gyp"}, {"sha": "74627829c60ff52b2f37c4e03d6a6582c654edf3", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8d1fa399402c71331aefd634d710004e00b73a6/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8d1fa399402c71331aefd634d710004e00b73a6/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=b8d1fa399402c71331aefd634d710004e00b73a6", "patch": "@@ -54,10 +54,10 @@ pub fn run(lib_path: &str,\n         in_fd: None,\n         out_fd: None,\n         err_fd: None\n-    });\n+    }).unwrap();\n \n     for input in input.iter() {\n-        proc.input().write_str(*input);\n+        proc.input().write(input.as_bytes());\n     }\n     let output = proc.finish_with_output();\n "}, {"sha": "16de4f8e82233dbdbd1b1c5c4c54d1981cfacc6e", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 2, "deletions": 27, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b8d1fa399402c71331aefd634d710004e00b73a6/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8d1fa399402c71331aefd634d710004e00b73a6/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=b8d1fa399402c71331aefd634d710004e00b73a6", "patch": "@@ -20,41 +20,16 @@ use procsrv;\n use util;\n use util::logv;\n \n-use std::cell::Cell;\n use std::io;\n use std::os;\n use std::str;\n-use std::task::{spawn_sched, SingleThreaded};\n use std::vec;\n-use std::unstable::running_on_valgrind;\n \n use extra::test::MetricMap;\n \n pub fn run(config: config, testfile: ~str) {\n-    let config = Cell::new(config);\n-    let testfile = Cell::new(testfile);\n-    // FIXME #6436: Creating another thread to run the test because this\n-    // is going to call waitpid. The new scheduler has some strange\n-    // interaction between the blocking tasks and 'friend' schedulers\n-    // that destroys parallelism if we let normal schedulers block.\n-    // It should be possible to remove this spawn once std::run is\n-    // rewritten to be non-blocking.\n-    //\n-    // We do _not_ create another thread if we're running on V because\n-    // it serializes all threads anyways.\n-    if running_on_valgrind() {\n-        let config = config.take();\n-        let testfile = testfile.take();\n-        let mut _mm = MetricMap::new();\n-        run_metrics(config, testfile, &mut _mm);\n-    } else {\n-        do spawn_sched(SingleThreaded) {\n-            let config = config.take();\n-            let testfile = testfile.take();\n-            let mut _mm = MetricMap::new();\n-            run_metrics(config, testfile, &mut _mm);\n-        }\n-    }\n+    let mut _mm = MetricMap::new();\n+    run_metrics(config, testfile, &mut _mm);\n }\n \n pub fn run_metrics(config: config, testfile: ~str, mm: &mut MetricMap) {"}, {"sha": "635d02196fe47fdbec14beed9bdad5a7ee624402", "filename": "src/librustdoc/markdown_writer.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b8d1fa399402c71331aefd634d710004e00b73a6/src%2Flibrustdoc%2Fmarkdown_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8d1fa399402c71331aefd634d710004e00b73a6/src%2Flibrustdoc%2Fmarkdown_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_writer.rs?ref=b8d1fa399402c71331aefd634d710004e00b73a6", "patch": "@@ -104,14 +104,14 @@ fn pandoc_writer(\n     ];\n \n     do generic_writer |markdown| {\n-        use std::io::WriterUtil;\n-\n         debug!(\"pandoc cmd: %s\", pandoc_cmd);\n         debug!(\"pandoc args: %s\", pandoc_args.connect(\" \"));\n \n-        let mut proc = run::Process::new(pandoc_cmd, pandoc_args, run::ProcessOptions::new());\n+        let proc = run::Process::new(pandoc_cmd, pandoc_args,\n+                                     run::ProcessOptions::new());\n+        let mut proc = proc.unwrap();\n \n-        proc.input().write_str(markdown);\n+        proc.input().write(markdown.as_bytes());\n         let output = proc.finish_with_output();\n \n         debug!(\"pandoc result: %i\", output.status);"}, {"sha": "c67a81581393d977e5b5040fafbdc39237c89364", "filename": "src/librustpkg/source_control.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8d1fa399402c71331aefd634d710004e00b73a6/src%2Flibrustpkg%2Fsource_control.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8d1fa399402c71331aefd634d710004e00b73a6/src%2Flibrustpkg%2Fsource_control.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fsource_control.rs?ref=b8d1fa399402c71331aefd634d710004e00b73a6", "patch": "@@ -89,7 +89,7 @@ pub fn git_clone_general(source: &str, target: &Path, v: &Version) -> bool {\n \n fn process_output_in_cwd(prog: &str, args: &[~str], cwd: &Path) -> ProcessOutput {\n     let mut prog = Process::new(prog, args, ProcessOptions{ dir: Some(cwd)\n-                                ,..ProcessOptions::new()});\n+                                ,..ProcessOptions::new()}).unwrap();\n     prog.finish_with_output()\n }\n "}, {"sha": "b0d996ea0afa81d126c6644c0c888b6bbd98a374", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b8d1fa399402c71331aefd634d710004e00b73a6/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8d1fa399402c71331aefd634d710004e00b73a6/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=b8d1fa399402c71331aefd634d710004e00b73a6", "patch": "@@ -112,13 +112,14 @@ fn mk_temp_workspace(short_name: &Path, version: &Version) -> Path {\n \n fn run_git(args: &[~str], env: Option<~[(~str, ~str)]>, cwd: &Path, err_msg: &str) {\n     let cwd = (*cwd).clone();\n-    let mut prog = run::Process::new(\"git\", args, run::ProcessOptions {\n+    let prog = run::Process::new(\"git\", args, run::ProcessOptions {\n         env: env,\n         dir: Some(&cwd),\n         in_fd: None,\n         out_fd: None,\n         err_fd: None\n     });\n+    let mut prog = prog.unwrap();\n     let rslt = prog.finish_with_output();\n     if rslt.status != 0 {\n         fail!(\"%s [git returned %?, output = %s, error = %s]\", err_msg,\n@@ -226,7 +227,7 @@ fn command_line_test_with_env(args: &[~str], cwd: &Path, env: Option<~[(~str, ~s\n         in_fd: None,\n         out_fd: None,\n         err_fd: None\n-    });\n+    }).unwrap();\n     let output = prog.finish_with_output();\n     debug!(\"Output from command %s with args %? was %s {%s}[%?]\",\n                     cmd, args, str::from_bytes(output.output),\n@@ -1027,16 +1028,17 @@ fn test_extern_mod() {\n                      test_sysroot().to_str(),\n                      exec_file.to_str());\n \n-    let mut prog = run::Process::new(rustc.to_str(), [main_file.to_str(),\n-                                                      ~\"--sysroot\", test_sysroot().to_str(),\n-                                               ~\"-o\", exec_file.to_str()],\n-                                     run::ProcessOptions {\n+    let prog = run::Process::new(rustc.to_str(), [main_file.to_str(),\n+                                                  ~\"--sysroot\", test_sysroot().to_str(),\n+                                                  ~\"-o\", exec_file.to_str()],\n+                                 run::ProcessOptions {\n         env: env,\n         dir: Some(&dir),\n         in_fd: None,\n         out_fd: None,\n         err_fd: None\n     });\n+    let mut prog = prog.unwrap();\n     let outp = prog.finish_with_output();\n     if outp.status != 0 {\n         fail!(\"output was %s, error was %s\","}, {"sha": "534e308a1a6e8dc65e0414560617070abe56aaa7", "filename": "src/libstd/rt/io/file.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b8d1fa399402c71331aefd634d710004e00b73a6/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8d1fa399402c71331aefd634d710004e00b73a6/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Ffile.rs?ref=b8d1fa399402c71331aefd634d710004e00b73a6", "patch": "@@ -71,9 +71,6 @@ pub struct FileStream {\n     last_nread: int,\n }\n \n-impl FileStream {\n-}\n-\n impl Reader for FileStream {\n     fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n         match self.fd.read(buf) {"}, {"sha": "038fca9a1ade441c2e0a867ee1cf3eb89ae3a71f", "filename": "src/libstd/rt/io/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b8d1fa399402c71331aefd634d710004e00b73a6/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8d1fa399402c71331aefd634d710004e00b73a6/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fmod.rs?ref=b8d1fa399402c71331aefd634d710004e00b73a6", "patch": "@@ -268,6 +268,9 @@ pub use self::extensions::WriterByteConversions;\n /// Synchronous, non-blocking file I/O.\n pub mod file;\n \n+/// Synchronous, in-memory I/O.\n+pub mod pipe;\n+\n /// Synchronous, non-blocking network I/O.\n pub mod net {\n     pub mod tcp;"}, {"sha": "dc7135f4a61ecb2bea11351b4a6b67fc3e6c9d52", "filename": "src/libstd/rt/io/net/tcp.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b8d1fa399402c71331aefd634d710004e00b73a6/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8d1fa399402c71331aefd634d710004e00b73a6/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs?ref=b8d1fa399402c71331aefd634d710004e00b73a6", "patch": "@@ -16,7 +16,7 @@ use rt::io::{io_error, read_error, EndOfFile};\n use rt::rtio::{IoFactory, IoFactoryObject,\n                RtioSocket, RtioTcpListener,\n                RtioTcpListenerObject, RtioTcpStream,\n-               RtioTcpStreamObject};\n+               RtioTcpStreamObject, RtioStream};\n use rt::local::Local;\n \n pub struct TcpStream(~RtioTcpStreamObject);\n@@ -69,7 +69,7 @@ impl TcpStream {\n \n impl Reader for TcpStream {\n     fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n-        match (**self).read(buf) {\n+        match (***self).read(buf) {\n             Ok(read) => Some(read),\n             Err(ioerr) => {\n                 // EOF is indicated by returning None\n@@ -86,7 +86,7 @@ impl Reader for TcpStream {\n \n impl Writer for TcpStream {\n     fn write(&mut self, buf: &[u8]) {\n-        match (**self).write(buf) {\n+        match (***self).write(buf) {\n             Ok(_) => (),\n             Err(ioerr) => io_error::cond.raise(ioerr),\n         }\n@@ -166,7 +166,7 @@ mod test {\n         do run_in_newsched_task {\n             let mut called = false;\n             do io_error::cond.trap(|e| {\n-                assert!(e.kind == ConnectionRefused);\n+                assert_eq!(e.kind, ConnectionRefused);\n                 called = true;\n             }).inside {\n                 let addr = SocketAddr { ip: Ipv4Addr(0, 0, 0, 0), port: 1 };"}, {"sha": "02b3d0fe57dc24856bf584093539c9af7ffd235c", "filename": "src/libstd/rt/io/pipe.rs", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/b8d1fa399402c71331aefd634d710004e00b73a6/src%2Flibstd%2Frt%2Fio%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8d1fa399402c71331aefd634d710004e00b73a6/src%2Flibstd%2Frt%2Fio%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fpipe.rs?ref=b8d1fa399402c71331aefd634d710004e00b73a6", "patch": "@@ -0,0 +1,77 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Synchronous, in-memory pipes.\n+//!\n+//! Currently these aren't particularly useful, there only exists bindings\n+//! enough so that pipes can be created to child processes.\n+\n+use prelude::*;\n+use super::{Reader, Writer};\n+use rt::io::{io_error, read_error, EndOfFile};\n+use rt::local::Local;\n+use rt::rtio::{RtioPipeObject, RtioStream, IoFactoryObject, IoFactory};\n+use rt::uv::pipe;\n+\n+pub struct PipeStream(~RtioPipeObject);\n+\n+impl PipeStream {\n+    /// Creates a new pipe initialized, but not bound to any particular\n+    /// source/destination\n+    pub fn new() -> Option<PipeStream> {\n+        let pipe = unsafe {\n+            let io: *mut IoFactoryObject = Local::unsafe_borrow();\n+            (*io).pipe_init(false)\n+        };\n+        match pipe {\n+            Ok(p) => Some(PipeStream(p)),\n+            Err(ioerr) => {\n+                io_error::cond.raise(ioerr);\n+                None\n+            }\n+        }\n+    }\n+\n+    /// Extracts the underlying libuv pipe to be bound to another source.\n+    pub fn uv_pipe(&self) -> pipe::Pipe {\n+        // Did someone say multiple layers of indirection?\n+        (**self).uv_pipe()\n+    }\n+}\n+\n+impl Reader for PipeStream {\n+    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+        match (***self).read(buf) {\n+            Ok(read) => Some(read),\n+            Err(ioerr) => {\n+                // EOF is indicated by returning None\n+                if ioerr.kind != EndOfFile {\n+                    read_error::cond.raise(ioerr);\n+                }\n+                return None;\n+            }\n+        }\n+    }\n+\n+    fn eof(&mut self) -> bool { fail!() }\n+}\n+\n+impl Writer for PipeStream {\n+    fn write(&mut self, buf: &[u8]) {\n+        match (***self).write(buf) {\n+            Ok(_) => (),\n+            Err(ioerr) => {\n+                io_error::cond.raise(ioerr);\n+            }\n+        }\n+    }\n+\n+    fn flush(&mut self) { fail!() }\n+}"}, {"sha": "1a7ef6ea309b9ac78c4f781298b782a93b131c93", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b8d1fa399402c71331aefd634d710004e00b73a6/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8d1fa399402c71331aefd634d710004e00b73a6/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=b8d1fa399402c71331aefd634d710004e00b73a6", "patch": "@@ -8,12 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use libc;\n use option::*;\n use result::*;\n use libc::c_int;\n \n use rt::io::IoError;\n use super::io::net::ip::{IpAddr, SocketAddr};\n+use rt::uv;\n use rt::uv::uvio;\n use path::Path;\n use super::io::support::PathLike;\n@@ -30,6 +32,9 @@ pub type RtioTcpListenerObject = uvio::UvTcpListener;\n pub type RtioUdpSocketObject = uvio::UvUdpSocket;\n pub type RtioTimerObject = uvio::UvTimer;\n pub type PausibleIdleCallback = uvio::UvPausibleIdleCallback;\n+pub type RtioPipeObject = uvio::UvPipeStream;\n+pub type RtioProcessObject = uvio::UvProcess;\n+pub type RtioProcessConfig<'self> = uv::process::Config<'self>;\n \n pub trait EventLoop {\n     fn run(&mut self);\n@@ -72,6 +77,13 @@ pub trait IoFactory {\n     fn fs_open<P: PathLike>(&mut self, path: &P, fm: FileMode, fa: FileAccess)\n         -> Result<~RtioFileStream, IoError>;\n     fn fs_unlink<P: PathLike>(&mut self, path: &P) -> Result<(), IoError>;\n+    fn pipe_init(&mut self, ipc: bool) -> Result<~RtioPipeObject, IoError>;\n+    fn spawn(&mut self, config: &RtioProcessConfig) -> Result<~RtioProcessObject, IoError>;\n+}\n+\n+pub trait RtioStream {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError>;\n+    fn write(&mut self, buf: &[u8]) -> Result<(), IoError>;\n }\n \n pub trait RtioTcpListener : RtioSocket {\n@@ -80,9 +92,7 @@ pub trait RtioTcpListener : RtioSocket {\n     fn dont_accept_simultaneously(&mut self) -> Result<(), IoError>;\n }\n \n-pub trait RtioTcpStream : RtioSocket {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError>;\n-    fn write(&mut self, buf: &[u8]) -> Result<(), IoError>;\n+pub trait RtioTcpStream : RtioSocket + RtioStream {\n     fn peer_name(&mut self) -> Result<SocketAddr, IoError>;\n     fn control_congestion(&mut self) -> Result<(), IoError>;\n     fn nodelay(&mut self) -> Result<(), IoError>;\n@@ -124,3 +134,9 @@ pub trait RtioFileStream {\n     fn tell(&self) -> Result<u64, IoError>;\n     fn flush(&mut self) -> Result<(), IoError>;\n }\n+\n+pub trait RtioProcess {\n+    fn id(&self) -> libc::pid_t;\n+    fn kill(&mut self, signal: int) -> Result<(), IoError>;\n+    fn wait(&mut self) -> int;\n+}"}, {"sha": "ff7bb9dd03abcf8403fd40a0d703e44c2c339618", "filename": "src/libstd/rt/uv/async.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8d1fa399402c71331aefd634d710004e00b73a6/src%2Flibstd%2Frt%2Fuv%2Fasync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8d1fa399402c71331aefd634d710004e00b73a6/src%2Flibstd%2Frt%2Fuv%2Fasync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fasync.rs?ref=b8d1fa399402c71331aefd634d710004e00b73a6", "patch": "@@ -34,7 +34,7 @@ impl AsyncWatcher {\n \n         extern fn async_cb(handle: *uvll::uv_async_t, status: c_int) {\n             let mut watcher: AsyncWatcher = NativeHandle::from_native_handle(handle);\n-            let status = status_to_maybe_uv_error(watcher, status);\n+            let status = status_to_maybe_uv_error(status);\n             let data = watcher.get_watcher_data();\n             let cb = data.async_cb.get_ref();\n             (*cb)(watcher, status);"}, {"sha": "5c77181d7eb83a7098a3cb194a85ee89c6157fa8", "filename": "src/libstd/rt/uv/file.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b8d1fa399402c71331aefd634d710004e00b73a6/src%2Flibstd%2Frt%2Fuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8d1fa399402c71331aefd634d710004e00b73a6/src%2Flibstd%2Frt%2Fuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Ffile.rs?ref=b8d1fa399402c71331aefd634d710004e00b73a6", "patch": "@@ -11,8 +11,8 @@\n use prelude::*;\n use ptr::null;\n use libc::c_void;\n-use rt::uv::{Request, NativeHandle, Loop, FsCallback, Buf,\n-             status_to_maybe_uv_error_with_loop, UvError};\n+use rt::uv::{Request, NativeHandle, Loop, FsCallback, Buf, UvError};\n+use rt::uv::status_to_maybe_uv_error;\n use rt::uv::uvll;\n use rt::uv::uvll::*;\n use super::super::io::support::PathLike;\n@@ -62,7 +62,7 @@ impl FsRequest {\n     pub fn open_sync<P: PathLike>(loop_: &Loop, path: &P, flags: int, mode: int)\n           -> Result<int, UvError> {\n         let result = FsRequest::open_common(loop_, path, flags, mode, None);\n-        sync_cleanup(loop_, result)\n+        sync_cleanup(result)\n     }\n \n     fn unlink_common<P: PathLike>(loop_: &Loop, path: &P, cb: Option<FsCallback>) -> int {\n@@ -83,11 +83,11 @@ impl FsRequest {\n     }\n     pub fn unlink<P: PathLike>(loop_: &Loop, path: &P, cb: FsCallback) {\n         let result = FsRequest::unlink_common(loop_, path, Some(cb));\n-        sync_cleanup(loop_, result);\n+        sync_cleanup(result);\n     }\n     pub fn unlink_sync<P: PathLike>(loop_: &Loop, path: &P) -> Result<int, UvError> {\n         let result = FsRequest::unlink_common(loop_, path, None);\n-        sync_cleanup(loop_, result)\n+        sync_cleanup(result)\n     }\n \n     pub fn install_req_data(&self, cb: Option<FsCallback>) {\n@@ -139,9 +139,8 @@ impl NativeHandle<*uvll::uv_fs_t> for FsRequest {\n         match self { &FsRequest(ptr) => ptr }\n     }\n }\n-    fn sync_cleanup(loop_: &Loop, result: int)\n-          -> Result<int, UvError> {\n-        match status_to_maybe_uv_error_with_loop(loop_.native_handle(), result as i32) {\n+    fn sync_cleanup(result: int) -> Result<int, UvError> {\n+        match status_to_maybe_uv_error(result as i32) {\n             Some(err) => Err(err),\n             None => Ok(result)\n         }\n@@ -184,7 +183,7 @@ impl FileDescriptor {\n     pub fn write_sync(&mut self, loop_: &Loop, buf: Buf, offset: i64)\n           -> Result<int, UvError> {\n         let result = self.write_common(loop_, buf, offset, None);\n-        sync_cleanup(loop_, result)\n+        sync_cleanup(result)\n     }\n \n     fn read_common(&mut self, loop_: &Loop, buf: Buf,\n@@ -212,7 +211,7 @@ impl FileDescriptor {\n     pub fn read_sync(&mut self, loop_: &Loop, buf: Buf, offset: i64)\n           -> Result<int, UvError> {\n         let result = self.read_common(loop_, buf, offset, None);\n-        sync_cleanup(loop_, result)\n+        sync_cleanup(result)\n     }\n \n     fn close_common(self, loop_: &Loop, cb: Option<FsCallback>) -> int {\n@@ -234,12 +233,11 @@ impl FileDescriptor {\n     }\n     pub fn close_sync(self, loop_: &Loop) -> Result<int, UvError> {\n         let result = self.close_common(loop_, None);\n-        sync_cleanup(loop_, result)\n+        sync_cleanup(result)\n     }\n }\n extern fn compl_cb(req: *uv_fs_t) {\n     let mut req: FsRequest = NativeHandle::from_native_handle(req);\n-    let loop_ = req.get_loop();\n     // pull the user cb out of the req data\n     let cb = {\n         let data = req.get_req_data();\n@@ -250,8 +248,7 @@ extern fn compl_cb(req: *uv_fs_t) {\n     // in uv_fs_open calls, the result will be the fd in the\n     // case of success, otherwise it's -1 indicating an error\n     let result = req.get_result();\n-    let status = status_to_maybe_uv_error_with_loop(\n-        loop_.native_handle(), result);\n+    let status = status_to_maybe_uv_error(result);\n     // we have a req and status, call the user cb..\n     // only giving the user a ref to the FsRequest, as we\n     // have to clean it up, afterwards (and they aren't really"}, {"sha": "8cbcd7b77c0824fdea0b1df2e1234cdc0a412b3c", "filename": "src/libstd/rt/uv/idle.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8d1fa399402c71331aefd634d710004e00b73a6/src%2Flibstd%2Frt%2Fuv%2Fidle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8d1fa399402c71331aefd634d710004e00b73a6/src%2Flibstd%2Frt%2Fuv%2Fidle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fidle.rs?ref=b8d1fa399402c71331aefd634d710004e00b73a6", "patch": "@@ -43,7 +43,7 @@ impl IdleWatcher {\n             let mut idle_watcher: IdleWatcher = NativeHandle::from_native_handle(handle);\n             let data = idle_watcher.get_watcher_data();\n             let cb: &IdleCallback = data.idle_cb.get_ref();\n-            let status = status_to_maybe_uv_error(idle_watcher, status);\n+            let status = status_to_maybe_uv_error(status);\n             (*cb)(idle_watcher, status);\n         }\n     }\n@@ -57,7 +57,7 @@ impl IdleWatcher {\n             let mut idle_watcher: IdleWatcher = NativeHandle::from_native_handle(handle);\n             let data = idle_watcher.get_watcher_data();\n             let cb: &IdleCallback = data.idle_cb.get_ref();\n-            let status = status_to_maybe_uv_error(idle_watcher, status);\n+            let status = status_to_maybe_uv_error(status);\n             (*cb)(idle_watcher, status);\n         }\n     }"}, {"sha": "700b80c7398b53675416cb92cbbc8a168c6d9b57", "filename": "src/libstd/rt/uv/mod.rs", "status": "modified", "additions": 23, "deletions": 42, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/b8d1fa399402c71331aefd634d710004e00b73a6/src%2Flibstd%2Frt%2Fuv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8d1fa399402c71331aefd634d710004e00b73a6/src%2Flibstd%2Frt%2Fuv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fmod.rs?ref=b8d1fa399402c71331aefd634d710004e00b73a6", "patch": "@@ -58,6 +58,8 @@ pub use self::net::{StreamWatcher, TcpWatcher, UdpWatcher};\n pub use self::idle::IdleWatcher;\n pub use self::timer::TimerWatcher;\n pub use self::async::AsyncWatcher;\n+pub use self::process::Process;\n+pub use self::pipe::Pipe;\n \n /// The implementation of `rtio` for libuv\n pub mod uvio;\n@@ -70,6 +72,8 @@ pub mod net;\n pub mod idle;\n pub mod timer;\n pub mod async;\n+pub mod process;\n+pub mod pipe;\n \n /// XXX: Loop(*handle) is buggy with destructors. Normal structs\n /// with dtors may not be destructured, but tuple structs can,\n@@ -126,6 +130,8 @@ pub type NullCallback = ~fn();\n pub type IdleCallback = ~fn(IdleWatcher, Option<UvError>);\n pub type ConnectionCallback = ~fn(StreamWatcher, Option<UvError>);\n pub type FsCallback = ~fn(&mut FsRequest, Option<UvError>);\n+// first int is exit_status, second is term_signal\n+pub type ExitCallback = ~fn(Process, int, int, Option<UvError>);\n pub type TimerCallback = ~fn(TimerWatcher, Option<UvError>);\n pub type AsyncCallback = ~fn(AsyncWatcher, Option<UvError>);\n pub type UdpReceiveCallback = ~fn(UdpWatcher, int, Buf, SocketAddr, uint, Option<UvError>);\n@@ -143,7 +149,8 @@ struct WatcherData {\n     timer_cb: Option<TimerCallback>,\n     async_cb: Option<AsyncCallback>,\n     udp_recv_cb: Option<UdpReceiveCallback>,\n-    udp_send_cb: Option<UdpSendCallback>\n+    udp_send_cb: Option<UdpSendCallback>,\n+    exit_cb: Option<ExitCallback>,\n }\n \n pub trait WatcherInterop {\n@@ -175,7 +182,8 @@ impl<H, W: Watcher + NativeHandle<*H>> WatcherInterop for W {\n                 timer_cb: None,\n                 async_cb: None,\n                 udp_recv_cb: None,\n-                udp_send_cb: None\n+                udp_send_cb: None,\n+                exit_cb: None,\n             };\n             let data = transmute::<~WatcherData, *c_void>(data);\n             uvll::set_data_for_uv_handle(self.native_handle(), data);\n@@ -202,12 +210,12 @@ impl<H, W: Watcher + NativeHandle<*H>> WatcherInterop for W {\n // XXX: Need to define the error constants like EOF so they can be\n // compared to the UvError type\n \n-pub struct UvError(uvll::uv_err_t);\n+pub struct UvError(c_int);\n \n impl UvError {\n     pub fn name(&self) -> ~str {\n         unsafe {\n-            let inner = match self { &UvError(ref a) => a };\n+            let inner = match self { &UvError(a) => a };\n             let name_str = uvll::err_name(inner);\n             assert!(name_str.is_not_null());\n             from_c_str(name_str)\n@@ -216,15 +224,15 @@ impl UvError {\n \n     pub fn desc(&self) -> ~str {\n         unsafe {\n-            let inner = match self { &UvError(ref a) => a };\n+            let inner = match self { &UvError(a) => a };\n             let desc_str = uvll::strerror(inner);\n             assert!(desc_str.is_not_null());\n             from_c_str(desc_str)\n         }\n     }\n \n     pub fn is_eof(&self) -> bool {\n-        self.code == uvll::EOF\n+        **self == uvll::EOF\n     }\n }\n \n@@ -236,38 +244,30 @@ impl ToStr for UvError {\n \n #[test]\n fn error_smoke_test() {\n-    let err = uvll::uv_err_t { code: 1, sys_errno_: 1 };\n-    let err: UvError = UvError(err);\n+    let err: UvError = UvError(uvll::EOF);\n     assert_eq!(err.to_str(), ~\"EOF: end of file\");\n }\n \n-pub fn last_uv_error<H, W: Watcher + NativeHandle<*H>>(watcher: &W) -> UvError {\n-    unsafe {\n-        let loop_ = watcher.event_loop();\n-        UvError(uvll::last_error(loop_.native_handle()))\n-    }\n-}\n-\n pub fn uv_error_to_io_error(uverr: UvError) -> IoError {\n     unsafe {\n         // Importing error constants\n         use rt::uv::uvll::*;\n         use rt::io::*;\n \n         // uv error descriptions are static\n-        let c_desc = uvll::strerror(&*uverr);\n+        let c_desc = uvll::strerror(*uverr);\n         let desc = str::raw::c_str_to_static_slice(c_desc);\n \n-        let kind = match uverr.code {\n+        let kind = match *uverr {\n             UNKNOWN => OtherIoError,\n             OK => OtherIoError,\n             EOF => EndOfFile,\n             EACCES => PermissionDenied,\n             ECONNREFUSED => ConnectionRefused,\n             ECONNRESET => ConnectionReset,\n             EPIPE => BrokenPipe,\n-            _ => {\n-                rtdebug!(\"uverr.code %u\", uverr.code as uint);\n+            err => {\n+                rtdebug!(\"uverr.code %d\", err as int);\n                 // XXX: Need to map remaining uv error types\n                 OtherIoError\n             }\n@@ -281,31 +281,12 @@ pub fn uv_error_to_io_error(uverr: UvError) -> IoError {\n     }\n }\n \n-/// Given a uv handle, convert a callback status to a UvError\n-pub fn status_to_maybe_uv_error_with_loop(\n-    loop_: *uvll::uv_loop_t,\n-    status: c_int) -> Option<UvError> {\n-    if status != -1 {\n-        None\n-    } else {\n-        unsafe {\n-            rtdebug!(\"loop: %x\", loop_ as uint);\n-            let err = uvll::last_error(loop_);\n-            Some(UvError(err))\n-        }\n-    }\n-}\n-/// Given a uv handle, convert a callback status to a UvError\n-pub fn status_to_maybe_uv_error<T, U: Watcher + NativeHandle<*T>>(handle: U,\n-                                                                 status: c_int) -> Option<UvError> {\n-    if status != -1 {\n+/// Convert a callback status to a UvError\n+pub fn status_to_maybe_uv_error(status: c_int) -> Option<UvError> {\n+    if status >= 0 {\n         None\n     } else {\n-        unsafe {\n-            rtdebug!(\"handle: %x\", handle.native_handle() as uint);\n-            let loop_ = uvll::get_loop_for_uv_handle(handle.native_handle());\n-            status_to_maybe_uv_error_with_loop(loop_, status)\n-        }\n+        Some(UvError(status))\n     }\n }\n "}, {"sha": "1581b0170878fb0f7276c732860d7e6e2ef65df1", "filename": "src/libstd/rt/uv/net.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b8d1fa399402c71331aefd634d710004e00b73a6/src%2Flibstd%2Frt%2Fuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8d1fa399402c71331aefd634d710004e00b73a6/src%2Flibstd%2Frt%2Fuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fnet.rs?ref=b8d1fa399402c71331aefd634d710004e00b73a6", "patch": "@@ -16,7 +16,6 @@ use rt::uv::{AllocCallback, ConnectionCallback, ReadCallback, UdpReceiveCallback\n use rt::uv::{Loop, Watcher, Request, UvError, Buf, NativeHandle, NullCallback,\n              status_to_maybe_uv_error};\n use rt::io::net::ip::{SocketAddr, Ipv4Addr, Ipv6Addr};\n-use rt::uv::last_uv_error;\n use vec;\n use str;\n use from_str::{FromStr};\n@@ -137,7 +136,7 @@ impl StreamWatcher {\n             rtdebug!(\"buf len: %d\", buf.len as int);\n             let mut stream_watcher: StreamWatcher = NativeHandle::from_native_handle(stream);\n             let cb = stream_watcher.get_watcher_data().read_cb.get_ref();\n-            let status = status_to_maybe_uv_error(stream_watcher, nread as c_int);\n+            let status = status_to_maybe_uv_error(nread as c_int);\n             (*cb)(stream_watcher, nread as int, buf, status);\n         }\n     }\n@@ -167,7 +166,7 @@ impl StreamWatcher {\n             let mut stream_watcher = write_request.stream();\n             write_request.delete();\n             let cb = stream_watcher.get_watcher_data().write_cb.take_unwrap();\n-            let status = status_to_maybe_uv_error(stream_watcher, status);\n+            let status = status_to_maybe_uv_error(status);\n             cb(stream_watcher, status);\n         }\n     }\n@@ -232,7 +231,7 @@ impl TcpWatcher {\n             };\n             match result {\n                 0 => Ok(()),\n-                _ => Err(last_uv_error(self)),\n+                _ => Err(UvError(result)),\n             }\n         }\n     }\n@@ -260,7 +259,7 @@ impl TcpWatcher {\n                 let mut stream_watcher = connect_request.stream();\n                 connect_request.delete();\n                 let cb = stream_watcher.get_watcher_data().connect_cb.take_unwrap();\n-                let status = status_to_maybe_uv_error(stream_watcher, status);\n+                let status = status_to_maybe_uv_error(status);\n                 cb(stream_watcher, status);\n             }\n         }\n@@ -283,7 +282,7 @@ impl TcpWatcher {\n             rtdebug!(\"connection_cb\");\n             let mut stream_watcher: StreamWatcher = NativeHandle::from_native_handle(handle);\n             let cb = stream_watcher.get_watcher_data().connect_cb.get_ref();\n-            let status = status_to_maybe_uv_error(stream_watcher, status);\n+            let status = status_to_maybe_uv_error(status);\n             (*cb)(stream_watcher, status);\n         }\n     }\n@@ -327,7 +326,7 @@ impl UdpWatcher {\n             };\n             match result {\n                 0 => Ok(()),\n-                _ => Err(last_uv_error(self)),\n+                _ => Err(UvError(result)),\n             }\n         }\n     }\n@@ -360,7 +359,7 @@ impl UdpWatcher {\n             rtdebug!(\"buf len: %d\", buf.len as int);\n             let mut udp_watcher: UdpWatcher = NativeHandle::from_native_handle(handle);\n             let cb = udp_watcher.get_watcher_data().udp_recv_cb.get_ref();\n-            let status = status_to_maybe_uv_error(udp_watcher, nread as c_int);\n+            let status = status_to_maybe_uv_error(nread as c_int);\n             let addr = uv_socket_addr_to_socket_addr(sockaddr_to_UvSocketAddr(addr));\n             (*cb)(udp_watcher, nread as int, buf, addr, flags as uint, status);\n         }\n@@ -395,7 +394,7 @@ impl UdpWatcher {\n             let mut udp_watcher = send_request.handle();\n             send_request.delete();\n             let cb = udp_watcher.get_watcher_data().udp_send_cb.take_unwrap();\n-            let status = status_to_maybe_uv_error(udp_watcher, status);\n+            let status = status_to_maybe_uv_error(status);\n             cb(udp_watcher, status);\n         }\n     }"}, {"sha": "1147c731a60c5e312a1d055bf915cec8ad4bbd4c", "filename": "src/libstd/rt/uv/pipe.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/b8d1fa399402c71331aefd634d710004e00b73a6/src%2Flibstd%2Frt%2Fuv%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8d1fa399402c71331aefd634d710004e00b73a6/src%2Flibstd%2Frt%2Fuv%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fpipe.rs?ref=b8d1fa399402c71331aefd634d710004e00b73a6", "patch": "@@ -0,0 +1,66 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use prelude::*;\n+use libc;\n+\n+use rt::uv;\n+use rt::uv::net;\n+use rt::uv::uvll;\n+\n+pub struct Pipe(*uvll::uv_pipe_t);\n+\n+impl uv::Watcher for Pipe {}\n+\n+impl Pipe {\n+    pub fn new(loop_: &uv::Loop, ipc: bool) -> Pipe {\n+        unsafe {\n+            let handle = uvll::malloc_handle(uvll::UV_NAMED_PIPE);\n+            assert!(handle.is_not_null());\n+            let ipc = ipc as libc::c_int;\n+            assert_eq!(uvll::pipe_init(loop_.native_handle(), handle, ipc), 0);\n+            let mut ret: Pipe =\n+                    uv::NativeHandle::from_native_handle(handle);\n+            ret.install_watcher_data();\n+            ret\n+        }\n+    }\n+\n+    pub fn as_stream(&self) -> net::StreamWatcher {\n+        net::StreamWatcher(**self as *uvll::uv_stream_t)\n+    }\n+\n+    pub fn close(self, cb: uv::NullCallback) {\n+        {\n+            let mut this = self;\n+            let data = this.get_watcher_data();\n+            assert!(data.close_cb.is_none());\n+            data.close_cb = Some(cb);\n+        }\n+\n+        unsafe { uvll::close(self.native_handle(), close_cb); }\n+\n+        extern fn close_cb(handle: *uvll::uv_pipe_t) {\n+            let mut process: Pipe = uv::NativeHandle::from_native_handle(handle);\n+            process.get_watcher_data().close_cb.take_unwrap()();\n+            process.drop_watcher_data();\n+            unsafe { uvll::free_handle(handle as *libc::c_void) }\n+        }\n+    }\n+}\n+\n+impl uv::NativeHandle<*uvll::uv_pipe_t> for Pipe {\n+    fn from_native_handle(handle: *uvll::uv_pipe_t) -> Pipe {\n+        Pipe(handle)\n+    }\n+    fn native_handle(&self) -> *uvll::uv_pipe_t {\n+        match self { &Pipe(ptr) => ptr }\n+    }\n+}"}, {"sha": "a02cf67ec2699973cd6703ce0f34135c68c57674", "filename": "src/libstd/rt/uv/process.rs", "status": "added", "additions": 264, "deletions": 0, "changes": 264, "blob_url": "https://github.com/rust-lang/rust/blob/b8d1fa399402c71331aefd634d710004e00b73a6/src%2Flibstd%2Frt%2Fuv%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8d1fa399402c71331aefd634d710004e00b73a6/src%2Flibstd%2Frt%2Fuv%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fprocess.rs?ref=b8d1fa399402c71331aefd634d710004e00b73a6", "patch": "@@ -0,0 +1,264 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use prelude::*;\n+use libc;\n+use ptr;\n+use vec;\n+use cell::Cell;\n+\n+use rt::uv;\n+use rt::uv::net;\n+use rt::uv::pipe;\n+use rt::uv::uvll;\n+\n+/// A process wraps the handle of the underlying uv_process_t.\n+pub struct Process(*uvll::uv_process_t);\n+\n+/// This configuration describes how a new process should be spawned. This is\n+/// translated to libuv's own configuration\n+pub struct Config<'self> {\n+    /// Path to the program to run\n+    program: &'self str,\n+\n+    /// Arguments to pass to the program (doesn't include the program itself)\n+    args: &'self [~str],\n+\n+    /// Optional environment to specify for the program. If this is None, then\n+    /// it will inherit the current process's environment.\n+    env: Option<&'self [(~str, ~str)]>,\n+\n+    /// Optional working directory for the new process. If this is None, then\n+    /// the current directory of the running process is inherited.\n+    cwd: Option<&'self str>,\n+\n+    /// Any number of streams/file descriptors/pipes may be attached to this\n+    /// process. This list enumerates the file descriptors and such for the\n+    /// process to be spawned, and the file descriptors inherited will start at\n+    /// 0 and go to the length of this array.\n+    ///\n+    /// Standard file descriptors are:\n+    ///\n+    ///     0 - stdin\n+    ///     1 - stdout\n+    ///     2 - stderr\n+    io: &'self [StdioContainer]\n+}\n+\n+/// Describes what to do with a standard io stream for a child process.\n+pub enum StdioContainer {\n+    /// This stream will be ignored. This is the equivalent of attaching the\n+    /// stream to `/dev/null`\n+    Ignored,\n+\n+    /// The specified file descriptor is inherited for the stream which it is\n+    /// specified for.\n+    InheritFd(libc::c_int),\n+\n+    /// The specified libuv stream is inherited for the corresponding file\n+    /// descriptor it is assigned to.\n+    InheritStream(net::StreamWatcher),\n+\n+    /// Creates a pipe for the specified file descriptor which will be directed\n+    /// into the previously-initialized pipe passed in.\n+    ///\n+    /// The first boolean argument is whether the pipe is readable, and the\n+    /// second is whether it is writable. These properties are from the view of\n+    /// the *child* process, not the parent process.\n+    CreatePipe(pipe::Pipe, bool /* readable */, bool /* writable */),\n+}\n+\n+impl uv::Watcher for Process {}\n+\n+impl Process {\n+    /// Creates a new process, ready to spawn inside an event loop\n+    pub fn new() -> Process {\n+        let handle = unsafe { uvll::malloc_handle(uvll::UV_PROCESS) };\n+        assert!(handle.is_not_null());\n+        let mut ret: Process = uv::NativeHandle::from_native_handle(handle);\n+        ret.install_watcher_data();\n+        return ret;\n+    }\n+\n+    /// Spawn a new process inside the specified event loop.\n+    ///\n+    /// The `config` variable will be passed down to libuv, and the `exit_cb`\n+    /// will be run only once, when the process exits.\n+    ///\n+    /// Returns either the corresponding process object or an error which\n+    /// occurred.\n+    pub fn spawn(&mut self, loop_: &uv::Loop, config: &Config,\n+                 exit_cb: uv::ExitCallback) -> Result<(), uv::UvError> {\n+        let cwd = config.cwd.map_move(|s| s.to_c_str());\n+\n+        extern fn on_exit(p: *uvll::uv_process_t,\n+                          exit_status: libc::c_int,\n+                          term_signal: libc::c_int) {\n+            let mut p: Process = uv::NativeHandle::from_native_handle(p);\n+            let err = match exit_status {\n+                0 => None,\n+                _ => uv::status_to_maybe_uv_error(-1)\n+            };\n+            p.get_watcher_data().exit_cb.take_unwrap()(p,\n+                                                       exit_status as int,\n+                                                       term_signal as int,\n+                                                       err);\n+        }\n+\n+        let mut stdio = vec::with_capacity::<uvll::uv_stdio_container_t>(\n+                                config.io.len());\n+        unsafe {\n+            vec::raw::set_len(&mut stdio, config.io.len());\n+            for (slot, &other) in stdio.iter().zip(config.io.iter()) {\n+                set_stdio(slot as *uvll::uv_stdio_container_t, other);\n+            }\n+        }\n+\n+        let exit_cb = Cell::new(exit_cb);\n+        do with_argv(config.program, config.args) |argv| {\n+            do with_env(config.env) |envp| {\n+                let options = uvll::uv_process_options_t {\n+                    exit_cb: on_exit,\n+                    file: unsafe { *argv },\n+                    args: argv,\n+                    env: envp,\n+                    cwd: match cwd {\n+                        Some(ref cwd) => cwd.with_ref(|p| p),\n+                        None => ptr::null(),\n+                    },\n+                    flags: 0,\n+                    stdio_count: stdio.len() as libc::c_int,\n+                    stdio: stdio.as_imm_buf(|p, _| p),\n+                    uid: 0,\n+                    gid: 0,\n+                };\n+\n+                match unsafe {\n+                    uvll::spawn(loop_.native_handle(), **self, options)\n+                } {\n+                    0 => {\n+                        (*self).get_watcher_data().exit_cb = Some(exit_cb.take());\n+                        Ok(())\n+                    }\n+                    err => Err(uv::UvError(err))\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Sends a signal to this process.\n+    ///\n+    /// This is a wrapper around `uv_process_kill`\n+    pub fn kill(&self, signum: int) -> Result<(), uv::UvError> {\n+        match unsafe {\n+            uvll::process_kill(self.native_handle(), signum as libc::c_int)\n+        } {\n+            0 => Ok(()),\n+            err => Err(uv::UvError(err))\n+        }\n+    }\n+\n+    /// Returns the process id of a spawned process\n+    pub fn pid(&self) -> libc::pid_t {\n+        unsafe { uvll::process_pid(**self) as libc::pid_t }\n+    }\n+\n+    /// Closes this handle, invoking the specified callback once closed\n+    pub fn close(self, cb: uv::NullCallback) {\n+        {\n+            let mut this = self;\n+            let data = this.get_watcher_data();\n+            assert!(data.close_cb.is_none());\n+            data.close_cb = Some(cb);\n+        }\n+\n+        unsafe { uvll::close(self.native_handle(), close_cb); }\n+\n+        extern fn close_cb(handle: *uvll::uv_process_t) {\n+            let mut process: Process = uv::NativeHandle::from_native_handle(handle);\n+            process.get_watcher_data().close_cb.take_unwrap()();\n+            process.drop_watcher_data();\n+            unsafe { uvll::free_handle(handle as *libc::c_void) }\n+        }\n+    }\n+}\n+\n+unsafe fn set_stdio(dst: *uvll::uv_stdio_container_t, io: StdioContainer) {\n+    match io {\n+        Ignored => { uvll::set_stdio_container_flags(dst, uvll::STDIO_IGNORE); }\n+        InheritFd(fd) => {\n+            uvll::set_stdio_container_flags(dst, uvll::STDIO_INHERIT_FD);\n+            uvll::set_stdio_container_fd(dst, fd);\n+        }\n+        InheritStream(stream) => {\n+            uvll::set_stdio_container_flags(dst, uvll::STDIO_INHERIT_STREAM);\n+            uvll::set_stdio_container_stream(dst, stream.native_handle());\n+        }\n+        CreatePipe(pipe, readable, writable) => {\n+            let mut flags = uvll::STDIO_CREATE_PIPE as libc::c_int;\n+            if readable {\n+                flags |= uvll::STDIO_READABLE_PIPE as libc::c_int;\n+            }\n+            if writable {\n+                flags |= uvll::STDIO_WRITABLE_PIPE as libc::c_int;\n+            }\n+            uvll::set_stdio_container_flags(dst, flags);\n+            uvll::set_stdio_container_stream(dst,\n+                                             pipe.as_stream().native_handle());\n+        }\n+    }\n+}\n+\n+/// Converts the program and arguments to the argv array expected by libuv\n+fn with_argv<T>(prog: &str, args: &[~str], f: &fn(**libc::c_char) -> T) -> T {\n+    // First, allocation space to put all the C-strings (we need to have\n+    // ownership of them somewhere\n+    let mut c_strs = vec::with_capacity(args.len() + 1);\n+    c_strs.push(prog.to_c_str());\n+    for arg in args.iter() {\n+        c_strs.push(arg.to_c_str());\n+    }\n+\n+    // Next, create the char** array\n+    let mut c_args = vec::with_capacity(c_strs.len() + 1);\n+    for s in c_strs.iter() {\n+        c_args.push(s.with_ref(|p| p));\n+    }\n+    c_args.push(ptr::null());\n+    c_args.as_imm_buf(|buf, _| f(buf))\n+}\n+\n+/// Converts the environment to the env array expected by libuv\n+fn with_env<T>(env: Option<&[(~str, ~str)]>, f: &fn(**libc::c_char) -> T) -> T {\n+    let env = match env {\n+        Some(s) => s,\n+        None => { return f(ptr::null()); }\n+    };\n+    // As with argv, create some temporary storage and then the actual array\n+    let mut envp = vec::with_capacity(env.len());\n+    for &(ref key, ref value) in env.iter() {\n+        envp.push(fmt!(\"%s=%s\", *key, *value).to_c_str());\n+    }\n+    let mut c_envp = vec::with_capacity(envp.len() + 1);\n+    for s in envp.iter() {\n+        c_envp.push(s.with_ref(|p| p));\n+    }\n+    c_envp.push(ptr::null());\n+    c_envp.as_imm_buf(|buf, _| f(buf))\n+}\n+\n+impl uv::NativeHandle<*uvll::uv_process_t> for Process {\n+    fn from_native_handle(handle: *uvll::uv_process_t) -> Process {\n+        Process(handle)\n+    }\n+    fn native_handle(&self) -> *uvll::uv_process_t {\n+        match self { &Process(ptr) => ptr }\n+    }\n+}"}, {"sha": "7b09cf2eb0e3ab058f4c2cf2d65526585964e758", "filename": "src/libstd/rt/uv/timer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8d1fa399402c71331aefd634d710004e00b73a6/src%2Flibstd%2Frt%2Fuv%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8d1fa399402c71331aefd634d710004e00b73a6/src%2Flibstd%2Frt%2Fuv%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Ftimer.rs?ref=b8d1fa399402c71331aefd634d710004e00b73a6", "patch": "@@ -43,7 +43,7 @@ impl TimerWatcher {\n             let mut watcher: TimerWatcher = NativeHandle::from_native_handle(handle);\n             let data = watcher.get_watcher_data();\n             let cb = data.timer_cb.get_ref();\n-            let status = status_to_maybe_uv_error(watcher, status);\n+            let status = status_to_maybe_uv_error(status);\n             (*cb)(watcher, status);\n         }\n     }"}, {"sha": "c771f93cef5e0de13b9b80e62b47fad4411662c2", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 244, "deletions": 50, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/b8d1fa399402c71331aefd634d710004e00b73a6/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8d1fa399402c71331aefd634d710004e00b73a6/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=b8d1fa399402c71331aefd634d710004e00b73a6", "patch": "@@ -13,7 +13,7 @@ use cast::transmute;\n use cast;\n use cell::Cell;\n use clone::Clone;\n-use libc::{c_int, c_uint, c_void};\n+use libc::{c_int, c_uint, c_void, pid_t};\n use ops::Drop;\n use option::*;\n use ptr;\n@@ -22,6 +22,7 @@ use result::*;\n use rt::io::IoError;\n use rt::io::net::ip::{SocketAddr, IpAddr};\n use rt::io::{standard_error, OtherIoError, SeekStyle, SeekSet, SeekCur, SeekEnd};\n+use rt::kill::BlockedTask;\n use rt::local::Local;\n use rt::rtio::*;\n use rt::sched::{Scheduler, SchedHandle};\n@@ -148,7 +149,7 @@ fn socket_name<T, U: Watcher + NativeHandle<*T>>(sk: SocketNameKind,\n     };\n \n     if r != 0 {\n-        let status = status_to_maybe_uv_error(handle, r);\n+        let status = status_to_maybe_uv_error(r);\n         return Err(uv_error_to_io_error(status.unwrap()));\n     }\n \n@@ -591,6 +592,63 @@ impl IoFactory for UvIoFactory {\n         assert!(!result_cell.is_empty());\n         return result_cell.take();\n     }\n+\n+    fn pipe_init(&mut self, ipc: bool) -> Result<~RtioPipeObject, IoError> {\n+        let home = get_handle_to_current_scheduler!();\n+        Ok(~UvPipeStream { pipe: Pipe::new(self.uv_loop(), ipc), home: home })\n+    }\n+\n+    fn spawn(&mut self,\n+             config: &process::Config) -> Result<~RtioProcessObject, IoError> {\n+        // Sadly, we must create the UvProcess before we actually call uv_spawn\n+        // so that the exit_cb can close over it and notify it when the process\n+        // has exited.\n+        let mut ret = ~UvProcess {\n+            process: Process::new(),\n+            home: None,\n+            exit_status: None,\n+            term_signal: None,\n+            exit_error: None,\n+            descheduled: None,\n+        };\n+        let ret_ptr = unsafe {\n+            *cast::transmute::<&~UvProcess, &*mut UvProcess>(&ret)\n+        };\n+\n+        // The purpose of this exit callback is to record the data about the\n+        // exit and then wake up the task which may be waiting for the process\n+        // to exit. This is all performed in the current io-loop, and the\n+        // implementation of UvProcess ensures that reading these fields always\n+        // occurs on the current io-loop.\n+        let exit_cb: ExitCallback = |_, exit_status, term_signal, error| {\n+            unsafe {\n+                assert!((*ret_ptr).exit_status.is_none());\n+                (*ret_ptr).exit_status = Some(exit_status);\n+                (*ret_ptr).term_signal = Some(term_signal);\n+                (*ret_ptr).exit_error = error;\n+                match (*ret_ptr).descheduled.take() {\n+                    Some(task) => {\n+                        let scheduler: ~Scheduler = Local::take();\n+                        scheduler.resume_blocked_task_immediately(task);\n+                    }\n+                    None => {}\n+                }\n+            }\n+        };\n+\n+        match ret.process.spawn(self.uv_loop(), config, exit_cb) {\n+            Ok(()) => {\n+                // Only now do we actually get a handle to this scheduler.\n+                ret.home = Some(get_handle_to_current_scheduler!());\n+                Ok(ret)\n+            }\n+            Err(uverr) => {\n+                // We still need to close the process handle we created, but\n+                // that's taken care for us in the destructor of UvProcess\n+                Err(uv_error_to_io_error(uverr))\n+            }\n+        }\n+    }\n }\n \n pub struct UvTcpListener {\n@@ -679,7 +737,7 @@ impl RtioTcpListener for UvTcpListener {\n                 uvll::tcp_simultaneous_accepts(self_.watcher().native_handle(), 1 as c_int)\n             };\n \n-            match status_to_maybe_uv_error(self_.watcher(), r) {\n+            match status_to_maybe_uv_error(r) {\n                 Some(err) => Err(uv_error_to_io_error(err)),\n                 None => Ok(())\n             }\n@@ -692,48 +750,23 @@ impl RtioTcpListener for UvTcpListener {\n                 uvll::tcp_simultaneous_accepts(self_.watcher().native_handle(), 0 as c_int)\n             };\n \n-            match status_to_maybe_uv_error(self_.watcher(), r) {\n+            match status_to_maybe_uv_error(r) {\n                 Some(err) => Err(uv_error_to_io_error(err)),\n                 None => Ok(())\n             }\n         }\n     }\n }\n \n-pub struct UvTcpStream {\n-    watcher: TcpWatcher,\n-    home: SchedHandle,\n-}\n-\n-impl HomingIO for UvTcpStream {\n-    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n+trait UvStream: HomingIO {\n+    fn as_stream(&mut self) -> StreamWatcher;\n }\n \n-impl Drop for UvTcpStream {\n-    fn drop(&self) {\n-        // XXX need mutable finalizer\n-        let this = unsafe { transmute::<&UvTcpStream, &mut UvTcpStream>(self) };\n-        do this.home_for_io_with_sched |self_, scheduler| {\n-            do scheduler.deschedule_running_task_and_then |_, task| {\n-                let task_cell = Cell::new(task);\n-                do self_.watcher.as_stream().close {\n-                    let scheduler: ~Scheduler = Local::take();\n-                    scheduler.resume_blocked_task_immediately(task_cell.take());\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl RtioSocket for UvTcpStream {\n-    fn socket_name(&mut self) -> Result<SocketAddr, IoError> {\n-        do self.home_for_io |self_| {\n-            socket_name(Tcp, self_.watcher)\n-        }\n-    }\n-}\n-\n-impl RtioTcpStream for UvTcpStream {\n+// FIXME(#3429) I would rather this be `impl<T: UvStream> RtioStream for T` but\n+//              that has conflicts with other traits that also have methods\n+//              called `read` and `write`\n+macro_rules! rtiostream(($t:ident) => {\n+impl RtioStream for $t {\n     fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n         do self.home_for_io_with_sched |self_, scheduler| {\n             let result_cell = Cell::new_empty();\n@@ -747,7 +780,7 @@ impl RtioTcpStream for UvTcpStream {\n                 let alloc: AllocCallback = |_| unsafe {\n                     slice_to_uv_buf(*buf_ptr)\n                 };\n-                let mut watcher = self_.watcher.as_stream();\n+                let mut watcher = self_.as_stream();\n                 do watcher.read_start(alloc) |mut watcher, nread, _buf, status| {\n \n                     // Stop reading so that no read callbacks are\n@@ -783,7 +816,7 @@ impl RtioTcpStream for UvTcpStream {\n             do scheduler.deschedule_running_task_and_then |_, task| {\n                 let task_cell = Cell::new(task);\n                 let buf = unsafe { slice_to_uv_buf(*buf_ptr) };\n-                let mut watcher = self_.watcher.as_stream();\n+                let mut watcher = self_.as_stream();\n                 do watcher.write(buf) |_watcher, status| {\n                     let result = if status.is_none() {\n                         Ok(())\n@@ -802,7 +835,85 @@ impl RtioTcpStream for UvTcpStream {\n             result_cell.take()\n         }\n     }\n+}\n+})\n+\n+rtiostream!(UvPipeStream)\n+rtiostream!(UvTcpStream)\n+\n+pub struct UvPipeStream {\n+    pipe: Pipe,\n+    home: SchedHandle,\n+}\n+\n+impl UvStream for UvPipeStream {\n+    fn as_stream(&mut self) -> StreamWatcher { self.pipe.as_stream() }\n+}\n+\n+impl HomingIO for UvPipeStream {\n+    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n+}\n+\n+impl Drop for UvPipeStream {\n+    fn drop(&self) {\n+        // FIXME(#4330): should not need a transmute\n+        let this = unsafe { cast::transmute_mut(self) };\n+        do this.home_for_io |self_| {\n+            let scheduler: ~Scheduler = Local::take();\n+            do scheduler.deschedule_running_task_and_then |_, task| {\n+                let task_cell = Cell::new(task);\n+                do self_.pipe.close {\n+                    let scheduler: ~Scheduler = Local::take();\n+                    scheduler.resume_blocked_task_immediately(task_cell.take());\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl UvPipeStream {\n+    pub fn uv_pipe(&self) -> Pipe { self.pipe }\n+}\n \n+pub struct UvTcpStream {\n+    watcher: TcpWatcher,\n+    home: SchedHandle,\n+}\n+\n+impl HomingIO for UvTcpStream {\n+    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n+}\n+\n+impl Drop for UvTcpStream {\n+    fn drop(&self) {\n+        // FIXME(#4330): should not need a transmute\n+        let this = unsafe { cast::transmute_mut(self) };\n+        do this.home_for_io |self_| {\n+            let scheduler: ~Scheduler = Local::take();\n+            do scheduler.deschedule_running_task_and_then |_, task| {\n+                let task_cell = Cell::new(task);\n+                do self_.watcher.as_stream().close {\n+                    let scheduler: ~Scheduler = Local::take();\n+                    scheduler.resume_blocked_task_immediately(task_cell.take());\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl UvStream for UvTcpStream {\n+    fn as_stream(&mut self) -> StreamWatcher { self.watcher.as_stream() }\n+}\n+\n+impl RtioSocket for UvTcpStream {\n+    fn socket_name(&mut self) -> Result<SocketAddr, IoError> {\n+        do self.home_for_io |self_| {\n+            socket_name(Tcp, self_.watcher)\n+        }\n+    }\n+}\n+\n+impl RtioTcpStream for UvTcpStream {\n     fn peer_name(&mut self) -> Result<SocketAddr, IoError> {\n         do self.home_for_io |self_| {\n             socket_name(TcpPeer, self_.watcher)\n@@ -813,7 +924,7 @@ impl RtioTcpStream for UvTcpStream {\n         do self.home_for_io |self_| {\n             let r = unsafe { uvll::tcp_nodelay(self_.watcher.native_handle(), 0 as c_int) };\n \n-            match status_to_maybe_uv_error(self_.watcher, r) {\n+            match status_to_maybe_uv_error(r) {\n                 Some(err) => Err(uv_error_to_io_error(err)),\n                 None => Ok(())\n             }\n@@ -824,7 +935,7 @@ impl RtioTcpStream for UvTcpStream {\n         do self.home_for_io |self_| {\n             let r = unsafe { uvll::tcp_nodelay(self_.watcher.native_handle(), 1 as c_int) };\n \n-            match status_to_maybe_uv_error(self_.watcher, r) {\n+            match status_to_maybe_uv_error(r) {\n                 Some(err) => Err(uv_error_to_io_error(err)),\n                 None => Ok(())\n             }\n@@ -838,7 +949,7 @@ impl RtioTcpStream for UvTcpStream {\n                                     delay_in_seconds as c_uint)\n             };\n \n-            match status_to_maybe_uv_error(self_.watcher, r) {\n+            match status_to_maybe_uv_error(r) {\n                 Some(err) => Err(uv_error_to_io_error(err)),\n                 None => Ok(())\n             }\n@@ -851,7 +962,7 @@ impl RtioTcpStream for UvTcpStream {\n                 uvll::tcp_keepalive(self_.watcher.native_handle(), 0 as c_int, 0 as c_uint)\n             };\n \n-            match status_to_maybe_uv_error(self_.watcher, r) {\n+            match status_to_maybe_uv_error(r) {\n                 Some(err) => Err(uv_error_to_io_error(err)),\n                 None => Ok(())\n             }\n@@ -963,7 +1074,7 @@ impl RtioUdpSocket for UvUdpSocket {\n                 }\n             };\n \n-            match status_to_maybe_uv_error(self_.watcher, r) {\n+            match status_to_maybe_uv_error(r) {\n                 Some(err) => Err(uv_error_to_io_error(err)),\n                 None => Ok(())\n             }\n@@ -979,7 +1090,7 @@ impl RtioUdpSocket for UvUdpSocket {\n                 }\n             };\n \n-            match status_to_maybe_uv_error(self_.watcher, r) {\n+            match status_to_maybe_uv_error(r) {\n                 Some(err) => Err(uv_error_to_io_error(err)),\n                 None => Ok(())\n             }\n@@ -993,7 +1104,7 @@ impl RtioUdpSocket for UvUdpSocket {\n                 uvll::udp_set_multicast_loop(self_.watcher.native_handle(), 1 as c_int)\n             };\n \n-            match status_to_maybe_uv_error(self_.watcher, r) {\n+            match status_to_maybe_uv_error(r) {\n                 Some(err) => Err(uv_error_to_io_error(err)),\n                 None => Ok(())\n             }\n@@ -1007,7 +1118,7 @@ impl RtioUdpSocket for UvUdpSocket {\n                 uvll::udp_set_multicast_loop(self_.watcher.native_handle(), 0 as c_int)\n             };\n \n-            match status_to_maybe_uv_error(self_.watcher, r) {\n+            match status_to_maybe_uv_error(r) {\n                 Some(err) => Err(uv_error_to_io_error(err)),\n                 None => Ok(())\n             }\n@@ -1021,7 +1132,7 @@ impl RtioUdpSocket for UvUdpSocket {\n                 uvll::udp_set_multicast_ttl(self_.watcher.native_handle(), ttl as c_int)\n             };\n \n-            match status_to_maybe_uv_error(self_.watcher, r) {\n+            match status_to_maybe_uv_error(r) {\n                 Some(err) => Err(uv_error_to_io_error(err)),\n                 None => Ok(())\n             }\n@@ -1035,7 +1146,7 @@ impl RtioUdpSocket for UvUdpSocket {\n                 uvll::udp_set_ttl(self_.watcher.native_handle(), ttl as c_int)\n             };\n \n-            match status_to_maybe_uv_error(self_.watcher, r) {\n+            match status_to_maybe_uv_error(r) {\n                 Some(err) => Err(uv_error_to_io_error(err)),\n                 None => Ok(())\n             }\n@@ -1049,7 +1160,7 @@ impl RtioUdpSocket for UvUdpSocket {\n                 uvll::udp_set_broadcast(self_.watcher.native_handle(), 1 as c_int)\n             };\n \n-            match status_to_maybe_uv_error(self_.watcher, r) {\n+            match status_to_maybe_uv_error(r) {\n                 Some(err) => Err(uv_error_to_io_error(err)),\n                 None => Ok(())\n             }\n@@ -1063,7 +1174,7 @@ impl RtioUdpSocket for UvUdpSocket {\n                 uvll::udp_set_broadcast(self_.watcher.native_handle(), 0 as c_int)\n             };\n \n-            match status_to_maybe_uv_error(self_.watcher, r) {\n+            match status_to_maybe_uv_error(r) {\n                 Some(err) => Err(uv_error_to_io_error(err)),\n                 None => Ok(())\n             }\n@@ -1250,6 +1361,89 @@ impl RtioFileStream for UvFileStream {\n     }\n }\n \n+pub struct UvProcess {\n+    process: process::Process,\n+\n+    // Sadly, this structure must be created before we return it, so in that\n+    // brief interim the `home` is None.\n+    home: Option<SchedHandle>,\n+\n+    // All None until the process exits (exit_error may stay None)\n+    priv exit_status: Option<int>,\n+    priv term_signal: Option<int>,\n+    priv exit_error: Option<UvError>,\n+\n+    // Used to store which task to wake up from the exit_cb\n+    priv descheduled: Option<BlockedTask>,\n+}\n+\n+impl HomingIO for UvProcess {\n+    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { self.home.get_mut_ref() }\n+}\n+\n+impl Drop for UvProcess {\n+    fn drop(&self) {\n+        // FIXME(#4330): should not need a transmute\n+        let this = unsafe { cast::transmute_mut(self) };\n+\n+        let close = |self_: &mut UvProcess| {\n+            let scheduler: ~Scheduler = Local::take();\n+            do scheduler.deschedule_running_task_and_then |_, task| {\n+                let task = Cell::new(task);\n+                do self_.process.close {\n+                    let scheduler: ~Scheduler = Local::take();\n+                    scheduler.resume_blocked_task_immediately(task.take());\n+                }\n+            }\n+        };\n+\n+        // If home is none, then this process never actually successfully\n+        // spawned, so there's no need to switch event loops\n+        if this.home.is_none() {\n+            close(this)\n+        } else {\n+            this.home_for_io(close)\n+        }\n+    }\n+}\n+\n+impl RtioProcess for UvProcess {\n+    fn id(&self) -> pid_t {\n+        self.process.pid()\n+    }\n+\n+    fn kill(&mut self, signal: int) -> Result<(), IoError> {\n+        do self.home_for_io |self_| {\n+            match self_.process.kill(signal) {\n+                Ok(()) => Ok(()),\n+                Err(uverr) => Err(uv_error_to_io_error(uverr))\n+            }\n+        }\n+    }\n+\n+    fn wait(&mut self) -> int {\n+        // Make sure (on the home scheduler) that we have an exit status listed\n+        do self.home_for_io |self_| {\n+            match self_.exit_status {\n+                Some(*) => {}\n+                None => {\n+                    // If there's no exit code previously listed, then the\n+                    // process's exit callback has yet to be invoked. We just\n+                    // need to deschedule ourselves and wait to be reawoken.\n+                    let scheduler: ~Scheduler = Local::take();\n+                    do scheduler.deschedule_running_task_and_then |_, task| {\n+                        assert!(self_.descheduled.is_none());\n+                        self_.descheduled = Some(task);\n+                    }\n+                    assert!(self_.exit_status.is_some());\n+                }\n+            }\n+        }\n+\n+        self.exit_status.unwrap()\n+    }\n+}\n+\n #[test]\n fn test_simple_io_no_connect() {\n     do run_in_newsched_task {"}, {"sha": "24e070ca239d1bfbc855dfb799fae2c08dffabaa", "filename": "src/libstd/rt/uv/uvll.rs", "status": "modified", "additions": 122, "deletions": 40, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/b8d1fa399402c71331aefd634d710004e00b73a6/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8d1fa399402c71331aefd634d710004e00b73a6/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs?ref=b8d1fa399402c71331aefd634d710004e00b73a6", "patch": "@@ -37,28 +37,74 @@ use libc::{malloc, free};\n use libc;\n use prelude::*;\n use ptr;\n-use str;\n use vec;\n \n-pub static UNKNOWN: c_int = -1;\n+pub use self::errors::*;\n+\n pub static OK: c_int = 0;\n-pub static EOF: c_int = 1;\n-pub static EADDRINFO: c_int = 2;\n-pub static EACCES: c_int = 3;\n-pub static ECONNREFUSED: c_int = 12;\n-pub static ECONNRESET: c_int = 13;\n-pub static EPIPE: c_int = 36;\n+pub static EOF: c_int = -4095;\n+pub static UNKNOWN: c_int = -4094;\n+\n+// uv-errno.h redefines error codes for windows, but not for unix...\n+\n+#[cfg(windows)]\n+pub mod errors {\n+    use libc::c_int;\n \n-pub struct uv_err_t {\n-    code: c_int,\n-    sys_errno_: c_int\n+    pub static EACCES: c_int = -4093;\n+    pub static ECONNREFUSED: c_int = -4079;\n+    pub static ECONNRESET: c_int = -4078;\n+    pub static EPIPE: c_int = -4048;\n }\n+#[cfg(not(windows))]\n+pub mod errors {\n+    use libc;\n+    use libc::c_int;\n+\n+    pub static EACCES: c_int = -libc::EACCES;\n+    pub static ECONNREFUSED: c_int = -libc::ECONNREFUSED;\n+    pub static ECONNRESET: c_int = -libc::ECONNRESET;\n+    pub static EPIPE: c_int = -libc::EPIPE;\n+}\n+\n+pub static PROCESS_SETUID: c_int = 1 << 0;\n+pub static PROCESS_SETGID: c_int = 1 << 1;\n+pub static PROCESS_WINDOWS_VERBATIM_ARGUMENTS: c_int = 1 << 2;\n+pub static PROCESS_DETACHED: c_int = 1 << 3;\n+pub static PROCESS_WINDOWS_HIDE: c_int = 1 << 4;\n+\n+pub static STDIO_IGNORE: c_int = 0x00;\n+pub static STDIO_CREATE_PIPE: c_int = 0x01;\n+pub static STDIO_INHERIT_FD: c_int = 0x02;\n+pub static STDIO_INHERIT_STREAM: c_int = 0x04;\n+pub static STDIO_READABLE_PIPE: c_int = 0x10;\n+pub static STDIO_WRITABLE_PIPE: c_int = 0x20;\n \n pub struct uv_buf_t {\n     base: *u8,\n     len: libc::size_t,\n }\n \n+pub struct uv_process_options_t {\n+    exit_cb: uv_exit_cb,\n+    file: *libc::c_char,\n+    args: **libc::c_char,\n+    env: **libc::c_char,\n+    cwd: *libc::c_char,\n+    flags: libc::c_uint,\n+    stdio_count: libc::c_int,\n+    stdio: *uv_stdio_container_t,\n+    uid: uv_uid_t,\n+    gid: uv_gid_t,\n+}\n+\n+// These fields are private because they must be interfaced with through the\n+// functions below.\n+pub struct uv_stdio_container_t {\n+    priv flags: libc::c_int,\n+    priv stream: *uv_stream_t,\n+}\n+\n pub type uv_handle_t = c_void;\n pub type uv_loop_t = c_void;\n pub type uv_idle_t = c_void;\n@@ -72,6 +118,8 @@ pub type uv_timer_t = c_void;\n pub type uv_stream_t = c_void;\n pub type uv_fs_t = c_void;\n pub type uv_udp_send_t = c_void;\n+pub type uv_process_t = c_void;\n+pub type uv_pipe_t = c_void;\n \n #[cfg(stage0)]\n pub type uv_idle_cb = *u8;\n@@ -97,6 +145,8 @@ pub type uv_connection_cb = *u8;\n pub type uv_timer_cb = *u8;\n #[cfg(stage0)]\n pub type uv_write_cb = *u8;\n+#[cfg(stage0)]\n+pub type uv_exit_cb = *u8;\n \n #[cfg(not(stage0))]\n pub type uv_idle_cb = extern \"C\" fn(handle: *uv_idle_t,\n@@ -137,12 +187,21 @@ pub type uv_timer_cb = extern \"C\" fn(handle: *uv_timer_t,\n #[cfg(not(stage0))]\n pub type uv_write_cb = extern \"C\" fn(handle: *uv_write_t,\n                                      status: c_int);\n+#[cfg(not(stage0))]\n+pub type uv_exit_cb = extern \"C\" fn(handle: *uv_process_t,\n+                                    exit_status: c_int,\n+                                    term_signal: c_int);\n \n pub type sockaddr = c_void;\n pub type sockaddr_in = c_void;\n pub type sockaddr_in6 = c_void;\n pub type sockaddr_storage = c_void;\n \n+#[cfg(unix)] pub type uv_uid_t = libc::types::os::arch::posix88::uid_t;\n+#[cfg(unix)] pub type uv_gid_t = libc::types::os::arch::posix88::gid_t;\n+#[cfg(windows)] pub type uv_uid_t = libc::c_uchar;\n+#[cfg(windows)] pub type uv_gid_t = libc::c_uchar;\n+\n #[deriving(Eq)]\n pub enum uv_handle_type {\n     UV_UNKNOWN_HANDLE,\n@@ -487,20 +546,12 @@ pub unsafe fn read_stop(stream: *uv_stream_t) -> c_int {\n     return rust_uv_read_stop(stream as *c_void);\n }\n \n-pub unsafe fn last_error(loop_handle: *c_void) -> uv_err_t {\n+pub unsafe fn strerror(err: c_int) -> *c_char {\n     #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_last_error(loop_handle);\n-}\n-\n-pub unsafe fn strerror(err: *uv_err_t) -> *c_char {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n     return rust_uv_strerror(err);\n }\n-pub unsafe fn err_name(err: *uv_err_t) -> *c_char {\n+pub unsafe fn err_name(err: c_int) -> *c_char {\n     #[fixed_stack_segment]; #[inline(never)];\n-\n     return rust_uv_err_name(err);\n }\n \n@@ -654,6 +705,45 @@ pub unsafe fn fs_req_cleanup(req: *uv_fs_t) {\n     rust_uv_fs_req_cleanup(req);\n }\n \n+pub unsafe fn spawn(loop_ptr: *c_void, result: *uv_process_t,\n+                    options: uv_process_options_t) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    return rust_uv_spawn(loop_ptr, result, options);\n+}\n+\n+pub unsafe fn process_kill(p: *uv_process_t, signum: c_int) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    return rust_uv_process_kill(p, signum);\n+}\n+\n+pub unsafe fn process_pid(p: *uv_process_t) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    return rust_uv_process_pid(p);\n+}\n+\n+pub unsafe fn set_stdio_container_flags(c: *uv_stdio_container_t,\n+                                        flags: libc::c_int) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    rust_set_stdio_container_flags(c, flags);\n+}\n+\n+pub unsafe fn set_stdio_container_fd(c: *uv_stdio_container_t,\n+                                     fd: libc::c_int) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    rust_set_stdio_container_fd(c, fd);\n+}\n+\n+pub unsafe fn set_stdio_container_stream(c: *uv_stdio_container_t,\n+                                         stream: *uv_stream_t) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    rust_set_stdio_container_stream(c, stream);\n+}\n+\n+pub unsafe fn pipe_init(loop_ptr: *c_void, p: *uv_pipe_t, ipc: c_int) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    rust_uv_pipe_init(loop_ptr, p, ipc)\n+}\n+\n // data access helpers\n pub unsafe fn get_result_from_fs_req(req: *uv_fs_t) -> c_int {\n     #[fixed_stack_segment]; #[inline(never)];\n@@ -720,22 +810,6 @@ pub unsafe fn get_len_from_buf(buf: uv_buf_t) -> size_t {\n \n     return rust_uv_get_len_from_buf(buf);\n }\n-pub unsafe fn get_last_err_info(uv_loop: *c_void) -> ~str {\n-    let err = last_error(uv_loop);\n-    let err_ptr = ptr::to_unsafe_ptr(&err);\n-    let err_name = str::raw::from_c_str(err_name(err_ptr));\n-    let err_msg = str::raw::from_c_str(strerror(err_ptr));\n-    return fmt!(\"LIBUV ERROR: name: %s msg: %s\",\n-                    err_name, err_msg);\n-}\n-\n-pub unsafe fn get_last_err_data(uv_loop: *c_void) -> uv_err_data {\n-    let err = last_error(uv_loop);\n-    let err_ptr = ptr::to_unsafe_ptr(&err);\n-    let err_name = str::raw::from_c_str(err_name(err_ptr));\n-    let err_msg = str::raw::from_c_str(strerror(err_ptr));\n-    uv_err_data { err_name: err_name, err_msg: err_msg }\n-}\n \n pub struct uv_err_data {\n     err_name: ~str,\n@@ -768,9 +842,8 @@ extern {\n                           cb: uv_async_cb) -> c_int;\n     fn rust_uv_tcp_init(loop_handle: *c_void, handle_ptr: *uv_tcp_t) -> c_int;\n     fn rust_uv_buf_init(out_buf: *uv_buf_t, base: *u8, len: size_t);\n-    fn rust_uv_last_error(loop_handle: *c_void) -> uv_err_t;\n-    fn rust_uv_strerror(err: *uv_err_t) -> *c_char;\n-    fn rust_uv_err_name(err: *uv_err_t) -> *c_char;\n+    fn rust_uv_strerror(err: c_int) -> *c_char;\n+    fn rust_uv_err_name(err: c_int) -> *c_char;\n     fn rust_uv_ip4_addrp(ip: *u8, port: c_int) -> *sockaddr_in;\n     fn rust_uv_ip6_addrp(ip: *u8, port: c_int) -> *sockaddr_in6;\n     fn rust_uv_free_ip4_addr(addr: *sockaddr_in);\n@@ -856,4 +929,13 @@ extern {\n     fn rust_uv_set_data_for_req(req: *c_void, data: *c_void);\n     fn rust_uv_get_base_from_buf(buf: uv_buf_t) -> *u8;\n     fn rust_uv_get_len_from_buf(buf: uv_buf_t) -> size_t;\n+    fn rust_uv_spawn(loop_ptr: *c_void, outptr: *uv_process_t,\n+                     options: uv_process_options_t) -> c_int;\n+    fn rust_uv_process_kill(p: *uv_process_t, signum: c_int) -> c_int;\n+    fn rust_uv_process_pid(p: *uv_process_t) -> c_int;\n+    fn rust_set_stdio_container_flags(c: *uv_stdio_container_t, flags: c_int);\n+    fn rust_set_stdio_container_fd(c: *uv_stdio_container_t, fd: c_int);\n+    fn rust_set_stdio_container_stream(c: *uv_stdio_container_t,\n+                                       stream: *uv_stream_t);\n+    fn rust_uv_pipe_init(loop_ptr: *c_void, p: *uv_pipe_t, ipc: c_int) -> c_int;\n }"}, {"sha": "b91aac2224401a532dcd9f54afda9ceb7f8a144f", "filename": "src/libstd/run.rs", "status": "modified", "additions": 208, "deletions": 891, "changes": 1099, "blob_url": "https://github.com/rust-lang/rust/blob/b8d1fa399402c71331aefd634d710004e00b73a6/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8d1fa399402c71331aefd634d710004e00b73a6/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=b8d1fa399402c71331aefd634d710004e00b73a6", "patch": "@@ -10,22 +10,21 @@\n \n //! Process spawning.\n \n-#[allow(missing_doc)];\n-\n-use c_str::ToCStr;\n use cast;\n-use clone::Clone;\n+use cell::Cell;\n use comm::{stream, SharedChan, GenericChan, GenericPort};\n-use io;\n-use libc::{pid_t, c_void, c_int};\n+#[cfg(not(windows))]\n use libc;\n-use option::{Some, None};\n-use os;\n+use libc::{pid_t, c_int};\n use prelude::*;\n-use ptr;\n use task;\n use vec::ImmutableVector;\n \n+use rt::io;\n+use rt::local::Local;\n+use rt::rtio::{IoFactoryObject, RtioProcessObject, RtioProcess, IoFactory};\n+use rt::uv::process;\n+\n /**\n  * A value representing a child process.\n  *\n@@ -34,28 +33,23 @@ use vec::ImmutableVector;\n  * for the process to terminate.\n  */\n pub struct Process {\n-\n     /// The unique id of the process (this should never be negative).\n     priv pid: pid_t,\n \n-    /**\n-     * A handle to the process - on unix this will always be NULL, but on\n-     * windows it will be a HANDLE to the process, which will prevent the\n-     * pid being re-used until the handle is closed.\n-     */\n-    priv handle: *(),\n+    /// The internal handle to the underlying libuv process.\n+    priv handle: ~RtioProcessObject,\n \n-    /// Some(fd), or None when stdin is being redirected from a fd not created by Process::new.\n-    priv input: Option<c_int>,\n+    /// Some(fd), or None when stdin is being redirected from a fd not created\n+    /// by Process::new.\n+    priv input: Option<~io::Writer>,\n \n-    /// Some(file), or None when stdout is being redirected to a fd not created by Process::new.\n-    priv output: Option<*libc::FILE>,\n+    /// Some(file), or None when stdout is being redirected to a fd not created\n+    /// by Process::new.\n+    priv output: Option<~io::Reader>,\n \n-    /// Some(file), or None when stderr is being redirected to a fd not created by Process::new.\n-    priv error: Option<*libc::FILE>,\n-\n-    /// None until finish() is called.\n-    priv exit_code: Option<int>,\n+    /// Some(file), or None when stderr is being redirected to a fd not created\n+    /// by Process::new.\n+    priv error: Option<~io::Reader>,\n }\n \n /// Options that can be given when starting a Process.\n@@ -93,26 +87,27 @@ pub struct ProcessOptions<'self> {\n      * If this is None then a new pipe will be created for the new program's\n      * output and Process.output() will provide a Reader to read from this pipe.\n      *\n-     * If this is Some(file-descriptor) then the new process will write its output\n-     * to the given file descriptor, Process.output_redirected() will return\n-     * true, and Process.output() will fail.\n+     * If this is Some(file-descriptor) then the new process will write its\n+     * output to the given file descriptor, Process.output_redirected() will\n+     * return true, and Process.output() will fail.\n      */\n     out_fd: Option<c_int>,\n \n     /**\n-     * If this is None then a new pipe will be created for the new program's\n-     * error stream and Process.error() will provide a Reader to read from this pipe.\n+     * If this is None then a new pipe will be created for the new progam's\n+     * error stream and Process.error() will provide a Reader to read from this\n+     * pipe.\n      *\n-     * If this is Some(file-descriptor) then the new process will write its error output\n-     * to the given file descriptor, Process.error_redirected() will return true, and\n-     * and Process.error() will fail.\n+     * If this is Some(file-descriptor) then the new process will write its\n+     * error output to the given file descriptor, Process.error_redirected()\n+     * will return true, and and Process.error() will fail.\n      */\n     err_fd: Option<c_int>,\n }\n \n-impl <'self> ProcessOptions<'self> {\n+impl<'self> ProcessOptions<'self> {\n     /// Return a ProcessOptions that has None in every field.\n-    pub fn new<'a>() -> ProcessOptions<'a> {\n+    pub fn new() -> ProcessOptions {\n         ProcessOptions {\n             env: None,\n             dir: None,\n@@ -125,7 +120,6 @@ impl <'self> ProcessOptions<'self> {\n \n /// The output of a finished process.\n pub struct ProcessOutput {\n-\n     /// The status (exit code) of the process.\n     status: int,\n \n@@ -148,223 +142,159 @@ impl Process {\n      *             the working directory and the standard IO streams.\n      */\n     pub fn new(prog: &str, args: &[~str],\n-               options: ProcessOptions)\n-               -> Process {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n-        let (in_pipe, in_fd) = match options.in_fd {\n+               options: ProcessOptions) -> Option<Process> {\n+        // First, translate all the stdio options into their libuv equivalents\n+        let (uv_stdin, stdin) = match options.in_fd {\n+            Some(fd) => (process::InheritFd(fd), None),\n             None => {\n-                let pipe = os::pipe();\n-                (Some(pipe), pipe.input)\n-            },\n-            Some(fd) => (None, fd)\n+                let p = io::pipe::PipeStream::new().expect(\"need stdin pipe\");\n+                (process::CreatePipe(p.uv_pipe(), true, false),\n+                 Some(~p as ~io::Writer))\n+            }\n         };\n-        let (out_pipe, out_fd) = match options.out_fd {\n+        let (uv_stdout, stdout) = match options.out_fd {\n+            Some(fd) => (process::InheritFd(fd), None),\n             None => {\n-                let pipe = os::pipe();\n-                (Some(pipe), pipe.out)\n-            },\n-            Some(fd) => (None, fd)\n+                let p = io::pipe::PipeStream::new().expect(\"need stdout pipe\");\n+                (process::CreatePipe(p.uv_pipe(), false, true),\n+                 Some(~p as ~io::Reader))\n+            }\n         };\n-        let (err_pipe, err_fd) = match options.err_fd {\n+        let (uv_stderr, stderr) = match options.err_fd {\n+            Some(fd) => (process::InheritFd(fd), None),\n             None => {\n-                let pipe = os::pipe();\n-                (Some(pipe), pipe.out)\n-            },\n-            Some(fd) => (None, fd)\n+                let p = io::pipe::PipeStream::new().expect(\"need stderr pipe\");\n+                (process::CreatePipe(p.uv_pipe(), false, true),\n+                 Some(~p as ~io::Reader))\n+            }\n         };\n \n-        let res = spawn_process_os(prog, args, options.env.clone(), options.dir,\n-                                   in_fd, out_fd, err_fd);\n+        // Next, massage our options into the libuv options\n+        let dir = options.dir.map(|d| d.to_str());\n+        let dir = dir.map(|d| d.as_slice());\n+        let config = process::Config {\n+            program: prog,\n+            args: args,\n+            env: options.env.map(|e| e.as_slice()),\n+            cwd: dir,\n+            io: [uv_stdin, uv_stdout, uv_stderr],\n+        };\n \n+        // Finally, actually spawn the process\n         unsafe {\n-            for pipe in in_pipe.iter() { libc::close(pipe.input); }\n-            for pipe in out_pipe.iter() { libc::close(pipe.out); }\n-            for pipe in err_pipe.iter() { libc::close(pipe.out); }\n-        }\n-\n-        Process {\n-            pid: res.pid,\n-            handle: res.handle,\n-            input: in_pipe.map(|pipe| pipe.out),\n-            output: out_pipe.map(|pipe| os::fdopen(pipe.input)),\n-            error: err_pipe.map(|pipe| os::fdopen(pipe.input)),\n-            exit_code: None,\n+            let io: *mut IoFactoryObject = Local::unsafe_borrow();\n+            match (*io).spawn(&config) {\n+                Ok(handle) => {\n+                    Some(Process {\n+                        pid: handle.id(),\n+                        handle: handle,\n+                        input: stdin,\n+                        output: stdout,\n+                        error: stderr,\n+                    })\n+                }\n+                Err(*) => { None }\n+            }\n         }\n     }\n \n     /// Returns the unique id of the process\n     pub fn get_id(&self) -> pid_t { self.pid }\n \n-    fn input_fd(&mut self) -> c_int {\n-        match self.input {\n-            Some(fd) => fd,\n-            None => fail!(\"This Process's stdin was redirected to an \\\n-                           existing file descriptor.\")\n-        }\n-    }\n-\n-    fn output_file(&mut self) -> *libc::FILE {\n-        match self.output {\n-            Some(file) => file,\n-            None => fail!(\"This Process's stdout was redirected to an \\\n-                           existing file descriptor.\")\n-        }\n-    }\n-\n-    fn error_file(&mut self) -> *libc::FILE {\n-        match self.error {\n-            Some(file) => file,\n-            None => fail!(\"This Process's stderr was redirected to an \\\n-                           existing file descriptor.\")\n-        }\n-    }\n-\n     /**\n-     * Returns whether this process is reading its stdin from an existing file\n-     * descriptor rather than a pipe that was created specifically for this\n-     * process.\n+     * Returns a rt::io::Writer that can be used to write to this Process's\n+     * stdin.\n      *\n-     * If this method returns true then self.input() will fail.\n+     * Fails if this Process's stdin was redirected to an existing file\n+     * descriptor.\n      */\n-    pub fn input_redirected(&self) -> bool {\n-        self.input.is_none()\n+    pub fn input<'a>(&'a mut self) -> &'a mut io::Writer {\n+        let ret: &mut io::Writer = *self.input.get_mut_ref();\n+        return ret;\n     }\n \n     /**\n-     * Returns whether this process is writing its stdout to an existing file\n-     * descriptor rather than a pipe that was created specifically for this\n-     * process.\n+     * Returns a rt::io::Reader that can be used to read from this Process's\n+     * stdout.\n      *\n-     * If this method returns true then self.output() will fail.\n+     * Fails if this Process's stdout was redirected to an existing file\n+     * descriptor.\n      */\n-    pub fn output_redirected(&self) -> bool {\n-        self.output.is_none()\n+    pub fn output<'a>(&'a mut self) -> &'a mut io::Reader {\n+        let ret: &mut io::Reader = *self.output.get_mut_ref();\n+        return ret;\n     }\n \n     /**\n-     * Returns whether this process is writing its stderr to an existing file\n-     * descriptor rather than a pipe that was created specifically for this\n-     * process.\n+     * Returns a rt::io::Reader that can be used to read from this Process's\n+     * stderr.\n      *\n-     * If this method returns true then self.error() will fail.\n+     * Fails if this Process's stderr was redirected to an existing file\n+     * descriptor.\n      */\n-    pub fn error_redirected(&self) -> bool {\n-        self.error.is_none()\n+    pub fn error<'a>(&'a mut self) -> &'a mut io::Reader {\n+        let ret: &mut io::Reader = *self.error.get_mut_ref();\n+        return ret;\n     }\n \n     /**\n-     * Returns an io::Writer that can be used to write to this Process's stdin.\n+     * Closes the handle to stdin, waits for the child process to terminate, and\n+     * returns the exit code.\n      *\n-     * Fails if this Process's stdin was redirected to an existing file descriptor.\n+     * If the child has already been finished then the exit code is returned.\n      */\n-    pub fn input(&mut self) -> @io::Writer {\n-        // FIXME: the Writer can still be used after self is destroyed: #2625\n-       io::fd_writer(self.input_fd(), false)\n-    }\n+    pub fn finish(&mut self) -> int {\n+        // We're not going to be giving any more input, so close the input by\n+        // destroying it. Also, if the output is desired, then\n+        // finish_with_output is called so we discard all the outputs here. Note\n+        // that the process may not terminate if we don't destroy stdio because\n+        // it'll be waiting in a write which we'll just never read.\n+        self.input.take();\n+        self.output.take();\n+        self.error.take();\n \n-    /**\n-     * Returns an io::Reader that can be used to read from this Process's stdout.\n-     *\n-     * Fails if this Process's stdout was redirected to an existing file descriptor.\n-     */\n-    pub fn output(&mut self) -> @io::Reader {\n-        // FIXME: the Reader can still be used after self is destroyed: #2625\n-        io::FILE_reader(self.output_file(), false)\n+        self.handle.wait()\n     }\n \n     /**\n-     * Returns an io::Reader that can be used to read from this Process's stderr.\n+     * Closes the handle to stdin, waits for the child process to terminate,\n+     * and reads and returns all remaining output of stdout and stderr, along\n+     * with the exit code.\n      *\n-     * Fails if this Process's stderr was redirected to an existing file descriptor.\n-     */\n-    pub fn error(&mut self) -> @io::Reader {\n-        // FIXME: the Reader can still be used after self is destroyed: #2625\n-        io::FILE_reader(self.error_file(), false)\n-    }\n-\n-    /**\n-     * Closes the handle to the child process's stdin.\n+     * If the child has already been finished then the exit code and any\n+     * remaining unread output of stdout and stderr will be returned.\n      *\n-     * If this process is reading its stdin from an existing file descriptor, then this\n-     * method does nothing.\n+     * This method will fail if the child process's stdout or stderr streams\n+     * were redirected to existing file descriptors, or if this method has\n+     * already been called.\n      */\n-    pub fn close_input(&mut self) {\n-        #[fixed_stack_segment]; #[inline(never)];\n-        match self.input {\n-            Some(-1) | None => (),\n-            Some(fd) => {\n-                unsafe {\n-                    libc::close(fd);\n+    pub fn finish_with_output(&mut self) -> ProcessOutput {\n+        // This should probably be a helper method in rt::io\n+        fn read_everything(input: &mut io::Reader) -> ~[u8] {\n+            let mut result = ~[];\n+            let mut buf = [0u8, ..1024];\n+            loop {\n+                match input.read(buf) {\n+                    Some(i) => { result = result + buf.slice_to(i) }\n+                    None => break\n                 }\n-                self.input = Some(-1);\n             }\n+            return result;\n         }\n-    }\n-\n-    fn close_outputs(&mut self) {\n-        #[fixed_stack_segment]; #[inline(never)];\n-        fclose_and_null(&mut self.output);\n-        fclose_and_null(&mut self.error);\n-\n-        fn fclose_and_null(f_opt: &mut Option<*libc::FILE>) {\n-            #[allow(cstack)]; // fixed_stack_segment declared on enclosing fn\n-            match *f_opt {\n-                Some(f) if !f.is_null() => {\n-                    unsafe {\n-                        libc::fclose(f);\n-                        *f_opt = Some(0 as *libc::FILE);\n-                    }\n-                },\n-                _ => ()\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Closes the handle to stdin, waits for the child process to terminate,\n-     * and returns the exit code.\n-     *\n-     * If the child has already been finished then the exit code is returned.\n-     */\n-    pub fn finish(&mut self) -> int {\n-        for &code in self.exit_code.iter() {\n-            return code;\n-        }\n-        self.close_input();\n-        let code = waitpid(self.pid);\n-        self.exit_code = Some(code);\n-        return code;\n-    }\n \n-    /**\n-     * Closes the handle to stdin, waits for the child process to terminate, and reads\n-     * and returns all remaining output of stdout and stderr, along with the exit code.\n-     *\n-     * If the child has already been finished then the exit code and any remaining\n-     * unread output of stdout and stderr will be returned.\n-     *\n-     * This method will fail if the child process's stdout or stderr streams were\n-     * redirected to existing file descriptors.\n-     */\n-    pub fn finish_with_output(&mut self) -> ProcessOutput {\n-        let output_file = self.output_file();\n-        let error_file = self.error_file();\n-\n-        // Spawn two entire schedulers to read both stdout and sterr\n-        // in parallel so we don't deadlock while blocking on one\n-        // or the other. FIXME (#2625): Surely there's a much more\n-        // clever way to do this.\n         let (p, ch) = stream();\n         let ch = SharedChan::new(ch);\n         let ch_clone = ch.clone();\n-        do task::spawn_sched(task::SingleThreaded) {\n-            let errput = io::FILE_reader(error_file, false);\n-            ch.send((2, errput.read_whole_stream()));\n+\n+        let stderr = Cell::new(self.error.take().unwrap());\n+        do task::spawn {\n+            let output = read_everything(stderr.take());\n+            ch.send((2, output));\n         }\n-        do task::spawn_sched(task::SingleThreaded) {\n-            let output = io::FILE_reader(output_file, false);\n-            ch_clone.send((1, output.read_whole_stream()));\n+        let stdout = Cell::new(self.output.take().unwrap());\n+        do task::spawn {\n+            let output = read_everything(stdout.take());\n+            ch_clone.send((1, output));\n         }\n \n         let status = self.finish();\n@@ -382,48 +312,19 @@ impl Process {\n                               error: errs};\n     }\n \n-    fn destroy_internal(&mut self, force: bool) {\n-        // if the process has finished, and therefore had waitpid called,\n-        // and we kill it, then on unix we might ending up killing a\n-        // newer process that happens to have the same (re-used) id\n-        if self.exit_code.is_none() {\n-            killpid(self.pid, force);\n-            self.finish();\n-        }\n-\n-        #[cfg(windows)]\n-        fn killpid(pid: pid_t, _force: bool) {\n-            #[fixed_stack_segment]; #[inline(never)];\n-            unsafe {\n-                libc::funcs::extra::kernel32::TerminateProcess(\n-                    cast::transmute(pid), 1);\n-            }\n-        }\n-\n-        #[cfg(unix)]\n-        fn killpid(pid: pid_t, force: bool) {\n-            #[fixed_stack_segment]; #[inline(never)];\n-\n-            let signal = if force {\n-                libc::consts::os::posix88::SIGKILL\n-            } else {\n-                libc::consts::os::posix88::SIGTERM\n-            };\n-\n-            unsafe {\n-                libc::funcs::posix88::signal::kill(pid, signal as c_int);\n-            }\n-        }\n-    }\n-\n     /**\n      * Terminates the process, giving it a chance to clean itself up if\n      * this is supported by the operating system.\n      *\n      * On Posix OSs SIGTERM will be sent to the process. On Win32\n      * TerminateProcess(..) will be called.\n      */\n-    pub fn destroy(&mut self) { self.destroy_internal(false); }\n+    pub fn destroy(&mut self) {\n+        #[cfg(windows)]      fn sigterm() -> int { 15 }\n+        #[cfg(not(windows))] fn sigterm() -> int { libc::SIGTERM as int }\n+        self.handle.kill(sigterm());\n+        self.finish();\n+    }\n \n     /**\n      * Terminates the process as soon as possible without giving it a\n@@ -432,378 +333,22 @@ impl Process {\n      * On Posix OSs SIGKILL will be sent to the process. On Win32\n      * TerminateProcess(..) will be called.\n      */\n-    pub fn force_destroy(&mut self) { self.destroy_internal(true); }\n+    pub fn force_destroy(&mut self) {\n+        #[cfg(windows)]      fn sigkill() -> int { 9 }\n+        #[cfg(not(windows))] fn sigkill() -> int { libc::SIGKILL as int }\n+        self.handle.kill(sigkill());\n+        self.finish();\n+    }\n }\n \n impl Drop for Process {\n     fn drop(&self) {\n         // FIXME(#4330) Need self by value to get mutability.\n         let mut_self: &mut Process = unsafe { cast::transmute(self) };\n-\n         mut_self.finish();\n-        mut_self.close_outputs();\n-        free_handle(self.handle);\n-    }\n-}\n-\n-struct SpawnProcessResult {\n-    pid: pid_t,\n-    handle: *(),\n-}\n-\n-#[cfg(windows)]\n-fn spawn_process_os(prog: &str, args: &[~str],\n-                    env: Option<~[(~str, ~str)]>,\n-                    dir: Option<&Path>,\n-                    in_fd: c_int, out_fd: c_int, err_fd: c_int) -> SpawnProcessResult {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    use libc::types::os::arch::extra::{DWORD, HANDLE, STARTUPINFO};\n-    use libc::consts::os::extra::{\n-        TRUE, FALSE,\n-        STARTF_USESTDHANDLES,\n-        INVALID_HANDLE_VALUE,\n-        DUPLICATE_SAME_ACCESS\n-    };\n-    use libc::funcs::extra::kernel32::{\n-        GetCurrentProcess,\n-        DuplicateHandle,\n-        CloseHandle,\n-        CreateProcessA\n-    };\n-    use libc::funcs::extra::msvcrt::get_osfhandle;\n-\n-    use sys;\n-\n-    unsafe {\n-\n-        let mut si = zeroed_startupinfo();\n-        si.cb = sys::size_of::<STARTUPINFO>() as DWORD;\n-        si.dwFlags = STARTF_USESTDHANDLES;\n-\n-        let cur_proc = GetCurrentProcess();\n-\n-        let orig_std_in = get_osfhandle(in_fd) as HANDLE;\n-        if orig_std_in == INVALID_HANDLE_VALUE as HANDLE {\n-            fail!(\"failure in get_osfhandle: %s\", os::last_os_error());\n-        }\n-        if DuplicateHandle(cur_proc, orig_std_in, cur_proc, &mut si.hStdInput,\n-                           0, TRUE, DUPLICATE_SAME_ACCESS) == FALSE {\n-            fail!(\"failure in DuplicateHandle: %s\", os::last_os_error());\n-        }\n-\n-        let orig_std_out = get_osfhandle(out_fd) as HANDLE;\n-        if orig_std_out == INVALID_HANDLE_VALUE as HANDLE {\n-            fail!(\"failure in get_osfhandle: %s\", os::last_os_error());\n-        }\n-        if DuplicateHandle(cur_proc, orig_std_out, cur_proc, &mut si.hStdOutput,\n-                           0, TRUE, DUPLICATE_SAME_ACCESS) == FALSE {\n-            fail!(\"failure in DuplicateHandle: %s\", os::last_os_error());\n-        }\n-\n-        let orig_std_err = get_osfhandle(err_fd) as HANDLE;\n-        if orig_std_err == INVALID_HANDLE_VALUE as HANDLE {\n-            fail!(\"failure in get_osfhandle: %s\", os::last_os_error());\n-        }\n-        if DuplicateHandle(cur_proc, orig_std_err, cur_proc, &mut si.hStdError,\n-                           0, TRUE, DUPLICATE_SAME_ACCESS) == FALSE {\n-            fail!(\"failure in DuplicateHandle: %s\", os::last_os_error());\n-        }\n-\n-        let cmd = make_command_line(prog, args);\n-        let mut pi = zeroed_process_information();\n-        let mut create_err = None;\n-\n-        do with_envp(env) |envp| {\n-            do with_dirp(dir) |dirp| {\n-                do cmd.with_c_str |cmdp| {\n-                    let created = CreateProcessA(ptr::null(), cast::transmute(cmdp),\n-                                                 ptr::mut_null(), ptr::mut_null(), TRUE,\n-                                                 0, envp, dirp, &mut si, &mut pi);\n-                    if created == FALSE {\n-                        create_err = Some(os::last_os_error());\n-                    }\n-                }\n-            }\n-        }\n-\n-        CloseHandle(si.hStdInput);\n-        CloseHandle(si.hStdOutput);\n-        CloseHandle(si.hStdError);\n-\n-        for msg in create_err.iter() {\n-            fail!(\"failure in CreateProcess: %s\", *msg);\n-        }\n-\n-        // We close the thread handle because we don't care about keeping the thread id valid,\n-        // and we aren't keeping the thread handle around to be able to close it later. We don't\n-        // close the process handle however because we want the process id to stay valid at least\n-        // until the calling code closes the process handle.\n-        CloseHandle(pi.hThread);\n-\n-        SpawnProcessResult {\n-            pid: pi.dwProcessId as pid_t,\n-            handle: pi.hProcess as *()\n-        }\n-    }\n-}\n-\n-#[cfg(windows)]\n-fn zeroed_startupinfo() -> libc::types::os::arch::extra::STARTUPINFO {\n-    libc::types::os::arch::extra::STARTUPINFO {\n-        cb: 0,\n-        lpReserved: ptr::mut_null(),\n-        lpDesktop: ptr::mut_null(),\n-        lpTitle: ptr::mut_null(),\n-        dwX: 0,\n-        dwY: 0,\n-        dwXSize: 0,\n-        dwYSize: 0,\n-        dwXCountChars: 0,\n-        dwYCountCharts: 0,\n-        dwFillAttribute: 0,\n-        dwFlags: 0,\n-        wShowWindow: 0,\n-        cbReserved2: 0,\n-        lpReserved2: ptr::mut_null(),\n-        hStdInput: ptr::mut_null(),\n-        hStdOutput: ptr::mut_null(),\n-        hStdError: ptr::mut_null()\n-    }\n-}\n-\n-#[cfg(windows)]\n-fn zeroed_process_information() -> libc::types::os::arch::extra::PROCESS_INFORMATION {\n-    libc::types::os::arch::extra::PROCESS_INFORMATION {\n-        hProcess: ptr::mut_null(),\n-        hThread: ptr::mut_null(),\n-        dwProcessId: 0,\n-        dwThreadId: 0\n-    }\n-}\n-\n-// FIXME: this is only pub so it can be tested (see issue #4536)\n-#[cfg(windows)]\n-pub fn make_command_line(prog: &str, args: &[~str]) -> ~str {\n-    let mut cmd = ~\"\";\n-    append_arg(&mut cmd, prog);\n-    for arg in args.iter() {\n-        cmd.push_char(' ');\n-        append_arg(&mut cmd, *arg);\n-    }\n-    return cmd;\n-\n-    fn append_arg(cmd: &mut ~str, arg: &str) {\n-        let quote = arg.iter().any(|c| c == ' ' || c == '\\t');\n-        if quote {\n-            cmd.push_char('\"');\n-        }\n-        for i in range(0u, arg.len()) {\n-            append_char_at(cmd, arg, i);\n-        }\n-        if quote {\n-            cmd.push_char('\"');\n-        }\n-    }\n-\n-    fn append_char_at(cmd: &mut ~str, arg: &str, i: uint) {\n-        match arg[i] as char {\n-            '\"' => {\n-                // Escape quotes.\n-                cmd.push_str(\"\\\\\\\"\");\n-            }\n-            '\\\\' => {\n-                if backslash_run_ends_in_quote(arg, i) {\n-                    // Double all backslashes that are in runs before quotes.\n-                    cmd.push_str(\"\\\\\\\\\");\n-                } else {\n-                    // Pass other backslashes through unescaped.\n-                    cmd.push_char('\\\\');\n-                }\n-            }\n-            c => {\n-                cmd.push_char(c);\n-            }\n-        }\n-    }\n-\n-    fn backslash_run_ends_in_quote(s: &str, mut i: uint) -> bool {\n-        while i < s.len() && s[i] as char == '\\\\' {\n-            i += 1;\n-        }\n-        return i < s.len() && s[i] as char == '\"';\n-    }\n-}\n-\n-#[cfg(unix)]\n-fn spawn_process_os(prog: &str, args: &[~str],\n-                    env: Option<~[(~str, ~str)]>,\n-                    dir: Option<&Path>,\n-                    in_fd: c_int, out_fd: c_int, err_fd: c_int) -> SpawnProcessResult {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    use libc::funcs::posix88::unistd::{fork, dup2, close, chdir, execvp};\n-    use libc::funcs::bsd44::getdtablesize;\n-\n-    mod rustrt {\n-        use libc::c_void;\n-\n-        #[abi = \"cdecl\"]\n-        extern {\n-            pub fn rust_unset_sigprocmask();\n-            pub fn rust_set_environ(envp: *c_void);\n-        }\n-    }\n-\n-    unsafe {\n-\n-        let pid = fork();\n-        if pid < 0 {\n-            fail!(\"failure in fork: %s\", os::last_os_error());\n-        } else if pid > 0 {\n-            return SpawnProcessResult {pid: pid, handle: ptr::null()};\n-        }\n-\n-        rustrt::rust_unset_sigprocmask();\n-\n-        if dup2(in_fd, 0) == -1 {\n-            fail!(\"failure in dup2(in_fd, 0): %s\", os::last_os_error());\n-        }\n-        if dup2(out_fd, 1) == -1 {\n-            fail!(\"failure in dup2(out_fd, 1): %s\", os::last_os_error());\n-        }\n-        if dup2(err_fd, 2) == -1 {\n-            fail!(\"failure in dup3(err_fd, 2): %s\", os::last_os_error());\n-        }\n-        // close all other fds\n-        for fd in range(3, getdtablesize()).invert() {\n-            close(fd as c_int);\n-        }\n-\n-        do with_dirp(dir) |dirp| {\n-            if !dirp.is_null() && chdir(dirp) == -1 {\n-                fail!(\"failure in chdir: %s\", os::last_os_error());\n-            }\n-        }\n-\n-        do with_envp(env) |envp| {\n-            if !envp.is_null() {\n-                rustrt::rust_set_environ(envp);\n-            }\n-            do with_argv(prog, args) |argv| {\n-                execvp(*argv, argv);\n-                // execvp only returns if an error occurred\n-                fail!(\"failure in execvp: %s\", os::last_os_error());\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(unix)]\n-fn with_argv<T>(prog: &str, args: &[~str], cb: &fn(**libc::c_char) -> T) -> T {\n-    use vec;\n-\n-    // We can't directly convert `str`s into `*char`s, as someone needs to hold\n-    // a reference to the intermediary byte buffers. So first build an array to\n-    // hold all the ~[u8] byte strings.\n-    let mut tmps = vec::with_capacity(args.len() + 1);\n-\n-    tmps.push(prog.to_c_str());\n-\n-    for arg in args.iter() {\n-        tmps.push(arg.to_c_str());\n-    }\n-\n-    // Next, convert each of the byte strings into a pointer. This is\n-    // technically unsafe as the caller could leak these pointers out of our\n-    // scope.\n-    let mut ptrs = do tmps.map |tmp| {\n-        tmp.with_ref(|buf| buf)\n-    };\n-\n-    // Finally, make sure we add a null pointer.\n-    ptrs.push(ptr::null());\n-\n-    ptrs.as_imm_buf(|buf, _| cb(buf))\n-}\n-\n-#[cfg(unix)]\n-fn with_envp<T>(env: Option<~[(~str, ~str)]>, cb: &fn(*c_void) -> T) -> T {\n-    use vec;\n-\n-    // On posixy systems we can pass a char** for envp, which is a\n-    // null-terminated array of \"k=v\\n\" strings. Like `with_argv`, we have to\n-    // have a temporary buffer to hold the intermediary `~[u8]` byte strings.\n-    match env {\n-        Some(env) => {\n-            let mut tmps = vec::with_capacity(env.len());\n-\n-            for pair in env.iter() {\n-                // Use of match here is just to workaround limitations\n-                // in the stage0 irrefutable pattern impl.\n-                let kv = fmt!(\"%s=%s\", pair.first(), pair.second());\n-                tmps.push(kv.to_c_str());\n-            }\n-\n-            // Once again, this is unsafe.\n-            let mut ptrs = do tmps.map |tmp| {\n-                tmp.with_ref(|buf| buf)\n-            };\n-            ptrs.push(ptr::null());\n-\n-            do ptrs.as_imm_buf |buf, _| {\n-                unsafe { cb(cast::transmute(buf)) }\n-            }\n-        }\n-        _ => cb(ptr::null())\n-    }\n-}\n-\n-#[cfg(windows)]\n-fn with_envp<T>(env: Option<~[(~str, ~str)]>, cb: &fn(*mut c_void) -> T) -> T {\n-    // On win32 we pass an \"environment block\" which is not a char**, but\n-    // rather a concatenation of null-terminated k=v\\0 sequences, with a final\n-    // \\0 to terminate.\n-    match env {\n-        Some(env) => {\n-            let mut blk = ~[];\n-\n-            for pair in env.iter() {\n-                let kv = fmt!(\"%s=%s\", pair.first(), pair.second());\n-                blk.push_all(kv.as_bytes());\n-                blk.push(0);\n-            }\n-\n-            blk.push(0);\n-\n-            do blk.as_imm_buf |p, _len| {\n-                unsafe { cb(cast::transmute(p)) }\n-            }\n-        }\n-        _ => cb(ptr::mut_null())\n-    }\n-}\n-\n-fn with_dirp<T>(d: Option<&Path>, cb: &fn(*libc::c_char) -> T) -> T {\n-    match d {\n-      Some(dir) => dir.with_c_str(|buf| cb(buf)),\n-      None => cb(ptr::null())\n-    }\n-}\n-\n-#[cfg(windows)]\n-fn free_handle(handle: *()) {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    unsafe {\n-        libc::funcs::extra::kernel32::CloseHandle(cast::transmute(handle));\n     }\n }\n \n-#[cfg(unix)]\n-fn free_handle(_handle: *()) {\n-    // unix has no process handle object, just a pid\n-}\n-\n /**\n  * Spawns a process and waits for it to terminate. The process will\n  * inherit the current stdin/stdout/stderr file descriptors.\n@@ -824,7 +369,7 @@ pub fn process_status(prog: &str, args: &[~str]) -> int {\n         in_fd: Some(0),\n         out_fd: Some(1),\n         err_fd: Some(2)\n-    });\n+    }).unwrap();\n     prog.finish()\n }\n \n@@ -841,162 +386,38 @@ pub fn process_status(prog: &str, args: &[~str]) -> int {\n  * The process's stdout/stderr output and exit code.\n  */\n pub fn process_output(prog: &str, args: &[~str]) -> ProcessOutput {\n-    let mut prog = Process::new(prog, args, ProcessOptions::new());\n+    let mut prog = Process::new(prog, args, ProcessOptions::new()).unwrap();\n     prog.finish_with_output()\n }\n \n-/**\n- * Waits for a process to exit and returns the exit code, failing\n- * if there is no process with the specified id.\n- *\n- * Note that this is private to avoid race conditions on unix where if\n- * a user calls waitpid(some_process.get_id()) then some_process.finish()\n- * and some_process.destroy() and some_process.finalize() will then either\n- * operate on a none-existent process or, even worse, on a newer process\n- * with the same id.\n- */\n-fn waitpid(pid: pid_t) -> int {\n-    return waitpid_os(pid);\n-\n-    #[cfg(windows)]\n-    fn waitpid_os(pid: pid_t) -> int {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n-        use libc::types::os::arch::extra::DWORD;\n-        use libc::consts::os::extra::{\n-            SYNCHRONIZE,\n-            PROCESS_QUERY_INFORMATION,\n-            FALSE,\n-            STILL_ACTIVE,\n-            INFINITE,\n-            WAIT_FAILED\n-        };\n-        use libc::funcs::extra::kernel32::{\n-            OpenProcess,\n-            GetExitCodeProcess,\n-            CloseHandle,\n-            WaitForSingleObject\n-        };\n-\n-        unsafe {\n-\n-            let proc = OpenProcess(SYNCHRONIZE | PROCESS_QUERY_INFORMATION, FALSE, pid as DWORD);\n-            if proc.is_null() {\n-                fail!(\"failure in OpenProcess: %s\", os::last_os_error());\n-            }\n-\n-            loop {\n-                let mut status = 0;\n-                if GetExitCodeProcess(proc, &mut status) == FALSE {\n-                    CloseHandle(proc);\n-                    fail!(\"failure in GetExitCodeProcess: %s\", os::last_os_error());\n-                }\n-                if status != STILL_ACTIVE {\n-                    CloseHandle(proc);\n-                    return status as int;\n-                }\n-                if WaitForSingleObject(proc, INFINITE) == WAIT_FAILED {\n-                    CloseHandle(proc);\n-                    fail!(\"failure in WaitForSingleObject: %s\", os::last_os_error());\n-                }\n-            }\n-        }\n-    }\n-\n-    #[cfg(unix)]\n-    fn waitpid_os(pid: pid_t) -> int {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n-        use libc::funcs::posix01::wait::*;\n-\n-        #[cfg(target_os = \"linux\")]\n-        #[cfg(target_os = \"android\")]\n-        fn WIFEXITED(status: i32) -> bool {\n-            (status & 0xffi32) == 0i32\n-        }\n-\n-        #[cfg(target_os = \"macos\")]\n-        #[cfg(target_os = \"freebsd\")]\n-        fn WIFEXITED(status: i32) -> bool {\n-            (status & 0x7fi32) == 0i32\n-        }\n-\n-        #[cfg(target_os = \"linux\")]\n-        #[cfg(target_os = \"android\")]\n-        fn WEXITSTATUS(status: i32) -> i32 {\n-            (status >> 8i32) & 0xffi32\n-        }\n-\n-        #[cfg(target_os = \"macos\")]\n-        #[cfg(target_os = \"freebsd\")]\n-        fn WEXITSTATUS(status: i32) -> i32 {\n-            status >> 8i32\n-        }\n-\n-        let mut status = 0 as c_int;\n-        if unsafe { waitpid(pid, &mut status, 0) } == -1 {\n-            fail!(\"failure in waitpid: %s\", os::last_os_error());\n-        }\n-\n-        return if WIFEXITED(status) {\n-            WEXITSTATUS(status) as int\n-        } else {\n-            1\n-        };\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n-    use io;\n-    use libc::c_int;\n-    use option::{Option, None, Some};\n     use os;\n     use path::Path;\n-    use run;\n+    use prelude::*;\n     use str;\n+    use super::*;\n     use unstable::running_on_valgrind;\n \n-    #[test]\n-    #[cfg(windows)]\n-    fn test_make_command_line() {\n-        assert_eq!(\n-            run::make_command_line(\"prog\", [~\"aaa\", ~\"bbb\", ~\"ccc\"]),\n-            ~\"prog aaa bbb ccc\"\n-        );\n-        assert_eq!(\n-            run::make_command_line(\"C:\\\\Program Files\\\\blah\\\\blah.exe\", [~\"aaa\"]),\n-            ~\"\\\"C:\\\\Program Files\\\\blah\\\\blah.exe\\\" aaa\"\n-        );\n-        assert_eq!(\n-            run::make_command_line(\"C:\\\\Program Files\\\\test\", [~\"aa\\\"bb\"]),\n-            ~\"\\\"C:\\\\Program Files\\\\test\\\" aa\\\\\\\"bb\"\n-        );\n-        assert_eq!(\n-            run::make_command_line(\"echo\", [~\"a b c\"]),\n-            ~\"echo \\\"a b c\\\"\"\n-        );\n-    }\n-\n     #[test]\n     #[cfg(not(target_os=\"android\"))]\n     fn test_process_status() {\n-        assert_eq!(run::process_status(\"false\", []), 1);\n-        assert_eq!(run::process_status(\"true\", []), 0);\n+        assert_eq!(process_status(\"false\", []), 1);\n+        assert_eq!(process_status(\"true\", []), 0);\n     }\n     #[test]\n     #[cfg(target_os=\"android\")]\n     fn test_process_status() {\n-        assert_eq!(run::process_status(\"/system/bin/sh\", [~\"-c\",~\"false\"]), 1);\n-        assert_eq!(run::process_status(\"/system/bin/sh\", [~\"-c\",~\"true\"]), 0);\n+        assert_eq!(process_status(\"/system/bin/sh\", [~\"-c\",~\"false\"]), 1);\n+        assert_eq!(process_status(\"/system/bin/sh\", [~\"-c\",~\"true\"]), 0);\n     }\n \n     #[test]\n     #[cfg(not(target_os=\"android\"))]\n     fn test_process_output_output() {\n \n-        let run::ProcessOutput {status, output, error}\n-             = run::process_output(\"echo\", [~\"hello\"]);\n+        let ProcessOutput {status, output, error}\n+             = process_output(\"echo\", [~\"hello\"]);\n         let output_str = str::from_bytes(output);\n \n         assert_eq!(status, 0);\n@@ -1010,8 +431,8 @@ mod tests {\n     #[cfg(target_os=\"android\")]\n     fn test_process_output_output() {\n \n-        let run::ProcessOutput {status, output, error}\n-             = run::process_output(\"/system/bin/sh\", [~\"-c\",~\"echo hello\"]);\n+        let ProcessOutput {status, output, error}\n+             = process_output(\"/system/bin/sh\", [~\"-c\",~\"echo hello\"]);\n         let output_str = str::from_bytes(output);\n \n         assert_eq!(status, 0);\n@@ -1026,8 +447,8 @@ mod tests {\n     #[cfg(not(target_os=\"android\"))]\n     fn test_process_output_error() {\n \n-        let run::ProcessOutput {status, output, error}\n-             = run::process_output(\"mkdir\", [~\".\"]);\n+        let ProcessOutput {status, output, error}\n+             = process_output(\"mkdir\", [~\".\"]);\n \n         assert_eq!(status, 1);\n         assert_eq!(output, ~[]);\n@@ -1037,90 +458,40 @@ mod tests {\n     #[cfg(target_os=\"android\")]\n     fn test_process_output_error() {\n \n-        let run::ProcessOutput {status, output, error}\n-             = run::process_output(\"/system/bin/mkdir\", [~\".\"]);\n+        let ProcessOutput {status, output, error}\n+             = process_output(\"/system/bin/mkdir\", [~\".\"]);\n \n         assert_eq!(status, 255);\n         assert_eq!(output, ~[]);\n         assert!(!error.is_empty());\n     }\n \n-    #[test]\n-    fn test_pipes() {\n-\n-        let pipe_in = os::pipe();\n-        let pipe_out = os::pipe();\n-        let pipe_err = os::pipe();\n-\n-        let mut proc = run::Process::new(\"cat\", [], run::ProcessOptions {\n-            dir: None,\n-            env: None,\n-            in_fd: Some(pipe_in.input),\n-            out_fd: Some(pipe_out.out),\n-            err_fd: Some(pipe_err.out)\n-        });\n-\n-        assert!(proc.input_redirected());\n-        assert!(proc.output_redirected());\n-        assert!(proc.error_redirected());\n-\n-        os::close(pipe_in.input);\n-        os::close(pipe_out.out);\n-        os::close(pipe_err.out);\n-\n-        let expected = ~\"test\";\n-        writeclose(pipe_in.out, expected);\n-        let actual = readclose(pipe_out.input);\n-        readclose(pipe_err.input);\n-        proc.finish();\n-\n-        assert_eq!(expected, actual);\n-    }\n-\n-    fn writeclose(fd: c_int, s: &str) {\n-        let writer = io::fd_writer(fd, false);\n-        writer.write_str(s);\n-        os::close(fd);\n-    }\n-\n-    fn readclose(fd: c_int) -> ~str {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n-        unsafe {\n-            let file = os::fdopen(fd);\n-            let reader = io::FILE_reader(file, false);\n-            let buf = reader.read_whole_stream();\n-            os::fclose(file);\n-            str::from_bytes(buf)\n-        }\n-    }\n-\n     #[test]\n     #[cfg(not(target_os=\"android\"))]\n     fn test_finish_once() {\n-        let mut prog = run::Process::new(\"false\", [], run::ProcessOptions::new());\n+        let mut prog = Process::new(\"false\", [], ProcessOptions::new()).unwrap();\n         assert_eq!(prog.finish(), 1);\n     }\n     #[test]\n     #[cfg(target_os=\"android\")]\n     fn test_finish_once() {\n-        let mut prog = run::Process::new(\"/system/bin/sh\", [~\"-c\",~\"false\"],\n-                                         run::ProcessOptions::new());\n+        let mut prog = Process::new(\"/system/bin/sh\", [~\"-c\",~\"false\"],\n+                                    ProcessOptions::new()).unwrap();\n         assert_eq!(prog.finish(), 1);\n     }\n \n     #[test]\n     #[cfg(not(target_os=\"android\"))]\n     fn test_finish_twice() {\n-        let mut prog = run::Process::new(\"false\", [], run::ProcessOptions::new());\n+        let mut prog = Process::new(\"false\", [], ProcessOptions::new()).unwrap();\n         assert_eq!(prog.finish(), 1);\n         assert_eq!(prog.finish(), 1);\n     }\n     #[test]\n     #[cfg(target_os=\"android\")]\n     fn test_finish_twice() {\n-        let mut prog = run::Process::new(\"/system/bin/sh\", [~\"-c\",~\"false\"],\n-                                         run::ProcessOptions::new());\n+        let mut prog = Process::new(\"/system/bin/sh\", [~\"-c\",~\"false\"],\n+                                    ProcessOptions::new()).unwrap();\n         assert_eq!(prog.finish(), 1);\n         assert_eq!(prog.finish(), 1);\n     }\n@@ -1129,8 +500,9 @@ mod tests {\n     #[cfg(not(target_os=\"android\"))]\n     fn test_finish_with_output_once() {\n \n-        let mut prog = run::Process::new(\"echo\", [~\"hello\"], run::ProcessOptions::new());\n-        let run::ProcessOutput {status, output, error}\n+        let prog = Process::new(\"echo\", [~\"hello\"], ProcessOptions::new());\n+        let mut prog = prog.unwrap();\n+        let ProcessOutput {status, output, error}\n             = prog.finish_with_output();\n         let output_str = str::from_bytes(output);\n \n@@ -1145,28 +517,10 @@ mod tests {\n     #[cfg(target_os=\"android\")]\n     fn test_finish_with_output_once() {\n \n-        let mut prog = run::Process::new(\"/system/bin/sh\", [~\"-c\",~\"echo hello\"],\n-                                         run::ProcessOptions::new());\n-        let run::ProcessOutput {status, output, error}\n-            = prog.finish_with_output();\n-        let output_str = str::from_bytes(output);\n-\n-        assert_eq!(status, 0);\n-        assert_eq!(output_str.trim().to_owned(), ~\"hello\");\n-        // FIXME #7224\n-        if !running_on_valgrind() {\n-            assert_eq!(error, ~[]);\n-        }\n-    }\n-\n-    #[test]\n-    #[cfg(not(target_os=\"android\"))]\n-    fn test_finish_with_output_twice() {\n-\n-        let mut prog = run::Process::new(\"echo\", [~\"hello\"], run::ProcessOptions::new());\n-        let run::ProcessOutput {status, output, error}\n+        let mut prog = Process::new(\"/system/bin/sh\", [~\"-c\",~\"echo hello\"],\n+                                    ProcessOptions::new()).unwrap();\n+        let ProcessOutput {status, output, error}\n             = prog.finish_with_output();\n-\n         let output_str = str::from_bytes(output);\n \n         assert_eq!(status, 0);\n@@ -1175,97 +529,61 @@ mod tests {\n         if !running_on_valgrind() {\n             assert_eq!(error, ~[]);\n         }\n-\n-        let run::ProcessOutput {status, output, error}\n-            = prog.finish_with_output();\n-\n-        assert_eq!(status, 0);\n-        assert_eq!(output, ~[]);\n-        // FIXME #7224\n-        if !running_on_valgrind() {\n-            assert_eq!(error, ~[]);\n-        }\n-    }\n-    #[test]\n-    #[cfg(target_os=\"android\")]\n-    fn test_finish_with_output_twice() {\n-\n-        let mut prog = run::Process::new(\"/system/bin/sh\", [~\"-c\",~\"echo hello\"],\n-                                         run::ProcessOptions::new());\n-        let run::ProcessOutput {status, output, error}\n-            = prog.finish_with_output();\n-\n-        let output_str = str::from_bytes(output);\n-\n-        assert_eq!(status, 0);\n-        assert_eq!(output_str.trim().to_owned(), ~\"hello\");\n-        // FIXME #7224\n-        if !running_on_valgrind() {\n-            assert_eq!(error, ~[]);\n-        }\n-\n-        let run::ProcessOutput {status, output, error}\n-            = prog.finish_with_output();\n-\n-        assert_eq!(status, 0);\n-        assert_eq!(output, ~[]);\n-        // FIXME #7224\n-        if !running_on_valgrind() {\n-            assert_eq!(error, ~[]);\n-        }\n     }\n \n     #[test]\n     #[should_fail]\n     #[cfg(not(windows),not(target_os=\"android\"))]\n     fn test_finish_with_output_redirected() {\n-        let mut prog = run::Process::new(\"echo\", [~\"hello\"], run::ProcessOptions {\n+        let mut prog = Process::new(\"echo\", [~\"hello\"], ProcessOptions {\n             env: None,\n             dir: None,\n             in_fd: Some(0),\n             out_fd: Some(1),\n             err_fd: Some(2)\n-        });\n-        // this should fail because it is not valid to read the output when it was redirected\n+        }).unwrap();\n+        // this should fail because it is not valid to read the output when it\n+        // was redirected\n         prog.finish_with_output();\n     }\n     #[test]\n     #[should_fail]\n     #[cfg(not(windows),target_os=\"android\")]\n     fn test_finish_with_output_redirected() {\n-        let mut prog = run::Process::new(\"/system/bin/sh\", [~\"-c\",~\"echo hello\"],\n-                                         run::ProcessOptions {\n+        let mut prog = Process::new(\"/system/bin/sh\", [~\"-c\",~\"echo hello\"],\n+                                    ProcessOptions {\n             env: None,\n             dir: None,\n             in_fd: Some(0),\n             out_fd: Some(1),\n             err_fd: Some(2)\n-        });\n-        // this should fail because it is not valid to read the output when it was redirected\n+        }).unwrap();\n+        // this should fail because it is not valid to read the output when it\n+        // was redirected\n         prog.finish_with_output();\n     }\n \n     #[cfg(unix,not(target_os=\"android\"))]\n-    fn run_pwd(dir: Option<&Path>) -> run::Process {\n-        run::Process::new(\"pwd\", [], run::ProcessOptions {\n+    fn run_pwd(dir: Option<&Path>) -> Process {\n+        Process::new(\"pwd\", [], ProcessOptions {\n             dir: dir,\n-            .. run::ProcessOptions::new()\n-        })\n+            .. ProcessOptions::new()\n+        }).unwrap()\n     }\n     #[cfg(unix,target_os=\"android\")]\n-    fn run_pwd(dir: Option<&Path>) -> run::Process {\n-        run::Process::new(\"/system/bin/sh\", [~\"-c\",~\"pwd\"], run::ProcessOptions {\n+    fn run_pwd(dir: Option<&Path>) -> Process {\n+        Process::new(\"/system/bin/sh\", [~\"-c\",~\"pwd\"], ProcessOptions {\n             dir: dir,\n-            .. run::ProcessOptions::new()\n-        })\n+            .. ProcessOptions::new()\n+        }).unwrap()\n     }\n \n     #[cfg(windows)]\n-    fn run_pwd(dir: Option<&Path>) -> run::Process {\n-        run::Process::new(\"cmd\", [~\"/c\", ~\"cd\"], run::ProcessOptions {\n+    fn run_pwd(dir: Option<&Path>) -> Process {\n+        Process::new(\"cmd\", [~\"/c\", ~\"cd\"], ProcessOptions {\n             dir: dir,\n-            .. run::ProcessOptions::new()\n-        })\n+            .. ProcessOptions::new()\n+        }).unwrap()\n     }\n \n     #[test]\n@@ -1301,26 +619,26 @@ mod tests {\n     }\n \n     #[cfg(unix,not(target_os=\"android\"))]\n-    fn run_env(env: Option<~[(~str, ~str)]>) -> run::Process {\n-        run::Process::new(\"env\", [], run::ProcessOptions {\n+    fn run_env(env: Option<~[(~str, ~str)]>) -> Process {\n+        Process::new(\"env\", [], ProcessOptions {\n             env: env,\n-            .. run::ProcessOptions::new()\n-        })\n+            .. ProcessOptions::new()\n+        }).unwrap()\n     }\n     #[cfg(unix,target_os=\"android\")]\n-    fn run_env(env: Option<~[(~str, ~str)]>) -> run::Process {\n-        run::Process::new(\"/system/bin/sh\", [~\"-c\",~\"set\"], run::ProcessOptions {\n+    fn run_env(env: Option<~[(~str, ~str)]>) -> Process {\n+        Process::new(\"/system/bin/sh\", [~\"-c\",~\"set\"], ProcessOptions {\n             env: env,\n-            .. run::ProcessOptions::new()\n-        })\n+            .. ProcessOptions::new()\n+        }).unwrap()\n     }\n \n     #[cfg(windows)]\n-    fn run_env(env: Option<~[(~str, ~str)]>) -> run::Process {\n-        run::Process::new(\"cmd\", [~\"/c\", ~\"set\"], run::ProcessOptions {\n+    fn run_env(env: Option<~[(~str, ~str)]>) -> Process {\n+        Process::new(\"cmd\", [~\"/c\", ~\"set\"], ProcessOptions {\n             env: env,\n-            .. run::ProcessOptions::new()\n-        })\n+            .. ProcessOptions::new()\n+        }).unwrap()\n     }\n \n     #[test]\n@@ -1357,7 +675,6 @@ mod tests {\n \n     #[test]\n     fn test_add_to_env() {\n-\n         let mut new_env = os::env();\n         new_env.push((~\"RUN_TEST_NEW_ENV\", ~\"123\"));\n "}, {"sha": "ef2bcd134164adcaa072dcb56e62b737fdcb075e", "filename": "src/libuv", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibuv?ref=b8d1fa399402c71331aefd634d710004e00b73a6", "patch": "@@ -1 +1 @@\n-Subproject commit dfae9c3e958dc086d9c0ab068cd76d196c95a433\n+Subproject commit ef2bcd134164adcaa072dcb56e62b737fdcb075e"}, {"sha": "a181e76df5ca70f1bb31ee21a93c7c4be96fcd6a", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 36, "deletions": 9, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/b8d1fa399402c71331aefd634d710004e00b73a6/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/b8d1fa399402c71331aefd634d710004e00b73a6/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=b8d1fa399402c71331aefd634d710004e00b73a6", "patch": "@@ -329,20 +329,13 @@ rust_uv_get_len_from_buf(uv_buf_t buf) {\n     return buf.len;\n }\n \n-extern \"C\" uv_err_t\n-rust_uv_last_error(uv_loop_t* loop) {\n-    return uv_last_error(loop);\n-}\n-\n extern \"C\" const char*\n-rust_uv_strerror(uv_err_t* err_ptr) {\n-    uv_err_t err = *err_ptr;\n+rust_uv_strerror(int err) {\n     return uv_strerror(err);\n }\n \n extern \"C\" const char*\n-rust_uv_err_name(uv_err_t* err_ptr) {\n-    uv_err_t err = *err_ptr;\n+rust_uv_err_name(int err) {\n     return uv_err_name(err);\n }\n \n@@ -553,3 +546,37 @@ extern \"C\" uv_loop_t*\n rust_uv_get_loop_from_fs_req(uv_fs_t* req) {\n   return req->loop;\n }\n+extern \"C\" int\n+rust_uv_spawn(uv_loop_t *loop, uv_process_t *p, uv_process_options_t options) {\n+  return uv_spawn(loop, p, options);\n+}\n+\n+extern \"C\" int\n+rust_uv_process_kill(uv_process_t *p, int signum) {\n+  return uv_process_kill(p, signum);\n+}\n+\n+extern \"C\" void\n+rust_set_stdio_container_flags(uv_stdio_container_t *c, int flags) {\n+  c->flags = (uv_stdio_flags) flags;\n+}\n+\n+extern \"C\" void\n+rust_set_stdio_container_fd(uv_stdio_container_t *c, int fd) {\n+  c->data.fd = fd;\n+}\n+\n+extern \"C\" void\n+rust_set_stdio_container_stream(uv_stdio_container_t *c, uv_stream_t *stream) {\n+  c->data.stream = stream;\n+}\n+\n+extern \"C\" int\n+rust_uv_process_pid(uv_process_t* p) {\n+  return p->pid;\n+}\n+\n+extern \"C\" int\n+rust_uv_pipe_init(uv_loop_t *loop, uv_pipe_t* p, int ipc) {\n+  return uv_pipe_init(loop, p, ipc);\n+}"}, {"sha": "2fc1a91a132da55d66c5ba660612398ebbfe06d1", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b8d1fa399402c71331aefd634d710004e00b73a6/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/b8d1fa399402c71331aefd634d710004e00b73a6/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=b8d1fa399402c71331aefd634d710004e00b73a6", "patch": "@@ -47,7 +47,6 @@ rust_uv_timer_start\n rust_uv_timer_stop\n rust_uv_tcp_init\n rust_uv_buf_init\n-rust_uv_last_error\n rust_uv_strerror\n rust_uv_err_name\n rust_uv_ip4_addr\n@@ -191,4 +190,11 @@ rust_drop_global_args_lock\n rust_take_change_dir_lock\n rust_drop_change_dir_lock\n rust_get_test_int\n-rust_get_task\n\\ No newline at end of file\n+rust_get_task\n+rust_uv_spawn\n+rust_uv_process_kill\n+rust_set_stdio_container_flags\n+rust_set_stdio_container_fd\n+rust_set_stdio_container_stream\n+rust_uv_process_pid\n+rust_uv_pipe_init"}, {"sha": "90e63fc977d866841394f491be862265b95ef0c2", "filename": "src/test/run-pass/core-run-destroy.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b8d1fa399402c71331aefd634d710004e00b73a6/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8d1fa399402c71331aefd634d710004e00b73a6/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs?ref=b8d1fa399402c71331aefd634d710004e00b73a6", "patch": "@@ -22,13 +22,15 @@ use std::str;\n \n #[test]\n fn test_destroy_once() {\n-    let mut p = run::Process::new(\"echo\", [], run::ProcessOptions::new());\n+    let p = run::Process::new(\"echo\", [], run::ProcessOptions::new());\n+    let mut p = p.unwrap();\n     p.destroy(); // this shouldn't crash (and nor should the destructor)\n }\n \n #[test]\n fn test_destroy_twice() {\n-    let mut p = run::Process::new(\"echo\", [], run::ProcessOptions::new());\n+    let p = run::Process::new(\"echo\", [], run::ProcessOptions::new());\n+    let mut p = p.unwrap();\n     p.destroy(); // this shouldnt crash...\n     p.destroy(); // ...and nor should this (and nor should the destructor)\n }\n@@ -74,7 +76,8 @@ fn test_destroy_actually_kills(force: bool) {\n     }\n \n     // this process will stay alive indefinitely trying to read from stdin\n-    let mut p = run::Process::new(BLOCK_COMMAND, [], run::ProcessOptions::new());\n+    let p = run::Process::new(BLOCK_COMMAND, [], run::ProcessOptions::new());\n+    let mut p = p.unwrap();\n \n     assert!(process_exists(p.get_id()));\n "}]}