{"sha": "ad4e108c39696b368705d9238f44b10fced91a58", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkNGUxMDhjMzk2OTZiMzY4NzA1ZDkyMzhmNDRiMTBmY2VkOTFhNTg=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-02-29T22:01:36Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-02-29T22:01:36Z"}, "message": "Merge #3380\n\n3380: Unsizing in method resolution & autoderef for indexing r=matklad a=flodiebold\n\n - do autoderef for indexing\r\n - do array unsizing (`[T; N]` -> `[T]`) in both method resolution and indexing. It turns out array unsizing is actually the only unsizing coercion that rustc does for method receivers, so this is simpler than I expected.\r\n\r\nSadly, this doesn't fix indexing slices/arrays yet, there are still some trait solving problems...\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "0597ebf09ac6c3216477c4993a8f16686f0ca452", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0597ebf09ac6c3216477c4993a8f16686f0ca452"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad4e108c39696b368705d9238f44b10fced91a58", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeWt9ACRBK7hj4Ov3rIwAAdHIIACaIxbNpVvjYMNp2zEda+iY7\nFMFh1tZVFGove3brY4lJuw43M1sxQsojvwNyoTFiFOzLymTe1CEreDSoUgvAS7Kt\nhP6XanOD03Bzfv7BVtv9r47T6cJ+kupOn4MFx4bQGezqOL3cugWkmtHoi3dFLqH6\n6xKIUSkK6FuhQqJpStvnbg6MzwA8ADl/sqKcS1GFdc0pAqcfSjZd+yrYOYsD6OZU\nCdf82lSGKgmkEub9rdSr3FLsaDbPLmeu1TEA/nfmigEP+mFvAo6VorUQS+uqZQwZ\nRj6fnLCWiMoNpGkp6Hvt+ccU1xWpUx2ArnXq6NWWtfwVqOlPUb5XrnU0txPqzx0=\n=ZPVR\n-----END PGP SIGNATURE-----\n", "payload": "tree 0597ebf09ac6c3216477c4993a8f16686f0ca452\nparent 5e78036e6c8752fda350818afdd411ab25f405ce\nparent 31171eed5eeab217280237e63ffe6adda62baf96\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1583013696 +0000\ncommitter GitHub <noreply@github.com> 1583013696 +0000\n\nMerge #3380\n\n3380: Unsizing in method resolution & autoderef for indexing r=matklad a=flodiebold\n\n - do autoderef for indexing\r\n - do array unsizing (`[T; N]` -> `[T]`) in both method resolution and indexing. It turns out array unsizing is actually the only unsizing coercion that rustc does for method receivers, so this is simpler than I expected.\r\n\r\nSadly, this doesn't fix indexing slices/arrays yet, there are still some trait solving problems...\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad4e108c39696b368705d9238f44b10fced91a58", "html_url": "https://github.com/rust-lang/rust/commit/ad4e108c39696b368705d9238f44b10fced91a58", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad4e108c39696b368705d9238f44b10fced91a58/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e78036e6c8752fda350818afdd411ab25f405ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e78036e6c8752fda350818afdd411ab25f405ce", "html_url": "https://github.com/rust-lang/rust/commit/5e78036e6c8752fda350818afdd411ab25f405ce"}, {"sha": "31171eed5eeab217280237e63ffe6adda62baf96", "url": "https://api.github.com/repos/rust-lang/rust/commits/31171eed5eeab217280237e63ffe6adda62baf96", "html_url": "https://github.com/rust-lang/rust/commit/31171eed5eeab217280237e63ffe6adda62baf96"}], "stats": {"total": 120, "additions": 111, "deletions": 9}, "files": [{"sha": "377f44fa75a60fae93277b84676bd44d92cd9ecf", "filename": "crates/ra_hir_ty/src/infer.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ad4e108c39696b368705d9238f44b10fced91a58/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad4e108c39696b368705d9238f44b10fced91a58/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs?ref=ad4e108c39696b368705d9238f44b10fced91a58", "patch": "@@ -28,7 +28,7 @@ use hir_def::{\n     path::{path, Path},\n     resolver::{HasResolver, Resolver, TypeNs},\n     type_ref::{Mutability, TypeRef},\n-    AdtId, AssocItemId, DefWithBodyId, FunctionId, StructFieldId, TypeAliasId, VariantId,\n+    AdtId, AssocItemId, DefWithBodyId, FunctionId, StructFieldId, TraitId, TypeAliasId, VariantId,\n };\n use hir_expand::{diagnostics::DiagnosticSink, name::name};\n use ra_arena::map::ArenaMap;\n@@ -540,8 +540,12 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         Some(struct_.into())\n     }\n \n+    fn resolve_ops_index(&self) -> Option<TraitId> {\n+        self.resolve_lang_item(\"index\")?.as_trait()\n+    }\n+\n     fn resolve_ops_index_output(&self) -> Option<TypeAliasId> {\n-        let trait_ = self.resolve_lang_item(\"index\")?.as_trait()?;\n+        let trait_ = self.resolve_ops_index()?;\n         self.db.trait_data(trait_).associated_type_by_name(&name![Output])\n     }\n }"}, {"sha": "e89cc72987c93e0f82e5260896883129b5ba52e3", "filename": "crates/ra_hir_ty/src/infer/expr.rs", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ad4e108c39696b368705d9238f44b10fced91a58/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad4e108c39696b368705d9238f44b10fced91a58/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=ad4e108c39696b368705d9238f44b10fced91a58", "patch": "@@ -429,11 +429,27 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 let base_ty = self.infer_expr_inner(*base, &Expectation::none());\n                 let index_ty = self.infer_expr(*index, &Expectation::none());\n \n-                self.resolve_associated_type_with_params(\n-                    base_ty,\n-                    self.resolve_ops_index_output(),\n-                    &[index_ty],\n-                )\n+                if let (Some(index_trait), Some(krate)) =\n+                    (self.resolve_ops_index(), self.resolver.krate())\n+                {\n+                    let canonicalized = self.canonicalizer().canonicalize_ty(base_ty);\n+                    let self_ty = method_resolution::resolve_indexing_op(\n+                        self.db,\n+                        &canonicalized.value,\n+                        self.trait_env.clone(),\n+                        krate,\n+                        index_trait,\n+                    );\n+                    let self_ty =\n+                        self_ty.map_or(Ty::Unknown, |t| canonicalized.decanonicalize_ty(t.value));\n+                    self.resolve_associated_type_with_params(\n+                        self_ty,\n+                        self.resolve_ops_index_output(),\n+                        &[index_ty],\n+                    )\n+                } else {\n+                    Ty::Unknown\n+                }\n             }\n             Expr::Tuple { exprs } => {\n                 let mut tys = match &expected.ty {"}, {"sha": "74b908c2e03264d208c3cbc1407e52cc2e277ff8", "filename": "crates/ra_hir_ty/src/method_resolution.rs", "status": "modified", "additions": 38, "deletions": 2, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ad4e108c39696b368705d9238f44b10fced91a58/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad4e108c39696b368705d9238f44b10fced91a58/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs?ref=ad4e108c39696b368705d9238f44b10fced91a58", "patch": "@@ -20,7 +20,7 @@ use crate::{\n     db::HirDatabase,\n     primitive::{FloatBitness, Uncertain},\n     utils::all_super_traits,\n-    Canonical, InEnvironment, TraitEnvironment, TraitRef, Ty, TypeCtor, TypeWalk,\n+    ApplicationTy, Canonical, InEnvironment, TraitEnvironment, TraitRef, Ty, TypeCtor, TypeWalk,\n };\n \n /// This is used as a key for indexing impls.\n@@ -214,7 +214,7 @@ pub fn iterate_method_candidates<T>(\n             // the methods by autoderef order of *receiver types*, not *self\n             // types*.\n \n-            let deref_chain: Vec<_> = autoderef::autoderef(db, Some(krate), ty).collect();\n+            let deref_chain = autoderef_method_receiver(db, krate, ty);\n             for i in 0..deref_chain.len() {\n                 if let Some(result) = iterate_method_candidates_with_autoref(\n                     &deref_chain[i..],\n@@ -447,6 +447,25 @@ fn iterate_inherent_methods<T>(\n     None\n }\n \n+/// Returns the self type for the index trait call.\n+pub fn resolve_indexing_op(\n+    db: &impl HirDatabase,\n+    ty: &Canonical<Ty>,\n+    env: Arc<TraitEnvironment>,\n+    krate: CrateId,\n+    index_trait: TraitId,\n+) -> Option<Canonical<Ty>> {\n+    let ty = InEnvironment { value: ty.clone(), environment: env.clone() };\n+    let deref_chain = autoderef_method_receiver(db, krate, ty);\n+    for ty in deref_chain {\n+        let goal = generic_implements_goal(db, env.clone(), index_trait, ty.clone());\n+        if db.trait_solve(krate, goal).is_some() {\n+            return Some(ty);\n+        }\n+    }\n+    None\n+}\n+\n fn is_valid_candidate(\n     db: &impl HirDatabase,\n     name: Option<&Name>,\n@@ -548,3 +567,20 @@ fn generic_implements_goal(\n     let obligation = super::Obligation::Trait(trait_ref);\n     Canonical { num_vars, value: InEnvironment::new(env, obligation) }\n }\n+\n+fn autoderef_method_receiver(\n+    db: &impl HirDatabase,\n+    krate: CrateId,\n+    ty: InEnvironment<Canonical<Ty>>,\n+) -> Vec<Canonical<Ty>> {\n+    let mut deref_chain: Vec<_> = autoderef::autoderef(db, Some(krate), ty).collect();\n+    // As a last step, we can do array unsizing (that's the only unsizing that rustc does for method receivers!)\n+    if let Some(Ty::Apply(ApplicationTy { ctor: TypeCtor::Array, parameters })) =\n+        deref_chain.last().map(|ty| &ty.value)\n+    {\n+        let num_vars = deref_chain.last().unwrap().num_vars;\n+        let unsized_ty = Ty::apply(TypeCtor::Slice, parameters.clone());\n+        deref_chain.push(Canonical { value: unsized_ty, num_vars })\n+    }\n+    deref_chain\n+}"}, {"sha": "f9b394f059a5d9776499abf9f79bbb65e8e41575", "filename": "crates/ra_hir_ty/src/tests/method_resolution.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ad4e108c39696b368705d9238f44b10fced91a58/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad4e108c39696b368705d9238f44b10fced91a58/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs?ref=ad4e108c39696b368705d9238f44b10fced91a58", "patch": "@@ -838,6 +838,24 @@ fn test() { (&S).foo()<|>; }\n     assert_eq!(t, \"u128\");\n }\n \n+#[test]\n+fn method_resolution_unsize_array() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+#[lang = \"slice\"]\n+impl<T> [T] {\n+    fn len(&self) -> usize { loop {} }\n+}\n+fn test() {\n+    let a = [1, 2, 3];\n+    a.len()<|>;\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"usize\");\n+}\n+\n #[test]\n fn method_resolution_trait_from_prelude() {\n     let (db, pos) = TestDB::with_position("}, {"sha": "547010b35199ddf83a902fbfcc815e65a0306756", "filename": "crates/ra_hir_ty/src/tests/traits.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ad4e108c39696b368705d9238f44b10fced91a58/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad4e108c39696b368705d9238f44b10fced91a58/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs?ref=ad4e108c39696b368705d9238f44b10fced91a58", "patch": "@@ -567,6 +567,34 @@ mod ops {\n     assert_eq!(\"Foo\", type_at_pos(&db, pos));\n }\n \n+#[test]\n+fn infer_ops_index_autoderef() {\n+    let (db, pos) = TestDB::with_position(\n+        r#\"\n+//- /main.rs crate:main deps:std\n+fn test() {\n+    let a = &[1u32, 2, 3];\n+    let b = a[1];\n+    b<|>;\n+}\n+\n+//- /std.rs crate:std\n+impl<T> ops::Index<u32> for [T] {\n+    type Output = T;\n+}\n+\n+#[prelude_import] use ops::*;\n+mod ops {\n+    #[lang = \"index\"]\n+    pub trait Index<Idx> {\n+        type Output;\n+    }\n+}\n+\"#,\n+    );\n+    assert_eq!(\"u32\", type_at_pos(&db, pos));\n+}\n+\n #[test]\n fn deref_trait() {\n     let t = type_at("}]}