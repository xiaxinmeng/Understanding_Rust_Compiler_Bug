{"sha": "ed35e516b13682726e4c9ee2fc3c88da6253a402", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkMzVlNTE2YjEzNjgyNzI2ZTRjOWVlMmZjM2M4OGRhNjI1M2E0MDI=", "commit": {"author": {"name": "Kushagra Gupta", "email": "39802979+Kushagra-0801@users.noreply.github.com", "date": "2021-02-03T15:35:21Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-02-03T15:35:21Z"}, "message": "Grammar fixes\n\nI think line 235 is still wrong, but I am not sure.\r\n\r\nIs the `crated/tt` in line 252 supposed to be `crates/tt`?", "tree": {"sha": "b11c4f5185719415c61cb3d137b53981d845fab5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b11c4f5185719415c61cb3d137b53981d845fab5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed35e516b13682726e4c9ee2fc3c88da6253a402", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgGsK5CRBK7hj4Ov3rIwAAdHIIAAt5ULaGLRwMX75/9j/CcwzL\n4Mpp0oZokaUDd2qncH83e09Oud4S142losEPG6qHlyk4qz4B7LcaQXYh68INkoB4\nDXCeHl0mO+84uyR5EQs1DgBmti5Rl8LtuhlUsg52Ke25pjEn/H6UxvAo7GUmoMAd\nEMBWPhQDgXmOKInmM8qEYht++1UZIiLYpeuUhvktKHqBByw/AcEnq1KP2GmuG4zE\nBrPLzNfCC8MsFHskLweue/hEA8nU66Uv4riEUgMvdXW7QvvqU3ppe6NE7sNslXZ2\naa1U7ZU/Fy/vNgLevFx9If6SlKv8ZX/EhX8oSIm16lCFQZhJ79WUEzM5RHOx1VQ=\n=Bb7R\n-----END PGP SIGNATURE-----\n", "payload": "tree b11c4f5185719415c61cb3d137b53981d845fab5\nparent fd84df9e1bb231f7aa4bcf760e0aff0a6bd10e9f\nauthor Kushagra Gupta <39802979+Kushagra-0801@users.noreply.github.com> 1612366521 +0530\ncommitter GitHub <noreply@github.com> 1612366521 +0530\n\nGrammar fixes\n\nI think line 235 is still wrong, but I am not sure.\r\n\r\nIs the `crated/tt` in line 252 supposed to be `crates/tt`?"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed35e516b13682726e4c9ee2fc3c88da6253a402", "html_url": "https://github.com/rust-lang/rust/commit/ed35e516b13682726e4c9ee2fc3c88da6253a402", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed35e516b13682726e4c9ee2fc3c88da6253a402/comments", "author": {"login": "Kushagra-0801", "id": 39802979, "node_id": "MDQ6VXNlcjM5ODAyOTc5", "avatar_url": "https://avatars.githubusercontent.com/u/39802979?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kushagra-0801", "html_url": "https://github.com/Kushagra-0801", "followers_url": "https://api.github.com/users/Kushagra-0801/followers", "following_url": "https://api.github.com/users/Kushagra-0801/following{/other_user}", "gists_url": "https://api.github.com/users/Kushagra-0801/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kushagra-0801/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kushagra-0801/subscriptions", "organizations_url": "https://api.github.com/users/Kushagra-0801/orgs", "repos_url": "https://api.github.com/users/Kushagra-0801/repos", "events_url": "https://api.github.com/users/Kushagra-0801/events{/privacy}", "received_events_url": "https://api.github.com/users/Kushagra-0801/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fd84df9e1bb231f7aa4bcf760e0aff0a6bd10e9f", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd84df9e1bb231f7aa4bcf760e0aff0a6bd10e9f", "html_url": "https://github.com/rust-lang/rust/commit/fd84df9e1bb231f7aa4bcf760e0aff0a6bd10e9f"}], "stats": {"total": 40, "additions": 20, "deletions": 20}, "files": [{"sha": "9e21d7c83c202034c208d7672e28d41c509f6d1f", "filename": "docs/dev/architecture.md", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ed35e516b13682726e4c9ee2fc3c88da6253a402/docs%2Fdev%2Farchitecture.md", "raw_url": "https://github.com/rust-lang/rust/raw/ed35e516b13682726e4c9ee2fc3c88da6253a402/docs%2Fdev%2Farchitecture.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2Farchitecture.md?ref=ed35e516b13682726e4c9ee2fc3c88da6253a402", "patch": "@@ -9,9 +9,9 @@ Yet another resource is this playlist with videos about various parts of the ana\n \n https://www.youtube.com/playlist?list=PL85XCvVPmGQho7MZkdW-wtPtuJcFpzycE\n \n-Note that the guide and videos are pretty dated, this document should be in generally fresher.\n+Note that the guide and videos are pretty dated, this document should be, in general, fresher.\n \n-See also this implementation-oriented blog posts:\n+See also these implementation-related blog posts:\n \n * https://rust-analyzer.github.io/blog/2019/11/13/find-usages.html\n * https://rust-analyzer.github.io/blog/2020/07/20/three-architectures-for-responsive-ide.html\n@@ -27,9 +27,9 @@ On the highest level, rust-analyzer is a thing which accepts input source code f\n \n More specifically, input data consists of a set of test files (`(PathBuf, String)` pairs) and information about project structure, captured in the so called `CrateGraph`.\n The crate graph specifies which files are crate roots, which cfg flags are specified for each crate and what dependencies exist between the crates.\n-This the input (ground) state.\n+This is the input (ground) state.\n The analyzer keeps all this input data in memory and never does any IO.\n-Because the input data are source code, which typically measures in tens of megabytes at most, keeping everything in memory is OK.\n+Because the input data is source code, which typically measures in tens of megabytes at most, keeping everything in memory is OK.\n \n A \"structured semantic model\" is basically an object-oriented representation of modules, functions and types which appear in the source code.\n This representation is fully \"resolved\": all expressions have types, all references are bound to declarations, etc.\n@@ -42,7 +42,7 @@ The underlying engine makes sure that model is computed lazily (on-demand) and c\n \n ## Code Map\n \n-This section talks briefly about various important directories an data structures.\n+This section talks briefly about various important directories and data structures.\n Pay attention to the **Architecture Invariant** sections.\n They often talk about things which are deliberately absent in the source code.\n \n@@ -62,7 +62,7 @@ VS Code plugin.\n ### `libs/`\n \n rust-analyzer independent libraries which we publish to crates.io.\n-It not heavily utilized at the moment.\n+It's not heavily utilized at the moment.\n \n ### `crates/parser`\n \n@@ -110,8 +110,8 @@ in particular: it shows off various methods of working with syntax tree.\n \n See [#93](https://github.com/rust-analyzer/rust-analyzer/pull/93) for an example PR which fixes a bug in the grammar.\n \n-**Architecture Invariant:** `syntax` crate is completely independent from the rest of rust-analyzer, it knows nothing about salsa or LSP.\n-This is important because it is possible to useful tooling using only syntax tree.\n+**Architecture Invariant:** `syntax` crate is completely independent from the rest of rust-analyzer. It knows nothing about salsa or LSP.\n+This is important because it is possible to make useful tooling using only the syntax tree.\n Without semantic information, you don't need to be able to _build_ code, which makes the tooling more robust.\n See also https://web.stanford.edu/~mlfbrown/paper.pdf.\n You can view the `syntax` crate as an entry point to rust-analyzer.\n@@ -122,7 +122,7 @@ The tree is fully determined by the contents of its syntax nodes, it doesn't nee\n Using the tree as a store for semantic info is convenient in traditional compilers, but doesn't work nicely in the IDE.\n Specifically, assists and refactors require transforming syntax trees, and that becomes awkward if you need to do something with the semantic info.\n \n-**Architecture Invariant:** syntax tree is build for a single file.\n+**Architecture Invariant:** syntax tree is built for a single file.\n This is to enable parallel parsing of all files.\n \n **Architecture Invariant:**  Syntax trees are by design incomplete and do not enforce well-formedness.\n@@ -131,7 +131,7 @@ If an AST method returns an `Option`, it *can* be `None` at runtime, even if thi\n ### `crates/base_db`\n \n We use the [salsa](https://github.com/salsa-rs/salsa) crate for incremental and on-demand computation.\n-Roughly, you can think of salsa as a key-value store, but it also can compute derived values using specified functions. The `base_db` crate provides basic infrastructure for interacting with salsa.\n+Roughly, you can think of salsa as a key-value store, but it can also compute derived values using specified functions. The `base_db` crate provides basic infrastructure for interacting with salsa.\n Crucially, it defines most of the \"input\" queries: facts supplied by the client of the analyzer.\n Reading the docs of the `base_db::input` module should be useful: everything else is strictly derived from those inputs.\n \n@@ -160,11 +160,11 @@ These crates also define various intermediate representations of the core.\n \n `Body` stores information about expressions.\n \n-**Architecture Invariant:** this crates are not, and will never be, an api boundary.\n+**Architecture Invariant:** these crates are not, and will never be, an api boundary.\n \n-**Architecture Invariant:** these creates explicitly care about being incremental.\n+**Architecture Invariant:** these crates explicitly care about being incremental.\n The core invariant we maintain is \"typing inside a function's body never invalidates global derived data\".\n-Ie, if you change body of `foo`, all facts about `bar` should remain intact.\n+IE, if you change the body of `foo`, all facts about `bar` should remain intact.\n \n **Architecture Invariant:** hir exists only in context of particular crate instance with specific CFG flags.\n The same syntax may produce several instances of HIR if the crate participates in the crate graph more than once.\n@@ -188,12 +188,12 @@ We first resolve the parent _syntax_ node to the parent _hir_ element.\n Then we ask the _hir_ parent what _syntax_ children does it have.\n Then we look for our node in the set of children.\n \n-This is the heart of many IDE features, like goto definition, which start with figuring out a hir node at the cursor.\n+This is the heart of many IDE features, like goto definition, which start with figuring out the hir node at the cursor.\n This is some kind of (yet unnamed) uber-IDE pattern, as it is present in Roslyn and Kotlin as well.\n \n ### `crates/ide`\n \n-The `ide` crate build's on top of `hir` semantic model to provide high-level IDE features like completion or goto definition.\n+The `ide` crate builds on top of `hir` semantic model to provide high-level IDE features like completion or goto definition.\n It is an **API Boundary**.\n If you want to use IDE parts of rust-analyzer via LSP, custom flatbuffers-based protocol or just as a library in your text editor, this is the right API.\n \n@@ -260,7 +260,7 @@ This crate is responsible for parsing, evaluation and general definition of `cfg\n \n ### `crates/vfs`, `crates/vfs-notify`\n \n-These crates implement a virtual fils system.\n+These crates implement a virtual file system.\n They provide consistent snapshots of the underlying file system and insulate messy OS paths.\n \n **Architecture Invariant:** vfs doesn't assume a single unified file system.\n@@ -319,7 +319,7 @@ That is, rust-analyzer requires unwinding.\n \n ### Testing\n \n-Rust Analyzer has three interesting [systems boundaries](https://www.tedinski.com/2018/04/10/making-tests-a-positive-influence-on-design.html) to concentrate tests on.\n+Rust Analyzer has three interesting [system boundaries](https://www.tedinski.com/2018/04/10/making-tests-a-positive-influence-on-design.html) to concentrate tests on.\n \n The outermost boundary is the `rust-analyzer` crate, which defines an LSP interface in terms of stdio.\n We do integration testing of this component, by feeding it with a stream of LSP requests and checking responses.\n@@ -328,8 +328,8 @@ For this reason, we try to avoid writing too many tests on this boundary: in a s\n Heavy tests are only run when `RUN_SLOW_TESTS` env var is set.\n \n The middle, and most important, boundary is `ide`.\n-Unlike `rust-analyzer`, which exposes API, `ide` uses Rust API and is intended to use by various tools.\n-Typical test creates an `AnalysisHost`, calls some `Analysis` functions and compares the results against expectation.\n+Unlike `rust-analyzer`, which exposes API, `ide` uses Rust API and is intended for use by various tools.\n+A typical test creates an `AnalysisHost`, calls some `Analysis` functions and compares the results against expectation.\n \n The innermost and most elaborate boundary is `hir`.\n It has a much richer vocabulary of types than `ide`, but the basic testing setup is the same: we create a database, run some queries, assert result.\n@@ -343,7 +343,7 @@ See the `marks` module in the `test_utils` crate for more.\n All required library code must be a part of the tests.\n This ensures fast test execution.\n \n-**Architecture Invariant:** tests are data driven and do not test API.\n+**Architecture Invariant:** tests are data driven and do not test the API.\n Tests which directly call various API functions are a liability, because they make refactoring the API significantly more complicated.\n So most of the tests look like this:\n "}]}