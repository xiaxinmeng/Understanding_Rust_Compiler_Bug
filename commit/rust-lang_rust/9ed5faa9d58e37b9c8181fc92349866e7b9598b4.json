{"sha": "9ed5faa9d58e37b9c8181fc92349866e7b9598b4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllZDVmYWE5ZDU4ZTM3YjljODE4MWZjOTIzNDk4NjZlN2I5NTk4YjQ=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-10-08T13:29:09Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-10-08T13:34:54Z"}, "message": "Document the new more conservative dropck rule and the escape hatch.", "tree": {"sha": "0570af5cda1f069b91ccfd90c409e4df07d4b9d7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0570af5cda1f069b91ccfd90c409e4df07d4b9d7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9ed5faa9d58e37b9c8181fc92349866e7b9598b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9ed5faa9d58e37b9c8181fc92349866e7b9598b4", "html_url": "https://github.com/rust-lang/rust/commit/9ed5faa9d58e37b9c8181fc92349866e7b9598b4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9ed5faa9d58e37b9c8181fc92349866e7b9598b4/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "73f35cfb240667518c8636fb8c8ca2a9679c4f2b", "url": "https://api.github.com/repos/rust-lang/rust/commits/73f35cfb240667518c8636fb8c8ca2a9679c4f2b", "html_url": "https://github.com/rust-lang/rust/commit/73f35cfb240667518c8636fb8c8ca2a9679c4f2b"}], "stats": {"total": 157, "additions": 152, "deletions": 5}, "files": [{"sha": "5b83433ba3e02a381a79a0cbb0b8bb4cd32400b4", "filename": "src/doc/nomicon/dropck.md", "status": "modified", "additions": 152, "deletions": 5, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/9ed5faa9d58e37b9c8181fc92349866e7b9598b4/src%2Fdoc%2Fnomicon%2Fdropck.md", "raw_url": "https://github.com/rust-lang/rust/raw/9ed5faa9d58e37b9c8181fc92349866e7b9598b4/src%2Fdoc%2Fnomicon%2Fdropck.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fdropck.md?ref=9ed5faa9d58e37b9c8181fc92349866e7b9598b4", "patch": "@@ -115,13 +115,160 @@ section:\n **For a generic type to soundly implement drop, its generics arguments must\n strictly outlive it.**\n \n-This rule is sufficient but not necessary to satisfy the drop checker. That is,\n-if your type obeys this rule then it's definitely sound to drop. However\n-there are special cases where you can fail to satisfy this, but still\n-successfully pass the borrow checker. These are the precise rules that are\n-currently up in the air.\n+Obeying this rule is (usually) necessary to satisfy the borrow\n+checker; obeying it is sufficient but not necessary to be\n+sound. That is, if your type obeys this rule then it's definitely\n+sound to drop.\n+\n+The reason that it is not always necessary to satisfy the above rule\n+is that some Drop implementations will not access borrowed data even\n+though their type gives them the capability for such access.\n+\n+For example, this variant of the above `Inspector` example will never\n+accessed borrowed data:\n+\n+```rust,ignore\n+struct Inspector<'a>(&'a u8, &'static str);\n+\n+impl<'a> Drop for Inspector<'a> {\n+    fn drop(&mut self) {\n+        println!(\"Inspector(_, {}) knows when *not* to inspect.\", self.1);\n+    }\n+}\n+\n+fn main() {\n+    let (inspector, days);\n+    days = Box::new(1);\n+    inspector = Inspector(&days, \"gadget\");\n+    // Let's say `days` happens to get dropped first.\n+    // Even when Inspector is dropped, its destructor will not access the\n+    // borrowed `days`.\n+}\n+```\n+\n+Likewise, this variant will also never access borrowed data:\n+\n+```rust,ignore\n+use std::fmt;\n+\n+struct Inspector<T: fmt::Display>(T, &'static str);\n+\n+impl<T: fmt::Display> Drop for Inspector<T> {\n+    fn drop(&mut self) {\n+        println!(\"Inspector(_, {}) knows when *not* to inspect.\", self.1);\n+    }\n+}\n+\n+fn main() {\n+    let (inspector, days): (Inspector<&u8>, Box<u8>);\n+    days = Box::new(1);\n+    inspector = Inspector(&days, \"gadget\");\n+    // Let's say `days` happens to get dropped first.\n+    // Even when Inspector is dropped, its destructor will not access the\n+    // borrowed `days`.\n+}\n+```\n+\n+However, *both* of the above variants are rejected by the borrow\n+checker during the analysis of `fn main`, saying that `days` does not\n+live long enough.\n+\n+The reason is that the borrow checking analysis of `main` does not\n+know about the internals of each Inspector's Drop implementation.  As\n+far as the borrow checker knows while it is analyzing `main`, the body\n+of an inspector's destructor might access that borrowed data.\n+\n+Therefore, the drop checker forces all borrowed data in a value to\n+strictly outlive that value.\n+\n+# An Escape Hatch\n+\n+The precise rules that govern drop checking may be less restrictive in\n+the future.\n+\n+The current analysis is deliberately conservative; forcing all\n+borrowed data in a value to outlive that value is certainly sound.\n+\n+Future versions of the language may improve its precision (i.e. to\n+reduce the number of cases where sound code is rejected as unsafe).\n+\n+In the meantime, there is an unstable attribute that one can use to\n+assert (unsafely) that a generic type's destructor is *guaranteed* to\n+not access any expired data, even if its type gives it the capability\n+to do so.\n+\n+That attribute is called `unsafe_destructor_blind_to_params`.\n+To deploy it on the Inspector example from above, we would write:\n+\n+```rust,ignore\n+struct Inspector<'a>(&'a u8, &'static str);\n+\n+impl<'a> Drop for Inspector<'a> {\n+    #[unsafe_destructor_blind_to_params]\n+    fn drop(&mut self) {\n+        println!(\"Inspector(_, {}) knows when *not* to inspect.\", self.1);\n+    }\n+}\n+```\n+\n+This attribute has the word `unsafe` in it because the compiler is not\n+checking the implicit assertion that no potentially expired data\n+(e.g. `self.0` above) is accessed.\n+\n+It is sometimes obvious that no such access can occur, like the case above.\n+However, when dealing with a generic type parameter, such access can\n+occur indirectly. Examples of such indirect access are:\n+ * invoking a callback,\n+ * via a trait method call.\n+\n+(Future changes to the language, such as impl specialization, may add\n+other avenues for such indirect access.)\n+\n+Here is an example of invoking a callback:\n+\n+```rust,ignore\n+struct Inspector<T>(T, &'static str, Box<for <'r> fn(&'r T) -> String>);\n+\n+impl<T> Drop for Inspector<T> {\n+    fn drop(&mut self) {\n+        // The `self.2` call could access a borrow e.g. if `T` is `&'a _`.\n+        println!(\"Inspector({}, {}) unwittingly inspects expired data.\",\n+                 (self.2)(&self.0), self.1);\n+    }\n+}\n+```\n+\n+Here is an example of a trait method call:\n+\n+```rust,ignore\n+use std::fmt;\n+\n+struct Inspector<T: fmt::Display>(T, &'static str);\n+\n+impl<T: fmt::Display> Drop for Inspector<T> {\n+    fn drop(&mut self) {\n+        // There is a hidden call to `<T as Display>::fmt` below, which\n+        // could access a borrow e.g. if `T` is `&'a _`\n+        println!(\"Inspector({}, {}) unwittingly inspects expired data.\",\n+                 self.0, self.1);\n+    }\n+}\n+```\n+\n+And of course, all of these accesses could be further hidden within\n+some other method invoked by the destructor, rather than being written\n+directly within it.\n+\n+In all of the above cases where the `&'a u8` is accessed in the\n+destructor, adding the `#[unsafe_destructor_blind_to_params]`\n+attribute makes the type vulnerable to misuse that the borrower\n+checker will not catch, inviting havoc. It is better to avoid adding\n+the attribute.\n+\n+# Is that all about drop checker?\n \n It turns out that when writing unsafe code, we generally don't need to\n worry at all about doing the right thing for the drop checker. However there\n is one special case that you need to worry about, which we will look at in\n the next section.\n+"}]}