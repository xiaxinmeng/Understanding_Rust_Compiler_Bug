{"sha": "594ff51b237299565a79de323aa1ba390190e28a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5NGZmNTFiMjM3Mjk5NTY1YTc5ZGUzMjNhYTFiYTM5MDE5MGUyOGE=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-12-06T22:44:01Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-12-13T22:03:46Z"}, "message": "librbml: use unboxed closures in free functions", "tree": {"sha": "6003a42aabb3bdbd1c70089f8f04e811615583c1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6003a42aabb3bdbd1c70089f8f04e811615583c1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/594ff51b237299565a79de323aa1ba390190e28a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/594ff51b237299565a79de323aa1ba390190e28a", "html_url": "https://github.com/rust-lang/rust/commit/594ff51b237299565a79de323aa1ba390190e28a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/594ff51b237299565a79de323aa1ba390190e28a/comments", "author": null, "committer": null, "parents": [{"sha": "807c5e8c8d9a6275846e010007119ba64f42f105", "url": "https://api.github.com/repos/rust-lang/rust/commits/807c5e8c8d9a6275846e010007119ba64f42f105", "html_url": "https://github.com/rust-lang/rust/commit/807c5e8c8d9a6275846e010007119ba64f42f105"}], "stats": {"total": 25, "additions": 18, "deletions": 7}, "files": [{"sha": "28d5e1812f0902485b91062b30d7d7f61e0f435e", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/594ff51b237299565a79de323aa1ba390190e28a/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/594ff51b237299565a79de323aa1ba390190e28a/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=594ff51b237299565a79de323aa1ba390190e28a", "patch": "@@ -260,7 +260,9 @@ pub mod reader {\n         }\n     }\n \n-    pub fn docs<'a>(d: Doc<'a>, it: |uint, Doc<'a>| -> bool) -> bool {\n+    pub fn docs<F>(d: Doc, mut it: F) -> bool where\n+        F: FnMut(uint, Doc) -> bool,\n+    {\n         let mut pos = d.start;\n         while pos < d.end {\n             let elt_tag = try_or!(vuint_at(d.data, pos), false);\n@@ -274,7 +276,9 @@ pub mod reader {\n         return true;\n     }\n \n-    pub fn tagged_docs<'a>(d: Doc<'a>, tg: uint, it: |Doc<'a>| -> bool) -> bool {\n+    pub fn tagged_docs<F>(d: Doc, tg: uint, mut it: F) -> bool where\n+        F: FnMut(Doc) -> bool,\n+    {\n         let mut pos = d.start;\n         while pos < d.end {\n             let elt_tag = try_or!(vuint_at(d.data, pos), false);\n@@ -291,7 +295,9 @@ pub mod reader {\n         return true;\n     }\n \n-    pub fn with_doc_data<'a, T>(d: Doc<'a>, f: |x: &'a [u8]| -> T) -> T {\n+    pub fn with_doc_data<T, F>(d: Doc, f: F) -> T where\n+        F: FnOnce(&[u8]) -> T,\n+    {\n         f(d.data[d.start..d.end])\n     }\n \n@@ -399,8 +405,9 @@ pub mod reader {\n             Ok(r as uint)\n         }\n \n-        pub fn read_opaque<R>(&mut self,\n-                              op: |&mut Decoder<'doc>, Doc| -> DecodeResult<R>) -> DecodeResult<R> {\n+        pub fn read_opaque<R, F>(&mut self, op: F) -> DecodeResult<R> where\n+            F: FnOnce(&mut Decoder, Doc) -> DecodeResult<R>,\n+        {\n             let doc = try!(self.next_doc(EsOpaque));\n \n             let (old_parent, old_pos) = (self.parent, self.pos);\n@@ -761,7 +768,9 @@ pub mod writer {\n             Ok(r)\n         }\n \n-        pub fn wr_tag(&mut self, tag_id: uint, blk: || -> EncodeResult) -> EncodeResult {\n+        pub fn wr_tag<F>(&mut self, tag_id: uint, blk: F) -> EncodeResult where\n+            F: FnOnce() -> EncodeResult,\n+        {\n             try!(self.start_tag(tag_id));\n             try!(blk());\n             self.end_tag()\n@@ -857,7 +866,9 @@ pub mod writer {\n             else { Ok(()) }\n         }\n \n-        pub fn emit_opaque(&mut self, f: |&mut Encoder<W>| -> EncodeResult) -> EncodeResult {\n+        pub fn emit_opaque<F>(&mut self, f: F) -> EncodeResult where\n+            F: FnOnce(&mut Encoder<W>) -> EncodeResult,\n+        {\n             try!(self.start_tag(EsOpaque as uint));\n             try!(f(self));\n             self.end_tag()"}]}