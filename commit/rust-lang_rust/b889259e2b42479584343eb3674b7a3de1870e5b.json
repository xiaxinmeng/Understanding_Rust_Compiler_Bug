{"sha": "b889259e2b42479584343eb3674b7a3de1870e5b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4ODkyNTllMmI0MjQ3OTU4NDM0M2ViMzY3NGI3YTNkZTE4NzBlNWI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-11-02T22:25:31Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-11-16T18:51:36Z"}, "message": "separate impl-items from the impl in the HIR\n\nThis commit does not change how the incremental accounting is done, so\nchanges (or accessses) to an impl-item are still tagged to the enclosing\nimpl.\n\nThis commits adds the \"main guts\" of this change. It does not build on\nits own.", "tree": {"sha": "f85a495d294b6030fc84257cbbfbe376638fffca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f85a495d294b6030fc84257cbbfbe376638fffca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b889259e2b42479584343eb3674b7a3de1870e5b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b889259e2b42479584343eb3674b7a3de1870e5b", "html_url": "https://github.com/rust-lang/rust/commit/b889259e2b42479584343eb3674b7a3de1870e5b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b889259e2b42479584343eb3674b7a3de1870e5b/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "36fbf8c53cd37498e5eaadf02740e2aac87f6118", "url": "https://api.github.com/repos/rust-lang/rust/commits/36fbf8c53cd37498e5eaadf02740e2aac87f6118", "html_url": "https://github.com/rust-lang/rust/commit/36fbf8c53cd37498e5eaadf02740e2aac87f6118"}], "stats": {"total": 97, "additions": 86, "deletions": 11}, "files": [{"sha": "6d89bbba54ecde164c5fb5706d7cd2ab2e225cbc", "filename": "src/librustc/dep_graph/visit.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b889259e2b42479584343eb3674b7a3de1870e5b/src%2Flibrustc%2Fdep_graph%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b889259e2b42479584343eb3674b7a3de1870e5b/src%2Flibrustc%2Fdep_graph%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fvisit.rs?ref=b889259e2b42479584343eb3674b7a3de1870e5b", "patch": "@@ -45,6 +45,18 @@ pub fn visit_all_item_likes_in_krate<'a, 'tcx, V, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>\n             self.visitor.visit_item(i);\n             debug!(\"Ended task {:?}\", task_id);\n         }\n+\n+        fn visit_impl_item(&mut self, i: &'tcx hir::ImplItem) {\n+            // TODO -- use the def-id of the impl for now\n+            let impl_def_id = self.tcx.map.get_parent_did(i.id);\n+            let task_id = (self.dep_node_fn)(impl_def_id);\n+            let _task = self.tcx.dep_graph.in_task(task_id.clone());\n+            debug!(\"Started task {:?}\", task_id);\n+            assert!(!self.tcx.map.is_inlined_def_id(impl_def_id));\n+            self.tcx.dep_graph.read(DepNode::Hir(impl_def_id));\n+            self.visitor.visit_impl_item(i);\n+            debug!(\"Ended task {:?}\", task_id);\n+        }\n     }\n \n     let krate = tcx.dep_graph.with_ignore(|| tcx.map.krate());"}, {"sha": "5a193a0ac9420aec8cca165c85c2d1b9ec90edf1", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b889259e2b42479584343eb3674b7a3de1870e5b/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b889259e2b42479584343eb3674b7a3de1870e5b/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=b889259e2b42479584343eb3674b7a3de1870e5b", "patch": "@@ -94,7 +94,17 @@ pub trait Visitor<'v> : Sized {\n     fn visit_nested_item(&mut self, id: ItemId) {\n     }\n \n-    /// Visit the top-level item and (optionally) nested items. See\n+    /// Invoked when a nested impl item is encountered. By default, does\n+    /// nothing. If you want a deep walk, you need to override to\n+    /// fetch the item contents. But most of the time, it is easier\n+    /// (and better) to invoke `Crate::visit_all_item_likes`, which visits\n+    /// all items in the crate in some order (but doesn't respect\n+    /// nesting).\n+    #[allow(unused_variables)]\n+    fn visit_nested_impl_item(&mut self, id: ImplItemId) {\n+    }\n+\n+    /// Visit the top-level item and (optionally) nested items / impl items. See\n     /// `visit_nested_item` for details.\n     fn visit_item(&mut self, i: &'v Item) {\n         walk_item(self, i)\n@@ -359,12 +369,14 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n             visitor.visit_id(item.id);\n             visitor.visit_trait_ref(trait_ref)\n         }\n-        ItemImpl(.., ref type_parameters, ref opt_trait_reference, ref typ, ref impl_items) => {\n+        ItemImpl(.., ref type_parameters, ref opt_trait_reference, ref typ, ref impl_item_ids) => {\n             visitor.visit_id(item.id);\n             visitor.visit_generics(type_parameters);\n             walk_list!(visitor, visit_trait_ref, opt_trait_reference);\n             visitor.visit_ty(typ);\n-            walk_list!(visitor, visit_impl_item, impl_items);\n+            for &impl_item_id in impl_item_ids {\n+                visitor.visit_nested_impl_item(impl_item_id);\n+            }\n         }\n         ItemStruct(ref struct_definition, ref generics) |\n         ItemUnion(ref struct_definition, ref generics) => {"}, {"sha": "22b56604428861cd63d99907ad01710c1e2bae33", "filename": "src/librustc/hir/itemlikevisit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b889259e2b42479584343eb3674b7a3de1870e5b/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b889259e2b42479584343eb3674b7a3de1870e5b/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs?ref=b889259e2b42479584343eb3674b7a3de1870e5b", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::Item;\n+use super::{Item, ImplItem};\n use super::intravisit::Visitor;\n \n /// The \"item-like visitor\" visitor defines only the top-level methods"}, {"sha": "0731c35ff163268f3de8fee665402e3f4542ce31", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b889259e2b42479584343eb3674b7a3de1870e5b/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b889259e2b42479584343eb3674b7a3de1870e5b/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=b889259e2b42479584343eb3674b7a3de1870e5b", "patch": "@@ -105,6 +105,7 @@ impl<'a> LoweringContext<'a> {\n     fn lower_crate(&mut self, c: &Crate) -> hir::Crate {\n         struct ItemLowerer<'lcx, 'interner: 'lcx> {\n             items: BTreeMap<NodeId, hir::Item>,\n+            impl_items: BTreeMap<hir::ImplItemId, hir::ImplItem>,\n             lctx: &'lcx mut LoweringContext<'interner>,\n         }\n \n@@ -113,12 +114,20 @@ impl<'a> LoweringContext<'a> {\n                 self.items.insert(item.id, self.lctx.lower_item(item));\n                 visit::walk_item(self, item);\n             }\n+\n+            fn visit_impl_item(&mut self, item: &ImplItem) {\n+                let id = self.lctx.lower_impl_item_id(item);\n+                self.impl_items.insert(id, self.lctx.lower_impl_item(item));\n+                visit::walk_impl_item(self, item);\n+            }\n         }\n \n-        let items = {\n-            let mut item_lowerer = ItemLowerer { items: BTreeMap::new(), lctx: self };\n+        let (items, impl_items) = {\n+            let mut item_lowerer = ItemLowerer { items: BTreeMap::new(),\n+                                                 impl_items: BTreeMap::new(),\n+                                                 lctx: self };\n             visit::walk_crate(&mut item_lowerer, c);\n-            item_lowerer.items\n+            (item_lowerer.items, item_lowerer.impl_items)\n         };\n \n         hir::Crate {\n@@ -127,6 +136,7 @@ impl<'a> LoweringContext<'a> {\n             span: c.span,\n             exported_macros: c.exported_macros.iter().map(|m| self.lower_macro_def(m)).collect(),\n             items: items,\n+            impl_items: impl_items,\n         }\n     }\n \n@@ -631,7 +641,7 @@ impl<'a> LoweringContext<'a> {\n             }\n             ItemKind::Impl(unsafety, polarity, ref generics, ref ifce, ref ty, ref impl_items) => {\n                 let new_impl_items = impl_items.iter()\n-                                               .map(|item| self.lower_impl_item(item))\n+                                               .map(|item| self.lower_impl_item_id(item))\n                                                .collect();\n                 let ifce = ifce.as_ref().map(|trait_ref| self.lower_trait_ref(trait_ref));\n                 hir::ItemImpl(self.lower_unsafety(unsafety),\n@@ -707,6 +717,10 @@ impl<'a> LoweringContext<'a> {\n         })\n     }\n \n+    fn lower_impl_item_id(&mut self, i: &ImplItem) -> hir::ImplItemId {\n+        hir::ImplItemId { id: i.id }\n+    }\n+\n     fn lower_mod(&mut self, m: &Mod) -> hir::Mod {\n         hir::Mod {\n             inner: m.inner,"}, {"sha": "c629ec66ca4d918edbcf9c50913c26c9b9b6ae91", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b889259e2b42479584343eb3674b7a3de1870e5b/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b889259e2b42479584343eb3674b7a3de1870e5b/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=b889259e2b42479584343eb3674b7a3de1870e5b", "patch": "@@ -378,6 +378,15 @@ impl<'ast> Map<'ast> {\n         self.forest.krate()\n     }\n \n+    pub fn impl_item(&self, id: ImplItemId) -> &'ast ImplItem {\n+        // TODO right now this triggers a read of the whole impl\n+        self.read(id.id);\n+\n+        // NB: intentionally bypass `self.forest.krate()` so that we\n+        // do not trigger a read of the whole krate here\n+        self.forest.krate.impl_item(id)\n+    }\n+\n     /// Get the attributes on the krate. This is preferable to\n     /// invoking `krate.attrs` because it registers a tighter\n     /// dep-graph access."}, {"sha": "c9892135b1d3007781c8f308b4bb7a140a7a5633", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b889259e2b42479584343eb3674b7a3de1870e5b/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b889259e2b42479584343eb3674b7a3de1870e5b/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=b889259e2b42479584343eb3674b7a3de1870e5b", "patch": "@@ -424,13 +424,19 @@ pub struct Crate {\n     // detected, which in turn can make compile-fail tests yield\n     // slightly different results.\n     pub items: BTreeMap<NodeId, Item>,\n+\n+    pub impl_items: BTreeMap<ImplItemId, ImplItem>,\n }\n \n impl Crate {\n     pub fn item(&self, id: NodeId) -> &Item {\n         &self.items[&id]\n     }\n \n+    pub fn impl_item(&self, id: ImplItemId) -> &ImplItem {\n+        &self.impl_items[&id]\n+    }\n+\n     /// Visits all items in the crate in some determinstic (but\n     /// unspecified) order. If you just need to process every item,\n     /// but don't care about nesting, this method is the best choice.\n@@ -445,6 +451,10 @@ impl Crate {\n         for (_, item) in &self.items {\n             visitor.visit_item(item);\n         }\n+\n+        for (_, impl_item) in &self.impl_items {\n+            visitor.visit_impl_item(impl_item);\n+        }\n     }\n }\n \n@@ -1042,6 +1052,14 @@ pub enum TraitItem_ {\n     TypeTraitItem(TyParamBounds, Option<P<Ty>>),\n }\n \n+// The bodies for items are stored \"out of line\", in a separate\n+// hashmap in the `Crate`. Here we just record the node-id of the item\n+// so it can fetched later.\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct ImplItemId {\n+    pub id: NodeId,\n+}\n+\n /// Represents anything within an `impl` block\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct ImplItem {\n@@ -1528,7 +1546,7 @@ pub enum Item_ {\n              Generics,\n              Option<TraitRef>, // (optional) trait this impl implements\n              P<Ty>, // self\n-             HirVec<ImplItem>),\n+             HirVec<ImplItemId>),\n }\n \n impl Item_ {"}, {"sha": "ed274b5a23ef270d0beb0d6400017d3fb92cb902", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b889259e2b42479584343eb3674b7a3de1870e5b/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b889259e2b42479584343eb3674b7a3de1870e5b/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=b889259e2b42479584343eb3674b7a3de1870e5b", "patch": "@@ -808,8 +808,8 @@ impl<'a> State<'a> {\n                 space(&mut self.s)?;\n                 self.bopen()?;\n                 self.print_inner_attributes(&item.attrs)?;\n-                for impl_item in impl_items {\n-                    self.print_impl_item(impl_item)?;\n+                for &impl_item in impl_items {\n+                    self.print_impl_item_id(impl_item)?;\n                 }\n                 self.bclose(item.span)?;\n             }\n@@ -1020,6 +1020,16 @@ impl<'a> State<'a> {\n         self.ann.post(self, NodeSubItem(ti.id))\n     }\n \n+    pub fn print_impl_item_id(&mut self, item_id: hir::ImplItemId) -> io::Result<()> {\n+        if let Some(krate) = self.krate {\n+            // skip nested items if krate context was not provided\n+            let item = &krate.impl_item(item_id);\n+            self.print_impl_item(item)\n+        } else {\n+            Ok(())\n+        }\n+    }\n+\n     pub fn print_impl_item(&mut self, ii: &hir::ImplItem) -> io::Result<()> {\n         self.ann.pre(self, NodeSubItem(ii.id))?;\n         self.hardbreak_if_not_bol()?;"}]}