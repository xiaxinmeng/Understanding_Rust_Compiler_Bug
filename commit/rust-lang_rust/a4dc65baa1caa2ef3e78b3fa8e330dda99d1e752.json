{"sha": "a4dc65baa1caa2ef3e78b3fa8e330dda99d1e752", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0ZGM2NWJhYTFjYWEyZWYzZTc4YjNmYThlMzMwZGRhOTlkMWU3NTI=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-01-11T23:07:48Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-01-14T23:49:53Z"}, "message": "syntax/rustc: Eliminate some bad copies\n\nr=pcwalton", "tree": {"sha": "c6cd09c3f05c8f00bb358d938aa1305894cdf96d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c6cd09c3f05c8f00bb358d938aa1305894cdf96d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a4dc65baa1caa2ef3e78b3fa8e330dda99d1e752", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a4dc65baa1caa2ef3e78b3fa8e330dda99d1e752", "html_url": "https://github.com/rust-lang/rust/commit/a4dc65baa1caa2ef3e78b3fa8e330dda99d1e752", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a4dc65baa1caa2ef3e78b3fa8e330dda99d1e752/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ca369e9dc5f6ea0ba0c38d047e8d931badfc82c", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ca369e9dc5f6ea0ba0c38d047e8d931badfc82c", "html_url": "https://github.com/rust-lang/rust/commit/0ca369e9dc5f6ea0ba0c38d047e8d931badfc82c"}], "stats": {"total": 204, "additions": 103, "deletions": 101}, "files": [{"sha": "723a97795f82ddcd3bbfd84cd59c17249ad0a2a2", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 62, "deletions": 62, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/a4dc65baa1caa2ef3e78b3fa8e330dda99d1e752/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4dc65baa1caa2ef3e78b3fa8e330dda99d1e752/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=a4dc65baa1caa2ef3e78b3fa8e330dda99d1e752", "patch": "@@ -457,32 +457,32 @@ mod write {\n  *\n  */\n \n-fn build_link_meta(sess: Session, c: ast::crate, output: &Path,\n+fn build_link_meta(sess: Session, c: &ast::crate, output: &Path,\n                    symbol_hasher: &hash::State) -> link_meta {\n \n     type provided_metas =\n-        {name: Option<~str>,\n-         vers: Option<~str>,\n+        {name: Option<@str>,\n+         vers: Option<@str>,\n          cmh_items: ~[@ast::meta_item]};\n \n-    fn provided_link_metas(sess: Session, c: ast::crate) ->\n+    fn provided_link_metas(sess: Session, c: &ast::crate) ->\n        provided_metas {\n-        let mut name: Option<~str> = None;\n-        let mut vers: Option<~str> = None;\n-        let mut cmh_items: ~[@ast::meta_item] = ~[];\n-        let linkage_metas =\n-            attr::find_linkage_metas(/*bad*/copy c.node.attrs);\n-        // XXX: Bad copy.\n-        attr::require_unique_names(sess.diagnostic(), copy linkage_metas);\n+        let mut name = None;\n+        let mut vers = None;\n+        let mut cmh_items = ~[];\n+        let linkage_metas = attr::find_linkage_metas(c.node.attrs);\n+        attr::require_unique_names(sess.diagnostic(), linkage_metas);\n         for linkage_metas.each |meta| {\n             if attr::get_meta_item_name(*meta) == ~\"name\" {\n                 match attr::get_meta_item_value_str(*meta) {\n-                  Some(ref v) => { name = Some((/*bad*/copy *v)); }\n+                  // Changing attr would avoid the need for the copy\n+                  // here\n+                  Some(v) => { name = Some(v.to_managed()); }\n                   None => cmh_items.push(*meta)\n                 }\n             } else if attr::get_meta_item_name(*meta) == ~\"vers\" {\n                 match attr::get_meta_item_value_str(*meta) {\n-                  Some(ref v) => { vers = Some((/*bad*/copy *v)); }\n+                  Some(v) => { vers = Some(v.to_managed()); }\n                   None => cmh_items.push(*meta)\n                 }\n             } else { cmh_items.push(*meta); }\n@@ -492,9 +492,8 @@ fn build_link_meta(sess: Session, c: ast::crate, output: &Path,\n \n     // This calculates CMH as defined above\n     fn crate_meta_extras_hash(symbol_hasher: &hash::State,\n-                              _crate: ast::crate,\n-                              metas: provided_metas,\n-                              dep_hashes: ~[~str]) -> ~str {\n+                              -cmh_items: ~[@ast::meta_item],\n+                              dep_hashes: ~[~str]) -> @str {\n         fn len_and_str(s: ~str) -> ~str {\n             return fmt!(\"%u_%s\", str::len(s), s);\n         }\n@@ -503,7 +502,7 @@ fn build_link_meta(sess: Session, c: ast::crate, output: &Path,\n             return len_and_str(pprust::lit_to_str(@l));\n         }\n \n-        let cmh_items = attr::sort_meta_items(/*bad*/copy metas.cmh_items);\n+        let cmh_items = attr::sort_meta_items(cmh_items);\n \n         symbol_hasher.reset();\n         for cmh_items.each |m| {\n@@ -526,52 +525,53 @@ fn build_link_meta(sess: Session, c: ast::crate, output: &Path,\n             symbol_hasher.write_str(len_and_str(*dh));\n         }\n \n-        return truncated_hash_result(symbol_hasher);\n+    // tjc: allocation is unfortunate; need to change core::hash\n+        return truncated_hash_result(symbol_hasher).to_managed();\n     }\n \n-    fn warn_missing(sess: Session, name: ~str, default: ~str) {\n+    fn warn_missing(sess: Session, name: &str, default: &str) {\n         if !sess.building_library { return; }\n         sess.warn(fmt!(\"missing crate link meta `%s`, using `%s` as default\",\n                        name, default));\n     }\n \n-    fn crate_meta_name(sess: Session, _crate: ast::crate,\n-                       output: &Path, metas: provided_metas) -> ~str {\n-        return match metas.name {\n-              Some(ref v) => (/*bad*/copy *v),\n+    fn crate_meta_name(sess: Session, output: &Path, -opt_name: Option<@str>)\n+        -> @str {\n+        return match opt_name {\n+              Some(v) => v,\n               None => {\n-                let name = match output.filestem() {\n-                  None => sess.fatal(fmt!(\"output file name `%s` doesn't\\\n+                // to_managed could go away if there was a version of\n+                // filestem that returned an @str\n+                let name = session::expect(sess,\n+                                  output.filestem(),\n+                                  || fmt!(\"output file name `%s` doesn't\\\n                                            appear to have a stem\",\n-                                          output.to_str())),\n-                  Some(ref s) => (/*bad*/copy *s)\n-                };\n-                // XXX: Bad copy.\n-                warn_missing(sess, ~\"name\", copy name);\n+                                          output.to_str())).to_managed();\n+                warn_missing(sess, ~\"name\", name);\n                 name\n               }\n             };\n     }\n \n-    fn crate_meta_vers(sess: Session, _crate: ast::crate,\n-                       metas: provided_metas) -> ~str {\n-        return match metas.vers {\n-              Some(ref v) => (/*bad*/copy *v),\n+    fn crate_meta_vers(sess: Session, opt_vers: Option<@str>) -> @str {\n+        return match opt_vers {\n+              Some(v) => v,\n               None => {\n-                let vers = ~\"0.0\";\n-                // Bad copy.\n-                warn_missing(sess, ~\"vers\", copy vers);\n+                let vers = @\"0.0\";\n+                warn_missing(sess, ~\"vers\", vers);\n                 vers\n               }\n             };\n     }\n \n-    let provided_metas = provided_link_metas(sess, c);\n-    let name = crate_meta_name(sess, c, output, provided_metas);\n-    let vers = crate_meta_vers(sess, c, provided_metas);\n+    let {name: opt_name, vers: opt_vers,\n+         cmh_items: cmh_items} = provided_link_metas(sess, c);\n+    let name = crate_meta_name(sess, output, move opt_name);\n+    let vers = crate_meta_vers(sess, move opt_vers);\n     let dep_hashes = cstore::get_dep_hashes(sess.cstore);\n     let extras_hash =\n-        crate_meta_extras_hash(symbol_hasher, c, provided_metas, dep_hashes);\n+        crate_meta_extras_hash(symbol_hasher, move cmh_items,\n+                               dep_hashes);\n \n     return {name: name, vers: vers, extras_hash: extras_hash};\n }\n@@ -583,7 +583,7 @@ fn truncated_hash_result(symbol_hasher: &hash::State) -> ~str unsafe {\n \n // This calculates STH for a symbol, as defined above\n fn symbol_hash(tcx: ty::ctxt, symbol_hasher: &hash::State, t: ty::t,\n-               link_meta: link_meta) -> ~str {\n+               link_meta: link_meta) -> @str {\n     // NB: do *not* use abbrevs here as we want the symbol names\n     // to be independent of one another in the crate.\n \n@@ -593,20 +593,20 @@ fn symbol_hash(tcx: ty::ctxt, symbol_hasher: &hash::State, t: ty::t,\n     symbol_hasher.write_str(link_meta.extras_hash);\n     symbol_hasher.write_str(~\"-\");\n     symbol_hasher.write_str(encoder::encoded_ty(tcx, t));\n-    let hash = truncated_hash_result(symbol_hasher);\n+    let mut hash = truncated_hash_result(symbol_hasher);\n     // Prefix with _ so that it never blends into adjacent digits\n-\n-    return ~\"_\" + hash;\n+    str::unshift_char(&mut hash, '_');\n+    // tjc: allocation is unfortunate; need to change core::hash\n+    hash.to_managed()\n }\n \n-fn get_symbol_hash(ccx: @crate_ctxt, t: ty::t) -> ~str {\n+fn get_symbol_hash(ccx: @crate_ctxt, t: ty::t) -> @str {\n     match ccx.type_hashcodes.find(t) {\n-      Some(ref h) => return (/*bad*/copy *h),\n+      Some(h) => h,\n       None => {\n         let hash = symbol_hash(ccx.tcx, ccx.symbol_hasher, t, ccx.link_meta);\n-        // XXX: Bad copy. Prefer `@str`?\n-        ccx.type_hashcodes.insert(t, copy hash);\n-        return hash;\n+        ccx.type_hashcodes.insert(t, hash);\n+        hash\n       }\n     }\n }\n@@ -664,30 +664,30 @@ fn mangle(sess: Session, ss: path) -> ~str {\n \n fn exported_name(sess: Session,\n                  +path: path,\n-                 +hash: ~str,\n-                 +vers: ~str) -> ~str {\n+                 hash: &str,\n+                 vers: &str) -> ~str {\n     return mangle(sess,\n-                  vec::append_one(\n-                      vec::append_one(path, path_name(sess.ident_of(hash))),\n-                      path_name(sess.ident_of(vers))));\n+            vec::append_one(\n+            vec::append_one(path, path_name(sess.ident_of(hash.to_owned()))),\n+            path_name(sess.ident_of(vers.to_owned()))));\n }\n \n fn mangle_exported_name(ccx: @crate_ctxt, +path: path, t: ty::t) -> ~str {\n     let hash = get_symbol_hash(ccx, t);\n     return exported_name(ccx.sess, path,\n                          hash,\n-                         /*bad*/copy ccx.link_meta.vers);\n+                         ccx.link_meta.vers);\n }\n \n fn mangle_internal_name_by_type_only(ccx: @crate_ctxt,\n                                      t: ty::t,\n-                                     +name: ~str) -> ~str {\n+                                     name: &str) -> ~str {\n     let s = ppaux::ty_to_short_str(ccx.tcx, t);\n     let hash = get_symbol_hash(ccx, t);\n     return mangle(ccx.sess,\n-                  ~[path_name(ccx.sess.ident_of(name)),\n-                    path_name(ccx.sess.ident_of(s)),\n-                    path_name(ccx.sess.ident_of(hash))]);\n+        ~[path_name(ccx.sess.ident_of(name.to_owned())),\n+          path_name(ccx.sess.ident_of(s)),\n+          path_name(ccx.sess.ident_of(hash.to_owned()))]);\n }\n \n fn mangle_internal_name_by_path_and_seq(ccx: @crate_ctxt,\n@@ -706,7 +706,7 @@ fn mangle_internal_name_by_seq(ccx: @crate_ctxt, +flav: ~str) -> ~str {\n }\n \n \n-fn output_dll_filename(os: session::os, lm: &link_meta) -> ~str {\n+fn output_dll_filename(os: session::os, lm: link_meta) -> ~str {\n     let libname = fmt!(\"%s-%s-%s\", lm.name, lm.extras_hash, lm.vers);\n     let (dll_prefix, dll_suffix) = match os {\n         session::os_win32 => (win32::DLL_PREFIX, win32::DLL_SUFFIX),\n@@ -736,7 +736,7 @@ fn link_binary(sess: Session,\n     }\n \n     let output = if sess.building_library {\n-        let long_libname = output_dll_filename(sess.targ_cfg.os, &lm);\n+        let long_libname = output_dll_filename(sess.targ_cfg.os, lm);\n         debug!(\"link_meta.name:  %s\", lm.name);\n         debug!(\"long_libname: %s\", long_libname);\n         debug!(\"out_filename: %s\", out_filename.to_str());"}, {"sha": "bc30924322e459959479d4e38b3fca61bd5d4bbb", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a4dc65baa1caa2ef3e78b3fa8e330dda99d1e752/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4dc65baa1caa2ef3e78b3fa8e330dda99d1e752/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=a4dc65baa1caa2ef3e78b3fa8e330dda99d1e752", "patch": "@@ -108,8 +108,7 @@ fn default_configuration(sess: Session, +argv0: ~str, input: input) ->\n }\n \n fn append_configuration(+cfg: ast::crate_cfg, +name: ~str) -> ast::crate_cfg {\n-    // XXX: Bad copy.\n-    if attr::contains_name(copy cfg, copy name) {\n+    if attr::contains_name(cfg, name) {\n         return cfg;\n     } else {\n         return vec::append_one(cfg, attr::mk_word_item(name));"}, {"sha": "ab57359c4189e7f861b1b97a6ff5badda972bb81", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4dc65baa1caa2ef3e78b3fa8e330dda99d1e752/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4dc65baa1caa2ef3e78b3fa8e330dda99d1e752/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=a4dc65baa1caa2ef3e78b3fa8e330dda99d1e752", "patch": "@@ -297,7 +297,7 @@ fn mk_tests(cx: test_ctxt) -> @ast::item {\n \n fn is_std(cx: test_ctxt) -> bool {\n     let is_std = {\n-        let items = attr::find_linkage_metas(/*bad*/copy cx.crate.node.attrs);\n+        let items = attr::find_linkage_metas(cx.crate.node.attrs);\n         match attr::last_meta_item_value_str_by_name(items, ~\"name\") {\n           Some(~\"std\") => true,\n           _ => false"}, {"sha": "a9094cf6a48c72b76bd551938be2efdbdf2e9b52", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4dc65baa1caa2ef3e78b3fa8e330dda99d1e752/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4dc65baa1caa2ef3e78b3fa8e330dda99d1e752/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=a4dc65baa1caa2ef3e78b3fa8e330dda99d1e752", "patch": "@@ -152,5 +152,5 @@ const tag_lang_items_item: uint = 0x73;\n const tag_lang_items_item_id: uint = 0x74;\n const tag_lang_items_item_node_id: uint = 0x75;\n \n-type link_meta = {name: ~str, vers: ~str, extras_hash: ~str};\n+type link_meta = {name: @str, vers: @str, extras_hash: @str};\n "}, {"sha": "03bd63b8bf76c883e6d48b4f88ec80a9ab872c17", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a4dc65baa1caa2ef3e78b3fa8e330dda99d1e752/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4dc65baa1caa2ef3e78b3fa8e330dda99d1e752/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=a4dc65baa1caa2ef3e78b3fa8e330dda99d1e752", "patch": "@@ -191,8 +191,7 @@ fn visit_item(e: env, i: @ast::item) {\n \n fn metas_with(+ident: ~str, +key: ~str, +metas: ~[@ast::meta_item])\n     -> ~[@ast::meta_item] {\n-    // XXX: Bad copies.\n-    let name_items = attr::find_meta_items_by_name(copy metas, copy key);\n+    let name_items = attr::find_meta_items_by_name(metas, key);\n     if name_items.is_empty() {\n         vec::append_one(metas, attr::mk_name_value_item_str(key, ident))\n     } else {"}, {"sha": "05000ac85e4b0a19c078a89463b01bbbec8fcdb0", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a4dc65baa1caa2ef3e78b3fa8e330dda99d1e752/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4dc65baa1caa2ef3e78b3fa8e330dda99d1e752/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=a4dc65baa1caa2ef3e78b3fa8e330dda99d1e752", "patch": "@@ -881,7 +881,7 @@ fn encode_info_for_foreign_item(ecx: @encode_ctxt,\n }\n \n fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n-                         crate: @crate) -> ~[entry<int>] {\n+                         crate: &crate) -> ~[entry<int>] {\n     let index = @mut ~[];\n     ebml_w.start_tag(tag_items_data);\n     index.push({val: crate_node_id, pos: ebml_w.writer.tell()});\n@@ -1021,20 +1021,20 @@ fn encode_attributes(ebml_w: writer::Encoder, attrs: ~[attribute]) {\n // metadata that Rust cares about for linking crates. This attribute requires\n // 'name' and 'vers' items, so if the user didn't provide them we will throw\n // them in anyway with default values.\n-fn synthesize_crate_attrs(ecx: @encode_ctxt, crate: @crate) -> ~[attribute] {\n+fn synthesize_crate_attrs(ecx: @encode_ctxt, crate: &crate) -> ~[attribute] {\n \n     fn synthesize_link_attr(ecx: @encode_ctxt, +items: ~[@meta_item]) ->\n        attribute {\n \n-        assert (ecx.link_meta.name != ~\"\");\n-        assert (ecx.link_meta.vers != ~\"\");\n+        assert ecx.link_meta.name.is_not_empty();\n+        assert ecx.link_meta.vers.is_not_empty();\n \n         let name_item =\n             attr::mk_name_value_item_str(~\"name\",\n-                                         /*bad*/copy ecx.link_meta.name);\n+                                         ecx.link_meta.name.to_owned());\n         let vers_item =\n             attr::mk_name_value_item_str(~\"vers\",\n-                                         /*bad*/copy ecx.link_meta.vers);\n+                                         ecx.link_meta.vers.to_owned());\n \n         let other_items =\n             {\n@@ -1156,7 +1156,7 @@ fn encode_crate_dep(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n     ebml_w.end_tag();\n }\n \n-fn encode_hash(ebml_w: writer::Encoder, hash: ~str) {\n+fn encode_hash(ebml_w: writer::Encoder, hash: &str) {\n     ebml_w.start_tag(tag_crate_hash);\n     ebml_w.writer.write(str::to_bytes(hash));\n     ebml_w.end_tag();\n@@ -1169,7 +1169,7 @@ const metadata_encoding_version : &[u8] = &[0x72, //'r' as u8,\n                                             0x74, //'t' as u8,\n                                             0, 0, 0, 1 ];\n \n-fn encode_metadata(parms: encode_parms, crate: @crate) -> ~[u8] {\n+fn encode_metadata(parms: encode_parms, crate: &crate) -> ~[u8] {\n     let wr = @io::BytesWriter();\n     let stats =\n         {mut inline_bytes: 0,\n@@ -1197,7 +1197,7 @@ fn encode_metadata(parms: encode_parms, crate: @crate) -> ~[u8] {\n \n     let ebml_w = writer::Encoder(wr as io::Writer);\n \n-    encode_hash(ebml_w, /*bad*/copy ecx.link_meta.extras_hash);\n+    encode_hash(ebml_w, ecx.link_meta.extras_hash);\n \n     let mut i = wr.pos;\n     let crate_attrs = synthesize_crate_attrs(ecx, crate);"}, {"sha": "46f41b071076007761f2bb3267fbc81a40286329", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4dc65baa1caa2ef3e78b3fa8e330dda99d1e752/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4dc65baa1caa2ef3e78b3fa8e330dda99d1e752/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=a4dc65baa1caa2ef3e78b3fa8e330dda99d1e752", "patch": "@@ -77,7 +77,7 @@ fn load_library_crate(cx: ctxt) -> {ident: ~str, data: @~[u8]} {\n }\n \n fn find_library_crate(cx: ctxt) -> Option<{ident: ~str, data: @~[u8]}> {\n-    attr::require_unique_names(cx.diag, /*bad*/copy cx.metas);\n+    attr::require_unique_names(cx.diag, cx.metas);\n     find_library_crate_aux(cx, libname(cx), cx.filesearch)\n }\n "}, {"sha": "eb4d861476196f7fcdc6f0a75a05a703566246ee", "filename": "src/librustc/middle/borrowck/preserve.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a4dc65baa1caa2ef3e78b3fa8e330dda99d1e752/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4dc65baa1caa2ef3e78b3fa8e330dda99d1e752/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs?ref=a4dc65baa1caa2ef3e78b3fa8e330dda99d1e752", "patch": "@@ -106,6 +106,9 @@ priv impl &preserve_ctxt {\n             let scope_region = if self.root_ub == 0 {\n                 ty::re_static\n             } else {\n+                // Maybe if we pass in the parent instead here,\n+                // we can prevent the \"scope not found\" error\n+                debug!(\"scope_region thing: %? \", cmt.id);\n                 ty::re_scope(self.tcx().region_map.get(cmt.id))\n             };\n "}, {"sha": "dbb74da232abf2aaf6901bff791aa8e2b6617b46", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a4dc65baa1caa2ef3e78b3fa8e330dda99d1e752/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4dc65baa1caa2ef3e78b3fa8e330dda99d1e752/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=a4dc65baa1caa2ef3e78b3fa8e330dda99d1e752", "patch": "@@ -2530,7 +2530,7 @@ fn trans_constant(ccx: @crate_ctxt, it: @ast::item) {\n     }\n }\n \n-fn trans_constants(ccx: @crate_ctxt, crate: @ast::crate) {\n+fn trans_constants(ccx: @crate_ctxt, crate: &ast::crate) {\n     visit::visit_crate(\n         *crate, (),\n         visit::mk_simple_visitor(@visit::SimpleVisitor {\n@@ -2808,7 +2808,8 @@ fn decl_crate_map(sess: session::Session, mapmeta: link_meta,\n     let cstore = sess.cstore;\n     while cstore::have_crate_data(cstore, n_subcrates) { n_subcrates += 1; }\n     let mapname = if sess.building_library {\n-        mapmeta.name + ~\"_\" + mapmeta.vers + ~\"_\" + mapmeta.extras_hash\n+        mapmeta.name.to_owned() + ~\"_\" + mapmeta.vers.to_owned() + ~\"_\"\n+            + mapmeta.extras_hash.to_owned()\n     } else { ~\"toplevel\" };\n     let sym_name = ~\"_rust_crate_map_\" + mapname;\n     let arrtype = T_array(int_type, n_subcrates as uint);\n@@ -2881,7 +2882,7 @@ fn crate_ctxt_to_encode_parms(cx: @crate_ctxt) -> encoder::encode_parms {\n     };\n }\n \n-fn write_metadata(cx: @crate_ctxt, crate: @ast::crate) {\n+fn write_metadata(cx: @crate_ctxt, crate: &ast::crate) {\n     if !cx.sess.building_library { return; }\n     let encode_parms = crate_ctxt_to_encode_parms(cx);\n     let llmeta = C_bytes(encoder::encode_metadata(encode_parms, crate));\n@@ -2919,12 +2920,11 @@ fn trans_crate(sess: session::Session,\n                tcx: ty::ctxt,\n                output: &Path,\n                emap2: resolve::ExportMap2,\n-               maps: astencode::maps)\n-            -> (ModuleRef, link_meta) {\n+               maps: astencode::maps) -> (ModuleRef, link_meta) {\n \n     let symbol_hasher = @hash::default_state();\n     let link_meta =\n-        link::build_link_meta(sess, *crate, output, symbol_hasher);\n+        link::build_link_meta(sess, crate, output, symbol_hasher);\n     let reachable = reachable::find_reachable(crate.node.module, emap2, tcx,\n                                               maps.method_map);\n \n@@ -2936,7 +2936,7 @@ fn trans_crate(sess: session::Session,\n     // crashes if the module identifer is same as other symbols\n     // such as a function name in the module.\n     // 1. http://llvm.org/bugs/show_bug.cgi?id=11479\n-    let llmod_id = link_meta.name + ~\".rc\";\n+    let llmod_id = link_meta.name.to_owned() + ~\".rc\";\n \n     unsafe {\n         let llmod = str::as_c_str(llmod_id, |buf| {\n@@ -2985,7 +2985,7 @@ fn trans_crate(sess: session::Session,\n               reachable: reachable,\n               item_symbols: HashMap(),\n               mut main_fn: None::<ValueRef>,\n-              link_meta: copy link_meta,    // XXX: Bad copy.\n+              link_meta: link_meta,\n               enum_sizes: ty::new_ty_hash(),\n               discrims: HashMap(),\n               discrim_symbols: HashMap(),"}, {"sha": "4c89495f27a91b6fb7f70a49ab13f3903edaaf02", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4dc65baa1caa2ef3e78b3fa8e330dda99d1e752/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4dc65baa1caa2ef3e78b3fa8e330dda99d1e752/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=a4dc65baa1caa2ef3e78b3fa8e330dda99d1e752", "patch": "@@ -200,7 +200,7 @@ struct crate_ctxt {\n      names: namegen,\n      next_addrspace: addrspace_gen,\n      symbol_hasher: @hash::State,\n-     type_hashcodes: HashMap<ty::t, ~str>,\n+     type_hashcodes: HashMap<ty::t, @str>,\n      type_short_names: HashMap<ty::t, ~str>,\n      all_llvm_symbols: Set<~str>,\n      tcx: ty::ctxt,"}, {"sha": "f361981074125c7bddc9625d51f9effeda775450", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4dc65baa1caa2ef3e78b3fa8e330dda99d1e752/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4dc65baa1caa2ef3e78b3fa8e330dda99d1e752/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=a4dc65baa1caa2ef3e78b3fa8e330dda99d1e752", "patch": "@@ -173,7 +173,7 @@ fn trans_log(log_ex: @ast::expr,\n     }\n \n     let modpath = vec::append(\n-        ~[path_mod(ccx.sess.ident_of(/*bad*/copy ccx.link_meta.name))],\n+        ~[path_mod(ccx.sess.ident_of(ccx.link_meta.name.to_owned()))],\n         bcx.fcx.path.filtered(|e|\n             match *e { path_mod(_) => true, _ => false }\n         ));"}, {"sha": "66e5ef55df059b32c620e2eb4ff3ce294fd42ef6", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a4dc65baa1caa2ef3e78b3fa8e330dda99d1e752/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4dc65baa1caa2ef3e78b3fa8e330dda99d1e752/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=a4dc65baa1caa2ef3e78b3fa8e330dda99d1e752", "patch": "@@ -2284,10 +2284,10 @@ fn type_kind_ext(cx: ctxt, ty: t, allow_ty_var: bool) -> Kind {\n       ty_enum(did, ref substs) => {\n         let mut lowest = kind_top();\n         let variants = enum_variants(cx, did);\n-        if vec::len(*variants) == 0u {\n+        if variants.is_empty() {\n             lowest = kind_owned_only() | kind_durable();\n         } else {\n-            for vec::each(*variants) |variant| {\n+            for variants.each |variant| {\n                 for variant.args.each |aty| {\n                     // Perform any type parameter substitutions.\n                     let arg_ty = subst(cx, substs, *aty);"}, {"sha": "264aa89583d7f3e6590106afbe1b02db1b0c51d3", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a4dc65baa1caa2ef3e78b3fa8e330dda99d1e752/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4dc65baa1caa2ef3e78b3fa8e330dda99d1e752/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=a4dc65baa1caa2ef3e78b3fa8e330dda99d1e752", "patch": "@@ -70,7 +70,7 @@ export require_unique_names;\n \n /* Constructors */\n \n-fn mk_name_value_item_str(name: ~str, +value: ~str) ->\n+fn mk_name_value_item_str(name: ~str, value: ~str) ->\n     @ast::meta_item {\n     let value_lit = dummy_spanned(ast::lit_str(@value));\n     return mk_name_value_item(name, value_lit);\n@@ -193,14 +193,15 @@ fn find_attrs_by_name(attrs: &[ast::attribute], name: &str) ->\n }\n \n /// Search a list of meta items and return only those with a specific name\n-fn find_meta_items_by_name(metas: ~[@ast::meta_item], name: ~str) ->\n+fn find_meta_items_by_name(metas: &[@ast::meta_item], name: &str) ->\n    ~[@ast::meta_item] {\n-    let filter = fn@(m: &@ast::meta_item) -> Option<@ast::meta_item> {\n-        if get_meta_item_name(*m) == name {\n-            option::Some(*m)\n-        } else { option::None }\n-    };\n-    return vec::filter_map(metas, filter);\n+    let mut rs = ~[];\n+    for metas.each |mi| {\n+        if name == get_meta_item_name(*mi) {\n+            rs.push(*mi)\n+        }\n+    }\n+    rs\n }\n \n /**\n@@ -237,7 +238,7 @@ fn eq(a: @ast::meta_item, b: @ast::meta_item) -> bool {\n         }\n }\n \n-fn contains_name(metas: ~[@ast::meta_item], name: ~str) -> bool {\n+fn contains_name(metas: &[@ast::meta_item], name: &str) -> bool {\n     let matches = find_meta_items_by_name(metas, name);\n     return vec::len(matches) > 0u;\n }\n@@ -323,7 +324,7 @@ fn remove_meta_items_by_name(items: ~[@ast::meta_item], name: ~str) ->\n  * From a list of crate attributes get only the meta_items that affect crate\n  * linkage\n  */\n-fn find_linkage_metas(attrs: ~[ast::attribute]) -> ~[@ast::meta_item] {\n+fn find_linkage_metas(attrs: &[ast::attribute]) -> ~[@ast::meta_item] {\n     do find_attrs_by_name(attrs, ~\"link\").flat_map |attr| {\n         match attr.node.value.node {\n             ast::meta_list(_, items) => /* FIXME (#2543) */ copy items,\n@@ -389,7 +390,7 @@ fn find_inline_attr(attrs: ~[ast::attribute]) -> inline_attr {\n \n \n fn require_unique_names(diagnostic: span_handler,\n-                        metas: ~[@ast::meta_item]) {\n+                        metas: &[@ast::meta_item]) {\n     let map = map::HashMap();\n     for metas.each |meta| {\n         let name = get_meta_item_name(*meta);"}]}