{"sha": "f37b4fe84fa2a2aac501a5e9a2f2361ffead0418", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzN2I0ZmU4NGZhMmEyYWFjNTAxYTVlOWEyZjIzNjFmZmVhZDA0MTg=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-10-20T14:15:58Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-11-15T17:22:32Z"}, "message": "put projections in RFC447 order", "tree": {"sha": "1cd43a35c5d8c949a80759fb43f0d5b73a58e6f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1cd43a35c5d8c949a80759fb43f0d5b73a58e6f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f37b4fe84fa2a2aac501a5e9a2f2361ffead0418", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f37b4fe84fa2a2aac501a5e9a2f2361ffead0418", "html_url": "https://github.com/rust-lang/rust/commit/f37b4fe84fa2a2aac501a5e9a2f2361ffead0418", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f37b4fe84fa2a2aac501a5e9a2f2361ffead0418/comments", "author": null, "committer": null, "parents": [{"sha": "a43533a1f548dad19b1b6bad573e660acc9ed88f", "url": "https://api.github.com/repos/rust-lang/rust/commits/a43533a1f548dad19b1b6bad573e660acc9ed88f", "html_url": "https://github.com/rust-lang/rust/commit/a43533a1f548dad19b1b6bad573e660acc9ed88f"}], "stats": {"total": 196, "additions": 137, "deletions": 59}, "files": [{"sha": "07edaf585f5fa4b45118080c871367cebe88fea2", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f37b4fe84fa2a2aac501a5e9a2f2361ffead0418/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f37b4fe84fa2a2aac501a5e9a2f2361ffead0418/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=f37b4fe84fa2a2aac501a5e9a2f2361ffead0418", "patch": "@@ -663,9 +663,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     {\n         // Avoid caching results that depend on more than just the trait-ref:\n         // The stack can create EvaluatedToUnknown, and closure signatures\n-        // being yet uninferred can create \"spurious\" EvaluatedToAmbig.\n+        // being yet uninferred can create \"spurious\" EvaluatedToAmbig\n+        // and EvaluatedToOk.\n         if result == EvaluatedToUnknown ||\n-            (result == EvaluatedToAmbig && trait_ref.has_closure_types())\n+            ((result == EvaluatedToAmbig || result == EvaluatedToOk)\n+             && trait_ref.has_closure_types())\n         {\n             return;\n         }\n@@ -2297,6 +2299,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                impl_def_id,\n                impl_obligations);\n \n+        // Because of RFC447, the impl-trait-ref and obligations\n+        // are sufficient to determine the impl substs, without\n+        // relying on projections in the impl-trait-ref.\n+        //\n+        // e.g. `impl<U: Tr, V: Iterator<Item=U>> Foo<<U as Tr>::T> for V`\n         impl_obligations.append(&mut substs.obligations);\n \n         VtableImplData { impl_def_id: impl_def_id,\n@@ -2933,12 +2940,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let predicates = self.tcx().lookup_predicates(def_id);\n         let predicates = predicates.instantiate(self.tcx(), substs);\n         let predicates = normalize_with_depth(self, cause.clone(), recursion_depth, &predicates);\n-        let mut predicates = self.infcx().plug_leaks(skol_map, snapshot, &predicates);\n-        let mut obligations =\n-            util::predicates_for_generics(cause,\n-                                          recursion_depth,\n-                                          &predicates.value);\n-        obligations.append(&mut predicates.obligations);\n+        let predicates = self.infcx().plug_leaks(skol_map, snapshot, &predicates);\n+\n+        let mut obligations = predicates.obligations;\n+        obligations.append(\n+            &mut util::predicates_for_generics(cause,\n+                                               recursion_depth,\n+                                               &predicates.value));\n         obligations\n     }\n "}, {"sha": "185623a4402531f794ede5b45703c65d17d3a25b", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 38, "deletions": 20, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/f37b4fe84fa2a2aac501a5e9a2f2361ffead0418/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f37b4fe84fa2a2aac501a5e9a2f2361ffead0418/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=f37b4fe84fa2a2aac501a5e9a2f2361ffead0418", "patch": "@@ -775,31 +775,33 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                       ref impl_items) => {\n             // Create generics from the generics specified in the impl head.\n             debug!(\"convert: ast_generics={:?}\", generics);\n+            let def_id = ccx.tcx.map.local_def_id(it.id);\n             let ty_generics = ty_generics_for_type_or_impl(ccx, generics);\n-            let ty_predicates = ty_generic_predicates_for_type_or_impl(ccx, generics);\n+            let mut ty_predicates = ty_generic_predicates_for_type_or_impl(ccx, generics);\n \n             debug!(\"convert: impl_bounds={:?}\", ty_predicates);\n \n             let selfty = ccx.icx(&ty_predicates).to_ty(&ExplicitRscope, &**selfty);\n             write_ty_to_tcx(tcx, it.id, selfty);\n \n-            tcx.register_item_type(ccx.tcx.map.local_def_id(it.id),\n+            tcx.register_item_type(def_id,\n                                    TypeScheme { generics: ty_generics.clone(),\n                                                 ty: selfty });\n-            tcx.predicates.borrow_mut().insert(ccx.tcx.map.local_def_id(it.id),\n-                                               ty_predicates.clone());\n             if let &Some(ref ast_trait_ref) = opt_trait_ref {\n                 tcx.impl_trait_refs.borrow_mut().insert(\n-                    ccx.tcx.map.local_def_id(it.id),\n+                    def_id,\n                     Some(astconv::instantiate_mono_trait_ref(&ccx.icx(&ty_predicates),\n                                                              &ExplicitRscope,\n                                                              ast_trait_ref,\n                                                              Some(selfty)))\n                         );\n             } else {\n-                tcx.impl_trait_refs.borrow_mut().insert(ccx.tcx.map.local_def_id(it.id), None);\n+                tcx.impl_trait_refs.borrow_mut().insert(def_id, None);\n             }\n \n+            enforce_impl_params_are_constrained(tcx, generics, &mut ty_predicates, def_id);\n+            tcx.predicates.borrow_mut().insert(def_id, ty_predicates.clone());\n+\n \n             // If there is a trait reference, treat the methods as always public.\n             // This is to work around some incorrect behavior in privacy checking:\n@@ -844,7 +846,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                                                generics: ty_generics.clone(),\n                                                ty: ty,\n                                            });\n-                    convert_associated_const(ccx, ImplContainer(ccx.tcx.map.local_def_id(it.id)),\n+                    convert_associated_const(ccx, ImplContainer(def_id),\n                                              impl_item.name, impl_item.id,\n                                              impl_item.vis.inherit_from(parent_visibility),\n                                              ty, true /* has_value */);\n@@ -861,7 +863,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n \n                     let typ = ccx.icx(&ty_predicates).to_ty(&ExplicitRscope, ty);\n \n-                    convert_associated_type(ccx, ImplContainer(ccx.tcx.map.local_def_id(it.id)),\n+                    convert_associated_type(ccx, ImplContainer(def_id),\n                                             impl_item.name, impl_item.id, impl_item.vis,\n                                             Some(typ));\n                 }\n@@ -880,7 +882,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                 }\n             });\n             convert_methods(ccx,\n-                            ImplContainer(ccx.tcx.map.local_def_id(it.id)),\n+                            ImplContainer(def_id),\n                             methods,\n                             selfty,\n                             &ty_generics,\n@@ -898,10 +900,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                 }\n             }\n \n-            enforce_impl_params_are_constrained(tcx,\n-                                                generics,\n-                                                ccx.tcx.map.local_def_id(it.id),\n-                                                impl_items);\n+            enforce_impl_lifetimes_are_constrained(tcx, generics, def_id, impl_items);\n         },\n         hir::ItemTrait(_, _, _, ref trait_items) => {\n             let trait_def = trait_def_of_item(ccx, it);\n@@ -2377,13 +2376,15 @@ fn check_method_self_type<'a, 'tcx, RS:RegionScope>(\n /// Checks that all the type parameters on an impl\n fn enforce_impl_params_are_constrained<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                              ast_generics: &hir::Generics,\n-                                             impl_def_id: DefId,\n-                                             impl_items: &[P<hir::ImplItem>])\n+                                             impl_predicates: &mut ty::GenericPredicates<'tcx>,\n+                                             impl_def_id: DefId)\n {\n     let impl_scheme = tcx.lookup_item_type(impl_def_id);\n-    let impl_predicates = tcx.lookup_predicates(impl_def_id);\n     let impl_trait_ref = tcx.impl_trait_ref(impl_def_id);\n \n+    assert!(impl_predicates.predicates.is_empty_in(FnSpace));\n+    assert!(impl_predicates.predicates.is_empty_in(SelfSpace));\n+\n     // The trait reference is an input, so find all type parameters\n     // reachable from there, to start (if this is an inherent impl,\n     // then just examine the self type).\n@@ -2393,10 +2394,10 @@ fn enforce_impl_params_are_constrained<'tcx>(tcx: &ty::ctxt<'tcx>,\n         input_parameters.extend(ctp::parameters_for_trait_ref(trait_ref));\n     }\n \n-    ctp::identify_constrained_type_params(tcx,\n-                                          impl_predicates.predicates.as_slice(),\n-                                          impl_trait_ref,\n-                                          &mut input_parameters);\n+    ctp::setup_constraining_predicates(tcx,\n+                                       impl_predicates.predicates.get_mut_slice(TypeSpace),\n+                                       impl_trait_ref,\n+                                       &mut input_parameters);\n \n     for (index, ty_param) in ast_generics.ty_params.iter().enumerate() {\n         let param_ty = ty::ParamTy { space: TypeSpace,\n@@ -2406,8 +2407,25 @@ fn enforce_impl_params_are_constrained<'tcx>(tcx: &ty::ctxt<'tcx>,\n             report_unused_parameter(tcx, ty_param.span, \"type\", &param_ty.to_string());\n         }\n     }\n+}\n \n+fn enforce_impl_lifetimes_are_constrained<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                                ast_generics: &hir::Generics,\n+                                                impl_def_id: DefId,\n+                                                impl_items: &[P<hir::ImplItem>])\n+{\n     // Every lifetime used in an associated type must be constrained.\n+    let impl_scheme = tcx.lookup_item_type(impl_def_id);\n+    let impl_predicates = tcx.lookup_predicates(impl_def_id);\n+    let impl_trait_ref = tcx.impl_trait_ref(impl_def_id);\n+\n+    let mut input_parameters: HashSet<_> =\n+        ctp::parameters_for_type(impl_scheme.ty).into_iter().collect();\n+    if let Some(ref trait_ref) = impl_trait_ref {\n+        input_parameters.extend(ctp::parameters_for_trait_ref(trait_ref));\n+    }\n+    ctp::identify_constrained_type_params(tcx,\n+        &impl_predicates.predicates.as_slice(), impl_trait_ref, &mut input_parameters);\n \n     let lifetimes_in_associated_types: HashSet<_> =\n         impl_items.iter()"}, {"sha": "39d5872b3dc7a2fcf7dba29cf2f9c3f9fc626615", "filename": "src/librustc_typeck/constrained_type_params.rs", "status": "modified", "additions": 83, "deletions": 31, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/f37b4fe84fa2a2aac501a5e9a2f2361ffead0418/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f37b4fe84fa2a2aac501a5e9a2f2361ffead0418/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fconstrained_type_params.rs?ref=f37b4fe84fa2a2aac501a5e9a2f2361ffead0418", "patch": "@@ -84,40 +84,92 @@ pub fn identify_constrained_type_params<'tcx>(_tcx: &ty::ctxt<'tcx>,\n                                               impl_trait_ref: Option<ty::TraitRef<'tcx>>,\n                                               input_parameters: &mut HashSet<Parameter>)\n {\n-    loop {\n-        let num_inputs = input_parameters.len();\n-\n-        let poly_projection_predicates = // : iterator over PolyProjectionPredicate\n-            predicates.iter()\n-                      .filter_map(|predicate| {\n-                          match *predicate {\n-                              ty::Predicate::Projection(ref data) => Some(data.clone()),\n-                              _ => None,\n-                          }\n-                      });\n-\n-        for poly_projection in poly_projection_predicates {\n-            // Note that we can skip binder here because the impl\n-            // trait ref never contains any late-bound regions.\n-            let projection = poly_projection.skip_binder();\n-\n-            // Special case: watch out for some kind of sneaky attempt\n-            // to project out an associated type defined by this very\n-            // trait.\n-            let unbound_trait_ref = &projection.projection_ty.trait_ref;\n-            if Some(unbound_trait_ref.clone()) == impl_trait_ref {\n-                continue;\n-            }\n+    let mut predicates = predicates.to_owned();\n+    setup_constraining_predicates(_tcx, &mut predicates, impl_trait_ref, input_parameters);\n+}\n+\n \n-            let inputs = parameters_for_trait_ref(&projection.projection_ty.trait_ref);\n-            let relies_only_on_inputs = inputs.iter().all(|p| input_parameters.contains(&p));\n-            if relies_only_on_inputs {\n+/// Order the predicates in `predicates` such that each parameter is\n+/// constrained before it is used, if that is possible, and add the\n+/// paramaters so constrained to `input_parameters`. For example,\n+/// imagine the following impl:\n+///\n+///     impl<T: Debug, U: Iterator<Item=T>> Trait for U\n+///\n+/// The impl's predicates are collected from left to right. Ignoring\n+/// the implicit `Sized` bounds, these are\n+///   * T: Debug\n+///   * U: Iterator\n+///   * <U as Iterator>::Item = T -- a desugared ProjectionPredicate\n+///\n+/// When we, for example, try to go over the trait-reference\n+/// `IntoIter<u32> as Trait`, we substitute the impl parameters with fresh\n+/// variables and match them with the impl trait-ref, so we know that\n+/// `$U = IntoIter<u32>`.\n+///\n+/// However, in order to process the `$T: Debug` predicate, we must first\n+/// know the value of `$T` - which is only given by processing the\n+/// projection. As we occasionally want to process predicates in a single\n+/// pass, we want the projection to come first. In fact, as projections\n+/// can (acyclically) depend on one another - see RFC447 for details - we\n+/// need to topologically sort them.\n+pub fn setup_constraining_predicates<'tcx>(_tcx: &ty::ctxt<'tcx>,\n+                                           predicates: &mut [ty::Predicate<'tcx>],\n+                                           impl_trait_ref: Option<ty::TraitRef<'tcx>>,\n+                                           input_parameters: &mut HashSet<Parameter>)\n+{\n+    // The canonical way of doing the needed topological sort\n+    // would be a DFS, but getting the graph and its ownership\n+    // right is annoying, so I am using an in-place fixed-point iteration,\n+    // which is `O(nt)` where `t` is the depth of type-parameter constraints,\n+    // remembering that `t` should be less than 7 in practice.\n+    //\n+    // Basically, I iterate over all projections and swap every\n+    // \"ready\" projection to the start of the list, such that\n+    // all of the projections before `i` are topologically sorted\n+    // and constrain all the parameters in `input_parameters`.\n+    //\n+    // In the example, `input_parameters` starts by containing `U` - which\n+    // is constrained by the trait-ref - and so on the first pass we\n+    // observe that `<U as Iterator>::Item = T` is a \"ready\" projection that\n+    // constrains `T` and swap it to front. As it is the sole projection,\n+    // no more swaps can take place afterwards, with the result being\n+    //   * <U as Iterator>::Item = T\n+    //   * T: Debug\n+    //   * U: Iterator\n+    let mut i = 0;\n+    let mut changed = true;\n+    while changed {\n+        changed = false;\n+\n+        for j in i..predicates.len() {\n+\n+            if let ty::Predicate::Projection(ref poly_projection) = predicates[j] {\n+                // Note that we can skip binder here because the impl\n+                // trait ref never contains any late-bound regions.\n+                let projection = poly_projection.skip_binder();\n+\n+                // Special case: watch out for some kind of sneaky attempt\n+                // to project out an associated type defined by this very\n+                // trait.\n+                let unbound_trait_ref = &projection.projection_ty.trait_ref;\n+                if Some(unbound_trait_ref.clone()) == impl_trait_ref {\n+                    continue;\n+                }\n+\n+                let inputs = parameters_for_trait_ref(&projection.projection_ty.trait_ref);\n+                let relies_only_on_inputs = inputs.iter().all(|p| input_parameters.contains(&p));\n+                if !relies_only_on_inputs {\n+                    continue;\n+                }\n                 input_parameters.extend(parameters_for_type(projection.ty));\n+            } else {\n+                continue;\n             }\n-        }\n-\n-        if input_parameters.len() == num_inputs {\n-            break;\n+            // fancy control flow to bypass borrow checker\n+            predicates.swap(i, j);\n+            i += 1;\n+            changed = true;\n         }\n     }\n }"}]}