{"sha": "9e3f0003fdc1b28c7cdaaf01956e919b6267a322", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllM2YwMDAzZmRjMWIyOGM3Y2RhYWYwMTk1NmU5MTliNjI2N2EzMjI=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2019-11-07T00:20:46Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-11-07T00:20:46Z"}, "message": "Rollup merge of #66147 - RalfJung:no-scalar-ptr, r=oli-obk\n\nMiri: Refactor to_scalar_ptr out of existence\n\n`to_scalar_ptr` is somewhat subtle as it just throws away the 2nd component of a `ScalarPair` if there is one -- without any check if this is truly a pointer or so. And indeed we used it wrong on two occasions!\n\nSo I fixed those two, and then refactored things such that everyone calls `ref_to_mplace` instead (which they did anyway, I just moved up the calls), which is the only place that should interpret a `ScalarPair` as a wide ptr -- and it checks the type first. Thus we can remove `to_scalar_ptr` and `to_meta`.\n\nr? @oli-obk", "tree": {"sha": "a4ec92d9ad11be08b8bfd0739daba4e58d7f20be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a4ec92d9ad11be08b8bfd0739daba4e58d7f20be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9e3f0003fdc1b28c7cdaaf01956e919b6267a322", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdw2NfCRBK7hj4Ov3rIwAAdHIIAK6LKf/dVCaDmWxF+v5G/z71\n7oLbdgcMy3OR+bapBixbzzoE+6nsrCpthSjApIXRnEx2N3DElJXYIlNIOJvF6lcc\nHnZyx7A43+P7kfAY0yn+0wtOMCeQzj5vAQroZ+KTOAybPj3GirCEfPMx8MC1TfTm\nsM3tPujGvGui9AENN2LhM57moOCFGDyZLot9nk2b+YihzFIWmyDGxU2zxth58opi\ntARQQzQuGdovf8Jss9ey26X/I2cLxO94OccTCF8n91yKqwHHgc9KDukMYFsy2fBR\n6yNPhe303hCPhvdWDBmmLs9/wiv2aR26RHn2wB7zRBEfpkNTkeBrZucH9tWOvuo=\n=qff9\n-----END PGP SIGNATURE-----\n", "payload": "tree a4ec92d9ad11be08b8bfd0739daba4e58d7f20be\nparent de401900b4d25b4a01c5f3e34554f9a656f89f84\nparent 2312a56f5c4e65df4b6d8128489bc58a79555718\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1573086046 +0900\ncommitter GitHub <noreply@github.com> 1573086046 +0900\n\nRollup merge of #66147 - RalfJung:no-scalar-ptr, r=oli-obk\n\nMiri: Refactor to_scalar_ptr out of existence\n\n`to_scalar_ptr` is somewhat subtle as it just throws away the 2nd component of a `ScalarPair` if there is one -- without any check if this is truly a pointer or so. And indeed we used it wrong on two occasions!\n\nSo I fixed those two, and then refactored things such that everyone calls `ref_to_mplace` instead (which they did anyway, I just moved up the calls), which is the only place that should interpret a `ScalarPair` as a wide ptr -- and it checks the type first. Thus we can remove `to_scalar_ptr` and `to_meta`.\n\nr? @oli-obk\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9e3f0003fdc1b28c7cdaaf01956e919b6267a322", "html_url": "https://github.com/rust-lang/rust/commit/9e3f0003fdc1b28c7cdaaf01956e919b6267a322", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9e3f0003fdc1b28c7cdaaf01956e919b6267a322/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de401900b4d25b4a01c5f3e34554f9a656f89f84", "url": "https://api.github.com/repos/rust-lang/rust/commits/de401900b4d25b4a01c5f3e34554f9a656f89f84", "html_url": "https://github.com/rust-lang/rust/commit/de401900b4d25b4a01c5f3e34554f9a656f89f84"}, {"sha": "2312a56f5c4e65df4b6d8128489bc58a79555718", "url": "https://api.github.com/repos/rust-lang/rust/commits/2312a56f5c4e65df4b6d8128489bc58a79555718", "html_url": "https://github.com/rust-lang/rust/commit/2312a56f5c4e65df4b6d8128489bc58a79555718"}], "stats": {"total": 106, "additions": 38, "deletions": 68}, "files": [{"sha": "2037305580ad33a23dd9c60a8ca4550cd7f3f9b1", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e3f0003fdc1b28c7cdaaf01956e919b6267a322/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3f0003fdc1b28c7cdaaf01956e919b6267a322/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=9e3f0003fdc1b28c7cdaaf01956e919b6267a322", "patch": "@@ -260,7 +260,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n         match (&src_pointee_ty.kind, &dest_pointee_ty.kind) {\n             (&ty::Array(_, length), &ty::Slice(_)) => {\n-                let ptr = self.read_immediate(src)?.to_scalar_ptr()?;\n+                let ptr = self.read_immediate(src)?.to_scalar()?;\n                 // u64 cast is from usize to u64, which is always good\n                 let val = Immediate::new_slice(\n                     ptr,\n@@ -279,7 +279,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             (_, &ty::Dynamic(ref data, _)) => {\n                 // Initial cast from sized to dyn trait\n                 let vtable = self.get_vtable(src_pointee_ty, data.principal())?;\n-                let ptr = self.read_immediate(src)?.to_scalar_ptr()?;\n+                let ptr = self.read_immediate(src)?.to_scalar()?;\n                 let val = Immediate::new_dyn_trait(ptr, vtable);\n                 self.write_immediate(val, dest)\n             }"}, {"sha": "2171ceaa452c88f9134901485a9ced9f9f9c3900", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9e3f0003fdc1b28c7cdaaf01956e919b6267a322/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3f0003fdc1b28c7cdaaf01956e919b6267a322/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=9e3f0003fdc1b28c7cdaaf01956e919b6267a322", "patch": "@@ -192,20 +192,18 @@ for\n         let ty = mplace.layout.ty;\n         if let ty::Ref(_, referenced_ty, mutability) = ty.kind {\n             let value = self.ecx.read_immediate(mplace.into())?;\n+            let mplace = self.ecx.ref_to_mplace(value)?;\n             // Handle trait object vtables\n-            if let Ok(meta) = value.to_meta() {\n-                if let ty::Dynamic(..) =\n-                    self.ecx.tcx.struct_tail_erasing_lifetimes(\n-                        referenced_ty, self.ecx.param_env).kind\n-                {\n-                    if let Ok(vtable) = meta.unwrap().to_ptr() {\n-                        // explitly choose `Immutable` here, since vtables are immutable, even\n-                        // if the reference of the fat pointer is mutable\n-                        self.intern_shallow(vtable.alloc_id, Mutability::Immutable, None)?;\n-                    }\n+            if let ty::Dynamic(..) =\n+                self.ecx.tcx.struct_tail_erasing_lifetimes(\n+                    referenced_ty, self.ecx.param_env).kind\n+            {\n+                if let Ok(vtable) = mplace.meta.unwrap().to_ptr() {\n+                    // explitly choose `Immutable` here, since vtables are immutable, even\n+                    // if the reference of the fat pointer is mutable\n+                    self.intern_shallow(vtable.alloc_id, Mutability::Immutable, None)?;\n                 }\n             }\n-            let mplace = self.ecx.ref_to_mplace(value)?;\n             // Check if we have encountered this pointer+layout combination before.\n             // Only recurse for allocation-backed pointers.\n             if let Scalar::Ptr(ptr) = mplace.ptr {\n@@ -230,7 +228,7 @@ for\n                             ty::Array(_, n)\n                                 if n.eval_usize(self.ecx.tcx.tcx, self.ecx.param_env) == 0 => {}\n                             ty::Slice(_)\n-                                if value.to_meta().unwrap().unwrap().to_usize(self.ecx)? == 0 => {}\n+                                if mplace.meta.unwrap().to_usize(self.ecx)? == 0 => {}\n                             _ => bug!(\"const qualif failed to prevent mutable references\"),\n                         }\n                     },"}, {"sha": "d80ad3848d20a79cc1bbfa11840be546154476f4", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9e3f0003fdc1b28c7cdaaf01956e919b6267a322/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3f0003fdc1b28c7cdaaf01956e919b6267a322/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=9e3f0003fdc1b28c7cdaaf01956e919b6267a322", "patch": "@@ -82,26 +82,6 @@ impl<'tcx, Tag> Immediate<Tag> {\n             Immediate::ScalarPair(a, b) => Ok((a.not_undef()?, b.not_undef()?))\n         }\n     }\n-\n-    /// Converts the immediate into a pointer (or a pointer-sized integer).\n-    /// Throws away the second half of a ScalarPair!\n-    #[inline]\n-    pub fn to_scalar_ptr(self) -> InterpResult<'tcx, Scalar<Tag>> {\n-        match self {\n-            Immediate::Scalar(ptr) |\n-            Immediate::ScalarPair(ptr, _) => ptr.not_undef(),\n-        }\n-    }\n-\n-    /// Converts the value into its metadata.\n-    /// Throws away the first half of a ScalarPair!\n-    #[inline]\n-    pub fn to_meta(self) -> InterpResult<'tcx, Option<Scalar<Tag>>> {\n-        Ok(match self {\n-            Immediate::Scalar(_) => None,\n-            Immediate::ScalarPair(_, meta) => Some(meta.not_undef()?),\n-        })\n-    }\n }\n \n // ScalarPair needs a type to interpret, so we often have an immediate and a type together"}, {"sha": "36e58d356d1004b732d078b2bb5853f13a2a8666", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9e3f0003fdc1b28c7cdaaf01956e919b6267a322/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3f0003fdc1b28c7cdaaf01956e919b6267a322/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=9e3f0003fdc1b28c7cdaaf01956e919b6267a322", "patch": "@@ -287,17 +287,23 @@ where\n         &self,\n         val: ImmTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n-        let pointee_type = val.layout.ty.builtin_deref(true).unwrap().ty;\n+        let pointee_type = val.layout.ty.builtin_deref(true)\n+            .expect(\"`ref_to_mplace` called on non-ptr type\")\n+            .ty;\n         let layout = self.layout_of(pointee_type)?;\n+        let (ptr, meta) = match *val {\n+            Immediate::Scalar(ptr) => (ptr.not_undef()?, None),\n+            Immediate::ScalarPair(ptr, meta) => (ptr.not_undef()?, Some(meta.not_undef()?)),\n+        };\n \n         let mplace = MemPlace {\n-            ptr: val.to_scalar_ptr()?,\n+            ptr,\n             // We could use the run-time alignment here. For now, we do not, because\n             // the point of tracking the alignment here is to make sure that the *static*\n             // alignment information emitted with the loads is correct. The run-time\n             // alignment can only be more restrictive.\n             align: layout.align.abi,\n-            meta: val.to_meta()?,\n+            meta,\n         };\n         Ok(MPlaceTy { mplace, layout })\n     }"}, {"sha": "8cb2f6c3462cc94083b5a342de4304805db95a29", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 15, "deletions": 29, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/9e3f0003fdc1b28c7cdaaf01956e919b6267a322/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3f0003fdc1b28c7cdaaf01956e919b6267a322/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=9e3f0003fdc1b28c7cdaaf01956e919b6267a322", "patch": "@@ -388,44 +388,31 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 }\n             }\n             ty::RawPtr(..) => {\n-                // Check pointer part.\n-                if self.ref_tracking_for_consts.is_some() {\n-                    // Integers/floats in CTFE: For consistency with integers, we do not\n-                    // accept undef.\n-                    let _ptr = try_validation!(value.to_scalar_ptr(),\n-                        \"undefined address in raw pointer\", self.path);\n-                } else {\n-                    // Remain consistent with `usize`: Accept anything.\n-                }\n-\n-                // Check metadata.\n-                let meta = try_validation!(value.to_meta(),\n-                    \"uninitialized data in wide pointer metadata\", self.path);\n-                let layout = self.ecx.layout_of(value.layout.ty.builtin_deref(true).unwrap().ty)?;\n-                if layout.is_unsized() {\n-                    self.check_wide_ptr_meta(meta, layout)?;\n+                // We are conservative with undef for integers, but try to\n+                // actually enforce our current rules for raw pointers.\n+                let place = try_validation!(self.ecx.ref_to_mplace(value),\n+                    \"undefined pointer\", self.path);\n+                if place.layout.is_unsized() {\n+                    self.check_wide_ptr_meta(place.meta, place.layout)?;\n                 }\n             }\n             _ if ty.is_box() || ty.is_region_ptr() => {\n                 // Handle wide pointers.\n                 // Check metadata early, for better diagnostics\n-                let ptr = try_validation!(value.to_scalar_ptr(),\n-                    \"undefined address in pointer\", self.path);\n-                let meta = try_validation!(value.to_meta(),\n-                    \"uninitialized data in wide pointer metadata\", self.path);\n-                let layout = self.ecx.layout_of(value.layout.ty.builtin_deref(true).unwrap().ty)?;\n-                if layout.is_unsized() {\n-                    self.check_wide_ptr_meta(meta, layout)?;\n+                let place = try_validation!(self.ecx.ref_to_mplace(value),\n+                    \"undefined pointer\", self.path);\n+                if place.layout.is_unsized() {\n+                    self.check_wide_ptr_meta(place.meta, place.layout)?;\n                 }\n                 // Make sure this is dereferencable and all.\n-                let (size, align) = self.ecx.size_and_align_of(meta, layout)?\n+                let (size, align) = self.ecx.size_and_align_of(place.meta, place.layout)?\n                     // for the purpose of validity, consider foreign types to have\n                     // alignment and size determined by the layout (size will be 0,\n                     // alignment should take attributes into account).\n-                    .unwrap_or_else(|| (layout.size, layout.align.abi));\n+                    .unwrap_or_else(|| (place.layout.size, place.layout.align.abi));\n                 let ptr: Option<_> = match\n                     self.ecx.memory.check_ptr_access_align(\n-                        ptr,\n+                        place.ptr,\n                         size,\n                         Some(align),\n                         CheckInAllocMsg::InboundsTest,\n@@ -435,7 +422,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                     Err(err) => {\n                         info!(\n                             \"{:?} did not pass access check for size {:?}, align {:?}\",\n-                            ptr, size, align\n+                            place.ptr, size, align\n                         );\n                         match err.kind {\n                             err_unsup!(InvalidNullPointerUsage) =>\n@@ -459,7 +446,6 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 };\n                 // Recursive checking\n                 if let Some(ref mut ref_tracking) = self.ref_tracking_for_consts {\n-                    let place = self.ecx.ref_to_mplace(value)?;\n                     if let Some(ptr) = ptr { // not a ZST\n                         // Skip validation entirely for some external statics\n                         let alloc_kind = self.ecx.tcx.alloc_map.lock().get(ptr.alloc_id);\n@@ -627,7 +613,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 // reject it.  However, that's good: We don't inherently want\n                 // to reject those pointers, we just do not have the machinery to\n                 // talk about parts of a pointer.\n-                // We also accept undef, for consistency with the type-based checks.\n+                // We also accept undef, for consistency with the slow path.\n                 match self.ecx.memory.get(ptr.alloc_id)?.check_bytes(\n                     self.ecx,\n                     ptr,"}, {"sha": "85fb8ac2a4a367edea8a8413d676f38ebbf22101", "filename": "src/test/ui/consts/const-eval/ub-wide-ptr.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e3f0003fdc1b28c7cdaaf01956e919b6267a322/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e3f0003fdc1b28c7cdaaf01956e919b6267a322/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.stderr?ref=9e3f0003fdc1b28c7cdaaf01956e919b6267a322", "patch": "@@ -42,7 +42,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-wide-ptr.rs:107:1\n    |\n LL | const SLICE_LENGTH_UNINIT: &[u8] = unsafe { SliceTransmute { addr: 42 }.slice};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized data in wide pointer metadata\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered undefined pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n@@ -90,7 +90,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-wide-ptr.rs:133:1\n    |\n LL | const RAW_SLICE_LENGTH_UNINIT: *const [u8] = unsafe { SliceTransmute { addr: 42 }.raw_slice};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized data in wide pointer metadata\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered undefined pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n "}]}