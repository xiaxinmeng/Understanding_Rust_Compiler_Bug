{"sha": "f496ab6a6fa5c7c71c4fd0cc8b134c60455ec5a9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0OTZhYjZhNmZhNWM3YzcxYzRmZDBjYzhiMTM0YzYwNDU1ZWM1YTk=", "commit": {"author": {"name": "Florian Zeitz", "email": "florob@babelmonkeys.de", "date": "2014-03-15T20:50:44Z"}, "committer": {"name": "Florian Zeitz", "email": "florob@babelmonkeys.de", "date": "2014-03-15T23:01:49Z"}, "message": "num: Slightly optimize bigint", "tree": {"sha": "b40f99501a3ed2baf0c7cbd2ed0505740ac94c24", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b40f99501a3ed2baf0c7cbd2ed0505740ac94c24"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f496ab6a6fa5c7c71c4fd0cc8b134c60455ec5a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f496ab6a6fa5c7c71c4fd0cc8b134c60455ec5a9", "html_url": "https://github.com/rust-lang/rust/commit/f496ab6a6fa5c7c71c4fd0cc8b134c60455ec5a9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f496ab6a6fa5c7c71c4fd0cc8b134c60455ec5a9/comments", "author": {"login": "Florob", "id": 133684, "node_id": "MDQ6VXNlcjEzMzY4NA==", "avatar_url": "https://avatars.githubusercontent.com/u/133684?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Florob", "html_url": "https://github.com/Florob", "followers_url": "https://api.github.com/users/Florob/followers", "following_url": "https://api.github.com/users/Florob/following{/other_user}", "gists_url": "https://api.github.com/users/Florob/gists{/gist_id}", "starred_url": "https://api.github.com/users/Florob/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Florob/subscriptions", "organizations_url": "https://api.github.com/users/Florob/orgs", "repos_url": "https://api.github.com/users/Florob/repos", "events_url": "https://api.github.com/users/Florob/events{/privacy}", "received_events_url": "https://api.github.com/users/Florob/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Florob", "id": 133684, "node_id": "MDQ6VXNlcjEzMzY4NA==", "avatar_url": "https://avatars.githubusercontent.com/u/133684?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Florob", "html_url": "https://github.com/Florob", "followers_url": "https://api.github.com/users/Florob/followers", "following_url": "https://api.github.com/users/Florob/following{/other_user}", "gists_url": "https://api.github.com/users/Florob/gists{/gist_id}", "starred_url": "https://api.github.com/users/Florob/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Florob/subscriptions", "organizations_url": "https://api.github.com/users/Florob/orgs", "repos_url": "https://api.github.com/users/Florob/repos", "events_url": "https://api.github.com/users/Florob/events{/privacy}", "received_events_url": "https://api.github.com/users/Florob/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5cd17b8150e218f2634d3ec8cebbc5d38fa16c22", "url": "https://api.github.com/repos/rust-lang/rust/commits/5cd17b8150e218f2634d3ec8cebbc5d38fa16c22", "html_url": "https://github.com/rust-lang/rust/commit/5cd17b8150e218f2634d3ec8cebbc5d38fa16c22"}], "stats": {"total": 76, "additions": 32, "deletions": 44}, "files": [{"sha": "27ab0d798028857b17e02b77563948684411ee21", "filename": "src/libnum/bigint.rs", "status": "modified", "additions": 32, "deletions": 44, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/f496ab6a6fa5c7c71c4fd0cc8b134c60455ec5a9/src%2Flibnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f496ab6a6fa5c7c71c4fd0cc8b134c60455ec5a9/src%2Flibnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fbigint.rs?ref=f496ab6a6fa5c7c71c4fd0cc8b134c60455ec5a9", "patch": "@@ -47,6 +47,7 @@ A `BigDigit` is half the size of machine word size.\n pub type BigDigit = u32;\n \n pub static ZERO_BIG_DIGIT: BigDigit = 0;\n+static ZERO_VEC: [BigDigit, ..1] = [ZERO_BIG_DIGIT];\n \n pub mod BigDigit {\n     use super::BigDigit;\n@@ -140,37 +141,28 @@ impl Num for BigUint {}\n \n impl BitAnd<BigUint, BigUint> for BigUint {\n     fn bitand(&self, other: &BigUint) -> BigUint {\n-        let new_len = cmp::min(self.data.len(), other.data.len());\n-        let anded = vec::from_fn(new_len, |i| {\n-            // i will never be less than the size of either data vector\n-            let ai = self.data[i];\n-            let bi = other.data[i];\n-            ai & bi\n-        });\n-        return BigUint::new(anded);\n+        BigUint::new(self.data.iter().zip(other.data.iter()).map(|(ai, bi)| *ai & *bi).collect())\n     }\n }\n \n impl BitOr<BigUint, BigUint> for BigUint {\n     fn bitor(&self, other: &BigUint) -> BigUint {\n-        let new_len = cmp::max(self.data.len(), other.data.len());\n-        let ored = vec::from_fn(new_len, |i| {\n-            let ai = if i < self.data.len()  { self.data[i]  } else { 0 };\n-            let bi = if i < other.data.len() { other.data[i] } else { 0 };\n-            ai | bi\n-        });\n+        let zeros = ZERO_VEC.iter().cycle();\n+        let (a, b) = if self.data.len() > other.data.len() { (self, other) } else { (other, self) };\n+        let ored = a.data.iter().zip(b.data.iter().chain(zeros)).map(\n+            |(ai, bi)| *ai | *bi\n+        ).collect();\n         return BigUint::new(ored);\n     }\n }\n \n impl BitXor<BigUint, BigUint> for BigUint {\n     fn bitxor(&self, other: &BigUint) -> BigUint {\n-        let new_len = cmp::max(self.data.len(), other.data.len());\n-        let xored = vec::from_fn(new_len, |i| {\n-            let ai = if i < self.data.len()  { self.data[i]  } else { 0 };\n-            let bi = if i < other.data.len() { other.data[i] } else { 0 };\n-            ai ^ bi\n-        });\n+        let zeros = ZERO_VEC.iter().cycle();\n+        let (a, b) = if self.data.len() > other.data.len() { (self, other) } else { (other, self) };\n+        let xored = a.data.iter().zip(b.data.iter().chain(zeros)).map(\n+            |(ai, bi)| *ai ^ *bi\n+        ).collect();\n         return BigUint::new(xored);\n     }\n }\n@@ -210,18 +202,15 @@ impl Unsigned for BigUint {}\n \n impl Add<BigUint, BigUint> for BigUint {\n     fn add(&self, other: &BigUint) -> BigUint {\n-        let new_len = cmp::max(self.data.len(), other.data.len());\n+        let zeros = ZERO_VEC.iter().cycle();\n+        let (a, b) = if self.data.len() > other.data.len() { (self, other) } else { (other, self) };\n \n         let mut carry = 0;\n-        let mut sum = vec::from_fn(new_len, |i| {\n-            let ai = if i < self.data.len()  { self.data[i]  } else { 0 };\n-            let bi = if i < other.data.len() { other.data[i] } else { 0 };\n-            let (hi, lo) = BigDigit::from_uint(\n-                (ai as uint) + (bi as uint) + (carry as uint)\n-            );\n+        let mut sum: ~[BigDigit] =  a.data.iter().zip(b.data.iter().chain(zeros)).map(|(ai, bi)| {\n+            let (hi, lo) = BigDigit::from_uint((*ai as uint) + (*bi as uint) + (carry as uint));\n             carry = hi;\n             lo\n-        });\n+        }).collect();\n         if carry != 0 { sum.push(carry); }\n         return BigUint::new(sum);\n     }\n@@ -230,22 +219,21 @@ impl Add<BigUint, BigUint> for BigUint {\n impl Sub<BigUint, BigUint> for BigUint {\n     fn sub(&self, other: &BigUint) -> BigUint {\n         let new_len = cmp::max(self.data.len(), other.data.len());\n+        let zeros = ZERO_VEC.iter().cycle();\n+        let (a, b) = (self.data.iter().chain(zeros.clone()), other.data.iter().chain(zeros));\n \n         let mut borrow = 0;\n-        let diff = vec::from_fn(new_len, |i| {\n-            let ai = if i < self.data.len()  { self.data[i]  } else { 0 };\n-            let bi = if i < other.data.len() { other.data[i] } else { 0 };\n+        let diff: ~[BigDigit] =  a.take(new_len).zip(b).map(|(ai, bi)| {\n             let (hi, lo) = BigDigit::from_uint(\n-                (BigDigit::base) +\n-                (ai as uint) - (bi as uint) - (borrow as uint)\n+                BigDigit::base + (*ai as uint) - (*bi as uint) - (borrow as uint)\n             );\n             /*\n             hi * (base) + lo == 1*(base) + ai - bi - borrow\n             => ai - bi - borrow < 0 <=> hi == 0\n             */\n             borrow = if hi == 0 { 1 } else { 0 };\n             lo\n-        });\n+        }).collect();\n \n         assert_eq!(borrow, 0);     // <=> assert!((self >= other));\n         return BigUint::new(diff);\n@@ -451,17 +439,18 @@ impl Integer for BigUint {\n                 return (Zero::zero(), Zero::zero(), (*a).clone());\n             }\n \n-            let an = a.data.slice(a.data.len() - n, a.data.len());\n+            let an = a.data.tailn(a.data.len() - n);\n             let bn = *b.data.last().unwrap();\n-            let mut d = ~[];\n+            let mut d = vec::with_capacity(an.len());\n             let mut carry = 0;\n             for elt in an.rev_iter() {\n                 let ai = BigDigit::to_uint(carry, *elt);\n                 let di = ai / (bn as uint);\n                 assert!(di < BigDigit::base);\n                 carry = (ai % (bn as uint)) as BigDigit;\n-                d = ~[di as BigDigit] + d;\n+                d.push(di as BigDigit)\n             }\n+            d.reverse();\n \n             let shift = (a.data.len() - an.len()) - (b.data.len() - 1);\n             if shift == 0 {\n@@ -506,10 +495,9 @@ impl Integer for BigUint {\n     #[inline]\n     fn is_even(&self) -> bool {\n         // Considering only the last digit.\n-        if self.data.is_empty() {\n-            true\n-        } else {\n-            self.data[0].is_even()\n+        match self.data.head() {\n+            Some(x) => x.is_even(),\n+            None => true\n         }\n     }\n \n@@ -664,12 +652,12 @@ impl ToStrRadix for BigUint {\n         if base == BigDigit::base {\n             return fill_concat(self.data, radix, max_len)\n         }\n-        return fill_concat(convert_base((*self).clone(), base), radix, max_len);\n+        return fill_concat(convert_base(self, base), radix, max_len);\n \n-        fn convert_base(n: BigUint, base: uint) -> ~[BigDigit] {\n+        fn convert_base(n: &BigUint, base: uint) -> ~[BigDigit] {\n             let divider    = FromPrimitive::from_uint(base).unwrap();\n             let mut result = ~[];\n-            let mut m      = n;\n+            let mut m      = n.clone();\n             while m >= divider {\n                 let (d, m0) = m.div_mod_floor(&divider);\n                 result.push(m0.to_uint().unwrap() as BigDigit);"}]}