{"sha": "c8f5d6d80d397334eb613cf3e414028af68f3f02", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4ZjVkNmQ4MGQzOTczMzRlYjYxM2NmM2U0MTQwMjhhZjY4ZjNmMDI=", "commit": {"author": {"name": "Sebastian Widua", "email": "seppel3210@gmail.com", "date": "2021-06-12T21:47:17Z"}, "committer": {"name": "Sebastian Widua", "email": "seppel3210@gmail.com", "date": "2021-06-12T21:47:17Z"}, "message": "Merge branch 'master' of https://github.com/rust-lang/rust", "tree": {"sha": "c859f2b8272a054cda20323f113e6ae78f73f37f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c859f2b8272a054cda20323f113e6ae78f73f37f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c8f5d6d80d397334eb613cf3e414028af68f3f02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c8f5d6d80d397334eb613cf3e414028af68f3f02", "html_url": "https://github.com/rust-lang/rust/commit/c8f5d6d80d397334eb613cf3e414028af68f3f02", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c8f5d6d80d397334eb613cf3e414028af68f3f02/comments", "author": {"login": "Seppel3210", "id": 34406239, "node_id": "MDQ6VXNlcjM0NDA2MjM5", "avatar_url": "https://avatars.githubusercontent.com/u/34406239?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Seppel3210", "html_url": "https://github.com/Seppel3210", "followers_url": "https://api.github.com/users/Seppel3210/followers", "following_url": "https://api.github.com/users/Seppel3210/following{/other_user}", "gists_url": "https://api.github.com/users/Seppel3210/gists{/gist_id}", "starred_url": "https://api.github.com/users/Seppel3210/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Seppel3210/subscriptions", "organizations_url": "https://api.github.com/users/Seppel3210/orgs", "repos_url": "https://api.github.com/users/Seppel3210/repos", "events_url": "https://api.github.com/users/Seppel3210/events{/privacy}", "received_events_url": "https://api.github.com/users/Seppel3210/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Seppel3210", "id": 34406239, "node_id": "MDQ6VXNlcjM0NDA2MjM5", "avatar_url": "https://avatars.githubusercontent.com/u/34406239?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Seppel3210", "html_url": "https://github.com/Seppel3210", "followers_url": "https://api.github.com/users/Seppel3210/followers", "following_url": "https://api.github.com/users/Seppel3210/following{/other_user}", "gists_url": "https://api.github.com/users/Seppel3210/gists{/gist_id}", "starred_url": "https://api.github.com/users/Seppel3210/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Seppel3210/subscriptions", "organizations_url": "https://api.github.com/users/Seppel3210/orgs", "repos_url": "https://api.github.com/users/Seppel3210/repos", "events_url": "https://api.github.com/users/Seppel3210/events{/privacy}", "received_events_url": "https://api.github.com/users/Seppel3210/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b5e92756b305c6ec4bdd42feddd013333eb69d63", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5e92756b305c6ec4bdd42feddd013333eb69d63", "html_url": "https://github.com/rust-lang/rust/commit/b5e92756b305c6ec4bdd42feddd013333eb69d63"}, {"sha": "da7ada584a3e5c3467b8b9f344b4a0f2a81ce32a", "url": "https://api.github.com/repos/rust-lang/rust/commits/da7ada584a3e5c3467b8b9f344b4a0f2a81ce32a", "html_url": "https://github.com/rust-lang/rust/commit/da7ada584a3e5c3467b8b9f344b4a0f2a81ce32a"}], "stats": {"total": 22440, "additions": 13792, "deletions": 8648}, "files": [{"sha": "51a670b5fbefdaf7904f1d304ea482b0543bc9a9", "filename": ".gitattributes", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/.gitattributes", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/.gitattributes", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitattributes?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -16,11 +16,3 @@ config.toml.example linguist-language=TOML\n *.ico binary\n *.woff binary\n *.woff2 binary\n-\n-# Needed as part of converting rustfmt to a subtree, can hopefully be removed later.\n-src/tools/rustfmt/tests/source/issue-3494/crlf.rs -text\n-src/tools/rustfmt/tests/source/comment_crlf_newline.rs -text\n-src/tools/rustfmt/tests/source/configs/enum_discrim_align_threshold/40.rs -text\n-src/tools/rustfmt/tests/target/issue-3494/crlf.rs -text\n-src/tools/rustfmt/tests/target/comment_crlf_newline.rs -text\n-src/tools/rustfmt/tests/target/configs/enum_discrim_align_threshold/40.rs -text"}, {"sha": "36362635b154552995070c1faaf9a3448ba71f4c", "filename": ".github/workflows/ci.yml", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yml?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -259,6 +259,11 @@ jobs:\n           - name: x86_64-gnu\n             os: ubuntu-latest-xl\n             env: {}\n+          - name: x86_64-gnu-stable\n+            env:\n+              IMAGE: x86_64-gnu\n+              RUST_CI_OVERRIDE_RELEASE_CHANNEL: stable\n+            os: ubuntu-latest-xl\n           - name: x86_64-gnu-aux\n             os: ubuntu-latest-xl\n             env: {}"}, {"sha": "de110c55a4b2c6e374a8fa15fd61470543846117", "filename": "Cargo.lock", "status": "modified", "additions": 84, "deletions": 63, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -278,6 +278,7 @@ dependencies = [\n  \"humantime 2.0.1\",\n  \"ignore\",\n  \"im-rc\",\n+ \"itertools 0.10.0\",\n  \"jobserver\",\n  \"lazy_static\",\n  \"lazycell\",\n@@ -293,7 +294,7 @@ dependencies = [\n  \"rand 0.8.3\",\n  \"rustc-workspace-hack\",\n  \"rustfix\",\n- \"semver 0.10.0\",\n+ \"semver 1.0.3\",\n  \"serde\",\n  \"serde_ignored\",\n  \"serde_json\",\n@@ -551,10 +552,10 @@ name = \"clippy\"\n version = \"0.1.54\"\n dependencies = [\n  \"cargo_metadata 0.12.0\",\n- \"clippy-mini-macro-test\",\n  \"clippy_lints\",\n  \"compiletest_rs\",\n  \"derive-new\",\n+ \"filetime\",\n  \"quote\",\n  \"regex\",\n  \"rustc-workspace-hack\",\n@@ -566,10 +567,6 @@ dependencies = [\n  \"tester\",\n ]\n \n-[[package]]\n-name = \"clippy-mini-macro-test\"\n-version = \"0.2.0\"\n-\n [[package]]\n name = \"clippy_dev\"\n version = \"0.0.1\"\n@@ -655,9 +652,9 @@ dependencies = [\n \n [[package]]\n name = \"compiler_builtins\"\n-version = \"0.1.43\"\n+version = \"0.1.45\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"65af2dcae4779003dfa91aedc6ade7bdc7ba685944e50a8b4f9380df376a4466\"\n+checksum = \"787187ae221adfcda34b03006f1617099e4ae26b50e5a4db282496014ab75837\"\n dependencies = [\n  \"cc\",\n  \"rustc-std-workspace-core\",\n@@ -1715,6 +1712,15 @@ dependencies = [\n  \"either\",\n ]\n \n+[[package]]\n+name = \"itertools\"\n+version = \"0.10.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"37d572918e350e82412fe766d24b15e6682fb2ed2bbe018280caa810397cb319\"\n+dependencies = [\n+ \"either\",\n+]\n+\n [[package]]\n name = \"itoa\"\n version = \"0.4.6\"\n@@ -1743,11 +1749,10 @@ dependencies = [\n  \"fs-err\",\n  \"getopts\",\n  \"jsonpath_lib\",\n- \"lazy_static\",\n+ \"once_cell\",\n  \"regex\",\n- \"serde\",\n  \"serde_json\",\n- \"shlex 0.1.1\",\n+ \"shlex\",\n ]\n \n [[package]]\n@@ -2128,16 +2133,16 @@ dependencies = [\n  \"serde\",\n  \"serde_derive\",\n  \"serde_json\",\n- \"shlex 1.0.0\",\n+ \"shlex\",\n  \"tempfile\",\n  \"toml\",\n ]\n \n [[package]]\n name = \"measureme\"\n-version = \"9.1.1\"\n+version = \"9.1.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"49cf14eb7d2eea897d9949b68f19e165638755e3a1a3c0941b6b6c3e00141f2c\"\n+checksum = \"78f7a41bc6f856a2cf0e95094ad5121f82500e2d9a0f3c0171d98f6566d8117d\"\n dependencies = [\n  \"log\",\n  \"memmap2\",\n@@ -2149,9 +2154,9 @@ dependencies = [\n \n [[package]]\n name = \"memchr\"\n-version = \"2.3.3\"\n+version = \"2.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3728d817d99e5ac407411fa471ff9800a778d88a24685968b36824eaf4bee400\"\n+checksum = \"b16bd47d9e329435e309c58469fe0791c2d0d1ba96ec0954152a5ae2b04387dc\"\n \n [[package]]\n name = \"memmap2\"\n@@ -2289,6 +2294,7 @@ dependencies = [\n  \"hex 0.4.2\",\n  \"libc\",\n  \"log\",\n+ \"measureme\",\n  \"rand 0.8.3\",\n  \"rustc-workspace-hack\",\n  \"rustc_version\",\n@@ -2353,6 +2359,17 @@ dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n \n+[[package]]\n+name = \"object\"\n+version = \"0.25.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f8bc1d42047cf336f0f939c99e97183cf31551bf0f2865a2ec9c8d91fd4ffb5e\"\n+dependencies = [\n+ \"crc32fast\",\n+ \"indexmap\",\n+ \"memchr\",\n+]\n+\n [[package]]\n name = \"once_cell\"\n version = \"1.7.2\"\n@@ -2845,9 +2862,9 @@ dependencies = [\n \n [[package]]\n name = \"racer\"\n-version = \"2.1.47\"\n+version = \"2.1.48\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"513c70e67444a0d62fdc581dffa521c6820942a5f08300d0864863f8d0e750e3\"\n+checksum = \"7fec2e85e7a30f8fd31b7cf288ad363b5e51fd2cb6f53b416b0cfaabd84e1ccb\"\n dependencies = [\n  \"bitflags\",\n  \"clap\",\n@@ -3071,7 +3088,7 @@ dependencies = [\n  \"anyhow\",\n  \"cargo\",\n  \"cargo-util\",\n- \"cargo_metadata 0.8.2\",\n+ \"cargo_metadata 0.12.0\",\n  \"clippy_lints\",\n  \"crossbeam-channel\",\n  \"difference\",\n@@ -3204,19 +3221,19 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_arena\"\n-version = \"718.0.0\"\n+version = \"722.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"526610f47139efa440178239553b59ea805ff57a532b4e295c71d2a9b18fd676\"\n+checksum = \"550ca1a0925d31a0af089b18c89f5adf3b286e319e3e1f1a5204c21bd2f17371\"\n dependencies = [\n  \"rustc-ap-rustc_data_structures\",\n  \"smallvec\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_ast\"\n-version = \"718.0.0\"\n+version = \"722.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"cf6a9dda0804a7243b0282e3b75a8cf4654c7a61f033e587751941e1fe39391b\"\n+checksum = \"4aa53b68080df17994a54747f7c37b0686288a670efb9ba3b382ce62e744aed2\"\n dependencies = [\n  \"bitflags\",\n  \"rustc-ap-rustc_data_structures\",\n@@ -3231,9 +3248,9 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_ast_pretty\"\n-version = \"718.0.0\"\n+version = \"722.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"82f5019be8b41a58664169fd2f4b1a37fe82705681db394b76419e4e87d40ab1\"\n+checksum = \"0ae71e68fada466a4b2c39c79ca6aee3226587abe6787170d2f6c92237569565\"\n dependencies = [\n  \"rustc-ap-rustc_ast\",\n  \"rustc-ap-rustc_span\",\n@@ -3242,9 +3259,9 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_data_structures\"\n-version = \"718.0.0\"\n+version = \"722.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a701717fb14549331085756b9741ae3b4bf35808489f1887d72c1d0e0fe52b77\"\n+checksum = \"faa484d6e0ca32d1d82303647275c696f745599b3d97e686f396ceef5b99d7ae\"\n dependencies = [\n  \"arrayvec\",\n  \"bitflags\",\n@@ -3274,9 +3291,9 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_errors\"\n-version = \"718.0.0\"\n+version = \"722.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e3182ce85e8bfc96443475547f2f5aa2b5e67655d9b88721795f36f0ba9e265a\"\n+checksum = \"5f85ba19cca320ad797e3a29c35cab9bddfff0e7adbde336a436249e54cee7b1\"\n dependencies = [\n  \"annotate-snippets\",\n  \"atty\",\n@@ -3294,31 +3311,31 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_feature\"\n-version = \"718.0.0\"\n+version = \"722.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"eed033b93270126ef60963c3ebbd0e026bf53b985172b6366c7b0e7881c9d507\"\n+checksum = \"97d538adab96b8b2b1ca9fcd4c8c47d4e23e862a23d1a38b6c15cd8fd52b34b1\"\n dependencies = [\n  \"rustc-ap-rustc_data_structures\",\n  \"rustc-ap-rustc_span\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_fs_util\"\n-version = \"718.0.0\"\n+version = \"722.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"28ee6531986a205101e09fd143d7bf31897388f33b1814d4bcc45fd62211dca6\"\n+checksum = \"8ad6f13d240944fa8f360d2f3b849a7cadaec75e477829e7dde61e838deda83d\"\n \n [[package]]\n name = \"rustc-ap-rustc_graphviz\"\n-version = \"718.0.0\"\n+version = \"722.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3398fddc0e23d2db89c036f8952ddf78cadc597f7059752116e69483e164a5b6\"\n+checksum = \"08b3451153cc5828c02cc4f1a0df146d25ac4b3382a112e25fd9d3f5bff15cdc\"\n \n [[package]]\n name = \"rustc-ap-rustc_index\"\n-version = \"718.0.0\"\n+version = \"722.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"dca4e27eb5b701f6bbd47d8fc9d242378fca3e4107a519a28415c2989c4a3bd3\"\n+checksum = \"cd39a9f01b442c629bdff5778cb3dd29b7c2ea4afe62d5ab61d216bd1b556692\"\n dependencies = [\n  \"arrayvec\",\n  \"rustc-ap-rustc_macros\",\n@@ -3327,18 +3344,18 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_lexer\"\n-version = \"718.0.0\"\n+version = \"722.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"786bbfe9d4d5264294c1819dbf1497a2480b583d5eda1ca9ae22e12d6661f5df\"\n+checksum = \"a5de290c44a90e671d2cd730062b9ef73d11155da7e44e7741d633e1e51e616e\"\n dependencies = [\n  \"unicode-xid\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_lint_defs\"\n-version = \"718.0.0\"\n+version = \"722.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"be2f045e2b999c154ec505d5fea69c994b742f3ebd2f552d11a6c81723921e47\"\n+checksum = \"69570b4beb61088926b131579865bbe70d124d30778c46307a62ec8b310ae462\"\n dependencies = [\n  \"rustc-ap-rustc_ast\",\n  \"rustc-ap-rustc_data_structures\",\n@@ -3351,9 +3368,9 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_macros\"\n-version = \"718.0.0\"\n+version = \"722.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"27789cd26d6b9e2fdfa68a262a20664d79ca67d31a3886d40fb88ebf6935869c\"\n+checksum = \"86bd877df37f15c5a44d9679d1b5207ebc95f3943fbc336eeac670195ac58610\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -3363,9 +3380,9 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_parse\"\n-version = \"718.0.0\"\n+version = \"722.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1dc331f4958350679679e619d63a891e8d5d34ef99087068c89aa9e657d52caa\"\n+checksum = \"02502d8522ba31d0bcad28a78822b68c1b6ba947a2b4aa6a2341b30594379b80\"\n dependencies = [\n  \"bitflags\",\n  \"rustc-ap-rustc_ast\",\n@@ -3383,19 +3400,19 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_serialize\"\n-version = \"718.0.0\"\n+version = \"722.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e9a6824a462c4c1a379e911b0faf86d303a54bcf8673d4cc445195085966a4a4\"\n+checksum = \"5f741f8e9aee6323fbe127329490608a5a250cc0072ac91e684ef62518cdb1ff\"\n dependencies = [\n  \"indexmap\",\n  \"smallvec\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_session\"\n-version = \"718.0.0\"\n+version = \"722.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a782a5f6ada0dbe089c6416ad0104f0b8a8bdb4bd26ea95e5fefaec67aed5e8a\"\n+checksum = \"dba61eca749f4fced4427ad1cc7f23342cfc6527c3bcc624e3aa56abc1f81298\"\n dependencies = [\n  \"bitflags\",\n  \"getopts\",\n@@ -3415,9 +3432,9 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_span\"\n-version = \"718.0.0\"\n+version = \"722.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a257546cb264b250c7abdb81239bb02f18a274a966211755a3ea89411b122214\"\n+checksum = \"a642e8d6fc883f34e0778e079f8242ac40c6614a6b7a0ef61681333e847f5e62\"\n dependencies = [\n  \"cfg-if 0.1.10\",\n  \"md-5\",\n@@ -3435,9 +3452,9 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_target\"\n-version = \"718.0.0\"\n+version = \"722.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b5a72dd689421bcb5750f3ed0dedf367076e714ef0ba56c02ed391b9a8582862\"\n+checksum = \"80feebd8c323b80dd73a395fa7fabba9e2098b6277670ff89c473f618ffa07de\"\n dependencies = [\n  \"bitflags\",\n  \"rustc-ap-rustc_data_structures\",\n@@ -3676,6 +3693,7 @@ dependencies = [\n  \"rustc_incremental\",\n  \"rustc_index\",\n  \"rustc_llvm\",\n+ \"rustc_metadata\",\n  \"rustc_middle\",\n  \"rustc_serialize\",\n  \"rustc_session\",\n@@ -3695,7 +3713,7 @@ dependencies = [\n  \"itertools 0.9.0\",\n  \"jobserver\",\n  \"libc\",\n- \"object\",\n+ \"object 0.25.2\",\n  \"pathdiff\",\n  \"rustc_apfloat\",\n  \"rustc_ast\",\n@@ -4673,6 +4691,15 @@ dependencies = [\n  \"serde\",\n ]\n \n+[[package]]\n+name = \"semver\"\n+version = \"1.0.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"5f3aac57ee7f3272d8395c6e4f502f434f0e289fcd62876f70daa008c20dcabe\"\n+dependencies = [\n+ \"serde\",\n+]\n+\n [[package]]\n name = \"semver-parser\"\n version = \"0.7.0\"\n@@ -4793,12 +4820,6 @@ version = \"0.1.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"45bb67a18fa91266cc7807181f62f9178a6873bfad7dc788c42e6430db40184f\"\n \n-[[package]]\n-name = \"shlex\"\n-version = \"0.1.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7fdf1b9db47230893d76faad238fd6097fd6d6a9245cd7a4d90dbd639536bbd2\"\n-\n [[package]]\n name = \"shlex\"\n version = \"1.0.0\"\n@@ -4903,7 +4924,7 @@ dependencies = [\n  \"hermit-abi\",\n  \"libc\",\n  \"miniz_oxide\",\n- \"object\",\n+ \"object 0.22.0\",\n  \"panic_abort\",\n  \"panic_unwind\",\n  \"profiler_builtins\",\n@@ -5032,9 +5053,9 @@ dependencies = [\n \n [[package]]\n name = \"tar\"\n-version = \"0.4.33\"\n+version = \"0.4.35\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c0bcfbd6a598361fda270d82469fff3d65089dc33e175c9a131f7b4cd395f228\"\n+checksum = \"7d779dc6aeff029314570f666ec83f19df7280bb36ef338442cfa8c604021b80\"\n dependencies = [\n  \"filetime\",\n  \"libc\","}, {"sha": "93d7a597681339e3cfddea236667e67f4a371667", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -623,12 +623,13 @@ impl Pat {\n             PatKind::Ident(_, _, Some(p)) => p.walk(it),\n \n             // Walk into each field of struct.\n-            PatKind::Struct(_, fields, _) => fields.iter().for_each(|field| field.pat.walk(it)),\n+            PatKind::Struct(_, _, fields, _) => fields.iter().for_each(|field| field.pat.walk(it)),\n \n             // Sequence of patterns.\n-            PatKind::TupleStruct(_, s) | PatKind::Tuple(s) | PatKind::Slice(s) | PatKind::Or(s) => {\n-                s.iter().for_each(|p| p.walk(it))\n-            }\n+            PatKind::TupleStruct(_, _, s)\n+            | PatKind::Tuple(s)\n+            | PatKind::Slice(s)\n+            | PatKind::Or(s) => s.iter().for_each(|p| p.walk(it)),\n \n             // Trivial wrappers over inner patterns.\n             PatKind::Box(s) | PatKind::Ref(s, _) | PatKind::Paren(s) => s.walk(it),\n@@ -701,10 +702,10 @@ pub enum PatKind {\n \n     /// A struct or struct variant pattern (e.g., `Variant {x, y, ..}`).\n     /// The `bool` is `true` in the presence of a `..`.\n-    Struct(Path, Vec<PatField>, /* recovered */ bool),\n+    Struct(Option<QSelf>, Path, Vec<PatField>, /* recovered */ bool),\n \n     /// A tuple struct/variant pattern (`Variant(x, y, .., z)`).\n-    TupleStruct(Path, Vec<P<Pat>>),\n+    TupleStruct(Option<QSelf>, Path, Vec<P<Pat>>),\n \n     /// An or-pattern `A | B | C`.\n     /// Invariant: `pats.len() >= 2`.\n@@ -1247,6 +1248,7 @@ pub enum StructRest {\n \n #[derive(Clone, Encodable, Decodable, Debug)]\n pub struct StructExpr {\n+    pub qself: Option<QSelf>,\n     pub path: Path,\n     pub fields: Vec<ExprField>,\n     pub rest: StructRest,"}, {"sha": "d586426d70ef053c4825ee567eb7289b2e48c18e", "filename": "compiler/rustc_ast/src/ast_like.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_ast%2Fsrc%2Fast_like.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_ast%2Fsrc%2Fast_like.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast_like.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -82,7 +82,8 @@ impl AstLike for crate::token::Nonterminal {\n             Nonterminal::NtMeta(attr_item) => attr_item.tokens_mut(),\n             Nonterminal::NtPath(path) => path.tokens_mut(),\n             Nonterminal::NtVis(vis) => vis.tokens_mut(),\n-            _ => panic!(\"Called tokens_mut on {:?}\", self),\n+            Nonterminal::NtBlock(block) => block.tokens_mut(),\n+            Nonterminal::NtIdent(..) | Nonterminal::NtLifetime(..) | Nonterminal::NtTT(..) => None,\n         }\n     }\n }"}, {"sha": "7c79b4aab3cce78596397f1e56ed3f09c9d33966", "filename": "compiler/rustc_ast/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Flib.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -12,13 +12,11 @@\n #![feature(box_patterns)]\n #![cfg_attr(bootstrap, feature(const_fn_unsize))]\n #![feature(const_fn_transmute)]\n-#![feature(const_panic)]\n #![feature(crate_visibility_modifier)]\n #![feature(iter_zip)]\n #![feature(label_break_value)]\n #![feature(nll)]\n #![feature(min_specialization)]\n-#![feature(trusted_step)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "0b6099fd330dad615198553db46362b523bfe637", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -1139,15 +1139,17 @@ pub fn noop_visit_pat<T: MutVisitor>(pat: &mut P<Pat>, vis: &mut T) {\n             visit_opt(sub, |sub| vis.visit_pat(sub));\n         }\n         PatKind::Lit(e) => vis.visit_expr(e),\n-        PatKind::TupleStruct(path, elems) => {\n+        PatKind::TupleStruct(qself, path, elems) => {\n+            vis.visit_qself(qself);\n             vis.visit_path(path);\n             visit_vec(elems, |elem| vis.visit_pat(elem));\n         }\n         PatKind::Path(qself, path) => {\n             vis.visit_qself(qself);\n             vis.visit_path(path);\n         }\n-        PatKind::Struct(path, fields, _etc) => {\n+        PatKind::Struct(qself, path, fields, _etc) => {\n+            vis.visit_qself(qself);\n             vis.visit_path(path);\n             fields.flat_map_in_place(|field| vis.flat_map_pat_field(field));\n         }\n@@ -1333,7 +1335,8 @@ pub fn noop_visit_expr<T: MutVisitor>(\n         }\n         ExprKind::MacCall(mac) => vis.visit_mac_call(mac),\n         ExprKind::Struct(se) => {\n-            let StructExpr { path, fields, rest } = se.deref_mut();\n+            let StructExpr { qself, path, fields, rest } = se.deref_mut();\n+            vis.visit_qself(qself);\n             vis.visit_path(path);\n             fields.flat_map_in_place(|field| vis.flat_map_expr_field(field));\n             match rest {"}, {"sha": "5d994dbad4d1fcf128851668679a54ced7f92e41", "filename": "compiler/rustc_ast/src/tokenstream.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -218,8 +218,7 @@ impl AttrAnnotatedTokenStream {\n                 AttrAnnotatedTokenTree::Attributes(data) => {\n                     let mut outer_attrs = Vec::new();\n                     let mut inner_attrs = Vec::new();\n-                    let attrs: Vec<_> = data.attrs.clone().into();\n-                    for attr in attrs {\n+                    for attr in &data.attrs {\n                         match attr.style {\n                             crate::AttrStyle::Outer => {\n                                 assert!(\n@@ -264,7 +263,7 @@ impl AttrAnnotatedTokenStream {\n                                 // so we never reach this code.\n \n                                 let mut builder = TokenStreamBuilder::new();\n-                                for inner_attr in &inner_attrs {\n+                                for inner_attr in inner_attrs {\n                                     builder.push(inner_attr.tokens().to_tokenstream());\n                                 }\n                                 builder.push(delim_tokens.clone());"}, {"sha": "1ebfcf367110fb5bde6563c03a3afb1f57026bce", "filename": "compiler/rustc_ast/src/visit.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -497,7 +497,10 @@ pub fn walk_assoc_ty_constraint<'a, V: Visitor<'a>>(\n \n pub fn walk_pat<'a, V: Visitor<'a>>(visitor: &mut V, pattern: &'a Pat) {\n     match pattern.kind {\n-        PatKind::TupleStruct(ref path, ref elems) => {\n+        PatKind::TupleStruct(ref opt_qself, ref path, ref elems) => {\n+            if let Some(ref qself) = *opt_qself {\n+                visitor.visit_ty(&qself.ty);\n+            }\n             visitor.visit_path(path, pattern.id);\n             walk_list!(visitor, visit_pat, elems);\n         }\n@@ -507,7 +510,10 @@ pub fn walk_pat<'a, V: Visitor<'a>>(visitor: &mut V, pattern: &'a Pat) {\n             }\n             visitor.visit_path(path, pattern.id)\n         }\n-        PatKind::Struct(ref path, ref fields, _) => {\n+        PatKind::Struct(ref opt_qself, ref path, ref fields, _) => {\n+            if let Some(ref qself) = *opt_qself {\n+                visitor.visit_ty(&qself.ty);\n+            }\n             visitor.visit_path(path, pattern.id);\n             walk_list!(visitor, visit_pat_field, fields);\n         }\n@@ -740,6 +746,9 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n             visitor.visit_anon_const(count)\n         }\n         ExprKind::Struct(ref se) => {\n+            if let Some(ref qself) = se.qself {\n+                visitor.visit_ty(&qself.ty);\n+            }\n             visitor.visit_path(&se.path, expression.id);\n             walk_list!(visitor, visit_expr_field, &se.fields);\n             match &se.rest {"}, {"sha": "b9dcd083c0b8c9b176883851952e7cbdd3007cd9", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -237,7 +237,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     hir::ExprKind::Struct(\n                         self.arena.alloc(self.lower_qpath(\n                             e.id,\n-                            &None,\n+                            &se.qself,\n                             &se.path,\n                             ParamMode::Optional,\n                             ImplTraitContext::disallowed(),\n@@ -1041,18 +1041,20 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     /// It is not a complete check, but just tries to reject most paths early\n     /// if they are not tuple structs.\n     /// Type checking will take care of the full validation later.\n-    fn extract_tuple_struct_path<'a>(&mut self, expr: &'a Expr) -> Option<&'a Path> {\n-        // For tuple struct destructuring, it must be a non-qualified path (like in patterns).\n-        if let ExprKind::Path(None, path) = &expr.kind {\n-            // Does the path resolves to something disallowed in a tuple struct/variant pattern?\n+    fn extract_tuple_struct_path<'a>(\n+        &mut self,\n+        expr: &'a Expr,\n+    ) -> Option<(&'a Option<QSelf>, &'a Path)> {\n+        if let ExprKind::Path(qself, path) = &expr.kind {\n+            // Does the path resolve to something disallowed in a tuple struct/variant pattern?\n             if let Some(partial_res) = self.resolver.get_partial_res(expr.id) {\n                 if partial_res.unresolved_segments() == 0\n                     && !partial_res.base_res().expected_in_tuple_struct_pat()\n                 {\n                     return None;\n                 }\n             }\n-            return Some(path);\n+            return Some((qself, path));\n         }\n         None\n     }\n@@ -1088,7 +1090,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             }\n             // Tuple structs.\n             ExprKind::Call(callee, args) => {\n-                if let Some(path) = self.extract_tuple_struct_path(callee) {\n+                if let Some((qself, path)) = self.extract_tuple_struct_path(callee) {\n                     let (pats, rest) = self.destructure_sequence(\n                         args,\n                         \"tuple struct or variant\",\n@@ -1097,7 +1099,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     );\n                     let qpath = self.lower_qpath(\n                         callee.id,\n-                        &None,\n+                        qself,\n                         path,\n                         ParamMode::Optional,\n                         ImplTraitContext::disallowed(),\n@@ -1122,7 +1124,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 }));\n                 let qpath = self.lower_qpath(\n                     lhs.id,\n-                    &None,\n+                    &se.qself,\n                     &se.path,\n                     ParamMode::Optional,\n                     ImplTraitContext::disallowed(),"}, {"sha": "0ff1efd8165eae60cc5d294a41e4f95dee9a82ec", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -43,7 +43,7 @@ use rustc_ast::walk_list;\n use rustc_ast::{self as ast, *};\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::captures::Captures;\n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{struct_span_err, Applicability};\n use rustc_hir as hir;\n@@ -198,7 +198,7 @@ pub trait ResolverAstLowering {\n \n     fn next_node_id(&mut self) -> NodeId;\n \n-    fn trait_map(&self) -> &NodeMap<Vec<hir::TraitCandidate>>;\n+    fn take_trait_map(&mut self) -> NodeMap<Vec<hir::TraitCandidate>>;\n \n     fn opt_local_def_id(&self, node: NodeId) -> Option<LocalDefId>;\n \n@@ -501,14 +501,13 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let proc_macros =\n             c.proc_macros.iter().map(|id| self.node_id_to_hir_id[*id].unwrap()).collect();\n \n-        let trait_map = self\n-            .resolver\n-            .trait_map()\n-            .iter()\n-            .filter_map(|(&k, v)| {\n-                self.node_id_to_hir_id.get(k).and_then(|id| id.as_ref()).map(|id| (*id, v.clone()))\n-            })\n-            .collect();\n+        let mut trait_map: FxHashMap<_, FxHashMap<_, _>> = FxHashMap::default();\n+        for (k, v) in self.resolver.take_trait_map().into_iter() {\n+            if let Some(Some(hir_id)) = self.node_id_to_hir_id.get(k) {\n+                let map = trait_map.entry(hir_id.owner).or_default();\n+                map.insert(hir_id.local_id, v.into_boxed_slice());\n+            }\n+        }\n \n         let mut def_id_to_hir_id = IndexVec::default();\n "}, {"sha": "66e623528f3bd179a189e75414ae59fc0b063f6e", "filename": "compiler/rustc_ast_lowering/src/pat.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -21,10 +21,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         break self.lower_pat_ident(pattern, binding_mode, ident, lower_sub);\n                     }\n                     PatKind::Lit(ref e) => break hir::PatKind::Lit(self.lower_expr(e)),\n-                    PatKind::TupleStruct(ref path, ref pats) => {\n+                    PatKind::TupleStruct(ref qself, ref path, ref pats) => {\n                         let qpath = self.lower_qpath(\n                             pattern.id,\n-                            &None,\n+                            qself,\n                             path,\n                             ParamMode::Optional,\n                             ImplTraitContext::disallowed(),\n@@ -47,10 +47,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         );\n                         break hir::PatKind::Path(qpath);\n                     }\n-                    PatKind::Struct(ref path, ref fields, etc) => {\n+                    PatKind::Struct(ref qself, ref path, ref fields, etc) => {\n                         let qpath = self.lower_qpath(\n                             pattern.id,\n-                            &None,\n+                            qself,\n                             path,\n                             ParamMode::Optional,\n                             ImplTraitContext::disallowed(),"}, {"sha": "30aa51a121a80edfb2e45d05f680dfb98b750a3f", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -938,8 +938,11 @@ fn validate_generic_param_order(\n                 }\n                 GenericParamKind::Type { default: None } => (),\n                 GenericParamKind::Lifetime => (),\n-                // FIXME(const_generics_defaults)\n-                GenericParamKind::Const { ty: _, kw_span: _, default: _ } => (),\n+                GenericParamKind::Const { ty: _, kw_span: _, default: Some(default) } => {\n+                    ordered_params += \" = \";\n+                    ordered_params += &pprust::expr_to_string(&*default.value);\n+                }\n+                GenericParamKind::Const { ty: _, kw_span: _, default: None } => (),\n             }\n             first = false;\n         }\n@@ -959,7 +962,7 @@ fn validate_generic_param_order(\n             span,\n             &format!(\n                 \"reorder the parameters: lifetimes, {}\",\n-                if sess.features_untracked().const_generics {\n+                if sess.features_untracked().unordered_const_ty_params() {\n                     \"then consts and types\"\n                 } else {\n                     \"then types, then consts\""}, {"sha": "3f98944d850e7991f01393e0062da1984dcb0441", "filename": "compiler/rustc_ast_passes/src/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -318,7 +318,6 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                 }}\n \n                 gate_doc!(\n-                    include => external_doc\n                     cfg => doc_cfg\n                     masked => doc_masked\n                     notable_trait => doc_notable_trait\n@@ -706,6 +705,7 @@ pub fn check_crate(krate: &ast::Crate, sess: &Session) {\n         \"async closures are unstable\",\n         \"to use an async block, remove the `||`: `async {`\"\n     );\n+    gate_all!(more_qualified_paths, \"usage of qualified paths in this context is experimental\");\n     gate_all!(generators, \"yield syntax is experimental\");\n     gate_all!(raw_ref_op, \"raw address of syntax is experimental\");\n     gate_all!(const_trait_bound_opt_out, \"`?const` on trait bounds is experimental\");"}, {"sha": "26da18b571cc0d205fec2f4f592d0cee31b9b4d1", "filename": "compiler/rustc_ast_passes/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_ast_passes%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_ast_passes%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Flib.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -6,7 +6,6 @@\n \n #![feature(bindings_after_at)]\n #![feature(iter_is_partitioned)]\n-#![feature(box_syntax)]\n #![feature(box_patterns)]\n #![recursion_limit = \"256\"]\n "}, {"sha": "93facd255df5e3427bfe373755466ed4850dfa95", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -1713,11 +1713,16 @@ impl<'a> State<'a> {\n \n     fn print_expr_struct(\n         &mut self,\n+        qself: &Option<ast::QSelf>,\n         path: &ast::Path,\n         fields: &[ast::ExprField],\n         rest: &ast::StructRest,\n     ) {\n-        self.print_path(path, true, 0);\n+        if let Some(qself) = qself {\n+            self.print_qpath(path, qself, true);\n+        } else {\n+            self.print_path(path, true, 0);\n+        }\n         self.s.word(\"{\");\n         self.commasep_cmnt(\n             Consistent,\n@@ -1874,7 +1879,7 @@ impl<'a> State<'a> {\n                 self.print_expr_repeat(element, count);\n             }\n             ast::ExprKind::Struct(ref se) => {\n-                self.print_expr_struct(&se.path, &se.fields, &se.rest);\n+                self.print_expr_struct(&se.qself, &se.path, &se.fields, &se.rest);\n             }\n             ast::ExprKind::Tup(ref exprs) => {\n                 self.print_expr_tup(exprs);\n@@ -2340,8 +2345,12 @@ impl<'a> State<'a> {\n                     self.print_pat(p);\n                 }\n             }\n-            PatKind::TupleStruct(ref path, ref elts) => {\n-                self.print_path(path, true, 0);\n+            PatKind::TupleStruct(ref qself, ref path, ref elts) => {\n+                if let Some(qself) = qself {\n+                    self.print_qpath(path, qself, true);\n+                } else {\n+                    self.print_path(path, true, 0);\n+                }\n                 self.popen();\n                 self.commasep(Inconsistent, &elts[..], |s, p| s.print_pat(p));\n                 self.pclose();\n@@ -2355,8 +2364,12 @@ impl<'a> State<'a> {\n             PatKind::Path(Some(ref qself), ref path) => {\n                 self.print_qpath(path, qself, false);\n             }\n-            PatKind::Struct(ref path, ref fields, etc) => {\n-                self.print_path(path, true, 0);\n+            PatKind::Struct(ref qself, ref path, ref fields, etc) => {\n+                if let Some(qself) = qself {\n+                    self.print_qpath(path, qself, true);\n+                } else {\n+                    self.print_path(path, true, 0);\n+                }\n                 self.nbsp();\n                 self.word_space(\"{\");\n                 self.commasep_cmnt("}, {"sha": "99544ddb66e66f4445d7fec260b46aa435055017", "filename": "compiler/rustc_builtin_macros/src/test.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -254,6 +254,10 @@ pub fn expand_test_or_bench(\n                                         \"allow_fail\",\n                                         cx.expr_bool(sp, should_fail(&cx.sess, &item)),\n                                     ),\n+                                    // compile_fail: true | false\n+                                    field(\"compile_fail\", cx.expr_bool(sp, false)),\n+                                    // no_run: true | false\n+                                    field(\"no_run\", cx.expr_bool(sp, false)),\n                                     // should_panic: ...\n                                     field(\n                                         \"should_panic\","}, {"sha": "22897c43e7ef917cdc456010c9129d35aca97c1e", "filename": "compiler/rustc_codegen_cranelift/src/archive.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_codegen_cranelift%2Fsrc%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_codegen_cranelift%2Fsrc%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Farchive.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -254,6 +254,15 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n             }\n         }\n     }\n+\n+    fn inject_dll_import_lib(\n+        &mut self,\n+        _lib_name: &str,\n+        _dll_imports: &[rustc_middle::middle::cstore::DllImport],\n+        _tmpdir: &rustc_data_structures::temp_dir::MaybeTempDir,\n+    ) {\n+        bug!(\"injecting dll imports is not supported\");\n+    }\n }\n \n impl<'a> ArArchiveBuilder<'a> {"}, {"sha": "6676d88602c45d9e34991e80ce25e6cf158077e5", "filename": "compiler/rustc_codegen_cranelift/src/driver/aot.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -177,21 +177,6 @@ pub(crate) fn run_aot(\n     metadata: EncodedMetadata,\n     need_metadata_module: bool,\n ) -> Box<(CodegenResults, FxHashMap<WorkProductId, WorkProduct>)> {\n-    use rustc_span::symbol::sym;\n-\n-    let crate_attrs = tcx.hir().attrs(rustc_hir::CRATE_HIR_ID);\n-    let subsystem = tcx.sess.first_attr_value_str_by_name(crate_attrs, sym::windows_subsystem);\n-    let windows_subsystem = subsystem.map(|subsystem| {\n-        if subsystem != sym::windows && subsystem != sym::console {\n-            tcx.sess.fatal(&format!(\n-                \"invalid windows subsystem `{}`, only \\\n-                                    `windows` and `console` are allowed\",\n-                subsystem\n-            ));\n-        }\n-        subsystem.to_string()\n-    });\n-\n     let mut work_products = FxHashMap::default();\n \n     let cgus = if tcx.sess.opts.output_types.should_codegen() {\n@@ -307,12 +292,10 @@ pub(crate) fn run_aot(\n \n     Box::new((\n         CodegenResults {\n-            crate_name: tcx.crate_name(LOCAL_CRATE),\n             modules,\n             allocator_module,\n             metadata_module,\n             metadata,\n-            windows_subsystem,\n             linker_info: LinkerInfo::new(tcx, crate::target_triple(tcx.sess).to_string()),\n             crate_info: CrateInfo::new(tcx),\n         },"}, {"sha": "6aadaf8a7cadcea9ce47d930099a987a4c9b8d43", "filename": "compiler/rustc_codegen_cranelift/src/lib.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -14,6 +14,7 @@ extern crate rustc_fs_util;\n extern crate rustc_hir;\n extern crate rustc_incremental;\n extern crate rustc_index;\n+extern crate rustc_metadata;\n extern crate rustc_session;\n extern crate rustc_span;\n extern crate rustc_target;\n@@ -28,8 +29,7 @@ use rustc_codegen_ssa::traits::CodegenBackend;\n use rustc_codegen_ssa::CodegenResults;\n use rustc_errors::ErrorReported;\n use rustc_middle::dep_graph::{WorkProduct, WorkProductId};\n-use rustc_middle::middle::cstore::{EncodedMetadata, MetadataLoader};\n-use rustc_middle::ty::query::Providers;\n+use rustc_middle::middle::cstore::EncodedMetadata;\n use rustc_session::config::OutputFilenames;\n use rustc_session::Session;\n \n@@ -164,17 +164,14 @@ impl CodegenBackend for CraneliftCodegenBackend {\n         }\n     }\n \n-    fn metadata_loader(&self) -> Box<dyn MetadataLoader + Sync> {\n-        Box::new(rustc_codegen_ssa::back::metadata::DefaultMetadataLoader)\n-    }\n-\n-    fn provide(&self, _providers: &mut Providers) {}\n-    fn provide_extern(&self, _providers: &mut Providers) {}\n-\n     fn target_features(&self, _sess: &Session) -> Vec<rustc_span::Symbol> {\n         vec![]\n     }\n \n+    fn print_version(&self) {\n+        println!(\"Cranelift version: {}\", cranelift_codegen::VERSION);\n+    }\n+\n     fn codegen_crate(\n         &self,\n         tcx: TyCtxt<'_>,\n@@ -222,7 +219,7 @@ impl CodegenBackend for CraneliftCodegenBackend {\n             sess,\n             &codegen_results,\n             outputs,\n-            &codegen_results.crate_name.as_str(),\n+            &codegen_results.crate_info.local_crate_name.as_str(),\n         );\n \n         Ok(())"}, {"sha": "db24bf65eb5a2e015620822b67b81592feeff024", "filename": "compiler/rustc_codegen_cranelift/src/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmetadata.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -10,7 +10,7 @@ pub(crate) fn write_metadata<O: WriteMetadata>(tcx: TyCtxt<'_>, object: &mut O)\n     use std::io::Write;\n \n     let metadata = tcx.encode_metadata();\n-    let mut compressed = tcx.metadata_encoding_version();\n+    let mut compressed = rustc_metadata::METADATA_HEADER.to_vec();\n     FrameEncoder::new(&mut compressed).write_all(&metadata.raw_data).unwrap();\n \n     object.add_rustc_section("}, {"sha": "f86236ef3eafc6eee6c6a476bb19d2fed1f13ce4", "filename": "compiler/rustc_codegen_cranelift/src/toolchain.rs", "status": "modified", "additions": 1, "deletions": 88, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_codegen_cranelift%2Fsrc%2Ftoolchain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_codegen_cranelift%2Fsrc%2Ftoolchain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Ftoolchain.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -2,9 +2,8 @@\n \n use std::path::PathBuf;\n \n-use rustc_middle::bug;\n+use rustc_codegen_ssa::back::link::linker_and_flavor;\n use rustc_session::Session;\n-use rustc_target::spec::LinkerFlavor;\n \n /// Tries to infer the path of a binary for the target toolchain from the linker name.\n pub(crate) fn get_toolchain_binary(sess: &Session, tool: &str) -> PathBuf {\n@@ -30,89 +29,3 @@ pub(crate) fn get_toolchain_binary(sess: &Session, tool: &str) -> PathBuf {\n \n     linker\n }\n-\n-// Adapted from https://github.com/rust-lang/rust/blob/5db778affee7c6600c8e7a177c48282dab3f6292/src/librustc_codegen_ssa/back/link.rs#L848-L931\n-fn linker_and_flavor(sess: &Session) -> (PathBuf, LinkerFlavor) {\n-    fn infer_from(\n-        sess: &Session,\n-        linker: Option<PathBuf>,\n-        flavor: Option<LinkerFlavor>,\n-    ) -> Option<(PathBuf, LinkerFlavor)> {\n-        match (linker, flavor) {\n-            (Some(linker), Some(flavor)) => Some((linker, flavor)),\n-            // only the linker flavor is known; use the default linker for the selected flavor\n-            (None, Some(flavor)) => Some((\n-                PathBuf::from(match flavor {\n-                    LinkerFlavor::Em => {\n-                        if cfg!(windows) {\n-                            \"emcc.bat\"\n-                        } else {\n-                            \"emcc\"\n-                        }\n-                    }\n-                    LinkerFlavor::Gcc => {\n-                        if cfg!(any(target_os = \"solaris\", target_os = \"illumos\")) {\n-                            // On historical Solaris systems, \"cc\" may have\n-                            // been Sun Studio, which is not flag-compatible\n-                            // with \"gcc\".  This history casts a long shadow,\n-                            // and many modern illumos distributions today\n-                            // ship GCC as \"gcc\" without also making it\n-                            // available as \"cc\".\n-                            \"gcc\"\n-                        } else {\n-                            \"cc\"\n-                        }\n-                    }\n-                    LinkerFlavor::Ld => \"ld\",\n-                    LinkerFlavor::Msvc => \"link.exe\",\n-                    LinkerFlavor::Lld(_) => \"lld\",\n-                    LinkerFlavor::PtxLinker => \"rust-ptx-linker\",\n-                }),\n-                flavor,\n-            )),\n-            (Some(linker), None) => {\n-                let stem = linker.file_stem().and_then(|stem| stem.to_str()).unwrap_or_else(|| {\n-                    sess.fatal(\"couldn't extract file stem from specified linker\")\n-                });\n-\n-                let flavor = if stem == \"emcc\" {\n-                    LinkerFlavor::Em\n-                } else if stem == \"gcc\"\n-                    || stem.ends_with(\"-gcc\")\n-                    || stem == \"clang\"\n-                    || stem.ends_with(\"-clang\")\n-                {\n-                    LinkerFlavor::Gcc\n-                } else if stem == \"ld\" || stem == \"ld.lld\" || stem.ends_with(\"-ld\") {\n-                    LinkerFlavor::Ld\n-                } else if stem == \"link\" || stem == \"lld-link\" {\n-                    LinkerFlavor::Msvc\n-                } else if stem == \"lld\" || stem == \"rust-lld\" {\n-                    LinkerFlavor::Lld(sess.target.lld_flavor)\n-                } else {\n-                    // fall back to the value in the target spec\n-                    sess.target.linker_flavor\n-                };\n-\n-                Some((linker, flavor))\n-            }\n-            (None, None) => None,\n-        }\n-    }\n-\n-    // linker and linker flavor specified via command line have precedence over what the target\n-    // specification specifies\n-    if let Some(ret) = infer_from(sess, sess.opts.cg.linker.clone(), sess.opts.cg.linker_flavor) {\n-        return ret;\n-    }\n-\n-    if let Some(ret) = infer_from(\n-        sess,\n-        sess.target.linker.clone().map(PathBuf::from),\n-        Some(sess.target.linker_flavor),\n-    ) {\n-        return ret;\n-    }\n-\n-    bug!(\"Not enough information provided to determine how to invoke the linker\");\n-}"}, {"sha": "d0eb6913accde06efb58127b23ca33a71673dc62", "filename": "compiler/rustc_codegen_llvm/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_codegen_llvm%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_codegen_llvm%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2FCargo.toml?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -27,6 +27,7 @@ rustc_hir = { path = \"../rustc_hir\" }\n rustc_incremental = { path = \"../rustc_incremental\" }\n rustc_index = { path = \"../rustc_index\" }\n rustc_llvm = { path = \"../rustc_llvm\" }\n+rustc_metadata = { path = \"../rustc_metadata\" }\n rustc_session = { path = \"../rustc_session\" }\n rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_target = { path = \"../rustc_target\" }"}, {"sha": "ecf62ed213df82aec1daaf5b5b1cf958d0f9054c", "filename": "compiler/rustc_codegen_llvm/src/asm.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -288,6 +288,7 @@ impl AsmBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 InlineAsmArch::Mips | InlineAsmArch::Mips64 => {}\n                 InlineAsmArch::SpirV => {}\n                 InlineAsmArch::Wasm32 => {}\n+                InlineAsmArch::Bpf => {}\n             }\n         }\n         if !options.contains(InlineAsmOptions::NOMEM) {\n@@ -593,6 +594,8 @@ fn reg_to_llvm(reg: InlineAsmRegOrRegClass, layout: Option<&TyAndLayout<'tcx>>)\n             InlineAsmRegClass::X86(X86InlineAsmRegClass::zmm_reg) => \"v\",\n             InlineAsmRegClass::X86(X86InlineAsmRegClass::kreg) => \"^Yk\",\n             InlineAsmRegClass::Wasm(WasmInlineAsmRegClass::local) => \"r\",\n+            InlineAsmRegClass::Bpf(BpfInlineAsmRegClass::reg) => \"r\",\n+            InlineAsmRegClass::Bpf(BpfInlineAsmRegClass::wreg) => \"w\",\n             InlineAsmRegClass::SpirV(SpirVInlineAsmRegClass::reg) => {\n                 bug!(\"LLVM backend does not support SPIR-V\")\n             }\n@@ -661,6 +664,7 @@ fn modifier_to_llvm(\n         },\n         InlineAsmRegClass::X86(X86InlineAsmRegClass::kreg) => None,\n         InlineAsmRegClass::Wasm(WasmInlineAsmRegClass::local) => None,\n+        InlineAsmRegClass::Bpf(_) => None,\n         InlineAsmRegClass::SpirV(SpirVInlineAsmRegClass::reg) => {\n             bug!(\"LLVM backend does not support SPIR-V\")\n         }\n@@ -708,6 +712,8 @@ fn dummy_output_type(cx: &CodegenCx<'ll, 'tcx>, reg: InlineAsmRegClass) -> &'ll\n         | InlineAsmRegClass::X86(X86InlineAsmRegClass::zmm_reg) => cx.type_f32(),\n         InlineAsmRegClass::X86(X86InlineAsmRegClass::kreg) => cx.type_i16(),\n         InlineAsmRegClass::Wasm(WasmInlineAsmRegClass::local) => cx.type_i32(),\n+        InlineAsmRegClass::Bpf(BpfInlineAsmRegClass::reg) => cx.type_i64(),\n+        InlineAsmRegClass::Bpf(BpfInlineAsmRegClass::wreg) => cx.type_i32(),\n         InlineAsmRegClass::SpirV(SpirVInlineAsmRegClass::reg) => {\n             bug!(\"LLVM backend does not support SPIR-V\")\n         }"}, {"sha": "64416bced31d024dcd8819dbeaa6f35e0f2cf8ad", "filename": "compiler/rustc_codegen_llvm/src/back/archive.rs", "status": "modified", "additions": 82, "deletions": 1, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -8,9 +8,11 @@ use std::ptr;\n use std::str;\n \n use crate::llvm::archive_ro::{ArchiveRO, Child};\n-use crate::llvm::{self, ArchiveKind};\n+use crate::llvm::{self, ArchiveKind, LLVMMachineType, LLVMRustCOFFShortExport};\n use rustc_codegen_ssa::back::archive::{find_library, ArchiveBuilder};\n use rustc_codegen_ssa::{looks_like_rust_object_file, METADATA_FILENAME};\n+use rustc_data_structures::temp_dir::MaybeTempDir;\n+use rustc_middle::middle::cstore::DllImport;\n use rustc_session::Session;\n use rustc_span::symbol::Symbol;\n \n@@ -61,6 +63,17 @@ fn archive_config<'a>(sess: &'a Session, output: &Path, input: Option<&Path>) ->\n     }\n }\n \n+/// Map machine type strings to values of LLVM's MachineTypes enum.\n+fn llvm_machine_type(cpu: &str) -> LLVMMachineType {\n+    match cpu {\n+        \"x86_64\" => LLVMMachineType::AMD64,\n+        \"x86\" => LLVMMachineType::I386,\n+        \"aarch64\" => LLVMMachineType::ARM64,\n+        \"arm\" => LLVMMachineType::ARM,\n+        _ => panic!(\"unsupported cpu type {}\", cpu),\n+    }\n+}\n+\n impl<'a> ArchiveBuilder<'a> for LlvmArchiveBuilder<'a> {\n     /// Creates a new static archive, ready for modifying the archive specified\n     /// by `config`.\n@@ -175,6 +188,74 @@ impl<'a> ArchiveBuilder<'a> for LlvmArchiveBuilder<'a> {\n             self.config.sess.fatal(&format!(\"failed to build archive: {}\", e));\n         }\n     }\n+\n+    fn inject_dll_import_lib(\n+        &mut self,\n+        lib_name: &str,\n+        dll_imports: &[DllImport],\n+        tmpdir: &MaybeTempDir,\n+    ) {\n+        let output_path = {\n+            let mut output_path: PathBuf = tmpdir.as_ref().to_path_buf();\n+            output_path.push(format!(\"{}_imports\", lib_name));\n+            output_path.with_extension(\"lib\")\n+        };\n+\n+        // we've checked for \\0 characters in the library name already\n+        let dll_name_z = CString::new(lib_name).unwrap();\n+        // All import names are Rust identifiers and therefore cannot contain \\0 characters.\n+        // FIXME: when support for #[link_name] implemented, ensure that import.name values don't\n+        // have any \\0 characters\n+        let import_name_vector: Vec<CString> = dll_imports\n+            .iter()\n+            .map(if self.config.sess.target.arch == \"x86\" {\n+                |import: &DllImport| CString::new(format!(\"_{}\", import.name.to_string())).unwrap()\n+            } else {\n+                |import: &DllImport| CString::new(import.name.to_string()).unwrap()\n+            })\n+            .collect();\n+\n+        let output_path_z = rustc_fs_util::path_to_c_string(&output_path);\n+\n+        tracing::trace!(\"invoking LLVMRustWriteImportLibrary\");\n+        tracing::trace!(\"  dll_name {:#?}\", dll_name_z);\n+        tracing::trace!(\"  output_path {}\", output_path.display());\n+        tracing::trace!(\n+            \"  import names: {}\",\n+            dll_imports.iter().map(|import| import.name.to_string()).collect::<Vec<_>>().join(\", \"),\n+        );\n+\n+        let ffi_exports: Vec<LLVMRustCOFFShortExport> = import_name_vector\n+            .iter()\n+            .map(|name_z| LLVMRustCOFFShortExport::from_name(name_z.as_ptr()))\n+            .collect();\n+        let result = unsafe {\n+            crate::llvm::LLVMRustWriteImportLibrary(\n+                dll_name_z.as_ptr(),\n+                output_path_z.as_ptr(),\n+                ffi_exports.as_ptr(),\n+                ffi_exports.len(),\n+                llvm_machine_type(&self.config.sess.target.arch) as u16,\n+                !self.config.sess.target.is_like_msvc,\n+            )\n+        };\n+\n+        if result == crate::llvm::LLVMRustResult::Failure {\n+            self.config.sess.fatal(&format!(\n+                \"Error creating import library for {}: {}\",\n+                lib_name,\n+                llvm::last_error().unwrap_or(\"unknown LLVM error\".to_string())\n+            ));\n+        }\n+\n+        self.add_archive(&output_path, |_| false).unwrap_or_else(|e| {\n+            self.config.sess.fatal(&format!(\n+                \"failed to add native library {}: {}\",\n+                output_path.display(),\n+                e\n+            ));\n+        });\n+    }\n }\n \n impl<'a> LlvmArchiveBuilder<'a> {"}, {"sha": "cc3cbea4def5e1bf20876b3eaf24baa539d64aee", "filename": "compiler/rustc_codegen_llvm/src/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -63,7 +63,7 @@ pub fn write_compressed_metadata<'tcx>(\n     let section_name = if tcx.sess.target.is_like_osx { \"__DATA,.rustc\" } else { \".rustc\" };\n \n     let (metadata_llcx, metadata_llmod) = (&*llvm_module.llcx, llvm_module.llmod());\n-    let mut compressed = tcx.metadata_encoding_version();\n+    let mut compressed = rustc_metadata::METADATA_HEADER.to_vec();\n     FrameEncoder::new(&mut compressed).write_all(&metadata.raw_data).unwrap();\n \n     let llmeta = common::bytes_in_context(metadata_llcx, &compressed);"}, {"sha": "c8cf0116c641ef526a84506d039d08cd629b1d62", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -69,6 +69,7 @@ impl abi::HasDataLayout for Builder<'_, '_, '_> {\n }\n \n impl ty::layout::HasTyCtxt<'tcx> for Builder<'_, '_, 'tcx> {\n+    #[inline]\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.cx.tcx\n     }\n@@ -81,6 +82,7 @@ impl ty::layout::HasParamEnv<'tcx> for Builder<'_, '_, 'tcx> {\n }\n \n impl HasTargetSpec for Builder<'_, '_, 'tcx> {\n+    #[inline]\n     fn target_spec(&self) -> &Target {\n         &self.cx.target_spec()\n     }\n@@ -98,6 +100,7 @@ impl abi::LayoutOf for Builder<'_, '_, 'tcx> {\n impl Deref for Builder<'_, 'll, 'tcx> {\n     type Target = CodegenCx<'ll, 'tcx>;\n \n+    #[inline]\n     fn deref(&self) -> &Self::Target {\n         self.cx\n     }"}, {"sha": "6aa952462fa58d50f0d20435fed58a5ba63e1c3a", "filename": "compiler/rustc_codegen_llvm/src/context.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -765,18 +765,21 @@ impl<'b, 'tcx> CodegenCx<'b, 'tcx> {\n }\n \n impl HasDataLayout for CodegenCx<'ll, 'tcx> {\n+    #[inline]\n     fn data_layout(&self) -> &TargetDataLayout {\n         &self.tcx.data_layout\n     }\n }\n \n impl HasTargetSpec for CodegenCx<'ll, 'tcx> {\n+    #[inline]\n     fn target_spec(&self) -> &Target {\n         &self.tcx.sess.target\n     }\n }\n \n impl ty::layout::HasTyCtxt<'tcx> for CodegenCx<'ll, 'tcx> {\n+    #[inline]\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.tcx\n     }"}, {"sha": "1e70664e64d707dbc3aa9af04669b0c416a68c88", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 149, "deletions": 102, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -1457,7 +1457,6 @@ struct EnumMemberDescriptionFactory<'ll, 'tcx> {\n     enum_type: Ty<'tcx>,\n     layout: TyAndLayout<'tcx>,\n     tag_type_metadata: Option<&'ll DIType>,\n-    containing_scope: &'ll DIScope,\n     common_members: Vec<Option<&'ll DIType>>,\n     span: Span,\n }\n@@ -1486,13 +1485,9 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n             _ => bug!(),\n         };\n \n-        // This will always find the metadata in the type map.\n         let fallback = use_enum_fallback(cx);\n-        let self_metadata = if fallback {\n-            self.containing_scope\n-        } else {\n-            type_metadata(cx, self.enum_type, self.span)\n-        };\n+        // This will always find the metadata in the type map.\n+        let self_metadata = type_metadata(cx, self.enum_type, self.span);\n \n         match self.layout.variants {\n             Variants::Single { index } => {\n@@ -1507,7 +1502,7 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                     cx,\n                     self.layout,\n                     variant_info,\n-                    NoTag,\n+                    None,\n                     self_metadata,\n                     self.span,\n                 );\n@@ -1539,13 +1534,26 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                 ..\n             } => {\n                 let tag_info = if fallback {\n-                    RegularTag {\n+                    // For MSVC, we generate a union of structs for each variant with an explicit\n+                    // discriminant field roughly equivalent to the following C:\n+                    // ```c\n+                    // union enum$<{name}> {\n+                    //   struct {variant 0 name} {\n+                    //     tag$ variant$;\n+                    //     <variant 0 fields>\n+                    //   } variant0;\n+                    //   <other variant structs>\n+                    // }\n+                    // ```\n+                    // The natvis in `intrinsic.nativs` then matches on `this.variant0.variant$` to\n+                    // determine which variant is active and then displays it.\n+                    Some(DirectTag {\n                         tag_field: Field::from(tag_field),\n                         tag_type_metadata: self.tag_type_metadata.unwrap(),\n-                    }\n+                    })\n                 } else {\n                     // This doesn't matter in this case.\n-                    NoTag\n+                    None\n                 };\n                 variants\n                     .iter_enumerated()\n@@ -1574,7 +1582,7 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n \n                         MemberDescription {\n                             name: if fallback {\n-                                String::new()\n+                                format!(\"variant{}\", i.as_u32())\n                             } else {\n                                 variant_info.variant_name()\n                             },\n@@ -1599,77 +1607,135 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                 ref variants,\n                 tag_field,\n             } => {\n+                let calculate_niche_value = |i: VariantIdx| {\n+                    if i == dataful_variant {\n+                        None\n+                    } else {\n+                        let value = (i.as_u32() as u128)\n+                            .wrapping_sub(niche_variants.start().as_u32() as u128)\n+                            .wrapping_add(niche_start);\n+                        let value = tag.value.size(cx).truncate(value);\n+                        // NOTE(eddyb) do *NOT* remove this assert, until\n+                        // we pass the full 128-bit value to LLVM, otherwise\n+                        // truncation will be silent and remain undetected.\n+                        assert_eq!(value as u64 as u128, value);\n+                        Some(value as u64)\n+                    }\n+                };\n+\n+                // For MSVC, we will generate a union of two fields, one for the dataful variant\n+                // and one that just points to the discriminant. We also create an enum that\n+                // contains tag values for the non-dataful variants and make the discriminant field\n+                // that type. We then use natvis to render the enum type correctly in Windbg/VS.\n+                // This will generate debuginfo roughly equivalent to the following C:\n+                // ```c\n+                // union enum$<{name}, {min niche}, {max niche}, {dataful variant name}> {\n+                //   struct <dataful variant name> {\n+                //     <fields in dataful variant>\n+                //   } dataful_variant;\n+                //   enum Discriminant$ {\n+                //     <non-dataful variants>\n+                //   } discriminant;\n+                // }\n+                // ```\n+                // The natvis in `intrinsic.natvis` matches on the type name `enum$<*, *, *, *>`\n+                // and evaluates `this.discriminant`. If the value is between the min niche and max\n+                // niche, then the enum is in the dataful variant and `this.dataful_variant` is\n+                // rendered. Otherwise, the enum is in one of the non-dataful variants. In that\n+                // case, we just need to render the name of the `this.discriminant` enum.\n                 if fallback {\n-                    let variant = self.layout.for_variant(cx, dataful_variant);\n-                    // Create a description of the non-null variant.\n-                    let (variant_type_metadata, member_description_factory) = describe_enum_variant(\n+                    let dataful_variant_layout = self.layout.for_variant(cx, dataful_variant);\n+\n+                    let mut discr_enum_ty = tag.value.to_ty(cx.tcx);\n+                    // If the niche is the NULL value of a reference, then `discr_enum_ty` will be a RawPtr.\n+                    // CodeView doesn't know what to do with enums whose base type is a pointer so we fix this up\n+                    // to just be `usize`.\n+                    if let ty::RawPtr(_) = discr_enum_ty.kind() {\n+                        discr_enum_ty = cx.tcx.types.usize;\n+                    }\n+\n+                    let tags: Vec<_> = variants\n+                        .iter_enumerated()\n+                        .filter_map(|(variant_idx, _)| {\n+                            calculate_niche_value(variant_idx).map(|tag| {\n+                                let variant = variant_info_for(variant_idx);\n+                                let name = variant.variant_name();\n+\n+                                Some(unsafe {\n+                                    llvm::LLVMRustDIBuilderCreateEnumerator(\n+                                        DIB(cx),\n+                                        name.as_ptr().cast(),\n+                                        name.len(),\n+                                        tag as i64,\n+                                        !discr_enum_ty.is_signed(),\n+                                    )\n+                                })\n+                            })\n+                        })\n+                        .collect();\n+\n+                    let discr_enum = unsafe {\n+                        llvm::LLVMRustDIBuilderCreateEnumerationType(\n+                            DIB(cx),\n+                            self_metadata,\n+                            \"Discriminant$\".as_ptr().cast(),\n+                            \"Discriminant$\".len(),\n+                            unknown_file_metadata(cx),\n+                            UNKNOWN_LINE_NUMBER,\n+                            tag.value.size(cx).bits(),\n+                            tag.value.align(cx).abi.bits() as u32,\n+                            create_DIArray(DIB(cx), &tags),\n+                            type_metadata(cx, discr_enum_ty, self.span),\n+                            true,\n+                        )\n+                    };\n+\n+                    let variant_info = variant_info_for(dataful_variant);\n+                    let (variant_type_metadata, member_desc_factory) = describe_enum_variant(\n                         cx,\n-                        variant,\n-                        variant_info_for(dataful_variant),\n-                        OptimizedTag,\n-                        self.containing_scope,\n+                        dataful_variant_layout,\n+                        variant_info,\n+                        Some(NicheTag),\n+                        self_metadata,\n                         self.span,\n                     );\n \n-                    let variant_member_descriptions =\n-                        member_description_factory.create_member_descriptions(cx);\n+                    let member_descriptions = member_desc_factory.create_member_descriptions(cx);\n \n                     set_members_of_composite_type(\n                         cx,\n                         self.enum_type,\n                         variant_type_metadata,\n-                        variant_member_descriptions,\n+                        member_descriptions,\n                         Some(&self.common_members),\n                     );\n \n-                    // Encode the information about the null variant in the union\n-                    // member's name.\n-                    let mut name = String::from(\"RUST$ENCODED$ENUM$\");\n-                    // Right now it's not even going to work for `niche_start > 0`,\n-                    // and for multiple niche variants it only supports the first.\n-                    fn compute_field_path<'a, 'tcx>(\n-                        cx: &CodegenCx<'a, 'tcx>,\n-                        name: &mut String,\n-                        layout: TyAndLayout<'tcx>,\n-                        offset: Size,\n-                        size: Size,\n-                    ) {\n-                        for i in 0..layout.fields.count() {\n-                            let field_offset = layout.fields.offset(i);\n-                            if field_offset > offset {\n-                                continue;\n-                            }\n-                            let inner_offset = offset - field_offset;\n-                            let field = layout.field(cx, i);\n-                            if inner_offset + size <= field.size {\n-                                write!(name, \"{}$\", i).unwrap();\n-                                compute_field_path(cx, name, field, inner_offset, size);\n-                            }\n-                        }\n-                    }\n-                    compute_field_path(\n-                        cx,\n-                        &mut name,\n-                        self.layout,\n-                        self.layout.fields.offset(tag_field),\n-                        self.layout.field(cx, tag_field).size,\n-                    );\n-                    let variant_info = variant_info_for(*niche_variants.start());\n-                    variant_info.map_struct_name(|variant_name| {\n-                        name.push_str(variant_name);\n-                    });\n-\n-                    // Create the (singleton) list of descriptions of union members.\n-                    vec![MemberDescription {\n-                        name,\n-                        type_metadata: variant_type_metadata,\n-                        offset: Size::ZERO,\n-                        size: variant.size,\n-                        align: variant.align.abi,\n-                        flags: DIFlags::FlagZero,\n-                        discriminant: None,\n-                        source_info: variant_info.source_info(cx),\n-                    }]\n+                    let (size, align) =\n+                        cx.size_and_align_of(dataful_variant_layout.field(cx, tag_field).ty);\n+\n+                    vec![\n+                        MemberDescription {\n+                            // Name the dataful variant so that we can identify it for natvis\n+                            name: \"dataful_variant\".to_string(),\n+                            type_metadata: variant_type_metadata,\n+                            offset: Size::ZERO,\n+                            size: self.layout.size,\n+                            align: self.layout.align.abi,\n+                            flags: DIFlags::FlagZero,\n+                            discriminant: None,\n+                            source_info: variant_info.source_info(cx),\n+                        },\n+                        MemberDescription {\n+                            name: \"discriminant\".into(),\n+                            type_metadata: discr_enum,\n+                            offset: dataful_variant_layout.fields.offset(tag_field),\n+                            size,\n+                            align,\n+                            flags: DIFlags::FlagZero,\n+                            discriminant: None,\n+                            source_info: None,\n+                        },\n+                    ]\n                 } else {\n                     variants\n                         .iter_enumerated()\n@@ -1681,7 +1747,7 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                                     cx,\n                                     variant,\n                                     variant_info,\n-                                    OptimizedTag,\n+                                    Some(NicheTag),\n                                     self_metadata,\n                                     self.span,\n                                 );\n@@ -1697,19 +1763,7 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                                 Some(&self.common_members),\n                             );\n \n-                            let niche_value = if i == dataful_variant {\n-                                None\n-                            } else {\n-                                let value = (i.as_u32() as u128)\n-                                    .wrapping_sub(niche_variants.start().as_u32() as u128)\n-                                    .wrapping_add(niche_start);\n-                                let value = tag.value.size(cx).truncate(value);\n-                                // NOTE(eddyb) do *NOT* remove this assert, until\n-                                // we pass the full 128-bit value to LLVM, otherwise\n-                                // truncation will be silent and remain undetected.\n-                                assert_eq!(value as u64 as u128, value);\n-                                Some(value as u64)\n-                            };\n+                            let niche_value = calculate_niche_value(i);\n \n                             MemberDescription {\n                                 name: variant_info.variant_name(),\n@@ -1771,14 +1825,10 @@ impl VariantMemberDescriptionFactory<'ll, 'tcx> {\n     }\n }\n \n-// FIXME: terminology here should be aligned with `abi::TagEncoding`.\n-// `OptimizedTag` is `TagEncoding::Niche`, `RegularTag` is `TagEncoding::Direct`.\n-// `NoTag` should be removed; users should use `Option<EnumTagInfo>` instead.\n #[derive(Copy, Clone)]\n enum EnumTagInfo<'ll> {\n-    RegularTag { tag_field: Field, tag_type_metadata: &'ll DIType },\n-    OptimizedTag,\n-    NoTag,\n+    DirectTag { tag_field: Field, tag_type_metadata: &'ll DIType },\n+    NicheTag,\n }\n \n #[derive(Copy, Clone)]\n@@ -1859,7 +1909,7 @@ fn describe_enum_variant(\n     cx: &CodegenCx<'ll, 'tcx>,\n     layout: layout::TyAndLayout<'tcx>,\n     variant: VariantInfo<'_, 'tcx>,\n-    discriminant_info: EnumTagInfo<'ll>,\n+    discriminant_info: Option<EnumTagInfo<'ll>>,\n     containing_scope: &'ll DIScope,\n     span: Span,\n ) -> (&'ll DICompositeType, MemberDescriptionFactory<'ll, 'tcx>) {\n@@ -1882,12 +1932,11 @@ fn describe_enum_variant(\n     let (offsets, args) = if use_enum_fallback(cx) {\n         // If this is not a univariant enum, there is also the discriminant field.\n         let (discr_offset, discr_arg) = match discriminant_info {\n-            RegularTag { tag_field, .. } => {\n+            Some(DirectTag { tag_field, .. }) => {\n                 // We have the layout of an enum variant, we need the layout of the outer enum\n                 let enum_layout = cx.layout_of(layout.ty);\n                 let offset = enum_layout.fields.offset(tag_field.as_usize());\n-                let args =\n-                    (\"RUST$ENUM$DISR\".to_owned(), enum_layout.field(cx, tag_field.as_usize()).ty);\n+                let args = (\"variant$\".to_owned(), enum_layout.field(cx, tag_field.as_usize()).ty);\n                 (Some(offset), Some(args))\n             }\n             _ => (None, None),\n@@ -1918,7 +1967,7 @@ fn describe_enum_variant(\n         offsets,\n         args,\n         tag_type_metadata: match discriminant_info {\n-            RegularTag { tag_type_metadata, .. } => Some(tag_type_metadata),\n+            Some(DirectTag { tag_type_metadata, .. }) => Some(tag_type_metadata),\n             _ => None,\n         },\n         span,\n@@ -2048,9 +2097,9 @@ fn prepare_enum_metadata(\n \n     if use_enum_fallback(cx) {\n         let discriminant_type_metadata = match layout.variants {\n-            Variants::Single { .. }\n-            | Variants::Multiple { tag_encoding: TagEncoding::Niche { .. }, .. } => None,\n-            Variants::Multiple { tag_encoding: TagEncoding::Direct, ref tag, .. } => {\n+            Variants::Single { .. } => None,\n+            Variants::Multiple { tag_encoding: TagEncoding::Niche { .. }, ref tag, .. }\n+            | Variants::Multiple { tag_encoding: TagEncoding::Direct, ref tag, .. } => {\n                 Some(discriminant_type_metadata(tag.value))\n             }\n         };\n@@ -2062,7 +2111,7 @@ fn prepare_enum_metadata(\n             unsafe {\n                 llvm::LLVMRustDIBuilderCreateUnionType(\n                     DIB(cx),\n-                    containing_scope,\n+                    None,\n                     enum_name.as_ptr().cast(),\n                     enum_name.len(),\n                     file_metadata,\n@@ -2088,7 +2137,6 @@ fn prepare_enum_metadata(\n                 enum_type,\n                 layout,\n                 tag_type_metadata: discriminant_type_metadata,\n-                containing_scope,\n                 common_members: vec![],\n                 span,\n             }),\n@@ -2241,7 +2289,6 @@ fn prepare_enum_metadata(\n             enum_type,\n             layout,\n             tag_type_metadata: None,\n-            containing_scope,\n             common_members: outer_fields,\n             span,\n         }),\n@@ -2437,7 +2484,7 @@ fn create_union_stub(\n \n         llvm::LLVMRustDIBuilderCreateUnionType(\n             DIB(cx),\n-            containing_scope,\n+            Some(containing_scope),\n             union_type_name.as_ptr().cast(),\n             union_type_name.len(),\n             unknown_file_metadata(cx),"}, {"sha": "776cb2ee99bcbf727f6ce65d5fa6124454eed4f6", "filename": "compiler/rustc_codegen_llvm/src/lib.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -29,8 +29,8 @@ use rustc_codegen_ssa::{CodegenResults, CompiledModule};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::{ErrorReported, FatalError, Handler};\n use rustc_middle::dep_graph::{WorkProduct, WorkProductId};\n-use rustc_middle::middle::cstore::{EncodedMetadata, MetadataLoaderDyn};\n-use rustc_middle::ty::{self, TyCtxt};\n+use rustc_middle::middle::cstore::EncodedMetadata;\n+use rustc_middle::ty::TyCtxt;\n use rustc_session::config::{OptLevel, OutputFilenames, PrintRequest};\n use rustc_session::Session;\n use rustc_span::symbol::Symbol;\n@@ -248,13 +248,6 @@ impl CodegenBackend for LlvmCodegenBackend {\n         target_features(sess)\n     }\n \n-    fn metadata_loader(&self) -> Box<MetadataLoaderDyn> {\n-        Box::new(rustc_codegen_ssa::back::metadata::DefaultMetadataLoader)\n-    }\n-\n-    fn provide(&self, _providers: &mut ty::query::Providers) {}\n-    fn provide_extern(&self, _providers: &mut ty::query::Providers) {}\n-\n     fn codegen_crate<'tcx>(\n         &self,\n         tcx: TyCtxt<'tcx>,\n@@ -304,7 +297,7 @@ impl CodegenBackend for LlvmCodegenBackend {\n             sess,\n             &codegen_results,\n             outputs,\n-            &codegen_results.crate_name.as_str(),\n+            &codegen_results.crate_info.local_crate_name.as_str(),\n         );\n \n         Ok(())"}, {"sha": "91923251018a898671319bc486f5b3e98f651f5e", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 35, "deletions": 41, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -29,6 +29,31 @@ pub enum LLVMRustResult {\n     Success,\n     Failure,\n }\n+\n+// Rust version of the C struct with the same name in rustc_llvm/llvm-wrapper/RustWrapper.cpp.\n+#[repr(C)]\n+pub struct LLVMRustCOFFShortExport {\n+    pub name: *const c_char,\n+}\n+\n+impl LLVMRustCOFFShortExport {\n+    pub fn from_name(name: *const c_char) -> LLVMRustCOFFShortExport {\n+        LLVMRustCOFFShortExport { name }\n+    }\n+}\n+\n+/// Translation of LLVM's MachineTypes enum, defined in llvm\\include\\llvm\\BinaryFormat\\COFF.h.\n+///\n+/// We include only architectures supported on Windows.\n+#[derive(Copy, Clone, PartialEq)]\n+#[repr(C)]\n+pub enum LLVMMachineType {\n+    AMD64 = 0x8664,\n+    I386 = 0x14c,\n+    ARM64 = 0xaa64,\n+    ARM = 0x01c0,\n+}\n+\n // Consts for the LLVM CallConv type, pre-cast to usize.\n \n /// LLVM CallingConv::ID. Should we wrap this?\n@@ -582,11 +607,6 @@ pub struct PassManager<'a>(InvariantOpaque<'a>);\n extern \"C\" {\n     pub type PassManagerBuilder;\n }\n-extern \"C\" {\n-    pub type ObjectFile;\n-}\n-#[repr(C)]\n-pub struct SectionIterator<'a>(InvariantOpaque<'a>);\n extern \"C\" {\n     pub type Pass;\n }\n@@ -1703,35 +1723,6 @@ extern \"C\" {\n \n     pub fn LLVMDisposeMessage(message: *mut c_char);\n \n-    // Stuff that's in llvm-wrapper/ because it's not upstream yet.\n-\n-    /// Opens an object file.\n-    pub fn LLVMCreateObjectFile(\n-        MemBuf: &'static mut MemoryBuffer,\n-    ) -> Option<&'static mut ObjectFile>;\n-    /// Closes an object file.\n-    pub fn LLVMDisposeObjectFile(ObjFile: &'static mut ObjectFile);\n-\n-    /// Enumerates the sections in an object file.\n-    pub fn LLVMGetSections(ObjFile: &'a ObjectFile) -> &'a mut SectionIterator<'a>;\n-    /// Destroys a section iterator.\n-    pub fn LLVMDisposeSectionIterator(SI: &'a mut SectionIterator<'a>);\n-    /// Returns `true` if the section iterator is at the end of the section\n-    /// list:\n-    pub fn LLVMIsSectionIteratorAtEnd(ObjFile: &'a ObjectFile, SI: &SectionIterator<'a>) -> Bool;\n-    /// Moves the section iterator to point to the next section.\n-    pub fn LLVMMoveToNextSection(SI: &SectionIterator<'_>);\n-    /// Returns the current section size.\n-    pub fn LLVMGetSectionSize(SI: &SectionIterator<'_>) -> c_ulonglong;\n-    /// Returns the current section contents as a string buffer.\n-    pub fn LLVMGetSectionContents(SI: &SectionIterator<'_>) -> *const c_char;\n-\n-    /// Reads the given file and returns it as a memory buffer. Use\n-    /// LLVMDisposeMemoryBuffer() to get rid of it.\n-    pub fn LLVMRustCreateMemoryBufferWithContentsOfFile(\n-        Path: *const c_char,\n-    ) -> Option<&'static mut MemoryBuffer>;\n-\n     pub fn LLVMStartMultithreaded() -> Bool;\n \n     /// Returns a string describing the last error caused by an LLVMRust* call.\n@@ -2038,7 +2029,7 @@ extern \"C\" {\n \n     pub fn LLVMRustDIBuilderCreateUnionType(\n         Builder: &DIBuilder<'a>,\n-        Scope: &'a DIScope,\n+        Scope: Option<&'a DIScope>,\n         Name: *const c_char,\n         NameLen: size_t,\n         File: &'a DIFile,\n@@ -2236,12 +2227,6 @@ extern \"C\" {\n     pub fn LLVMRustArchiveIteratorFree(AIR: &'a mut ArchiveIterator<'a>);\n     pub fn LLVMRustDestroyArchive(AR: &'static mut Archive);\n \n-    #[allow(improper_ctypes)]\n-    pub fn LLVMRustGetSectionName(\n-        SI: &SectionIterator<'_>,\n-        data: &mut Option<std::ptr::NonNull<c_char>>,\n-    ) -> size_t;\n-\n     #[allow(improper_ctypes)]\n     pub fn LLVMRustWriteTwineToString(T: &Twine, s: &RustString);\n \n@@ -2305,6 +2290,15 @@ extern \"C\" {\n     ) -> &'a mut RustArchiveMember<'a>;\n     pub fn LLVMRustArchiveMemberFree(Member: &'a mut RustArchiveMember<'a>);\n \n+    pub fn LLVMRustWriteImportLibrary(\n+        ImportName: *const c_char,\n+        Path: *const c_char,\n+        Exports: *const LLVMRustCOFFShortExport,\n+        NumExports: usize,\n+        Machine: u16,\n+        MinGW: bool,\n+    ) -> LLVMRustResult;\n+\n     pub fn LLVMRustSetDataLayoutFromTargetMachine(M: &'a Module, TM: &'a TargetMachine);\n \n     pub fn LLVMRustBuildOperandBundleDef("}, {"sha": "38d56f872116933dccdae216c772ecb547b0aa1a", "filename": "compiler/rustc_codegen_llvm/src/llvm/mod.rs", "status": "modified", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fmod.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -150,50 +150,6 @@ impl Attribute {\n     }\n }\n \n-// Memory-managed interface to object files.\n-\n-pub struct ObjectFile {\n-    pub llof: &'static mut ffi::ObjectFile,\n-}\n-\n-unsafe impl Send for ObjectFile {}\n-\n-impl ObjectFile {\n-    // This will take ownership of llmb\n-    pub fn new(llmb: &'static mut MemoryBuffer) -> Option<ObjectFile> {\n-        unsafe {\n-            let llof = LLVMCreateObjectFile(llmb)?;\n-            Some(ObjectFile { llof })\n-        }\n-    }\n-}\n-\n-impl Drop for ObjectFile {\n-    fn drop(&mut self) {\n-        unsafe {\n-            LLVMDisposeObjectFile(&mut *(self.llof as *mut _));\n-        }\n-    }\n-}\n-\n-// Memory-managed interface to section iterators.\n-\n-pub struct SectionIter<'a> {\n-    pub llsi: &'a mut SectionIterator<'a>,\n-}\n-\n-impl Drop for SectionIter<'a> {\n-    fn drop(&mut self) {\n-        unsafe {\n-            LLVMDisposeSectionIterator(&mut *(self.llsi as *mut _));\n-        }\n-    }\n-}\n-\n-pub fn mk_section_iter(llof: &ffi::ObjectFile) -> SectionIter<'_> {\n-    unsafe { SectionIter { llsi: LLVMGetSections(llof) } }\n-}\n-\n pub fn set_section(llglobal: &Value, section_name: &str) {\n     let section_name_cstr = CString::new(section_name).expect(\"unexpected CString error\");\n     unsafe {"}, {"sha": "0dd3d2ae15bcae74a3c9ca974e59d021c0f75d14", "filename": "compiler/rustc_codegen_llvm/src/llvm_util.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -1,5 +1,5 @@\n use crate::back::write::create_informational_target_machine;\n-use crate::llvm;\n+use crate::{llvm, llvm_util};\n use libc::c_int;\n use rustc_codegen_ssa::target_features::supported_target_features;\n use rustc_data_structures::fx::FxHashSet;\n@@ -84,6 +84,17 @@ unsafe fn configure_llvm(sess: &Session) {\n         if !sess.opts.debugging_opts.no_generate_arange_section {\n             add(\"-generate-arange-section\", false);\n         }\n+\n+        // FIXME(nagisa): disable the machine outliner by default in LLVM versions 11, where it was\n+        // introduced and up.\n+        //\n+        // This should remain in place until https://reviews.llvm.org/D103167 is fixed. If LLVM\n+        // has been upgraded since, consider adjusting the version check below to contain an upper\n+        // bound.\n+        if llvm_util::get_version() >= (11, 0, 0) {\n+            add(\"-enable-machine-outliner=never\", false);\n+        }\n+\n         match sess.opts.debugging_opts.merge_functions.unwrap_or(sess.target.merge_functions) {\n             MergeFunctions::Disabled | MergeFunctions::Trampolines => {}\n             MergeFunctions::Aliases => {"}, {"sha": "9bd5764f0730dbff3e4772db5a50b0947b2afbe7", "filename": "compiler/rustc_codegen_ssa/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_codegen_ssa%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_codegen_ssa%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2FCargo.toml?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -35,6 +35,6 @@ rustc_target = { path = \"../rustc_target\" }\n rustc_session = { path = \"../rustc_session\" }\n \n [dependencies.object]\n-version = \"0.22.0\"\n+version = \"0.25.2\"\n default-features = false\n-features = [\"read_core\", \"elf\", \"macho\", \"pe\", \"unaligned\", \"archive\"]\n+features = [\"read_core\", \"elf\", \"macho\", \"pe\", \"unaligned\", \"archive\", \"write\"]"}, {"sha": "63f457bb979e3ff693f0702c228ca693545a9553", "filename": "compiler/rustc_codegen_ssa/src/back/archive.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -1,3 +1,5 @@\n+use rustc_data_structures::temp_dir::MaybeTempDir;\n+use rustc_middle::middle::cstore::DllImport;\n use rustc_session::Session;\n use rustc_span::symbol::Symbol;\n \n@@ -57,4 +59,11 @@ pub trait ArchiveBuilder<'a> {\n     fn update_symbols(&mut self);\n \n     fn build(self);\n+\n+    fn inject_dll_import_lib(\n+        &mut self,\n+        lib_name: &str,\n+        dll_imports: &[DllImport],\n+        tmpdir: &MaybeTempDir,\n+    );\n }"}, {"sha": "6c9ec9e7b0dae909fe262739f4c5a46892133867", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 465, "deletions": 203, "changes": 668, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -1,11 +1,11 @@\n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::temp_dir::MaybeTempDir;\n use rustc_errors::Handler;\n use rustc_fs_util::fix_windows_verbatim_for_gcc;\n use rustc_hir::def_id::CrateNum;\n-use rustc_middle::middle::cstore::{EncodedMetadata, LibSource};\n+use rustc_middle::middle::cstore::{DllImport, LibSource};\n use rustc_middle::middle::dependency_format::Linkage;\n-use rustc_session::config::{self, CFGuard, CrateType, DebugInfo};\n+use rustc_session::config::{self, CFGuard, CrateType, DebugInfo, LdImpl, Strip};\n use rustc_session::config::{OutputFilenames, OutputType, PrintRequest};\n use rustc_session::output::{check_file_is_writeable, invalid_output_for_target, out_filename};\n use rustc_session::search_paths::PathKind;\n@@ -14,6 +14,7 @@ use rustc_session::utils::NativeLibKind;\n /// need out of the shared crate context before we get rid of it.\n use rustc_session::{filesearch, Session};\n use rustc_span::symbol::Symbol;\n+use rustc_target::abi::Endian;\n use rustc_target::spec::crt_objects::{CrtObjects, CrtObjectsFallback};\n use rustc_target::spec::{LinkOutputKind, LinkerFlavor, LldFlavor, SplitDebuginfo};\n use rustc_target::spec::{PanicStrategy, RelocModel, RelroLevel, SanitizerSet, Target};\n@@ -28,8 +29,12 @@ use crate::{\n };\n \n use cc::windows_registry;\n+use object::elf;\n+use object::write::Object;\n+use object::{Architecture, BinaryFormat, Endianness, FileFlags, SectionFlags, SectionKind};\n use tempfile::Builder as TempFileBuilder;\n \n+use std::cmp::Ordering;\n use std::ffi::OsString;\n use std::path::{Path, PathBuf};\n use std::process::{ExitStatus, Output, Stdio};\n@@ -278,9 +283,9 @@ pub fn each_linked_rlib(\n /// building an `.rlib` (stomping over one another), or writing an `.rmeta` into a\n /// directory being searched for `extern crate` (observing an incomplete file).\n /// The returned path is the temporary file containing the complete metadata.\n-pub fn emit_metadata(sess: &Session, metadata: &EncodedMetadata, tmpdir: &MaybeTempDir) -> PathBuf {\n+pub fn emit_metadata(sess: &Session, metadata: &[u8], tmpdir: &MaybeTempDir) -> PathBuf {\n     let out_filename = tmpdir.as_ref().join(METADATA_FILENAME);\n-    let result = fs::write(&out_filename, &metadata.raw_data);\n+    let result = fs::write(&out_filename, metadata);\n \n     if let Err(e) = result {\n         sess.fatal(&format!(\"failed to write {}: {}\", out_filename.display(), e));\n@@ -339,6 +344,12 @@ fn link_rlib<'a, B: ArchiveBuilder<'a>>(\n         }\n     }\n \n+    for (raw_dylib_name, raw_dylib_imports) in\n+        collate_raw_dylibs(&codegen_results.crate_info.used_libraries)\n+    {\n+        ab.inject_dll_import_lib(&raw_dylib_name, &raw_dylib_imports, tmpdir);\n+    }\n+\n     // After adding all files to the archive, we need to update the\n     // symbol table of the archive.\n     ab.update_symbols();\n@@ -366,9 +377,11 @@ fn link_rlib<'a, B: ArchiveBuilder<'a>>(\n     // code above.\n     match flavor {\n         RlibFlavor::Normal => {\n-            // Instead of putting the metadata in an object file section, rlibs\n-            // contain the metadata in a separate file.\n-            ab.add_file(&emit_metadata(sess, &codegen_results.metadata, tmpdir));\n+            // metadata in rlib files is wrapped in a \"dummy\" object file for\n+            // the target platform so the rlib can be processed entirely by\n+            // normal linkers for the platform.\n+            let metadata = create_metadata_file(sess, &codegen_results.metadata.raw_data);\n+            ab.add_file(&emit_metadata(sess, &metadata, tmpdir));\n \n             // After adding all files to the archive, we need to update the\n             // symbol table of the archive. This currently dies on macOS (see\n@@ -385,8 +398,188 @@ fn link_rlib<'a, B: ArchiveBuilder<'a>>(\n             }\n         }\n     }\n+    return ab;\n+\n+    // For rlibs we \"pack\" rustc metadata into a dummy object file. When rustc\n+    // creates a dylib crate type it will pass `--whole-archive` (or the\n+    // platform equivalent) to include all object files from an rlib into the\n+    // final dylib itself. This causes linkers to iterate and try to include all\n+    // files located in an archive, so if metadata is stored in an archive then\n+    // it needs to be of a form that the linker will be able to process.\n+    //\n+    // Note, though, that we don't actually want this metadata to show up in any\n+    // final output of the compiler. Instead this is purely for rustc's own\n+    // metadata tracking purposes.\n+    //\n+    // With the above in mind, each \"flavor\" of object format gets special\n+    // handling here depending on the target:\n+    //\n+    // * MachO - macos-like targets will insert the metadata into a section that\n+    //   is sort of fake dwarf debug info. Inspecting the source of the macos\n+    //   linker this causes these sections to be skipped automatically because\n+    //   it's not in an allowlist of otherwise well known dwarf section names to\n+    //   go into the final artifact.\n+    //\n+    // * WebAssembly - we actually don't have any container format for this\n+    //   target. WebAssembly doesn't support the `dylib` crate type anyway so\n+    //   there's no need for us to support this at this time. Consequently the\n+    //   metadata bytes are simply stored as-is into an rlib.\n+    //\n+    // * COFF - Windows-like targets create an object with a section that has\n+    //   the `IMAGE_SCN_LNK_REMOVE` flag set which ensures that if the linker\n+    //   ever sees the section it doesn't process it and it's removed.\n+    //\n+    // * ELF - All other targets are similar to Windows in that there's a\n+    //   `SHF_EXCLUDE` flag we can set on sections in an object file to get\n+    //   automatically removed from the final output.\n+    //\n+    // Note that this metdata format is kept in sync with\n+    // `rustc_codegen_ssa/src/back/metadata.rs`.\n+    fn create_metadata_file(sess: &Session, metadata: &[u8]) -> Vec<u8> {\n+        let endianness = match sess.target.options.endian {\n+            Endian::Little => Endianness::Little,\n+            Endian::Big => Endianness::Big,\n+        };\n+        let architecture = match &sess.target.arch[..] {\n+            \"arm\" => Architecture::Arm,\n+            \"aarch64\" => Architecture::Aarch64,\n+            \"x86\" => Architecture::I386,\n+            \"s390x\" => Architecture::S390x,\n+            \"mips\" => Architecture::Mips,\n+            \"mips64\" => Architecture::Mips64,\n+            \"x86_64\" => {\n+                if sess.target.pointer_width == 32 {\n+                    Architecture::X86_64_X32\n+                } else {\n+                    Architecture::X86_64\n+                }\n+            }\n+            \"powerpc\" => Architecture::PowerPc,\n+            \"powerpc64\" => Architecture::PowerPc64,\n+            \"riscv32\" => Architecture::Riscv32,\n+            \"riscv64\" => Architecture::Riscv64,\n+            \"sparc64\" => Architecture::Sparc64,\n+\n+            // This is used to handle all \"other\" targets. This includes targets\n+            // in two categories:\n+            //\n+            // * Some targets don't have support in the `object` crate just yet\n+            //   to write an object file. These targets are likely to get filled\n+            //   out over time.\n+            //\n+            // * Targets like WebAssembly don't support dylibs, so the purpose\n+            //   of putting metadata in object files, to support linking rlibs\n+            //   into dylibs, is moot.\n+            //\n+            // In both of these cases it means that linking into dylibs will\n+            // not be supported by rustc. This doesn't matter for targets like\n+            // WebAssembly and for targets not supported by the `object` crate\n+            // yet it means that work will need to be done in the `object` crate\n+            // to add a case above.\n+            _ => return metadata.to_vec(),\n+        };\n+\n+        if sess.target.is_like_osx {\n+            let mut file = Object::new(BinaryFormat::MachO, architecture, endianness);\n+\n+            let section =\n+                file.add_section(b\"__DWARF\".to_vec(), b\".rmeta\".to_vec(), SectionKind::Debug);\n+            file.append_section_data(section, metadata, 1);\n+            file.write().unwrap()\n+        } else if sess.target.is_like_windows {\n+            const IMAGE_SCN_LNK_REMOVE: u32 = 0;\n+            let mut file = Object::new(BinaryFormat::Coff, architecture, endianness);\n+\n+            let section = file.add_section(Vec::new(), b\".rmeta\".to_vec(), SectionKind::Debug);\n+            file.section_mut(section).flags =\n+                SectionFlags::Coff { characteristics: IMAGE_SCN_LNK_REMOVE };\n+            file.append_section_data(section, metadata, 1);\n+            file.write().unwrap()\n+        } else {\n+            const SHF_EXCLUDE: u64 = 0x80000000;\n+            let mut file = Object::new(BinaryFormat::Elf, architecture, endianness);\n+\n+            match &sess.target.arch[..] {\n+                // copied from `mipsel-linux-gnu-gcc foo.c -c` and\n+                // inspecting the resulting `e_flags` field.\n+                \"mips\" => {\n+                    let e_flags = elf::EF_MIPS_ARCH_32R2 | elf::EF_MIPS_CPIC | elf::EF_MIPS_PIC;\n+                    file.flags = FileFlags::Elf { e_flags };\n+                }\n+                // copied from `mips64el-linux-gnuabi64-gcc foo.c -c`\n+                \"mips64\" => {\n+                    let e_flags = elf::EF_MIPS_ARCH_64R2 | elf::EF_MIPS_CPIC | elf::EF_MIPS_PIC;\n+                    file.flags = FileFlags::Elf { e_flags };\n+                }\n+\n+                // copied from `riscv64-linux-gnu-gcc foo.c -c`, note though\n+                // that the `+d` target feature represents whether the double\n+                // float abi is enabled.\n+                \"riscv64\" if sess.target.options.features.contains(\"+d\") => {\n+                    let e_flags = elf::EF_RISCV_RVC | elf::EF_RISCV_FLOAT_ABI_DOUBLE;\n+                    file.flags = FileFlags::Elf { e_flags };\n+                }\n+\n+                _ => {}\n+            }\n+\n+            let section = file.add_section(Vec::new(), b\".rmeta\".to_vec(), SectionKind::Debug);\n+            file.section_mut(section).flags = SectionFlags::Elf { sh_flags: SHF_EXCLUDE };\n+            file.append_section_data(section, metadata, 1);\n+            file.write().unwrap()\n+        }\n+    }\n+}\n+\n+/// Extract all symbols defined in raw-dylib libraries, collated by library name.\n+///\n+/// If we have multiple extern blocks that specify symbols defined in the same raw-dylib library,\n+/// then the CodegenResults value contains one NativeLib instance for each block.  However, the\n+/// linker appears to expect only a single import library for each library used, so we need to\n+/// collate the symbols together by library name before generating the import libraries.\n+fn collate_raw_dylibs(used_libraries: &[NativeLib]) -> Vec<(String, Vec<DllImport>)> {\n+    let mut dylib_table: FxHashMap<String, FxHashSet<Symbol>> = FxHashMap::default();\n+\n+    for lib in used_libraries {\n+        if lib.kind == NativeLibKind::RawDylib {\n+            let name = lib.name.unwrap_or_else(||\n+                bug!(\"`link` attribute with kind = \\\"raw-dylib\\\" and no name should have caused error earlier\")\n+            );\n+            let name = if matches!(lib.verbatim, Some(true)) {\n+                name.to_string()\n+            } else {\n+                format!(\"{}.dll\", name)\n+            };\n+            dylib_table\n+                .entry(name)\n+                .or_default()\n+                .extend(lib.dll_imports.iter().map(|import| import.name));\n+        }\n+    }\n \n-    ab\n+    // FIXME: when we add support for ordinals, fix this to propagate ordinals.  Also figure out\n+    // what we should do if we have two DllImport values with the same name but different\n+    // ordinals.\n+    let mut result = dylib_table\n+        .into_iter()\n+        .map(|(lib_name, imported_names)| {\n+            let mut names = imported_names\n+                .iter()\n+                .map(|name| DllImport { name: *name, ordinal: None })\n+                .collect::<Vec<_>>();\n+            names.sort_unstable_by(|a: &DllImport, b: &DllImport| {\n+                match a.name.as_str().cmp(&b.name.as_str()) {\n+                    Ordering::Equal => a.ordinal.cmp(&b.ordinal),\n+                    x => x,\n+                }\n+            });\n+            (lib_name, names)\n+        })\n+        .collect::<Vec<_>>();\n+    result.sort_unstable_by(|a: &(String, Vec<DllImport>), b: &(String, Vec<DllImport>)| {\n+        a.0.cmp(&b.0)\n+    });\n+    result\n }\n \n /// Create a static archive.\n@@ -714,14 +907,6 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(\n         }\n     }\n \n-    fn escape_string(s: &[u8]) -> String {\n-        str::from_utf8(s).map(|s| s.to_owned()).unwrap_or_else(|_| {\n-            let mut x = \"Non-UTF-8 output: \".to_string();\n-            x.extend(s.iter().flat_map(|&b| ascii::escape_default(b)).map(char::from));\n-            x\n-        })\n-    }\n-\n     match prog {\n         Ok(prog) => {\n             if !prog.status.success() {\n@@ -863,9 +1048,50 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(\n         // ... and otherwise we're processing a `*.dwp` packed dwarf file.\n         SplitDebuginfo::Packed => link_dwarf_object(sess, &out_filename),\n     }\n+\n+    if sess.target.is_like_osx {\n+        if let Some(option) = osx_strip_opt(sess.opts.debugging_opts.strip) {\n+            strip_symbols_in_osx(sess, &out_filename, option);\n+        }\n+    }\n }\n \n-fn link_sanitizers(sess: &Session, crate_type: CrateType, linker: &mut dyn Linker) {\n+fn strip_symbols_in_osx<'a>(sess: &'a Session, out_filename: &Path, option: &str) {\n+    let prog = Command::new(\"strip\").arg(option).arg(out_filename).output();\n+    match prog {\n+        Ok(prog) => {\n+            if !prog.status.success() {\n+                let mut output = prog.stderr.clone();\n+                output.extend_from_slice(&prog.stdout);\n+                sess.struct_warn(&format!(\n+                    \"stripping debug info with `strip` failed: {}\",\n+                    prog.status\n+                ))\n+                .note(&escape_string(&output))\n+                .emit();\n+            }\n+        }\n+        Err(e) => sess.fatal(&format!(\"unable to run `strip`: {}\", e)),\n+    }\n+}\n+\n+fn osx_strip_opt<'a>(strip: Strip) -> Option<&'a str> {\n+    match strip {\n+        Strip::Debuginfo => Some(\"-S\"),\n+        Strip::Symbols => Some(\"-x\"),\n+        Strip::None => None,\n+    }\n+}\n+\n+fn escape_string(s: &[u8]) -> String {\n+    str::from_utf8(s).map(|s| s.to_owned()).unwrap_or_else(|_| {\n+        let mut x = \"Non-UTF-8 output: \".to_string();\n+        x.extend(s.iter().flat_map(|&b| ascii::escape_default(b)).map(char::from));\n+        x\n+    })\n+}\n+\n+fn add_sanitizer_libraries(sess: &Session, crate_type: CrateType, linker: &mut dyn Linker) {\n     // On macOS the runtimes are distributed as dylibs which should be linked to\n     // both executables and dynamic shared objects. Everywhere else the runtimes\n     // are currently distributed as static liraries which should be linked to\n@@ -954,7 +1180,8 @@ pub fn ignored_for_lto(sess: &Session, info: &CrateInfo, cnum: CrateNum) -> bool\n         && (info.compiler_builtins == Some(cnum) || info.is_no_builtins.contains(&cnum))\n }\n \n-fn linker_and_flavor(sess: &Session) -> (PathBuf, LinkerFlavor) {\n+// This functions tries to determine the appropriate linker (and corresponding LinkerFlavor) to use\n+pub fn linker_and_flavor(sess: &Session) -> (PathBuf, LinkerFlavor) {\n     fn infer_from(\n         sess: &Session,\n         linker: Option<PathBuf>,\n@@ -989,6 +1216,7 @@ fn linker_and_flavor(sess: &Session) -> (PathBuf, LinkerFlavor) {\n                     LinkerFlavor::Msvc => \"link.exe\",\n                     LinkerFlavor::Lld(_) => \"lld\",\n                     LinkerFlavor::PtxLinker => \"rust-ptx-linker\",\n+                    LinkerFlavor::BpfLinker => \"bpf-linker\",\n                 }),\n                 flavor,\n             )),\n@@ -1005,6 +1233,8 @@ fn linker_and_flavor(sess: &Session) -> (PathBuf, LinkerFlavor) {\n                     || stem.ends_with(\"-clang\")\n                 {\n                     LinkerFlavor::Gcc\n+                } else if stem == \"wasm-ld\" || stem.ends_with(\"-wasm-ld\") {\n+                    LinkerFlavor::Lld(LldFlavor::Wasm)\n                 } else if stem == \"ld\" || stem == \"ld.lld\" || stem.ends_with(\"-ld\") {\n                     LinkerFlavor::Ld\n                 } else if stem == \"link\" || stem == \"lld-link\" {\n@@ -1484,55 +1714,6 @@ fn add_local_crate_metadata_objects(\n     }\n }\n \n-/// Link native libraries corresponding to the current crate and all libraries corresponding to\n-/// all its dependency crates.\n-/// FIXME: Consider combining this with the functions above adding object files for the local crate.\n-fn link_local_crate_native_libs_and_dependent_crate_libs<'a, B: ArchiveBuilder<'a>>(\n-    cmd: &mut dyn Linker,\n-    sess: &'a Session,\n-    crate_type: CrateType,\n-    codegen_results: &CodegenResults,\n-    tmpdir: &Path,\n-) {\n-    // Take careful note of the ordering of the arguments we pass to the linker\n-    // here. Linkers will assume that things on the left depend on things to the\n-    // right. Things on the right cannot depend on things on the left. This is\n-    // all formally implemented in terms of resolving symbols (libs on the right\n-    // resolve unknown symbols of libs on the left, but not vice versa).\n-    //\n-    // For this reason, we have organized the arguments we pass to the linker as\n-    // such:\n-    //\n-    // 1. The local object that LLVM just generated\n-    // 2. Local native libraries\n-    // 3. Upstream rust libraries\n-    // 4. Upstream native libraries\n-    //\n-    // The rationale behind this ordering is that those items lower down in the\n-    // list can't depend on items higher up in the list. For example nothing can\n-    // depend on what we just generated (e.g., that'd be a circular dependency).\n-    // Upstream rust libraries are not allowed to depend on our local native\n-    // libraries as that would violate the structure of the DAG, in that\n-    // scenario they are required to link to them as well in a shared fashion.\n-    //\n-    // Note that upstream rust libraries may contain native dependencies as\n-    // well, but they also can't depend on what we just started to add to the\n-    // link line. And finally upstream native libraries can't depend on anything\n-    // in this DAG so far because they're only dylibs and dylibs can only depend\n-    // on other dylibs (e.g., other native deps).\n-    //\n-    // If -Zlink-native-libraries=false is set, then the assumption is that an\n-    // external build system already has the native dependencies defined, and it\n-    // will provide them to the linker itself.\n-    if sess.opts.debugging_opts.link_native_libraries {\n-        add_local_native_libraries(cmd, sess, codegen_results);\n-    }\n-    add_upstream_rust_crates::<B>(cmd, sess, codegen_results, crate_type, tmpdir);\n-    if sess.opts.debugging_opts.link_native_libraries {\n-        add_upstream_native_libraries(cmd, sess, codegen_results, crate_type);\n-    }\n-}\n-\n /// Add sysroot and other globally set directories to the directory search list.\n fn add_library_search_dirs(cmd: &mut dyn Linker, sess: &Session, self_contained: bool) {\n     // The default library location, we need this to find the runtime.\n@@ -1567,36 +1748,27 @@ fn add_rpath_args(\n ) {\n     // FIXME (#2397): At some point we want to rpath our guesses as to\n     // where extern libraries might live, based on the\n-    // addl_lib_search_paths\n+    // add_lib_search_paths\n     if sess.opts.cg.rpath {\n-        let target_triple = sess.opts.target_triple.triple();\n-        let mut get_install_prefix_lib_path = || {\n-            let install_prefix = option_env!(\"CFG_PREFIX\").expect(\"CFG_PREFIX\");\n-            let tlib = rustc_target::target_rustlib_path(&sess.sysroot, target_triple).join(\"lib\");\n-            let mut path = PathBuf::from(install_prefix);\n-            path.push(&tlib);\n-\n-            path\n-        };\n         let mut rpath_config = RPathConfig {\n             used_crates: &codegen_results.crate_info.used_crates_dynamic,\n             out_filename: out_filename.to_path_buf(),\n             has_rpath: sess.target.has_rpath,\n             is_like_osx: sess.target.is_like_osx,\n             linker_is_gnu: sess.target.linker_is_gnu,\n-            get_install_prefix_lib_path: &mut get_install_prefix_lib_path,\n         };\n         cmd.args(&rpath::get_rpath_flags(&mut rpath_config));\n     }\n }\n \n /// Produce the linker command line containing linker path and arguments.\n-/// `NO-OPT-OUT` marks the arguments that cannot be removed from the command line\n-/// by the user without creating a custom target specification.\n-/// `OBJECT-FILES` specify whether the arguments can add object files.\n-/// `CUSTOMIZATION-POINT` means that arbitrary arguments defined by the user\n-/// or by the target spec can be inserted here.\n-/// `AUDIT-ORDER` - need to figure out whether the option is order-dependent or not.\n+///\n+/// When comments in the function say \"order-(in)dependent\" they mean order-dependence between\n+/// options and libraries/object files. For example `--whole-archive` (order-dependent) applies\n+/// to specific libraries passed after it, and `-o` (output file, order-independent) applies\n+/// to the linking process as a whole.\n+/// Order-independent options may still override each other in order-dependent fashion,\n+/// e.g `--foo=yes --foo=no` may be equivalent to `--foo=no`.\n fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n     path: &Path,\n     flavor: LinkerFlavor,\n@@ -1614,16 +1786,153 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n     let cmd = &mut *codegen_results.linker_info.to_linker(base_cmd, &sess, flavor);\n     let link_output_kind = link_output_kind(sess, crate_type);\n \n-    // NO-OPT-OUT, OBJECT-FILES-MAYBE, CUSTOMIZATION-POINT\n+    // ------------ Early order-dependent options ------------\n+\n+    // If we're building something like a dynamic library then some platforms\n+    // need to make sure that all symbols are exported correctly from the\n+    // dynamic library.\n+    // Must be passed before any libraries to prevent the symbols to export from being thrown away,\n+    // at least on some platforms (e.g. windows-gnu).\n+    cmd.export_symbols(tmpdir, crate_type);\n+\n+    // Can be used for adding custom CRT objects or overriding order-dependent options above.\n+    // FIXME: In practice built-in target specs use this for arbitrary order-independent options,\n+    // introduce a target spec option for order-independent linker options and migrate built-in\n+    // specs to it.\n     add_pre_link_args(cmd, sess, flavor);\n \n-    // NO-OPT-OUT, OBJECT-FILES-NO\n+    // ------------ Object code and libraries, order-dependent ------------\n+\n+    // Pre-link CRT objects.\n+    add_pre_link_objects(cmd, sess, link_output_kind, crt_objects_fallback);\n+\n+    // Sanitizer libraries.\n+    add_sanitizer_libraries(sess, crate_type, cmd);\n+\n+    // Object code from the current crate.\n+    // Take careful note of the ordering of the arguments we pass to the linker\n+    // here. Linkers will assume that things on the left depend on things to the\n+    // right. Things on the right cannot depend on things on the left. This is\n+    // all formally implemented in terms of resolving symbols (libs on the right\n+    // resolve unknown symbols of libs on the left, but not vice versa).\n+    //\n+    // For this reason, we have organized the arguments we pass to the linker as\n+    // such:\n+    //\n+    // 1. The local object that LLVM just generated\n+    // 2. Local native libraries\n+    // 3. Upstream rust libraries\n+    // 4. Upstream native libraries\n+    //\n+    // The rationale behind this ordering is that those items lower down in the\n+    // list can't depend on items higher up in the list. For example nothing can\n+    // depend on what we just generated (e.g., that'd be a circular dependency).\n+    // Upstream rust libraries are not supposed to depend on our local native\n+    // libraries as that would violate the structure of the DAG, in that\n+    // scenario they are required to link to them as well in a shared fashion.\n+    // (The current implementation still doesn't prevent it though, see the FIXME below.)\n+    //\n+    // Note that upstream rust libraries may contain native dependencies as\n+    // well, but they also can't depend on what we just started to add to the\n+    // link line. And finally upstream native libraries can't depend on anything\n+    // in this DAG so far because they can only depend on other native libraries\n+    // and such dependencies are also required to be specified.\n+    add_local_crate_regular_objects(cmd, codegen_results);\n+    add_local_crate_metadata_objects(cmd, crate_type, codegen_results);\n+    add_local_crate_allocator_objects(cmd, codegen_results);\n+\n+    // Avoid linking to dynamic libraries unless they satisfy some undefined symbols\n+    // at the point at which they are specified on the command line.\n+    // Must be passed before any (dynamic) libraries to have effect on them.\n+    // On Solaris-like systems, `-z ignore` acts as both `--as-needed` and `--gc-sections`\n+    // so it will ignore unreferenced ELF sections from relocatable objects.\n+    // For that reason, we put this flag after metadata objects as they would otherwise be removed.\n+    // FIXME: Support more fine-grained dead code removal on Solaris/illumos\n+    // and move this option back to the top.\n+    cmd.add_as_needed();\n+\n+    // FIXME: Move this below to other native libraries\n+    // (or alternatively link all native libraries after their respective crates).\n+    // This change is somewhat breaking in practice due to local static libraries being linked\n+    // as whole-archive (#85144), so removing whole-archive may be a pre-requisite.\n+    if sess.opts.debugging_opts.link_native_libraries {\n+        add_local_native_libraries(cmd, sess, codegen_results);\n+    }\n+\n+    // Rust libraries.\n+    add_upstream_rust_crates::<B>(cmd, sess, codegen_results, crate_type, tmpdir);\n+\n+    // Native libraries linked with `#[link]` attributes at and `-l` command line options.\n+    // If -Zlink-native-libraries=false is set, then the assumption is that an\n+    // external build system already has the native dependencies defined, and it\n+    // will provide them to the linker itself.\n+    if sess.opts.debugging_opts.link_native_libraries {\n+        add_upstream_native_libraries(cmd, sess, codegen_results, crate_type);\n+    }\n+\n+    // Library linking above uses some global state for things like `-Bstatic`/`-Bdynamic` to make\n+    // command line shorter, reset it to default here before adding more libraries.\n+    cmd.reset_per_library_state();\n+\n+    // FIXME: Built-in target specs occasionally use this for linking system libraries,\n+    // eliminate all such uses by migrating them to `#[link]` attributes in `lib(std,c,unwind)`\n+    // and remove the option.\n+    add_late_link_args(cmd, sess, flavor, crate_type, codegen_results);\n+\n+    // ------------ Arbitrary order-independent options ------------\n+\n+    // Add order-independent options determined by rustc from its compiler options,\n+    // target properties and source code.\n+    add_order_independent_options(\n+        cmd,\n+        sess,\n+        link_output_kind,\n+        crt_objects_fallback,\n+        flavor,\n+        crate_type,\n+        codegen_results,\n+        out_filename,\n+        tmpdir,\n+    );\n+\n+    // Can be used for arbitrary order-independent options.\n+    // In practice may also be occasionally used for linking native libraries.\n+    // Passed after compiler-generated options to support manual overriding when necessary.\n+    add_user_defined_link_args(cmd, sess);\n+\n+    // ------------ Object code and libraries, order-dependent ------------\n+\n+    // Post-link CRT objects.\n+    add_post_link_objects(cmd, sess, link_output_kind, crt_objects_fallback);\n+\n+    // ------------ Late order-dependent options ------------\n+\n+    // Doesn't really make sense.\n+    // FIXME: In practice built-in target specs use this for arbitrary order-independent options,\n+    // introduce a target spec option for order-independent linker options, migrate built-in specs\n+    // to it and remove the option.\n+    add_post_link_args(cmd, sess, flavor);\n+\n+    cmd.take_cmd()\n+}\n+\n+fn add_order_independent_options(\n+    cmd: &mut dyn Linker,\n+    sess: &Session,\n+    link_output_kind: LinkOutputKind,\n+    crt_objects_fallback: bool,\n+    flavor: LinkerFlavor,\n+    crate_type: CrateType,\n+    codegen_results: &CodegenResults,\n+    out_filename: &Path,\n+    tmpdir: &Path,\n+) {\n+    add_gcc_ld_path(cmd, sess, flavor);\n+\n     add_apple_sdk(cmd, sess, flavor);\n \n-    // NO-OPT-OUT\n     add_link_script(cmd, sess, tmpdir, crate_type);\n \n-    // NO-OPT-OUT, OBJECT-FILES-NO, AUDIT-ORDER\n     if sess.target.is_like_fuchsia && crate_type == CrateType::Executable {\n         let prefix = if sess.opts.debugging_opts.sanitizer.contains(SanitizerSet::ADDRESS) {\n             \"asan/\"\n@@ -1633,30 +1942,17 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n         cmd.arg(format!(\"--dynamic-linker={}ld.so.1\", prefix));\n     }\n \n-    // NO-OPT-OUT, OBJECT-FILES-NO, AUDIT-ORDER\n     if sess.target.eh_frame_header {\n         cmd.add_eh_frame_header();\n     }\n \n-    // NO-OPT-OUT, OBJECT-FILES-NO, AUDIT-ORDER\n     // Make the binary compatible with data execution prevention schemes.\n     cmd.add_no_exec();\n \n-    // NO-OPT-OUT, OBJECT-FILES-NO\n-    // Avoid linking to dynamic libraries unless they satisfy some undefined symbols\n-    // at the point at which they are specified on the command line.\n-    // Must be passed before any dynamic libraries.\n-    cmd.add_as_needed();\n-\n-    // NO-OPT-OUT, OBJECT-FILES-NO\n     if crt_objects_fallback {\n         cmd.no_crt_objects();\n     }\n \n-    // NO-OPT-OUT, OBJECT-FILES-YES\n-    add_pre_link_objects(cmd, sess, link_output_kind, crt_objects_fallback);\n-\n-    // NO-OPT-OUT, OBJECT-FILES-NO, AUDIT-ORDER\n     if sess.target.is_like_emscripten {\n         cmd.arg(\"-s\");\n         cmd.arg(if sess.panic_strategy() == PanicStrategy::Abort {\n@@ -1666,111 +1962,64 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n         });\n     }\n \n-    // OBJECT-FILES-YES, AUDIT-ORDER\n-    link_sanitizers(sess, crate_type, cmd);\n+    if flavor == LinkerFlavor::PtxLinker {\n+        // Provide the linker with fallback to internal `target-cpu`.\n+        cmd.arg(\"--fallback-arch\");\n+        cmd.arg(&codegen_results.linker_info.target_cpu);\n+    } else if flavor == LinkerFlavor::BpfLinker {\n+        cmd.arg(\"--cpu\");\n+        cmd.arg(&codegen_results.linker_info.target_cpu);\n+        cmd.arg(\"--cpu-features\");\n+        cmd.arg(match &sess.opts.cg.target_feature {\n+            feat if !feat.is_empty() => feat,\n+            _ => &sess.target.options.features,\n+        });\n+    }\n \n-    // OBJECT-FILES-NO, AUDIT-ORDER\n-    // Linker plugins should be specified early in the list of arguments\n-    // FIXME: How \"early\" exactly?\n     cmd.linker_plugin_lto();\n \n-    // NO-OPT-OUT, OBJECT-FILES-NO, AUDIT-ORDER\n-    // FIXME: Order-dependent, at least relatively to other args adding searh directories.\n     add_library_search_dirs(cmd, sess, crt_objects_fallback);\n \n-    // OBJECT-FILES-YES\n-    add_local_crate_regular_objects(cmd, codegen_results);\n-\n-    // NO-OPT-OUT, OBJECT-FILES-NO, AUDIT-ORDER\n     cmd.output_filename(out_filename);\n \n-    // OBJECT-FILES-NO, AUDIT-ORDER\n     if crate_type == CrateType::Executable && sess.target.is_like_windows {\n-        if let Some(ref s) = codegen_results.windows_subsystem {\n+        if let Some(ref s) = codegen_results.crate_info.windows_subsystem {\n             cmd.subsystem(s);\n         }\n     }\n \n-    // NO-OPT-OUT, OBJECT-FILES-NO, AUDIT-ORDER\n-    // If we're building something like a dynamic library then some platforms\n-    // need to make sure that all symbols are exported correctly from the\n-    // dynamic library.\n-    cmd.export_symbols(tmpdir, crate_type);\n-\n-    // OBJECT-FILES-YES\n-    add_local_crate_metadata_objects(cmd, crate_type, codegen_results);\n-\n-    // OBJECT-FILES-YES\n-    add_local_crate_allocator_objects(cmd, codegen_results);\n-\n-    // OBJECT-FILES-NO, AUDIT-ORDER\n-    // FIXME: Order dependent, applies to the following objects. Where should it be placed?\n     // Try to strip as much out of the generated object by removing unused\n     // sections if possible. See more comments in linker.rs\n     if !sess.link_dead_code() {\n         let keep_metadata = crate_type == CrateType::Dylib;\n         cmd.gc_sections(keep_metadata);\n     }\n \n-    // NO-OPT-OUT, OBJECT-FILES-NO, AUDIT-ORDER\n     cmd.set_output_kind(link_output_kind, out_filename);\n \n-    // OBJECT-FILES-NO, AUDIT-ORDER\n     add_relro_args(cmd, sess);\n \n-    // OBJECT-FILES-NO, AUDIT-ORDER\n     // Pass optimization flags down to the linker.\n     cmd.optimize();\n \n-    // OBJECT-FILES-NO, AUDIT-ORDER\n     // Pass debuginfo and strip flags down to the linker.\n     cmd.debuginfo(sess.opts.debugging_opts.strip);\n \n-    // OBJECT-FILES-NO, AUDIT-ORDER\n     // We want to prevent the compiler from accidentally leaking in any system libraries,\n     // so by default we tell linkers not to link to any default libraries.\n     if !sess.opts.cg.default_linker_libraries && sess.target.no_default_libraries {\n         cmd.no_default_libraries();\n     }\n \n-    // OBJECT-FILES-YES\n-    link_local_crate_native_libs_and_dependent_crate_libs::<B>(\n-        cmd,\n-        sess,\n-        crate_type,\n-        codegen_results,\n-        tmpdir,\n-    );\n-\n-    // OBJECT-FILES-NO, AUDIT-ORDER\n     if sess.opts.cg.profile_generate.enabled() || sess.instrument_coverage() {\n         cmd.pgo_gen();\n     }\n \n-    // OBJECT-FILES-NO, AUDIT-ORDER\n     if sess.opts.cg.control_flow_guard != CFGuard::Disabled {\n         cmd.control_flow_guard();\n     }\n \n-    // OBJECT-FILES-NO, AUDIT-ORDER\n     add_rpath_args(cmd, sess, codegen_results, out_filename);\n-\n-    // OBJECT-FILES-MAYBE, CUSTOMIZATION-POINT\n-    add_user_defined_link_args(cmd, sess);\n-\n-    // NO-OPT-OUT, OBJECT-FILES-NO, AUDIT-ORDER\n-    cmd.finalize();\n-\n-    // NO-OPT-OUT, OBJECT-FILES-MAYBE, CUSTOMIZATION-POINT\n-    add_late_link_args(cmd, sess, flavor, crate_type, codegen_results);\n-\n-    // NO-OPT-OUT, OBJECT-FILES-YES\n-    add_post_link_objects(cmd, sess, link_output_kind, crt_objects_fallback);\n-\n-    // NO-OPT-OUT, OBJECT-FILES-MAYBE, CUSTOMIZATION-POINT\n-    add_post_link_args(cmd, sess, flavor);\n-\n-    cmd.take_cmd()\n }\n \n /// # Native library linking\n@@ -1964,11 +2213,8 @@ fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(\n     }\n \n     // Adds the static \"rlib\" versions of all crates to the command line.\n-    // There's a bit of magic which happens here specifically related to LTO and\n-    // dynamic libraries. Specifically:\n-    //\n-    // * For LTO, we remove upstream object files.\n-    // * For dylibs we remove metadata and bytecode from upstream rlibs\n+    // There's a bit of magic which happens here specifically related to LTO,\n+    // namely that we remove upstream object files.\n     //\n     // When performing LTO, almost(*) all of the bytecode from the upstream\n     // libraries has already been included in our object file output. As a\n@@ -1981,20 +2227,9 @@ fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(\n     // their bytecode wasn't included. The object files in those libraries must\n     // still be passed to the linker.\n     //\n-    // When making a dynamic library, linkers by default don't include any\n-    // object files in an archive if they're not necessary to resolve the link.\n-    // We basically want to convert the archive (rlib) to a dylib, though, so we\n-    // *do* want everything included in the output, regardless of whether the\n-    // linker thinks it's needed or not. As a result we must use the\n-    // --whole-archive option (or the platform equivalent). When using this\n-    // option the linker will fail if there are non-objects in the archive (such\n-    // as our own metadata and/or bytecode). All in all, for rlibs to be\n-    // entirely included in dylibs, we need to remove all non-object files.\n-    //\n-    // Note, however, that if we're not doing LTO or we're not producing a dylib\n-    // (aka we're making an executable), we can just pass the rlib blindly to\n-    // the linker (fast) because it's fine if it's not actually included as\n-    // we're at the end of the dependency chain.\n+    // Note, however, that if we're not doing LTO we can just pass the rlib\n+    // blindly to the linker (fast) because it's fine if it's not actually\n+    // included as we're at the end of the dependency chain.\n     fn add_static_crate<'a, B: ArchiveBuilder<'a>>(\n         cmd: &mut dyn Linker,\n         sess: &'a Session,\n@@ -2006,6 +2241,24 @@ fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(\n         let src = &codegen_results.crate_info.used_crate_source[&cnum];\n         let cratepath = &src.rlib.as_ref().unwrap().0;\n \n+        let mut link_upstream = |path: &Path| {\n+            // If we're creating a dylib, then we need to include the\n+            // whole of each object in our archive into that artifact. This is\n+            // because a `dylib` can be reused as an intermediate artifact.\n+            //\n+            // Note, though, that we don't want to include the whole of a\n+            // compiler-builtins crate (e.g., compiler-rt) because it'll get\n+            // repeatedly linked anyway.\n+            let path = fix_windows_verbatim_for_gcc(path);\n+            if crate_type == CrateType::Dylib\n+                && codegen_results.crate_info.compiler_builtins != Some(cnum)\n+            {\n+                cmd.link_whole_rlib(&path);\n+            } else {\n+                cmd.link_rlib(&path);\n+            }\n+        };\n+\n         // See the comment above in `link_staticlib` and `link_rlib` for why if\n         // there's a static library that's not relevant we skip all object\n         // files.\n@@ -2017,10 +2270,9 @@ fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(\n \n         if (!are_upstream_rust_objects_already_included(sess)\n             || ignored_for_lto(sess, &codegen_results.crate_info, cnum))\n-            && crate_type != CrateType::Dylib\n             && !skip_native\n         {\n-            cmd.link_rlib(&fix_windows_verbatim_for_gcc(cratepath));\n+            link_upstream(cratepath);\n             return;\n         }\n \n@@ -2070,21 +2322,7 @@ fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(\n                 return;\n             }\n             archive.build();\n-\n-            // If we're creating a dylib, then we need to include the\n-            // whole of each object in our archive into that artifact. This is\n-            // because a `dylib` can be reused as an intermediate artifact.\n-            //\n-            // Note, though, that we don't want to include the whole of a\n-            // compiler-builtins crate (e.g., compiler-rt) because it'll get\n-            // repeatedly linked anyway.\n-            if crate_type == CrateType::Dylib\n-                && codegen_results.crate_info.compiler_builtins != Some(cnum)\n-            {\n-                cmd.link_whole_rlib(&fix_windows_verbatim_for_gcc(&dst));\n-            } else {\n-                cmd.link_rlib(&fix_windows_verbatim_for_gcc(&dst));\n-            }\n+            link_upstream(&dst);\n         });\n     }\n \n@@ -2178,10 +2416,7 @@ fn add_upstream_native_libraries(\n                 // already included them when we included the rust library\n                 // previously\n                 NativeLibKind::Static { bundle: None | Some(true), .. } => {}\n-                NativeLibKind::RawDylib => {\n-                    // FIXME(#58713): Proper handling for raw dylibs.\n-                    bug!(\"raw_dylib feature not yet implemented\");\n-                }\n+                NativeLibKind::RawDylib => {}\n             }\n         }\n     }\n@@ -2295,3 +2530,30 @@ fn get_apple_sdk_root(sdk_name: &str) -> Result<String, String> {\n         Err(e) => Err(format!(\"failed to get {} SDK path: {}\", sdk_name, e)),\n     }\n }\n+\n+fn add_gcc_ld_path(cmd: &mut dyn Linker, sess: &Session, flavor: LinkerFlavor) {\n+    if let Some(ld_impl) = sess.opts.debugging_opts.gcc_ld {\n+        if let LinkerFlavor::Gcc = flavor {\n+            match ld_impl {\n+                LdImpl::Lld => {\n+                    let tools_path =\n+                        sess.host_filesearch(PathKind::All).get_tools_search_paths(false);\n+                    let lld_path = tools_path\n+                        .into_iter()\n+                        .map(|p| p.join(\"gcc-ld\"))\n+                        .find(|p| {\n+                            p.join(if sess.host.is_like_windows { \"ld.exe\" } else { \"ld\" }).exists()\n+                        })\n+                        .unwrap_or_else(|| sess.fatal(\"rust-lld (as ld) not found\"));\n+                    cmd.cmd().arg({\n+                        let mut arg = OsString::from(\"-B\");\n+                        arg.push(lld_path);\n+                        arg\n+                    });\n+                }\n+            }\n+        } else {\n+            sess.fatal(\"option `-Z gcc-ld` is used even though linker flavor is not gcc\");\n+        }\n+    }\n+}"}, {"sha": "43ff664c3e641059488a75f90f672990418144bb", "filename": "compiler/rustc_codegen_ssa/src/back/linker.rs", "status": "modified", "additions": 132, "deletions": 23, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -37,7 +37,7 @@ pub fn disable_localization(linker: &mut Command) {\n /// need out of the shared crate context before we get rid of it.\n #[derive(Encodable, Decodable)]\n pub struct LinkerInfo {\n-    target_cpu: String,\n+    pub(super) target_cpu: String,\n     exports: FxHashMap<CrateType, Vec<String>>,\n }\n \n@@ -81,8 +81,10 @@ impl LinkerInfo {\n                 Box::new(WasmLd::new(cmd, sess, self)) as Box<dyn Linker>\n             }\n \n-            LinkerFlavor::PtxLinker => {\n-                Box::new(PtxLinker { cmd, sess, info: self }) as Box<dyn Linker>\n+            LinkerFlavor::PtxLinker => Box::new(PtxLinker { cmd, sess }) as Box<dyn Linker>,\n+\n+            LinkerFlavor::BpfLinker => {\n+                Box::new(BpfLinker { cmd, sess, info: self }) as Box<dyn Linker>\n             }\n         }\n     }\n@@ -128,7 +130,7 @@ pub trait Linker {\n     fn add_eh_frame_header(&mut self) {}\n     fn add_no_exec(&mut self) {}\n     fn add_as_needed(&mut self) {}\n-    fn finalize(&mut self);\n+    fn reset_per_library_state(&mut self) {}\n }\n \n impl dyn Linker + '_ {\n@@ -472,21 +474,23 @@ impl<'a> Linker for GccLinker<'a> {\n         // eliminate the metadata. If we're building an executable, however,\n         // --gc-sections drops the size of hello world from 1.8MB to 597K, a 67%\n         // reduction.\n-        } else if self.sess.target.linker_is_gnu && !keep_metadata {\n+        } else if (self.sess.target.linker_is_gnu || self.sess.target.is_like_wasm)\n+            && !keep_metadata\n+        {\n             self.linker_arg(\"--gc-sections\");\n         }\n     }\n \n     fn no_gc_sections(&mut self) {\n         if self.sess.target.is_like_osx {\n             self.linker_arg(\"-no_dead_strip\");\n-        } else if self.sess.target.linker_is_gnu {\n+        } else if self.sess.target.linker_is_gnu || self.sess.target.is_like_wasm {\n             self.linker_arg(\"--no-gc-sections\");\n         }\n     }\n \n     fn optimize(&mut self) {\n-        if !self.sess.target.linker_is_gnu {\n+        if !self.sess.target.linker_is_gnu && !self.sess.target.is_like_wasm {\n             return;\n         }\n \n@@ -522,15 +526,18 @@ impl<'a> Linker for GccLinker<'a> {\n     fn control_flow_guard(&mut self) {}\n \n     fn debuginfo(&mut self, strip: Strip) {\n+        // MacOS linker doesn't support stripping symbols directly anymore.\n+        if self.sess.target.is_like_osx {\n+            return;\n+        }\n+\n         match strip {\n             Strip::None => {}\n             Strip::Debuginfo => {\n-                // MacOS linker does not support longhand argument --strip-debug\n-                self.linker_arg(\"-S\");\n+                self.linker_arg(\"--strip-debug\");\n             }\n             Strip::Symbols => {\n-                // MacOS linker does not support longhand argument --strip-all\n-                self.linker_arg(\"-s\");\n+                self.linker_arg(\"--strip-all\");\n             }\n         }\n     }\n@@ -647,7 +654,7 @@ impl<'a> Linker for GccLinker<'a> {\n         self.linker_arg(&subsystem);\n     }\n \n-    fn finalize(&mut self) {\n+    fn reset_per_library_state(&mut self) {\n         self.hint_dynamic(); // Reset to default before returning the composed command line.\n     }\n \n@@ -931,8 +938,6 @@ impl<'a> Linker for MsvcLinker<'a> {\n         }\n     }\n \n-    fn finalize(&mut self) {}\n-\n     // MSVC doesn't need group indicators\n     fn group_start(&mut self) {}\n     fn group_end(&mut self) {}\n@@ -1093,8 +1098,6 @@ impl<'a> Linker for EmLinker<'a> {\n         // noop\n     }\n \n-    fn finalize(&mut self) {}\n-\n     // Appears not necessary on Emscripten\n     fn group_start(&mut self) {}\n     fn group_end(&mut self) {}\n@@ -1275,8 +1278,6 @@ impl<'a> Linker for WasmLd<'a> {\n \n     fn subsystem(&mut self, _subsystem: &str) {}\n \n-    fn finalize(&mut self) {}\n-\n     // Not needed for now with LLD\n     fn group_start(&mut self) {}\n     fn group_end(&mut self) {}\n@@ -1330,7 +1331,6 @@ fn exported_symbols(tcx: TyCtxt<'_>, crate_type: CrateType) -> Vec<String> {\n pub struct PtxLinker<'a> {\n     cmd: Command,\n     sess: &'a Session,\n-    info: &'a LinkerInfo,\n }\n \n impl<'a> Linker for PtxLinker<'a> {\n@@ -1374,9 +1374,105 @@ impl<'a> Linker for PtxLinker<'a> {\n         self.cmd.arg(\"-o\").arg(path);\n     }\n \n-    fn finalize(&mut self) {\n-        // Provide the linker with fallback to internal `target-cpu`.\n-        self.cmd.arg(\"--fallback-arch\").arg(&self.info.target_cpu);\n+    fn link_dylib(&mut self, _lib: Symbol, _verbatim: bool, _as_needed: bool) {\n+        panic!(\"external dylibs not supported\")\n+    }\n+\n+    fn link_rust_dylib(&mut self, _lib: Symbol, _path: &Path) {\n+        panic!(\"external dylibs not supported\")\n+    }\n+\n+    fn link_staticlib(&mut self, _lib: Symbol, _verbatim: bool) {\n+        panic!(\"staticlibs not supported\")\n+    }\n+\n+    fn link_whole_staticlib(&mut self, _lib: Symbol, _verbatim: bool, _search_path: &[PathBuf]) {\n+        panic!(\"staticlibs not supported\")\n+    }\n+\n+    fn framework_path(&mut self, _path: &Path) {\n+        panic!(\"frameworks not supported\")\n+    }\n+\n+    fn link_framework(&mut self, _framework: Symbol, _as_needed: bool) {\n+        panic!(\"frameworks not supported\")\n+    }\n+\n+    fn full_relro(&mut self) {}\n+\n+    fn partial_relro(&mut self) {}\n+\n+    fn no_relro(&mut self) {}\n+\n+    fn gc_sections(&mut self, _keep_metadata: bool) {}\n+\n+    fn no_gc_sections(&mut self) {}\n+\n+    fn pgo_gen(&mut self) {}\n+\n+    fn no_crt_objects(&mut self) {}\n+\n+    fn no_default_libraries(&mut self) {}\n+\n+    fn control_flow_guard(&mut self) {}\n+\n+    fn export_symbols(&mut self, _tmpdir: &Path, _crate_type: CrateType) {}\n+\n+    fn subsystem(&mut self, _subsystem: &str) {}\n+\n+    fn group_start(&mut self) {}\n+\n+    fn group_end(&mut self) {}\n+\n+    fn linker_plugin_lto(&mut self) {}\n+}\n+\n+pub struct BpfLinker<'a> {\n+    cmd: Command,\n+    sess: &'a Session,\n+    info: &'a LinkerInfo,\n+}\n+\n+impl<'a> Linker for BpfLinker<'a> {\n+    fn cmd(&mut self) -> &mut Command {\n+        &mut self.cmd\n+    }\n+\n+    fn set_output_kind(&mut self, _output_kind: LinkOutputKind, _out_filename: &Path) {}\n+\n+    fn link_rlib(&mut self, path: &Path) {\n+        self.cmd.arg(path);\n+    }\n+\n+    fn link_whole_rlib(&mut self, path: &Path) {\n+        self.cmd.arg(path);\n+    }\n+\n+    fn include_path(&mut self, path: &Path) {\n+        self.cmd.arg(\"-L\").arg(path);\n+    }\n+\n+    fn debuginfo(&mut self, _strip: Strip) {\n+        self.cmd.arg(\"--debug\");\n+    }\n+\n+    fn add_object(&mut self, path: &Path) {\n+        self.cmd.arg(path);\n+    }\n+\n+    fn optimize(&mut self) {\n+        self.cmd.arg(match self.sess.opts.optimize {\n+            OptLevel::No => \"-O0\",\n+            OptLevel::Less => \"-O1\",\n+            OptLevel::Default => \"-O2\",\n+            OptLevel::Aggressive => \"-O3\",\n+            OptLevel::Size => \"-Os\",\n+            OptLevel::SizeMin => \"-Oz\",\n+        });\n+    }\n+\n+    fn output_filename(&mut self, path: &Path) {\n+        self.cmd.arg(\"-o\").arg(path);\n     }\n \n     fn link_dylib(&mut self, _lib: Symbol, _verbatim: bool, _as_needed: bool) {\n@@ -1421,7 +1517,20 @@ impl<'a> Linker for PtxLinker<'a> {\n \n     fn control_flow_guard(&mut self) {}\n \n-    fn export_symbols(&mut self, _tmpdir: &Path, _crate_type: CrateType) {}\n+    fn export_symbols(&mut self, tmpdir: &Path, crate_type: CrateType) {\n+        let path = tmpdir.join(\"symbols\");\n+        let res: io::Result<()> = try {\n+            let mut f = BufWriter::new(File::create(&path)?);\n+            for sym in self.info.exports[&crate_type].iter() {\n+                writeln!(f, \"{}\", sym)?;\n+            }\n+        };\n+        if let Err(e) = res {\n+            self.sess.fatal(&format!(\"failed to write symbols file: {}\", e));\n+        } else {\n+            self.cmd.arg(\"--export-symbols\").arg(&path);\n+        }\n+    }\n \n     fn subsystem(&mut self, _subsystem: &str) {}\n "}, {"sha": "0fff3195808834e50a7c443d020f1138f1df2d8f", "filename": "compiler/rustc_codegen_ssa/src/back/metadata.rs", "status": "modified", "additions": 27, "deletions": 13, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -3,6 +3,7 @@\n use std::fs::File;\n use std::path::Path;\n \n+use object::{Object, ObjectSection};\n use rustc_data_structures::memmap::Mmap;\n use rustc_data_structures::owning_ref::OwningRef;\n use rustc_data_structures::rustc_erase_owner;\n@@ -46,7 +47,10 @@ impl MetadataLoader for DefaultMetadataLoader {\n                 let entry = entry_result\n                     .map_err(|e| format!(\"failed to parse rlib '{}': {}\", path.display(), e))?;\n                 if entry.name() == METADATA_FILENAME.as_bytes() {\n-                    return Ok(entry.data());\n+                    let data = entry\n+                        .data(data)\n+                        .map_err(|e| format!(\"failed to parse rlib '{}': {}\", path.display(), e))?;\n+                    return search_for_metadata(path, data, \".rmeta\");\n                 }\n             }\n \n@@ -55,17 +59,27 @@ impl MetadataLoader for DefaultMetadataLoader {\n     }\n \n     fn get_dylib_metadata(&self, _target: &Target, path: &Path) -> Result<MetadataRef, String> {\n-        use object::{Object, ObjectSection};\n-\n-        load_metadata_with(path, |data| {\n-            let file = object::File::parse(&data)\n-                .map_err(|e| format!(\"failed to parse dylib '{}': {}\", path.display(), e))?;\n-            file.section_by_name(\".rustc\")\n-                .ok_or_else(|| format!(\"no .rustc section in '{}'\", path.display()))?\n-                .data()\n-                .map_err(|e| {\n-                    format!(\"failed to read .rustc section in '{}': {}\", path.display(), e)\n-                })\n-        })\n+        load_metadata_with(path, |data| search_for_metadata(path, data, \".rustc\"))\n     }\n }\n+\n+fn search_for_metadata<'a>(\n+    path: &Path,\n+    bytes: &'a [u8],\n+    section: &str,\n+) -> Result<&'a [u8], String> {\n+    let file = match object::File::parse(bytes) {\n+        Ok(f) => f,\n+        // The parse above could fail for odd reasons like corruption, but for\n+        // now we just interpret it as this target doesn't support metadata\n+        // emission in object files so the entire byte slice itself is probably\n+        // a metadata file. Ideally though if necessary we could at least check\n+        // the prefix of bytes to see if it's an actual metadata object and if\n+        // not forward the error along here.\n+        Err(_) => return Ok(bytes),\n+    };\n+    file.section_by_name(section)\n+        .ok_or_else(|| format!(\"no `{}` section in '{}'\", section, path.display()))?\n+        .data()\n+        .map_err(|e| format!(\"failed to read {} section in '{}': {}\", section, path.display(), e))\n+}"}, {"sha": "39b0ccd120de519c747af97a88091c035d1cf4a2", "filename": "compiler/rustc_codegen_ssa/src/back/rpath.rs", "status": "modified", "additions": 4, "deletions": 23, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Frpath.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -13,7 +13,6 @@ pub struct RPathConfig<'a> {\n     pub is_like_osx: bool,\n     pub has_rpath: bool,\n     pub linker_is_gnu: bool,\n-    pub get_install_prefix_lib_path: &'a mut dyn FnMut() -> PathBuf,\n }\n \n pub fn get_rpath_flags(config: &mut RPathConfig<'_>) -> Vec<String> {\n@@ -63,24 +62,13 @@ fn get_rpaths(config: &mut RPathConfig<'_>, libs: &[PathBuf]) -> Vec<String> {\n     // Use relative paths to the libraries. Binaries can be moved\n     // as long as they maintain the relative relationship to the\n     // crates they depend on.\n-    let rel_rpaths = get_rpaths_relative_to_output(config, libs);\n+    let rpaths = get_rpaths_relative_to_output(config, libs);\n \n-    // And a final backup rpath to the global library location.\n-    let fallback_rpaths = vec![get_install_prefix_rpath(config)];\n-\n-    fn log_rpaths(desc: &str, rpaths: &[String]) {\n-        debug!(\"{} rpaths:\", desc);\n-        for rpath in rpaths {\n-            debug!(\"    {}\", *rpath);\n-        }\n+    debug!(\"rpaths:\");\n+    for rpath in &rpaths {\n+        debug!(\"    {}\", rpath);\n     }\n \n-    log_rpaths(\"relative\", &rel_rpaths);\n-    log_rpaths(\"fallback\", &fallback_rpaths);\n-\n-    let mut rpaths = rel_rpaths;\n-    rpaths.extend_from_slice(&fallback_rpaths);\n-\n     // Remove duplicates\n     minimize_rpaths(&rpaths)\n }\n@@ -113,13 +101,6 @@ fn path_relative_from(path: &Path, base: &Path) -> Option<PathBuf> {\n     diff_paths(path, base)\n }\n \n-fn get_install_prefix_rpath(config: &mut RPathConfig<'_>) -> String {\n-    let path = (config.get_install_prefix_lib_path)();\n-    let path = env::current_dir().unwrap().join(&path);\n-    // FIXME (#9639): This needs to handle non-utf8 paths\n-    path.to_str().expect(\"non-utf8 component in rpath\").to_owned()\n-}\n-\n fn minimize_rpaths(rpaths: &[String]) -> Vec<String> {\n     let mut set = FxHashSet::default();\n     let mut minimized = Vec::new();"}, {"sha": "24c362db12275b103947ad2cbfcdaaecf4f9faae", "filename": "compiler/rustc_codegen_ssa/src/back/rpath/tests.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Frpath%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Frpath%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Frpath%2Ftests.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -40,15 +40,13 @@ fn test_rpath_relative() {\n             is_like_osx: true,\n             linker_is_gnu: false,\n             out_filename: PathBuf::from(\"bin/rustc\"),\n-            get_install_prefix_lib_path: &mut || panic!(),\n         };\n         let res = get_rpath_relative_to_output(config, Path::new(\"lib/libstd.so\"));\n         assert_eq!(res, \"@loader_path/../lib\");\n     } else {\n         let config = &mut RPathConfig {\n             used_crates: &[],\n             out_filename: PathBuf::from(\"bin/rustc\"),\n-            get_install_prefix_lib_path: &mut || panic!(),\n             has_rpath: true,\n             is_like_osx: false,\n             linker_is_gnu: true,"}, {"sha": "b2ecc3b0f3242e33738c6255ca35e4365ff87f14", "filename": "compiler/rustc_codegen_ssa/src/back/symbol_export.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -370,7 +370,6 @@ pub fn provide(providers: &mut Providers) {\n pub fn provide_extern(providers: &mut Providers) {\n     providers.is_reachable_non_generic = is_reachable_non_generic_provider_extern;\n     providers.upstream_monomorphizations_for = upstream_monomorphizations_for_provider;\n-    providers.wasm_import_module_map = wasm_import_module_map;\n }\n \n fn symbol_export_level(tcx: TyCtxt<'_>, sym_def_id: DefId) -> SymbolExportLevel {"}, {"sha": "ff4e64095714086cd4a76222786f164a2587b895", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -31,7 +31,7 @@ use rustc_session::config::{self, CrateType, Lto, OutputFilenames, OutputType};\n use rustc_session::config::{Passes, SwitchWithOptPath};\n use rustc_session::Session;\n use rustc_span::source_map::SourceMap;\n-use rustc_span::symbol::{sym, Symbol};\n+use rustc_span::symbol::sym;\n use rustc_span::{BytePos, FileName, InnerSpan, Pos, Span};\n use rustc_target::spec::{MergeFunctions, PanicStrategy, SanitizerSet};\n \n@@ -426,21 +426,9 @@ pub fn start_async_codegen<B: ExtraBackendMethods>(\n     let (coordinator_send, coordinator_receive) = channel();\n     let sess = tcx.sess;\n \n-    let crate_name = tcx.crate_name(LOCAL_CRATE);\n     let crate_attrs = tcx.hir().attrs(rustc_hir::CRATE_HIR_ID);\n     let no_builtins = tcx.sess.contains_name(crate_attrs, sym::no_builtins);\n     let is_compiler_builtins = tcx.sess.contains_name(crate_attrs, sym::compiler_builtins);\n-    let subsystem = tcx.sess.first_attr_value_str_by_name(crate_attrs, sym::windows_subsystem);\n-    let windows_subsystem = subsystem.map(|subsystem| {\n-        if subsystem != sym::windows && subsystem != sym::console {\n-            tcx.sess.fatal(&format!(\n-                \"invalid windows subsystem `{}`, only \\\n-                                     `windows` and `console` are allowed\",\n-                subsystem\n-            ));\n-        }\n-        subsystem.to_string()\n-    });\n \n     let linker_info = LinkerInfo::new(tcx, target_cpu);\n     let crate_info = CrateInfo::new(tcx);\n@@ -472,9 +460,7 @@ pub fn start_async_codegen<B: ExtraBackendMethods>(\n \n     OngoingCodegen {\n         backend,\n-        crate_name,\n         metadata,\n-        windows_subsystem,\n         linker_info,\n         crate_info,\n \n@@ -1812,9 +1798,7 @@ impl SharedEmitterMain {\n \n pub struct OngoingCodegen<B: ExtraBackendMethods> {\n     pub backend: B,\n-    pub crate_name: Symbol,\n     pub metadata: EncodedMetadata,\n-    pub windows_subsystem: Option<String>,\n     pub linker_info: LinkerInfo,\n     pub crate_info: CrateInfo,\n     pub coordinator_send: Sender<Box<dyn Any + Send>>,\n@@ -1857,9 +1841,7 @@ impl<B: ExtraBackendMethods> OngoingCodegen<B> {\n \n         (\n             CodegenResults {\n-                crate_name: self.crate_name,\n                 metadata: self.metadata,\n-                windows_subsystem: self.windows_subsystem,\n                 linker_info: self.linker_info,\n                 crate_info: self.crate_info,\n "}, {"sha": "38ab39febe066c4c0db3adfb8f4286d1ff0289e7", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -30,6 +30,7 @@ use rustc_middle::ty::{self, Instance, Ty, TyCtxt};\n use rustc_session::cgu_reuse_tracker::CguReuse;\n use rustc_session::config::{self, EntryFnType};\n use rustc_session::Session;\n+use rustc_span::symbol::sym;\n use rustc_target::abi::{Align, LayoutOf, VariantIdx};\n \n use std::ops::{Deref, DerefMut};\n@@ -755,7 +756,22 @@ impl<B: ExtraBackendMethods> Drop for AbortCodegenOnDrop<B> {\n \n impl CrateInfo {\n     pub fn new(tcx: TyCtxt<'_>) -> CrateInfo {\n+        let local_crate_name = tcx.crate_name(LOCAL_CRATE);\n+        let crate_attrs = tcx.hir().attrs(rustc_hir::CRATE_HIR_ID);\n+        let subsystem = tcx.sess.first_attr_value_str_by_name(crate_attrs, sym::windows_subsystem);\n+        let windows_subsystem = subsystem.map(|subsystem| {\n+            if subsystem != sym::windows && subsystem != sym::console {\n+                tcx.sess.fatal(&format!(\n+                    \"invalid windows subsystem `{}`, only \\\n+                                     `windows` and `console` are allowed\",\n+                    subsystem\n+                ));\n+            }\n+            subsystem.to_string()\n+        });\n+\n         let mut info = CrateInfo {\n+            local_crate_name,\n             panic_runtime: None,\n             compiler_builtins: None,\n             profiler_runtime: None,\n@@ -769,6 +785,7 @@ impl CrateInfo {\n             lang_item_to_crate: Default::default(),\n             missing_lang_items: Default::default(),\n             dependency_formats: tcx.dependency_formats(()),\n+            windows_subsystem,\n         };\n         let lang_items = tcx.lang_items();\n "}, {"sha": "c1dfe1ef85600d63dd9441a1bd2e49094c4af13d", "filename": "compiler/rustc_codegen_ssa/src/coverageinfo/map.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fmap.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -28,6 +28,7 @@ pub struct Expression {\n /// only whitespace or comments). According to LLVM Code Coverage Mapping documentation, \"A count\n /// for a gap area is only used as the line execution count if there are no other regions on a\n /// line.\"\n+#[derive(Debug)]\n pub struct FunctionCoverage<'tcx> {\n     instance: Instance<'tcx>,\n     source_hash: u64,\n@@ -113,6 +114,14 @@ impl<'tcx> FunctionCoverage<'tcx> {\n             expression_id, lhs, op, rhs, region\n         );\n         let expression_index = self.expression_index(u32::from(expression_id));\n+        debug_assert!(\n+            expression_index.as_usize() < self.expressions.len(),\n+            \"expression_index {} is out of range for expressions.len() = {}\n+            for {:?}\",\n+            expression_index.as_usize(),\n+            self.expressions.len(),\n+            self,\n+        );\n         if let Some(previous_expression) = self.expressions[expression_index].replace(Expression {\n             lhs,\n             op,"}, {"sha": "7b4b0821c4be8017c75e66434cc2bed946e6bd03", "filename": "compiler/rustc_codegen_ssa/src/debuginfo/type_names.rs", "status": "modified", "additions": 56, "deletions": 3, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -3,7 +3,8 @@\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n-use rustc_middle::ty::{self, subst::SubstsRef, Ty, TyCtxt};\n+use rustc_middle::ty::{self, subst::SubstsRef, AdtDef, Ty, TyCtxt};\n+use rustc_target::abi::{TagEncoding, Variants};\n \n use std::fmt::Write;\n \n@@ -45,8 +46,12 @@ pub fn push_debuginfo_type_name<'tcx>(\n         ty::Float(float_ty) => output.push_str(float_ty.name_str()),\n         ty::Foreign(def_id) => push_item_name(tcx, def_id, qualified, output),\n         ty::Adt(def, substs) => {\n-            push_item_name(tcx, def.did, qualified, output);\n-            push_type_params(tcx, substs, output, visited);\n+            if def.is_enum() && cpp_like_names {\n+                msvc_enum_fallback(tcx, t, def, substs, output, visited);\n+            } else {\n+                push_item_name(tcx, def.did, qualified, output);\n+                push_type_params(tcx, substs, output, visited);\n+            }\n         }\n         ty::Tuple(component_types) => {\n             if cpp_like_names {\n@@ -233,6 +238,54 @@ pub fn push_debuginfo_type_name<'tcx>(\n         }\n     }\n \n+    /// MSVC names enums differently than other platforms so that the debugging visualization\n+    // format (natvis) is able to understand enums and render the active variant correctly in the\n+    // debugger. For more information, look in `src/etc/natvis/intrinsic.natvis` and\n+    // `EnumMemberDescriptionFactor::create_member_descriptions`.\n+    fn msvc_enum_fallback(\n+        tcx: TyCtxt<'tcx>,\n+        ty: Ty<'tcx>,\n+        def: &AdtDef,\n+        substs: SubstsRef<'tcx>,\n+        output: &mut String,\n+        visited: &mut FxHashSet<Ty<'tcx>>,\n+    ) {\n+        let layout = tcx.layout_of(tcx.param_env(def.did).and(ty)).expect(\"layout error\");\n+\n+        if let Variants::Multiple {\n+            tag_encoding: TagEncoding::Niche { dataful_variant, .. },\n+            tag,\n+            variants,\n+            ..\n+        } = &layout.variants\n+        {\n+            let dataful_variant_layout = &variants[*dataful_variant];\n+\n+            // calculate the range of values for the dataful variant\n+            let dataful_discriminant_range =\n+                &dataful_variant_layout.largest_niche.as_ref().unwrap().scalar.valid_range;\n+\n+            let min = dataful_discriminant_range.start();\n+            let min = tag.value.size(&tcx).truncate(*min);\n+\n+            let max = dataful_discriminant_range.end();\n+            let max = tag.value.size(&tcx).truncate(*max);\n+\n+            output.push_str(\"enum$<\");\n+            push_item_name(tcx, def.did, true, output);\n+            push_type_params(tcx, substs, output, visited);\n+\n+            let dataful_variant_name = def.variants[*dataful_variant].ident.as_str();\n+\n+            output.push_str(&format!(\", {}, {}, {}>\", min, max, dataful_variant_name));\n+        } else {\n+            output.push_str(\"enum$<\");\n+            push_item_name(tcx, def.did, true, output);\n+            push_type_params(tcx, substs, output, visited);\n+            output.push('>');\n+        }\n+    }\n+\n     fn push_item_name(tcx: TyCtxt<'tcx>, def_id: DefId, qualified: bool, output: &mut String) {\n         if qualified {\n             output.push_str(&tcx.crate_name(def_id.krate).as_str());"}, {"sha": "b6de12fa35e37ee183dcc89412d5ad2af0a08d8a", "filename": "compiler/rustc_codegen_ssa/src/lib.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -1,15 +1,11 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n-#![feature(assert_matches)]\n #![feature(bool_to_option)]\n #![feature(box_patterns)]\n-#![feature(drain_filter)]\n #![feature(try_blocks)]\n #![feature(in_band_lifetimes)]\n #![feature(nll)]\n #![feature(associated_type_bounds)]\n-#![feature(iter_zip)]\n #![recursion_limit = \"256\"]\n-#![feature(box_syntax)]\n \n //! This crate contains codegen code that is used by all codegen backends (LLVM and others).\n //! The backend-agnostic functions of this crate use functions defined in various traits that\n@@ -114,11 +110,18 @@ pub struct NativeLib {\n     pub name: Option<Symbol>,\n     pub cfg: Option<ast::MetaItem>,\n     pub verbatim: Option<bool>,\n+    pub dll_imports: Vec<cstore::DllImport>,\n }\n \n impl From<&cstore::NativeLib> for NativeLib {\n     fn from(lib: &cstore::NativeLib) -> Self {\n-        NativeLib { kind: lib.kind, name: lib.name, cfg: lib.cfg.clone(), verbatim: lib.verbatim }\n+        NativeLib {\n+            kind: lib.kind,\n+            name: lib.name,\n+            cfg: lib.cfg.clone(),\n+            verbatim: lib.verbatim,\n+            dll_imports: lib.dll_imports.clone(),\n+        }\n     }\n }\n \n@@ -132,6 +135,7 @@ impl From<&cstore::NativeLib> for NativeLib {\n /// and the corresponding properties without referencing information outside of a `CrateInfo`.\n #[derive(Debug, Encodable, Decodable)]\n pub struct CrateInfo {\n+    pub local_crate_name: Symbol,\n     pub panic_runtime: Option<CrateNum>,\n     pub compiler_builtins: Option<CrateNum>,\n     pub profiler_runtime: Option<CrateNum>,\n@@ -145,16 +149,15 @@ pub struct CrateInfo {\n     pub lang_item_to_crate: FxHashMap<LangItem, CrateNum>,\n     pub missing_lang_items: FxHashMap<CrateNum, Vec<LangItem>>,\n     pub dependency_formats: Lrc<Dependencies>,\n+    pub windows_subsystem: Option<String>,\n }\n \n #[derive(Encodable, Decodable)]\n pub struct CodegenResults {\n-    pub crate_name: Symbol,\n     pub modules: Vec<CompiledModule>,\n     pub allocator_module: Option<CompiledModule>,\n     pub metadata_module: Option<CompiledModule>,\n     pub metadata: rustc_middle::middle::cstore::EncodedMetadata,\n-    pub windows_subsystem: Option<String>,\n     pub linker_info: back::linker::LinkerInfo,\n     pub crate_info: CrateInfo,\n }"}, {"sha": "49b5e8466bef2bd3d94324cad71750b785a57a31", "filename": "compiler/rustc_codegen_ssa/src/mir/analyze.rs", "status": "modified", "additions": 7, "deletions": 75, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -7,11 +7,8 @@ use rustc_data_structures::graph::dominators::Dominators;\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::mir::traversal;\n-use rustc_middle::mir::visit::{\n-    MutatingUseContext, NonMutatingUseContext, NonUseContext, PlaceContext, Visitor,\n-};\n+use rustc_middle::mir::visit::{MutatingUseContext, NonMutatingUseContext, PlaceContext, Visitor};\n use rustc_middle::mir::{self, Location, TerminatorKind};\n-use rustc_middle::ty;\n use rustc_middle::ty::layout::HasTyCtxt;\n use rustc_target::abi::LayoutOf;\n \n@@ -21,7 +18,12 @@ pub fn non_ssa_locals<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     let mir = fx.mir;\n     let mut analyzer = LocalAnalyzer::new(fx);\n \n-    analyzer.visit_body(&mir);\n+    // If there exists a local definition that dominates all uses of that local,\n+    // the definition should be visited first. Traverse blocks in preorder which\n+    // is a topological sort of dominance partial order.\n+    for (bb, data) in traversal::preorder(&mir) {\n+        analyzer.visit_basic_block_data(bb, data);\n+    }\n \n     for (local, decl) in mir.local_decls.iter_enumerated() {\n         let ty = fx.monomorphize(decl.ty);\n@@ -142,36 +144,7 @@ impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n \n             if let mir::ProjectionElem::Deref = elem {\n                 // Deref projections typically only read the pointer.\n-                // (the exception being `VarDebugInfo` contexts, handled below)\n                 base_context = PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy);\n-\n-                // Indirect debuginfo requires going through memory, that only\n-                // the debugger accesses, following our emitted DWARF pointer ops.\n-                //\n-                // FIXME(eddyb) Investigate the possibility of relaxing this, but\n-                // note that `llvm.dbg.declare` *must* be used for indirect places,\n-                // even if we start using `llvm.dbg.value` for all other cases,\n-                // as we don't necessarily know when the value changes, but only\n-                // where it lives in memory.\n-                //\n-                // It's possible `llvm.dbg.declare` could support starting from\n-                // a pointer that doesn't point to an `alloca`, but this would\n-                // only be useful if we know the pointer being `Deref`'d comes\n-                // from an immutable place, and if `llvm.dbg.declare` calls\n-                // must be at the very start of the function, then only function\n-                // arguments could contain such pointers.\n-                if context == PlaceContext::NonUse(NonUseContext::VarDebugInfo) {\n-                    // We use `NonUseContext::VarDebugInfo` for the base,\n-                    // which might not force the base local to memory,\n-                    // so we have to do it manually.\n-                    self.visit_local(&place_ref.local, context, location);\n-                }\n-            }\n-\n-            // `NonUseContext::VarDebugInfo` needs to flow all the\n-            // way down to the base local (see `visit_local`).\n-            if context == PlaceContext::NonUse(NonUseContext::VarDebugInfo) {\n-                base_context = context;\n             }\n \n             self.process_place(&place_base, base_context, location);\n@@ -186,20 +159,7 @@ impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n                 );\n             }\n         } else {\n-            // FIXME this is super_place code, is repeated here to avoid cloning place or changing\n-            // visit_place API\n-            let mut context = context;\n-\n-            if !place_ref.projection.is_empty() {\n-                context = if context.is_mutating_use() {\n-                    PlaceContext::MutatingUse(MutatingUseContext::Projection)\n-                } else {\n-                    PlaceContext::NonMutatingUse(NonMutatingUseContext::Projection)\n-                };\n-            }\n-\n             self.visit_local(&place_ref.local, context, location);\n-            self.visit_projection(*place_ref, context, location);\n         }\n     }\n }\n@@ -228,34 +188,6 @@ impl<'mir, 'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> Visitor<'tcx>\n         self.visit_rvalue(rvalue, location);\n     }\n \n-    fn visit_terminator(&mut self, terminator: &mir::Terminator<'tcx>, location: Location) {\n-        let check = match terminator.kind {\n-            mir::TerminatorKind::Call { func: mir::Operand::Constant(ref c), ref args, .. } => {\n-                match *c.ty().kind() {\n-                    ty::FnDef(did, _) => Some((did, args)),\n-                    _ => None,\n-                }\n-            }\n-            _ => None,\n-        };\n-        if let Some((def_id, args)) = check {\n-            if Some(def_id) == self.fx.cx.tcx().lang_items().box_free_fn() {\n-                // box_free(x) shares with `drop x` the property that it\n-                // is not guaranteed to be statically dominated by the\n-                // definition of x, so x must always be in an alloca.\n-                if let mir::Operand::Move(ref place) = args[0] {\n-                    self.visit_place(\n-                        place,\n-                        PlaceContext::MutatingUse(MutatingUseContext::Drop),\n-                        location,\n-                    );\n-                }\n-            }\n-        }\n-\n-        self.super_terminator(terminator, location);\n-    }\n-\n     fn visit_place(&mut self, place: &mir::Place<'tcx>, context: PlaceContext, location: Location) {\n         debug!(\"visit_place(place={:?}, context={:?})\", place, context);\n         self.process_place(&place.as_ref(), context, location);"}, {"sha": "c89d42ecc58ac10797ee245103e281db752ebd6c", "filename": "compiler/rustc_codegen_ssa/src/target_features.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -205,11 +205,13 @@ const RISCV_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n ];\n \n const WASM_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n-    (\"simd128\", Some(sym::wasm_target_feature)),\n+    (\"simd128\", None),\n     (\"atomics\", Some(sym::wasm_target_feature)),\n     (\"nontrapping-fptoint\", Some(sym::wasm_target_feature)),\n ];\n \n+const BPF_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[(\"alu32\", Some(sym::bpf_target_feature))];\n+\n /// When rustdoc is running, provide a list of all known features so that all their respective\n /// primitives may be documented.\n ///\n@@ -224,6 +226,7 @@ pub fn all_known_features() -> impl Iterator<Item = (&'static str, Option<Symbol\n         .chain(MIPS_ALLOWED_FEATURES.iter())\n         .chain(RISCV_ALLOWED_FEATURES.iter())\n         .chain(WASM_ALLOWED_FEATURES.iter())\n+        .chain(BPF_ALLOWED_FEATURES.iter())\n         .cloned()\n }\n \n@@ -237,6 +240,7 @@ pub fn supported_target_features(sess: &Session) -> &'static [(&'static str, Opt\n         \"powerpc\" | \"powerpc64\" => POWERPC_ALLOWED_FEATURES,\n         \"riscv32\" | \"riscv64\" => RISCV_ALLOWED_FEATURES,\n         \"wasm32\" | \"wasm64\" => WASM_ALLOWED_FEATURES,\n+        \"bpf\" => BPF_ALLOWED_FEATURES,\n         _ => &[],\n     }\n }"}, {"sha": "dc4146ec7b58dc132fa1cf454e9fe2a9ae352d70", "filename": "compiler/rustc_codegen_ssa/src/traits/backend.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -63,9 +63,16 @@ pub trait CodegenBackend {\n         None\n     }\n \n-    fn metadata_loader(&self) -> Box<MetadataLoaderDyn>;\n-    fn provide(&self, _providers: &mut Providers);\n-    fn provide_extern(&self, _providers: &mut Providers);\n+    /// The metadata loader used to load rlib and dylib metadata.\n+    ///\n+    /// Alternative codegen backends may want to use different rlib or dylib formats than the\n+    /// default native static archives and dynamic libraries.\n+    fn metadata_loader(&self) -> Box<MetadataLoaderDyn> {\n+        Box::new(crate::back::metadata::DefaultMetadataLoader)\n+    }\n+\n+    fn provide(&self, _providers: &mut Providers) {}\n+    fn provide_extern(&self, _providers: &mut Providers) {}\n     fn codegen_crate<'tcx>(\n         &self,\n         tcx: TyCtxt<'tcx>,"}, {"sha": "eb6f4e8213ec711dac0b945cc5c2f751c9511451", "filename": "compiler/rustc_data_structures/src/box_region.rs", "status": "removed", "additions": 0, "deletions": 169, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/b5e92756b305c6ec4bdd42feddd013333eb69d63/compiler%2Frustc_data_structures%2Fsrc%2Fbox_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5e92756b305c6ec4bdd42feddd013333eb69d63/compiler%2Frustc_data_structures%2Fsrc%2Fbox_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fbox_region.rs?ref=b5e92756b305c6ec4bdd42feddd013333eb69d63", "patch": "@@ -1,169 +0,0 @@\n-//! This module provides a way to deal with self-referential data.\n-//!\n-//! The main idea is to allocate such data in a generator frame and then\n-//! give access to it by executing user-provided closures inside that generator.\n-//! The module provides a safe abstraction for the latter task.\n-//!\n-//! The interface consists of two exported macros meant to be used together:\n-//! * `declare_box_region_type` wraps a generator inside a struct with `access`\n-//!   method which accepts closures.\n-//! * `box_region_allow_access` is a helper which should be called inside\n-//!   a generator to actually execute those closures.\n-\n-use std::marker::PhantomData;\n-use std::ops::{Generator, GeneratorState};\n-use std::pin::Pin;\n-\n-#[derive(Copy, Clone)]\n-pub struct AccessAction(*mut dyn FnMut());\n-\n-impl AccessAction {\n-    pub fn get(self) -> *mut dyn FnMut() {\n-        self.0\n-    }\n-}\n-\n-#[derive(Copy, Clone)]\n-pub enum Action {\n-    Initial,\n-    Access(AccessAction),\n-    Complete,\n-}\n-\n-pub struct PinnedGenerator<I, A, R> {\n-    generator: Pin<Box<dyn Generator<Action, Yield = YieldType<I, A>, Return = R>>>,\n-}\n-\n-impl<I, A, R> PinnedGenerator<I, A, R> {\n-    pub fn new<T: Generator<Action, Yield = YieldType<I, A>, Return = R> + 'static>(\n-        generator: T,\n-    ) -> (I, Self) {\n-        let mut result = PinnedGenerator { generator: Box::pin(generator) };\n-\n-        // Run it to the first yield to set it up\n-        let init = match Pin::new(&mut result.generator).resume(Action::Initial) {\n-            GeneratorState::Yielded(YieldType::Initial(y)) => y,\n-            _ => panic!(),\n-        };\n-\n-        (init, result)\n-    }\n-\n-    pub unsafe fn access(&mut self, closure: *mut dyn FnMut()) {\n-        // Call the generator, which in turn will call the closure\n-        if let GeneratorState::Complete(_) =\n-            Pin::new(&mut self.generator).resume(Action::Access(AccessAction(closure)))\n-        {\n-            panic!()\n-        }\n-    }\n-\n-    pub fn complete(&mut self) -> R {\n-        // Tell the generator we want it to complete, consuming it and yielding a result\n-        let result = Pin::new(&mut self.generator).resume(Action::Complete);\n-        if let GeneratorState::Complete(r) = result { r } else { panic!() }\n-    }\n-}\n-\n-#[derive(PartialEq)]\n-pub struct Marker<T>(PhantomData<T>);\n-\n-impl<T> Marker<T> {\n-    pub unsafe fn new() -> Self {\n-        Marker(PhantomData)\n-    }\n-}\n-\n-pub enum YieldType<I, A> {\n-    Initial(I),\n-    Accessor(Marker<A>),\n-}\n-\n-#[macro_export]\n-#[allow_internal_unstable(fn_traits)]\n-macro_rules! declare_box_region_type {\n-    (impl $v:vis\n-     $name: ident,\n-     $yield_type:ty,\n-     for($($lifetimes:tt)*),\n-     ($($args:ty),*) -> ($reti:ty, $retc:ty)\n-    ) => {\n-        $v struct $name($crate::box_region::PinnedGenerator<\n-            $reti,\n-            for<$($lifetimes)*> fn(($($args,)*)),\n-            $retc\n-        >);\n-\n-        impl $name {\n-            fn new<T: ::std::ops::Generator<$crate::box_region::Action, Yield = $yield_type, Return = $retc> + 'static>(\n-                generator: T\n-            ) -> ($reti, Self) {\n-                let (initial, pinned) = $crate::box_region::PinnedGenerator::new(generator);\n-                (initial, $name(pinned))\n-            }\n-\n-            $v fn access<F: for<$($lifetimes)*> FnOnce($($args,)*) -> R, R>(&mut self, f: F) -> R {\n-                // Turn the FnOnce closure into *mut dyn FnMut()\n-                // so we can pass it in to the generator\n-                let mut r = None;\n-                let mut f = Some(f);\n-                let mut_f: &mut dyn for<$($lifetimes)*> FnMut(($($args,)*)) =\n-                    &mut |args| {\n-                        let f = f.take().unwrap();\n-                        r = Some(FnOnce::call_once(f, args));\n-                };\n-                let mut_f = mut_f as *mut dyn for<$($lifetimes)*> FnMut(($($args,)*));\n-\n-                // Get the generator to call our closure\n-                unsafe {\n-                    self.0.access(::std::mem::transmute(mut_f));\n-                }\n-\n-                // Unwrap the result\n-                r.unwrap()\n-            }\n-\n-            $v fn complete(mut self) -> $retc {\n-                self.0.complete()\n-            }\n-\n-            fn initial_yield(value: $reti) -> $yield_type {\n-                $crate::box_region::YieldType::Initial(value)\n-            }\n-        }\n-    };\n-\n-    ($v:vis $name: ident, for($($lifetimes:tt)*), ($($args:ty),*) -> ($reti:ty, $retc:ty)) => {\n-        declare_box_region_type!(\n-            impl $v $name,\n-            $crate::box_region::YieldType<$reti, for<$($lifetimes)*> fn(($($args,)*))>,\n-            for($($lifetimes)*),\n-            ($($args),*) -> ($reti, $retc)\n-        );\n-    };\n-}\n-\n-#[macro_export]\n-#[allow_internal_unstable(fn_traits)]\n-macro_rules! box_region_allow_access {\n-    (for($($lifetimes:tt)*), ($($args:ty),*), ($($exprs:expr),*), $action:ident) => {\n-        loop {\n-            match $action {\n-                $crate::box_region::Action::Access(accessor) => {\n-                    let accessor: &mut dyn for<$($lifetimes)*> FnMut($($args),*) = unsafe {\n-                        ::std::mem::transmute(accessor.get())\n-                    };\n-                    (*accessor)(($($exprs),*));\n-                    unsafe {\n-                        let marker = $crate::box_region::Marker::<\n-                            for<$($lifetimes)*> fn(($($args,)*))\n-                        >::new();\n-                        $action = yield $crate::box_region::YieldType::Accessor(marker);\n-                    };\n-                }\n-                $crate::box_region::Action::Complete => break,\n-                $crate::box_region::Action::Initial => panic!(\"unexpected box_region action: Initial\"),\n-            }\n-        }\n-    }\n-}"}, {"sha": "16151e9dca5e039bc832b83246e3afb2ed19642d", "filename": "compiler/rustc_data_structures/src/lib.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -10,15 +10,11 @@\n #![feature(array_windows)]\n #![feature(control_flow_enum)]\n #![feature(in_band_lifetimes)]\n-#![feature(unboxed_closures)]\n-#![feature(generator_trait)]\n-#![feature(fn_traits)]\n #![feature(min_specialization)]\n #![feature(auto_traits)]\n #![feature(nll)]\n #![feature(allow_internal_unstable)]\n #![feature(hash_raw_entry)]\n-#![feature(stmt_expr_attributes)]\n #![feature(core_intrinsics)]\n #![feature(test)]\n #![feature(associated_type_bounds)]\n@@ -66,7 +62,6 @@ macro_rules! unlikely {\n \n pub mod base_n;\n pub mod binary_search_util;\n-pub mod box_region;\n pub mod captures;\n pub mod flock;\n pub mod functor;\n@@ -99,6 +94,7 @@ pub mod thin_vec;\n pub mod tiny_list;\n pub mod transitive_relation;\n pub mod vec_linked_list;\n+pub mod vec_map;\n pub mod work_queue;\n pub use atomic_ref::AtomicRef;\n pub mod frozen;"}, {"sha": "05b1a85381f454ff880d854199f102924cbe00d3", "filename": "compiler/rustc_data_structures/src/obligation_forest/mod.rs", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -342,7 +342,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n             return Ok(());\n         }\n \n-        match self.active_cache.entry(cache_key.clone()) {\n+        match self.active_cache.entry(cache_key) {\n             Entry::Occupied(o) => {\n                 let node = &mut self.nodes[*o.get()];\n                 if let Some(parent_index) = parent {\n@@ -366,8 +366,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n                     && self\n                         .error_cache\n                         .get(&obligation_tree_id)\n-                        .map(|errors| errors.contains(&cache_key))\n-                        .unwrap_or(false);\n+                        .map_or(false, |errors| errors.contains(v.key()));\n \n                 if already_failed {\n                     Err(())\n@@ -597,7 +596,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n                 Some(rpos) => {\n                     // Cycle detected.\n                     processor.process_backedge(\n-                        stack[rpos..].iter().map(GetObligation(&self.nodes)),\n+                        stack[rpos..].iter().map(|&i| &self.nodes[i].obligation),\n                         PhantomData,\n                     );\n                 }\n@@ -705,20 +704,3 @@ impl<O: ForestObligation> ObligationForest<O> {\n         });\n     }\n }\n-\n-// I need a Clone closure.\n-#[derive(Clone)]\n-struct GetObligation<'a, O>(&'a [Node<O>]);\n-\n-impl<'a, 'b, O> FnOnce<(&'b usize,)> for GetObligation<'a, O> {\n-    type Output = &'a O;\n-    extern \"rust-call\" fn call_once(self, args: (&'b usize,)) -> &'a O {\n-        &self.0[*args.0].obligation\n-    }\n-}\n-\n-impl<'a, 'b, O> FnMut<(&'b usize,)> for GetObligation<'a, O> {\n-    extern \"rust-call\" fn call_mut(&mut self, args: (&'b usize,)) -> &'a O {\n-        &self.0[*args.0].obligation\n-    }\n-}"}, {"sha": "18b352cf3b0b9152f42eb6c43dfd536c92f4e1dd", "filename": "compiler/rustc_data_structures/src/stable_hasher.rs", "status": "modified", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -550,35 +550,3 @@ pub fn hash_stable_hashmap<HCX, K, V, R, SK, F>(\n     entries.sort_unstable_by(|&(ref sk1, _), &(ref sk2, _)| sk1.cmp(sk2));\n     entries.hash_stable(hcx, hasher);\n }\n-\n-/// A vector container that makes sure that its items are hashed in a stable\n-/// order.\n-#[derive(Debug)]\n-pub struct StableVec<T>(Vec<T>);\n-\n-impl<T> StableVec<T> {\n-    pub fn new(v: Vec<T>) -> Self {\n-        StableVec(v)\n-    }\n-}\n-\n-impl<T> ::std::ops::Deref for StableVec<T> {\n-    type Target = Vec<T>;\n-\n-    fn deref(&self) -> &Vec<T> {\n-        &self.0\n-    }\n-}\n-\n-impl<T, HCX> HashStable<HCX> for StableVec<T>\n-where\n-    T: HashStable<HCX> + ToStableHashKey<HCX>,\n-{\n-    fn hash_stable(&self, hcx: &mut HCX, hasher: &mut StableHasher) {\n-        let StableVec(ref v) = *self;\n-\n-        let mut sorted: Vec<_> = v.iter().map(|x| x.to_stable_hash_key(hcx)).collect();\n-        sorted.sort_unstable();\n-        sorted.hash_stable(hcx, hasher);\n-    }\n-}"}, {"sha": "722ce6b6367266730667d510ffe4130bf44b8898", "filename": "compiler/rustc_data_structures/src/sync.rs", "status": "modified", "additions": 2, "deletions": 60, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -43,49 +43,9 @@ cfg_if! {\n         use std::ops::Add;\n         use std::panic::{resume_unwind, catch_unwind, AssertUnwindSafe};\n \n-        /// This is a single threaded variant of AtomicCell provided by crossbeam.\n-        /// Unlike `Atomic` this is intended for all `Copy` types,\n-        /// but it lacks the explicit ordering arguments.\n-        #[derive(Debug)]\n-        pub struct AtomicCell<T: Copy>(Cell<T>);\n-\n-        impl<T: Copy> AtomicCell<T> {\n-            #[inline]\n-            pub fn new(v: T) -> Self {\n-                AtomicCell(Cell::new(v))\n-            }\n-\n-            #[inline]\n-            pub fn get_mut(&mut self) -> &mut T {\n-                self.0.get_mut()\n-            }\n-        }\n-\n-        impl<T: Copy> AtomicCell<T> {\n-            #[inline]\n-            pub fn into_inner(self) -> T {\n-                self.0.into_inner()\n-            }\n-\n-            #[inline]\n-            pub fn load(&self) -> T {\n-                self.0.get()\n-            }\n-\n-            #[inline]\n-            pub fn store(&self, val: T) {\n-                self.0.set(val)\n-            }\n-\n-            #[inline]\n-            pub fn swap(&self, val: T) -> T {\n-                self.0.replace(val)\n-            }\n-        }\n-\n         /// This is a single threaded variant of `AtomicU64`, `AtomicUsize`, etc.\n-        /// It differs from `AtomicCell` in that it has explicit ordering arguments\n-        /// and is only intended for use with the native atomic types.\n+        /// It has explicit ordering arguments and is only intended for use with\n+        /// the native atomic types.\n         /// You should use this type through the `AtomicU64`, `AtomicUsize`, etc, type aliases\n         /// as it's not intended to be used separately.\n         #[derive(Debug)]\n@@ -159,22 +119,6 @@ cfg_if! {\n             (oper_a(), oper_b())\n         }\n \n-        pub struct SerialScope;\n-\n-        impl SerialScope {\n-            pub fn spawn<F>(&self, f: F)\n-                where F: FnOnce(&SerialScope)\n-            {\n-                f(self)\n-            }\n-        }\n-\n-        pub fn scope<F, R>(f: F) -> R\n-            where F: FnOnce(&SerialScope) -> R\n-        {\n-            f(&SerialScope)\n-        }\n-\n         #[macro_export]\n         macro_rules! parallel {\n             ($($blocks:tt),*) => {\n@@ -318,8 +262,6 @@ cfg_if! {\n \n         pub use std::sync::atomic::{AtomicBool, AtomicUsize, AtomicU32, AtomicU64};\n \n-        pub use crossbeam_utils::atomic::AtomicCell;\n-\n         pub use std::sync::Arc as Lrc;\n         pub use std::sync::Weak as Weak;\n "}, {"sha": "324a8624dd076a2ac213e4c68f18c8402cb5f8bc", "filename": "compiler/rustc_data_structures/src/tagged_ptr.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -90,9 +90,11 @@ pub unsafe trait Tag: Copy {\n \n unsafe impl<T> Pointer for Box<T> {\n     const BITS: usize = std::mem::align_of::<T>().trailing_zeros() as usize;\n+    #[inline]\n     fn into_usize(self) -> usize {\n         Box::into_raw(self) as usize\n     }\n+    #[inline]\n     unsafe fn from_usize(ptr: usize) -> Self {\n         Box::from_raw(ptr as *mut T)\n     }\n@@ -104,9 +106,11 @@ unsafe impl<T> Pointer for Box<T> {\n \n unsafe impl<T> Pointer for Rc<T> {\n     const BITS: usize = std::mem::align_of::<T>().trailing_zeros() as usize;\n+    #[inline]\n     fn into_usize(self) -> usize {\n         Rc::into_raw(self) as usize\n     }\n+    #[inline]\n     unsafe fn from_usize(ptr: usize) -> Self {\n         Rc::from_raw(ptr as *const T)\n     }\n@@ -118,9 +122,11 @@ unsafe impl<T> Pointer for Rc<T> {\n \n unsafe impl<T> Pointer for Arc<T> {\n     const BITS: usize = std::mem::align_of::<T>().trailing_zeros() as usize;\n+    #[inline]\n     fn into_usize(self) -> usize {\n         Arc::into_raw(self) as usize\n     }\n+    #[inline]\n     unsafe fn from_usize(ptr: usize) -> Self {\n         Arc::from_raw(ptr as *const T)\n     }\n@@ -132,9 +138,11 @@ unsafe impl<T> Pointer for Arc<T> {\n \n unsafe impl<'a, T: 'a> Pointer for &'a T {\n     const BITS: usize = std::mem::align_of::<T>().trailing_zeros() as usize;\n+    #[inline]\n     fn into_usize(self) -> usize {\n         self as *const T as usize\n     }\n+    #[inline]\n     unsafe fn from_usize(ptr: usize) -> Self {\n         &*(ptr as *const T)\n     }\n@@ -145,9 +153,11 @@ unsafe impl<'a, T: 'a> Pointer for &'a T {\n \n unsafe impl<'a, T: 'a> Pointer for &'a mut T {\n     const BITS: usize = std::mem::align_of::<T>().trailing_zeros() as usize;\n+    #[inline]\n     fn into_usize(self) -> usize {\n         self as *mut T as usize\n     }\n+    #[inline]\n     unsafe fn from_usize(ptr: usize) -> Self {\n         &mut *(ptr as *mut T)\n     }"}, {"sha": "73b04d3329cb8e79e9c9a3c5d63f5f178b307e27", "filename": "compiler/rustc_data_structures/src/vec_map.rs", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_data_structures%2Fsrc%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_data_structures%2Fsrc%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fvec_map.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -0,0 +1,155 @@\n+use std::borrow::Borrow;\n+use std::iter::FromIterator;\n+use std::slice::{Iter, IterMut};\n+use std::vec::IntoIter;\n+\n+use crate::stable_hasher::{HashStable, StableHasher};\n+\n+/// A map type implemented as a vector of pairs `K` (key) and `V` (value).\n+/// It currently provides a subset of all the map operations, the rest could be added as needed.\n+#[derive(Clone, Encodable, Decodable, Debug)]\n+pub struct VecMap<K, V>(Vec<(K, V)>);\n+\n+impl<K, V> VecMap<K, V>\n+where\n+    K: PartialEq,\n+{\n+    pub fn new() -> Self {\n+        VecMap(Default::default())\n+    }\n+\n+    /// Sets the value of the entry, and returns the entry's old value.\n+    pub fn insert(&mut self, k: K, v: V) -> Option<V> {\n+        if let Some(elem) = self.0.iter_mut().find(|(key, _)| *key == k) {\n+            Some(std::mem::replace(&mut elem.1, v))\n+        } else {\n+            self.0.push((k, v));\n+            None\n+        }\n+    }\n+\n+    /// Gets a reference to the value in the entry.\n+    pub fn get<Q: ?Sized>(&self, k: &Q) -> Option<&V>\n+    where\n+        K: Borrow<Q>,\n+        Q: Eq,\n+    {\n+        self.0.iter().find(|(key, _)| k == key.borrow()).map(|elem| &elem.1)\n+    }\n+\n+    /// Returns the value corresponding to the supplied predicate filter.\n+    ///\n+    /// The supplied predicate will be applied to each (key, value) pair and it will return a\n+    /// reference to the values where the predicate returns `true`.\n+    pub fn get_by(&self, mut predicate: impl FnMut(&(K, V)) -> bool) -> Option<&V> {\n+        self.0.iter().find(|kv| predicate(kv)).map(|elem| &elem.1)\n+    }\n+\n+    /// Returns `true` if the map contains a value for the specified key.\n+    ///\n+    /// The key may be any borrowed form of the map's key type,\n+    /// [`Eq`] on the borrowed form *must* match those for\n+    /// the key type.\n+    pub fn contains_key<Q: ?Sized>(&self, k: &Q) -> bool\n+    where\n+        K: Borrow<Q>,\n+        Q: Eq,\n+    {\n+        self.get(k).is_some()\n+    }\n+\n+    /// Returns `true` if the map contains no elements.\n+    pub fn is_empty(&self) -> bool {\n+        self.0.is_empty()\n+    }\n+\n+    pub fn iter(&self) -> Iter<'_, (K, V)> {\n+        self.into_iter()\n+    }\n+\n+    pub fn iter_mut(&mut self) -> IterMut<'_, (K, V)> {\n+        self.into_iter()\n+    }\n+}\n+\n+impl<K, V> Default for VecMap<K, V> {\n+    #[inline]\n+    fn default() -> Self {\n+        Self(Default::default())\n+    }\n+}\n+\n+impl<K, V> From<Vec<(K, V)>> for VecMap<K, V> {\n+    fn from(vec: Vec<(K, V)>) -> Self {\n+        Self(vec)\n+    }\n+}\n+\n+impl<K, V> Into<Vec<(K, V)>> for VecMap<K, V> {\n+    fn into(self) -> Vec<(K, V)> {\n+        self.0\n+    }\n+}\n+\n+impl<K, V> FromIterator<(K, V)> for VecMap<K, V> {\n+    fn from_iter<I: IntoIterator<Item = (K, V)>>(iter: I) -> Self {\n+        Self(iter.into_iter().collect())\n+    }\n+}\n+\n+impl<'a, K, V> IntoIterator for &'a VecMap<K, V> {\n+    type Item = &'a (K, V);\n+    type IntoIter = Iter<'a, (K, V)>;\n+\n+    #[inline]\n+    fn into_iter(self) -> Self::IntoIter {\n+        self.0.iter()\n+    }\n+}\n+\n+impl<'a, K, V> IntoIterator for &'a mut VecMap<K, V> {\n+    type Item = &'a mut (K, V);\n+    type IntoIter = IterMut<'a, (K, V)>;\n+\n+    #[inline]\n+    fn into_iter(self) -> Self::IntoIter {\n+        self.0.iter_mut()\n+    }\n+}\n+\n+impl<K, V> IntoIterator for VecMap<K, V> {\n+    type Item = (K, V);\n+    type IntoIter = IntoIter<(K, V)>;\n+\n+    #[inline]\n+    fn into_iter(self) -> Self::IntoIter {\n+        self.0.into_iter()\n+    }\n+}\n+\n+impl<K, V> Extend<(K, V)> for VecMap<K, V> {\n+    fn extend<I: IntoIterator<Item = (K, V)>>(&mut self, iter: I) {\n+        self.0.extend(iter);\n+    }\n+\n+    fn extend_one(&mut self, item: (K, V)) {\n+        self.0.extend_one(item);\n+    }\n+\n+    fn extend_reserve(&mut self, additional: usize) {\n+        self.0.extend_reserve(additional);\n+    }\n+}\n+\n+impl<K, V, CTX> HashStable<CTX> for VecMap<K, V>\n+where\n+    K: HashStable<CTX> + Eq,\n+    V: HashStable<CTX>,\n+{\n+    fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {\n+        self.0.hash_stable(hcx, hasher)\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests;"}, {"sha": "9083de85982e7df482863d3e201a09acd5846cc7", "filename": "compiler/rustc_data_structures/src/vec_map/tests.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_data_structures%2Fsrc%2Fvec_map%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_data_structures%2Fsrc%2Fvec_map%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fvec_map%2Ftests.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -0,0 +1,48 @@\n+use super::*;\n+\n+impl<K, V> VecMap<K, V> {\n+    fn into_vec(self) -> Vec<(K, V)> {\n+        self.0.into()\n+    }\n+}\n+\n+#[test]\n+fn test_from_iterator() {\n+    assert_eq!(\n+        std::iter::empty().collect::<VecMap<i32, bool>>().into_vec(),\n+        Vec::<(i32, bool)>::new()\n+    );\n+    assert_eq!(std::iter::once((42, true)).collect::<VecMap<_, _>>().into_vec(), vec![(42, true)]);\n+    assert_eq!(\n+        vec![(1, true), (2, false)].into_iter().collect::<VecMap<_, _>>().into_vec(),\n+        vec![(1, true), (2, false)]\n+    );\n+}\n+\n+#[test]\n+fn test_into_iterator_owned() {\n+    assert_eq!(VecMap::new().into_iter().collect::<Vec<(i32, bool)>>(), Vec::<(i32, bool)>::new());\n+    assert_eq!(VecMap::from(vec![(1, true)]).into_iter().collect::<Vec<_>>(), vec![(1, true)]);\n+    assert_eq!(\n+        VecMap::from(vec![(1, true), (2, false)]).into_iter().collect::<Vec<_>>(),\n+        vec![(1, true), (2, false)]\n+    );\n+}\n+\n+#[test]\n+fn test_insert() {\n+    let mut v = VecMap::new();\n+    assert_eq!(v.insert(1, true), None);\n+    assert_eq!(v.insert(2, false), None);\n+    assert_eq!(v.clone().into_vec(), vec![(1, true), (2, false)]);\n+    assert_eq!(v.insert(1, false), Some(true));\n+    assert_eq!(v.into_vec(), vec![(1, false), (2, false)]);\n+}\n+\n+#[test]\n+fn test_get() {\n+    let v = vec![(1, true), (2, false)].into_iter().collect::<VecMap<_, _>>();\n+    assert_eq!(v.get(&1), Some(&true));\n+    assert_eq!(v.get(&2), Some(&false));\n+    assert_eq!(v.get(&3), None);\n+}"}, {"sha": "b943977e4c2bb36c7518a4bcdae5c989a4681a49", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -21,7 +21,7 @@ use rustc_data_structures::sync::SeqCst;\n use rustc_errors::registry::{InvalidErrorCode, Registry};\n use rustc_errors::{ErrorReported, PResult};\n use rustc_feature::find_gated_cfg;\n-use rustc_interface::util::{self, collect_crate_types, get_builtin_codegen_backend};\n+use rustc_interface::util::{self, collect_crate_types, get_codegen_backend};\n use rustc_interface::{interface, Queries};\n use rustc_lint::LintStore;\n use rustc_metadata::locator;\n@@ -499,7 +499,7 @@ fn make_input(\n     }\n }\n \n-// Whether to stop or continue compilation.\n+/// Whether to stop or continue compilation.\n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n pub enum Compilation {\n     Stop,\n@@ -765,9 +765,16 @@ pub fn version(binary: &str, matches: &getopts::Matches) {\n         println!(\"commit-date: {}\", unw(util::commit_date_str()));\n         println!(\"host: {}\", config::host_triple());\n         println!(\"release: {}\", unw(util::release_str()));\n-        if cfg!(feature = \"llvm\") {\n-            get_builtin_codegen_backend(&None, \"llvm\")().print_version();\n-        }\n+\n+        let debug_flags = matches.opt_strs(\"Z\");\n+        let backend_name = debug_flags.iter().find_map(|x| {\n+            if x.starts_with(\"codegen-backend=\") {\n+                Some(&x[\"codegen-backends=\".len()..])\n+            } else {\n+                None\n+            }\n+        });\n+        get_codegen_backend(&None, backend_name).print_version();\n     }\n }\n \n@@ -1039,8 +1046,8 @@ pub fn handle_options(args: &[String]) -> Option<getopts::Matches> {\n     }\n \n     // Don't handle -W help here, because we might first load plugins.\n-    let r = matches.opt_strs(\"Z\");\n-    if r.iter().any(|x| *x == \"help\") {\n+    let debug_flags = matches.opt_strs(\"Z\");\n+    if debug_flags.iter().any(|x| *x == \"help\") {\n         describe_debug_flags();\n         return None;\n     }\n@@ -1060,9 +1067,14 @@ pub fn handle_options(args: &[String]) -> Option<getopts::Matches> {\n     }\n \n     if cg_flags.iter().any(|x| *x == \"passes=list\") {\n-        if cfg!(feature = \"llvm\") {\n-            get_builtin_codegen_backend(&None, \"llvm\")().print_passes();\n-        }\n+        let backend_name = debug_flags.iter().find_map(|x| {\n+            if x.starts_with(\"codegen-backend=\") {\n+                Some(&x[\"codegen-backends=\".len()..])\n+            } else {\n+                None\n+            }\n+        });\n+        get_codegen_backend(&None, backend_name).print_passes();\n         return None;\n     }\n "}, {"sha": "f10efd832361c252715a628de77127f7f4dae5b7", "filename": "compiler/rustc_error_codes/src/error_codes.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -157,6 +157,7 @@ E0308: include_str!(\"./error_codes/E0308.md\"),\n E0309: include_str!(\"./error_codes/E0309.md\"),\n E0310: include_str!(\"./error_codes/E0310.md\"),\n E0312: include_str!(\"./error_codes/E0312.md\"),\n+E0316: include_str!(\"./error_codes/E0316.md\"),\n E0317: include_str!(\"./error_codes/E0317.md\"),\n E0321: include_str!(\"./error_codes/E0321.md\"),\n E0322: include_str!(\"./error_codes/E0322.md\"),\n@@ -553,9 +554,8 @@ E0783: include_str!(\"./error_codes/E0783.md\"),\n     E0311, // thing may not live long enough\n     E0313, // lifetime of borrowed pointer outlives lifetime of captured\n            // variable\n-    E0314, // closure outlives stack frame\n-    E0315, // cannot invoke closure outside of its lifetime\n-    E0316, // nested quantification of lifetimes\n+//  E0314, // closure outlives stack frame\n+//  E0315, // cannot invoke closure outside of its lifetime\n //  E0319, // trait impls for defaulted traits allowed just for structs/enums\n     E0320, // recursive overflow during dropck\n //  E0372, // coherence not object safe\n@@ -584,21 +584,21 @@ E0783: include_str!(\"./error_codes/E0783.md\"),\n //  E0470, removed\n //  E0471, // constant evaluation error (in pattern)\n     E0472, // llvm_asm! is unsupported on this target\n-    E0473, // dereference of reference outside its lifetime\n-    E0474, // captured variable `..` does not outlive the enclosing closure\n-    E0475, // index of slice outside its lifetime\n+//  E0473, // dereference of reference outside its lifetime\n+//  E0474, // captured variable `..` does not outlive the enclosing closure\n+//  E0475, // index of slice outside its lifetime\n     E0476, // lifetime of the source pointer does not outlive lifetime bound...\n-    E0479, // the type `..` (provided as the value of a type parameter) is...\n-    E0480, // lifetime of method receiver does not outlive the method call\n-    E0481, // lifetime of function argument does not outlive the function call\n+//  E0479, // the type `..` (provided as the value of a type parameter) is...\n+//  E0480, // lifetime of method receiver does not outlive the method call\n+//  E0481, // lifetime of function argument does not outlive the function call\n     E0482, // lifetime of return value does not outlive the function call\n-    E0483, // lifetime of operand does not outlive the operation\n-    E0484, // reference is not valid at the time of borrow\n-    E0485, // automatically reference is not valid at the time of borrow\n-    E0486, // type of expression contains references that are not valid during..\n-    E0487, // unsafe use of destructor: destructor might be called while...\n-    E0488, // lifetime of variable does not enclose its declaration\n-    E0489, // type/lifetime parameter not in scope here\n+//  E0483, // lifetime of operand does not outlive the operation\n+//  E0484, // reference is not valid at the time of borrow\n+//  E0485, // automatically reference is not valid at the time of borrow\n+//  E0486, // type of expression contains references that are not valid during..\n+//  E0487, // unsafe use of destructor: destructor might be called while...\n+//  E0488, // lifetime of variable does not enclose its declaration\n+//  E0489, // type/lifetime parameter not in scope here\n     E0490, // a value of type `..` is borrowed for too long\n     E0498,  // malformed plugin attribute\n     E0514, // metadata version mismatch"}, {"sha": "4368c321737b2b0ea0349ad05824334741deaefb", "filename": "compiler/rustc_error_codes/src/error_codes/E0316.md", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0316.md", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0316.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0316.md?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -0,0 +1,32 @@\n+A `where` clause contains a nested quantification over lifetimes.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0316\n+trait Tr<'a, 'b> {}\n+\n+fn foo<T>(t: T)\n+where\n+    for<'a> &'a T: for<'b> Tr<'a, 'b>, // error: nested quantification\n+{\n+}\n+```\n+\n+Rust syntax allows lifetime quantifications in two places within\n+`where` clauses: Quantifying over the trait bound only (as in\n+`Ty: for<'l> Trait<'l>`) and quantifying over the whole clause\n+(as in `for<'l> &'l Ty: Trait<'l>`). Using both in the same clause\n+leads to a nested lifetime quantification, which is not supported.\n+\n+The following example compiles, because the clause with the nested\n+quantification has been rewritten to use only one `for<>`:\n+\n+```\n+trait Tr<'a, 'b> {}\n+\n+fn foo<T>(t: T)\n+where\n+    for<'a, 'b> &'a T: Tr<'a, 'b>, // ok\n+{\n+}\n+```"}, {"sha": "6b16a7d415aa61e17af426913e183271cd229a78", "filename": "compiler/rustc_error_codes/src/error_codes/E0759.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0759.md", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0759.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0759.md?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -16,13 +16,13 @@ fn bar(x: &i32) -> Box<dyn Debug> { // error!\n \n Add `'static` requirement to fix them:\n \n-```compile_fail,E0759\n+```\n # use std::fmt::Debug;\n-fn foo(x: &i32) -> impl Debug + 'static { // ok!\n+fn foo(x: &'static i32) -> impl Debug + 'static { // ok!\n     x\n }\n \n-fn bar(x: &i32) -> Box<dyn Debug + 'static> { // ok!\n+fn bar(x: &'static i32) -> Box<dyn Debug + 'static> { // ok!\n     Box::new(x)\n }\n ```"}, {"sha": "72395bd31eca556aed999d8f7057489b6a546dca", "filename": "compiler/rustc_errors/src/json.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_errors%2Fsrc%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_errors%2Fsrc%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fjson.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -216,7 +216,7 @@ macro_rules! encode_fields {\n             $(\n                 $enc.emit_struct_field(\n                     stringify!($name),\n-                    idx,\n+                    idx == 0,\n                     |enc| $name.encode(enc),\n                 )?;\n                 idx += 1;\n@@ -229,7 +229,7 @@ macro_rules! encode_fields {\n // Special-case encoder to skip tool_metadata if not set\n impl<E: Encoder> Encodable<E> for Diagnostic {\n     fn encode(&self, s: &mut E) -> Result<(), E::Error> {\n-        s.emit_struct(\"diagnostic\", 7, |s| {\n+        s.emit_struct(false, |s| {\n             let mut idx = 0;\n \n             idx = encode_fields!("}, {"sha": "979f2d3b3005d3ec345cd048413fbb6b6ec6938f", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -715,6 +715,7 @@ impl Handler {\n         self.inner.borrow_mut().bug(msg)\n     }\n \n+    #[inline]\n     pub fn err_count(&self) -> usize {\n         self.inner.borrow().err_count()\n     }\n@@ -924,6 +925,7 @@ impl HandlerInner {\n         }\n     }\n \n+    #[inline]\n     fn err_count(&self) -> usize {\n         self.err_count + self.stashed_diagnostics.len()\n     }"}, {"sha": "aab2741c85240c1b4d08ffa72a7ec5a998726702", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -1068,11 +1068,11 @@ impl<'a> ExtCtxt<'a> {\n         self.resolver.check_unused_macros();\n     }\n \n-    /// Resolves a path mentioned inside Rust code.\n+    /// Resolves a `path` mentioned inside Rust code, returning an absolute path.\n     ///\n-    /// This unifies the logic used for resolving `include_X!`, and `#[doc(include)]` file paths.\n+    /// This unifies the logic used for resolving `include_X!`.\n     ///\n-    /// Returns an absolute path to the file that `path` refers to.\n+    /// FIXME: move this to `rustc_builtin_macros` and make it private.\n     pub fn resolve_path(\n         &self,\n         path: impl Into<PathBuf>,"}, {"sha": "ef5b97a946909707e20767b6be5921525451e85a", "filename": "compiler/rustc_expand/src/build.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -275,7 +275,12 @@ impl<'a> ExtCtxt<'a> {\n     ) -> P<ast::Expr> {\n         self.expr(\n             span,\n-            ast::ExprKind::Struct(P(ast::StructExpr { path, fields, rest: ast::StructRest::None })),\n+            ast::ExprKind::Struct(P(ast::StructExpr {\n+                qself: None,\n+                path,\n+                fields,\n+                rest: ast::StructRest::None,\n+            })),\n         )\n     }\n     pub fn expr_struct_ident(\n@@ -405,15 +410,15 @@ impl<'a> ExtCtxt<'a> {\n         path: ast::Path,\n         subpats: Vec<P<ast::Pat>>,\n     ) -> P<ast::Pat> {\n-        self.pat(span, PatKind::TupleStruct(path, subpats))\n+        self.pat(span, PatKind::TupleStruct(None, path, subpats))\n     }\n     pub fn pat_struct(\n         &self,\n         span: Span,\n         path: ast::Path,\n         field_pats: Vec<ast::PatField>,\n     ) -> P<ast::Pat> {\n-        self.pat(span, PatKind::Struct(path, field_pats, false))\n+        self.pat(span, PatKind::Struct(None, path, field_pats, false))\n     }\n     pub fn pat_tuple(&self, span: Span, pats: Vec<P<ast::Pat>>) -> P<ast::Pat> {\n         self.pat(span, PatKind::Tuple(pats))"}, {"sha": "39c0447bd099eadc87a28c52c6804c623b0e396f", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 5, "deletions": 139, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -12,11 +12,11 @@ use rustc_ast::ptr::P;\n use rustc_ast::token;\n use rustc_ast::tokenstream::TokenStream;\n use rustc_ast::visit::{self, AssocCtxt, Visitor};\n-use rustc_ast::{AstLike, AttrItem, Block, Inline, ItemKind, LitKind, MacArgs};\n+use rustc_ast::{AstLike, Block, Inline, ItemKind, MacArgs};\n use rustc_ast::{MacCallStmt, MacStmtStyle, MetaItemKind, ModKind, NestedMetaItem};\n use rustc_ast::{NodeId, PatKind, Path, StmtKind, Unsafe};\n use rustc_ast_pretty::pprust;\n-use rustc_attr::{self as attr, is_builtin_attr};\n+use rustc_attr::is_builtin_attr;\n use rustc_data_structures::map_in_place::MapInPlace;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_data_structures::sync::Lrc;\n@@ -28,15 +28,14 @@ use rustc_session::lint::builtin::UNUSED_DOC_COMMENTS;\n use rustc_session::lint::BuiltinLintDiagnostics;\n use rustc_session::parse::{feature_err, ParseSess};\n use rustc_session::Limit;\n-use rustc_span::symbol::{sym, Ident, Symbol};\n-use rustc_span::{ExpnId, FileName, Span, DUMMY_SP};\n+use rustc_span::symbol::{sym, Ident};\n+use rustc_span::{ExpnId, FileName, Span};\n \n use smallvec::{smallvec, SmallVec};\n-use std::io::ErrorKind;\n use std::ops::DerefMut;\n use std::path::PathBuf;\n use std::rc::Rc;\n-use std::{iter, mem, slice};\n+use std::{iter, mem};\n \n macro_rules! ast_fragments {\n     (\n@@ -1524,139 +1523,6 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n         noop_flat_map_generic_param(param, self)\n     }\n \n-    fn visit_attribute(&mut self, at: &mut ast::Attribute) {\n-        // turn `#[doc(include=\"filename\")]` attributes into `#[doc(include(file=\"filename\",\n-        // contents=\"file contents\")]` attributes\n-        if !self.cx.sess.check_name(at, sym::doc) {\n-            return noop_visit_attribute(at, self);\n-        }\n-\n-        if let Some(list) = at.meta_item_list() {\n-            if !list.iter().any(|it| it.has_name(sym::include)) {\n-                return noop_visit_attribute(at, self);\n-            }\n-\n-            let mut items = vec![];\n-\n-            for mut it in list {\n-                if !it.has_name(sym::include) {\n-                    items.push({\n-                        noop_visit_meta_list_item(&mut it, self);\n-                        it\n-                    });\n-                    continue;\n-                }\n-\n-                if let Some(file) = it.value_str() {\n-                    let err_count = self.cx.sess.parse_sess.span_diagnostic.err_count();\n-                    self.check_attributes(slice::from_ref(at));\n-                    if self.cx.sess.parse_sess.span_diagnostic.err_count() > err_count {\n-                        // avoid loading the file if they haven't enabled the feature\n-                        return noop_visit_attribute(at, self);\n-                    }\n-\n-                    let filename = match self.cx.resolve_path(&*file.as_str(), it.span()) {\n-                        Ok(filename) => filename,\n-                        Err(mut err) => {\n-                            err.emit();\n-                            continue;\n-                        }\n-                    };\n-\n-                    match self.cx.source_map().load_file(&filename) {\n-                        Ok(source_file) => {\n-                            let src = source_file\n-                                .src\n-                                .as_ref()\n-                                .expect(\"freshly loaded file should have a source\");\n-                            let src_interned = Symbol::intern(src.as_str());\n-\n-                            let include_info = vec![\n-                                ast::NestedMetaItem::MetaItem(attr::mk_name_value_item_str(\n-                                    Ident::with_dummy_span(sym::file),\n-                                    file,\n-                                    DUMMY_SP,\n-                                )),\n-                                ast::NestedMetaItem::MetaItem(attr::mk_name_value_item_str(\n-                                    Ident::with_dummy_span(sym::contents),\n-                                    src_interned,\n-                                    DUMMY_SP,\n-                                )),\n-                            ];\n-\n-                            let include_ident = Ident::with_dummy_span(sym::include);\n-                            let item = attr::mk_list_item(include_ident, include_info);\n-                            items.push(ast::NestedMetaItem::MetaItem(item));\n-                        }\n-                        Err(e) => {\n-                            let lit_span = it.name_value_literal_span().unwrap();\n-\n-                            if e.kind() == ErrorKind::InvalidData {\n-                                self.cx\n-                                    .struct_span_err(\n-                                        lit_span,\n-                                        &format!(\"{} wasn't a utf-8 file\", filename.display()),\n-                                    )\n-                                    .span_label(lit_span, \"contains invalid utf-8\")\n-                                    .emit();\n-                            } else {\n-                                let mut err = self.cx.struct_span_err(\n-                                    lit_span,\n-                                    &format!(\"couldn't read {}: {}\", filename.display(), e),\n-                                );\n-                                err.span_label(lit_span, \"couldn't read file\");\n-\n-                                err.emit();\n-                            }\n-                        }\n-                    }\n-                } else {\n-                    let mut err = self\n-                        .cx\n-                        .struct_span_err(it.span(), \"expected path to external documentation\");\n-\n-                    // Check if the user erroneously used `doc(include(...))` syntax.\n-                    let literal = it.meta_item_list().and_then(|list| {\n-                        if list.len() == 1 {\n-                            list[0].literal().map(|literal| &literal.kind)\n-                        } else {\n-                            None\n-                        }\n-                    });\n-\n-                    let (path, applicability) = match &literal {\n-                        Some(LitKind::Str(path, ..)) => {\n-                            (path.to_string(), Applicability::MachineApplicable)\n-                        }\n-                        _ => (String::from(\"<path>\"), Applicability::HasPlaceholders),\n-                    };\n-\n-                    err.span_suggestion(\n-                        it.span(),\n-                        \"provide a file path with `=`\",\n-                        format!(\"include = \\\"{}\\\"\", path),\n-                        applicability,\n-                    );\n-\n-                    err.emit();\n-                }\n-            }\n-\n-            let meta = attr::mk_list_item(Ident::with_dummy_span(sym::doc), items);\n-            *at = ast::Attribute {\n-                kind: ast::AttrKind::Normal(\n-                    AttrItem { path: meta.path, args: meta.kind.mac_args(meta.span), tokens: None },\n-                    None,\n-                ),\n-                span: at.span,\n-                id: at.id,\n-                style: at.style,\n-            };\n-        } else {\n-            noop_visit_attribute(at, self)\n-        }\n-    }\n-\n     fn visit_id(&mut self, id: &mut ast::NodeId) {\n         if self.monotonic {\n             debug_assert_eq!(*id, ast::DUMMY_NODE_ID);"}, {"sha": "efed41de23a89ebf23b7f0c86841db93167d20f5", "filename": "compiler/rustc_expand/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Flib.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -1,7 +1,7 @@\n-#![feature(bool_to_option)]\n #![feature(crate_visibility_modifier)]\n #![feature(decl_macro)]\n #![feature(destructuring_assignment)]\n+#![feature(format_args_capture)]\n #![feature(iter_zip)]\n #![feature(proc_macro_diagnostic)]\n #![feature(proc_macro_internals)]"}, {"sha": "a7434d73abe68ea7ec514b8650eee802313ce095", "filename": "compiler/rustc_expand/src/mbe/macro_parser.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -85,6 +85,7 @@ use smallvec::{smallvec, SmallVec};\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n+use rustc_span::symbol::Ident;\n use std::borrow::Cow;\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::mem;\n@@ -615,7 +616,11 @@ fn inner_parse_loop<'root, 'tt>(\n \n /// Use the given sequence of token trees (`ms`) as a matcher. Match the token\n /// stream from the given `parser` against it and return the match.\n-pub(super) fn parse_tt(parser: &mut Cow<'_, Parser<'_>>, ms: &[TokenTree]) -> NamedParseResult {\n+pub(super) fn parse_tt(\n+    parser: &mut Cow<'_, Parser<'_>>,\n+    ms: &[TokenTree],\n+    macro_name: Ident,\n+) -> NamedParseResult {\n     // A queue of possible matcher positions. We initialize it with the matcher position in which\n     // the \"dot\" is before the first token of the first token tree in `ms`. `inner_parse_loop` then\n     // processes all of these possible matcher positions and produces possible next positions into\n@@ -711,7 +716,7 @@ pub(super) fn parse_tt(parser: &mut Cow<'_, Parser<'_>>, ms: &[TokenTree]) -> Na\n             return Error(\n                 parser.token.span,\n                 format!(\n-                    \"local ambiguity: multiple parsing options: {}\",\n+                    \"local ambiguity when calling macro `{macro_name}`: multiple parsing options: {}\",\n                     match next_items.len() {\n                         0 => format!(\"built-in NTs {}.\", nts),\n                         1 => format!(\"built-in NTs {} or 1 other option.\", nts),"}, {"sha": "abad190b072ab3081cc8ce064bdd659c147e55c8", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -245,7 +245,7 @@ fn generic_extension<'cx>(\n         // are not recorded. On the first `Success(..)`ful matcher, the spans are merged.\n         let mut gated_spans_snapshot = mem::take(&mut *sess.gated_spans.spans.borrow_mut());\n \n-        match parse_tt(&mut Cow::Borrowed(&parser), lhs_tt) {\n+        match parse_tt(&mut Cow::Borrowed(&parser), lhs_tt, name) {\n             Success(named_matches) => {\n                 // The matcher was `Success(..)`ful.\n                 // Merge the gated spans from parsing the matcher with the pre-existing ones.\n@@ -338,7 +338,7 @@ fn generic_extension<'cx>(\n                 _ => continue,\n             };\n             if let Success(_) =\n-                parse_tt(&mut Cow::Borrowed(&parser_from_cx(sess, arg.clone())), lhs_tt)\n+                parse_tt(&mut Cow::Borrowed(&parser_from_cx(sess, arg.clone())), lhs_tt, name)\n             {\n                 if comma_span.is_dummy() {\n                     err.note(\"you might be missing a comma\");\n@@ -432,7 +432,7 @@ pub fn compile_declarative_macro(\n     ];\n \n     let parser = Parser::new(&sess.parse_sess, body, true, rustc_parse::MACRO_ARGUMENTS);\n-    let argument_map = match parse_tt(&mut Cow::Borrowed(&parser), &argument_gram) {\n+    let argument_map = match parse_tt(&mut Cow::Borrowed(&parser), &argument_gram, def.ident) {\n         Success(m) => m,\n         Failure(token, msg) => {\n             let s = parse_failure_msg(&token);\n@@ -467,6 +467,7 @@ pub fn compile_declarative_macro(\n                             &sess.parse_sess,\n                             def.id,\n                             features,\n+                            edition,\n                         )\n                         .pop()\n                         .unwrap();\n@@ -492,6 +493,7 @@ pub fn compile_declarative_macro(\n                             &sess.parse_sess,\n                             def.id,\n                             features,\n+                            edition,\n                         )\n                         .pop()\n                         .unwrap();"}, {"sha": "fb7479eafc86f5e155640393e1efd8891f4c5873", "filename": "compiler/rustc_expand/src/mbe/quoted.rs", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fquoted.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -9,7 +9,8 @@ use rustc_feature::Features;\n use rustc_session::parse::ParseSess;\n use rustc_span::symbol::{kw, Ident};\n \n-use rustc_span::Span;\n+use rustc_span::edition::Edition;\n+use rustc_span::{Span, SyntaxContext};\n \n use rustc_data_structures::sync::Lrc;\n \n@@ -32,6 +33,7 @@ const VALID_FRAGMENT_NAMES_MSG: &str = \"valid fragment specifiers are \\\n /// - `sess`: the parsing session. Any errors will be emitted to this session.\n /// - `node_id`: the NodeId of the macro we are parsing.\n /// - `features`: language features so we can do feature gating.\n+/// - `edition`: the edition of the crate defining the macro\n ///\n /// # Returns\n ///\n@@ -42,6 +44,7 @@ pub(super) fn parse(\n     sess: &ParseSess,\n     node_id: NodeId,\n     features: &Features,\n+    edition: Edition,\n ) -> Vec<TokenTree> {\n     // Will contain the final collection of `self::TokenTree`\n     let mut result = Vec::new();\n@@ -52,7 +55,7 @@ pub(super) fn parse(\n     while let Some(tree) = trees.next() {\n         // Given the parsed tree, if there is a metavar and we are expecting matchers, actually\n         // parse out the matcher (i.e., in `$id:ident` this would parse the `:` and `ident`).\n-        let tree = parse_tree(tree, &mut trees, expect_matchers, sess, node_id, features);\n+        let tree = parse_tree(tree, &mut trees, expect_matchers, sess, node_id, features, edition);\n         match tree {\n             TokenTree::MetaVar(start_sp, ident) if expect_matchers => {\n                 let span = match trees.next() {\n@@ -64,7 +67,19 @@ pub(super) fn parse(\n \n                                     let kind =\n                                         token::NonterminalKind::from_symbol(frag.name, || {\n-                                            span.edition()\n+                                            // FIXME(#85708) - once we properly decode a foreign\n+                                            // crate's `SyntaxContext::root`, then we can replace\n+                                            // this with just `span.edition()`. A\n+                                            // `SyntaxContext::root()` from the current crate will\n+                                            // have the edition of the current crate, and a\n+                                            // `SyntaxxContext::root()` from a foreign crate will\n+                                            // have the edition of that crate (which we manually\n+                                            // retrieve via the `edition` parameter).\n+                                            if span.ctxt() == SyntaxContext::root() {\n+                                                edition\n+                                            } else {\n+                                                span.edition()\n+                                            }\n                                         })\n                                         .unwrap_or_else(\n                                             || {\n@@ -117,13 +132,15 @@ pub(super) fn parse(\n /// - `expect_matchers`: same as for `parse` (see above).\n /// - `sess`: the parsing session. Any errors will be emitted to this session.\n /// - `features`: language features so we can do feature gating.\n+/// - `edition` - the edition of the crate defining the macro\n fn parse_tree(\n     tree: tokenstream::TokenTree,\n     outer_trees: &mut impl Iterator<Item = tokenstream::TokenTree>,\n     expect_matchers: bool,\n     sess: &ParseSess,\n     node_id: NodeId,\n     features: &Features,\n+    edition: Edition,\n ) -> TokenTree {\n     // Depending on what `tree` is, we could be parsing different parts of a macro\n     match tree {\n@@ -151,7 +168,7 @@ fn parse_tree(\n                         sess.span_diagnostic.span_err(span.entire(), &msg);\n                     }\n                     // Parse the contents of the sequence itself\n-                    let sequence = parse(tts, expect_matchers, sess, node_id, features);\n+                    let sequence = parse(tts, expect_matchers, sess, node_id, features, edition);\n                     // Get the Kleene operator and optional separator\n                     let (separator, kleene) =\n                         parse_sep_and_kleene_op(&mut trees, span.entire(), sess);\n@@ -204,7 +221,7 @@ fn parse_tree(\n             span,\n             Lrc::new(Delimited {\n                 delim,\n-                tts: parse(tts, expect_matchers, sess, node_id, features),\n+                tts: parse(tts, expect_matchers, sess, node_id, features, edition),\n             }),\n         ),\n     }"}, {"sha": "56a320c8d3bce0f786d07557e9164398335ba18d", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -250,6 +250,7 @@ declare_features! (\n     (active, f16c_target_feature, \"1.36.0\", Some(44839), None),\n     (active, riscv_target_feature, \"1.45.0\", Some(44839), None),\n     (active, ermsb_target_feature, \"1.49.0\", Some(44839), None),\n+    (active, bpf_target_feature, \"1.54.0\", Some(44839), None),\n \n     // -------------------------------------------------------------------------\n     // feature-group-end: actual feature gates (target features)\n@@ -370,9 +371,6 @@ declare_features! (\n     /// Allows `#[doc(masked)]`.\n     (active, doc_masked, \"1.21.0\", Some(44027), None),\n \n-    /// Allows `#[doc(include = \"some-file\")]`.\n-    (active, external_doc, \"1.22.0\", Some(44732), None),\n-\n     /// Allows using `crate` as visibility modifier, synonymous with `pub(crate)`.\n     (active, crate_visibility_modifier, \"1.23.0\", Some(53120), None),\n \n@@ -665,6 +663,9 @@ declare_features! (\n     /// Allows unnamed fields of struct and union type\n     (active, unnamed_fields, \"1.53.0\", Some(49804), None),\n \n+    /// Allows qualified paths in struct expressions, struct patterns and tuple struct patterns.\n+    (active, more_qualified_paths, \"1.54.0\", Some(80080), None),\n+\n     // -------------------------------------------------------------------------\n     // feature-group-end: actual feature gates\n     // -------------------------------------------------------------------------"}, {"sha": "259a6328a22f6832a6ae275578b532a5ba95550d", "filename": "compiler/rustc_feature/src/builtin_attrs.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -568,10 +568,6 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     rustc_attr!(TEST, rustc_evaluate_where_clauses, AssumedUsed, template!(Word)),\n     rustc_attr!(TEST, rustc_if_this_changed, AssumedUsed, template!(Word, List: \"DepNode\")),\n     rustc_attr!(TEST, rustc_then_this_would_need, AssumedUsed, template!(List: \"DepNode\")),\n-    rustc_attr!(\n-        TEST, rustc_dirty, AssumedUsed,\n-        template!(List: r#\"cfg = \"...\", /*opt*/ label = \"...\", /*opt*/ except = \"...\"\"#),\n-    ),\n     rustc_attr!(\n         TEST, rustc_clean, AssumedUsed,\n         template!(List: r#\"cfg = \"...\", /*opt*/ label = \"...\", /*opt*/ except = \"...\"\"#),"}, {"sha": "71c10eb650754699eb8d98456c7fe0a4dd2e46ca", "filename": "compiler/rustc_feature/src/removed.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_feature%2Fsrc%2Fremoved.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_feature%2Fsrc%2Fremoved.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fremoved.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -140,6 +140,10 @@ declare_features! (\n     (removed, const_fn, \"1.54.0\", Some(57563), None,\n      Some(\"split into finer-grained feature gates\")),\n \n+    /// Allows `#[doc(include = \"some-file\")]`.\n+    (removed, external_doc, \"1.54.0\", Some(44732), None,\n+     Some(\"use #[doc = include_str!(\\\"filename\\\")] instead, which handles macro invocations\")),\n+\n     // -------------------------------------------------------------------------\n     // feature-group-end: removed features\n     // -------------------------------------------------------------------------"}, {"sha": "753b8c85670ba5dd1e01f9f7ba6c5a57752149e9", "filename": "compiler/rustc_hir/src/definitions.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -94,15 +94,6 @@ impl DefPathTable {\n             .iter_enumerated()\n             .map(move |(index, key)| (index, key, &self.def_path_hashes[index]))\n     }\n-\n-    pub fn all_def_path_hashes_and_def_ids(\n-        &self,\n-        krate: CrateNum,\n-    ) -> impl Iterator<Item = (DefPathHash, DefId)> + '_ {\n-        self.def_path_hashes\n-            .iter_enumerated()\n-            .map(move |(index, hash)| (*hash, DefId { krate, index }))\n-    }\n }\n \n /// The definition table containing node definitions.\n@@ -306,6 +297,7 @@ impl Definitions {\n         self.table.index_to_key.len()\n     }\n \n+    #[inline]\n     pub fn def_key(&self, id: LocalDefId) -> DefKey {\n         self.table.def_key(id.local_def_index)\n     }\n@@ -439,6 +431,14 @@ impl Definitions {\n     pub fn iter_local_def_id(&self) -> impl Iterator<Item = LocalDefId> + '_ {\n         self.def_id_to_hir_id.iter_enumerated().map(|(k, _)| k)\n     }\n+\n+    #[inline(always)]\n+    pub fn local_def_path_hash_to_def_id(&self, hash: DefPathHash) -> Option<LocalDefId> {\n+        self.table\n+            .def_path_hash_to_index\n+            .get(&hash)\n+            .map(|&local_def_index| LocalDefId { local_def_index })\n+    }\n }\n \n #[derive(Copy, Clone, PartialEq, Debug)]"}, {"sha": "577d43b1c8e5e3c1f9c19671815f682deea0cdb5", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -1,7 +1,7 @@\n // ignore-tidy-filelength\n use crate::def::{CtorKind, DefKind, Res};\n use crate::def_id::DefId;\n-crate use crate::hir_id::HirId;\n+crate use crate::hir_id::{HirId, ItemLocalId};\n use crate::{itemlikevisit, LangItem};\n \n use rustc_ast::util::parser::ExprPrecedence;\n@@ -10,6 +10,7 @@ use rustc_ast::{Attribute, FloatTy, IntTy, Label, LitKind, StrStyle, TraitObject\n pub use rustc_ast::{BorrowKind, ImplPolarity, IsAuto};\n pub use rustc_ast::{CaptureBy, Movability, Mutability};\n use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::{par_for_each_in, Send, Sync};\n use rustc_macros::HashStable_Generic;\n use rustc_span::source_map::Spanned;\n@@ -658,7 +659,9 @@ pub struct Crate<'hir> {\n     /// they are declared in the static array generated by proc_macro_harness.\n     pub proc_macros: Vec<HirId>,\n \n-    pub trait_map: BTreeMap<HirId, Vec<TraitCandidate>>,\n+    /// Map indicating what traits are in scope for places where this\n+    /// is relevant; generated by resolve.\n+    pub trait_map: FxHashMap<LocalDefId, FxHashMap<ItemLocalId, Box<[TraitCandidate]>>>,\n \n     /// Collected attributes from HIR nodes.\n     pub attrs: BTreeMap<HirId, &'hir [Attribute]>,\n@@ -2485,6 +2488,7 @@ pub enum FnRetTy<'hir> {\n }\n \n impl FnRetTy<'_> {\n+    #[inline]\n     pub fn span(&self) -> Span {\n         match *self {\n             Self::DefaultReturn(span) => span,"}, {"sha": "ad2ecae9233bcd9ea30e51e3719aadc5d33abc7d", "filename": "compiler/rustc_hir/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flib.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -3,12 +3,10 @@\n //! [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/hir.html\n \n #![feature(crate_visibility_modifier)]\n-#![feature(const_panic)]\n #![cfg_attr(bootstrap, feature(extended_key_value_attributes))]\n #![feature(in_band_lifetimes)]\n #![feature(once_cell)]\n #![feature(min_specialization)]\n-#![feature(trusted_step)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "560607528330bbd04c187b67b8988567fd02dc6b", "filename": "compiler/rustc_hir/src/stable_hash_impls.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -5,7 +5,7 @@ use crate::hir::{\n     TraitItem, TraitItemId, Ty, VisibilityKind,\n };\n use crate::hir_id::{HirId, ItemLocalId};\n-use rustc_span::def_id::{DefPathHash, LocalDefId};\n+use rustc_span::def_id::DefPathHash;\n \n /// Requirements for a `StableHashingContext` to be used in this crate.\n /// This is a hack to allow using the `HashStable_Generic` derive macro\n@@ -21,15 +21,14 @@ pub trait HashStableContext:\n     fn hash_hir_ty(&mut self, _: &Ty<'_>, hasher: &mut StableHasher);\n     fn hash_hir_visibility_kind(&mut self, _: &VisibilityKind<'_>, hasher: &mut StableHasher);\n     fn hash_hir_item_like<F: FnOnce(&mut Self)>(&mut self, f: F);\n-    fn local_def_path_hash(&self, def_id: LocalDefId) -> DefPathHash;\n }\n \n impl<HirCtx: crate::HashStableContext> ToStableHashKey<HirCtx> for HirId {\n     type KeyType = (DefPathHash, ItemLocalId);\n \n     #[inline]\n     fn to_stable_hash_key(&self, hcx: &HirCtx) -> (DefPathHash, ItemLocalId) {\n-        let def_path_hash = hcx.local_def_path_hash(self.owner);\n+        let def_path_hash = self.owner.to_stable_hash_key(hcx);\n         (def_path_hash, self.local_id)\n     }\n }\n@@ -39,7 +38,7 @@ impl<HirCtx: crate::HashStableContext> ToStableHashKey<HirCtx> for ItemId {\n \n     #[inline]\n     fn to_stable_hash_key(&self, hcx: &HirCtx) -> DefPathHash {\n-        hcx.local_def_path_hash(self.def_id)\n+        self.def_id.to_stable_hash_key(hcx)\n     }\n }\n \n@@ -48,7 +47,7 @@ impl<HirCtx: crate::HashStableContext> ToStableHashKey<HirCtx> for TraitItemId {\n \n     #[inline]\n     fn to_stable_hash_key(&self, hcx: &HirCtx) -> DefPathHash {\n-        hcx.local_def_path_hash(self.def_id)\n+        self.def_id.to_stable_hash_key(hcx)\n     }\n }\n \n@@ -57,7 +56,7 @@ impl<HirCtx: crate::HashStableContext> ToStableHashKey<HirCtx> for ImplItemId {\n \n     #[inline]\n     fn to_stable_hash_key(&self, hcx: &HirCtx) -> DefPathHash {\n-        hcx.local_def_path_hash(self.def_id)\n+        self.def_id.to_stable_hash_key(hcx)\n     }\n }\n \n@@ -66,7 +65,7 @@ impl<HirCtx: crate::HashStableContext> ToStableHashKey<HirCtx> for ForeignItemId\n \n     #[inline]\n     fn to_stable_hash_key(&self, hcx: &HirCtx) -> DefPathHash {\n-        hcx.local_def_path_hash(self.def_id)\n+        self.def_id.to_stable_hash_key(hcx)\n     }\n }\n "}, {"sha": "9abd4eae914b3652efe7f806a0126b2802907346", "filename": "compiler/rustc_incremental/src/persist/dirty_clean.rs", "status": "modified", "additions": 28, "deletions": 100, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -1,6 +1,5 @@\n-//! Debugging code to test fingerprints computed for query results.\n-//! For each node marked with `#[rustc_clean]` or `#[rustc_dirty]`,\n-//! we will compare the fingerprint from the current and from the previous\n+//! Debugging code to test fingerprints computed for query results.  For each node marked with\n+//! `#[rustc_clean]` we will compare the fingerprint from the current and from the previous\n //! compilation session as appropriate:\n //!\n //! - `#[rustc_clean(cfg=\"rev2\", except=\"typeck\")]` if we are\n@@ -30,7 +29,6 @@ use std::iter::FromIterator;\n use std::vec::Vec;\n \n const EXCEPT: Symbol = sym::except;\n-const LABEL: Symbol = sym::label;\n const CFG: Symbol = sym::cfg;\n \n // Base and Extra labels to build up the labels\n@@ -101,6 +99,12 @@ const LABELS_FN_IN_TRAIT: &[&[&str]] =\n /// For generic cases like inline-assembly, modules, etc.\n const LABELS_HIR_ONLY: &[&[&str]] = &[BASE_HIR];\n \n+/// Impl `DepNode`s.\n+const LABELS_TRAIT: &[&[&str]] = &[\n+    BASE_HIR,\n+    &[label_strs::associated_item_def_ids, label_strs::predicates_of, label_strs::generics_of],\n+];\n+\n /// Impl `DepNode`s.\n const LABELS_IMPL: &[&[&str]] = &[BASE_HIR, BASE_IMPL];\n \n@@ -122,22 +126,12 @@ struct Assertion {\n     dirty: Labels,\n }\n \n-impl Assertion {\n-    fn from_clean_labels(labels: Labels) -> Assertion {\n-        Assertion { clean: labels, dirty: Labels::default() }\n-    }\n-\n-    fn from_dirty_labels(labels: Labels) -> Assertion {\n-        Assertion { clean: Labels::default(), dirty: labels }\n-    }\n-}\n-\n pub fn check_dirty_clean_annotations(tcx: TyCtxt<'_>) {\n     if !tcx.sess.opts.debugging_opts.query_dep_graph {\n         return;\n     }\n \n-    // can't add `#[rustc_dirty]` etc without opting in to this feature\n+    // can't add `#[rustc_clean]` etc without opting in to this feature\n     if !tcx.features().rustc_attrs {\n         return;\n     }\n@@ -147,11 +141,7 @@ pub fn check_dirty_clean_annotations(tcx: TyCtxt<'_>) {\n         let mut dirty_clean_visitor = DirtyCleanVisitor { tcx, checked_attrs: Default::default() };\n         krate.visit_all_item_likes(&mut dirty_clean_visitor);\n \n-        let mut all_attrs = FindAllAttrs {\n-            tcx,\n-            attr_names: &[sym::rustc_dirty, sym::rustc_clean],\n-            found_attrs: vec![],\n-        };\n+        let mut all_attrs = FindAllAttrs { tcx, found_attrs: vec![] };\n         intravisit::walk_crate(&mut all_attrs, krate);\n \n         // Note that we cannot use the existing \"unused attribute\"-infrastructure\n@@ -169,37 +159,20 @@ pub struct DirtyCleanVisitor<'tcx> {\n impl DirtyCleanVisitor<'tcx> {\n     /// Possibly \"deserialize\" the attribute into a clean/dirty assertion\n     fn assertion_maybe(&mut self, item_id: LocalDefId, attr: &Attribute) -> Option<Assertion> {\n-        let is_clean = if self.tcx.sess.check_name(attr, sym::rustc_dirty) {\n-            false\n-        } else if self.tcx.sess.check_name(attr, sym::rustc_clean) {\n-            true\n-        } else {\n+        if !self.tcx.sess.check_name(attr, sym::rustc_clean) {\n             // skip: not rustc_clean/dirty\n             return None;\n-        };\n+        }\n         if !check_config(self.tcx, attr) {\n             // skip: not the correct `cfg=`\n             return None;\n         }\n-        let assertion = if let Some(labels) = self.labels(attr) {\n-            if is_clean {\n-                Assertion::from_clean_labels(labels)\n-            } else {\n-                Assertion::from_dirty_labels(labels)\n-            }\n-        } else {\n-            self.assertion_auto(item_id, attr, is_clean)\n-        };\n+        let assertion = self.assertion_auto(item_id, attr);\n         Some(assertion)\n     }\n \n     /// Gets the \"auto\" assertion on pre-validated attr, along with the `except` labels.\n-    fn assertion_auto(\n-        &mut self,\n-        item_id: LocalDefId,\n-        attr: &Attribute,\n-        is_clean: bool,\n-    ) -> Assertion {\n+    fn assertion_auto(&mut self, item_id: LocalDefId, attr: &Attribute) -> Assertion {\n         let (name, mut auto) = self.auto_labels(item_id, attr);\n         let except = self.except(attr);\n         for e in except.iter() {\n@@ -211,21 +184,7 @@ impl DirtyCleanVisitor<'tcx> {\n                 self.tcx.sess.span_fatal(attr.span, &msg);\n             }\n         }\n-        if is_clean {\n-            Assertion { clean: auto, dirty: except }\n-        } else {\n-            Assertion { clean: except, dirty: auto }\n-        }\n-    }\n-\n-    fn labels(&self, attr: &Attribute) -> Option<Labels> {\n-        for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n-            if item.has_name(LABEL) {\n-                let value = expect_associated_value(self.tcx, &item);\n-                return Some(self.resolve_labels(&item, value));\n-            }\n-        }\n-        None\n+        Assertion { clean: auto, dirty: except }\n     }\n \n     /// `except=` attribute value\n@@ -288,20 +247,7 @@ impl DirtyCleanVisitor<'tcx> {\n                     HirItem::Union(..) => (\"ItemUnion\", LABELS_ADT),\n \n                     // Represents a Trait Declaration\n-                    // FIXME(michaelwoerister): trait declaration is buggy because sometimes some of\n-                    // the depnodes don't exist (because they legitimately didn't need to be\n-                    // calculated)\n-                    //\n-                    // michaelwoerister and vitiral came up with a possible solution,\n-                    // to just do this before every query\n-                    // ```\n-                    // ::rustc_middle::ty::query::plumbing::force_from_dep_node(tcx, dep_node)\n-                    // ```\n-                    //\n-                    // However, this did not seem to work effectively and more bugs were hit.\n-                    // Nebie @vitiral gave up :)\n-                    //\n-                    //HirItem::Trait(..) => (\"ItemTrait\", LABELS_TRAIT),\n+                    HirItem::Trait(..) => (\"ItemTrait\", LABELS_TRAIT),\n \n                     // An implementation, eg `impl<A> Trait for Foo { .. }`\n                     HirItem::Impl { .. } => (\"ItemKind::Impl\", LABELS_IMPL),\n@@ -434,35 +380,23 @@ impl ItemLikeVisitor<'tcx> for DirtyCleanVisitor<'tcx> {\n     }\n }\n \n-/// Given a `#[rustc_dirty]` or `#[rustc_clean]` attribute, scan\n-/// for a `cfg=\"foo\"` attribute and check whether we have a cfg\n-/// flag called `foo`.\n-///\n-/// Also make sure that the `label` and `except` fields do not\n-/// both exist.\n+/// Given a `#[rustc_clean]` attribute, scan for a `cfg=\"foo\"` attribute and check whether we have\n+/// a cfg flag called `foo`.\n fn check_config(tcx: TyCtxt<'_>, attr: &Attribute) -> bool {\n     debug!(\"check_config(attr={:?})\", attr);\n     let config = &tcx.sess.parse_sess.config;\n     debug!(\"check_config: config={:?}\", config);\n-    let (mut cfg, mut except, mut label) = (None, false, false);\n+    let mut cfg = None;\n     for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n         if item.has_name(CFG) {\n             let value = expect_associated_value(tcx, &item);\n             debug!(\"check_config: searching for cfg {:?}\", value);\n             cfg = Some(config.contains(&(value, None)));\n-        }\n-        if item.has_name(LABEL) {\n-            label = true;\n-        }\n-        if item.has_name(EXCEPT) {\n-            except = true;\n+        } else if !item.has_name(EXCEPT) {\n+            tcx.sess.span_err(attr.span, &format!(\"unknown item `{}`\", item.name_or_empty()));\n         }\n     }\n \n-    if label && except {\n-        tcx.sess.span_fatal(attr.span, \"must specify only one of: `label`, `except`\");\n-    }\n-\n     match cfg {\n         None => tcx.sess.span_fatal(attr.span, \"no cfg attribute\"),\n         Some(c) => c,\n@@ -483,21 +417,18 @@ fn expect_associated_value(tcx: TyCtxt<'_>, item: &NestedMetaItem) -> Symbol {\n     }\n }\n \n-// A visitor that collects all #[rustc_dirty]/#[rustc_clean] attributes from\n+// A visitor that collects all #[rustc_clean] attributes from\n // the HIR. It is used to verify that we really ran checks for all annotated\n // nodes.\n-pub struct FindAllAttrs<'a, 'tcx> {\n+pub struct FindAllAttrs<'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    attr_names: &'a [Symbol],\n     found_attrs: Vec<&'tcx Attribute>,\n }\n \n-impl FindAllAttrs<'_, 'tcx> {\n+impl FindAllAttrs<'tcx> {\n     fn is_active_attr(&mut self, attr: &Attribute) -> bool {\n-        for attr_name in self.attr_names {\n-            if self.tcx.sess.check_name(attr, *attr_name) && check_config(self.tcx, attr) {\n-                return true;\n-            }\n+        if self.tcx.sess.check_name(attr, sym::rustc_clean) && check_config(self.tcx, attr) {\n+            return true;\n         }\n \n         false\n@@ -506,17 +437,14 @@ impl FindAllAttrs<'_, 'tcx> {\n     fn report_unchecked_attrs(&self, mut checked_attrs: FxHashSet<ast::AttrId>) {\n         for attr in &self.found_attrs {\n             if !checked_attrs.contains(&attr.id) {\n-                self.tcx.sess.span_err(\n-                    attr.span,\n-                    \"found unchecked `#[rustc_dirty]` / `#[rustc_clean]` attribute\",\n-                );\n+                self.tcx.sess.span_err(attr.span, \"found unchecked `#[rustc_clean]` attribute\");\n                 checked_attrs.insert(attr.id);\n             }\n         }\n     }\n }\n \n-impl intravisit::Visitor<'tcx> for FindAllAttrs<'_, 'tcx> {\n+impl intravisit::Visitor<'tcx> for FindAllAttrs<'tcx> {\n     type Map = Map<'tcx>;\n \n     fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<Self::Map> {"}, {"sha": "8539cc693713952a356be917bf923b6bc909357f", "filename": "compiler/rustc_incremental/src/persist/load.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -1,7 +1,6 @@\n //! Code to save/load the dep-graph from files.\n \n use rustc_data_structures::fx::FxHashMap;\n-use rustc_hir::definitions::DefPathTable;\n use rustc_middle::dep_graph::{SerializedDepGraph, WorkProduct, WorkProductId};\n use rustc_middle::ty::query::OnDiskCache;\n use rustc_serialize::opaque::Decoder;\n@@ -196,10 +195,7 @@ pub fn load_dep_graph(sess: &Session) -> DepGraphFuture {\n /// If we are not in incremental compilation mode, returns `None`.\n /// Otherwise, tries to load the query result cache from disk,\n /// creating an empty cache if it could not be loaded.\n-pub fn load_query_result_cache<'a>(\n-    sess: &'a Session,\n-    def_path_table: &DefPathTable,\n-) -> Option<OnDiskCache<'a>> {\n+pub fn load_query_result_cache<'a>(sess: &'a Session) -> Option<OnDiskCache<'a>> {\n     if sess.opts.incremental.is_none() {\n         return None;\n     }\n@@ -212,7 +208,7 @@ pub fn load_query_result_cache<'a>(\n         sess.is_nightly_build(),\n     ) {\n         LoadResult::Ok { data: (bytes, start_pos) } => {\n-            Some(OnDiskCache::new(sess, bytes, start_pos, def_path_table))\n+            Some(OnDiskCache::new(sess, bytes, start_pos))\n         }\n         _ => Some(OnDiskCache::new_empty(sess.source_map())),\n     }"}, {"sha": "a8455854ebb5fd97809e26f170c29c13beb4cfca", "filename": "compiler/rustc_incremental/src/persist/save.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -229,6 +229,7 @@ pub fn build_dep_graph(\n     }\n \n     Some(DepGraph::new(\n+        &sess.prof,\n         prev_graph,\n         prev_work_products,\n         encoder,"}, {"sha": "0093fa5e562af979a4024fb6cf00c6c17d6800ba", "filename": "compiler/rustc_index/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_index%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_index%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Flib.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -1,12 +1,10 @@\n #![feature(allow_internal_unstable)]\n #![feature(bench_black_box)]\n-#![feature(const_panic)]\n #![feature(extend_one)]\n #![feature(iter_zip)]\n #![feature(unboxed_closures)]\n #![feature(test)]\n #![feature(fn_traits)]\n-#![feature(trusted_step)]\n \n pub mod bit_set;\n pub mod vec;"}, {"sha": "246fa28d986e5b59c52a613a5d1ef14235cfd595", "filename": "compiler/rustc_index/src/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_index%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_index%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fvec.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -65,7 +65,7 @@ impl Idx for u32 {\n /// `u32::MAX`. You can also customize things like the `Debug` impl,\n /// what traits are derived, and so forth via the macro.\n #[macro_export]\n-#[allow_internal_unstable(step_trait, rustc_attrs)]\n+#[allow_internal_unstable(step_trait, rustc_attrs, trusted_step)]\n macro_rules! newtype_index {\n     // ---- public rules ----\n "}, {"sha": "c3c28d70081512550f398aacac7337d78888947d", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -660,7 +660,12 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for QueryTypeRelatingDelegate<'_, 'tcx> {\n         )\n     }\n \n-    fn push_outlives(&mut self, sup: ty::Region<'tcx>, sub: ty::Region<'tcx>) {\n+    fn push_outlives(\n+        &mut self,\n+        sup: ty::Region<'tcx>,\n+        sub: ty::Region<'tcx>,\n+        _info: ty::VarianceDiagInfo<'tcx>,\n+    ) {\n         self.obligations.push(Obligation {\n             cause: self.cause.clone(),\n             param_env: self.param_env,"}, {"sha": "3a11b5a214490088d71ef7f4ff7cb8518b9c4d7b", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -371,9 +371,12 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n         match dir {\n             EqTo => self.equate(a_is_expected).relate(a_ty, b_ty),\n             SubtypeOf => self.sub(a_is_expected).relate(a_ty, b_ty),\n-            SupertypeOf => {\n-                self.sub(a_is_expected).relate_with_variance(ty::Contravariant, a_ty, b_ty)\n-            }\n+            SupertypeOf => self.sub(a_is_expected).relate_with_variance(\n+                ty::Contravariant,\n+                ty::VarianceDiagInfo::default(),\n+                a_ty,\n+                b_ty,\n+            ),\n         }?;\n \n         Ok(())\n@@ -574,6 +577,7 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         variance: ty::Variance,\n+        _info: ty::VarianceDiagInfo<'tcx>,\n         a: T,\n         b: T,\n     ) -> RelateResult<'tcx, T> {\n@@ -737,7 +741,12 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n                 if self.tcx().lazy_normalization() =>\n             {\n                 assert_eq!(promoted, None);\n-                let substs = self.relate_with_variance(ty::Variance::Invariant, substs, substs)?;\n+                let substs = self.relate_with_variance(\n+                    ty::Variance::Invariant,\n+                    ty::VarianceDiagInfo::default(),\n+                    substs,\n+                    substs,\n+                )?;\n                 Ok(self.tcx().mk_const(ty::Const {\n                     ty: c.ty,\n                     val: ty::ConstKind::Unevaluated(ty::Unevaluated { def, substs, promoted }),\n@@ -831,6 +840,7 @@ impl TypeRelation<'tcx> for ConstInferUnifier<'_, 'tcx> {\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         _variance: ty::Variance,\n+        _info: ty::VarianceDiagInfo<'tcx>,\n         a: T,\n         b: T,\n     ) -> RelateResult<'tcx, T> {\n@@ -965,7 +975,12 @@ impl TypeRelation<'tcx> for ConstInferUnifier<'_, 'tcx> {\n                 if self.tcx().lazy_normalization() =>\n             {\n                 assert_eq!(promoted, None);\n-                let substs = self.relate_with_variance(ty::Variance::Invariant, substs, substs)?;\n+                let substs = self.relate_with_variance(\n+                    ty::Variance::Invariant,\n+                    ty::VarianceDiagInfo::default(),\n+                    substs,\n+                    substs,\n+                )?;\n                 Ok(self.tcx().mk_const(ty::Const {\n                     ty: c.ty,\n                     val: ty::ConstKind::Unevaluated(ty::Unevaluated { def, substs, promoted }),"}, {"sha": "0c93271a1aeca716844af99337c8f8e7e9fd8bb7", "filename": "compiler/rustc_infer/src/infer/equate.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -59,6 +59,7 @@ impl TypeRelation<'tcx> for Equate<'combine, 'infcx, 'tcx> {\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         _: ty::Variance,\n+        _info: ty::VarianceDiagInfo<'tcx>,\n         a: T,\n         b: T,\n     ) -> RelateResult<'tcx, T> {"}, {"sha": "e3a79fe2653305da6414187b0301b48d9f660ad0", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -64,6 +64,7 @@ use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{Item, ItemKind, Node};\n+use rustc_middle::dep_graph::DepContext;\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::{\n     self,\n@@ -524,7 +525,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             }\n \n             fn path_crate(self, cnum: CrateNum) -> Result<Self::Path, Self::Error> {\n-                Ok(vec![self.tcx.original_crate_name(cnum).to_string()])\n+                Ok(vec![self.tcx.crate_name(cnum).to_string()])\n             }\n             fn path_qualified(\n                 self,\n@@ -1965,7 +1966,33 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 struct_span_err!(self.tcx.sess, span, E0580, \"{}\", failure_str)\n             }\n             FailureCode::Error0308(failure_str) => {\n-                struct_span_err!(self.tcx.sess, span, E0308, \"{}\", failure_str)\n+                let mut err = struct_span_err!(self.tcx.sess, span, E0308, \"{}\", failure_str);\n+                if let ValuePairs::Types(ty::error::ExpectedFound { expected, found }) =\n+                    trace.values\n+                {\n+                    // If a tuple of length one was expected and the found expression has\n+                    // parentheses around it, perhaps the user meant to write `(expr,)` to\n+                    // build a tuple (issue #86100)\n+                    match (expected.kind(), found.kind()) {\n+                        (ty::Tuple(_), ty::Tuple(_)) => {}\n+                        (ty::Tuple(_), _) if expected.tuple_fields().count() == 1 => {\n+                            if let Ok(code) = self.tcx.sess().source_map().span_to_snippet(span) {\n+                                if let Some(code) =\n+                                    code.strip_prefix('(').and_then(|s| s.strip_suffix(')'))\n+                                {\n+                                    err.span_suggestion(\n+                                        span,\n+                                        \"use a trailing comma to create a tuple with one element\",\n+                                        format!(\"({},)\", code),\n+                                        Applicability::MaybeIncorrect,\n+                                    );\n+                                }\n+                            }\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+                err\n             }\n             FailureCode::Error0644(failure_str) => {\n                 struct_span_err!(self.tcx.sess, span, E0644, \"{}\", failure_str)"}, {"sha": "60f02b84aa344225f73a762884c33e783d628a03", "filename": "compiler/rustc_infer/src/infer/glb.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -43,6 +43,7 @@ impl TypeRelation<'tcx> for Glb<'combine, 'infcx, 'tcx> {\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         variance: ty::Variance,\n+        _info: ty::VarianceDiagInfo<'tcx>,\n         a: T,\n         b: T,\n     ) -> RelateResult<'tcx, T> {\n@@ -96,7 +97,7 @@ impl TypeRelation<'tcx> for Glb<'combine, 'infcx, 'tcx> {\n         // When higher-ranked types are involved, computing the LUB is\n         // very challenging, switch to invariance. This is obviously\n         // overly conservative but works ok in practice.\n-        self.relate_with_variance(ty::Variance::Invariant, a, b)?;\n+        self.relate_with_variance(ty::Variance::Invariant, ty::VarianceDiagInfo::default(), a, b)?;\n         Ok(a)\n     }\n }"}, {"sha": "a08323535c55abd6d926abb15df0246800b8d66a", "filename": "compiler/rustc_infer/src/infer/lub.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -43,6 +43,7 @@ impl TypeRelation<'tcx> for Lub<'combine, 'infcx, 'tcx> {\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         variance: ty::Variance,\n+        _info: ty::VarianceDiagInfo<'tcx>,\n         a: T,\n         b: T,\n     ) -> RelateResult<'tcx, T> {\n@@ -96,7 +97,7 @@ impl TypeRelation<'tcx> for Lub<'combine, 'infcx, 'tcx> {\n         // When higher-ranked types are involved, computing the LUB is\n         // very challenging, switch to invariance. This is obviously\n         // overly conservative but works ok in practice.\n-        self.relate_with_variance(ty::Variance::Invariant, a, b)?;\n+        self.relate_with_variance(ty::Variance::Invariant, ty::VarianceDiagInfo::default(), a, b)?;\n         Ok(a)\n     }\n }"}, {"sha": "20be06adfd09e1a37c64991476ee00f4d85cedca", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 28, "deletions": 6, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -55,6 +55,8 @@ where\n     /// - Bivariant means that it doesn't matter.\n     ambient_variance: ty::Variance,\n \n+    ambient_variance_info: ty::VarianceDiagInfo<'tcx>,\n+\n     /// When we pass through a set of binders (e.g., when looking into\n     /// a `fn` type), we push a new bound region scope onto here. This\n     /// will contain the instantiated region for each region in those\n@@ -78,7 +80,12 @@ pub trait TypeRelatingDelegate<'tcx> {\n     /// satisfied for the two types to be related. `sub` and `sup` may\n     /// be regions from the type or new variables created through the\n     /// delegate.\n-    fn push_outlives(&mut self, sup: ty::Region<'tcx>, sub: ty::Region<'tcx>);\n+    fn push_outlives(\n+        &mut self,\n+        sup: ty::Region<'tcx>,\n+        sub: ty::Region<'tcx>,\n+        info: ty::VarianceDiagInfo<'tcx>,\n+    );\n \n     fn const_equate(&mut self, a: &'tcx ty::Const<'tcx>, b: &'tcx ty::Const<'tcx>);\n \n@@ -138,7 +145,14 @@ where\n         delegate: D,\n         ambient_variance: ty::Variance,\n     ) -> Self {\n-        Self { infcx, delegate, ambient_variance, a_scopes: vec![], b_scopes: vec![] }\n+        Self {\n+            infcx,\n+            delegate,\n+            ambient_variance,\n+            ambient_variance_info: ty::VarianceDiagInfo::default(),\n+            a_scopes: vec![],\n+            b_scopes: vec![],\n+        }\n     }\n \n     fn ambient_covariance(&self) -> bool {\n@@ -239,10 +253,15 @@ where\n \n     /// Push a new outlives requirement into our output set of\n     /// constraints.\n-    fn push_outlives(&mut self, sup: ty::Region<'tcx>, sub: ty::Region<'tcx>) {\n+    fn push_outlives(\n+        &mut self,\n+        sup: ty::Region<'tcx>,\n+        sub: ty::Region<'tcx>,\n+        info: ty::VarianceDiagInfo<'tcx>,\n+    ) {\n         debug!(\"push_outlives({:?}: {:?})\", sup, sub);\n \n-        self.delegate.push_outlives(sup, sub);\n+        self.delegate.push_outlives(sup, sub, info);\n     }\n \n     /// Relate a projection type and some value type lazily. This will always\n@@ -490,13 +509,15 @@ where\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         variance: ty::Variance,\n+        info: ty::VarianceDiagInfo<'tcx>,\n         a: T,\n         b: T,\n     ) -> RelateResult<'tcx, T> {\n         debug!(\"relate_with_variance(variance={:?}, a={:?}, b={:?})\", variance, a, b);\n \n         let old_ambient_variance = self.ambient_variance;\n         self.ambient_variance = self.ambient_variance.xform(variance);\n+        self.ambient_variance_info = self.ambient_variance_info.clone().xform(info);\n \n         debug!(\"relate_with_variance: ambient_variance = {:?}\", self.ambient_variance);\n \n@@ -574,12 +595,12 @@ where\n \n         if self.ambient_covariance() {\n             // Covariance: a <= b. Hence, `b: a`.\n-            self.push_outlives(v_b, v_a);\n+            self.push_outlives(v_b, v_a, self.ambient_variance_info.clone());\n         }\n \n         if self.ambient_contravariance() {\n             // Contravariant: b <= a. Hence, `a: b`.\n-            self.push_outlives(v_a, v_b);\n+            self.push_outlives(v_a, v_b, self.ambient_variance_info.clone());\n         }\n \n         Ok(a)\n@@ -835,6 +856,7 @@ where\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         variance: ty::Variance,\n+        _info: ty::VarianceDiagInfo<'tcx>,\n         a: T,\n         b: T,\n     ) -> RelateResult<'tcx, T> {"}, {"sha": "b3131936ae06608210a7bedab490e1bf38859c58", "filename": "compiler/rustc_infer/src/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -62,6 +62,7 @@ impl TypeRelation<'tcx> for Sub<'combine, 'infcx, 'tcx> {\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         variance: ty::Variance,\n+        _info: ty::VarianceDiagInfo<'tcx>,\n         a: T,\n         b: T,\n     ) -> RelateResult<'tcx, T> {"}, {"sha": "ee358c52c2f57f129dac51da0dd3de69c957699c", "filename": "compiler/rustc_infer/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_infer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_infer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Flib.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -16,14 +16,12 @@\n #![feature(bool_to_option)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n-#![feature(const_panic)]\n #![feature(extend_one)]\n #![feature(iter_zip)]\n #![feature(never_type)]\n #![feature(in_band_lifetimes)]\n #![feature(control_flow_enum)]\n #![feature(min_specialization)]\n-#![feature(trusted_step)]\n #![recursion_limit = \"512\"] // For rustdoc\n \n #[macro_use]"}, {"sha": "c7424b9e2a120560a39c506abd23157056f73470", "filename": "compiler/rustc_interface/src/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_interface%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_interface%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Flib.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -1,10 +1,7 @@\n #![feature(bool_to_option)]\n #![feature(box_patterns)]\n-#![feature(box_syntax)]\n #![feature(internal_output_capture)]\n #![feature(nll)]\n-#![feature(generator_trait)]\n-#![feature(generators)]\n #![feature(once_cell)]\n #![recursion_limit = \"256\"]\n "}, {"sha": "9e3e96df3a7f2effe50a5f0787c95d8f5eb8e8f8", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 90, "deletions": 43, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -6,10 +6,10 @@ use rustc_ast::mut_visit::MutVisitor;\n use rustc_ast::{self as ast, visit};\n use rustc_codegen_ssa::back::link::emit_metadata;\n use rustc_codegen_ssa::traits::CodegenBackend;\n+use rustc_data_structures::parallel;\n use rustc_data_structures::steal::Steal;\n use rustc_data_structures::sync::{par_iter, Lrc, OnceCell, ParallelIterator, WorkerLocal};\n use rustc_data_structures::temp_dir::MaybeTempDir;\n-use rustc_data_structures::{box_region_allow_access, declare_box_region_type, parallel};\n use rustc_errors::{ErrorReported, PResult};\n use rustc_expand::base::ExtCtxt;\n use rustc_hir::def_id::LOCAL_CRATE;\n@@ -47,7 +47,9 @@ use std::cell::RefCell;\n use std::ffi::OsString;\n use std::io::{self, BufWriter, Write};\n use std::lazy::SyncLazy;\n+use std::marker::PhantomPinned;\n use std::path::PathBuf;\n+use std::pin::Pin;\n use std::rc::Rc;\n use std::{env, fs, iter};\n \n@@ -85,11 +87,83 @@ fn count_nodes(krate: &ast::Crate) -> usize {\n     counter.count\n }\n \n-declare_box_region_type!(\n-    pub BoxedResolver,\n-    for(),\n-    (&mut Resolver<'_>) -> (Result<ast::Crate>, ResolverOutputs)\n-);\n+pub use boxed_resolver::BoxedResolver;\n+mod boxed_resolver {\n+    use super::*;\n+\n+    pub struct BoxedResolver(Pin<Box<BoxedResolverInner>>);\n+\n+    struct BoxedResolverInner {\n+        session: Lrc<Session>,\n+        resolver_arenas: Option<ResolverArenas<'static>>,\n+        resolver: Option<Resolver<'static>>,\n+        _pin: PhantomPinned,\n+    }\n+\n+    // Note: Drop order is important to prevent dangling references. Resolver must be dropped first,\n+    // then resolver_arenas and finally session.\n+    impl Drop for BoxedResolverInner {\n+        fn drop(&mut self) {\n+            self.resolver.take();\n+            self.resolver_arenas.take();\n+        }\n+    }\n+\n+    impl BoxedResolver {\n+        pub(super) fn new<F>(session: Lrc<Session>, make_resolver: F) -> Result<(ast::Crate, Self)>\n+        where\n+            F: for<'a> FnOnce(\n+                &'a Session,\n+                &'a ResolverArenas<'a>,\n+            ) -> Result<(ast::Crate, Resolver<'a>)>,\n+        {\n+            let mut boxed_resolver = Box::new(BoxedResolverInner {\n+                session,\n+                resolver_arenas: Some(Resolver::arenas()),\n+                resolver: None,\n+                _pin: PhantomPinned,\n+            });\n+            // SAFETY: `make_resolver` takes a resolver arena with an arbitrary lifetime and\n+            // returns a resolver with the same lifetime as the arena. We ensure that the arena\n+            // outlives the resolver in the drop impl and elsewhere so these transmutes are sound.\n+            unsafe {\n+                let (crate_, resolver) = make_resolver(\n+                    std::mem::transmute::<&Session, &Session>(&boxed_resolver.session),\n+                    std::mem::transmute::<&ResolverArenas<'_>, &ResolverArenas<'_>>(\n+                        boxed_resolver.resolver_arenas.as_ref().unwrap(),\n+                    ),\n+                )?;\n+                boxed_resolver.resolver = Some(resolver);\n+                Ok((crate_, BoxedResolver(Pin::new_unchecked(boxed_resolver))))\n+            }\n+        }\n+\n+        pub fn access<F: for<'a> FnOnce(&mut Resolver<'a>) -> R, R>(&mut self, f: F) -> R {\n+            // SAFETY: The resolver doesn't need to be pinned.\n+            let mut resolver = unsafe {\n+                self.0.as_mut().map_unchecked_mut(|boxed_resolver| &mut boxed_resolver.resolver)\n+            };\n+            f((&mut *resolver).as_mut().unwrap())\n+        }\n+\n+        pub fn to_resolver_outputs(resolver: Rc<RefCell<BoxedResolver>>) -> ResolverOutputs {\n+            match Rc::try_unwrap(resolver) {\n+                Ok(resolver) => {\n+                    let mut resolver = resolver.into_inner();\n+                    // SAFETY: The resolver doesn't need to be pinned.\n+                    let mut resolver = unsafe {\n+                        resolver\n+                            .0\n+                            .as_mut()\n+                            .map_unchecked_mut(|boxed_resolver| &mut boxed_resolver.resolver)\n+                    };\n+                    resolver.take().unwrap().into_outputs()\n+                }\n+                Err(resolver) => resolver.borrow_mut().access(|resolver| resolver.clone_outputs()),\n+            }\n+        }\n+    }\n+}\n \n /// Runs the \"early phases\" of the compiler: initial `cfg` processing, loading compiler plugins,\n /// syntax expansion, secondary `cfg` expansion, synthesis of a test\n@@ -111,41 +185,16 @@ pub fn configure_and_expand(\n     // its contents but the results of name resolution on those contents. Hopefully we'll push\n     // this back at some point.\n     let crate_name = crate_name.to_string();\n-    let (result, resolver) = BoxedResolver::new(static move |mut action| {\n-        let _ = action;\n-        let sess = &*sess;\n-        let resolver_arenas = Resolver::arenas();\n-        let res = configure_and_expand_inner(\n+    BoxedResolver::new(sess, move |sess, resolver_arenas| {\n+        configure_and_expand_inner(\n             sess,\n             &lint_store,\n             krate,\n             &crate_name,\n             &resolver_arenas,\n-            &*metadata_loader,\n-        );\n-        let mut resolver = match res {\n-            Err(v) => {\n-                yield BoxedResolver::initial_yield(Err(v));\n-                panic!()\n-            }\n-            Ok((krate, resolver)) => {\n-                action = yield BoxedResolver::initial_yield(Ok(krate));\n-                resolver\n-            }\n-        };\n-        box_region_allow_access!(for(), (&mut Resolver<'_>), (&mut resolver), action);\n-        resolver.into_outputs()\n-    });\n-    result.map(|k| (k, resolver))\n-}\n-\n-impl BoxedResolver {\n-    pub fn to_resolver_outputs(resolver: Rc<RefCell<BoxedResolver>>) -> ResolverOutputs {\n-        match Rc::try_unwrap(resolver) {\n-            Ok(resolver) => resolver.into_inner().complete(),\n-            Err(resolver) => resolver.borrow_mut().access(|resolver| resolver.clone_outputs()),\n-        }\n-    }\n+            metadata_loader,\n+        )\n+    })\n }\n \n pub fn register_plugins<'a>(\n@@ -231,11 +280,11 @@ fn pre_expansion_lint(\n \n fn configure_and_expand_inner<'a>(\n     sess: &'a Session,\n-    lint_store: &'a LintStore,\n+    lint_store: &LintStore,\n     mut krate: ast::Crate,\n     crate_name: &str,\n     resolver_arenas: &'a ResolverArenas<'a>,\n-    metadata_loader: &'a MetadataLoaderDyn,\n+    metadata_loader: Box<MetadataLoaderDyn>,\n ) -> Result<(ast::Crate, Resolver<'a>)> {\n     tracing::trace!(\"configure_and_expand_inner\");\n     pre_expansion_lint(sess, lint_store, &krate, crate_name);\n@@ -765,9 +814,7 @@ pub fn create_global_ctxt<'tcx>(\n ) -> QueryContext<'tcx> {\n     let sess = &compiler.session();\n \n-    let def_path_table = resolver_outputs.definitions.def_path_table();\n-    let query_result_on_disk_cache =\n-        rustc_incremental::load_query_result_cache(sess, def_path_table);\n+    let query_result_on_disk_cache = rustc_incremental::load_query_result_cache(sess);\n \n     let codegen_backend = compiler.codegen_backend();\n     let mut local_providers = *DEFAULT_QUERY_PROVIDERS;\n@@ -795,7 +842,7 @@ pub fn create_global_ctxt<'tcx>(\n                 query_result_on_disk_cache,\n                 queries.as_dyn(),\n                 &crate_name,\n-                &outputs,\n+                outputs,\n             )\n         })\n     });\n@@ -981,7 +1028,7 @@ fn encode_and_write_metadata(\n             .tempdir_in(out_filename.parent().unwrap())\n             .unwrap_or_else(|err| tcx.sess.fatal(&format!(\"couldn't create a temp dir: {}\", err)));\n         let metadata_tmpdir = MaybeTempDir::new(metadata_tmpdir, tcx.sess.opts.cg.save_temps);\n-        let metadata_filename = emit_metadata(tcx.sess, &metadata, &metadata_tmpdir);\n+        let metadata_filename = emit_metadata(tcx.sess, &metadata.raw_data, &metadata_tmpdir);\n         if let Err(e) = util::non_durable_rename(&metadata_filename, &out_filename) {\n             tcx.sess.fatal(&format!(\"failed to write {}: {}\", out_filename.display(), e));\n         }"}, {"sha": "2320f0b47d27df0bb04b9a8c530ebc0d6bbfc72f", "filename": "compiler/rustc_interface/src/queries.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -245,8 +245,7 @@ impl<'tcx> Queries<'tcx> {\n         self.prepare_outputs.compute(|| {\n             let expansion_result = self.expansion()?;\n             let (krate, boxed_resolver, _) = &*expansion_result.peek();\n-            let crate_name = self.crate_name()?;\n-            let crate_name = crate_name.peek();\n+            let crate_name = self.crate_name()?.peek();\n             passes::prepare_outputs(\n                 self.session(),\n                 self.compiler,\n@@ -343,32 +342,36 @@ impl<'tcx> Queries<'tcx> {\n     }\n \n     pub fn linker(&'tcx self) -> Result<Linker> {\n-        let dep_graph = self.dep_graph()?;\n-        let prepare_outputs = self.prepare_outputs()?;\n-        let crate_hash = self.global_ctxt()?.peek_mut().enter(|tcx| tcx.crate_hash(LOCAL_CRATE));\n-        let ongoing_codegen = self.ongoing_codegen()?;\n-\n         let sess = self.session().clone();\n         let codegen_backend = self.codegen_backend().clone();\n \n+        let dep_graph = self.dep_graph()?.peek().clone();\n+        let prepare_outputs = self.prepare_outputs()?.take();\n+        let crate_hash = self.global_ctxt()?.peek_mut().enter(|tcx| tcx.crate_hash(LOCAL_CRATE));\n+        let ongoing_codegen = self.ongoing_codegen()?.take();\n+\n         Ok(Linker {\n             sess,\n-            dep_graph: dep_graph.peek().clone(),\n-            prepare_outputs: prepare_outputs.take(),\n-            crate_hash,\n-            ongoing_codegen: ongoing_codegen.take(),\n             codegen_backend,\n+\n+            dep_graph,\n+            prepare_outputs,\n+            crate_hash,\n+            ongoing_codegen,\n         })\n     }\n }\n \n pub struct Linker {\n+    // compilation inputs\n     sess: Lrc<Session>,\n+    codegen_backend: Lrc<Box<dyn CodegenBackend>>,\n+\n+    // compilation outputs\n     dep_graph: DepGraph,\n     prepare_outputs: OutputFilenames,\n     crate_hash: Svh,\n     ongoing_codegen: Box<dyn Any>,\n-    codegen_backend: Lrc<Box<dyn CodegenBackend>>,\n }\n \n impl Linker {"}, {"sha": "5d8a6084f2e0b486809c8705314e423618cbeab3", "filename": "compiler/rustc_interface/src/tests.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ftests.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -252,7 +252,8 @@ fn test_lints_tracking_hash_different_construction_order() {\n         (String::from(\"d\"), Level::Forbid),\n     ];\n \n-    assert_same_hash(&v1, &v2);\n+    // The hash should be order-dependent\n+    assert_different_hash(&v1, &v2);\n }\n \n #[test]\n@@ -491,9 +492,10 @@ fn test_native_libs_tracking_hash_different_order() {\n         },\n     ];\n \n-    assert_same_hash(&v1, &v2);\n-    assert_same_hash(&v1, &v3);\n-    assert_same_hash(&v2, &v3);\n+    // The hash should be order-dependent\n+    assert_different_hash(&v1, &v2);\n+    assert_different_hash(&v1, &v3);\n+    assert_different_hash(&v2, &v3);\n }\n \n #[test]"}, {"sha": "6485fbebd665fd028ccc35274b6fd65ef89d9648", "filename": "compiler/rustc_interface/src/util.rs", "status": "modified", "additions": 23, "deletions": 32, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Futil.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -35,7 +35,7 @@ use std::ops::DerefMut;\n use std::panic;\n use std::path::{Path, PathBuf};\n use std::sync::atomic::{AtomicBool, Ordering};\n-use std::sync::{Arc, Mutex, Once};\n+use std::sync::{Arc, Mutex};\n use std::thread;\n use tracing::info;\n \n@@ -76,7 +76,10 @@ pub fn create_session(\n     let codegen_backend = if let Some(make_codegen_backend) = make_codegen_backend {\n         make_codegen_backend(&sopts)\n     } else {\n-        get_codegen_backend(&sopts)\n+        get_codegen_backend(\n+            &sopts.maybe_sysroot,\n+            sopts.debugging_opts.codegen_backend.as_ref().map(|name| &name[..]),\n+        )\n     };\n \n     // target_override is documented to be called before init(), so this is okay\n@@ -244,35 +247,34 @@ fn load_backend_from_dylib(path: &Path) -> fn() -> Box<dyn CodegenBackend> {\n     }\n }\n \n-pub fn get_codegen_backend(sopts: &config::Options) -> Box<dyn CodegenBackend> {\n-    static INIT: Once = Once::new();\n-\n-    static mut LOAD: fn() -> Box<dyn CodegenBackend> = || unreachable!();\n+/// Get the codegen backend based on the name and specified sysroot.\n+///\n+/// A name of `None` indicates that the default backend should be used.\n+pub fn get_codegen_backend(\n+    maybe_sysroot: &Option<PathBuf>,\n+    backend_name: Option<&str>,\n+) -> Box<dyn CodegenBackend> {\n+    static LOAD: SyncOnceCell<unsafe fn() -> Box<dyn CodegenBackend>> = SyncOnceCell::new();\n \n-    INIT.call_once(|| {\n+    let load = LOAD.get_or_init(|| {\n         #[cfg(feature = \"llvm\")]\n         const DEFAULT_CODEGEN_BACKEND: &str = \"llvm\";\n \n         #[cfg(not(feature = \"llvm\"))]\n         const DEFAULT_CODEGEN_BACKEND: &str = \"cranelift\";\n \n-        let codegen_name = sopts\n-            .debugging_opts\n-            .codegen_backend\n-            .as_ref()\n-            .map(|name| &name[..])\n-            .unwrap_or(DEFAULT_CODEGEN_BACKEND);\n-\n-        let backend = match codegen_name {\n+        match backend_name.unwrap_or(DEFAULT_CODEGEN_BACKEND) {\n             filename if filename.contains('.') => load_backend_from_dylib(filename.as_ref()),\n-            codegen_name => get_builtin_codegen_backend(&sopts.maybe_sysroot, codegen_name),\n-        };\n-\n-        unsafe {\n-            LOAD = backend;\n+            #[cfg(feature = \"llvm\")]\n+            \"llvm\" => rustc_codegen_llvm::LlvmCodegenBackend::new,\n+            backend_name => get_codegen_sysroot(maybe_sysroot, backend_name),\n         }\n     });\n-    unsafe { LOAD() }\n+\n+    // SAFETY: In case of a builtin codegen backend this is safe. In case of an external codegen\n+    // backend we hope that the backend links against the same rustc_driver version. If this is not\n+    // the case, we get UB.\n+    unsafe { load() }\n }\n \n // This is used for rustdoc, but it uses similar machinery to codegen backend\n@@ -390,17 +392,6 @@ fn sysroot_candidates() -> Vec<PathBuf> {\n     }\n }\n \n-pub fn get_builtin_codegen_backend(\n-    maybe_sysroot: &Option<PathBuf>,\n-    backend_name: &str,\n-) -> fn() -> Box<dyn CodegenBackend> {\n-    match backend_name {\n-        #[cfg(feature = \"llvm\")]\n-        \"llvm\" => rustc_codegen_llvm::LlvmCodegenBackend::new,\n-        _ => get_codegen_sysroot(maybe_sysroot, backend_name),\n-    }\n-}\n-\n pub fn get_codegen_sysroot(\n     maybe_sysroot: &Option<PathBuf>,\n     backend_name: &str,"}, {"sha": "f6a84966f7a91b9a4b5ab92d2cbf026e16101467", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -489,7 +489,7 @@ fn has_doc(sess: &Session, attr: &ast::Attribute) -> bool {\n \n     if let Some(list) = attr.meta_item_list() {\n         for meta in list {\n-            if meta.has_name(sym::include) || meta.has_name(sym::hidden) {\n+            if meta.has_name(sym::hidden) {\n                 return true;\n             }\n         }"}, {"sha": "a8df1b0952c18297e38febb48793c5ab995947ee", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 25, "deletions": 14, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -334,8 +334,14 @@ impl LintStore {\n         }\n     }\n \n-    /// Checks the validity of lint names derived from the command line\n-    pub fn check_lint_name_cmdline(&self, sess: &Session, lint_name: &str, level: Level) {\n+    /// Checks the validity of lint names derived from the command line. Returns\n+    /// true if the lint is valid, false otherwise.\n+    pub fn check_lint_name_cmdline(\n+        &self,\n+        sess: &Session,\n+        lint_name: &str,\n+        level: Option<Level>,\n+    ) -> bool {\n         let db = match self.check_lint_name(lint_name, None) {\n             CheckLintNameResult::Ok(_) => None,\n             CheckLintNameResult::Warning(ref msg, _) => Some(sess.struct_warn(msg)),\n@@ -361,18 +367,23 @@ impl LintStore {\n         };\n \n         if let Some(mut db) = db {\n-            let msg = format!(\n-                \"requested on the command line with `{} {}`\",\n-                match level {\n-                    Level::Allow => \"-A\",\n-                    Level::Warn => \"-W\",\n-                    Level::Deny => \"-D\",\n-                    Level::Forbid => \"-F\",\n-                },\n-                lint_name\n-            );\n-            db.note(&msg);\n+            if let Some(level) = level {\n+                let msg = format!(\n+                    \"requested on the command line with `{} {}`\",\n+                    match level {\n+                        Level::Allow => \"-A\",\n+                        Level::Warn => \"-W\",\n+                        Level::Deny => \"-D\",\n+                        Level::Forbid => \"-F\",\n+                    },\n+                    lint_name\n+                );\n+                db.note(&msg);\n+            }\n             db.emit();\n+            false\n+        } else {\n+            true\n         }\n     }\n \n@@ -922,7 +933,7 @@ impl<'tcx> LateContext<'tcx> {\n             }\n \n             fn path_crate(self, cnum: CrateNum) -> Result<Self::Path, Self::Error> {\n-                Ok(vec![self.tcx.original_crate_name(cnum)])\n+                Ok(vec![self.tcx.crate_name(cnum)])\n             }\n \n             fn path_qualified("}, {"sha": "0ee434f5fb50bae3e359d986b90936c9027c1470", "filename": "compiler/rustc_lint/src/levels.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flevels.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -88,7 +88,7 @@ impl<'s> LintLevelsBuilder<'s> {\n         self.sets.lint_cap = sess.opts.lint_cap.unwrap_or(Level::Forbid);\n \n         for &(ref lint_name, level) in &sess.opts.lint_opts {\n-            store.check_lint_name_cmdline(sess, &lint_name, level);\n+            store.check_lint_name_cmdline(sess, &lint_name, Some(level));\n             let orig_level = level;\n \n             // If the cap is less than this specified level, e.g., if we've got\n@@ -109,6 +109,16 @@ impl<'s> LintLevelsBuilder<'s> {\n             }\n         }\n \n+        for lint_name in &sess.opts.force_warns {\n+            let valid = store.check_lint_name_cmdline(sess, lint_name, None);\n+            if valid {\n+                let lints = store\n+                    .find_lints(lint_name)\n+                    .unwrap_or_else(|_| bug!(\"A valid lint failed to produce a lint ids\"));\n+                self.sets.force_warns.extend(&lints);\n+            }\n+        }\n+\n         self.sets.list.push(LintSet::CommandLine { specs });\n     }\n \n@@ -142,6 +152,9 @@ impl<'s> LintLevelsBuilder<'s> {\n                     LintLevelSource::Default => false,\n                     LintLevelSource::Node(symbol, _, _) => self.store.is_lint_group(symbol),\n                     LintLevelSource::CommandLine(symbol, _) => self.store.is_lint_group(symbol),\n+                    LintLevelSource::ForceWarn(_symbol) => {\n+                        bug!(\"forced warn lint returned a forbid lint level\")\n+                    }\n                 };\n                 debug!(\n                     \"fcw_warning={:?}, specs.get(&id) = {:?}, old_src={:?}, id_name={:?}\",\n@@ -166,6 +179,7 @@ impl<'s> LintLevelsBuilder<'s> {\n                         LintLevelSource::CommandLine(_, _) => {\n                             diag_builder.note(\"`forbid` lint level was set on command line\");\n                         }\n+                        _ => bug!(\"forced warn lint returned a forbid lint level\"),\n                     }\n                     diag_builder.emit();\n                 };"}, {"sha": "4f59460aa82a4e89f0aec06da78738716715c753", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -36,8 +36,6 @@\n #![feature(iter_zip)]\n #![feature(never_type)]\n #![feature(nll)]\n-#![feature(half_open_range_patterns)]\n-#![feature(exclusive_range_pattern)]\n #![feature(control_flow_enum)]\n #![recursion_limit = \"256\"]\n "}, {"sha": "a3a87a48768dcde44bfa80ff9e1dc482229a38bb", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 25, "deletions": 40, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -5,15 +5,14 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::{is_range_literal, ExprKind, Node};\n-use rustc_index::vec::Idx;\n use rustc_middle::ty::layout::{IntegerExt, SizeSkeleton};\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{self, AdtKind, Ty, TyCtxt, TypeFoldable};\n use rustc_span::source_map;\n use rustc_span::symbol::sym;\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi::Abi;\n-use rustc_target::abi::{Integer, LayoutOf, TagEncoding, VariantIdx, Variants};\n+use rustc_target::abi::{Integer, LayoutOf, TagEncoding, Variants};\n use rustc_target::spec::abi::Abi as SpecAbi;\n \n use std::cmp;\n@@ -680,16 +679,11 @@ pub fn transparent_newtype_field<'a, 'tcx>(\n     variant: &'a ty::VariantDef,\n ) -> Option<&'a ty::FieldDef> {\n     let param_env = tcx.param_env(variant.def_id);\n-    for field in &variant.fields {\n+    variant.fields.iter().find(|field| {\n         let field_ty = tcx.type_of(field.did);\n         let is_zst = tcx.layout_of(param_env.and(field_ty)).map_or(false, |layout| layout.is_zst());\n-\n-        if !is_zst {\n-            return Some(field);\n-        }\n-    }\n-\n-    None\n+        !is_zst\n+    })\n }\n \n /// Is type known to be non-null?\n@@ -712,15 +706,10 @@ fn ty_is_known_nonnull<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, mode: CItemKi\n                 return false;\n             }\n \n-            for variant in &def.variants {\n-                if let Some(field) = transparent_newtype_field(cx.tcx, variant) {\n-                    if ty_is_known_nonnull(cx, field.ty(tcx, substs), mode) {\n-                        return true;\n-                    }\n-                }\n-            }\n-\n-            false\n+            def.variants\n+                .iter()\n+                .filter_map(|variant| transparent_newtype_field(cx.tcx, variant))\n+                .any(|field| ty_is_known_nonnull(cx, field.ty(tcx, substs), mode))\n         }\n         _ => false,\n     }\n@@ -783,25 +772,14 @@ crate fn repr_nullable_ptr<'tcx>(\n ) -> Option<Ty<'tcx>> {\n     debug!(\"is_repr_nullable_ptr(cx, ty = {:?})\", ty);\n     if let ty::Adt(ty_def, substs) = ty.kind() {\n-        if ty_def.variants.len() != 2 {\n-            return None;\n-        }\n-\n-        let get_variant_fields = |index| &ty_def.variants[VariantIdx::new(index)].fields;\n-        let variant_fields = [get_variant_fields(0), get_variant_fields(1)];\n-        let fields = if variant_fields[0].is_empty() {\n-            &variant_fields[1]\n-        } else if variant_fields[1].is_empty() {\n-            &variant_fields[0]\n-        } else {\n-            return None;\n+        let field_ty = match &ty_def.variants.raw[..] {\n+            [var_one, var_two] => match (&var_one.fields[..], &var_two.fields[..]) {\n+                ([], [field]) | ([field], []) => field.ty(cx.tcx, substs),\n+                _ => return None,\n+            },\n+            _ => return None,\n         };\n \n-        if fields.len() != 1 {\n-            return None;\n-        }\n-\n-        let field_ty = fields[0].ty(cx.tcx, substs);\n         if !ty_is_known_nonnull(cx, field_ty, ckind) {\n             return None;\n         }\n@@ -921,11 +899,18 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         }\n \n         match *ty.kind() {\n-            ty::Adt(def, _) if def.is_box() && matches!(self.mode, CItemKind::Definition) => {\n-                FfiSafe\n-            }\n-\n             ty::Adt(def, substs) => {\n+                if def.is_box() && matches!(self.mode, CItemKind::Definition) {\n+                    if ty.boxed_ty().is_sized(tcx.at(DUMMY_SP), self.cx.param_env) {\n+                        return FfiSafe;\n+                    } else {\n+                        return FfiUnsafe {\n+                            ty,\n+                            reason: format!(\"box cannot be represented as a single pointer\"),\n+                            help: None,\n+                        };\n+                    }\n+                }\n                 if def.is_phantom_data() {\n                     return FfiPhantom(ty);\n                 }"}, {"sha": "44c2a550c30e2d40af462a89bd4afda3f30c49d2", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -858,10 +858,10 @@ impl EarlyLintPass for UnusedParens {\n             // The other cases do not contain sub-patterns.\n             | Wild | Rest | Lit(..) | MacCall(..) | Range(..) | Ident(.., None) | Path(..) => {},\n             // These are list-like patterns; parens can always be removed.\n-            TupleStruct(_, ps) | Tuple(ps) | Slice(ps) | Or(ps) => for p in ps {\n+            TupleStruct(_, _, ps) | Tuple(ps) | Slice(ps) | Or(ps) => for p in ps {\n                 self.check_unused_parens_pat(cx, p, false, false);\n             },\n-            Struct(_, fps, _) => for f in fps {\n+            Struct(_, _, fps, _) => for f in fps {\n                 self.check_unused_parens_pat(cx, &f.pat, false, false);\n             },\n             // Avoid linting on `i @ (p0 | .. | pn)` and `box (p0 | .. | pn)`, #64106."}, {"sha": "352146d64635ad69f72e56cac4c6ac926174426a", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -2994,6 +2994,7 @@ declare_lint_pass! {\n         USELESS_DEPRECATED,\n         UNSUPPORTED_NAKED_FUNCTIONS,\n         MISSING_ABI,\n+        INVALID_DOC_ATTRIBUTES,\n         SEMICOLON_IN_EXPRESSIONS_FROM_MACROS,\n         DISJOINT_CAPTURE_MIGRATION,\n         LEGACY_DERIVE_HELPERS,"}, {"sha": "f1c4e5fb4a368ba1e5a7cdd596155d21157895aa", "filename": "compiler/rustc_lint_defs/src/lib.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -25,7 +25,11 @@ macro_rules! pluralize {\n /// before applying the suggestion.\n #[derive(Copy, Clone, Debug, PartialEq, Hash, Encodable, Decodable)]\n pub enum Applicability {\n-    /// The suggestion is definitely what the user intended. This suggestion should be\n+    /// The suggestion is definitely what the user intended, or maintains the exact meaning of the code.\n+    /// This suggestion should be automatically applied.\n+    ///\n+    /// In case of multiple `MachineApplicable` suggestions (whether as part of\n+    /// the same `multipart_suggestion` or not), all of them should be\n     /// automatically applied.\n     MachineApplicable,\n "}, {"sha": "452d1b19a18a84b18e861736f51505a437a0170a", "filename": "compiler/rustc_llvm/build.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_llvm%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_llvm%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fbuild.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -86,6 +86,7 @@ fn main() {\n         \"nvptx\",\n         \"hexagon\",\n         \"riscv\",\n+        \"bpf\",\n     ];\n \n     let required_components = &["}, {"sha": "9b757eb40c1840b64834fac51a76a36f58f1ed4e", "filename": "compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp", "status": "modified", "additions": 52, "deletions": 35, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -6,6 +6,7 @@\n #include \"llvm/IR/Instructions.h\"\n #include \"llvm/IR/Intrinsics.h\"\n #include \"llvm/Object/Archive.h\"\n+#include \"llvm/Object/COFFImportFile.h\"\n #include \"llvm/Object/ObjectFile.h\"\n #include \"llvm/Bitcode/BitcodeWriterPass.h\"\n #include \"llvm/Support/Signals.h\"\n@@ -70,17 +71,6 @@ extern \"C\" void LLVMRustInstallFatalErrorHandler() {\n   install_fatal_error_handler(FatalErrorHandler);\n }\n \n-extern \"C\" LLVMMemoryBufferRef\n-LLVMRustCreateMemoryBufferWithContentsOfFile(const char *Path) {\n-  ErrorOr<std::unique_ptr<MemoryBuffer>> BufOr =\n-      MemoryBuffer::getFile(Path, -1, false);\n-  if (!BufOr) {\n-    LLVMRustSetLastError(BufOr.getError().message().c_str());\n-    return nullptr;\n-  }\n-  return wrap(BufOr.get().release());\n-}\n-\n extern \"C\" char *LLVMRustGetLastError(void) {\n   char *Ret = LastError;\n   LastError = nullptr;\n@@ -1077,30 +1067,6 @@ extern \"C\" void LLVMRustWriteValueToString(LLVMValueRef V,\n   }\n }\n \n-// Note that the two following functions look quite similar to the\n-// LLVMGetSectionName function. Sadly, it appears that this function only\n-// returns a char* pointer, which isn't guaranteed to be null-terminated. The\n-// function provided by LLVM doesn't return the length, so we've created our own\n-// function which returns the length as well as the data pointer.\n-//\n-// For an example of this not returning a null terminated string, see\n-// lib/Object/COFFObjectFile.cpp in the getSectionName function. One of the\n-// branches explicitly creates a StringRef without a null terminator, and then\n-// that's returned.\n-\n-inline section_iterator *unwrap(LLVMSectionIteratorRef SI) {\n-  return reinterpret_cast<section_iterator *>(SI);\n-}\n-\n-extern \"C\" size_t LLVMRustGetSectionName(LLVMSectionIteratorRef SI,\n-                                         const char **Ptr) {\n-  auto NameOrErr = (*unwrap(SI))->getName();\n-  if (!NameOrErr)\n-    report_fatal_error(NameOrErr.takeError());\n-  *Ptr = NameOrErr->data();\n-  return NameOrErr->size();\n-}\n-\n // LLVMArrayType function does not support 64-bit ElementCount\n extern \"C\" LLVMTypeRef LLVMRustArrayType(LLVMTypeRef ElementTy,\n                                          uint64_t ElementCount) {\n@@ -1757,3 +1723,54 @@ extern \"C\" LLVMValueRef\n LLVMRustBuildMaxNum(LLVMBuilderRef B, LLVMValueRef LHS, LLVMValueRef RHS) {\n     return wrap(unwrap(B)->CreateMaxNum(unwrap(LHS),unwrap(RHS)));\n }\n+\n+// This struct contains all necessary info about a symbol exported from a DLL.\n+// At the moment, it's just the symbol's name, but we use a separate struct to\n+// make it easier to add other information like ordinal later.\n+struct LLVMRustCOFFShortExport {\n+  const char* name;\n+};\n+\n+// Machine must be a COFF machine type, as defined in PE specs.\n+extern \"C\" LLVMRustResult LLVMRustWriteImportLibrary(\n+  const char* ImportName,\n+  const char* Path,\n+  const LLVMRustCOFFShortExport* Exports,\n+  size_t NumExports,\n+  uint16_t Machine,\n+  bool MinGW)\n+{\n+  std::vector<llvm::object::COFFShortExport> ConvertedExports;\n+  ConvertedExports.reserve(NumExports);\n+\n+  for (size_t i = 0; i < NumExports; ++i) {\n+    ConvertedExports.push_back(llvm::object::COFFShortExport{\n+      Exports[i].name,  // Name\n+      std::string{},    // ExtName\n+      std::string{},    // SymbolName\n+      std::string{},    // AliasTarget\n+      0,                // Ordinal\n+      false,            // Noname\n+      false,            // Data\n+      false,            // Private\n+      false             // Constant\n+    });\n+  }\n+\n+  auto Error = llvm::object::writeImportLibrary(\n+    ImportName,\n+    Path,\n+    ConvertedExports,\n+    static_cast<llvm::COFF::MachineTypes>(Machine),\n+    MinGW);\n+  if (Error) {\n+    std::string errorString;\n+    llvm::raw_string_ostream stream(errorString);\n+    stream << Error;\n+    stream.flush();\n+    LLVMRustSetLastError(errorString.c_str());\n+    return LLVMRustResult::Failure;\n+  } else {\n+    return LLVMRustResult::Success;\n+  }\n+}"}, {"sha": "122627eb500ada1b69f2d38924d63e9f4069dcc9", "filename": "compiler/rustc_llvm/src/lib.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fsrc%2Flib.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -167,4 +167,12 @@ pub fn initialize_available_targets() {\n         LLVMInitializeWebAssemblyAsmPrinter,\n         LLVMInitializeWebAssemblyAsmParser\n     );\n+    init_target!(\n+        llvm_component = \"bpf\",\n+        LLVMInitializeBPFTargetInfo,\n+        LLVMInitializeBPFTarget,\n+        LLVMInitializeBPFTargetMC,\n+        LLVMInitializeBPFAsmPrinter,\n+        LLVMInitializeBPFAsmParser\n+    );\n }"}, {"sha": "7bc669f2b005c53fc86c89970270b62f617dd799", "filename": "compiler/rustc_macros/src/serialize.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_macros%2Fsrc%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_macros%2Fsrc%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fserialize.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -43,12 +43,9 @@ fn decodable_body(\n     let decode_body = match s.variants() {\n         [vi] => {\n             let construct = vi.construct(|field, index| decode_field(field, index, true));\n-            let n_fields = vi.ast().fields.len();\n             quote! {\n                 ::rustc_serialize::Decoder::read_struct(\n                     __decoder,\n-                    #ty_name,\n-                    #n_fields,\n                     |__decoder| { ::std::result::Result::Ok(#construct) },\n                 )\n             }\n@@ -77,7 +74,6 @@ fn decodable_body(\n             quote! {\n                 ::rustc_serialize::Decoder::read_enum(\n                     __decoder,\n-                    #ty_name,\n                     |__decoder| {\n                         ::rustc_serialize::Decoder::read_enum_variant(\n                             __decoder,\n@@ -128,7 +124,7 @@ fn decode_field(field: &syn::Field, index: usize, is_struct: bool) -> proc_macro\n \n     quote! {\n         match ::rustc_serialize::Decoder::#decode_method(\n-            __decoder, #opt_field_name #index, #decode_inner_method) {\n+            __decoder, #opt_field_name #decode_inner_method) {\n             ::std::result::Result::Ok(__res) => __res,\n             ::std::result::Result::Err(__err) => return ::std::result::Result::Err(__err),\n         }\n@@ -183,7 +179,6 @@ fn encodable_body(\n         }\n     });\n \n-    let ty_name = s.ast().ident.to_string();\n     let encode_body = match s.variants() {\n         [_] => {\n             let mut field_idx = 0usize;\n@@ -197,11 +192,12 @@ fn encodable_body(\n                             .ident\n                             .as_ref()\n                             .map_or_else(|| field_idx.to_string(), |i| i.to_string());\n+                        let first = field_idx == 0;\n                         let result = quote! {\n                             match ::rustc_serialize::Encoder::emit_struct_field(\n                                 __encoder,\n                                 #field_name,\n-                                #field_idx,\n+                                #first,\n                                 |__encoder|\n                                 ::rustc_serialize::Encodable::<#encoder_ty>::encode(#bind_ident, __encoder),\n                             ) {\n@@ -215,8 +211,9 @@ fn encodable_body(\n                     })\n                     .collect::<TokenStream>()\n             });\n+            let no_fields = field_idx == 0;\n             quote! {\n-                ::rustc_serialize::Encoder::emit_struct(__encoder, #ty_name, #field_idx, |__encoder| {\n+                ::rustc_serialize::Encoder::emit_struct(__encoder, #no_fields, |__encoder| {\n                     ::std::result::Result::Ok(match *self { #encode_inner })\n                 })\n             }\n@@ -232,10 +229,11 @@ fn encodable_body(\n                     .iter()\n                     .map(|binding| {\n                         let bind_ident = &binding.binding;\n+                        let first = field_idx == 0;\n                         let result = quote! {\n                             match ::rustc_serialize::Encoder::emit_enum_variant_arg(\n                                 __encoder,\n-                                #field_idx,\n+                                #first,\n                                 |__encoder|\n                                 ::rustc_serialize::Encodable::<#encoder_ty>::encode(#bind_ident, __encoder),\n                             ) {\n@@ -260,7 +258,7 @@ fn encodable_body(\n                 result\n             });\n             quote! {\n-                ::rustc_serialize::Encoder::emit_enum(__encoder, #ty_name, |__encoder| {\n+                ::rustc_serialize::Encoder::emit_enum(__encoder, |__encoder| {\n                     match *self {\n                         #encode_inner\n                     }"}, {"sha": "d73cfe35dc4a13cc9c2cdd84337411027a2166b5", "filename": "compiler/rustc_metadata/src/creader.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -54,7 +54,7 @@ pub struct CStore {\n pub struct CrateLoader<'a> {\n     // Immutable configuration.\n     sess: &'a Session,\n-    metadata_loader: &'a MetadataLoaderDyn,\n+    metadata_loader: Box<MetadataLoaderDyn>,\n     local_crate_name: Symbol,\n     // Mutable output.\n     cstore: CStore,\n@@ -219,7 +219,7 @@ impl CStore {\n impl<'a> CrateLoader<'a> {\n     pub fn new(\n         sess: &'a Session,\n-        metadata_loader: &'a MetadataLoaderDyn,\n+        metadata_loader: Box<MetadataLoaderDyn>,\n         local_crate_name: &str,\n     ) -> Self {\n         let local_crate_stable_id =\n@@ -544,7 +544,7 @@ impl<'a> CrateLoader<'a> {\n             info!(\"falling back to a load\");\n             let mut locator = CrateLocator::new(\n                 self.sess,\n-                self.metadata_loader,\n+                &*self.metadata_loader,\n                 name,\n                 hash,\n                 host_hash,"}, {"sha": "2c9bad7e5cedb326da042688f939998a06a9f140", "filename": "compiler/rustc_metadata/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_metadata%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_metadata%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flib.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -1,13 +1,11 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n-#![feature(core_intrinsics)]\n #![feature(crate_visibility_modifier)]\n #![feature(drain_filter)]\n #![feature(in_band_lifetimes)]\n #![feature(nll)]\n #![feature(once_cell)]\n #![feature(proc_macro_internals)]\n #![feature(min_specialization)]\n-#![feature(stmt_expr_attributes)]\n #![feature(try_blocks)]\n #![feature(never_type)]\n #![recursion_limit = \"256\"]\n@@ -31,3 +29,5 @@ mod rmeta;\n pub mod creader;\n pub mod dynamic_lib;\n pub mod locator;\n+\n+pub use rmeta::METADATA_HEADER;"}, {"sha": "cd4c394ae14ecf752d1deba6ff36927be57ca8ab", "filename": "compiler/rustc_metadata/src/native_libs.rs", "status": "modified", "additions": 61, "deletions": 11, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -3,7 +3,7 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n-use rustc_middle::middle::cstore::NativeLib;\n+use rustc_middle::middle::cstore::{DllImport, NativeLib};\n use rustc_middle::ty::TyCtxt;\n use rustc_session::parse::feature_err;\n use rustc_session::utils::NativeLibKind;\n@@ -33,8 +33,8 @@ struct Collector<'tcx> {\n \n impl ItemLikeVisitor<'tcx> for Collector<'tcx> {\n     fn visit_item(&mut self, it: &'tcx hir::Item<'tcx>) {\n-        let abi = match it.kind {\n-            hir::ItemKind::ForeignMod { abi, .. } => abi,\n+        let (abi, foreign_mod_items) = match it.kind {\n+            hir::ItemKind::ForeignMod { abi, items } => (abi, items),\n             _ => return,\n         };\n \n@@ -57,6 +57,7 @@ impl ItemLikeVisitor<'tcx> for Collector<'tcx> {\n                 foreign_module: Some(it.def_id.to_def_id()),\n                 wasm_import_module: None,\n                 verbatim: None,\n+                dll_imports: Vec::new(),\n             };\n             let mut kind_specified = false;\n \n@@ -196,6 +197,27 @@ impl ItemLikeVisitor<'tcx> for Collector<'tcx> {\n                 .span_label(m.span, \"missing `name` argument\")\n                 .emit();\n             }\n+\n+            if lib.kind == NativeLibKind::RawDylib {\n+                match abi {\n+                    Abi::C { .. } => (),\n+                    Abi::Cdecl => (),\n+                    _ => {\n+                        if sess.target.arch == \"x86\" {\n+                            sess.span_fatal(\n+                                it.span,\n+                                r#\"`#[link(kind = \"raw-dylib\")]` only supports C and Cdecl ABIs\"#,\n+                            );\n+                        }\n+                    }\n+                };\n+                lib.dll_imports.extend(\n+                    foreign_mod_items\n+                        .iter()\n+                        .map(|child_item| DllImport { name: child_item.ident.name, ordinal: None }),\n+                );\n+            }\n+\n             self.register_native_lib(Some(m.span), lib);\n         }\n     }\n@@ -253,15 +275,42 @@ impl Collector<'tcx> {\n             )\n             .emit();\n         }\n-        if lib.kind == NativeLibKind::RawDylib && !self.tcx.features().raw_dylib {\n-            feature_err(\n-                &self.tcx.sess.parse_sess,\n-                sym::raw_dylib,\n-                span.unwrap_or(rustc_span::DUMMY_SP),\n-                \"kind=\\\"raw-dylib\\\" is unstable\",\n-            )\n-            .emit();\n+        // this just unwraps lib.name; we already established that it isn't empty above.\n+        if let (NativeLibKind::RawDylib, Some(lib_name)) = (lib.kind, lib.name) {\n+            let span = match span {\n+                Some(s) => s,\n+                None => {\n+                    bug!(\"raw-dylib libraries are not supported on the command line\");\n+                }\n+            };\n+\n+            if !self.tcx.sess.target.options.is_like_windows {\n+                self.tcx.sess.span_fatal(\n+                    span,\n+                    \"`#[link(...)]` with `kind = \\\"raw-dylib\\\"` only supported on Windows\",\n+                );\n+            } else if !self.tcx.sess.target.options.is_like_msvc {\n+                self.tcx.sess.span_warn(\n+                    span,\n+                    \"`#[link(...)]` with `kind = \\\"raw-dylib\\\"` not supported on windows-gnu\",\n+                );\n+            }\n+\n+            if lib_name.as_str().contains('\\0') {\n+                self.tcx.sess.span_err(span, \"library name may not contain NUL characters\");\n+            }\n+\n+            if !self.tcx.features().raw_dylib {\n+                feature_err(\n+                    &self.tcx.sess.parse_sess,\n+                    sym::raw_dylib,\n+                    span,\n+                    \"kind=\\\"raw-dylib\\\" is unstable\",\n+                )\n+                .emit();\n+            }\n         }\n+\n         self.libs.push(lib);\n     }\n \n@@ -337,6 +386,7 @@ impl Collector<'tcx> {\n                     foreign_module: None,\n                     wasm_import_module: None,\n                     verbatim: passed_lib.verbatim,\n+                    dll_imports: Vec::new(),\n                 };\n                 self.register_native_lib(None, lib);\n             } else {"}, {"sha": "52cb1e1996e382f4cc342ae28a99087d6458d3f5", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -300,7 +300,7 @@ impl<'a, 'tcx> TyDecoder<'tcx> for DecodeContext<'a, 'tcx> {\n     {\n         let tcx = self.tcx();\n \n-        let key = ty::CReaderCacheKey { cnum: self.cdata().cnum, pos: shorthand };\n+        let key = ty::CReaderCacheKey { cnum: Some(self.cdata().cnum), pos: shorthand };\n \n         if let Some(&ty) = tcx.ty_rcache.borrow().get(&key) {\n             return Ok(ty);\n@@ -1935,6 +1935,10 @@ impl CrateMetadata {\n         self.root.hash\n     }\n \n+    fn num_def_ids(&self) -> usize {\n+        self.root.tables.def_keys.size()\n+    }\n+\n     fn local_def_id(&self, index: DefIndex) -> DefId {\n         DefId { krate: self.cnum, index }\n     }"}, {"sha": "9a97835d9c000e403be89c998b243b3feafb0104", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -1,7 +1,7 @@\n use crate::creader::{CStore, LoadedMacro};\n use crate::foreign_modules;\n use crate::native_libs;\n-use crate::rmeta::{self, encoder};\n+use crate::rmeta::encoder;\n \n use rustc_ast as ast;\n use rustc_ast::expand::allocator::AllocatorKind;\n@@ -155,6 +155,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     is_ctfe_mir_available => { cdata.is_ctfe_mir_available(def_id.index) }\n \n     dylib_dependency_formats => { cdata.get_dylib_dependency_formats(tcx) }\n+    is_private_dep => { cdata.private_dep }\n     is_panic_runtime => { cdata.root.panic_runtime }\n     is_compiler_builtins => { cdata.root.compiler_builtins }\n     has_global_allocator => { cdata.root.has_global_allocator }\n@@ -188,7 +189,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     crate_disambiguator => { cdata.root.disambiguator }\n     crate_hash => { cdata.root.hash }\n     crate_host_hash => { cdata.host_hash }\n-    original_crate_name => { cdata.root.name }\n+    crate_name => { cdata.root.name }\n \n     extra_filename => { cdata.root.extra_filename.clone() }\n \n@@ -205,7 +206,6 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n         let r = *cdata.dep_kind.lock();\n         r\n     }\n-    crate_name => { cdata.root.name }\n     item_children => {\n         let mut result = SmallVec::<[_; 8]>::new();\n         cdata.each_child_of_item(def_id.index, |child| result.push(child), tcx.sess);\n@@ -251,6 +251,10 @@ pub fn provide(providers: &mut Providers) {\n         is_statically_included_foreign_item: |tcx, id| {\n             matches!(tcx.native_library_kind(id), Some(NativeLibKind::Static { .. }))\n         },\n+        is_private_dep: |_tcx, cnum| {\n+            assert_eq!(cnum, LOCAL_CRATE);\n+            false\n+        },\n         native_library_kind: |tcx, id| {\n             tcx.native_libraries(id.krate)\n                 .iter()\n@@ -455,6 +459,13 @@ impl CStore {\n         self.get_crate_data(def_id.krate).module_expansion(def_id.index, sess)\n     }\n \n+    /// Only public-facing way to traverse all the definitions in a non-local crate.\n+    /// Critically useful for this third-party project: <https://github.com/hacspec/hacspec>.\n+    /// See <https://github.com/rust-lang/rust/pull/85889> for context.\n+    pub fn num_def_ids_untracked(&self, cnum: CrateNum) -> usize {\n+        self.get_crate_data(cnum).num_def_ids()\n+    }\n+\n     pub fn item_attrs(&self, def_id: DefId, sess: &Session) -> Vec<ast::Attribute> {\n         self.get_crate_data(def_id.krate).get_item_attrs(def_id.index, sess).collect()\n     }\n@@ -478,10 +489,6 @@ impl CrateStore for CStore {\n         self.get_crate_data(cnum).root.name\n     }\n \n-    fn crate_is_private_dep_untracked(&self, cnum: CrateNum) -> bool {\n-        self.get_crate_data(cnum).private_dep\n-    }\n-\n     fn crate_disambiguator_untracked(&self, cnum: CrateNum) -> CrateDisambiguator {\n         self.get_crate_data(cnum).root.disambiguator\n     }\n@@ -529,10 +536,6 @@ impl CrateStore for CStore {\n         encoder::encode_metadata(tcx)\n     }\n \n-    fn metadata_encoding_version(&self) -> &[u8] {\n-        rmeta::METADATA_HEADER\n-    }\n-\n     fn allocator_kind(&self) -> Option<AllocatorKind> {\n         self.allocator_kind()\n     }"}, {"sha": "76007398000415fa8c772be9e21e2d14b49e6579", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -943,7 +943,7 @@ impl EncodeContext<'a, 'tcx> {\n             });\n             record!(self.tables.span[def_id] <- tcx.def_span(def_id));\n             record!(self.tables.attributes[def_id] <- tcx.get_attrs(def_id));\n-            record!(self.tables.expn_that_defined[def_id] <- self.tcx.expansion_that_defined(def_id));\n+            record!(self.tables.expn_that_defined[def_id] <- self.tcx.expn_that_defined(def_id));\n             if should_encode_visibility(def_kind) {\n                 record!(self.tables.visibility[def_id] <- self.tcx.visibility(def_id));\n             }\n@@ -1674,7 +1674,7 @@ impl EncodeContext<'a, 'tcx> {\n             .iter()\n             .map(|&cnum| {\n                 let dep = CrateDep {\n-                    name: self.tcx.original_crate_name(cnum),\n+                    name: self.tcx.crate_name(cnum),\n                     hash: self.tcx.crate_hash(cnum),\n                     host_hash: self.tcx.crate_host_hash(cnum),\n                     kind: self.tcx.dep_kind(cnum),"}, {"sha": "99ea0cc8f2f1634374efff7691f739ce8bf4b994", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -52,7 +52,7 @@ const METADATA_VERSION: u8 = 5;\n /// This header is followed by the position of the `CrateRoot`,\n /// which is encoded as a 32-bit big-endian unsigned integer,\n /// and further followed by the rustc version string.\n-crate const METADATA_HEADER: &[u8; 8] = &[b'r', b'u', b's', b't', 0, 0, 0, METADATA_VERSION];\n+pub const METADATA_HEADER: &[u8] = &[b'r', b'u', b's', b't', 0, 0, 0, METADATA_VERSION];\n \n /// Additional metadata for a `Lazy<T>` where `T` may not be `Sized`,\n /// e.g. for `Lazy<[T]>`, this is the length (count of `T` values)."}, {"sha": "8ffd98326f1c86ce022a72a9747820a1442b22f8", "filename": "compiler/rustc_middle/src/hir/map/collector.rs", "status": "modified", "additions": 17, "deletions": 25, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fcollector.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -1,6 +1,6 @@\n use crate::arena::Arena;\n-use crate::hir::map::{HirOwnerData, Map};\n-use crate::hir::{IndexedHir, Owner, OwnerNodes, ParentedNode};\n+use crate::hir::map::Map;\n+use crate::hir::{IndexedHir, OwnerNodes, ParentedNode};\n use crate::ich::StableHashingContext;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n@@ -28,7 +28,7 @@ pub(super) struct NodeCollector<'a, 'hir> {\n     /// Source map\n     source_map: &'a SourceMap,\n \n-    map: IndexVec<LocalDefId, HirOwnerData<'hir>>,\n+    map: IndexVec<LocalDefId, Option<&'hir mut OwnerNodes<'hir>>>,\n     parenting: FxHashMap<LocalDefId, HirId>,\n \n     /// The parent of this node\n@@ -107,9 +107,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n             current_dep_node_owner: LocalDefId { local_def_index: CRATE_DEF_INDEX },\n             definitions,\n             hcx,\n-            map: (0..definitions.def_index_count())\n-                .map(|_| HirOwnerData { signature: None, with_bodies: None })\n-                .collect(),\n+            map: IndexVec::from_fn_n(|_| None, definitions.def_index_count()),\n             parenting: FxHashMap::default(),\n         };\n         collector.insert_entry(\n@@ -124,7 +122,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n     pub(super) fn finalize_and_compute_crate_hash(mut self) -> IndexedHir<'hir> {\n         // Insert bodies into the map\n         for (id, body) in self.krate.bodies.iter() {\n-            let bodies = &mut self.map[id.hir_id.owner].with_bodies.as_mut().unwrap().bodies;\n+            let bodies = &mut self.map[id.hir_id.owner].as_mut().unwrap().bodies;\n             assert!(bodies.insert(id.hir_id.local_id, body).is_none());\n         }\n         IndexedHir { map: self.map, parenting: self.parenting }\n@@ -137,22 +135,13 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n \n         let data = &mut self.map[id.owner];\n \n-        if data.with_bodies.is_none() {\n-            data.with_bodies = Some(arena.alloc(OwnerNodes {\n+        if i == 0 {\n+            debug_assert!(data.is_none());\n+            *data = Some(arena.alloc(OwnerNodes {\n                 hash,\n                 nodes: IndexVec::new(),\n                 bodies: FxHashMap::default(),\n             }));\n-        }\n-\n-        let nodes = data.with_bodies.as_mut().unwrap();\n-\n-        if i == 0 {\n-            // Overwrite the dummy hash with the real HIR owner hash.\n-            nodes.hash = hash;\n-\n-            debug_assert!(data.signature.is_none());\n-            data.signature = Some(self.arena.alloc(Owner { node: entry.node }));\n \n             let dk_parent = self.definitions.def_key(id.owner).parent;\n             if let Some(dk_parent) = dk_parent {\n@@ -168,13 +157,16 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n                 debug_assert_eq!(self.parenting.get(&id.owner), Some(&entry.parent));\n             }\n         } else {\n-            assert_eq!(entry.parent.owner, id.owner);\n-            insert_vec_map(\n-                &mut nodes.nodes,\n-                id.local_id,\n-                ParentedNode { parent: entry.parent.local_id, node: entry.node },\n-            );\n+            debug_assert_eq!(entry.parent.owner, id.owner);\n         }\n+\n+        let data = data.as_mut().unwrap();\n+\n+        insert_vec_map(\n+            &mut data.nodes,\n+            id.local_id,\n+            ParentedNode { parent: entry.parent.local_id, node: entry.node },\n+        );\n     }\n \n     fn insert(&mut self, span: Span, hir_id: HirId, node: Node<'hir>) {"}, {"sha": "20bbf9097f4255c80287557d66197b27ff3d085e", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -1,6 +1,6 @@\n use self::collector::NodeCollector;\n \n-use crate::hir::{AttributeMap, HirOwnerData, IndexedHir};\n+use crate::hir::{AttributeMap, IndexedHir};\n use crate::middle::cstore::CrateStore;\n use crate::ty::TyCtxt;\n use rustc_ast as ast;\n@@ -952,7 +952,7 @@ pub(super) fn crate_hash(tcx: TyCtxt<'_>, crate_num: CrateNum) -> Svh {\n         .filter_map(|(def_id, hod)| {\n             let def_path_hash = tcx.definitions.def_path_hash(def_id);\n             let mut hasher = StableHasher::new();\n-            hod.with_bodies.as_ref()?.hash_stable(&mut hcx, &mut hasher);\n+            hod.as_ref()?.hash_stable(&mut hcx, &mut hasher);\n             AttributeMap { map: &tcx.untracked_crate.attrs, prefix: def_id }\n                 .hash_stable(&mut hcx, &mut hasher);\n             Some((def_path_hash, hasher.finish()))"}, {"sha": "087f772c812bdb2cf5a2aade1900cd4d8c59f398", "filename": "compiler/rustc_middle/src/hir/mod.rs", "status": "modified", "additions": 30, "deletions": 11, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -15,23 +15,25 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::*;\n-use rustc_index::vec::IndexVec;\n+use rustc_index::vec::{Idx, IndexVec};\n use rustc_span::DUMMY_SP;\n use std::collections::BTreeMap;\n \n-#[derive(Debug)]\n-struct HirOwnerData<'hir> {\n-    signature: Option<&'hir Owner<'hir>>,\n-    with_bodies: Option<&'hir mut OwnerNodes<'hir>>,\n-}\n-\n+/// Result of HIR indexing.\n #[derive(Debug)]\n pub struct IndexedHir<'hir> {\n-    map: IndexVec<LocalDefId, HirOwnerData<'hir>>,\n+    /// Contents of the HIR owned by each definition. None for definitions that are not HIR owners.\n+    // The `mut` comes from construction time, and is harmless since we only ever hand out\n+    // immutable refs to IndexedHir.\n+    map: IndexVec<LocalDefId, Option<&'hir mut OwnerNodes<'hir>>>,\n+    /// Map from each owner to its parent's HirId inside another owner.\n+    // This map is separate from `map` to eventually allow for per-owner indexing.\n     parenting: FxHashMap<LocalDefId, HirId>,\n }\n \n-#[derive(Debug)]\n+/// Top-level HIR node for current owner. This only contains the node for which\n+/// `HirId::local_id == 0`, and excludes bodies.\n+#[derive(Copy, Clone, Debug)]\n pub struct Owner<'tcx> {\n     node: Node<'tcx>,\n }\n@@ -43,6 +45,9 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for Owner<'tcx> {\n     }\n }\n \n+/// HIR node coupled with its parent's id in the same HIR owner.\n+///\n+/// The parent is trash when the node is a HIR owner.\n #[derive(Clone, Debug)]\n pub struct ParentedNode<'tcx> {\n     parent: ItemLocalId,\n@@ -51,8 +56,12 @@ pub struct ParentedNode<'tcx> {\n \n #[derive(Debug)]\n pub struct OwnerNodes<'tcx> {\n+    /// Pre-computed hash of the full HIR.\n     hash: Fingerprint,\n+    /// Full HIR for the current owner.\n+    // The zeroth node's parent is trash, but is never accessed.\n     nodes: IndexVec<ItemLocalId, Option<ParentedNode<'tcx>>>,\n+    /// Content of local bodies.\n     bodies: FxHashMap<ItemLocalId, &'tcx Body<'tcx>>,\n }\n \n@@ -65,6 +74,8 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for OwnerNodes<'tcx> {\n     }\n }\n \n+/// Attributes owner by a HIR owner. It is build as a slice inside the attributes map, restricted\n+/// to the nodes whose `HirId::owner` is `prefix`.\n #[derive(Copy, Clone)]\n pub struct AttributeMap<'tcx> {\n     map: &'tcx BTreeMap<HirId, &'tcx [Attribute]>,\n@@ -127,8 +138,12 @@ pub fn provide(providers: &mut Providers) {\n     providers.index_hir = map::index_hir;\n     providers.crate_hash = map::crate_hash;\n     providers.hir_module_items = |tcx, id| &tcx.untracked_crate.modules[&id];\n-    providers.hir_owner = |tcx, id| tcx.index_hir(()).map[id].signature;\n-    providers.hir_owner_nodes = |tcx, id| tcx.index_hir(()).map[id].with_bodies.as_deref();\n+    providers.hir_owner = |tcx, id| {\n+        let owner = tcx.index_hir(()).map[id].as_ref()?;\n+        let node = owner.nodes[ItemLocalId::new(0)].as_ref()?.node;\n+        Some(Owner { node })\n+    };\n+    providers.hir_owner_nodes = |tcx, id| tcx.index_hir(()).map[id].as_deref();\n     providers.hir_owner_parent = |tcx, id| {\n         let index = tcx.index_hir(());\n         index.parenting.get(&id).copied().unwrap_or(CRATE_HIR_ID)\n@@ -152,4 +167,8 @@ pub fn provide(providers: &mut Providers) {\n     };\n     providers.opt_def_kind = |tcx, def_id| tcx.hir().opt_def_kind(def_id.expect_local());\n     providers.all_local_trait_impls = |tcx, ()| &tcx.hir_crate(()).trait_impls;\n+    providers.expn_that_defined = |tcx, id| {\n+        let id = id.expect_local();\n+        tcx.definitions.expansion_that_defined(id)\n+    };\n }"}, {"sha": "91c81c367a16febb0e59bc64429f0d291c8425be", "filename": "compiler/rustc_middle/src/ich/hcx.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_middle%2Fsrc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_middle%2Fsrc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fich%2Fhcx.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -14,7 +14,6 @@ use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::Symbol;\n use rustc_span::{BytePos, CachingSourceMapView, SourceFile, SpanData};\n \n-use rustc_span::def_id::{CrateNum, CRATE_DEF_INDEX};\n use smallvec::SmallVec;\n use std::cmp::Ord;\n use std::thread::LocalKey;\n@@ -227,15 +226,8 @@ impl<'a> rustc_span::HashStableContext for StableHashingContext<'a> {\n     }\n \n     #[inline]\n-    fn hash_crate_num(&mut self, cnum: CrateNum, hasher: &mut StableHasher) {\n-        let hcx = self;\n-        hcx.def_path_hash(DefId { krate: cnum, index: CRATE_DEF_INDEX }).hash_stable(hcx, hasher);\n-    }\n-\n-    #[inline]\n-    fn hash_def_id(&mut self, def_id: DefId, hasher: &mut StableHasher) {\n-        let hcx = self;\n-        hcx.def_path_hash(def_id).hash_stable(hcx, hasher);\n+    fn def_path_hash(&self, def_id: DefId) -> DefPathHash {\n+        self.def_path_hash(def_id)\n     }\n \n     fn expn_id_cache() -> &'static LocalKey<rustc_span::ExpnIdCache> {"}, {"sha": "5dfd00bc6d42c36e372f1d0cd4a22bc806b8e3a7", "filename": "compiler/rustc_middle/src/ich/impls_hir.rs", "status": "modified", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_middle%2Fsrc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_middle%2Fsrc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fich%2Fimpls_hir.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -6,7 +6,6 @@ use rustc_attr as attr;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher, ToStableHashKey};\n use rustc_hir as hir;\n-use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, CRATE_DEF_INDEX};\n use rustc_hir::definitions::DefPathHash;\n use smallvec::SmallVec;\n use std::mem;\n@@ -113,46 +112,6 @@ impl<'ctx> rustc_hir::HashStableContext for StableHashingContext<'ctx> {\n \n         self.node_id_hashing_mode = prev_hash_node_ids;\n     }\n-\n-    #[inline]\n-    fn local_def_path_hash(&self, def_id: LocalDefId) -> DefPathHash {\n-        self.local_def_path_hash(def_id)\n-    }\n-}\n-\n-impl<'a> ToStableHashKey<StableHashingContext<'a>> for DefId {\n-    type KeyType = DefPathHash;\n-\n-    #[inline]\n-    fn to_stable_hash_key(&self, hcx: &StableHashingContext<'a>) -> DefPathHash {\n-        hcx.def_path_hash(*self)\n-    }\n-}\n-\n-impl<'a> HashStable<StableHashingContext<'a>> for LocalDefId {\n-    #[inline]\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        hcx.def_path_hash(self.to_def_id()).hash_stable(hcx, hasher);\n-    }\n-}\n-\n-impl<'a> ToStableHashKey<StableHashingContext<'a>> for LocalDefId {\n-    type KeyType = DefPathHash;\n-\n-    #[inline]\n-    fn to_stable_hash_key(&self, hcx: &StableHashingContext<'a>) -> DefPathHash {\n-        hcx.def_path_hash(self.to_def_id())\n-    }\n-}\n-\n-impl<'a> ToStableHashKey<StableHashingContext<'a>> for CrateNum {\n-    type KeyType = DefPathHash;\n-\n-    #[inline]\n-    fn to_stable_hash_key(&self, hcx: &StableHashingContext<'a>) -> DefPathHash {\n-        let def_id = DefId { krate: *self, index: CRATE_DEF_INDEX };\n-        def_id.to_stable_hash_key(hcx)\n-    }\n }\n \n impl<'a> ToStableHashKey<StableHashingContext<'a>> for hir::ItemLocalId {"}, {"sha": "d764d45ba7e5c7dfb2c9f9daf40a3d9718684793", "filename": "compiler/rustc_middle/src/infer/canonical.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -294,6 +294,7 @@ TrivialTypeFoldableImpls! {\n }\n \n impl<'tcx> CanonicalVarValues<'tcx> {\n+    #[inline]\n     pub fn len(&self) -> usize {\n         self.var_values.len()\n     }"}, {"sha": "e1d7bc4be533c467fa07a833296441957abbfd49", "filename": "compiler/rustc_middle/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flib.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -29,7 +29,6 @@\n #![feature(bool_to_option)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n-#![feature(const_panic)]\n #![feature(core_intrinsics)]\n #![feature(discriminant_kind)]\n #![feature(never_type)]\n@@ -50,7 +49,6 @@\n #![feature(associated_type_defaults)]\n #![feature(iter_zip)]\n #![feature(thread_local_const_init)]\n-#![feature(trusted_step)]\n #![recursion_limit = \"512\"]\n \n #[macro_use]"}, {"sha": "4c7ea937ceb7dd1d9f486b05daba3248c89674c7", "filename": "compiler/rustc_middle/src/lint.rs", "status": "modified", "additions": 26, "deletions": 4, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_middle%2Fsrc%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_middle%2Fsrc%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flint.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -1,7 +1,7 @@\n use std::cmp;\n \n use crate::ich::StableHashingContext;\n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_errors::{DiagnosticBuilder, DiagnosticId};\n use rustc_hir::HirId;\n@@ -28,6 +28,9 @@ pub enum LintLevelSource {\n     /// The provided `Level` is the level specified on the command line.\n     /// (The actual level may be lower due to `--cap-lints`.)\n     CommandLine(Symbol, Level),\n+\n+    /// Lint is being forced to warn no matter what.\n+    ForceWarn(Symbol),\n }\n \n impl LintLevelSource {\n@@ -36,6 +39,7 @@ impl LintLevelSource {\n             LintLevelSource::Default => symbol::kw::Default,\n             LintLevelSource::Node(name, _, _) => name,\n             LintLevelSource::CommandLine(name, _) => name,\n+            LintLevelSource::ForceWarn(name) => name,\n         }\n     }\n \n@@ -44,6 +48,7 @@ impl LintLevelSource {\n             LintLevelSource::Default => DUMMY_SP,\n             LintLevelSource::Node(_, span, _) => span,\n             LintLevelSource::CommandLine(_, _) => DUMMY_SP,\n+            LintLevelSource::ForceWarn(_) => DUMMY_SP,\n         }\n     }\n }\n@@ -55,6 +60,7 @@ pub type LevelAndSource = (Level, LintLevelSource);\n pub struct LintLevelSets {\n     pub list: Vec<LintSet>,\n     pub lint_cap: Level,\n+    pub force_warns: FxHashSet<LintId>,\n }\n \n #[derive(Debug)]\n@@ -73,7 +79,11 @@ pub enum LintSet {\n \n impl LintLevelSets {\n     pub fn new() -> Self {\n-        LintLevelSets { list: Vec::new(), lint_cap: Level::Forbid }\n+        LintLevelSets {\n+            list: Vec::new(),\n+            lint_cap: Level::Forbid,\n+            force_warns: FxHashSet::default(),\n+        }\n     }\n \n     pub fn get_lint_level(\n@@ -83,6 +93,11 @@ impl LintLevelSets {\n         aux: Option<&FxHashMap<LintId, LevelAndSource>>,\n         sess: &Session,\n     ) -> LevelAndSource {\n+        // Check whether we should always warn\n+        if self.force_warns.contains(&LintId::of(lint)) {\n+            return (Level::Warn, LintLevelSource::ForceWarn(Symbol::intern(lint.name)));\n+        }\n+\n         let (level, mut src) = self.get_lint_id_level(LintId::of(lint), idx, aux);\n \n         // If `level` is none then we actually assume the default level for this\n@@ -176,11 +191,11 @@ impl LintLevelMap {\n impl<'a> HashStable<StableHashingContext<'a>> for LintLevelMap {\n     #[inline]\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        let LintLevelMap { ref sets, ref id_to_set } = *self;\n+        let LintLevelMap { ref sets, ref id_to_set, .. } = *self;\n \n         id_to_set.hash_stable(hcx, hasher);\n \n-        let LintLevelSets { ref list, lint_cap } = *sets;\n+        let LintLevelSets { ref list, lint_cap, .. } = *sets;\n \n         lint_cap.hash_stable(hcx, hasher);\n \n@@ -346,6 +361,13 @@ pub fn struct_lint_level<'s, 'd>(\n                     );\n                 }\n             }\n+            LintLevelSource::ForceWarn(_) => {\n+                sess.diag_note_once(\n+                    &mut err,\n+                    DiagnosticMessageId::from(lint),\n+                    \"warning forced by `force-warns` commandline option\",\n+                );\n+            }\n         }\n \n         err.code(DiagnosticId::Lint { name, has_future_breakage });"}, {"sha": "a7ab43d106c4a45d9a567435569b714876985344", "filename": "compiler/rustc_middle/src/middle/cstore.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fcstore.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -95,6 +95,13 @@ pub struct NativeLib {\n     pub foreign_module: Option<DefId>,\n     pub wasm_import_module: Option<Symbol>,\n     pub verbatim: Option<bool>,\n+    pub dll_imports: Vec<DllImport>,\n+}\n+\n+#[derive(Clone, Debug, Encodable, Decodable, HashStable)]\n+pub struct DllImport {\n+    pub name: Symbol,\n+    pub ordinal: Option<u16>,\n }\n \n #[derive(Clone, TyEncodable, TyDecodable, HashStable, Debug)]\n@@ -199,7 +206,6 @@ pub trait CrateStore {\n \n     // \"queries\" used in resolve that aren't tracked for incremental compilation\n     fn crate_name_untracked(&self, cnum: CrateNum) -> Symbol;\n-    fn crate_is_private_dep_untracked(&self, cnum: CrateNum) -> bool;\n     fn crate_disambiguator_untracked(&self, cnum: CrateNum) -> CrateDisambiguator;\n     fn crate_hash_untracked(&self, cnum: CrateNum) -> Svh;\n \n@@ -209,7 +215,6 @@ pub trait CrateStore {\n \n     // utility functions\n     fn encode_metadata(&self, tcx: TyCtxt<'_>) -> EncodedMetadata;\n-    fn metadata_encoding_version(&self) -> &[u8];\n     fn allocator_kind(&self) -> Option<AllocatorKind>;\n }\n "}, {"sha": "288dd0394464581691c16201964eaa7b2f085d8e", "filename": "compiler/rustc_middle/src/middle/exported_symbols.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fexported_symbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fexported_symbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fexported_symbols.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -49,7 +49,7 @@ impl<'tcx> ExportedSymbol<'tcx> {\n pub fn metadata_symbol_name(tcx: TyCtxt<'_>) -> String {\n     format!(\n         \"rust_metadata_{}_{}\",\n-        tcx.original_crate_name(LOCAL_CRATE),\n+        tcx.crate_name(LOCAL_CRATE),\n         tcx.crate_disambiguator(LOCAL_CRATE).to_fingerprint().to_hex()\n     )\n }"}, {"sha": "1ef10241143b83ed0ca19f0c51abff8f84ff0419", "filename": "compiler/rustc_middle/src/mir/abstract_const.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fabstract_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fabstract_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fabstract_const.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -1,6 +1,6 @@\n //! A subset of a mir body used for const evaluatability checking.\n-use crate::mir;\n-use crate::ty;\n+use crate::mir::{self, CastKind};\n+use crate::ty::{self, Ty};\n \n rustc_index::newtype_index! {\n     /// An index into an `AbstractConst`.\n@@ -17,6 +17,7 @@ pub enum Node<'tcx> {\n     Binop(mir::BinOp, NodeId, NodeId),\n     UnaryOp(mir::UnOp, NodeId),\n     FunctionCall(NodeId, &'tcx [NodeId]),\n+    Cast(CastKind, NodeId, Ty<'tcx>),\n }\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, HashStable, TyEncodable, TyDecodable)]"}, {"sha": "65d9c1dd90efbdc76dfc8897414686d8c47366f2", "filename": "compiler/rustc_middle/src/mir/interpret/error.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -435,8 +435,12 @@ impl<T: Any> AsAny for T {\n }\n \n /// A trait for machine-specific errors (or other \"machine stop\" conditions).\n-pub trait MachineStopType: AsAny + fmt::Display + Send {}\n-impl MachineStopType for String {}\n+pub trait MachineStopType: AsAny + fmt::Display + Send {\n+    /// If `true`, emit a hard error instead of going through the `CONST_ERR` lint\n+    fn is_hard_err(&self) -> bool {\n+        false\n+    }\n+}\n \n impl dyn MachineStopType {\n     #[inline(always)]"}, {"sha": "14bdb0a5a2d506b03e1c0f91cbac59030f3e879a", "filename": "compiler/rustc_middle/src/mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -246,6 +246,7 @@ pub struct AllocDecodingState {\n }\n \n impl AllocDecodingState {\n+    #[inline]\n     pub fn new_decoding_session(&self) -> AllocDecodingSession<'_> {\n         static DECODER_SESSION_ID: AtomicU32 = AtomicU32::new(0);\n         let counter = DECODER_SESSION_ID.fetch_add(1, Ordering::SeqCst);"}, {"sha": "7ae7eab6e5a315cda438adbea5f2007cc623b4b6", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -1249,10 +1249,12 @@ impl<'tcx> BasicBlockData<'tcx> {\n     ///\n     /// Terminator may not be None after construction of the basic block is complete. This accessor\n     /// provides a convenience way to reach the terminator.\n+    #[inline]\n     pub fn terminator(&self) -> &Terminator<'tcx> {\n         self.terminator.as_ref().expect(\"invalid terminator state\")\n     }\n \n+    #[inline]\n     pub fn terminator_mut(&mut self) -> &mut Terminator<'tcx> {\n         self.terminator.as_mut().expect(\"invalid terminator state\")\n     }\n@@ -1870,13 +1872,15 @@ impl<'tcx> PlaceRef<'tcx> {\n \n     /// If this place represents a local variable like `_X` with no\n     /// projections, return `Some(_X)`.\n+    #[inline]\n     pub fn as_local(&self) -> Option<Local> {\n         match *self {\n             PlaceRef { local, projection: [] } => Some(local),\n             _ => None,\n         }\n     }\n \n+    #[inline]\n     pub fn last_projection(&self) -> Option<(PlaceRef<'tcx>, PlaceElem<'tcx>)> {\n         if let &[ref proj_base @ .., elem] = self.projection {\n             Some((PlaceRef { local: self.local, projection: proj_base }, elem))\n@@ -2464,12 +2468,14 @@ impl Constant<'tcx> {\n             _ => None,\n         }\n     }\n+    #[inline]\n     pub fn ty(&self) -> Ty<'tcx> {\n         self.literal.ty()\n     }\n }\n \n impl From<&'tcx ty::Const<'tcx>> for ConstantKind<'tcx> {\n+    #[inline]\n     fn from(ct: &'tcx ty::Const<'tcx>) -> Self {\n         Self::Ty(ct)\n     }"}, {"sha": "74650f50a1c8aa6385cc7d82fa6cba005be6ff23", "filename": "compiler/rustc_middle/src/mir/mono.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -267,6 +267,7 @@ pub enum Visibility {\n }\n \n impl<'tcx> CodegenUnit<'tcx> {\n+    #[inline]\n     pub fn new(name: Symbol) -> CodegenUnit<'tcx> {\n         CodegenUnit { name, items: Default::default(), size_estimate: None, primary: false }\n     }\n@@ -311,6 +312,7 @@ impl<'tcx> CodegenUnit<'tcx> {\n         self.size_estimate = Some(self.items.keys().map(|mi| mi.size_estimate(tcx)).sum());\n     }\n \n+    #[inline]\n     pub fn size_estimate(&self) -> usize {\n         // Should only be called if `estimate_size` has previously been called.\n         self.size_estimate.expect(\"estimate_size must be called before getting a size_estimate\")"}, {"sha": "4fb737f463a8621e127979700cc6eb038922006b", "filename": "compiler/rustc_middle/src/mir/query.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -2,13 +2,14 @@\n \n use crate::mir::{abstract_const, Body, Promoted};\n use crate::ty::{self, Ty, TyCtxt};\n-use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n+use rustc_data_structures::vec_map::VecMap;\n use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_index::bit_set::BitMatrix;\n use rustc_index::vec::IndexVec;\n+use rustc_middle::ty::OpaqueTypeKey;\n use rustc_span::Span;\n use rustc_target::abi::VariantIdx;\n use smallvec::SmallVec;\n@@ -210,7 +211,7 @@ pub struct BorrowCheckResult<'tcx> {\n     /// All the opaque types that are restricted to concrete types\n     /// by this function. Unlike the value in `TypeckResults`, this has\n     /// unerased regions.\n-    pub concrete_opaque_types: FxHashMap<DefId, ty::ResolvedOpaqueTy<'tcx>>,\n+    pub concrete_opaque_types: VecMap<OpaqueTypeKey<'tcx>, Ty<'tcx>>,\n     pub closure_requirements: Option<ClosureRegionRequirements<'tcx>>,\n     pub used_mut_upvars: SmallVec<[Field; 8]>,\n }"}, {"sha": "0860520ef9dfe8aa1dca8fab66ba9198489a9b95", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -47,7 +47,7 @@ rustc_queries! {\n     ///\n     /// This can be conveniently accessed by methods on `tcx.hir()`.\n     /// Avoid calling this query directly.\n-    query hir_owner(key: LocalDefId) -> Option<&'tcx crate::hir::Owner<'tcx>> {\n+    query hir_owner(key: LocalDefId) -> Option<crate::hir::Owner<'tcx>> {\n         eval_always\n         desc { |tcx| \"HIR owner of `{}`\", tcx.def_path_str(key.to_def_id()) }\n     }\n@@ -210,8 +210,8 @@ rustc_queries! {\n         desc { |tcx| \"parent module of `{}`\", tcx.def_path_str(key.to_def_id()) }\n     }\n \n-    /// Internal helper query. Use `tcx.expansion_that_defined` instead\n     query expn_that_defined(key: DefId) -> rustc_span::ExpnId {\n+        eval_always\n         desc { |tcx| \"expansion that defined `{}`\", tcx.def_path_str(key) }\n     }\n \n@@ -1127,8 +1127,7 @@ rustc_queries! {\n         desc { \"computing whether impls specialize one another\" }\n     }\n     query in_scope_traits_map(_: LocalDefId)\n-        -> Option<&'tcx FxHashMap<ItemLocalId, StableVec<TraitCandidate>>> {\n-        eval_always\n+        -> Option<&'tcx FxHashMap<ItemLocalId, Box<[TraitCandidate]>>> {\n         desc { \"traits in scope at a block\" }\n     }\n \n@@ -1252,10 +1251,6 @@ rustc_queries! {\n         eval_always\n         desc { \"looking up the hash of a host version of a crate\" }\n     }\n-    query original_crate_name(_: CrateNum) -> Symbol {\n-        eval_always\n-        desc { \"looking up the original name a crate\" }\n-    }\n     query extra_filename(_: CrateNum) -> String {\n         eval_always\n         desc { \"looking up the extra filename for a crate\" }\n@@ -1419,6 +1414,12 @@ rustc_queries! {\n         eval_always\n         desc { \"generating a postorder list of CrateNums\" }\n     }\n+    /// Returns whether or not the crate with CrateNum 'cnum'\n+    /// is marked as a private dependency\n+    query is_private_dep(c: CrateNum) -> bool {\n+        eval_always\n+        desc { \"check whether crate {} is a private dependency\", c }\n+    }\n \n     query upvars_mentioned(def_id: DefId) -> Option<&'tcx FxIndexMap<hir::HirId, hir::Upvar>> {\n         desc { |tcx| \"collecting upvars mentioned in `{}`\", tcx.def_path_str(def_id) }"}, {"sha": "02ff1b9f4d655ff15fc191617eccd1439e7dfd29", "filename": "compiler/rustc_middle/src/ty/_match.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -46,6 +46,7 @@ impl TypeRelation<'tcx> for Match<'tcx> {\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         _: ty::Variance,\n+        _: ty::VarianceDiagInfo<'tcx>,\n         a: T,\n         b: T,\n     ) -> RelateResult<'tcx, T> {"}, {"sha": "d13cbdd122854a8c9bd7c6004b2a9702e2263ae8", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 12, "deletions": 40, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -31,9 +31,10 @@ use rustc_attr as attr;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::profiling::SelfProfilerRef;\n use rustc_data_structures::sharded::{IntoPointer, ShardedHashMap};\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher, StableVec};\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::steal::Steal;\n use rustc_data_structures::sync::{self, Lock, Lrc, WorkerLocal};\n+use rustc_data_structures::vec_map::VecMap;\n use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n@@ -47,6 +48,7 @@ use rustc_hir::{\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_macros::HashStable;\n use rustc_middle::mir::FakeReadCause;\n+use rustc_middle::ty::OpaqueTypeKey;\n use rustc_serialize::opaque::{FileEncodeResult, FileEncoder};\n use rustc_session::config::{BorrowckMode, CrateType, OutputFilenames};\n use rustc_session::lint::{Level, Lint};\n@@ -286,17 +288,6 @@ impl<'a, V> LocalTableInContextMut<'a, V> {\n     }\n }\n \n-/// All information necessary to validate and reveal an `impl Trait`.\n-#[derive(TyEncodable, TyDecodable, Debug, HashStable)]\n-pub struct ResolvedOpaqueTy<'tcx> {\n-    /// The revealed type as seen by this function.\n-    pub concrete_type: Ty<'tcx>,\n-    /// Generic parameters on the opaque type as passed by this function.\n-    /// For `type Foo<A, B> = impl Bar<A, B>; fn foo<T, U>() -> Foo<T, U> { .. }`\n-    /// this is `[T, U]`, not `[A, B]`.\n-    pub substs: SubstsRef<'tcx>,\n-}\n-\n /// Whenever a value may be live across a generator yield, the type of that value winds up in the\n /// `GeneratorInteriorTypeCause` struct. This struct adds additional information about such\n /// captured types that can be useful for diagnostics. In particular, it stores the span that\n@@ -424,7 +415,7 @@ pub struct TypeckResults<'tcx> {\n \n     /// All the opaque types that are restricted to concrete types\n     /// by this function.\n-    pub concrete_opaque_types: FxHashMap<DefId, ResolvedOpaqueTy<'tcx>>,\n+    pub concrete_opaque_types: VecMap<OpaqueTypeKey<'tcx>, Ty<'tcx>>,\n \n     /// Tracks the minimum captures required for a closure;\n     /// see `MinCaptureInformationMap` for more details.\n@@ -966,10 +957,6 @@ pub struct GlobalCtxt<'tcx> {\n     /// Resolutions of `extern crate` items produced by resolver.\n     extern_crate_map: FxHashMap<LocalDefId, CrateNum>,\n \n-    /// Map indicating what traits are in scope for places where this\n-    /// is relevant; generated by resolve.\n-    trait_map: FxHashMap<LocalDefId, FxHashMap<ItemLocalId, StableVec<TraitCandidate>>>,\n-\n     /// Export map produced by name resolution.\n     export_map: ExportMap<LocalDefId>,\n \n@@ -1009,7 +996,7 @@ pub struct GlobalCtxt<'tcx> {\n \n     /// The definite name of the current crate after taking into account\n     /// attributes, commandline parameters, etc.\n-    pub crate_name: Symbol,\n+    crate_name: Symbol,\n \n     /// Data layout specification for the current target.\n     pub data_layout: TargetDataLayout,\n@@ -1139,7 +1126,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         on_disk_cache: Option<query::OnDiskCache<'tcx>>,\n         queries: &'tcx dyn query::QueryEngine<'tcx>,\n         crate_name: &str,\n-        output_filenames: &OutputFilenames,\n+        output_filenames: OutputFilenames,\n     ) -> GlobalCtxt<'tcx> {\n         let data_layout = TargetDataLayout::parse(&s.target).unwrap_or_else(|err| {\n             s.fatal(&err);\n@@ -1150,12 +1137,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         let common_consts = CommonConsts::new(&interners, &common_types);\n         let cstore = resolutions.cstore;\n \n-        let mut trait_map: FxHashMap<_, FxHashMap<_, _>> = FxHashMap::default();\n-        for (hir_id, v) in krate.trait_map.iter() {\n-            let map = trait_map.entry(hir_id.owner).or_default();\n-            map.insert(hir_id.local_id, StableVec::new(v.to_vec()));\n-        }\n-\n         GlobalCtxt {\n             sess: s,\n             lint_store,\n@@ -1169,7 +1150,6 @@ impl<'tcx> TyCtxt<'tcx> {\n             consts: common_consts,\n             visibilities: resolutions.visibilities,\n             extern_crate_map: resolutions.extern_crate_map,\n-            trait_map,\n             export_map: resolutions.export_map,\n             maybe_unused_trait_imports: resolutions.maybe_unused_trait_imports,\n             maybe_unused_extern_crates: resolutions.maybe_unused_extern_crates,\n@@ -1190,7 +1170,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             stability_interner: Default::default(),\n             const_stability_interner: Default::default(),\n             alloc_map: Lock::new(interpret::AllocMap::new()),\n-            output_filenames: Arc::new(output_filenames.clone()),\n+            output_filenames: Arc::new(output_filenames),\n             main_def: resolutions.main_def,\n         }\n     }\n@@ -1275,12 +1255,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    /// Returns whether or not the crate with CrateNum 'cnum'\n-    /// is marked as a private dependency\n-    pub fn is_private_dep(self, cnum: CrateNum) -> bool {\n-        if cnum == LOCAL_CRATE { false } else { self.cstore.crate_is_private_dep_untracked(cnum) }\n-    }\n-\n     #[inline]\n     pub fn def_path_hash(self, def_id: DefId) -> rustc_hir::definitions::DefPathHash {\n         if let Some(def_id) = def_id.as_local() {\n@@ -1314,10 +1288,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         )\n     }\n \n-    pub fn metadata_encoding_version(self) -> Vec<u8> {\n-        self.cstore.metadata_encoding_version().to_vec()\n-    }\n-\n     pub fn encode_metadata(self) -> EncodedMetadata {\n         let _prof_timer = self.prof.verbose_generic_activity(\"generate_crate_metadata\");\n         self.cstore.encode_metadata(self)\n@@ -2662,8 +2632,10 @@ impl<'tcx> TyCtxt<'tcx> {\n         struct_lint_level(self.sess, lint, level, src, None, decorate);\n     }\n \n-    pub fn in_scope_traits(self, id: HirId) -> Option<&'tcx StableVec<TraitCandidate>> {\n-        self.in_scope_traits_map(id.owner).and_then(|map| map.get(&id.local_id))\n+    pub fn in_scope_traits(self, id: HirId) -> Option<&'tcx [TraitCandidate]> {\n+        let map = self.in_scope_traits_map(id.owner)?;\n+        let candidates = map.get(&id.local_id)?;\n+        Some(&*candidates)\n     }\n \n     pub fn named_region(self, id: HirId) -> Option<resolve_lifetime::Region> {\n@@ -2793,7 +2765,7 @@ fn ptr_eq<T, U>(t: *const T, u: *const U) -> bool {\n }\n \n pub fn provide(providers: &mut ty::query::Providers) {\n-    providers.in_scope_traits_map = |tcx, id| tcx.gcx.trait_map.get(&id);\n+    providers.in_scope_traits_map = |tcx, id| tcx.hir_crate(()).trait_map.get(&id);\n     providers.module_exports = |tcx, id| tcx.gcx.export_map.get(&id).map(|v| &v[..]);\n     providers.crate_name = |tcx, id| {\n         assert_eq!(id, LOCAL_CRATE);"}, {"sha": "bfb4c0cb538dec29ad8ec51ae8a3c125a0836d8b", "filename": "compiler/rustc_middle/src/ty/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -54,7 +54,7 @@ impl<'tcx> TyS<'tcx> {\n     /// ADTs with no type arguments.\n     pub fn is_simple_text(&self) -> bool {\n         match self.kind() {\n-            Adt(_, substs) => substs.types().next().is_none(),\n+            Adt(_, substs) => substs.non_erasable_generics().next().is_none(),\n             Ref(_, ty, _) => ty.is_simple_text(),\n             _ => self.is_simple_ty(),\n         }"}, {"sha": "4e3f475a915f35119c503b7eb02c2609bbf33fa1", "filename": "compiler/rustc_middle/src/ty/generics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -93,6 +93,7 @@ pub struct Generics {\n }\n \n impl<'tcx> Generics {\n+    #[inline]\n     pub fn count(&self) -> usize {\n         self.parent_count + self.params.len()\n     }"}, {"sha": "28a44b09de2b112ce0e8a366ca541b3ef51329d6", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -367,7 +367,14 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n         for &i in &inverse_memory_index {\n             let field = fields[i as usize];\n             if !sized {\n-                bug!(\"univariant: field #{} of `{}` comes after unsized field\", offsets.len(), ty);\n+                self.tcx.sess.delay_span_bug(\n+                    DUMMY_SP,\n+                    &format!(\n+                        \"univariant: field #{} of `{}` comes after unsized field\",\n+                        offsets.len(),\n+                        ty\n+                    ),\n+                );\n             }\n \n             if field.is_unsized() {"}, {"sha": "44dfcbf1866a7a402c4248fb2b1f3c4b74e17dcb", "filename": "compiler/rustc_middle/src/ty/list.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_middle%2Fsrc%2Fty%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_middle%2Fsrc%2Fty%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flist.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -37,9 +37,11 @@ pub struct List<T> {\n \n unsafe impl<'a, T: 'a> rustc_data_structures::tagged_ptr::Pointer for &'a List<T> {\n     const BITS: usize = std::mem::align_of::<usize>().trailing_zeros() as usize;\n+    #[inline]\n     fn into_usize(self) -> usize {\n         self as *const List<T> as usize\n     }\n+    #[inline]\n     unsafe fn from_usize(ptr: usize) -> Self {\n         &*(ptr as *const List<T>)\n     }"}, {"sha": "227aa8dc284e27dd7a0d80d6e63f9cf868bfd94c", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -39,7 +39,6 @@ use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, LocalDefIdMap, CRATE_DEF_INDEX};\n use rustc_hir::{Constness, Node};\n use rustc_macros::HashStable;\n-use rustc_span::hygiene::ExpnId;\n use rustc_span::symbol::{kw, Ident, Symbol};\n use rustc_span::Span;\n use rustc_target::abi::Align;\n@@ -59,7 +58,7 @@ pub use self::consts::{Const, ConstInt, ConstKind, InferConst, ScalarInt, Uneval\n pub use self::context::{\n     tls, CanonicalUserType, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations,\n     CtxtInterners, DelaySpanBugEmitted, FreeRegionInfo, GeneratorInteriorTypeCause, GlobalCtxt,\n-    Lift, ResolvedOpaqueTy, TyCtxt, TypeckResults, UserType, UserTypeAnnotationIndex,\n+    Lift, TyCtxt, TypeckResults, UserType, UserTypeAnnotationIndex,\n };\n pub use self::instance::{Instance, InstanceDef};\n pub use self::list::List;\n@@ -72,7 +71,7 @@ pub use self::sty::{\n     ExistentialPredicate, ExistentialProjection, ExistentialTraitRef, FnSig, FreeRegion, GenSig,\n     GeneratorSubsts, GeneratorSubstsParts, ParamConst, ParamTy, PolyExistentialProjection,\n     PolyExistentialTraitRef, PolyFnSig, PolyGenSig, PolyTraitRef, ProjectionTy, Region, RegionKind,\n-    RegionVid, TraitRef, TyKind, TypeAndMut, UpvarSubsts,\n+    RegionVid, TraitRef, TyKind, TypeAndMut, UpvarSubsts, VarianceDiagInfo, VarianceDiagMutKind,\n };\n pub use self::trait_def::TraitDef;\n \n@@ -269,7 +268,7 @@ pub struct CrateVariancesMap<'tcx> {\n // the types of AST nodes.\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n pub struct CReaderCacheKey {\n-    pub cnum: CrateNum,\n+    pub cnum: Option<CrateNum>,\n     pub pos: usize,\n }\n \n@@ -836,6 +835,12 @@ impl<'tcx> InstantiatedPredicates<'tcx> {\n     }\n }\n \n+#[derive(Copy, Clone, Debug, PartialEq, Eq, HashStable, TyEncodable, TyDecodable)]\n+pub struct OpaqueTypeKey<'tcx> {\n+    pub def_id: DefId,\n+    pub substs: SubstsRef<'tcx>,\n+}\n+\n rustc_index::newtype_index! {\n     /// \"Universes\" are used during type- and trait-checking in the\n     /// presence of `for<..>` binders to control what sets of names are\n@@ -1097,12 +1102,14 @@ pub struct ParamEnv<'tcx> {\n \n unsafe impl rustc_data_structures::tagged_ptr::Tag for traits::Reveal {\n     const BITS: usize = 1;\n+    #[inline]\n     fn into_usize(self) -> usize {\n         match self {\n             traits::Reveal::UserFacing => 0,\n             traits::Reveal::All => 1,\n         }\n     }\n+    #[inline]\n     unsafe fn from_usize(ptr: usize) -> Self {\n         match ptr {\n             0 => traits::Reveal::UserFacing,\n@@ -1200,6 +1207,7 @@ impl<'tcx> ParamEnv<'tcx> {\n     }\n \n     /// Returns this same environment but with no caller bounds.\n+    #[inline]\n     pub fn without_caller_bounds(self) -> Self {\n         Self::new(List::empty(), self.reveal())\n     }\n@@ -1618,7 +1626,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     fn item_name_from_def_id(self, def_id: DefId) -> Option<Symbol> {\n         if def_id.index == CRATE_DEF_INDEX {\n-            Some(self.original_crate_name(def_id.krate))\n+            Some(self.crate_name(def_id.krate))\n         } else {\n             let def_key = self.def_key(def_id);\n             match def_key.disambiguated_data.data {\n@@ -1859,20 +1867,11 @@ impl<'tcx> TyCtxt<'tcx> {\n             && use_name\n                 .span\n                 .ctxt()\n-                .hygienic_eq(def_name.span.ctxt(), self.expansion_that_defined(def_parent_def_id))\n-    }\n-\n-    pub fn expansion_that_defined(self, scope: DefId) -> ExpnId {\n-        match scope.as_local() {\n-            // Parsing and expansion aren't incremental, so we don't\n-            // need to go through a query for the same-crate case.\n-            Some(scope) => self.hir().definitions().expansion_that_defined(scope),\n-            None => self.expn_that_defined(scope),\n-        }\n+                .hygienic_eq(def_name.span.ctxt(), self.expn_that_defined(def_parent_def_id))\n     }\n \n     pub fn adjust_ident(self, mut ident: Ident, scope: DefId) -> Ident {\n-        ident.span.normalize_to_macros_2_0_and_adjust(self.expansion_that_defined(scope));\n+        ident.span.normalize_to_macros_2_0_and_adjust(self.expn_that_defined(scope));\n         ident\n     }\n \n@@ -1883,8 +1882,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         block: hir::HirId,\n     ) -> (Ident, DefId) {\n         let scope =\n-            match ident.span.normalize_to_macros_2_0_and_adjust(self.expansion_that_defined(scope))\n-            {\n+            match ident.span.normalize_to_macros_2_0_and_adjust(self.expn_that_defined(scope)) {\n                 Some(actual_expansion) => {\n                     self.hir().definitions().parent_module_of_macro_def(actual_expansion)\n                 }"}, {"sha": "25557bdd1000e7b9164a49007bc589ee64903366", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -452,7 +452,7 @@ pub trait PrettyPrinter<'tcx>:\n             }\n             // Re-exported `extern crate` (#43189).\n             DefPathData::CrateRoot => {\n-                data = DefPathData::TypeNs(self.tcx().original_crate_name(def_id.krate));\n+                data = DefPathData::TypeNs(self.tcx().crate_name(def_id.krate));\n             }\n             _ => {}\n         }"}, {"sha": "297110ee3ecff36950a33be1bd8babb3b86e57cc", "filename": "compiler/rustc_middle/src/ty/query/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fmod.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -34,7 +34,6 @@ use crate::ty::subst::{GenericArg, SubstsRef};\n use crate::ty::util::AlwaysRequiresDrop;\n use crate::ty::{self, AdtSizedConstraint, CrateInherentImpls, ParamEnvAnd, Ty, TyCtxt};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap};\n-use rustc_data_structures::stable_hasher::StableVec;\n use rustc_data_structures::steal::Steal;\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::Lrc;"}, {"sha": "5c42625306bf3aa0296377605d92d516ec38890a", "filename": "compiler/rustc_middle/src/ty/query/on_disk_cache.rs", "status": "modified", "additions": 6, "deletions": 25, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -10,7 +10,7 @@ use rustc_data_structures::thin_vec::ThinVec;\n use rustc_data_structures::unhash::UnhashMap;\n use rustc_errors::Diagnostic;\n use rustc_hir::def_id::{CrateNum, DefId, DefIndex, LocalDefId, LOCAL_CRATE};\n-use rustc_hir::definitions::{DefPathHash, DefPathTable};\n+use rustc_hir::definitions::DefPathHash;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_query_system::dep_graph::DepContext;\n use rustc_query_system::query::QueryContext;\n@@ -27,7 +27,6 @@ use rustc_span::source_map::{SourceMap, StableSourceFileId};\n use rustc_span::CachingSourceMapView;\n use rustc_span::{BytePos, ExpnData, SourceFile, Span, DUMMY_SP};\n use std::collections::hash_map::Entry;\n-use std::iter::FromIterator;\n use std::mem;\n \n const TAG_FILE_FOOTER: u128 = 0xC0FFEE_C0FFEE_C0FFEE_C0FFEE_C0FFEE;\n@@ -103,12 +102,6 @@ pub struct OnDiskCache<'sess> {\n     // during the next compilation session.\n     latest_foreign_def_path_hashes: Lock<UnhashMap<DefPathHash, RawDefId>>,\n \n-    // Maps `DefPathHashes` to their corresponding `LocalDefId`s for all\n-    // local items in the current compilation session. This is only populated\n-    // when we are in incremental mode and have loaded a pre-existing cache\n-    // from disk, since this map is only used when deserializing a `DefPathHash`\n-    // from the incremental cache.\n-    local_def_path_hash_to_def_id: UnhashMap<DefPathHash, LocalDefId>,\n     // Caches all lookups of `DefPathHashes`, both for local and foreign\n     // definitions. A definition from the previous compilation session\n     // may no longer exist in the current compilation session, so\n@@ -168,12 +161,7 @@ crate struct RawDefId {\n \n impl<'sess> OnDiskCache<'sess> {\n     /// Creates a new `OnDiskCache` instance from the serialized data in `data`.\n-    pub fn new(\n-        sess: &'sess Session,\n-        data: Vec<u8>,\n-        start_pos: usize,\n-        def_path_table: &DefPathTable,\n-    ) -> Self {\n+    pub fn new(sess: &'sess Session, data: Vec<u8>, start_pos: usize) -> Self {\n         debug_assert!(sess.opts.incremental.is_some());\n \n         // Wrap in a scope so we can borrow `data`.\n@@ -210,11 +198,6 @@ impl<'sess> OnDiskCache<'sess> {\n             hygiene_context: Default::default(),\n             foreign_def_path_hashes: footer.foreign_def_path_hashes,\n             latest_foreign_def_path_hashes: Default::default(),\n-            local_def_path_hash_to_def_id: UnhashMap::from_iter(\n-                def_path_table\n-                    .all_def_path_hashes_and_def_ids(LOCAL_CRATE)\n-                    .map(|(hash, def_id)| (hash, def_id.as_local().unwrap())),\n-            ),\n             def_path_hash_to_def_id_cache: Default::default(),\n         }\n     }\n@@ -236,7 +219,6 @@ impl<'sess> OnDiskCache<'sess> {\n             hygiene_context: Default::default(),\n             foreign_def_path_hashes: Default::default(),\n             latest_foreign_def_path_hashes: Default::default(),\n-            local_def_path_hash_to_def_id: Default::default(),\n             def_path_hash_to_def_id_cache: Default::default(),\n         }\n     }\n@@ -349,7 +331,7 @@ impl<'sess> OnDiskCache<'sess> {\n             let prev_cnums: Vec<_> = sorted_cnums\n                 .iter()\n                 .map(|&cnum| {\n-                    let crate_name = tcx.original_crate_name(cnum).to_string();\n+                    let crate_name = tcx.crate_name(cnum).to_string();\n                     let crate_disambiguator = tcx.crate_disambiguator(cnum);\n                     (cnum.as_u32(), crate_name, crate_disambiguator)\n                 })\n@@ -582,7 +564,7 @@ impl<'sess> OnDiskCache<'sess> {\n                 .all_crate_nums(())\n                 .iter()\n                 .map(|&cnum| {\n-                    let crate_name = tcx.original_crate_name(cnum).to_string();\n+                    let crate_name = tcx.crate_name(cnum).to_string();\n                     let crate_disambiguator = tcx.crate_disambiguator(cnum);\n                     ((crate_name, crate_disambiguator), cnum)\n                 })\n@@ -616,7 +598,7 @@ impl<'sess> OnDiskCache<'sess> {\n                 debug!(\"def_path_hash_to_def_id({:?})\", hash);\n                 // Check if the `DefPathHash` corresponds to a definition in the current\n                 // crate\n-                if let Some(def_id) = self.local_def_path_hash_to_def_id.get(&hash).cloned() {\n+                if let Some(def_id) = tcx.definitions.local_def_path_hash_to_def_id(hash) {\n                     let def_id = def_id.to_def_id();\n                     e.insert(Some(def_id));\n                     return Some(def_id);\n@@ -758,8 +740,7 @@ impl<'a, 'tcx> TyDecoder<'tcx> for CacheDecoder<'a, 'tcx> {\n     {\n         let tcx = self.tcx();\n \n-        let cache_key =\n-            ty::CReaderCacheKey { cnum: CrateNum::ReservedForIncrCompCache, pos: shorthand };\n+        let cache_key = ty::CReaderCacheKey { cnum: None, pos: shorthand };\n \n         if let Some(&ty) = tcx.ty_rcache.borrow().get(&cache_key) {\n             return Ok(ty);"}, {"sha": "3f426b13688fe94302ca6ffd98c917d5913f0250", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 57, "deletions": 28, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -67,6 +67,7 @@ pub trait TypeRelation<'tcx>: Sized {\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         variance: ty::Variance,\n+        info: ty::VarianceDiagInfo<'tcx>,\n         a: T,\n         b: T,\n     ) -> RelateResult<'tcx, T>;\n@@ -111,24 +112,23 @@ pub trait Relate<'tcx>: TypeFoldable<'tcx> + Copy {\n ///////////////////////////////////////////////////////////////////////////\n // Relate impls\n \n-impl<'tcx> Relate<'tcx> for ty::TypeAndMut<'tcx> {\n-    fn relate<R: TypeRelation<'tcx>>(\n-        relation: &mut R,\n-        a: ty::TypeAndMut<'tcx>,\n-        b: ty::TypeAndMut<'tcx>,\n-    ) -> RelateResult<'tcx, ty::TypeAndMut<'tcx>> {\n-        debug!(\"{}.mts({:?}, {:?})\", relation.tag(), a, b);\n-        if a.mutbl != b.mutbl {\n-            Err(TypeError::Mutability)\n-        } else {\n-            let mutbl = a.mutbl;\n-            let variance = match mutbl {\n-                ast::Mutability::Not => ty::Covariant,\n-                ast::Mutability::Mut => ty::Invariant,\n-            };\n-            let ty = relation.relate_with_variance(variance, a.ty, b.ty)?;\n-            Ok(ty::TypeAndMut { ty, mutbl })\n-        }\n+pub fn relate_type_and_mut<'tcx, R: TypeRelation<'tcx>>(\n+    relation: &mut R,\n+    a: ty::TypeAndMut<'tcx>,\n+    b: ty::TypeAndMut<'tcx>,\n+    kind: ty::VarianceDiagMutKind,\n+) -> RelateResult<'tcx, ty::TypeAndMut<'tcx>> {\n+    debug!(\"{}.mts({:?}, {:?})\", relation.tag(), a, b);\n+    if a.mutbl != b.mutbl {\n+        Err(TypeError::Mutability)\n+    } else {\n+        let mutbl = a.mutbl;\n+        let (variance, info) = match mutbl {\n+            ast::Mutability::Not => (ty::Covariant, ty::VarianceDiagInfo::None),\n+            ast::Mutability::Mut => (ty::Invariant, ty::VarianceDiagInfo::Mut { kind, ty: a.ty }),\n+        };\n+        let ty = relation.relate_with_variance(variance, info, a.ty, b.ty)?;\n+        Ok(ty::TypeAndMut { ty, mutbl })\n     }\n }\n \n@@ -142,7 +142,7 @@ pub fn relate_substs<R: TypeRelation<'tcx>>(\n \n     let params = iter::zip(a_subst, b_subst).enumerate().map(|(i, (a, b))| {\n         let variance = variances.map_or(ty::Invariant, |v| v[i]);\n-        relation.relate_with_variance(variance, a, b)\n+        relation.relate_with_variance(variance, ty::VarianceDiagInfo::default(), a, b)\n     });\n \n     tcx.mk_substs(params)\n@@ -177,7 +177,12 @@ impl<'tcx> Relate<'tcx> for ty::FnSig<'tcx> {\n                 if is_output {\n                     relation.relate(a, b)\n                 } else {\n-                    relation.relate_with_variance(ty::Contravariant, a, b)\n+                    relation.relate_with_variance(\n+                        ty::Contravariant,\n+                        ty::VarianceDiagInfo::default(),\n+                        a,\n+                        b,\n+                    )\n                 }\n             })\n             .enumerate()\n@@ -251,8 +256,18 @@ impl<'tcx> Relate<'tcx> for ty::ExistentialProjection<'tcx> {\n                 b.item_def_id,\n             )))\n         } else {\n-            let ty = relation.relate_with_variance(ty::Invariant, a.ty, b.ty)?;\n-            let substs = relation.relate_with_variance(ty::Invariant, a.substs, b.substs)?;\n+            let ty = relation.relate_with_variance(\n+                ty::Invariant,\n+                ty::VarianceDiagInfo::default(),\n+                a.ty,\n+                b.ty,\n+            )?;\n+            let substs = relation.relate_with_variance(\n+                ty::Invariant,\n+                ty::VarianceDiagInfo::default(),\n+                a.substs,\n+                b.substs,\n+            )?;\n             Ok(ty::ExistentialProjection { item_def_id: a.item_def_id, substs, ty })\n         }\n     }\n@@ -364,7 +379,12 @@ pub fn super_relate_tys<R: TypeRelation<'tcx>>(\n \n         (&ty::Dynamic(a_obj, a_region), &ty::Dynamic(b_obj, b_region)) => {\n             let region_bound = relation.with_cause(Cause::ExistentialRegionBound, |relation| {\n-                relation.relate_with_variance(ty::Contravariant, a_region, b_region)\n+                relation.relate_with_variance(\n+                    ty::Contravariant,\n+                    ty::VarianceDiagInfo::default(),\n+                    a_region,\n+                    b_region,\n+                )\n             })?;\n             Ok(tcx.mk_dynamic(relation.relate(a_obj, b_obj)?, region_bound))\n         }\n@@ -398,15 +418,20 @@ pub fn super_relate_tys<R: TypeRelation<'tcx>>(\n         }\n \n         (&ty::RawPtr(a_mt), &ty::RawPtr(b_mt)) => {\n-            let mt = relation.relate(a_mt, b_mt)?;\n+            let mt = relate_type_and_mut(relation, a_mt, b_mt, ty::VarianceDiagMutKind::RawPtr)?;\n             Ok(tcx.mk_ptr(mt))\n         }\n \n         (&ty::Ref(a_r, a_ty, a_mutbl), &ty::Ref(b_r, b_ty, b_mutbl)) => {\n-            let r = relation.relate_with_variance(ty::Contravariant, a_r, b_r)?;\n+            let r = relation.relate_with_variance(\n+                ty::Contravariant,\n+                ty::VarianceDiagInfo::default(),\n+                a_r,\n+                b_r,\n+            )?;\n             let a_mt = ty::TypeAndMut { ty: a_ty, mutbl: a_mutbl };\n             let b_mt = ty::TypeAndMut { ty: b_ty, mutbl: b_mutbl };\n-            let mt = relation.relate(a_mt, b_mt)?;\n+            let mt = relate_type_and_mut(relation, a_mt, b_mt, ty::VarianceDiagMutKind::Ref)?;\n             Ok(tcx.mk_ref(r, mt))\n         }\n \n@@ -536,8 +561,12 @@ pub fn super_relate_consts<R: TypeRelation<'tcx>>(\n         (ty::ConstKind::Unevaluated(au), ty::ConstKind::Unevaluated(bu))\n             if au.def == bu.def && au.promoted == bu.promoted =>\n         {\n-            let substs =\n-                relation.relate_with_variance(ty::Variance::Invariant, au.substs, bu.substs)?;\n+            let substs = relation.relate_with_variance(\n+                ty::Variance::Invariant,\n+                ty::VarianceDiagInfo::default(),\n+                au.substs,\n+                bu.substs,\n+            )?;\n             return Ok(tcx.mk_const(ty::Const {\n                 val: ty::ConstKind::Unevaluated(ty::Unevaluated {\n                     def: au.def,"}, {"sha": "1d9ff512288db9b05e140f6f4d224fa35b60f36a", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 58, "deletions": 9, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -1837,10 +1837,12 @@ impl<'tcx> TyS<'tcx> {\n \n     #[inline]\n     pub fn is_enum(&self) -> bool {\n-        match self.kind() {\n-            Adt(adt_def, _) => adt_def.is_enum(),\n-            _ => false,\n-        }\n+        matches!(self.kind(), Adt(adt_def, _) if adt_def.is_enum())\n+    }\n+\n+    #[inline]\n+    pub fn is_union(&self) -> bool {\n+        matches!(self.kind(), Adt(adt_def, _) if adt_def.is_union())\n     }\n \n     #[inline]\n@@ -1888,11 +1890,6 @@ impl<'tcx> TyS<'tcx> {\n         matches!(self.kind(), Int(ty::IntTy::Isize) | Uint(ty::UintTy::Usize))\n     }\n \n-    #[inline]\n-    pub fn is_machine(&self) -> bool {\n-        matches!(self.kind(), Int(..) | Uint(..) | Float(..))\n-    }\n-\n     #[inline]\n     pub fn has_concrete_skeleton(&self) -> bool {\n         !matches!(self.kind(), Param(_) | Infer(_) | Error(_))\n@@ -2184,3 +2181,55 @@ impl<'tcx> TyS<'tcx> {\n         }\n     }\n }\n+\n+/// Extra information about why we ended up with a particular variance.\n+/// This is only used to add more information to error messages, and\n+/// has no effect on soundness. While choosing the 'wrong' `VarianceDiagInfo`\n+/// may lead to confusing notes in error messages, it will never cause\n+/// a miscompilation or unsoundness.\n+///\n+/// When in doubt, use `VarianceDiagInfo::default()`\n+#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]\n+pub enum VarianceDiagInfo<'tcx> {\n+    /// No additional information - this is the default.\n+    /// We will not add any additional information to error messages.\n+    None,\n+    /// We switched our variance because a type occurs inside\n+    /// the generic argument of a mutable reference or pointer\n+    /// (`*mut T` or `&mut T`). In either case, our variance\n+    /// will always be `Invariant`.\n+    Mut {\n+        /// Tracks whether we had a mutable pointer or reference,\n+        /// for better error messages\n+        kind: VarianceDiagMutKind,\n+        /// The type parameter of the mutable pointer/reference\n+        /// (the `T` in `&mut T` or `*mut T`).\n+        ty: Ty<'tcx>,\n+    },\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]\n+pub enum VarianceDiagMutKind {\n+    /// A mutable raw pointer (`*mut T`)\n+    RawPtr,\n+    /// A mutable reference (`&mut T`)\n+    Ref,\n+}\n+\n+impl<'tcx> VarianceDiagInfo<'tcx> {\n+    /// Mirrors `Variance::xform` - used to 'combine' the existing\n+    /// and new `VarianceDiagInfo`s when our variance changes.\n+    pub fn xform(self, other: VarianceDiagInfo<'tcx>) -> VarianceDiagInfo<'tcx> {\n+        // For now, just use the first `VarianceDiagInfo::Mut` that we see\n+        match self {\n+            VarianceDiagInfo::None => other,\n+            VarianceDiagInfo::Mut { .. } => self,\n+        }\n+    }\n+}\n+\n+impl<'tcx> Default for VarianceDiagInfo<'tcx> {\n+    fn default() -> Self {\n+        Self::None\n+    }\n+}"}, {"sha": "9e4cfb2cc00fa0f541e51649c229d0c0f18da8fb", "filename": "compiler/rustc_mir/src/borrow_check/constraints/graph.rs", "status": "modified", "additions": 36, "deletions": 32, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fconstraints%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fconstraints%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fconstraints%2Fgraph.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -1,7 +1,7 @@\n use rustc_data_structures::graph;\n use rustc_index::vec::IndexVec;\n use rustc_middle::mir::ConstraintCategory;\n-use rustc_middle::ty::RegionVid;\n+use rustc_middle::ty::{RegionVid, VarianceDiagInfo};\n use rustc_span::DUMMY_SP;\n \n use crate::borrow_check::{\n@@ -26,8 +26,8 @@ crate type ReverseConstraintGraph = ConstraintGraph<Reverse>;\n /// Marker trait that controls whether a `R1: R2` constraint\n /// represents an edge `R1 -> R2` or `R2 -> R1`.\n crate trait ConstraintGraphDirecton: Copy + 'static {\n-    fn start_region(c: &OutlivesConstraint) -> RegionVid;\n-    fn end_region(c: &OutlivesConstraint) -> RegionVid;\n+    fn start_region(c: &OutlivesConstraint<'_>) -> RegionVid;\n+    fn end_region(c: &OutlivesConstraint<'_>) -> RegionVid;\n     fn is_normal() -> bool;\n }\n \n@@ -39,11 +39,11 @@ crate trait ConstraintGraphDirecton: Copy + 'static {\n crate struct Normal;\n \n impl ConstraintGraphDirecton for Normal {\n-    fn start_region(c: &OutlivesConstraint) -> RegionVid {\n+    fn start_region(c: &OutlivesConstraint<'_>) -> RegionVid {\n         c.sup\n     }\n \n-    fn end_region(c: &OutlivesConstraint) -> RegionVid {\n+    fn end_region(c: &OutlivesConstraint<'_>) -> RegionVid {\n         c.sub\n     }\n \n@@ -60,11 +60,11 @@ impl ConstraintGraphDirecton for Normal {\n crate struct Reverse;\n \n impl ConstraintGraphDirecton for Reverse {\n-    fn start_region(c: &OutlivesConstraint) -> RegionVid {\n+    fn start_region(c: &OutlivesConstraint<'_>) -> RegionVid {\n         c.sub\n     }\n \n-    fn end_region(c: &OutlivesConstraint) -> RegionVid {\n+    fn end_region(c: &OutlivesConstraint<'_>) -> RegionVid {\n         c.sup\n     }\n \n@@ -78,7 +78,7 @@ impl<D: ConstraintGraphDirecton> ConstraintGraph<D> {\n     /// R2` is treated as an edge `R1 -> R2`. We use this graph to\n     /// construct SCCs for region inference but also for error\n     /// reporting.\n-    crate fn new(direction: D, set: &OutlivesConstraintSet, num_region_vars: usize) -> Self {\n+    crate fn new(direction: D, set: &OutlivesConstraintSet<'_>, num_region_vars: usize) -> Self {\n         let mut first_constraints = IndexVec::from_elem_n(None, num_region_vars);\n         let mut next_constraints = IndexVec::from_elem(None, &set.outlives);\n \n@@ -96,21 +96,21 @@ impl<D: ConstraintGraphDirecton> ConstraintGraph<D> {\n     /// Given the constraint set from which this graph was built\n     /// creates a region graph so that you can iterate over *regions*\n     /// and not constraints.\n-    crate fn region_graph<'rg>(\n+    crate fn region_graph<'rg, 'tcx>(\n         &'rg self,\n-        set: &'rg OutlivesConstraintSet,\n+        set: &'rg OutlivesConstraintSet<'tcx>,\n         static_region: RegionVid,\n-    ) -> RegionGraph<'rg, D> {\n+    ) -> RegionGraph<'rg, 'tcx, D> {\n         RegionGraph::new(set, self, static_region)\n     }\n \n     /// Given a region `R`, iterate over all constraints `R: R1`.\n-    crate fn outgoing_edges<'a>(\n+    crate fn outgoing_edges<'a, 'tcx>(\n         &'a self,\n         region_sup: RegionVid,\n-        constraints: &'a OutlivesConstraintSet,\n+        constraints: &'a OutlivesConstraintSet<'tcx>,\n         static_region: RegionVid,\n-    ) -> Edges<'a, D> {\n+    ) -> Edges<'a, 'tcx, D> {\n         //if this is the `'static` region and the graph's direction is normal,\n         //then setup the Edges iterator to return all regions #53178\n         if region_sup == static_region && D::is_normal() {\n@@ -129,22 +129,22 @@ impl<D: ConstraintGraphDirecton> ConstraintGraph<D> {\n     }\n }\n \n-crate struct Edges<'s, D: ConstraintGraphDirecton> {\n+crate struct Edges<'s, 'tcx, D: ConstraintGraphDirecton> {\n     graph: &'s ConstraintGraph<D>,\n-    constraints: &'s OutlivesConstraintSet,\n+    constraints: &'s OutlivesConstraintSet<'tcx>,\n     pointer: Option<OutlivesConstraintIndex>,\n     next_static_idx: Option<usize>,\n     static_region: RegionVid,\n }\n \n-impl<'s, D: ConstraintGraphDirecton> Iterator for Edges<'s, D> {\n-    type Item = OutlivesConstraint;\n+impl<'s, 'tcx, D: ConstraintGraphDirecton> Iterator for Edges<'s, 'tcx, D> {\n+    type Item = OutlivesConstraint<'tcx>;\n \n     fn next(&mut self) -> Option<Self::Item> {\n         if let Some(p) = self.pointer {\n             self.pointer = self.graph.next_constraints[p];\n \n-            Some(self.constraints[p])\n+            Some(self.constraints[p].clone())\n         } else if let Some(next_static_idx) = self.next_static_idx {\n             self.next_static_idx = if next_static_idx == (self.graph.first_constraints.len() - 1) {\n                 None\n@@ -157,6 +157,7 @@ impl<'s, D: ConstraintGraphDirecton> Iterator for Edges<'s, D> {\n                 sub: next_static_idx.into(),\n                 locations: Locations::All(DUMMY_SP),\n                 category: ConstraintCategory::Internal,\n+                variance_info: VarianceDiagInfo::default(),\n             })\n         } else {\n             None\n@@ -167,19 +168,19 @@ impl<'s, D: ConstraintGraphDirecton> Iterator for Edges<'s, D> {\n /// This struct brings together a constraint set and a (normal, not\n /// reverse) constraint graph. It implements the graph traits and is\n /// usd for doing the SCC computation.\n-crate struct RegionGraph<'s, D: ConstraintGraphDirecton> {\n-    set: &'s OutlivesConstraintSet,\n+crate struct RegionGraph<'s, 'tcx, D: ConstraintGraphDirecton> {\n+    set: &'s OutlivesConstraintSet<'tcx>,\n     constraint_graph: &'s ConstraintGraph<D>,\n     static_region: RegionVid,\n }\n \n-impl<'s, D: ConstraintGraphDirecton> RegionGraph<'s, D> {\n+impl<'s, 'tcx, D: ConstraintGraphDirecton> RegionGraph<'s, 'tcx, D> {\n     /// Creates a \"dependency graph\" where each region constraint `R1:\n     /// R2` is treated as an edge `R1 -> R2`. We use this graph to\n     /// construct SCCs for region inference but also for error\n     /// reporting.\n     crate fn new(\n-        set: &'s OutlivesConstraintSet,\n+        set: &'s OutlivesConstraintSet<'tcx>,\n         constraint_graph: &'s ConstraintGraph<D>,\n         static_region: RegionVid,\n     ) -> Self {\n@@ -188,42 +189,45 @@ impl<'s, D: ConstraintGraphDirecton> RegionGraph<'s, D> {\n \n     /// Given a region `R`, iterate over all regions `R1` such that\n     /// there exists a constraint `R: R1`.\n-    crate fn outgoing_regions(&self, region_sup: RegionVid) -> Successors<'_, D> {\n+    crate fn outgoing_regions(&self, region_sup: RegionVid) -> Successors<'_, 'tcx, D> {\n         Successors {\n             edges: self.constraint_graph.outgoing_edges(region_sup, self.set, self.static_region),\n         }\n     }\n }\n \n-crate struct Successors<'s, D: ConstraintGraphDirecton> {\n-    edges: Edges<'s, D>,\n+crate struct Successors<'s, 'tcx, D: ConstraintGraphDirecton> {\n+    edges: Edges<'s, 'tcx, D>,\n }\n \n-impl<'s, D: ConstraintGraphDirecton> Iterator for Successors<'s, D> {\n+impl<'s, 'tcx, D: ConstraintGraphDirecton> Iterator for Successors<'s, 'tcx, D> {\n     type Item = RegionVid;\n \n     fn next(&mut self) -> Option<Self::Item> {\n         self.edges.next().map(|c| D::end_region(&c))\n     }\n }\n \n-impl<'s, D: ConstraintGraphDirecton> graph::DirectedGraph for RegionGraph<'s, D> {\n+impl<'s, 'tcx, D: ConstraintGraphDirecton> graph::DirectedGraph for RegionGraph<'s, 'tcx, D> {\n     type Node = RegionVid;\n }\n \n-impl<'s, D: ConstraintGraphDirecton> graph::WithNumNodes for RegionGraph<'s, D> {\n+impl<'s, 'tcx, D: ConstraintGraphDirecton> graph::WithNumNodes for RegionGraph<'s, 'tcx, D> {\n     fn num_nodes(&self) -> usize {\n         self.constraint_graph.first_constraints.len()\n     }\n }\n \n-impl<'s, D: ConstraintGraphDirecton> graph::WithSuccessors for RegionGraph<'s, D> {\n+impl<'s, 'tcx, D: ConstraintGraphDirecton> graph::WithSuccessors for RegionGraph<'s, 'tcx, D> {\n     fn successors(&self, node: Self::Node) -> <Self as graph::GraphSuccessors<'_>>::Iter {\n         self.outgoing_regions(node)\n     }\n }\n \n-impl<'s, 'graph, D: ConstraintGraphDirecton> graph::GraphSuccessors<'graph> for RegionGraph<'s, D> {\n+impl<'s, 'graph, 'tcx, D: ConstraintGraphDirecton> graph::GraphSuccessors<'graph>\n+    for RegionGraph<'s, 'tcx, D>\n+{\n     type Item = RegionVid;\n-    type Iter = Successors<'graph, D>;\n+    // FIXME - why can't this be `'graph, 'tcx`\n+    type Iter = Successors<'graph, 'graph, D>;\n }"}, {"sha": "b944479ca456b387fe7dd23c44e1be17a2840308", "filename": "compiler/rustc_mir/src/borrow_check/constraints/mod.rs", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fconstraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fconstraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fconstraints%2Fmod.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -1,7 +1,7 @@\n use rustc_data_structures::graph::scc::Sccs;\n use rustc_index::vec::IndexVec;\n use rustc_middle::mir::ConstraintCategory;\n-use rustc_middle::ty::RegionVid;\n+use rustc_middle::ty::{RegionVid, VarianceDiagInfo};\n use std::fmt;\n use std::ops::Index;\n \n@@ -14,12 +14,12 @@ crate mod graph;\n /// a unique `OutlivesConstraintIndex` and you can index into the set\n /// (`constraint_set[i]`) to access the constraint details.\n #[derive(Clone, Default)]\n-crate struct OutlivesConstraintSet {\n-    outlives: IndexVec<OutlivesConstraintIndex, OutlivesConstraint>,\n+crate struct OutlivesConstraintSet<'tcx> {\n+    outlives: IndexVec<OutlivesConstraintIndex, OutlivesConstraint<'tcx>>,\n }\n \n-impl OutlivesConstraintSet {\n-    crate fn push(&mut self, constraint: OutlivesConstraint) {\n+impl<'tcx> OutlivesConstraintSet<'tcx> {\n+    crate fn push(&mut self, constraint: OutlivesConstraint<'tcx>) {\n         debug!(\n             \"OutlivesConstraintSet::push({:?}: {:?} @ {:?}\",\n             constraint.sup, constraint.sub, constraint.locations\n@@ -59,21 +59,21 @@ impl OutlivesConstraintSet {\n         Sccs::new(region_graph)\n     }\n \n-    crate fn outlives(&self) -> &IndexVec<OutlivesConstraintIndex, OutlivesConstraint> {\n+    crate fn outlives(&self) -> &IndexVec<OutlivesConstraintIndex, OutlivesConstraint<'tcx>> {\n         &self.outlives\n     }\n }\n \n-impl Index<OutlivesConstraintIndex> for OutlivesConstraintSet {\n-    type Output = OutlivesConstraint;\n+impl<'tcx> Index<OutlivesConstraintIndex> for OutlivesConstraintSet<'tcx> {\n+    type Output = OutlivesConstraint<'tcx>;\n \n     fn index(&self, i: OutlivesConstraintIndex) -> &Self::Output {\n         &self.outlives[i]\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]\n-pub struct OutlivesConstraint {\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]\n+pub struct OutlivesConstraint<'tcx> {\n     // NB. The ordering here is not significant for correctness, but\n     // it is for convenience. Before we dump the constraints in the\n     // debugging logs, we sort them, and we'd like the \"super region\"\n@@ -89,11 +89,18 @@ pub struct OutlivesConstraint {\n \n     /// What caused this constraint?\n     pub category: ConstraintCategory,\n+\n+    /// Variance diagnostic information\n+    pub variance_info: VarianceDiagInfo<'tcx>,\n }\n \n-impl fmt::Debug for OutlivesConstraint {\n+impl<'tcx> fmt::Debug for OutlivesConstraint<'tcx> {\n     fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(formatter, \"({:?}: {:?}) due to {:?}\", self.sup, self.sub, self.locations)\n+        write!(\n+            formatter,\n+            \"({:?}: {:?}) due to {:?} ({:?})\",\n+            self.sup, self.sub, self.locations, self.variance_info\n+        )\n     }\n }\n "}, {"sha": "e9f1ecb9bbc81dec0af6123ecb6402f742d69c55", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/explain_borrow.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -15,6 +15,7 @@ use rustc_middle::ty::{self, RegionVid, TyCtxt};\n use rustc_span::symbol::Symbol;\n use rustc_span::Span;\n \n+use crate::borrow_check::region_infer::BlameConstraint;\n use crate::borrow_check::{\n     borrow_set::BorrowData, nll::ConstraintDescription, region_infer::Cause, MirBorrowckCtxt,\n     WriteKind,\n@@ -289,12 +290,13 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         borrow_region: RegionVid,\n         outlived_region: RegionVid,\n     ) -> (ConstraintCategory, bool, Span, Option<RegionName>) {\n-        let (category, from_closure, span) = self.regioncx.best_blame_constraint(\n-            &self.body,\n-            borrow_region,\n-            NllRegionVariableOrigin::FreeRegion,\n-            |r| self.regioncx.provides_universal_region(r, borrow_region, outlived_region),\n-        );\n+        let BlameConstraint { category, from_closure, span, variance_info: _ } =\n+            self.regioncx.best_blame_constraint(\n+                &self.body,\n+                borrow_region,\n+                NllRegionVariableOrigin::FreeRegion,\n+                |r| self.regioncx.provides_universal_region(r, borrow_region, outlived_region),\n+            );\n \n         let outlived_fr_name = self.give_region_a_name(outlived_region);\n "}, {"sha": "bf5f2c0eec23edc8382fc0819410dd4811600948", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/mutability_errors.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -902,9 +902,13 @@ fn suggest_ampmut<'tcx>(\n             {\n                 let lt_name = &src[1..ws_pos];\n                 let ty = &src[ws_pos..];\n-                return (assignment_rhs_span, format!(\"&{} mut {}\", lt_name, ty));\n+                if !ty.trim_start().starts_with(\"mut\") {\n+                    return (assignment_rhs_span, format!(\"&{} mut {}\", lt_name, ty));\n+                }\n             } else if let Some(stripped) = src.strip_prefix('&') {\n-                return (assignment_rhs_span, format!(\"&mut {}\", stripped));\n+                if !stripped.trim_start().starts_with(\"mut\") {\n+                    return (assignment_rhs_span, format!(\"&mut {}\", stripped));\n+                }\n             }\n         }\n     }"}, {"sha": "feb7672f650ecdd1338e55b04693bd211db9d2b8", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/region_errors.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -13,6 +13,7 @@ use rustc_span::Span;\n \n use crate::util::borrowck_errors;\n \n+use crate::borrow_check::region_infer::BlameConstraint;\n use crate::borrow_check::{\n     nll::ConstraintDescription,\n     region_infer::{values::RegionElement, TypeTest},\n@@ -275,12 +276,12 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     ) {\n         debug!(\"report_region_error(fr={:?}, outlived_fr={:?})\", fr, outlived_fr);\n \n-        let (category, _, span) =\n+        let BlameConstraint { category, span, variance_info, from_closure: _ } =\n             self.regioncx.best_blame_constraint(&self.body, fr, fr_origin, |r| {\n                 self.regioncx.provides_universal_region(r, fr, outlived_fr)\n             });\n \n-        debug!(\"report_region_error: category={:?} {:?}\", category, span);\n+        debug!(\"report_region_error: category={:?} {:?} {:?}\", category, span, variance_info);\n         // Check if we can use one of the \"nice region errors\".\n         if let (Some(f), Some(o)) = (self.to_error_region(fr), self.to_error_region(outlived_fr)) {\n             let nice = NiceRegionError::new_from_span(self.infcx, span, o, f);\n@@ -309,7 +310,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             span,\n         };\n \n-        let diag = match (category, fr_is_local, outlived_fr_is_local) {\n+        let mut diag = match (category, fr_is_local, outlived_fr_is_local) {\n             (ConstraintCategory::Return(kind), true, false) if self.is_closure_fn_mut(fr) => {\n                 self.report_fnmut_error(&errci, kind)\n             }\n@@ -332,6 +333,19 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             }\n         };\n \n+        match variance_info {\n+            ty::VarianceDiagInfo::None => {}\n+            ty::VarianceDiagInfo::Mut { kind, ty } => {\n+                let kind_name = match kind {\n+                    ty::VarianceDiagMutKind::Ref => \"reference\",\n+                    ty::VarianceDiagMutKind::RawPtr => \"pointer\",\n+                };\n+                diag.note(&format!(\"requirement occurs because of a mutable {kind_name} to {ty}\",));\n+                diag.note(&format!(\"mutable {kind_name}s are invariant over their type parameter\"));\n+                diag.help(\"see <https://doc.rust-lang.org/nomicon/subtyping.html> for more information about variance\");\n+            }\n+        }\n+\n         diag.buffer(&mut self.errors_buffer);\n     }\n "}, {"sha": "36eb8a4baa8308f1f7d13a8c81c8f64cb79d57d2", "filename": "compiler/rustc_mir/src/borrow_check/mod.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -1965,13 +1965,11 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 // no move out from an earlier location) then this is an attempt at initialization\n                 // of the union - we should error in that case.\n                 let tcx = this.infcx.tcx;\n-                if let ty::Adt(def, _) = base.ty(this.body(), tcx).ty.kind() {\n-                    if def.is_union() {\n-                        if this.move_data.path_map[mpi].iter().any(|moi| {\n-                            this.move_data.moves[*moi].source.is_predecessor_of(location, this.body)\n-                        }) {\n-                            return;\n-                        }\n+                if base.ty(this.body(), tcx).ty.is_union() {\n+                    if this.move_data.path_map[mpi].iter().any(|moi| {\n+                        this.move_data.moves[*moi].source.is_predecessor_of(location, this.body)\n+                    }) {\n+                        return;\n                     }\n                 }\n "}, {"sha": "bfeafa33a91cfca4e78569b2c78c9234ce9199b9", "filename": "compiler/rustc_mir/src/borrow_check/nll.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fnll.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -1,15 +1,14 @@\n //! The entry point of the NLL borrow checker.\n \n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::vec_map::VecMap;\n use rustc_errors::Diagnostic;\n-use rustc_hir::def_id::DefId;\n use rustc_index::vec::IndexVec;\n use rustc_infer::infer::InferCtxt;\n use rustc_middle::mir::{\n     BasicBlock, Body, ClosureOutlivesSubject, ClosureRegionRequirements, LocalKind, Location,\n     Promoted,\n };\n-use rustc_middle::ty::{self, RegionKind, RegionVid};\n+use rustc_middle::ty::{self, OpaqueTypeKey, RegionKind, RegionVid, Ty};\n use rustc_span::symbol::sym;\n use std::env;\n use std::fmt::Debug;\n@@ -47,7 +46,7 @@ crate type PoloniusOutput = Output<RustcFacts>;\n /// closure requirements to propagate, and any generated errors.\n crate struct NllOutput<'tcx> {\n     pub regioncx: RegionInferenceContext<'tcx>,\n-    pub opaque_type_values: FxHashMap<DefId, ty::ResolvedOpaqueTy<'tcx>>,\n+    pub opaque_type_values: VecMap<OpaqueTypeKey<'tcx>, Ty<'tcx>>,\n     pub polonius_output: Option<Rc<PoloniusOutput>>,\n     pub opt_closure_req: Option<ClosureRegionRequirements<'tcx>>,\n     pub nll_errors: RegionErrors<'tcx>,\n@@ -367,7 +366,7 @@ pub(super) fn dump_annotation<'a, 'tcx>(\n     body: &Body<'tcx>,\n     regioncx: &RegionInferenceContext<'tcx>,\n     closure_region_requirements: &Option<ClosureRegionRequirements<'_>>,\n-    opaque_type_values: &FxHashMap<DefId, ty::ResolvedOpaqueTy<'tcx>>,\n+    opaque_type_values: &VecMap<OpaqueTypeKey<'tcx>, Ty<'tcx>>,\n     errors_buffer: &mut Vec<Diagnostic>,\n ) {\n     let tcx = infcx.tcx;"}, {"sha": "d21550a8e1af60b5bb0564eae081fedc315ea0b8", "filename": "compiler/rustc_mir/src/borrow_check/places_conflict.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fplaces_conflict.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -331,17 +331,14 @@ fn place_projection_conflict<'tcx>(\n                 Overlap::EqualOrDisjoint\n             } else {\n                 let ty = Place::ty_from(pi1_local, pi1_proj_base, body, tcx).ty;\n-                match ty.kind() {\n-                    ty::Adt(def, _) if def.is_union() => {\n-                        // Different fields of a union, we are basically stuck.\n-                        debug!(\"place_element_conflict: STUCK-UNION\");\n-                        Overlap::Arbitrary\n-                    }\n-                    _ => {\n-                        // Different fields of a struct (`a.x` vs. `a.y`). Disjoint!\n-                        debug!(\"place_element_conflict: DISJOINT-FIELD\");\n-                        Overlap::Disjoint\n-                    }\n+                if ty.is_union() {\n+                    // Different fields of a union, we are basically stuck.\n+                    debug!(\"place_element_conflict: STUCK-UNION\");\n+                    Overlap::Arbitrary\n+                } else {\n+                    // Different fields of a struct (`a.x` vs. `a.y`). Disjoint!\n+                    debug!(\"place_element_conflict: DISJOINT-FIELD\");\n+                    Overlap::Disjoint\n                 }\n             }\n         }"}, {"sha": "213ebff12abc0b65940e94f9845232c3c83cfa95", "filename": "compiler/rustc_mir/src/borrow_check/region_infer/dump_mir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fdump_mir.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -74,7 +74,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let mut constraints: Vec<_> = self.constraints.outlives().iter().collect();\n         constraints.sort();\n         for constraint in &constraints {\n-            let OutlivesConstraint { sup, sub, locations, category } = constraint;\n+            let OutlivesConstraint { sup, sub, locations, category, variance_info: _ } = constraint;\n             let (name, arg) = match locations {\n                 Locations::All(span) => {\n                     (\"All\", tcx.sess.source_map().span_to_embeddable_string(*span))"}, {"sha": "b944d74e6f23137b3040974955e291d9ce70e26d", "filename": "compiler/rustc_mir/src/borrow_check/region_infer/graphviz.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fgraphviz.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -35,7 +35,7 @@ struct RawConstraints<'a, 'tcx> {\n \n impl<'a, 'this, 'tcx> dot::Labeller<'this> for RawConstraints<'a, 'tcx> {\n     type Node = RegionVid;\n-    type Edge = OutlivesConstraint;\n+    type Edge = OutlivesConstraint<'tcx>;\n \n     fn graph_id(&'this self) -> dot::Id<'this> {\n         dot::Id::new(\"RegionInferenceContext\").unwrap()\n@@ -49,31 +49,31 @@ impl<'a, 'this, 'tcx> dot::Labeller<'this> for RawConstraints<'a, 'tcx> {\n     fn node_label(&'this self, n: &RegionVid) -> dot::LabelText<'this> {\n         dot::LabelText::LabelStr(format!(\"{:?}\", n).into())\n     }\n-    fn edge_label(&'this self, e: &OutlivesConstraint) -> dot::LabelText<'this> {\n+    fn edge_label(&'this self, e: &OutlivesConstraint<'tcx>) -> dot::LabelText<'this> {\n         dot::LabelText::LabelStr(format!(\"{:?}\", e.locations).into())\n     }\n }\n \n impl<'a, 'this, 'tcx> dot::GraphWalk<'this> for RawConstraints<'a, 'tcx> {\n     type Node = RegionVid;\n-    type Edge = OutlivesConstraint;\n+    type Edge = OutlivesConstraint<'tcx>;\n \n     fn nodes(&'this self) -> dot::Nodes<'this, RegionVid> {\n         let vids: Vec<RegionVid> = self.regioncx.definitions.indices().collect();\n         vids.into()\n     }\n-    fn edges(&'this self) -> dot::Edges<'this, OutlivesConstraint> {\n+    fn edges(&'this self) -> dot::Edges<'this, OutlivesConstraint<'tcx>> {\n         (&self.regioncx.constraints.outlives().raw[..]).into()\n     }\n \n     // Render `a: b` as `a -> b`, indicating the flow\n     // of data during inference.\n \n-    fn source(&'this self, edge: &OutlivesConstraint) -> RegionVid {\n+    fn source(&'this self, edge: &OutlivesConstraint<'tcx>) -> RegionVid {\n         edge.sup\n     }\n \n-    fn target(&'this self, edge: &OutlivesConstraint) -> RegionVid {\n+    fn target(&'this self, edge: &OutlivesConstraint<'tcx>) -> RegionVid {\n         edge.sub\n     }\n }"}, {"sha": "dded7a7e3cf99e47166e2997d7c364369866490e", "filename": "compiler/rustc_mir/src/borrow_check/region_infer/mod.rs", "status": "modified", "additions": 71, "deletions": 36, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fmod.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -54,7 +54,7 @@ pub struct RegionInferenceContext<'tcx> {\n     liveness_constraints: LivenessValues<RegionVid>,\n \n     /// The outlives constraints computed by the type-check.\n-    constraints: Frozen<OutlivesConstraintSet>,\n+    constraints: Frozen<OutlivesConstraintSet<'tcx>>,\n \n     /// The constraint-set, but in graph form, making it easy to traverse\n     /// the constraints adjacent to a particular region. Used to construct\n@@ -227,10 +227,10 @@ enum RegionRelationCheckResult {\n     Error,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-enum Trace {\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+enum Trace<'tcx> {\n     StartRegion,\n-    FromOutlivesConstraint(OutlivesConstraint),\n+    FromOutlivesConstraint(OutlivesConstraint<'tcx>),\n     NotVisited,\n }\n \n@@ -247,7 +247,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         universal_regions: Rc<UniversalRegions<'tcx>>,\n         placeholder_indices: Rc<PlaceholderIndices>,\n         universal_region_relations: Frozen<UniversalRegionRelations<'tcx>>,\n-        outlives_constraints: OutlivesConstraintSet,\n+        outlives_constraints: OutlivesConstraintSet<'tcx>,\n         member_constraints_in: MemberConstraintSet<'tcx, RegionVid>,\n         closure_bounds_mapping: FxHashMap<\n             Location,\n@@ -1750,20 +1750,35 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     crate fn retrieve_closure_constraint_info(\n         &self,\n         body: &Body<'tcx>,\n-        constraint: &OutlivesConstraint,\n-    ) -> (ConstraintCategory, bool, Span) {\n+        constraint: &OutlivesConstraint<'tcx>,\n+    ) -> BlameConstraint<'tcx> {\n         let loc = match constraint.locations {\n-            Locations::All(span) => return (constraint.category, false, span),\n+            Locations::All(span) => {\n+                return BlameConstraint {\n+                    category: constraint.category,\n+                    from_closure: false,\n+                    span,\n+                    variance_info: constraint.variance_info.clone(),\n+                };\n+            }\n             Locations::Single(loc) => loc,\n         };\n \n         let opt_span_category =\n             self.closure_bounds_mapping[&loc].get(&(constraint.sup, constraint.sub));\n-        opt_span_category.map(|&(category, span)| (category, true, span)).unwrap_or((\n-            constraint.category,\n-            false,\n-            body.source_info(loc).span,\n-        ))\n+        opt_span_category\n+            .map(|&(category, span)| BlameConstraint {\n+                category,\n+                from_closure: true,\n+                span: span,\n+                variance_info: constraint.variance_info.clone(),\n+            })\n+            .unwrap_or(BlameConstraint {\n+                category: constraint.category,\n+                from_closure: false,\n+                span: body.source_info(loc).span,\n+                variance_info: constraint.variance_info.clone(),\n+            })\n     }\n \n     /// Finds a good span to blame for the fact that `fr1` outlives `fr2`.\n@@ -1774,9 +1789,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         fr1_origin: NllRegionVariableOrigin,\n         fr2: RegionVid,\n     ) -> (ConstraintCategory, Span) {\n-        let (category, _, span) = self.best_blame_constraint(body, fr1, fr1_origin, |r| {\n-            self.provides_universal_region(r, fr1, fr2)\n-        });\n+        let BlameConstraint { category, span, .. } =\n+            self.best_blame_constraint(body, fr1, fr1_origin, |r| {\n+                self.provides_universal_region(r, fr1, fr2)\n+            });\n         (category, span)\n     }\n \n@@ -1792,7 +1808,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &self,\n         from_region: RegionVid,\n         target_test: impl Fn(RegionVid) -> bool,\n-    ) -> Option<(Vec<OutlivesConstraint>, RegionVid)> {\n+    ) -> Option<(Vec<OutlivesConstraint<'tcx>>, RegionVid)> {\n         let mut context = IndexVec::from_elem(Trace::NotVisited, &self.definitions);\n         context[from_region] = Trace::StartRegion;\n \n@@ -1816,14 +1832,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 let mut result = vec![];\n                 let mut p = r;\n                 loop {\n-                    match context[p] {\n+                    match context[p].clone() {\n                         Trace::NotVisited => {\n                             bug!(\"found unvisited region {:?} on path to {:?}\", p, r)\n                         }\n \n                         Trace::FromOutlivesConstraint(c) => {\n-                            result.push(c);\n                             p = c.sup;\n+                            result.push(c);\n                         }\n \n                         Trace::StartRegion => {\n@@ -1846,7 +1862,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n             // Always inline this closure because it can be hot.\n             let mut handle_constraint = #[inline(always)]\n-            |constraint: OutlivesConstraint| {\n+            |constraint: OutlivesConstraint<'tcx>| {\n                 debug_assert_eq!(constraint.sup, r);\n                 let sub_region = constraint.sub;\n                 if let Trace::NotVisited = context[sub_region] {\n@@ -1870,6 +1886,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     sub: constraint.min_choice,\n                     locations: Locations::All(p_c.definition_span),\n                     category: ConstraintCategory::OpaqueType,\n+                    variance_info: ty::VarianceDiagInfo::default(),\n                 };\n                 handle_constraint(constraint);\n             }\n@@ -1967,7 +1984,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         from_region: RegionVid,\n         from_region_origin: NllRegionVariableOrigin,\n         target_test: impl Fn(RegionVid) -> bool,\n-    ) -> (ConstraintCategory, bool, Span) {\n+    ) -> BlameConstraint<'tcx> {\n         debug!(\n             \"best_blame_constraint(from_region={:?}, from_region_origin={:?})\",\n             from_region, from_region_origin\n@@ -1979,7 +1996,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         debug!(\n             \"best_blame_constraint: path={:#?}\",\n             path.iter()\n-                .map(|&c| format!(\n+                .map(|c| format!(\n                     \"{:?} ({:?}: {:?})\",\n                     c,\n                     self.constraint_sccs.scc(c.sup),\n@@ -1989,13 +2006,18 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         );\n \n         // Classify each of the constraints along the path.\n-        let mut categorized_path: Vec<(ConstraintCategory, bool, Span)> = path\n+        let mut categorized_path: Vec<BlameConstraint<'tcx>> = path\n             .iter()\n             .map(|constraint| {\n                 if constraint.category == ConstraintCategory::ClosureBounds {\n                     self.retrieve_closure_constraint_info(body, &constraint)\n                 } else {\n-                    (constraint.category, false, constraint.locations.span(body))\n+                    BlameConstraint {\n+                        category: constraint.category,\n+                        from_closure: false,\n+                        span: constraint.locations.span(body),\n+                        variance_info: constraint.variance_info.clone(),\n+                    }\n                 }\n             })\n             .collect();\n@@ -2067,12 +2089,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         };\n \n         let find_region = |i: &usize| {\n-            let constraint = path[*i];\n+            let constraint = &path[*i];\n \n             let constraint_sup_scc = self.constraint_sccs.scc(constraint.sup);\n \n             if blame_source {\n-                match categorized_path[*i].0 {\n+                match categorized_path[*i].category {\n                     ConstraintCategory::OpaqueType\n                     | ConstraintCategory::Boring\n                     | ConstraintCategory::BoringNoLocation\n@@ -2083,7 +2105,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     _ => constraint_sup_scc != target_scc,\n                 }\n             } else {\n-                match categorized_path[*i].0 {\n+                match categorized_path[*i].category {\n                     ConstraintCategory::OpaqueType\n                     | ConstraintCategory::Boring\n                     | ConstraintCategory::BoringNoLocation\n@@ -2103,37 +2125,42 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         if let Some(i) = best_choice {\n             if let Some(next) = categorized_path.get(i + 1) {\n-                if matches!(categorized_path[i].0, ConstraintCategory::Return(_))\n-                    && next.0 == ConstraintCategory::OpaqueType\n+                if matches!(categorized_path[i].category, ConstraintCategory::Return(_))\n+                    && next.category == ConstraintCategory::OpaqueType\n                 {\n                     // The return expression is being influenced by the return type being\n                     // impl Trait, point at the return type and not the return expr.\n-                    return *next;\n+                    return next.clone();\n                 }\n             }\n \n-            if categorized_path[i].0 == ConstraintCategory::Return(ReturnConstraint::Normal) {\n+            if categorized_path[i].category == ConstraintCategory::Return(ReturnConstraint::Normal)\n+            {\n                 let field = categorized_path.iter().find_map(|p| {\n-                    if let ConstraintCategory::ClosureUpvar(f) = p.0 { Some(f) } else { None }\n+                    if let ConstraintCategory::ClosureUpvar(f) = p.category {\n+                        Some(f)\n+                    } else {\n+                        None\n+                    }\n                 });\n \n                 if let Some(field) = field {\n-                    categorized_path[i].0 =\n+                    categorized_path[i].category =\n                         ConstraintCategory::Return(ReturnConstraint::ClosureUpvar(field));\n                 }\n             }\n \n-            return categorized_path[i];\n+            return categorized_path[i].clone();\n         }\n \n         // If that search fails, that is.. unusual. Maybe everything\n         // is in the same SCC or something. In that case, find what\n         // appears to be the most interesting point to report to the\n         // user via an even more ad-hoc guess.\n-        categorized_path.sort_by(|p0, p1| p0.0.cmp(&p1.0));\n+        categorized_path.sort_by(|p0, p1| p0.category.cmp(&p1.category));\n         debug!(\"`: sorted_path={:#?}\", categorized_path);\n \n-        *categorized_path.first().unwrap()\n+        categorized_path.remove(0)\n     }\n }\n \n@@ -2228,3 +2255,11 @@ impl<'tcx> ClosureRegionRequirementsExt<'tcx> for ClosureRegionRequirements<'tcx\n             .collect()\n     }\n }\n+\n+#[derive(Clone, Debug)]\n+pub struct BlameConstraint<'tcx> {\n+    pub category: ConstraintCategory,\n+    pub from_closure: bool,\n+    pub span: Span,\n+    pub variance_info: ty::VarianceDiagInfo<'tcx>,\n+}"}, {"sha": "3ec24156f223717f0d63438e852fc1bfe87c35a7", "filename": "compiler/rustc_mir/src/borrow_check/region_infer/opaque_types.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fopaque_types.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -1,7 +1,6 @@\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_hir::def_id::DefId;\n+use rustc_data_structures::vec_map::VecMap;\n use rustc_infer::infer::InferCtxt;\n-use rustc_middle::ty::{self, TyCtxt, TypeFoldable};\n+use rustc_middle::ty::{self, OpaqueTypeKey, Ty, TyCtxt, TypeFoldable};\n use rustc_span::Span;\n use rustc_trait_selection::opaque_types::InferCtxtExt;\n \n@@ -51,12 +50,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     pub(in crate::borrow_check) fn infer_opaque_types(\n         &self,\n         infcx: &InferCtxt<'_, 'tcx>,\n-        opaque_ty_decls: FxHashMap<DefId, ty::ResolvedOpaqueTy<'tcx>>,\n+        opaque_ty_decls: VecMap<OpaqueTypeKey<'tcx>, Ty<'tcx>>,\n         span: Span,\n-    ) -> FxHashMap<DefId, ty::ResolvedOpaqueTy<'tcx>> {\n+    ) -> VecMap<OpaqueTypeKey<'tcx>, Ty<'tcx>> {\n         opaque_ty_decls\n             .into_iter()\n-            .map(|(opaque_def_id, ty::ResolvedOpaqueTy { concrete_type, substs })| {\n+            .map(|(opaque_type_key, concrete_type)| {\n+                let substs = opaque_type_key.substs;\n                 debug!(?concrete_type, ?substs);\n \n                 let mut subst_regions = vec![self.universal_regions.fr_static];\n@@ -110,16 +110,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n                 debug!(?universal_concrete_type, ?universal_substs);\n \n+                let opaque_type_key =\n+                    OpaqueTypeKey { def_id: opaque_type_key.def_id, substs: universal_substs };\n                 let remapped_type = infcx.infer_opaque_definition_from_instantiation(\n-                    opaque_def_id,\n-                    universal_substs,\n+                    opaque_type_key,\n                     universal_concrete_type,\n                     span,\n                 );\n-                (\n-                    opaque_def_id,\n-                    ty::ResolvedOpaqueTy { concrete_type: remapped_type, substs: universal_substs },\n-                )\n+                (opaque_type_key, remapped_type)\n             })\n             .collect()\n     }"}, {"sha": "eb11b9371433d145a24cac55f8738877d39ecb25", "filename": "compiler/rustc_mir/src/borrow_check/type_check/constraint_conversion.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fconstraint_conversion.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -143,6 +143,7 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n             category: self.category,\n             sub,\n             sup,\n+            variance_info: ty::VarianceDiagInfo::default(),\n         });\n     }\n "}, {"sha": "a34ae281b70dfdd547ed652226264299e0f37a1f", "filename": "compiler/rustc_mir/src/borrow_check/type_check/liveness/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fliveness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fliveness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fliveness%2Fmod.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -107,7 +107,7 @@ fn compute_live_locals(\n fn regions_that_outlive_free_regions(\n     num_region_vars: usize,\n     universal_regions: &UniversalRegions<'tcx>,\n-    constraint_set: &OutlivesConstraintSet,\n+    constraint_set: &OutlivesConstraintSet<'tcx>,\n ) -> FxHashSet<RegionVid> {\n     // Build a graph of the outlives constraints thus far. This is\n     // a reverse graph, so for each constraint `R1: R2` we have an"}, {"sha": "09cafddeeffde9213c4f1997e3f4fe69b6d5fdc7", "filename": "compiler/rustc_mir/src/borrow_check/type_check/mod.rs", "status": "modified", "additions": 27, "deletions": 29, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -7,9 +7,10 @@ use either::Either;\n \n use rustc_data_structures::frozen::Frozen;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::vec_map::VecMap;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n-use rustc_hir::def_id::{DefId, LocalDefId};\n+use rustc_hir::def_id::LocalDefId;\n use rustc_hir::lang_items::LangItem;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_infer::infer::canonical::QueryRegionConstraints;\n@@ -27,8 +28,8 @@ use rustc_middle::ty::cast::CastTy;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::subst::{GenericArgKind, Subst, SubstsRef, UserSubsts};\n use rustc_middle::ty::{\n-    self, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations, RegionVid, ToPredicate, Ty,\n-    TyCtxt, UserType, UserTypeAnnotationIndex, WithConstness,\n+    self, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations, OpaqueTypeKey, RegionVid,\n+    ToPredicate, Ty, TyCtxt, UserType, UserTypeAnnotationIndex, WithConstness,\n };\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi::VariantIdx;\n@@ -226,7 +227,7 @@ fn translate_outlives_facts(typeck: &mut TypeChecker<'_, '_>) {\n         let _prof_timer = typeck.infcx.tcx.prof.generic_activity(\"polonius_fact_generation\");\n         let location_table = cx.location_table;\n         facts.outlives.extend(cx.constraints.outlives_constraints.outlives().iter().flat_map(\n-            |constraint: &OutlivesConstraint| {\n+            |constraint: &OutlivesConstraint<'_>| {\n                 if let Some(from_location) = constraint.locations.from_location() {\n                     Either::Left(iter::once((\n                         constraint.sup,\n@@ -572,7 +573,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n \n         let locations = location.to_locations();\n         for constraint in constraints.outlives().iter() {\n-            let mut constraint = *constraint;\n+            let mut constraint = constraint.clone();\n             constraint.locations = locations;\n             if let ConstraintCategory::Return(_)\n             | ConstraintCategory::UseAsConst\n@@ -818,7 +819,7 @@ struct TypeChecker<'a, 'tcx> {\n     reported_errors: FxHashSet<(Ty<'tcx>, Span)>,\n     borrowck_context: &'a mut BorrowCheckContext<'a, 'tcx>,\n     universal_region_relations: &'a UniversalRegionRelations<'tcx>,\n-    opaque_type_values: FxHashMap<DefId, ty::ResolvedOpaqueTy<'tcx>>,\n+    opaque_type_values: VecMap<OpaqueTypeKey<'tcx>, Ty<'tcx>>,\n }\n \n struct BorrowCheckContext<'a, 'tcx> {\n@@ -833,7 +834,7 @@ struct BorrowCheckContext<'a, 'tcx> {\n crate struct MirTypeckResults<'tcx> {\n     crate constraints: MirTypeckRegionConstraints<'tcx>,\n     pub(in crate::borrow_check) universal_region_relations: Frozen<UniversalRegionRelations<'tcx>>,\n-    crate opaque_type_values: FxHashMap<DefId, ty::ResolvedOpaqueTy<'tcx>>,\n+    crate opaque_type_values: VecMap<OpaqueTypeKey<'tcx>, Ty<'tcx>>,\n }\n \n /// A collection of region constraints that must be satisfied for the\n@@ -862,7 +863,7 @@ crate struct MirTypeckRegionConstraints<'tcx> {\n     /// hence it must report on their liveness constraints.\n     crate liveness_constraints: LivenessValues<RegionVid>,\n \n-    crate outlives_constraints: OutlivesConstraintSet,\n+    crate outlives_constraints: OutlivesConstraintSet<'tcx>,\n \n     crate member_constraints: MemberConstraintSet<'tcx, RegionVid>,\n \n@@ -978,7 +979,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             borrowck_context,\n             reported_errors: Default::default(),\n             universal_region_relations,\n-            opaque_type_values: FxHashMap::default(),\n+            opaque_type_values: VecMap::default(),\n         };\n         checker.check_user_type_annotations();\n         checker\n@@ -1240,7 +1241,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         let param_env = self.param_env;\n         let body = self.body;\n         let concrete_opaque_types = &tcx.typeck(anon_owner_def_id).concrete_opaque_types;\n-        let mut opaque_type_values = Vec::new();\n+        let mut opaque_type_values = VecMap::new();\n \n         debug!(\"eq_opaque_type_and_type: mir_def_id={:?}\", body.source.def_id());\n         let opaque_type_map = self.fully_perform_op(\n@@ -1281,37 +1282,39 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                             .eq(output_ty, revealed_ty)?,\n                     );\n \n-                    for (&opaque_def_id, opaque_decl) in &opaque_type_map {\n+                    for &(opaque_type_key, opaque_decl) in &opaque_type_map {\n                         let resolved_ty = infcx.resolve_vars_if_possible(opaque_decl.concrete_ty);\n                         let concrete_is_opaque = if let ty::Opaque(def_id, _) = resolved_ty.kind() {\n-                            *def_id == opaque_def_id\n+                            *def_id == opaque_type_key.def_id\n                         } else {\n                             false\n                         };\n-                        let opaque_defn_ty = match concrete_opaque_types.get(&opaque_def_id) {\n+\n+                        let concrete_ty = match concrete_opaque_types\n+                            .get_by(|(key, _)| key.def_id == opaque_type_key.def_id)\n+                        {\n                             None => {\n                                 if !concrete_is_opaque {\n                                     tcx.sess.delay_span_bug(\n                                         body.span,\n                                         &format!(\n                                             \"Non-defining use of {:?} with revealed type\",\n-                                            opaque_def_id,\n+                                            opaque_type_key.def_id,\n                                         ),\n                                     );\n                                 }\n                                 continue;\n                             }\n-                            Some(opaque_defn_ty) => opaque_defn_ty,\n+                            Some(concrete_ty) => concrete_ty,\n                         };\n-                        debug!(\"opaque_defn_ty = {:?}\", opaque_defn_ty);\n-                        let subst_opaque_defn_ty =\n-                            opaque_defn_ty.concrete_type.subst(tcx, opaque_decl.substs);\n+                        debug!(\"concrete_ty = {:?}\", concrete_ty);\n+                        let subst_opaque_defn_ty = concrete_ty.subst(tcx, opaque_type_key.substs);\n                         let renumbered_opaque_defn_ty =\n                             renumber::renumber_regions(infcx, subst_opaque_defn_ty);\n \n                         debug!(\n                             \"eq_opaque_type_and_type: concrete_ty={:?}={:?} opaque_defn_ty={:?}\",\n-                            opaque_decl.concrete_ty, resolved_ty, renumbered_opaque_defn_ty,\n+                            concrete_ty, resolved_ty, renumbered_opaque_defn_ty,\n                         );\n \n                         if !concrete_is_opaque {\n@@ -1322,13 +1325,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                                     .at(&ObligationCause::dummy(), param_env)\n                                     .eq(opaque_decl.concrete_ty, renumbered_opaque_defn_ty)?,\n                             );\n-                            opaque_type_values.push((\n-                                opaque_def_id,\n-                                ty::ResolvedOpaqueTy {\n-                                    concrete_type: renumbered_opaque_defn_ty,\n-                                    substs: opaque_decl.substs,\n-                                },\n-                            ));\n+                            opaque_type_values.insert(opaque_type_key, renumbered_opaque_defn_ty);\n                         } else {\n                             // We're using an opaque `impl Trait` type without\n                             // 'revealing' it. For example, code like this:\n@@ -1351,7 +1348,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                             // gets 'revealed' into\n                             debug!(\n                                 \"eq_opaque_type_and_type: non-defining use of {:?}\",\n-                                opaque_def_id,\n+                                opaque_type_key.def_id,\n                             );\n                         }\n                     }\n@@ -1376,14 +1373,14 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         // prove that `T: Iterator` where `T` is the type we\n         // instantiated it with).\n         if let Some(opaque_type_map) = opaque_type_map {\n-            for (opaque_def_id, opaque_decl) in opaque_type_map {\n+            for (opaque_type_key, opaque_decl) in opaque_type_map {\n                 self.fully_perform_op(\n                     locations,\n                     ConstraintCategory::OpaqueType,\n                     CustomTypeOp::new(\n                         |_cx| {\n                             infcx.constrain_opaque_type(\n-                                opaque_def_id,\n+                                opaque_type_key,\n                                 &opaque_decl,\n                                 GenerateMemberConstraints::IfNoStaticBound,\n                                 universal_region_relations,\n@@ -2535,6 +2532,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                                 sub: borrow_region.to_region_vid(),\n                                 locations: location.to_locations(),\n                                 category,\n+                                variance_info: ty::VarianceDiagInfo::default(),\n                             });\n \n                             match mutbl {"}, {"sha": "f97252a117a6f018eec4cc881f37a39ceb94f727", "filename": "compiler/rustc_mir/src/borrow_check/type_check/relate_tys.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Frelate_tys.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -94,7 +94,12 @@ impl TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx> {\n         )\n     }\n \n-    fn push_outlives(&mut self, sup: ty::Region<'tcx>, sub: ty::Region<'tcx>) {\n+    fn push_outlives(\n+        &mut self,\n+        sup: ty::Region<'tcx>,\n+        sub: ty::Region<'tcx>,\n+        info: ty::VarianceDiagInfo<'tcx>,\n+    ) {\n         if let Some(borrowck_context) = &mut self.borrowck_context {\n             let sub = borrowck_context.universal_regions.to_region_vid(sub);\n             let sup = borrowck_context.universal_regions.to_region_vid(sup);\n@@ -103,6 +108,7 @@ impl TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx> {\n                 sub,\n                 locations: self.locations,\n                 category: self.category,\n+                variance_info: info,\n             });\n         }\n     }"}, {"sha": "fc21047ab72ff3a02d040a757f4f82ed1a04907a", "filename": "compiler/rustc_mir/src/const_eval/error.rs", "status": "modified", "additions": 56, "deletions": 52, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Ferror.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -9,7 +9,7 @@ use rustc_span::{Span, Symbol};\n \n use super::InterpCx;\n use crate::interpret::{\n-    struct_error, ErrorHandled, FrameInfo, InterpError, InterpErrorInfo, Machine,\n+    struct_error, ErrorHandled, FrameInfo, InterpError, InterpErrorInfo, Machine, MachineStopType,\n };\n \n /// The CTFE machine has some custom error kinds.\n@@ -24,12 +24,21 @@ pub enum ConstEvalErrKind {\n     Abort(String),\n }\n \n+impl MachineStopType for ConstEvalErrKind {\n+    fn is_hard_err(&self) -> bool {\n+        match self {\n+            Self::Panic { .. } => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n // The errors become `MachineStop` with plain strings when being raised.\n // `ConstEvalErr` (in `librustc_middle/mir/interpret/error.rs`) knows to\n // handle these.\n impl<'tcx> Into<InterpErrorInfo<'tcx>> for ConstEvalErrKind {\n     fn into(self) -> InterpErrorInfo<'tcx> {\n-        err_machine_stop!(self.to_string()).into()\n+        err_machine_stop!(self).into()\n     }\n }\n \n@@ -148,31 +157,10 @@ impl<'tcx> ConstEvalErr<'tcx> {\n         tcx: TyCtxtAt<'tcx>,\n         message: &str,\n         emit: impl FnOnce(DiagnosticBuilder<'_>),\n-        lint_root: Option<hir::HirId>,\n+        mut lint_root: Option<hir::HirId>,\n     ) -> ErrorHandled {\n-        let must_error = match self.error {\n-            err_inval!(Layout(LayoutError::Unknown(_))) | err_inval!(TooGeneric) => {\n-                return ErrorHandled::TooGeneric;\n-            }\n-            err_inval!(AlreadyReported(error_reported)) => {\n-                return ErrorHandled::Reported(error_reported);\n-            }\n-            // We must *always* hard error on these, even if the caller wants just a lint.\n-            err_inval!(Layout(LayoutError::SizeOverflow(_))) => true,\n-            _ => false,\n-        };\n-        trace!(\"reporting const eval failure at {:?}\", self.span);\n-\n-        let err_msg = match &self.error {\n-            InterpError::MachineStop(msg) => {\n-                // A custom error (`ConstEvalErrKind` in `librustc_mir/interp/const_eval/error.rs`).\n-                // Should be turned into a string by now.\n-                msg.downcast_ref::<String>().expect(\"invalid MachineStop payload\").clone()\n-            }\n-            err => err.to_string(),\n-        };\n-\n         let finish = |mut err: DiagnosticBuilder<'_>, span_msg: Option<String>| {\n+            trace!(\"reporting const eval failure at {:?}\", self.span);\n             if let Some(span_msg) = span_msg {\n                 err.span_label(self.span, span_msg);\n             }\n@@ -186,34 +174,50 @@ impl<'tcx> ConstEvalErr<'tcx> {\n             emit(err)\n         };\n \n-        if must_error {\n-            // The `message` makes little sense here, this is a more serious error than the\n-            // caller thinks anyway.\n-            // See <https://github.com/rust-lang/rust/pull/63152>.\n-            finish(struct_error(tcx, &err_msg), None);\n-            ErrorHandled::Reported(ErrorReported)\n-        } else {\n-            // Regular case.\n-            if let Some(lint_root) = lint_root {\n-                // Report as lint.\n-                let hir_id = self\n-                    .stacktrace\n-                    .iter()\n-                    .rev()\n-                    .find_map(|frame| frame.lint_root)\n-                    .unwrap_or(lint_root);\n-                tcx.struct_span_lint_hir(\n-                    rustc_session::lint::builtin::CONST_ERR,\n-                    hir_id,\n-                    tcx.span,\n-                    |lint| finish(lint.build(message), Some(err_msg)),\n-                );\n-                ErrorHandled::Linted\n-            } else {\n-                // Report as hard error.\n-                finish(struct_error(tcx, message), Some(err_msg));\n-                ErrorHandled::Reported(ErrorReported)\n+        // Special handling for certain errors\n+        match &self.error {\n+            // Don't emit a new diagnostic for these errors\n+            err_inval!(Layout(LayoutError::Unknown(_))) | err_inval!(TooGeneric) => {\n+                return ErrorHandled::TooGeneric;\n+            }\n+            err_inval!(AlreadyReported(error_reported)) => {\n+                return ErrorHandled::Reported(*error_reported);\n+            }\n+            err_inval!(Layout(LayoutError::SizeOverflow(_))) => {\n+                // We must *always* hard error on these, even if the caller wants just a lint.\n+                // The `message` makes little sense here, this is a more serious error than the\n+                // caller thinks anyway.\n+                // See <https://github.com/rust-lang/rust/pull/63152>.\n+                finish(struct_error(tcx, &self.error.to_string()), None);\n+                return ErrorHandled::Reported(ErrorReported);\n             }\n+            _ => {}\n+        };\n+\n+        // If we have a 'hard error', then set `lint_root` to `None` so that we don't\n+        // emit a lint.\n+        if matches!(&self.error, InterpError::MachineStop(err) if err.is_hard_err()) {\n+            lint_root = None;\n+        }\n+\n+        let err_msg = self.error.to_string();\n+\n+        // Regular case - emit a lint.\n+        if let Some(lint_root) = lint_root {\n+            // Report as lint.\n+            let hir_id =\n+                self.stacktrace.iter().rev().find_map(|frame| frame.lint_root).unwrap_or(lint_root);\n+            tcx.struct_span_lint_hir(\n+                rustc_session::lint::builtin::CONST_ERR,\n+                hir_id,\n+                tcx.span,\n+                |lint| finish(lint.build(message), Some(err_msg)),\n+            );\n+            ErrorHandled::Linted\n+        } else {\n+            // Report as hard error.\n+            finish(struct_error(tcx, message), Some(err_msg));\n+            ErrorHandled::Reported(ErrorReported)\n         }\n     }\n }"}, {"sha": "cea465ea1ed9dc423045c5a80d5ffed630310173", "filename": "compiler/rustc_mir/src/dataflow/move_paths/builder.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -519,10 +519,8 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n         // Check if we are assigning into a field of a union, if so, lookup the place\n         // of the union so it is marked as initialized again.\n         if let Some((place_base, ProjectionElem::Field(_, _))) = place.last_projection() {\n-            if let ty::Adt(def, _) = place_base.ty(self.builder.body, self.builder.tcx).ty.kind() {\n-                if def.is_union() {\n-                    place = place_base;\n-                }\n+            if place_base.ty(self.builder.body, self.builder.tcx).ty.is_union() {\n+                place = place_base;\n             }\n         }\n "}, {"sha": "4e4166dad50e29b83c7b49c00905fe344941f659", "filename": "compiler/rustc_mir/src/interpret/intrinsics.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -56,8 +56,12 @@ crate fn eval_nullary_intrinsic<'tcx>(\n             let alloc = type_name::alloc_type_name(tcx, tp_ty);\n             ConstValue::Slice { data: alloc, start: 0, end: alloc.len() }\n         }\n-        sym::needs_drop => ConstValue::from_bool(tp_ty.needs_drop(tcx, param_env)),\n+        sym::needs_drop => {\n+            ensure_monomorphic_enough(tcx, tp_ty)?;\n+            ConstValue::from_bool(tp_ty.needs_drop(tcx, param_env))\n+        }\n         sym::min_align_of | sym::pref_align_of => {\n+            // Correctly handles non-monomorphic calls, so there is no need for ensure_monomorphic_enough.\n             let layout = tcx.layout_of(param_env.and(tp_ty)).map_err(|e| err_inval!(Layout(e)))?;\n             let n = match name {\n                 sym::pref_align_of => layout.align.pref.bytes(),\n@@ -71,6 +75,7 @@ crate fn eval_nullary_intrinsic<'tcx>(\n             ConstValue::from_u64(tcx.type_id_hash(tp_ty))\n         }\n         sym::variant_count => match tp_ty.kind() {\n+            // Correctly handles non-monomorphic calls, so there is no need for ensure_monomorphic_enough.\n             ty::Adt(ref adt, _) => ConstValue::from_machine_usize(adt.variants.len() as u64, &tcx),\n             ty::Projection(_)\n             | ty::Opaque(_, _)"}, {"sha": "a7012cd63f313059b270808ebea4cc8fe6d16c8d", "filename": "compiler/rustc_mir/src/interpret/intrinsics/type_name.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics%2Ftype_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics%2Ftype_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics%2Ftype_name.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -1,5 +1,5 @@\n use rustc_hir::def_id::CrateNum;\n-use rustc_hir::definitions::{DefPathData, DisambiguatedDefPathData};\n+use rustc_hir::definitions::DisambiguatedDefPathData;\n use rustc_middle::mir::interpret::Allocation;\n use rustc_middle::ty::{\n     self,\n@@ -88,7 +88,7 @@ impl<'tcx> Printer<'tcx> for AbsolutePathPrinter<'tcx> {\n     }\n \n     fn path_crate(mut self, cnum: CrateNum) -> Result<Self::Path, Self::Error> {\n-        self.path.push_str(&self.tcx.original_crate_name(cnum).as_str());\n+        self.path.push_str(&self.tcx.crate_name(cnum).as_str());\n         Ok(self)\n     }\n \n@@ -127,11 +127,6 @@ impl<'tcx> Printer<'tcx> for AbsolutePathPrinter<'tcx> {\n     ) -> Result<Self::Path, Self::Error> {\n         self = print_prefix(self)?;\n \n-        // Skip `::{{constructor}}` on tuple/unit structs.\n-        if disambiguated_data.data == DefPathData::Ctor {\n-            return Ok(self);\n-        }\n-\n         write!(self.path, \"::{}\", disambiguated_data.data).unwrap();\n \n         Ok(self)"}, {"sha": "d0c04b5b414ebf3feb235ad9fb90899b4e78d35b", "filename": "compiler/rustc_mir/src/interpret/traits.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Ftraits.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -158,13 +158,15 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let size = u64::try_from(self.force_bits(size, pointer_size)?).unwrap();\n         let align = vtable.read_ptr_sized(pointer_size * 2)?.check_init()?;\n         let align = u64::try_from(self.force_bits(align, pointer_size)?).unwrap();\n+        let align = Align::from_bytes(align)\n+            .map_err(|e| err_ub_format!(\"invalid vtable: alignment {}\", e))?;\n \n         if size >= self.tcx.data_layout.obj_size_bound() {\n             throw_ub_format!(\n                 \"invalid vtable: \\\n                 size is bigger than largest supported object\"\n             );\n         }\n-        Ok((Size::from_bytes(size), Align::from_bytes(align).unwrap()))\n+        Ok((Size::from_bytes(size), align))\n     }\n }"}, {"sha": "1da17bddcb777c3b044f4160beb686b8fddf4172", "filename": "compiler/rustc_mir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Flib.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -12,16 +12,14 @@ Rust MIR: a lowered representation of Rust.\n #![feature(bool_to_option)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n-#![feature(const_panic)]\n #![feature(crate_visibility_modifier)]\n #![feature(decl_macro)]\n #![feature(exact_size_is_empty)]\n-#![feature(exhaustive_patterns)]\n+#![feature(format_args_capture)]\n #![feature(iter_zip)]\n #![feature(never_type)]\n #![feature(map_try_insert)]\n #![feature(min_specialization)]\n-#![feature(slice_ptr_len)]\n #![feature(slice_ptr_get)]\n #![feature(trusted_len)]\n #![feature(try_blocks)]\n@@ -31,7 +29,6 @@ Rust MIR: a lowered representation of Rust.\n #![feature(option_get_or_insert_default)]\n #![feature(once_cell)]\n #![feature(control_flow_enum)]\n-#![feature(trusted_step)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "4fbd27c89d9c8f6b7f0338f3d2020ad1c3db6f28", "filename": "compiler/rustc_mir/src/transform/check_consts/validation.rs", "status": "modified", "additions": 10, "deletions": 17, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -356,10 +356,9 @@ impl Validator<'mir, 'tcx> {\n     }\n \n     fn check_static(&mut self, def_id: DefId, span: Span) {\n-        assert!(\n-            !self.tcx.is_thread_local_static(def_id),\n-            \"tls access is checked in `Rvalue::ThreadLocalRef\"\n-        );\n+        if self.tcx.is_thread_local_static(def_id) {\n+            self.tcx.sess.delay_span_bug(span, \"tls access is checked in `Rvalue::ThreadLocalRef\");\n+        }\n         self.check_op_spanned(ops::StaticAccess, span)\n     }\n \n@@ -730,13 +729,11 @@ impl Visitor<'tcx> for Validator<'mir, 'tcx> {\n                 let base_ty = Place::ty_from(place_local, proj_base, self.body, self.tcx).ty;\n                 if let ty::RawPtr(_) = base_ty.kind() {\n                     if proj_base.is_empty() {\n-                        if let (local, []) = (place_local, proj_base) {\n-                            let decl = &self.body.local_decls[local];\n-                            if let Some(box LocalInfo::StaticRef { def_id, .. }) = decl.local_info {\n-                                let span = decl.source_info.span;\n-                                self.check_static(def_id, span);\n-                                return;\n-                            }\n+                        let decl = &self.body.local_decls[place_local];\n+                        if let Some(box LocalInfo::StaticRef { def_id, .. }) = decl.local_info {\n+                            let span = decl.source_info.span;\n+                            self.check_static(def_id, span);\n+                            return;\n                         }\n                     }\n                     self.check_op(ops::RawPtrDeref);\n@@ -753,12 +750,8 @@ impl Visitor<'tcx> for Validator<'mir, 'tcx> {\n             | ProjectionElem::Field(..)\n             | ProjectionElem::Index(_) => {\n                 let base_ty = Place::ty_from(place_local, proj_base, self.body, self.tcx).ty;\n-                match base_ty.ty_adt_def() {\n-                    Some(def) if def.is_union() => {\n-                        self.check_op(ops::UnionAccess);\n-                    }\n-\n-                    _ => {}\n+                if base_ty.is_union() {\n+                    self.check_op(ops::UnionAccess);\n                 }\n             }\n         }"}, {"sha": "103ddda1a1d262c45069da1fab78d78404a7776b", "filename": "compiler/rustc_mir/src/transform/check_unsafety.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_unsafety.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -221,7 +221,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n             }\n \n             let base_ty = base.ty(self.body, self.tcx).ty;\n-            if base_ty.ty_adt_def().map_or(false, |adt| adt.is_union()) {\n+            if base_ty.is_union() {\n                 // If we did not hit a `Deref` yet and the overall place use is an assignment, the\n                 // rules are different.\n                 let assign_to_field = !saw_deref\n@@ -376,6 +376,12 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n     /// Checks whether calling `func_did` needs an `unsafe` context or not, i.e. whether\n     /// the called function has target features the calling function hasn't.\n     fn check_target_features(&mut self, func_did: DefId) {\n+        // Unsafety isn't required on wasm targets. For more information see\n+        // the corresponding check in typeck/src/collect.rs\n+        if self.tcx.sess.target.options.is_like_wasm {\n+            return;\n+        }\n+\n         let callee_features = &self.tcx.codegen_fn_attrs(func_did).target_features;\n         let self_features = &self.tcx.codegen_fn_attrs(self.body_did).target_features;\n "}, {"sha": "ba10b54c5ae2e37fa579dc694bcfb35a79d50e1f", "filename": "compiler/rustc_mir/src/transform/const_goto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_goto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_goto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_goto.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -47,7 +47,7 @@ impl<'tcx> MirPass<'tcx> for ConstGoto {\n         // if we applied optimizations, we potentially have some cfg to cleanup to\n         // make it easier for further passes\n         if should_simplify {\n-            simplify_cfg(body);\n+            simplify_cfg(tcx, body);\n             simplify_locals(body, tcx);\n         }\n     }"}, {"sha": "f6672335cb1385d6e80b58767dd6a7755524c66b", "filename": "compiler/rustc_mir/src/transform/coverage/debug.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fdebug.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -116,7 +116,6 @@ use crate::util::pretty;\n use crate::util::spanview::{self, SpanViewable};\n \n use rustc_data_structures::fx::FxHashMap;\n-use rustc_index::vec::Idx;\n use rustc_middle::mir::coverage::*;\n use rustc_middle::mir::{self, BasicBlock, TerminatorKind};\n use rustc_middle::ty::TyCtxt;"}, {"sha": "912505c65983edb8f06df2ef6fe0016035ef90db", "filename": "compiler/rustc_mir/src/transform/deduplicate_blocks.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fdeduplicate_blocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fdeduplicate_blocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fdeduplicate_blocks.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -26,7 +26,7 @@ impl<'tcx> MirPass<'tcx> for DeduplicateBlocks {\n         if has_opts_to_apply {\n             let mut opt_applier = OptApplier { tcx, duplicates };\n             opt_applier.visit_body(body);\n-            simplify_cfg(body);\n+            simplify_cfg(tcx, body);\n         }\n     }\n }"}, {"sha": "4f5a467a6ee624cd39a1509aa6f9064c89e90aeb", "filename": "compiler/rustc_mir/src/transform/dest_prop.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fdest_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fdest_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fdest_prop.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -114,7 +114,7 @@ use rustc_middle::mir::{\n     traversal, Body, InlineAsmOperand, Local, LocalKind, Location, Operand, Place, PlaceElem,\n     Rvalue, Statement, StatementKind, Terminator, TerminatorKind,\n };\n-use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_middle::ty::TyCtxt;\n \n // Empirical measurements have resulted in some observations:\n // - Running on a body with a single block and 500 locals takes barely any time\n@@ -910,17 +910,8 @@ impl<'a, 'tcx> Visitor<'tcx> for FindAssignments<'a, 'tcx> {\n \n             // Handle the \"subtle case\" described above by rejecting any `dest` that is or\n             // projects through a union.\n-            let is_union = |ty: Ty<'_>| {\n-                if let ty::Adt(def, _) = ty.kind() {\n-                    if def.is_union() {\n-                        return true;\n-                    }\n-                }\n-\n-                false\n-            };\n             let mut place_ty = PlaceTy::from_ty(self.body.local_decls[dest.local].ty);\n-            if is_union(place_ty.ty) {\n+            if place_ty.ty.is_union() {\n                 return;\n             }\n             for elem in dest.projection {\n@@ -930,7 +921,7 @@ impl<'a, 'tcx> Visitor<'tcx> for FindAssignments<'a, 'tcx> {\n                 }\n \n                 place_ty = place_ty.projection_ty(self.tcx, elem);\n-                if is_union(place_ty.ty) {\n+                if place_ty.ty.is_union() {\n                     return;\n                 }\n             }"}, {"sha": "07127042fa41e82b31ba7b35d7718b6e45480729", "filename": "compiler/rustc_mir/src/transform/early_otherwise_branch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fearly_otherwise_branch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fearly_otherwise_branch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fearly_otherwise_branch.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -164,7 +164,7 @@ impl<'tcx> MirPass<'tcx> for EarlyOtherwiseBranch {\n         // Since this optimization adds new basic blocks and invalidates others,\n         // clean up the cfg to make it nicer for other passes\n         if should_cleanup {\n-            simplify_cfg(body);\n+            simplify_cfg(tcx, body);\n         }\n     }\n }"}, {"sha": "3560b4b1e8645e77ed17488ac8ba954b9ea4c28c", "filename": "compiler/rustc_mir/src/transform/generator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fgenerator.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -964,7 +964,7 @@ fn create_generator_drop_shim<'tcx>(\n \n     // Make sure we remove dead blocks to remove\n     // unrelated code from the resume part of the function\n-    simplify::remove_dead_blocks(&mut body);\n+    simplify::remove_dead_blocks(tcx, &mut body);\n \n     dump_mir(tcx, None, \"generator_drop\", &0, &body, |_, _| Ok(()));\n \n@@ -1137,7 +1137,7 @@ fn create_generator_resume_function<'tcx>(\n \n     // Make sure we remove dead blocks to remove\n     // unrelated code from the drop part of the function\n-    simplify::remove_dead_blocks(body);\n+    simplify::remove_dead_blocks(tcx, body);\n \n     dump_mir(tcx, None, \"generator_resume\", &0, body, |_, _| Ok(()));\n }"}, {"sha": "f1c95a84ade85a04800a9af36440ba28429fbe6d", "filename": "compiler/rustc_mir/src/transform/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -57,7 +57,7 @@ impl<'tcx> MirPass<'tcx> for Inline {\n         if inline(tcx, body) {\n             debug!(\"running simplify cfg on {:?}\", body.source);\n             CfgSimplifier::new(body).simplify();\n-            remove_dead_blocks(body);\n+            remove_dead_blocks(tcx, body);\n         }\n     }\n }"}, {"sha": "b64189a7f3c1e6a3d2a052dde6ea1c0a8b4938aa", "filename": "compiler/rustc_mir/src/transform/instcombine.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finstcombine.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -4,7 +4,7 @@ use crate::transform::MirPass;\n use rustc_hir::Mutability;\n use rustc_middle::mir::{\n     BinOp, Body, Constant, LocalDecls, Operand, Place, ProjectionElem, Rvalue, SourceInfo,\n-    StatementKind,\n+    StatementKind, UnOp,\n };\n use rustc_middle::ty::{self, TyCtxt};\n \n@@ -47,28 +47,35 @@ impl<'tcx, 'a> InstCombineContext<'tcx, 'a> {\n             Rvalue::BinaryOp(op @ (BinOp::Eq | BinOp::Ne), box (a, b)) => {\n                 let new = match (op, self.try_eval_bool(a), self.try_eval_bool(b)) {\n                     // Transform \"Eq(a, true)\" ==> \"a\"\n-                    (BinOp::Eq, _, Some(true)) => Some(a.clone()),\n+                    (BinOp::Eq, _, Some(true)) => Some(Rvalue::Use(a.clone())),\n \n                     // Transform \"Ne(a, false)\" ==> \"a\"\n-                    (BinOp::Ne, _, Some(false)) => Some(a.clone()),\n+                    (BinOp::Ne, _, Some(false)) => Some(Rvalue::Use(a.clone())),\n \n                     // Transform \"Eq(true, b)\" ==> \"b\"\n-                    (BinOp::Eq, Some(true), _) => Some(b.clone()),\n+                    (BinOp::Eq, Some(true), _) => Some(Rvalue::Use(b.clone())),\n \n                     // Transform \"Ne(false, b)\" ==> \"b\"\n-                    (BinOp::Ne, Some(false), _) => Some(b.clone()),\n+                    (BinOp::Ne, Some(false), _) => Some(Rvalue::Use(b.clone())),\n \n-                    // FIXME: Consider combining remaining comparisons into logical operations:\n                     // Transform \"Eq(false, b)\" ==> \"Not(b)\"\n+                    (BinOp::Eq, Some(false), _) => Some(Rvalue::UnaryOp(UnOp::Not, b.clone())),\n+\n                     // Transform \"Ne(true, b)\" ==> \"Not(b)\"\n+                    (BinOp::Ne, Some(true), _) => Some(Rvalue::UnaryOp(UnOp::Not, b.clone())),\n+\n                     // Transform \"Eq(a, false)\" ==> \"Not(a)\"\n+                    (BinOp::Eq, _, Some(false)) => Some(Rvalue::UnaryOp(UnOp::Not, a.clone())),\n+\n                     // Transform \"Ne(a, true)\" ==> \"Not(a)\"\n+                    (BinOp::Ne, _, Some(true)) => Some(Rvalue::UnaryOp(UnOp::Not, a.clone())),\n+\n                     _ => None,\n                 };\n \n                 if let Some(new) = new {\n                     if self.should_combine(source_info, rvalue) {\n-                        *rvalue = Rvalue::Use(new);\n+                        *rvalue = new;\n                     }\n                 }\n             }"}, {"sha": "21b208a08c2dca13cad206c4c28bf986187f3e43", "filename": "compiler/rustc_mir/src/transform/match_branches.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmatch_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmatch_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmatch_branches.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -167,7 +167,7 @@ impl<'tcx> MirPass<'tcx> for MatchBranchSimplification {\n         }\n \n         if should_cleanup {\n-            simplify_cfg(body);\n+            simplify_cfg(tcx, body);\n         }\n     }\n }"}, {"sha": "cd2db180552868c681f5bf862da1b988b43f9375", "filename": "compiler/rustc_mir/src/transform/multiple_return_terminators.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmultiple_return_terminators.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmultiple_return_terminators.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmultiple_return_terminators.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -38,6 +38,6 @@ impl<'tcx> MirPass<'tcx> for MultipleReturnTerminators {\n             }\n         }\n \n-        simplify::remove_dead_blocks(body)\n+        simplify::remove_dead_blocks(tcx, body)\n     }\n }"}, {"sha": "78e84419c62cde8cf85337cb23d6b42725c1d7ba", "filename": "compiler/rustc_mir/src/transform/promote_consts.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -415,11 +415,9 @@ impl<'tcx> Validator<'_, 'tcx> {\n \n                     ProjectionElem::Field(..) => {\n                         let base_ty = place_base.ty(self.body, self.tcx).ty;\n-                        if let Some(def) = base_ty.ty_adt_def() {\n+                        if base_ty.is_union() {\n                             // No promotion of union field accesses.\n-                            if def.is_union() {\n-                                return Err(Unpromotable);\n-                            }\n+                            return Err(Unpromotable);\n                         }\n                     }\n                 }"}, {"sha": "02e45021a0aaf343fe3f73173934dbbead3e9f0d", "filename": "compiler/rustc_mir/src/transform/remove_unneeded_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fremove_unneeded_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fremove_unneeded_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fremove_unneeded_drops.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -36,7 +36,7 @@ impl<'tcx> MirPass<'tcx> for RemoveUnneededDrops {\n         // if we applied optimizations, we potentially have some cfg to cleanup to\n         // make it easier for further passes\n         if should_simplify {\n-            simplify_cfg(body);\n+            simplify_cfg(tcx, body);\n         }\n     }\n }"}, {"sha": "40b1a8a2da9fa80b45ebbb1cd41764564ed9a32d", "filename": "compiler/rustc_mir/src/transform/remove_zsts.rs", "status": "modified", "additions": 24, "deletions": 34, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fremove_zsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fremove_zsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fremove_zsts.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -16,32 +16,29 @@ impl<'tcx> MirPass<'tcx> for RemoveZsts {\n         let (basic_blocks, local_decls) = body.basic_blocks_and_local_decls_mut();\n         for block in basic_blocks.iter_mut() {\n             for statement in block.statements.iter_mut() {\n-                match statement.kind {\n-                    StatementKind::Assign(box (place, _)) => {\n-                        let place_ty = place.ty(local_decls, tcx).ty;\n-                        if !maybe_zst(place_ty) {\n-                            continue;\n-                        }\n-                        let layout = match tcx.layout_of(param_env.and(place_ty)) {\n-                            Ok(layout) => layout,\n-                            Err(_) => continue,\n-                        };\n-                        if !layout.is_zst() {\n-                            continue;\n-                        }\n-                        if involves_a_union(place, local_decls, tcx) {\n-                            continue;\n-                        }\n-                        if tcx.consider_optimizing(|| {\n-                            format!(\n-                                \"RemoveZsts - Place: {:?} SourceInfo: {:?}\",\n-                                place, statement.source_info\n-                            )\n-                        }) {\n-                            statement.make_nop();\n-                        }\n+                if let StatementKind::Assign(box (place, _)) = statement.kind {\n+                    let place_ty = place.ty(local_decls, tcx).ty;\n+                    if !maybe_zst(place_ty) {\n+                        continue;\n+                    }\n+                    let layout = match tcx.layout_of(param_env.and(place_ty)) {\n+                        Ok(layout) => layout,\n+                        Err(_) => continue,\n+                    };\n+                    if !layout.is_zst() {\n+                        continue;\n+                    }\n+                    if involves_a_union(place, local_decls, tcx) {\n+                        continue;\n+                    }\n+                    if tcx.consider_optimizing(|| {\n+                        format!(\n+                            \"RemoveZsts - Place: {:?} SourceInfo: {:?}\",\n+                            place, statement.source_info\n+                        )\n+                    }) {\n+                        statement.make_nop();\n                     }\n-                    _ => {}\n                 }\n             }\n         }\n@@ -69,21 +66,14 @@ fn involves_a_union<'tcx>(\n     tcx: TyCtxt<'tcx>,\n ) -> bool {\n     let mut place_ty = PlaceTy::from_ty(local_decls[place.local].ty);\n-    if is_union(place_ty.ty) {\n+    if place_ty.ty.is_union() {\n         return true;\n     }\n     for elem in place.projection {\n         place_ty = place_ty.projection_ty(tcx, elem);\n-        if is_union(place_ty.ty) {\n+        if place_ty.ty.is_union() {\n             return true;\n         }\n     }\n     return false;\n }\n-\n-fn is_union(ty: Ty<'_>) -> bool {\n-    match ty.kind() {\n-        ty::Adt(def, _) if def.is_union() => true,\n-        _ => false,\n-    }\n-}"}, {"sha": "7aebca77e6f2090562816b78a0ab8ee2c1ea4c91", "filename": "compiler/rustc_mir/src/transform/simplify.rs", "status": "modified", "additions": 80, "deletions": 5, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -29,6 +29,7 @@\n \n use crate::transform::MirPass;\n use rustc_index::vec::{Idx, IndexVec};\n+use rustc_middle::mir::coverage::*;\n use rustc_middle::mir::visit::{MutVisitor, MutatingUseContext, PlaceContext, Visitor};\n use rustc_middle::mir::*;\n use rustc_middle::ty::TyCtxt;\n@@ -46,9 +47,9 @@ impl SimplifyCfg {\n     }\n }\n \n-pub fn simplify_cfg(body: &mut Body<'_>) {\n+pub fn simplify_cfg(tcx: TyCtxt<'tcx>, body: &mut Body<'_>) {\n     CfgSimplifier::new(body).simplify();\n-    remove_dead_blocks(body);\n+    remove_dead_blocks(tcx, body);\n \n     // FIXME: Should probably be moved into some kind of pass manager\n     body.basic_blocks_mut().raw.shrink_to_fit();\n@@ -59,9 +60,9 @@ impl<'tcx> MirPass<'tcx> for SimplifyCfg {\n         Cow::Borrowed(&self.label)\n     }\n \n-    fn run_pass(&self, _tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         debug!(\"SimplifyCfg({:?}) - simplifying {:?}\", self.label, body.source);\n-        simplify_cfg(body);\n+        simplify_cfg(tcx, body);\n     }\n }\n \n@@ -286,7 +287,7 @@ impl<'a, 'tcx> CfgSimplifier<'a, 'tcx> {\n     }\n }\n \n-pub fn remove_dead_blocks(body: &mut Body<'_>) {\n+pub fn remove_dead_blocks(tcx: TyCtxt<'tcx>, body: &mut Body<'_>) {\n     let reachable = traversal::reachable_as_bitset(body);\n     let num_blocks = body.basic_blocks().len();\n     if num_blocks == reachable.count() {\n@@ -306,6 +307,11 @@ pub fn remove_dead_blocks(body: &mut Body<'_>) {\n         }\n         used_blocks += 1;\n     }\n+\n+    if tcx.sess.instrument_coverage() {\n+        save_unreachable_coverage(basic_blocks, used_blocks);\n+    }\n+\n     basic_blocks.raw.truncate(used_blocks);\n \n     for block in basic_blocks {\n@@ -315,6 +321,75 @@ pub fn remove_dead_blocks(body: &mut Body<'_>) {\n     }\n }\n \n+/// Some MIR transforms can determine at compile time that a sequences of\n+/// statements will never be executed, so they can be dropped from the MIR.\n+/// For example, an `if` or `else` block that is guaranteed to never be executed\n+/// because its condition can be evaluated at compile time, such as by const\n+/// evaluation: `if false { ... }`.\n+///\n+/// Those statements are bypassed by redirecting paths in the CFG around the\n+/// `dead blocks`; but with `-Z instrument-coverage`, the dead blocks usually\n+/// include `Coverage` statements representing the Rust source code regions to\n+/// be counted at runtime. Without these `Coverage` statements, the regions are\n+/// lost, and the Rust source code will show no coverage information.\n+///\n+/// What we want to show in a coverage report is the dead code with coverage\n+/// counts of `0`. To do this, we need to save the code regions, by injecting\n+/// `Unreachable` coverage statements. These are non-executable statements whose\n+/// code regions are still recorded in the coverage map, representing regions\n+/// with `0` executions.\n+fn save_unreachable_coverage(\n+    basic_blocks: &mut IndexVec<BasicBlock, BasicBlockData<'_>>,\n+    first_dead_block: usize,\n+) {\n+    let has_live_counters = basic_blocks.raw[0..first_dead_block].iter().any(|live_block| {\n+        live_block.statements.iter().any(|statement| {\n+            if let StatementKind::Coverage(coverage) = &statement.kind {\n+                matches!(coverage.kind, CoverageKind::Counter { .. })\n+            } else {\n+                false\n+            }\n+        })\n+    });\n+    if !has_live_counters {\n+        // If there are no live `Counter` `Coverage` statements anymore, don't\n+        // move dead coverage to the `START_BLOCK`. Just allow the dead\n+        // `Coverage` statements to be dropped with the dead blocks.\n+        //\n+        // The `generator::StateTransform` MIR pass can create atypical\n+        // conditions, where all live `Counter`s are dropped from the MIR.\n+        //\n+        // At least one Counter per function is required by LLVM (and necessary,\n+        // to add the `function_hash` to the counter's call to the LLVM\n+        // intrinsic `instrprof.increment()`).\n+        return;\n+    }\n+\n+    // Retain coverage info for dead blocks, so coverage reports will still\n+    // report `0` executions for the uncovered code regions.\n+    let mut dropped_coverage = Vec::new();\n+    for dead_block in basic_blocks.raw[first_dead_block..].iter() {\n+        for statement in dead_block.statements.iter() {\n+            if let StatementKind::Coverage(coverage) = &statement.kind {\n+                if let Some(code_region) = &coverage.code_region {\n+                    dropped_coverage.push((statement.source_info, code_region.clone()));\n+                }\n+            }\n+        }\n+    }\n+\n+    let start_block = &mut basic_blocks[START_BLOCK];\n+    for (source_info, code_region) in dropped_coverage {\n+        start_block.statements.push(Statement {\n+            source_info,\n+            kind: StatementKind::Coverage(box Coverage {\n+                kind: CoverageKind::Unreachable,\n+                code_region: Some(code_region),\n+            }),\n+        })\n+    }\n+}\n+\n pub struct SimplifyLocals;\n \n impl<'tcx> MirPass<'tcx> for SimplifyLocals {"}, {"sha": "dd2ec39c066ab31844b9b031ed34428375290fb0", "filename": "compiler/rustc_mir/src/transform/simplify_try.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_try.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_try.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_try.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -558,7 +558,7 @@ impl<'tcx> MirPass<'tcx> for SimplifyBranchSame {\n \n         if did_remove_blocks {\n             // We have dead blocks now, so remove those.\n-            simplify::remove_dead_blocks(body);\n+            simplify::remove_dead_blocks(tcx, body);\n         }\n     }\n }"}, {"sha": "e7fb6b4f6b4ade858cf5210480c5a4aece8647d9", "filename": "compiler/rustc_mir/src/transform/unreachable_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Funreachable_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Funreachable_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Funreachable_prop.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -60,7 +60,7 @@ impl MirPass<'_> for UnreachablePropagation {\n         }\n \n         if replaced {\n-            simplify::remove_dead_blocks(body);\n+            simplify::remove_dead_blocks(tcx, body);\n         }\n     }\n }"}, {"sha": "835789069bb2e666c5b2a62293a7763298bb6343", "filename": "compiler/rustc_mir/src/transform/validate.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fvalidate.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -11,8 +11,9 @@ use rustc_middle::mir::interpret::Scalar;\n use rustc_middle::mir::traversal;\n use rustc_middle::mir::visit::{PlaceContext, Visitor};\n use rustc_middle::mir::{\n-    AggregateKind, BasicBlock, Body, BorrowKind, Local, Location, MirPhase, Operand, PlaceRef,\n-    Rvalue, SourceScope, Statement, StatementKind, Terminator, TerminatorKind,\n+    AggregateKind, BasicBlock, Body, BorrowKind, Local, Location, MirPhase, Operand, PlaceElem,\n+    PlaceRef, ProjectionElem, Rvalue, SourceScope, Statement, StatementKind, Terminator,\n+    TerminatorKind,\n };\n use rustc_middle::ty::fold::BottomUpFolder;\n use rustc_middle::ty::{self, ParamEnv, Ty, TyCtxt, TypeFoldable};\n@@ -217,6 +218,23 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n         self.super_operand(operand, location);\n     }\n \n+    fn visit_projection_elem(\n+        &mut self,\n+        local: Local,\n+        proj_base: &[PlaceElem<'tcx>],\n+        elem: PlaceElem<'tcx>,\n+        context: PlaceContext,\n+        location: Location,\n+    ) {\n+        if let ProjectionElem::Index(index) = elem {\n+            let index_ty = self.body.local_decls[index].ty;\n+            if index_ty != self.tcx.types.usize {\n+                self.fail(location, format!(\"bad index ({:?} != usize)\", index_ty))\n+            }\n+        }\n+        self.super_projection_elem(local, proj_base, elem, context, location);\n+    }\n+\n     fn visit_statement(&mut self, statement: &Statement<'tcx>, location: Location) {\n         match &statement.kind {\n             StatementKind::Assign(box (dest, rvalue)) => {"}, {"sha": "770b52a4d4b0fbb3ffc26e9bdf3030b23e2d7e4c", "filename": "compiler/rustc_mir/src/util/generic_graph.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Futil%2Fgeneric_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir%2Fsrc%2Futil%2Fgeneric_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Futil%2Fgeneric_graph.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -1,6 +1,5 @@\n use gsgdt::{Edge, Graph, Node, NodeStyle};\n use rustc_hir::def_id::DefId;\n-use rustc_index::vec::Idx;\n use rustc_middle::mir::*;\n use rustc_middle::ty::TyCtxt;\n "}, {"sha": "69786c14ee8dd390702aa59a20275fbac82d34e2", "filename": "compiler/rustc_mir_build/src/build/expr/as_rvalue.rs", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -186,25 +186,21 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 // };\n                 // ```\n                 //\n-                // FIXME(RFC2229, rust#85435): Remove feature gate once diagnostics are\n-                // improved and unsafe checking works properly in closure bodies again.\n-                if this.tcx.features().capture_disjoint_fields {\n-                    for (thir_place, cause, hir_id) in fake_reads.into_iter() {\n-                        let place_builder =\n-                            unpack!(block = this.as_place_builder(block, &this.thir[*thir_place]));\n-\n-                        if let Ok(place_builder_resolved) =\n-                            place_builder.try_upvars_resolved(this.tcx, this.typeck_results)\n-                        {\n-                            let mir_place =\n-                                place_builder_resolved.into_place(this.tcx, this.typeck_results);\n-                            this.cfg.push_fake_read(\n-                                block,\n-                                this.source_info(this.tcx.hir().span(*hir_id)),\n-                                *cause,\n-                                mir_place,\n-                            );\n-                        }\n+                for (thir_place, cause, hir_id) in fake_reads.into_iter() {\n+                    let place_builder =\n+                        unpack!(block = this.as_place_builder(block, &this.thir[*thir_place]));\n+\n+                    if let Ok(place_builder_resolved) =\n+                        place_builder.try_upvars_resolved(this.tcx, this.typeck_results)\n+                    {\n+                        let mir_place =\n+                            place_builder_resolved.into_place(this.tcx, this.typeck_results);\n+                        this.cfg.push_fake_read(\n+                            block,\n+                            this.source_info(this.tcx.hir().span(*hir_id)),\n+                            *cause,\n+                            mir_place,\n+                        );\n                     }\n                 }\n "}, {"sha": "2d52577829c71829f0c2beaaa91526cfeceb3f95", "filename": "compiler/rustc_mir_build/src/check_unsafety.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -166,13 +166,16 @@ impl<'a, 'tcx> Visitor<'a, 'tcx> for UnsafetyVisitor<'a, 'tcx> {\n                     self.requires_unsafe(expr.span, CallToUnsafeFunction);\n                 } else if let &ty::FnDef(func_did, _) = self.thir[fun].ty.kind() {\n                     // If the called function has target features the calling function hasn't,\n-                    // the call requires `unsafe`.\n-                    if !self\n-                        .tcx\n-                        .codegen_fn_attrs(func_did)\n-                        .target_features\n-                        .iter()\n-                        .all(|feature| self.body_target_features.contains(feature))\n+                    // the call requires `unsafe`. Don't check this on wasm\n+                    // targets, though. For more information on wasm see the\n+                    // is_like_wasm check in typeck/src/collect.rs\n+                    if !self.tcx.sess.target.options.is_like_wasm\n+                        && !self\n+                            .tcx\n+                            .codegen_fn_attrs(func_did)\n+                            .target_features\n+                            .iter()\n+                            .all(|feature| self.body_target_features.contains(feature))\n                     {\n                         self.requires_unsafe(expr.span, CallToFunctionWith);\n                     }"}, {"sha": "d2992f0bf186e79aa172c0025d0164151b5f8171", "filename": "compiler/rustc_mir_build/src/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -1,17 +1,14 @@\n //! Construction of MIR from HIR.\n //!\n //! This crate also contains the match exhaustiveness and usefulness checking.\n-#![feature(array_windows)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n-#![feature(const_panic)]\n #![feature(control_flow_enum)]\n #![feature(crate_visibility_modifier)]\n #![feature(bool_to_option)]\n #![feature(iter_zip)]\n #![feature(once_cell)]\n #![feature(min_specialization)]\n-#![feature(trusted_step)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "51df06bd989455d82bb4baf4d0ff2e8d1697f786", "filename": "compiler/rustc_parse/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flib.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -3,7 +3,6 @@\n #![feature(array_windows)]\n #![feature(crate_visibility_modifier)]\n #![feature(bindings_after_at)]\n-#![feature(iter_order_by)]\n #![feature(box_syntax)]\n #![feature(box_patterns)]\n #![recursion_limit = \"256\"]"}, {"sha": "8b050389078a648311b408e4415fd19a42541707", "filename": "compiler/rustc_parse/src/parser/attr.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -32,7 +32,6 @@ impl<'a> Parser<'a> {\n         let mut just_parsed_doc_comment = false;\n         let start_pos = self.token_cursor.num_next_calls;\n         loop {\n-            debug!(\"parse_outer_attributes: self.token={:?}\", self.token);\n             let attr = if self.check(&token::Pound) {\n                 let inner_error_reason = if just_parsed_doc_comment {\n                     \"an inner attribute is not permitted following an outer doc comment\""}, {"sha": "e1d0b84f4193f92a0ff002af50b24234b33b32a2", "filename": "compiler/rustc_parse/src/parser/attr_wrapper.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -342,16 +342,10 @@ impl<'a> Parser<'a> {\n \n         // If we support tokens at all\n         if let Some(target_tokens) = ret.tokens_mut() {\n-            if let Some(target_tokens) = target_tokens {\n-                assert!(\n-                    !self.capture_cfg,\n-                    \"Encountered existing tokens with capture_cfg set: {:?}\",\n-                    target_tokens\n-                );\n-            } else {\n+            if target_tokens.is_none() {\n                 // Store se our newly captured tokens into the AST node\n                 *target_tokens = Some(tokens.clone());\n-            };\n+            }\n         }\n \n         let final_attrs = ret.attrs();"}, {"sha": "b37caaebfb6895b4e098bfdb6f0ad430dd140490", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -366,7 +366,7 @@ impl<'a> Parser<'a> {\n             let mut snapshot = self.clone();\n             let path =\n                 Path { segments: vec![], span: self.prev_token.span.shrink_to_lo(), tokens: None };\n-            let struct_expr = snapshot.parse_struct_expr(path, AttrVec::new(), false);\n+            let struct_expr = snapshot.parse_struct_expr(None, path, AttrVec::new(), false);\n             let block_tail = self.parse_block_tail(lo, s, AttemptLocalParseRecovery::No);\n             return Some(match (struct_expr, block_tail) {\n                 (Ok(expr), Err(mut err)) => {"}, {"sha": "c8789abc142d6cf1179a8f0bf712398656e58620", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -94,17 +94,7 @@ impl<'a> Parser<'a> {\n \n     /// Parses an expression, forcing tokens to be collected\n     pub fn parse_expr_force_collect(&mut self) -> PResult<'a, P<Expr>> {\n-        // If we have outer attributes, then the call to `collect_tokens_trailing_token`\n-        // will be made for us.\n-        if matches!(self.token.kind, TokenKind::Pound | TokenKind::DocComment(..)) {\n-            self.parse_expr()\n-        } else {\n-            // If we don't have outer attributes, then we need to ensure\n-            // that collection happens by using `collect_tokens_no_attrs`.\n-            // Expression don't support custom inner attributes, so `parse_expr`\n-            // will never try to collect tokens if we don't have outer attributes.\n-            self.collect_tokens_no_attrs(|this| this.parse_expr())\n-        }\n+        self.collect_tokens_no_attrs(|this| this.parse_expr())\n     }\n \n     pub fn parse_anon_const_expr(&mut self) -> PResult<'a, AnonConst> {\n@@ -1118,9 +1108,6 @@ impl<'a> Parser<'a> {\n             self.parse_closure_expr(attrs)\n         } else if self.check(&token::OpenDelim(token::Bracket)) {\n             self.parse_array_or_repeat_expr(attrs)\n-        } else if self.eat_lt() {\n-            let (qself, path) = self.parse_qpath(PathStyle::Expr)?;\n-            Ok(self.mk_expr(lo.to(path.span), ExprKind::Path(Some(qself), path), attrs))\n         } else if self.check_path() {\n             self.parse_path_start_expr(attrs)\n         } else if self.check_keyword(kw::Move) || self.check_keyword(kw::Static) {\n@@ -1272,26 +1259,37 @@ impl<'a> Parser<'a> {\n     }\n \n     fn parse_path_start_expr(&mut self, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n-        let path = self.parse_path(PathStyle::Expr)?;\n+        let (qself, path) = if self.eat_lt() {\n+            let (qself, path) = self.parse_qpath(PathStyle::Expr)?;\n+            (Some(qself), path)\n+        } else {\n+            (None, self.parse_path(PathStyle::Expr)?)\n+        };\n         let lo = path.span;\n \n         // `!`, as an operator, is prefix, so we know this isn't that.\n         let (hi, kind) = if self.eat(&token::Not) {\n             // MACRO INVOCATION expression\n+            if qself.is_some() {\n+                self.struct_span_err(path.span, \"macros cannot use qualified paths\").emit();\n+            }\n             let mac = MacCall {\n                 path,\n                 args: self.parse_mac_args()?,\n                 prior_type_ascription: self.last_type_ascription,\n             };\n             (self.prev_token.span, ExprKind::MacCall(mac))\n         } else if self.check(&token::OpenDelim(token::Brace)) {\n-            if let Some(expr) = self.maybe_parse_struct_expr(&path, &attrs) {\n+            if let Some(expr) = self.maybe_parse_struct_expr(qself.as_ref(), &path, &attrs) {\n+                if qself.is_some() {\n+                    self.sess.gated_spans.gate(sym::more_qualified_paths, path.span);\n+                }\n                 return expr;\n             } else {\n-                (path.span, ExprKind::Path(None, path))\n+                (path.span, ExprKind::Path(qself, path))\n             }\n         } else {\n-            (path.span, ExprKind::Path(None, path))\n+            (path.span, ExprKind::Path(qself, path))\n         };\n \n         let expr = self.mk_expr(lo.to(hi), kind, attrs);\n@@ -2257,6 +2255,7 @@ impl<'a> Parser<'a> {\n \n     fn maybe_parse_struct_expr(\n         &mut self,\n+        qself: Option<&ast::QSelf>,\n         path: &ast::Path,\n         attrs: &AttrVec,\n     ) -> Option<PResult<'a, P<Expr>>> {\n@@ -2265,7 +2264,7 @@ impl<'a> Parser<'a> {\n             if let Err(err) = self.expect(&token::OpenDelim(token::Brace)) {\n                 return Some(Err(err));\n             }\n-            let expr = self.parse_struct_expr(path.clone(), attrs.clone(), true);\n+            let expr = self.parse_struct_expr(qself.cloned(), path.clone(), attrs.clone(), true);\n             if let (Ok(expr), false) = (&expr, struct_allowed) {\n                 // This is a struct literal, but we don't can't accept them here.\n                 self.error_struct_lit_not_allowed_here(path.span, expr.span);\n@@ -2288,6 +2287,7 @@ impl<'a> Parser<'a> {\n     /// Precondition: already parsed the '{'.\n     pub(super) fn parse_struct_expr(\n         &mut self,\n+        qself: Option<ast::QSelf>,\n         pth: ast::Path,\n         attrs: AttrVec,\n         recover: bool,\n@@ -2385,7 +2385,7 @@ impl<'a> Parser<'a> {\n         let expr = if recover_async {\n             ExprKind::Err\n         } else {\n-            ExprKind::Struct(P(ast::StructExpr { path: pth, fields, rest: base }))\n+            ExprKind::Struct(P(ast::StructExpr { qself, path: pth, fields, rest: base }))\n         };\n         Ok(self.mk_expr(span, expr, attrs))\n     }"}, {"sha": "54e6ff6272c0594cfca0861a3b827ba3505c1b82", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -1474,7 +1474,10 @@ impl<'a> Parser<'a> {\n                 self.sess.gated_spans.gate(sym::unnamed_fields, lo);\n             } else {\n                 let err = if self.check_fn_front_matter(false) {\n-                    let _ = self.parse_fn(&mut Vec::new(), |_| true, lo);\n+                    // We use `parse_fn` to get a span for the function\n+                    if let Err(mut db) = self.parse_fn(&mut Vec::new(), |_| true, lo) {\n+                        db.delay_as_bug();\n+                    }\n                     let mut err = self.struct_span_err(\n                         lo.to(self.prev_token.span),\n                         &format!(\"functions are not allowed in {} definitions\", adt_ty),"}, {"sha": "cd9f84db5e55958005bcb3284c00c4fee3f63e89", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -63,6 +63,7 @@ enum BlockMode {\n \n /// Whether or not we should force collection of tokens for an AST node,\n /// regardless of whether or not it has attributes\n+#[derive(Clone, Copy, PartialEq)]\n pub enum ForceCollect {\n     Yes,\n     No,"}, {"sha": "30a6b61407f69a06cca09094e715dc028bed125d", "filename": "compiler/rustc_parse/src/parser/nonterminal.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -1,5 +1,6 @@\n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Nonterminal, NonterminalKind, Token};\n+use rustc_ast::AstLike;\n use rustc_ast_pretty::pprust;\n use rustc_errors::PResult;\n use rustc_span::symbol::{kw, Ident};\n@@ -102,7 +103,7 @@ impl<'a> Parser<'a> {\n         // which requires having captured tokens available. Since we cannot determine\n         // in advance whether or not a proc-macro will be (transitively) invoked,\n         // we always capture tokens for any `Nonterminal` which needs them.\n-        Ok(match kind {\n+        let mut nt = match kind {\n             NonterminalKind::Item => match self.parse_item(ForceCollect::Yes)? {\n                 Some(item) => token::NtItem(item),\n                 None => {\n@@ -169,7 +170,19 @@ impl<'a> Parser<'a> {\n                     return Err(self.struct_span_err(self.token.span, msg));\n                 }\n             }\n-        })\n+        };\n+\n+        // If tokens are supported at all, they should be collected.\n+        if matches!(nt.tokens_mut(), Some(None)) {\n+            panic!(\n+                \"Missing tokens for nt {:?} at {:?}: {:?}\",\n+                nt,\n+                nt.span(),\n+                pprust::nonterminal_to_string(&nt)\n+            );\n+        }\n+\n+        Ok(nt)\n     }\n }\n "}, {"sha": "418122202be1b187e9e356ee0f96005ae7d7f328", "filename": "compiler/rustc_parse/src/parser/pat.rs", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -859,7 +859,8 @@ impl<'a> Parser<'a> {\n     /// Parse a struct (\"record\") pattern (e.g. `Foo { ... }` or `Foo::Bar { ... }`).\n     fn parse_pat_struct(&mut self, qself: Option<QSelf>, path: Path) -> PResult<'a, PatKind> {\n         if qself.is_some() {\n-            return self.error_qpath_before_pat(&path, \"{\");\n+            // Feature gate the use of qualified paths in patterns\n+            self.sess.gated_spans.gate(sym::more_qualified_paths, path.span);\n         }\n         self.bump();\n         let (fields, etc) = self.parse_pat_fields().unwrap_or_else(|mut e| {\n@@ -869,27 +870,17 @@ impl<'a> Parser<'a> {\n             (vec![], true)\n         });\n         self.bump();\n-        Ok(PatKind::Struct(path, fields, etc))\n+        Ok(PatKind::Struct(qself, path, fields, etc))\n     }\n \n     /// Parse tuple struct or tuple variant pattern (e.g. `Foo(...)` or `Foo::Bar(...)`).\n     fn parse_pat_tuple_struct(&mut self, qself: Option<QSelf>, path: Path) -> PResult<'a, PatKind> {\n-        if qself.is_some() {\n-            return self.error_qpath_before_pat(&path, \"(\");\n-        }\n         let (fields, _) =\n             self.parse_paren_comma_seq(|p| p.parse_pat_allow_top_alt(None, RecoverComma::No))?;\n-        Ok(PatKind::TupleStruct(path, fields))\n-    }\n-\n-    /// Error when there's a qualified path, e.g. `<Foo as Bar>::Baz`\n-    /// as the path of e.g., a tuple or record struct pattern.\n-    fn error_qpath_before_pat(&mut self, path: &Path, token: &str) -> PResult<'a, PatKind> {\n-        let msg = &format!(\"unexpected `{}` after qualified path\", token);\n-        let mut err = self.struct_span_err(self.token.span, msg);\n-        err.span_label(self.token.span, msg);\n-        err.span_label(path.span, \"the qualified path\");\n-        Err(err)\n+        if qself.is_some() {\n+            self.sess.gated_spans.gate(sym::more_qualified_paths, path.span);\n+        }\n+        Ok(PatKind::TupleStruct(qself, path, fields))\n     }\n \n     /// Parses the fields of a struct-like pattern."}, {"sha": "953c6915068afd49409201f91b0ad485cb94c953", "filename": "compiler/rustc_parse/src/parser/path.rs", "status": "modified", "additions": 47, "deletions": 37, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -352,49 +352,59 @@ impl<'a> Parser<'a> {\n         debug!(\"parse_generic_args_with_leading_angle_bracket_recovery: (snapshotting)\");\n         match self.parse_angle_args() {\n             Ok(args) => Ok(args),\n-            Err(ref mut e) if is_first_invocation && self.unmatched_angle_bracket_count > 0 => {\n-                // Cancel error from being unable to find `>`. We know the error\n-                // must have been this due to a non-zero unmatched angle bracket\n-                // count.\n-                e.cancel();\n-\n+            Err(mut e) if is_first_invocation && self.unmatched_angle_bracket_count > 0 => {\n                 // Swap `self` with our backup of the parser state before attempting to parse\n                 // generic arguments.\n                 let snapshot = mem::replace(self, snapshot.unwrap());\n \n-                debug!(\n-                    \"parse_generic_args_with_leading_angle_bracket_recovery: (snapshot failure) \\\n-                     snapshot.count={:?}\",\n-                    snapshot.unmatched_angle_bracket_count,\n-                );\n-\n                 // Eat the unmatched angle brackets.\n-                for _ in 0..snapshot.unmatched_angle_bracket_count {\n-                    self.eat_lt();\n-                }\n-\n-                // Make a span over ${unmatched angle bracket count} characters.\n-                let span = lo.with_hi(lo.lo() + BytePos(snapshot.unmatched_angle_bracket_count));\n-                self.struct_span_err(\n-                    span,\n-                    &format!(\n-                        \"unmatched angle bracket{}\",\n-                        pluralize!(snapshot.unmatched_angle_bracket_count)\n-                    ),\n-                )\n-                .span_suggestion(\n-                    span,\n-                    &format!(\n-                        \"remove extra angle bracket{}\",\n-                        pluralize!(snapshot.unmatched_angle_bracket_count)\n-                    ),\n-                    String::new(),\n-                    Applicability::MachineApplicable,\n-                )\n-                .emit();\n+                let all_angle_brackets = (0..snapshot.unmatched_angle_bracket_count)\n+                    .fold(true, |a, _| a && self.eat_lt());\n+\n+                if !all_angle_brackets {\n+                    // If there are other tokens in between the extraneous `<`s, we cannot simply\n+                    // suggest to remove them. This check also prevents us from accidentally ending\n+                    // up in the middle of a multibyte character (issue #84104).\n+                    let _ = mem::replace(self, snapshot);\n+                    Err(e)\n+                } else {\n+                    // Cancel error from being unable to find `>`. We know the error\n+                    // must have been this due to a non-zero unmatched angle bracket\n+                    // count.\n+                    e.cancel();\n+\n+                    debug!(\n+                        \"parse_generic_args_with_leading_angle_bracket_recovery: (snapshot failure) \\\n+                         snapshot.count={:?}\",\n+                        snapshot.unmatched_angle_bracket_count,\n+                    );\n+\n+                    // Make a span over ${unmatched angle bracket count} characters.\n+                    // This is safe because `all_angle_brackets` ensures that there are only `<`s,\n+                    // i.e. no multibyte characters, in this range.\n+                    let span =\n+                        lo.with_hi(lo.lo() + BytePos(snapshot.unmatched_angle_bracket_count));\n+                    self.struct_span_err(\n+                        span,\n+                        &format!(\n+                            \"unmatched angle bracket{}\",\n+                            pluralize!(snapshot.unmatched_angle_bracket_count)\n+                        ),\n+                    )\n+                    .span_suggestion(\n+                        span,\n+                        &format!(\n+                            \"remove extra angle bracket{}\",\n+                            pluralize!(snapshot.unmatched_angle_bracket_count)\n+                        ),\n+                        String::new(),\n+                        Applicability::MachineApplicable,\n+                    )\n+                    .emit();\n \n-                // Try again without unmatched angle bracket characters.\n-                self.parse_angle_args()\n+                    // Try again without unmatched angle bracket characters.\n+                    self.parse_angle_args()\n+                }\n             }\n             Err(e) => Err(e),\n         }"}, {"sha": "9ef3f61ec346b11b2933dcc5f0cd075b8b0863c5", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -73,7 +73,11 @@ impl<'a> Parser<'a> {\n             // or `auto trait` items. We aim to parse an arbitrary path `a::b` but not something\n             // that starts like a path (1 token), but it fact not a path.\n             // Also, we avoid stealing syntax from `parse_item_`.\n-            self.parse_stmt_path_start(lo, attrs, force_collect)?\n+            if force_collect == ForceCollect::Yes {\n+                self.collect_tokens_no_attrs(|this| this.parse_stmt_path_start(lo, attrs))\n+            } else {\n+                self.parse_stmt_path_start(lo, attrs)\n+            }?\n         } else if let Some(item) =\n             self.parse_item_common(attrs.clone(), false, true, |_| true, force_collect)?\n         {\n@@ -85,21 +89,22 @@ impl<'a> Parser<'a> {\n             self.mk_stmt(lo, StmtKind::Empty)\n         } else if self.token != token::CloseDelim(token::Brace) {\n             // Remainder are line-expr stmts.\n-            let e = self.parse_expr_res(Restrictions::STMT_EXPR, Some(attrs))?;\n+            let e = if force_collect == ForceCollect::Yes {\n+                self.collect_tokens_no_attrs(|this| {\n+                    this.parse_expr_res(Restrictions::STMT_EXPR, Some(attrs))\n+                })\n+            } else {\n+                self.parse_expr_res(Restrictions::STMT_EXPR, Some(attrs))\n+            }?;\n             self.mk_stmt(lo.to(e.span), StmtKind::Expr(e))\n         } else {\n             self.error_outer_attrs(&attrs.take_for_recovery());\n             return Ok(None);\n         }))\n     }\n \n-    fn parse_stmt_path_start(\n-        &mut self,\n-        lo: Span,\n-        attrs: AttrWrapper,\n-        force_collect: ForceCollect,\n-    ) -> PResult<'a, Stmt> {\n-        let stmt = self.collect_tokens_trailing_token(attrs, force_collect, |this, attrs| {\n+    fn parse_stmt_path_start(&mut self, lo: Span, attrs: AttrWrapper) -> PResult<'a, Stmt> {\n+        let stmt = self.collect_tokens_trailing_token(attrs, ForceCollect::No, |this, attrs| {\n             let path = this.parse_path(PathStyle::Expr)?;\n \n             if this.eat(&token::Not) {\n@@ -112,7 +117,7 @@ impl<'a> Parser<'a> {\n             }\n \n             let expr = if this.eat(&token::OpenDelim(token::Brace)) {\n-                this.parse_struct_expr(path, AttrVec::new(), true)?\n+                this.parse_struct_expr(None, path, AttrVec::new(), true)?\n             } else {\n                 let hi = this.prev_token.span;\n                 this.mk_expr(lo.to(hi), ExprKind::Path(None, path), AttrVec::new())"}, {"sha": "de5a5632600e4ee39a1f6c0dd90d01f92fb5ed46", "filename": "compiler/rustc_parse/src/parser/ty.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -334,7 +334,6 @@ impl<'a> Parser<'a> {\n         mut bounds: GenericBounds,\n         plus: bool,\n     ) -> PResult<'a, TyKind> {\n-        assert_ne!(self.token, token::Question);\n         if plus {\n             self.eat_plus(); // `+`, or `+=` gets split and `+` is discarded\n             bounds.append(&mut self.parse_generic_bounds(Some(self.prev_token.span))?);"}, {"sha": "b18ef302962378b1819e909dfd9ca6841535dd24", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 26, "deletions": 3, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -577,7 +577,7 @@ impl CheckAttrVisitor<'tcx> {\n         target: Target,\n         specified_inline: &mut Option<(bool, Span)>,\n     ) -> bool {\n-        if target == Target::Use {\n+        if target == Target::Use || target == Target::ExternCrate {\n             let do_inline = meta.name_or_empty() == sym::inline;\n             if let Some((prev_inline, prev_span)) = *specified_inline {\n                 if do_inline != prev_inline {\n@@ -705,7 +705,7 @@ impl CheckAttrVisitor<'tcx> {\n         let mut is_valid = true;\n \n         if let Some(list) = attr.meta().and_then(|mi| mi.meta_item_list().map(|l| l.to_vec())) {\n-            for meta in list {\n+            for meta in &list {\n                 if let Some(i_meta) = meta.meta_item() {\n                     match i_meta.name_or_empty() {\n                         sym::alias\n@@ -757,7 +757,6 @@ impl CheckAttrVisitor<'tcx> {\n                         | sym::html_no_source\n                         | sym::html_playground_url\n                         | sym::html_root_url\n-                        | sym::include\n                         | sym::inline\n                         | sym::issue_tracker_base_url\n                         | sym::keyword\n@@ -792,6 +791,30 @@ impl CheckAttrVisitor<'tcx> {\n                                         );\n                                         diag.note(\"`doc(spotlight)` is now a no-op\");\n                                     }\n+                                    if i_meta.has_name(sym::include) {\n+                                        if let Some(value) = i_meta.value_str() {\n+                                            // if there are multiple attributes, the suggestion would suggest deleting all of them, which is incorrect\n+                                            let applicability = if list.len() == 1 {\n+                                                Applicability::MachineApplicable\n+                                            } else {\n+                                                Applicability::MaybeIncorrect\n+                                            };\n+                                            let inner = if attr.style == AttrStyle::Inner {\n+                                                \"!\"\n+                                            } else {\n+                                                \"\"\n+                                            };\n+                                            diag.span_suggestion(\n+                                                attr.meta().unwrap().span,\n+                                                \"use `doc = include_str!` instead\",\n+                                                format!(\n+                                                    \"#{}[doc = include_str!(\\\"{}\\\")]\",\n+                                                    inner, value\n+                                                ),\n+                                                applicability,\n+                                            );\n+                                        }\n+                                    }\n                                     diag.emit();\n                                 },\n                             );"}, {"sha": "28633faa205d053a056f9922f295cf0dd60e66bc", "filename": "compiler/rustc_passes/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_passes%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_passes%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flib.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -5,13 +5,11 @@\n //! This API is completely unstable and subject to change.\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n-#![feature(const_panic)]\n #![feature(crate_visibility_modifier)]\n #![feature(in_band_lifetimes)]\n #![feature(iter_zip)]\n #![feature(nll)]\n #![feature(min_specialization)]\n-#![feature(trusted_step)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "5a79a9cc6ecfd1ffe1e4a1a4ca4a5439392b4f3b", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -156,6 +156,7 @@ where\n                 let leaf = leaf.subst(tcx, ct.substs);\n                 self.visit_const(leaf)\n             }\n+            ACNode::Cast(_, _, ty) => self.visit_ty(ty),\n             ACNode::Binop(..) | ACNode::UnaryOp(..) | ACNode::FunctionCall(_, _) => {\n                 ControlFlow::CONTINUE\n             }"}, {"sha": "4175fb6925ac4bab1238fdcf3b743bd2a41d1b49", "filename": "compiler/rustc_query_impl/src/lib.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -2,13 +2,9 @@\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(in_band_lifetimes)]\n-#![feature(exhaustive_patterns)]\n #![feature(nll)]\n #![feature(min_specialization)]\n-#![feature(crate_visibility_modifier)]\n-#![feature(once_cell)]\n #![feature(rustc_attrs)]\n-#![feature(never_type)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "b4191c135b4f9b425a3052b92a7b1fac7c5d8637", "filename": "compiler/rustc_query_impl/src/plumbing.rs", "status": "modified", "additions": 1, "deletions": 34, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -3,7 +3,7 @@\n //! manage the caches, and so forth.\n \n use super::queries;\n-use rustc_middle::dep_graph::{DepKind, DepNode, DepNodeExt, DepNodeIndex, SerializedDepNodeIndex};\n+use rustc_middle::dep_graph::{DepKind, DepNode, DepNodeIndex, SerializedDepNodeIndex};\n use rustc_middle::ty::query::on_disk_cache;\n use rustc_middle::ty::tls::{self, ImplicitCtxt};\n use rustc_middle::ty::{self, TyCtxt};\n@@ -57,39 +57,6 @@ impl QueryContext for QueryCtxt<'tcx> {\n     }\n \n     fn try_force_from_dep_node(&self, dep_node: &DepNode) -> bool {\n-        // FIXME: This match is just a workaround for incremental bugs and should\n-        // be removed. https://github.com/rust-lang/rust/issues/62649 is one such\n-        // bug that must be fixed before removing this.\n-        match dep_node.kind {\n-            DepKind::hir_owner | DepKind::hir_owner_nodes => {\n-                if let Some(def_id) = dep_node.extract_def_id(**self) {\n-                    let def_id = def_id.expect_local();\n-                    let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n-                    if def_id != hir_id.owner {\n-                        // This `DefPath` does not have a\n-                        // corresponding `DepNode` (e.g. a\n-                        // struct field), and the ` DefPath`\n-                        // collided with the `DefPath` of a\n-                        // proper item that existed in the\n-                        // previous compilation session.\n-                        //\n-                        // Since the given `DefPath` does not\n-                        // denote the item that previously\n-                        // existed, we just fail to mark green.\n-                        return false;\n-                    }\n-                } else {\n-                    // If the node does not exist anymore, we\n-                    // just fail to mark green.\n-                    return false;\n-                }\n-            }\n-            _ => {\n-                // For other kinds of nodes it's OK to be\n-                // forced.\n-            }\n-        }\n-\n         debug!(\"try_force_from_dep_node({:?}) --- trying to force\", dep_node);\n \n         // We must avoid ever having to call `force_from_dep_node()` for a"}, {"sha": "95edc1e93a538ee093b0c19465be2c4489ff7180", "filename": "compiler/rustc_query_impl/src/profiling_support.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_query_impl%2Fsrc%2Fprofiling_support.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_query_impl%2Fsrc%2Fprofiling_support.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fprofiling_support.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -61,7 +61,7 @@ impl<'p, 'c, 'tcx> QueryKeyStringBuilder<'p, 'c, 'tcx> {\n \n         match def_key.disambiguated_data.data {\n             DefPathData::CrateRoot => {\n-                crate_name = self.tcx.original_crate_name(def_id.krate).as_str();\n+                crate_name = self.tcx.crate_name(def_id.krate).as_str();\n                 name = &*crate_name;\n                 dis = \"\";\n                 end_index = 3;"}, {"sha": "71e67dfee538bdee7f553a687eb03e3aed6e8e72", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 53, "deletions": 27, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -44,6 +44,7 @@ rustc_index::newtype_index! {\n \n impl DepNodeIndex {\n     pub const INVALID: DepNodeIndex = DepNodeIndex::MAX;\n+    pub const SINGLETON_DEPENDENCYLESS_ANON_NODE: DepNodeIndex = DepNodeIndex::from_u32(0);\n }\n \n impl std::convert::From<DepNodeIndex> for QueryInvocationId {\n@@ -108,6 +109,7 @@ where\n \n impl<K: DepKind> DepGraph<K> {\n     pub fn new(\n+        profiler: &SelfProfilerRef,\n         prev_graph: SerializedDepGraph<K>,\n         prev_work_products: FxHashMap<WorkProductId, WorkProduct>,\n         encoder: FileEncoder,\n@@ -116,16 +118,23 @@ impl<K: DepKind> DepGraph<K> {\n     ) -> DepGraph<K> {\n         let prev_graph_node_count = prev_graph.node_count();\n \n+        let current =\n+            CurrentDepGraph::new(prev_graph_node_count, encoder, record_graph, record_stats);\n+\n+        // Instantiate a dependy-less node only once for anonymous queries.\n+        let _green_node_index = current.intern_new_node(\n+            profiler,\n+            DepNode { kind: DepKind::NULL, hash: current.anon_id_seed.into() },\n+            smallvec![],\n+            Fingerprint::ZERO,\n+        );\n+        debug_assert_eq!(_green_node_index, DepNodeIndex::SINGLETON_DEPENDENCYLESS_ANON_NODE);\n+\n         DepGraph {\n             data: Some(Lrc::new(DepGraphData {\n                 previous_work_products: prev_work_products,\n                 dep_node_debug: Default::default(),\n-                current: CurrentDepGraph::new(\n-                    prev_graph_node_count,\n-                    encoder,\n-                    record_graph,\n-                    record_stats,\n-                ),\n+                current,\n                 emitting_diagnostics: Default::default(),\n                 emitting_diagnostics_cond_var: Condvar::new(),\n                 previous: prev_graph,\n@@ -287,30 +296,47 @@ impl<K: DepKind> DepGraph<K> {\n             let task_deps = Lock::new(TaskDeps::default());\n             let result = K::with_deps(Some(&task_deps), op);\n             let task_deps = task_deps.into_inner();\n+            let task_deps = task_deps.reads;\n+\n+            let dep_node_index = match task_deps.len() {\n+                0 => {\n+                    // Because the dep-node id of anon nodes is computed from the sets of its\n+                    // dependencies we already know what the ID of this dependency-less node is\n+                    // going to be (i.e. equal to the precomputed\n+                    // `SINGLETON_DEPENDENCYLESS_ANON_NODE`). As a consequence we can skip creating\n+                    // a `StableHasher` and sending the node through interning.\n+                    DepNodeIndex::SINGLETON_DEPENDENCYLESS_ANON_NODE\n+                }\n+                1 => {\n+                    // When there is only one dependency, don't bother creating a node.\n+                    task_deps[0]\n+                }\n+                _ => {\n+                    // The dep node indices are hashed here instead of hashing the dep nodes of the\n+                    // dependencies. These indices may refer to different nodes per session, but this isn't\n+                    // a problem here because we that ensure the final dep node hash is per session only by\n+                    // combining it with the per session random number `anon_id_seed`. This hash only need\n+                    // to map the dependencies to a single value on a per session basis.\n+                    let mut hasher = StableHasher::new();\n+                    task_deps.hash(&mut hasher);\n+\n+                    let target_dep_node = DepNode {\n+                        kind: dep_kind,\n+                        // Fingerprint::combine() is faster than sending Fingerprint\n+                        // through the StableHasher (at least as long as StableHasher\n+                        // is so slow).\n+                        hash: data.current.anon_id_seed.combine(hasher.finish()).into(),\n+                    };\n \n-            // The dep node indices are hashed here instead of hashing the dep nodes of the\n-            // dependencies. These indices may refer to different nodes per session, but this isn't\n-            // a problem here because we that ensure the final dep node hash is per session only by\n-            // combining it with the per session random number `anon_id_seed`. This hash only need\n-            // to map the dependencies to a single value on a per session basis.\n-            let mut hasher = StableHasher::new();\n-            task_deps.reads.hash(&mut hasher);\n-\n-            let target_dep_node = DepNode {\n-                kind: dep_kind,\n-                // Fingerprint::combine() is faster than sending Fingerprint\n-                // through the StableHasher (at least as long as StableHasher\n-                // is so slow).\n-                hash: data.current.anon_id_seed.combine(hasher.finish()).into(),\n+                    data.current.intern_new_node(\n+                        cx.profiler(),\n+                        target_dep_node,\n+                        task_deps,\n+                        Fingerprint::ZERO,\n+                    )\n+                }\n             };\n \n-            let dep_node_index = data.current.intern_new_node(\n-                cx.profiler(),\n-                target_dep_node,\n-                task_deps.reads,\n-                Fingerprint::ZERO,\n-            );\n-\n             (result, dep_node_index)\n         } else {\n             (op(), self.next_virtual_depnode_index())"}, {"sha": "73c00fc49ba39c7794becf632ae0a8d1a9daa973", "filename": "compiler/rustc_query_system/src/dep_graph/serialized.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -122,21 +122,21 @@ impl<'a, K: DepKind + Decodable<opaque::Decoder<'a>>> Decodable<opaque::Decoder<\n         let mut edge_list_data = Vec::with_capacity(edge_count);\n \n         for _index in 0..node_count {\n-            d.read_struct(\"NodeInfo\", 3, |d| {\n-                let dep_node: DepNode<K> = d.read_struct_field(\"node\", 0, Decodable::decode)?;\n+            d.read_struct(|d| {\n+                let dep_node: DepNode<K> = d.read_struct_field(\"node\", Decodable::decode)?;\n                 let _i: SerializedDepNodeIndex = nodes.push(dep_node);\n                 debug_assert_eq!(_i.index(), _index);\n \n                 let fingerprint: Fingerprint =\n-                    d.read_struct_field(\"fingerprint\", 1, Decodable::decode)?;\n+                    d.read_struct_field(\"fingerprint\", Decodable::decode)?;\n                 let _i: SerializedDepNodeIndex = fingerprints.push(fingerprint);\n                 debug_assert_eq!(_i.index(), _index);\n \n-                d.read_struct_field(\"edges\", 2, |d| {\n+                d.read_struct_field(\"edges\", |d| {\n                     d.read_seq(|d, len| {\n                         let start = edge_list_data.len().try_into().unwrap();\n-                        for e in 0..len {\n-                            let edge = d.read_seq_elt(e, Decodable::decode)?;\n+                        for _ in 0..len {\n+                            let edge = d.read_seq_elt(Decodable::decode)?;\n                             edge_list_data.push(edge);\n                         }\n                         let end = edge_list_data.len().try_into().unwrap();"}, {"sha": "0d4fb34265c55a33df6395be42919be61d8f7c73", "filename": "compiler/rustc_query_system/src/lib.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_query_system%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_query_system%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Flib.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -1,12 +1,8 @@\n #![feature(bool_to_option)]\n-#![feature(const_panic)]\n #![feature(core_intrinsics)]\n-#![feature(drain_filter)]\n #![feature(hash_raw_entry)]\n #![feature(iter_zip)]\n #![feature(min_specialization)]\n-#![feature(stmt_expr_attributes)]\n-#![feature(trusted_step)]\n \n #[macro_use]\n extern crate tracing;"}, {"sha": "03d94f43897ba19fcd472316db990b0b0ec34f7b", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -450,7 +450,7 @@ impl<'a> Resolver<'a> {\n                 err.span_label(shadowed_binding_span, msg);\n                 err\n             }\n-            ResolutionError::ForwardDeclaredTyParam => {\n+            ResolutionError::ForwardDeclaredGenericParam => {\n                 let mut err = struct_span_err!(\n                     self.session,\n                     span,"}, {"sha": "a21d8197bdbb3cb70e3271b9a7e6cfff2f765abe", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -1613,10 +1613,10 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                     self.r.record_partial_res(pat.id, PartialRes::new(res));\n                     self.r.record_pat_span(pat.id, pat.span);\n                 }\n-                PatKind::TupleStruct(ref path, ref sub_patterns) => {\n+                PatKind::TupleStruct(ref qself, ref path, ref sub_patterns) => {\n                     self.smart_resolve_path(\n                         pat.id,\n-                        None,\n+                        qself.as_ref(),\n                         path,\n                         PathSource::TupleStruct(\n                             pat.span,\n@@ -1627,8 +1627,8 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 PatKind::Path(ref qself, ref path) => {\n                     self.smart_resolve_path(pat.id, qself.as_ref(), path, PathSource::Pat);\n                 }\n-                PatKind::Struct(ref path, ..) => {\n-                    self.smart_resolve_path(pat.id, None, path, PathSource::Struct);\n+                PatKind::Struct(ref qself, ref path, ..) => {\n+                    self.smart_resolve_path(pat.id, qself.as_ref(), path, PathSource::Struct);\n                 }\n                 PatKind::Or(ref ps) => {\n                     // Add a new set of bindings to the stack. `Or` here records that when a\n@@ -1959,7 +1959,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 if ns == ValueNS {\n                     let item_name = path.last().unwrap().ident;\n                     let traits = self.traits_in_scope(item_name, ns);\n-                    self.r.trait_map.insert(id, traits);\n+                    self.r.trait_map.as_mut().unwrap().insert(id, traits);\n                 }\n \n                 if PrimTy::from_name(path[0].ident.name).is_some() {\n@@ -2288,7 +2288,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             }\n \n             ExprKind::Struct(ref se) => {\n-                self.smart_resolve_path(expr.id, None, &se.path, PathSource::Struct);\n+                self.smart_resolve_path(expr.id, se.qself.as_ref(), &se.path, PathSource::Struct);\n                 visit::walk_expr(self, expr);\n             }\n \n@@ -2435,12 +2435,12 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 // the field name so that we can do some nice error reporting\n                 // later on in typeck.\n                 let traits = self.traits_in_scope(ident, ValueNS);\n-                self.r.trait_map.insert(expr.id, traits);\n+                self.r.trait_map.as_mut().unwrap().insert(expr.id, traits);\n             }\n             ExprKind::MethodCall(ref segment, ..) => {\n                 debug!(\"(recording candidate traits for expr) recording traits for {}\", expr.id);\n                 let traits = self.traits_in_scope(segment.ident, ValueNS);\n-                self.r.trait_map.insert(expr.id, traits);\n+                self.r.trait_map.as_mut().unwrap().insert(expr.id, traits);\n             }\n             _ => {\n                 // Nothing to do."}, {"sha": "ca7cdc4caf5053d1841358129e3c4cae446601e0", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -1841,14 +1841,6 @@ fn object_lifetime_defaults_for_item(\n }\n \n impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n-    // FIXME(#37666) this works around a limitation in the region inferencer\n-    fn hack<F>(&mut self, f: F)\n-    where\n-        F: for<'b> FnOnce(&mut LifetimeContext<'b, 'tcx>),\n-    {\n-        f(self)\n-    }\n-\n     fn with<F>(&mut self, wrap_scope: Scope<'_>, f: F)\n     where\n         F: for<'b> FnOnce(ScopeRef<'_>, &mut LifetimeContext<'b, 'tcx>),\n@@ -2252,7 +2244,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         };\n         self.with(scope, move |old_scope, this| {\n             this.check_lifetime_params(old_scope, &generics.params);\n-            this.hack(walk); // FIXME(#37666) workaround in place of `walk(this)`\n+            walk(this);\n         });\n     }\n "}, {"sha": "6d5531d330783257109c0fa696522b0f5a7360dc", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -242,7 +242,7 @@ enum ResolutionError<'a> {\n         shadowed_binding_span: Span,\n     },\n     /// Error E0128: generic parameters with a default cannot use forward-declared identifiers.\n-    ForwardDeclaredTyParam, // FIXME(const_generics_defaults)\n+    ForwardDeclaredGenericParam,\n     /// ERROR E0770: the type of const parameters must not depend on other generic parameters.\n     ParamInTyOfConstParam(Symbol),\n     /// generic parameters must not be used inside const evaluations.\n@@ -909,7 +909,7 @@ pub struct Resolver<'a> {\n     /// `CrateNum` resolutions of `extern crate` items.\n     extern_crate_map: FxHashMap<LocalDefId, CrateNum>,\n     export_map: ExportMap<LocalDefId>,\n-    trait_map: NodeMap<Vec<TraitCandidate>>,\n+    trait_map: Option<NodeMap<Vec<TraitCandidate>>>,\n \n     /// A map from nodes to anonymous modules.\n     /// Anonymous modules are pseudo-modules that are implicitly created around items\n@@ -1138,8 +1138,8 @@ impl ResolverAstLowering for Resolver<'_> {\n         self.next_node_id()\n     }\n \n-    fn trait_map(&self) -> &NodeMap<Vec<TraitCandidate>> {\n-        &self.trait_map\n+    fn take_trait_map(&mut self) -> NodeMap<Vec<TraitCandidate>> {\n+        std::mem::replace(&mut self.trait_map, None).unwrap()\n     }\n \n     fn opt_local_def_id(&self, node: NodeId) -> Option<LocalDefId> {\n@@ -1198,7 +1198,7 @@ impl<'a> Resolver<'a> {\n         session: &'a Session,\n         krate: &Crate,\n         crate_name: &str,\n-        metadata_loader: &'a MetadataLoaderDyn,\n+        metadata_loader: Box<MetadataLoaderDyn>,\n         arenas: &'a ResolverArenas<'a>,\n     ) -> Resolver<'a> {\n         let root_local_def_id = LocalDefId { local_def_index: CRATE_DEF_INDEX };\n@@ -1286,7 +1286,7 @@ impl<'a> Resolver<'a> {\n             label_res_map: Default::default(),\n             extern_crate_map: Default::default(),\n             export_map: FxHashMap::default(),\n-            trait_map: Default::default(),\n+            trait_map: Some(NodeMap::default()),\n             underscore_disambiguator: 0,\n             empty_module,\n             module_map,\n@@ -2608,7 +2608,7 @@ impl<'a> Resolver<'a> {\n                 let res_error = if rib_ident.name == kw::SelfUpper {\n                     ResolutionError::SelfInTyParamDefault\n                 } else {\n-                    ResolutionError::ForwardDeclaredTyParam\n+                    ResolutionError::ForwardDeclaredGenericParam\n                 };\n                 self.report_error(span, res_error);\n             }"}, {"sha": "297383bfed1faf517f919eb4a5fde32485eda55a", "filename": "compiler/rustc_save_analysis/src/lib.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -823,20 +823,6 @@ impl<'tcx> SaveContext<'tcx> {\n                 // FIXME: Should save-analysis beautify doc strings itself or leave it to users?\n                 result.push_str(&beautify_doc_string(val).as_str());\n                 result.push('\\n');\n-            } else if self.tcx.sess.check_name(attr, sym::doc) {\n-                if let Some(meta_list) = attr.meta_item_list() {\n-                    meta_list\n-                        .into_iter()\n-                        .filter(|it| it.has_name(sym::include))\n-                        .filter_map(|it| it.meta_item_list().map(|l| l.to_owned()))\n-                        .flat_map(|it| it)\n-                        .filter(|meta| meta.has_name(sym::contents))\n-                        .filter_map(|meta| meta.value_str())\n-                        .for_each(|val| {\n-                            result.push_str(&val.as_str());\n-                            result.push('\\n');\n-                        });\n-                }\n             }\n         }\n "}, {"sha": "80a7f650188803f0e9a3a99ffdee40c5648b3604", "filename": "compiler/rustc_serialize/src/collection_impls.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_serialize%2Fsrc%2Fcollection_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_serialize%2Fsrc%2Fcollection_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fcollection_impls.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -21,8 +21,8 @@ impl<D: Decoder, A: Array<Item: Decodable<D>>> Decodable<D> for SmallVec<A> {\n         d.read_seq(|d, len| {\n             let mut vec = SmallVec::with_capacity(len);\n             // FIXME(#48994) - could just be collected into a Result<SmallVec, D::Error>\n-            for i in 0..len {\n-                vec.push(d.read_seq_elt(i, |d| Decodable::decode(d))?);\n+            for _ in 0..len {\n+                vec.push(d.read_seq_elt(|d| Decodable::decode(d))?);\n             }\n             Ok(vec)\n         })\n@@ -44,8 +44,8 @@ impl<D: Decoder, T: Decodable<D>> Decodable<D> for LinkedList<T> {\n     fn decode(d: &mut D) -> Result<LinkedList<T>, D::Error> {\n         d.read_seq(|d, len| {\n             let mut list = LinkedList::new();\n-            for i in 0..len {\n-                list.push_back(d.read_seq_elt(i, |d| Decodable::decode(d))?);\n+            for _ in 0..len {\n+                list.push_back(d.read_seq_elt(|d| Decodable::decode(d))?);\n             }\n             Ok(list)\n         })\n@@ -67,8 +67,8 @@ impl<D: Decoder, T: Decodable<D>> Decodable<D> for VecDeque<T> {\n     fn decode(d: &mut D) -> Result<VecDeque<T>, D::Error> {\n         d.read_seq(|d, len| {\n             let mut deque: VecDeque<T> = VecDeque::with_capacity(len);\n-            for i in 0..len {\n-                deque.push_back(d.read_seq_elt(i, |d| Decodable::decode(d))?);\n+            for _ in 0..len {\n+                deque.push_back(d.read_seq_elt(|d| Decodable::decode(d))?);\n             }\n             Ok(deque)\n         })\n@@ -84,7 +84,7 @@ where\n         e.emit_map(self.len(), |e| {\n             for (i, (key, val)) in self.iter().enumerate() {\n                 e.emit_map_elt_key(i, |e| key.encode(e))?;\n-                e.emit_map_elt_val(i, |e| val.encode(e))?;\n+                e.emit_map_elt_val(|e| val.encode(e))?;\n             }\n             Ok(())\n         })\n@@ -99,9 +99,9 @@ where\n     fn decode(d: &mut D) -> Result<BTreeMap<K, V>, D::Error> {\n         d.read_map(|d, len| {\n             let mut map = BTreeMap::new();\n-            for i in 0..len {\n-                let key = d.read_map_elt_key(i, |d| Decodable::decode(d))?;\n-                let val = d.read_map_elt_val(i, |d| Decodable::decode(d))?;\n+            for _ in 0..len {\n+                let key = d.read_map_elt_key(|d| Decodable::decode(d))?;\n+                let val = d.read_map_elt_val(|d| Decodable::decode(d))?;\n                 map.insert(key, val);\n             }\n             Ok(map)\n@@ -130,8 +130,8 @@ where\n     fn decode(d: &mut D) -> Result<BTreeSet<T>, D::Error> {\n         d.read_seq(|d, len| {\n             let mut set = BTreeSet::new();\n-            for i in 0..len {\n-                set.insert(d.read_seq_elt(i, |d| Decodable::decode(d))?);\n+            for _ in 0..len {\n+                set.insert(d.read_seq_elt(|d| Decodable::decode(d))?);\n             }\n             Ok(set)\n         })\n@@ -148,7 +148,7 @@ where\n         e.emit_map(self.len(), |e| {\n             for (i, (key, val)) in self.iter().enumerate() {\n                 e.emit_map_elt_key(i, |e| key.encode(e))?;\n-                e.emit_map_elt_val(i, |e| val.encode(e))?;\n+                e.emit_map_elt_val(|e| val.encode(e))?;\n             }\n             Ok(())\n         })\n@@ -165,9 +165,9 @@ where\n         d.read_map(|d, len| {\n             let state = Default::default();\n             let mut map = HashMap::with_capacity_and_hasher(len, state);\n-            for i in 0..len {\n-                let key = d.read_map_elt_key(i, |d| Decodable::decode(d))?;\n-                let val = d.read_map_elt_val(i, |d| Decodable::decode(d))?;\n+            for _ in 0..len {\n+                let key = d.read_map_elt_key(|d| Decodable::decode(d))?;\n+                let val = d.read_map_elt_val(|d| Decodable::decode(d))?;\n                 map.insert(key, val);\n             }\n             Ok(map)\n@@ -209,8 +209,8 @@ where\n         d.read_seq(|d, len| {\n             let state = Default::default();\n             let mut set = HashSet::with_capacity_and_hasher(len, state);\n-            for i in 0..len {\n-                set.insert(d.read_seq_elt(i, |d| Decodable::decode(d))?);\n+            for _ in 0..len {\n+                set.insert(d.read_seq_elt(|d| Decodable::decode(d))?);\n             }\n             Ok(set)\n         })\n@@ -227,7 +227,7 @@ where\n         e.emit_map(self.len(), |e| {\n             for (i, (key, val)) in self.iter().enumerate() {\n                 e.emit_map_elt_key(i, |e| key.encode(e))?;\n-                e.emit_map_elt_val(i, |e| val.encode(e))?;\n+                e.emit_map_elt_val(|e| val.encode(e))?;\n             }\n             Ok(())\n         })\n@@ -244,9 +244,9 @@ where\n         d.read_map(|d, len| {\n             let state = Default::default();\n             let mut map = indexmap::IndexMap::with_capacity_and_hasher(len, state);\n-            for i in 0..len {\n-                let key = d.read_map_elt_key(i, |d| Decodable::decode(d))?;\n-                let val = d.read_map_elt_val(i, |d| Decodable::decode(d))?;\n+            for _ in 0..len {\n+                let key = d.read_map_elt_key(|d| Decodable::decode(d))?;\n+                let val = d.read_map_elt_val(|d| Decodable::decode(d))?;\n                 map.insert(key, val);\n             }\n             Ok(map)\n@@ -278,8 +278,8 @@ where\n         d.read_seq(|d, len| {\n             let state = Default::default();\n             let mut set = indexmap::IndexSet::with_capacity_and_hasher(len, state);\n-            for i in 0..len {\n-                set.insert(d.read_seq_elt(i, |d| Decodable::decode(d))?);\n+            for _ in 0..len {\n+                set.insert(d.read_seq_elt(|d| Decodable::decode(d))?);\n             }\n             Ok(set)\n         })"}, {"sha": "b79adb6f7bcd92a5d2bb4287c018c3bfa84e2638", "filename": "compiler/rustc_serialize/src/json.rs", "status": "modified", "additions": 24, "deletions": 147, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_serialize%2Fsrc%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_serialize%2Fsrc%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fjson.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -560,7 +560,7 @@ impl<'a> crate::Encoder for Encoder<'a> {\n         Ok(())\n     }\n \n-    fn emit_enum<F>(&mut self, _name: &str, f: F) -> EncodeResult\n+    fn emit_enum<F>(&mut self, f: F) -> EncodeResult\n     where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n@@ -589,46 +589,20 @@ impl<'a> crate::Encoder for Encoder<'a> {\n         }\n     }\n \n-    fn emit_enum_variant_arg<F>(&mut self, idx: usize, f: F) -> EncodeResult\n+    fn emit_enum_variant_arg<F>(&mut self, first: bool, f: F) -> EncodeResult\n     where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key {\n             return Err(EncoderError::BadHashmapKey);\n         }\n-        if idx != 0 {\n+        if !first {\n             write!(self.writer, \",\")?;\n         }\n         f(self)\n     }\n \n-    fn emit_enum_struct_variant<F>(\n-        &mut self,\n-        name: &str,\n-        id: usize,\n-        cnt: usize,\n-        f: F,\n-    ) -> EncodeResult\n-    where\n-        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n-    {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        self.emit_enum_variant(name, id, cnt, f)\n-    }\n-\n-    fn emit_enum_struct_variant_field<F>(&mut self, _: &str, idx: usize, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n-    {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        self.emit_enum_variant_arg(idx, f)\n-    }\n-\n-    fn emit_struct<F>(&mut self, _: &str, _: usize, f: F) -> EncodeResult\n+    fn emit_struct<F>(&mut self, _: bool, f: F) -> EncodeResult\n     where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n@@ -641,14 +615,14 @@ impl<'a> crate::Encoder for Encoder<'a> {\n         Ok(())\n     }\n \n-    fn emit_struct_field<F>(&mut self, name: &str, idx: usize, f: F) -> EncodeResult\n+    fn emit_struct_field<F>(&mut self, name: &str, first: bool, f: F) -> EncodeResult\n     where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key {\n             return Err(EncoderError::BadHashmapKey);\n         }\n-        if idx != 0 {\n+        if !first {\n             write!(self.writer, \",\")?;\n         }\n         escape_str(self.writer, name)?;\n@@ -675,25 +649,6 @@ impl<'a> crate::Encoder for Encoder<'a> {\n         self.emit_seq_elt(idx, f)\n     }\n \n-    fn emit_tuple_struct<F>(&mut self, _name: &str, len: usize, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n-    {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        self.emit_seq(len, f)\n-    }\n-    fn emit_tuple_struct_arg<F>(&mut self, idx: usize, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n-    {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        self.emit_seq_elt(idx, f)\n-    }\n-\n     fn emit_option<F>(&mut self, f: F) -> EncodeResult\n     where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n@@ -774,7 +729,7 @@ impl<'a> crate::Encoder for Encoder<'a> {\n         Ok(())\n     }\n \n-    fn emit_map_elt_val<F>(&mut self, _idx: usize, f: F) -> EncodeResult\n+    fn emit_map_elt_val<F>(&mut self, f: F) -> EncodeResult\n     where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n@@ -892,7 +847,7 @@ impl<'a> crate::Encoder for PrettyEncoder<'a> {\n         Ok(())\n     }\n \n-    fn emit_enum<F>(&mut self, _name: &str, f: F) -> EncodeResult\n+    fn emit_enum<F>(&mut self, f: F) -> EncodeResult\n     where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n@@ -930,54 +885,28 @@ impl<'a> crate::Encoder for PrettyEncoder<'a> {\n         }\n     }\n \n-    fn emit_enum_variant_arg<F>(&mut self, idx: usize, f: F) -> EncodeResult\n+    fn emit_enum_variant_arg<F>(&mut self, first: bool, f: F) -> EncodeResult\n     where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key {\n             return Err(EncoderError::BadHashmapKey);\n         }\n-        if idx != 0 {\n+        if !first {\n             writeln!(self.writer, \",\")?;\n         }\n         spaces(self.writer, self.curr_indent)?;\n         f(self)\n     }\n \n-    fn emit_enum_struct_variant<F>(\n-        &mut self,\n-        name: &str,\n-        id: usize,\n-        cnt: usize,\n-        f: F,\n-    ) -> EncodeResult\n+    fn emit_struct<F>(&mut self, no_fields: bool, f: F) -> EncodeResult\n     where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key {\n             return Err(EncoderError::BadHashmapKey);\n         }\n-        self.emit_enum_variant(name, id, cnt, f)\n-    }\n-\n-    fn emit_enum_struct_variant_field<F>(&mut self, _: &str, idx: usize, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n-    {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        self.emit_enum_variant_arg(idx, f)\n-    }\n-\n-    fn emit_struct<F>(&mut self, _: &str, len: usize, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n-    {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        if len == 0 {\n+        if no_fields {\n             write!(self.writer, \"{{}}\")?;\n         } else {\n             write!(self.writer, \"{{\")?;\n@@ -991,14 +920,14 @@ impl<'a> crate::Encoder for PrettyEncoder<'a> {\n         Ok(())\n     }\n \n-    fn emit_struct_field<F>(&mut self, name: &str, idx: usize, f: F) -> EncodeResult\n+    fn emit_struct_field<F>(&mut self, name: &str, first: bool, f: F) -> EncodeResult\n     where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key {\n             return Err(EncoderError::BadHashmapKey);\n         }\n-        if idx == 0 {\n+        if first {\n             writeln!(self.writer)?;\n         } else {\n             writeln!(self.writer, \",\")?;\n@@ -1028,25 +957,6 @@ impl<'a> crate::Encoder for PrettyEncoder<'a> {\n         self.emit_seq_elt(idx, f)\n     }\n \n-    fn emit_tuple_struct<F>(&mut self, _: &str, len: usize, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n-    {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        self.emit_seq(len, f)\n-    }\n-    fn emit_tuple_struct_arg<F>(&mut self, idx: usize, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n-    {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        self.emit_seq_elt(idx, f)\n-    }\n-\n     fn emit_option<F>(&mut self, f: F) -> EncodeResult\n     where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n@@ -1149,7 +1059,7 @@ impl<'a> crate::Encoder for PrettyEncoder<'a> {\n         Ok(())\n     }\n \n-    fn emit_map_elt_val<F>(&mut self, _idx: usize, f: F) -> EncodeResult\n+    fn emit_map_elt_val<F>(&mut self, f: F) -> EncodeResult\n     where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n@@ -2373,7 +2283,7 @@ impl crate::Decoder for Decoder {\n         Ok(())\n     }\n \n-    fn read_enum<T, F>(&mut self, _name: &str, f: F) -> DecodeResult<T>\n+    fn read_enum<T, F>(&mut self, f: F) -> DecodeResult<T>\n     where\n         F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n     {\n@@ -2410,33 +2320,14 @@ impl crate::Decoder for Decoder {\n         f(self, idx)\n     }\n \n-    fn read_enum_variant_arg<T, F>(&mut self, _idx: usize, f: F) -> DecodeResult<T>\n+    fn read_enum_variant_arg<T, F>(&mut self, f: F) -> DecodeResult<T>\n     where\n         F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n     {\n         f(self)\n     }\n \n-    fn read_enum_struct_variant<T, F>(&mut self, names: &[&str], f: F) -> DecodeResult<T>\n-    where\n-        F: FnMut(&mut Decoder, usize) -> DecodeResult<T>,\n-    {\n-        self.read_enum_variant(names, f)\n-    }\n-\n-    fn read_enum_struct_variant_field<T, F>(\n-        &mut self,\n-        _name: &str,\n-        idx: usize,\n-        f: F,\n-    ) -> DecodeResult<T>\n-    where\n-        F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n-    {\n-        self.read_enum_variant_arg(idx, f)\n-    }\n-\n-    fn read_struct<T, F>(&mut self, _name: &str, _len: usize, f: F) -> DecodeResult<T>\n+    fn read_struct<T, F>(&mut self, f: F) -> DecodeResult<T>\n     where\n         F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n     {\n@@ -2445,7 +2336,7 @@ impl crate::Decoder for Decoder {\n         Ok(value)\n     }\n \n-    fn read_struct_field<T, F>(&mut self, name: &str, _idx: usize, f: F) -> DecodeResult<T>\n+    fn read_struct_field<T, F>(&mut self, name: &str, f: F) -> DecodeResult<T>\n     where\n         F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n     {\n@@ -2483,25 +2374,11 @@ impl crate::Decoder for Decoder {\n         })\n     }\n \n-    fn read_tuple_arg<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T>\n-    where\n-        F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n-    {\n-        self.read_seq_elt(idx, f)\n-    }\n-\n-    fn read_tuple_struct<T, F>(&mut self, _name: &str, len: usize, f: F) -> DecodeResult<T>\n-    where\n-        F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n-    {\n-        self.read_tuple(len, f)\n-    }\n-\n-    fn read_tuple_struct_arg<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T>\n+    fn read_tuple_arg<T, F>(&mut self, f: F) -> DecodeResult<T>\n     where\n         F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n     {\n-        self.read_tuple_arg(idx, f)\n+        self.read_seq_elt(f)\n     }\n \n     fn read_option<T, F>(&mut self, mut f: F) -> DecodeResult<T>\n@@ -2527,7 +2404,7 @@ impl crate::Decoder for Decoder {\n         f(self, len)\n     }\n \n-    fn read_seq_elt<T, F>(&mut self, _idx: usize, f: F) -> DecodeResult<T>\n+    fn read_seq_elt<T, F>(&mut self, f: F) -> DecodeResult<T>\n     where\n         F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n     {\n@@ -2547,14 +2424,14 @@ impl crate::Decoder for Decoder {\n         f(self, len)\n     }\n \n-    fn read_map_elt_key<T, F>(&mut self, _idx: usize, f: F) -> DecodeResult<T>\n+    fn read_map_elt_key<T, F>(&mut self, f: F) -> DecodeResult<T>\n     where\n         F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n     {\n         f(self)\n     }\n \n-    fn read_map_elt_val<T, F>(&mut self, _idx: usize, f: F) -> DecodeResult<T>\n+    fn read_map_elt_val<T, F>(&mut self, f: F) -> DecodeResult<T>\n     where\n         F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n     {"}, {"sha": "c79786a839fc46feecc9b793129ee257519dee64", "filename": "compiler/rustc_serialize/src/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_serialize%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_serialize%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Flib.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -14,10 +14,7 @@ Core encoding and decoding interfaces.\n #![feature(nll)]\n #![feature(associated_type_bounds)]\n #![feature(min_specialization)]\n-#![feature(vec_spare_capacity)]\n #![feature(core_intrinsics)]\n-#![feature(maybe_uninit_array_assume_init)]\n-#![feature(maybe_uninit_uninit_array)]\n #![feature(maybe_uninit_slice)]\n #![feature(new_uninit)]\n #![cfg_attr(test, feature(test))]"}, {"sha": "bb3c537ef1949c024637efa50612078c794854d0", "filename": "compiler/rustc_serialize/src/serialize.rs", "status": "modified", "additions": 25, "deletions": 108, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -37,7 +37,7 @@ pub trait Encoder {\n \n     // Compound types:\n     #[inline]\n-    fn emit_enum<F>(&mut self, _name: &str, f: F) -> Result<(), Self::Error>\n+    fn emit_enum<F>(&mut self, f: F) -> Result<(), Self::Error>\n     where\n         F: FnOnce(&mut Self) -> Result<(), Self::Error>,\n     {\n@@ -59,53 +59,23 @@ pub trait Encoder {\n     }\n \n     #[inline]\n-    fn emit_enum_variant_arg<F>(&mut self, _a_idx: usize, f: F) -> Result<(), Self::Error>\n+    fn emit_enum_variant_arg<F>(&mut self, _first: bool, f: F) -> Result<(), Self::Error>\n     where\n         F: FnOnce(&mut Self) -> Result<(), Self::Error>,\n     {\n         f(self)\n     }\n \n-    fn emit_enum_struct_variant<F>(\n-        &mut self,\n-        v_name: &str,\n-        v_id: usize,\n-        len: usize,\n-        f: F,\n-    ) -> Result<(), Self::Error>\n-    where\n-        F: FnOnce(&mut Self) -> Result<(), Self::Error>,\n-    {\n-        self.emit_enum_variant(v_name, v_id, len, f)\n-    }\n-\n-    fn emit_enum_struct_variant_field<F>(\n-        &mut self,\n-        _f_name: &str,\n-        f_idx: usize,\n-        f: F,\n-    ) -> Result<(), Self::Error>\n-    where\n-        F: FnOnce(&mut Self) -> Result<(), Self::Error>,\n-    {\n-        self.emit_enum_variant_arg(f_idx, f)\n-    }\n-\n     #[inline]\n-    fn emit_struct<F>(&mut self, _name: &str, _len: usize, f: F) -> Result<(), Self::Error>\n+    fn emit_struct<F>(&mut self, _no_fields: bool, f: F) -> Result<(), Self::Error>\n     where\n         F: FnOnce(&mut Self) -> Result<(), Self::Error>,\n     {\n         f(self)\n     }\n \n     #[inline]\n-    fn emit_struct_field<F>(\n-        &mut self,\n-        _f_name: &str,\n-        _f_idx: usize,\n-        f: F,\n-    ) -> Result<(), Self::Error>\n+    fn emit_struct_field<F>(&mut self, _f_name: &str, _first: bool, f: F) -> Result<(), Self::Error>\n     where\n         F: FnOnce(&mut Self) -> Result<(), Self::Error>,\n     {\n@@ -128,26 +98,12 @@ pub trait Encoder {\n         f(self)\n     }\n \n-    fn emit_tuple_struct<F>(&mut self, _name: &str, len: usize, f: F) -> Result<(), Self::Error>\n-    where\n-        F: FnOnce(&mut Self) -> Result<(), Self::Error>,\n-    {\n-        self.emit_tuple(len, f)\n-    }\n-\n-    fn emit_tuple_struct_arg<F>(&mut self, f_idx: usize, f: F) -> Result<(), Self::Error>\n-    where\n-        F: FnOnce(&mut Self) -> Result<(), Self::Error>,\n-    {\n-        self.emit_tuple_arg(f_idx, f)\n-    }\n-\n     // Specialized types:\n     fn emit_option<F>(&mut self, f: F) -> Result<(), Self::Error>\n     where\n         F: FnOnce(&mut Self) -> Result<(), Self::Error>,\n     {\n-        self.emit_enum(\"Option\", f)\n+        self.emit_enum(f)\n     }\n \n     #[inline]\n@@ -195,7 +151,7 @@ pub trait Encoder {\n     }\n \n     #[inline]\n-    fn emit_map_elt_val<F>(&mut self, _idx: usize, f: F) -> Result<(), Self::Error>\n+    fn emit_map_elt_val<F>(&mut self, f: F) -> Result<(), Self::Error>\n     where\n         F: FnOnce(&mut Self) -> Result<(), Self::Error>,\n     {\n@@ -229,7 +185,7 @@ pub trait Decoder {\n \n     // Compound types:\n     #[inline]\n-    fn read_enum<T, F>(&mut self, _name: &str, f: F) -> Result<T, Self::Error>\n+    fn read_enum<T, F>(&mut self, f: F) -> Result<T, Self::Error>\n     where\n         F: FnOnce(&mut Self) -> Result<T, Self::Error>,\n     {\n@@ -246,47 +202,23 @@ pub trait Decoder {\n     }\n \n     #[inline]\n-    fn read_enum_variant_arg<T, F>(&mut self, _a_idx: usize, f: F) -> Result<T, Self::Error>\n+    fn read_enum_variant_arg<T, F>(&mut self, f: F) -> Result<T, Self::Error>\n     where\n         F: FnOnce(&mut Self) -> Result<T, Self::Error>,\n     {\n         f(self)\n     }\n \n-    fn read_enum_struct_variant<T, F>(&mut self, names: &[&str], f: F) -> Result<T, Self::Error>\n-    where\n-        F: FnMut(&mut Self, usize) -> Result<T, Self::Error>,\n-    {\n-        self.read_enum_variant(names, f)\n-    }\n-\n-    fn read_enum_struct_variant_field<T, F>(\n-        &mut self,\n-        _f_name: &str,\n-        f_idx: usize,\n-        f: F,\n-    ) -> Result<T, Self::Error>\n-    where\n-        F: FnOnce(&mut Self) -> Result<T, Self::Error>,\n-    {\n-        self.read_enum_variant_arg(f_idx, f)\n-    }\n-\n     #[inline]\n-    fn read_struct<T, F>(&mut self, _s_name: &str, _len: usize, f: F) -> Result<T, Self::Error>\n+    fn read_struct<T, F>(&mut self, f: F) -> Result<T, Self::Error>\n     where\n         F: FnOnce(&mut Self) -> Result<T, Self::Error>,\n     {\n         f(self)\n     }\n \n     #[inline]\n-    fn read_struct_field<T, F>(\n-        &mut self,\n-        _f_name: &str,\n-        _f_idx: usize,\n-        f: F,\n-    ) -> Result<T, Self::Error>\n+    fn read_struct_field<T, F>(&mut self, _f_name: &str, f: F) -> Result<T, Self::Error>\n     where\n         F: FnOnce(&mut Self) -> Result<T, Self::Error>,\n     {\n@@ -302,33 +234,19 @@ pub trait Decoder {\n     }\n \n     #[inline]\n-    fn read_tuple_arg<T, F>(&mut self, _a_idx: usize, f: F) -> Result<T, Self::Error>\n+    fn read_tuple_arg<T, F>(&mut self, f: F) -> Result<T, Self::Error>\n     where\n         F: FnOnce(&mut Self) -> Result<T, Self::Error>,\n     {\n         f(self)\n     }\n \n-    fn read_tuple_struct<T, F>(&mut self, _s_name: &str, len: usize, f: F) -> Result<T, Self::Error>\n-    where\n-        F: FnOnce(&mut Self) -> Result<T, Self::Error>,\n-    {\n-        self.read_tuple(len, f)\n-    }\n-\n-    fn read_tuple_struct_arg<T, F>(&mut self, a_idx: usize, f: F) -> Result<T, Self::Error>\n-    where\n-        F: FnOnce(&mut Self) -> Result<T, Self::Error>,\n-    {\n-        self.read_tuple_arg(a_idx, f)\n-    }\n-\n     // Specialized types:\n     fn read_option<T, F>(&mut self, mut f: F) -> Result<T, Self::Error>\n     where\n         F: FnMut(&mut Self, bool) -> Result<T, Self::Error>,\n     {\n-        self.read_enum(\"Option\", move |this| {\n+        self.read_enum(move |this| {\n             this.read_enum_variant(&[\"None\", \"Some\"], move |this, idx| match idx {\n                 0 => f(this, false),\n                 1 => f(this, true),\n@@ -346,7 +264,7 @@ pub trait Decoder {\n     }\n \n     #[inline]\n-    fn read_seq_elt<T, F>(&mut self, _idx: usize, f: F) -> Result<T, Self::Error>\n+    fn read_seq_elt<T, F>(&mut self, f: F) -> Result<T, Self::Error>\n     where\n         F: FnOnce(&mut Self) -> Result<T, Self::Error>,\n     {\n@@ -362,15 +280,15 @@ pub trait Decoder {\n     }\n \n     #[inline]\n-    fn read_map_elt_key<T, F>(&mut self, _idx: usize, f: F) -> Result<T, Self::Error>\n+    fn read_map_elt_key<T, F>(&mut self, f: F) -> Result<T, Self::Error>\n     where\n         F: FnOnce(&mut Self) -> Result<T, Self::Error>,\n     {\n         f(self)\n     }\n \n     #[inline]\n-    fn read_map_elt_val<T, F>(&mut self, _idx: usize, f: F) -> Result<T, Self::Error>\n+    fn read_map_elt_val<T, F>(&mut self, f: F) -> Result<T, Self::Error>\n     where\n         F: FnOnce(&mut Self) -> Result<T, Self::Error>,\n     {\n@@ -550,8 +468,8 @@ impl<D: Decoder, T: Decodable<D>> Decodable<D> for Vec<T> {\n     default fn decode(d: &mut D) -> Result<Vec<T>, D::Error> {\n         d.read_seq(|d, len| {\n             let mut v = Vec::with_capacity(len);\n-            for i in 0..len {\n-                v.push(d.read_seq_elt(i, |d| Decodable::decode(d))?);\n+            for _ in 0..len {\n+                v.push(d.read_seq_elt(|d| Decodable::decode(d))?);\n             }\n             Ok(v)\n         })\n@@ -571,7 +489,7 @@ impl<D: Decoder, const N: usize> Decodable<D> for [u8; N] {\n             assert!(len == N);\n             let mut v = [0u8; N];\n             for i in 0..len {\n-                v[i] = d.read_seq_elt(i, |d| Decodable::decode(d))?;\n+                v[i] = d.read_seq_elt(|d| Decodable::decode(d))?;\n             }\n             Ok(v)\n         })\n@@ -615,23 +533,23 @@ impl<D: Decoder, T: Decodable<D>> Decodable<D> for Option<T> {\n \n impl<S: Encoder, T1: Encodable<S>, T2: Encodable<S>> Encodable<S> for Result<T1, T2> {\n     fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_enum(\"Result\", |s| match *self {\n+        s.emit_enum(|s| match *self {\n             Ok(ref v) => {\n-                s.emit_enum_variant(\"Ok\", 0, 1, |s| s.emit_enum_variant_arg(0, |s| v.encode(s)))\n+                s.emit_enum_variant(\"Ok\", 0, 1, |s| s.emit_enum_variant_arg(true, |s| v.encode(s)))\n             }\n             Err(ref v) => {\n-                s.emit_enum_variant(\"Err\", 1, 1, |s| s.emit_enum_variant_arg(0, |s| v.encode(s)))\n+                s.emit_enum_variant(\"Err\", 1, 1, |s| s.emit_enum_variant_arg(true, |s| v.encode(s)))\n             }\n         })\n     }\n }\n \n impl<D: Decoder, T1: Decodable<D>, T2: Decodable<D>> Decodable<D> for Result<T1, T2> {\n     fn decode(d: &mut D) -> Result<Result<T1, T2>, D::Error> {\n-        d.read_enum(\"Result\", |d| {\n+        d.read_enum(|d| {\n             d.read_enum_variant(&[\"Ok\", \"Err\"], |d, disr| match disr {\n-                0 => Ok(Ok(d.read_enum_variant_arg(0, |d| T1::decode(d))?)),\n-                1 => Ok(Err(d.read_enum_variant_arg(0, |d| T2::decode(d))?)),\n+                0 => Ok(Ok(d.read_enum_variant_arg(|d| T1::decode(d))?)),\n+                1 => Ok(Err(d.read_enum_variant_arg(|d| T2::decode(d))?)),\n                 _ => {\n                     panic!(\n                         \"Encountered invalid discriminant while \\\n@@ -668,8 +586,7 @@ macro_rules! tuple {\n             fn decode(d: &mut D) -> Result<($($name,)+), D::Error> {\n                 let len: usize = count!($($name)+);\n                 d.read_tuple(len, |d| {\n-                    let mut i = 0;\n-                    let ret = ($(d.read_tuple_arg({ i+=1; i-1 }, |d| -> Result<$name, D::Error> {\n+                    let ret = ($(d.read_tuple_arg(|d| -> Result<$name, D::Error> {\n                         Decodable::decode(d)\n                     })?,)+);\n                     Ok(ret)"}, {"sha": "2b547f8be92286559e4d14dc2513d1b9cb3ac2df", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 56, "deletions": 46, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -677,6 +677,7 @@ impl Default for Options {\n             optimize: OptLevel::No,\n             debuginfo: DebugInfo::None,\n             lint_opts: Vec::new(),\n+            force_warns: Vec::new(),\n             lint_cap: None,\n             describe_lints: false,\n             output_types: OutputTypes(BTreeMap::new()),\n@@ -1092,6 +1093,13 @@ pub fn rustc_short_optgroups() -> Vec<RustcOptGroup> {\n              level\",\n             \"LEVEL\",\n         ),\n+        opt::multi_s(\n+            \"\",\n+            \"force-warns\",\n+            \"Specifiy lints that should warn even if \\\n+             they are allowed somewhere else\",\n+            \"LINT\",\n+        ),\n         opt::multi_s(\"C\", \"codegen\", \"Set a codegen option\", \"OPT[=VALUE]\"),\n         opt::flag_s(\"V\", \"version\", \"Print version info and exit\"),\n         opt::flag_s(\"v\", \"verbose\", \"Use verbose output\"),\n@@ -1156,7 +1164,8 @@ pub fn rustc_optgroups() -> Vec<RustcOptGroup> {\n pub fn get_cmd_lint_options(\n     matches: &getopts::Matches,\n     error_format: ErrorOutputType,\n-) -> (Vec<(String, lint::Level)>, bool, Option<lint::Level>) {\n+    debugging_opts: &DebuggingOptions,\n+) -> (Vec<(String, lint::Level)>, bool, Option<lint::Level>, Vec<String>) {\n     let mut lint_opts_with_position = vec![];\n     let mut describe_lints = false;\n \n@@ -1189,7 +1198,18 @@ pub fn get_cmd_lint_options(\n         lint::Level::from_str(&cap)\n             .unwrap_or_else(|| early_error(error_format, &format!(\"unknown lint level: `{}`\", cap)))\n     });\n-    (lint_opts, describe_lints, lint_cap)\n+\n+    if !debugging_opts.unstable_options && matches.opt_present(\"force-warns\") {\n+        early_error(\n+            error_format,\n+            \"the `-Z unstable-options` flag must also be passed to enable \\\n+            the flag `--force-warns=lints`\",\n+        );\n+    }\n+\n+    let force_warns = matches.opt_strs(\"force-warns\");\n+\n+    (lint_opts, describe_lints, lint_cap, force_warns)\n }\n \n /// Parses the `--color` flag.\n@@ -1926,9 +1946,10 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n     let crate_types = parse_crate_types_from_list(unparsed_crate_types)\n         .unwrap_or_else(|e| early_error(error_format, &e[..]));\n \n-    let (lint_opts, describe_lints, lint_cap) = get_cmd_lint_options(matches, error_format);\n-\n     let mut debugging_opts = DebuggingOptions::build(matches, error_format);\n+    let (lint_opts, describe_lints, lint_cap, force_warns) =\n+        get_cmd_lint_options(matches, error_format, &debugging_opts);\n+\n     check_debug_option_stability(&debugging_opts, error_format, json_rendered);\n \n     if !debugging_opts.unstable_options && json_unused_externs {\n@@ -2100,6 +2121,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         optimize: opt_level,\n         debuginfo,\n         lint_opts,\n+        force_warns,\n         lint_cap,\n         describe_lints,\n         output_types,\n@@ -2395,6 +2417,7 @@ impl PpMode {\n /// we have an opt-in scheme here, so one is hopefully forced to think about\n /// how the hash should be calculated when adding a new command-line argument.\n crate mod dep_tracking {\n+    use super::LdImpl;\n     use super::{\n         CFGuard, CrateType, DebugInfo, ErrorOutputType, InstrumentCoverage, LinkerPluginLto,\n         LtoCli, OptLevel, OutputTypes, Passes, SourceFileHashAlgorithm, SwitchWithOptPath,\n@@ -2427,46 +2450,32 @@ crate mod dep_tracking {\n         )+};\n     }\n \n-    macro_rules! impl_dep_tracking_hash_for_sortable_vec_of {\n-        ($($t:ty),+ $(,)?) => {$(\n-            impl DepTrackingHash for Vec<$t> {\n-                fn hash(&self, hasher: &mut DefaultHasher, error_format: ErrorOutputType) {\n-                    let mut elems: Vec<&$t> = self.iter().collect();\n-                    elems.sort();\n-                    Hash::hash(&elems.len(), hasher);\n-                    for (index, elem) in elems.iter().enumerate() {\n-                        Hash::hash(&index, hasher);\n-                        DepTrackingHash::hash(*elem, hasher, error_format);\n-                    }\n+    impl<T: DepTrackingHash> DepTrackingHash for Option<T> {\n+        fn hash(&self, hasher: &mut DefaultHasher, error_format: ErrorOutputType) {\n+            match self {\n+                Some(x) => {\n+                    Hash::hash(&1, hasher);\n+                    DepTrackingHash::hash(x, hasher, error_format);\n                 }\n+                None => Hash::hash(&0, hasher),\n             }\n-        )+};\n+        }\n     }\n \n     impl_dep_tracking_hash_via_hash!(\n         bool,\n         usize,\n+        NonZeroUsize,\n         u64,\n         String,\n         PathBuf,\n         lint::Level,\n-        Option<bool>,\n-        Option<u32>,\n-        Option<usize>,\n-        Option<NonZeroUsize>,\n-        Option<String>,\n-        Option<(String, u64)>,\n-        Option<Vec<String>>,\n-        Option<MergeFunctions>,\n-        Option<RelocModel>,\n-        Option<CodeModel>,\n-        Option<TlsModel>,\n-        Option<WasiExecModel>,\n-        Option<PanicStrategy>,\n-        Option<RelroLevel>,\n-        Option<InstrumentCoverage>,\n-        Option<lint::Level>,\n-        Option<PathBuf>,\n+        WasiExecModel,\n+        u32,\n+        RelocModel,\n+        CodeModel,\n+        TlsModel,\n+        InstrumentCoverage,\n         CrateType,\n         MergeFunctions,\n         PanicStrategy,\n@@ -2484,21 +2493,12 @@ crate mod dep_tracking {\n         TargetTriple,\n         Edition,\n         LinkerPluginLto,\n-        Option<SplitDebuginfo>,\n+        SplitDebuginfo,\n         SwitchWithOptPath,\n-        Option<SymbolManglingVersion>,\n-        Option<SourceFileHashAlgorithm>,\n+        SymbolManglingVersion,\n+        SourceFileHashAlgorithm,\n         TrimmedDefPaths,\n-    );\n-\n-    impl_dep_tracking_hash_for_sortable_vec_of!(\n-        String,\n-        PathBuf,\n-        (PathBuf, PathBuf),\n-        CrateType,\n-        NativeLib,\n-        (String, lint::Level),\n-        (String, u64)\n+        Option<LdImpl>,\n     );\n \n     impl<T1, T2> DepTrackingHash for (T1, T2)\n@@ -2530,6 +2530,16 @@ crate mod dep_tracking {\n         }\n     }\n \n+    impl<T: DepTrackingHash> DepTrackingHash for Vec<T> {\n+        fn hash(&self, hasher: &mut DefaultHasher, error_format: ErrorOutputType) {\n+            Hash::hash(&self.len(), hasher);\n+            for (index, elem) in self.iter().enumerate() {\n+                Hash::hash(&index, hasher);\n+                DepTrackingHash::hash(elem, hasher, error_format);\n+            }\n+        }\n+    }\n+\n     // This is a stable hash because BTreeMap is a sorted container\n     crate fn stable_hash(\n         sub_hashes: BTreeMap<&'static str, &dyn DepTrackingHash>,"}, {"sha": "1946bfd78cc38ebab2b757616d79c7dacfe1be18", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -130,6 +130,7 @@ top_level_options!(\n         debuginfo: DebugInfo [TRACKED],\n         lint_opts: Vec<(String, lint::Level)> [TRACKED],\n         lint_cap: Option<lint::Level> [TRACKED],\n+        force_warns: Vec<String> [TRACKED],\n         describe_lints: bool [UNTRACKED],\n         output_types: OutputTypes [TRACKED],\n         search_paths: Vec<SearchPath> [UNTRACKED],\n@@ -368,7 +369,8 @@ mod desc {\n     pub const parse_target_feature: &str = parse_string;\n     pub const parse_wasi_exec_model: &str = \"either `command` or `reactor`\";\n     pub const parse_split_debuginfo: &str =\n-        \"one of supported split-debuginfo modes (`off` or `dsymutil`)\";\n+        \"one of supported split-debuginfo modes (`off`, `packed`, or `unpacked`)\";\n+    pub const parse_gcc_ld: &str = \"one of: no value, `lld`\";\n }\n \n mod parse {\n@@ -863,6 +865,15 @@ mod parse {\n         }\n         true\n     }\n+\n+    crate fn parse_gcc_ld(slot: &mut Option<LdImpl>, v: Option<&str>) -> bool {\n+        match v {\n+            None => *slot = None,\n+            Some(\"lld\") => *slot = Some(LdImpl::Lld),\n+            _ => return false,\n+        }\n+        true\n+    }\n }\n \n options! {\n@@ -1066,6 +1077,7 @@ options! {\n         \"set the optimization fuel quota for a crate\"),\n     function_sections: Option<bool> = (None, parse_opt_bool, [TRACKED],\n         \"whether each function should go in its own section\"),\n+    gcc_ld: Option<LdImpl> = (None, parse_gcc_ld, [TRACKED], \"implementation of ld used by cc\"),\n     graphviz_dark_mode: bool = (false, parse_bool, [UNTRACKED],\n         \"use dark-themed colors in graphviz output (default: no)\"),\n     graphviz_font: String = (\"Courier, monospace\".to_string(), parse_string, [UNTRACKED],\n@@ -1320,3 +1332,8 @@ pub enum WasiExecModel {\n     Command,\n     Reactor,\n }\n+\n+#[derive(Clone, Copy, Hash)]\n+pub enum LdImpl {\n+    Lld,\n+}"}, {"sha": "cc1e4bb198a3b4c2c204b0f85ceddbd1e3e3886d", "filename": "compiler/rustc_session/src/output.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_session%2Fsrc%2Foutput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_session%2Fsrc%2Foutput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foutput.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -127,6 +127,11 @@ pub fn filename_for_metadata(\n     crate_name: &str,\n     outputs: &OutputFilenames,\n ) -> PathBuf {\n+    // If the command-line specified the path, use that directly.\n+    if let Some(Some(out_filename)) = sess.opts.output_types.get(&OutputType::Metadata) {\n+        return out_filename.clone();\n+    }\n+\n     let libname = format!(\"{}{}\", crate_name, sess.opts.cg.extra_filename);\n \n     let out_filename = outputs"}, {"sha": "86b8389a670e624e5b51d3b495ea91d87199ab74", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -452,6 +452,7 @@ impl Session {\n     pub fn emit_err<'a>(&'a self, err: impl SessionDiagnostic<'a>) {\n         err.into_diagnostic(self).emit()\n     }\n+    #[inline]\n     pub fn err_count(&self) -> usize {\n         self.diagnostic().err_count()\n     }\n@@ -524,6 +525,7 @@ impl Session {\n         self.diagnostic().struct_note_without_error(msg)\n     }\n \n+    #[inline]\n     pub fn diagnostic(&self) -> &rustc_errors::Handler {\n         &self.parse_sess.span_diagnostic\n     }\n@@ -1512,6 +1514,14 @@ fn validate_commandline_args_with_session_available(sess: &Session) {\n     if let (Some(first), Some(second)) = (sanitizer_iter.next(), sanitizer_iter.next()) {\n         sess.err(&format!(\"`-Zsanitizer={}` is incompatible with `-Zsanitizer={}`\", first, second));\n     }\n+\n+    // Cannot enable crt-static with sanitizers on Linux\n+    if sess.crt_static(None) && !sess.opts.debugging_opts.sanitizer.is_empty() {\n+        sess.err(\n+            \"Sanitizer is incompatible with statically linked libc, \\\n+                                disable it using `-C target-feature=-crt-static`\",\n+        );\n+    }\n }\n \n /// Holds data on the current incremental compilation session, if there is one."}, {"sha": "bb4ac22d9c867d6ef037d4fe66a2a715b278f08d", "filename": "compiler/rustc_span/src/def_id.rs", "status": "modified", "additions": 51, "deletions": 69, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -1,7 +1,7 @@\n use crate::crate_disambiguator::CrateDisambiguator;\n use crate::HashStableContext;\n use rustc_data_structures::fingerprint::Fingerprint;\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher, ToStableHashKey};\n use rustc_data_structures::AtomicRef;\n use rustc_index::vec::Idx;\n use rustc_macros::HashStable_Generic;\n@@ -10,76 +10,31 @@ use std::borrow::Borrow;\n use std::fmt;\n \n rustc_index::newtype_index! {\n-    pub struct CrateId {\n+    pub struct CrateNum {\n         ENCODABLE = custom\n+        DEBUG_FORMAT = \"crate{}\"\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub enum CrateNum {\n-    /// A special `CrateNum` that we use for the `tcx.rcache` when decoding from\n-    /// the incr. comp. cache.\n-    ReservedForIncrCompCache,\n-    Index(CrateId),\n-}\n-\n /// Item definitions in the currently-compiled crate would have the `CrateNum`\n /// `LOCAL_CRATE` in their `DefId`.\n-pub const LOCAL_CRATE: CrateNum = CrateNum::Index(CrateId::from_u32(0));\n-\n-impl Idx for CrateNum {\n-    #[inline]\n-    fn new(value: usize) -> Self {\n-        CrateNum::Index(Idx::new(value))\n-    }\n-\n-    #[inline]\n-    fn index(self) -> usize {\n-        match self {\n-            CrateNum::Index(idx) => Idx::index(idx),\n-            _ => panic!(\"Tried to get crate index of {:?}\", self),\n-        }\n-    }\n-}\n+pub const LOCAL_CRATE: CrateNum = CrateNum::from_u32(0);\n \n impl CrateNum {\n+    #[inline]\n     pub fn new(x: usize) -> CrateNum {\n         CrateNum::from_usize(x)\n     }\n \n-    pub fn from_usize(x: usize) -> CrateNum {\n-        CrateNum::Index(CrateId::from_usize(x))\n-    }\n-\n-    pub fn from_u32(x: u32) -> CrateNum {\n-        CrateNum::Index(CrateId::from_u32(x))\n-    }\n-\n-    pub fn as_usize(self) -> usize {\n-        match self {\n-            CrateNum::Index(id) => id.as_usize(),\n-            _ => panic!(\"tried to get index of non-standard crate {:?}\", self),\n-        }\n-    }\n-\n-    pub fn as_u32(self) -> u32 {\n-        match self {\n-            CrateNum::Index(id) => id.as_u32(),\n-            _ => panic!(\"tried to get index of non-standard crate {:?}\", self),\n-        }\n-    }\n-\n+    #[inline]\n     pub fn as_def_id(&self) -> DefId {\n         DefId { krate: *self, index: CRATE_DEF_INDEX }\n     }\n }\n \n impl fmt::Display for CrateNum {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self {\n-            CrateNum::Index(id) => fmt::Display::fmt(&id.private, f),\n-            CrateNum::ReservedForIncrCompCache => write!(f, \"crate for decoding incr comp cache\"),\n-        }\n+        fmt::Display::fmt(&self.private, f)\n     }\n }\n \n@@ -97,15 +52,6 @@ impl<D: Decoder> Decodable<D> for CrateNum {\n     }\n }\n \n-impl ::std::fmt::Debug for CrateNum {\n-    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {\n-        match self {\n-            CrateNum::Index(id) => write!(fmt, \"crate{}\", id.private),\n-            CrateNum::ReservedForIncrCompCache => write!(fmt, \"crate for decoding incr comp cache\"),\n-        }\n-    }\n-}\n-\n /// A `DefPathHash` is a fixed-size representation of a `DefPath` that is\n /// stable across crate and compilation session boundaries. It consists of two\n /// separate 64-bit hashes. The first uniquely identifies the crate this\n@@ -271,20 +217,20 @@ impl DefId {\n \n impl<E: Encoder> Encodable<E> for DefId {\n     default fn encode(&self, s: &mut E) -> Result<(), E::Error> {\n-        s.emit_struct(\"DefId\", 2, |s| {\n-            s.emit_struct_field(\"krate\", 0, |s| self.krate.encode(s))?;\n+        s.emit_struct(false, |s| {\n+            s.emit_struct_field(\"krate\", true, |s| self.krate.encode(s))?;\n \n-            s.emit_struct_field(\"index\", 1, |s| self.index.encode(s))\n+            s.emit_struct_field(\"index\", false, |s| self.index.encode(s))\n         })\n     }\n }\n \n impl<D: Decoder> Decodable<D> for DefId {\n     default fn decode(d: &mut D) -> Result<DefId, D::Error> {\n-        d.read_struct(\"DefId\", 2, |d| {\n+        d.read_struct(|d| {\n             Ok(DefId {\n-                krate: d.read_struct_field(\"krate\", 0, Decodable::decode)?,\n-                index: d.read_struct_field(\"index\", 1, Decodable::decode)?,\n+                krate: d.read_struct_field(\"krate\", Decodable::decode)?,\n+                index: d.read_struct_field(\"index\", Decodable::decode)?,\n             })\n         })\n     }\n@@ -362,13 +308,49 @@ impl<D: Decoder> Decodable<D> for LocalDefId {\n rustc_data_structures::define_id_collections!(LocalDefIdMap, LocalDefIdSet, LocalDefId);\n \n impl<CTX: HashStableContext> HashStable<CTX> for DefId {\n+    #[inline]\n+    fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {\n+        self.to_stable_hash_key(hcx).hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<CTX: HashStableContext> HashStable<CTX> for LocalDefId {\n+    #[inline]\n     fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {\n-        hcx.hash_def_id(*self, hasher)\n+        self.to_stable_hash_key(hcx).hash_stable(hcx, hasher);\n     }\n }\n \n impl<CTX: HashStableContext> HashStable<CTX> for CrateNum {\n+    #[inline]\n     fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {\n-        hcx.hash_crate_num(*self, hasher)\n+        self.to_stable_hash_key(hcx).hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<CTX: HashStableContext> ToStableHashKey<CTX> for DefId {\n+    type KeyType = DefPathHash;\n+\n+    #[inline]\n+    fn to_stable_hash_key(&self, hcx: &CTX) -> DefPathHash {\n+        hcx.def_path_hash(*self)\n+    }\n+}\n+\n+impl<CTX: HashStableContext> ToStableHashKey<CTX> for LocalDefId {\n+    type KeyType = DefPathHash;\n+\n+    #[inline]\n+    fn to_stable_hash_key(&self, hcx: &CTX) -> DefPathHash {\n+        hcx.def_path_hash(self.to_def_id())\n+    }\n+}\n+\n+impl<CTX: HashStableContext> ToStableHashKey<CTX> for CrateNum {\n+    type KeyType = DefPathHash;\n+\n+    #[inline]\n+    fn to_stable_hash_key(&self, hcx: &CTX) -> DefPathHash {\n+        self.as_def_id().to_stable_hash_key(hcx)\n     }\n }"}, {"sha": "23efaf6f4f33d861c5d59c5a4b86c2ac72bc3e1b", "filename": "compiler/rustc_span/src/hygiene.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -29,7 +29,7 @@ use crate::symbol::{kw, sym, Symbol};\n use crate::SESSION_GLOBALS;\n use crate::{BytePos, CachingSourceMapView, ExpnIdCache, SourceFile, Span, DUMMY_SP};\n \n-use crate::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use crate::def_id::{CrateNum, DefId, DefPathHash, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n@@ -1330,9 +1330,12 @@ fn update_disambiguator(expn_id: ExpnId) {\n     }\n \n     impl<'a> crate::HashStableContext for DummyHashStableContext<'a> {\n-        fn hash_def_id(&mut self, def_id: DefId, hasher: &mut StableHasher) {\n-            def_id.krate.as_u32().hash_stable(self, hasher);\n-            def_id.index.as_u32().hash_stable(self, hasher);\n+        #[inline]\n+        fn def_path_hash(&self, def_id: DefId) -> DefPathHash {\n+            DefPathHash(Fingerprint::new(\n+                def_id.krate.as_u32().into(),\n+                def_id.index.as_u32().into(),\n+            ))\n         }\n \n         fn expn_id_cache() -> &'static LocalKey<ExpnIdCache> {\n@@ -1345,9 +1348,6 @@ fn update_disambiguator(expn_id: ExpnId) {\n             &CACHE\n         }\n \n-        fn hash_crate_num(&mut self, krate: CrateNum, hasher: &mut StableHasher) {\n-            krate.as_u32().hash_stable(self, hasher);\n-        }\n         fn hash_spans(&self) -> bool {\n             true\n         }"}, {"sha": "b4fe7c980de9582e9ca5ebb86d0f2fe5412b2161", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 37, "deletions": 38, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -16,12 +16,10 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(array_windows)]\n #![feature(crate_visibility_modifier)]\n-#![feature(const_panic)]\n #![feature(negative_impls)]\n #![feature(nll)]\n #![feature(min_specialization)]\n #![feature(thread_local_const_init)]\n-#![feature(trusted_step)]\n \n #[macro_use]\n extern crate rustc_macros;\n@@ -42,7 +40,7 @@ pub use hygiene::SyntaxContext;\n use hygiene::Transparency;\n pub use hygiene::{DesugaringKind, ExpnData, ExpnId, ExpnKind, ForLoopLoc, MacroKind};\n pub mod def_id;\n-use def_id::{CrateNum, DefId, LOCAL_CRATE};\n+use def_id::{CrateNum, DefId, DefPathHash, LOCAL_CRATE};\n pub mod lev_distance;\n mod span_encoding;\n pub use span_encoding::{Span, DUMMY_SP};\n@@ -148,11 +146,12 @@ impl Hash for RealFileName {\n // an added assert statement\n impl<S: Encoder> Encodable<S> for RealFileName {\n     fn encode(&self, encoder: &mut S) -> Result<(), S::Error> {\n-        encoder.emit_enum(\"RealFileName\", |encoder| match *self {\n+        encoder.emit_enum(|encoder| match *self {\n             RealFileName::LocalPath(ref local_path) => {\n                 encoder.emit_enum_variant(\"LocalPath\", 0, 1, |encoder| {\n                     Ok({\n-                        encoder.emit_enum_variant_arg(0, |encoder| local_path.encode(encoder))?;\n+                        encoder\n+                            .emit_enum_variant_arg(true, |encoder| local_path.encode(encoder))?;\n                     })\n                 })\n             }\n@@ -163,8 +162,10 @@ impl<S: Encoder> Encodable<S> for RealFileName {\n                     // if they have been remapped by --remap-path-prefix\n                     assert!(local_path.is_none());\n                     Ok({\n-                        encoder.emit_enum_variant_arg(0, |encoder| local_path.encode(encoder))?;\n-                        encoder.emit_enum_variant_arg(1, |encoder| virtual_name.encode(encoder))?;\n+                        encoder\n+                            .emit_enum_variant_arg(true, |encoder| local_path.encode(encoder))?;\n+                        encoder\n+                            .emit_enum_variant_arg(false, |encoder| virtual_name.encode(encoder))?;\n                     })\n                 }),\n         })\n@@ -829,17 +830,17 @@ impl Default for Span {\n impl<E: Encoder> Encodable<E> for Span {\n     default fn encode(&self, s: &mut E) -> Result<(), E::Error> {\n         let span = self.data();\n-        s.emit_struct(\"Span\", 2, |s| {\n-            s.emit_struct_field(\"lo\", 0, |s| span.lo.encode(s))?;\n-            s.emit_struct_field(\"hi\", 1, |s| span.hi.encode(s))\n+        s.emit_struct(false, |s| {\n+            s.emit_struct_field(\"lo\", true, |s| span.lo.encode(s))?;\n+            s.emit_struct_field(\"hi\", false, |s| span.hi.encode(s))\n         })\n     }\n }\n impl<D: Decoder> Decodable<D> for Span {\n     default fn decode(s: &mut D) -> Result<Span, D::Error> {\n-        s.read_struct(\"Span\", 2, |d| {\n-            let lo = d.read_struct_field(\"lo\", 0, Decodable::decode)?;\n-            let hi = d.read_struct_field(\"hi\", 1, Decodable::decode)?;\n+        s.read_struct(|d| {\n+            let lo = d.read_struct_field(\"lo\", Decodable::decode)?;\n+            let hi = d.read_struct_field(\"hi\", Decodable::decode)?;\n \n             Ok(Span::new(lo, hi, SyntaxContext::root()))\n         })\n@@ -1236,12 +1237,12 @@ pub struct SourceFile {\n \n impl<S: Encoder> Encodable<S> for SourceFile {\n     fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_struct(\"SourceFile\", 8, |s| {\n-            s.emit_struct_field(\"name\", 0, |s| self.name.encode(s))?;\n-            s.emit_struct_field(\"src_hash\", 2, |s| self.src_hash.encode(s))?;\n-            s.emit_struct_field(\"start_pos\", 3, |s| self.start_pos.encode(s))?;\n-            s.emit_struct_field(\"end_pos\", 4, |s| self.end_pos.encode(s))?;\n-            s.emit_struct_field(\"lines\", 5, |s| {\n+        s.emit_struct(false, |s| {\n+            s.emit_struct_field(\"name\", true, |s| self.name.encode(s))?;\n+            s.emit_struct_field(\"src_hash\", false, |s| self.src_hash.encode(s))?;\n+            s.emit_struct_field(\"start_pos\", false, |s| self.start_pos.encode(s))?;\n+            s.emit_struct_field(\"end_pos\", false, |s| self.end_pos.encode(s))?;\n+            s.emit_struct_field(\"lines\", false, |s| {\n                 let lines = &self.lines[..];\n                 // Store the length.\n                 s.emit_u32(lines.len() as u32)?;\n@@ -1299,25 +1300,24 @@ impl<S: Encoder> Encodable<S> for SourceFile {\n \n                 Ok(())\n             })?;\n-            s.emit_struct_field(\"multibyte_chars\", 6, |s| self.multibyte_chars.encode(s))?;\n-            s.emit_struct_field(\"non_narrow_chars\", 7, |s| self.non_narrow_chars.encode(s))?;\n-            s.emit_struct_field(\"name_hash\", 8, |s| self.name_hash.encode(s))?;\n-            s.emit_struct_field(\"normalized_pos\", 9, |s| self.normalized_pos.encode(s))?;\n-            s.emit_struct_field(\"cnum\", 10, |s| self.cnum.encode(s))\n+            s.emit_struct_field(\"multibyte_chars\", false, |s| self.multibyte_chars.encode(s))?;\n+            s.emit_struct_field(\"non_narrow_chars\", false, |s| self.non_narrow_chars.encode(s))?;\n+            s.emit_struct_field(\"name_hash\", false, |s| self.name_hash.encode(s))?;\n+            s.emit_struct_field(\"normalized_pos\", false, |s| self.normalized_pos.encode(s))?;\n+            s.emit_struct_field(\"cnum\", false, |s| self.cnum.encode(s))\n         })\n     }\n }\n \n impl<D: Decoder> Decodable<D> for SourceFile {\n     fn decode(d: &mut D) -> Result<SourceFile, D::Error> {\n-        d.read_struct(\"SourceFile\", 8, |d| {\n-            let name: FileName = d.read_struct_field(\"name\", 0, |d| Decodable::decode(d))?;\n+        d.read_struct(|d| {\n+            let name: FileName = d.read_struct_field(\"name\", |d| Decodable::decode(d))?;\n             let src_hash: SourceFileHash =\n-                d.read_struct_field(\"src_hash\", 2, |d| Decodable::decode(d))?;\n-            let start_pos: BytePos =\n-                d.read_struct_field(\"start_pos\", 3, |d| Decodable::decode(d))?;\n-            let end_pos: BytePos = d.read_struct_field(\"end_pos\", 4, |d| Decodable::decode(d))?;\n-            let lines: Vec<BytePos> = d.read_struct_field(\"lines\", 5, |d| {\n+                d.read_struct_field(\"src_hash\", |d| Decodable::decode(d))?;\n+            let start_pos: BytePos = d.read_struct_field(\"start_pos\", |d| Decodable::decode(d))?;\n+            let end_pos: BytePos = d.read_struct_field(\"end_pos\", |d| Decodable::decode(d))?;\n+            let lines: Vec<BytePos> = d.read_struct_field(\"lines\", |d| {\n                 let num_lines: u32 = Decodable::decode(d)?;\n                 let mut lines = Vec::with_capacity(num_lines as usize);\n \n@@ -1346,13 +1346,13 @@ impl<D: Decoder> Decodable<D> for SourceFile {\n                 Ok(lines)\n             })?;\n             let multibyte_chars: Vec<MultiByteChar> =\n-                d.read_struct_field(\"multibyte_chars\", 6, |d| Decodable::decode(d))?;\n+                d.read_struct_field(\"multibyte_chars\", |d| Decodable::decode(d))?;\n             let non_narrow_chars: Vec<NonNarrowChar> =\n-                d.read_struct_field(\"non_narrow_chars\", 7, |d| Decodable::decode(d))?;\n-            let name_hash: u128 = d.read_struct_field(\"name_hash\", 8, |d| Decodable::decode(d))?;\n+                d.read_struct_field(\"non_narrow_chars\", |d| Decodable::decode(d))?;\n+            let name_hash: u128 = d.read_struct_field(\"name_hash\", |d| Decodable::decode(d))?;\n             let normalized_pos: Vec<NormalizedPos> =\n-                d.read_struct_field(\"normalized_pos\", 9, |d| Decodable::decode(d))?;\n-            let cnum: CrateNum = d.read_struct_field(\"cnum\", 10, |d| Decodable::decode(d))?;\n+                d.read_struct_field(\"normalized_pos\", |d| Decodable::decode(d))?;\n+            let cnum: CrateNum = d.read_struct_field(\"cnum\", |d| Decodable::decode(d))?;\n             Ok(SourceFile {\n                 name,\n                 start_pos,\n@@ -1928,13 +1928,12 @@ fn lookup_line(lines: &[BytePos], pos: BytePos) -> isize {\n /// This is a hack to allow using the [`HashStable_Generic`] derive macro\n /// instead of implementing everything in rustc_middle.\n pub trait HashStableContext {\n-    fn hash_def_id(&mut self, _: DefId, hasher: &mut StableHasher);\n+    fn def_path_hash(&self, def_id: DefId) -> DefPathHash;\n     /// Obtains a cache for storing the `Fingerprint` of an `ExpnId`.\n     /// This method allows us to have multiple `HashStableContext` implementations\n     /// that hash things in a different way, without the results of one polluting\n     /// the cache of the other.\n     fn expn_id_cache() -> &'static LocalKey<ExpnIdCache>;\n-    fn hash_crate_num(&mut self, _: CrateNum, hasher: &mut StableHasher);\n     fn hash_spans(&self) -> bool;\n     fn span_data_to_lines_and_cols(\n         &mut self,"}, {"sha": "1d45cd172b300f186f9aa24b8e2efde61c418659", "filename": "compiler/rustc_span/src/source_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -407,7 +407,7 @@ impl SourceMap {\n     }\n \n     fn span_to_string(&self, sp: Span, prefer_local: bool) -> String {\n-        if self.files.borrow().source_files.is_empty() && sp.is_dummy() {\n+        if self.files.borrow().source_files.is_empty() || sp.is_dummy() {\n             return \"no-location\".to_string();\n         }\n "}, {"sha": "fb37c5e9c1eff58f3a6bd5b1f565751fd917d801", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -328,6 +328,7 @@ symbols! {\n         box_free,\n         box_patterns,\n         box_syntax,\n+        bpf_target_feature,\n         braced_empty_structs,\n         branch,\n         breakpoint,\n@@ -755,6 +756,7 @@ symbols! {\n         modifiers,\n         module,\n         module_path,\n+        more_qualified_paths,\n         more_struct_aliases,\n         movbe_target_feature,\n         move_ref_pattern,\n@@ -1332,6 +1334,7 @@ symbols! {\n         wrapping_add,\n         wrapping_mul,\n         wrapping_sub,\n+        wreg,\n         write_bytes,\n         xmm_reg,\n         ymm_reg,"}, {"sha": "025eaffcbd3285ca8c012281d2f289efe5d33d1f", "filename": "compiler/rustc_symbol_mangling/src/legacy.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -126,9 +126,7 @@ fn get_symbol_hash<'tcx>(\n         substs.hash_stable(&mut hcx, &mut hasher);\n \n         if let Some(instantiating_crate) = instantiating_crate {\n-            tcx.original_crate_name(instantiating_crate)\n-                .as_str()\n-                .hash_stable(&mut hcx, &mut hasher);\n+            tcx.crate_name(instantiating_crate).as_str().hash_stable(&mut hcx, &mut hasher);\n             tcx.crate_disambiguator(instantiating_crate).hash_stable(&mut hcx, &mut hasher);\n         }\n \n@@ -255,7 +253,7 @@ impl Printer<'tcx> for SymbolPrinter<'tcx> {\n     }\n \n     fn path_crate(mut self, cnum: CrateNum) -> Result<Self::Path, Self::Error> {\n-        self.write_str(&self.tcx.original_crate_name(cnum).as_str())?;\n+        self.write_str(&self.tcx.crate_name(cnum).as_str())?;\n         Ok(self)\n     }\n     fn path_qualified("}, {"sha": "828f1ac0a7989a7cdbc0e3fbb4a62983b9273c2c", "filename": "compiler/rustc_symbol_mangling/src/v0.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -594,7 +594,7 @@ impl Printer<'tcx> for SymbolMangler<'tcx> {\n         self.push(\"C\");\n         let fingerprint = self.tcx.crate_disambiguator(cnum).to_fingerprint();\n         self.push_disambiguator(fingerprint.to_smaller_hash());\n-        let name = self.tcx.original_crate_name(cnum).as_str();\n+        let name = self.tcx.crate_name(cnum).as_str();\n         self.push_ident(&name);\n         Ok(self)\n     }"}, {"sha": "466c525531c1bc0ae30c6a53fa993876fc84fe18", "filename": "compiler/rustc_target/src/abi/call/bpf.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fbpf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fbpf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fbpf.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -0,0 +1,31 @@\n+// see https://github.com/llvm/llvm-project/blob/main/llvm/lib/Target/BPF/BPFCallingConv.td\n+use crate::abi::call::{ArgAbi, FnAbi};\n+\n+fn classify_ret<Ty>(ret: &mut ArgAbi<'_, Ty>) {\n+    if ret.layout.is_aggregate() || ret.layout.size.bits() > 64 {\n+        ret.make_indirect();\n+    } else {\n+        ret.extend_integer_width_to(32);\n+    }\n+}\n+\n+fn classify_arg<Ty>(arg: &mut ArgAbi<'_, Ty>) {\n+    if arg.layout.is_aggregate() || arg.layout.size.bits() > 64 {\n+        arg.make_indirect();\n+    } else {\n+        arg.extend_integer_width_to(32);\n+    }\n+}\n+\n+pub fn compute_abi_info<Ty>(fn_abi: &mut FnAbi<'_, Ty>) {\n+    if !fn_abi.ret.is_ignore() {\n+        classify_ret(&mut fn_abi.ret);\n+    }\n+\n+    for arg in &mut fn_abi.args {\n+        if arg.is_ignore() {\n+            continue;\n+        }\n+        classify_arg(arg);\n+    }\n+}"}, {"sha": "6e0e140374033c3c2eef6ae53780160e3b9090c0", "filename": "compiler/rustc_target/src/abi/call/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -6,6 +6,7 @@ mod aarch64;\n mod amdgpu;\n mod arm;\n mod avr;\n+mod bpf;\n mod hexagon;\n mod mips;\n mod mips64;\n@@ -654,6 +655,7 @@ impl<'a, Ty> FnAbi<'a, Ty> {\n                 }\n             }\n             \"asmjs\" => wasm::compute_c_abi_info(cx, self),\n+            \"bpf\" => bpf::compute_abi_info(self),\n             a => return Err(format!(\"unrecognized arch \\\"{}\\\" in target specification\", a)),\n         }\n "}, {"sha": "8e71ded3d1de6a7dfbbc006d4d7e8525df3d4866", "filename": "compiler/rustc_target/src/abi/mod.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -222,6 +222,7 @@ pub trait HasDataLayout {\n }\n \n impl HasDataLayout for TargetDataLayout {\n+    #[inline]\n     fn data_layout(&self) -> &TargetDataLayout {\n         self\n     }\n@@ -752,11 +753,7 @@ impl FieldsShape {\n         match *self {\n             FieldsShape::Primitive => 0,\n             FieldsShape::Union(count) => count.get(),\n-            FieldsShape::Array { count, .. } => {\n-                let usize_count = count as usize;\n-                assert_eq!(usize_count as u64, count);\n-                usize_count\n-            }\n+            FieldsShape::Array { count, .. } => count.try_into().unwrap(),\n             FieldsShape::Arbitrary { ref offsets, .. } => offsets.len(),\n         }\n     }\n@@ -790,11 +787,7 @@ impl FieldsShape {\n                 unreachable!(\"FieldsShape::memory_index: `Primitive`s have no fields\")\n             }\n             FieldsShape::Union(_) | FieldsShape::Array { .. } => i,\n-            FieldsShape::Arbitrary { ref memory_index, .. } => {\n-                let r = memory_index[i];\n-                assert_eq!(r as usize as u32, r);\n-                r as usize\n-            }\n+            FieldsShape::Arbitrary { ref memory_index, .. } => memory_index[i].try_into().unwrap(),\n         }\n     }\n \n@@ -862,6 +855,7 @@ pub enum Abi {\n \n impl Abi {\n     /// Returns `true` if the layout corresponds to an unsized type.\n+    #[inline]\n     pub fn is_unsized(&self) -> bool {\n         match *self {\n             Abi::Uninhabited | Abi::Scalar(_) | Abi::ScalarPair(..) | Abi::Vector { .. } => false,\n@@ -881,11 +875,13 @@ impl Abi {\n     }\n \n     /// Returns `true` if this is an uninhabited type\n+    #[inline]\n     pub fn is_uninhabited(&self) -> bool {\n         matches!(*self, Abi::Uninhabited)\n     }\n \n     /// Returns `true` is this is a scalar type\n+    #[inline]\n     pub fn is_scalar(&self) -> bool {\n         matches!(*self, Abi::Scalar(_))\n     }"}, {"sha": "ecb6bdc95ce0991b13573983f431e1b83ecdc0e0", "filename": "compiler/rustc_target/src/asm/bpf.rs", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_target%2Fsrc%2Fasm%2Fbpf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_target%2Fsrc%2Fasm%2Fbpf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Fbpf.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -0,0 +1,129 @@\n+use super::{InlineAsmArch, InlineAsmType, Target};\n+use rustc_macros::HashStable_Generic;\n+use std::fmt;\n+\n+def_reg_class! {\n+    Bpf BpfInlineAsmRegClass {\n+        reg,\n+        wreg,\n+    }\n+}\n+\n+impl BpfInlineAsmRegClass {\n+    pub fn valid_modifiers(self, _arch: InlineAsmArch) -> &'static [char] {\n+        &[]\n+    }\n+\n+    pub fn suggest_class(self, _arch: InlineAsmArch, _ty: InlineAsmType) -> Option<Self> {\n+        None\n+    }\n+\n+    pub fn suggest_modifier(\n+        self,\n+        _arch: InlineAsmArch,\n+        _ty: InlineAsmType,\n+    ) -> Option<(char, &'static str)> {\n+        None\n+    }\n+\n+    pub fn default_modifier(self, _arch: InlineAsmArch) -> Option<(char, &'static str)> {\n+        None\n+    }\n+\n+    pub fn supported_types(\n+        self,\n+        _arch: InlineAsmArch,\n+    ) -> &'static [(InlineAsmType, Option<&'static str>)] {\n+        match self {\n+            Self::reg => types! { _: I8, I16, I32, I64; },\n+            Self::wreg => types! { \"alu32\": I8, I16, I32; },\n+        }\n+    }\n+}\n+\n+fn only_alu32(\n+    _arch: InlineAsmArch,\n+    mut has_feature: impl FnMut(&str) -> bool,\n+    _target: &Target,\n+) -> Result<(), &'static str> {\n+    if !has_feature(\"alu32\") {\n+        Err(\"register can't be used without the `alu32` target feature\")\n+    } else {\n+        Ok(())\n+    }\n+}\n+\n+def_regs! {\n+    Bpf BpfInlineAsmReg BpfInlineAsmRegClass {\n+        r0: reg = [\"r0\"],\n+        r1: reg = [\"r1\"],\n+        r2: reg = [\"r2\"],\n+        r3: reg = [\"r3\"],\n+        r4: reg = [\"r4\"],\n+        r5: reg = [\"r5\"],\n+        r6: reg = [\"r6\"],\n+        r7: reg = [\"r7\"],\n+        r8: reg = [\"r8\"],\n+        r9: reg = [\"r9\"],\n+        w0: wreg = [\"w0\"] % only_alu32,\n+        w1: wreg = [\"w1\"] % only_alu32,\n+        w2: wreg = [\"w2\"] % only_alu32,\n+        w3: wreg = [\"w3\"] % only_alu32,\n+        w4: wreg = [\"w4\"] % only_alu32,\n+        w5: wreg = [\"w5\"] % only_alu32,\n+        w6: wreg = [\"w6\"] % only_alu32,\n+        w7: wreg = [\"w7\"] % only_alu32,\n+        w8: wreg = [\"w8\"] % only_alu32,\n+        w9: wreg = [\"w9\"] % only_alu32,\n+\n+        #error = [\"r10\", \"w10\"] =>\n+            \"the stack pointer cannot be used as an operand for inline asm\",\n+    }\n+}\n+\n+impl BpfInlineAsmReg {\n+    pub fn emit(\n+        self,\n+        out: &mut dyn fmt::Write,\n+        _arch: InlineAsmArch,\n+        _modifier: Option<char>,\n+    ) -> fmt::Result {\n+        out.write_str(self.name())\n+    }\n+\n+    pub fn overlapping_regs(self, mut cb: impl FnMut(BpfInlineAsmReg)) {\n+        cb(self);\n+\n+        macro_rules! reg_conflicts {\n+            (\n+                $(\n+                    $r:ident : $w:ident\n+                ),*\n+            ) => {\n+                match self {\n+                    $(\n+                        Self::$r => {\n+                            cb(Self::$w);\n+                        }\n+                        Self::$w => {\n+                            cb(Self::$r);\n+                        }\n+                    )*\n+                }\n+            };\n+        }\n+\n+        reg_conflicts! {\n+            r0 : w0,\n+            r1 : w1,\n+            r2 : w2,\n+            r3 : w3,\n+            r4 : w4,\n+            r5 : w5,\n+            r6 : w6,\n+            r7 : w7,\n+            r8 : w8,\n+            r9 : w9\n+        }\n+    }\n+}"}, {"sha": "305ea7d50e66ea058a37d579d3223820bf4870c6", "filename": "compiler/rustc_target/src/asm/mod.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -148,6 +148,7 @@ macro_rules! types {\n \n mod aarch64;\n mod arm;\n+mod bpf;\n mod hexagon;\n mod mips;\n mod nvptx;\n@@ -159,6 +160,7 @@ mod x86;\n \n pub use aarch64::{AArch64InlineAsmReg, AArch64InlineAsmRegClass};\n pub use arm::{ArmInlineAsmReg, ArmInlineAsmRegClass};\n+pub use bpf::{BpfInlineAsmReg, BpfInlineAsmRegClass};\n pub use hexagon::{HexagonInlineAsmReg, HexagonInlineAsmRegClass};\n pub use mips::{MipsInlineAsmReg, MipsInlineAsmRegClass};\n pub use nvptx::{NvptxInlineAsmReg, NvptxInlineAsmRegClass};\n@@ -184,6 +186,7 @@ pub enum InlineAsmArch {\n     PowerPC64,\n     SpirV,\n     Wasm32,\n+    Bpf,\n }\n \n impl FromStr for InlineAsmArch {\n@@ -205,6 +208,7 @@ impl FromStr for InlineAsmArch {\n             \"mips64\" => Ok(Self::Mips64),\n             \"spirv\" => Ok(Self::SpirV),\n             \"wasm32\" => Ok(Self::Wasm32),\n+            \"bpf\" => Ok(Self::Bpf),\n             _ => Err(()),\n         }\n     }\n@@ -233,6 +237,7 @@ pub enum InlineAsmReg {\n     Mips(MipsInlineAsmReg),\n     SpirV(SpirVInlineAsmReg),\n     Wasm(WasmInlineAsmReg),\n+    Bpf(BpfInlineAsmReg),\n     // Placeholder for invalid register constraints for the current target\n     Err,\n }\n@@ -247,6 +252,7 @@ impl InlineAsmReg {\n             Self::PowerPC(r) => r.name(),\n             Self::Hexagon(r) => r.name(),\n             Self::Mips(r) => r.name(),\n+            Self::Bpf(r) => r.name(),\n             Self::Err => \"<reg>\",\n         }\n     }\n@@ -260,6 +266,7 @@ impl InlineAsmReg {\n             Self::PowerPC(r) => InlineAsmRegClass::PowerPC(r.reg_class()),\n             Self::Hexagon(r) => InlineAsmRegClass::Hexagon(r.reg_class()),\n             Self::Mips(r) => InlineAsmRegClass::Mips(r.reg_class()),\n+            Self::Bpf(r) => InlineAsmRegClass::Bpf(r.reg_class()),\n             Self::Err => InlineAsmRegClass::Err,\n         }\n     }\n@@ -304,6 +311,9 @@ impl InlineAsmReg {\n             InlineAsmArch::Wasm32 => {\n                 Self::Wasm(WasmInlineAsmReg::parse(arch, has_feature, target, &name)?)\n             }\n+            InlineAsmArch::Bpf => {\n+                Self::Bpf(BpfInlineAsmReg::parse(arch, has_feature, target, &name)?)\n+            }\n         })\n     }\n \n@@ -323,6 +333,7 @@ impl InlineAsmReg {\n             Self::PowerPC(r) => r.emit(out, arch, modifier),\n             Self::Hexagon(r) => r.emit(out, arch, modifier),\n             Self::Mips(r) => r.emit(out, arch, modifier),\n+            Self::Bpf(r) => r.emit(out, arch, modifier),\n             Self::Err => unreachable!(\"Use of InlineAsmReg::Err\"),\n         }\n     }\n@@ -336,6 +347,7 @@ impl InlineAsmReg {\n             Self::PowerPC(_) => cb(self),\n             Self::Hexagon(r) => r.overlapping_regs(|r| cb(Self::Hexagon(r))),\n             Self::Mips(_) => cb(self),\n+            Self::Bpf(r) => r.overlapping_regs(|r| cb(Self::Bpf(r))),\n             Self::Err => unreachable!(\"Use of InlineAsmReg::Err\"),\n         }\n     }\n@@ -364,6 +376,7 @@ pub enum InlineAsmRegClass {\n     Mips(MipsInlineAsmRegClass),\n     SpirV(SpirVInlineAsmRegClass),\n     Wasm(WasmInlineAsmRegClass),\n+    Bpf(BpfInlineAsmRegClass),\n     // Placeholder for invalid register constraints for the current target\n     Err,\n }\n@@ -381,6 +394,7 @@ impl InlineAsmRegClass {\n             Self::Mips(r) => r.name(),\n             Self::SpirV(r) => r.name(),\n             Self::Wasm(r) => r.name(),\n+            Self::Bpf(r) => r.name(),\n             Self::Err => rustc_span::symbol::sym::reg,\n         }\n     }\n@@ -400,6 +414,7 @@ impl InlineAsmRegClass {\n             Self::Mips(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::Mips),\n             Self::SpirV(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::SpirV),\n             Self::Wasm(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::Wasm),\n+            Self::Bpf(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::Bpf),\n             Self::Err => unreachable!(\"Use of InlineAsmRegClass::Err\"),\n         }\n     }\n@@ -426,6 +441,7 @@ impl InlineAsmRegClass {\n             Self::Mips(r) => r.suggest_modifier(arch, ty),\n             Self::SpirV(r) => r.suggest_modifier(arch, ty),\n             Self::Wasm(r) => r.suggest_modifier(arch, ty),\n+            Self::Bpf(r) => r.suggest_modifier(arch, ty),\n             Self::Err => unreachable!(\"Use of InlineAsmRegClass::Err\"),\n         }\n     }\n@@ -448,6 +464,7 @@ impl InlineAsmRegClass {\n             Self::Mips(r) => r.default_modifier(arch),\n             Self::SpirV(r) => r.default_modifier(arch),\n             Self::Wasm(r) => r.default_modifier(arch),\n+            Self::Bpf(r) => r.default_modifier(arch),\n             Self::Err => unreachable!(\"Use of InlineAsmRegClass::Err\"),\n         }\n     }\n@@ -469,6 +486,7 @@ impl InlineAsmRegClass {\n             Self::Mips(r) => r.supported_types(arch),\n             Self::SpirV(r) => r.supported_types(arch),\n             Self::Wasm(r) => r.supported_types(arch),\n+            Self::Bpf(r) => r.supported_types(arch),\n             Self::Err => unreachable!(\"Use of InlineAsmRegClass::Err\"),\n         }\n     }\n@@ -493,6 +511,7 @@ impl InlineAsmRegClass {\n             }\n             InlineAsmArch::SpirV => Self::SpirV(SpirVInlineAsmRegClass::parse(arch, name)?),\n             InlineAsmArch::Wasm32 => Self::Wasm(WasmInlineAsmRegClass::parse(arch, name)?),\n+            InlineAsmArch::Bpf => Self::Bpf(BpfInlineAsmRegClass::parse(arch, name)?),\n         })\n     }\n \n@@ -510,6 +529,7 @@ impl InlineAsmRegClass {\n             Self::Mips(r) => r.valid_modifiers(arch),\n             Self::SpirV(r) => r.valid_modifiers(arch),\n             Self::Wasm(r) => r.valid_modifiers(arch),\n+            Self::Bpf(r) => r.valid_modifiers(arch),\n             Self::Err => unreachable!(\"Use of InlineAsmRegClass::Err\"),\n         }\n     }\n@@ -679,5 +699,10 @@ pub fn allocatable_registers(\n             wasm::fill_reg_map(arch, has_feature, target, &mut map);\n             map\n         }\n+        InlineAsmArch::Bpf => {\n+            let mut map = bpf::regclass_map();\n+            bpf::fill_reg_map(arch, has_feature, target, &mut map);\n+            map\n+        }\n     }\n }"}, {"sha": "cb8f6b9656c6834fd620a2bb02c1bbb035bdb3eb", "filename": "compiler/rustc_target/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_target%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_target%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Flib.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -9,13 +9,11 @@\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(bool_to_option)]\n-#![feature(const_panic)]\n #![feature(nll)]\n #![feature(never_type)]\n #![feature(associated_type_bounds)]\n #![feature(exhaustive_patterns)]\n #![feature(min_specialization)]\n-#![feature(trusted_step)]\n \n use std::path::{Path, PathBuf};\n "}, {"sha": "5682039b86512aa6b0f3feb98846aa78c6319bcf", "filename": "compiler/rustc_target/src/spec/aarch64_apple_ios.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_ios.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_ios.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_ios.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -10,7 +10,6 @@ pub fn target() -> Target {\n         arch: \"aarch64\".to_string(),\n         options: TargetOptions {\n             features: \"+neon,+fp-armv8,+apple-a7\".to_string(),\n-            eliminate_frame_pointer: false,\n             max_atomic_width: Some(128),\n             unsupported_abis: super::arm_base::unsupported_abis(),\n             forces_embed_bitcode: true,"}, {"sha": "8a832546d09526334877090c86a9e31cb87a1edc", "filename": "compiler/rustc_target/src/spec/aarch64_apple_ios_macabi.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_ios_macabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_ios_macabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_ios_macabi.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -10,7 +10,6 @@ pub fn target() -> Target {\n         arch: \"aarch64\".to_string(),\n         options: TargetOptions {\n             features: \"+neon,+fp-armv8,+apple-a12\".to_string(),\n-            eliminate_frame_pointer: false,\n             max_atomic_width: Some(128),\n             unsupported_abis: super::arm_base::unsupported_abis(),\n             forces_embed_bitcode: true,"}, {"sha": "2187015b627d3a19e12dde51d0f00af62bbe8381", "filename": "compiler/rustc_target/src/spec/aarch64_apple_ios_sim.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_ios_sim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_ios_sim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_ios_sim.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -18,7 +18,6 @@ pub fn target() -> Target {\n         arch: \"aarch64\".to_string(),\n         options: TargetOptions {\n             features: \"+neon,+fp-armv8,+apple-a7\".to_string(),\n-            eliminate_frame_pointer: false,\n             max_atomic_width: Some(128),\n             unsupported_abis: super::arm_base::unsupported_abis(),\n             forces_embed_bitcode: true,"}, {"sha": "cb6c06b371183f61bcf0e5d8b3b5bda2f2c01c2e", "filename": "compiler/rustc_target/src/spec/aarch64_apple_tvos.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_tvos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_tvos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_tvos.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -10,7 +10,6 @@ pub fn target() -> Target {\n         arch: \"aarch64\".to_string(),\n         options: TargetOptions {\n             features: \"+neon,+fp-armv8,+apple-a7\".to_string(),\n-            eliminate_frame_pointer: false,\n             max_atomic_width: Some(128),\n             unsupported_abis: super::arm_base::unsupported_abis(),\n             forces_embed_bitcode: true,"}, {"sha": "8530db179d9919060cfc17886d3ab2726c318ffd", "filename": "compiler/rustc_target/src/spec/apple_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_base.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -27,6 +27,7 @@ pub fn opts(os: &str) -> TargetOptions {\n         families: vec![\"unix\".to_string()],\n         is_like_osx: true,\n         dwarf_version: Some(2),\n+        eliminate_frame_pointer: false,\n         has_rpath: true,\n         dll_suffix: \".dylib\".to_string(),\n         archive_format: \"darwin\".to_string(),"}, {"sha": "e7f7bb343d0c534541dd31261b886b7a0870efe7", "filename": "compiler/rustc_target/src/spec/apple_sdk_base.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_sdk_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_sdk_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_sdk_base.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -44,7 +44,6 @@ pub fn opts(os: &str, arch: Arch) -> TargetOptions {\n         executables: true,\n         link_env_remove: link_env_remove(arch),\n         has_elf_tls: false,\n-        eliminate_frame_pointer: false,\n         ..super::apple_base::opts(os)\n     }\n }"}, {"sha": "764cc735d75d1b1d02b75d425b075e8153243e4e", "filename": "compiler/rustc_target/src/spec/bpf_base.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_target%2Fsrc%2Fspec%2Fbpf_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_target%2Fsrc%2Fspec%2Fbpf_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fbpf_base.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -0,0 +1,42 @@\n+use crate::spec::{LinkerFlavor, MergeFunctions, PanicStrategy, TargetOptions};\n+use crate::{abi::Endian, spec::abi::Abi};\n+\n+pub fn opts(endian: Endian) -> TargetOptions {\n+    TargetOptions {\n+        allow_asm: true,\n+        endian,\n+        linker_flavor: LinkerFlavor::BpfLinker,\n+        atomic_cas: false,\n+        executables: true,\n+        dynamic_linking: true,\n+        no_builtins: true,\n+        panic_strategy: PanicStrategy::Abort,\n+        position_independent_executables: true,\n+        // Disable MergeFunctions since:\n+        // - older kernels don't support bpf-to-bpf calls\n+        // - on newer kernels, userspace still needs to relocate before calling\n+        //   BPF_PROG_LOAD and not all BPF libraries do that yet\n+        merge_functions: MergeFunctions::Disabled,\n+        obj_is_bitcode: true,\n+        requires_lto: false,\n+        singlethread: true,\n+        max_atomic_width: Some(64),\n+        unsupported_abis: vec![\n+            Abi::Cdecl,\n+            Abi::Stdcall { unwind: false },\n+            Abi::Stdcall { unwind: true },\n+            Abi::Fastcall,\n+            Abi::Vectorcall,\n+            Abi::Thiscall { unwind: false },\n+            Abi::Thiscall { unwind: true },\n+            Abi::Aapcs,\n+            Abi::Win64,\n+            Abi::SysV64,\n+            Abi::PtxKernel,\n+            Abi::Msp430Interrupt,\n+            Abi::X86Interrupt,\n+            Abi::AmdGpuKernel,\n+        ],\n+        ..Default::default()\n+    }\n+}"}, {"sha": "a45da82eb4032a116ab997e23945ff3f1c6c6ca2", "filename": "compiler/rustc_target/src/spec/bpfeb_unknown_none.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_target%2Fsrc%2Fspec%2Fbpfeb_unknown_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_target%2Fsrc%2Fspec%2Fbpfeb_unknown_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fbpfeb_unknown_none.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -0,0 +1,12 @@\n+use crate::spec::Target;\n+use crate::{abi::Endian, spec::bpf_base};\n+\n+pub fn target() -> Target {\n+    Target {\n+        llvm_target: \"bpfeb\".to_string(),\n+        data_layout: \"E-m:e-p:64:64-i64:64-i128:128-n32:64-S128\".to_string(),\n+        pointer_width: 64,\n+        arch: \"bpf\".to_string(),\n+        options: bpf_base::opts(Endian::Big),\n+    }\n+}"}, {"sha": "6c9afdf35aef47d1a8e0f11300dc19fd5a46ad48", "filename": "compiler/rustc_target/src/spec/bpfel_unknown_none.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_target%2Fsrc%2Fspec%2Fbpfel_unknown_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_target%2Fsrc%2Fspec%2Fbpfel_unknown_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fbpfel_unknown_none.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -0,0 +1,12 @@\n+use crate::spec::Target;\n+use crate::{abi::Endian, spec::bpf_base};\n+\n+pub fn target() -> Target {\n+    Target {\n+        llvm_target: \"bpfel\".to_string(),\n+        data_layout: \"e-m:e-p:64:64-i64:64-i128:128-n32:64-S128\".to_string(),\n+        pointer_width: 64,\n+        arch: \"bpf\".to_string(),\n+        options: bpf_base::opts(Endian::Little),\n+    }\n+}"}, {"sha": "0f2aaeb533a97d3ed4b8a9d27750fdd8285ce28c", "filename": "compiler/rustc_target/src/spec/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -57,6 +57,7 @@ mod apple_base;\n mod apple_sdk_base;\n mod arm_base;\n mod avr_gnu_base;\n+mod bpf_base;\n mod dragonfly_base;\n mod freebsd_base;\n mod fuchsia_base;\n@@ -93,6 +94,7 @@ pub enum LinkerFlavor {\n     Msvc,\n     Lld(LldFlavor),\n     PtxLinker,\n+    BpfLinker,\n }\n \n #[derive(Clone, Copy, Debug, Eq, Ord, PartialEq, PartialOrd)]\n@@ -161,6 +163,7 @@ flavor_mappings! {\n     ((LinkerFlavor::Ld), \"ld\"),\n     ((LinkerFlavor::Msvc), \"msvc\"),\n     ((LinkerFlavor::PtxLinker), \"ptx-linker\"),\n+    ((LinkerFlavor::BpfLinker), \"bpf-linker\"),\n     ((LinkerFlavor::Lld(LldFlavor::Wasm)), \"wasm-ld\"),\n     ((LinkerFlavor::Lld(LldFlavor::Ld64)), \"ld64.lld\"),\n     ((LinkerFlavor::Lld(LldFlavor::Ld)), \"ld.lld\"),\n@@ -897,6 +900,9 @@ supported_targets! {\n     (\"aarch64_be-unknown-linux-gnu\", aarch64_be_unknown_linux_gnu),\n     (\"aarch64-unknown-linux-gnu_ilp32\", aarch64_unknown_linux_gnu_ilp32),\n     (\"aarch64_be-unknown-linux-gnu_ilp32\", aarch64_be_unknown_linux_gnu_ilp32),\n+\n+    (\"bpfeb-unknown-none\", bpfeb_unknown_none),\n+    (\"bpfel-unknown-none\", bpfel_unknown_none),\n }\n \n /// Everything `rustc` knows about how to compile for a specific target.\n@@ -922,6 +928,7 @@ pub trait HasTargetSpec {\n }\n \n impl HasTargetSpec for Target {\n+    #[inline]\n     fn target_spec(&self) -> &Target {\n         self\n     }"}, {"sha": "6e3a241a86e042bd3c1e0b32db903fd2fcd26e82", "filename": "compiler/rustc_target/src/spec/msp430_none_elf.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmsp430_none_elf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmsp430_none_elf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmsp430_none_elf.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -17,6 +17,7 @@ pub fn target() -> Target {\n             // dependency on this specific gcc.\n             asm_args: vec![\"-mcpu=msp430\".to_string()],\n             linker: Some(\"msp430-elf-gcc\".to_string()),\n+            linker_is_gnu: false,\n \n             // There are no atomic CAS instructions available in the MSP430\n             // instruction set, and the LLVM backend doesn't currently support"}, {"sha": "4c954a1e567ccb236e95b515fb2c8276be192364", "filename": "compiler/rustc_target/src/spec/wasm_base.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_target%2Fsrc%2Fspec%2Fwasm_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_target%2Fsrc%2Fspec%2Fwasm_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fwasm_base.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -102,12 +102,7 @@ pub fn options() -> TargetOptions {\n         // we use the LLD shipped with the Rust toolchain by default\n         linker: Some(\"rust-lld\".to_owned()),\n         lld_flavor: LldFlavor::Wasm,\n-\n-        // No need for indirection here, simd types can always be passed by\n-        // value as the whole module either has simd or not, which is different\n-        // from x86 (for example) where programs can have functions that don't\n-        // enable simd features.\n-        simd_types_indirect: false,\n+        linker_is_gnu: false,\n \n         pre_link_args,\n "}, {"sha": "ac2e0ebae32732cbe778c6e4896ffd30b5987a4c", "filename": "compiler/rustc_trait_selection/src/autoderef.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_trait_selection%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_trait_selection%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fautoderef.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -6,6 +6,7 @@ use rustc_infer::infer::InferCtxt;\n use rustc_middle::ty::{self, TraitRef, Ty, TyCtxt, WithConstness};\n use rustc_middle::ty::{ToPredicate, TypeFoldable};\n use rustc_session::DiagnosticMessageId;\n+use rustc_span::def_id::LOCAL_CRATE;\n use rustc_span::Span;\n \n #[derive(Copy, Clone, Debug)]\n@@ -231,7 +232,8 @@ pub fn report_autoderef_recursion_limit_error<'tcx>(tcx: TyCtxt<'tcx>, span: Spa\n         .span_label(span, \"deref recursion limit reached\")\n         .help(&format!(\n             \"consider adding a `#![recursion_limit=\\\"{}\\\"]` attribute to your crate (`{}`)\",\n-            suggested_limit, tcx.crate_name,\n+            suggested_limit,\n+            tcx.crate_name(LOCAL_CRATE),\n         ))\n         .emit();\n     }"}, {"sha": "89ec211f2627bcadf4ec47f8eb14e5095e71aa2b", "filename": "compiler/rustc_trait_selection/src/opaque_types.rs", "status": "modified", "additions": 43, "deletions": 42, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -2,21 +2,22 @@ use crate::infer::InferCtxtExt as _;\n use crate::traits::{self, PredicateObligation};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n+use rustc_data_structures::vec_map::VecMap;\n use rustc_hir as hir;\n-use rustc_hir::def_id::{DefId, DefIdMap, LocalDefId};\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::Node;\n use rustc_infer::infer::error_reporting::unexpected_hidden_region_diagnostic;\n use rustc_infer::infer::free_regions::FreeRegionRelations;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::{self, InferCtxt, InferOk};\n use rustc_middle::ty::fold::{BottomUpFolder, TypeFoldable, TypeFolder, TypeVisitor};\n-use rustc_middle::ty::subst::{GenericArg, GenericArgKind, InternalSubsts, Subst, SubstsRef};\n-use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_middle::ty::subst::{GenericArg, GenericArgKind, InternalSubsts, Subst};\n+use rustc_middle::ty::{self, OpaqueTypeKey, Ty, TyCtxt};\n use rustc_span::Span;\n \n use std::ops::ControlFlow;\n \n-pub type OpaqueTypeMap<'tcx> = DefIdMap<OpaqueTypeDecl<'tcx>>;\n+pub type OpaqueTypeMap<'tcx> = VecMap<OpaqueTypeKey<'tcx>, OpaqueTypeDecl<'tcx>>;\n \n /// Information about the opaque types whose values we\n /// are inferring in this function (these are the `impl Trait` that\n@@ -26,19 +27,6 @@ pub struct OpaqueTypeDecl<'tcx> {\n     /// The opaque type (`ty::Opaque`) for this declaration.\n     pub opaque_type: Ty<'tcx>,\n \n-    /// The substitutions that we apply to the opaque type that this\n-    /// `impl Trait` desugars to. e.g., if:\n-    ///\n-    ///     fn foo<'a, 'b, T>() -> impl Trait<'a>\n-    ///\n-    /// winds up desugared to:\n-    ///\n-    ///     type Foo<'x, X> = impl Trait<'x>\n-    ///     fn foo<'a, 'b, T>() -> Foo<'a, T>\n-    ///\n-    /// then `substs` would be `['a, T]`.\n-    pub substs: SubstsRef<'tcx>,\n-\n     /// The span of this particular definition of the opaque type. So\n     /// for example:\n     ///\n@@ -125,7 +113,7 @@ pub trait InferCtxtExt<'tcx> {\n \n     fn constrain_opaque_type<FRR: FreeRegionRelations<'tcx>>(\n         &self,\n-        def_id: DefId,\n+        opaque_type_key: OpaqueTypeKey<'tcx>,\n         opaque_defn: &OpaqueTypeDecl<'tcx>,\n         mode: GenerateMemberConstraints,\n         free_region_relations: &FRR,\n@@ -136,14 +124,13 @@ pub trait InferCtxtExt<'tcx> {\n         &self,\n         concrete_ty: Ty<'tcx>,\n         opaque_defn: &OpaqueTypeDecl<'tcx>,\n-        opaque_type_def_id: DefId,\n+        opaque_type_key: OpaqueTypeKey<'tcx>,\n         first_own_region_index: usize,\n     );\n \n     fn infer_opaque_definition_from_instantiation(\n         &self,\n-        def_id: DefId,\n-        substs: SubstsRef<'tcx>,\n+        opaque_type_key: OpaqueTypeKey<'tcx>,\n         instantiated_ty: Ty<'tcx>,\n         span: Span,\n     ) -> Ty<'tcx>;\n@@ -370,10 +357,10 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     ) {\n         debug!(\"constrain_opaque_types()\");\n \n-        for (&def_id, opaque_defn) in opaque_types {\n+        for &(opaque_type_key, opaque_defn) in opaque_types {\n             self.constrain_opaque_type(\n-                def_id,\n-                opaque_defn,\n+                opaque_type_key,\n+                &opaque_defn,\n                 GenerateMemberConstraints::WhenRequired,\n                 free_region_relations,\n             );\n@@ -383,11 +370,13 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     /// See `constrain_opaque_types` for documentation.\n     fn constrain_opaque_type<FRR: FreeRegionRelations<'tcx>>(\n         &self,\n-        def_id: DefId,\n+        opaque_type_key: OpaqueTypeKey<'tcx>,\n         opaque_defn: &OpaqueTypeDecl<'tcx>,\n         mode: GenerateMemberConstraints,\n         free_region_relations: &FRR,\n     ) {\n+        let def_id = opaque_type_key.def_id;\n+\n         debug!(\"constrain_opaque_type()\");\n         debug!(\"constrain_opaque_type: def_id={:?}\", def_id);\n         debug!(\"constrain_opaque_type: opaque_defn={:#?}\", opaque_defn);\n@@ -426,9 +415,9 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             let bounds = tcx.explicit_item_bounds(def_id);\n             debug!(\"constrain_opaque_type: predicates: {:#?}\", bounds);\n             let bounds: Vec<_> =\n-                bounds.iter().map(|(bound, _)| bound.subst(tcx, opaque_defn.substs)).collect();\n+                bounds.iter().map(|(bound, _)| bound.subst(tcx, opaque_type_key.substs)).collect();\n             debug!(\"constrain_opaque_type: bounds={:#?}\", bounds);\n-            let opaque_type = tcx.mk_opaque(def_id, opaque_defn.substs);\n+            let opaque_type = tcx.mk_opaque(def_id, opaque_type_key.substs);\n \n             let required_region_bounds =\n                 required_region_bounds(tcx, opaque_type, bounds.into_iter());\n@@ -440,7 +429,12 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 });\n             }\n             if let GenerateMemberConstraints::IfNoStaticBound = mode {\n-                self.generate_member_constraint(concrete_ty, opaque_defn, def_id, first_own_region);\n+                self.generate_member_constraint(\n+                    concrete_ty,\n+                    opaque_defn,\n+                    opaque_type_key,\n+                    first_own_region,\n+                );\n             }\n             return;\n         }\n@@ -454,7 +448,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         // second.\n         let mut least_region = None;\n \n-        for subst_arg in &opaque_defn.substs[first_own_region..] {\n+        for subst_arg in &opaque_type_key.substs[first_own_region..] {\n             let subst_region = match subst_arg.unpack() {\n                 GenericArgKind::Lifetime(r) => r,\n                 GenericArgKind::Type(_) | GenericArgKind::Const(_) => continue,\n@@ -484,7 +478,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         return self.generate_member_constraint(\n                             concrete_ty,\n                             opaque_defn,\n-                            def_id,\n+                            opaque_type_key,\n                             first_own_region,\n                         );\n                     }\n@@ -497,7 +491,12 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n         if let GenerateMemberConstraints::IfNoStaticBound = mode {\n             if least_region != tcx.lifetimes.re_static {\n-                self.generate_member_constraint(concrete_ty, opaque_defn, def_id, first_own_region);\n+                self.generate_member_constraint(\n+                    concrete_ty,\n+                    opaque_defn,\n+                    opaque_type_key,\n+                    first_own_region,\n+                );\n             }\n         }\n         concrete_ty.visit_with(&mut ConstrainOpaqueTypeRegionVisitor {\n@@ -517,14 +516,14 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         &self,\n         concrete_ty: Ty<'tcx>,\n         opaque_defn: &OpaqueTypeDecl<'tcx>,\n-        opaque_type_def_id: DefId,\n+        opaque_type_key: OpaqueTypeKey<'tcx>,\n         first_own_region: usize,\n     ) {\n         // Create the set of choice regions: each region in the hidden\n         // type can be equal to any of the region parameters of the\n         // opaque type definition.\n         let choice_regions: Lrc<Vec<ty::Region<'tcx>>> = Lrc::new(\n-            opaque_defn.substs[first_own_region..]\n+            opaque_type_key.substs[first_own_region..]\n                 .iter()\n                 .filter_map(|arg| match arg.unpack() {\n                     GenericArgKind::Lifetime(r) => Some(r),\n@@ -537,7 +536,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         concrete_ty.visit_with(&mut ConstrainOpaqueTypeRegionVisitor {\n             op: |r| {\n                 self.member_constraint(\n-                    opaque_type_def_id,\n+                    opaque_type_key.def_id,\n                     opaque_defn.definition_span,\n                     concrete_ty,\n                     r,\n@@ -572,11 +571,12 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     ///   `opaque_defn.concrete_ty`\n     fn infer_opaque_definition_from_instantiation(\n         &self,\n-        def_id: DefId,\n-        substs: SubstsRef<'tcx>,\n+        opaque_type_key: OpaqueTypeKey<'tcx>,\n         instantiated_ty: Ty<'tcx>,\n         span: Span,\n     ) -> Ty<'tcx> {\n+        let OpaqueTypeKey { def_id, substs } = opaque_type_key;\n+\n         debug!(\n             \"infer_opaque_definition_from_instantiation(def_id={:?}, instantiated_ty={:?})\",\n             def_id, instantiated_ty\n@@ -1007,7 +1007,9 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n                             ),\n                         };\n                         if in_definition_scope {\n-                            return self.fold_opaque_ty(ty, def_id.to_def_id(), substs, origin);\n+                            let opaque_type_key =\n+                                OpaqueTypeKey { def_id: def_id.to_def_id(), substs };\n+                            return self.fold_opaque_ty(ty, opaque_type_key, origin);\n                         }\n \n                         debug!(\n@@ -1029,18 +1031,18 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n     fn fold_opaque_ty(\n         &mut self,\n         ty: Ty<'tcx>,\n-        def_id: DefId,\n-        substs: SubstsRef<'tcx>,\n+        opaque_type_key: OpaqueTypeKey<'tcx>,\n         origin: hir::OpaqueTyOrigin,\n     ) -> Ty<'tcx> {\n         let infcx = self.infcx;\n         let tcx = infcx.tcx;\n+        let OpaqueTypeKey { def_id, substs } = opaque_type_key;\n \n         debug!(\"instantiate_opaque_types: Opaque(def_id={:?}, substs={:?})\", def_id, substs);\n \n         // Use the same type variable if the exact same opaque type appears more\n         // than once in the return type (e.g., if it's passed to a type alias).\n-        if let Some(opaque_defn) = self.opaque_types.get(&def_id) {\n+        if let Some(opaque_defn) = self.opaque_types.get(&opaque_type_key) {\n             debug!(\"instantiate_opaque_types: returning concrete ty {:?}\", opaque_defn.concrete_ty);\n             return opaque_defn.concrete_ty;\n         }\n@@ -1078,10 +1080,9 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n         let definition_span = self.value_span;\n \n         self.opaque_types.insert(\n-            def_id,\n+            OpaqueTypeKey { def_id, substs },\n             OpaqueTypeDecl {\n                 opaque_type: ty,\n-                substs,\n                 definition_span,\n                 concrete_ty: ty_var,\n                 has_required_region_bounds: !required_region_bounds.is_empty(),"}, {"sha": "b1a938836b70ee1fff62cf28941327e124a5080e", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -97,6 +97,16 @@ pub fn is_const_evaluatable<'cx, 'tcx>(\n \n                         ControlFlow::CONTINUE\n                     }\n+                    Node::Cast(_, _, ty) => {\n+                        let ty = ty.subst(tcx, ct.substs);\n+                        if ty.has_infer_types_or_consts() {\n+                            failure_kind = FailureKind::MentionsInfer;\n+                        } else if ty.has_param_types_or_consts() {\n+                            failure_kind = cmp::min(failure_kind, FailureKind::MentionsParam);\n+                        }\n+\n+                        ControlFlow::CONTINUE\n+                    }\n                     Node::Binop(_, _, _) | Node::UnaryOp(_, _) | Node::FunctionCall(_, _) => {\n                         ControlFlow::CONTINUE\n                     }\n@@ -304,6 +314,9 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n                 self.nodes[func].used = true;\n                 nodes.iter().for_each(|&n| self.nodes[n].used = true);\n             }\n+            Node::Cast(_, operand, _) => {\n+                self.nodes[operand].used = true;\n+            }\n         }\n \n         // Nodes start as unused.\n@@ -408,11 +421,19 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n                         self.locals[local] = self.add_node(Node::UnaryOp(op, operand), span);\n                         Ok(())\n                     }\n+                    Rvalue::Cast(cast_kind, ref operand, ty) => {\n+                        let operand = self.operand_to_node(span, operand)?;\n+                        self.locals[local] =\n+                            self.add_node(Node::Cast(cast_kind, operand, ty), span);\n+                        Ok(())\n+                    }\n                     _ => self.error(Some(span), \"unsupported rvalue\")?,\n                 }\n             }\n             // These are not actually relevant for us here, so we can ignore them.\n-            StatementKind::StorageLive(_) | StatementKind::StorageDead(_) => Ok(()),\n+            StatementKind::AscribeUserType(..)\n+            | StatementKind::StorageLive(_)\n+            | StatementKind::StorageDead(_) => Ok(()),\n             _ => self.error(Some(stmt.source_info.span), \"unsupported statement\")?,\n         }\n     }\n@@ -594,6 +615,7 @@ where\n                 recurse(tcx, ct.subtree(func), f)?;\n                 args.iter().try_for_each(|&arg| recurse(tcx, ct.subtree(arg), f))\n             }\n+            Node::Cast(_, operand, _) => recurse(tcx, ct.subtree(operand), f),\n         }\n     }\n \n@@ -676,6 +698,11 @@ pub(super) fn try_unify<'tcx>(\n                 && iter::zip(a_args, b_args)\n                     .all(|(&an, &bn)| try_unify(tcx, a.subtree(an), b.subtree(bn)))\n         }\n+        (Node::Cast(a_cast_kind, a_operand, a_ty), Node::Cast(b_cast_kind, b_operand, b_ty))\n+            if (a_ty == b_ty) && (a_cast_kind == b_cast_kind) =>\n+        {\n+            try_unify(tcx, a.subtree(a_operand), b.subtree(b_operand))\n+        }\n         _ => false,\n     }\n }"}, {"sha": "19c3385dd4cbcbc119df5a9144fc0cf8a7eea2b0", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -1878,6 +1878,10 @@ impl<'v> Visitor<'v> for FindTypeParam {\n         hir::intravisit::NestedVisitorMap::None\n     }\n \n+    fn visit_where_predicate(&mut self, _: &'v hir::WherePredicate<'v>) {\n+        // Skip where-clauses, to avoid suggesting indirection for type parameters found there.\n+    }\n+\n     fn visit_ty(&mut self, ty: &hir::Ty<'_>) {\n         // We collect the spans of all uses of the \"bare\" type param, like in `field: T` or\n         // `field: (T, T)` where we could make `T: ?Sized` while skipping cases that are known to be"}, {"sha": "5c35b515f3d027f9ba60db1e4ab0a8e447699080", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -21,6 +21,7 @@ use rustc_middle::ty::{\n     Infer, InferTy, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness,\n };\n use rustc_middle::ty::{TypeAndMut, TypeckResults};\n+use rustc_span::def_id::LOCAL_CRATE;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{BytePos, MultiSpan, Span, DUMMY_SP};\n use rustc_target::spec::abi;\n@@ -2313,7 +2314,8 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         let suggested_limit = current_limit * 2;\n         err.help(&format!(\n             \"consider adding a `#![recursion_limit=\\\"{}\\\"]` attribute to your crate (`{}`)\",\n-            suggested_limit, self.tcx.crate_name,\n+            suggested_limit,\n+            self.tcx.crate_name(LOCAL_CRATE),\n         ));\n     }\n "}, {"sha": "7ebef7f8883ae0902eca5df5eea3c5a409771b52", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -838,6 +838,7 @@ fn contains_illegal_self_type_reference<'tcx, T: TypeFoldable<'tcx>>(\n                         let leaf = leaf.subst(self.tcx, ct.substs);\n                         self.visit_const(leaf)\n                     }\n+                    Node::Cast(_, _, ty) => self.visit_ty(ty),\n                     Node::Binop(..) | Node::UnaryOp(..) | Node::FunctionCall(_, _) => {\n                         ControlFlow::CONTINUE\n                     }\n@@ -859,6 +860,7 @@ fn contains_illegal_self_type_reference<'tcx, T: TypeFoldable<'tcx>>(\n                             let leaf = leaf.subst(self.tcx, ct.substs);\n                             self.visit_const(leaf)\n                         }\n+                        Node::Cast(_, _, ty) => self.visit_ty(ty),\n                         Node::Binop(..) | Node::UnaryOp(..) | Node::FunctionCall(_, _) => {\n                             ControlFlow::CONTINUE\n                         }"}, {"sha": "ebc7b0d0d99cfc0eb5a8bc65e386997c2b7fdaba", "filename": "compiler/rustc_ty_utils/src/ty.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -7,7 +7,6 @@ use rustc_middle::ty::{\n     self, Binder, Predicate, PredicateKind, ToPredicate, Ty, TyCtxt, WithConstness,\n };\n use rustc_session::CrateDisambiguator;\n-use rustc_span::symbol::Symbol;\n use rustc_span::Span;\n use rustc_trait_selection::traits;\n \n@@ -394,11 +393,6 @@ fn crate_disambiguator(tcx: TyCtxt<'_>, crate_num: CrateNum) -> CrateDisambiguat\n     tcx.sess.local_crate_disambiguator()\n }\n \n-fn original_crate_name(tcx: TyCtxt<'_>, crate_num: CrateNum) -> Symbol {\n-    assert_eq!(crate_num, LOCAL_CRATE);\n-    tcx.crate_name\n-}\n-\n fn instance_def_size_estimate<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     instance_def: ty::InstanceDef<'tcx>,\n@@ -545,7 +539,6 @@ pub fn provide(providers: &mut ty::query::Providers) {\n         param_env_reveal_all_normalized,\n         trait_of_item,\n         crate_disambiguator,\n-        original_crate_name,\n         instance_def_size_estimate,\n         issue33140_self_ty,\n         impl_defaultness,"}, {"sha": "2d102127dd9d65dd7c2585590dbe8647e0a60782", "filename": "compiler/rustc_type_ir/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -1,5 +1,4 @@\n #![feature(min_specialization)]\n-#![feature(trusted_step)]\n \n #[macro_use]\n extern crate bitflags;"}, {"sha": "70d85796d002e961a70149c3cb06e1d1818699d0", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -16,7 +16,7 @@ use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::layout::MAX_SIMD_LANES;\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::util::{Discr, IntTypeExt};\n-use rustc_middle::ty::{self, ParamEnv, RegionKind, Ty, TyCtxt};\n+use rustc_middle::ty::{self, OpaqueTypeKey, ParamEnv, RegionKind, Ty, TyCtxt};\n use rustc_session::lint::builtin::UNINHABITED_STATIC;\n use rustc_span::symbol::sym;\n use rustc_span::{self, MultiSpan, Span};\n@@ -716,10 +716,10 @@ fn check_opaque_meets_bounds<'tcx>(\n             infcx.instantiate_opaque_types(def_id, hir_id, param_env, opaque_ty, span),\n         );\n \n-        for (def_id, opaque_defn) in opaque_type_map {\n+        for (OpaqueTypeKey { def_id, substs }, opaque_defn) in opaque_type_map {\n             match infcx\n                 .at(&misc_cause, param_env)\n-                .eq(opaque_defn.concrete_ty, tcx.type_of(def_id).subst(tcx, opaque_defn.substs))\n+                .eq(opaque_defn.concrete_ty, tcx.type_of(def_id).subst(tcx, substs))\n             {\n                 Ok(infer_ok) => inh.register_infer_ok_obligations(infer_ok),\n                 Err(ty_err) => tcx.sess.delay_span_bug(\n@@ -1214,10 +1214,19 @@ pub fn check_simd(tcx: TyCtxt<'_>, sp: Span, def_id: LocalDefId) {\n                 }\n             }\n \n+            // Check that we use types valid for use in the lanes of a SIMD \"vector register\"\n+            // These are scalar types which directly match a \"machine\" type\n+            // Yes: Integers, floats, \"thin\" pointers\n+            // No: char, \"fat\" pointers, compound types\n             match e.kind() {\n-                ty::Param(_) => { /* struct<T>(T, T, T, T) is ok */ }\n-                _ if e.is_machine() => { /* struct(u8, u8, u8, u8) is ok */ }\n-                ty::Array(ty, _c) if ty.is_machine() => { /* struct([f32; 4]) */ }\n+                ty::Param(_) => (), // pass struct<T>(T, T, T, T) through, let monomorphization catch errors\n+                ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::RawPtr(_) => (), // struct(u8, u8, u8, u8) is ok\n+                ty::Array(t, _clen)\n+                    if matches!(\n+                        t.kind(),\n+                        ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::RawPtr(_)\n+                    ) =>\n+                { /* struct([f32; 4]) is ok */ }\n                 _ => {\n                     struct_span_err!(\n                         tcx.sess,"}, {"sha": "33bc25accb319dceffcf2862d321aaf476cbee1f", "filename": "compiler/rustc_typeck/src/check/demand.rs", "status": "modified", "additions": 29, "deletions": 23, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -8,6 +8,7 @@ use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{is_range_literal, Node};\n+use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::adjustment::AllowTwoPhase;\n use rustc_middle::ty::{self, AssocItem, Ty, TypeAndMut};\n use rustc_span::symbol::sym;\n@@ -16,6 +17,7 @@ use rustc_span::Span;\n use super::method::probe;\n \n use std::fmt;\n+use std::iter;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn emit_coerce_suggestions(\n@@ -412,25 +414,23 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         checked_ty: Ty<'tcx>,\n         expected: Ty<'tcx>,\n     ) -> Option<(Span, &'static str, String, Applicability)> {\n-        let sm = self.sess().source_map();\n+        let sess = self.sess();\n         let sp = expr.span;\n-        if sm.is_imported(sp) {\n-            // Ignore if span is from within a macro #41858, #58298. We previously used the macro\n-            // call span, but that breaks down when the type error comes from multiple calls down.\n+\n+        // If the span is from an external macro, there's no suggestion we can make.\n+        if in_external_macro(sess, sp) {\n             return None;\n         }\n \n+        let sm = sess.source_map();\n+\n         let replace_prefix = |s: &str, old: &str, new: &str| {\n             s.strip_prefix(old).map(|stripped| new.to_string() + stripped)\n         };\n \n         let is_struct_pat_shorthand_field =\n             self.is_hir_id_from_struct_pattern_shorthand_field(expr.hir_id, sp);\n \n-        // If the span is from a macro, then it's hard to extract the text\n-        // and make a good suggestion, so don't bother.\n-        let is_macro = sp.from_expansion() && sp.desugaring_kind().is_none();\n-\n         // `ExprKind::DropTemps` is semantically irrelevant for these suggestions.\n         let expr = expr.peel_drop_temps();\n \n@@ -570,32 +570,38 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 hir::ExprKind::AddrOf(hir::BorrowKind::Ref, _, ref expr),\n                 _,\n                 &ty::Ref(_, checked, _),\n-            ) if {\n-                self.infcx.can_sub(self.param_env, checked, &expected).is_ok() && !is_macro\n-            } =>\n-            {\n+            ) if self.infcx.can_sub(self.param_env, checked, &expected).is_ok() => {\n                 // We have `&T`, check if what was expected was `T`. If so,\n                 // we may want to suggest removing a `&`.\n                 if sm.is_imported(expr.span) {\n-                    if let Ok(src) = sm.span_to_snippet(sp) {\n-                        if let Some(src) = src.strip_prefix('&') {\n+                    // Go through the spans from which this span was expanded,\n+                    // and find the one that's pointing inside `sp`.\n+                    //\n+                    // E.g. for `&format!(\"\")`, where we want the span to the\n+                    // `format!()` invocation instead of its expansion.\n+                    if let Some(call_span) =\n+                        iter::successors(Some(expr.span), |s| s.parent()).find(|&s| sp.contains(s))\n+                    {\n+                        if let Ok(code) = sm.span_to_snippet(call_span) {\n                             return Some((\n                                 sp,\n                                 \"consider removing the borrow\",\n-                                src.to_string(),\n+                                code,\n                                 Applicability::MachineApplicable,\n                             ));\n                         }\n                     }\n                     return None;\n                 }\n-                if let Ok(code) = sm.span_to_snippet(expr.span) {\n-                    return Some((\n-                        sp,\n-                        \"consider removing the borrow\",\n-                        code,\n-                        Applicability::MachineApplicable,\n-                    ));\n+                if sp.contains(expr.span) {\n+                    if let Ok(code) = sm.span_to_snippet(expr.span) {\n+                        return Some((\n+                            sp,\n+                            \"consider removing the borrow\",\n+                            code,\n+                            Applicability::MachineApplicable,\n+                        ));\n+                    }\n                 }\n             }\n             (\n@@ -643,7 +649,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                 }\n             }\n-            _ if sp == expr.span && !is_macro => {\n+            _ if sp == expr.span => {\n                 if let Some(steps) = self.deref_steps(checked_ty, expected) {\n                     let expr = expr.peel_blocks();\n "}, {"sha": "01276495c185aea81546f90973c0c04a3db91852", "filename": "compiler/rustc_typeck/src/check/dropck.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -310,6 +310,7 @@ impl TypeRelation<'tcx> for SimpleEqRelation<'tcx> {\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         _: ty::Variance,\n+        _info: ty::VarianceDiagInfo<'tcx>,\n         a: T,\n         b: T,\n     ) -> RelateResult<'tcx, T> {"}, {"sha": "2e9bef15f900a715fe515a9bb3e8d7db23325d84", "filename": "compiler/rustc_typeck/src/check/inherited.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -2,13 +2,14 @@ use super::callee::DeferredCallResolution;\n use super::MaybeInProgressTables;\n \n use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::vec_map::VecMap;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefIdMap, LocalDefId};\n use rustc_hir::HirIdMap;\n use rustc_infer::infer;\n use rustc_infer::infer::{InferCtxt, InferOk, TyCtxtInferExt};\n use rustc_middle::ty::fold::TypeFoldable;\n-use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_middle::ty::{self, OpaqueTypeKey, Ty, TyCtxt};\n use rustc_span::{self, Span};\n use rustc_trait_selection::infer::InferCtxtExt as _;\n use rustc_trait_selection::opaque_types::OpaqueTypeDecl;\n@@ -58,7 +59,7 @@ pub struct Inherited<'a, 'tcx> {\n     // associated fresh inference variable. Writeback resolves these\n     // variables to get the concrete type, which can be used to\n     // 'de-opaque' OpaqueTypeDecl, after typeck is done with all functions.\n-    pub(super) opaque_types: RefCell<DefIdMap<OpaqueTypeDecl<'tcx>>>,\n+    pub(super) opaque_types: RefCell<VecMap<OpaqueTypeKey<'tcx>, OpaqueTypeDecl<'tcx>>>,\n \n     /// A map from inference variables created from opaque\n     /// type instantiations (`ty::Infer`) to the actual opaque"}, {"sha": "652b82f1063c9c48c60d71f2f2980e47a2c750ca", "filename": "compiler/rustc_typeck/src/check/place_op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fplace_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fplace_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fplace_op.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -248,7 +248,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // Clear previous flag; after a pointer indirection it does not apply any more.\n                 inside_union = false;\n             }\n-            if source.ty_adt_def().map_or(false, |adt| adt.is_union()) {\n+            if source.is_union() {\n                 inside_union = true;\n             }\n             // Fix up the autoderefs. Autorefs can only occur immediately preceding"}, {"sha": "6baa185406e207f7373f23588d010bbc40aaf16a", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -1588,6 +1588,11 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n     fn fake_read(&mut self, place: Place<'tcx>, cause: FakeReadCause, diag_expr_id: hir::HirId) {\n         if let PlaceBase::Upvar(_) = place.base {\n+            // We need to restrict Fake Read precision to avoid fake reading unsafe code,\n+            // such as deref of a raw pointer.\n+            let place = restrict_capture_precision(place);\n+            let place =\n+                restrict_repr_packed_field_ref_capture(self.fcx.tcx, self.fcx.param_env, &place);\n             self.fake_reads.push((place, cause, diag_expr_id));\n         }\n     }"}, {"sha": "032cc7ee2334abc18a641f34cbb022dc577ee171", "filename": "compiler/rustc_typeck/src/check/writeback.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -475,8 +475,9 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n     }\n \n     fn visit_opaque_types(&mut self, span: Span) {\n-        for (&def_id, opaque_defn) in self.fcx.opaque_types.borrow().iter() {\n-            let hir_id = self.tcx().hir().local_def_id_to_hir_id(def_id.expect_local());\n+        for &(opaque_type_key, opaque_defn) in self.fcx.opaque_types.borrow().iter() {\n+            let hir_id =\n+                self.tcx().hir().local_def_id_to_hir_id(opaque_type_key.def_id.expect_local());\n             let instantiated_ty = self.resolve(opaque_defn.concrete_ty, &hir_id);\n \n             debug_assert!(!instantiated_ty.has_escaping_bound_vars());\n@@ -494,50 +495,47 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n             // ```\n             // figures out the concrete type with `U`, but the stored type is with `T`.\n             let definition_ty = self.fcx.infer_opaque_definition_from_instantiation(\n-                def_id,\n-                opaque_defn.substs,\n+                opaque_type_key,\n                 instantiated_ty,\n                 span,\n             );\n \n             let mut skip_add = false;\n \n-            if let ty::Opaque(defin_ty_def_id, _substs) = *definition_ty.kind() {\n+            if let ty::Opaque(definition_ty_def_id, _substs) = *definition_ty.kind() {\n                 if let hir::OpaqueTyOrigin::Misc | hir::OpaqueTyOrigin::TyAlias = opaque_defn.origin\n                 {\n-                    if def_id == defin_ty_def_id {\n+                    if opaque_type_key.def_id == definition_ty_def_id {\n                         debug!(\n                             \"skipping adding concrete definition for opaque type {:?} {:?}\",\n-                            opaque_defn, defin_ty_def_id\n+                            opaque_defn, opaque_type_key.def_id\n                         );\n                         skip_add = true;\n                     }\n                 }\n             }\n \n-            if !opaque_defn.substs.needs_infer() {\n+            if !opaque_type_key.substs.needs_infer() {\n                 // We only want to add an entry into `concrete_opaque_types`\n                 // if we actually found a defining usage of this opaque type.\n                 // Otherwise, we do nothing - we'll either find a defining usage\n                 // in some other location, or we'll end up emitting an error due\n                 // to the lack of defining usage\n                 if !skip_add {\n-                    let new = ty::ResolvedOpaqueTy {\n-                        concrete_type: definition_ty,\n-                        substs: opaque_defn.substs,\n-                    };\n-\n-                    let old = self.typeck_results.concrete_opaque_types.insert(def_id, new);\n-                    if let Some(old) = old {\n-                        if old.concrete_type != definition_ty || old.substs != opaque_defn.substs {\n+                    let old_concrete_ty = self\n+                        .typeck_results\n+                        .concrete_opaque_types\n+                        .insert(opaque_type_key, definition_ty);\n+                    if let Some(old_concrete_ty) = old_concrete_ty {\n+                        if old_concrete_ty != definition_ty {\n                             span_bug!(\n                                 span,\n                                 \"`visit_opaque_types` tried to write different types for the same \\\n                                  opaque type: {:?}, {:?}, {:?}, {:?}\",\n-                                def_id,\n+                                opaque_type_key.def_id,\n                                 definition_ty,\n                                 opaque_defn,\n-                                old,\n+                                old_concrete_ty,\n                             );\n                         }\n                     }"}, {"sha": "ee3ac3b62d9ec7ed5d56b03004ad24a21a634700", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -2597,6 +2597,7 @@ fn from_target_feature(\n                 Some(sym::rtm_target_feature) => rust_features.rtm_target_feature,\n                 Some(sym::f16c_target_feature) => rust_features.f16c_target_feature,\n                 Some(sym::ermsb_target_feature) => rust_features.ermsb_target_feature,\n+                Some(sym::bpf_target_feature) => rust_features.bpf_target_feature,\n                 Some(name) => bug!(\"unknown target feature gate {}\", name),\n                 None => true,\n             };\n@@ -2770,7 +2771,25 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n             }\n         } else if tcx.sess.check_name(attr, sym::target_feature) {\n             if !tcx.is_closure(id) && tcx.fn_sig(id).unsafety() == hir::Unsafety::Normal {\n-                if !tcx.features().target_feature_11 {\n+                if tcx.sess.target.is_like_wasm || tcx.sess.opts.actually_rustdoc {\n+                    // The `#[target_feature]` attribute is allowed on\n+                    // WebAssembly targets on all functions, including safe\n+                    // ones. Other targets require that `#[target_feature]` is\n+                    // only applied to unsafe funtions (pending the\n+                    // `target_feature_11` feature) because on most targets\n+                    // execution of instructions that are not supported is\n+                    // considered undefined behavior. For WebAssembly which is a\n+                    // 100% safe target at execution time it's not possible to\n+                    // execute undefined instructions, and even if a future\n+                    // feature was added in some form for this it would be a\n+                    // deterministic trap. There is no undefined behavior when\n+                    // executing WebAssembly so `#[target_feature]` is allowed\n+                    // on safe functions (but again, only for WebAssembly)\n+                    //\n+                    // Note that this is also allowed if `actually_rustdoc` so\n+                    // if a target is documenting some wasm-specific code then\n+                    // it's not spuriously denied.\n+                } else if !tcx.features().target_feature_11 {\n                     let mut err = feature_err(\n                         &tcx.sess.parse_sess,\n                         sym::target_feature_11,"}, {"sha": "abe5d69a3b3c1b313c71f02a28084f38167d5fb8", "filename": "compiler/rustc_typeck/src/collect/type_of.rs", "status": "modified", "additions": 88, "deletions": 23, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -9,7 +9,7 @@ use rustc_hir::{HirId, Node};\n use rustc_middle::hir::map::Map;\n use rustc_middle::ty::subst::{GenericArgKind, InternalSubsts};\n use rustc_middle::ty::util::IntTypeExt;\n-use rustc_middle::ty::{self, DefIdTree, Ty, TyCtxt, TypeFoldable};\n+use rustc_middle::ty::{self, DefIdTree, Ty, TyCtxt, TypeFoldable, TypeFolder};\n use rustc_span::symbol::Ident;\n use rustc_span::{Span, DUMMY_SP};\n \n@@ -349,8 +349,8 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                     let concrete_ty = tcx\n                         .mir_borrowck(owner.expect_local())\n                         .concrete_opaque_types\n-                        .get(&def_id.to_def_id())\n-                        .map(|opaque| opaque.concrete_type)\n+                        .get_by(|(key, _)| key.def_id == def_id.to_def_id())\n+                        .map(|concrete_ty| *concrete_ty)\n                         .unwrap_or_else(|| {\n                             tcx.sess.delay_span_bug(\n                                 DUMMY_SP,\n@@ -515,19 +515,27 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Ty<'_> {\n             }\n             // Calling `mir_borrowck` can lead to cycle errors through\n             // const-checking, avoid calling it if we don't have to.\n-            if !self.tcx.typeck(def_id).concrete_opaque_types.contains_key(&self.def_id) {\n+            if self\n+                .tcx\n+                .typeck(def_id)\n+                .concrete_opaque_types\n+                .get_by(|(key, _)| key.def_id == self.def_id)\n+                .is_none()\n+            {\n                 debug!(\n                     \"find_opaque_ty_constraints: no constraint for `{:?}` at `{:?}`\",\n                     self.def_id, def_id,\n                 );\n                 return;\n             }\n             // Use borrowck to get the type with unerased regions.\n-            let ty = self.tcx.mir_borrowck(def_id).concrete_opaque_types.get(&self.def_id);\n-            if let Some(ty::ResolvedOpaqueTy { concrete_type, substs }) = ty {\n+            let concrete_opaque_types = &self.tcx.mir_borrowck(def_id).concrete_opaque_types;\n+            if let Some((opaque_type_key, concrete_type)) =\n+                concrete_opaque_types.iter().find(|(key, _)| key.def_id == self.def_id)\n+            {\n                 debug!(\n                     \"find_opaque_ty_constraints: found constraint for `{:?}` at `{:?}`: {:?}\",\n-                    self.def_id, def_id, ty,\n+                    self.def_id, def_id, concrete_type,\n                 );\n \n                 // FIXME(oli-obk): trace the actual span from inference to improve errors.\n@@ -538,7 +546,7 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Ty<'_> {\n                 // using `delay_span_bug`, just in case `wfcheck` slips up.\n                 let opaque_generics = self.tcx.generics_of(self.def_id);\n                 let mut used_params: FxHashSet<_> = FxHashSet::default();\n-                for (i, arg) in substs.iter().enumerate() {\n+                for (i, arg) in opaque_type_key.substs.iter().enumerate() {\n                     let arg_is_param = match arg.unpack() {\n                         GenericArgKind::Type(ty) => matches!(ty.kind(), ty::Param(_)),\n                         GenericArgKind::Lifetime(lt) => {\n@@ -699,8 +707,8 @@ fn let_position_impl_trait_type(tcx: TyCtxt<'_>, opaque_ty_id: LocalDefId) -> Ty\n     let owner_typeck_results = tcx.typeck(scope_def_id);\n     let concrete_ty = owner_typeck_results\n         .concrete_opaque_types\n-        .get(&opaque_ty_def_id)\n-        .map(|opaque| opaque.concrete_type)\n+        .get_by(|(key, _)| key.def_id == opaque_ty_def_id)\n+        .map(|concrete_ty| *concrete_ty)\n         .unwrap_or_else(|| {\n             tcx.sess.delay_span_bug(\n                 DUMMY_SP,\n@@ -741,6 +749,40 @@ fn infer_placeholder_type(\n     span: Span,\n     item_ident: Ident,\n ) -> Ty<'_> {\n+    // Attempts to make the type nameable by turning FnDefs into FnPtrs.\n+    struct MakeNameable<'tcx> {\n+        success: bool,\n+        tcx: TyCtxt<'tcx>,\n+    }\n+\n+    impl<'tcx> MakeNameable<'tcx> {\n+        fn new(tcx: TyCtxt<'tcx>) -> Self {\n+            MakeNameable { success: true, tcx }\n+        }\n+    }\n+\n+    impl TypeFolder<'tcx> for MakeNameable<'tcx> {\n+        fn tcx(&self) -> TyCtxt<'tcx> {\n+            self.tcx\n+        }\n+\n+        fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+            if !self.success {\n+                return ty;\n+            }\n+\n+            match ty.kind() {\n+                ty::FnDef(def_id, _) => self.tcx.mk_fn_ptr(self.tcx.fn_sig(*def_id)),\n+                // FIXME: non-capturing closures should also suggest a function pointer\n+                ty::Closure(..) | ty::Generator(..) => {\n+                    self.success = false;\n+                    ty\n+                }\n+                _ => ty.super_fold_with(self),\n+            }\n+        }\n+    }\n+\n     let ty = tcx.diagnostic_only_typeck(def_id).node_type(body_id.hir_id);\n \n     // If this came from a free `const` or `static mut?` item,\n@@ -752,24 +794,47 @@ fn infer_placeholder_type(\n             // The parser provided a sub-optimal `HasPlaceholders` suggestion for the type.\n             // We are typeck and have the real type, so remove that and suggest the actual type.\n             err.suggestions.clear();\n-            err.span_suggestion(\n-                span,\n-                \"provide a type for the item\",\n-                format!(\"{}: {}\", item_ident, ty),\n-                Applicability::MachineApplicable,\n-            )\n-            .emit_unless(ty.references_error());\n+\n+            // Suggesting unnameable types won't help.\n+            let mut mk_nameable = MakeNameable::new(tcx);\n+            let ty = mk_nameable.fold_ty(ty);\n+            let sugg_ty = if mk_nameable.success { Some(ty) } else { None };\n+            if let Some(sugg_ty) = sugg_ty {\n+                err.span_suggestion(\n+                    span,\n+                    \"provide a type for the item\",\n+                    format!(\"{}: {}\", item_ident, sugg_ty),\n+                    Applicability::MachineApplicable,\n+                );\n+            } else {\n+                err.span_note(\n+                    tcx.hir().body(body_id).value.span,\n+                    &format!(\"however, the inferred type `{}` cannot be named\", ty.to_string()),\n+                );\n+            }\n+\n+            err.emit_unless(ty.references_error());\n         }\n         None => {\n             let mut diag = bad_placeholder_type(tcx, vec![span]);\n \n             if !ty.references_error() {\n-                diag.span_suggestion(\n-                    span,\n-                    \"replace `_` with the correct type\",\n-                    ty.to_string(),\n-                    Applicability::MaybeIncorrect,\n-                );\n+                let mut mk_nameable = MakeNameable::new(tcx);\n+                let ty = mk_nameable.fold_ty(ty);\n+                let sugg_ty = if mk_nameable.success { Some(ty) } else { None };\n+                if let Some(sugg_ty) = sugg_ty {\n+                    diag.span_suggestion(\n+                        span,\n+                        \"replace with the correct type\",\n+                        sugg_ty.to_string(),\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                } else {\n+                    diag.span_note(\n+                        tcx.hir().body(body_id).value.span,\n+                        &format!(\"however, the inferred type `{}` cannot be named\", ty.to_string()),\n+                    );\n+                }\n             }\n \n             diag.emit();"}, {"sha": "bccc19774e0d94048c6dcaa71d24b989d8103065", "filename": "compiler/rustc_typeck/src/structured_errors/wrong_number_of_generic_args.rs", "status": "modified", "additions": 44, "deletions": 31, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_typeck%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/compiler%2Frustc_typeck%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -605,30 +605,35 @@ impl<'a, 'tcx> WrongNumberOfGenericArgs<'a, 'tcx> {\n         let remove_entire_generics = num_redundant_args >= self.gen_args.args.len();\n \n         let remove_lifetime_args = |err: &mut DiagnosticBuilder<'_>| {\n-            let idx_first_redundant_lt_args = self.num_expected_lifetime_args();\n-            let span_lo_redundant_lt_args =\n-                self.gen_args.args[idx_first_redundant_lt_args].span().shrink_to_lo();\n-            let span_hi_redundant_lt_args = self.gen_args.args\n-                [idx_first_redundant_lt_args + num_redundant_lt_args - 1]\n-                .span()\n-                .shrink_to_hi();\n-            let eat_comma =\n-                idx_first_redundant_lt_args + num_redundant_lt_args - 1 != self.gen_args.args.len();\n-\n-            let span_redundant_lt_args = if eat_comma {\n-                let span_hi = self.gen_args.args\n-                    [idx_first_redundant_lt_args + num_redundant_lt_args - 1]\n-                    .span()\n-                    .shrink_to_hi();\n-                span_lo_redundant_lt_args.to(span_hi)\n-            } else {\n-                span_lo_redundant_lt_args.to(span_hi_redundant_lt_args)\n-            };\n+            let mut lt_arg_spans = Vec::new();\n+            let mut found_redundant = false;\n+            for arg in self.gen_args.args {\n+                if let hir::GenericArg::Lifetime(_) = arg {\n+                    lt_arg_spans.push(arg.span());\n+                    if lt_arg_spans.len() > self.num_expected_lifetime_args() {\n+                        found_redundant = true;\n+                    }\n+                } else if found_redundant {\n+                    // Argument which is redundant and separated like this `'c`\n+                    // is not included to avoid including `Bar` in span.\n+                    // ```\n+                    // type Foo<'a, T> = &'a T;\n+                    // let _: Foo<'a, 'b, Bar, 'c>;\n+                    // ```\n+                    break;\n+                }\n+            }\n+\n+            let span_lo_redundant_lt_args = lt_arg_spans[self.num_expected_lifetime_args()];\n+            let span_hi_redundant_lt_args = lt_arg_spans[lt_arg_spans.len() - 1];\n+\n+            let span_redundant_lt_args = span_lo_redundant_lt_args.to(span_hi_redundant_lt_args);\n             debug!(\"span_redundant_lt_args: {:?}\", span_redundant_lt_args);\n \n+            let num_redundant_lt_args = lt_arg_spans.len() - self.num_expected_lifetime_args();\n             let msg_lifetimes = format!(\n                 \"remove {} {} argument{}\",\n-                if num_redundant_args == 1 { \"this\" } else { \"these\" },\n+                if num_redundant_lt_args == 1 { \"this\" } else { \"these\" },\n                 \"lifetime\",\n                 pluralize!(num_redundant_lt_args),\n             );\n@@ -642,26 +647,34 @@ impl<'a, 'tcx> WrongNumberOfGenericArgs<'a, 'tcx> {\n         };\n \n         let remove_type_or_const_args = |err: &mut DiagnosticBuilder<'_>| {\n-            let idx_first_redundant_type_or_const_args = self.get_lifetime_args_offset()\n-                + num_redundant_lt_args\n-                + self.num_expected_type_or_const_args();\n+            let mut gen_arg_spans = Vec::new();\n+            let mut found_redundant = false;\n+            for arg in self.gen_args.args {\n+                match arg {\n+                    hir::GenericArg::Type(_) | hir::GenericArg::Const(_) => {\n+                        gen_arg_spans.push(arg.span());\n+                        if gen_arg_spans.len() > self.num_expected_type_or_const_args() {\n+                            found_redundant = true;\n+                        }\n+                    }\n+                    _ if found_redundant => break,\n+                    _ => {}\n+                }\n+            }\n \n             let span_lo_redundant_type_or_const_args =\n-                self.gen_args.args[idx_first_redundant_type_or_const_args].span().shrink_to_lo();\n-\n-            let span_hi_redundant_type_or_const_args = self.gen_args.args\n-                [idx_first_redundant_type_or_const_args + num_redundant_type_or_const_args - 1]\n-                .span()\n-                .shrink_to_hi();\n+                gen_arg_spans[self.num_expected_type_or_const_args()];\n+            let span_hi_redundant_type_or_const_args = gen_arg_spans[gen_arg_spans.len() - 1];\n \n             let span_redundant_type_or_const_args =\n                 span_lo_redundant_type_or_const_args.to(span_hi_redundant_type_or_const_args);\n-\n             debug!(\"span_redundant_type_or_const_args: {:?}\", span_redundant_type_or_const_args);\n \n+            let num_redundant_gen_args =\n+                gen_arg_spans.len() - self.num_expected_type_or_const_args();\n             let msg_types_or_consts = format!(\n                 \"remove {} {} argument{}\",\n-                if num_redundant_args == 1 { \"this\" } else { \"these\" },\n+                if num_redundant_gen_args == 1 { \"this\" } else { \"these\" },\n                 \"generic\",\n                 pluralize!(num_redundant_type_or_const_args),\n             );"}, {"sha": "7fa5353d09b899e7af4872bdb3ee522b41a4788c", "filename": "config.toml.example", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -94,7 +94,7 @@ changelog-seen = 2\n # support. You'll need to write a target specification at least, and most\n # likely, teach rustc about the C ABI of the target. Get in touch with the\n # Rust team and file an issue if you need assistance in porting!\n-#targets = \"AArch64;ARM;Hexagon;MSP430;Mips;NVPTX;PowerPC;RISCV;Sparc;SystemZ;WebAssembly;X86\"\n+#targets = \"AArch64;ARM;BPF;Hexagon;MSP430;Mips;NVPTX;PowerPC;RISCV;Sparc;SystemZ;WebAssembly;X86\"\n \n # LLVM experimental targets to build support for. These targets are specified in\n # the same format as above, but since these targets are experimental, they are"}, {"sha": "91eec10d575935ab95bf69ac22962c13e5394988", "filename": "library/alloc/benches/vec.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Falloc%2Fbenches%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Falloc%2Fbenches%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fbenches%2Fvec.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -551,19 +551,13 @@ const LEN: usize = 16384;\n #[bench]\n fn bench_chain_collect(b: &mut Bencher) {\n     let data = black_box([0; LEN]);\n-    b.iter(|| data.iter().cloned().chain([1].iter().cloned()).collect::<Vec<_>>());\n+    b.iter(|| data.iter().cloned().chain([1]).collect::<Vec<_>>());\n }\n \n #[bench]\n fn bench_chain_chain_collect(b: &mut Bencher) {\n     let data = black_box([0; LEN]);\n-    b.iter(|| {\n-        data.iter()\n-            .cloned()\n-            .chain([1].iter().cloned())\n-            .chain([2].iter().cloned())\n-            .collect::<Vec<_>>()\n-    });\n+    b.iter(|| data.iter().cloned().chain([1]).chain([2]).collect::<Vec<_>>());\n }\n \n #[bench]"}, {"sha": "13b42442dcf0979e6f9832f2e5913ae9a2535b85", "filename": "library/alloc/src/boxed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Falloc%2Fsrc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Falloc%2Fsrc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fboxed.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -1209,7 +1209,7 @@ impl<T: ?Sized + Hasher, A: Allocator> Hasher for Box<T, A> {\n #[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"from_for_ptrs\", since = \"1.6.0\")]\n impl<T> From<T> for Box<T> {\n-    /// Converts a generic type `T` into a `Box<T>`\n+    /// Converts a `T` into a `Box<T>`\n     ///\n     /// The conversion allocates on the heap and moves `t`\n     /// from the stack into it."}, {"sha": "1a58ad51f78d3e8465a41d6f5fe9518a6f62f8f5", "filename": "library/alloc/src/collections/linked_list.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -64,7 +64,15 @@ pub struct Iter<'a, T: 'a> {\n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<T: fmt::Debug> fmt::Debug for Iter<'_, T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_tuple(\"Iter\").field(&self.len).finish()\n+        f.debug_tuple(\"Iter\")\n+            .field(&*mem::ManuallyDrop::new(LinkedList {\n+                head: self.head,\n+                tail: self.tail,\n+                len: self.len,\n+                marker: PhantomData,\n+            }))\n+            .field(&self.len)\n+            .finish()\n     }\n }\n \n@@ -82,19 +90,24 @@ impl<T> Clone for Iter<'_, T> {\n /// documentation for more.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, T: 'a> {\n-    // We do *not* exclusively own the entire list here, references to node's `element`\n-    // have been handed out by the iterator! So be careful when using this; the methods\n-    // called must be aware that there can be aliasing pointers to `element`.\n-    list: &'a mut LinkedList<T>,\n     head: Option<NonNull<Node<T>>>,\n     tail: Option<NonNull<Node<T>>>,\n     len: usize,\n+    marker: PhantomData<&'a mut Node<T>>,\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<T: fmt::Debug> fmt::Debug for IterMut<'_, T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_tuple(\"IterMut\").field(&self.list).field(&self.len).finish()\n+        f.debug_tuple(\"IterMut\")\n+            .field(&*mem::ManuallyDrop::new(LinkedList {\n+                head: self.head,\n+                tail: self.tail,\n+                len: self.len,\n+                marker: PhantomData,\n+            }))\n+            .field(&self.len)\n+            .finish()\n     }\n }\n \n@@ -493,7 +506,7 @@ impl<T> LinkedList<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter_mut(&mut self) -> IterMut<'_, T> {\n-        IterMut { head: self.head, tail: self.tail, len: self.len, list: self }\n+        IterMut { head: self.head, tail: self.tail, len: self.len, marker: PhantomData }\n     }\n \n     /// Provides a cursor at the front element."}, {"sha": "5d03be35e466fea7e14994ccfe7200c1d9f03c3c", "filename": "library/alloc/src/collections/vec_deque/mod.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -2416,7 +2416,6 @@ impl<T> VecDeque<T> {\n     /// found; the fourth could match any position in `[1, 4]`.\n     ///\n     /// ```\n-    /// #![feature(vecdeque_binary_search)]\n     /// use std::collections::VecDeque;\n     ///\n     /// let deque: VecDeque<_> = vec![0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55].into();\n@@ -2432,7 +2431,6 @@ impl<T> VecDeque<T> {\n     /// sort order:\n     ///\n     /// ```\n-    /// #![feature(vecdeque_binary_search)]\n     /// use std::collections::VecDeque;\n     ///\n     /// let mut deque: VecDeque<_> = vec![0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55].into();\n@@ -2441,7 +2439,7 @@ impl<T> VecDeque<T> {\n     /// deque.insert(idx, num);\n     /// assert_eq!(deque, &[0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 42, 55]);\n     /// ```\n-    #[unstable(feature = \"vecdeque_binary_search\", issue = \"78021\")]\n+    #[stable(feature = \"vecdeque_binary_search\", since = \"1.54.0\")]\n     #[inline]\n     pub fn binary_search(&self, x: &T) -> Result<usize, usize>\n     where\n@@ -2476,7 +2474,6 @@ impl<T> VecDeque<T> {\n     /// found; the fourth could match any position in `[1, 4]`.\n     ///\n     /// ```\n-    /// #![feature(vecdeque_binary_search)]\n     /// use std::collections::VecDeque;\n     ///\n     /// let deque: VecDeque<_> = vec![0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55].into();\n@@ -2487,7 +2484,7 @@ impl<T> VecDeque<T> {\n     /// let r = deque.binary_search_by(|x| x.cmp(&1));\n     /// assert!(matches!(r, Ok(1..=4)));\n     /// ```\n-    #[unstable(feature = \"vecdeque_binary_search\", issue = \"78021\")]\n+    #[stable(feature = \"vecdeque_binary_search\", since = \"1.54.0\")]\n     pub fn binary_search_by<'a, F>(&'a self, mut f: F) -> Result<usize, usize>\n     where\n         F: FnMut(&'a T) -> Ordering,\n@@ -2530,7 +2527,6 @@ impl<T> VecDeque<T> {\n     /// fourth could match any position in `[1, 4]`.\n     ///\n     /// ```\n-    /// #![feature(vecdeque_binary_search)]\n     /// use std::collections::VecDeque;\n     ///\n     /// let deque: VecDeque<_> = vec![(0, 0), (2, 1), (4, 1), (5, 1),\n@@ -2543,7 +2539,7 @@ impl<T> VecDeque<T> {\n     /// let r = deque.binary_search_by_key(&1, |&(a, b)| b);\n     /// assert!(matches!(r, Ok(1..=4)));\n     /// ```\n-    #[unstable(feature = \"vecdeque_binary_search\", issue = \"78021\")]\n+    #[stable(feature = \"vecdeque_binary_search\", since = \"1.54.0\")]\n     #[inline]\n     pub fn binary_search_by_key<'a, B, F>(&'a self, b: &B, mut f: F) -> Result<usize, usize>\n     where\n@@ -2574,7 +2570,6 @@ impl<T> VecDeque<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(vecdeque_binary_search)]\n     /// use std::collections::VecDeque;\n     ///\n     /// let deque: VecDeque<_> = vec![1, 2, 3, 3, 5, 6, 7].into();\n@@ -2584,7 +2579,7 @@ impl<T> VecDeque<T> {\n     /// assert!(deque.iter().take(i).all(|&x| x < 5));\n     /// assert!(deque.iter().skip(i).all(|&x| !(x < 5)));\n     /// ```\n-    #[unstable(feature = \"vecdeque_binary_search\", issue = \"78021\")]\n+    #[stable(feature = \"vecdeque_binary_search\", since = \"1.54.0\")]\n     pub fn partition_point<P>(&self, mut pred: P) -> usize\n     where\n         P: FnMut(&T) -> bool,"}, {"sha": "7b87090fb07138f18c17f990304dd15adf1db729", "filename": "library/alloc/src/collections/vec_deque/pair_slices.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fpair_slices.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fpair_slices.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fpair_slices.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -1,4 +1,3 @@\n-use core::array;\n use core::cmp::{self};\n use core::mem::replace;\n \n@@ -37,7 +36,7 @@ impl<'a, 'b, T> PairSlices<'a, 'b, T> {\n     }\n \n     pub fn remainder(self) -> impl Iterator<Item = &'b [T]> {\n-        array::IntoIter::new([self.b0, self.b1])\n+        IntoIterator::into_iter([self.b0, self.b1])\n     }\n }\n "}, {"sha": "a04e7c8a498daf7d6cda9dff39feee5a810d331d", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -59,7 +59,6 @@\n #![allow(unused_attributes)]\n #![stable(feature = \"alloc\", since = \"1.36.0\")]\n #![doc(\n-    html_root_url = \"https://doc.rust-lang.org/nightly/\",\n     html_playground_url = \"https://play.rust-lang.org/\",\n     issue_tracker_base_url = \"https://github.com/rust-lang/rust/issues/\",\n     test(no_crate_inject, attr(allow(unused_variables), deny(warnings)))\n@@ -144,6 +143,7 @@\n #![feature(associated_type_bounds)]\n #![feature(slice_group_by)]\n #![feature(decl_macro)]\n+#![feature(bindings_after_at)]\n // Allow testing this library\n \n #[cfg(test)]"}, {"sha": "93f5fe45cd6aa28de9313f4ca0da20410800a1b1", "filename": "library/alloc/src/string.rs", "status": "modified", "additions": 118, "deletions": 29, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Falloc%2Fsrc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Falloc%2Fsrc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fstring.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -48,7 +48,7 @@ use core::fmt;\n use core::hash;\n #[cfg(not(no_global_oom_handling))]\n use core::iter::FromIterator;\n-use core::iter::FusedIterator;\n+use core::iter::{from_fn, FusedIterator};\n #[cfg(not(no_global_oom_handling))]\n use core::ops::Add;\n #[cfg(not(no_global_oom_handling))]\n@@ -843,6 +843,42 @@ impl String {\n         self.vec.extend_from_slice(string.as_bytes())\n     }\n \n+    /// Copies elements from `src` range to the end of the string.\n+    ///\n+    /// ## Panics\n+    ///\n+    /// Panics if the starting point or end point do not lie on a [`char`]\n+    /// boundary, or if they're out of bounds.\n+    ///\n+    /// ## Examples\n+    ///\n+    /// ```\n+    /// #![feature(string_extend_from_within)]\n+    /// let mut string = String::from(\"abcde\");\n+    ///\n+    /// string.extend_from_within(2..);\n+    /// assert_eq!(string, \"abcdecde\");\n+    ///\n+    /// string.extend_from_within(..2);\n+    /// assert_eq!(string, \"abcdecdeab\");\n+    ///\n+    /// string.extend_from_within(4..8);\n+    /// assert_eq!(string, \"abcdecdeabecde\");\n+    /// ```\n+    #[cfg(not(no_global_oom_handling))]\n+    #[unstable(feature = \"string_extend_from_within\", issue = \"none\")]\n+    pub fn extend_from_within<R>(&mut self, src: R)\n+    where\n+        R: RangeBounds<usize>,\n+    {\n+        let src @ Range { start, end } = slice::range(src, ..self.len());\n+\n+        assert!(self.is_char_boundary(start));\n+        assert!(self.is_char_boundary(end));\n+\n+        self.vec.extend_from_within(src);\n+    }\n+\n     /// Returns this `String`'s capacity, in bytes.\n     ///\n     /// # Examples\n@@ -1254,32 +1290,49 @@ impl String {\n     {\n         use core::str::pattern::Searcher;\n \n-        let matches = {\n+        let rejections = {\n             let mut searcher = pat.into_searcher(self);\n-            let mut matches = Vec::new();\n-\n-            while let Some(m) = searcher.next_match() {\n-                matches.push(m);\n-            }\n-\n-            matches\n+            // Per Searcher::next:\n+            //\n+            // A Match result needs to contain the whole matched pattern,\n+            // however Reject results may be split up into arbitrary many\n+            // adjacent fragments. Both ranges may have zero length.\n+            //\n+            // In practice the implementation of Searcher::next_match tends to\n+            // be more efficient, so we use it here and do some work to invert\n+            // matches into rejections since that's what we want to copy below.\n+            let mut front = 0;\n+            let rejections: Vec<_> = from_fn(|| {\n+                let (start, end) = searcher.next_match()?;\n+                let prev_front = front;\n+                front = end;\n+                Some((prev_front, start))\n+            })\n+            .collect();\n+            rejections.into_iter().chain(core::iter::once((front, self.len())))\n         };\n \n-        let len = self.len();\n-        let mut shrunk_by = 0;\n+        let mut len = 0;\n+        let ptr = self.vec.as_mut_ptr();\n+\n+        for (start, end) in rejections {\n+            let count = end - start;\n+            if start != len {\n+                // SAFETY: per Searcher::next:\n+                //\n+                // The stream of Match and Reject values up to a Done will\n+                // contain index ranges that are adjacent, non-overlapping,\n+                // covering the whole haystack, and laying on utf8\n+                // boundaries.\n+                unsafe {\n+                    ptr::copy(ptr.add(start), ptr.add(len), count);\n+                }\n+            }\n+            len += count;\n+        }\n \n-        // SAFETY: start and end will be on utf8 byte boundaries per\n-        // the Searcher docs\n         unsafe {\n-            for (start, end) in matches {\n-                ptr::copy(\n-                    self.vec.as_mut_ptr().add(end - shrunk_by),\n-                    self.vec.as_mut_ptr().add(start - shrunk_by),\n-                    len - end,\n-                );\n-                shrunk_by += end - start;\n-            }\n-            self.vec.set_len(len - shrunk_by);\n+            self.vec.set_len(len);\n         }\n     }\n \n@@ -2438,6 +2491,9 @@ impl AsRef<[u8]> for String {\n #[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl From<&str> for String {\n+    /// Converts a `&str` into a [`String`].\n+    ///\n+    /// The result is allocated on the heap.\n     #[inline]\n     fn from(s: &str) -> String {\n         s.to_owned()\n@@ -2447,7 +2503,7 @@ impl From<&str> for String {\n #[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"from_mut_str_for_string\", since = \"1.44.0\")]\n impl From<&mut str> for String {\n-    /// Converts a `&mut str` into a `String`.\n+    /// Converts a `&mut str` into a [`String`].\n     ///\n     /// The result is allocated on the heap.\n     #[inline]\n@@ -2459,6 +2515,9 @@ impl From<&mut str> for String {\n #[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"from_ref_string\", since = \"1.35.0\")]\n impl From<&String> for String {\n+    /// Converts a `&String` into a [`String`].\n+    ///\n+    /// This clones `s` and returns the clone.\n     #[inline]\n     fn from(s: &String) -> String {\n         s.clone()\n@@ -2469,7 +2528,7 @@ impl From<&String> for String {\n #[cfg(not(test))]\n #[stable(feature = \"string_from_box\", since = \"1.18.0\")]\n impl From<Box<str>> for String {\n-    /// Converts the given boxed `str` slice to a `String`.\n+    /// Converts the given boxed `str` slice to a [`String`].\n     /// It is notable that the `str` slice is owned.\n     ///\n     /// # Examples\n@@ -2491,7 +2550,7 @@ impl From<Box<str>> for String {\n #[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"box_from_str\", since = \"1.20.0\")]\n impl From<String> for Box<str> {\n-    /// Converts the given `String` to a boxed `str` slice that is owned.\n+    /// Converts the given [`String`] to a boxed `str` slice that is owned.\n     ///\n     /// # Examples\n     ///\n@@ -2512,6 +2571,22 @@ impl From<String> for Box<str> {\n #[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"string_from_cow_str\", since = \"1.14.0\")]\n impl<'a> From<Cow<'a, str>> for String {\n+    /// Converts a clone-on-write string to an owned\n+    /// instance of [`String`].\n+    ///\n+    /// This extracts the owned string,\n+    /// clones the string if it is not already owned.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// # use std::borrow::Cow;\n+    /// // If the string is not owned...\n+    /// let cow: Cow<str> = Cow::Borrowed(\"eggplant\");\n+    /// // It will allocate on the heap and copy the string.\n+    /// let owned: String = String::from(cow);\n+    /// assert_eq!(&owned[..], \"eggplant\");\n+    /// ```\n     fn from(s: Cow<'a, str>) -> String {\n         s.into_owned()\n     }\n@@ -2520,7 +2595,7 @@ impl<'a> From<Cow<'a, str>> for String {\n #[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> From<&'a str> for Cow<'a, str> {\n-    /// Converts a string slice into a Borrowed variant.\n+    /// Converts a string slice into a [`Borrowed`] variant.\n     /// No heap allocation is performed, and the string\n     /// is not copied.\n     ///\n@@ -2530,6 +2605,8 @@ impl<'a> From<&'a str> for Cow<'a, str> {\n     /// # use std::borrow::Cow;\n     /// assert_eq!(Cow::from(\"eggplant\"), Cow::Borrowed(\"eggplant\"));\n     /// ```\n+    ///\n+    /// [`Borrowed`]: crate::borrow::Cow::Borrowed\n     #[inline]\n     fn from(s: &'a str) -> Cow<'a, str> {\n         Cow::Borrowed(s)\n@@ -2539,7 +2616,7 @@ impl<'a> From<&'a str> for Cow<'a, str> {\n #[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> From<String> for Cow<'a, str> {\n-    /// Converts a String into an Owned variant.\n+    /// Converts a [`String`] into an [`Owned`] variant.\n     /// No heap allocation is performed, and the string\n     /// is not copied.\n     ///\n@@ -2551,6 +2628,8 @@ impl<'a> From<String> for Cow<'a, str> {\n     /// let s2 = \"eggplant\".to_string();\n     /// assert_eq!(Cow::from(s), Cow::<'static, str>::Owned(s2));\n     /// ```\n+    ///\n+    /// [`Owned`]: crate::borrow::Cow::Owned\n     #[inline]\n     fn from(s: String) -> Cow<'a, str> {\n         Cow::Owned(s)\n@@ -2560,7 +2639,7 @@ impl<'a> From<String> for Cow<'a, str> {\n #[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"cow_from_string_ref\", since = \"1.28.0\")]\n impl<'a> From<&'a String> for Cow<'a, str> {\n-    /// Converts a String reference into a Borrowed variant.\n+    /// Converts a [`String`] reference into a [`Borrowed`] variant.\n     /// No heap allocation is performed, and the string\n     /// is not copied.\n     ///\n@@ -2571,6 +2650,8 @@ impl<'a> From<&'a String> for Cow<'a, str> {\n     /// let s = \"eggplant\".to_string();\n     /// assert_eq!(Cow::from(&s), Cow::Borrowed(\"eggplant\"));\n     /// ```\n+    ///\n+    /// [`Borrowed`]: crate::borrow::Cow::Borrowed\n     #[inline]\n     fn from(s: &'a String) -> Cow<'a, str> {\n         Cow::Borrowed(s.as_str())\n@@ -2603,7 +2684,7 @@ impl<'a> FromIterator<String> for Cow<'a, str> {\n \n #[stable(feature = \"from_string_for_vec_u8\", since = \"1.14.0\")]\n impl From<String> for Vec<u8> {\n-    /// Converts the given `String` to a vector `Vec` that holds values of type `u8`.\n+    /// Converts the given [`String`] to a vector [`Vec`] that holds values of type [`u8`].\n     ///\n     /// # Examples\n     ///\n@@ -2749,6 +2830,14 @@ impl FusedIterator for Drain<'_> {}\n #[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"from_char_for_string\", since = \"1.46.0\")]\n impl From<char> for String {\n+    /// Allocates an owned [`String`] from a single character.\n+    ///\n+    /// # Example\n+    /// ```rust\n+    /// let c: char = 'a';\n+    /// let s: String = String::from(c);\n+    /// assert_eq!(\"a\", &s[..]);\n+    /// ```\n     #[inline]\n     fn from(c: char) -> Self {\n         c.to_string()"}, {"sha": "64943a273c9a591b9c1fb84da7de15a81c478c3d", "filename": "library/alloc/src/vec/cow.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Falloc%2Fsrc%2Fvec%2Fcow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Falloc%2Fsrc%2Fvec%2Fcow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fcow.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -5,20 +5,38 @@ use super::Vec;\n \n #[stable(feature = \"cow_from_vec\", since = \"1.8.0\")]\n impl<'a, T: Clone> From<&'a [T]> for Cow<'a, [T]> {\n+    /// Creates a [`Borrowed`] variant of [`Cow`]\n+    /// from a slice.\n+    ///\n+    /// This conversion does not allocate or clone the data.\n+    ///\n+    /// [`Borrowed`]: crate::borrow::Cow::Borrowed\n     fn from(s: &'a [T]) -> Cow<'a, [T]> {\n         Cow::Borrowed(s)\n     }\n }\n \n #[stable(feature = \"cow_from_vec\", since = \"1.8.0\")]\n impl<'a, T: Clone> From<Vec<T>> for Cow<'a, [T]> {\n+    /// Creates an [`Owned`] variant of [`Cow`]\n+    /// from an owned instance of [`Vec`].\n+    ///\n+    /// This conversion does not allocate or clone the data.\n+    ///\n+    /// [`Owned`]: crate::borrow::Cow::Owned\n     fn from(v: Vec<T>) -> Cow<'a, [T]> {\n         Cow::Owned(v)\n     }\n }\n \n #[stable(feature = \"cow_from_vec_ref\", since = \"1.28.0\")]\n impl<'a, T: Clone> From<&'a Vec<T>> for Cow<'a, [T]> {\n+    /// Creates a [`Borrowed`] variant of [`Cow`]\n+    /// from a reference to [`Vec`].\n+    ///\n+    /// This conversion does not allocate or clone the data.\n+    ///\n+    /// [`Borrowed`]: crate::borrow::Cow::Borrowed\n     fn from(v: &'a Vec<T>) -> Cow<'a, [T]> {\n         Cow::Borrowed(v.as_slice())\n     }"}, {"sha": "0efc4893c3c42847a696197a1a223687cd9f0741", "filename": "library/alloc/src/vec/is_zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Falloc%2Fsrc%2Fvec%2Fis_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Falloc%2Fsrc%2Fvec%2Fis_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fis_zero.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -73,7 +73,7 @@ unsafe impl<T: ?Sized> IsZero for Option<Box<T>> {\n // `Option<num::NonZeroU32>` and similar have a representation guarantee that\n // they're the same size as the corresponding `u32` type, as well as a guarantee\n // that transmuting between `NonZeroU32` and `Option<num::NonZeroU32>` works.\n-// While the documentation officially makes in UB to transmute from `None`,\n+// While the documentation officially makes it UB to transmute from `None`,\n // we're the standard library so we can make extra inferences, and we know that\n // the only niche available to represent `None` is the one that's all zeros.\n "}, {"sha": "4a1d564e2ab879547f8036133d7c0dc296c34c70", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -921,7 +921,7 @@ impl<T, A: Allocator> Vec<T, A> {\n     ///\n     /// ```\n     /// let mut vec = Vec::with_capacity(10);\n-    /// vec.extend([1, 2, 3].iter().cloned());\n+    /// vec.extend([1, 2, 3]);\n     /// assert_eq!(vec.capacity(), 10);\n     /// vec.shrink_to_fit();\n     /// assert!(vec.capacity() >= 3);\n@@ -950,7 +950,7 @@ impl<T, A: Allocator> Vec<T, A> {\n     /// ```\n     /// #![feature(shrink_to)]\n     /// let mut vec = Vec::with_capacity(10);\n-    /// vec.extend([1, 2, 3].iter().cloned());\n+    /// vec.extend([1, 2, 3]);\n     /// assert_eq!(vec.capacity(), 10);\n     /// vec.shrink_to(4);\n     /// assert!(vec.capacity() >= 4);\n@@ -984,7 +984,7 @@ impl<T, A: Allocator> Vec<T, A> {\n     ///\n     /// ```\n     /// let mut vec = Vec::with_capacity(10);\n-    /// vec.extend([1, 2, 3].iter().cloned());\n+    /// vec.extend([1, 2, 3]);\n     ///\n     /// assert_eq!(vec.capacity(), 10);\n     /// let slice = vec.into_boxed_slice();\n@@ -2586,7 +2586,7 @@ impl<T, A: Allocator> Vec<T, A> {\n     /// ```\n     /// let mut v = vec![1, 2, 3];\n     /// let new = [7, 8];\n-    /// let u: Vec<_> = v.splice(..2, new.iter().cloned()).collect();\n+    /// let u: Vec<_> = v.splice(..2, new).collect();\n     /// assert_eq!(v, &[7, 8, 3]);\n     /// assert_eq!(u, &[1, 2]);\n     /// ```"}, {"sha": "efa6868473e49844bb8b4fabe299f840f5f19ad3", "filename": "library/alloc/src/vec/spec_from_iter.rs", "status": "modified", "additions": 1, "deletions": 34, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Falloc%2Fsrc%2Fvec%2Fspec_from_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Falloc%2Fsrc%2Fvec%2Fspec_from_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fspec_from_iter.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -1,6 +1,5 @@\n use core::mem::ManuallyDrop;\n use core::ptr::{self};\n-use core::slice::{self};\n \n use super::{IntoIter, SpecExtend, SpecFromIterNested, Vec};\n \n@@ -19,9 +18,7 @@ use super::{IntoIter, SpecExtend, SpecFromIterNested, Vec};\n /// |where I:                      |  |  |where I:             |\n /// |  Iterator (default)----------+  |  |  Iterator (default) |\n /// |  vec::IntoIter               |  |  |  TrustedLen         |\n-/// |  SourceIterMarker---fallback-+  |  |                     |\n-/// |  slice::Iter                    |  |                     |\n-/// |  Iterator<Item = &Clone>        |  +---------------------+\n+/// |  SourceIterMarker---fallback-+  |  +---------------------+\n /// +---------------------------------+\n /// ```\n pub(super) trait SpecFromIter<T, I> {\n@@ -65,33 +62,3 @@ impl<T> SpecFromIter<T, IntoIter<T>> for Vec<T> {\n         vec\n     }\n }\n-\n-impl<'a, T: 'a, I> SpecFromIter<&'a T, I> for Vec<T>\n-where\n-    I: Iterator<Item = &'a T>,\n-    T: Clone,\n-{\n-    default fn from_iter(iterator: I) -> Self {\n-        SpecFromIter::from_iter(iterator.cloned())\n-    }\n-}\n-\n-// This utilizes `iterator.as_slice().to_vec()` since spec_extend\n-// must take more steps to reason about the final capacity + length\n-// and thus do more work. `to_vec()` directly allocates the correct amount\n-// and fills it exactly.\n-impl<'a, T: 'a + Clone> SpecFromIter<&'a T, slice::Iter<'a, T>> for Vec<T> {\n-    #[cfg(not(test))]\n-    fn from_iter(iterator: slice::Iter<'a, T>) -> Self {\n-        iterator.as_slice().to_vec()\n-    }\n-\n-    // HACK(japaric): with cfg(test) the inherent `[T]::to_vec` method, which is\n-    // required for this method definition, is not available. Instead use the\n-    // `slice::to_vec`  function which is only available with cfg(test)\n-    // NB see the slice::hack module in slice.rs for more information\n-    #[cfg(test)]\n-    fn from_iter(iterator: slice::Iter<'a, T>) -> Self {\n-        crate::slice::to_vec(iterator.as_slice(), crate::alloc::Global)\n-    }\n-}"}, {"sha": "bad765c7f51fab944b3de89a3a956de2dd42f158", "filename": "library/alloc/src/vec/splice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Falloc%2Fsrc%2Fvec%2Fsplice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Falloc%2Fsrc%2Fvec%2Fsplice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fsplice.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -14,7 +14,7 @@ use super::{Drain, Vec};\n /// ```\n /// let mut v = vec![0, 1, 2];\n /// let new = [7, 8];\n-/// let iter: std::vec::Splice<_> = v.splice(1.., new.iter().cloned());\n+/// let iter: std::vec::Splice<_> = v.splice(1.., new);\n /// ```\n #[derive(Debug)]\n #[stable(feature = \"vec_splice\", since = \"1.21.0\")]"}, {"sha": "3143afa269dde08ce98aebb149ec6bd6504c4c2e", "filename": "library/alloc/tests/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Falloc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Falloc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Flib.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -17,7 +17,6 @@\n #![feature(binary_heap_as_slice)]\n #![feature(inplace_iteration)]\n #![feature(iter_map_while)]\n-#![feature(vecdeque_binary_search)]\n #![feature(slice_group_by)]\n #![feature(slice_partition_dedup)]\n #![feature(vec_spare_capacity)]"}, {"sha": "c203cdafecb03dd27be6f502965adffb715b6491", "filename": "library/alloc/tests/vec.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Falloc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Falloc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fvec.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -793,7 +793,7 @@ fn test_drain_leak() {\n fn test_splice() {\n     let mut v = vec![1, 2, 3, 4, 5];\n     let a = [10, 11, 12];\n-    v.splice(2..4, a.iter().cloned());\n+    v.splice(2..4, a);\n     assert_eq!(v, &[1, 2, 10, 11, 12, 5]);\n     v.splice(1..3, Some(20));\n     assert_eq!(v, &[1, 20, 11, 12, 5]);\n@@ -803,7 +803,7 @@ fn test_splice() {\n fn test_splice_inclusive_range() {\n     let mut v = vec![1, 2, 3, 4, 5];\n     let a = [10, 11, 12];\n-    let t1: Vec<_> = v.splice(2..=3, a.iter().cloned()).collect();\n+    let t1: Vec<_> = v.splice(2..=3, a).collect();\n     assert_eq!(v, &[1, 2, 10, 11, 12, 5]);\n     assert_eq!(t1, &[3, 4]);\n     let t2: Vec<_> = v.splice(1..=2, Some(20)).collect();\n@@ -816,15 +816,15 @@ fn test_splice_inclusive_range() {\n fn test_splice_out_of_bounds() {\n     let mut v = vec![1, 2, 3, 4, 5];\n     let a = [10, 11, 12];\n-    v.splice(5..6, a.iter().cloned());\n+    v.splice(5..6, a);\n }\n \n #[test]\n #[should_panic]\n fn test_splice_inclusive_out_of_bounds() {\n     let mut v = vec![1, 2, 3, 4, 5];\n     let a = [10, 11, 12];\n-    v.splice(5..=5, a.iter().cloned());\n+    v.splice(5..=5, a);\n }\n \n #[test]\n@@ -848,7 +848,7 @@ fn test_splice_unbounded() {\n fn test_splice_forget() {\n     let mut v = vec![1, 2, 3, 4, 5];\n     let a = [10, 11, 12];\n-    std::mem::forget(v.splice(2..4, a.iter().cloned()));\n+    std::mem::forget(v.splice(2..4, a));\n     assert_eq!(v, &[1, 2]);\n }\n "}, {"sha": "37af3557fdd51ce792459ec680f32019413bbf03", "filename": "library/core/src/array/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fmod.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -416,7 +416,7 @@ impl<T, const N: usize> [T; N] {\n     {\n         // SAFETY: we know for certain that this iterator will yield exactly `N`\n         // items.\n-        unsafe { collect_into_array_unchecked(&mut IntoIter::new(self).map(f)) }\n+        unsafe { collect_into_array_unchecked(&mut IntoIterator::into_iter(self).map(f)) }\n     }\n \n     /// 'Zips up' two arrays into a single array of pairs.\n@@ -437,7 +437,7 @@ impl<T, const N: usize> [T; N] {\n     /// ```\n     #[unstable(feature = \"array_zip\", issue = \"80094\")]\n     pub fn zip<U>(self, rhs: [U; N]) -> [(T, U); N] {\n-        let mut iter = IntoIter::new(self).zip(IntoIter::new(rhs));\n+        let mut iter = IntoIterator::into_iter(self).zip(rhs);\n \n         // SAFETY: we know for certain that this iterator will yield exactly `N`\n         // items."}, {"sha": "80d0890551fd2f34e85caef419ca3982cd18c379", "filename": "library/core/src/char/methods.rs", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Fcore%2Fsrc%2Fchar%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Fcore%2Fsrc%2Fchar%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fchar%2Fmethods.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -1,6 +1,5 @@\n //! impl char {}\n \n-use crate::intrinsics::likely;\n use crate::slice;\n use crate::str::from_utf8_unchecked_mut;\n use crate::unicode::printable::is_printable;\n@@ -58,7 +57,7 @@ impl char {\n     /// ];\n     ///\n     /// assert_eq!(\n-    ///     decode_utf16(v.iter().cloned())\n+    ///     decode_utf16(v)\n     ///         .map(|r| r.map_err(|e| e.unpaired_surrogate()))\n     ///         .collect::<Vec<_>>(),\n     ///     vec![\n@@ -82,7 +81,7 @@ impl char {\n     /// ];\n     ///\n     /// assert_eq!(\n-    ///     decode_utf16(v.iter().cloned())\n+    ///     decode_utf16(v)\n     ///        .map(|r| r.unwrap_or(REPLACEMENT_CHARACTER))\n     ///        .collect::<String>(),\n     ///     \"\ud834\udd1emus\ufffdic\ufffd\"\n@@ -332,21 +331,16 @@ impl char {\n     #[inline]\n     pub fn to_digit(self, radix: u32) -> Option<u32> {\n         assert!(radix <= 36, \"to_digit: radix is too high (maximum 36)\");\n-        // the code is split up here to improve execution speed for cases where\n-        // the `radix` is constant and 10 or smaller\n-        let val = if likely(radix <= 10) {\n-            // If not a digit, a number greater than radix will be created.\n-            (self as u32).wrapping_sub('0' as u32)\n-        } else {\n-            match self {\n-                '0'..='9' => self as u32 - '0' as u32,\n-                'a'..='z' => self as u32 - 'a' as u32 + 10,\n-                'A'..='Z' => self as u32 - 'A' as u32 + 10,\n-                _ => return None,\n+        // If not a digit, a number greater than radix will be created.\n+        let mut digit = (self as u32).wrapping_sub('0' as u32);\n+        if radix > 10 {\n+            if digit < 10 {\n+                return Some(digit);\n             }\n-        };\n-\n-        if val < radix { Some(val) } else { None }\n+            // Force the 6th bit to be set to ensure ascii is lower case.\n+            digit = (self as u32 | 0b10_0000).wrapping_sub('a' as u32).saturating_add(10);\n+        }\n+        (digit < radix).then_some(digit)\n     }\n \n     /// Returns an iterator that yields the hexadecimal Unicode escape of a"}, {"sha": "70ab27cbfac57172d489d784cd92268920195faa", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 186, "deletions": 151, "changes": 337, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -1742,157 +1742,6 @@ extern \"rust-intrinsic\" {\n     /// Allocate at compile time. Should not be called at runtime.\n     #[rustc_const_unstable(feature = \"const_heap\", issue = \"79597\")]\n     pub fn const_allocate(size: usize, align: usize) -> *mut u8;\n-\n-    /// Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n-    /// and destination must *not* overlap.\n-    ///\n-    /// For regions of memory which might overlap, use [`copy`] instead.\n-    ///\n-    /// `copy_nonoverlapping` is semantically equivalent to C's [`memcpy`], but\n-    /// with the argument order swapped.\n-    ///\n-    /// [`memcpy`]: https://en.cppreference.com/w/c/string/byte/memcpy\n-    ///\n-    /// # Safety\n-    ///\n-    /// Behavior is undefined if any of the following conditions are violated:\n-    ///\n-    /// * `src` must be [valid] for reads of `count * size_of::<T>()` bytes.\n-    ///\n-    /// * `dst` must be [valid] for writes of `count * size_of::<T>()` bytes.\n-    ///\n-    /// * Both `src` and `dst` must be properly aligned.\n-    ///\n-    /// * The region of memory beginning at `src` with a size of `count *\n-    ///   size_of::<T>()` bytes must *not* overlap with the region of memory\n-    ///   beginning at `dst` with the same size.\n-    ///\n-    /// Like [`read`], `copy_nonoverlapping` creates a bitwise copy of `T`, regardless of\n-    /// whether `T` is [`Copy`]. If `T` is not [`Copy`], using *both* the values\n-    /// in the region beginning at `*src` and the region beginning at `*dst` can\n-    /// [violate memory safety][read-ownership].\n-    ///\n-    /// Note that even if the effectively copied size (`count * size_of::<T>()`) is\n-    /// `0`, the pointers must be non-null and properly aligned.\n-    ///\n-    /// [`read`]: crate::ptr::read\n-    /// [read-ownership]: crate::ptr::read#ownership-of-the-returned-value\n-    /// [valid]: crate::ptr#safety\n-    ///\n-    /// # Examples\n-    ///\n-    /// Manually implement [`Vec::append`]:\n-    ///\n-    /// ```\n-    /// use std::ptr;\n-    ///\n-    /// /// Moves all the elements of `src` into `dst`, leaving `src` empty.\n-    /// fn append<T>(dst: &mut Vec<T>, src: &mut Vec<T>) {\n-    ///     let src_len = src.len();\n-    ///     let dst_len = dst.len();\n-    ///\n-    ///     // Ensure that `dst` has enough capacity to hold all of `src`.\n-    ///     dst.reserve(src_len);\n-    ///\n-    ///     unsafe {\n-    ///         // The call to offset is always safe because `Vec` will never\n-    ///         // allocate more than `isize::MAX` bytes.\n-    ///         let dst_ptr = dst.as_mut_ptr().offset(dst_len as isize);\n-    ///         let src_ptr = src.as_ptr();\n-    ///\n-    ///         // Truncate `src` without dropping its contents. We do this first,\n-    ///         // to avoid problems in case something further down panics.\n-    ///         src.set_len(0);\n-    ///\n-    ///         // The two regions cannot overlap because mutable references do\n-    ///         // not alias, and two different vectors cannot own the same\n-    ///         // memory.\n-    ///         ptr::copy_nonoverlapping(src_ptr, dst_ptr, src_len);\n-    ///\n-    ///         // Notify `dst` that it now holds the contents of `src`.\n-    ///         dst.set_len(dst_len + src_len);\n-    ///     }\n-    /// }\n-    ///\n-    /// let mut a = vec!['r'];\n-    /// let mut b = vec!['u', 's', 't'];\n-    ///\n-    /// append(&mut a, &mut b);\n-    ///\n-    /// assert_eq!(a, &['r', 'u', 's', 't']);\n-    /// assert!(b.is_empty());\n-    /// ```\n-    ///\n-    /// [`Vec::append`]: ../../std/vec/struct.Vec.html#method.append\n-    #[doc(alias = \"memcpy\")]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_intrinsic_copy\", issue = \"80697\")]\n-    pub fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize);\n-\n-    /// Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n-    /// and destination may overlap.\n-    ///\n-    /// If the source and destination will *never* overlap,\n-    /// [`copy_nonoverlapping`] can be used instead.\n-    ///\n-    /// `copy` is semantically equivalent to C's [`memmove`], but with the argument\n-    /// order swapped. Copying takes place as if the bytes were copied from `src`\n-    /// to a temporary array and then copied from the array to `dst`.\n-    ///\n-    /// [`memmove`]: https://en.cppreference.com/w/c/string/byte/memmove\n-    ///\n-    /// # Safety\n-    ///\n-    /// Behavior is undefined if any of the following conditions are violated:\n-    ///\n-    /// * `src` must be [valid] for reads of `count * size_of::<T>()` bytes.\n-    ///\n-    /// * `dst` must be [valid] for writes of `count * size_of::<T>()` bytes.\n-    ///\n-    /// * Both `src` and `dst` must be properly aligned.\n-    ///\n-    /// Like [`read`], `copy` creates a bitwise copy of `T`, regardless of\n-    /// whether `T` is [`Copy`]. If `T` is not [`Copy`], using both the values\n-    /// in the region beginning at `*src` and the region beginning at `*dst` can\n-    /// [violate memory safety][read-ownership].\n-    ///\n-    /// Note that even if the effectively copied size (`count * size_of::<T>()`) is\n-    /// `0`, the pointers must be non-null and properly aligned.\n-    ///\n-    /// [`read`]: crate::ptr::read\n-    /// [read-ownership]: crate::ptr::read#ownership-of-the-returned-value\n-    /// [valid]: crate::ptr#safety\n-    ///\n-    /// # Examples\n-    ///\n-    /// Efficiently create a Rust vector from an unsafe buffer:\n-    ///\n-    /// ```\n-    /// use std::ptr;\n-    ///\n-    /// /// # Safety\n-    /// ///\n-    /// /// * `ptr` must be correctly aligned for its type and non-zero.\n-    /// /// * `ptr` must be valid for reads of `elts` contiguous elements of type `T`.\n-    /// /// * Those elements must not be used after calling this function unless `T: Copy`.\n-    /// # #[allow(dead_code)]\n-    /// unsafe fn from_buf_raw<T>(ptr: *const T, elts: usize) -> Vec<T> {\n-    ///     let mut dst = Vec::with_capacity(elts);\n-    ///\n-    ///     // SAFETY: Our precondition ensures the source is aligned and valid,\n-    ///     // and `Vec::with_capacity` ensures that we have usable space to write them.\n-    ///     ptr::copy(ptr, dst.as_mut_ptr(), elts);\n-    ///\n-    ///     // SAFETY: We created it with this much capacity earlier,\n-    ///     // and the previous `copy` has initialized these elements.\n-    ///     dst.set_len(elts);\n-    ///     dst\n-    /// }\n-    /// ```\n-    #[doc(alias = \"memmove\")]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_intrinsic_copy\", issue = \"80697\")]\n-    pub fn copy<T>(src: *const T, dst: *mut T, count: usize);\n }\n \n // Some functions are defined here because they accidentally got made\n@@ -1906,6 +1755,192 @@ pub(crate) fn is_aligned_and_not_null<T>(ptr: *const T) -> bool {\n     !ptr.is_null() && ptr as usize % mem::align_of::<T>() == 0\n }\n \n+/// Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n+/// and destination must *not* overlap.\n+///\n+/// For regions of memory which might overlap, use [`copy`] instead.\n+///\n+/// `copy_nonoverlapping` is semantically equivalent to C's [`memcpy`], but\n+/// with the argument order swapped.\n+///\n+/// [`memcpy`]: https://en.cppreference.com/w/c/string/byte/memcpy\n+///\n+/// # Safety\n+///\n+/// Behavior is undefined if any of the following conditions are violated:\n+///\n+/// * `src` must be [valid] for reads of `count * size_of::<T>()` bytes.\n+///\n+/// * `dst` must be [valid] for writes of `count * size_of::<T>()` bytes.\n+///\n+/// * Both `src` and `dst` must be properly aligned.\n+///\n+/// * The region of memory beginning at `src` with a size of `count *\n+///   size_of::<T>()` bytes must *not* overlap with the region of memory\n+///   beginning at `dst` with the same size.\n+///\n+/// Like [`read`], `copy_nonoverlapping` creates a bitwise copy of `T`, regardless of\n+/// whether `T` is [`Copy`]. If `T` is not [`Copy`], using *both* the values\n+/// in the region beginning at `*src` and the region beginning at `*dst` can\n+/// [violate memory safety][read-ownership].\n+///\n+/// Note that even if the effectively copied size (`count * size_of::<T>()`) is\n+/// `0`, the pointers must be non-null and properly aligned.\n+///\n+/// [`read`]: crate::ptr::read\n+/// [read-ownership]: crate::ptr::read#ownership-of-the-returned-value\n+/// [valid]: crate::ptr#safety\n+///\n+/// # Examples\n+///\n+/// Manually implement [`Vec::append`]:\n+///\n+/// ```\n+/// use std::ptr;\n+///\n+/// /// Moves all the elements of `src` into `dst`, leaving `src` empty.\n+/// fn append<T>(dst: &mut Vec<T>, src: &mut Vec<T>) {\n+///     let src_len = src.len();\n+///     let dst_len = dst.len();\n+///\n+///     // Ensure that `dst` has enough capacity to hold all of `src`.\n+///     dst.reserve(src_len);\n+///\n+///     unsafe {\n+///         // The call to offset is always safe because `Vec` will never\n+///         // allocate more than `isize::MAX` bytes.\n+///         let dst_ptr = dst.as_mut_ptr().offset(dst_len as isize);\n+///         let src_ptr = src.as_ptr();\n+///\n+///         // Truncate `src` without dropping its contents. We do this first,\n+///         // to avoid problems in case something further down panics.\n+///         src.set_len(0);\n+///\n+///         // The two regions cannot overlap because mutable references do\n+///         // not alias, and two different vectors cannot own the same\n+///         // memory.\n+///         ptr::copy_nonoverlapping(src_ptr, dst_ptr, src_len);\n+///\n+///         // Notify `dst` that it now holds the contents of `src`.\n+///         dst.set_len(dst_len + src_len);\n+///     }\n+/// }\n+///\n+/// let mut a = vec!['r'];\n+/// let mut b = vec!['u', 's', 't'];\n+///\n+/// append(&mut a, &mut b);\n+///\n+/// assert_eq!(a, &['r', 'u', 's', 't']);\n+/// assert!(b.is_empty());\n+/// ```\n+///\n+/// [`Vec::append`]: ../../std/vec/struct.Vec.html#method.append\n+#[doc(alias = \"memcpy\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_const_unstable(feature = \"const_intrinsic_copy\", issue = \"80697\")]\n+#[inline]\n+pub const unsafe fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize) {\n+    extern \"rust-intrinsic\" {\n+        #[rustc_const_unstable(feature = \"const_intrinsic_copy\", issue = \"80697\")]\n+        pub fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize);\n+    }\n+\n+    // FIXME: Perform these checks only at run time\n+    /*if cfg!(debug_assertions)\n+        && !(is_aligned_and_not_null(src)\n+            && is_aligned_and_not_null(dst)\n+            && is_nonoverlapping(src, dst, count))\n+    {\n+        // Not panicking to keep codegen impact smaller.\n+        abort();\n+    }*/\n+\n+    // SAFETY: the safety contract for `copy_nonoverlapping` must be\n+    // upheld by the caller.\n+    unsafe { copy_nonoverlapping(src, dst, count) }\n+}\n+\n+/// Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n+/// and destination may overlap.\n+///\n+/// If the source and destination will *never* overlap,\n+/// [`copy_nonoverlapping`] can be used instead.\n+///\n+/// `copy` is semantically equivalent to C's [`memmove`], but with the argument\n+/// order swapped. Copying takes place as if the bytes were copied from `src`\n+/// to a temporary array and then copied from the array to `dst`.\n+///\n+/// [`memmove`]: https://en.cppreference.com/w/c/string/byte/memmove\n+///\n+/// # Safety\n+///\n+/// Behavior is undefined if any of the following conditions are violated:\n+///\n+/// * `src` must be [valid] for reads of `count * size_of::<T>()` bytes.\n+///\n+/// * `dst` must be [valid] for writes of `count * size_of::<T>()` bytes.\n+///\n+/// * Both `src` and `dst` must be properly aligned.\n+///\n+/// Like [`read`], `copy` creates a bitwise copy of `T`, regardless of\n+/// whether `T` is [`Copy`]. If `T` is not [`Copy`], using both the values\n+/// in the region beginning at `*src` and the region beginning at `*dst` can\n+/// [violate memory safety][read-ownership].\n+///\n+/// Note that even if the effectively copied size (`count * size_of::<T>()`) is\n+/// `0`, the pointers must be non-null and properly aligned.\n+///\n+/// [`read`]: crate::ptr::read\n+/// [read-ownership]: crate::ptr::read#ownership-of-the-returned-value\n+/// [valid]: crate::ptr#safety\n+///\n+/// # Examples\n+///\n+/// Efficiently create a Rust vector from an unsafe buffer:\n+///\n+/// ```\n+/// use std::ptr;\n+///\n+/// /// # Safety\n+/// ///\n+/// /// * `ptr` must be correctly aligned for its type and non-zero.\n+/// /// * `ptr` must be valid for reads of `elts` contiguous elements of type `T`.\n+/// /// * Those elements must not be used after calling this function unless `T: Copy`.\n+/// # #[allow(dead_code)]\n+/// unsafe fn from_buf_raw<T>(ptr: *const T, elts: usize) -> Vec<T> {\n+///     let mut dst = Vec::with_capacity(elts);\n+///\n+///     // SAFETY: Our precondition ensures the source is aligned and valid,\n+///     // and `Vec::with_capacity` ensures that we have usable space to write them.\n+///     ptr::copy(ptr, dst.as_mut_ptr(), elts);\n+///\n+///     // SAFETY: We created it with this much capacity earlier,\n+///     // and the previous `copy` has initialized these elements.\n+///     dst.set_len(elts);\n+///     dst\n+/// }\n+/// ```\n+#[doc(alias = \"memmove\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_const_unstable(feature = \"const_intrinsic_copy\", issue = \"80697\")]\n+#[inline]\n+pub const unsafe fn copy<T>(src: *const T, dst: *mut T, count: usize) {\n+    extern \"rust-intrinsic\" {\n+        #[rustc_const_unstable(feature = \"const_intrinsic_copy\", issue = \"80697\")]\n+        fn copy<T>(src: *const T, dst: *mut T, count: usize);\n+    }\n+\n+    // FIXME: Perform these checks only at run time\n+    /*if cfg!(debug_assertions) && !(is_aligned_and_not_null(src) && is_aligned_and_not_null(dst)) {\n+        // Not panicking to keep codegen impact smaller.\n+        abort();\n+    }*/\n+\n+    // SAFETY: the safety contract for `copy` must be upheld by the caller.\n+    unsafe { copy(src, dst, count) }\n+}\n+\n /// Sets `count * size_of::<T>()` bytes of memory starting at `dst` to\n /// `val`.\n ///"}, {"sha": "beda8c32c6bdc70473945bd70b6b73ee458c4a39", "filename": "library/core/src/iter/adapters/take.rs", "status": "modified", "additions": 1, "deletions": 22, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ftake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ftake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ftake.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -1,8 +1,5 @@\n use crate::cmp;\n-use crate::iter::{\n-    adapters::zip::try_get_unchecked, adapters::SourceIter, FusedIterator, InPlaceIterable,\n-    TrustedLen, TrustedRandomAccess,\n-};\n+use crate::iter::{adapters::SourceIter, FusedIterator, InPlaceIterable, TrustedLen};\n use crate::ops::{ControlFlow, Try};\n \n /// An iterator that only iterates over the first `n` iterations of `iter`.\n@@ -114,15 +111,6 @@ where\n \n         self.try_fold(init, ok(fold)).unwrap()\n     }\n-\n-    unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> <I as Iterator>::Item\n-    where\n-        Self: TrustedRandomAccess,\n-    {\n-        // SAFETY: the caller must uphold the contract for\n-        // `Iterator::__iterator_get_unchecked`.\n-        unsafe { try_get_unchecked(&mut self.iter, idx) }\n-    }\n }\n \n #[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n@@ -219,12 +207,3 @@ impl<I> FusedIterator for Take<I> where I: FusedIterator {}\n \n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n unsafe impl<I: TrustedLen> TrustedLen for Take<I> {}\n-\n-#[doc(hidden)]\n-#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n-unsafe impl<I> TrustedRandomAccess for Take<I>\n-where\n-    I: TrustedRandomAccess,\n-{\n-    const MAY_HAVE_SIDE_EFFECT: bool = I::MAY_HAVE_SIDE_EFFECT;\n-}"}, {"sha": "c95324c80ba61e14243b3fc59e8ed6c5fc2ca605", "filename": "library/core/src/iter/adapters/zip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fzip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fzip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fzip.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -434,7 +434,7 @@ impl<A: Debug + TrustedRandomAccess, B: Debug + TrustedRandomAccess> ZipFmt<A, B\n ///    called on `self`:\n ///     * `std::clone::Clone::clone()`\n ///     * `std::iter::Iterator::size_hint()`\n-///     * `std::iter::Iterator::next_back()`\n+///     * `std::iter::DoubleEndedIterator::next_back()`\n ///     * `std::iter::Iterator::__iterator_get_unchecked()`\n ///     * `std::iter::TrustedRandomAccess::size()`\n ///"}, {"sha": "a7e914526f408c541c87325ea05ce8535544efee", "filename": "library/core/src/iter/traits/iterator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -138,7 +138,7 @@ pub trait Iterator {\n     /// A more complex example:\n     ///\n     /// ```\n-    /// // The even numbers from zero to ten.\n+    /// // The even numbers in the range of zero to nine.\n     /// let iter = (0..10).filter(|x| x % 2 == 0);\n     ///\n     /// // We might iterate from zero to ten times. Knowing that it's five"}, {"sha": "949ef27f018e4c3b89afd439cd0cba43e8e8601d", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -51,7 +51,6 @@\n #![cfg(not(test))]\n #![stable(feature = \"core\", since = \"1.6.0\")]\n #![doc(\n-    html_root_url = \"https://doc.rust-lang.org/nightly/\",\n     html_playground_url = \"https://play.rust-lang.org/\",\n     issue_tracker_base_url = \"https://github.com/rust-lang/rust/issues/\",\n     test(no_crate_inject, attr(deny(warnings))),\n@@ -66,6 +65,7 @@\n #![feature(allow_internal_unstable)]\n #![feature(arbitrary_self_types)]\n #![feature(asm)]\n+#![feature(bool_to_option)]\n #![feature(cfg_target_has_atomic)]\n #![feature(const_heap)]\n #![feature(const_alloc_layout)]\n@@ -160,13 +160,13 @@\n #![feature(const_fn_transmute)]\n #![feature(abi_unadjusted)]\n #![feature(adx_target_feature)]\n-#![feature(external_doc)]\n #![feature(associated_type_bounds)]\n #![feature(const_caller_location)]\n #![feature(slice_ptr_get)]\n #![feature(no_niche)] // rust-lang/rust#68303\n #![feature(no_coverage)] // rust-lang/rust#84605\n #![feature(int_error_matching)]\n+#![cfg_attr(bootstrap, feature(target_feature_11))]\n #![deny(unsafe_op_in_unsafe_fn)]\n #![deny(or_patterns_back_compat)]\n "}, {"sha": "c6750c52d16c8616508247fc0a5f14cd2f9eb5ce", "filename": "library/core/src/mem/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -682,8 +682,7 @@ pub unsafe fn uninitialized<T>() -> T {\n /// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_swap\", issue = \"83163\")]\n-pub const fn swap<T>(x: &mut T, y: &mut T) {\n+pub fn swap<T>(x: &mut T, y: &mut T) {\n     // SAFETY: the raw pointers have been created from safe mutable references satisfying all the\n     // constraints on `ptr::swap_nonoverlapping_one`\n     unsafe {\n@@ -813,8 +812,7 @@ pub fn take<T: Default>(dest: &mut T) -> T {\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[must_use = \"if you don't need the old value, you can just assign the new value directly\"]\n-#[rustc_const_unstable(feature = \"const_replace\", issue = \"83164\")]\n-pub const fn replace<T>(dest: &mut T, src: T) -> T {\n+pub fn replace<T>(dest: &mut T, src: T) -> T {\n     // SAFETY: We read from `dest` but directly write `src` into it afterwards,\n     // such that the old value is not duplicated. Nothing is dropped and\n     // nothing here can panic."}, {"sha": "c47a2e8b05c4bed0b75c2ffca61ba342d8073feb", "filename": "library/core/src/num/f32.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -727,8 +727,8 @@ impl f32 {\n     ///\n     /// This is currently identical to `transmute::<f32, u32>(self)` on all platforms.\n     ///\n-    /// See `from_bits` for some discussion of the portability of this operation\n-    /// (there are almost no issues).\n+    /// See [`from_bits`](Self::from_bits) for some discussion of the\n+    /// portability of this operation (there are almost no issues).\n     ///\n     /// Note that this function is distinct from `as` casting, which attempts to\n     /// preserve the *numeric* value, and not the bitwise value."}, {"sha": "cfcc08b9addeb9b26fa07152161ec8549b744b11", "filename": "library/core/src/num/f64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -741,8 +741,8 @@ impl f64 {\n     ///\n     /// This is currently identical to `transmute::<f64, u64>(self)` on all platforms.\n     ///\n-    /// See `from_bits` for some discussion of the portability of this operation\n-    /// (there are almost no issues).\n+    /// See [`from_bits`](Self::from_bits) for some discussion of the\n+    /// portability of this operation (there are almost no issues).\n     ///\n     /// Note that this function is distinct from `as` casting, which attempts to\n     /// preserve the *numeric* value, and not the bitwise value."}, {"sha": "dd9b9330aee2b5ed466c0e5e9f42323190eeedc2", "filename": "library/core/src/num/nonzero.rs", "status": "modified", "additions": 572, "deletions": 1, "changes": 573, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -42,7 +42,8 @@ macro_rules! nonzero_integers {\n             pub struct $Ty($Int);\n \n             impl $Ty {\n-                /// Creates a non-zero without checking the value.\n+                /// Creates a non-zero without checking whether the value is non-zero.\n+                /// This results in undefined behaviour if the value is zero.\n                 ///\n                 /// # Safety\n                 ///\n@@ -285,6 +286,576 @@ nonzero_integers_div! {\n     NonZeroUsize(usize);\n }\n \n+// A bunch of methods for unsigned nonzero types only.\n+macro_rules! nonzero_unsigned_operations {\n+    ( $( $Ty: ident($Int: ty); )+ ) => {\n+        $(\n+            impl $Ty {\n+                /// Add an unsigned integer to a non-zero value.\n+                /// Check for overflow and return [`None`] on overflow\n+                /// As a consequence, the result cannot wrap to zero.\n+                ///\n+                ///\n+                /// # Examples\n+                ///\n+                /// ```\n+                /// #![feature(nonzero_ops)]\n+                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n+                ///\n+                /// # fn main() { test().unwrap(); }\n+                /// # fn test() -> Option<()> {\n+                #[doc = concat!(\"let one = \", stringify!($Ty), \"::new(1)?;\")]\n+                #[doc = concat!(\"let two = \", stringify!($Ty), \"::new(2)?;\")]\n+                #[doc = concat!(\"let max = \", stringify!($Ty), \"::new(\",\n+                                stringify!($Int), \"::MAX)?;\")]\n+                ///\n+                /// assert_eq!(Some(two), one.checked_add(1));\n+                /// assert_eq!(None, max.checked_add(1));\n+                /// # Some(())\n+                /// # }\n+                /// ```\n+                #[unstable(feature = \"nonzero_ops\", issue = \"84186\")]\n+                #[inline]\n+                pub const fn checked_add(self, other: $Int) -> Option<$Ty> {\n+                    if let Some(result) = self.get().checked_add(other) {\n+                        // SAFETY: $Int::checked_add returns None on overflow\n+                        // so the result cannot be zero.\n+                        Some(unsafe { $Ty::new_unchecked(result) })\n+                    } else {\n+                        None\n+                    }\n+                }\n+\n+                /// Add an unsigned integer to a non-zero value.\n+                #[doc = concat!(\"Return [`\", stringify!($Int), \"::MAX`] on overflow.\")]\n+                ///\n+                /// # Examples\n+                ///\n+                /// ```\n+                /// #![feature(nonzero_ops)]\n+                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n+                ///\n+                /// # fn main() { test().unwrap(); }\n+                /// # fn test() -> Option<()> {\n+                #[doc = concat!(\"let one = \", stringify!($Ty), \"::new(1)?;\")]\n+                #[doc = concat!(\"let two = \", stringify!($Ty), \"::new(2)?;\")]\n+                #[doc = concat!(\"let max = \", stringify!($Ty), \"::new(\",\n+                                stringify!($Int), \"::MAX)?;\")]\n+                ///\n+                /// assert_eq!(two, one.saturating_add(1));\n+                /// assert_eq!(max, max.saturating_add(1));\n+                /// # Some(())\n+                /// # }\n+                /// ```\n+                #[unstable(feature = \"nonzero_ops\", issue = \"84186\")]\n+                #[inline]\n+                pub const fn saturating_add(self, other: $Int) -> $Ty {\n+                    // SAFETY: $Int::saturating_add returns $Int::MAX on overflow\n+                    // so the result cannot be zero.\n+                    unsafe { $Ty::new_unchecked(self.get().saturating_add(other)) }\n+                }\n+\n+                /// Add an unsigned integer to a non-zero value,\n+                /// assuming overflow cannot occur.\n+                /// Overflow is unchecked, and it is undefined behaviour to overflow\n+                /// *even if the result would wrap to a non-zero value*.\n+                /// The behaviour is undefined as soon as\n+                #[doc = concat!(\"`self + rhs > \", stringify!($Int), \"::MAX`.\")]\n+                ///\n+                /// # Examples\n+                ///\n+                /// ```\n+                /// #![feature(nonzero_ops)]\n+                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n+                ///\n+                /// # fn main() { test().unwrap(); }\n+                /// # fn test() -> Option<()> {\n+                #[doc = concat!(\"let one = \", stringify!($Ty), \"::new(1)?;\")]\n+                #[doc = concat!(\"let two = \", stringify!($Ty), \"::new(2)?;\")]\n+                ///\n+                /// assert_eq!(two, unsafe { one.unchecked_add(1) });\n+                /// # Some(())\n+                /// # }\n+                /// ```\n+                #[unstable(feature = \"nonzero_ops\", issue = \"84186\")]\n+                #[inline]\n+                pub unsafe fn unchecked_add(self, other: $Int) -> $Ty {\n+                    // SAFETY: The caller ensures there is no overflow.\n+                    unsafe { $Ty::new_unchecked(self.get().unchecked_add(other)) }\n+                }\n+\n+                /// Returns the smallest power of two greater than or equal to n.\n+                /// Check for overflow and return [`None`]\n+                /// if the next power of two is greater than the type\u2019s maximum value.\n+                /// As a consequence, the result cannot wrap to zero.\n+                ///\n+                /// # Examples\n+                ///\n+                /// ```\n+                /// #![feature(nonzero_ops)]\n+                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n+                ///\n+                /// # fn main() { test().unwrap(); }\n+                /// # fn test() -> Option<()> {\n+                #[doc = concat!(\"let two = \", stringify!($Ty), \"::new(2)?;\")]\n+                #[doc = concat!(\"let three = \", stringify!($Ty), \"::new(3)?;\")]\n+                #[doc = concat!(\"let four = \", stringify!($Ty), \"::new(4)?;\")]\n+                #[doc = concat!(\"let max = \", stringify!($Ty), \"::new(\",\n+                                stringify!($Int), \"::MAX)?;\")]\n+                ///\n+                /// assert_eq!(Some(two), two.checked_next_power_of_two() );\n+                /// assert_eq!(Some(four), three.checked_next_power_of_two() );\n+                /// assert_eq!(None, max.checked_next_power_of_two() );\n+                /// # Some(())\n+                /// # }\n+                /// ```\n+                #[unstable(feature = \"nonzero_ops\", issue = \"84186\")]\n+                #[inline]\n+                pub const fn checked_next_power_of_two(self) -> Option<$Ty> {\n+                    if let Some(nz) = self.get().checked_next_power_of_two() {\n+                        // SAFETY: The next power of two is positive\n+                        // and overflow is checked.\n+                        Some(unsafe { $Ty::new_unchecked(nz) })\n+                    } else {\n+                        None\n+                    }\n+                }\n+            }\n+        )+\n+    }\n+}\n+\n+nonzero_unsigned_operations! {\n+    NonZeroU8(u8);\n+    NonZeroU16(u16);\n+    NonZeroU32(u32);\n+    NonZeroU64(u64);\n+    NonZeroU128(u128);\n+    NonZeroUsize(usize);\n+}\n+\n+// A bunch of methods for signed nonzero types only.\n+macro_rules! nonzero_signed_operations {\n+    ( $( $Ty: ident($Int: ty) -> $Uty: ident($Uint: ty); )+ ) => {\n+        $(\n+            impl $Ty {\n+                /// Computes the absolute value of self.\n+                #[doc = concat!(\"See [`\", stringify!($Int), \"::abs`]\")]\n+                /// for documentation on overflow behaviour.\n+                ///\n+                /// # Example\n+                ///\n+                /// ```\n+                /// #![feature(nonzero_ops)]\n+                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n+                ///\n+                /// # fn main() { test().unwrap(); }\n+                /// # fn test() -> Option<()> {\n+                #[doc = concat!(\"let pos = \", stringify!($Ty), \"::new(1)?;\")]\n+                #[doc = concat!(\"let neg = \", stringify!($Ty), \"::new(-1)?;\")]\n+                ///\n+                /// assert_eq!(pos, pos.abs());\n+                /// assert_eq!(pos, neg.abs());\n+                /// # Some(())\n+                /// # }\n+                /// ```\n+                #[unstable(feature = \"nonzero_ops\", issue = \"84186\")]\n+                #[inline]\n+                pub const fn abs(self) -> $Ty {\n+                    // SAFETY: This cannot overflow to zero.\n+                    unsafe { $Ty::new_unchecked(self.get().abs()) }\n+                }\n+\n+                /// Checked absolute value.\n+                /// Check for overflow and returns [`None`] if\n+                #[doc = concat!(\"`self == \", stringify!($Int), \"::MIN`.\")]\n+                /// The result cannot be zero.\n+                ///\n+                /// # Example\n+                ///\n+                /// ```\n+                /// #![feature(nonzero_ops)]\n+                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n+                ///\n+                /// # fn main() { test().unwrap(); }\n+                /// # fn test() -> Option<()> {\n+                #[doc = concat!(\"let pos = \", stringify!($Ty), \"::new(1)?;\")]\n+                #[doc = concat!(\"let neg = \", stringify!($Ty), \"::new(-1)?;\")]\n+                #[doc = concat!(\"let min = \", stringify!($Ty), \"::new(\",\n+                                stringify!($Int), \"::MIN)?;\")]\n+                ///\n+                /// assert_eq!(Some(pos), neg.checked_abs());\n+                /// assert_eq!(None, min.checked_abs());\n+                /// # Some(())\n+                /// # }\n+                /// ```\n+                #[unstable(feature = \"nonzero_ops\", issue = \"84186\")]\n+                #[inline]\n+                pub const fn checked_abs(self) -> Option<$Ty> {\n+                    if let Some(nz) = self.get().checked_abs() {\n+                        // SAFETY: absolute value of nonzero cannot yield zero values.\n+                        Some(unsafe { $Ty::new_unchecked(nz) })\n+                    } else {\n+                        None\n+                    }\n+                }\n+\n+                /// Computes the absolute value of self,\n+                /// with overflow information, see\n+                #[doc = concat!(\"[`\", stringify!($Int), \"::overflowing_abs`].\")]\n+                ///\n+                /// # Example\n+                ///\n+                /// ```\n+                /// #![feature(nonzero_ops)]\n+                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n+                ///\n+                /// # fn main() { test().unwrap(); }\n+                /// # fn test() -> Option<()> {\n+                #[doc = concat!(\"let pos = \", stringify!($Ty), \"::new(1)?;\")]\n+                #[doc = concat!(\"let neg = \", stringify!($Ty), \"::new(-1)?;\")]\n+                #[doc = concat!(\"let min = \", stringify!($Ty), \"::new(\",\n+                                stringify!($Int), \"::MIN)?;\")]\n+                ///\n+                /// assert_eq!((pos, false), pos.overflowing_abs());\n+                /// assert_eq!((pos, false), neg.overflowing_abs());\n+                /// assert_eq!((min, true), min.overflowing_abs());\n+                /// # Some(())\n+                /// # }\n+                /// ```\n+                #[unstable(feature = \"nonzero_ops\", issue = \"84186\")]\n+                #[inline]\n+                pub const fn overflowing_abs(self) -> ($Ty, bool) {\n+                    let (nz, flag) = self.get().overflowing_abs();\n+                    (\n+                        // SAFETY: absolute value of nonzero cannot yield zero values.\n+                        unsafe { $Ty::new_unchecked(nz) },\n+                        flag,\n+                    )\n+                }\n+\n+                /// Saturating absolute value, see\n+                #[doc = concat!(\"[`\", stringify!($Int), \"::saturating_abs`].\")]\n+                ///\n+                /// # Example\n+                ///\n+                /// ```\n+                /// #![feature(nonzero_ops)]\n+                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n+                ///\n+                /// # fn main() { test().unwrap(); }\n+                /// # fn test() -> Option<()> {\n+                #[doc = concat!(\"let pos = \", stringify!($Ty), \"::new(1)?;\")]\n+                #[doc = concat!(\"let neg = \", stringify!($Ty), \"::new(-1)?;\")]\n+                #[doc = concat!(\"let min = \", stringify!($Ty), \"::new(\",\n+                                stringify!($Int), \"::MIN)?;\")]\n+                #[doc = concat!(\"let min_plus = \", stringify!($Ty), \"::new(\",\n+                                stringify!($Int), \"::MIN + 1)?;\")]\n+                #[doc = concat!(\"let max = \", stringify!($Ty), \"::new(\",\n+                                stringify!($Int), \"::MAX)?;\")]\n+                ///\n+                /// assert_eq!(pos, pos.saturating_abs());\n+                /// assert_eq!(pos, neg.saturating_abs());\n+                /// assert_eq!(max, min.saturating_abs());\n+                /// assert_eq!(max, min_plus.saturating_abs());\n+                /// # Some(())\n+                /// # }\n+                /// ```\n+                #[unstable(feature = \"nonzero_ops\", issue = \"84186\")]\n+                #[inline]\n+                pub const fn saturating_abs(self) -> $Ty {\n+                    // SAFETY: absolute value of nonzero cannot yield zero values.\n+                    unsafe { $Ty::new_unchecked(self.get().saturating_abs()) }\n+                }\n+\n+                /// Wrapping absolute value, see\n+                #[doc = concat!(\"[`\", stringify!($Int), \"::wrapping_abs`].\")]\n+                ///\n+                /// # Example\n+                ///\n+                /// ```\n+                /// #![feature(nonzero_ops)]\n+                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n+                ///\n+                /// # fn main() { test().unwrap(); }\n+                /// # fn test() -> Option<()> {\n+                #[doc = concat!(\"let pos = \", stringify!($Ty), \"::new(1)?;\")]\n+                #[doc = concat!(\"let neg = \", stringify!($Ty), \"::new(-1)?;\")]\n+                #[doc = concat!(\"let min = \", stringify!($Ty), \"::new(\",\n+                                stringify!($Int), \"::MIN)?;\")]\n+                #[doc = concat!(\"let max = \", stringify!($Ty), \"::new(\",\n+                                stringify!($Int), \"::MAX)?;\")]\n+                ///\n+                /// assert_eq!(pos, pos.wrapping_abs());\n+                /// assert_eq!(pos, neg.wrapping_abs());\n+                /// assert_eq!(min, min.wrapping_abs());\n+                /// # // FIXME: add once Neg is implemented?\n+                /// # // assert_eq!(max, (-max).wrapping_abs());\n+                /// # Some(())\n+                /// # }\n+                /// ```\n+                #[unstable(feature = \"nonzero_ops\", issue = \"84186\")]\n+                #[inline]\n+                pub const fn wrapping_abs(self) -> $Ty {\n+                    // SAFETY: absolute value of nonzero cannot yield zero values.\n+                    unsafe { $Ty::new_unchecked(self.get().wrapping_abs()) }\n+                }\n+\n+                /// Computes the absolute value of self\n+                /// without any wrapping or panicking.\n+                ///\n+                /// # Example\n+                ///\n+                /// ```\n+                /// #![feature(nonzero_ops)]\n+                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n+                #[doc = concat!(\"# use std::num::\", stringify!($Uty), \";\")]\n+                ///\n+                /// # fn main() { test().unwrap(); }\n+                /// # fn test() -> Option<()> {\n+                #[doc = concat!(\"let u_pos = \", stringify!($Uty), \"::new(1)?;\")]\n+                #[doc = concat!(\"let i_pos = \", stringify!($Ty), \"::new(1)?;\")]\n+                #[doc = concat!(\"let i_neg = \", stringify!($Ty), \"::new(-1)?;\")]\n+                #[doc = concat!(\"let i_min = \", stringify!($Ty), \"::new(\",\n+                                stringify!($Int), \"::MIN)?;\")]\n+                #[doc = concat!(\"let u_max = \", stringify!($Uty), \"::new(\",\n+                                stringify!($Uint), \"::MAX / 2 + 1)?;\")]\n+                ///\n+                /// assert_eq!(u_pos, i_pos.unsigned_abs());\n+                /// assert_eq!(u_pos, i_neg.unsigned_abs());\n+                /// assert_eq!(u_max, i_min.unsigned_abs());\n+                /// # Some(())\n+                /// # }\n+                /// ```\n+                #[unstable(feature = \"nonzero_ops\", issue = \"84186\")]\n+                #[inline]\n+                pub const fn unsigned_abs(self) -> $Uty {\n+                    // SAFETY: absolute value of nonzero cannot yield zero values.\n+                    unsafe { $Uty::new_unchecked(self.get().unsigned_abs()) }\n+                }\n+            }\n+        )+\n+    }\n+}\n+\n+nonzero_signed_operations! {\n+    NonZeroI8(i8) -> NonZeroU8(u8);\n+    NonZeroI16(i16) -> NonZeroU16(u16);\n+    NonZeroI32(i32) -> NonZeroU32(u32);\n+    NonZeroI64(i64) -> NonZeroU64(u64);\n+    NonZeroI128(i128) -> NonZeroU128(u128);\n+    NonZeroIsize(isize) -> NonZeroUsize(usize);\n+}\n+\n+// A bunch of methods for both signed and unsigned nonzero types.\n+macro_rules! nonzero_unsigned_signed_operations {\n+    ( $( $signedness:ident $Ty: ident($Int: ty); )+ ) => {\n+        $(\n+            impl $Ty {\n+                /// Multiply two non-zero integers together.\n+                /// Check for overflow and return [`None`] on overflow.\n+                /// As a consequence, the result cannot wrap to zero.\n+                ///\n+                /// # Examples\n+                ///\n+                /// ```\n+                /// #![feature(nonzero_ops)]\n+                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n+                ///\n+                /// # fn main() { test().unwrap(); }\n+                /// # fn test() -> Option<()> {\n+                #[doc = concat!(\"let two = \", stringify!($Ty), \"::new(2)?;\")]\n+                #[doc = concat!(\"let four = \", stringify!($Ty), \"::new(4)?;\")]\n+                #[doc = concat!(\"let max = \", stringify!($Ty), \"::new(\",\n+                                stringify!($Int), \"::MAX)?;\")]\n+                ///\n+                /// assert_eq!(Some(four), two.checked_mul(two));\n+                /// assert_eq!(None, max.checked_mul(two));\n+                /// # Some(())\n+                /// # }\n+                /// ```\n+                #[unstable(feature = \"nonzero_ops\", issue = \"84186\")]\n+                #[inline]\n+                pub const fn checked_mul(self, other: $Ty) -> Option<$Ty> {\n+                    if let Some(result) = self.get().checked_mul(other.get()) {\n+                        // SAFETY: checked_mul returns None on overflow\n+                        // and `other` is also non-null\n+                        // so the result cannot be zero.\n+                        Some(unsafe { $Ty::new_unchecked(result) })\n+                    } else {\n+                        None\n+                    }\n+                }\n+\n+                /// Multiply two non-zero integers together.\n+                #[doc = concat!(\"Return [`\", stringify!($Int), \"::MAX`] on overflow.\")]\n+                ///\n+                /// # Examples\n+                ///\n+                /// ```\n+                /// #![feature(nonzero_ops)]\n+                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n+                ///\n+                /// # fn main() { test().unwrap(); }\n+                /// # fn test() -> Option<()> {\n+                #[doc = concat!(\"let two = \", stringify!($Ty), \"::new(2)?;\")]\n+                #[doc = concat!(\"let four = \", stringify!($Ty), \"::new(4)?;\")]\n+                #[doc = concat!(\"let max = \", stringify!($Ty), \"::new(\",\n+                                stringify!($Int), \"::MAX)?;\")]\n+                ///\n+                /// assert_eq!(four, two.saturating_mul(two));\n+                /// assert_eq!(max, four.saturating_mul(max));\n+                /// # Some(())\n+                /// # }\n+                /// ```\n+                #[unstable(feature = \"nonzero_ops\", issue = \"84186\")]\n+                #[inline]\n+                pub const fn saturating_mul(self, other: $Ty) -> $Ty {\n+                    // SAFETY: saturating_mul returns u*::MAX on overflow\n+                    // and `other` is also non-null\n+                    // so the result cannot be zero.\n+                    unsafe { $Ty::new_unchecked(self.get().saturating_mul(other.get())) }\n+                }\n+\n+                /// Multiply two non-zero integers together,\n+                /// assuming overflow cannot occur.\n+                /// Overflow is unchecked, and it is undefined behaviour to overflow\n+                /// *even if the result would wrap to a non-zero value*.\n+                /// The behaviour is undefined as soon as\n+                #[doc = sign_dependent_expr!{\n+                    $signedness ?\n+                    if signed {\n+                        concat!(\"`self * rhs > \", stringify!($Int), \"::MAX`, \",\n+                                \"or `self * rhs < \", stringify!($Int), \"::MIN`.\")\n+                    }\n+                    if unsigned {\n+                        concat!(\"`self * rhs > \", stringify!($Int), \"::MAX`.\")\n+                    }\n+                }]\n+                ///\n+                /// # Examples\n+                ///\n+                /// ```\n+                /// #![feature(nonzero_ops)]\n+                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n+                ///\n+                /// # fn main() { test().unwrap(); }\n+                /// # fn test() -> Option<()> {\n+                #[doc = concat!(\"let two = \", stringify!($Ty), \"::new(2)?;\")]\n+                #[doc = concat!(\"let four = \", stringify!($Ty), \"::new(4)?;\")]\n+                ///\n+                /// assert_eq!(four, unsafe { two.unchecked_mul(two) });\n+                /// # Some(())\n+                /// # }\n+                /// ```\n+                #[unstable(feature = \"nonzero_ops\", issue = \"84186\")]\n+                #[inline]\n+                pub unsafe fn unchecked_mul(self, other: $Ty) -> $Ty {\n+                    // SAFETY: The caller ensures there is no overflow.\n+                    unsafe { $Ty::new_unchecked(self.get().unchecked_mul(other.get())) }\n+                }\n+\n+                /// Raise non-zero value to an integer power.\n+                /// Check for overflow and return [`None`] on overflow.\n+                /// As a consequence, the result cannot wrap to zero.\n+                ///\n+                /// # Examples\n+                ///\n+                /// ```\n+                /// #![feature(nonzero_ops)]\n+                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n+                ///\n+                /// # fn main() { test().unwrap(); }\n+                /// # fn test() -> Option<()> {\n+                #[doc = concat!(\"let three = \", stringify!($Ty), \"::new(3)?;\")]\n+                #[doc = concat!(\"let twenty_seven = \", stringify!($Ty), \"::new(27)?;\")]\n+                #[doc = concat!(\"let half_max = \", stringify!($Ty), \"::new(\",\n+                                stringify!($Int), \"::MAX / 2)?;\")]\n+                ///\n+                /// assert_eq!(Some(twenty_seven), three.checked_pow(3));\n+                /// assert_eq!(None, half_max.checked_pow(3));\n+                /// # Some(())\n+                /// # }\n+                /// ```\n+                #[unstable(feature = \"nonzero_ops\", issue = \"84186\")]\n+                #[inline]\n+                pub const fn checked_pow(self, other: u32) -> Option<$Ty> {\n+                    if let Some(result) = self.get().checked_pow(other) {\n+                        // SAFETY: checked_pow returns None on overflow\n+                        // so the result cannot be zero.\n+                        Some(unsafe { $Ty::new_unchecked(result) })\n+                    } else {\n+                        None\n+                    }\n+                }\n+\n+                /// Raise non-zero value to an integer power.\n+                #[doc = sign_dependent_expr!{\n+                    $signedness ?\n+                    if signed {\n+                        concat!(\"Return [`\", stringify!($Int), \"::MIN`] \",\n+                                    \"or [`\", stringify!($Int), \"::MAX`] on overflow.\")\n+                    }\n+                    if unsigned {\n+                        concat!(\"Return [`\", stringify!($Int), \"::MAX`] on overflow.\")\n+                    }\n+                }]\n+                ///\n+                /// # Examples\n+                ///\n+                /// ```\n+                /// #![feature(nonzero_ops)]\n+                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n+                ///\n+                /// # fn main() { test().unwrap(); }\n+                /// # fn test() -> Option<()> {\n+                #[doc = concat!(\"let three = \", stringify!($Ty), \"::new(3)?;\")]\n+                #[doc = concat!(\"let twenty_seven = \", stringify!($Ty), \"::new(27)?;\")]\n+                #[doc = concat!(\"let max = \", stringify!($Ty), \"::new(\",\n+                                stringify!($Int), \"::MAX)?;\")]\n+                ///\n+                /// assert_eq!(twenty_seven, three.saturating_pow(3));\n+                /// assert_eq!(max, max.saturating_pow(3));\n+                /// # Some(())\n+                /// # }\n+                /// ```\n+                #[unstable(feature = \"nonzero_ops\", issue = \"84186\")]\n+                #[inline]\n+                pub const fn saturating_pow(self, other: u32) -> $Ty {\n+                    // SAFETY: saturating_pow returns u*::MAX on overflow\n+                    // so the result cannot be zero.\n+                    unsafe { $Ty::new_unchecked(self.get().saturating_pow(other)) }\n+                }\n+            }\n+        )+\n+    }\n+}\n+\n+// Use this when the generated code should differ between signed and unsigned types.\n+macro_rules! sign_dependent_expr {\n+    (signed ? if signed { $signed_case:expr } if unsigned { $unsigned_case:expr } ) => {\n+        $signed_case\n+    };\n+    (unsigned ? if signed { $signed_case:expr } if unsigned { $unsigned_case:expr } ) => {\n+        $unsigned_case\n+    };\n+}\n+\n+nonzero_unsigned_signed_operations! {\n+    unsigned NonZeroU8(u8);\n+    unsigned NonZeroU16(u16);\n+    unsigned NonZeroU32(u32);\n+    unsigned NonZeroU64(u64);\n+    unsigned NonZeroU128(u128);\n+    unsigned NonZeroUsize(usize);\n+    signed NonZeroI8(i8);\n+    signed NonZeroI16(i16);\n+    signed NonZeroI32(i32);\n+    signed NonZeroI64(i64);\n+    signed NonZeroI128(i128);\n+    signed NonZeroIsize(isize);\n+}\n+\n macro_rules! nonzero_unsigned_is_power_of_two {\n     ( $( $Ty: ident )+ ) => {\n         $("}, {"sha": "bb948376bc7c7715d005f05a7add1f6dd26e7732", "filename": "library/core/src/ops/range.rs", "status": "modified", "additions": 36, "deletions": 2, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Fcore%2Fsrc%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Fcore%2Fsrc%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Frange.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -674,10 +674,10 @@ pub enum Bound<T> {\n     Unbounded,\n }\n \n-#[unstable(feature = \"bound_as_ref\", issue = \"80996\")]\n impl<T> Bound<T> {\n     /// Converts from `&Bound<T>` to `Bound<&T>`.\n     #[inline]\n+    #[unstable(feature = \"bound_as_ref\", issue = \"80996\")]\n     pub fn as_ref(&self) -> Bound<&T> {\n         match *self {\n             Included(ref x) => Included(x),\n@@ -686,15 +686,49 @@ impl<T> Bound<T> {\n         }\n     }\n \n-    /// Converts from `&mut Bound<T>` to `Bound<&T>`.\n+    /// Converts from `&mut Bound<T>` to `Bound<&mut T>`.\n     #[inline]\n+    #[unstable(feature = \"bound_as_ref\", issue = \"80996\")]\n     pub fn as_mut(&mut self) -> Bound<&mut T> {\n         match *self {\n             Included(ref mut x) => Included(x),\n             Excluded(ref mut x) => Excluded(x),\n             Unbounded => Unbounded,\n         }\n     }\n+\n+    /// Maps a `Bound<T>` to a `Bound<U>` by applying a function to the contained value (including\n+    /// both `Included` and `Excluded`), returning a `Bound` of the same kind.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(bound_map)]\n+    /// use std::ops::Bound::*;\n+    ///\n+    /// let bound_string = Included(\"Hello, World!\");\n+    ///\n+    /// assert_eq!(bound_string.map(|s| s.len()), Included(13));\n+    /// ```\n+    ///\n+    /// ```\n+    /// #![feature(bound_map)]\n+    /// use std::ops::Bound;\n+    /// use Bound::*;\n+    ///\n+    /// let unbounded_string: Bound<String> = Unbounded;\n+    ///\n+    /// assert_eq!(unbounded_string.map(|s| s.len()), Unbounded);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"bound_map\", issue = \"86026\")]\n+    pub fn map<U, F: FnOnce(T) -> U>(self, f: F) -> Bound<U> {\n+        match self {\n+            Unbounded => Unbounded,\n+            Included(x) => Included(f(x)),\n+            Excluded(x) => Excluded(f(x)),\n+        }\n+    }\n }\n \n impl<T: Clone> Bound<&T> {"}, {"sha": "4e7afca6a4930e3115136e678e875108dc951968", "filename": "library/core/src/option.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Fcore%2Fsrc%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Fcore%2Fsrc%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Foption.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -83,6 +83,8 @@\n //! * [`ptr::NonNull<U>`]\n //! * `#[repr(transparent)]` struct around one of the types in this list.\n //!\n+//! This is called the \"null pointer optimization\" or NPO.\n+//!\n //! It is further guaranteed that, for the cases above, one can\n //! [`mem::transmute`] from all valid values of `T` to `Option<T>` and\n //! from `Some::<T>(_)` to `T` (but transmuting `None::<T>` to `T`"}, {"sha": "79753c1fb66871fc47ada3b4258c03f17cc2b70c", "filename": "library/core/src/prelude/mod.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Fcore%2Fsrc%2Fprelude%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Fcore%2Fsrc%2Fprelude%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fprelude%2Fmod.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -11,31 +11,37 @@ pub mod v1;\n /// The 2015 version of the core prelude.\n ///\n /// See the [module-level documentation](self) for more.\n-#[unstable(feature = \"prelude_2015\", issue = \"none\")]\n+#[unstable(feature = \"prelude_2015\", issue = \"85684\")]\n pub mod rust_2015 {\n-    #[unstable(feature = \"prelude_2015\", issue = \"none\")]\n+    #[unstable(feature = \"prelude_2015\", issue = \"85684\")]\n     #[doc(no_inline)]\n     pub use super::v1::*;\n }\n \n /// The 2018 version of the core prelude.\n ///\n /// See the [module-level documentation](self) for more.\n-#[unstable(feature = \"prelude_2018\", issue = \"none\")]\n+#[unstable(feature = \"prelude_2018\", issue = \"85684\")]\n pub mod rust_2018 {\n-    #[unstable(feature = \"prelude_2018\", issue = \"none\")]\n+    #[unstable(feature = \"prelude_2018\", issue = \"85684\")]\n     #[doc(no_inline)]\n     pub use super::v1::*;\n }\n \n /// The 2021 version of the core prelude.\n ///\n /// See the [module-level documentation](self) for more.\n-#[unstable(feature = \"prelude_2021\", issue = \"none\")]\n+#[unstable(feature = \"prelude_2021\", issue = \"85684\")]\n pub mod rust_2021 {\n-    #[unstable(feature = \"prelude_2021\", issue = \"none\")]\n+    #[unstable(feature = \"prelude_2021\", issue = \"85684\")]\n     #[doc(no_inline)]\n     pub use super::v1::*;\n \n-    // FIXME: Add more things.\n+    #[unstable(feature = \"prelude_2021\", issue = \"85684\")]\n+    #[doc(no_inline)]\n+    pub use crate::iter::FromIterator;\n+\n+    #[unstable(feature = \"prelude_2021\", issue = \"85684\")]\n+    #[doc(no_inline)]\n+    pub use crate::convert::{TryFrom, TryInto};\n }"}, {"sha": "6a6cee0911feacf5253d08294e70d0773646cbe0", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -430,8 +430,7 @@ pub const unsafe fn swap_nonoverlapping<T>(x: *mut T, y: *mut T, count: usize) {\n }\n \n #[inline]\n-#[rustc_const_unstable(feature = \"const_swap\", issue = \"83163\")]\n-pub(crate) const unsafe fn swap_nonoverlapping_one<T>(x: *mut T, y: *mut T) {\n+pub(crate) unsafe fn swap_nonoverlapping_one<T>(x: *mut T, y: *mut T) {\n     // NOTE(eddyb) SPIR-V's Logical addressing model doesn't allow for arbitrary\n     // reinterpretation of values as (chunkable) byte arrays, and the loop in the\n     // block optimization in `swap_nonoverlapping_bytes` is hard to rewrite back\n@@ -564,8 +563,7 @@ const unsafe fn swap_nonoverlapping_bytes(x: *mut u8, y: *mut u8, len: usize) {\n /// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_replace\", issue = \"83164\")]\n-pub const unsafe fn replace<T>(dst: *mut T, mut src: T) -> T {\n+pub unsafe fn replace<T>(dst: *mut T, mut src: T) -> T {\n     // SAFETY: the caller must guarantee that `dst` is valid to be\n     // cast to a mutable reference (valid for writes, aligned, initialized),\n     // and cannot overlap `src` since `dst` must point to a distinct\n@@ -871,14 +869,18 @@ pub const unsafe fn read_unaligned<T>(src: *const T) -> T {\n /// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_ptr_write\", issue = \"none\")]\n-pub const unsafe fn write<T>(dst: *mut T, src: T) {\n+pub unsafe fn write<T>(dst: *mut T, src: T) {\n+    // We are calling the intrinsics directly to avoid function calls in the generated code\n+    // as `intrinsics::copy_nonoverlapping` is a wrapper function.\n+    extern \"rust-intrinsic\" {\n+        fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize);\n+    }\n+\n     // SAFETY: the caller must guarantee that `dst` is valid for writes.\n     // `dst` cannot overlap `src` because the caller has mutable access\n     // to `dst` while `src` is owned by this function.\n     unsafe {\n         copy_nonoverlapping(&src as *const T, dst, 1);\n-        // We are calling the intrinsic directly to avoid function calls in the generated code.\n         intrinsics::forget(src);\n     }\n }"}, {"sha": "a6424041542d9054c79e060f23772de186088cc3", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -1002,9 +1002,8 @@ impl<T: ?Sized> *mut T {\n     ///\n     /// [`ptr::write`]: crate::ptr::write()\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n-    #[rustc_const_unstable(feature = \"const_ptr_write\", issue = \"none\")]\n     #[inline(always)]\n-    pub const unsafe fn write(self, val: T)\n+    pub unsafe fn write(self, val: T)\n     where\n         T: Sized,\n     {"}, {"sha": "0e5c5ee726e54f4ca07d734a330cd95653287a6d", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -2100,9 +2100,11 @@ impl<T> [T] {\n     ///\n     /// If the value is found then [`Result::Ok`] is returned, containing the\n     /// index of the matching element. If there are multiple matches, then any\n-    /// one of the matches could be returned. If the value is not found then\n-    /// [`Result::Err`] is returned, containing the index where a matching\n-    /// element could be inserted while maintaining sorted order.\n+    /// one of the matches could be returned. The index is chosen\n+    /// deterministically, but is subject to change in future versions of Rust.\n+    /// If the value is not found then [`Result::Err`] is returned, containing\n+    /// the index where a matching element could be inserted while maintaining\n+    /// sorted order.\n     ///\n     /// See also [`binary_search_by`], [`binary_search_by_key`], and [`partition_point`].\n     ///\n@@ -2153,9 +2155,11 @@ impl<T> [T] {\n     ///\n     /// If the value is found then [`Result::Ok`] is returned, containing the\n     /// index of the matching element. If there are multiple matches, then any\n-    /// one of the matches could be returned. If the value is not found then\n-    /// [`Result::Err`] is returned, containing the index where a matching\n-    /// element could be inserted while maintaining sorted order.\n+    /// one of the matches could be returned. The index is chosen\n+    /// deterministically, but is subject to change in future versions of Rust.\n+    /// If the value is not found then [`Result::Err`] is returned, containing\n+    /// the index where a matching element could be inserted while maintaining\n+    /// sorted order.\n     ///\n     /// See also [`binary_search`], [`binary_search_by_key`], and [`partition_point`].\n     ///\n@@ -2224,9 +2228,11 @@ impl<T> [T] {\n     ///\n     /// If the value is found then [`Result::Ok`] is returned, containing the\n     /// index of the matching element. If there are multiple matches, then any\n-    /// one of the matches could be returned. If the value is not found then\n-    /// [`Result::Err`] is returned, containing the index where a matching\n-    /// element could be inserted while maintaining sorted order.\n+    /// one of the matches could be returned. The index is chosen\n+    /// deterministically, but is subject to change in future versions of Rust.\n+    /// If the value is not found then [`Result::Err`] is returned, containing\n+    /// the index where a matching element could be inserted while maintaining\n+    /// sorted order.\n     ///\n     /// See also [`binary_search`], [`binary_search_by`], and [`partition_point`].\n     ///"}, {"sha": "b36d6f0d4040598b0ea86718d0489681d8c19781", "filename": "library/core/tests/any.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Fcore%2Ftests%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Fcore%2Ftests%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fany.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -114,3 +114,16 @@ fn any_unsized() {\n     fn is_any<T: Any + ?Sized>() {}\n     is_any::<[i32]>();\n }\n+\n+#[test]\n+fn distinct_type_names() {\n+    // https://github.com/rust-lang/rust/issues/84666\n+\n+    struct Velocity(f32, f32);\n+\n+    fn type_name_of_val<T>(_: T) -> &'static str {\n+        type_name::<T>()\n+    }\n+\n+    assert_ne!(type_name_of_val(Velocity), type_name_of_val(Velocity(0.0, -9.8)),);\n+}"}, {"sha": "0ae625bdb68c6244f20b7a65c5e6154d6594afd4", "filename": "library/core/tests/array.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Fcore%2Ftests%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f5d6d80d397334eb613cf3e414028af68f3f02/library%2Fcore%2Ftests%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Farray.rs?ref=c8f5d6d80d397334eb613cf3e414028af68f3f02", "patch": "@@ -1,4 +1,4 @@\n-use core::array::{self, IntoIter};\n+use core::array;\n use core::convert::TryFrom;\n \n #[test]\n@@ -41,44 +41,44 @@ fn array_try_from() {\n #[test]\n fn iterator_collect() {\n     let arr = [0, 1, 2, 5, 9];\n-    let v: Vec<_> = IntoIter::new(arr.clone()).collect();\n+    let v: Vec<_> = IntoIterator::into_iter(arr.clone()).collect();\n     assert_eq!(&arr[..], &v[..]);\n }\n \n #[test]\n fn iterator_rev_collect() {\n     let arr = [0, 1, 2, 5, 9];\n-    let v: Vec<_> = IntoIter::new(arr.clone()).rev().collect();\n+    let v: Vec<_> = IntoIterator::into_iter(arr.clone()).rev().collect();\n     assert_eq!(&v[..], &[9, 5, 2, 1, 0]);\n }\n \n #[test]\n fn iterator_nth() {\n     let v = [0, 1, 2, 3, 4];\n     for i in 0..v.len() {\n-        assert_eq!(IntoIter::new(v.clone()).nth(i).unwrap(), v[i]);\n+        assert_eq!(IntoIterator::into_iter(v.clone()).nth(i).unwrap(), v[i]);\n     }\n-    assert_eq!(IntoIter::new(v.clone()).nth(v.len()), None);\n+    assert_eq!(IntoIterator::into_iter(v.clone()).nth(v.len()), None);\n \n-    let mut iter = IntoIter::new(v);\n+    let mut iter = IntoIterator::into_iter(v);\n     assert_eq!(iter.nth(2).unwrap(), v[2]);\n     assert_eq!(iter.nth(1).unwrap(), v[4]);\n }\n \n #[test]\n fn iterator_last() {\n     let v = [0, 1, 2, 3, 4];\n-    assert_eq!(IntoIter::new(v).last().unwrap(), 4);\n-    assert_eq!(IntoIter::new([0]).last().unwrap(), 0);\n+    assert_eq!(IntoIterator::into_iter(v).last().unwrap(), 4);\n+    assert_eq!(IntoIterator::into_iter([0]).last().unwrap(), 0);\n \n-    let mut it = IntoIter::new([0, 9, 2, 4]);\n+    let mut it = IntoIterator::into_iter([0, 9, 2, 4]);\n     assert_eq!(it.next_back(), Some(4));\n     assert_eq!(it.last(), Some(2));\n }\n \n #[test]\n fn iterator_clone() {\n-    let mut it = IntoIter::new([0, 2, 4, 6, 8]);\n+    let mut it = IntoIterator::into_iter([0, 2, 4, 6, 8]);\n     assert_eq!(it.next(), Some(0));\n     assert_eq!(it.next_back(), Some(8));\n     let mut clone = it.clone();\n@@ -92,7 +92,7 @@ fn iterator_clone() {\n \n #[test]\n fn iterator_fused() {\n-    let mut it = IntoIter::new([0, 9, 2]);\n+    let mut it = IntoIterator::into_iter([0, 9, 2]);\n     assert_eq!(it.next(), Some(0));\n     assert_eq!(it.next(), Some(9));\n     assert_eq!(it.next(), Some(2));\n@@ -105,7 +105,7 @@ fn iterator_fused() {\n \n #[test]\n fn iterator_len() {\n-    let mut it = IntoIter::new([0, 1, 2, 5, 9]);\n+    let mut it = IntoIterator::into_iter([0, 1, 2, 5, 9]);\n     assert_eq!(it.size_hint(), (5, Some(5)));\n     assert_eq!(it.len(), 5);\n     assert_eq!(it.is_empty(), false);\n@@ -121,7 +121,7 @@ fn iterator_len() {\n     assert_eq!(it.is_empty(), false);\n \n     // Empty\n-    let it = IntoIter::new([] as [String; 0]);\n+    let it = IntoIterator::into_iter([] as [String; 0]);\n     assert_eq!(it.size_hint(), (0, Some(0)));\n     assert_eq!(it.len(), 0);\n     assert_eq!(it.is_empty(), true);\n@@ -130,23 +130,23 @@ fn iterator_len() {\n #[test]\n fn iterator_count() {\n     let v = [0, 1, 2, 3, 4];\n-    assert_eq!(IntoIter::new(v.clone()).count(), 5);\n+    assert_eq!(IntoIterator::into_iter(v.clone()).count(), 5);\n \n-    let mut iter2 = IntoIter::new(v);\n+    let mut iter2 = IntoIterator::into_iter(v);\n     iter2.next();\n     iter2.next();\n     assert_eq!(iter2.count(), 3);\n }\n \n #[test]\n fn iterator_flat_map() {\n-    assert!((0..5).flat_map(|i| IntoIter::new([2 * i, 2 * i + 1])).eq(0..10));\n+    assert!((0..5).flat_map(|i| IntoIterator::into_iter([2 * i, 2 * i + 1])).eq(0..10));\n }\n \n #[test]\n fn iterator_debug() {\n     let arr = [0, 1, 2, 5, 9];\n-    assert_eq!(format!(\"{:?}\", IntoIter::new(arr)), \"IntoIter([0, 1, 2, 5, 9])\",);\n+    assert_eq!(format!(\"{:?}\", IntoIterator::into_iter(arr)), \"IntoIter([0, 1, 2, 5, 9])\",);\n }\n \n #[test]\n@@ -176,14 +176,14 @@ fn iterator_drops() {\n     // Simple: drop new iterator.\n     let i = Cell::new(0);\n     {\n-        IntoIter::new(five(&i));\n+        IntoIterator::into_iter(five(&i));\n     }\n     assert_eq!(i.get(), 5);\n \n     // Call `next()` once.\n     let i = Cell::new(0);\n     {\n-        let mut iter = IntoIter::new(five(&i));\n+        let mut iter = IntoIterator::into_iter(five(&i));\n         let _x = iter.next();\n         assert_eq!(i.get(), 0);\n         assert_eq!(iter.count(), 4);\n@@ -194,7 +194,7 @@ fn iterator_drops() {\n     // Check `clone` and calling `next`/`next_back`.\n     let i = Cell::new(0);\n     {\n-        let mut iter = IntoIter::new(five(&i));\n+        let mut iter = IntoIterator::into_iter(five(&i));\n         iter.next();\n         assert_eq!(i.get(), 1);\n         iter.next_back();\n@@ -217,7 +217,7 @@ fn iterator_drops() {\n     // Check via `nth`.\n     let i = Cell::new(0);\n     {\n-        let mut iter = IntoIter::new(five(&i));\n+        let mut iter = IntoIterator::into_iter(five(&i));\n         let _x = iter.nth(2);\n         assert_eq!(i.get(), 2);\n         let _y = iter.last();\n@@ -227,13 +227,13 @@ fn iterator_drops() {\n \n     // Check every element.\n     let i = Cell::new(0);\n-    for (index, _x) in IntoIter::new(five(&i)).enumerate() {\n+    for (index, _x) in IntoIterator::into_iter(five(&i)).enumerate() {\n         assert_eq!(i.get(), index);\n     }\n     assert_eq!(i.get(), 5);\n \n     let i = Cell::new(0);\n-    for (index, _x) in IntoIter::new(five(&i)).rev().enumerate() {\n+    for (index, _x) in IntoIterator::into_iter(five(&i)).rev().enumerate() {\n         assert_eq!(i.get(), index);\n     }\n     assert_eq!(i.get(), 5);"}]}