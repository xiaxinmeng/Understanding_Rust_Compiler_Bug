{"sha": "b21f66fce37cc9c1bcd1b174acd86aa2ed9aab41", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyMWY2NmZjZTM3Y2M5YzFiY2QxYjE3NGFjZDg2YWEyZWQ5YWFiNDE=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-07-29T20:01:24Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-07-29T20:07:56Z"}, "message": "Simplify extract_function assist", "tree": {"sha": "1722af90f942cebc7fae4039a1d508ff8de1907c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1722af90f942cebc7fae4039a1d508ff8de1907c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b21f66fce37cc9c1bcd1b174acd86aa2ed9aab41", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b21f66fce37cc9c1bcd1b174acd86aa2ed9aab41", "html_url": "https://github.com/rust-lang/rust/commit/b21f66fce37cc9c1bcd1b174acd86aa2ed9aab41", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b21f66fce37cc9c1bcd1b174acd86aa2ed9aab41/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b537cb186ed7b200c8ca86a70be81c56ecd154a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/b537cb186ed7b200c8ca86a70be81c56ecd154a3", "html_url": "https://github.com/rust-lang/rust/commit/b537cb186ed7b200c8ca86a70be81c56ecd154a3"}], "stats": {"total": 454, "additions": 236, "deletions": 218}, "files": [{"sha": "493cac6e21e62c93ed77b54b6909147452894e27", "filename": "crates/ide_assists/src/handlers/extract_function.rs", "status": "modified", "additions": 118, "deletions": 117, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/b21f66fce37cc9c1bcd1b174acd86aa2ed9aab41/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21f66fce37cc9c1bcd1b174acd86aa2ed9aab41/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=b21f66fce37cc9c1bcd1b174acd86aa2ed9aab41", "patch": "@@ -74,20 +74,12 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option\n     let (locals_used, has_await, self_param) = analyze_body(&ctx.sema, &body);\n \n     let anchor = if self_param.is_some() { Anchor::Method } else { Anchor::Freestanding };\n-    let insert_after = scope_for_fn_insertion(&body, anchor)?;\n+    let insert_after = node_to_insert_after(&body, anchor)?;\n     let module = ctx.sema.scope(&insert_after).module()?;\n \n-    let vars_defined_in_body_and_outlive =\n-        vars_defined_in_body_and_outlive(ctx, &body, node.parent().as_ref().unwrap_or(&node));\n     let ret_ty = body_return_ty(ctx, &body)?;\n+    let ret_values = ret_values(ctx, &body, node.parent().as_ref().unwrap_or(&node));\n \n-    // FIXME: we compute variables that outlive here just to check `never!` condition\n-    //        this requires traversing whole `body` (cheap) and finding all references (expensive)\n-    //        maybe we can move this check to `edit` closure somehow?\n-    if stdx::never!(!vars_defined_in_body_and_outlive.is_empty() && !ret_ty.is_unit()) {\n-        // We should not have variables that outlive body if we have expression block\n-        return None;\n-    }\n     let control_flow = external_control_flow(ctx, &body)?;\n \n     let target_range = body.text_range();\n@@ -97,16 +89,22 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option\n         \"Extract into function\",\n         target_range,\n         move |builder| {\n+            let ret_values: Vec<_> = ret_values.collect();\n+            if stdx::never!(!ret_values.is_empty() && !ret_ty.is_unit()) {\n+                // We should not have variables that outlive body if we have expression block\n+                return;\n+            }\n+\n             let params = extracted_function_params(ctx, &body, locals_used.iter().copied());\n \n             let fun = Function {\n                 name: \"fun_name\".to_string(),\n-                self_param: self_param.map(|(_, pat)| pat),\n+                self_param,\n                 params,\n                 control_flow,\n                 ret_ty,\n                 body,\n-                vars_defined_in_body_and_outlive,\n+                vars_defined_in_body_and_outlive: ret_values,\n             };\n \n             let new_indent = IndentLevel::from_node(&insert_after);\n@@ -124,68 +122,46 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option\n     )\n }\n \n+/// Analyses the function body for external control flow.\n fn external_control_flow(ctx: &AssistContext, body: &FunctionBody) -> Option<ControlFlow> {\n     let mut ret_expr = None;\n     let mut try_expr = None;\n     let mut break_expr = None;\n     let mut continue_expr = None;\n-    let (syntax, text_range) = match body {\n-        FunctionBody::Expr(expr) => (expr.syntax(), expr.syntax().text_range()),\n-        FunctionBody::Span { parent, text_range } => (parent.syntax(), *text_range),\n-    };\n \n-    let mut nested_loop = None;\n-    let mut nested_scope = None;\n+    let mut loop_depth = 0;\n \n-    for e in syntax.preorder() {\n-        let e = match e {\n+    body.preorder_expr(&mut |expr| {\n+        let expr = match expr {\n             WalkEvent::Enter(e) => e,\n-            WalkEvent::Leave(e) => {\n-                if nested_loop.as_ref() == Some(&e) {\n-                    nested_loop = None;\n-                }\n-                if nested_scope.as_ref() == Some(&e) {\n-                    nested_scope = None;\n-                }\n-                continue;\n+            WalkEvent::Leave(\n+                ast::Expr::LoopExpr(_) | ast::Expr::ForExpr(_) | ast::Expr::WhileExpr(_),\n+            ) => {\n+                loop_depth -= 1;\n+                return false;\n             }\n+            WalkEvent::Leave(_) => return false,\n         };\n-        if nested_scope.is_some() {\n-            continue;\n-        }\n-        if !text_range.contains_range(e.text_range()) {\n-            continue;\n-        }\n-        match e.kind() {\n-            SyntaxKind::LOOP_EXPR | SyntaxKind::WHILE_EXPR | SyntaxKind::FOR_EXPR => {\n-                if nested_loop.is_none() {\n-                    nested_loop = Some(e);\n-                }\n-            }\n-            SyntaxKind::FN\n-            | SyntaxKind::CONST\n-            | SyntaxKind::STATIC\n-            | SyntaxKind::IMPL\n-            | SyntaxKind::MODULE => {\n-                if nested_scope.is_none() {\n-                    nested_scope = Some(e);\n-                }\n+        match expr {\n+            ast::Expr::LoopExpr(_) | ast::Expr::ForExpr(_) | ast::Expr::WhileExpr(_) => {\n+                loop_depth += 1;\n             }\n-            SyntaxKind::RETURN_EXPR => {\n-                ret_expr = Some(ast::ReturnExpr::cast(e).unwrap());\n+            ast::Expr::ReturnExpr(it) => {\n+                ret_expr = Some(it);\n             }\n-            SyntaxKind::TRY_EXPR => {\n-                try_expr = Some(ast::TryExpr::cast(e).unwrap());\n+            ast::Expr::TryExpr(it) => {\n+                try_expr = Some(it);\n             }\n-            SyntaxKind::BREAK_EXPR if nested_loop.is_none() => {\n-                break_expr = Some(ast::BreakExpr::cast(e).unwrap());\n+            ast::Expr::BreakExpr(it) if loop_depth == 0 => {\n+                break_expr = Some(it);\n             }\n-            SyntaxKind::CONTINUE_EXPR if nested_loop.is_none() => {\n-                continue_expr = Some(ast::ContinueExpr::cast(e).unwrap());\n+            ast::Expr::ContinueExpr(it) if loop_depth == 0 => {\n+                continue_expr = Some(it);\n             }\n             _ => {}\n         }\n-    }\n+        false\n+    });\n \n     let kind = match (try_expr, ret_expr, break_expr, continue_expr) {\n         (Some(e), None, None, None) => {\n@@ -272,11 +248,6 @@ struct Param {\n     is_copy: bool,\n }\n \n-#[derive(Debug)]\n-struct ControlFlow {\n-    kind: Option<FlowKind>,\n-}\n-\n #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n enum ParamKind {\n     Value,\n@@ -355,6 +326,11 @@ impl Param {\n     }\n }\n \n+#[derive(Debug)]\n+struct ControlFlow {\n+    kind: Option<FlowKind>,\n+}\n+\n /// Control flow that is exported from extracted function\n ///\n /// E.g.:\n@@ -456,6 +432,7 @@ impl RetType {\n }\n \n /// Semantically same as `ast::Expr`, but preserves identity when using only part of the Block\n+/// This is the future function body, the part that is being extracted.\n #[derive(Debug)]\n enum FunctionBody {\n     Expr(ast::Expr),\n@@ -488,11 +465,7 @@ impl FunctionBody {\n             FunctionBody::Expr(expr) => Some(expr.clone()),\n             FunctionBody::Span { parent, text_range } => {\n                 let tail_expr = parent.tail_expr()?;\n-                if text_range.contains_range(tail_expr.syntax().text_range()) {\n-                    Some(tail_expr)\n-                } else {\n-                    None\n-                }\n+                text_range.contains_range(tail_expr.syntax().text_range()).then(|| tail_expr)\n             }\n         }\n     }\n@@ -520,6 +493,29 @@ impl FunctionBody {\n         }\n     }\n \n+    fn preorder_expr(&self, cb: &mut dyn FnMut(WalkEvent<ast::Expr>) -> bool) {\n+        match self {\n+            FunctionBody::Expr(expr) => expr.preorder(cb),\n+            FunctionBody::Span { parent, text_range } => {\n+                parent\n+                    .statements()\n+                    .filter(|stmt| text_range.contains_range(stmt.syntax().text_range()))\n+                    .filter_map(|stmt| match stmt {\n+                        ast::Stmt::ExprStmt(expr_stmt) => expr_stmt.expr(),\n+                        ast::Stmt::Item(_) => None,\n+                        ast::Stmt::LetStmt(stmt) => stmt.initializer(),\n+                    })\n+                    .for_each(|expr| expr.preorder(cb));\n+                if let Some(expr) = parent\n+                    .tail_expr()\n+                    .filter(|it| text_range.contains_range(it.syntax().text_range()))\n+                {\n+                    expr.preorder(cb);\n+                }\n+            }\n+        }\n+    }\n+\n     fn walk_pat(&self, cb: &mut dyn FnMut(ast::Pat)) {\n         match self {\n             FunctionBody::Expr(expr) => expr.walk_patterns(cb),\n@@ -556,15 +552,15 @@ impl FunctionBody {\n     fn text_range(&self) -> TextRange {\n         match self {\n             FunctionBody::Expr(expr) => expr.syntax().text_range(),\n-            FunctionBody::Span { parent: _, text_range } => *text_range,\n+            &FunctionBody::Span { text_range, .. } => text_range,\n         }\n     }\n \n     fn contains_range(&self, range: TextRange) -> bool {\n         self.text_range().contains_range(range)\n     }\n \n-    fn preceedes_range(&self, range: TextRange) -> bool {\n+    fn precedes_range(&self, range: TextRange) -> bool {\n         self.text_range().end() <= range.start()\n     }\n \n@@ -668,7 +664,7 @@ fn extraction_target(node: &SyntaxNode, selection_range: TextRange) -> Option<Fu\n fn analyze_body(\n     sema: &Semantics<RootDatabase>,\n     body: &FunctionBody,\n-) -> (FxIndexSet<Local>, bool, Option<(Local, ast::SelfParam)>) {\n+) -> (FxIndexSet<Local>, bool, Option<ast::SelfParam>) {\n     // FIXME: currently usages inside macros are not found\n     let mut has_await = false;\n     let mut self_param = None;\n@@ -692,7 +688,7 @@ fn analyze_body(\n                     match local_ref.source(sema.db).value {\n                         Either::Right(it) => {\n                             stdx::always!(\n-                                self_param.replace((local_ref, it)).is_none(),\n+                                self_param.replace(it).is_none(),\n                                 \"body references two different self params\"\n                             );\n                         }\n@@ -743,7 +739,7 @@ fn extracted_function_params(\n }\n \n fn has_usages_after_body(usages: &LocalUsages, body: &FunctionBody) -> bool {\n-    usages.iter().any(|reference| body.preceedes_range(reference.range))\n+    usages.iter().any(|reference| body.precedes_range(reference.range))\n }\n \n /// checks if relevant var is used with `&mut` access inside body\n@@ -828,7 +824,7 @@ impl LocalUsages {\n     }\n \n     fn iter(&self) -> impl Iterator<Item = &FileReference> + '_ {\n-        self.0.iter().flat_map(|(_, rs)| rs.iter())\n+        self.0.iter().flat_map(|(_, rs)| rs)\n     }\n }\n \n@@ -868,31 +864,59 @@ fn path_element_of_reference(\n }\n \n /// list local variables defined inside `body`\n-fn locals_defined_in_body(body: &FunctionBody, ctx: &AssistContext) -> FxIndexSet<Local> {\n+fn locals_defined_in_body(\n+    sema: &Semantics<RootDatabase>,\n+    body: &FunctionBody,\n+) -> FxIndexSet<Local> {\n     // FIXME: this doesn't work well with macros\n     //        see https://github.com/rust-analyzer/rust-analyzer/pull/7535#discussion_r570048550\n     let mut res = FxIndexSet::default();\n     body.walk_pat(&mut |pat| {\n         if let ast::Pat::IdentPat(pat) = pat {\n-            if let Some(local) = ctx.sema.to_def(&pat) {\n+            if let Some(local) = sema.to_def(&pat) {\n                 res.insert(local);\n             }\n         }\n     });\n     res\n }\n \n-/// list local variables defined inside `body` that should be returned from extracted function\n-fn vars_defined_in_body_and_outlive(\n-    ctx: &AssistContext,\n+/// Local variables defined inside `body` that are accessed outside of it\n+fn ret_values<'a>(\n+    ctx: &'a AssistContext,\n     body: &FunctionBody,\n     parent: &SyntaxNode,\n-) -> Vec<OutlivedLocal> {\n-    let vars_defined_in_body = locals_defined_in_body(body, ctx);\n-    vars_defined_in_body\n+) -> impl Iterator<Item = OutlivedLocal> + 'a {\n+    let parent = parent.clone();\n+    let range = body.text_range();\n+    locals_defined_in_body(&ctx.sema, body)\n         .into_iter()\n-        .filter_map(|var| var_outlives_body(ctx, body, var, parent))\n-        .collect()\n+        .filter_map(move |local| local_outlives_body(ctx, range, local, &parent))\n+}\n+\n+/// Returns usage details if local variable is used after(outside of) body\n+fn local_outlives_body(\n+    ctx: &AssistContext,\n+    body_range: TextRange,\n+    local: Local,\n+    parent: &SyntaxNode,\n+) -> Option<OutlivedLocal> {\n+    let usages = LocalUsages::find(ctx, local);\n+    let mut has_mut_usages = false;\n+    let mut any_outlives = false;\n+    for usage in usages.iter() {\n+        if body_range.end() <= usage.range.start() {\n+            has_mut_usages |= reference_is_exclusive(usage, parent, ctx);\n+            any_outlives |= true;\n+            if has_mut_usages {\n+                break; // no need to check more elements we have all the info we wanted\n+            }\n+        }\n+    }\n+    if !any_outlives {\n+        return None;\n+    }\n+    Some(OutlivedLocal { local, mut_usage_outside_body: has_mut_usages })\n }\n \n /// checks if the relevant local was defined before(outside of) body\n@@ -912,25 +936,6 @@ fn either_syntax(value: &Either<ast::IdentPat, ast::SelfParam>) -> &SyntaxNode {\n     }\n }\n \n-/// returns usage details if local variable is used after(outside of) body\n-fn var_outlives_body(\n-    ctx: &AssistContext,\n-    body: &FunctionBody,\n-    var: Local,\n-    parent: &SyntaxNode,\n-) -> Option<OutlivedLocal> {\n-    let usages = LocalUsages::find(ctx, var);\n-    let has_usages = usages.iter().any(|reference| body.preceedes_range(reference.range));\n-    if !has_usages {\n-        return None;\n-    }\n-    let has_mut_usages = usages\n-        .iter()\n-        .filter(|reference| body.preceedes_range(reference.range))\n-        .any(|reference| reference_is_exclusive(reference, parent, ctx));\n-    Some(OutlivedLocal { local: var, mut_usage_outside_body: has_mut_usages })\n-}\n-\n fn body_return_ty(ctx: &AssistContext, body: &FunctionBody) -> Option<RetType> {\n     match body.tail_expr() {\n         Some(expr) => {\n@@ -940,6 +945,7 @@ fn body_return_ty(ctx: &AssistContext, body: &FunctionBody) -> Option<RetType> {\n         None => Some(RetType::Stmt),\n     }\n }\n+\n /// Where to put extracted function definition\n #[derive(Debug)]\n enum Anchor {\n@@ -952,36 +958,31 @@ enum Anchor {\n /// find where to put extracted function definition\n ///\n /// Function should be put right after returned node\n-fn scope_for_fn_insertion(body: &FunctionBody, anchor: Anchor) -> Option<SyntaxNode> {\n-    match body {\n-        FunctionBody::Expr(e) => scope_for_fn_insertion_node(e.syntax(), anchor),\n-        FunctionBody::Span { parent, .. } => scope_for_fn_insertion_node(parent.syntax(), anchor),\n-    }\n-}\n-\n-fn scope_for_fn_insertion_node(node: &SyntaxNode, anchor: Anchor) -> Option<SyntaxNode> {\n+fn node_to_insert_after(body: &FunctionBody, anchor: Anchor) -> Option<SyntaxNode> {\n+    let node = match body {\n+        FunctionBody::Expr(e) => e.syntax(),\n+        FunctionBody::Span { parent, .. } => parent.syntax(),\n+    };\n     let mut ancestors = node.ancestors().peekable();\n     let mut last_ancestor = None;\n     while let Some(next_ancestor) = ancestors.next() {\n         match next_ancestor.kind() {\n             SyntaxKind::SOURCE_FILE => break,\n+            SyntaxKind::ITEM_LIST if !matches!(anchor, Anchor::Freestanding) => continue,\n             SyntaxKind::ITEM_LIST => {\n-                if !matches!(anchor, Anchor::Freestanding) {\n-                    continue;\n-                }\n                 if ancestors.peek().map(SyntaxNode::kind) == Some(SyntaxKind::MODULE) {\n                     break;\n                 }\n             }\n+            SyntaxKind::ASSOC_ITEM_LIST if !matches!(anchor, Anchor::Method) => {\n+                continue;\n+            }\n             SyntaxKind::ASSOC_ITEM_LIST => {\n-                if !matches!(anchor, Anchor::Method) {\n-                    continue;\n-                }\n                 if ancestors.peek().map(SyntaxNode::kind) == Some(SyntaxKind::IMPL) {\n                     break;\n                 }\n             }\n-            _ => {}\n+            _ => (),\n         }\n         last_ancestor = Some(next_ancestor);\n     }"}, {"sha": "5307516ecb792dae8f31586372dd65ee0be2a5b0", "filename": "crates/syntax/src/ast/expr_ext.rs", "status": "modified", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/b21f66fce37cc9c1bcd1b174acd86aa2ed9aab41/crates%2Fsyntax%2Fsrc%2Fast%2Fexpr_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21f66fce37cc9c1bcd1b174acd86aa2ed9aab41/crates%2Fsyntax%2Fsrc%2Fast%2Fexpr_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fexpr_ext.rs?ref=b21f66fce37cc9c1bcd1b174acd86aa2ed9aab41", "patch": "@@ -1,5 +1,7 @@\n //! Various extension methods to ast Expr Nodes, which are hard to code-generate.\n \n+use rowan::WalkEvent;\n+\n use crate::{\n     ast::{self, support, AstChildren, AstNode},\n     AstToken,\n@@ -34,6 +36,122 @@ impl ast::Expr {\n         }\n         None\n     }\n+\n+    /// Preorder walk all the expression's child expressions.\n+    pub fn walk(&self, cb: &mut dyn FnMut(ast::Expr)) {\n+        self.preorder(&mut |ev| {\n+            if let WalkEvent::Enter(expr) = ev {\n+                cb(expr);\n+            }\n+            false\n+        })\n+    }\n+\n+    /// Preorder walk all the expression's child expressions preserving events.\n+    /// If the callback returns true the subtree of the expression will be skipped.\n+    /// Note that the subtree may already be skipped due to the context analysis this function does.\n+    pub fn preorder(&self, cb: &mut dyn FnMut(WalkEvent<ast::Expr>) -> bool) {\n+        let mut preorder = self.syntax().preorder();\n+        while let Some(event) = preorder.next() {\n+            let node = match event {\n+                WalkEvent::Enter(node) => node,\n+                WalkEvent::Leave(node) => {\n+                    if let Some(expr) = ast::Expr::cast(node) {\n+                        cb(WalkEvent::Leave(expr));\n+                    }\n+                    continue;\n+                }\n+            };\n+            match ast::Stmt::cast(node.clone()) {\n+                // recursively walk the initializer, skipping potential const pat expressions\n+                // let statements aren't usually nested too deeply so this is fine to recurse on\n+                Some(ast::Stmt::LetStmt(l)) => {\n+                    if let Some(expr) = l.initializer() {\n+                        expr.preorder(cb);\n+                    }\n+                    preorder.skip_subtree();\n+                }\n+                // Don't skip subtree since we want to process the expression child next\n+                Some(ast::Stmt::ExprStmt(_)) => (),\n+                // skip inner items which might have their own expressions\n+                Some(ast::Stmt::Item(_)) => preorder.skip_subtree(),\n+                None => {\n+                    // skip const args, those expressions are a different context\n+                    if ast::GenericArg::can_cast(node.kind()) {\n+                        preorder.skip_subtree();\n+                    } else if let Some(expr) = ast::Expr::cast(node) {\n+                        let is_different_context = match &expr {\n+                            ast::Expr::EffectExpr(effect) => {\n+                                matches!(\n+                                    effect.effect(),\n+                                    ast::Effect::Async(_)\n+                                        | ast::Effect::Try(_)\n+                                        | ast::Effect::Const(_)\n+                                )\n+                            }\n+                            ast::Expr::ClosureExpr(_) => true,\n+                            _ => false,\n+                        };\n+                        let skip = cb(WalkEvent::Enter(expr));\n+                        if skip || is_different_context {\n+                            preorder.skip_subtree();\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Preorder walk all the expression's child patterns.\n+    pub fn walk_patterns(&self, cb: &mut dyn FnMut(ast::Pat)) {\n+        let mut preorder = self.syntax().preorder();\n+        while let Some(event) = preorder.next() {\n+            let node = match event {\n+                WalkEvent::Enter(node) => node,\n+                WalkEvent::Leave(_) => continue,\n+            };\n+            match ast::Stmt::cast(node.clone()) {\n+                Some(ast::Stmt::LetStmt(l)) => {\n+                    if let Some(pat) = l.pat() {\n+                        pat.walk(cb);\n+                    }\n+                    if let Some(expr) = l.initializer() {\n+                        expr.walk_patterns(cb);\n+                    }\n+                    preorder.skip_subtree();\n+                }\n+                // Don't skip subtree since we want to process the expression child next\n+                Some(ast::Stmt::ExprStmt(_)) => (),\n+                // skip inner items which might have their own patterns\n+                Some(ast::Stmt::Item(_)) => preorder.skip_subtree(),\n+                None => {\n+                    // skip const args, those are a different context\n+                    if ast::GenericArg::can_cast(node.kind()) {\n+                        preorder.skip_subtree();\n+                    } else if let Some(expr) = ast::Expr::cast(node.clone()) {\n+                        let is_different_context = match &expr {\n+                            ast::Expr::EffectExpr(effect) => {\n+                                matches!(\n+                                    effect.effect(),\n+                                    ast::Effect::Async(_)\n+                                        | ast::Effect::Try(_)\n+                                        | ast::Effect::Const(_)\n+                                )\n+                            }\n+                            ast::Expr::ClosureExpr(_) => true,\n+                            _ => false,\n+                        };\n+                        if is_different_context {\n+                            preorder.skip_subtree();\n+                        }\n+                    } else if let Some(pat) = ast::Pat::cast(node) {\n+                        preorder.skip_subtree();\n+                        pat.walk(cb);\n+                    }\n+                }\n+            }\n+        }\n+    }\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]"}, {"sha": "ea156087fff47bdda5091b5684702cb1a8e90281", "filename": "crates/syntax/src/ast/node_ext.rs", "status": "modified", "additions": 0, "deletions": 101, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/b21f66fce37cc9c1bcd1b174acd86aa2ed9aab41/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21f66fce37cc9c1bcd1b174acd86aa2ed9aab41/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs?ref=b21f66fce37cc9c1bcd1b174acd86aa2ed9aab41", "patch": "@@ -55,107 +55,6 @@ impl ast::BlockExpr {\n     }\n }\n \n-impl ast::Expr {\n-    /// Preorder walk all the expression's child expressions.\n-    pub fn walk(&self, cb: &mut dyn FnMut(ast::Expr)) {\n-        let mut preorder = self.syntax().preorder();\n-        while let Some(event) = preorder.next() {\n-            let node = match event {\n-                WalkEvent::Enter(node) => node,\n-                WalkEvent::Leave(_) => continue,\n-            };\n-            match ast::Stmt::cast(node.clone()) {\n-                // recursively walk the initializer, skipping potential const pat expressions\n-                // let statements aren't usually nested too deeply so this is fine to recurse on\n-                Some(ast::Stmt::LetStmt(l)) => {\n-                    if let Some(expr) = l.initializer() {\n-                        expr.walk(cb);\n-                    }\n-                    preorder.skip_subtree();\n-                }\n-                // Don't skip subtree since we want to process the expression child next\n-                Some(ast::Stmt::ExprStmt(_)) => (),\n-                // skip inner items which might have their own expressions\n-                Some(ast::Stmt::Item(_)) => preorder.skip_subtree(),\n-                None => {\n-                    // skip const args, those expressions are a different context\n-                    if ast::GenericArg::can_cast(node.kind()) {\n-                        preorder.skip_subtree();\n-                    } else if let Some(expr) = ast::Expr::cast(node) {\n-                        let is_different_context = match &expr {\n-                            ast::Expr::EffectExpr(effect) => {\n-                                matches!(\n-                                    effect.effect(),\n-                                    ast::Effect::Async(_)\n-                                        | ast::Effect::Try(_)\n-                                        | ast::Effect::Const(_)\n-                                )\n-                            }\n-                            ast::Expr::ClosureExpr(_) => true,\n-                            _ => false,\n-                        };\n-                        cb(expr);\n-                        if is_different_context {\n-                            preorder.skip_subtree();\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    /// Preorder walk all the expression's child patterns.\n-    pub fn walk_patterns(&self, cb: &mut dyn FnMut(ast::Pat)) {\n-        let mut preorder = self.syntax().preorder();\n-        while let Some(event) = preorder.next() {\n-            let node = match event {\n-                WalkEvent::Enter(node) => node,\n-                WalkEvent::Leave(_) => continue,\n-            };\n-            match ast::Stmt::cast(node.clone()) {\n-                Some(ast::Stmt::LetStmt(l)) => {\n-                    if let Some(pat) = l.pat() {\n-                        pat.walk(cb);\n-                    }\n-                    if let Some(expr) = l.initializer() {\n-                        expr.walk_patterns(cb);\n-                    }\n-                    preorder.skip_subtree();\n-                }\n-                // Don't skip subtree since we want to process the expression child next\n-                Some(ast::Stmt::ExprStmt(_)) => (),\n-                // skip inner items which might have their own patterns\n-                Some(ast::Stmt::Item(_)) => preorder.skip_subtree(),\n-                None => {\n-                    // skip const args, those are a different context\n-                    if ast::GenericArg::can_cast(node.kind()) {\n-                        preorder.skip_subtree();\n-                    } else if let Some(expr) = ast::Expr::cast(node.clone()) {\n-                        let is_different_context = match &expr {\n-                            ast::Expr::EffectExpr(effect) => {\n-                                matches!(\n-                                    effect.effect(),\n-                                    ast::Effect::Async(_)\n-                                        | ast::Effect::Try(_)\n-                                        | ast::Effect::Const(_)\n-                                )\n-                            }\n-                            ast::Expr::ClosureExpr(_) => true,\n-                            _ => false,\n-                        };\n-                        if is_different_context {\n-                            preorder.skip_subtree();\n-                        }\n-                    } else if let Some(pat) = ast::Pat::cast(node) {\n-                        preorder.skip_subtree();\n-                        pat.walk(cb);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n impl ast::Pat {\n     /// Preorder walk all the pattern's sub patterns.\n     pub fn walk(&self, cb: &mut dyn FnMut(ast::Pat)) {"}]}