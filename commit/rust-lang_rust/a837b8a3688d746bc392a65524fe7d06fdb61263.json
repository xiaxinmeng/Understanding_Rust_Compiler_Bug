{"sha": "a837b8a3688d746bc392a65524fe7d06fdb61263", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4MzdiOGEzNjg4ZDc0NmJjMzkyYTY1NTI0ZmU3ZDA2ZmRiNjEyNjM=", "commit": {"author": {"name": "Saleem Jaffer", "email": "saleem@acko.com", "date": "2019-03-17T05:42:39Z"}, "committer": {"name": "Saleem Jaffer", "email": "saleem@acko.com", "date": "2019-03-18T09:33:30Z"}, "message": "cleaner code as per review", "tree": {"sha": "cb95074cbe494328789114efd838598af29a8bc5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cb95074cbe494328789114efd838598af29a8bc5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a837b8a3688d746bc392a65524fe7d06fdb61263", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a837b8a3688d746bc392a65524fe7d06fdb61263", "html_url": "https://github.com/rust-lang/rust/commit/a837b8a3688d746bc392a65524fe7d06fdb61263", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a837b8a3688d746bc392a65524fe7d06fdb61263/comments", "author": null, "committer": null, "parents": [{"sha": "7fb1c22da181426f6ea7662f5c7f47edbbe24f56", "url": "https://api.github.com/repos/rust-lang/rust/commits/7fb1c22da181426f6ea7662f5c7f47edbbe24f56", "html_url": "https://github.com/rust-lang/rust/commit/7fb1c22da181426f6ea7662f5c7f47edbbe24f56"}], "stats": {"total": 369, "additions": 158, "deletions": 211}, "files": [{"sha": "6761c70550ec81525c50ad10b4ea4c2ebb677deb", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a837b8a3688d746bc392a65524fe7d06fdb61263/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a837b8a3688d746bc392a65524fe7d06fdb61263/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=a837b8a3688d746bc392a65524fe7d06fdb61263", "patch": "@@ -737,16 +737,6 @@ macro_rules! make_mir_visitor {\n                         self.visit_local(local, context, location);\n                     }\n                     Place::Base(PlaceBase::Static(static_)) => {\n-                        match static_.promoted {\n-                            None => {\n-                                self.visit_static(static_, context, location);\n-                            }\n-                            Some(_) => {\n-                                self.visit_ty(\n-                                    & $($mutability)? static_.ty, TyContext::Location(location)\n-                                );\n-                            }\n-                        }\n                         self.visit_static(static_, context, location);\n                     }\n                     Place::Projection(proj) => {"}, {"sha": "b9877945e7eac775ddd5a8865b616142bc8b6d6d", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a837b8a3688d746bc392a65524fe7d06fdb61263/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a837b8a3688d746bc392a65524fe7d06fdb61263/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=a837b8a3688d746bc392a65524fe7d06fdb61263", "patch": "@@ -1602,13 +1602,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 self.append_local_to_string(local, buf)?;\n             }\n             Place::Base(PlaceBase::Static(ref static_)) => {\n-                match static_.promoted {\n-                    Some(_) => {\n-                        buf.push_str(\"promoted\");\n-                    }\n-                    None => {\n-                        buf.push_str(&self.infcx.tcx.item_name(static_.def_id).to_string());\n-                    }\n+                if static_.promoted.is_some() {\n+                    buf.push_str(\"promoted\");\n+                } else {\n+                    buf.push_str(&self.infcx.tcx.item_name(static_.def_id).to_string());\n                 }\n             }\n             Place::Projection(ref proj) => {"}, {"sha": "e92ed1f2c7caa0d89e27a7c4e50edc40a169750e", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 10, "deletions": 25, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a837b8a3688d746bc392a65524fe7d06fdb61263/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a837b8a3688d746bc392a65524fe7d06fdb61263/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=a837b8a3688d746bc392a65524fe7d06fdb61263", "patch": "@@ -1309,15 +1309,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         // FIXME: allow thread-locals to borrow other thread locals?\n         let (might_be_alive, will_be_dropped) = match root_place {\n             Place::Base(PlaceBase::Static(st)) => {\n-                match st.promoted {\n-                    None => {\n-                        // Thread-locals might be dropped after the function exits, but\n-                        // \"true\" statics will never be.\n-                        let is_thread_local = self.is_place_thread_local(&root_place);\n-                        (true, is_thread_local)\n-                    }\n-                    Some(_) => (true, false),\n-                }\n+                (true, st.promoted.is_none() && self.is_place_thread_local(&root_place))\n             }\n             Place::Base(PlaceBase::Local(_)) => {\n                 // Locals are always dropped at function exit, and if they\n@@ -1990,28 +1982,21 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             }\n             // The rules for promotion are made by `qualify_consts`, there wouldn't even be a\n             // `Place::Promoted` if the promotion weren't 100% legal. So we just forward this\n-//            Place::Base(PlaceBase::Promoted(_)) => Ok(RootPlace {\n-//                place,\n-//                is_local_mutation_allowed,\n-//            }),\n             Place::Base(PlaceBase::Static(ref static_)) => {\n-                match static_.promoted {\n-                    Some(_) => {\n+                if static_.promoted.is_some() {\n+                    Ok(RootPlace {\n+                        place,\n+                        is_local_mutation_allowed,\n+                    })\n+                } else {\n+                    if self.infcx.tcx.is_static(static_.def_id) != Some(hir::Mutability::MutMutable) {\n+                        Err(place)\n+                    } else {\n                         Ok(RootPlace {\n                             place,\n                             is_local_mutation_allowed,\n                         })\n                     }\n-                    None => {\n-                        if self.infcx.tcx.is_static(static_.def_id) != Some(hir::Mutability::MutMutable) {\n-                            Err(place)\n-                        } else {\n-                            Ok(RootPlace {\n-                                place,\n-                                is_local_mutation_allowed,\n-                            })\n-                        }\n-                    }\n                 }\n             }\n             Place::Projection(ref proj) => {"}, {"sha": "2661d765718dda4b8a66a9391b0c54db8d672345", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a837b8a3688d746bc392a65524fe7d06fdb61263/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a837b8a3688d746bc392a65524fe7d06fdb61263/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=a837b8a3688d746bc392a65524fe7d06fdb61263", "patch": "@@ -130,18 +130,14 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n             }\n \n             Place::Base(PlaceBase::Static(box Static { def_id, ty: _, promoted })) => {\n-                match promoted {\n-                    Some(_) => unreachable!(),\n-                    None => {\n-                        if let Place::Base(PlaceBase::Static(_)) = access_place {\n-                            item_msg = format!(\"immutable static item `{}`\", access_place_desc.unwrap());\n-                            reason = String::new();\n-                        } else {\n-                            item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n-                            let static_name = &self.infcx.tcx.item_name(*def_id);\n-                            reason = format!(\", as `{}` is an immutable static item\", static_name);\n-                        }\n-                    }\n+                assert!(promoted.is_none());\n+                if let Place::Base(PlaceBase::Static(_)) = access_place {\n+                    item_msg = format!(\"immutable static item `{}`\", access_place_desc.unwrap());\n+                    reason = String::new();\n+                } else {\n+                    item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n+                    let static_name = &self.infcx.tcx.item_name(*def_id);\n+                    reason = format!(\", as `{}` is an immutable static item\", static_name);\n                 }\n             }\n "}, {"sha": "c2efd3625c32bef756cb7443f83f3f2d149864df", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a837b8a3688d746bc392a65524fe7d06fdb61263/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a837b8a3688d746bc392a65524fe7d06fdb61263/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=a837b8a3688d746bc392a65524fe7d06fdb61263", "patch": "@@ -454,10 +454,9 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                 ty: self.mir.local_decls[index].ty,\n             },\n             Place::Base(PlaceBase::Static(box Static { def_id, ty: sty, promoted })) => {\n+                let sty = self.sanitize_type(place, sty);\n                 match promoted {\n                     Some(pr) => {\n-                        let sty = self.sanitize_type(place, sty);\n-\n                         if !self.errors_reported {\n                             let promoted_mir = &self.mir.promoted[pr];\n                             self.sanitize_promoted(promoted_mir, location);\n@@ -480,15 +479,18 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                                 );\n                             };\n                         }\n-                        PlaceTy::Ty { ty: sty }\n                     }\n                     None => {\n-                        let sty = self.sanitize_type(place, sty);\n                         let ty = self.tcx().type_of(def_id);\n                         let ty = self.cx.normalize(ty, location);\n                         if let Err(terr) =\n                             self.cx\n-                                .eq_types(ty, sty, location.to_locations(), ConstraintCategory::Boring)\n+                                .eq_types(\n+                                    ty,\n+                                    sty,\n+                                    location.to_locations(),\n+                                    ConstraintCategory::Boring\n+                                )\n                         {\n                             span_mirbug!(\n                                 self,\n@@ -498,10 +500,10 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                                 sty,\n                                 terr\n                             );\n-                        }\n-                        PlaceTy::Ty { ty: sty }\n+                        };\n                     }\n                 }\n+                PlaceTy::Ty { ty: sty }\n             }\n             Place::Projection(ref proj) => {\n                 let base_context = if context.is_mutating_use() {"}, {"sha": "5e691db0a2e4e754ba7eab9f011917cca5f83b11", "filename": "src/librustc_mir/borrow_check/place_ext.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a837b8a3688d746bc392a65524fe7d06fdb61263/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a837b8a3688d746bc392a65524fe7d06fdb61263/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs?ref=a837b8a3688d746bc392a65524fe7d06fdb61263", "patch": "@@ -50,11 +50,10 @@ impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n                 }\n             }\n             Place::Base(PlaceBase::Static(static_)) => {\n-                match static_.promoted {\n-                    Some(_) => false,\n-                    None => {\n-                        tcx.is_static(static_.def_id) == Some(hir::Mutability::MutMutable)\n-                    }\n+                if static_.promoted.is_none() {\n+                    tcx.is_static(static_.def_id) == Some(hir::Mutability::MutMutable)\n+                } else {\n+                    false\n                 }\n             }\n             Place::Projection(proj) => match proj.elem {"}, {"sha": "c4f9df0cfe57961b97defca6bf3b5037ed952ddd", "filename": "src/librustc_mir/borrow_check/places_conflict.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a837b8a3688d746bc392a65524fe7d06fdb61263/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a837b8a3688d746bc392a65524fe7d06fdb61263/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs?ref=a837b8a3688d746bc392a65524fe7d06fdb61263", "patch": "@@ -387,7 +387,7 @@ fn place_element_conflict<'a, 'gcx: 'tcx, 'tcx>(\n                 },\n                 (Some(p1), Some(p2)) => {\n                     if p1 == p2 {\n-                        if let ty::Array(_, size) =s1.ty.sty {\n+                        if let ty::Array(_, size) = s1.ty.sty {\n                             if size.unwrap_usize(tcx) == 0 {\n                                 // Ignore conflicts with promoted [T; 0].\n                                 debug!(\"place_element_conflict: IGNORE-LEN-0-PROMOTED\");\n@@ -404,7 +404,7 @@ fn place_element_conflict<'a, 'gcx: 'tcx, 'tcx>(\n                     }\n                 },\n                 (p1_, p2_) => {\n-                    debug!(\"place_element_conflict: DISJOINT-STATIC-LOCAL-PROMOTED\");\n+                    debug!(\"place_element_conflict: DISJOINT-STATIC-PROMOTED\");\n                     Overlap::Disjoint\n                 }\n             }"}, {"sha": "7adcb118f843c3c7ab64a57645638063999571e6", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 30, "deletions": 32, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/a837b8a3688d746bc392a65524fe7d06fdb61263/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a837b8a3688d746bc392a65524fe7d06fdb61263/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=a837b8a3688d746bc392a65524fe7d06fdb61263", "patch": "@@ -582,39 +582,37 @@ where\n     ) -> EvalResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         use rustc::mir::Place::*;\n         use rustc::mir::PlaceBase;\n+        use rustc::mir::Static;\n         Ok(match *mir_place {\n-            Base(PlaceBase::Static(ref static_)) => {\n-                match static_.promoted {\n-                    Some(promoted) => {\n-                        let instance = self.frame().instance;\n-                        self.const_eval_raw(GlobalId {\n-                            instance,\n-                            promoted: Some(promoted),\n-                        })?\n-                    }\n-                    None => {\n-                        assert!(!static_.ty.needs_subst());\n-                        let layout = self.layout_of(static_.ty)?;\n-                        let instance = ty::Instance::mono(*self.tcx, static_.def_id);\n-                        let cid = GlobalId {\n-                            instance,\n-                            promoted: None\n-                        };\n-                        // Just create a lazy reference, so we can support recursive statics.\n-                        // tcx takes are of assigning every static one and only one unique AllocId.\n-                        // When the data here is ever actually used, memory will notice,\n-                        // and it knows how to deal with alloc_id that are present in the\n-                        // global table but not in its local memory: It calls back into tcx through\n-                        // a query, triggering the CTFE machinery to actually turn this lazy reference\n-                        // into a bunch of bytes.  IOW, statics are evaluated with CTFE even when\n-                        // this EvalContext uses another Machine (e.g., in miri).  This is what we\n-                        // want!  This way, computing statics works concistently between codegen\n-                        // and miri: They use the same query to eventually obtain a `ty::Const`\n-                        // and use that for further computation.\n-                        let alloc = self.tcx.alloc_map.lock().intern_static(cid.instance.def_id());\n-                        MPlaceTy::from_aligned_ptr(Pointer::from(alloc).with_default_tag(), layout)\n-                    }\n-                }\n+            Base(PlaceBase::Static(box Static {promoted: Some(promoted), ty, ..})) => {\n+                let instance = self.frame().instance;\n+                self.const_eval_raw(GlobalId {\n+                    instance,\n+                    promoted: Some(promoted),\n+                })?\n+            }\n+\n+            Base(PlaceBase::Static(box Static {promoted: None, ty, def_id})) => {\n+                assert!(!ty.needs_subst());\n+                let layout = self.layout_of(ty)?;\n+                let instance = ty::Instance::mono(*self.tcx, def_id);\n+                let cid = GlobalId {\n+                    instance,\n+                    promoted: None\n+                };\n+                // Just create a lazy reference, so we can support recursive statics.\n+                // tcx takes are of assigning every static one and only one unique AllocId.\n+                // When the data here is ever actually used, memory will notice,\n+                // and it knows how to deal with alloc_id that are present in the\n+                // global table but not in its local memory: It calls back into tcx through\n+                // a query, triggering the CTFE machinery to actually turn this lazy reference\n+                // into a bunch of bytes.  IOW, statics are evaluated with CTFE even when\n+                // this EvalContext uses another Machine (e.g., in miri).  This is what we\n+                // want!  This way, computing statics works concistently between codegen\n+                // and miri: They use the same query to eventually obtain a `ty::Const`\n+                // and use that for further computation.\n+                let alloc = self.tcx.alloc_map.lock().intern_static(cid.instance.def_id());\n+                MPlaceTy::from_aligned_ptr(Pointer::from(alloc).with_default_tag(), layout)\n             }\n \n             _ => bug!(\"eval_place_to_mplace called on {:?}\", mir_place),"}, {"sha": "2ebe28e6ac091ee1b5af869fece9951c997e1b6d", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 21, "deletions": 26, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/a837b8a3688d746bc392a65524fe7d06fdb61263/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a837b8a3688d746bc392a65524fe7d06fdb61263/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=a837b8a3688d746bc392a65524fe7d06fdb61263", "patch": "@@ -301,32 +301,27 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                 // locals are safe\n             }\n             &Place::Base(PlaceBase::Static(box Static { def_id, ty: _, promoted })) => {\n-                match promoted {\n-                    Some(..) => {\n-                        bug!(\"unsafety checking should happen before promotion\")\n-                    }\n-                    None => {\n-                        if self.tcx.is_static(def_id) == Some(hir::Mutability::MutMutable) {\n-                            self.require_unsafe(\"use of mutable static\",\n-                                \"mutable statics can be mutated by multiple threads: aliasing violations \\\n-                                 or data races will cause undefined behavior\",\n-                                 UnsafetyViolationKind::General);\n-                        } else if self.tcx.is_foreign_item(def_id) {\n-                            let source_info = self.source_info;\n-                            let lint_root =\n-                                self.source_scope_local_data[source_info.scope].lint_root;\n-                            self.register_violations(&[UnsafetyViolation {\n-                                source_info,\n-                                description: Symbol::intern(\"use of extern static\").as_interned_str(),\n-                                details:\n-                                    Symbol::intern(\"extern statics are not controlled by the Rust type \\\n-                                                    system: invalid data, aliasing violations or data \\\n-                                                    races will cause undefined behavior\")\n-                                        .as_interned_str(),\n-                                kind: UnsafetyViolationKind::ExternStatic(lint_root)\n-                            }], &[]);\n-                        }\n-                    }\n+                assert!(promoted.is_none(), \"unsafety checking should happen before promotion\");\n+\n+                if self.tcx.is_static(def_id) == Some(hir::Mutability::MutMutable) {\n+                    self.require_unsafe(\"use of mutable static\",\n+                        \"mutable statics can be mutated by multiple threads: aliasing violations \\\n+                         or data races will cause undefined behavior\",\n+                         UnsafetyViolationKind::General);\n+                } else if self.tcx.is_foreign_item(def_id) {\n+                    let source_info = self.source_info;\n+                    let lint_root =\n+                        self.source_scope_local_data[source_info.scope].lint_root;\n+                    self.register_violations(&[UnsafetyViolation {\n+                        source_info,\n+                        description: Symbol::intern(\"use of extern static\").as_interned_str(),\n+                        details:\n+                            Symbol::intern(\"extern statics are not controlled by the Rust type \\\n+                                            system: invalid data, aliasing violations or data \\\n+                                            races will cause undefined behavior\")\n+                                .as_interned_str(),\n+                        kind: UnsafetyViolationKind::ExternStatic(lint_root)\n+                    }], &[]);\n                 }\n             }\n         };"}, {"sha": "3ee26e7dd26d98a0c638ef050aaf6af7906308d3", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 19, "deletions": 24, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/a837b8a3688d746bc392a65524fe7d06fdb61263/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a837b8a3688d746bc392a65524fe7d06fdb61263/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=a837b8a3688d746bc392a65524fe7d06fdb61263", "patch": "@@ -266,6 +266,7 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n     }\n \n     fn eval_place(&mut self, place: &Place<'tcx>, source_info: SourceInfo) -> Option<Const<'tcx>> {\n+        use rustc::mir::Static;\n         match *place {\n             Place::Base(PlaceBase::Local(loc)) => self.places[loc].clone(),\n             Place::Projection(ref proj) => match proj.elem {\n@@ -282,31 +283,25 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n                 // an `Index` projection would throw us off-track.\n                 _ => None,\n             },\n-            Place::Base(PlaceBase::Static(ref static_)) => {\n-                match static_.promoted {\n-                    Some(promoted) => {\n-                        let generics = self.tcx.generics_of(self.source.def_id());\n-                        if generics.requires_monomorphization(self.tcx) {\n-                            // FIXME: can't handle code with generics\n-                            return None;\n-                        }\n-                        let substs = InternalSubsts::identity_for_item(self.tcx, self.source.def_id());\n-                        let instance = Instance::new(self.source.def_id(), substs);\n-                        let cid = GlobalId {\n-                            instance,\n-                            promoted: Some(promoted),\n-                        };\n-                        // cannot use `const_eval` here, because that would require having the MIR\n-                        // for the current function available, but we're producing said MIR right now\n-                        let res = self.use_ecx(source_info, |this| {\n-                            eval_promoted(this.tcx, cid, this.mir, this.param_env)\n-                        })?;\n-                        trace!(\"evaluated promoted {:?} to {:?}\", promoted, res);\n-                        Some((res.into(), source_info.span))\n-                    }\n-                    None => None\n+            Place::Base(PlaceBase::Static(box Static {promoted: Some(promoted), ty, ..})) => {\n+                let generics = self.tcx.generics_of(self.source.def_id());\n+                if generics.requires_monomorphization(self.tcx) {\n+                    // FIXME: can't handle code with generics\n+                    return None;\n                 }\n-\n+                let substs = InternalSubsts::identity_for_item(self.tcx, self.source.def_id());\n+                let instance = Instance::new(self.source.def_id(), substs);\n+                let cid = GlobalId {\n+                    instance,\n+                    promoted: Some(promoted),\n+                };\n+                // cannot use `const_eval` here, because that would require having the MIR\n+                // for the current function available, but we're producing said MIR right now\n+                let res = self.use_ecx(source_info, |this| {\n+                    eval_promoted(this.tcx, cid, this.mir, this.param_env)\n+                })?;\n+                trace!(\"evaluated promoted {:?} to {:?}\", promoted, res);\n+                Some((res.into(), source_info.span))\n             },\n             _ => None,\n         }"}, {"sha": "9cbb891316dca07ef34db0bc7f764892c5599b79", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 51, "deletions": 61, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/a837b8a3688d746bc392a65524fe7d06fdb61263/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a837b8a3688d746bc392a65524fe7d06fdb61263/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=a837b8a3688d746bc392a65524fe7d06fdb61263", "patch": "@@ -189,10 +189,8 @@ trait Qualif {\n         match *place {\n             Place::Base(PlaceBase::Local(local)) => Self::in_local(cx, local),\n             Place::Base(PlaceBase::Static(ref static_)) => {\n-                match static_.promoted {\n-                    Some(..) => bug!(\"qualifying already promoted MIR\"),\n-                    None => Self::in_static(cx, static_),\n-                 }\n+                assert!(static_.promoted.is_none(), \"qualifying already promoted MIR\");\n+                Self::in_static(cx, static_)\n             },\n             Place::Projection(ref proj) => Self::in_projection(cx, proj),\n         }\n@@ -773,19 +771,15 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n                     dest = &proj.base;\n                 },\n                 Place::Base(PlaceBase::Static(st)) => {\n-                    match st.promoted {\n-                        Some(..) => bug!(\"promoteds don't exist yet during promotion\"),\n-                        None => {\n-                            // Catch more errors in the destination. `visit_place` also checks that we\n-                            // do not try to access statics from constants or try to mutate statics\n-                            self.visit_place(\n-                                dest,\n-                                PlaceContext::MutatingUse(MutatingUseContext::Store),\n-                                location\n-                            );\n-                            return;\n-                        }\n-                    }\n+                    assert!(st.promoted.is_none(), \"promoteds don't exist yet during promotion\");\n+                    // Catch more errors in the destination. `visit_place` also checks that we\n+                    // do not try to access statics from constants or try to mutate statics\n+                    self.visit_place(\n+                        dest,\n+                        PlaceContext::MutatingUse(MutatingUseContext::Store),\n+                        location\n+                    );\n+                    return;\n                 }\n             }\n         };\n@@ -928,53 +922,49 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n         match *place {\n             Place::Base(PlaceBase::Local(_)) => {}\n             Place::Base(PlaceBase::Static(ref global)) => {\n-                match global.promoted {\n-                    Some(..) => {}\n-                    None => {\n-                        if self.tcx\n-                               .get_attrs(global.def_id)\n-                               .iter()\n-                               .any(|attr| attr.check_name(\"thread_local\")) {\n-                            if self.mode != Mode::Fn {\n-                                span_err!(self.tcx.sess, self.span, E0625,\n-                                          \"thread-local statics cannot be \\\n-                                           accessed at compile-time\");\n-                            }\n-                            return;\n-                        }\n+                assert!(global.promoted.is_none(), {});\n+                if self.tcx\n+                       .get_attrs(global.def_id)\n+                       .iter()\n+                       .any(|attr| attr.check_name(\"thread_local\")) {\n+                    if self.mode != Mode::Fn {\n+                        span_err!(self.tcx.sess, self.span, E0625,\n+                                  \"thread-local statics cannot be \\\n+                                   accessed at compile-time\");\n+                    }\n+                    return;\n+                }\n \n-                        // Only allow statics (not consts) to refer to other statics.\n-                        if self.mode == Mode::Static || self.mode == Mode::StaticMut {\n-                            if self.mode == Mode::Static && context.is_mutating_use() {\n-                                // this is not strictly necessary as miri will also bail out\n-                                // For interior mutability we can't really catch this statically as that\n-                                // goes through raw pointers and intermediate temporaries, so miri has\n-                                // to catch this anyway\n-                                self.tcx.sess.span_err(\n-                                    self.span,\n-                                    \"cannot mutate statics in the initializer of another static\",\n-                                );\n-                            }\n-                            return;\n-                        }\n-                        unleash_miri!(self);\n+                // Only allow statics (not consts) to refer to other statics.\n+                if self.mode == Mode::Static || self.mode == Mode::StaticMut {\n+                    if self.mode == Mode::Static && context.is_mutating_use() {\n+                        // this is not strictly necessary as miri will also bail out\n+                        // For interior mutability we can't really catch this statically as that\n+                        // goes through raw pointers and intermediate temporaries, so miri has\n+                        // to catch this anyway\n+                        self.tcx.sess.span_err(\n+                            self.span,\n+                            \"cannot mutate statics in the initializer of another static\",\n+                        );\n+                    }\n+                    return;\n+                }\n+                unleash_miri!(self);\n \n-                        if self.mode != Mode::Fn {\n-                            let mut err = struct_span_err!(self.tcx.sess, self.span, E0013,\n-                                                           \"{}s cannot refer to statics, use \\\n-                                                            a constant instead\", self.mode);\n-                            if self.tcx.sess.teach(&err.get_code().unwrap()) {\n-                                err.note(\n-                                    \"Static and const variables can refer to other const variables. But a \\\n-                                     const variable cannot refer to a static variable.\"\n-                                );\n-                                err.help(\n-                                    \"To fix this, the value can be extracted as a const and then used.\"\n-                                );\n-                            }\n-                            err.emit()\n-                        }\n+                if self.mode != Mode::Fn {\n+                    let mut err = struct_span_err!(self.tcx.sess, self.span, E0013,\n+                                                   \"{}s cannot refer to statics, use \\\n+                                                    a constant instead\", self.mode);\n+                    if self.tcx.sess.teach(&err.get_code().unwrap()) {\n+                        err.note(\n+                            \"Static and const variables can refer to other const variables. But a \\\n+                             const variable cannot refer to a static variable.\"\n+                        );\n+                        err.help(\n+                            \"To fix this, the value can be extracted as a const and then used.\"\n+                        );\n                     }\n+                    err.emit()\n                 }\n             }\n             Place::Projection(ref proj) => {"}]}