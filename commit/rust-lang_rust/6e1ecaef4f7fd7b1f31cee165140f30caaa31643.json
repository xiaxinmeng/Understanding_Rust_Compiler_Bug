{"sha": "6e1ecaef4f7fd7b1f31cee165140f30caaa31643", "node_id": "C_kwDOAAsO6NoAKDZlMWVjYWVmNGY3ZmQ3YjFmMzFjZWUxNjUxNDBmMzBjYWFhMzE2NDM", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-11-17T14:30:12Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-11-17T14:54:38Z"}, "message": "Simplify", "tree": {"sha": "21fea72bcaf943804d17d4e018dc5b7fc37d91ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/21fea72bcaf943804d17d4e018dc5b7fc37d91ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e1ecaef4f7fd7b1f31cee165140f30caaa31643", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e1ecaef4f7fd7b1f31cee165140f30caaa31643", "html_url": "https://github.com/rust-lang/rust/commit/6e1ecaef4f7fd7b1f31cee165140f30caaa31643", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e1ecaef4f7fd7b1f31cee165140f30caaa31643/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f1e26c3f9804eaaf2941feaa140d6f8c6d8c562", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f1e26c3f9804eaaf2941feaa140d6f8c6d8c562", "html_url": "https://github.com/rust-lang/rust/commit/9f1e26c3f9804eaaf2941feaa140d6f8c6d8c562"}], "stats": {"total": 103, "additions": 48, "deletions": 55}, "files": [{"sha": "d2c0175982d546a1191e17173f4a6a97f1244f3b", "filename": "crates/hir_def/src/nameres/collector.rs", "status": "modified", "additions": 48, "deletions": 55, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/6e1ecaef4f7fd7b1f31cee165140f30caaa31643/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e1ecaef4f7fd7b1f31cee165140f30caaa31643/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=6e1ecaef4f7fd7b1f31cee165140f30caaa31643", "patch": "@@ -21,7 +21,7 @@ use itertools::Itertools;\n use la_arena::Idx;\n use limit::Limit;\n use rustc_hash::{FxHashMap, FxHashSet};\n-use syntax::ast;\n+use syntax::{ast, SmolStr};\n \n use crate::{\n     attr::{Attr, AttrId, AttrInput, Attrs},\n@@ -94,7 +94,6 @@ pub(super) fn collect_defs(\n         glob_imports: FxHashMap::default(),\n         unresolved_imports: Vec::new(),\n         resolved_imports: Vec::new(),\n-\n         unresolved_macros: Vec::new(),\n         mod_dirs: FxHashMap::default(),\n         cfg_options,\n@@ -107,12 +106,8 @@ pub(super) fn collect_defs(\n         registered_tools: Default::default(),\n     };\n     match block {\n-        Some(block) => {\n-            collector.seed_with_inner(block);\n-        }\n-        None => {\n-            collector.seed_with_top_level();\n-        }\n+        Some(block) => collector.seed_with_inner(block),\n+        None => collector.seed_with_top_level(),\n     }\n     collector.collect();\n     let mut def_map = collector.finish();\n@@ -126,16 +121,15 @@ enum PartialResolvedImport {\n     Unresolved,\n     /// One of namespaces is resolved\n     Indeterminate(PerNs),\n-    /// All namespaces are resolved, OR it is came from other crate\n+    /// All namespaces are resolved, OR it comes from other crate\n     Resolved(PerNs),\n }\n \n impl PartialResolvedImport {\n-    fn namespaces(&self) -> PerNs {\n+    fn namespaces(self) -> PerNs {\n         match self {\n             PartialResolvedImport::Unresolved => PerNs::none(),\n-            PartialResolvedImport::Indeterminate(ns) => *ns,\n-            PartialResolvedImport::Resolved(ns) => *ns,\n+            PartialResolvedImport::Indeterminate(ns) | PartialResolvedImport::Resolved(ns) => ns,\n         }\n     }\n }\n@@ -268,9 +262,9 @@ struct DefCollector<'a> {\n     /// attributes.\n     derive_helpers_in_scope: FxHashMap<AstId<ast::Item>, Vec<Name>>,\n     /// Custom attributes registered with `#![register_attr]`.\n-    registered_attrs: Vec<String>,\n+    registered_attrs: Vec<SmolStr>,\n     /// Custom tool modules registered with `#![register_tool]`.\n-    registered_tools: Vec<String>,\n+    registered_tools: Vec<SmolStr>,\n }\n \n impl DefCollector<'_> {\n@@ -292,31 +286,31 @@ impl DefCollector<'_> {\n                     None => continue,\n                 };\n \n-                let registered_name = if *attr_name == hir_expand::name![register_attr]\n-                    || *attr_name == hir_expand::name![register_tool]\n-                {\n-                    match attr.input.as_deref() {\n-                        Some(AttrInput::TokenTree(subtree, _)) => match &*subtree.token_trees {\n-                            [tt::TokenTree::Leaf(tt::Leaf::Ident(name))] => name.as_name(),\n-                            _ => continue,\n-                        },\n-                        _ => continue,\n-                    }\n-                } else {\n+                let attr_is_register_like = *attr_name == hir_expand::name![register_attr]\n+                    || *attr_name == hir_expand::name![register_tool];\n+                if !attr_is_register_like {\n                     continue;\n+                }\n+\n+                let registered_name = match attr.input.as_deref() {\n+                    Some(AttrInput::TokenTree(subtree, _)) => match &*subtree.token_trees {\n+                        [tt::TokenTree::Leaf(tt::Leaf::Ident(name))] => name.as_name(),\n+                        _ => continue,\n+                    },\n+                    _ => continue,\n                 };\n \n                 if *attr_name == hir_expand::name![register_attr] {\n-                    self.registered_attrs.push(registered_name.to_string());\n+                    self.registered_attrs.push(registered_name.to_smol_str());\n                     cov_mark::hit!(register_attr);\n                 } else {\n-                    self.registered_tools.push(registered_name.to_string());\n+                    self.registered_tools.push(registered_name.to_smol_str());\n                     cov_mark::hit!(register_tool);\n                 }\n             }\n \n             ModCollector {\n-                def_collector: &mut *self,\n+                def_collector: self,\n                 macro_depth: 0,\n                 module_id,\n                 tree_id: TreeId::new(file_id.into(), None),\n@@ -330,13 +324,14 @@ impl DefCollector<'_> {\n     fn seed_with_inner(&mut self, block: AstId<ast::BlockExpr>) {\n         let item_tree = self.db.file_item_tree(block.file_id);\n         let module_id = self.def_map.root;\n-        if item_tree\n+\n+        let is_cfg_enabled = item_tree\n             .top_level_attrs(self.db, self.def_map.krate)\n             .cfg()\n-            .map_or(true, |cfg| self.cfg_options.check(&cfg) != Some(false))\n-        {\n+            .map_or(true, |cfg| self.cfg_options.check(&cfg) != Some(false));\n+        if is_cfg_enabled {\n             ModCollector {\n-                def_collector: &mut *self,\n+                def_collector: self,\n                 macro_depth: 0,\n                 module_id,\n                 // FIXME: populate block once we have per-block ItemTrees\n@@ -444,7 +439,7 @@ impl DefCollector<'_> {\n                 let item_tree = self.db.file_item_tree(file_id);\n                 let mod_dir = self.mod_dirs[&directive.module_id].clone();\n                 ModCollector {\n-                    def_collector: &mut *self,\n+                    def_collector: self,\n                     macro_depth: directive.depth,\n                     module_id: directive.module_id,\n                     tree_id: TreeId::new(file_id, None),\n@@ -522,16 +517,16 @@ impl DefCollector<'_> {\n                 BuiltinShadowMode::Other,\n             );\n \n-            match &per_ns.types {\n+            match per_ns.types {\n                 Some((ModuleDefId::ModuleId(m), _)) => {\n-                    self.def_map.prelude = Some(*m);\n+                    self.def_map.prelude = Some(m);\n                     return;\n                 }\n-                _ => {\n+                types => {\n                     tracing::debug!(\n                         \"could not resolve prelude path `{}` to module (resolved to {:?})\",\n                         path,\n-                        per_ns.types\n+                        types\n                     );\n                 }\n             }\n@@ -558,9 +553,9 @@ impl DefCollector<'_> {\n         let kind = def.kind.to_basedb_kind();\n         self.exports_proc_macros = true;\n         let macro_def = match self.proc_macros.iter().find(|(n, _)| n == &def.name) {\n-            Some((_, expander)) => MacroDefId {\n+            Some(&(_, expander)) => MacroDefId {\n                 krate: self.def_map.krate,\n-                kind: MacroDefKind::ProcMacro(*expander, kind, ast_id),\n+                kind: MacroDefKind::ProcMacro(expander, kind, ast_id),\n                 local_inner: false,\n             },\n             None => MacroDefId {\n@@ -786,18 +781,16 @@ impl DefCollector<'_> {\n     }\n \n     fn resolve_extern_crate(&self, name: &Name) -> PerNs {\n-        let arc;\n-        let root = match self.def_map.block {\n-            Some(_) => {\n-                arc = self.def_map.crate_root(self.db).def_map(self.db);\n-                &*arc\n-            }\n-            None => &self.def_map,\n-        };\n-\n         if name == &name!(self) {\n             cov_mark::hit!(extern_crate_self_as);\n-            PerNs::types(root.module_id(root.root()).into(), Visibility::Public)\n+            let root = match self.def_map.block {\n+                Some(_) => {\n+                    let def_map = self.def_map.crate_root(self.db).def_map(self.db);\n+                    def_map.module_id(def_map.root())\n+                }\n+                None => self.def_map.module_id(self.def_map.root()),\n+            };\n+            PerNs::types(root.into(), Visibility::Public)\n         } else {\n             self.deps.get(name).map_or(PerNs::none(), |&it| PerNs::types(it, Visibility::Public))\n         }\n@@ -817,10 +810,10 @@ impl DefCollector<'_> {\n         match import.kind {\n             ImportKind::Plain | ImportKind::TypeOnly => {\n                 let name = match &import.alias {\n-                    Some(ImportAlias::Alias(name)) => Some(name.clone()),\n+                    Some(ImportAlias::Alias(name)) => Some(name),\n                     Some(ImportAlias::Underscore) => None,\n                     None => match import.path.segments().last() {\n-                        Some(last_segment) => Some(last_segment.clone()),\n+                        Some(last_segment) => Some(last_segment),\n                         None => {\n                             cov_mark::hit!(bogus_paths);\n                             return;\n@@ -837,12 +830,12 @@ impl DefCollector<'_> {\n \n                 // extern crates in the crate root are special-cased to insert entries into the extern prelude: rust-lang/rust#54658\n                 if import.is_extern_crate && module_id == self.def_map.root {\n-                    if let (Some(def), Some(name)) = (def.take_types(), name.as_ref()) {\n+                    if let (Some(def), Some(name)) = (def.take_types(), name) {\n                         self.def_map.extern_prelude.insert(name.clone(), def);\n                     }\n                 }\n \n-                self.update(module_id, &[(name, def)], vis, ImportType::Named);\n+                self.update(module_id, &[(name.cloned(), def)], vis, ImportType::Named);\n             }\n             ImportKind::Glob => {\n                 tracing::debug!(\"glob import: {:?}\", import);\n@@ -1763,7 +1756,7 @@ impl ModCollector<'_, '_> {\n                 let is_tool = builtin_attr::TOOL_MODULES\n                     .iter()\n                     .copied()\n-                    .chain(self.def_collector.registered_tools.iter().map(AsRef::as_ref))\n+                    .chain(self.def_collector.registered_tools.iter().map(SmolStr::as_str))\n                     .any(|m| tool_module == *m);\n                 if is_tool {\n                     return true;\n@@ -1776,7 +1769,7 @@ impl ModCollector<'_, '_> {\n                     .iter()\n                     .chain(builtin_attr::EXTRA_ATTRIBUTES)\n                     .copied()\n-                    .chain(self.def_collector.registered_attrs.iter().map(AsRef::as_ref))\n+                    .chain(self.def_collector.registered_attrs.iter().map(SmolStr::as_str))\n                     .any(|attr| name == *attr);\n                 return is_inert;\n             }"}]}