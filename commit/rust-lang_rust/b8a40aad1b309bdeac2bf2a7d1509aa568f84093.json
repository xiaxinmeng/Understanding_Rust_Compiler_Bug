{"sha": "b8a40aad1b309bdeac2bf2a7d1509aa568f84093", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4YTQwYWFkMWIzMDliZGVhYzJiZjJhN2QxNTA5YWE1NjhmODQwOTM=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-27T11:34:12Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-29T06:44:37Z"}, "message": "memory: make getting the alloc for a static an associate function for easier calling", "tree": {"sha": "24931883be142cb466bf1fdfb5428a246cce2130", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/24931883be142cb466bf1fdfb5428a246cce2130"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b8a40aad1b309bdeac2bf2a7d1509aa568f84093", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b8a40aad1b309bdeac2bf2a7d1509aa568f84093", "html_url": "https://github.com/rust-lang/rust/commit/b8a40aad1b309bdeac2bf2a7d1509aa568f84093", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b8a40aad1b309bdeac2bf2a7d1509aa568f84093/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cdeef61425ec177d2eb0f84d02a9d25000c954dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/cdeef61425ec177d2eb0f84d02a9d25000c954dd", "html_url": "https://github.com/rust-lang/rust/commit/cdeef61425ec177d2eb0f84d02a9d25000c954dd"}], "stats": {"total": 84, "additions": 42, "deletions": 42}, "files": [{"sha": "b08e8c230bd34e6e47282050bc36ce8381a12731", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/b8a40aad1b309bdeac2bf2a7d1509aa568f84093/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a40aad1b309bdeac2bf2a7d1509aa568f84093/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=b8a40aad1b309bdeac2bf2a7d1509aa568f84093", "patch": "@@ -122,45 +122,6 @@ impl<'a, 'mir, 'tcx, M> Hash for Memory<'a, 'mir, 'tcx, M>\n     }\n }\n \n-/// Helper function to obtain the global (tcx) allocation for a static\n-fn const_eval_static<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>>(\n-    tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n-    id: AllocId\n-) -> EvalResult<'tcx, &'tcx Allocation> {\n-    let alloc = tcx.alloc_map.lock().get(id);\n-    let def_id = match alloc {\n-        Some(AllocType::Memory(mem)) => {\n-            return Ok(mem)\n-        }\n-        Some(AllocType::Function(..)) => {\n-            return err!(DerefFunctionPointer)\n-        }\n-        Some(AllocType::Static(did)) => {\n-            did\n-        }\n-        None =>\n-            return err!(DanglingPointerDeref),\n-    };\n-    // We got a \"lazy\" static that has not been computed yet, do some work\n-    trace!(\"static_alloc: Need to compute {:?}\", def_id);\n-    if tcx.is_foreign_item(def_id) {\n-        return M::find_foreign_static(tcx, def_id);\n-    }\n-    let instance = Instance::mono(tcx.tcx, def_id);\n-    let gid = GlobalId {\n-        instance,\n-        promoted: None,\n-    };\n-    tcx.const_eval(ty::ParamEnv::reveal_all().and(gid)).map_err(|err| {\n-        // no need to report anything, the const_eval call takes care of that for statics\n-        assert!(tcx.is_static(def_id).is_some());\n-        EvalErrorKind::ReferencedConstant(err).into()\n-    }).map(|val| {\n-        // FIXME We got our static (will be a ByRef), now we make a *copy*?!?\n-        tcx.const_to_allocation(val)\n-    })\n-}\n-\n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     pub fn new(tcx: TyCtxtAt<'a, 'tcx, 'tcx>, data: M::MemoryData) -> Self {\n         Memory {\n@@ -343,13 +304,52 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n /// Allocation accessors\n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n+    /// Helper function to obtain the global (tcx) allocation for a static\n+    fn get_static_alloc(\n+        tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n+        id: AllocId,\n+    ) -> EvalResult<'tcx, &'tcx Allocation> {\n+        let alloc = tcx.alloc_map.lock().get(id);\n+        let def_id = match alloc {\n+            Some(AllocType::Memory(mem)) => {\n+                return Ok(mem)\n+            }\n+            Some(AllocType::Function(..)) => {\n+                return err!(DerefFunctionPointer)\n+            }\n+            Some(AllocType::Static(did)) => {\n+                did\n+            }\n+            None =>\n+                return err!(DanglingPointerDeref),\n+        };\n+        // We got a \"lazy\" static that has not been computed yet, do some work\n+        trace!(\"static_alloc: Need to compute {:?}\", def_id);\n+        if tcx.is_foreign_item(def_id) {\n+            return M::find_foreign_static(tcx, def_id);\n+        }\n+        let instance = Instance::mono(tcx.tcx, def_id);\n+        let gid = GlobalId {\n+            instance,\n+            promoted: None,\n+        };\n+        tcx.const_eval(ty::ParamEnv::reveal_all().and(gid)).map_err(|err| {\n+            // no need to report anything, the const_eval call takes care of that for statics\n+            assert!(tcx.is_static(def_id).is_some());\n+            EvalErrorKind::ReferencedConstant(err).into()\n+        }).map(|val| {\n+            // FIXME We got our static (will be a ByRef), now we make a *copy*?!?\n+            tcx.const_to_allocation(val)\n+        })\n+    }\n+\n     pub fn get(&self, id: AllocId) -> EvalResult<'tcx, &Allocation> {\n         match self.alloc_map.get(&id) {\n             // Normal alloc?\n             Some(alloc) => Ok(&alloc.1),\n             // Static. No need to make any copies, just provide read access to the global static\n             // memory in tcx.\n-            None => const_eval_static::<M>(self.tcx, id),\n+            None => Self::get_static_alloc(self.tcx, id),\n         }\n     }\n \n@@ -381,7 +381,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         if ptr.offset.bytes() != 0 {\n             return err!(InvalidFunctionPointer);\n         }\n-        debug!(\"reading fn ptr: {}\", ptr.alloc_id);\n+        trace!(\"reading fn ptr: {}\", ptr.alloc_id);\n         match self.tcx.alloc_map.lock().get(ptr.alloc_id) {\n             Some(AllocType::Function(instance)) => Ok(instance),\n             _ => Err(EvalErrorKind::ExecuteMemory.into()),\n@@ -610,7 +610,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         id: AllocId,\n         kind: MemoryKind<M::MemoryKinds>,\n     ) -> EvalResult<'tcx> {\n-        let alloc = const_eval_static::<M>(self.tcx, id)?;\n+        let alloc = Self::get_static_alloc(self.tcx, id)?;\n         if alloc.mutability == Mutability::Immutable {\n             return err!(ModifiedConstantMemory);\n         }"}]}