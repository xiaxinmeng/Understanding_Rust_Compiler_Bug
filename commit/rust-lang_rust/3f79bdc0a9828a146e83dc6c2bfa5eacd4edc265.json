{"sha": "3f79bdc0a9828a146e83dc6c2bfa5eacd4edc265", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmNzliZGMwYTk4MjhhMTQ2ZTgzZGM2YzJiZmE1ZWFjZDRlZGMyNjU=", "commit": {"author": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2017-04-15T02:05:41Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-04-15T02:05:41Z"}, "message": "Rollup merge of #41125 - lukaramu:std-hash-docs, r=frewsxcv\n\nImprove std::hash docs\n\nFixes #29357.\n\nFor details on what exactly I've done, see the commit descriptions.\n\nThere are some things I'm not sure about, but would like to address before merging this so the issue can be closed; any feedback on these points would really be appriciated:\n* [x] ~I didn't touch the module level docs at all. On the one hand, I think they could use a short overview over the module; on the other hand, the module really isn't that big and I don't know if I could really do anything beyond just duplicating the type's summaries...~\n* [x] ~I feel like the module-level examples are quite long-winded and not to the point, but I couldn't really think of anything better. Any ideas?~\n* [x] ~Should `Hasher` get an example for implementing it? There is one in the module documentation, but it only \"implements\" it via `unimplemented!` and I'm not sure what the value of that is.~\n* [x] ~Should `Hasher`'s `write_{int}` methods get examples?~\n\nIf there's anything else you'd like to see in std::hash's docs, please let me know!\n\nr? @rust-lang/docs", "tree": {"sha": "d37d1566b6ca20762fb566dbcb8d710845e8f3b2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d37d1566b6ca20762fb566dbcb8d710845e8f3b2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3f79bdc0a9828a146e83dc6c2bfa5eacd4edc265", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3f79bdc0a9828a146e83dc6c2bfa5eacd4edc265", "html_url": "https://github.com/rust-lang/rust/commit/3f79bdc0a9828a146e83dc6c2bfa5eacd4edc265", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3f79bdc0a9828a146e83dc6c2bfa5eacd4edc265/comments", "author": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f0ca5d4bad07a4fc8497bd9766cdadaee1bd0ac6", "url": "https://api.github.com/repos/rust-lang/rust/commits/f0ca5d4bad07a4fc8497bd9766cdadaee1bd0ac6", "html_url": "https://github.com/rust-lang/rust/commit/f0ca5d4bad07a4fc8497bd9766cdadaee1bd0ac6"}, {"sha": "12d7c3d9d8e6694b693e9ee30402063b6cef18ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/12d7c3d9d8e6694b693e9ee30402063b6cef18ab", "html_url": "https://github.com/rust-lang/rust/commit/12d7c3d9d8e6694b693e9ee30402063b6cef18ab"}], "stats": {"total": 197, "additions": 164, "deletions": 33}, "files": [{"sha": "f68361e8522778b6d2e950278cd96217d0aedf6e", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 164, "deletions": 33, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/3f79bdc0a9828a146e83dc6c2bfa5eacd4edc265/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f79bdc0a9828a146e83dc6c2bfa5eacd4edc265/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=3f79bdc0a9828a146e83dc6c2bfa5eacd4edc265", "patch": "@@ -107,29 +107,25 @@ mod sip;\n \n /// A hashable type.\n ///\n-/// The `H` type parameter is an abstract hash state that is used by the `Hash`\n-/// to compute the hash.\n+/// Types implementing `Hash` are able to be [`hash`]ed with an instance of\n+/// [`Hasher`].\n ///\n-/// If you are also implementing [`Eq`], there is an additional property that\n-/// is important:\n+/// ## Implementing `Hash`\n ///\n-/// ```text\n-/// k1 == k2 -> hash(k1) == hash(k2)\n-/// ```\n-///\n-/// In other words, if two keys are equal, their hashes should also be equal.\n-/// [`HashMap`] and [`HashSet`] both rely on this behavior.\n+/// You can derive `Hash` with `#[derive(Hash)]` if all fields implement `Hash`.\n+/// The resulting hash will be the combination of the values from calling\n+/// [`hash`] on each field.\n ///\n-/// ## Derivable\n-///\n-/// This trait can be used with `#[derive]` if all fields implement `Hash`.\n-/// When `derive`d, the resulting hash will be the combination of the values\n-/// from calling [`.hash`] on each field.\n-///\n-/// ## How can I implement `Hash`?\n+/// ```\n+/// #[derive(Hash)]\n+/// struct Rustacean {\n+///     name: String,\n+///     country: String,\n+/// }\n+/// ```\n ///\n-/// If you need more control over how a value is hashed, you need to implement\n-/// the `Hash` trait:\n+/// If you need more control over how a value is hashed, you can of course\n+/// implement the `Hash` trait yourself:\n ///\n /// ```\n /// use std::hash::{Hash, Hasher};\n@@ -148,17 +144,60 @@ mod sip;\n /// }\n /// ```\n ///\n+/// ## `Hash` and `Eq`\n+///\n+/// When implementing both `Hash` and [`Eq`], it is important that the following\n+/// property holds:\n+///\n+/// ```text\n+/// k1 == k2 -> hash(k1) == hash(k2)\n+/// ```\n+///\n+/// In other words, if two keys are equal, their hashes must also be equal.\n+/// [`HashMap`] and [`HashSet`] both rely on this behavior.\n+///\n+/// Thankfully, you won't need to worry about upholding this property when\n+/// deriving both [`Eq`] and `Hash` with `#[derive(PartialEq, Eq, Hash)]`.\n+///\n /// [`Eq`]: ../../std/cmp/trait.Eq.html\n+/// [`Hasher`]: trait.Hasher.html\n /// [`HashMap`]: ../../std/collections/struct.HashMap.html\n /// [`HashSet`]: ../../std/collections/struct.HashSet.html\n-/// [`.hash`]: #tymethod.hash\n+/// [`hash`]: #tymethod.hash\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Hash {\n-    /// Feeds this value into the state given, updating the hasher as necessary.\n+    /// Feeds this value into the given [`Hasher`].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::hash_map::DefaultHasher;\n+    /// use std::hash::{Hash, Hasher};\n+    ///\n+    /// let mut hasher = DefaultHasher::new();\n+    /// 7920.hash(&mut hasher);\n+    /// println!(\"Hash is {:x}!\", hasher.finish());\n+    /// ```\n+    ///\n+    /// [`Hasher`]: trait.Hasher.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn hash<H: Hasher>(&self, state: &mut H);\n \n-    /// Feeds a slice of this type into the state provided.\n+    /// Feeds a slice of this type into the given [`Hasher`].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::hash_map::DefaultHasher;\n+    /// use std::hash::{Hash, Hasher};\n+    ///\n+    /// let mut hasher = DefaultHasher::new();\n+    /// let numbers = [6, 28, 496, 8128];\n+    /// Hash::hash_slice(&numbers, &mut hasher);\n+    /// println!(\"Hash is {:x}!\", hasher.finish());\n+    /// ```\n+    ///\n+    /// [`Hasher`]: trait.Hasher.html\n     #[stable(feature = \"hash_slice\", since = \"1.3.0\")]\n     fn hash_slice<H: Hasher>(data: &[Self], state: &mut H)\n         where Self: Sized\n@@ -169,18 +208,73 @@ pub trait Hash {\n     }\n }\n \n-/// A trait which represents the ability to hash an arbitrary stream of bytes.\n+/// A trait for hashing an arbitrary stream of bytes.\n+///\n+/// Instances of `Hasher` usually represent state that is changed while hashing\n+/// data.\n+///\n+/// `Hasher` provides a fairly basic interface for retrieving the generated hash\n+/// (with [`finish`]), and writing integers as well as slices of bytes into an\n+/// instance (with [`write`] and [`write_u8`] etc.). Most of the time, `Hasher`\n+/// instances are used in conjunction with the [`Hash`] trait.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::collections::hash_map::DefaultHasher;\n+/// use std::hash::Hasher;\n+///\n+/// let mut hasher = DefaultHasher::new();\n+///\n+/// hasher.write_u32(1989);\n+/// hasher.write_u8(11);\n+/// hasher.write_u8(9);\n+/// hasher.write(b\"Huh?\");\n+///\n+/// println!(\"Hash is {:x}!\", hasher.finish());\n+/// ```\n+///\n+/// [`Hash`]: trait.Hash.html\n+/// [`finish`]: #tymethod.finish\n+/// [`write`]: #tymethod.write\n+/// [`write_u8`]: #method.write_u8\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Hasher {\n     /// Completes a round of hashing, producing the output hash generated.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::hash_map::DefaultHasher;\n+    /// use std::hash::Hasher;\n+    ///\n+    /// let mut hasher = DefaultHasher::new();\n+    /// hasher.write(b\"Cool!\");\n+    ///\n+    /// println!(\"Hash is {:x}!\", hasher.finish());\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn finish(&self) -> u64;\n \n     /// Writes some data into this `Hasher`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::hash_map::DefaultHasher;\n+    /// use std::hash::Hasher;\n+    ///\n+    /// let mut hasher = DefaultHasher::new();\n+    /// let data = [0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef];\n+    ///\n+    /// hasher.write(&data);\n+    ///\n+    /// println!(\"Hash is {:x}!\", hasher.finish());\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn write(&mut self, bytes: &[u8]);\n \n-    /// Write a single `u8` into this hasher.\n+    /// Writes a single `u8` into this hasher.\n     #[inline]\n     #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n     fn write_u8(&mut self, i: u8) {\n@@ -258,12 +352,35 @@ pub trait Hasher {\n     }\n }\n \n-/// A `BuildHasher` is typically used as a factory for instances of `Hasher`\n-/// which a `HashMap` can then use to hash keys independently.\n+/// A trait for creating instances of [`Hasher`].\n+///\n+/// A `BuildHasher` is typically used (e.g. by [`HashMap`]) to create\n+/// [`Hasher`]s for each key such that they are hashed independently of one\n+/// another, since [`Hasher`]s contain state.\n+///\n+/// For each instance of `BuildHasher`, the [`Hasher`]s created by\n+/// [`build_hasher`] should be identical. That is, if the same stream of bytes\n+/// is fed into each hasher, the same output will also be generated.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::collections::hash_map::RandomState;\n+/// use std::hash::{BuildHasher, Hasher};\n+///\n+/// let s = RandomState::new();\n+/// let mut hasher_1 = s.build_hasher();\n+/// let mut hasher_2 = s.build_hasher();\n ///\n-/// Note that for each instance of `BuildHasher`, the created hashers should be\n-/// identical. That is, if the same stream of bytes is fed into each hasher, the\n-/// same output will also be generated.\n+/// hasher_1.write_u32(8128);\n+/// hasher_2.write_u32(8128);\n+///\n+/// assert_eq!(hasher_1.finish(), hasher_2.finish());\n+/// ```\n+///\n+/// [`build_hasher`]: #tymethod.build_hasher\n+/// [`Hasher`]: trait.Hasher.html\n+/// [`HashMap`]: ../../std/collections/struct.HashMap.html\n #[stable(since = \"1.7.0\", feature = \"build_hasher\")]\n pub trait BuildHasher {\n     /// Type of the hasher that will be created.\n@@ -272,6 +389,9 @@ pub trait BuildHasher {\n \n     /// Creates a new hasher.\n     ///\n+    /// Each call to `build_hasher` on the same instance should produce identical\n+    /// [`Hasher`]s.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -281,15 +401,23 @@ pub trait BuildHasher {\n     /// let s = RandomState::new();\n     /// let new_s = s.build_hasher();\n     /// ```\n+    ///\n+    /// [`Hasher`]: trait.Hasher.html\n     #[stable(since = \"1.7.0\", feature = \"build_hasher\")]\n     fn build_hasher(&self) -> Self::Hasher;\n }\n \n-/// The `BuildHasherDefault` structure is used in scenarios where one has a\n-/// type that implements [`Hasher`] and [`Default`], but needs that type to\n-/// implement [`BuildHasher`].\n+/// Used to create a default [`BuildHasher`] instance for types that implement\n+/// [`Hasher`] and [`Default`].\n ///\n-/// This structure is zero-sized and does not need construction.\n+/// `BuildHasherDefault<H>` can be used when a type `H` implements [`Hasher`] and\n+/// [`Default`], and you need a corresponding [`BuildHasher`] instance, but none is\n+/// defined.\n+///\n+/// Any `BuildHasherDefault` is [zero-sized]. It can be created with\n+/// [`default`][method.Default]. When using `BuildHasherDefault` with [`HashMap`] or\n+/// [`HashSet`], this doesn't need to be done, since they implement appropriate\n+/// [`Default`] instances themselves.\n ///\n /// # Examples\n ///\n@@ -322,8 +450,11 @@ pub trait BuildHasher {\n ///\n /// [`BuildHasher`]: trait.BuildHasher.html\n /// [`Default`]: ../default/trait.Default.html\n+/// [method.default]: #method.default\n /// [`Hasher`]: trait.Hasher.html\n /// [`HashMap`]: ../../std/collections/struct.HashMap.html\n+/// [`HashSet`]: ../../std/collections/struct.HashSet.html\n+/// [zero-sized]: https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts\n #[stable(since = \"1.7.0\", feature = \"build_hasher\")]\n pub struct BuildHasherDefault<H>(marker::PhantomData<H>);\n "}]}