{"sha": "66d7a88c41ebcc25e499babd103177a9d8df6cdb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2ZDdhODhjNDFlYmNjMjVlNDk5YmFiZDEwMzE3N2E5ZDhkZjZjZGI=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2020-03-07T16:02:32Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2020-03-07T16:30:57Z"}, "message": "resolve: `directive` -> `import`", "tree": {"sha": "9b459b825b413539c570c46c32f661eea449fd4c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9b459b825b413539c570c46c32f661eea449fd4c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/66d7a88c41ebcc25e499babd103177a9d8df6cdb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/66d7a88c41ebcc25e499babd103177a9d8df6cdb", "html_url": "https://github.com/rust-lang/rust/commit/66d7a88c41ebcc25e499babd103177a9d8df6cdb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/66d7a88c41ebcc25e499babd103177a9d8df6cdb/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1915bf122e488ce540cdb7782550e907f269b9e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/1915bf122e488ce540cdb7782550e907f269b9e3", "html_url": "https://github.com/rust-lang/rust/commit/1915bf122e488ce540cdb7782550e907f269b9e3"}], "stats": {"total": 452, "additions": 215, "deletions": 237}, "files": [{"sha": "ec5a8c4a0b896c92ed7322be9c9489130591c162", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 21, "deletions": 30, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/66d7a88c41ebcc25e499babd103177a9d8df6cdb/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66d7a88c41ebcc25e499babd103177a9d8df6cdb/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=66d7a88c41ebcc25e499babd103177a9d8df6cdb", "patch": "@@ -307,8 +307,8 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         })\n     }\n \n-    // Add an import directive to the current module.\n-    fn add_import_directive(\n+    // Add an import to the current module.\n+    fn add_import(\n         &mut self,\n         module_path: Vec<Segment>,\n         kind: ImportKind<'a>,\n@@ -320,7 +320,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         vis: ty::Visibility,\n     ) {\n         let current_module = self.parent_scope.module;\n-        let directive = self.r.arenas.alloc_import_directive(Import {\n+        let import = self.r.arenas.alloc_import(Import {\n             kind,\n             parent_scope: self.parent_scope,\n             module_path,\n@@ -336,25 +336,25 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n             used: Cell::new(false),\n         });\n \n-        debug!(\"add_import_directive({:?})\", directive);\n+        debug!(\"add_import({:?})\", import);\n \n-        self.r.indeterminate_imports.push(directive);\n-        match directive.kind {\n+        self.r.indeterminate_imports.push(import);\n+        match import.kind {\n             // Don't add unresolved underscore imports to modules\n             ImportKind::Single { target: Ident { name: kw::Underscore, .. }, .. } => {}\n             ImportKind::Single { target, type_ns_only, .. } => {\n                 self.r.per_ns(|this, ns| {\n                     if !type_ns_only || ns == TypeNS {\n                         let key = this.new_key(target, ns);\n                         let mut resolution = this.resolution(current_module, key).borrow_mut();\n-                        resolution.add_single_import(directive);\n+                        resolution.add_single_import(import);\n                     }\n                 });\n             }\n             // We don't add prelude imports to the globs since they only affect lexical scopes,\n             // which are not relevant to import resolution.\n             ImportKind::Glob { is_prelude: true, .. } => {}\n-            ImportKind::Glob { .. } => current_module.globs.borrow_mut().push(directive),\n+            ImportKind::Glob { .. } => current_module.globs.borrow_mut().push(import),\n             _ => unreachable!(),\n         }\n     }\n@@ -495,7 +495,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                     type_ns_only,\n                     nested,\n                 };\n-                self.add_import_directive(\n+                self.add_import(\n                     module_path,\n                     kind,\n                     use_tree.span,\n@@ -511,16 +511,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                     is_prelude: attr::contains_name(&item.attrs, sym::prelude_import),\n                     max_vis: Cell::new(ty::Visibility::Invisible),\n                 };\n-                self.add_import_directive(\n-                    prefix,\n-                    kind,\n-                    use_tree.span,\n-                    id,\n-                    item,\n-                    root_span,\n-                    item.id,\n-                    vis,\n-                );\n+                self.add_import(prefix, kind, use_tree.span, id, item, root_span, item.id, vis);\n             }\n             ast::UseTreeKind::Nested(ref items) => {\n                 // Ensure there is at most one `self` in the list\n@@ -636,7 +627,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 let used = self.process_legacy_macro_imports(item, module);\n                 let binding =\n                     (module, ty::Visibility::Public, sp, expansion).to_name_binding(self.r.arenas);\n-                let directive = self.r.arenas.alloc_import_directive(Import {\n+                let import = self.r.arenas.alloc_import(Import {\n                     kind: ImportKind::ExternCrate { source: orig_name, target: ident },\n                     root_id: item.id,\n                     id: item.id,\n@@ -651,8 +642,8 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                     vis: Cell::new(vis),\n                     used: Cell::new(used),\n                 });\n-                self.r.potentially_unused_imports.push(directive);\n-                let imported_binding = self.r.import(binding, directive);\n+                self.r.potentially_unused_imports.push(import);\n+                let imported_binding = self.r.import(binding, import);\n                 if ptr::eq(parent, self.r.graph_root) {\n                     if let Some(entry) = self.r.extern_prelude.get(&ident.modern()) {\n                         if expansion != ExpnId::root()\n@@ -988,8 +979,8 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n             }\n         }\n \n-        let macro_use_directive = |this: &Self, span| {\n-            this.r.arenas.alloc_import_directive(Import {\n+        let macro_use_import = |this: &Self, span| {\n+            this.r.arenas.alloc_import(Import {\n                 kind: ImportKind::MacroUse,\n                 root_id: item.id,\n                 id: item.id,\n@@ -1008,11 +999,11 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n \n         let allow_shadowing = self.parent_scope.expansion == ExpnId::root();\n         if let Some(span) = import_all {\n-            let directive = macro_use_directive(self, span);\n-            self.r.potentially_unused_imports.push(directive);\n+            let import = macro_use_import(self, span);\n+            self.r.potentially_unused_imports.push(import);\n             module.for_each_child(self, |this, ident, ns, binding| {\n                 if ns == MacroNS {\n-                    let imported_binding = this.r.import(binding, directive);\n+                    let imported_binding = this.r.import(binding, import);\n                     this.legacy_import_macro(ident.name, imported_binding, span, allow_shadowing);\n                 }\n             });\n@@ -1027,9 +1018,9 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                     ident.span,\n                 );\n                 if let Ok(binding) = result {\n-                    let directive = macro_use_directive(self, ident.span);\n-                    self.r.potentially_unused_imports.push(directive);\n-                    let imported_binding = self.r.import(binding, directive);\n+                    let import = macro_use_import(self, ident.span);\n+                    self.r.potentially_unused_imports.push(import);\n+                    let imported_binding = self.r.import(binding, import);\n                     self.legacy_import_macro(\n                         ident.name,\n                         imported_binding,"}, {"sha": "722f843ab6e7ead20f33305bcde33f7613e342ba", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/66d7a88c41ebcc25e499babd103177a9d8df6cdb/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66d7a88c41ebcc25e499babd103177a9d8df6cdb/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=66d7a88c41ebcc25e499babd103177a9d8df6cdb", "patch": "@@ -3,7 +3,7 @@\n //\n // Although this is mostly a lint pass, it lives in here because it depends on\n // resolve data structures and because it finalises the privacy information for\n-// `use` directives.\n+// `use` items.\n //\n // Unused trait imports can't be checked until the method resolution. We save\n // candidates here, and do the actual check in librustc_typeck/check_unused.rs.\n@@ -58,7 +58,7 @@ struct UnusedImportCheckVisitor<'a, 'b> {\n }\n \n impl<'a, 'b> UnusedImportCheckVisitor<'a, 'b> {\n-    // We have information about whether `use` (import) directives are actually\n+    // We have information about whether `use` (import) items are actually\n     // used now. If an import is not used at all, we signal a lint error.\n     fn check_import(&mut self, id: ast::NodeId) {\n         let mut used = false;\n@@ -223,33 +223,33 @@ fn calc_unused_spans(\n \n impl Resolver<'_> {\n     crate fn check_unused(&mut self, krate: &ast::Crate) {\n-        for directive in self.potentially_unused_imports.iter() {\n-            match directive.kind {\n-                _ if directive.used.get()\n-                    || directive.vis.get() == ty::Visibility::Public\n-                    || directive.span.is_dummy() =>\n+        for import in self.potentially_unused_imports.iter() {\n+            match import.kind {\n+                _ if import.used.get()\n+                    || import.vis.get() == ty::Visibility::Public\n+                    || import.span.is_dummy() =>\n                 {\n-                    if let ImportKind::MacroUse = directive.kind {\n-                        if !directive.span.is_dummy() {\n+                    if let ImportKind::MacroUse = import.kind {\n+                        if !import.span.is_dummy() {\n                             self.lint_buffer.buffer_lint(\n                                 lint::builtin::MACRO_USE_EXTERN_CRATE,\n-                                directive.id,\n-                                directive.span,\n-                                \"deprecated `#[macro_use]` directive used to \\\n+                                import.id,\n+                                import.span,\n+                                \"deprecated `#[macro_use]` attribute used to \\\n                                 import macros should be replaced at use sites \\\n-                                with a `use` statement to import the macro \\\n+                                with a `use` item to import the macro \\\n                                 instead\",\n                             );\n                         }\n                     }\n                 }\n                 ImportKind::ExternCrate { .. } => {\n-                    self.maybe_unused_extern_crates.push((directive.id, directive.span));\n+                    self.maybe_unused_extern_crates.push((import.id, import.span));\n                 }\n                 ImportKind::MacroUse => {\n                     let lint = lint::builtin::UNUSED_IMPORTS;\n                     let msg = \"unused `#[macro_use]` import\";\n-                    self.lint_buffer.buffer_lint(lint, directive.id, directive.span, msg);\n+                    self.lint_buffer.buffer_lint(lint, import.id, import.span, msg);\n                 }\n                 _ => {}\n             }"}, {"sha": "38efc907ff077f5fa32b4b77943c944f784f9d8c", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/66d7a88c41ebcc25e499babd103177a9d8df6cdb/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66d7a88c41ebcc25e499babd103177a9d8df6cdb/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=66d7a88c41ebcc25e499babd103177a9d8df6cdb", "patch": "@@ -1126,7 +1126,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n     /// ```\n     pub(crate) fn check_for_module_export_macro(\n         &mut self,\n-        directive: &'b Import<'b>,\n+        import: &'b Import<'b>,\n         module: ModuleOrUniformRoot<'b>,\n         ident: Ident,\n     ) -> Option<(Option<Suggestion>, Vec<String>)> {\n@@ -1151,26 +1151,26 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         let binding = resolution.borrow().binding()?;\n         if let Res::Def(DefKind::Macro(MacroKind::Bang), _) = binding.res() {\n             let module_name = crate_module.kind.name().unwrap();\n-            let import = match directive.kind {\n+            let import_snippet = match import.kind {\n                 ImportKind::Single { source, target, .. } if source != target => {\n                     format!(\"{} as {}\", source, target)\n                 }\n                 _ => format!(\"{}\", ident),\n             };\n \n             let mut corrections: Vec<(Span, String)> = Vec::new();\n-            if !directive.is_nested() {\n+            if !import.is_nested() {\n                 // Assume this is the easy case of `use issue_59764::foo::makro;` and just remove\n                 // intermediate segments.\n-                corrections.push((directive.span, format!(\"{}::{}\", module_name, import)));\n+                corrections.push((import.span, format!(\"{}::{}\", module_name, import_snippet)));\n             } else {\n                 // Find the binding span (and any trailing commas and spaces).\n                 //   ie. `use a::b::{c, d, e};`\n                 //                      ^^^\n                 let (found_closing_brace, binding_span) = find_span_of_binding_until_next_binding(\n                     self.r.session,\n-                    directive.span,\n-                    directive.use_span,\n+                    import.span,\n+                    import.use_span,\n                 );\n                 debug!(\n                     \"check_for_module_export_macro: found_closing_brace={:?} binding_span={:?}\",\n@@ -1207,7 +1207,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 let (has_nested, after_crate_name) = find_span_immediately_after_crate_name(\n                     self.r.session,\n                     module_name,\n-                    directive.use_span,\n+                    import.use_span,\n                 );\n                 debug!(\n                     \"check_for_module_export_macro: has_nested={:?} after_crate_name={:?}\",\n@@ -1223,11 +1223,11 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                         start_point,\n                         if has_nested {\n                             // In this case, `start_snippet` must equal '{'.\n-                            format!(\"{}{}, \", start_snippet, import)\n+                            format!(\"{}{}, \", start_snippet, import_snippet)\n                         } else {\n                             // In this case, add a `{`, then the moved import, then whatever\n                             // was there before.\n-                            format!(\"{{{}, {}\", import, start_snippet)\n+                            format!(\"{{{}, {}\", import_snippet, start_snippet)\n                         },\n                     ));\n                 }"}, {"sha": "81c1e496c9d5f32de15a8cab61e4cecd0d7cc10d", "filename": "src/librustc_resolve/imports.rs", "status": "modified", "additions": 126, "deletions": 138, "changes": 264, "blob_url": "https://github.com/rust-lang/rust/blob/66d7a88c41ebcc25e499babd103177a9d8df6cdb/src%2Flibrustc_resolve%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66d7a88c41ebcc25e499babd103177a9d8df6cdb/src%2Flibrustc_resolve%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fimports.rs?ref=66d7a88c41ebcc25e499babd103177a9d8df6cdb", "patch": "@@ -34,7 +34,7 @@ use std::{mem, ptr};\n \n type Res = def::Res<NodeId>;\n \n-/// Contains data for specific types of import directives.\n+/// Contains data for specific kinds of imports.\n #[derive(Clone, Debug)]\n pub enum ImportKind<'a> {\n     Single {\n@@ -63,7 +63,7 @@ pub enum ImportKind<'a> {\n     MacroUse,\n }\n \n-/// One import directive.\n+/// One import.\n #[derive(Debug, Clone)]\n crate struct Import<'a> {\n     pub kind: ImportKind<'a>,\n@@ -77,7 +77,7 @@ crate struct Import<'a> {\n     /// use foo::bar::{a, b}\n     /// ```\n     ///\n-    /// If this is the import directive for `foo::bar::a`, we would have the ID of the `UseTree`\n+    /// If this is the import for `foo::bar::a`, we would have the ID of the `UseTree`\n     /// for `a` in this field.\n     pub id: NodeId,\n \n@@ -135,7 +135,7 @@ impl<'a> Import<'a> {\n /// Records information about the resolution of a name in a namespace of a module.\n pub struct NameResolution<'a> {\n     /// Single imports that may define the name in the namespace.\n-    /// Import directives are arena-allocated, so it's ok to use pointers as keys.\n+    /// Imports are arena-allocated, so it's ok to use pointers as keys.\n     single_imports: FxHashSet<PtrKey<'a, Import<'a>>>,\n     /// The least shadowable known binding for this name, or None if there are no known bindings.\n     pub binding: Option<&'a NameBinding<'a>>,\n@@ -154,8 +154,8 @@ impl<'a> NameResolution<'a> {\n         })\n     }\n \n-    crate fn add_single_import(&mut self, directive: &'a Import<'a>) {\n-        self.single_imports.insert(PtrKey(directive));\n+    crate fn add_single_import(&mut self, import: &'a Import<'a>) {\n+        self.single_imports.insert(PtrKey(import));\n     }\n }\n \n@@ -450,34 +450,34 @@ impl<'a> Resolver<'a> {\n         Err((Determined, Weak::No))\n     }\n \n-    // Given a binding and an import directive that resolves to it,\n-    // return the corresponding binding defined by the import directive.\n+    // Given a binding and an import that resolves to it,\n+    // return the corresponding binding defined by the import.\n     crate fn import(\n         &self,\n         binding: &'a NameBinding<'a>,\n-        directive: &'a Import<'a>,\n+        import: &'a Import<'a>,\n     ) -> &'a NameBinding<'a> {\n-        let vis = if binding.pseudo_vis().is_at_least(directive.vis.get(), self) ||\n+        let vis = if binding.pseudo_vis().is_at_least(import.vis.get(), self) ||\n                      // cf. `PUB_USE_OF_PRIVATE_EXTERN_CRATE`\n-                     !directive.is_glob() && binding.is_extern_crate()\n+                     !import.is_glob() && binding.is_extern_crate()\n         {\n-            directive.vis.get()\n+            import.vis.get()\n         } else {\n             binding.pseudo_vis()\n         };\n \n-        if let ImportKind::Glob { ref max_vis, .. } = directive.kind {\n-            if vis == directive.vis.get() || vis.is_at_least(max_vis.get(), self) {\n+        if let ImportKind::Glob { ref max_vis, .. } = import.kind {\n+            if vis == import.vis.get() || vis.is_at_least(max_vis.get(), self) {\n                 max_vis.set(vis)\n             }\n         }\n \n         self.arenas.alloc_name_binding(NameBinding {\n-            kind: NameBindingKind::Import { binding, directive, used: Cell::new(false) },\n+            kind: NameBindingKind::Import { binding, import, used: Cell::new(false) },\n             ambiguity: None,\n-            span: directive.span,\n+            span: import.span,\n             vis,\n-            expansion: directive.parent_scope.expansion,\n+            expansion: import.parent_scope.expansion,\n         })\n     }\n \n@@ -576,17 +576,17 @@ impl<'a> Resolver<'a> {\n         };\n \n         // Define `binding` in `module`s glob importers.\n-        for directive in module.glob_importers.borrow_mut().iter() {\n+        for import in module.glob_importers.borrow_mut().iter() {\n             let mut ident = key.ident;\n-            let scope = match ident.span.reverse_glob_adjust(module.expansion, directive.span) {\n+            let scope = match ident.span.reverse_glob_adjust(module.expansion, import.span) {\n                 Some(Some(def)) => self.macro_def_scope(def),\n-                Some(None) => directive.parent_scope.module,\n+                Some(None) => import.parent_scope.module,\n                 None => continue,\n             };\n             if self.is_accessible_from(binding.vis, scope) {\n-                let imported_binding = self.import(binding, directive);\n+                let imported_binding = self.import(binding, import);\n                 let key = BindingKey { ident, ..key };\n-                let _ = self.try_define(directive.parent_scope.module, key, imported_binding);\n+                let _ = self.try_define(import.parent_scope.module, key, imported_binding);\n             }\n         }\n \n@@ -595,13 +595,13 @@ impl<'a> Resolver<'a> {\n \n     // Define a \"dummy\" resolution containing a Res::Err as a placeholder for a\n     // failed resolution\n-    fn import_dummy_binding(&mut self, directive: &'a Import<'a>) {\n-        if let ImportKind::Single { target, .. } = directive.kind {\n+    fn import_dummy_binding(&mut self, import: &'a Import<'a>) {\n+        if let ImportKind::Single { target, .. } = import.kind {\n             let dummy_binding = self.dummy_binding;\n-            let dummy_binding = self.import(dummy_binding, directive);\n+            let dummy_binding = self.import(dummy_binding, import);\n             self.per_ns(|this, ns| {\n                 let key = this.new_key(target, ns);\n-                let _ = this.try_define(directive.parent_scope.module, key, dummy_binding);\n+                let _ = this.try_define(import.parent_scope.module, key, dummy_binding);\n                 // Consider erroneous imports used to avoid duplicate diagnostics.\n                 this.record_use(target, ns, dummy_binding, false);\n             });\n@@ -766,28 +766,28 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n \n     /// Attempts to resolve the given import, returning true if its resolution is determined.\n     /// If successful, the resolved bindings are written into the module.\n-    fn resolve_import(&mut self, directive: &'b Import<'b>) -> bool {\n+    fn resolve_import(&mut self, import: &'b Import<'b>) -> bool {\n         debug!(\n             \"(resolving import for module) resolving import `{}::...` in `{}`\",\n-            Segment::names_to_string(&directive.module_path),\n-            module_to_string(directive.parent_scope.module).unwrap_or_else(|| \"???\".to_string()),\n+            Segment::names_to_string(&import.module_path),\n+            module_to_string(import.parent_scope.module).unwrap_or_else(|| \"???\".to_string()),\n         );\n \n-        let module = if let Some(module) = directive.imported_module.get() {\n+        let module = if let Some(module) = import.imported_module.get() {\n             module\n         } else {\n             // For better failure detection, pretend that the import will\n             // not define any names while resolving its module path.\n-            let orig_vis = directive.vis.replace(ty::Visibility::Invisible);\n+            let orig_vis = import.vis.replace(ty::Visibility::Invisible);\n             let path_res = self.r.resolve_path(\n-                &directive.module_path,\n+                &import.module_path,\n                 None,\n-                &directive.parent_scope,\n+                &import.parent_scope,\n                 false,\n-                directive.span,\n-                directive.crate_lint(),\n+                import.span,\n+                import.crate_lint(),\n             );\n-            directive.vis.set(orig_vis);\n+            import.vis.set(orig_vis);\n \n             match path_res {\n                 PathResult::Module(module) => module,\n@@ -796,9 +796,8 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             }\n         };\n \n-        directive.imported_module.set(Some(module));\n-        let (source, target, source_bindings, target_bindings, type_ns_only) = match directive.kind\n-        {\n+        import.imported_module.set(Some(module));\n+        let (source, target, source_bindings, target_bindings, type_ns_only) = match import.kind {\n             ImportKind::Single {\n                 source,\n                 target,\n@@ -808,7 +807,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 ..\n             } => (source, target, source_bindings, target_bindings, type_ns_only),\n             ImportKind::Glob { .. } => {\n-                self.resolve_glob_import(directive);\n+                self.resolve_glob_import(import);\n                 return true;\n             }\n             _ => unreachable!(),\n@@ -820,44 +819,44 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 if let Err(Undetermined) = source_bindings[ns].get() {\n                     // For better failure detection, pretend that the import will\n                     // not define any names while resolving its module path.\n-                    let orig_vis = directive.vis.replace(ty::Visibility::Invisible);\n+                    let orig_vis = import.vis.replace(ty::Visibility::Invisible);\n                     let binding = this.resolve_ident_in_module(\n                         module,\n                         source,\n                         ns,\n-                        &directive.parent_scope,\n+                        &import.parent_scope,\n                         false,\n-                        directive.span,\n+                        import.span,\n                     );\n-                    directive.vis.set(orig_vis);\n+                    import.vis.set(orig_vis);\n \n                     source_bindings[ns].set(binding);\n                 } else {\n                     return;\n                 };\n \n-                let parent = directive.parent_scope.module;\n+                let parent = import.parent_scope.module;\n                 match source_bindings[ns].get() {\n                     Err(Undetermined) => indeterminate = true,\n                     // Don't update the resolution, because it was never added.\n                     Err(Determined) if target.name == kw::Underscore => {}\n                     Err(Determined) => {\n                         let key = this.new_key(target, ns);\n                         this.update_resolution(parent, key, |_, resolution| {\n-                            resolution.single_imports.remove(&PtrKey(directive));\n+                            resolution.single_imports.remove(&PtrKey(import));\n                         });\n                     }\n                     Ok(binding) if !binding.is_importable() => {\n                         let msg = format!(\"`{}` is not directly importable\", target);\n-                        struct_span_err!(this.session, directive.span, E0253, \"{}\", &msg)\n-                            .span_label(directive.span, \"cannot be imported directly\")\n+                        struct_span_err!(this.session, import.span, E0253, \"{}\", &msg)\n+                            .span_label(import.span, \"cannot be imported directly\")\n                             .emit();\n                         // Do not import this illegal binding. Import a dummy binding and pretend\n                         // everything is fine\n-                        this.import_dummy_binding(directive);\n+                        this.import_dummy_binding(import);\n                     }\n                     Ok(binding) => {\n-                        let imported_binding = this.import(binding, directive);\n+                        let imported_binding = this.import(binding, import);\n                         target_bindings[ns].set(Some(imported_binding));\n                         this.define(parent, target, ns, imported_binding);\n                     }\n@@ -872,55 +871,55 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n     ///\n     /// Optionally returns an unresolved import error. This error is buffered and used to\n     /// consolidate multiple unresolved import errors into a single diagnostic.\n-    fn finalize_import(&mut self, directive: &'b Import<'b>) -> Option<UnresolvedImportError> {\n-        let orig_vis = directive.vis.replace(ty::Visibility::Invisible);\n+    fn finalize_import(&mut self, import: &'b Import<'b>) -> Option<UnresolvedImportError> {\n+        let orig_vis = import.vis.replace(ty::Visibility::Invisible);\n         let prev_ambiguity_errors_len = self.r.ambiguity_errors.len();\n         let path_res = self.r.resolve_path(\n-            &directive.module_path,\n+            &import.module_path,\n             None,\n-            &directive.parent_scope,\n+            &import.parent_scope,\n             true,\n-            directive.span,\n-            directive.crate_lint(),\n+            import.span,\n+            import.crate_lint(),\n         );\n         let no_ambiguity = self.r.ambiguity_errors.len() == prev_ambiguity_errors_len;\n-        directive.vis.set(orig_vis);\n+        import.vis.set(orig_vis);\n         if let PathResult::Failed { .. } | PathResult::NonModule(..) = path_res {\n             // Consider erroneous imports used to avoid duplicate diagnostics.\n-            self.r.used_imports.insert((directive.id, TypeNS));\n+            self.r.used_imports.insert((import.id, TypeNS));\n         }\n         let module = match path_res {\n             PathResult::Module(module) => {\n                 // Consistency checks, analogous to `finalize_macro_resolutions`.\n-                if let Some(initial_module) = directive.imported_module.get() {\n+                if let Some(initial_module) = import.imported_module.get() {\n                     if !ModuleOrUniformRoot::same_def(module, initial_module) && no_ambiguity {\n-                        span_bug!(directive.span, \"inconsistent resolution for an import\");\n+                        span_bug!(import.span, \"inconsistent resolution for an import\");\n                     }\n                 } else {\n                     if self.r.privacy_errors.is_empty() {\n                         let msg = \"cannot determine resolution for the import\";\n                         let msg_note = \"import resolution is stuck, try simplifying other imports\";\n-                        self.r.session.struct_span_err(directive.span, msg).note(msg_note).emit();\n+                        self.r.session.struct_span_err(import.span, msg).note(msg_note).emit();\n                     }\n                 }\n \n                 module\n             }\n             PathResult::Failed { is_error_from_last_segment: false, span, label, suggestion } => {\n                 if no_ambiguity {\n-                    assert!(directive.imported_module.get().is_none());\n+                    assert!(import.imported_module.get().is_none());\n                     self.r\n                         .report_error(span, ResolutionError::FailedToResolve { label, suggestion });\n                 }\n                 return None;\n             }\n             PathResult::Failed { is_error_from_last_segment: true, span, label, suggestion } => {\n                 if no_ambiguity {\n-                    assert!(directive.imported_module.get().is_none());\n+                    assert!(import.imported_module.get().is_none());\n                     let err = match self.make_path_suggestion(\n                         span,\n-                        directive.module_path.clone(),\n-                        &directive.parent_scope,\n+                        import.module_path.clone(),\n+                        &import.parent_scope,\n                     ) {\n                         Some((suggestion, note)) => UnresolvedImportError {\n                             span,\n@@ -945,15 +944,15 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             }\n             PathResult::NonModule(path_res) if path_res.base_res() == Res::Err => {\n                 if no_ambiguity {\n-                    assert!(directive.imported_module.get().is_none());\n+                    assert!(import.imported_module.get().is_none());\n                 }\n                 // The error was already reported earlier.\n                 return None;\n             }\n             PathResult::Indeterminate | PathResult::NonModule(..) => unreachable!(),\n         };\n \n-        let (ident, target, source_bindings, target_bindings, type_ns_only) = match directive.kind {\n+        let (ident, target, source_bindings, target_bindings, type_ns_only) = match import.kind {\n             ImportKind::Single {\n                 source,\n                 target,\n@@ -963,24 +962,24 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 ..\n             } => (source, target, source_bindings, target_bindings, type_ns_only),\n             ImportKind::Glob { is_prelude, ref max_vis } => {\n-                if directive.module_path.len() <= 1 {\n+                if import.module_path.len() <= 1 {\n                     // HACK(eddyb) `lint_if_path_starts_with_module` needs at least\n                     // 2 segments, so the `resolve_path` above won't trigger it.\n-                    let mut full_path = directive.module_path.clone();\n+                    let mut full_path = import.module_path.clone();\n                     full_path.push(Segment::from_ident(Ident::invalid()));\n                     self.r.lint_if_path_starts_with_module(\n-                        directive.crate_lint(),\n+                        import.crate_lint(),\n                         &full_path,\n-                        directive.span,\n+                        import.span,\n                         None,\n                     );\n                 }\n \n                 if let ModuleOrUniformRoot::Module(module) = module {\n-                    if module.def_id() == directive.parent_scope.module.def_id() {\n+                    if module.def_id() == import.parent_scope.module.def_id() {\n                         // Importing a module into itself is not allowed.\n                         return Some(UnresolvedImportError {\n-                            span: directive.span,\n+                            span: import.span,\n                             label: Some(String::from(\"cannot glob-import a module into itself\")),\n                             note: Vec::new(),\n                             suggestion: None,\n@@ -989,15 +988,10 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 }\n                 if !is_prelude &&\n                    max_vis.get() != ty::Visibility::Invisible && // Allow empty globs.\n-                   !max_vis.get().is_at_least(directive.vis.get(), &*self)\n+                   !max_vis.get().is_at_least(import.vis.get(), &*self)\n                 {\n                     let msg = \"glob import doesn't reexport anything because no candidate is public enough\";\n-                    self.r.lint_buffer.buffer_lint(\n-                        UNUSED_IMPORTS,\n-                        directive.id,\n-                        directive.span,\n-                        msg,\n-                    );\n+                    self.r.lint_buffer.buffer_lint(UNUSED_IMPORTS, import.id, import.span, msg);\n                 }\n                 return None;\n             }\n@@ -1007,21 +1001,21 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         let mut all_ns_err = true;\n         self.r.per_ns(|this, ns| {\n             if !type_ns_only || ns == TypeNS {\n-                let orig_vis = directive.vis.replace(ty::Visibility::Invisible);\n+                let orig_vis = import.vis.replace(ty::Visibility::Invisible);\n                 let orig_blacklisted_binding =\n                     mem::replace(&mut this.blacklisted_binding, target_bindings[ns].get());\n                 let orig_last_import_segment = mem::replace(&mut this.last_import_segment, true);\n                 let binding = this.resolve_ident_in_module(\n                     module,\n                     ident,\n                     ns,\n-                    &directive.parent_scope,\n+                    &import.parent_scope,\n                     true,\n-                    directive.span,\n+                    import.span,\n                 );\n                 this.last_import_segment = orig_last_import_segment;\n                 this.blacklisted_binding = orig_blacklisted_binding;\n-                directive.vis.set(orig_vis);\n+                import.vis.set(orig_vis);\n \n                 match binding {\n                     Ok(binding) => {\n@@ -1038,7 +1032,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                                         ident,\n                                         ns,\n                                         target_binding,\n-                                        directive.module_path.is_empty(),\n+                                        import.module_path.is_empty(),\n                                     );\n                                 }\n                             }\n@@ -1047,7 +1041,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                         let res = binding.res();\n                         if let Ok(initial_res) = initial_res {\n                             if res != initial_res && this.ambiguity_errors.is_empty() {\n-                                span_bug!(directive.span, \"inconsistent resolution for an import\");\n+                                span_bug!(import.span, \"inconsistent resolution for an import\");\n                             }\n                         } else {\n                             if res != Res::Err\n@@ -1058,7 +1052,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                                 let msg_note =\n                                     \"import resolution is stuck, try simplifying other imports\";\n                                 this.session\n-                                    .struct_span_err(directive.span, msg)\n+                                    .struct_span_err(import.span, msg)\n                                     .note(msg_note)\n                                     .emit();\n                             }\n@@ -1084,9 +1078,9 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                         module,\n                         ident,\n                         ns,\n-                        &directive.parent_scope,\n+                        &import.parent_scope,\n                         true,\n-                        directive.span,\n+                        import.span,\n                     );\n                     if binding.is_ok() {\n                         all_ns_failed = false;\n@@ -1137,7 +1131,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                     });\n \n                 let (suggestion, note) =\n-                    match self.check_for_module_export_macro(directive, module, ident) {\n+                    match self.check_for_module_export_macro(import, module, ident) {\n                         Some((suggestion, note)) => (suggestion.or(lev_suggestion), note),\n                         _ => (lev_suggestion, Vec::new()),\n                     };\n@@ -1163,14 +1157,14 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 };\n \n                 Some(UnresolvedImportError {\n-                    span: directive.span,\n+                    span: import.span,\n                     label: Some(label),\n                     note,\n                     suggestion,\n                 })\n             } else {\n                 // `resolve_ident_in_module` reported a privacy error.\n-                self.r.import_dummy_binding(directive);\n+                self.r.import_dummy_binding(import);\n                 None\n             };\n         }\n@@ -1179,7 +1173,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         let mut any_successful_reexport = false;\n         self.r.per_ns(|this, ns| {\n             if let Ok(binding) = source_bindings[ns].get() {\n-                let vis = directive.vis.get();\n+                let vis = import.vis.get();\n                 if !binding.pseudo_vis().is_at_least(vis, &*this) {\n                     reexport_error = Some((ns, binding));\n                 } else {\n@@ -1200,42 +1194,42 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 );\n                 self.r.lint_buffer.buffer_lint(\n                     PUB_USE_OF_PRIVATE_EXTERN_CRATE,\n-                    directive.id,\n-                    directive.span,\n+                    import.id,\n+                    import.span,\n                     &msg,\n                 );\n             } else if ns == TypeNS {\n                 struct_span_err!(\n                     self.r.session,\n-                    directive.span,\n+                    import.span,\n                     E0365,\n                     \"`{}` is private, and cannot be re-exported\",\n                     ident\n                 )\n-                .span_label(directive.span, format!(\"re-export of private `{}`\", ident))\n+                .span_label(import.span, format!(\"re-export of private `{}`\", ident))\n                 .note(&format!(\"consider declaring type or module `{}` with `pub`\", ident))\n                 .emit();\n             } else {\n                 let msg = format!(\"`{}` is private, and cannot be re-exported\", ident);\n                 let note_msg =\n                     format!(\"consider marking `{}` as `pub` in the imported module\", ident,);\n-                struct_span_err!(self.r.session, directive.span, E0364, \"{}\", &msg)\n-                    .span_note(directive.span, &note_msg)\n+                struct_span_err!(self.r.session, import.span, E0364, \"{}\", &msg)\n+                    .span_note(import.span, &note_msg)\n                     .emit();\n             }\n         }\n \n-        if directive.module_path.len() <= 1 {\n+        if import.module_path.len() <= 1 {\n             // HACK(eddyb) `lint_if_path_starts_with_module` needs at least\n             // 2 segments, so the `resolve_path` above won't trigger it.\n-            let mut full_path = directive.module_path.clone();\n+            let mut full_path = import.module_path.clone();\n             full_path.push(Segment::from_ident(ident));\n             self.r.per_ns(|this, ns| {\n                 if let Ok(binding) = source_bindings[ns].get() {\n                     this.lint_if_path_starts_with_module(\n-                        directive.crate_lint(),\n+                        import.crate_lint(),\n                         &full_path,\n-                        directive.span,\n+                        import.span,\n                         Some(binding),\n                     );\n                 }\n@@ -1247,17 +1241,11 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         // purposes it's good enough to just favor one over the other.\n         self.r.per_ns(|this, ns| {\n             if let Ok(binding) = source_bindings[ns].get() {\n-                this.import_res_map.entry(directive.id).or_default()[ns] = Some(binding.res());\n+                this.import_res_map.entry(import.id).or_default()[ns] = Some(binding.res());\n             }\n         });\n \n-        self.check_for_redundant_imports(\n-            ident,\n-            directive,\n-            source_bindings,\n-            target_bindings,\n-            target,\n-        );\n+        self.check_for_redundant_imports(ident, import, source_bindings, target_bindings, target);\n \n         debug!(\"(resolving single import) successfully resolved import\");\n         None\n@@ -1266,19 +1254,19 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n     fn check_for_redundant_imports(\n         &mut self,\n         ident: Ident,\n-        directive: &'b Import<'b>,\n+        import: &'b Import<'b>,\n         source_bindings: &PerNS<Cell<Result<&'b NameBinding<'b>, Determinacy>>>,\n         target_bindings: &PerNS<Cell<Option<&'b NameBinding<'b>>>>,\n         target: Ident,\n     ) {\n         // Skip if the import was produced by a macro.\n-        if directive.parent_scope.expansion != ExpnId::root() {\n+        if import.parent_scope.expansion != ExpnId::root() {\n             return;\n         }\n \n         // Skip if we are inside a named module (in contrast to an anonymous\n         // module defined by a block).\n-        if let ModuleKind::Def(..) = directive.parent_scope.module.kind {\n+        if let ModuleKind::Def(..) = import.parent_scope.module.kind {\n             return;\n         }\n \n@@ -1298,10 +1286,10 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 match this.early_resolve_ident_in_lexical_scope(\n                     target,\n                     ScopeSet::All(ns, false),\n-                    &directive.parent_scope,\n+                    &import.parent_scope,\n                     false,\n                     false,\n-                    directive.span,\n+                    import.span,\n                 ) {\n                     Ok(other_binding) => {\n                         is_redundant[ns] = Some(\n@@ -1323,35 +1311,35 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             redundant_spans.dedup();\n             self.r.lint_buffer.buffer_lint_with_diagnostic(\n                 UNUSED_IMPORTS,\n-                directive.id,\n-                directive.span,\n+                import.id,\n+                import.span,\n                 &format!(\"the item `{}` is imported redundantly\", ident),\n                 BuiltinLintDiagnostics::RedundantImport(redundant_spans, ident),\n             );\n         }\n     }\n \n-    fn resolve_glob_import(&mut self, directive: &'b Import<'b>) {\n-        let module = match directive.imported_module.get().unwrap() {\n+    fn resolve_glob_import(&mut self, import: &'b Import<'b>) {\n+        let module = match import.imported_module.get().unwrap() {\n             ModuleOrUniformRoot::Module(module) => module,\n             _ => {\n-                self.r.session.span_err(directive.span, \"cannot glob-import all possible crates\");\n+                self.r.session.span_err(import.span, \"cannot glob-import all possible crates\");\n                 return;\n             }\n         };\n \n         if module.is_trait() {\n-            self.r.session.span_err(directive.span, \"items in traits are not importable.\");\n+            self.r.session.span_err(import.span, \"items in traits are not importable.\");\n             return;\n-        } else if module.def_id() == directive.parent_scope.module.def_id() {\n+        } else if module.def_id() == import.parent_scope.module.def_id() {\n             return;\n-        } else if let ImportKind::Glob { is_prelude: true, .. } = directive.kind {\n+        } else if let ImportKind::Glob { is_prelude: true, .. } = import.kind {\n             self.r.prelude = Some(module);\n             return;\n         }\n \n         // Add to module's glob_importers\n-        module.glob_importers.borrow_mut().push(directive);\n+        module.glob_importers.borrow_mut().push(import);\n \n         // Ensure that `resolutions` isn't borrowed during `try_define`,\n         // since it might get updated via a glob cycle.\n@@ -1365,19 +1353,19 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             })\n             .collect::<Vec<_>>();\n         for (mut key, binding) in bindings {\n-            let scope = match key.ident.span.reverse_glob_adjust(module.expansion, directive.span) {\n+            let scope = match key.ident.span.reverse_glob_adjust(module.expansion, import.span) {\n                 Some(Some(def)) => self.r.macro_def_scope(def),\n-                Some(None) => directive.parent_scope.module,\n+                Some(None) => import.parent_scope.module,\n                 None => continue,\n             };\n             if self.r.is_accessible_from(binding.pseudo_vis(), scope) {\n-                let imported_binding = self.r.import(binding, directive);\n-                let _ = self.r.try_define(directive.parent_scope.module, key, imported_binding);\n+                let imported_binding = self.r.import(binding, import);\n+                let _ = self.r.try_define(import.parent_scope.module, key, imported_binding);\n             }\n         }\n \n         // Record the destination of this import\n-        self.r.record_partial_res(directive.id, PartialRes::new(module.res().unwrap()));\n+        self.r.record_partial_res(import.id, PartialRes::new(module.res().unwrap()));\n     }\n \n     // Miscellaneous post-processing, including recording re-exports,\n@@ -1401,12 +1389,12 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 }\n             }\n \n-            if let NameBindingKind::Import { binding: orig_binding, directive, .. } = binding.kind {\n+            if let NameBindingKind::Import { binding: orig_binding, import, .. } = binding.kind {\n                 if ns == TypeNS\n                     && orig_binding.is_variant()\n                     && !orig_binding.vis.is_at_least(binding.vis, &*this)\n                 {\n-                    let msg = match directive.kind {\n+                    let msg = match import.kind {\n                         ImportKind::Single { .. } => {\n                             format!(\"variant `{}` is private and cannot be re-exported\", ident)\n                         }\n@@ -1430,14 +1418,14 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                     };\n                     let mut err = this.session.struct_span_err(binding.span, &msg);\n \n-                    let imported_module = match directive.imported_module.get() {\n+                    let imported_module = match import.imported_module.get() {\n                         Some(ModuleOrUniformRoot::Module(module)) => module,\n                         _ => bug!(\"module should exist\"),\n                     };\n                     let parent_module = imported_module.parent.expect(\"parent should exist\");\n                     let resolutions = this.resolutions(parent_module).borrow();\n-                    let enum_path_segment_index = directive.module_path.len() - 1;\n-                    let enum_ident = directive.module_path[enum_path_segment_index].ident;\n+                    let enum_path_segment_index = import.module_path.len() - 1;\n+                    let enum_ident = import.module_path[enum_path_segment_index].ident;\n \n                     let key = this.new_key(enum_ident, TypeNS);\n                     let enum_resolution = resolutions.get(&key).expect(\"resolution should exist\");\n@@ -1484,18 +1472,18 @@ fn import_path_to_string(names: &[Ident], import_kind: &ImportKind<'_>, span: Sp\n     } else {\n         let names = if global { &names[1..] } else { names };\n         if names.is_empty() {\n-            import_directive_subclass_to_string(import_kind)\n+            import_kind_to_string(import_kind)\n         } else {\n             format!(\n                 \"{}::{}\",\n                 names_to_string(&names.iter().map(|ident| ident.name).collect::<Vec<_>>()),\n-                import_directive_subclass_to_string(import_kind),\n+                import_kind_to_string(import_kind),\n             )\n         }\n     }\n }\n \n-fn import_directive_subclass_to_string(import_kind: &ImportKind<'_>) -> String {\n+fn import_kind_to_string(import_kind: &ImportKind<'_>) -> String {\n     match import_kind {\n         ImportKind::Single { source, .. } => source.to_string(),\n         ImportKind::Glob { .. } => \"*\".to_string(),"}, {"sha": "98bb98a3a8dac6834773b429745c199a9078c9a2", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/66d7a88c41ebcc25e499babd103177a9d8df6cdb/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66d7a88c41ebcc25e499babd103177a9d8df6cdb/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=66d7a88c41ebcc25e499babd103177a9d8df6cdb", "patch": "@@ -2189,10 +2189,10 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         trait_name: Ident,\n     ) -> SmallVec<[NodeId; 1]> {\n         let mut import_ids = smallvec![];\n-        while let NameBindingKind::Import { directive, binding, .. } = kind {\n-            self.r.maybe_unused_trait_imports.insert(directive.id);\n-            self.r.add_to_glob_map(&directive, trait_name);\n-            import_ids.push(directive.id);\n+        while let NameBindingKind::Import { import, binding, .. } = kind {\n+            self.r.maybe_unused_trait_imports.insert(import.id);\n+            self.r.add_to_glob_map(&import, trait_name);\n+            import_ids.push(import.id);\n             kind = &binding.kind;\n         }\n         import_ids"}, {"sha": "492ac6ed839770f8847ad79c3257c874cd3ebd12", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 38, "deletions": 39, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/66d7a88c41ebcc25e499babd103177a9d8df6cdb/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66d7a88c41ebcc25e499babd103177a9d8df6cdb/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=66d7a88c41ebcc25e499babd103177a9d8df6cdb", "patch": "@@ -584,7 +584,7 @@ impl<'a> ToNameBinding<'a> for &'a NameBinding<'a> {\n enum NameBindingKind<'a> {\n     Res(Res, /* is_macro_export */ bool),\n     Module(Module<'a>),\n-    Import { binding: &'a NameBinding<'a>, directive: &'a Import<'a>, used: Cell<bool> },\n+    Import { binding: &'a NameBinding<'a>, import: &'a Import<'a>, used: Cell<bool> },\n }\n \n impl<'a> NameBindingKind<'a> {\n@@ -713,7 +713,7 @@ impl<'a> NameBinding<'a> {\n     fn is_extern_crate(&self) -> bool {\n         match self.kind {\n             NameBindingKind::Import {\n-                directive: &Import { kind: ImportKind::ExternCrate { .. }, .. },\n+                import: &Import { kind: ImportKind::ExternCrate { .. }, .. },\n                 ..\n             } => true,\n             NameBindingKind::Module(&ModuleData {\n@@ -733,7 +733,7 @@ impl<'a> NameBinding<'a> {\n \n     fn is_glob_import(&self) -> bool {\n         match self.kind {\n-            NameBindingKind::Import { directive, .. } => directive.is_glob(),\n+            NameBindingKind::Import { import, .. } => import.is_glob(),\n             _ => false,\n         }\n     }\n@@ -970,7 +970,7 @@ pub struct ResolverArenas<'a> {\n     modules: arena::TypedArena<ModuleData<'a>>,\n     local_modules: RefCell<Vec<Module<'a>>>,\n     name_bindings: arena::TypedArena<NameBinding<'a>>,\n-    import_directives: arena::TypedArena<Import<'a>>,\n+    imports: arena::TypedArena<Import<'a>>,\n     name_resolutions: arena::TypedArena<RefCell<NameResolution<'a>>>,\n     legacy_bindings: arena::TypedArena<LegacyBinding<'a>>,\n     ast_paths: arena::TypedArena<ast::Path>,\n@@ -990,8 +990,8 @@ impl<'a> ResolverArenas<'a> {\n     fn alloc_name_binding(&'a self, name_binding: NameBinding<'a>) -> &'a NameBinding<'a> {\n         self.name_bindings.alloc(name_binding)\n     }\n-    fn alloc_import_directive(&'a self, import_directive: Import<'a>) -> &'a Import<'_> {\n-        self.import_directives.alloc(import_directive)\n+    fn alloc_import(&'a self, import: Import<'a>) -> &'a Import<'_> {\n+        self.imports.alloc(import)\n     }\n     fn alloc_name_resolution(&'a self) -> &'a RefCell<NameResolution<'a>> {\n         self.name_resolutions.alloc(Default::default())\n@@ -1406,7 +1406,7 @@ impl<'a> Resolver<'a> {\n                 misc2: AmbiguityErrorMisc::None,\n             });\n         }\n-        if let NameBindingKind::Import { directive, binding, ref used } = used_binding.kind {\n+        if let NameBindingKind::Import { import, binding, ref used } = used_binding.kind {\n             // Avoid marking `extern crate` items that refer to a name from extern prelude,\n             // but not introduce it, as used if they are accessed from lexical scope.\n             if is_lexical_scope {\n@@ -1419,17 +1419,17 @@ impl<'a> Resolver<'a> {\n                 }\n             }\n             used.set(true);\n-            directive.used.set(true);\n-            self.used_imports.insert((directive.id, ns));\n-            self.add_to_glob_map(&directive, ident);\n+            import.used.set(true);\n+            self.used_imports.insert((import.id, ns));\n+            self.add_to_glob_map(&import, ident);\n             self.record_use(ident, ns, binding, false);\n         }\n     }\n \n     #[inline]\n-    fn add_to_glob_map(&mut self, directive: &Import<'_>, ident: Ident) {\n-        if directive.is_glob() {\n-            self.glob_map.entry(directive.id).or_default().insert(ident.name);\n+    fn add_to_glob_map(&mut self, import: &Import<'_>, ident: Ident) {\n+        if import.is_glob() {\n+            self.glob_map.entry(import.id).or_default().insert(ident.name);\n         }\n     }\n \n@@ -2254,10 +2254,9 @@ impl<'a> Resolver<'a> {\n         // `ExternCrate` (also used for `crate::...`) then no need to issue a\n         // warning, this looks all good!\n         if let Some(binding) = second_binding {\n-            if let NameBindingKind::Import { directive: d, .. } = binding.kind {\n-                // Careful: we still want to rewrite paths from\n-                // renamed extern crates.\n-                if let ImportKind::ExternCrate { source: None, .. } = d.kind {\n+            if let NameBindingKind::Import { import, .. } = binding.kind {\n+                // Careful: we still want to rewrite paths from renamed extern crates.\n+                if let ImportKind::ExternCrate { source: None, .. } = import.kind {\n                     return;\n                 }\n             }\n@@ -2560,10 +2559,10 @@ impl<'a> Resolver<'a> {\n \n         // See https://github.com/rust-lang/rust/issues/32354\n         use NameBindingKind::Import;\n-        let directive = match (&new_binding.kind, &old_binding.kind) {\n+        let import = match (&new_binding.kind, &old_binding.kind) {\n             // If there are two imports where one or both have attributes then prefer removing the\n             // import without attributes.\n-            (Import { directive: new, .. }, Import { directive: old, .. })\n+            (Import { import: new, .. }, Import { import: old, .. })\n                 if {\n                     !new_binding.span.is_dummy()\n                         && !old_binding.span.is_dummy()\n@@ -2577,11 +2576,11 @@ impl<'a> Resolver<'a> {\n                 }\n             }\n             // Otherwise prioritize the new binding.\n-            (Import { directive, .. }, other) if !new_binding.span.is_dummy() => {\n-                Some((directive, new_binding.span, other.is_import()))\n+            (Import { import, .. }, other) if !new_binding.span.is_dummy() => {\n+                Some((import, new_binding.span, other.is_import()))\n             }\n-            (other, Import { directive, .. }) if !old_binding.span.is_dummy() => {\n-                Some((directive, old_binding.span, other.is_import()))\n+            (other, Import { import, .. }) if !old_binding.span.is_dummy() => {\n+                Some((import, old_binding.span, other.is_import()))\n             }\n             _ => None,\n         };\n@@ -2598,22 +2597,22 @@ impl<'a> Resolver<'a> {\n             && !has_dummy_span\n             && ((new_binding.is_extern_crate() || old_binding.is_extern_crate()) || from_item);\n \n-        match directive {\n-            Some((directive, span, true)) if should_remove_import && directive.is_nested() => {\n-                self.add_suggestion_for_duplicate_nested_use(&mut err, directive, span)\n+        match import {\n+            Some((import, span, true)) if should_remove_import && import.is_nested() => {\n+                self.add_suggestion_for_duplicate_nested_use(&mut err, import, span)\n             }\n-            Some((directive, _, true)) if should_remove_import && !directive.is_glob() => {\n+            Some((import, _, true)) if should_remove_import && !import.is_glob() => {\n                 // Simple case - remove the entire import. Due to the above match arm, this can\n                 // only be a single use so just remove it entirely.\n                 err.tool_only_span_suggestion(\n-                    directive.use_span_with_attributes,\n+                    import.use_span_with_attributes,\n                     \"remove unnecessary import\",\n                     String::new(),\n                     Applicability::MaybeIncorrect,\n                 );\n             }\n-            Some((directive, span, _)) => {\n-                self.add_suggestion_for_rename_of_use(&mut err, name, directive, span)\n+            Some((import, span, _)) => {\n+                self.add_suggestion_for_rename_of_use(&mut err, name, import, span)\n             }\n             _ => {}\n         }\n@@ -2635,7 +2634,7 @@ impl<'a> Resolver<'a> {\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n         name: Name,\n-        directive: &Import<'_>,\n+        import: &Import<'_>,\n         binding_span: Span,\n     ) {\n         let suggested_name = if name.as_str().chars().next().unwrap().is_uppercase() {\n@@ -2645,7 +2644,7 @@ impl<'a> Resolver<'a> {\n         };\n \n         let mut suggestion = None;\n-        match directive.kind {\n+        match import.kind {\n             ImportKind::Single { type_ns_only: true, .. } => {\n                 suggestion = Some(format!(\"self as {}\", suggested_name))\n             }\n@@ -2707,27 +2706,27 @@ impl<'a> Resolver<'a> {\n     /// If the nested use contains only one import then the suggestion will remove the entire\n     /// line.\n     ///\n-    /// It is expected that the directive provided is a nested import - this isn't checked by the\n+    /// It is expected that the provided import is nested - this isn't checked by the\n     /// function. If this invariant is not upheld, this function's behaviour will be unexpected\n     /// as characters expected by span manipulations won't be present.\n     fn add_suggestion_for_duplicate_nested_use(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n-        directive: &Import<'_>,\n+        import: &Import<'_>,\n         binding_span: Span,\n     ) {\n-        assert!(directive.is_nested());\n+        assert!(import.is_nested());\n         let message = \"remove unnecessary import\";\n \n         // Two examples will be used to illustrate the span manipulations we're doing:\n         //\n         // - Given `use issue_52891::{d, a, e};` where `a` is a duplicate then `binding_span` is\n-        //   `a` and `directive.use_span` is `issue_52891::{d, a, e};`.\n+        //   `a` and `import.use_span` is `issue_52891::{d, a, e};`.\n         // - Given `use issue_52891::{d, e, a};` where `a` is a duplicate then `binding_span` is\n-        //   `a` and `directive.use_span` is `issue_52891::{d, e, a};`.\n+        //   `a` and `import.use_span` is `issue_52891::{d, e, a};`.\n \n         let (found_closing_brace, span) =\n-            find_span_of_binding_until_next_binding(self.session, binding_span, directive.use_span);\n+            find_span_of_binding_until_next_binding(self.session, binding_span, import.use_span);\n \n         // If there was a closing brace then identify the span to remove any trailing commas from\n         // previous imports.\n@@ -2743,7 +2742,7 @@ impl<'a> Resolver<'a> {\n                 // Remove the entire line if we cannot extend the span back, this indicates a\n                 // `issue_52891::{self}` case.\n                 err.span_suggestion(\n-                    directive.use_span_with_attributes,\n+                    import.use_span_with_attributes,\n                     message,\n                     String::new(),\n                     Applicability::MaybeIncorrect,"}, {"sha": "65400163ddd86ab09fe09102de41923eabda44d5", "filename": "src/test/ui/rust-2018/macro-use-warned-against.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66d7a88c41ebcc25e499babd103177a9d8df6cdb/src%2Ftest%2Fui%2Frust-2018%2Fmacro-use-warned-against.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66d7a88c41ebcc25e499babd103177a9d8df6cdb/src%2Ftest%2Fui%2Frust-2018%2Fmacro-use-warned-against.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fmacro-use-warned-against.rs?ref=66d7a88c41ebcc25e499babd103177a9d8df6cdb", "patch": "@@ -4,7 +4,7 @@\n \n #![warn(macro_use_extern_crate, unused)]\n \n-#[macro_use] //~ WARN should be replaced at use sites with a `use` statement\n+#[macro_use] //~ WARN should be replaced at use sites with a `use` item\n extern crate macro_use_warned_against;\n #[macro_use] //~ WARN unused `#[macro_use]`\n extern crate macro_use_warned_against2;"}, {"sha": "ef00b865815c06032c5b268751921c2904350b16", "filename": "src/test/ui/rust-2018/macro-use-warned-against.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66d7a88c41ebcc25e499babd103177a9d8df6cdb/src%2Ftest%2Fui%2Frust-2018%2Fmacro-use-warned-against.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/66d7a88c41ebcc25e499babd103177a9d8df6cdb/src%2Ftest%2Fui%2Frust-2018%2Fmacro-use-warned-against.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fmacro-use-warned-against.stderr?ref=66d7a88c41ebcc25e499babd103177a9d8df6cdb", "patch": "@@ -1,4 +1,4 @@\n-warning: deprecated `#[macro_use]` directive used to import macros should be replaced at use sites with a `use` statement to import the macro instead\n+warning: deprecated `#[macro_use]` attribute used to import macros should be replaced at use sites with a `use` item to import the macro instead\n   --> $DIR/macro-use-warned-against.rs:7:1\n    |\n LL | #[macro_use]"}]}