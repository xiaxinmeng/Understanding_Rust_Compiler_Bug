{"sha": "3f50dea4d0dfce527871bb0a198dc17c479e697b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmNTBkZWE0ZDBkZmNlNTI3ODcxYmIwYTE5OGRjMTdjNDc5ZTY5N2I=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-17T01:41:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-17T01:41:43Z"}, "message": "Auto merge of #78033 - Dylan-DPC:rollup-ds2cfsf, r=Dylan-DPC\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #76199 (Permit uninhabited enums to cast into ints)\n - #77751 (liballoc: VecDeque: Add binary search functions)\n - #77785 (Remove compiler-synthesized reexports when documenting)\n - #77932 (BTreeMap: improve gdb introspection of BTreeMap with ZST keys or values)\n - #77961 (Set .llvmbc and .llvmcmd sections as allocatable)\n - #77985 (llvm: backport SystemZ fix for AGR clobbers)\n\nFailed merges:\n\nr? `@ghost`", "tree": {"sha": "bdde49e8d12de219742f63555eed23fde2ced051", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bdde49e8d12de219742f63555eed23fde2ced051"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3f50dea4d0dfce527871bb0a198dc17c479e697b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3f50dea4d0dfce527871bb0a198dc17c479e697b", "html_url": "https://github.com/rust-lang/rust/commit/3f50dea4d0dfce527871bb0a198dc17c479e697b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3f50dea4d0dfce527871bb0a198dc17c479e697b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f1b97ee7f8ffb1a814944b85c7e05a1555a7eda5", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1b97ee7f8ffb1a814944b85c7e05a1555a7eda5", "html_url": "https://github.com/rust-lang/rust/commit/f1b97ee7f8ffb1a814944b85c7e05a1555a7eda5"}, {"sha": "b9c45d1e782f710bae7b8d43c1863848b8f660a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/b9c45d1e782f710bae7b8d43c1863848b8f660a5", "html_url": "https://github.com/rust-lang/rust/commit/b9c45d1e782f710bae7b8d43c1863848b8f660a5"}], "stats": {"total": 276, "additions": 238, "deletions": 38}, "files": [{"sha": "092d1cea295153742cd7dbfd20361cdcd373e38f", "filename": "compiler/rustc_codegen_llvm/src/back/write.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f50dea4d0dfce527871bb0a198dc17c479e697b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f50dea4d0dfce527871bb0a198dc17c479e697b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs?ref=3f50dea4d0dfce527871bb0a198dc17c479e697b", "patch": "@@ -936,8 +936,8 @@ unsafe fn embed_bitcode(\n         llvm::LLVMRustAppendModuleInlineAsm(llmod, asm.as_ptr().cast(), asm.len());\n     } else {\n         let asm = \"\n-            .section .llvmbc,\\\"e\\\"\n-            .section .llvmcmd,\\\"e\\\"\n+            .section .llvmbc,\\\"a\\\"\n+            .section .llvmcmd,\\\"a\\\"\n         \";\n         llvm::LLVMRustAppendModuleInlineAsm(llmod, asm.as_ptr().cast(), asm.len());\n     }"}, {"sha": "bc84eccfcf56c9b0de99ec811804e5b7df886618", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f50dea4d0dfce527871bb0a198dc17c479e697b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f50dea4d0dfce527871bb0a198dc17c479e697b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=3f50dea4d0dfce527871bb0a198dc17c479e697b", "patch": "@@ -2436,8 +2436,10 @@ impl<'tcx> AdtDef {\n         self.variants.iter().flat_map(|v| v.fields.iter())\n     }\n \n+    /// Whether the ADT lacks fields. Note that this includes uninhabited enums,\n+    /// e.g., `enum Void {}` is considered payload free as well.\n     pub fn is_payloadfree(&self) -> bool {\n-        !self.variants.is_empty() && self.variants.iter().all(|v| v.fields.is_empty())\n+        self.variants.iter().all(|v| v.fields.is_empty())\n     }\n \n     /// Return a `VariantDef` given a variant id."}, {"sha": "affeae546b2aafce2fe45d4d558194f428a2d32b", "filename": "compiler/rustc_mir/src/interpret/cast.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3f50dea4d0dfce527871bb0a198dc17c479e697b/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f50dea4d0dfce527871bb0a198dc17c479e697b/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fcast.rs?ref=3f50dea4d0dfce527871bb0a198dc17c479e697b", "patch": "@@ -139,9 +139,14 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n         // # First handle non-scalar source values.\n \n-        // Handle cast from a univariant (ZST) enum.\n+        // Handle cast from a ZST enum (0 or 1 variants).\n         match src.layout.variants {\n             Variants::Single { index } => {\n+                if src.layout.abi.is_uninhabited() {\n+                    // This is dead code, because an uninhabited enum is UB to\n+                    // instantiate.\n+                    throw_ub!(Unreachable);\n+                }\n                 if let Some(discr) = src.layout.ty.discriminant_for_variant(*self.tcx, index) {\n                     assert!(src.layout.is_zst());\n                     let discr_layout = self.layout_of(discr.ty)?;"}, {"sha": "cf7961cbbfc2f3ba5ff4fbd2ecb7d6a6619e4ada", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3f50dea4d0dfce527871bb0a198dc17c479e697b/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f50dea4d0dfce527871bb0a198dc17c479e697b/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=3f50dea4d0dfce527871bb0a198dc17c479e697b", "patch": "@@ -87,7 +87,6 @@ impl<K, V> LeafNode<K, V> {\n #[repr(C)]\n // gdb_providers.py uses this type name for introspection.\n struct InternalNode<K, V> {\n-    // gdb_providers.py uses this field name for introspection.\n     data: LeafNode<K, V>,\n \n     /// The pointers to the children of this node. `len + 1` of these are considered"}, {"sha": "94dac1cd1769b455389362e95965b7188d51000f", "filename": "library/alloc/src/collections/vec_deque.rs", "status": "modified", "additions": 138, "deletions": 1, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/3f50dea4d0dfce527871bb0a198dc17c479e697b/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f50dea4d0dfce527871bb0a198dc17c479e697b/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque.rs?ref=3f50dea4d0dfce527871bb0a198dc17c479e697b", "patch": "@@ -2181,7 +2181,7 @@ impl<T> VecDeque<T> {\n     ///\n     /// This method does not allocate and does not change the order of the\n     /// inserted elements. As it returns a mutable slice, this can be used to\n-    /// sort or binary search a deque.\n+    /// sort a deque.\n     ///\n     /// Once the internal storage is contiguous, the [`as_slices`] and\n     /// [`as_mut_slices`] methods will return the entire contents of the\n@@ -2430,6 +2430,143 @@ impl<T> VecDeque<T> {\n             self.wrap_copy(self.tail, self.head, k);\n         }\n     }\n+\n+    /// Binary searches this sorted `VecDeque` for a given element.\n+    ///\n+    /// If the value is found then [`Result::Ok`] is returned, containing the\n+    /// index of the matching element. If there are multiple matches, then any\n+    /// one of the matches could be returned. If the value is not found then\n+    /// [`Result::Err`] is returned, containing the index where a matching\n+    /// element could be inserted while maintaining sorted order.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Looks up a series of four elements. The first is found, with a\n+    /// uniquely determined position; the second and third are not\n+    /// found; the fourth could match any position in `[1, 4]`.\n+    ///\n+    /// ```\n+    /// #![feature(vecdeque_binary_search)]\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let deque: VecDeque<_> = vec![0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55].into();\n+    ///\n+    /// assert_eq!(deque.binary_search(&13),  Ok(9));\n+    /// assert_eq!(deque.binary_search(&4),   Err(7));\n+    /// assert_eq!(deque.binary_search(&100), Err(13));\n+    /// let r = deque.binary_search(&1);\n+    /// assert!(matches!(r, Ok(1..=4)));\n+    /// ```\n+    ///\n+    /// If you want to insert an item to a sorted `VecDeque`, while maintaining\n+    /// sort order:\n+    ///\n+    /// ```\n+    /// #![feature(vecdeque_binary_search)]\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let mut deque: VecDeque<_> = vec![0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55].into();\n+    /// let num = 42;\n+    /// let idx = deque.binary_search(&num).unwrap_or_else(|x| x);\n+    /// deque.insert(idx, num);\n+    /// assert_eq!(deque, &[0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 42, 55]);\n+    /// ```\n+    #[unstable(feature = \"vecdeque_binary_search\", issue = \"78021\")]\n+    #[inline]\n+    pub fn binary_search(&self, x: &T) -> Result<usize, usize>\n+    where\n+        T: Ord,\n+    {\n+        self.binary_search_by(|e| e.cmp(x))\n+    }\n+\n+    /// Binary searches this sorted `VecDeque` with a comparator function.\n+    ///\n+    /// The comparator function should implement an order consistent\n+    /// with the sort order of the underlying `VecDeque`, returning an\n+    /// order code that indicates whether its argument is `Less`,\n+    /// `Equal` or `Greater` than the desired target.\n+    ///\n+    /// If the value is found then [`Result::Ok`] is returned, containing the\n+    /// index of the matching element. If there are multiple matches, then any\n+    /// one of the matches could be returned. If the value is not found then\n+    /// [`Result::Err`] is returned, containing the index where a matching\n+    /// element could be inserted while maintaining sorted order.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Looks up a series of four elements. The first is found, with a\n+    /// uniquely determined position; the second and third are not\n+    /// found; the fourth could match any position in `[1, 4]`.\n+    ///\n+    /// ```\n+    /// #![feature(vecdeque_binary_search)]\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let deque: VecDeque<_> = vec![0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55].into();\n+    ///\n+    /// assert_eq!(deque.binary_search_by(|x| x.cmp(&13)),  Ok(9));\n+    /// assert_eq!(deque.binary_search_by(|x| x.cmp(&4)),   Err(7));\n+    /// assert_eq!(deque.binary_search_by(|x| x.cmp(&100)), Err(13));\n+    /// let r = deque.binary_search_by(|x| x.cmp(&1));\n+    /// assert!(matches!(r, Ok(1..=4)));\n+    /// ```\n+    #[unstable(feature = \"vecdeque_binary_search\", issue = \"78021\")]\n+    pub fn binary_search_by<'a, F>(&'a self, mut f: F) -> Result<usize, usize>\n+    where\n+        F: FnMut(&'a T) -> Ordering,\n+    {\n+        let (front, back) = self.as_slices();\n+\n+        if let Some(Ordering::Less | Ordering::Equal) = back.first().map(|elem| f(elem)) {\n+            back.binary_search_by(f).map(|idx| idx + front.len()).map_err(|idx| idx + front.len())\n+        } else {\n+            front.binary_search_by(f)\n+        }\n+    }\n+\n+    /// Binary searches this sorted `VecDeque` with a key extraction function.\n+    ///\n+    /// Assumes that the `VecDeque` is sorted by the key, for instance with\n+    /// [`make_contiguous().sort_by_key()`](#method.make_contiguous) using the same\n+    /// key extraction function.\n+    ///\n+    /// If the value is found then [`Result::Ok`] is returned, containing the\n+    /// index of the matching element. If there are multiple matches, then any\n+    /// one of the matches could be returned. If the value is not found then\n+    /// [`Result::Err`] is returned, containing the index where a matching\n+    /// element could be inserted while maintaining sorted order.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Looks up a series of four elements in a slice of pairs sorted by\n+    /// their second elements. The first is found, with a uniquely\n+    /// determined position; the second and third are not found; the\n+    /// fourth could match any position in `[1, 4]`.\n+    ///\n+    /// ```\n+    /// #![feature(vecdeque_binary_search)]\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let deque: VecDeque<_> = vec![(0, 0), (2, 1), (4, 1), (5, 1),\n+    ///          (3, 1), (1, 2), (2, 3), (4, 5), (5, 8), (3, 13),\n+    ///          (1, 21), (2, 34), (4, 55)].into();\n+    ///\n+    /// assert_eq!(deque.binary_search_by_key(&13, |&(a,b)| b),  Ok(9));\n+    /// assert_eq!(deque.binary_search_by_key(&4, |&(a,b)| b),   Err(7));\n+    /// assert_eq!(deque.binary_search_by_key(&100, |&(a,b)| b), Err(13));\n+    /// let r = deque.binary_search_by_key(&1, |&(a,b)| b);\n+    /// assert!(matches!(r, Ok(1..=4)));\n+    /// ```\n+    #[unstable(feature = \"vecdeque_binary_search\", issue = \"78021\")]\n+    #[inline]\n+    pub fn binary_search_by_key<'a, B, F>(&'a self, b: &B, mut f: F) -> Result<usize, usize>\n+    where\n+        F: FnMut(&'a T) -> B,\n+        B: Ord,\n+    {\n+        self.binary_search_by(|k| f(k).cmp(b))\n+    }\n }\n \n impl<T: Clone> VecDeque<T> {"}, {"sha": "b7cc03f8eb999403f45f2a70939bbf92f960c569", "filename": "library/alloc/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3f50dea4d0dfce527871bb0a198dc17c479e697b/library%2Falloc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f50dea4d0dfce527871bb0a198dc17c479e697b/library%2Falloc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Flib.rs?ref=3f50dea4d0dfce527871bb0a198dc17c479e697b", "patch": "@@ -20,6 +20,7 @@\n #![feature(inplace_iteration)]\n #![feature(iter_map_while)]\n #![feature(int_bits_const)]\n+#![feature(vecdeque_binary_search)]\n \n use std::collections::hash_map::DefaultHasher;\n use std::hash::{Hash, Hasher};"}, {"sha": "05cb3a2c03d79a49780436dfe9889e918af955af", "filename": "library/alloc/tests/vec_deque.rs", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/3f50dea4d0dfce527871bb0a198dc17c479e697b/library%2Falloc%2Ftests%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f50dea4d0dfce527871bb0a198dc17c479e697b/library%2Falloc%2Ftests%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fvec_deque.rs?ref=3f50dea4d0dfce527871bb0a198dc17c479e697b", "patch": "@@ -1659,3 +1659,42 @@ fn test_drain_leak() {\n     drop(v);\n     assert_eq!(unsafe { DROPS }, 7);\n }\n+\n+#[test]\n+fn test_binary_search() {\n+    // Contiguous (front only) search:\n+    let deque: VecDeque<_> = vec![1, 2, 3, 5, 6].into();\n+    assert!(deque.as_slices().1.is_empty());\n+    assert_eq!(deque.binary_search(&3), Ok(2));\n+    assert_eq!(deque.binary_search(&4), Err(3));\n+\n+    // Split search (both front & back non-empty):\n+    let mut deque: VecDeque<_> = vec![5, 6].into();\n+    deque.push_front(3);\n+    deque.push_front(2);\n+    deque.push_front(1);\n+    deque.push_back(10);\n+    assert!(!deque.as_slices().0.is_empty());\n+    assert!(!deque.as_slices().1.is_empty());\n+    assert_eq!(deque.binary_search(&0), Err(0));\n+    assert_eq!(deque.binary_search(&1), Ok(0));\n+    assert_eq!(deque.binary_search(&5), Ok(3));\n+    assert_eq!(deque.binary_search(&7), Err(5));\n+    assert_eq!(deque.binary_search(&20), Err(6));\n+}\n+\n+#[test]\n+fn test_binary_search_by() {\n+    let deque: VecDeque<_> = vec![(1,), (2,), (3,), (5,), (6,)].into();\n+\n+    assert_eq!(deque.binary_search_by(|&(v,)| v.cmp(&3)), Ok(2));\n+    assert_eq!(deque.binary_search_by(|&(v,)| v.cmp(&4)), Err(3));\n+}\n+\n+#[test]\n+fn test_binary_search_by_key() {\n+    let deque: VecDeque<_> = vec![(1,), (2,), (3,), (5,), (6,)].into();\n+\n+    assert_eq!(deque.binary_search_by_key(&3, |&(v,)| v), Ok(2));\n+    assert_eq!(deque.binary_search_by_key(&4, |&(v,)| v), Err(3));\n+}"}, {"sha": "eec3027085c91290b67805b535db184bce259d3b", "filename": "src/etc/gdb_providers.py", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3f50dea4d0dfce527871bb0a198dc17c479e697b/src%2Fetc%2Fgdb_providers.py", "raw_url": "https://github.com/rust-lang/rust/raw/3f50dea4d0dfce527871bb0a198dc17c479e697b/src%2Fetc%2Fgdb_providers.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_providers.py?ref=3f50dea4d0dfce527871bb0a198dc17c479e697b", "patch": "@@ -229,8 +229,8 @@ def cast_to_internal(node):\n                 yield child\n         if i < length:\n             # Avoid \"Cannot perform pointer math on incomplete type\" on zero-sized arrays.\n-            key = keys[i][\"value\"][\"value\"] if keys.type.sizeof > 0 else None\n-            val = vals[i][\"value\"][\"value\"] if vals.type.sizeof > 0 else None\n+            key = keys[i][\"value\"][\"value\"] if keys.type.sizeof > 0 else \"()\"\n+            val = vals[i][\"value\"][\"value\"] if vals.type.sizeof > 0 else \"()\"\n             yield key, val\n \n \n@@ -242,11 +242,8 @@ def children_of_map(map):\n             root = root.cast(gdb.lookup_type(root.type.name[21:-1]))\n         boxed_root_node = root[\"node\"]\n         height = root[\"height\"]\n-        for i, (key, val) in enumerate(children_of_node(boxed_root_node, height)):\n-            if key is not None:\n-                yield \"key{}\".format(i), key\n-            if val is not None:\n-                yield \"val{}\".format(i), val\n+        for child in children_of_node(boxed_root_node, height):\n+            yield child\n \n \n class StdBTreeSetProvider:\n@@ -258,8 +255,8 @@ def to_string(self):\n \n     def children(self):\n         inner_map = self.valobj[\"map\"]\n-        for child in children_of_map(inner_map):\n-            yield child\n+        for i, (child, _) in enumerate(children_of_map(inner_map)):\n+            yield \"[{}]\".format(i), child\n \n     @staticmethod\n     def display_hint():\n@@ -274,8 +271,9 @@ def to_string(self):\n         return \"BTreeMap(size={})\".format(self.valobj[\"length\"])\n \n     def children(self):\n-        for child in children_of_map(self.valobj):\n-            yield child\n+        for i, (key, val) in enumerate(children_of_map(self.valobj)):\n+            yield \"key{}\".format(i), key\n+            yield \"val{}\".format(i), val\n \n     @staticmethod\n     def display_hint():"}, {"sha": "0365a8b48db3779b545a120073c6373b85f01648", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3f50dea4d0dfce527871bb0a198dc17c479e697b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f50dea4d0dfce527871bb0a198dc17c479e697b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=3f50dea4d0dfce527871bb0a198dc17c479e697b", "patch": "@@ -23,9 +23,9 @@ use rustc_middle::ty::fold::TypeFolder;\n use rustc_middle::ty::subst::{InternalSubsts, Subst};\n use rustc_middle::ty::{self, AdtKind, Lift, Ty, TyCtxt};\n use rustc_mir::const_eval::{is_const_fn, is_min_const_fn, is_unstable_const_fn};\n-use rustc_span::hygiene::MacroKind;\n+use rustc_span::hygiene::{AstPass, MacroKind};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n-use rustc_span::{self, Pos};\n+use rustc_span::{self, ExpnKind, Pos};\n use rustc_typeck::hir_ty_to_ty;\n \n use std::collections::hash_map::Entry;\n@@ -2231,6 +2231,13 @@ impl Clean<Vec<Item>> for doctree::ExternCrate<'_> {\n \n impl Clean<Vec<Item>> for doctree::Import<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Vec<Item> {\n+        // We need this comparison because some imports (for std types for example)\n+        // are \"inserted\" as well but directly by the compiler and they should not be\n+        // taken into account.\n+        if self.span.ctxt().outer_expn_data().kind == ExpnKind::AstPass(AstPass::StdImports) {\n+            return Vec::new();\n+        }\n+\n         // We consider inlining the documentation of `pub use` statements, but we\n         // forcefully don't inline if this is not public or if the\n         // #[doc(no_inline)] attribute is present."}, {"sha": "77a0125981b293260c9aec6355dff46ec707ab59", "filename": "src/llvm-project", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm-project?ref=3f50dea4d0dfce527871bb0a198dc17c479e697b", "patch": "@@ -1 +1 @@\n-Subproject commit 3c5d47c81d78e9316e971c9870e8bc7c2c449d24\n+Subproject commit 77a0125981b293260c9aec6355dff46ec707ab59"}, {"sha": "cc2a3a345102aace498beff496b51269d4145ced", "filename": "src/test/debuginfo/pretty-std-collections.rs", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3f50dea4d0dfce527871bb0a198dc17c479e697b/src%2Ftest%2Fdebuginfo%2Fpretty-std-collections.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f50dea4d0dfce527871bb0a198dc17c479e697b/src%2Ftest%2Fdebuginfo%2Fpretty-std-collections.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fpretty-std-collections.rs?ref=3f50dea4d0dfce527871bb0a198dc17c479e697b", "patch": "@@ -34,20 +34,26 @@\n // gdb-check:$6 = BTreeMap(size=15) = {[0] = pretty_std_collections::MyLeafNode (0), [...]}\n // (abbreviated because it's boring but we need enough elements to include internal nodes)\n \n-// gdb-command: print zst_btree_map\n-// gdb-check:$7 = BTreeMap(size=1)\n+// gdb-command: print zst_key_btree_map\n+// gdb-check:$7 = BTreeMap(size=1) = {[()] = 1}\n+\n+// gdb-command: print zst_val_btree_map\n+// gdb-check:$8 = BTreeMap(size=1) = {[1] = ()}\n+\n+// gdb-command: print zst_key_val_btree_map\n+// gdb-check:$9 = BTreeMap(size=1) = {[()] = ()}\n \n // gdb-command: print vec_deque\n-// gdb-check:$8 = VecDeque(size=3) = {5, 3, 7}\n+// gdb-check:$10 = VecDeque(size=3) = {5, 3, 7}\n \n // gdb-command: print vec_deque2\n-// gdb-check:$9 = VecDeque(size=7) = {2, 3, 4, 5, 6, 7, 8}\n+// gdb-check:$11 = VecDeque(size=7) = {2, 3, 4, 5, 6, 7, 8}\n \n // gdb-command: print hash_map\n-// gdb-check:$10 = HashMap(size=4) = {[1] = 10, [2] = 20, [3] = 30, [4] = 40}\n+// gdb-check:$12 = HashMap(size=4) = {[1] = 10, [2] = 20, [3] = 30, [4] = 40}\n \n // gdb-command: print hash_set\n-// gdb-check:$11 = HashSet(size=4) = {1, 2, 3, 4}\n+// gdb-check:$13 = HashSet(size=4) = {1, 2, 3, 4}\n \n // === LLDB TESTS ==================================================================================\n \n@@ -114,8 +120,14 @@ fn main() {\n         nasty_btree_map.insert(i, MyLeafNode(i));\n     }\n \n-    let mut zst_btree_map: BTreeMap<(), ()> = BTreeMap::new();\n-    zst_btree_map.insert((), ());\n+    let mut zst_key_btree_map: BTreeMap<(), i32> = BTreeMap::new();\n+    zst_key_btree_map.insert((), 1);\n+\n+    let mut zst_val_btree_map: BTreeMap<i32, ()> = BTreeMap::new();\n+    zst_val_btree_map.insert(1, ());\n+\n+    let mut zst_key_val_btree_map: BTreeMap<(), ()> = BTreeMap::new();\n+    zst_key_val_btree_map.insert((), ());\n \n     // VecDeque\n     let mut vec_deque = VecDeque::new();"}, {"sha": "6d50325fed550a5b1b42bd9a3f917f2c7f8d3c8c", "filename": "src/test/rustdoc/no-compiler-reexport.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3f50dea4d0dfce527871bb0a198dc17c479e697b/src%2Ftest%2Frustdoc%2Fno-compiler-reexport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f50dea4d0dfce527871bb0a198dc17c479e697b/src%2Ftest%2Frustdoc%2Fno-compiler-reexport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fno-compiler-reexport.rs?ref=3f50dea4d0dfce527871bb0a198dc17c479e697b", "patch": "@@ -0,0 +1,7 @@\n+// compile-flags: --no-defaults\n+\n+#![crate_name = \"foo\"]\n+\n+// @has 'foo/index.html' '//code' 'extern crate std;'\n+// @!has 'foo/index.html' '//code' 'use std::prelude::v1::*;'\n+pub struct Foo;"}, {"sha": "5a75c94c42f0bdd7244825d61d477012836e883a", "filename": "src/test/ui/uninhabited/uninhabited-enum-cast.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f50dea4d0dfce527871bb0a198dc17c479e697b/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-enum-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f50dea4d0dfce527871bb0a198dc17c479e697b/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-enum-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-enum-cast.rs?ref=3f50dea4d0dfce527871bb0a198dc17c479e697b", "patch": "@@ -1,7 +1,9 @@\n+// check-pass\n+\n enum E {}\n \n fn f(e: E) {\n-    println!(\"{}\", (e as isize).to_string());   //~ ERROR non-primitive cast\n+    println!(\"{}\", (e as isize).to_string());\n }\n \n fn main() {}"}, {"sha": "a9f10dfec994a9e4c7a71ca776e2fca44abb058f", "filename": "src/test/ui/uninhabited/uninhabited-enum-cast.stderr", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f1b97ee7f8ffb1a814944b85c7e05a1555a7eda5/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-enum-cast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1b97ee7f8ffb1a814944b85c7e05a1555a7eda5/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-enum-cast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-enum-cast.stderr?ref=f1b97ee7f8ffb1a814944b85c7e05a1555a7eda5", "patch": "@@ -1,9 +0,0 @@\n-error[E0605]: non-primitive cast: `E` as `isize`\n-  --> $DIR/uninhabited-enum-cast.rs:4:20\n-   |\n-LL |     println!(\"{}\", (e as isize).to_string());\n-   |                    ^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0605`."}]}