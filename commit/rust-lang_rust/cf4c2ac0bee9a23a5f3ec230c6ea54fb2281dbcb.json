{"sha": "cf4c2ac0bee9a23a5f3ec230c6ea54fb2281dbcb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmNGMyYWMwYmVlOWEyM2E1ZjNlYzIzMGM2ZWE1NGZiMjI4MWRiY2I=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-07-06T23:28:07Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-07-07T01:26:22Z"}, "message": "Generate a main fn for test running. Issue #428", "tree": {"sha": "d8f55b1efc15d0d4ec80d16d412028b38870cb89", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d8f55b1efc15d0d4ec80d16d412028b38870cb89"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf4c2ac0bee9a23a5f3ec230c6ea54fb2281dbcb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf4c2ac0bee9a23a5f3ec230c6ea54fb2281dbcb", "html_url": "https://github.com/rust-lang/rust/commit/cf4c2ac0bee9a23a5f3ec230c6ea54fb2281dbcb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf4c2ac0bee9a23a5f3ec230c6ea54fb2281dbcb/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6ca81b34079f6529ae385479d74496187c8063c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ca81b34079f6529ae385479d74496187c8063c2", "html_url": "https://github.com/rust-lang/rust/commit/6ca81b34079f6529ae385479d74496187c8063c2"}], "stats": {"total": 98, "additions": 80, "deletions": 18}, "files": [{"sha": "992d052839fbc389526b6951de6e3e9a6d01d711", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf4c2ac0bee9a23a5f3ec230c6ea54fb2281dbcb/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf4c2ac0bee9a23a5f3ec230c6ea54fb2281dbcb/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=cf4c2ac0bee9a23a5f3ec230c6ea54fb2281dbcb", "patch": "@@ -107,7 +107,7 @@ fn compile_input(session::session sess, ast::crate_cfg cfg, str input,\n                  bind front::config::strip_unconfigured_items(crate));\n     if (sess.get_opts().test) {\n         crate = time(time_passes, \"building test harness\",\n-                     bind front::test::modify_for_testing(sess, crate));\n+                     bind front::test::modify_for_testing(crate));\n     }\n     auto ast_map = time(time_passes, \"ast indexing\",\n                         bind middle::ast_map::map_crate(*crate));"}, {"sha": "aae0af125363a895ff379f35f5742dc286e88bc6", "filename": "src/comp/front/test.rs", "status": "modified", "additions": 79, "deletions": 17, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/cf4c2ac0bee9a23a5f3ec230c6ea54fb2281dbcb/src%2Fcomp%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf4c2ac0bee9a23a5f3ec230c6ea54fb2281dbcb/src%2Fcomp%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Ftest.rs?ref=cf4c2ac0bee9a23a5f3ec230c6ea54fb2281dbcb", "patch": "@@ -1,37 +1,99 @@\n-import driver::session;\n+// Code that generates a test runner to run all the tests in a crate\n+\n+import std::option;\n import syntax::ast;\n import syntax::fold;\n \n export modify_for_testing;\n \n-type test_ctxt = rec(@session::session sess);\n+type node_id_gen = @fn() -> ast::node_id;\n+\n+type test_ctxt = rec(node_id_gen next_node_id);\n \n // Traverse the crate, collecting all the test functions, eliding any\n // existing main functions, and synthesizing a main test harness\n-fn modify_for_testing(&session::session sess,\n-                      @ast::crate crate) -> @ast::crate {\n+fn modify_for_testing(@ast::crate crate) -> @ast::crate {\n+\n+    // FIXME: This hackasaurus assumes that 200000 is a safe number to start\n+    // generating node_ids at (which is totally not the case). pauls is going\n+    // to land a patch that puts parse_sess into session, which will give us\n+    // access to the real next node_id.\n+    auto next_node_id = @mutable 200000;\n+    auto next_node_id_fn = @bind fn(@mutable ast::node_id next_node_id)\n+        -> ast::node_id {\n+        auto this_node_id = *next_node_id;\n+        *next_node_id = next_node_id + 1;\n+        ret this_node_id;\n+    } (next_node_id);\n \n-  auto cx = rec(sess = @sess);\n+    auto cx = rec(next_node_id = next_node_id_fn);\n \n-  auto precursor = rec(fold_crate = bind fold_crate(cx, _, _)\n-                       with *fold::default_ast_fold());\n+    auto precursor = rec(fold_crate = bind fold_crate(cx, _, _)\n+                         with *fold::default_ast_fold());\n \n-  auto fold = fold::make_fold(precursor);\n-  auto res = @fold.fold_crate(*crate);\n-  // FIXME: This is necessary to break a circular reference\n-  fold::dummy_out(fold);\n-  ret res;\n+    auto fold = fold::make_fold(precursor);\n+    auto res = @fold.fold_crate(*crate);\n+    // FIXME: This is necessary to break a circular reference\n+    fold::dummy_out(fold);\n+    ret res;\n }\n \n fn fold_crate(&test_ctxt cx, &ast::crate_ c,\n               fold::ast_fold fld) -> ast::crate_ {\n-  auto folded = fold::noop_fold_crate(c, fld);\n-  ret rec(module = add_test_module(folded.module)\n-          with folded);\n+    auto folded = fold::noop_fold_crate(c, fld);\n+\n+    // Add a special __test module to the crate that will contain code\n+    // generated for the test harness\n+    ret rec(module = add_test_module(cx, folded.module)\n+            with folded);\n+}\n+\n+fn add_test_module(&test_ctxt cx, &ast::_mod m) -> ast::_mod {\n+    auto testmod = mk_test_module(cx);\n+    ret rec(items = m.items + [testmod]\n+            with m);\n }\n \n-fn add_test_module(&ast::_mod m) -> ast::_mod {\n-  ret m;\n+fn mk_test_module(&test_ctxt cx) -> @ast::item {\n+    auto mainfn = mk_main(cx);\n+    let ast::_mod testmod = rec(view_items = [],\n+                                items = [mainfn]);\n+    auto item_ = ast::item_mod(testmod);\n+    let ast::item item = rec(ident = \"__test\",\n+                             attrs = ~[],\n+                             id = cx.next_node_id(),\n+                             node = item_,\n+                             span = rec(lo=0u, hi=0u));\n+    ret @item;\n+}\n+\n+fn mk_main(&test_ctxt cx) -> @ast::item {\n+    auto ret_ty = @rec(node=ast::ty_nil,\n+                       span=rec(lo=0u, hi=0u));\n+\n+    let ast::fn_decl decl = rec(inputs = [],\n+                                output = ret_ty,\n+                                purity = ast::impure_fn,\n+                                cf = ast::return,\n+                                constraints = ~[]);\n+    auto proto = ast::proto_fn;\n+\n+    let ast::block_ body_ = rec(stmts = [],\n+                                 expr = option::none,\n+                                 id = cx.next_node_id());\n+    auto body = rec(node = body_, span = rec(lo=0u, hi=0u));\n+\n+    auto fn_ = rec(decl = decl,\n+                   proto = proto,\n+                   body = body);\n+\n+    auto item_ = ast::item_fn(fn_, []);\n+    let ast::item item = rec(ident = \"main\",\n+                             attrs = ~[],\n+                             id = cx.next_node_id(),\n+                             node = item_,\n+                             span = rec(lo=0u, hi=0u));\n+    ret @item;\n }\n \n // Local Variables:"}]}