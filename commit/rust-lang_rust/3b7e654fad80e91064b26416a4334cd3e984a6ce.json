{"sha": "3b7e654fad80e91064b26416a4334cd3e984a6ce", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiN2U2NTRmYWQ4MGU5MTA2NGIyNjQxNmE0MzM0Y2QzZTk4NGE2Y2U=", "commit": {"author": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2021-04-04T20:23:08Z"}, "committer": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2021-04-05T12:34:17Z"}, "message": "Use more appropriate return type for `resolve_associated_item`\n\nPreviously, the types looked like this:\n\n- None means this is not an associated item (but may be a variant field)\n- Some(Err) means this is known to be an error. I think the only way that can happen is if it resolved and but you had your own anchor.\n- Some(Ok(_, None)) was impossible.\n\nNow, this returns a nested Option and does the error handling and\nfiddling with the side channel in the caller. As a side-effect, it also\nremoves duplicate error handling.\n\nThis has one small change in behavior, which is that\n`resolve_primitive_associated_item` now goes through `variant_field` if\nit fails to resolve something.  This is not ideal, but since it will be\nquickly rejected anyway, I think the performance hit is worth the\ncleanup.\n\nThis also fixes a bug where struct fields would forget to set the side\nchannel, adds a test for the bug, and ignores `private_intra_doc_links`\nin rustc_resolve (since it's always documented with\n--document-private-items).", "tree": {"sha": "e4f17bd0488bfa0e6558a68ddc0d95faa34e2b6b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e4f17bd0488bfa0e6558a68ddc0d95faa34e2b6b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3b7e654fad80e91064b26416a4334cd3e984a6ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3b7e654fad80e91064b26416a4334cd3e984a6ce", "html_url": "https://github.com/rust-lang/rust/commit/3b7e654fad80e91064b26416a4334cd3e984a6ce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3b7e654fad80e91064b26416a4334cd3e984a6ce/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac04dbd056a94d59699be3983e5404856a9add13", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac04dbd056a94d59699be3983e5404856a9add13", "html_url": "https://github.com/rust-lang/rust/commit/ac04dbd056a94d59699be3983e5404856a9add13"}], "stats": {"total": 201, "additions": 103, "deletions": 98}, "files": [{"sha": "1c5f8996e1b454ecf419ab27f9f315c67a26470e", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3b7e654fad80e91064b26416a4334cd3e984a6ce/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b7e654fad80e91064b26416a4334cd3e984a6ce/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=3b7e654fad80e91064b26416a4334cd3e984a6ce", "patch": "@@ -18,6 +18,7 @@\n #![feature(nll)]\n #![cfg_attr(bootstrap, feature(or_patterns))]\n #![recursion_limit = \"256\"]\n+#![allow(rustdoc::private_intra_doc_links)]\n \n pub use rustc_hir::def::{Namespace, PerNS};\n "}, {"sha": "3501b7d86a46ff0430eb82c1a5765ea741d98e59", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 56, "deletions": 83, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/3b7e654fad80e91064b26416a4334cd3e984a6ce/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b7e654fad80e91064b26416a4334cd3e984a6ce/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=3b7e654fad80e91064b26416a4334cd3e984a6ce", "patch": "@@ -368,54 +368,28 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n     }\n \n     /// Given a primitive type, try to resolve an associated item.\n-    ///\n-    /// HACK(jynelson): `item_str` is passed in instead of derived from `item_name` so the\n-    /// lifetimes on `&'path` will work.\n     fn resolve_primitive_associated_item(\n         &self,\n         prim_ty: PrimitiveType,\n         ns: Namespace,\n-        module_id: DefId,\n         item_name: Symbol,\n-    ) -> Result<(Res, Option<String>), ErrorKind<'path>> {\n+    ) -> Option<(Res, String, Option<(DefKind, DefId)>)> {\n         let tcx = self.cx.tcx;\n \n-        prim_ty\n-            .impls(tcx)\n-            .into_iter()\n-            .find_map(|&impl_| {\n-                tcx.associated_items(impl_)\n-                    .find_by_name_and_namespace(tcx, Ident::with_dummy_span(item_name), ns, impl_)\n-                    .map(|item| {\n-                        let kind = item.kind;\n-                        self.kind_side_channel.set(Some((kind.as_def_kind(), item.def_id)));\n-                        match kind {\n-                            ty::AssocKind::Fn => \"method\",\n-                            ty::AssocKind::Const => \"associatedconstant\",\n-                            ty::AssocKind::Type => \"associatedtype\",\n-                        }\n-                    })\n-                    .map(|out| {\n-                        (\n-                            Res::Primitive(prim_ty),\n-                            Some(format!(\"{}#{}.{}\", prim_ty.as_str(), out, item_name)),\n-                        )\n-                    })\n-            })\n-            .ok_or_else(|| {\n-                debug!(\n-                    \"returning primitive error for {}::{} in {} namespace\",\n-                    prim_ty.as_str(),\n-                    item_name,\n-                    ns.descr()\n-                );\n-                ResolutionFailure::NotResolved {\n-                    module_id,\n-                    partial_res: Some(Res::Primitive(prim_ty)),\n-                    unresolved: item_name.to_string().into(),\n-                }\n-                .into()\n-            })\n+        prim_ty.impls(tcx).into_iter().find_map(|&impl_| {\n+            tcx.associated_items(impl_)\n+                .find_by_name_and_namespace(tcx, Ident::with_dummy_span(item_name), ns, impl_)\n+                .map(|item| {\n+                    let kind = item.kind;\n+                    let out = match kind {\n+                        ty::AssocKind::Fn => \"method\",\n+                        ty::AssocKind::Const => \"associatedconstant\",\n+                        ty::AssocKind::Type => \"associatedtype\",\n+                    };\n+                    let fragment = format!(\"{}#{}.{}\", prim_ty.as_str(), out, item_name);\n+                    (Res::Primitive(prim_ty), fragment, Some((kind.as_def_kind(), item.def_id)))\n+                })\n+        })\n     }\n \n     /// Resolves a string as a macro.\n@@ -538,7 +512,21 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         resolve_primitive(&path_root, TypeNS)\n             .or_else(|| self.resolve_path(&path_root, TypeNS, module_id))\n             .and_then(|ty_res| {\n-                self.resolve_associated_item(ty_res, item_name, ns, module_id, extra_fragment)\n+                let (res, fragment, side_channel) =\n+                    self.resolve_associated_item(ty_res, item_name, ns, module_id)?;\n+                let result = if extra_fragment.is_some() {\n+                    let diag_res = side_channel.map_or(res, |(k, r)| Res::Def(k, r));\n+                    Err(ErrorKind::AnchorFailure(AnchorFailure::RustdocAnchorConflict(diag_res)))\n+                } else {\n+                    // HACK(jynelson): `clean` expects the type, not the associated item\n+                    // but the disambiguator logic expects the associated item.\n+                    // Store the kind in a side channel so that only the disambiguator logic looks at it.\n+                    if let Some((kind, id)) = side_channel {\n+                        self.kind_side_channel.set(Some((kind, id)));\n+                    }\n+                    Ok((res, Some(fragment)))\n+                };\n+                Some(result)\n             })\n             .unwrap_or_else(|| {\n                 if ns == Namespace::ValueNS {\n@@ -554,21 +542,21 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             })\n     }\n \n+    /// Returns:\n+    /// - None if no associated item was found\n+    /// - Some((_, _, Some(_))) if an item was found and should go through a side channel\n+    /// - Some((_, _, None)) otherwise\n     fn resolve_associated_item(\n         &mut self,\n         root_res: Res,\n         item_name: Symbol,\n         ns: Namespace,\n         module_id: DefId,\n-        extra_fragment: &Option<String>,\n-        // lol this is so bad\n-    ) -> Option<Result<(Res, Option<String>), ErrorKind<'static>>> {\n+    ) -> Option<(Res, String, Option<(DefKind, DefId)>)> {\n         let tcx = self.cx.tcx;\n \n         match root_res {\n-            Res::Primitive(prim) => {\n-                Some(self.resolve_primitive_associated_item(prim, ns, module_id, item_name))\n-            }\n+            Res::Primitive(prim) => self.resolve_primitive_associated_item(prim, ns, item_name),\n             Res::Def(\n                 DefKind::Struct\n                 | DefKind::Union\n@@ -611,17 +599,14 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                         ty::AssocKind::Const => \"associatedconstant\",\n                         ty::AssocKind::Type => \"associatedtype\",\n                     };\n-                    return Some(if extra_fragment.is_some() {\n-                        Err(ErrorKind::AnchorFailure(AnchorFailure::RustdocAnchorConflict(\n-                            root_res,\n-                        )))\n-                    } else {\n-                        // HACK(jynelson): `clean` expects the type, not the associated item\n-                        // but the disambiguator logic expects the associated item.\n-                        // Store the kind in a side channel so that only the disambiguator logic looks at it.\n-                        self.kind_side_channel.set(Some((kind.as_def_kind(), id)));\n-                        Ok((root_res, Some(format!(\"{}.{}\", out, item_name))))\n-                    });\n+                    // HACK(jynelson): `clean` expects the type, not the associated item\n+                    // but the disambiguator logic expects the associated item.\n+                    // Store the kind in a side channel so that only the disambiguator logic looks at it.\n+                    return Some((\n+                        root_res,\n+                        format!(\"{}.{}\", out, item_name),\n+                        Some((kind.as_def_kind(), id)),\n+                    ));\n                 }\n \n                 if ns != Namespace::ValueNS {\n@@ -640,22 +625,16 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 } else {\n                     def.non_enum_variant().fields.iter().find(|item| item.ident.name == item_name)\n                 }?;\n-                Some(if extra_fragment.is_some() {\n-                    let res = Res::Def(\n-                        if def.is_enum() { DefKind::Variant } else { DefKind::Field },\n-                        field.did,\n-                    );\n-                    Err(ErrorKind::AnchorFailure(AnchorFailure::RustdocAnchorConflict(res)))\n-                } else {\n-                    Ok((\n-                        root_res,\n-                        Some(format!(\n-                            \"{}.{}\",\n-                            if def.is_enum() { \"variant\" } else { \"structfield\" },\n-                            field.ident\n-                        )),\n-                    ))\n-                })\n+                let kind = if def.is_enum() { DefKind::Variant } else { DefKind::Field };\n+                Some((\n+                    root_res,\n+                    format!(\n+                        \"{}.{}\",\n+                        if def.is_enum() { \"variant\" } else { \"structfield\" },\n+                        field.ident\n+                    ),\n+                    Some((kind, field.did)),\n+                ))\n             }\n             Res::Def(DefKind::Trait, did) => tcx\n                 .associated_items(did)\n@@ -673,14 +652,8 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                         }\n                     };\n \n-                    if extra_fragment.is_some() {\n-                        Err(ErrorKind::AnchorFailure(AnchorFailure::RustdocAnchorConflict(\n-                            root_res,\n-                        )))\n-                    } else {\n-                        let res = Res::Def(item.kind.as_def_kind(), item.def_id);\n-                        Ok((res, Some(format!(\"{}.{}\", kind, item_name))))\n-                    }\n+                    let res = Res::Def(item.kind.as_def_kind(), item.def_id);\n+                    (res, format!(\"{}.{}\", kind, item_name), None)\n                 }),\n             _ => None,\n         }"}, {"sha": "392321f9c60db4a72557f146adf8a2ae3381014c", "filename": "src/test/rustdoc-ui/intra-doc/private.private.stderr", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3b7e654fad80e91064b26416a4334cd3e984a6ce/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fprivate.private.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3b7e654fad80e91064b26416a4334cd3e984a6ce/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fprivate.private.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fprivate.private.stderr?ref=3b7e654fad80e91064b26416a4334cd3e984a6ce", "patch": "@@ -1,19 +1,27 @@\n warning: public documentation for `DocMe` links to private item `DontDocMe`\n-  --> $DIR/private.rs:5:11\n+  --> $DIR/private.rs:7:11\n    |\n-LL | /// docs [DontDocMe] [DontDocMe::f]\n+LL | /// docs [DontDocMe] [DontDocMe::f] [DontDocMe::x]\n    |           ^^^^^^^^^ this item is private\n    |\n    = note: `#[warn(rustdoc::private_intra_doc_links)]` on by default\n    = note: this link resolves only because you passed `--document-private-items`, but will break without\n \n warning: public documentation for `DocMe` links to private item `DontDocMe::f`\n-  --> $DIR/private.rs:5:23\n+  --> $DIR/private.rs:7:23\n    |\n-LL | /// docs [DontDocMe] [DontDocMe::f]\n+LL | /// docs [DontDocMe] [DontDocMe::f] [DontDocMe::x]\n    |                       ^^^^^^^^^^^^ this item is private\n    |\n    = note: this link resolves only because you passed `--document-private-items`, but will break without\n \n-warning: 2 warnings emitted\n+warning: public documentation for `DocMe` links to private item `DontDocMe::x`\n+  --> $DIR/private.rs:7:38\n+   |\n+LL | /// docs [DontDocMe] [DontDocMe::f] [DontDocMe::x]\n+   |                                      ^^^^^^^^^^^^ this item is private\n+   |\n+   = note: this link resolves only because you passed `--document-private-items`, but will break without\n+\n+warning: 3 warnings emitted\n "}, {"sha": "5d1c34b9168d9368bf0d643f407716c0abf59947", "filename": "src/test/rustdoc-ui/intra-doc/private.public.stderr", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3b7e654fad80e91064b26416a4334cd3e984a6ce/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fprivate.public.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3b7e654fad80e91064b26416a4334cd3e984a6ce/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fprivate.public.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fprivate.public.stderr?ref=3b7e654fad80e91064b26416a4334cd3e984a6ce", "patch": "@@ -1,19 +1,27 @@\n warning: public documentation for `DocMe` links to private item `DontDocMe`\n-  --> $DIR/private.rs:5:11\n+  --> $DIR/private.rs:7:11\n    |\n-LL | /// docs [DontDocMe] [DontDocMe::f]\n+LL | /// docs [DontDocMe] [DontDocMe::f] [DontDocMe::x]\n    |           ^^^^^^^^^ this item is private\n    |\n    = note: `#[warn(rustdoc::private_intra_doc_links)]` on by default\n    = note: this link will resolve properly if you pass `--document-private-items`\n \n warning: public documentation for `DocMe` links to private item `DontDocMe::f`\n-  --> $DIR/private.rs:5:23\n+  --> $DIR/private.rs:7:23\n    |\n-LL | /// docs [DontDocMe] [DontDocMe::f]\n+LL | /// docs [DontDocMe] [DontDocMe::f] [DontDocMe::x]\n    |                       ^^^^^^^^^^^^ this item is private\n    |\n    = note: this link will resolve properly if you pass `--document-private-items`\n \n-warning: 2 warnings emitted\n+warning: public documentation for `DocMe` links to private item `DontDocMe::x`\n+  --> $DIR/private.rs:7:38\n+   |\n+LL | /// docs [DontDocMe] [DontDocMe::f] [DontDocMe::x]\n+   |                                      ^^^^^^^^^^^^ this item is private\n+   |\n+   = note: this link will resolve properly if you pass `--document-private-items`\n+\n+warning: 3 warnings emitted\n "}, {"sha": "525332ddaac3badc8b9209d5361ee88ba7d6eff8", "filename": "src/test/rustdoc-ui/intra-doc/private.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3b7e654fad80e91064b26416a4334cd3e984a6ce/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fprivate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b7e654fad80e91064b26416a4334cd3e984a6ce/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fprivate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fprivate.rs?ref=3b7e654fad80e91064b26416a4334cd3e984a6ce", "patch": "@@ -2,12 +2,16 @@\n // revisions: public private\n // [private]compile-flags: --document-private-items\n \n-/// docs [DontDocMe] [DontDocMe::f]\n+// make sure to update `rustdoc/intra-doc/private.rs` if you update this file\n+\n+/// docs [DontDocMe] [DontDocMe::f] [DontDocMe::x]\n //~^ WARNING public documentation for `DocMe` links to private item `DontDocMe`\n+//~| WARNING public documentation for `DocMe` links to private item `DontDocMe::x`\n //~| WARNING public documentation for `DocMe` links to private item `DontDocMe::f`\n-// FIXME: for [private] we should also make sure the link was actually generated\n pub struct DocMe;\n-struct DontDocMe;\n+struct DontDocMe {\n+    x: usize,\n+}\n \n impl DontDocMe {\n     fn f() {}"}, {"sha": "337102d6ab3fa966d7a32fd362fda42d156234e1", "filename": "src/test/rustdoc/intra-doc/private.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3b7e654fad80e91064b26416a4334cd3e984a6ce/src%2Ftest%2Frustdoc%2Fintra-doc%2Fprivate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b7e654fad80e91064b26416a4334cd3e984a6ce/src%2Ftest%2Frustdoc%2Fintra-doc%2Fprivate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fprivate.rs?ref=3b7e654fad80e91064b26416a4334cd3e984a6ce", "patch": "@@ -1,6 +1,17 @@\n #![crate_name = \"private\"]\n // compile-flags: --document-private-items\n-/// docs [DontDocMe]\n+\n+// make sure to update `rustdoc-ui/intra-doc/private.rs` if you update this file\n+\n+/// docs [DontDocMe] [DontDocMe::f] [DontDocMe::x]\n // @has private/struct.DocMe.html '//*a[@href=\"../private/struct.DontDocMe.html\"]' 'DontDocMe'\n+// @has private/struct.DocMe.html '//*a[@href=\"../private/struct.DontDocMe.html#method.f\"]' 'DontDocMe::f'\n+// @has private/struct.DocMe.html '//*a[@href=\"../private/struct.DontDocMe.html#structfield.x\"]' 'DontDocMe::x'\n pub struct DocMe;\n-struct DontDocMe;\n+struct DontDocMe {\n+    x: usize,\n+}\n+\n+impl DontDocMe {\n+    fn f() {}\n+}"}]}