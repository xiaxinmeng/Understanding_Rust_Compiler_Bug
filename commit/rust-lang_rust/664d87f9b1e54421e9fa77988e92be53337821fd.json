{"sha": "664d87f9b1e54421e9fa77988e92be53337821fd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2NGQ4N2Y5YjFlNTQ0MjFlOWZhNzc5ODhlOTJiZTUzMzM3ODIxZmQ=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-02-08T23:53:53Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-02-08T23:53:53Z"}, "message": "Rollup merge of #68857 - Marwes:allocations, r=matthewjasper\n\nperf: Reduce Vec allocations in normalization by passing &mut Vec\n\nComplicates the code a bit but allocation/freeing were a few percent of the overall runtime in trait heavy code.", "tree": {"sha": "d8808088034babab5e2873d5327e90c0cedd4b67", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d8808088034babab5e2873d5327e90c0cedd4b67"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/664d87f9b1e54421e9fa77988e92be53337821fd", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeP0oSCRBK7hj4Ov3rIwAAdHIIAJJRVYMdWRzFpMNL0yC63+tE\n6lTqYF3LwKqnAnLy5YFJpekHFo2qeYxCsPRinPpwMdv8PzzOHi+/nB6owvTi6Y2d\nK48eBQjJsclMG6sxEwQtP/6OuvuU+8wxOHnXTsCL0a9pt0fVJLSdg4Cibj/7oHWs\neKa9zVyziEDFqkMVJ+/LJlU7ccYsUuk/izwU7Yt7ey2KjjGGtXSRGepniaH+7XPf\nVuO8n+2x8FpdCKNzTDauCSwlHquqUBumpFi0k3LLKMIGne+tFGtHacgIbXJ002wc\nXYK+AU+35eEw3YtJ2rn8AgXvL9QgqLl/+xYAg186ai+5YN8W2nW0S0XgI/PBFbg=\n=y/C5\n-----END PGP SIGNATURE-----\n", "payload": "tree d8808088034babab5e2873d5327e90c0cedd4b67\nparent cb87c958ef147f144d4b973e04e26a6bf9ddde9d\nparent 51b891ae2cf55ce0a265fa99e92bdb7b19244112\nauthor Dylan DPC <dylan.dpc@gmail.com> 1581206033 +0100\ncommitter GitHub <noreply@github.com> 1581206033 +0100\n\nRollup merge of #68857 - Marwes:allocations, r=matthewjasper\n\nperf: Reduce Vec allocations in normalization by passing &mut Vec\n\nComplicates the code a bit but allocation/freeing were a few percent of the overall runtime in trait heavy code.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/664d87f9b1e54421e9fa77988e92be53337821fd", "html_url": "https://github.com/rust-lang/rust/commit/664d87f9b1e54421e9fa77988e92be53337821fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/664d87f9b1e54421e9fa77988e92be53337821fd/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb87c958ef147f144d4b973e04e26a6bf9ddde9d", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb87c958ef147f144d4b973e04e26a6bf9ddde9d", "html_url": "https://github.com/rust-lang/rust/commit/cb87c958ef147f144d4b973e04e26a6bf9ddde9d"}, {"sha": "51b891ae2cf55ce0a265fa99e92bdb7b19244112", "url": "https://api.github.com/repos/rust-lang/rust/commits/51b891ae2cf55ce0a265fa99e92bdb7b19244112", "html_url": "https://github.com/rust-lang/rust/commit/51b891ae2cf55ce0a265fa99e92bdb7b19244112"}], "stats": {"total": 161, "additions": 100, "deletions": 61}, "files": [{"sha": "25bb54033f16575ca0654aeba0a48f5cc4597bb5", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/664d87f9b1e54421e9fa77988e92be53337821fd/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/664d87f9b1e54421e9fa77988e92be53337821fd/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=664d87f9b1e54421e9fa77988e92be53337821fd", "patch": "@@ -50,7 +50,9 @@ pub use self::object_safety::MethodViolationCode;\n pub use self::object_safety::ObjectSafetyViolation;\n pub use self::on_unimplemented::{OnUnimplementedDirective, OnUnimplementedNote};\n pub use self::project::MismatchedProjectionTypes;\n-pub use self::project::{normalize, normalize_projection_type, poly_project_and_unify_type};\n+pub use self::project::{\n+    normalize, normalize_projection_type, normalize_to, poly_project_and_unify_type,\n+};\n pub use self::project::{Normalized, ProjectionCache, ProjectionCacheSnapshot};\n pub use self::select::{IntercrateAmbiguityCause, SelectionContext};\n pub use self::specialize::find_associated_item;"}, {"sha": "a1d785cf4447a5cda172f001bf871530957298b8", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 59, "deletions": 22, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/664d87f9b1e54421e9fa77988e92be53337821fd/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/664d87f9b1e54421e9fa77988e92be53337821fd/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=664d87f9b1e54421e9fa77988e92be53337821fd", "patch": "@@ -216,7 +216,22 @@ pub fn normalize<'a, 'b, 'tcx, T>(\n where\n     T: TypeFoldable<'tcx>,\n {\n-    normalize_with_depth(selcx, param_env, cause, 0, value)\n+    let mut obligations = Vec::new();\n+    let value = normalize_to(selcx, param_env, cause, value, &mut obligations);\n+    Normalized { value, obligations }\n+}\n+\n+pub fn normalize_to<'a, 'b, 'tcx, T>(\n+    selcx: &'a mut SelectionContext<'b, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    cause: ObligationCause<'tcx>,\n+    value: &T,\n+    obligations: &mut Vec<PredicateObligation<'tcx>>,\n+) -> T\n+where\n+    T: TypeFoldable<'tcx>,\n+{\n+    normalize_with_depth_to(selcx, param_env, cause, 0, value, obligations)\n }\n \n /// As `normalize`, but with a custom depth.\n@@ -227,11 +242,27 @@ pub fn normalize_with_depth<'a, 'b, 'tcx, T>(\n     depth: usize,\n     value: &T,\n ) -> Normalized<'tcx, T>\n+where\n+    T: TypeFoldable<'tcx>,\n+{\n+    let mut obligations = Vec::new();\n+    let value = normalize_with_depth_to(selcx, param_env, cause, depth, value, &mut obligations);\n+    Normalized { value, obligations }\n+}\n+\n+pub fn normalize_with_depth_to<'a, 'b, 'tcx, T>(\n+    selcx: &'a mut SelectionContext<'b, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    cause: ObligationCause<'tcx>,\n+    depth: usize,\n+    value: &T,\n+    obligations: &mut Vec<PredicateObligation<'tcx>>,\n+) -> T\n where\n     T: TypeFoldable<'tcx>,\n {\n     debug!(\"normalize_with_depth(depth={}, value={:?})\", depth, value);\n-    let mut normalizer = AssocTypeNormalizer::new(selcx, param_env, cause, depth);\n+    let mut normalizer = AssocTypeNormalizer::new(selcx, param_env, cause, depth, obligations);\n     let result = normalizer.fold(value);\n     debug!(\n         \"normalize_with_depth: depth={} result={:?} with {} obligations\",\n@@ -240,14 +271,14 @@ where\n         normalizer.obligations.len()\n     );\n     debug!(\"normalize_with_depth: depth={} obligations={:?}\", depth, normalizer.obligations);\n-    Normalized { value: result, obligations: normalizer.obligations }\n+    result\n }\n \n struct AssocTypeNormalizer<'a, 'b, 'tcx> {\n     selcx: &'a mut SelectionContext<'b, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     cause: ObligationCause<'tcx>,\n-    obligations: Vec<PredicateObligation<'tcx>>,\n+    obligations: &'a mut Vec<PredicateObligation<'tcx>>,\n     depth: usize,\n }\n \n@@ -257,8 +288,9 @@ impl<'a, 'b, 'tcx> AssocTypeNormalizer<'a, 'b, 'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n         cause: ObligationCause<'tcx>,\n         depth: usize,\n+        obligations: &'a mut Vec<PredicateObligation<'tcx>>,\n     ) -> AssocTypeNormalizer<'a, 'b, 'tcx> {\n-        AssocTypeNormalizer { selcx, param_env, cause, obligations: vec![], depth }\n+        AssocTypeNormalizer { selcx, param_env, cause, obligations, depth }\n     }\n \n     fn fold<T: TypeFoldable<'tcx>>(&mut self, value: &T) -> T {\n@@ -343,7 +375,7 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n                 );\n                 debug!(\n                     \"AssocTypeNormalizer: depth={} normalized {:?} to {:?}, \\\n-                        now with {} obligations\",\n+                     now with {} obligations\",\n                     self.depth,\n                     ty,\n                     normalized_ty,\n@@ -441,8 +473,8 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n \n     debug!(\n         \"opt_normalize_projection_type(\\\n-           projection_ty={:?}, \\\n-           depth={})\",\n+         projection_ty={:?}, \\\n+         depth={})\",\n         projection_ty, depth\n     );\n \n@@ -469,7 +501,7 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n             // changes\n             debug!(\n                 \"opt_normalize_projection_type: \\\n-                    found cache entry: ambiguous\"\n+                 found cache entry: ambiguous\"\n             );\n             if !projection_ty.has_closure_types() {\n                 return None;\n@@ -498,7 +530,7 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n \n             debug!(\n                 \"opt_normalize_projection_type: \\\n-                    found cache entry: in-progress\"\n+                 found cache entry: in-progress\"\n             );\n \n             // But for now, let's classify this as an overflow:\n@@ -521,7 +553,7 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n             // evaluations can causes ICEs (e.g., #43132).\n             debug!(\n                 \"opt_normalize_projection_type: \\\n-                    found normalized ty `{:?}`\",\n+                 found normalized ty `{:?}`\",\n                 ty\n             );\n \n@@ -546,7 +578,7 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n         Err(ProjectionCacheEntry::Error) => {\n             debug!(\n                 \"opt_normalize_projection_type: \\\n-                    found error\"\n+                 found error\"\n             );\n             let result = normalize_to_error(selcx, param_env, projection_ty, cause, depth);\n             obligations.extend(result.obligations);\n@@ -567,23 +599,28 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n \n             debug!(\n                 \"opt_normalize_projection_type: \\\n-                    projected_ty={:?} \\\n-                    depth={} \\\n-                    projected_obligations={:?}\",\n+                 projected_ty={:?} \\\n+                 depth={} \\\n+                 projected_obligations={:?}\",\n                 projected_ty, depth, projected_obligations\n             );\n \n             let result = if projected_ty.has_projections() {\n-                let mut normalizer = AssocTypeNormalizer::new(selcx, param_env, cause, depth + 1);\n+                let mut normalizer = AssocTypeNormalizer::new(\n+                    selcx,\n+                    param_env,\n+                    cause,\n+                    depth + 1,\n+                    &mut projected_obligations,\n+                );\n                 let normalized_ty = normalizer.fold(&projected_ty);\n \n                 debug!(\n                     \"opt_normalize_projection_type: \\\n-                        normalized_ty={:?} depth={}\",\n+                     normalized_ty={:?} depth={}\",\n                     normalized_ty, depth\n                 );\n \n-                projected_obligations.extend(normalizer.obligations);\n                 Normalized { value: normalized_ty, obligations: projected_obligations }\n             } else {\n                 Normalized { value: projected_ty, obligations: projected_obligations }\n@@ -597,7 +634,7 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n         Ok(ProjectedTy::NoProgress(projected_ty)) => {\n             debug!(\n                 \"opt_normalize_projection_type: \\\n-                    projected_ty={:?} no progress\",\n+                 projected_ty={:?} no progress\",\n                 projected_ty\n             );\n             let result = Normalized { value: projected_ty, obligations: vec![] };\n@@ -608,7 +645,7 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n         Err(ProjectionTyError::TooManyCandidates) => {\n             debug!(\n                 \"opt_normalize_projection_type: \\\n-                    too many candidates\"\n+                 too many candidates\"\n             );\n             infcx.projection_cache.borrow_mut().ambiguous(cache_key);\n             None\n@@ -930,7 +967,7 @@ fn assemble_candidates_from_predicates<'cx, 'tcx, I>(\n \n             debug!(\n                 \"assemble_candidates_from_predicates: candidate={:?} \\\n-                    is_match={} same_def_id={}\",\n+                 is_match={} same_def_id={}\",\n                 data, is_match, same_def_id\n             );\n \n@@ -1192,7 +1229,7 @@ fn confirm_object_candidate<'cx, 'tcx>(\n             None => {\n                 debug!(\n                     \"confirm_object_candidate: no env-predicate \\\n-                        found in object type `{:?}`; ill-formed\",\n+                     found in object type `{:?}`; ill-formed\",\n                     object_ty\n                 );\n                 return Progress::error(selcx.tcx());"}, {"sha": "26f2a4ddb385a4b9c1fca59a9834a9d1949cd39f", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/664d87f9b1e54421e9fa77988e92be53337821fd/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/664d87f9b1e54421e9fa77988e92be53337821fd/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=664d87f9b1e54421e9fa77988e92be53337821fd", "patch": "@@ -9,7 +9,9 @@ use self::SelectionCandidate::*;\n \n use super::coherence::{self, Conflict};\n use super::project;\n-use super::project::{normalize_with_depth, Normalized, ProjectionCacheKey};\n+use super::project::{\n+    normalize_with_depth, normalize_with_depth_to, Normalized, ProjectionCacheKey,\n+};\n use super::util;\n use super::util::{closure_trait_ref_and_return_type, predicate_for_trait_def};\n use super::wf;\n@@ -1019,7 +1021,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         if let Some(value) = value {\n                             debug!(\n                                 \"filter_negative_and_reservation_impls: \\\n-                                    reservation impl ambiguity on {:?}\",\n+                                 reservation impl ambiguity on {:?}\",\n                                 def_id\n                             );\n                             intercrate_ambiguity_clauses.push(\n@@ -1317,7 +1319,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         if !self.can_cache_candidate(&candidate) {\n             debug!(\n                 \"insert_candidate_cache(trait_ref={:?}, candidate={:?} -\\\n-                    candidate is not cacheable\",\n+                 candidate is not cacheable\",\n                 trait_ref, candidate\n             );\n             return;\n@@ -3484,25 +3486,23 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // that order.\n         let predicates = tcx.predicates_of(def_id);\n         assert_eq!(predicates.parent, None);\n-        let mut predicates: Vec<_> = predicates\n-            .predicates\n-            .iter()\n-            .flat_map(|(predicate, _)| {\n-                let predicate = normalize_with_depth(\n-                    self,\n-                    param_env,\n-                    cause.clone(),\n-                    recursion_depth,\n-                    &predicate.subst(tcx, substs),\n-                );\n-                predicate.obligations.into_iter().chain(Some(Obligation {\n-                    cause: cause.clone(),\n-                    recursion_depth,\n-                    param_env,\n-                    predicate: predicate.value,\n-                }))\n-            })\n-            .collect();\n+        let mut obligations = Vec::new();\n+        for (predicate, _) in predicates.predicates {\n+            let predicate = normalize_with_depth_to(\n+                self,\n+                param_env,\n+                cause.clone(),\n+                recursion_depth,\n+                &predicate.subst(tcx, substs),\n+                &mut obligations,\n+            );\n+            obligations.push(Obligation {\n+                cause: cause.clone(),\n+                recursion_depth,\n+                param_env,\n+                predicate,\n+            });\n+        }\n \n         // We are performing deduplication here to avoid exponential blowups\n         // (#38528) from happening, but the real cause of the duplication is\n@@ -3513,20 +3513,20 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // This code is hot enough that it's worth avoiding the allocation\n         // required for the FxHashSet when possible. Special-casing lengths 0,\n         // 1 and 2 covers roughly 75-80% of the cases.\n-        if predicates.len() <= 1 {\n+        if obligations.len() <= 1 {\n             // No possibility of duplicates.\n-        } else if predicates.len() == 2 {\n+        } else if obligations.len() == 2 {\n             // Only two elements. Drop the second if they are equal.\n-            if predicates[0] == predicates[1] {\n-                predicates.truncate(1);\n+            if obligations[0] == obligations[1] {\n+                obligations.truncate(1);\n             }\n         } else {\n             // Three or more elements. Use a general deduplication process.\n             let mut seen = FxHashSet::default();\n-            predicates.retain(|i| seen.insert(i.clone()));\n+            obligations.retain(|i| seen.insert(i.clone()));\n         }\n \n-        predicates\n+        obligations\n     }\n }\n "}, {"sha": "fbcb77a403183ef41351525ba78376b980ae9eb8", "filename": "src/librustc/traits/wf.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/664d87f9b1e54421e9fa77988e92be53337821fd/src%2Flibrustc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/664d87f9b1e54421e9fa77988e92be53337821fd/src%2Flibrustc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fwf.rs?ref=664d87f9b1e54421e9fa77988e92be53337821fd", "patch": "@@ -8,7 +8,6 @@ use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_span::symbol::{kw, Ident};\n use rustc_span::Span;\n-use std::iter::once;\n \n /// Returns the set of obligations needed to make `ty` well-formed.\n /// If `ty` contains unresolved inference variables, this may include\n@@ -26,6 +25,7 @@ pub fn obligations<'a, 'tcx>(\n     let mut wf = WfPredicates { infcx, param_env, body_id, span, out: vec![], item: None };\n     if wf.compute(ty) {\n         debug!(\"wf::obligations({:?}, body_id={:?}) = {:?}\", ty, body_id, wf.out);\n+\n         let result = wf.normalize();\n         debug!(\"wf::obligations({:?}, body_id={:?}) ~~> {:?}\", ty, body_id, result);\n         Some(result)\n@@ -143,15 +143,15 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n         let cause = self.cause(traits::MiscObligation);\n         let infcx = &mut self.infcx;\n         let param_env = self.param_env;\n-        self.out\n-            .iter()\n-            .inspect(|pred| assert!(!pred.has_escaping_bound_vars()))\n-            .flat_map(|pred| {\n-                let mut selcx = traits::SelectionContext::new(infcx);\n-                let pred = traits::normalize(&mut selcx, param_env, cause.clone(), pred);\n-                once(pred.value).chain(pred.obligations)\n-            })\n-            .collect()\n+        let mut obligations = Vec::new();\n+        self.out.iter().inspect(|pred| assert!(!pred.has_escaping_bound_vars())).for_each(|pred| {\n+            let mut selcx = traits::SelectionContext::new(infcx);\n+            let i = obligations.len();\n+            let value =\n+                traits::normalize_to(&mut selcx, param_env, cause.clone(), pred, &mut obligations);\n+            obligations.insert(i, value);\n+        });\n+        obligations\n     }\n \n     /// Pushes the obligations required for `trait_ref` to be WF into `self.out`."}]}