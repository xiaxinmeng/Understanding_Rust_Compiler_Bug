{"sha": "05b5797664d6aeaa0c7d0606610f336fe0b57e97", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1YjU3OTc2NjRkNmFlYWEwYzdkMDYwNjYxMGYzMzZmZTBiNTdlOTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-07-01T13:31:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-07-01T13:31:32Z"}, "message": "Auto merge of #42882 - stjepang:improve-sort-tests-and-benches, r=alexcrichton\n\nImprove tests and benchmarks for slice::sort and slice::sort_unstable\n\nThis PR just hardens the tests and improves benchmarks.\nMore specifically:\n\n1. Benchmarks don't generate vectors in `Bencher::iter` loops, but simply clone pregenerated vectors.\n2. Benchmark `*_strings` doesn't allocate Strings in `Bencher::iter` loops, but merely clones a `Vec<&str>`.\n3. Benchmarks use seeded `XorShiftRng` to be more consistent.\n4. Additional tests for `slice::sort` are added, which test sorting on slices with several ascending/descending runs. The implementation identifies such runs so it's a good idea to test that scenario a bit.\n5. More checks are added to `run-pass/vector-sort-panic-safe.rs`. Sort algorithms copy elements around a lot (merge sort uses an auxilliary buffer and pdqsort copies the pivot onto the stack before partitioning, then writes it back into the slice). If elements that are being sorted are internally mutable and comparison function mutates them, it is important to make sure that sort algorithms always use the latest \"versions\" of elements. New checks verify that this is true for both `slice::sort` and `slice::sort_unstable`.\n\nAs a side note, all of those improvements were made as part of the parallel sorts PR in Rayon (nikomatsakis/rayon#379) and now I'm backporting them into libcore/libstd.\n\nr? @alexcrichton", "tree": {"sha": "258baa2269a023f726ce232fd3841bf5f8567ae2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/258baa2269a023f726ce232fd3841bf5f8567ae2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/05b5797664d6aeaa0c7d0606610f336fe0b57e97", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/05b5797664d6aeaa0c7d0606610f336fe0b57e97", "html_url": "https://github.com/rust-lang/rust/commit/05b5797664d6aeaa0c7d0606610f336fe0b57e97", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/05b5797664d6aeaa0c7d0606610f336fe0b57e97/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a5d34e1d035e5441fb5b3d56d5205d038538f053", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5d34e1d035e5441fb5b3d56d5205d038538f053", "html_url": "https://github.com/rust-lang/rust/commit/a5d34e1d035e5441fb5b3d56d5205d038538f053"}, {"sha": "723833f4e1ab867e9dafc7fed863321d96d507e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/723833f4e1ab867e9dafc7fed863321d96d507e8", "html_url": "https://github.com/rust-lang/rust/commit/723833f4e1ab867e9dafc7fed863321d96d507e8"}], "stats": {"total": 277, "additions": 181, "deletions": 96}, "files": [{"sha": "5f274eec87d4717ab0a62b252158ab020316d404", "filename": "src/liballoc/benches/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/05b5797664d6aeaa0c7d0606610f336fe0b57e97/src%2Fliballoc%2Fbenches%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05b5797664d6aeaa0c7d0606610f336fe0b57e97/src%2Fliballoc%2Fbenches%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Flib.rs?ref=05b5797664d6aeaa0c7d0606610f336fe0b57e97", "patch": "@@ -17,6 +17,7 @@\n #![feature(sort_unstable)]\n #![feature(test)]\n \n+extern crate rand;\n extern crate test;\n \n mod btree;"}, {"sha": "d99270e7f311e20c0e54c32622a48f42301a3b5d", "filename": "src/liballoc/benches/slice.rs", "status": "modified", "additions": 35, "deletions": 19, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/05b5797664d6aeaa0c7d0606610f336fe0b57e97/src%2Fliballoc%2Fbenches%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05b5797664d6aeaa0c7d0606610f336fe0b57e97/src%2Fliballoc%2Fbenches%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fslice.rs?ref=05b5797664d6aeaa0c7d0606610f336fe0b57e97", "patch": "@@ -8,9 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::{mem, ptr};\n-use std::__rand::{Rng, thread_rng};\n+use std::__rand::{thread_rng};\n+use std::mem;\n+use std::ptr;\n \n+use rand::{Rng, SeedableRng, XorShiftRng};\n use test::{Bencher, black_box};\n \n #[bench]\n@@ -191,17 +193,17 @@ fn gen_descending(len: usize) -> Vec<u64> {\n }\n \n fn gen_random(len: usize) -> Vec<u64> {\n-    let mut rng = thread_rng();\n+    let mut rng = XorShiftRng::from_seed([0, 1, 2, 3]);\n     rng.gen_iter::<u64>().take(len).collect()\n }\n \n fn gen_random_bytes(len: usize) -> Vec<u8> {\n-    let mut rng = thread_rng();\n+    let mut rng = XorShiftRng::from_seed([0, 1, 2, 3]);\n     rng.gen_iter::<u8>().take(len).collect()\n }\n \n fn gen_mostly_ascending(len: usize) -> Vec<u64> {\n-    let mut rng = thread_rng();\n+    let mut rng = XorShiftRng::from_seed([0, 1, 2, 3]);\n     let mut v = gen_ascending(len);\n     for _ in (0usize..).take_while(|x| x * x <= len) {\n         let x = rng.gen::<usize>() % len;\n@@ -212,7 +214,7 @@ fn gen_mostly_ascending(len: usize) -> Vec<u64> {\n }\n \n fn gen_mostly_descending(len: usize) -> Vec<u64> {\n-    let mut rng = thread_rng();\n+    let mut rng = XorShiftRng::from_seed([0, 1, 2, 3]);\n     let mut v = gen_descending(len);\n     for _ in (0usize..).take_while(|x| x * x <= len) {\n         let x = rng.gen::<usize>() % len;\n@@ -223,7 +225,7 @@ fn gen_mostly_descending(len: usize) -> Vec<u64> {\n }\n \n fn gen_strings(len: usize) -> Vec<String> {\n-    let mut rng = thread_rng();\n+    let mut rng = XorShiftRng::from_seed([0, 1, 2, 3]);\n     let mut v = vec![];\n     for _ in 0..len {\n         let n = rng.gen::<usize>() % 20 + 1;\n@@ -233,26 +235,40 @@ fn gen_strings(len: usize) -> Vec<String> {\n }\n \n fn gen_big_random(len: usize) -> Vec<[u64; 16]> {\n-    let mut rng = thread_rng();\n+    let mut rng = XorShiftRng::from_seed([0, 1, 2, 3]);\n     rng.gen_iter().map(|x| [x; 16]).take(len).collect()\n }\n \n macro_rules! sort {\n     ($f:ident, $name:ident, $gen:expr, $len:expr) => {\n         #[bench]\n         fn $name(b: &mut Bencher) {\n-            b.iter(|| $gen($len).$f());\n+            let v = $gen($len);\n+            b.iter(|| v.clone().$f());\n             b.bytes = $len * mem::size_of_val(&$gen(1)[0]) as u64;\n         }\n     }\n }\n \n+macro_rules! sort_strings {\n+    ($f:ident, $name:ident, $gen:expr, $len:expr) => {\n+        #[bench]\n+        fn $name(b: &mut Bencher) {\n+            let v = $gen($len);\n+            let v = v.iter().map(|s| &**s).collect::<Vec<&str>>();\n+            b.iter(|| v.clone().$f());\n+            b.bytes = $len * mem::size_of::<&str>() as u64;\n+        }\n+    }\n+}\n+\n macro_rules! sort_expensive {\n     ($f:ident, $name:ident, $gen:expr, $len:expr) => {\n         #[bench]\n         fn $name(b: &mut Bencher) {\n+            let v = $gen($len);\n             b.iter(|| {\n-                let mut v = $gen($len);\n+                let mut v = v.clone();\n                 let mut count = 0;\n                 v.$f(|a: &u64, b: &u64| {\n                     count += 1;\n@@ -263,38 +279,38 @@ macro_rules! sort_expensive {\n                 });\n                 black_box(count);\n             });\n-            b.bytes = $len as u64 * mem::size_of::<u64>() as u64;\n+            b.bytes = $len * mem::size_of_val(&$gen(1)[0]) as u64;\n         }\n     }\n }\n \n sort!(sort, sort_small_ascending, gen_ascending, 10);\n sort!(sort, sort_small_descending, gen_descending, 10);\n sort!(sort, sort_small_random, gen_random, 10);\n-sort!(sort, sort_small_big_random, gen_big_random, 10);\n+sort!(sort, sort_small_big, gen_big_random, 10);\n sort!(sort, sort_medium_random, gen_random, 100);\n sort!(sort, sort_large_ascending, gen_ascending, 10000);\n sort!(sort, sort_large_descending, gen_descending, 10000);\n sort!(sort, sort_large_mostly_ascending, gen_mostly_ascending, 10000);\n sort!(sort, sort_large_mostly_descending, gen_mostly_descending, 10000);\n sort!(sort, sort_large_random, gen_random, 10000);\n-sort!(sort, sort_large_big_random, gen_big_random, 10000);\n-sort!(sort, sort_large_strings, gen_strings, 10000);\n-sort_expensive!(sort_by, sort_large_random_expensive, gen_random, 10000);\n+sort!(sort, sort_large_big, gen_big_random, 10000);\n+sort_strings!(sort, sort_large_strings, gen_strings, 10000);\n+sort_expensive!(sort_by, sort_large_expensive, gen_random, 10000);\n \n sort!(sort_unstable, sort_unstable_small_ascending, gen_ascending, 10);\n sort!(sort_unstable, sort_unstable_small_descending, gen_descending, 10);\n sort!(sort_unstable, sort_unstable_small_random, gen_random, 10);\n-sort!(sort_unstable, sort_unstable_small_big_random, gen_big_random, 10);\n+sort!(sort_unstable, sort_unstable_small_big, gen_big_random, 10);\n sort!(sort_unstable, sort_unstable_medium_random, gen_random, 100);\n sort!(sort_unstable, sort_unstable_large_ascending, gen_ascending, 10000);\n sort!(sort_unstable, sort_unstable_large_descending, gen_descending, 10000);\n sort!(sort_unstable, sort_unstable_large_mostly_ascending, gen_mostly_ascending, 10000);\n sort!(sort_unstable, sort_unstable_large_mostly_descending, gen_mostly_descending, 10000);\n sort!(sort_unstable, sort_unstable_large_random, gen_random, 10000);\n-sort!(sort_unstable, sort_unstable_large_big_random, gen_big_random, 10000);\n-sort!(sort_unstable, sort_unstable_large_strings, gen_strings, 10000);\n-sort_expensive!(sort_unstable_by, sort_unstable_large_random_expensive, gen_random, 10000);\n+sort!(sort_unstable, sort_unstable_large_big, gen_big_random, 10000);\n+sort_strings!(sort_unstable, sort_unstable_large_strings, gen_strings, 10000);\n+sort_expensive!(sort_unstable_by, sort_unstable_large_expensive, gen_random, 10000);\n \n macro_rules! reverse {\n     ($name:ident, $ty:ty, $f:expr) => {"}, {"sha": "fe8893904eba1bf3ee8ae9e562471fec3eb4acd8", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05b5797664d6aeaa0c7d0606610f336fe0b57e97/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05b5797664d6aeaa0c7d0606610f336fe0b57e97/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=05b5797664d6aeaa0c7d0606610f336fe0b57e97", "patch": "@@ -1794,7 +1794,7 @@ unsafe fn merge<T, F>(v: &mut [T], mid: usize, buf: *mut T, is_less: &mut F)\n \n     impl<T> Drop for MergeHole<T> {\n         fn drop(&mut self) {\n-            // `T` is not a zero-sized type, so it's okay to divide by it's size.\n+            // `T` is not a zero-sized type, so it's okay to divide by its size.\n             let len = (self.end as usize - self.start as usize) / mem::size_of::<T>();\n             unsafe { ptr::copy_nonoverlapping(self.start, self.dest, len); }\n         }\n@@ -1908,7 +1908,7 @@ fn merge_sort<T, F>(v: &mut [T], mut is_less: F)\n     // if `Some(r)` is returned, that means `runs[r]` and `runs[r + 1]` must be merged next. If the\n     // algorithm should continue building a new run instead, `None` is returned.\n     //\n-    // TimSort is infamous for it's buggy implementations, as described here:\n+    // TimSort is infamous for its buggy implementations, as described here:\n     // http://envisage-project.eu/timsort-specification-and-verification/\n     //\n     // The gist of the story is: we must enforce the invariants on the top four runs on the stack."}, {"sha": "c53bf15f1bfb6263fe861c643defab423ffa3dd7", "filename": "src/liballoc/tests/slice.rs", "status": "modified", "additions": 38, "deletions": 12, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/05b5797664d6aeaa0c7d0606610f336fe0b57e97/src%2Fliballoc%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05b5797664d6aeaa0c7d0606610f336fe0b57e97/src%2Fliballoc%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fslice.rs?ref=05b5797664d6aeaa0c7d0606610f336fe0b57e97", "patch": "@@ -396,18 +396,44 @@ fn test_sort() {\n     let mut rng = thread_rng();\n \n     for len in (2..25).chain(500..510) {\n-        for _ in 0..100 {\n-            let mut v: Vec<_> = rng.gen_iter::<i32>().take(len).collect();\n-            let mut v1 = v.clone();\n-\n-            v.sort();\n-            assert!(v.windows(2).all(|w| w[0] <= w[1]));\n-\n-            v1.sort_by(|a, b| a.cmp(b));\n-            assert!(v1.windows(2).all(|w| w[0] <= w[1]));\n-\n-            v1.sort_by(|a, b| b.cmp(a));\n-            assert!(v1.windows(2).all(|w| w[0] >= w[1]));\n+        for &modulus in &[5, 10, 100, 1000] {\n+            for _ in 0..10 {\n+                let orig: Vec<_> = rng.gen_iter::<i32>()\n+                    .map(|x| x % modulus)\n+                    .take(len)\n+                    .collect();\n+\n+                // Sort in default order.\n+                let mut v = orig.clone();\n+                v.sort();\n+                assert!(v.windows(2).all(|w| w[0] <= w[1]));\n+\n+                // Sort in ascending order.\n+                let mut v = orig.clone();\n+                v.sort_by(|a, b| a.cmp(b));\n+                assert!(v.windows(2).all(|w| w[0] <= w[1]));\n+\n+                // Sort in descending order.\n+                let mut v = orig.clone();\n+                v.sort_by(|a, b| b.cmp(a));\n+                assert!(v.windows(2).all(|w| w[0] >= w[1]));\n+\n+                // Sort with many pre-sorted runs.\n+                let mut v = orig.clone();\n+                v.sort();\n+                v.reverse();\n+                for _ in 0..5 {\n+                    let a = rng.gen::<usize>() % len;\n+                    let b = rng.gen::<usize>() % len;\n+                    if a < b {\n+                        v[a..b].reverse();\n+                    } else {\n+                        v.swap(a, b);\n+                    }\n+                }\n+                v.sort();\n+                assert!(v.windows(2).all(|w| w[0] <= w[1]));\n+            }\n         }\n     }\n "}, {"sha": "4387a43f03b6a952026e5c3fb953cfac26b33f5d", "filename": "src/test/run-pass/vector-sort-panic-safe.rs", "status": "modified", "additions": 105, "deletions": 63, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/05b5797664d6aeaa0c7d0606610f336fe0b57e97/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05b5797664d6aeaa0c7d0606610f336fe0b57e97/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs?ref=05b5797664d6aeaa0c7d0606610f336fe0b57e97", "patch": "@@ -10,14 +10,17 @@\n \n // ignore-emscripten no threads support\n \n-#![feature(rand)]\n #![feature(const_fn)]\n+#![feature(rand)]\n+#![feature(sort_unstable)]\n \n use std::__rand::{thread_rng, Rng};\n+use std::cell::Cell;\n+use std::cmp::Ordering;\n use std::panic;\n-use std::sync::atomic::{AtomicUsize, Ordering};\n+use std::sync::atomic::{ATOMIC_USIZE_INIT, AtomicUsize};\n+use std::sync::atomic::Ordering::Relaxed;\n use std::thread;\n-use std::cell::Cell;\n \n const MAX_LEN: usize = 80;\n \n@@ -45,54 +48,85 @@ static DROP_COUNTS: [AtomicUsize; MAX_LEN] = [\n     AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n ];\n \n-#[derive(Clone, PartialEq, PartialOrd, Eq, Ord)]\n+static VERSIONS: AtomicUsize = ATOMIC_USIZE_INIT;\n+\n+#[derive(Clone, Eq)]\n struct DropCounter {\n     x: u32,\n     id: usize,\n+    version: Cell<usize>,\n+}\n+\n+impl PartialEq for DropCounter {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.partial_cmp(other) == Some(Ordering::Equal)\n+    }\n+}\n+\n+impl PartialOrd for DropCounter {\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        self.version.set(self.version.get() + 1);\n+        other.version.set(other.version.get() + 1);\n+        VERSIONS.fetch_add(2, Relaxed);\n+        self.x.partial_cmp(&other.x)\n+    }\n+}\n+\n+impl Ord for DropCounter {\n+    fn cmp(&self, other: &Self) -> Ordering {\n+        self.partial_cmp(other).unwrap()\n+    }\n }\n \n impl Drop for DropCounter {\n     fn drop(&mut self) {\n-        DROP_COUNTS[self.id].fetch_add(1, Ordering::Relaxed);\n+        DROP_COUNTS[self.id].fetch_add(1, Relaxed);\n+        VERSIONS.fetch_sub(self.version.get(), Relaxed);\n     }\n }\n \n-fn test(input: &[DropCounter]) {\n-    let len = input.len();\n-\n-    // Work out the total number of comparisons required to sort\n-    // this array...\n-    let mut count = 0usize;\n-    input.to_owned().sort_by(|a, b| { count += 1; a.cmp(b) });\n+macro_rules! test {\n+    ($input:ident, $func:ident) => {\n+        let len = $input.len();\n+\n+        // Work out the total number of comparisons required to sort\n+        // this array...\n+        let mut count = 0usize;\n+        $input.to_owned().$func(|a, b| { count += 1; a.cmp(b) });\n+\n+        // ... and then panic on each and every single one.\n+        for panic_countdown in 0..count {\n+            // Refresh the counters.\n+            VERSIONS.store(0, Relaxed);\n+            for i in 0..len {\n+                DROP_COUNTS[i].store(0, Relaxed);\n+            }\n \n-    // ... and then panic on each and every single one.\n-    for panic_countdown in 0..count {\n-        // Refresh the counters.\n-        for i in 0..len {\n-            DROP_COUNTS[i].store(0, Ordering::Relaxed);\n-        }\n+            let v = $input.to_owned();\n+            let _ = thread::spawn(move || {\n+                let mut v = v;\n+                let mut panic_countdown = panic_countdown;\n+                v.$func(|a, b| {\n+                    if panic_countdown == 0 {\n+                        SILENCE_PANIC.with(|s| s.set(true));\n+                        panic!();\n+                    }\n+                    panic_countdown -= 1;\n+                    a.cmp(b)\n+                })\n+            }).join();\n+\n+            // Check that the number of things dropped is exactly\n+            // what we expect (i.e. the contents of `v`).\n+            for (i, c) in DROP_COUNTS.iter().enumerate().take(len) {\n+                let count = c.load(Relaxed);\n+                assert!(count == 1,\n+                        \"found drop count == {} for i == {}, len == {}\",\n+                        count, i, len);\n+            }\n \n-        let v = input.to_owned();\n-        let _ = thread::spawn(move || {\n-            let mut v = v;\n-            let mut panic_countdown = panic_countdown;\n-            v.sort_by(|a, b| {\n-                if panic_countdown == 0 {\n-                    SILENCE_PANIC.with(|s| s.set(true));\n-                    panic!();\n-                }\n-                panic_countdown -= 1;\n-                a.cmp(b)\n-            })\n-        }).join();\n-\n-        // Check that the number of things dropped is exactly\n-        // what we expect (i.e. the contents of `v`).\n-        for (i, c) in DROP_COUNTS.iter().enumerate().take(len) {\n-            let count = c.load(Ordering::Relaxed);\n-            assert!(count == 1,\n-                    \"found drop count == {} for i == {}, len == {}\",\n-                    count, i, len);\n+            // Check that the most recent versions of values were dropped.\n+            assert_eq!(VERSIONS.load(Relaxed), 0);\n         }\n     }\n }\n@@ -106,33 +140,41 @@ fn main() {\n             prev(info);\n         }\n     }));\n+\n+    let mut rng = thread_rng();\n+\n     for len in (1..20).chain(70..MAX_LEN) {\n-        // Test on a random array.\n-        let mut rng = thread_rng();\n-        let input = (0..len).map(|id| {\n-            DropCounter {\n-                x: rng.next_u32(),\n-                id: id,\n-            }\n-        }).collect::<Vec<_>>();\n-        test(&input);\n-\n-        // Test on a sorted array with two elements randomly swapped, creating several natural\n-        // runs of random lengths. Such arrays have very high chances of hitting all code paths in\n-        // the merge procedure.\n-        for _ in 0..5 {\n-            let mut input = (0..len).map(|i|\n-                DropCounter {\n-                    x: i as u32,\n-                    id: i,\n+        for &modulus in &[5, 20, 50] {\n+            for &has_runs in &[false, true] {\n+                let mut input = (0..len)\n+                    .map(|id| {\n+                        DropCounter {\n+                            x: rng.next_u32() % modulus,\n+                            id: id,\n+                            version: Cell::new(0),\n+                        }\n+                    })\n+                    .collect::<Vec<_>>();\n+\n+                if has_runs {\n+                    for c in &mut input {\n+                        c.x = c.id as u32;\n+                    }\n+\n+                    for _ in 0..5 {\n+                        let a = rng.gen::<usize>() % len;\n+                        let b = rng.gen::<usize>() % len;\n+                        if a < b {\n+                            input[a..b].reverse();\n+                        } else {\n+                            input.swap(a, b);\n+                        }\n+                    }\n                 }\n-            ).collect::<Vec<_>>();\n-\n-            let a = rng.gen::<usize>() % len;\n-            let b = rng.gen::<usize>() % len;\n-            input.swap(a, b);\n \n-            test(&input);\n+                test!(input, sort_by);\n+                test!(input, sort_unstable_by);\n+            }\n         }\n     }\n }"}]}