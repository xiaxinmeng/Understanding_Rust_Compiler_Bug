{"sha": "8f56e7c3b1220ed0b065e97a9061e59284ac1df1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmNTZlN2MzYjEyMjBlZDBiMDY1ZTk3YTkwNjFlNTkyODRhYzFkZjE=", "commit": {"author": {"name": "Zac Pullar-Strecker", "email": "zacmps@gmail.com", "date": "2020-06-10T02:21:00Z"}, "committer": {"name": "Zac Pullar-Strecker", "email": "zacmps@gmail.com", "date": "2020-06-30T08:02:46Z"}, "message": "Generate correct symbol filename for relative links", "tree": {"sha": "e474ef697d9cf7becce938476920f36eb4572850", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e474ef697d9cf7becce938476920f36eb4572850"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f56e7c3b1220ed0b065e97a9061e59284ac1df1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f56e7c3b1220ed0b065e97a9061e59284ac1df1", "html_url": "https://github.com/rust-lang/rust/commit/8f56e7c3b1220ed0b065e97a9061e59284ac1df1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f56e7c3b1220ed0b065e97a9061e59284ac1df1/comments", "author": {"login": "zacps", "id": 9827696, "node_id": "MDQ6VXNlcjk4Mjc2OTY=", "avatar_url": "https://avatars.githubusercontent.com/u/9827696?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zacps", "html_url": "https://github.com/zacps", "followers_url": "https://api.github.com/users/zacps/followers", "following_url": "https://api.github.com/users/zacps/following{/other_user}", "gists_url": "https://api.github.com/users/zacps/gists{/gist_id}", "starred_url": "https://api.github.com/users/zacps/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zacps/subscriptions", "organizations_url": "https://api.github.com/users/zacps/orgs", "repos_url": "https://api.github.com/users/zacps/repos", "events_url": "https://api.github.com/users/zacps/events{/privacy}", "received_events_url": "https://api.github.com/users/zacps/received_events", "type": "User", "site_admin": false}, "committer": {"login": "zacps", "id": 9827696, "node_id": "MDQ6VXNlcjk4Mjc2OTY=", "avatar_url": "https://avatars.githubusercontent.com/u/9827696?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zacps", "html_url": "https://github.com/zacps", "followers_url": "https://api.github.com/users/zacps/followers", "following_url": "https://api.github.com/users/zacps/following{/other_user}", "gists_url": "https://api.github.com/users/zacps/gists{/gist_id}", "starred_url": "https://api.github.com/users/zacps/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zacps/subscriptions", "organizations_url": "https://api.github.com/users/zacps/orgs", "repos_url": "https://api.github.com/users/zacps/repos", "events_url": "https://api.github.com/users/zacps/events{/privacy}", "received_events_url": "https://api.github.com/users/zacps/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f497f6b4e048614094a9b38efe98cbb098013d18", "url": "https://api.github.com/repos/rust-lang/rust/commits/f497f6b4e048614094a9b38efe98cbb098013d18", "html_url": "https://github.com/rust-lang/rust/commit/f497f6b4e048614094a9b38efe98cbb098013d18"}], "stats": {"total": 52, "additions": 42, "deletions": 10}, "files": [{"sha": "112c4210dfb5a77fcc9f4f55faa28257f8fff4a4", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f56e7c3b1220ed0b065e97a9061e59284ac1df1/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/8f56e7c3b1220ed0b065e97a9061e59284ac1df1/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=8f56e7c3b1220ed0b065e97a9061e59284ac1df1", "patch": "@@ -1276,12 +1276,14 @@ dependencies = [\n  \"ra_fmt\",\n  \"ra_hir\",\n  \"ra_hir_def\",\n+ \"ra_hir_expand\",\n  \"ra_ide_db\",\n  \"ra_prof\",\n  \"ra_project_model\",\n  \"ra_ssr\",\n  \"ra_syntax\",\n  \"ra_text_edit\",\n+ \"ra_tt\",\n  \"rand\",\n  \"rustc-hash\",\n  \"stdx\","}, {"sha": "219ad33e616c639d44c4bf5568675aac6720a135", "filename": "crates/ra_ide/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8f56e7c3b1220ed0b065e97a9061e59284ac1df1/crates%2Fra_ide%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8f56e7c3b1220ed0b065e97a9061e59284ac1df1/crates%2Fra_ide%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2FCargo.toml?ref=8f56e7c3b1220ed0b065e97a9061e59284ac1df1", "patch": "@@ -35,6 +35,7 @@ ra_ssr = { path = \"../ra_ssr\" }\n ra_project_model = { path = \"../ra_project_model\" }\n ra_hir_def = { path = \"../ra_hir_def\" }\n ra_tt = { path = \"../ra_tt\" }\n+ra_hir_expand = { path = \"../ra_hir_expand\" }\n \n # ra_ide should depend only on the top-level `hir` package. if you need\n # something from some `hir_xxx` subpackage, reexport the API via `hir`."}, {"sha": "760d7fe14c27bd4fedaad6c21f2823ee0dadba8d", "filename": "crates/ra_ide/src/hover.rs", "status": "modified", "additions": 39, "deletions": 10, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/8f56e7c3b1220ed0b065e97a9061e59284ac1df1/crates%2Fra_ide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f56e7c3b1220ed0b065e97a9061e59284ac1df1/crates%2Fra_ide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fhover.rs?ref=8f56e7c3b1220ed0b065e97a9061e59284ac1df1", "patch": "@@ -16,6 +16,7 @@ use ra_syntax::{ast, match_ast, AstNode, SyntaxKind::*, SyntaxToken, TokenAtOffs\n use ra_project_model::ProjectWorkspace;\n use ra_hir_def::{item_scope::ItemInNs, db::DefDatabase};\n use ra_tt::{Literal, Ident, Punct, TokenTree, Leaf};\n+use ra_hir_expand::name::AsName;\n \n use comrak::{parse_document,format_commonmark, ComrakOptions, Arena};\n use comrak::nodes::NodeValue;\n@@ -406,9 +407,9 @@ fn rewrite_links(db: &RootDatabase, markdown: &str, definition: &Definition, wor\n                 match Url::parse(&String::from_utf8(link.url.clone()).unwrap()) {\n                     // If this is a valid absolute URL don't touch it\n                     Ok(_) => (),\n-                    // If contains .html            file-based link to new page\n-                    // If starts with #fragment     file-based link to fragment on current page\n-                    // If contains ::               module-based link\n+                    // Otherwise there are two main possibilities\n+                    // path-based links: `../../module/struct.MyStruct.html`\n+                    // module-based links (AKA intra-doc links): `super::super::module::MyStruct`\n                     Err(_) => {\n                         let link_str = String::from_utf8(link.url.clone()).unwrap();\n                         let resolved = try_resolve_path(db, &mut doc_target_dirs.clone(), definition, &link_str, UrlMode::Url)\n@@ -429,7 +430,9 @@ fn rewrite_links(db: &RootDatabase, markdown: &str, definition: &Definition, wor\n     Some(String::from_utf8(out).unwrap())\n }\n \n-/// Try to resolve path to local documentation via intra-doc-links (i.e. `super::gateway::Shard`)\n+/// Try to resolve path to local documentation via intra-doc-links (i.e. `super::gateway::Shard`).\n+///\n+/// See [RFC1946](https://github.com/rust-lang/rfcs/blob/master/text/1946-intra-rustdoc-links.md).\n fn try_resolve_intra(db: &RootDatabase, doc_target_dirs: impl Iterator<Item = PathBuf>, definition: &Definition, link: &str) -> Option<String> {\n     None\n }\n@@ -439,7 +442,7 @@ enum UrlMode {\n     File\n }\n \n-/// Try to resolve path to local documentation via path-based links (i.e. `../gateway/struct.Shard.html`)\n+/// Try to resolve path to local documentation via path-based links (i.e. `../gateway/struct.Shard.html`).\n fn try_resolve_path(db: &RootDatabase, doc_target_dirs: impl Iterator<Item = PathBuf>, definition: &Definition, link: &str, mode: UrlMode) -> Option<String> {\n     let ns = if let Definition::ModuleDef(moddef) = definition {\n         ItemInNs::Types(moddef.clone().into())\n@@ -456,12 +459,12 @@ fn try_resolve_path(db: &RootDatabase, doc_target_dirs: impl Iterator<Item = Pat\n \n     match mode {\n         UrlMode::Url => {\n-            let root = get_doc_url(db, &krate);\n             let mut base = base.join(\"/\");\n-            if link.starts_with(\"#\") {\n-                base = base + \"/\"\n-            };\n-            root.and_then(|url| url.join(&base).ok()).and_then(|url| url.join(link).ok()).map(|url| url.into_string())\n+            get_doc_url(db, &krate)\n+                .and_then(|url| url.join(&base).ok())\n+                .and_then(|url| get_symbol_filename(db, definition).as_deref().map(|f| url.join(f).ok()).flatten())\n+                .and_then(|url| url.join(link).ok())\n+                .map(|url| url.into_string())\n         },\n         UrlMode::File => {\n             let base = base.collect::<PathBuf>();\n@@ -502,6 +505,32 @@ fn get_doc_url(db: &RootDatabase, krate: &Crate) -> Option<Url> {\n     doc_url.map(|s| s.trim_matches('\"').to_owned() + \"/\").and_then(|s| Url::parse(&s).ok())\n }\n \n+/// Get the filename and extension generated for a symbol by rustdoc.\n+///\n+/// Example: `struct.Shard.html`\n+fn get_symbol_filename(db: &RootDatabase, definition: &Definition) -> Option<String> {\n+    Some(match definition {\n+        Definition::ModuleDef(def) => match def {\n+            ModuleDef::Adt(adt) => match adt {\n+                Adt::Struct(s) => format!(\"struct.{}.html\", s.name(db)),\n+                Adt::Enum(e) => format!(\"enum.{}.html\", e.name(db)),\n+                Adt::Union(u) => format!(\"union.{}.html\", u.name(db))\n+            },\n+            ModuleDef::Module(_) => \"index.html\".to_string(),\n+            ModuleDef::Trait(t) => format!(\"trait.{}.html\", t.name(db)),\n+            ModuleDef::TypeAlias(t) => format!(\"type.{}.html\", t.name(db)),\n+            ModuleDef::BuiltinType(t) => format!(\"primitive.{}.html\", t.as_name()),\n+            ModuleDef::Function(f) => format!(\"fn.{}.html\", f.name(db)),\n+            ModuleDef::EnumVariant(ev) => format!(\"enum.{}.html#variant.{}\", ev.parent_enum(db).name(db), ev.name(db)),\n+            ModuleDef::Const(c) => format!(\"const.{}.html\", c.name(db)?),\n+            // TODO: Check this is the right prefix\n+            ModuleDef::Static(s) => format!(\"static.{}.html\", s.name(db)?)\n+        },\n+        Definition::Macro(m) => format!(\"macro.{}.html\", m.name(db)?),\n+        _ => None?\n+    })\n+}\n+\n fn iter_nodes<'a, F>(node: &'a comrak::nodes::AstNode<'a>, f: &F)\n     where F : Fn(&'a comrak::nodes::AstNode<'a>) {\n     f(node);"}]}