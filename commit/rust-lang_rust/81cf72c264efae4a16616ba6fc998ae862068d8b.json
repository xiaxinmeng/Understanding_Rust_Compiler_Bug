{"sha": "81cf72c264efae4a16616ba6fc998ae862068d8b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxY2Y3MmMyNjRlZmFlNGExNjYxNmJhNmZjOTk4YWU4NjIwNjhkOGI=", "commit": {"author": {"name": "James Miller", "email": "bladeon@gmail.com", "date": "2013-06-16T10:52:44Z"}, "committer": {"name": "James Miller", "email": "bladeon@gmail.com", "date": "2013-06-22T00:35:35Z"}, "message": "Finish up Type refactoring", "tree": {"sha": "69a21cbeb51264632a4abe7766c854ded9733bc7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/69a21cbeb51264632a4abe7766c854ded9733bc7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/81cf72c264efae4a16616ba6fc998ae862068d8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/81cf72c264efae4a16616ba6fc998ae862068d8b", "html_url": "https://github.com/rust-lang/rust/commit/81cf72c264efae4a16616ba6fc998ae862068d8b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/81cf72c264efae4a16616ba6fc998ae862068d8b/comments", "author": null, "committer": null, "parents": [{"sha": "57a75374d63604e88c33a0cb16aaa17ac1442fa1", "url": "https://api.github.com/repos/rust-lang/rust/commits/57a75374d63604e88c33a0cb16aaa17ac1442fa1", "html_url": "https://github.com/rust-lang/rust/commit/57a75374d63604e88c33a0cb16aaa17ac1442fa1"}], "stats": {"total": 1403, "additions": 517, "deletions": 886}, "files": [{"sha": "76bba481619859677b262aeb1626d6d537c8b3c3", "filename": "src/librustc/back/upcall.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/81cf72c264efae4a16616ba6fc998ae862068d8b/src%2Flibrustc%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81cf72c264efae4a16616ba6fc998ae862068d8b/src%2Flibrustc%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fupcall.rs?ref=81cf72c264efae4a16616ba6fc998ae862068d8b", "patch": "@@ -24,25 +24,25 @@ pub struct Upcalls {\n \n macro_rules! upcall (\n     (fn $name:ident($($arg:expr),+) -> $ret:expr) => ({\n-        let fn_ty = Type::func([ $($arg),* ], $ret);\n+        let fn_ty = Type::func([ $($arg),* ], &$ret);\n         base::decl_cdecl_fn(llmod, ~\"upcall_\" + stringify!($name), fn_ty)\n     });\n     (nothrow fn $name:ident($($arg:expr),+) -> $ret:expr) => ({\n-        let fn_ty = Type::func([ $($arg),* ], $ret);\n+        let fn_ty = Type::func([ $($arg),* ], &$ret);\n         let decl = base::decl_cdecl_fn(llmod, ~\"upcall_\" + stringify!($name), fn_ty);\n         base::set_no_unwind(decl);\n         decl\n     });\n     (nothrow fn $name:ident -> $ret:expr) => ({\n-        let fn_ty = Type::func([], $ret);\n+        let fn_ty = Type::func([], &$ret);\n         let decl = base::decl_cdecl_fn(llmod, ~\"upcall_\" + stringify!($name), fn_ty);\n         base::set_no_unwind(decl);\n         decl\n     })\n )\n \n pub fn declare_upcalls(targ_cfg: @session::config, llmod: ModuleRef) -> @Upcalls {\n-    let opaque_ptr = Type::i8().to_ptr();\n+    let opaque_ptr = Type::i8().ptr_to();\n     let int_ty = Type::int(targ_cfg.arch);\n \n     @Upcalls {"}, {"sha": "ec3bf61608c34703762b435357c74258e96fdabc", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 12, "deletions": 35, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/81cf72c264efae4a16616ba6fc998ae862068d8b/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81cf72c264efae4a16616ba6fc998ae862068d8b/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=81cf72c264efae4a16616ba6fc998ae862068d8b", "patch": "@@ -2141,7 +2141,7 @@ impl TypeNames {\n     }\n \n     pub fn find_name<'r>(&'r self, ty: &Type) -> Option<&'r str> {\n-        match self.type_names.find(ty.to_ref()) {\n+        match self.type_names.find(&ty.to_ref()) {\n             Some(a) => Some(a.slice(0, a.len())),\n             None => None\n         }\n@@ -2151,14 +2151,14 @@ impl TypeNames {\n         self.named_types.find_equiv(&s).map_consume(|x| Type::from_ref(*x))\n     }\n \n-    pub fn type_to_str(&self, ty: TypeRef) -> ~str {\n+    pub fn type_to_str(&self, ty: Type) -> ~str {\n         match self.find_name(&ty) {\n             option::Some(name) => return name.to_owned(),\n             None => ()\n         }\n \n         unsafe {\n-            let kind = llvm::LLVMGetTypeKind(ty);\n+            let kind = ty.kind();\n \n             match kind {\n                 Void => ~\"Void\",\n@@ -2172,31 +2172,28 @@ impl TypeNames {\n                 Metadata => ~\"Metadata\",\n                 X86_MMX => ~\"X86_MMAX\",\n                 Integer => {\n-                    fmt!(\"i%d\", llvm::LLVMGetIntTypeWidth(ty) as int)\n+                    fmt!(\"i%d\", llvm::LLVMGetIntTypeWidth(ty.to_ref()) as int)\n                 }\n                 Function => {\n-                    let out_ty = llvm::LLVMGetReturnType(ty);\n-                    let n_args = llvm::LLVMCountParamTypes(ty) as uint;\n-                    let args = vec::from_elem(n_args, 0 as TypeRef);\n-                    llvm::LLVMGetParamTypes(ty, vec::raw::to_ptr(args));\n-\n+                    let out_ty = ty.return_type();\n+                    let args = ty.func_params();\n                     let args = args.map(|&ty| self.type_to_str(ty)).connect(\", \");\n                     let out_ty = self.type_to_str(out_ty);\n                     fmt!(\"fn(%s) -> %s\", args, out_ty)\n                 }\n                 Struct => {\n-                    let tys = struct_tys(ty);\n+                    let tys = ty.field_types();\n                     let tys = tys.map(|&ty| self.type_to_str(ty)).connect(\", \");\n                     fmt!(\"{%s}\", tys)\n                 }\n                 Array => {\n-                    let el_ty = llvm::LLVMGetElementType(ty);\n+                    let el_ty = ty.element_type();\n                     let el_ty = self.type_to_str(el_ty);\n-                    let len = llvm::LLVMGetArrayLength(ty) as uint;\n+                    let len = ty.array_length();\n                     fmt!(\"[%s x %u]\", el_ty, len)\n                 }\n                 Pointer => {\n-                    let el_ty = llvm::LLVMGetElementType(ty);\n+                    let el_ty = ty.element_type();\n                     let el_ty = self.type_to_str(el_ty);\n                     fmt!(\"*%s\", el_ty)\n                 }\n@@ -2207,32 +2204,12 @@ impl TypeNames {\n \n     pub fn val_to_str(&self, val: ValueRef) -> ~str {\n         unsafe {\n-            self.type_to_str(llvm::LLVMTypeOf(val))\n+            let ty = Type::from_ref(llvm::LLVMTypeOf(val));\n+            self.type_to_str(ty)\n         }\n     }\n }\n \n-pub fn float_width(llt: TypeRef) -> uint {\n-    unsafe {\n-        return match llvm::LLVMGetTypeKind(llt) as int {\n-              1 => 32u,\n-              2 => 64u,\n-              3 => 80u,\n-              4 | 5 => 128u,\n-              _ => fail!(\"llvm_float_width called on a non-float type\")\n-            };\n-    }\n-}\n-\n-pub fn fn_ty_param_tys(fn_ty: TypeRef) -> ~[TypeRef] {\n-    unsafe {\n-        let args = vec::from_elem(llvm::LLVMCountParamTypes(fn_ty) as uint,\n-                                 0 as TypeRef);\n-        llvm::LLVMGetParamTypes(fn_ty, vec::raw::to_ptr(args));\n-        return args;\n-    }\n-}\n-\n \n /* Memory-managed interface to target data. */\n "}, {"sha": "72da71afed6e23f4dbdff3fc0e035628f7bc5675", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81cf72c264efae4a16616ba6fc998ae862068d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81cf72c264efae4a16616ba6fc998ae862068d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=81cf72c264efae4a16616ba6fc998ae862068d8b", "patch": "@@ -911,7 +911,7 @@ pub fn extract_vec_elems(bcx: block,\n                     Sub(bcx, count,\n                         C_int(bcx.ccx(), (elem_count - i) as int))])\n             }\n-            _ => unsafe { llvm::LLVMGetUndef(vt.llunit_ty) }\n+            _ => unsafe { llvm::LLVMGetUndef(vt.llunit_ty.to_ref()) }\n         }\n     };\n     if slice.is_some() {"}, {"sha": "906c9d028ebc619d7152195f97b65944a44bfa5d", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/81cf72c264efae4a16616ba6fc998ae862068d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81cf72c264efae4a16616ba6fc998ae862068d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=81cf72c264efae4a16616ba6fc998ae862068d8b", "patch": "@@ -59,6 +59,8 @@ use middle::ty;\n use syntax::ast;\n use util::ppaux::ty_to_str;\n \n+use middle::trans::type_::Type;\n+\n \n /// Representations.\n pub enum Repr {\n@@ -260,10 +262,8 @@ fn generic_fields_of(cx: &mut CrateContext, r: &Repr, sizing: bool) -> ~[Type] {\n             let most_aligned = most_aligned.get();\n             let padding = largest_size - most_aligned.size;\n \n-            assert!(padding >= 0);\n-\n             struct_llfields(cx, most_aligned, sizing)\n-                + [Type::array(Type::i8(), padding /*bad*/as uint)]\n+                + [Type::array(&Type::i8(), padding)]\n         }\n     }\n }\n@@ -439,7 +439,7 @@ pub fn trans_field_ptr(bcx: block, r: &Repr, val: ValueRef, discr: int,\n                 // The unit-like case might have a nonzero number of unit-like fields.\n                 // (e.g., Result or Either with () as one side.)\n                 let ty = type_of::type_of(bcx.ccx(), nullfields[ix]);\n-                assert_eq!(machine::llsize_of_alloc(bcx.ccx(), llty), 0);\n+                assert_eq!(machine::llsize_of_alloc(bcx.ccx(), ty), 0);\n                 // The contents of memory at this pointer can't matter, but use\n                 // the value that's \"reasonable\" in case of pointer comparison.\n                 PointerCast(bcx, val, ty.ptr_to())\n@@ -457,7 +457,7 @@ fn struct_field_ptr(bcx: block, st: &Struct, val: ValueRef, ix: uint,\n             type_of::type_of(ccx, ty)\n         };\n         let real_ty = Type::struct_(fields, st.packed);\n-        PointerCast(bcx, val, real_llty.to_ptr().to_ref())\n+        PointerCast(bcx, val, real_ty.ptr_to())\n     } else {\n         val\n     };\n@@ -572,7 +572,7 @@ fn build_const_struct(ccx: &mut CrateContext, st: &Struct, vals: &[ValueRef])\n }\n \n fn padding(size: u64) -> ValueRef {\n-    C_undef(Type::array(Type::i8(), size).to_ref())\n+    C_undef(Type::array(&Type::i8(), size))\n }\n \n // XXX this utility routine should be somewhere more general"}, {"sha": "dd8b7ebc00b74c47cbf66f4cc0da720df00bc277", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81cf72c264efae4a16616ba6fc998ae862068d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81cf72c264efae4a16616ba6fc998ae862068d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=81cf72c264efae4a16616ba6fc998ae862068d8b", "patch": "@@ -20,6 +20,8 @@ use middle::trans::callee;\n use middle::trans::common::*;\n use middle::ty;\n \n+use middle::trans::type_::Type;\n+\n use core::str;\n use syntax::ast;\n "}, {"sha": "8ec05f447ee367fe0b7d8bd7830110412fbbafe9", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 43, "deletions": 49, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/81cf72c264efae4a16616ba6fc998ae862068d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81cf72c264efae4a16616ba6fc998ae862068d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=81cf72c264efae4a16616ba6fc998ae862068d8b", "patch": "@@ -63,6 +63,8 @@ use middle::ty;\n use util::common::indenter;\n use util::ppaux::{Repr, ty_to_str};\n \n+use middle::trans::type_::Type;\n+\n use core::hash;\n use core::hashmap::{HashMap};\n use core::int;\n@@ -150,7 +152,7 @@ pub fn decl_fn(llmod: ModuleRef, name: &str, cc: lib::llvm::CallConv, ty: Type)\n }\n \n pub fn decl_cdecl_fn(llmod: ModuleRef, name: &str, ty: Type) -> ValueRef {\n-    return decl_fn(llmod, name, lib::llvm::CCallConv, llty);\n+    return decl_fn(llmod, name, lib::llvm::CCallConv, ty);\n }\n \n // Only use this if you are going to actually define the function. It's\n@@ -229,7 +231,7 @@ pub fn opaque_box_body(bcx: block,\n     let _icx = bcx.insn_ctxt(\"opaque_box_body\");\n     let ccx = bcx.ccx();\n     let ty = type_of(ccx, body_t);\n-    let ty = Type::box(ccx, ty);\n+    let ty = Type::box(ccx, &ty);\n     let boxptr = PointerCast(bcx, boxptr, ty.ptr_to());\n     GEPi(bcx, boxptr, [0u, abi::box_field_body])\n }\n@@ -281,15 +283,8 @@ pub fn malloc_raw_dyn(bcx: block,\n * address space 0. Otherwise the resulting (non-box) pointer will be in the\n * wrong address space and thus be the wrong type.\n */\n-pub fn non_gc_box_cast(bcx: block, val: ValueRef) -> ValueRef {\n-    unsafe {\n-        debug!(\"non_gc_box_cast\");\n-        add_comment(bcx, \"non_gc_box_cast\");\n-        assert!(llvm::LLVMGetPointerAddressSpace(val_ty(val)) ==\n-                     gc_box_addrspace || bcx.unreachable);\n-        let non_gc_t = llvm::LLVMGetElementType(val_ty(val)).ptr_to();\n-        PointerCast(bcx, val, non_gc_t)\n-    }\n+pub fn non_gc_box_cast(_: block, val: ValueRef) -> ValueRef {\n+    val\n }\n \n // malloc_raw: expects an unboxed type and returns a pointer to\n@@ -721,8 +716,8 @@ pub fn cast_shift_expr_rhs(cx: block, op: ast::binop,\n pub fn cast_shift_const_rhs(op: ast::binop,\n                             lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     cast_shift_rhs(op, lhs, rhs,\n-                   |a, b| unsafe { llvm::LLVMConstTrunc(a, b) },\n-                   |a, b| unsafe { llvm::LLVMConstZExt(a, b) })\n+                   |a, b| unsafe { llvm::LLVMConstTrunc(a, b.to_ref()) },\n+                   |a, b| unsafe { llvm::LLVMConstZExt(a, b.to_ref()) })\n }\n \n pub fn cast_shift_rhs(op: ast::binop,\n@@ -735,8 +730,8 @@ pub fn cast_shift_rhs(op: ast::binop,\n         if ast_util::is_shift_binop(op) {\n             let rhs_llty = val_ty(rhs);\n             let lhs_llty = val_ty(lhs);\n-            let rhs_sz = llvm::LLVMGetIntTypeWidth(rhs_llty);\n-            let lhs_sz = llvm::LLVMGetIntTypeWidth(lhs_llty);\n+            let rhs_sz = llvm::LLVMGetIntTypeWidth(rhs_llty.to_ref());\n+            let lhs_sz = llvm::LLVMGetIntTypeWidth(lhs_llty.to_ref());\n             if lhs_sz < rhs_sz {\n                 trunc(rhs, lhs_llty)\n             } else if lhs_sz > rhs_sz {\n@@ -761,11 +756,11 @@ pub fn fail_if_zero(cx: block, span: span, divrem: ast::binop,\n     };\n     let is_zero = match ty::get(rhs_t).sty {\n       ty::ty_int(t) => {\n-        let zero = C_integral(Type::int_from_ty(cx.ccx(), t), 0u64, False);\n+        let zero = C_integral(Type::int_from_ty(cx.ccx(), t), 0u64, false);\n         ICmp(cx, lib::llvm::IntEQ, rhs, zero)\n       }\n       ty::ty_uint(t) => {\n-        let zero = C_integral(Type::uint_from_ty(cx.ccx(), t), 0u64, False);\n+        let zero = C_integral(Type::uint_from_ty(cx.ccx(), t), 0u64, false);\n         ICmp(cx, lib::llvm::IntEQ, rhs, zero)\n       }\n       _ => {\n@@ -779,7 +774,7 @@ pub fn fail_if_zero(cx: block, span: span, divrem: ast::binop,\n }\n \n pub fn null_env_ptr(bcx: block) -> ValueRef {\n-    C_null(Type::opaque_box(bcx.ccx()).to_ptr())\n+    C_null(Type::opaque_box(bcx.ccx()).ptr_to())\n }\n \n pub fn trans_external_path(ccx: &mut CrateContext, did: ast::def_id, t: ty::t)\n@@ -1479,7 +1474,7 @@ pub fn memzero(cx: block, llptr: ValueRef, llty: TypeRef) {\n     let llintrinsicfn = ccx.intrinsics.get_copy(&intrinsic_key);\n     let llptr = PointerCast(cx, llptr, Type::i8().ptr_to());\n     let llzeroval = C_u8(0);\n-    let size = IntCast(cx, machine::llsize_of(ccx, ty), ccx.int_type.to_ref());\n+    let size = IntCast(cx, machine::llsize_of(ccx, ty), ccx.int_type);\n     let align = C_i32(llalign_of_min(ccx, ty) as i32);\n     let volatile = C_i1(false);\n     Call(cx, llintrinsicfn, [llptr, llzeroval, size, align, volatile]);\n@@ -1506,7 +1501,7 @@ pub fn alloca_maybe_zeroed(cx: block, t: TypeRef, zero: bool) -> ValueRef {\n         }\n     }\n     let initcx = base::raw_block(cx.fcx, false, cx.fcx.llstaticallocas);\n-    let p = Alloca(initcx, ty.to_ref());\n+    let p = Alloca(initcx, ty);\n     if zero { memzero(initcx, p, ty); }\n     p\n }\n@@ -1515,10 +1510,10 @@ pub fn arrayalloca(cx: block, t: TypeRef, v: ValueRef) -> ValueRef {\n     let _icx = cx.insn_ctxt(\"arrayalloca\");\n     if cx.unreachable {\n         unsafe {\n-            return llvm::LLVMGetUndef(ty);\n+            return llvm::LLVMGetUndef(ty.to_ref());\n         }\n     }\n-    return ArrayAlloca(base::raw_block(cx.fcx, false, cx.fcx.llstaticallocas), ty.to_ref(), v);\n+    return ArrayAlloca(base::raw_block(cx.fcx, false, cx.fcx.llstaticallocas), ty, v);\n }\n \n pub struct BasicBlocks {\n@@ -1588,7 +1583,7 @@ pub fn new_fn_ctxt_w_id(ccx: @mut CrateContext,\n     let fcx = @mut fn_ctxt_ {\n           llfn: llfndecl,\n           llenv: unsafe {\n-              llvm::LLVMGetUndef(Type::i8p())\n+              llvm::LLVMGetUndef(Type::i8p().to_ref())\n           },\n           llretptr: None,\n           llstaticallocas: llbbs.sa,\n@@ -2309,7 +2304,7 @@ pub fn create_entry_wrapper(ccx: @mut CrateContext,\n     fn create_entry_fn(ccx: @mut CrateContext,\n                        rust_main: ValueRef,\n                        use_start_lang_item: bool) {\n-        let llfty = Type::func([ccx.int_type, Type::i8().ptr_to().ptr_to()], ccx.int_type);\n+        let llfty = Type::func([ccx.int_type, Type::i8().ptr_to().ptr_to()], &ccx.int_type);\n \n         // FIXME #4404 android JNI hacks\n         let llfn = if *ccx.sess.building_library {\n@@ -2338,10 +2333,9 @@ pub fn create_entry_wrapper(ccx: @mut CrateContext,\n             }\n \n             let crate_map = ccx.crate_map;\n-            let opaque_crate_map = llvm::LLVMBuildPointerCast(bld,\n-                                                              crate_map,\n-                                                              Type::i8p(),\n-                                                              noname());\n+            let opaque_crate_map = do \"crate_map\".as_c_str |buf| {\n+                llvm::LLVMBuildPointerCast(bld, crate_map, Type::i8p().to_ref(), buf)\n+            };\n \n             let (start_fn, args) = if use_start_lang_item {\n                 let start_def_id = ccx.tcx.lang_items.start_fn();\n@@ -2354,8 +2348,9 @@ pub fn create_entry_wrapper(ccx: @mut CrateContext,\n                 };\n \n                 let args = {\n-                    let opaque_rust_main = llvm::LLVMBuildPointerCast(\n-                            bld, rust_main, Type::i8p(), noname());\n+                    let opaque_rust_main = do \"rust_main\".as_c_str |buf| {\n+                        llvm::LLVMBuildPointerCast(bld, rust_main, Type::i8p().to_ref(), buf)\n+                    };\n \n                     ~[\n                         C_null(Type::opaque_box(ccx).ptr_to()),\n@@ -2487,7 +2482,7 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::node_id) -> ValueRef {\n                     let g = do str::as_c_str(ident) |buf| {\n                         unsafe {\n                             let ty = type_of(ccx, typ);\n-                            llvm::LLVMAddGlobal(ccx.llmod, ty, buf)\n+                            llvm::LLVMAddGlobal(ccx.llmod, ty.to_ref(), buf)\n                         }\n                     };\n                     g\n@@ -2583,7 +2578,7 @@ pub fn trans_constant(ccx: @mut CrateContext, it: @ast::item) {\n             note_unique_llvm_symbol(ccx, s);\n             let discrim_gvar = str::as_c_str(s, |buf| {\n                 unsafe {\n-                    llvm::LLVMAddGlobal(ccx.llmod, ccx.int_type, buf)\n+                    llvm::LLVMAddGlobal(ccx.llmod, ccx.int_type.to_ref(), buf)\n                 }\n             });\n             unsafe {\n@@ -2616,14 +2611,14 @@ pub fn vp2i(cx: block, v: ValueRef) -> ValueRef {\n \n pub fn p2i(ccx: &CrateContext, v: ValueRef) -> ValueRef {\n     unsafe {\n-        return llvm::LLVMConstPtrToInt(v, ccx.int_type);\n+        return llvm::LLVMConstPtrToInt(v, ccx.int_type.to_ref());\n     }\n }\n \n macro_rules! ifn (\n     ($name:expr, $args:expr, $ret:expr) => ({\n         let name = $name;\n-        let f = decl_cdecl_fn(llmod, name, Type::func($args, $ret));\n+        let f = decl_cdecl_fn(llmod, name, Type::func($args, &$ret));\n         intrinsics.insert(name, f);\n     })\n )\n@@ -2642,7 +2637,7 @@ pub fn declare_intrinsics(llmod: ModuleRef) -> HashMap<&'static str, ValueRef> {\n          [i8p, i8p, Type::i64(), Type::i32(), Type::i1()], Type::void());\n     ifn!(\"llvm.memset.p0i8.i32\",\n          [i8p, Type::i8(), Type::i32(), Type::i32(), Type::i1()], Type::void());\n-    ifn!(\"llvm.memcpy.p0i8.i64\",\n+    ifn!(\"llvm.memset.p0i8.i64\",\n          [i8p, Type::i8(), Type::i64(), Type::i32(), Type::i1()], Type::void());\n \n     ifn!(\"llvm.trap\", [], Type::void());\n@@ -2710,7 +2705,7 @@ pub fn declare_dbg_intrinsics(llmod: ModuleRef, intrinsics: &mut HashMap<&'stati\n }\n \n pub fn trap(bcx: block) {\n-    match bcx.ccx().intrinsics.find_equiv(\"llvm.trap\") {\n+    match bcx.ccx().intrinsics.find_equiv(& &\"llvm.trap\") {\n       Some(&x) => { Call(bcx, x, []); },\n       _ => bcx.sess().bug(\"unbound llvm.trap in trap\")\n     }\n@@ -2724,7 +2719,7 @@ pub fn decl_gc_metadata(ccx: &mut CrateContext, llmod_id: &str) {\n     let gc_metadata_name = ~\"_gc_module_metadata_\" + llmod_id;\n     let gc_metadata = do str::as_c_str(gc_metadata_name) |buf| {\n         unsafe {\n-            llvm::LLVMAddGlobal(ccx.llmod, Type::i32(), buf)\n+            llvm::LLVMAddGlobal(ccx.llmod, Type::i32().to_ref(), buf)\n         }\n     };\n     unsafe {\n@@ -2736,12 +2731,12 @@ pub fn decl_gc_metadata(ccx: &mut CrateContext, llmod_id: &str) {\n \n pub fn create_module_map(ccx: &mut CrateContext) -> ValueRef {\n     let elttype = Type::struct_([ccx.int_type, ccx.int_type], false);\n-    let maptype = Type::array(elttype, ccx.module_data.len() + 1);\n-    let map = str::as_c_str(\"_rust_mod_map\", |buf| {\n+    let maptype = Type::array(&elttype, (ccx.module_data.len() + 1) as u64);\n+    let map = do \"_rust_mod_map\".as_c_str |buf| {\n         unsafe {\n-            llvm::LLVMAddGlobal(ccx.llmod, maptype, buf)\n+            llvm::LLVMAddGlobal(ccx.llmod, maptype.to_ref(), buf)\n         }\n-    });\n+    };\n     lib::llvm::SetLinkage(map, lib::llvm::InternalLinkage);\n     let mut elts: ~[ValueRef] = ~[];\n \n@@ -2783,11 +2778,11 @@ pub fn decl_crate_map(sess: session::Session, mapmeta: LinkMeta,\n         ~\"toplevel\"\n     };\n     let sym_name = ~\"_rust_crate_map_\" + mapname;\n-    let arrtype = Type::array(int_type, n_subcrates as u64);\n+    let arrtype = Type::array(&int_type, n_subcrates as u64);\n     let maptype = Type::struct_([Type::i32(), Type::i8p(), int_type, arrtype], false);\n     let map = str::as_c_str(sym_name, |buf| {\n         unsafe {\n-            llvm::LLVMAddGlobal(llmod, maptype, buf)\n+            llvm::LLVMAddGlobal(llmod, maptype.to_ref(), buf)\n         }\n     });\n     lib::llvm::SetLinkage(map, lib::llvm::ExternalLinkage);\n@@ -2806,7 +2801,7 @@ pub fn fill_crate_map(ccx: @mut CrateContext, map: ValueRef) {\n                       cstore::get_crate_hash(cstore, i));\n         let cr = str::as_c_str(nm, |buf| {\n             unsafe {\n-                llvm::LLVMAddGlobal(ccx.llmod, ccx.int_type, buf)\n+                llvm::LLVMAddGlobal(ccx.llmod, ccx.int_type.to_ref(), buf)\n             }\n         });\n         subcrates.push(p2i(ccx, cr));\n@@ -2830,8 +2825,7 @@ pub fn fill_crate_map(ccx: @mut CrateContext, map: ValueRef) {\n         let mod_map = create_module_map(ccx);\n         llvm::LLVMSetInitializer(map, C_struct(\n             [C_i32(1),\n-             lib::llvm::llvm::LLVMConstPointerCast(llannihilatefn,\n-                                                   Type::i8p()),\n+             lib::llvm::llvm::LLVMConstPointerCast(llannihilatefn, Type::i8p().to_ref()),\n              p2i(ccx, mod_map),\n              C_array(ccx.int_type, subcrates)]));\n     }\n@@ -2869,7 +2863,7 @@ pub fn write_metadata(cx: &mut CrateContext, crate: &ast::crate) {\n     let llconst = C_struct([llmeta]);\n     let mut llglobal = str::as_c_str(\"rust_metadata\", |buf| {\n         unsafe {\n-            llvm::LLVMAddGlobal(cx.llmod, val_ty(llconst), buf)\n+            llvm::LLVMAddGlobal(cx.llmod, val_ty(llconst).to_ref(), buf)\n         }\n     });\n     unsafe {\n@@ -2880,9 +2874,9 @@ pub fn write_metadata(cx: &mut CrateContext, crate: &ast::crate) {\n         lib::llvm::SetLinkage(llglobal, lib::llvm::InternalLinkage);\n \n         let t_ptr_i8 = Type::i8p();\n-        llglobal = llvm::LLVMConstBitCast(llglobal, t_ptr_i8);\n+        llglobal = llvm::LLVMConstBitCast(llglobal, t_ptr_i8.to_ref());\n         let llvm_used = do \"llvm.used\".as_c_str |buf| {\n-            llvm::LLVMAddGlobal(cx.llmod, Type::array(t_ptr_i8, 1u), buf)\n+            llvm::LLVMAddGlobal(cx.llmod, Type::array(&t_ptr_i8, 1).to_ref(), buf)\n         };\n         lib::llvm::SetLinkage(llvm_used, lib::llvm::AppendingLinkage);\n         llvm::LLVMSetInitializer(llvm_used, C_array(t_ptr_i8, [llglobal]));"}, {"sha": "3e5a23cb18eb2854950a1f37b03b92012c01973e", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 32, "deletions": 23, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/81cf72c264efae4a16616ba6fc998ae862068d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81cf72c264efae4a16616ba6fc998ae862068d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=81cf72c264efae4a16616ba6fc998ae862068d8b", "patch": "@@ -13,12 +13,14 @@ use core::prelude::*;\n use lib::llvm::llvm;\n use lib::llvm::{CallConv, AtomicBinOp, AtomicOrdering, AsmDialect};\n use lib::llvm::{Opcode, IntPredicate, RealPredicate, False};\n-use lib::llvm::{ValueRef, Type, BasicBlockRef, BuilderRef, ModuleRef};\n+use lib::llvm::{ValueRef, BasicBlockRef, BuilderRef, ModuleRef};\n use lib;\n use middle::trans::common::*;\n use middle::trans::machine::llalign_of_min;\n use syntax::codemap::span;\n \n+use middle::trans::type_::Type;\n+\n use core::cast;\n use core::hashmap::HashMap;\n use core::libc::{c_uint, c_ulonglong, c_char};\n@@ -232,7 +234,7 @@ pub fn Unreachable(cx: block) {\n \n pub fn _Undef(val: ValueRef) -> ValueRef {\n     unsafe {\n-        return llvm::LLVMGetUndef(val_ty(val));\n+        return llvm::LLVMGetUndef(val_ty(val).to_ref());\n     }\n }\n \n@@ -504,15 +506,15 @@ pub fn ArrayMalloc(cx: block, Ty: Type, Val: ValueRef) -> ValueRef {\n \n pub fn Alloca(cx: block, Ty: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(Ty.to_ptr().to_ref()); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(Ty.ptr_to().to_ref()); }\n         count_insn(cx, \"alloca\");\n         return llvm::LLVMBuildAlloca(B(cx), Ty.to_ref(), noname());\n     }\n }\n \n pub fn ArrayAlloca(cx: block, Ty: Type, Val: ValueRef) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(Ty.to_ptr().to_ref()); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(Ty.ptr_to().to_ref()); }\n         count_insn(cx, \"arrayalloca\");\n         return llvm::LLVMBuildArrayAlloca(B(cx), Ty.to_ref(), Val, noname());\n     }\n@@ -531,9 +533,12 @@ pub fn Load(cx: block, PointerVal: ValueRef) -> ValueRef {\n         let ccx = cx.fcx.ccx;\n         if cx.unreachable {\n             let ty = val_ty(PointerVal);\n-            let eltty = if llvm::LLVMGetTypeKind(ty) == lib::llvm::Array {\n-                llvm::LLVMGetElementType(ty) } else { ccx.int_type };\n-            return llvm::LLVMGetUndef(eltty);\n+            let eltty = if ty.kind() == lib::llvm::Array {\n+                ty.element_type()\n+            } else {\n+                ccx.int_type\n+            };\n+            return llvm::LLVMGetUndef(eltty.to_ref());\n         }\n         count_insn(cx, \"load\");\n         return llvm::LLVMBuildLoad(B(cx), PointerVal, noname());\n@@ -544,7 +549,7 @@ pub fn AtomicLoad(cx: block, PointerVal: ValueRef, order: AtomicOrdering) -> Val\n     unsafe {\n         let ccx = cx.fcx.ccx;\n         if cx.unreachable {\n-            return llvm::LLVMGetUndef(ccx.int_type);\n+            return llvm::LLVMGetUndef(ccx.int_type.to_ref());\n         }\n         count_insn(cx, \"load.atomic\");\n         let align = llalign_of_min(ccx, ccx.int_type);\n@@ -639,15 +644,15 @@ pub fn StructGEP(cx: block, Pointer: ValueRef, Idx: uint) -> ValueRef {\n \n pub fn GlobalString(cx: block, _Str: *c_char) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(Type::i8p()); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(Type::i8p().to_ref()); }\n         count_insn(cx, \"globalstring\");\n         return llvm::LLVMBuildGlobalString(B(cx), _Str, noname());\n     }\n }\n \n pub fn GlobalStringPtr(cx: block, _Str: *c_char) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(Type::i8p()); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(Type::i8p().to_ref()); }\n         count_insn(cx, \"globalstringptr\");\n         return llvm::LLVMBuildGlobalStringPtr(B(cx), _Str, noname());\n     }\n@@ -841,7 +846,7 @@ pub fn Phi(cx: block, Ty: Type, vals: &[ValueRef], bbs: &[BasicBlockRef])\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Ty.to_ref()); }\n         assert_eq!(vals.len(), bbs.len());\n-        let phi = EmptyPhi(cx, Ty.to_ref());\n+        let phi = EmptyPhi(cx, Ty);\n         count_insn(cx, \"addincoming\");\n         llvm::LLVMAddIncoming(phi, vec::raw::to_ptr(vals),\n                               vec::raw::to_ptr(bbs),\n@@ -863,10 +868,13 @@ pub fn _UndefReturn(cx: block, Fn: ValueRef) -> ValueRef {\n     unsafe {\n         let ccx = cx.fcx.ccx;\n         let ty = val_ty(Fn);\n-        let retty = if llvm::LLVMGetTypeKind(ty) == lib::llvm::Integer {\n-            llvm::LLVMGetReturnType(ty) } else { ccx.int_type };\n-            count_insn(cx, \"\");\n-        return llvm::LLVMGetUndef(retty);\n+        let retty = if ty.kind() == lib::llvm::Integer {\n+            ty.return_type()\n+        } else {\n+            ccx.int_type\n+        };\n+        count_insn(cx, \"ret_undef\");\n+        return llvm::LLVMGetUndef(retty.to_ref());\n     }\n }\n \n@@ -887,9 +895,10 @@ pub fn add_comment(bcx: block, text: &str) {\n             let comment_text = ~\"# \" +\n                 sanitized.replace(\"\\n\", \"\\n\\t# \");\n             count_insn(bcx, \"inlineasm\");\n-            let asm = str::as_c_str(comment_text, |c| {\n-                llvm::LLVMConstInlineAsm(Type::func([], Type::void()), c, noname(), False, False)\n-            });\n+            let asm = do comment_text.as_c_str |c| {\n+                llvm::LLVMConstInlineAsm(Type::func([], &Type::void()).to_ref(),\n+                                         c, noname(), False, False)\n+            };\n             Call(bcx, asm, []);\n         }\n     }\n@@ -913,8 +922,8 @@ pub fn InlineAsmCall(cx: block, asm: *c_char, cons: *c_char,\n         };\n \n         debug!(\"Asm Output Type: %?\", cx.ccx().tn.type_to_str(output));\n-        let fty = Type::func(argtys, output);\n-        let v = llvm::LLVMInlineAsm(llfty.to_ref(), asm, cons, volatile, alignstack, dia as c_uint);\n+        let fty = Type::func(argtys, &output);\n+        let v = llvm::LLVMInlineAsm(fty.to_ref(), asm, cons, volatile, alignstack, dia as c_uint);\n \n         Call(cx, v, inputs)\n     }\n@@ -1005,9 +1014,9 @@ pub fn ShuffleVector(cx: block, V1: ValueRef, V2: ValueRef,\n pub fn VectorSplat(cx: block, NumElts: uint, EltVal: ValueRef) -> ValueRef {\n     unsafe {\n         let elt_ty = val_ty(EltVal);\n-        let Undef = llvm::LLVMGetUndef(Type::vector(elt_ty, NumElts).to_ref());\n+        let Undef = llvm::LLVMGetUndef(Type::vector(&elt_ty, NumElts as u64).to_ref());\n         let VecVal = InsertElement(cx, Undef, EltVal, C_i32(0));\n-        ShuffleVector(cx, VecVal, Undef, C_null(Type::vector(Type::i32().to_ref(), NumElts)))\n+        ShuffleVector(cx, VecVal, Undef, C_null(Type::vector(&Type::i32(), NumElts as u64)))\n     }\n }\n \n@@ -1049,7 +1058,7 @@ pub fn IsNotNull(cx: block, Val: ValueRef) -> ValueRef {\n pub fn PtrDiff(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     unsafe {\n         let ccx = cx.fcx.ccx;\n-        if cx.unreachable { return llvm::LLVMGetUndef(ccx.int_type); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(ccx.int_type.to_ref()); }\n         count_insn(cx, \"ptrdiff\");\n         return llvm::LLVMBuildPtrDiff(B(cx), LHS, RHS, noname());\n     }"}, {"sha": "dffa5a7f1ad07d43c4d51d4fb5990cad5c3d5bba", "filename": "src/librustc/middle/trans/cabi.rs", "status": "modified", "additions": 19, "deletions": 38, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/81cf72c264efae4a16616ba6fc998ae862068d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81cf72c264efae4a16616ba6fc998ae862068d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs?ref=81cf72c264efae4a16616ba6fc998ae862068d8b", "patch": "@@ -8,20 +8,19 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use lib::llvm::{llvm, TypeRef, ValueRef, Attribute, Void};\n+use lib::llvm::{llvm, ValueRef, Attribute, Void};\n use middle::trans::base::*;\n use middle::trans::build::*;\n use middle::trans::common::*;\n \n+use middle::trans::type_::Type;\n+\n use core::libc::c_uint;\n use core::option;\n use core::vec;\n \n pub trait ABIInfo {\n-    fn compute_info(&self,\n-                    atys: &[TypeRef],\n-                    rty: TypeRef,\n-                    ret_def: bool) -> FnType;\n+    fn compute_info(&self, atys: &[Type], rty: Type, ret_def: bool) -> FnType;\n }\n \n pub struct LLVMType {\n@@ -40,7 +39,7 @@ impl FnType {\n     pub fn decl_fn(&self, decl: &fn(fnty: Type) -> ValueRef) -> ValueRef {\n         let atys = vec::map(self.arg_tys, |t| t.ty);\n         let rty = self.ret_ty.ty;\n-        let fnty = Type::func(atys, rty);\n+        let fnty = Type::func(atys, &rty);\n         let llfn = decl(fnty);\n \n         for self.attrs.iter().enumerate().advance |(i, a)| {\n@@ -57,10 +56,7 @@ impl FnType {\n         return llfn;\n     }\n \n-    pub fn build_shim_args(&self,\n-                           bcx: block,\n-                           arg_tys: &[Type],\n-                           llargbundle: ValueRef)\n+    pub fn build_shim_args(&self, bcx: block, arg_tys: &[Type], llargbundle: ValueRef)\n                            -> ~[ValueRef] {\n         let mut atys: &[LLVMType] = self.arg_tys;\n         let mut attrs: &[option::Option<Attribute>] = self.attrs;\n@@ -80,7 +76,7 @@ impl FnType {\n         while i < n {\n             let llargval = if atys[i].cast {\n                 let arg_ptr = GEPi(bcx, llargbundle, [0u, i]);\n-                let arg_ptr = BitCast(bcx, arg_ptr, T_ptr(atys[i].ty));\n+                let arg_ptr = BitCast(bcx, arg_ptr, atys[i].ty.ptr_to());\n                 Load(bcx, arg_ptr)\n             } else if attrs[i].is_some() {\n                 GEPi(bcx, llargbundle, [0u, i])\n@@ -94,19 +90,14 @@ impl FnType {\n         return llargvals;\n     }\n \n-    pub fn build_shim_ret(&self,\n-                          bcx: block,\n-                          arg_tys: &[Type],\n-                          ret_def: bool,\n-                          llargbundle: ValueRef,\n-                          llretval: ValueRef) {\n+    pub fn build_shim_ret(&self, bcx: block, arg_tys: &[Type], ret_def: bool,\n+                          llargbundle: ValueRef, llretval: ValueRef) {\n+        for vec::eachi(self.attrs) |i, a| {\n         for self.attrs.iter().enumerate().advance |(i, a)| {\n             match *a {\n                 option::Some(attr) => {\n                     unsafe {\n-                        llvm::LLVMAddInstrAttribute(llretval,\n-                                                    (i + 1u) as c_uint,\n-                                                    attr as c_uint);\n+                        llvm::LLVMAddInstrAttribute(llretval, (i + 1u) as c_uint, attr as c_uint);\n                     }\n                 }\n                 _ => ()\n@@ -121,7 +112,7 @@ impl FnType {\n         // R* llretloc = *llretptr; /* (args->r) */\n         let llretloc = Load(bcx, llretptr);\n         if self.ret_ty.cast {\n-            let tmp_ptr = BitCast(bcx, llretloc, T_ptr(self.ret_ty.ty));\n+            let tmp_ptr = BitCast(bcx, llretloc, self.ret_ty.ty.ptr_to());\n             // *args->r = r;\n             Store(bcx, llretval, tmp_ptr);\n         } else {\n@@ -130,11 +121,8 @@ impl FnType {\n         };\n     }\n \n-    pub fn build_wrap_args(&self,\n-                           bcx: block,\n-                           ret_ty: Type,\n-                           llwrapfn: ValueRef,\n-                           llargbundle: ValueRef) {\n+    pub fn build_wrap_args(&self, bcx: block, ret_ty: Type,\n+                           llwrapfn: ValueRef, llargbundle: ValueRef) {\n         let mut atys: &[LLVMType] = self.arg_tys;\n         let mut attrs: &[option::Option<Attribute>] = self.attrs;\n         let mut j = 0u;\n@@ -159,7 +147,7 @@ impl FnType {\n                 store_inbounds(bcx, argval, llargbundle, [0u, i]);\n             } else if atys[i].cast {\n                 let argptr = GEPi(bcx, llargbundle, [0u, i]);\n-                let argptr = BitCast(bcx, argptr, T_ptr(atys[i].ty));\n+                let argptr = BitCast(bcx, argptr, atys[i].ty.ptr_to());\n                 Store(bcx, argval, argptr);\n             } else {\n                 store_inbounds(bcx, argval, llargbundle, [0u, i]);\n@@ -169,14 +157,9 @@ impl FnType {\n         store_inbounds(bcx, llretptr, llargbundle, [0u, n]);\n     }\n \n-    pub fn build_wrap_ret(&self,\n-                          bcx: block,\n-                          arg_tys: &[TypeRef],\n-                          llargbundle: ValueRef) {\n-        unsafe {\n-            if llvm::LLVMGetTypeKind(self.ret_ty.ty) == Void {\n-                return;\n-            }\n+    pub fn build_wrap_ret(&self, bcx: block, arg_tys: &[Type], llargbundle: ValueRef) {\n+        if self.ret_ty.ty.kind() == Void {\n+            return;\n         }\n \n         if bcx.fcx.llretptr.is_some() {\n@@ -187,9 +170,7 @@ impl FnType {\n             } else {\n                 Load(bcx, llretval)\n             };\n-            let llretptr = BitCast(bcx,\n-                                   bcx.fcx.llretptr.get(),\n-                                   self.ret_ty.ty.ptr_to());\n+            let llretptr = BitCast(bcx, bcx.fcx.llretptr.get(), self.ret_ty.ty.ptr_to());\n             Store(bcx, llretval, llretptr);\n         }\n     }"}, {"sha": "69896972ef0689e5f6ebb86f1395aabe1e0aef45", "filename": "src/librustc/middle/trans/cabi_arm.rs", "status": "modified", "additions": 45, "deletions": 44, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/81cf72c264efae4a16616ba6fc998ae862068d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81cf72c264efae4a16616ba6fc998ae862068d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs?ref=81cf72c264efae4a16616ba6fc998ae862068d8b", "patch": "@@ -9,11 +9,12 @@\n // except according to those terms.\n \n use lib::llvm::{llvm, Integer, Pointer, Float, Double, Struct, Array};\n-use lib::llvm::struct_tys;\n use lib::llvm::{Attribute, StructRetAttribute};\n use lib::llvm::True;\n use middle::trans::cabi::{ABIInfo, FnType, LLVMType};\n \n+use middle::trans::type_::Type;\n+\n use core::option::{Option, None, Some};\n use core::uint;\n \n@@ -27,58 +28,58 @@ fn align(off: uint, ty: Type) -> uint {\n }\n \n fn ty_align(ty: Type) -> uint {\n-    unsafe {\n-        match ty.kind() {\n-            Integer => {\n+    match ty.kind() {\n+        Integer => {\n+            unsafe {\n                 ((llvm::LLVMGetIntTypeWidth(ty.to_ref()) as uint) + 7) / 8\n             }\n-            Pointer => 4,\n-            Float => 4,\n-            Double => 8,\n-            Struct => {\n-                if ty.is_packed() {\n-                    1\n-                } else {\n-                    let str_tys = ty.field_types();\n-                    str_tys.iter().fold(1, |a, t| uint::max(a, ty_align(*t)))\n-                }\n-            }\n-            Array => {\n-                let elt = ty.element_type();\n-                ty_align(elt)\n+        }\n+        Pointer => 4,\n+        Float => 4,\n+        Double => 8,\n+        Struct => {\n+            if ty.is_packed() {\n+                1\n+            } else {\n+                let str_tys = ty.field_types();\n+                str_tys.iter().fold(1, |a, t| uint::max(a, ty_align(*t)))\n             }\n-            _ => fail!(\"ty_align: unhandled type\")\n         }\n+        Array => {\n+            let elt = ty.element_type();\n+            ty_align(elt)\n+        }\n+        _ => fail!(\"ty_align: unhandled type\")\n     }\n }\n \n fn ty_size(ty: Type) -> uint {\n-    unsafe {\n-        match ty.kind() {\n-            Integer => {\n+    match ty.kind() {\n+        Integer => {\n+            unsafe {\n                 ((llvm::LLVMGetIntTypeWidth(ty.to_ref()) as uint) + 7) / 8\n             }\n-            Pointer => 4,\n-            Float => 4,\n-            Double => 8,\n-            Struct => {\n-                if ty.is_packed() {\n-                    let str_tys = ty.field_types();\n-                    str_tys.iter().fold(0, |s, t| s + ty_size(*t))\n-                } else {\n-                    let str_tys = ty.field_types();\n-                    let size = str_tys.iter().fold(0, |s, t| align(s, *t) + ty_size(*t));\n-                    align(size, ty)\n-                }\n-            }\n-            Array => {\n-                let len = ty.array_length();\n-                let elt = ty.element_type();\n-                let eltsz = ty_size(elt);\n-                len * eltsz\n+        }\n+        Pointer => 4,\n+        Float => 4,\n+        Double => 8,\n+        Struct => {\n+            if ty.is_packed() {\n+                let str_tys = ty.field_types();\n+                str_tys.iter().fold(0, |s, t| s + ty_size(*t))\n+            } else {\n+                let str_tys = ty.field_types();\n+                let size = str_tys.iter().fold(0, |s, t| align(s, *t) + ty_size(*t));\n+                align(size, ty)\n             }\n-            _ => fail!(\"ty_size: unhandled type\")\n         }\n+        Array => {\n+            let len = ty.array_length();\n+            let elt = ty.element_type();\n+            let eltsz = ty_size(elt);\n+            len * eltsz\n+        }\n+        _ => fail!(\"ty_size: unhandled type\")\n     }\n }\n \n@@ -107,9 +108,9 @@ fn classify_arg_ty(ty: Type) -> (LLVMType, Option<Attribute>) {\n     let align = ty_align(ty);\n     let size = ty_size(ty);\n     let llty = if align <= 4 {\n-        Type::array(Type::i32(), (size + 3) / 4)\n+        Type::array(&Type::i32(), (size + 3) / 4 as u64)\n     } else {\n-        Type::array(Type::i64(), (size + 7) / 8)\n+        Type::array(&Type::i64(), (size + 7) / 8 as u64)\n     };\n     (LLVMType { cast: true, ty: llty }, None)\n }\n@@ -122,7 +123,7 @@ fn is_reg_ty(ty: Type) -> bool {\n             | Float\n             | Double => true,\n             _ => false\n-        };\n+        }\n     }\n }\n "}, {"sha": "27ac267895b3701e6283308dc32eee7d17de389f", "filename": "src/librustc/middle/trans/cabi_mips.rs", "status": "modified", "additions": 51, "deletions": 50, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/81cf72c264efae4a16616ba6fc998ae862068d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81cf72c264efae4a16616ba6fc998ae862068d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs?ref=81cf72c264efae4a16616ba6fc998ae862068d8b", "patch": "@@ -15,13 +15,14 @@ use core::ptr;\n use core::uint;\n use core::vec;\n use lib::llvm::{llvm, Integer, Pointer, Float, Double, Struct, Array};\n-use lib::llvm::struct_tys;\n use lib::llvm::{Attribute, StructRetAttribute};\n use lib::llvm::True;\n use middle::trans::context::task_llcx;\n use middle::trans::common::*;\n use middle::trans::cabi::*;\n \n+use middle::trans::type_::Type;\n+\n fn align_up_to(off: uint, a: uint) -> uint {\n     return (off + a - 1u) / a * a;\n }\n@@ -32,58 +33,58 @@ fn align(off: uint, ty: Type) -> uint {\n }\n \n fn ty_align(ty: Type) -> uint {\n-    unsafe {\n-        return match llvm::LLVMGetTypeKind(ty) {\n-            Integer => {\n-                ((llvm::LLVMGetIntTypeWidth(ty) as uint) + 7) / 8\n-            }\n-            Pointer => 4,\n-            Float => 4,\n-            Double => 8,\n-            Struct => {\n-              if ty.is_packed() {\n-                1\n-              } else {\n-                let str_tys = struct_tys(ty);\n-                str_tys.iter().fold(1, |a, t| uint::max(a, ty_align(*t)))\n-              }\n-            }\n-            Array => {\n-                let elt = llvm::LLVMGetElementType(ty);\n-                ty_align(elt)\n+    match ty.kind() {\n+        Integer => {\n+            unsafe {\n+                ((llvm::LLVMGetIntTypeWidth(ty.to_ref()) as uint) + 7) / 8\n             }\n-            _ => fail!(\"ty_size: unhandled type\")\n-        };\n+        }\n+        Pointer => 4,\n+        Float => 4,\n+        Double => 8,\n+        Struct => {\n+          if ty.is_packed() {\n+            1\n+          } else {\n+            let str_tys = ty.field_types();\n+            str_tys.iter().fold(1, |a, t| uint::max(a, ty_align(*t)))\n+          }\n+        }\n+        Array => {\n+            let elt = ty.element_type();\n+            ty_align(elt)\n+        }\n+        _ => fail!(\"ty_size: unhandled type\")\n     }\n }\n \n-fn ty_size(ty: TypeRef) -> uint {\n-    unsafe {\n-        return match llvm::LLVMGetTypeKind(ty) {\n-            Integer => {\n-                ((llvm::LLVMGetIntTypeWidth(ty) as uint) + 7) / 8\n+fn ty_size(ty: Type) -> uint {\n+    match ty.kind() {\n+        Integer => {\n+            unsafe {\n+                ((llvm::LLVMGetIntTypeWidth(ty.to_ref()) as uint) + 7) / 8\n             }\n-            Pointer => 4,\n-            Float => 4,\n-            Double => 8,\n-            Struct => {\n-                if llvm::LLVMIsPackedStruct(ty) == True {\n-                    let str_tys = struct_tys(ty);\n-                    str_tys.iter().fold(0, |s, t| s + ty_size(*t))\n-                } else {\n-                    let str_tys = ty.field_types();\n-                    let size = str_tys.iter().fold(0, |s, t| align(s, *t) + ty_size(*t));\n-                    align(size, ty)\n-                }\n-            }\n-            Array => {\n-                let len = ty.array_length();\n-                let elt = ty.element_type();\n-                let eltsz = ty_size(elt);\n-                len * eltsz\n+        }\n+        Pointer => 4,\n+        Float => 4,\n+        Double => 8,\n+        Struct => {\n+            if ty.is_packed() {\n+                let str_tys = ty.field_types();\n+                str_tys.iter().fold(0, |s, t| s + ty_size(*t))\n+            } else {\n+                let str_tys = ty.field_types();\n+                let size = str_tys.iter().fold(0, |s, t| align(s, *t) + ty_size(*t));\n+                align(size, ty)\n             }\n-            _ => fail!(\"ty_size: unhandled type\")\n-        };\n+        }\n+        Array => {\n+            let len = ty.array_length();\n+            let elt = ty.element_type();\n+            let eltsz = ty_size(elt);\n+            len * eltsz\n+        }\n+        _ => fail!(\"ty_size: unhandled type\")\n     }\n }\n \n@@ -120,7 +121,7 @@ fn classify_arg_ty(ty: Type, offset: &mut uint) -> (LLVMType, Option<Attribute>)\n     };\n }\n \n-fn is_reg_ty(ty: TypeRef) -> bool {\n+fn is_reg_ty(ty: Type) -> bool {\n     unsafe {\n         return match ty.kind() {\n             Integer\n@@ -153,11 +154,11 @@ fn coerce_to_int(size: uint) -> ~[Type] {\n     let r = size % 32;\n     if r > 0 {\n         unsafe {\n-            Type::from_ref(args.push(llvm::LLVMIntTypeInContext(task_llcx(), r as c_uint)))\n+            args.push(Type::from_ref(llvm::LLVMIntTypeInContext(task_llcx(), r as c_uint)));\n         }\n     }\n \n-    return args;\n+    args\n }\n \n fn struct_ty(ty: Type,"}, {"sha": "bdfe0e3d77daedcdb5bfee531024398551491ce1", "filename": "src/librustc/middle/trans/cabi_x86.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81cf72c264efae4a16616ba6fc998ae862068d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81cf72c264efae4a16616ba6fc998ae862068d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs?ref=81cf72c264efae4a16616ba6fc998ae862068d8b", "patch": "@@ -17,6 +17,8 @@ use super::cabi::*;\n use super::common::*;\n use super::machine::*;\n \n+use middle::trans::type_::Type;\n+\n struct X86_ABIInfo {\n     ccx: @mut CrateContext\n }"}, {"sha": "01ec4a90cb08d408425c56cd3c4161da3369fb18", "filename": "src/librustc/middle/trans/cabi_x86_64.rs", "status": "modified", "additions": 94, "deletions": 84, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/81cf72c264efae4a16616ba6fc998ae862068d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81cf72c264efae4a16616ba6fc998ae862068d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs?ref=81cf72c264efae4a16616ba6fc998ae862068d8b", "patch": "@@ -11,14 +11,15 @@\n // The classification code for the x86_64 ABI is taken from the clay language\n // https://github.com/jckarter/clay/blob/master/compiler/src/externals.cpp\n \n-use lib::llvm::{llvm, TypeRef, Integer, Pointer, Float, Double};\n+use lib::llvm::{llvm, Integer, Pointer, Float, Double};\n use lib::llvm::{Struct, Array, Attribute};\n use lib::llvm::{StructRetAttribute, ByValAttribute};\n-use lib::llvm::struct_tys;\n use lib::llvm::True;\n use middle::trans::common::*;\n use middle::trans::cabi::*;\n \n+use middle::trans::type_::Type;\n+\n use core::libc::c_uint;\n use core::option;\n use core::option::Option;\n@@ -28,7 +29,7 @@ use core::vec;\n #[deriving(Eq)]\n enum RegClass {\n     NoClass,\n-    Integer,\n+    Int,\n     SSEFs,\n     SSEFv,\n     SSEDs,\n@@ -43,7 +44,7 @@ enum RegClass {\n \n impl Type {\n     fn is_reg_ty(&self) -> bool {\n-        match ty.kind() {\n+        match self.kind() {\n             Integer | Pointer | Float | Double => true,\n             _ => false\n         }\n@@ -59,6 +60,11 @@ impl RegClass {\n     }\n }\n \n+trait ClassList {\n+    fn is_pass_byval(&self) -> bool;\n+    fn is_ret_bysret(&self) -> bool;\n+}\n+\n impl<'self> ClassList for &'self [RegClass] {\n     fn is_pass_byval(&self) -> bool {\n         if self.len() == 0 { return false; }\n@@ -83,64 +89,64 @@ fn classify_ty(ty: Type) -> ~[RegClass] {\n     }\n \n     fn ty_align(ty: Type) -> uint {\n-        unsafe {\n-            match ty.kind() {\n-                Integer => {\n+        match ty.kind() {\n+            Integer => {\n+                unsafe {\n                     ((llvm::LLVMGetIntTypeWidth(ty.to_ref()) as uint) + 7) / 8\n                 }\n-                Pointer => 8,\n-                Float => 4,\n-                Double => 8,\n-                Struct => {\n-                  if ty.is_packed() {\n-                    1\n-                  } else {\n-                    let str_tys = ty.field_types();\n-                    str_tys.iter().fold(1, |a, t| uint::max(a, ty_align(*t)))\n-                  }\n-                }\n-                Array => {\n-                    let elt = ty.element_type();\n-                    ty_align(elt)\n-                }\n-                _ => fail!(\"ty_size: unhandled type\")\n-            };\n+            }\n+            Pointer => 8,\n+            Float => 4,\n+            Double => 8,\n+            Struct => {\n+              if ty.is_packed() {\n+                1\n+              } else {\n+                let str_tys = ty.field_types();\n+                str_tys.iter().fold(1, |a, t| uint::max(a, ty_align(*t)))\n+              }\n+            }\n+            Array => {\n+                let elt = ty.element_type();\n+                ty_align(elt)\n+            }\n+            _ => fail!(\"ty_size: unhandled type\")\n         }\n     }\n \n-    fn ty_size(ty: TypeRef) -> uint {\n-        unsafe {\n-            match ty.kind() {\n-                Integer => {\n-                    ((llvm::LLVMGetIntTypeWidth(ty) as uint) + 7) / 8\n-                }\n-                Pointer => 8,\n-                Float => 4,\n-                Double => 8,\n-                Struct => {\n-                    if ty.is_packed() {\n-                        let str_tys = ty.field_types();\n-                        str_tys.iter().fold(0, |s, t| s + ty_size(*t))\n-                    } else {\n-                        let str_tys = ty.field_types();\n-                        let size = str_tys.iter().fold(0, |s, t| align(s, *t) + ty_size(*t));\n-                        align(size, ty)\n-                    }\n+    fn ty_size(ty: Type) -> uint {\n+        match ty.kind() {\n+            Integer => {\n+                unsafe {\n+                    ((llvm::LLVMGetIntTypeWidth(ty.to_ref()) as uint) + 7) / 8\n                 }\n-                Array => {\n-                    let len = ty.array_length();\n-                    let elt = ty.element_type();\n-                    let eltsz = ty_size(elt);\n-                    len * eltsz\n+            }\n+            Pointer => 8,\n+            Float => 4,\n+            Double => 8,\n+            Struct => {\n+                if ty.is_packed() {\n+                    let str_tys = ty.field_types();\n+                    str_tys.iter().fold(0, |s, t| s + ty_size(*t))\n+                } else {\n+                    let str_tys = ty.field_types();\n+                    let size = str_tys.iter().fold(0, |s, t| align(s, *t) + ty_size(*t));\n+                    align(size, ty)\n                 }\n-                _ => fail!(\"ty_size: unhandled type\")\n             }\n+            Array => {\n+                let len = ty.array_length();\n+                let elt = ty.element_type();\n+                let eltsz = ty_size(elt);\n+                len * eltsz\n+            }\n+            _ => fail!(\"ty_size: unhandled type\")\n         }\n     }\n \n     fn all_mem(cls: &mut [RegClass]) {\n         for uint::range(0, cls.len()) |i| {\n-            cls[i] = memory_class;\n+            cls[i] = Memory;\n         }\n     }\n \n@@ -149,21 +155,21 @@ fn classify_ty(ty: Type) -> ~[RegClass] {\n              newv: RegClass) {\n         if cls[i] == newv {\n             return;\n-        } else if cls[i] == no_class {\n+        } else if cls[i] == NoClass {\n             cls[i] = newv;\n-        } else if newv == no_class {\n+        } else if newv == NoClass {\n             return;\n-        } else if cls[i] == memory_class || newv == memory_class {\n-            cls[i] = memory_class;\n-        } else if cls[i] == integer_class || newv == integer_class {\n-            cls[i] = integer_class;\n-        } else if cls[i] == x87_class ||\n-                  cls[i] == x87up_class ||\n-                  cls[i] == complex_x87_class ||\n-                  newv == x87_class ||\n-                  newv == x87up_class ||\n-                  newv == complex_x87_class {\n-            cls[i] = memory_class;\n+        } else if cls[i] == Memory || newv == Memory {\n+            cls[i] = Memory;\n+        } else if cls[i] == Int || newv == Int {\n+            cls[i] = Int;\n+        } else if cls[i] == X87 ||\n+                  cls[i] == X87Up ||\n+                  cls[i] == ComplexX87 ||\n+                  newv == X87 ||\n+                  newv == X87Up ||\n+                  newv == ComplexX87 {\n+            cls[i] = Memory;\n         } else {\n             cls[i] = newv;\n         }\n@@ -192,7 +198,7 @@ fn classify_ty(ty: Type) -> ~[RegClass] {\n                 let mut i = off / 8u;\n                 let e = (off + t_size + 7u) / 8u;\n                 while i < e {\n-                    unify(cls, ix + i, memory_class);\n+                    unify(cls, ix + i, Memory);\n                     i += 1u;\n                 }\n                 return;\n@@ -201,17 +207,17 @@ fn classify_ty(ty: Type) -> ~[RegClass] {\n             match ty.kind() {\n                 Integer |\n                 Pointer => {\n-                    unify(cls, ix + off / 8u, integer_class);\n+                    unify(cls, ix + off / 8u, Int);\n                 }\n                 Float => {\n                     if off % 8u == 4u {\n-                        unify(cls, ix + off / 8u, sse_fv_class);\n+                        unify(cls, ix + off / 8u, SSEFv);\n                     } else {\n-                        unify(cls, ix + off / 8u, sse_fs_class);\n+                        unify(cls, ix + off / 8u, SSEFs);\n                     }\n                 }\n                 Double => {\n-                    unify(cls, ix + off / 8u, sse_ds_class);\n+                    unify(cls, ix + off / 8u, SSEDs);\n                 }\n                 Struct => {\n                     classify_struct(ty.field_types(), cls, ix, off);\n@@ -242,7 +248,7 @@ fn classify_ty(ty: Type) -> ~[RegClass] {\n                 if cls[i].is_sse() {\n                     i += 1u;\n                     while i < e {\n-                        if cls[i] != sseup_class {\n+                        if cls[i] != SSEUp {\n                             all_mem(cls);\n                             return;\n                         }\n@@ -254,24 +260,24 @@ fn classify_ty(ty: Type) -> ~[RegClass] {\n                 }\n             } else {\n                 while i < e {\n-                    if cls[i] == memory_class {\n+                    if cls[i] == Memory {\n                         all_mem(cls);\n                         return;\n                     }\n-                    if cls[i] == x87up_class {\n+                    if cls[i] == X87Up {\n                         // for darwin\n-                        // cls[i] = sse_ds_class;\n+                        // cls[i] = SSEDs;\n                         all_mem(cls);\n                         return;\n                     }\n-                    if cls[i] == sseup_class {\n-                        cls[i] = sse_int_class;\n+                    if cls[i] == SSEUp {\n+                        cls[i] = SSEInt;\n                     } else if cls[i].is_sse() {\n                         i += 1;\n-                        while i != e && cls[i] == sseup_class { i += 1u; }\n-                    } else if cls[i] == x87_class {\n+                        while i != e && cls[i] == SSEUp { i += 1u; }\n+                    } else if cls[i] == X87 {\n                         i += 1;\n-                        while i != e && cls[i] == x87up_class { i += 1u; }\n+                        while i != e && cls[i] == X87Up { i += 1u; }\n                     } else {\n                         i += 1;\n                     }\n@@ -281,7 +287,7 @@ fn classify_ty(ty: Type) -> ~[RegClass] {\n     }\n \n     let words = (ty_size(ty) + 7) / 8;\n-    let mut cls = vec::from_elem(words, no_class);\n+    let mut cls = vec::from_elem(words, NoClass);\n     if words > 4 {\n         all_mem(cls);\n         let cls = cls;\n@@ -296,7 +302,7 @@ fn llreg_ty(cls: &[RegClass]) -> Type {\n     fn llvec_len(cls: &[RegClass]) -> uint {\n         let mut len = 1u;\n         for cls.each |c| {\n-            if *c != sseup_class {\n+            if *c != SSEUp {\n                 break;\n             }\n             len += 1u;\n@@ -310,20 +316,20 @@ fn llreg_ty(cls: &[RegClass]) -> Type {\n         let e = cls.len();\n         while i < e {\n             match cls[i] {\n-                integer_class => {\n+                Int => {\n                     tys.push(Type::i64());\n                 }\n-                sse_fv_class => {\n+                SSEFv => {\n                     let vec_len = llvec_len(vec::tailn(cls, i + 1u)) * 2u;\n-                    let vec_ty = Type::vector(Type::f32(), vec_len);\n+                    let vec_ty = Type::vector(&Type::f32(), vec_len as u64);\n                     tys.push(vec_ty);\n                     i += vec_len;\n                     loop;\n                 }\n-                sse_fs_class => {\n+                SSEFs => {\n                     tys.push(Type::f32());\n                 }\n-                sse_ds_class => {\n+                SSEDs => {\n                     tys.push(Type::f64());\n                 }\n                 _ => fail!(\"llregtype: unhandled class\")\n@@ -341,15 +347,19 @@ fn x86_64_tys(atys: &[Type],\n     fn x86_64_ty(ty: Type,\n                  is_mem_cls: &fn(cls: &[RegClass]) -> bool,\n                  attr: Attribute) -> (LLVMType, Option<Attribute>) {\n+\n         let (cast, attr, ty) = if !ty.is_reg_ty() {\n             let cls = classify_ty(ty);\n             if is_mem_cls(cls) {\n                 (false, option::Some(attr), ty.ptr_to())\n             } else {\n                 (true, option::None, llreg_ty(cls))\n             }\n+        } else {\n+            (false, option::None, ty)\n         };\n-        return (LLVMType { cast: cast, ty: ty }, attr);\n+\n+        (LLVMType { cast: cast, ty: ty }, attr)\n     }\n \n     let mut arg_tys = ~[];"}, {"sha": "c74a2320b5b9890ccd2250c30c2cd300ec8b1d03", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/81cf72c264efae4a16616ba6fc998ae862068d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81cf72c264efae4a16616ba6fc998ae862068d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=81cf72c264efae4a16616ba6fc998ae862068d8b", "patch": "@@ -45,6 +45,8 @@ use middle::typeck;\n use middle::typeck::coherence::make_substs_for_receiver_types;\n use util::ppaux::Repr;\n \n+use middle::trans::type_::Type;\n+\n use core::vec;\n use syntax::ast;\n use syntax::ast_map;\n@@ -526,7 +528,7 @@ pub fn trans_call_inner(in_cx: block,\n         let (llfn, llenv) = unsafe {\n             match callee.data {\n                 Fn(d) => {\n-                    (d.llfn, llvm::LLVMGetUndef(Type::opaque_box(ccx).ptr_to()))\n+                    (d.llfn, llvm::LLVMGetUndef(Type::opaque_box(ccx).ptr_to().to_ref()))\n                 }\n                 Method(d) => {\n                     // Weird but true: we pass self in the *environment* slot!\n@@ -653,7 +655,7 @@ pub fn trans_ret_slot(bcx: block, fn_ty: ty::t, dest: expr::Dest)\n         expr::Ignore => {\n             if ty::type_is_nil(retty) {\n                 unsafe {\n-                    llvm::LLVMGetUndef(Type::nil().ptr_to())\n+                    llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref())\n                 }\n             } else {\n                 alloc_ty(bcx, retty)\n@@ -777,7 +779,7 @@ pub fn trans_arg_expr(bcx: block,\n         // to have type lldestty (the callee's expected type).\n         let llformal_arg_ty = type_of::type_of(ccx, formal_arg_ty);\n         unsafe {\n-            val = llvm::LLVMGetUndef(llformal_arg_ty);\n+            val = llvm::LLVMGetUndef(llformal_arg_ty.to_ref());\n         }\n     } else {\n         // FIXME(#3548) use the adjustments table"}, {"sha": "7d7c024640ab58310292779e88dea7b042757c7f", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81cf72c264efae4a16616ba6fc998ae862068d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81cf72c264efae4a16616ba6fc998ae862068d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=81cf72c264efae4a16616ba6fc998ae862068d8b", "patch": "@@ -26,6 +26,8 @@ use middle::trans::type_of::*;\n use middle::ty;\n use util::ppaux::ty_to_str;\n \n+use middle::trans::type_::Type;\n+\n use core::str;\n use core::vec;\n use syntax::ast;"}, {"sha": "3f9f39ac852d4841ad3d0739598a643960285003", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 19, "deletions": 373, "changes": 392, "blob_url": "https://github.com/rust-lang/rust/blob/81cf72c264efae4a16616ba6fc998ae862068d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81cf72c264efae4a16616ba6fc998ae862068d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=81cf72c264efae4a16616ba6fc998ae862068d8b", "patch": "@@ -31,6 +31,8 @@ use middle::typeck;\n use middle::borrowck::root_map_key;\n use util::ppaux::{Repr};\n \n+use middle::trans::type_::Type;\n+\n use core::cast::transmute;\n use core::cast;\n use core::hashmap::{HashMap};\n@@ -58,29 +60,11 @@ pub fn new_namegen() -> namegen {\n     f\n }\n \n-pub type addrspace = c_uint;\n-\n-// Address spaces communicate to LLVM which destructors need to run for\n-// specific types.\n-//    0 is ignored by the GC, and is used for all non-GC'd pointers.\n-//    1 is for opaque GC'd boxes.\n-//    >= 2 are for specific types (e.g. resources).\n-pub static default_addrspace: addrspace = 0;\n-pub static gc_box_addrspace: addrspace = 1;\n-\n-pub type addrspace_gen = @fn() -> addrspace;\n-pub fn new_addrspace_gen() -> addrspace_gen {\n-    let i = @mut 1;\n-    let result: addrspace_gen = || { *i += 1; *i };\n-    result\n-}\n-\n pub struct tydesc_info {\n     ty: ty::t,\n     tydesc: ValueRef,\n     size: ValueRef,\n     align: ValueRef,\n-    addrspace: addrspace,\n     take_glue: Option<ValueRef>,\n     drop_glue: Option<ValueRef>,\n     free_glue: Option<ValueRef>,\n@@ -345,39 +329,14 @@ pub fn cleanup_type(cx: ty::ctxt, ty: ty::t) -> cleantype {\n     }\n }\n \n-// This is not the same as datum::Datum::root(), which is used to keep copies\n-// of @ values live for as long as a borrowed pointer to the interior exists.\n-// In the new GC, we can identify immediates on the stack without difficulty,\n-// but have trouble knowing where non-immediates are on the stack. For\n-// non-immediates, we must add an additional level of indirection, which\n-// allows us to alloca a pointer with the right addrspace.\n-pub fn root_for_cleanup(bcx: block, v: ValueRef, t: ty::t)\n-    -> (ValueRef, bool) {\n-    let ccx = bcx.ccx();\n-\n-    let addrspace = base::get_tydesc(ccx, t).addrspace;\n-    if addrspace > gc_box_addrspace {\n-        let llty = type_of::type_of_rooted(ccx, t);\n-        let root = base::alloca(bcx, llty);\n-        build::Store(bcx, build::PointerCast(bcx, v, llty), root);\n-        (root, true)\n-    } else {\n-        (v, false)\n-    }\n-}\n-\n pub fn add_clean(bcx: block, val: ValueRef, t: ty::t) {\n     if !ty::type_needs_drop(bcx.tcx(), t) { return; }\n-    debug!(\"add_clean(%s, %s, %s)\",\n-           bcx.to_str(),\n-           bcx.val_to_str(val),\n-           t.repr(bcx.tcx()));\n-    let (root, rooted) = root_for_cleanup(bcx, val, t);\n+\n+    debug!(\"add_clean(%s, %s, %s)\", bcx.to_str(), bcx.val_to_str(val), t.repr(bcx.tcx()));\n+\n     let cleanup_type = cleanup_type(bcx.tcx(), t);\n     do in_scope_cx(bcx) |scope_info| {\n-        scope_info.cleanups.push(\n-            clean(|a| glue::drop_ty_root(a, root, rooted, t),\n-                  cleanup_type));\n+        scope_info.cleanups.push(clean(|a| glue::drop_ty(a, val, t), cleanup_type));\n         grow_scope_clean(scope_info);\n     }\n }\n@@ -400,12 +359,9 @@ pub fn add_clean_temp_mem(bcx: block, val: ValueRef, t: ty::t) {\n     debug!(\"add_clean_temp_mem(%s, %s, %s)\",\n            bcx.to_str(), bcx.val_to_str(val),\n            t.repr(bcx.tcx()));\n-    let (root, rooted) = root_for_cleanup(bcx, val, t);\n     let cleanup_type = cleanup_type(bcx.tcx(), t);\n     do in_scope_cx(bcx) |scope_info| {\n-        scope_info.cleanups.push(\n-            clean_temp(val, |a| glue::drop_ty_root(a, root, rooted, t),\n-                       cleanup_type));\n+        scope_info.cleanups.push(clean_temp(val, |a| glue::drop_ty(a, val, t), cleanup_type));\n         grow_scope_clean(scope_info);\n     }\n }\n@@ -431,12 +387,8 @@ pub fn add_clean_return_to_mut(bcx: block,\n         scope_info.cleanups.push(\n             clean_temp(\n                 frozen_val_ref,\n-                |bcx| write_guard::return_to_mut(bcx,\n-                                                 root_key,\n-                                                 frozen_val_ref,\n-                                                 bits_val_ref,\n-                                                 filename_val,\n-                                                 line_val),\n+                |bcx| write_guard::return_to_mut(bcx, root_key, frozen_val_ref, bits_val_ref,\n+                                                 filename_val, line_val),\n                 normal_exit_only));\n         grow_scope_clean(scope_info);\n     }\n@@ -621,9 +573,9 @@ impl Result {\n     }\n }\n \n-pub fn val_ty(v: ValueRef) -> TypeRef {\n+pub fn val_ty(v: ValueRef) -> Type {\n     unsafe {\n-        return llvm::LLVMTypeOf(v);\n+        Type::from_ref(llvm::LLVMTypeOf(v))\n     }\n }\n \n@@ -706,313 +658,6 @@ impl block_ {\n     }\n }\n \n-/*\n-// LLVM type constructors.\n-pub fn T_void() -> TypeRef {\n-    unsafe { return llvm::LLVMVoidTypeInContext(base::task_llcx()); }\n-}\n-\n-pub fn T_nil() -> TypeRef {\n-    return T_struct([], false)\n-}\n-\n-pub fn T_metadata() -> TypeRef {\n-    unsafe { return llvm::LLVMMetadataTypeInContext(base::task_llcx()); }\n-}\n-\n-pub fn T_i1() -> TypeRef {\n-    unsafe { return llvm::LLVMInt1TypeInContext(base::task_llcx()); }\n-}\n-\n-pub fn T_i8() -> TypeRef {\n-    unsafe { return llvm::LLVMInt8TypeInContext(base::task_llcx()); }\n-}\n-\n-pub fn T_i16() -> TypeRef {\n-    unsafe { return llvm::LLVMInt16TypeInContext(base::task_llcx()); }\n-}\n-\n-pub fn T_i32() -> TypeRef {\n-    unsafe { return llvm::LLVMInt32TypeInContext(base::task_llcx()); }\n-}\n-\n-pub fn T_i64() -> TypeRef {\n-    unsafe { return llvm::LLVMInt64TypeInContext(base::task_llcx()); }\n-}\n-\n-pub fn T_f32() -> TypeRef {\n-    unsafe { return llvm::LLVMFloatTypeInContext(base::task_llcx()); }\n-}\n-\n-pub fn T_f64() -> TypeRef {\n-    unsafe { return llvm::LLVMDoubleTypeInContext(base::task_llcx()); }\n-}\n-\n-pub fn T_bool() -> TypeRef { return T_i8(); }\n-\n-pub fn T_int(targ_cfg: &session::config) -> TypeRef {\n-    return match targ_cfg.arch {\n-        X86 => T_i32(),\n-        X86_64 => T_i64(),\n-        Arm => T_i32(),\n-        Mips => T_i32()\n-    };\n-}\n-\n-pub fn T_int_ty(cx: &CrateContext, t: ast::int_ty) -> TypeRef {\n-    match t {\n-      ast::ty_i => cx.int_type,\n-      ast::ty_char => T_char(),\n-      ast::ty_i8 => T_i8(),\n-      ast::ty_i16 => T_i16(),\n-      ast::ty_i32 => T_i32(),\n-      ast::ty_i64 => T_i64()\n-    }\n-}\n-\n-pub fn T_uint_ty(cx: &CrateContext, t: ast::uint_ty) -> TypeRef {\n-    match t {\n-      ast::ty_u => cx.int_type,\n-      ast::ty_u8 => T_i8(),\n-      ast::ty_u16 => T_i16(),\n-      ast::ty_u32 => T_i32(),\n-      ast::ty_u64 => T_i64()\n-    }\n-}\n-\n-pub fn T_float_ty(cx: &CrateContext, t: ast::float_ty) -> TypeRef {\n-    match t {\n-      ast::ty_f => cx.float_type,\n-      ast::ty_f32 => T_f32(),\n-      ast::ty_f64 => T_f64()\n-    }\n-}\n-\n-pub fn T_float(targ_cfg: &session::config) -> TypeRef {\n-    return match targ_cfg.arch {\n-        X86 => T_f64(),\n-        X86_64 => T_f64(),\n-        Arm => T_f64(),\n-        Mips => T_f64()\n-    };\n-}\n-\n-pub fn T_char() -> TypeRef { return T_i32(); }\n-\n-pub fn T_size_t(targ_cfg: &session::config) -> TypeRef {\n-    return T_int(targ_cfg);\n-}\n-\n-pub fn T_fn(inputs: &[TypeRef], output: TypeRef) -> TypeRef {\n-    unsafe {\n-        return llvm::LLVMFunctionType(output, to_ptr(inputs),\n-                                      inputs.len() as c_uint,\n-                                      False);\n-    }\n-}\n-\n-pub fn T_fn_pair(cx: &CrateContext, tfn: TypeRef) -> TypeRef {\n-    return T_struct([T_ptr(tfn), T_opaque_cbox_ptr(cx)], false);\n-}\n-\n-pub fn T_ptr(t: TypeRef) -> TypeRef {\n-    unsafe {\n-        return llvm::LLVMPointerType(t, default_addrspace);\n-    }\n-}\n-\n-pub fn T_root(t: TypeRef, addrspace: addrspace) -> TypeRef {\n-    unsafe {\n-        return llvm::LLVMPointerType(t, addrspace);\n-    }\n-}\n-\n-pub fn T_struct(elts: &[TypeRef], packed: bool) -> TypeRef {\n-    unsafe {\n-        return llvm::LLVMStructTypeInContext(base::task_llcx(),\n-                                             to_ptr(elts),\n-                                             elts.len() as c_uint,\n-                                             packed as Bool);\n-    }\n-}\n-\n-pub fn T_named_struct(name: &str) -> TypeRef {\n-    unsafe {\n-        return str::as_c_str(name, |buf| {\n-            llvm::LLVMStructCreateNamed(base::task_llcx(), buf)\n-        });\n-    }\n-}\n-\n-pub fn set_struct_body(t: TypeRef, elts: &[TypeRef], packed: bool) {\n-    unsafe {\n-        llvm::LLVMStructSetBody(t,\n-                                to_ptr(elts),\n-                                elts.len() as c_uint,\n-                                packed as Bool);\n-    }\n-}\n-\n-pub fn T_empty_struct() -> TypeRef { return T_struct([], false); }\n-\n-// A vtable is, in reality, a vtable pointer followed by zero or more pointers\n-// to tydescs and other vtables that it closes over. But the types and number\n-// of those are rarely known to the code that needs to manipulate them, so\n-// they are described by this opaque type.\n-pub fn T_vtable() -> TypeRef { T_array(T_ptr(T_i8()), 1u) }\n-\n-pub fn T_tydesc_field(cx: &CrateContext, field: uint) -> TypeRef {\n-    // Bit of a kludge: pick the fn typeref out of the tydesc..\n-\n-    unsafe {\n-        let mut tydesc_elts: ~[TypeRef] =\n-            vec::from_elem::<TypeRef>(abi::n_tydesc_fields,\n-                                     T_nil());\n-        llvm::LLVMGetStructElementTypes(cx.tydesc_type, &mut tydesc_elts[0]);\n-        let t = llvm::LLVMGetElementType(tydesc_elts[field]);\n-        return t;\n-    }\n-}\n-\n-pub fn T_generic_glue_fn(cx: &mut CrateContext) -> TypeRef {\n-    let s = @\"glue_fn\";\n-    match cx.tn.find_type(s) {\n-      Some(t) => return t,\n-      _ => ()\n-    }\n-    let t = T_tydesc_field(cx, abi::tydesc_field_drop_glue);\n-    cx.tn.associate_type(s, t);\n-    return t;\n-}\n-\n-pub fn T_tydesc(targ_cfg: @session::config) -> TypeRef {\n-    let tydesc = T_named_struct(\"tydesc\");\n-    let tydescpp = T_ptr(T_ptr(tydesc));\n-    let pvoid = T_ptr(T_i8());\n-    let glue_fn_ty =\n-        T_ptr(T_fn([T_ptr(T_nil()), tydescpp, pvoid], T_void()));\n-\n-    let int_type = T_int(targ_cfg);\n-    let elems =\n-        ~[int_type, int_type,\n-          glue_fn_ty, glue_fn_ty, glue_fn_ty, glue_fn_ty,\n-          T_ptr(T_i8()), T_ptr(T_i8())];\n-    set_struct_body(tydesc, elems, false);\n-    return tydesc;\n-}\n-\n-pub fn T_array(t: TypeRef, n: uint) -> TypeRef {\n-    unsafe {\n-        return llvm::LLVMArrayType(t, n as c_uint);\n-    }\n-}\n-\n-pub fn T_vector(t: TypeRef, n: uint) -> TypeRef {\n-    unsafe {\n-        return llvm::LLVMVectorType(t, n as c_uint);\n-    }\n-}\n-\n-// Interior vector.\n-pub fn T_vec2(targ_cfg: &session::config, t: TypeRef) -> TypeRef {\n-    return T_struct([T_int(targ_cfg), // fill\n-                     T_int(targ_cfg), // alloc\n-                     T_array(t, 0u)], // elements\n-                    false);\n-}\n-\n-pub fn T_vec(ccx: &CrateContext, t: TypeRef) -> TypeRef {\n-    return T_vec2(ccx.sess.targ_cfg, t);\n-}\n-\n-// Note that the size of this one is in bytes.\n-pub fn T_opaque_vec(targ_cfg: @session::config) -> TypeRef {\n-    return T_vec2(targ_cfg, T_i8());\n-}\n-\n-pub fn T_box_header_fields(cx: &CrateContext) -> ~[TypeRef] {\n-    let ptr = T_ptr(T_i8());\n-    return ~[cx.int_type, T_ptr(cx.tydesc_type), ptr, ptr];\n-}\n-\n-pub fn T_box_header(cx: &CrateContext) -> TypeRef {\n-    return T_struct(T_box_header_fields(cx), false);\n-}\n-\n-pub fn T_box(cx: &CrateContext, t: TypeRef) -> TypeRef {\n-    return T_struct(vec::append(T_box_header_fields(cx), [t]), false);\n-}\n-\n-pub fn T_box_ptr(t: TypeRef) -> TypeRef {\n-    unsafe {\n-        return llvm::LLVMPointerType(t, gc_box_addrspace);\n-    }\n-}\n-\n-pub fn T_opaque_box(cx: &CrateContext) -> TypeRef {\n-    return T_box(cx, T_i8());\n-}\n-\n-pub fn T_opaque_box_ptr(cx: &CrateContext) -> TypeRef {\n-    return T_box_ptr(T_opaque_box(cx));\n-}\n-\n-pub fn T_unique(cx: &CrateContext, t: TypeRef) -> TypeRef {\n-    return T_struct(vec::append(T_box_header_fields(cx), [t]), false);\n-}\n-\n-pub fn T_unique_ptr(t: TypeRef) -> TypeRef {\n-    unsafe {\n-        return llvm::LLVMPointerType(t, gc_box_addrspace);\n-    }\n-}\n-\n-pub fn T_port(cx: &CrateContext, _t: TypeRef) -> TypeRef {\n-    return T_struct([cx.int_type], false); // Refcount\n-\n-}\n-\n-pub fn T_chan(cx: &CrateContext, _t: TypeRef) -> TypeRef {\n-    return T_struct([cx.int_type], false); // Refcount\n-\n-}\n-\n-\n-pub fn T_opaque_cbox_ptr(cx: &CrateContext) -> TypeRef {\n-    // closures look like boxes (even when they are ~fn or &fn)\n-    // see trans_closure.rs\n-    return T_opaque_box_ptr(cx);\n-}\n-\n-pub fn T_enum_discrim(cx: &CrateContext) -> TypeRef {\n-    return cx.int_type;\n-}\n-\n-pub fn T_captured_tydescs(cx: &CrateContext, n: uint) -> TypeRef {\n-    return T_struct(vec::from_elem::<TypeRef>(n, T_ptr(cx.tydesc_type)), false);\n-}\n-\n-pub fn T_opaque_trait(cx: &CrateContext, store: ty::TraitStore) -> TypeRef {\n-    match store {\n-        ty::BoxTraitStore => {\n-            T_struct([T_ptr(cx.tydesc_type), T_opaque_box_ptr(cx)], false)\n-        }\n-        ty::UniqTraitStore => {\n-            T_struct([T_ptr(cx.tydesc_type),\n-                      T_unique_ptr(T_unique(cx, T_i8()))],\n-                     false)\n-        }\n-        ty::RegionTraitStore(_) => {\n-            T_struct([T_ptr(cx.tydesc_type), T_ptr(T_i8())], false)\n-        }\n-    }\n-}\n-\n-pub fn T_opaque_port_ptr() -> TypeRef { return T_ptr(T_i8()); }\n-\n-pub fn T_opaque_chan_ptr() -> TypeRef { return T_ptr(T_i8()); }\n-*/\n-\n // Let T be the content of a box @T.  tuplify_box_ty(t) returns the\n // representation of @T as a tuple (i.e., the ty::t version of what T_box()\n // returns).\n@@ -1101,7 +746,7 @@ pub fn C_cstr(cx: &mut CrateContext, s: @str) -> ValueRef {\n         };\n \n         let gsym = token::gensym(\"str\");\n-        let g = fmt!(\"str%u\", gsym).as_c_str |buf| {\n+        let g = do fmt!(\"str%u\", gsym).as_c_str |buf| {\n             llvm::LLVMAddGlobal(cx.llmod, val_ty(sc).to_ref(), buf)\n         };\n         llvm::LLVMSetInitializer(g, sc);\n@@ -1138,7 +783,8 @@ pub fn C_zero_byte_arr(size: uint) -> ValueRef {\n         let mut i = 0u;\n         let mut elts: ~[ValueRef] = ~[];\n         while i < size { elts.push(C_u8(0u)); i += 1u; }\n-        return llvm::LLVMConstArray(Type::i8(), vec::raw::to_ptr(elts), elts.len() as c_uint);\n+        return llvm::LLVMConstArray(Type::i8().to_ref(),\n+                                    vec::raw::to_ptr(elts), elts.len() as c_uint);\n     }\n }\n \n@@ -1158,17 +804,17 @@ pub fn C_packed_struct(elts: &[ValueRef]) -> ValueRef {\n     }\n }\n \n-pub fn C_named_struct(T: TypeRef, elts: &[ValueRef]) -> ValueRef {\n+pub fn C_named_struct(T: Type, elts: &[ValueRef]) -> ValueRef {\n     unsafe {\n         do vec::as_imm_buf(elts) |ptr, len| {\n-            llvm::LLVMConstNamedStruct(T, ptr, len as c_uint)\n+            llvm::LLVMConstNamedStruct(T.to_ref(), ptr, len as c_uint)\n         }\n     }\n }\n \n-pub fn C_array(ty: TypeRef, elts: &[ValueRef]) -> ValueRef {\n+pub fn C_array(ty: Type, elts: &[ValueRef]) -> ValueRef {\n     unsafe {\n-        return llvm::LLVMConstArray(ty, vec::raw::to_ptr(elts), elts.len() as c_uint);\n+        return llvm::LLVMConstArray(ty.to_ref(), vec::raw::to_ptr(elts), elts.len() as c_uint);\n     }\n }\n \n@@ -1193,7 +839,7 @@ pub fn C_shape(ccx: &CrateContext, bytes: ~[u8]) -> ValueRef {\n         let llglobal = do name.as_c_str |buf| {\n             llvm::LLVMAddGlobal(ccx.llmod, val_ty(llshape).to_ref(), buf)\n         };\n-        llvm::LLVMSetInitializer(llglobal, llshape.to_ref());\n+        llvm::LLVMSetInitializer(llglobal, llshape);\n         llvm::LLVMSetGlobalConstant(llglobal, True);\n         lib::llvm::SetLinkage(llglobal, lib::llvm::InternalLinkage);\n         return llvm::LLVMConstPointerCast(llglobal, Type::i8p().to_ref());"}, {"sha": "456dc6edfb6bae05e6a71c56a4fc2ad327ac3e25", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 28, "deletions": 26, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/81cf72c264efae4a16616ba6fc998ae862068d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81cf72c264efae4a16616ba6fc998ae862068d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=81cf72c264efae4a16616ba6fc998ae862068d8b", "patch": "@@ -11,7 +11,7 @@\n use core::prelude::*;\n \n use back::abi;\n-use lib::llvm::{llvm, ConstFCmp, ConstICmp, SetLinkage, PrivateLinkage, ValueRef, TypeRef, Bool,\n+use lib::llvm::{llvm, ConstFCmp, ConstICmp, SetLinkage, PrivateLinkage, ValueRef, Bool,\n     True, False};\n use lib::llvm::{IntEQ, IntNE, IntUGT, IntUGE, IntULT, IntULE, IntSGT, IntSGE, IntSLT, IntSLE,\n     RealOEQ, RealOGT, RealOGE, RealOLT, RealOLE, RealONE};\n@@ -30,6 +30,8 @@ use middle::trans::type_of;\n use middle::ty;\n use util::ppaux::{Repr, ty_to_str};\n \n+use middle::trans::type_::Type;\n+\n use core::libc::c_uint;\n use core::str;\n use syntax::{ast, ast_util, ast_map};\n@@ -38,28 +40,28 @@ pub fn const_lit(cx: @mut CrateContext, e: @ast::expr, lit: ast::lit)\n     -> ValueRef {\n     let _icx = cx.insn_ctxt(\"trans_lit\");\n     match lit.node {\n-      ast::lit_int(i, t) => C_integral(T_int_ty(cx, t), i as u64, True),\n-      ast::lit_uint(u, t) => C_integral(T_uint_ty(cx, t), u, False),\n+      ast::lit_int(i, t) => C_integral(Type::int_from_ty(cx, t), i as u64, true),\n+      ast::lit_uint(u, t) => C_integral(Type::uint_from_ty(cx, t), u, false),\n       ast::lit_int_unsuffixed(i) => {\n         let lit_int_ty = ty::node_id_to_type(cx.tcx, e.id);\n         match ty::get(lit_int_ty).sty {\n           ty::ty_int(t) => {\n-            C_integral(T_int_ty(cx, t), i as u64, True)\n+            C_integral(Type::int_from_ty(cx, t), i as u64, true)\n           }\n           ty::ty_uint(t) => {\n-            C_integral(T_uint_ty(cx, t), i as u64, False)\n+            C_integral(Type::uint_from_ty(cx, t), i as u64, false)\n           }\n           _ => cx.sess.span_bug(lit.span,\n                    fmt!(\"integer literal has type %s (expected int or uint)\",\n                         ty_to_str(cx.tcx, lit_int_ty)))\n         }\n       }\n-      ast::lit_float(fs, t) => C_floating(fs, T_float_ty(cx, t)),\n+      ast::lit_float(fs, t) => C_floating(fs, Type::float_from_ty(cx, t)),\n       ast::lit_float_unsuffixed(fs) => {\n         let lit_float_ty = ty::node_id_to_type(cx.tcx, e.id);\n         match ty::get(lit_float_ty).sty {\n           ty::ty_float(t) => {\n-            C_floating(fs, T_float_ty(cx, t))\n+            C_floating(fs, Type::float_from_ty(cx, t))\n           }\n           _ => {\n             cx.sess.span_bug(lit.span,\n@@ -73,16 +75,16 @@ pub fn const_lit(cx: @mut CrateContext, e: @ast::expr, lit: ast::lit)\n     }\n }\n \n-pub fn const_ptrcast(cx: &mut CrateContext, a: ValueRef, t: TypeRef) -> ValueRef {\n+pub fn const_ptrcast(cx: &mut CrateContext, a: ValueRef, t: Type) -> ValueRef {\n     unsafe {\n-        let b = llvm::LLVMConstPointerCast(a, T_ptr(t));\n+        let b = llvm::LLVMConstPointerCast(a, t.ptr_to().to_ref());\n         assert!(cx.const_globals.insert(b as int, a));\n         b\n     }\n }\n \n pub fn const_vec(cx: @mut CrateContext, e: @ast::expr, es: &[@ast::expr])\n-    -> (ValueRef, ValueRef, TypeRef) {\n+    -> (ValueRef, ValueRef, Type) {\n     unsafe {\n         let vec_ty = ty::expr_ty(cx.tcx, e);\n         let unit_ty = ty::sequence_element_type(cx.tcx, vec_ty);\n@@ -102,8 +104,8 @@ pub fn const_vec(cx: @mut CrateContext, e: @ast::expr, es: &[@ast::expr])\n \n fn const_addr_of(cx: @mut CrateContext, cv: ValueRef) -> ValueRef {\n     unsafe {\n-        let gv = do str::as_c_str(\"const\") |name| {\n-            llvm::LLVMAddGlobal(cx.llmod, val_ty(cv), name)\n+        let gv = do \"const\".as_c_str |name| {\n+            llvm::LLVMAddGlobal(cx.llmod, val_ty(cv).to_ref(), name)\n         };\n         llvm::LLVMSetInitializer(gv, cv);\n         llvm::LLVMSetGlobalConstant(gv, True);\n@@ -180,7 +182,7 @@ pub fn const_expr(cx: @mut CrateContext, e: @ast::expr) -> ValueRef {\n     match adjustment {\n         None => { }\n         Some(@ty::AutoAddEnv(ty::re_static, ast::BorrowedSigil)) => {\n-            llconst = C_struct([llconst, C_null(T_opaque_box_ptr(cx))])\n+            llconst = C_struct([llconst, C_null(Type::opaque_box(cx).ptr_to())])\n         }\n         Some(@ty::AutoAddEnv(ref r, ref s)) => {\n             cx.sess.span_bug(e.span, fmt!(\"unexpected static function: \\\n@@ -349,9 +351,9 @@ fn const_expr_unadjusted(cx: @mut CrateContext, e: @ast::expr) -> ValueRef {\n                     ty::ty_bool => {\n                         // Somewhat questionable, but I believe this is\n                         // correct.\n-                        let te = llvm::LLVMConstTrunc(te, T_i1());\n+                        let te = llvm::LLVMConstTrunc(te, Type::i1().to_ref());\n                         let te = llvm::LLVMConstNot(te);\n-                        llvm::LLVMConstZExt(te, T_bool())\n+                        llvm::LLVMConstZExt(te, Type::bool().to_ref())\n                     }\n                     _ => llvm::LLVMConstNot(te),\n                 }\n@@ -426,21 +428,21 @@ fn const_expr_unadjusted(cx: @mut CrateContext, e: @ast::expr) -> ValueRef {\n \n               (expr::cast_integral, expr::cast_integral) => {\n                 let s = ty::type_is_signed(basety) as Bool;\n-                llvm::LLVMConstIntCast(v, llty, s)\n+                llvm::LLVMConstIntCast(v, llty.to_ref(), s)\n               }\n               (expr::cast_integral, expr::cast_float) => {\n                 if ty::type_is_signed(basety) {\n-                    llvm::LLVMConstSIToFP(v, llty)\n+                    llvm::LLVMConstSIToFP(v, llty.to_ref())\n                 } else {\n-                    llvm::LLVMConstUIToFP(v, llty)\n+                    llvm::LLVMConstUIToFP(v, llty.to_ref())\n                 }\n               }\n               (expr::cast_float, expr::cast_float) => {\n-                llvm::LLVMConstFPCast(v, llty)\n+                llvm::LLVMConstFPCast(v, llty.to_ref())\n               }\n               (expr::cast_float, expr::cast_integral) => {\n-                if ty::type_is_signed(ety) { llvm::LLVMConstFPToSI(v, llty) }\n-                else { llvm::LLVMConstFPToUI(v, llty) }\n+                if ty::type_is_signed(ety) { llvm::LLVMConstFPToSI(v, llty.to_ref()) }\n+                else { llvm::LLVMConstFPToUI(v, llty.to_ref()) }\n               }\n               (expr::cast_enum, expr::cast_integral) |\n               (expr::cast_enum, expr::cast_float)  => {\n@@ -451,18 +453,18 @@ fn const_expr_unadjusted(cx: @mut CrateContext, e: @ast::expr) -> ValueRef {\n                 match ety_cast {\n                     expr::cast_integral => {\n                         let s = ty::type_is_signed(ety) as Bool;\n-                        llvm::LLVMConstIntCast(iv, llty, s)\n+                        llvm::LLVMConstIntCast(iv, llty.to_ref(), s)\n                     }\n-                    expr::cast_float => llvm::LLVMConstUIToFP(iv, llty),\n+                    expr::cast_float => llvm::LLVMConstUIToFP(iv, llty.to_ref()),\n                     _ => cx.sess.bug(\"enum cast destination is not \\\n                                       integral or float\")\n                 }\n               }\n               (expr::cast_pointer, expr::cast_pointer) => {\n-                llvm::LLVMConstPointerCast(v, llty)\n+                llvm::LLVMConstPointerCast(v, llty.to_ref())\n               }\n               (expr::cast_integral, expr::cast_pointer) => {\n-                llvm::LLVMConstIntToPtr(v, llty)\n+                llvm::LLVMConstIntToPtr(v, llty.to_ref())\n               }\n               _ => {\n                 cx.sess.impossible_case(e.span,\n@@ -513,7 +515,7 @@ fn const_expr_unadjusted(cx: @mut CrateContext, e: @ast::expr) -> ValueRef {\n                 let (cv, sz, llunitty) = const_vec(cx, e, *es);\n                 let llty = val_ty(cv);\n                 let gv = do str::as_c_str(\"const\") |name| {\n-                    llvm::LLVMAddGlobal(cx.llmod, llty, name)\n+                    llvm::LLVMAddGlobal(cx.llmod, llty.to_ref(), name)\n                 };\n                 llvm::LLVMSetInitializer(gv, cv);\n                 llvm::LLVMSetGlobalConstant(gv, True);"}, {"sha": "a709600cb9dcdca129f43af53e7d3c2232050442", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/81cf72c264efae4a16616ba6fc998ae862068d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81cf72c264efae4a16616ba6fc998ae862068d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=81cf72c264efae4a16616ba6fc998ae862068d8b", "patch": "@@ -12,7 +12,7 @@ use core::prelude::*;\n \n use back::{upcall};\n use driver::session;\n-use lib::llvm::{ContextRef, ModuleRef, ValueRef, TypeRef};\n+use lib::llvm::{ContextRef, ModuleRef, ValueRef};\n use lib::llvm::{llvm, TargetData, TypeNames};\n use lib::llvm::{mk_target_data};\n use lib;\n@@ -36,8 +36,8 @@ use core::local_data;\n use extra::time;\n use syntax::ast;\n \n-use middle::trans::common::{ExternMap,tydesc_info,BuilderRef_res,Stats,namegen,addrspace_gen};\n-use middle::trans::common::{mono_id,new_namegen,new_addrspace_gen};\n+use middle::trans::common::{ExternMap,tydesc_info,BuilderRef_res,Stats,namegen};\n+use middle::trans::common::{mono_id,new_namegen};\n \n use middle::trans::base::{decl_crate_map};\n \n@@ -94,11 +94,10 @@ pub struct CrateContext {\n      impl_method_cache: HashMap<(ast::def_id, ast::ident), ast::def_id>,\n \n      module_data: HashMap<~str, ValueRef>,\n-     lltypes: HashMap<ty::t, TypeRef>,\n-     llsizingtypes: HashMap<ty::t, TypeRef>,\n+     lltypes: HashMap<ty::t, Type>,\n+     llsizingtypes: HashMap<ty::t, Type>,\n      adt_reprs: HashMap<ty::t, @adt::Repr>,\n      names: namegen,\n-     next_addrspace: addrspace_gen,\n      symbol_hasher: hash::State,\n      type_hashcodes: HashMap<ty::t, @str>,\n      type_short_names: HashMap<ty::t, ~str>,\n@@ -151,8 +150,8 @@ impl CrateContext {\n             let tydesc_type = Type::tydesc(targ_cfg.arch);\n             let opaque_vec_type = Type::opaque_vec(targ_cfg.arch);\n \n-            let str_slice_ty = Type::named_struct(\"str_slice\");\n-            str_slice_ty.set_struct_body([Type::i8p(), int_type]);\n+            let mut str_slice_ty = Type::named_struct(\"str_slice\");\n+            str_slice_ty.set_struct_body([Type::i8p(), int_type], false);\n \n             tn.associate_type(\"tydesc\", &tydesc_type);\n             tn.associate_type(\"str_slice\", &str_slice_ty);\n@@ -197,7 +196,6 @@ impl CrateContext {\n                   llsizingtypes: HashMap::new(),\n                   adt_reprs: HashMap::new(),\n                   names: new_namegen(),\n-                  next_addrspace: new_addrspace_gen(),\n                   symbol_hasher: symbol_hasher,\n                   type_hashcodes: HashMap::new(),\n                   type_short_names: HashMap::new(),"}, {"sha": "a9892b34ccd707ebde05a4cc30ca55664b70be3d", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/81cf72c264efae4a16616ba6fc998ae862068d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81cf72c264efae4a16616ba6fc998ae862068d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=81cf72c264efae4a16616ba6fc998ae862068d8b", "patch": "@@ -24,6 +24,8 @@ use middle::ty;\n use util::common::indenter;\n use util::ppaux;\n \n+use middle::trans::type_::Type;\n+\n use core::str;\n use core::vec;\n use syntax::ast;\n@@ -204,7 +206,7 @@ pub fn trans_log(log_ex: @ast::expr,\n         let global;\n         unsafe {\n             global = str::as_c_str(s, |buf| {\n-                llvm::LLVMAddGlobal(ccx.llmod, Type::i32(), buf)\n+                llvm::LLVMAddGlobal(ccx.llmod, Type::i32().to_ref(), buf)\n             });\n             llvm::LLVMSetGlobalConstant(global, False);\n             llvm::LLVMSetInitializer(global, C_null(Type::i32()));"}, {"sha": "c0a3b76aca4bd5879f69a776261cd8afc33151a0", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/81cf72c264efae4a16616ba6fc998ae862068d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81cf72c264efae4a16616ba6fc998ae862068d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=81cf72c264efae4a16616ba6fc998ae862068d8b", "patch": "@@ -152,6 +152,8 @@ use middle::ty;\n use util::common::indenter;\n use util::ppaux::Repr;\n \n+use middle::trans::type_::Type;\n+\n use core::cast::transmute;\n use core::hashmap::HashMap;\n use core::vec;\n@@ -981,9 +983,7 @@ fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n                             let symbol = csearch::get_symbol(\n                                 bcx.ccx().sess.cstore,\n                                 did);\n-                            let llval = llvm::LLVMAddGlobal(\n-                                bcx.ccx().llmod,\n-                                llty,\n+                            let llval = llvm::LLVMAddGlobal( bcx.ccx().llmod, llty.to_ref(),\n                                 transmute::<&u8,*i8>(&symbol[0]));\n                             let extern_const_values = &mut bcx.ccx().extern_const_values;\n                             extern_const_values.insert(did, llval);\n@@ -1552,8 +1552,8 @@ fn int_cast(bcx: block, lldsttype: Type, llsrctype: Type,\n             llsrc: ValueRef, signed: bool) -> ValueRef {\n     let _icx = bcx.insn_ctxt(\"int_cast\");\n     unsafe {\n-        let srcsz = llvm::LLVMGetIntTypeWidth(llsrctype);\n-        let dstsz = llvm::LLVMGetIntTypeWidth(lldsttype);\n+        let srcsz = llvm::LLVMGetIntTypeWidth(llsrctype.to_ref());\n+        let dstsz = llvm::LLVMGetIntTypeWidth(lldsttype.to_ref());\n         return if dstsz == srcsz {\n             BitCast(bcx, llsrc, lldsttype)\n         } else if srcsz > dstsz {\n@@ -1569,8 +1569,8 @@ fn int_cast(bcx: block, lldsttype: Type, llsrctype: Type,\n fn float_cast(bcx: block, lldsttype: Type, llsrctype: Type,\n               llsrc: ValueRef) -> ValueRef {\n     let _icx = bcx.insn_ctxt(\"float_cast\");\n-    let srcsz = lib::llvm::float_width(llsrctype);\n-    let dstsz = lib::llvm::float_width(lldsttype);\n+    let srcsz = llsrctype.float_width();\n+    let dstsz = lldsttype.float_width();\n     return if dstsz > srcsz {\n         FPExt(bcx, llsrc, lldsttype)\n     } else if srcsz > dstsz {"}, {"sha": "5cad76e471ef75412beda6b6cc281b46292984ad", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/81cf72c264efae4a16616ba6fc998ae862068d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81cf72c264efae4a16616ba6fc998ae862068d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=81cf72c264efae4a16616ba6fc998ae862068d8b", "patch": "@@ -44,6 +44,7 @@ use syntax::parse::token;\n use syntax::abi::{X86, X86_64, Arm, Mips};\n use syntax::abi::{RustIntrinsic, Rust, Stdcall, Fastcall,\n                   Cdecl, Aapcs, C};\n+use middle::trans::type_::Type;\n \n fn abi_info(ccx: @mut CrateContext) -> @cabi::ABIInfo {\n     return match ccx.sess.targ_cfg.arch {\n@@ -122,7 +123,7 @@ fn shim_types(ccx: @mut CrateContext, id: ast::node_id) -> ShimTypes {\n         llsig: llsig,\n         ret_def: ret_def,\n         bundle_ty: bundle_ty,\n-        shim_fn_ty: Type::func([bundle_ty.ptr_to()], Type::void()),\n+        shim_fn_ty: Type::func([bundle_ty.ptr_to()], &Type::void()),\n         fn_ty: fn_ty\n     }\n }\n@@ -220,22 +221,17 @@ fn build_wrap_fn_(ccx: @mut CrateContext,\n         let return_context = raw_block(fcx, false, fcx.llreturn);\n \n         let llfunctiontype = val_ty(llwrapfn);\n-        let llfunctiontype =\n-            ::lib::llvm::llvm::LLVMGetElementType(llfunctiontype);\n-        let llfunctionreturntype =\n-            ::lib::llvm::llvm::LLVMGetReturnType(llfunctiontype);\n-        if ::lib::llvm::llvm::LLVMGetTypeKind(llfunctionreturntype) ==\n-                ::lib::llvm::Void {\n+        let llfunctiontype = llfunctiontype.element_type();\n+        let return_type = llfunctiontype.return_type();\n+        if return_type.kind() == ::lib::llvm::Void {\n             // XXX: This might be wrong if there are any functions for which\n             // the C ABI specifies a void output pointer and the Rust ABI\n             // does not.\n             RetVoid(return_context);\n         } else {\n             // Cast if we have to...\n             // XXX: This is ugly.\n-            let llretptr = BitCast(return_context,\n-                                   fcx.llretptr.get(),\n-                                   llfunctionreturntype.ptr_to());\n+            let llretptr = BitCast(return_context, fcx.llretptr.get(), return_type.ptr_to());\n             Ret(return_context, Load(return_context, llretptr));\n         }\n     }\n@@ -636,6 +632,9 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n             }\n         }\n \n+        build_return(bcx);\n+        finish_fn(fcx, lltop);\n+\n         return;\n     }\n "}, {"sha": "294d56dcd7665a8a75268109abc04219407fd159", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 25, "deletions": 53, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/81cf72c264efae4a16616ba6fc998ae862068d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81cf72c264efae4a16616ba6fc998ae862068d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=81cf72c264efae4a16616ba6fc998ae862068d8b", "patch": "@@ -18,7 +18,7 @@ use back::abi;\n use back::link::*;\n use driver::session;\n use lib;\n-use lib::llvm::{llvm, ValueRef, Type, True};\n+use lib::llvm::{llvm, ValueRef, True};\n use middle::trans::adt;\n use middle::trans::base::*;\n use middle::trans::callee;\n@@ -29,12 +29,14 @@ use middle::trans::expr;\n use middle::trans::machine::*;\n use middle::trans::reflect;\n use middle::trans::tvec;\n-use middle::trans::type_of::{type_of, type_of_glue_fn};\n+use middle::trans::type_of::type_of;\n use middle::trans::uniq;\n use middle::ty;\n use util::ppaux;\n use util::ppaux::ty_to_short_str;\n \n+use middle::trans::type_::Type;\n+\n use core::io;\n use core::libc::c_uint;\n use core::str;\n@@ -76,16 +78,6 @@ pub fn drop_ty(cx: block, v: ValueRef, t: ty::t) -> block {\n     return cx;\n }\n \n-pub fn drop_ty_root(bcx: block, v: ValueRef, rooted: bool, t: ty::t) -> block {\n-    if rooted {\n-        // NB: v is a raw ptr to an addrspace'd ptr to the value.\n-        let v = PointerCast(bcx, Load(bcx, v), type_of(bcx.ccx(), t).ptr_to());\n-        drop_ty(bcx, v, t)\n-    } else {\n-        drop_ty(bcx, v, t)\n-    }\n-}\n-\n pub fn drop_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> block {\n     let _icx = bcx.insn_ctxt(\"drop_ty_immediate\");\n     match ty::get(t).sty {\n@@ -436,8 +428,8 @@ pub fn trans_struct_drop(bcx: block,\n \n         // The second argument is the \"self\" argument for drop\n         let params = unsafe {\n-            lib::llvm::fn_ty_param_tys(\n-                llvm::LLVMGetElementType(llvm::LLVMTypeOf(dtor_addr)))\n+            let ty = Type::from_ref(llvm::LLVMTypeOf(dtor_addr));\n+            ty.element_type().func_params()\n         };\n \n         // Class dtors have no explicit args, so the params should\n@@ -617,20 +609,6 @@ pub fn incr_refcnt_of_boxed(cx: block, box_ptr: ValueRef) {\n }\n \n \n-// Chooses the addrspace for newly declared types.\n-pub fn declare_tydesc_addrspace(ccx: &CrateContext, t: ty::t) -> addrspace {\n-    if !ty::type_needs_drop(ccx.tcx, t) {\n-        return default_addrspace;\n-    } else if ty::type_is_immediate(t) {\n-        // For immediate types, we don't actually need an addrspace, because\n-        // e.g. boxed types include pointers to their contents which are\n-        // already correctly tagged with addrspaces.\n-        return default_addrspace;\n-    } else {\n-        return (ccx.next_addrspace)();\n-    }\n-}\n-\n // Generates the declaration for (but doesn't emit) a type descriptor.\n pub fn declare_tydesc(ccx: &mut CrateContext, t: ty::t) -> @mut tydesc_info {\n     // If emit_tydescs already ran, then we shouldn't be creating any new\n@@ -640,28 +618,25 @@ pub fn declare_tydesc(ccx: &mut CrateContext, t: ty::t) -> @mut tydesc_info {\n     let llty = type_of(ccx, t);\n \n     if ccx.sess.count_type_sizes() {\n-        io::println(fmt!(\"%u\\t%s\",\n-                         llsize_of_real(ccx, llty),\n+        io::println(fmt!(\"%u\\t%s\", llsize_of_real(ccx, llty),\n                          ppaux::ty_to_str(ccx.tcx, t)));\n     }\n \n     let llsize = llsize_of(ccx, llty);\n     let llalign = llalign_of(ccx, llty);\n-    let addrspace = declare_tydesc_addrspace(ccx, t);\n     let name = mangle_internal_name_by_type_and_seq(ccx, t, \"tydesc\").to_managed();\n     note_unique_llvm_symbol(ccx, name);\n     debug!(\"+++ declare_tydesc %s %s\", ppaux::ty_to_str(ccx.tcx, t), name);\n     let gvar = str::as_c_str(name, |buf| {\n         unsafe {\n-            llvm::LLVMAddGlobal(ccx.llmod, ccx.tydesc_type, buf)\n+            llvm::LLVMAddGlobal(ccx.llmod, ccx.tydesc_type.to_ref(), buf)\n         }\n     });\n     let inf = @mut tydesc_info {\n         ty: t,\n         tydesc: gvar,\n         size: llsize,\n         align: llalign,\n-        addrspace: addrspace,\n         take_glue: None,\n         drop_glue: None,\n         free_glue: None,\n@@ -706,7 +681,11 @@ pub fn make_generic_glue_inner(ccx: @mut CrateContext,\n     let llty = type_of(ccx, t);\n     let llrawptr0 = PointerCast(bcx, llrawptr0, llty.ptr_to());\n     helper(bcx, llrawptr0, t);\n-    finish_fn(fcx, lltop);\n+\n+    // This is from the general finish fn, but that emits a ret {} that we don't want\n+    Br(raw_block(fcx, false, fcx.llstaticallocas), lltop);\n+    RetVoid(raw_block(fcx, false, fcx.llreturn));\n+\n     return llfn;\n }\n \n@@ -732,7 +711,7 @@ pub fn emit_tydescs(ccx: &mut CrateContext) {\n     //let _icx = ccx.insn_ctxt(\"emit_tydescs\");\n     // As of this point, allow no more tydescs to be created.\n     ccx.finished_tydescs = true;\n-    let glue_fn_ty = T_generic_glue_fn(ccx).ptr_to();\n+    let glue_fn_ty = Type::generic_glue_fn(ccx);\n     let tyds = &mut ccx.tydescs;\n     for tyds.each_value |&val| {\n         let ti = val;\n@@ -747,7 +726,7 @@ pub fn emit_tydescs(ccx: &mut CrateContext) {\n               Some(v) => {\n                 unsafe {\n                     ccx.stats.n_real_glues += 1u;\n-                    llvm::LLVMConstPointerCast(v, glue_fn_ty)\n+                    llvm::LLVMConstPointerCast(v, glue_fn_ty.to_ref())\n                 }\n               }\n             };\n@@ -757,7 +736,7 @@ pub fn emit_tydescs(ccx: &mut CrateContext) {\n               Some(v) => {\n                 unsafe {\n                     ccx.stats.n_real_glues += 1u;\n-                    llvm::LLVMConstPointerCast(v, glue_fn_ty)\n+                    llvm::LLVMConstPointerCast(v, glue_fn_ty.to_ref())\n                 }\n               }\n             };\n@@ -767,7 +746,7 @@ pub fn emit_tydescs(ccx: &mut CrateContext) {\n               Some(v) => {\n                 unsafe {\n                     ccx.stats.n_real_glues += 1u;\n-                    llvm::LLVMConstPointerCast(v, glue_fn_ty)\n+                    llvm::LLVMConstPointerCast(v, glue_fn_ty.to_ref())\n                 }\n               }\n             };\n@@ -777,16 +756,16 @@ pub fn emit_tydescs(ccx: &mut CrateContext) {\n               Some(v) => {\n                 unsafe {\n                     ccx.stats.n_real_glues += 1u;\n-                    llvm::LLVMConstPointerCast(v, glue_fn_ty)\n+                    llvm::LLVMConstPointerCast(v, glue_fn_ty.to_ref())\n                 }\n               }\n             };\n \n+\n         let shape = C_null(Type::i8p());\n         let shape_tables = C_null(Type::i8p());\n \n-        let tydesc =\n-            C_named_struct(ccx.tydesc_type,\n+        let tydesc = C_named_struct(ccx.tydesc_type,\n                            [ti.size, // size\n                             ti.align, // align\n                             take_glue, // take_glue\n@@ -802,18 +781,11 @@ pub fn emit_tydescs(ccx: &mut CrateContext) {\n             llvm::LLVMSetGlobalConstant(gvar, True);\n             lib::llvm::SetLinkage(gvar, lib::llvm::InternalLinkage);\n \n-            // Index tydesc by addrspace.\n-            if ti.addrspace > gc_box_addrspace {\n-                let llty = ccx.tydesc_type.ptr_to();\n-                let addrspace_name = fmt!(\"_gc_addrspace_metadata_%u\",\n-                                          ti.addrspace as uint);\n-                let addrspace_gvar = str::as_c_str(addrspace_name, |buf| {\n-                    llvm::LLVMAddGlobal(ccx.llmod, llty, buf)\n-                });\n-                lib::llvm::SetLinkage(addrspace_gvar,\n-                                      lib::llvm::InternalLinkage);\n-                llvm::LLVMSetInitializer(addrspace_gvar, gvar);\n-            }\n         }\n     };\n }\n+\n+fn type_of_glue_fn(ccx: &CrateContext) -> Type {\n+    let tydescpp = ccx.tydesc_type.ptr_to().ptr_to();\n+    Type::func([ Type::nil().ptr_to(), tydescpp, Type::i8p() ], &Type::void())\n+}"}, {"sha": "495d3bcae16e60ec46814c1b9700e387ea1ea4fc", "filename": "src/librustc/middle/trans/machine.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/81cf72c264efae4a16616ba6fc998ae862068d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81cf72c264efae4a16616ba6fc998ae862068d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs?ref=81cf72c264efae4a16616ba6fc998ae862068d8b", "patch": "@@ -18,6 +18,8 @@ use middle::trans::type_of;\n use middle::ty;\n use util::ppaux::ty_to_str;\n \n+use middle::trans::type_::Type;\n+\n // ______________________________________________________________________\n // compute sizeof / alignof\n \n@@ -140,7 +142,7 @@ pub fn static_size_of_enum(cx: &mut CrateContext, t: ty::t) -> uint {\n \n                 debug!(\"static_size_of_enum: variant %s type %s\",\n                        cx.tcx.sess.str_of(variant.name),\n-                       cx.tn.type_to_str(T_struct(lltypes, false)));\n+                       cx.tn.type_to_str(Type::struct_(lltypes, false)));\n \n                 let this_size = llsize_of_real(cx, Type::struct_(lltypes, false));\n                 if max_size < this_size {"}, {"sha": "055e1ebbd371d9018c238a4a67dc454263b753da", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/81cf72c264efae4a16616ba6fc998ae862068d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81cf72c264efae4a16616ba6fc998ae862068d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=81cf72c264efae4a16616ba6fc998ae862068d8b", "patch": "@@ -30,6 +30,8 @@ use middle::typeck;\n use util::common::indenter;\n use util::ppaux::Repr;\n \n+use middle::trans::type_::Type;\n+\n use core::str;\n use core::vec;\n use syntax::ast_map::{path, path_mod, path_name};\n@@ -463,7 +465,7 @@ pub fn trans_monomorphized_callee(bcx: block,\n \n           // create a llvalue that represents the fn ptr\n           let fn_ty = node_id_type(bcx, callee_id);\n-          let llfn_ty = type_of_fn_from_ty(ccx, fn_ty).to_ptr();\n+          let llfn_ty = type_of_fn_from_ty(ccx, fn_ty).ptr_to();\n           let llfn_val = PointerCast(bcx, callee.llfn, llfn_ty);\n \n           // combine the self environment with the rest\n@@ -778,7 +780,7 @@ pub fn make_vtable(ccx: @mut CrateContext,\n         let tbl = C_struct(components);\n         let vtable = ccx.sess.str_of((ccx.names)(\"vtable\"));\n         let vt_gvar = do str::as_c_str(vtable) |buf| {\n-            llvm::LLVMAddGlobal(ccx.llmod, val_ty(tbl), buf)\n+            llvm::LLVMAddGlobal(ccx.llmod, val_ty(tbl).to_ref(), buf)\n         };\n         llvm::LLVMSetInitializer(vt_gvar, tbl);\n         llvm::LLVMSetGlobalConstant(vt_gvar, lib::llvm::True);"}, {"sha": "cb68a2af92bb78c3744cc219df4cc2438ca108b7", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/81cf72c264efae4a16616ba6fc998ae862068d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81cf72c264efae4a16616ba6fc998ae862068d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=81cf72c264efae4a16616ba6fc998ae862068d8b", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use back::link::mangle_internal_name_by_path_and_seq;\n-use lib::llvm::{Type, ValueRef, llvm};\n+use lib::llvm::{ValueRef, llvm};\n use middle::trans::adt;\n use middle::trans::base::*;\n use middle::trans::build::*;\n@@ -33,6 +33,8 @@ use syntax::ast;\n use syntax::ast_map::path_name;\n use syntax::parse::token::special_idents;\n \n+use middle::trans::type_::Type;\n+\n pub struct Reflector {\n     visitor_val: ValueRef,\n     visitor_methods: @~[@ty::Method],"}, {"sha": "82db5d405da6a059c0d5c5f759679bd50f69db0c", "filename": "src/librustc/middle/trans/shape.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/81cf72c264efae4a16616ba6fc998ae862068d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81cf72c264efae4a16616ba6fc998ae862068d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=81cf72c264efae4a16616ba6fc998ae862068d8b", "patch": "@@ -17,6 +17,8 @@ use lib::llvm::{True, ModuleRef, ValueRef};\n use middle::trans::common::*;\n use middle::trans;\n \n+use middle::trans::type_::Type;\n+\n use core::str;\n \n pub struct Ctxt {\n@@ -32,7 +34,7 @@ pub fn mk_global(ccx: &CrateContext,\n               -> ValueRef {\n     unsafe {\n         let llglobal = do str::as_c_str(name) |buf| {\n-            llvm::LLVMAddGlobal(ccx.llmod, val_ty(llval), buf)\n+            llvm::LLVMAddGlobal(ccx.llmod, val_ty(llval).to_ref(), buf)\n         };\n         llvm::LLVMSetInitializer(llglobal, llval);\n         llvm::LLVMSetGlobalConstant(llglobal, True);\n@@ -50,7 +52,7 @@ pub fn mk_ctxt(llmod: ModuleRef) -> Ctxt {\n     unsafe {\n         let llshapetablesty = Type::named_struct(\"shapes\");\n         do \"shapes\".as_c_str |buf| {\n-            llvm::LLVMAddGlobal(llmod, llshapetablesty, buf)\n+            llvm::LLVMAddGlobal(llmod, llshapetablesty.to_ref(), buf)\n         };\n \n         Ctxt {"}, {"sha": "014c46b06e4a637e98580713a23c661de06129f2", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81cf72c264efae4a16616ba6fc998ae862068d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81cf72c264efae4a16616ba6fc998ae862068d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=81cf72c264efae4a16616ba6fc998ae862068d8b", "patch": "@@ -27,6 +27,8 @@ use middle::ty;\n use util::common::indenter;\n use util::ppaux::ty_to_str;\n \n+use middle::trans::type_::Type;\n+\n use core::option::None;\n use syntax::ast;\n use syntax::codemap;"}, {"sha": "14c4ac71d97e4b3d7344e44d139bf89c04acdbd5", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 46, "deletions": 18, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/81cf72c264efae4a16616ba6fc998ae862068d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81cf72c264efae4a16616ba6fc998ae862068d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=81cf72c264efae4a16616ba6fc998ae862068d8b", "patch": "@@ -11,6 +11,7 @@\n use core::prelude::*;\n \n use lib::llvm::{llvm, TypeRef, Bool, False, True, TypeKind};\n+use lib::llvm::{Float, Double, X86_FP80, PPC_FP128, FP128};\n \n use middle::ty;\n \n@@ -26,6 +27,7 @@ use core::cast;\n \n use core::libc::{c_uint};\n \n+#[deriving(Eq)]\n pub struct Type {\n     priv rf: TypeRef\n }\n@@ -38,12 +40,14 @@ macro_rules! ty (\n  * Wrapper for LLVM TypeRef\n  */\n impl Type {\n+    #[inline(always)]\n     pub fn from_ref(r: TypeRef) -> Type {\n         Type {\n             rf: r\n         }\n     }\n \n+    #[inline(always)] // So it doesn't kill --opt-level=0 builds of the compiler\n     pub fn to_ref(&self) -> TypeRef {\n         self.rf\n     }\n@@ -136,7 +140,7 @@ impl Type {\n \n     pub fn float_from_ty(ctx: &CrateContext, t: ast::float_ty) -> Type {\n         match t {\n-            ast::ty_f => ctx.float_ty,\n+            ast::ty_f => ctx.float_type,\n             ast::ty_f32 => Type::f32(),\n             ast::ty_f64 => Type::f64()\n         }\n@@ -147,7 +151,7 @@ impl Type {\n     }\n \n     pub fn func(args: &[Type], ret: &Type) -> Type {\n-        let vec : &[TypeRef] = unsafe { cast::transmute() };\n+        let vec : &[TypeRef] = unsafe { cast::transmute(args) };\n         ty!(llvm::LLVMFunctionType(ret.to_ref(), vec::raw::to_ptr(vec),\n                                    args.len() as c_uint, False))\n     }\n@@ -157,12 +161,13 @@ impl Type {\n     }\n \n     pub fn ptr(ty: Type) -> Type {\n-        ty!(llvm::LLVMPointerType(ty, 0 as c_uint))\n+        ty!(llvm::LLVMPointerType(ty.to_ref(), 0 as c_uint))\n     }\n \n     pub fn struct_(els: &[Type], packed: bool) -> Type {\n         let els : &[TypeRef] = unsafe { cast::transmute(els) };\n-        ty!(llvm::LLVMStructType(vec::raw::to_ptr(els), els.len() as c_uint, packed as Bool))\n+        ty!(llvm::LLVMStructTypeInContext(base::task_llcx(), vec::raw::to_ptr(els),\n+                                          els.len() as c_uint, packed as Bool))\n     }\n \n     pub fn named_struct(name: &str) -> Type {\n@@ -175,7 +180,7 @@ impl Type {\n     }\n \n     pub fn vtable() -> Type {\n-        Type::array(Type::i8().ptr_to(), 1)\n+        Type::array(&Type::i8().ptr_to(), 1)\n     }\n \n     pub fn generic_glue_fn(cx: &mut CrateContext) -> Type {\n@@ -185,18 +190,17 @@ impl Type {\n         }\n \n         let ty = cx.tydesc_type.get_field(abi::tydesc_field_drop_glue);\n-        cx.tn.associate_type(\"glue_fn\", ty);\n+        cx.tn.associate_type(\"glue_fn\", &ty);\n \n         return ty;\n     }\n \n     pub fn tydesc(arch: Architecture) -> Type {\n         let mut tydesc = Type::named_struct(\"tydesc\");\n         let tydescpp = tydesc.ptr_to().ptr_to();\n-        let pvoid = Type::i8().ptr_to();\n-        let glue_fn_ty = Type::func(\n-            [ Type::nil.ptr_to(), tydescpp, pvoid ],\n-            Type::void()).ptr_to();\n+        let pvoid = Type::i8p();\n+        let glue_fn_ty = Type::func([ Type::nil().ptr_to(), tydescpp, pvoid ],\n+            &Type::void()).ptr_to();\n \n         let int_ty = Type::int(arch);\n \n@@ -226,7 +230,7 @@ impl Type {\n     }\n \n     pub fn opaque_vec(arch: Architecture) -> Type {\n-        Type::vec(arch, Type::i8())\n+        Type::vec(arch, &Type::i8())\n     }\n \n     #[inline]\n@@ -242,19 +246,19 @@ impl Type {\n     }\n \n     pub fn box(ctx: &CrateContext, ty: &Type) -> Type {\n-        Type::struct_(Type::box_header_fields(ctx) + [ty], false)\n+        Type::struct_(Type::box_header_fields(ctx) + [*ty], false)\n     }\n \n     pub fn opaque_box(ctx: &CrateContext) -> Type {\n-        Type::box(ctx, Type::i8())\n+        Type::box(ctx, &Type::i8())\n     }\n \n     pub fn unique(ctx: &CrateContext, ty: &Type) -> Type {\n         Type::box(ctx, ty)\n     }\n \n     pub fn opaque_cbox_ptr(cx: &CrateContext) -> Type {\n-        Type::opaque_box().ptr_to()\n+        Type::opaque_box(cx).ptr_to()\n     }\n \n     pub fn enum_discrim(cx: &CrateContext) -> Type {\n@@ -275,7 +279,7 @@ impl Type {\n             }\n             ty::UniqTraitStore => {\n                 Type::struct_(\n-                    [ tydesc_ptr, Type::unique(ctx, Type::i8()).ptr_to()],\n+                    [ tydesc_ptr, Type::unique(ctx, &Type::i8()).ptr_to()],\n                 false)\n             }\n             ty::RegionTraitStore(*) => {\n@@ -301,7 +305,7 @@ impl Type {\n     }\n \n     pub fn ptr_to(&self) -> Type {\n-        ty!(llvm::LLVMPointerType(self.to_ref()))\n+        ty!(llvm::LLVMPointerType(self.to_ref(), 0))\n     }\n \n     pub fn get_field(&self, idx: uint) -> Type {\n@@ -335,14 +339,38 @@ impl Type {\n \n     pub fn field_types(&self) -> ~[Type] {\n         unsafe {\n-            let n_elts = llvm::LLVMCountStructElementTypes(struct_ty) as uint;\n+            let n_elts = llvm::LLVMCountStructElementTypes(self.to_ref()) as uint;\n             if n_elts == 0 {\n                 return ~[];\n             }\n             let mut elts = vec::from_elem(n_elts, 0 as TypeRef);\n-            llvm::LLVMGetStructElementTypes(struct_ty, &mut elts[0]);\n+            llvm::LLVMGetStructElementTypes(self.to_ref(), &mut elts[0]);\n             cast::transmute(elts)\n         }\n     }\n \n+    pub fn return_type(&self) -> Type {\n+        unsafe {\n+            ty!(llvm::LLVMGetReturnType(self.to_ref()))\n+        }\n+    }\n+\n+    pub fn func_params(&self) -> ~[Type] {\n+        unsafe {\n+            let n_args = llvm::LLVMCountParamTypes(self.to_ref()) as uint;\n+            let args = vec::from_elem(n_args, 0 as TypeRef);\n+            llvm::LLVMGetParamTypes(self.to_ref(), vec::raw::to_ptr(args));\n+            cast::transmute(args)\n+        }\n+    }\n+\n+    pub fn float_width(&self) -> uint {\n+        match self.kind() {\n+            Float => 32,\n+            Double => 64,\n+            X86_FP80 => 80,\n+            FP128 | PPC_FP128 => 128,\n+            _ => fail!(\"llvm_float_width called on a non-float type\")\n+        }\n+    }\n }"}, {"sha": "0f4ffb04b28102035e34f42afcc4078e8b78f718", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 32, "deletions": 41, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/81cf72c264efae4a16616ba6fc998ae862068d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81cf72c264efae4a16616ba6fc998ae862068d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=81cf72c264efae4a16616ba6fc998ae862068d8b", "patch": "@@ -18,6 +18,8 @@ use middle::trans::common;\n use middle::ty;\n use util::ppaux;\n \n+use middle::trans::type_::Type;\n+\n use syntax::ast;\n \n pub fn arg_is_indirect(_: &CrateContext, arg_ty: &ty::t) -> bool {\n@@ -58,10 +60,15 @@ pub fn type_of_fn(cx: &mut CrateContext, inputs: &[ty::t], output: ty::t)\n         atys.push_all(type_of_explicit_args(cx, inputs));\n \n         // Use the output as the actual return value if it's immediate.\n+<<<<<<< HEAD\n         if output_is_immediate && !ty::type_is_nil(output) {\n             Type::func(atys, lloutputtype)\n+=======\n+        if output_is_immediate {\n+            Type::func(atys, &lloutputtype)\n+>>>>>>> Finish up Type refactoring\n         } else {\n-            Type::func(atys, Type::void())\n+            Type::func(atys, &Type::void())\n         }\n     }\n }\n@@ -87,11 +94,11 @@ pub fn type_of_non_gc_box(cx: &mut CrateContext, t: ty::t) -> Type {\n         match ty::get(t).sty {\n           ty::ty_box(mt) => {\n               let ty = type_of(cx, mt.ty);\n-              Type::box(cx, ty).ptr_to()\n+              Type::box(cx, &ty).ptr_to()\n           }\n           ty::ty_uniq(mt) => {\n               let ty = type_of(cx, mt.ty);\n-              Type::unique(cx, ty).ptr_to()\n+              Type::unique(cx, &ty).ptr_to()\n           }\n           _ => {\n             cx.sess.bug(\"non-box in type_of_non_gc_box\");\n@@ -146,14 +153,14 @@ pub fn sizing_type_of(cx: &mut CrateContext, t: ty::t) -> Type {\n         ty::ty_closure(*) => Type::struct_([Type::i8p(), Type::i8p()], false),\n         ty::ty_trait(_, _, store, _) => Type::opaque_trait(cx, store),\n \n-        ty::ty_estr(ty::vstore_fixed(size)) => Type::array(Type::i8(), size),\n+        ty::ty_estr(ty::vstore_fixed(size)) => Type::array(&Type::i8(), size as u64),\n         ty::ty_evec(mt, ty::vstore_fixed(size)) => {\n-            Type::array(sizing_type_of(cx, mt.ty), size)\n+            Type::array(&sizing_type_of(cx, mt.ty), size as u64)\n         }\n \n         ty::ty_unboxed_vec(mt) => {\n             let sz_ty = sizing_type_of(cx, mt.ty);\n-            Type::vec(cx.sess.targ_cfg.arch, sz_ty)\n+            Type::vec(cx.sess.targ_cfg.arch, &sz_ty)\n         }\n \n         ty::ty_tup(*) | ty::ty_enum(*) => {\n@@ -165,7 +172,7 @@ pub fn sizing_type_of(cx: &mut CrateContext, t: ty::t) -> Type {\n             if ty::type_is_simd(cx.tcx, t) {\n                 let et = ty::simd_type(cx.tcx, t);\n                 let n = ty::simd_size(cx.tcx, t);\n-                Type::vector(type_of(cx, et), n)\n+                Type::vector(&type_of(cx, et), n as u64)\n             } else {\n                 let repr = adt::represent_type(cx, t);\n                 let packed = ty::lookup_packed(cx.tcx, did);\n@@ -205,14 +212,14 @@ pub fn type_of(cx: &mut CrateContext, t: ty::t) -> Type {\n         return llty;\n     }\n \n-    let llty = match ty::get(t).sty {\n+    let mut llty = match ty::get(t).sty {\n       ty::ty_nil | ty::ty_bot => Type::nil(),\n       ty::ty_bool => Type::bool(),\n       ty::ty_int(t) => Type::int_from_ty(cx, t),\n       ty::ty_uint(t) => Type::uint_from_ty(cx, t),\n       ty::ty_float(t) => Type::float_from_ty(cx, t),\n       ty::ty_estr(ty::vstore_uniq) => {\n-        Type::unique(cx, Type::vec(cx.sess.targ_cfg.arch, Type::i8())).ptr_to()\n+        Type::unique(cx, &Type::vec(cx.sess.targ_cfg.arch, &Type::i8())).ptr_to()\n       }\n       ty::ty_enum(did, ref substs) => {\n         // Only create the named struct, but don't fill it in. We\n@@ -223,30 +230,30 @@ pub fn type_of(cx: &mut CrateContext, t: ty::t) -> Type {\n         Type::named_struct(llvm_type_name(cx, an_enum, did, substs.tps))\n       }\n       ty::ty_estr(ty::vstore_box) => {\n-        Type::box(cx, Type::vec(cx, Type::i8())).ptr_to()\n+        Type::box(cx, &Type::vec(cx.sess.targ_cfg.arch, &Type::i8())).ptr_to()\n       }\n       ty::ty_evec(ref mt, ty::vstore_box) => {\n           let e_ty = type_of(cx, mt.ty);\n-          let v_ty = Type::vec(cx.sess.targ_cfg.arch, e_ty);\n-          Type::box(cx, v_ty).ptr_to()\n+          let v_ty = Type::vec(cx.sess.targ_cfg.arch, &e_ty);\n+          Type::box(cx, &v_ty).ptr_to()\n       }\n       ty::ty_box(ref mt) => {\n           let ty = type_of(cx, mt.ty);\n-          Type::box(cx, ty).ptr_to()\n+          Type::box(cx, &ty).ptr_to()\n       }\n       ty::ty_opaque_box => Type::opaque_box(cx).ptr_to(),\n       ty::ty_uniq(ref mt) => {\n           let ty = type_of(cx, mt.ty);\n-          Type::unique(cx, ty).ptr_to()\n+          Type::unique(cx, &ty).ptr_to()\n       }\n       ty::ty_evec(ref mt, ty::vstore_uniq) => {\n           let ty = type_of(cx, mt.ty);\n-          let ty = Type::vec(cx, ty);\n-          Type::unique(cx, ty).ptr_to()\n+          let ty = Type::vec(cx.sess.targ_cfg.arch, &ty);\n+          Type::unique(cx, &ty).ptr_to()\n       }\n       ty::ty_unboxed_vec(ref mt) => {\n           let ty = type_of(cx, mt.ty);\n-          Type::vec(cx.sess.targ_cfg.arch, ty)\n+          Type::vec(cx.sess.targ_cfg.arch, &ty)\n       }\n       ty::ty_ptr(ref mt) => type_of(cx, mt.ty).ptr_to(),\n       ty::ty_rptr(_, ref mt) => type_of(cx, mt.ty).ptr_to(),\n@@ -263,20 +270,20 @@ pub fn type_of(cx: &mut CrateContext, t: ty::t) -> Type {\n       }\n \n       ty::ty_estr(ty::vstore_fixed(n)) => {\n-          Type::array(Type::i8(), n + 1u /* +1 for trailing null */)\n+          Type::array(&Type::i8(), (n + 1u) as u64)\n       }\n \n       ty::ty_evec(ref mt, ty::vstore_fixed(n)) => {\n-          Type::array(type_of(cx, mt.ty), n)\n+          Type::array(&type_of(cx, mt.ty), n as u64)\n       }\n \n       ty::ty_bare_fn(_) => type_of_fn_from_ty(cx, t).ptr_to(),\n       ty::ty_closure(_) => {\n           let ty = type_of_fn_from_ty(cx, t);\n-          Type::func_pair(cx, ty)\n+          Type::func_pair(cx, &ty)\n       }\n       ty::ty_trait(_, _, store, _) => Type::opaque_trait(cx, store),\n-      ty::ty_type => cx.tydesc_type.to_ptr(),\n+      ty::ty_type => cx.tydesc_type.ptr_to(),\n       ty::ty_tup(*) => {\n           let repr = adt::represent_type(cx, t);\n           Type::struct_(adt::fields_of(cx, repr), false)\n@@ -286,7 +293,7 @@ pub fn type_of(cx: &mut CrateContext, t: ty::t) -> Type {\n           if ty::type_is_simd(cx.tcx, t) {\n               let et = ty::simd_type(cx.tcx, t);\n               let n = ty::simd_size(cx.tcx, t);\n-              Type::vector(type_of(cx, et), n)\n+              Type::vector(&type_of(cx, et), n as u64)\n           } else {\n               // Only create the named struct, but don't fill it in. We fill it\n               // in *after* placing it into the type cache. This prevents\n@@ -306,16 +313,14 @@ pub fn type_of(cx: &mut CrateContext, t: ty::t) -> Type {\n     match ty::get(t).sty {\n       ty::ty_enum(*) => {\n           let repr = adt::represent_type(cx, t);\n-          common::set_struct_body(llty, adt::fields_of(cx, repr),\n-                                  false);\n+          llty.set_struct_body(adt::fields_of(cx, repr), false);\n       }\n \n       ty::ty_struct(did, _) => {\n         if !ty::type_is_simd(cx.tcx, t) {\n           let repr = adt::represent_type(cx, t);\n           let packed = ty::lookup_packed(cx.tcx, did);\n-          common::set_struct_body(llty, adt::fields_of(cx, repr),\n-                                  packed);\n+          llty.set_struct_body(adt::fields_of(cx, repr), packed);\n         }\n       }\n       _ => ()\n@@ -345,19 +350,5 @@ pub fn llvm_type_name(cx: &CrateContext,\n \n pub fn type_of_dtor(ccx: &mut CrateContext, self_ty: ty::t) -> Type {\n     let self_ty = type_of(ccx, self_ty).ptr_to();\n-    Type::func([self_ty], Type::viod())\n-}\n-\n-/*\n-pub fn type_of_rooted(ccx: &mut CrateContext, t: ty::t) -> Type {\n-    let addrspace = base::get_tydesc(ccx, t).addrspace;\n-    debug!(\"type_of_rooted %s in addrspace %u\",\n-           ppaux::ty_to_str(ccx.tcx, t), addrspace as uint);\n-    return T_root(type_of(ccx, t), addrspace);\n-}\n-\n-pub fn type_of_glue_fn(ccx: &CrateContext) -> Type {\n-    let tydescpp = T_ptr(T_ptr(ccx.tydesc_type));\n-    return T_fn([T_ptr(T_nil()), tydescpp, T_ptr(T_i8())], T_void());\n+    Type::func([self_ty], Type::void())\n }\n-*/"}, {"sha": "eb5376da69697cd48bc3999f15206540164dffb6", "filename": "src/librustc/middle/trans/write_guard.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81cf72c264efae4a16616ba6fc998ae862068d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81cf72c264efae4a16616ba6fc998ae862068d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs?ref=81cf72c264efae4a16616ba6fc998ae862068d8b", "patch": "@@ -28,6 +28,8 @@ use middle::ty;\n use syntax::codemap::span;\n use syntax::ast;\n \n+use middle::trans::type_::Type;\n+\n pub fn root_and_write_guard(datum: &Datum,\n                             mut bcx: block,\n                             span: span,"}, {"sha": "c38b013a75aa3f11b15d098c02a949fbf94333c3", "filename": "src/libstd/unstable/intrinsics.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/81cf72c264efae4a16616ba6fc998ae862068d8b/src%2Flibstd%2Funstable%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81cf72c264efae4a16616ba6fc998ae862068d8b/src%2Flibstd%2Funstable%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fintrinsics.rs?ref=81cf72c264efae4a16616ba6fc998ae862068d8b", "patch": "@@ -175,15 +175,15 @@ pub extern \"rust-intrinsic\" {\n     pub fn atomic_umin_relaxed(dst: &mut int, src: int) -> int;\n \n     #[cfg(not(stage0))]\n-    pub fn atomic_umin(dst: &mut int, src: int) -> int;\n+    pub fn atomic_umax(dst: &mut int, src: int) -> int;\n     #[cfg(not(stage0))]\n-    pub fn atomic_umin_acq(dst: &mut int, src: int) -> int;\n+    pub fn atomic_umax_acq(dst: &mut int, src: int) -> int;\n     #[cfg(not(stage0))]\n-    pub fn atomic_umin_rel(dst: &mut int, src: int) -> int;\n+    pub fn atomic_umax_rel(dst: &mut int, src: int) -> int;\n     #[cfg(not(stage0))]\n-    pub fn atomic_umin_acqrel(dst: &mut int, src: int) -> int;\n+    pub fn atomic_umax_acqrel(dst: &mut int, src: int) -> int;\n     #[cfg(not(stage0))]\n-    pub fn atomic_umin_relaxed(dst: &mut int, src: int) -> int;\n+    pub fn atomic_umax_relaxed(dst: &mut int, src: int) -> int;\n \n     /// The size of a type in bytes.\n     ///"}]}