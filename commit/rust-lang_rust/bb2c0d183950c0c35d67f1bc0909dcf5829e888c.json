{"sha": "bb2c0d183950c0c35d67f1bc0909dcf5829e888c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiMmMwZDE4Mzk1MGMwYzM1ZDY3ZjFiYzA5MDlkY2Y1ODI5ZTg4OGM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2019-04-05T13:37:03Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2019-04-05T16:13:46Z"}, "message": "wasi: Use shared API for preopened fds\n\nThis commit updates the wasi target with supported added in\nCraneStation/wasi-sysroot#10. That function allows both C and Rust to\ncooperate in how preopened files are managed, enabling us to learn about\npropened files through the same interface. The `open_parent` function in\nthe wasi `fs` module was updated to avoid its own initialization of a\nglobal preopened map and instead delegate to libc to perform this\nfunctionality.\n\nThis should both be more robust into the future in terms of handling\npath logic as well as ensuring the propened map is correctly set up at\nprocess boot time. This does currently require some unfortunate\nallocations on our side, but if that becomes an issue we can always\npaper over those in time!", "tree": {"sha": "8bd36677b85ed08a9e466dc1914014781722867c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8bd36677b85ed08a9e466dc1914014781722867c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bb2c0d183950c0c35d67f1bc0909dcf5829e888c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bb2c0d183950c0c35d67f1bc0909dcf5829e888c", "html_url": "https://github.com/rust-lang/rust/commit/bb2c0d183950c0c35d67f1bc0909dcf5829e888c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bb2c0d183950c0c35d67f1bc0909dcf5829e888c/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "52980d0fb39134a26f73b39b384407e010fc3af5", "url": "https://api.github.com/repos/rust-lang/rust/commits/52980d0fb39134a26f73b39b384407e010fc3af5", "html_url": "https://github.com/rust-lang/rust/commit/52980d0fb39134a26f73b39b384407e010fc3af5"}], "stats": {"total": 175, "additions": 87, "deletions": 88}, "files": [{"sha": "965286e5bcf645d087eab6f1c758b0b19dcb7b79", "filename": "src/ci/docker/dist-various-2/build-wasi-toolchain.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb2c0d183950c0c35d67f1bc0909dcf5829e888c/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-wasi-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bb2c0d183950c0c35d67f1bc0909dcf5829e888c/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-wasi-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-wasi-toolchain.sh?ref=bb2c0d183950c0c35d67f1bc0909dcf5829e888c", "patch": "@@ -12,7 +12,7 @@ export PATH=`pwd`/clang+llvm-8.0.0-x86_64-linux-gnu-ubuntu-14.04/bin:$PATH\n git clone https://github.com/CraneStation/wasi-sysroot\n \n cd wasi-sysroot\n-git reset --hard 320054e84f8f2440def3b1c8700cedb8fd697bf8\n+git reset --hard e5f14be38362f1ab83302895a6e74b2ffd0e2302\n make -j$(nproc) INSTALL_DIR=/wasm32-unknown-wasi install\n \n cd .."}, {"sha": "589593299d6093ec80ee2d22a6fe60e88d22a0bf", "filename": "src/libstd/sys/wasi/fs.rs", "status": "modified", "additions": 86, "deletions": 87, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/bb2c0d183950c0c35d67f1bc0909dcf5829e888c/src%2Flibstd%2Fsys%2Fwasi%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb2c0d183950c0c35d67f1bc0909dcf5829e888c/src%2Flibstd%2Fsys%2Fwasi%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Ffs.rs?ref=bb2c0d183950c0c35d67f1bc0909dcf5829e888c", "patch": "@@ -1,17 +1,15 @@\n-use crate::collections::HashMap;\n-use crate::ffi::{OsStr, OsString};\n+use crate::ffi::{CStr, CString, OsStr, OsString};\n use crate::fmt;\n use crate::io::{self, IoVec, IoVecMut, SeekFrom};\n use crate::iter;\n use crate::mem::{self, ManuallyDrop};\n use crate::os::wasi::ffi::{OsStrExt, OsStringExt};\n use crate::path::{Path, PathBuf};\n use crate::ptr;\n-use crate::sync::atomic::{AtomicPtr, Ordering::SeqCst};\n use crate::sync::Arc;\n use crate::sys::fd::{DirCookie, WasiFd};\n use crate::sys::time::SystemTime;\n-use crate::sys::{cvt_wasi, unsupported};\n+use crate::sys::unsupported;\n use crate::sys_common::FromInner;\n \n pub use crate::sys_common::fs::copy;\n@@ -230,7 +228,11 @@ impl DirEntry {\n     }\n \n     pub fn metadata(&self) -> io::Result<FileAttr> {\n-        metadata_at(&self.inner.dir.fd, 0, OsStr::from_bytes(&self.name).as_ref())\n+        metadata_at(\n+            &self.inner.dir.fd,\n+            0,\n+            OsStr::from_bytes(&self.name).as_ref(),\n+        )\n     }\n \n     pub fn file_type(&self) -> io::Result<FileType> {\n@@ -377,8 +379,8 @@ impl OpenOptions {\n \n impl File {\n     pub fn open(path: &Path, opts: &OpenOptions) -> io::Result<File> {\n-        let (dir, file) = open_parent(path)?;\n-        open_at(&dir, file, opts)\n+        let (dir, file) = open_parent(path, libc::__WASI_RIGHT_PATH_OPEN)?;\n+        open_at(&dir, &file, opts)\n     }\n \n     pub fn open_at(&self, path: &Path, opts: &OpenOptions) -> io::Result<File> {\n@@ -475,7 +477,7 @@ impl DirBuilder {\n     }\n \n     pub fn mkdir(&self, p: &Path) -> io::Result<()> {\n-        let (dir, file) = open_parent(p)?;\n+        let (dir, file) = open_parent(p, libc::__WASI_RIGHT_PATH_CREATE_DIRECTORY)?;\n         dir.create_directory(file.as_os_str().as_bytes())\n     }\n }\n@@ -506,13 +508,13 @@ pub fn readdir(p: &Path) -> io::Result<ReadDir> {\n }\n \n pub fn unlink(p: &Path) -> io::Result<()> {\n-    let (dir, file) = open_parent(p)?;\n+    let (dir, file) = open_parent(p, libc::__WASI_RIGHT_PATH_UNLINK_FILE)?;\n     dir.unlink_file(file.as_os_str().as_bytes())\n }\n \n pub fn rename(old: &Path, new: &Path) -> io::Result<()> {\n-    let (old, old_file) = open_parent(old)?;\n-    let (new, new_file) = open_parent(new)?;\n+    let (old, old_file) = open_parent(old, libc::__WASI_RIGHT_PATH_RENAME_SOURCE)?;\n+    let (new, new_file) = open_parent(new, libc::__WASI_RIGHT_PATH_RENAME_TARGET)?;\n     old.rename(\n         old_file.as_os_str().as_bytes(),\n         &new,\n@@ -527,13 +529,13 @@ pub fn set_perm(_p: &Path, _perm: FilePermissions) -> io::Result<()> {\n }\n \n pub fn rmdir(p: &Path) -> io::Result<()> {\n-    let (dir, file) = open_parent(p)?;\n+    let (dir, file) = open_parent(p, libc::__WASI_RIGHT_PATH_REMOVE_DIRECTORY)?;\n     dir.remove_directory(file.as_os_str().as_bytes())\n }\n \n pub fn readlink(p: &Path) -> io::Result<PathBuf> {\n-    let (dir, file) = open_parent(p)?;\n-    read_link(&dir, file)\n+    let (dir, file) = open_parent(p, libc::__WASI_RIGHT_PATH_READLINK)?;\n+    read_link(&dir, &file)\n }\n \n fn read_link(fd: &WasiFd, file: &Path) -> io::Result<PathBuf> {\n@@ -568,13 +570,13 @@ fn read_link(fd: &WasiFd, file: &Path) -> io::Result<PathBuf> {\n }\n \n pub fn symlink(src: &Path, dst: &Path) -> io::Result<()> {\n-    let (dst, dst_file) = open_parent(dst)?;\n+    let (dst, dst_file) = open_parent(dst, libc::__WASI_RIGHT_PATH_SYMLINK)?;\n     dst.symlink(src.as_os_str().as_bytes(), dst_file.as_os_str().as_bytes())\n }\n \n pub fn link(src: &Path, dst: &Path) -> io::Result<()> {\n-    let (src, src_file) = open_parent(src)?;\n-    let (dst, dst_file) = open_parent(dst)?;\n+    let (src, src_file) = open_parent(src, libc::__WASI_RIGHT_PATH_LINK_SOURCE)?;\n+    let (dst, dst_file) = open_parent(dst, libc::__WASI_RIGHT_PATH_LINK_TARGET)?;\n     src.link(\n         libc::__WASI_LOOKUP_SYMLINK_FOLLOW,\n         src_file.as_os_str().as_bytes(),\n@@ -584,13 +586,13 @@ pub fn link(src: &Path, dst: &Path) -> io::Result<()> {\n }\n \n pub fn stat(p: &Path) -> io::Result<FileAttr> {\n-    let (dir, file) = open_parent(p)?;\n-    metadata_at(&dir, libc::__WASI_LOOKUP_SYMLINK_FOLLOW, file)\n+    let (dir, file) = open_parent(p, libc::__WASI_RIGHT_PATH_FILESTAT_GET)?;\n+    metadata_at(&dir, libc::__WASI_LOOKUP_SYMLINK_FOLLOW, &file)\n }\n \n pub fn lstat(p: &Path) -> io::Result<FileAttr> {\n-    let (dir, file) = open_parent(p)?;\n-    metadata_at(&dir, 0, file)\n+    let (dir, file) = open_parent(p, libc::__WASI_RIGHT_PATH_FILESTAT_GET)?;\n+    metadata_at(&dir, 0, &file)\n }\n \n fn metadata_at(\n@@ -621,72 +623,69 @@ fn open_at(fd: &WasiFd, path: &Path, opts: &OpenOptions) -> io::Result<File> {\n     Ok(File { fd })\n }\n \n-// FIXME: we shouldn't implement this. It'd be much better to share this between\n-// libc (the wasi-sysroot) and Rust as the logic here is likely far more tricky\n-// than what we're executing below. For now this is a stopgap to enable this\n-// module, but we should add an official API in upstream wasi-libc which looks\n-// like this.\n-//\n-// In the meantime this is highly unlikely to be correct. It allows some basic\n-// testing but is not at all robust.\n-fn open_parent(p: &Path) -> io::Result<(&'static WasiFd, &Path)> {\n-    let map = preopened_map();\n-    for ancestor in p.ancestors() {\n-        if let Some(fd) = map.get(ancestor) {\n-            let tail = p.strip_prefix(ancestor).unwrap();\n-            let tail = if tail == Path::new(\"\") {\n-                \".\".as_ref()\n-            } else {\n-                tail\n-            };\n-            return Ok((fd, tail))\n-        }\n-    }\n-    let msg = format!(\"failed to find a preopened file descriptor to open {:?}\", p);\n-    return Err(io::Error::new(io::ErrorKind::Other, msg));\n-\n-    type Preopened = HashMap<PathBuf, ManuallyDrop<WasiFd>>;\n-    fn preopened_map() -> &'static Preopened {\n-        static PTR: AtomicPtr<Preopened> = AtomicPtr::new(ptr::null_mut());\n-        unsafe {\n-            let ptr = PTR.load(SeqCst);\n-            if !ptr.is_null() {\n-                return &*ptr;\n-            }\n-\n-            let mut map = Box::new(HashMap::new());\n-            for fd in 3.. {\n-                let mut buf = mem::zeroed();\n-                if cvt_wasi(libc::__wasi_fd_prestat_get(fd, &mut buf)).is_err() {\n-                    break;\n-                }\n-                if buf.pr_type != libc::__WASI_PREOPENTYPE_DIR {\n-                    continue;\n-                }\n-                let len = buf.u.dir.pr_name_len;\n-                let mut v = vec![0u8; len];\n-                let res = cvt_wasi(libc::__wasi_fd_prestat_dir_name(\n-                    fd,\n-                    v.as_mut_ptr() as *mut i8,\n-                    v.len(),\n-                ));\n-                if res.is_err() {\n-                    continue;\n-                }\n-                let path = PathBuf::from(OsString::from_vec(v));\n-                map.insert(path, ManuallyDrop::new(WasiFd::from_raw(fd)));\n-            }\n-            let ptr = Box::into_raw(map);\n-            match PTR.compare_exchange(ptr::null_mut(), ptr, SeqCst, SeqCst) {\n-                Ok(_) => &*ptr,\n-\n-                // If we lost the race for initialization clean up the map we\n-                // made and just use the one that's already there\n-                Err(other) => {\n-                    drop(Box::from_raw(ptr));\n-                    &*other\n-                }\n-            }\n+/// Attempts to open a bare path `p`.\n+///\n+/// WASI has no fundamental capability to do this. All syscalls and operations\n+/// are relative to already-open file descriptors. The C library, however,\n+/// manages a map of preopened file descriptors to their path, and then the C\n+/// library provides an API to look at this. In other words, when you want to\n+/// open a path `p`, you have to find a previously opened file descriptor in a\n+/// global table and then see if `p` is relative to that file descriptor.\n+///\n+/// This function, if successful, will return two items:\n+///\n+/// * The first is a `ManuallyDrop<WasiFd>`. This represents a preopened file\n+///   descriptor which we don't have ownership of, but we can use. You shouldn't\n+///   actually drop the `fd`.\n+///\n+/// * The second is a path that should be a part of `p` and represents a\n+///   relative traversal from the file descriptor specified to the desired\n+///   location `p`.\n+///\n+/// If successful you can use the returned file descriptor to perform\n+/// file-descriptor-relative operations on the path returned as well. The\n+/// `rights` argument indicates what operations are desired on the returned file\n+/// descriptor, and if successful the returned file descriptor should have the\n+/// appropriate rights for performing `rights` actions.\n+///\n+/// Note that this can fail if `p` doesn't look like it can be opened relative\n+/// to any preopened file descriptor.\n+fn open_parent(\n+    p: &Path,\n+    rights: libc::__wasi_rights_t,\n+) -> io::Result<(ManuallyDrop<WasiFd>, PathBuf)> {\n+    let p = CString::new(p.as_os_str().as_bytes())?;\n+    unsafe {\n+        let mut ret = ptr::null();\n+        let fd = __wasilibc_find_relpath(p.as_ptr(), rights, 0, &mut ret);\n+        if fd == -1 {\n+            let msg = format!(\n+                \"failed to find a preopened file descriptor \\\n+                 through which {:?} could be opened\",\n+                p\n+            );\n+            return Err(io::Error::new(io::ErrorKind::Other, msg));\n         }\n+        let path = Path::new(OsStr::from_bytes(CStr::from_ptr(ret).to_bytes()));\n+\n+        // FIXME: right now `path` is a pointer into `p`, the `CString` above.\n+        // When we return `p` is deallocated and we can't use it, so we need to\n+        // currently separately allocate `path`. If this becomes an issue though\n+        // we should probably turn this into a closure-taking interface or take\n+        // `&CString` and then pass off `&Path` tied to the same lifetime.\n+        let path = path.to_path_buf();\n+\n+        return Ok((ManuallyDrop::new(WasiFd::from_raw(fd as u32)), path));\n+    }\n+\n+    // FIXME(rust-lang/libc#1314) use the `libc` crate for this when the API\n+    // there is published\n+    extern \"C\" {\n+        pub fn __wasilibc_find_relpath(\n+            path: *const libc::c_char,\n+            rights_base: libc::__wasi_rights_t,\n+            rights_inheriting: libc::__wasi_rights_t,\n+            relative_path: *mut *const libc::c_char,\n+        ) -> libc::c_int;\n     }\n }"}]}