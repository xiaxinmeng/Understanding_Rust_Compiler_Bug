{"sha": "94a56a375803abf1826ed31756b6ac12df23de7c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0YTU2YTM3NTgwM2FiZjE4MjZlZDMxNzU2YjZhYzEyZGYyM2RlN2M=", "commit": {"author": {"name": "Luqman Aden", "email": "laden@csclub.uwaterloo.ca", "date": "2014-06-21T12:01:12Z"}, "committer": {"name": "Luqman Aden", "email": "me@luqman.ca", "date": "2014-07-03T03:22:33Z"}, "message": "librustc: Don't create extra alloca slot for by value bindings in match.", "tree": {"sha": "ce208d2b613af1337bac3f8e59e43c00b3accd10", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ce208d2b613af1337bac3f8e59e43c00b3accd10"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/94a56a375803abf1826ed31756b6ac12df23de7c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/94a56a375803abf1826ed31756b6ac12df23de7c", "html_url": "https://github.com/rust-lang/rust/commit/94a56a375803abf1826ed31756b6ac12df23de7c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/94a56a375803abf1826ed31756b6ac12df23de7c/comments", "author": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "committer": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "67776ba3dab24a3e281931da437d30ccfc3b04c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/67776ba3dab24a3e281931da437d30ccfc3b04c1", "html_url": "https://github.com/rust-lang/rust/commit/67776ba3dab24a3e281931da437d30ccfc3b04c1"}], "stats": {"total": 172, "additions": 56, "deletions": 116}, "files": [{"sha": "6ec126edf0b6fdeaf21ec88954358a410ab52b39", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 34, "deletions": 108, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/94a56a375803abf1826ed31756b6ac12df23de7c/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94a56a375803abf1826ed31756b6ac12df23de7c/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=94a56a375803abf1826ed31756b6ac12df23de7c", "patch": "@@ -64,10 +64,8 @@\n  * We store information about the bound variables for each arm as part of the\n  * per-arm `ArmData` struct.  There is a mapping from identifiers to\n  * `BindingInfo` structs.  These structs contain the mode/id/type of the\n- * binding, but they also contain up to two LLVM values, called `llmatch` and\n- * `llbinding` respectively (the `llbinding`, as will be described shortly, is\n- * optional and only present for by-value bindings---therefore it is bundled\n- * up as part of the `TransBindingMode` type).  Both point at allocas.\n+ * binding, but they also contain an LLVM value which points at an alloca\n+ * called `llmatch`.\n  *\n  * The `llmatch` binding always stores a pointer into the value being matched\n  * which points at the data for the binding.  If the value being matched has\n@@ -83,32 +81,26 @@\n  * up against an identifier, we store the current pointer into the\n  * corresponding alloca.\n  *\n- * In addition, for each by-value binding (copy or move), we will create a\n- * second alloca (`llbinding`) that will hold the final value.  In this\n- * example, that means that `d` would have this second alloca of type `D` (and\n- * hence `llbinding` has type `D*`).\n- *\n  * Once a pattern is completely matched, and assuming that there is no guard\n  * pattern, we will branch to a block that leads to the body itself.  For any\n  * by-value bindings, this block will first load the ptr from `llmatch` (the\n- * one of type `D*`) and copy/move the value into `llbinding` (the one of type\n- * `D`).  The second alloca then becomes the value of the local variable.  For\n- * by ref bindings, the value of the local variable is simply the first\n- * alloca.\n+ * one of type `D*`) and then load a second time to get the actual value (the\n+ * one of type `D`). For by ref bindings, the value of the local variable is\n+ * simply the first alloca.\n  *\n  * So, for the example above, we would generate a setup kind of like this:\n  *\n  *        +-------+\n  *        | Entry |\n  *        +-------+\n  *            |\n- *        +-------------------------------------------+\n- *        | llmatch_c = (addr of first half of tuple) |\n- *        | llmatch_d = (addr of first half of tuple) |\n- *        +-------------------------------------------+\n+ *        +--------------------------------------------+\n+ *        | llmatch_c = (addr of first half of tuple)  |\n+ *        | llmatch_d = (addr of second half of tuple) |\n+ *        +--------------------------------------------+\n  *            |\n  *        +--------------------------------------+\n- *        | *llbinding_d = **llmatch_dlbinding_d |\n+ *        | *llbinding_d = **llmatch_d           |\n  *        +--------------------------------------+\n  *\n  * If there is a guard, the situation is slightly different, because we must\n@@ -127,22 +119,20 @@\n  *        +-------------------------------------------+\n  *            |\n  *        +-------------------------------------------------+\n- *        | *llbinding_d = **llmatch_dlbinding_d            |\n+ *        | *llbinding_d = **llmatch_d                      |\n  *        | check condition                                 |\n- *        | if false { free *llbinding_d, goto next case }  |\n+ *        | if false { goto next case }                     |\n  *        | if true { goto body }                           |\n  *        +-------------------------------------------------+\n  *\n  * The handling for the cleanups is a bit... sensitive.  Basically, the body\n  * is the one that invokes `add_clean()` for each binding.  During the guard\n  * evaluation, we add temporary cleanups and revoke them after the guard is\n- * evaluated (it could fail, after all).  Presuming the guard fails, we drop\n- * the various values we copied explicitly.  Note that guards and moves are\n+ * evaluated (it could fail, after all). Note that guards and moves are\n  * just plain incompatible.\n  *\n  * Some relevant helper functions that manage bindings:\n  * - `create_bindings_map()`\n- * - `store_non_ref_bindings()`\n  * - `insert_lllocals()`\n  *\n  *\n@@ -215,7 +205,6 @@ use middle::trans::datum;\n use middle::trans::datum::*;\n use middle::trans::expr::Dest;\n use middle::trans::expr;\n-use middle::trans::glue;\n use middle::trans::tvec;\n use middle::trans::type_of;\n use middle::trans::debuginfo;\n@@ -362,8 +351,8 @@ fn variant_opt(bcx: &Block, pat_id: ast::NodeId) -> Opt {\n }\n \n #[deriving(Clone)]\n-enum TransBindingMode {\n-    TrByValue(/*llbinding:*/ ValueRef),\n+pub enum TransBindingMode {\n+    TrByValue,\n     TrByRef,\n }\n \n@@ -376,12 +365,12 @@ enum TransBindingMode {\n  * - `id` is the node id of the binding\n  * - `ty` is the Rust type of the binding */\n  #[deriving(Clone)]\n-struct BindingInfo {\n-    llmatch: ValueRef,\n-    trmode: TransBindingMode,\n-    id: ast::NodeId,\n-    span: Span,\n-    ty: ty::t,\n+pub struct BindingInfo {\n+    pub llmatch: ValueRef,\n+    pub trmode: TransBindingMode,\n+    pub id: ast::NodeId,\n+    pub span: Span,\n+    pub ty: ty::t,\n }\n \n type BindingsMap = HashMap<Ident, BindingInfo>;\n@@ -1260,41 +1249,6 @@ fn compare_values<'a>(\n     }\n }\n \n-fn store_non_ref_bindings<'a>(\n-                          bcx: &'a Block<'a>,\n-                          bindings_map: &BindingsMap,\n-                          opt_cleanup_scope: Option<cleanup::ScopeId>)\n-                          -> &'a Block<'a>\n-{\n-    /*!\n-     * For each copy/move binding, copy the value from the value being\n-     * matched into its final home.  This code executes once one of\n-     * the patterns for a given arm has completely matched.  It adds\n-     * cleanups to the `opt_cleanup_scope`, if one is provided.\n-     */\n-\n-    let fcx = bcx.fcx;\n-    let mut bcx = bcx;\n-    for (_, &binding_info) in bindings_map.iter() {\n-        match binding_info.trmode {\n-            TrByValue(lldest) => {\n-                let llval = Load(bcx, binding_info.llmatch); // get a T*\n-                let datum = Datum::new(llval, binding_info.ty, Lvalue);\n-                bcx = datum.store_to(bcx, lldest);\n-\n-                match opt_cleanup_scope {\n-                    None => {}\n-                    Some(s) => {\n-                        fcx.schedule_drop_mem(s, lldest, binding_info.ty);\n-                    }\n-                }\n-            }\n-            TrByRef => {}\n-        }\n-    }\n-    return bcx;\n-}\n-\n fn insert_lllocals<'a>(bcx: &'a Block<'a>,\n                        bindings_map: &BindingsMap,\n                        cleanup_scope: cleanup::ScopeId)\n@@ -1308,9 +1262,8 @@ fn insert_lllocals<'a>(bcx: &'a Block<'a>,\n \n     for (&ident, &binding_info) in bindings_map.iter() {\n         let llval = match binding_info.trmode {\n-            // By value bindings: use the stack slot that we\n-            // copied/moved the value into\n-            TrByValue(lldest) => lldest,\n+            // By value bindings: load from the ptr into the matched value\n+            TrByValue => Load(bcx, binding_info.llmatch),\n \n             // By ref binding: use the ptr into the matched value\n             TrByRef => binding_info.llmatch\n@@ -1327,9 +1280,7 @@ fn insert_lllocals<'a>(bcx: &'a Block<'a>,\n         if bcx.sess().opts.debuginfo == FullDebugInfo {\n             debuginfo::create_match_binding_metadata(bcx,\n                                                      ident,\n-                                                     binding_info.id,\n-                                                     binding_info.span,\n-                                                     datum);\n+                                                     binding_info);\n         }\n     }\n     bcx\n@@ -1355,11 +1306,8 @@ fn compile_guard<'a, 'b>(\n     // scope for any non-ref bindings we create.\n     let temp_scope = bcx.fcx.push_custom_cleanup_scope();\n \n-    let mut bcx = bcx;\n-    bcx = store_non_ref_bindings(bcx, &data.bindings_map,\n-                                 Some(cleanup::CustomScope(temp_scope)));\n-    bcx = insert_lllocals(bcx, &data.bindings_map,\n-                          cleanup::CustomScope(temp_scope));\n+    let mut bcx = insert_lllocals(bcx, &data.bindings_map,\n+                                  cleanup::CustomScope(temp_scope));\n \n     let val = unpack_datum!(bcx, expr::trans(bcx, guard_expr));\n     let val = val.to_llbool(bcx);\n@@ -1370,9 +1318,10 @@ fn compile_guard<'a, 'b>(\n     bcx.fcx.pop_custom_cleanup_scope(temp_scope);\n \n     return with_cond(bcx, Not(bcx, val), |bcx| {\n-        // Guard does not match: free the values we copied,\n-        // and remove all bindings from the lllocals table\n-        let bcx = drop_bindings(bcx, data);\n+        // Guard does not match: remove all bindings from the lllocals table\n+        for (_, &binding_info) in data.bindings_map.iter() {\n+            bcx.fcx.lllocals.borrow_mut().remove(&binding_info.id);\n+        }\n         match chk {\n             // If the default arm is the only one left, move on to the next\n             // condition explicitly rather than (possibly) falling back to\n@@ -1386,21 +1335,6 @@ fn compile_guard<'a, 'b>(\n         };\n         bcx\n     });\n-\n-    fn drop_bindings<'a>(bcx: &'a Block<'a>, data: &ArmData)\n-                     -> &'a Block<'a> {\n-        let mut bcx = bcx;\n-        for (_, &binding_info) in data.bindings_map.iter() {\n-            match binding_info.trmode {\n-                TrByValue(llval) => {\n-                    bcx = glue::drop_ty(bcx, llval, binding_info.ty);\n-                }\n-                TrByRef => {}\n-            }\n-            bcx.fcx.lllocals.borrow_mut().remove(&binding_info.id);\n-        }\n-        return bcx;\n-    }\n }\n \n fn compile_submatch<'a, 'b>(\n@@ -1836,10 +1770,10 @@ fn create_bindings_map(bcx: &Block, pat: Gc<ast::Pat>) -> BindingsMap {\n                 // in this case, the final type of the variable will be T,\n                 // but during matching we need to store a *T as explained\n                 // above\n-                llmatch = alloca(bcx, llvariable_ty.ptr_to(), \"__llmatch\");\n-                trmode = TrByValue(alloca(bcx,\n-                                          llvariable_ty,\n-                                          bcx.ident(ident).as_slice()));\n+                llmatch = alloca(bcx,\n+                                 llvariable_ty.ptr_to(),\n+                                 bcx.ident(ident).as_slice());\n+                trmode = TrByValue;\n             }\n             ast::BindByRef(_) => {\n                 llmatch = alloca(bcx,\n@@ -1925,14 +1859,6 @@ fn trans_match_inner<'a>(scope_cx: &'a Block<'a>,\n     for arm_data in arm_datas.iter() {\n         let mut bcx = arm_data.bodycx;\n \n-        // If this arm has a guard, then the various by-value bindings have\n-        // already been copied into their homes.  If not, we do it here.  This\n-        // is just to reduce code space.  See extensive comment at the start\n-        // of the file for more details.\n-        if arm_data.arm.guard.is_none() {\n-            bcx = store_non_ref_bindings(bcx, &arm_data.bindings_map, None);\n-        }\n-\n         // insert bindings into the lllocals map and add cleanups\n         let cleanup_scope = fcx.push_custom_cleanup_scope();\n         bcx = insert_lllocals(bcx, &arm_data.bindings_map,"}, {"sha": "27d32f2c4d8e9e416f39a43deaa1b2fd828b9c31", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/94a56a375803abf1826ed31756b6ac12df23de7c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94a56a375803abf1826ed31756b6ac12df23de7c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=94a56a375803abf1826ed31756b6ac12df23de7c", "patch": "@@ -187,8 +187,8 @@ use metadata::csearch;\n use middle::subst;\n use middle::trans::adt;\n use middle::trans::common::*;\n-use middle::trans::datum::{Datum, Lvalue};\n use middle::trans::machine;\n+use middle::trans::_match::{BindingInfo, TrByValue, TrByRef};\n use middle::trans::type_of;\n use middle::trans::type_::Type;\n use middle::trans;\n@@ -938,22 +938,36 @@ pub fn create_captured_var_metadata(bcx: &Block,\n /// Adds the created metadata nodes directly to the crate's IR.\n pub fn create_match_binding_metadata(bcx: &Block,\n                                      variable_ident: ast::Ident,\n-                                     node_id: ast::NodeId,\n-                                     span: Span,\n-                                     datum: Datum<Lvalue>) {\n+                                     binding: BindingInfo) {\n     if fn_should_be_ignored(bcx.fcx) {\n         return;\n     }\n \n-    let scope_metadata = scope_metadata(bcx.fcx, node_id, span);\n+    let scope_metadata = scope_metadata(bcx.fcx, binding.id, binding.span);\n+    let aops = unsafe {\n+        [llvm::LLVMDIBuilderCreateOpDeref(bcx.ccx().int_type.to_ref())]\n+    };\n+    // Regardless of the actual type (`T`) we're always passed the stack slot (alloca)\n+    // for the binding. For ByRef bindings that's a `T*` but for ByValue bindings we\n+    // actually have `T**`. So to get the actual variable we need to dereference once\n+    // more.\n+    let var_type = match binding.trmode {\n+        TrByValue => IndirectVariable {\n+            alloca: binding.llmatch,\n+            address_operations: aops\n+        },\n+        TrByRef => DirectVariable {\n+            alloca: binding.llmatch\n+        }\n+    };\n \n     declare_local(bcx,\n                   variable_ident,\n-                  datum.ty,\n+                  binding.ty,\n                   scope_metadata,\n-                  DirectVariable { alloca: datum.val },\n+                  var_type,\n                   LocalVariable,\n-                  span);\n+                  binding.span);\n }\n \n /// Creates debug information for the given function argument."}]}