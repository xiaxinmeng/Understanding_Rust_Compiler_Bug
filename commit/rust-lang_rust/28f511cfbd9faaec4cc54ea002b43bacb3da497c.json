{"sha": "28f511cfbd9faaec4cc54ea002b43bacb3da497c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4ZjUxMWNmYmQ5ZmFhZWM0Y2M1NGVhMDAyYjQzYmFjYjNkYTQ5N2M=", "commit": {"author": {"name": "Mark-Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-12-16T15:28:20Z"}, "committer": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-12-21T03:02:52Z"}, "message": "Remove global Builder", "tree": {"sha": "578c7aeb0c4f8dc39e58b2fe9627d1ecec6eed3b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/578c7aeb0c4f8dc39e58b2fe9627d1ecec6eed3b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/28f511cfbd9faaec4cc54ea002b43bacb3da497c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/28f511cfbd9faaec4cc54ea002b43bacb3da497c", "html_url": "https://github.com/rust-lang/rust/commit/28f511cfbd9faaec4cc54ea002b43bacb3da497c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/28f511cfbd9faaec4cc54ea002b43bacb3da497c/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e0ccc81bbf0069bf968a741594dd81338cf98ac3", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0ccc81bbf0069bf968a741594dd81338cf98ac3", "html_url": "https://github.com/rust-lang/rust/commit/e0ccc81bbf0069bf968a741594dd81338cf98ac3"}], "stats": {"total": 205, "additions": 99, "deletions": 106}, "files": [{"sha": "4f346f8897ebd2d5a67276915a425099a5992b14", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 2, "deletions": 94, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/28f511cfbd9faaec4cc54ea002b43bacb3da497c/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f511cfbd9faaec4cc54ea002b43bacb3da497c/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=28f511cfbd9faaec4cc54ea002b43bacb3da497c", "patch": "@@ -53,7 +53,7 @@ use builder::{Builder, noname};\n use callee::{Callee};\n use common::{BlockAndBuilder, C_bool, C_bytes_in_context, C_i32, C_uint};\n use collector::{self, TransItemCollectionMode};\n-use common::{C_null, C_struct_in_context, C_u64, C_u8, C_undef};\n+use common::{C_struct_in_context, C_u64, C_u8, C_undef};\n use common::{CrateContext, FunctionContext};\n use common::{fulfill_obligation};\n use common::{type_is_zero_size, val_ty};\n@@ -77,10 +77,9 @@ use value::Value;\n use Disr;\n use util::nodemap::{NodeSet, FxHashMap, FxHashSet};\n \n-use arena::TypedArena;\n use libc::c_uint;\n use std::ffi::{CStr, CString};\n-use std::cell::{Cell, RefCell};\n+use std::cell::RefCell;\n use std::ptr;\n use std::rc::Rc;\n use std::str;\n@@ -655,97 +654,6 @@ pub fn alloca(cx: &BlockAndBuilder, ty: Type, name: &str) -> ValueRef {\n }\n \n impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n-    /// Create a function context for the given function.\n-    /// Beware that you must call `fcx.init` or `fcx.bind_args`\n-    /// before doing anything with the returned function context.\n-    pub fn new(ccx: &'blk CrateContext<'blk, 'tcx>,\n-               llfndecl: ValueRef,\n-               fn_ty: FnType,\n-               definition: Option<(Instance<'tcx>, &ty::FnSig<'tcx>, Abi)>)\n-               -> FunctionContext<'blk, 'tcx> {\n-        let (param_substs, def_id) = match definition {\n-            Some((instance, ..)) => {\n-                common::validate_substs(instance.substs);\n-                (instance.substs, Some(instance.def))\n-            }\n-            None => (ccx.tcx().intern_substs(&[]), None)\n-        };\n-\n-        let local_id = def_id.and_then(|id| ccx.tcx().map.as_local_node_id(id));\n-\n-        debug!(\"FunctionContext::new({})\",\n-               definition.map_or(String::new(), |d| d.0.to_string()));\n-\n-        let no_debug = if let Some(id) = local_id {\n-            ccx.tcx().map.attrs(id)\n-               .iter().any(|item| item.check_name(\"no_debug\"))\n-        } else if let Some(def_id) = def_id {\n-            ccx.sess().cstore.item_attrs(def_id)\n-               .iter().any(|item| item.check_name(\"no_debug\"))\n-        } else {\n-            false\n-        };\n-\n-        let mir = def_id.map(|id| ccx.tcx().item_mir(id));\n-\n-        let debug_context = if let (false, Some((instance, sig, abi)), &Some(ref mir)) =\n-                (no_debug, definition, &mir) {\n-            debuginfo::create_function_debug_context(ccx, instance, sig, abi, llfndecl, mir)\n-        } else {\n-            debuginfo::empty_function_debug_context(ccx)\n-        };\n-\n-        FunctionContext {\n-            mir: mir,\n-            llfn: llfndecl,\n-            llretslotptr: Cell::new(None),\n-            param_env: ccx.tcx().empty_parameter_environment(),\n-            alloca_insert_pt: Cell::new(None),\n-            landingpad_alloca: Cell::new(None),\n-            fn_ty: fn_ty,\n-            param_substs: param_substs,\n-            span: None,\n-            funclet_arena: TypedArena::new(),\n-            ccx: ccx,\n-            debug_context: debug_context,\n-        }\n-    }\n-\n-    /// Performs setup on a newly created function, creating the entry\n-    /// scope block and allocating space for the return pointer.\n-    pub fn init(&'blk self, skip_retptr: bool) -> BlockAndBuilder<'blk, 'tcx> {\n-        let entry_bcx = self.build_new_block(\"entry-block\");\n-\n-        // Use a dummy instruction as the insertion point for all allocas.\n-        // This is later removed in FunctionContext::cleanup.\n-        self.alloca_insert_pt.set(Some(unsafe {\n-            entry_bcx.load(C_null(Type::i8p(self.ccx)));\n-            llvm::LLVMGetFirstInstruction(entry_bcx.llbb())\n-        }));\n-\n-        if !self.fn_ty.ret.is_ignore() && !skip_retptr {\n-            // We normally allocate the llretslotptr, unless we\n-            // have been instructed to skip it for immediate return\n-            // values, or there is nothing to return at all.\n-\n-            // We create an alloca to hold a pointer of type `ret.original_ty`\n-            // which will hold the pointer to the right alloca which has the\n-            // final ret value\n-            let llty = self.fn_ty.ret.memory_ty(self.ccx);\n-            // But if there are no nested returns, we skip the indirection\n-            // and have a single retslot\n-            let slot = if self.fn_ty.ret.is_indirect() {\n-                get_param(self.llfn, 0)\n-            } else {\n-                self.alloca(llty, \"sret_slot\")\n-            };\n-\n-            self.llretslotptr.set(Some(slot));\n-        }\n-\n-        entry_bcx\n-    }\n-\n     /// Ties up the llstaticallocas -> llloadenv -> lltop edges,\n     /// and builds the return block.\n     pub fn finish(&'blk self, ret_cx: &BlockAndBuilder<'blk, 'tcx>) {"}, {"sha": "e4c3d6497fd75aa9c896ce36db697bc07255f6ec", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 97, "deletions": 7, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/28f511cfbd9faaec4cc54ea002b43bacb3da497c/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f511cfbd9faaec4cc54ea002b43bacb3da497c/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=28f511cfbd9faaec4cc54ea002b43bacb3da497c", "patch": "@@ -15,7 +15,8 @@\n use session::Session;\n use llvm;\n use llvm::{ValueRef, BasicBlockRef, BuilderRef, ContextRef, TypeKind};\n-use llvm::{True, False, Bool, OperandBundleDef};\n+use llvm::{True, False, Bool, OperandBundleDef, get_param};\n+use monomorphize::Instance;\n use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::DefPathData;\n@@ -311,18 +312,109 @@ pub struct FunctionContext<'a, 'tcx: 'a> {\n \n     // Used and maintained by the debuginfo module.\n     pub debug_context: debuginfo::FunctionDebugContext,\n+\n+    owned_builder: OwnedBuilder<'a, 'tcx>,\n }\n \n impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n+    /// Create a function context for the given function.\n+    /// Beware that you must call `fcx.init` or `fcx.bind_args`\n+    /// before doing anything with the returned function context.\n+    pub fn new(ccx: &'a CrateContext<'a, 'tcx>,\n+               llfndecl: ValueRef,\n+               fn_ty: FnType,\n+               definition: Option<(Instance<'tcx>, &ty::FnSig<'tcx>, Abi)>)\n+               -> FunctionContext<'a, 'tcx> {\n+        let (param_substs, def_id) = match definition {\n+            Some((instance, ..)) => {\n+                validate_substs(instance.substs);\n+                (instance.substs, Some(instance.def))\n+            }\n+            None => (ccx.tcx().intern_substs(&[]), None)\n+        };\n+\n+        let local_id = def_id.and_then(|id| ccx.tcx().map.as_local_node_id(id));\n+\n+        debug!(\"FunctionContext::new({})\", definition.map_or(String::new(), |d| d.0.to_string()));\n+\n+        let no_debug = if let Some(id) = local_id {\n+            ccx.tcx().map.attrs(id).iter().any(|item| item.check_name(\"no_debug\"))\n+        } else if let Some(def_id) = def_id {\n+            ccx.sess().cstore.item_attrs(def_id).iter().any(|item| item.check_name(\"no_debug\"))\n+        } else {\n+            false\n+        };\n+\n+        let mir = def_id.map(|id| ccx.tcx().item_mir(id));\n+\n+        let debug_context = if let (false, Some((instance, sig, abi)), &Some(ref mir)) =\n+                (no_debug, definition, &mir) {\n+            debuginfo::create_function_debug_context(ccx, instance, sig, abi, llfndecl, mir)\n+        } else {\n+            debuginfo::empty_function_debug_context(ccx)\n+        };\n+\n+        FunctionContext {\n+            mir: mir,\n+            llfn: llfndecl,\n+            llretslotptr: Cell::new(None),\n+            param_env: ccx.tcx().empty_parameter_environment(),\n+            alloca_insert_pt: Cell::new(None),\n+            landingpad_alloca: Cell::new(None),\n+            fn_ty: fn_ty,\n+            param_substs: param_substs,\n+            span: None,\n+            funclet_arena: TypedArena::new(),\n+            ccx: ccx,\n+            debug_context: debug_context,\n+            owned_builder: OwnedBuilder::new_with_ccx(ccx),\n+        }\n+    }\n+\n+    /// Performs setup on a newly created function, creating the entry\n+    /// scope block and allocating space for the return pointer.\n+    pub fn init(&'a self, skip_retptr: bool) -> BlockAndBuilder<'a, 'tcx> {\n+        let entry_bcx = self.build_new_block(\"entry-block\");\n+\n+        // Use a dummy instruction as the insertion point for all allocas.\n+        // This is later removed in FunctionContext::cleanup.\n+        self.alloca_insert_pt.set(Some(unsafe {\n+            entry_bcx.load(C_null(Type::i8p(self.ccx)));\n+            llvm::LLVMGetFirstInstruction(entry_bcx.llbb())\n+        }));\n+\n+        self.owned_builder.builder.position_at_start(entry_bcx.llbb());\n+\n+        if !self.fn_ty.ret.is_ignore() && !skip_retptr {\n+            // We normally allocate the llretslotptr, unless we\n+            // have been instructed to skip it for immediate return\n+            // values, or there is nothing to return at all.\n+\n+            // We create an alloca to hold a pointer of type `ret.original_ty`\n+            // which will hold the pointer to the right alloca which has the\n+            // final ret value\n+            let llty = self.fn_ty.ret.memory_ty(self.ccx);\n+            // But if there are no nested returns, we skip the indirection\n+            // and have a single retslot\n+            let slot = if self.fn_ty.ret.is_indirect() {\n+                get_param(self.llfn, 0)\n+            } else {\n+                self.alloca(llty, \"sret_slot\")\n+            };\n+\n+            self.llretslotptr.set(Some(slot));\n+        }\n+\n+        entry_bcx\n+    }\n+\n     pub fn mir(&self) -> Ref<'tcx, Mir<'tcx>> {\n         self.mir.as_ref().map(Ref::clone).expect(\"fcx.mir was empty\")\n     }\n \n     pub fn cleanup(&self) {\n         unsafe {\n-            llvm::LLVMInstructionEraseFromParent(self.alloca_insert_pt\n-                                                     .get()\n-                                                     .unwrap());\n+            llvm::LLVMInstructionEraseFromParent(self.alloca_insert_pt.get().unwrap());\n         }\n     }\n \n@@ -431,9 +523,7 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n     }\n \n     pub fn alloca(&self, ty: Type, name: &str) -> ValueRef {\n-        let b = self.ccx.builder();\n-        b.position_before(self.alloca_insert_pt.get().unwrap());\n-        b.alloca(ty, name)\n+        self.owned_builder.builder.alloca(ty, name)\n     }\n }\n "}, {"sha": "4f524af29456ec5c60edbf9c5e33c527ca424a65", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/28f511cfbd9faaec4cc54ea002b43bacb3da497c/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f511cfbd9faaec4cc54ea002b43bacb3da497c/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=28f511cfbd9faaec4cc54ea002b43bacb3da497c", "patch": "@@ -17,7 +17,6 @@ use rustc::hir::def::ExportMap;\n use rustc::hir::def_id::DefId;\n use rustc::traits;\n use base;\n-use builder::Builder;\n use common::BuilderRef_res;\n use debuginfo;\n use declare;\n@@ -731,10 +730,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.shared.tcx.sess\n     }\n \n-    pub fn builder<'a>(&'a self) -> Builder<'a, 'tcx> {\n-        Builder::new(self)\n-    }\n-\n     pub fn raw_builder<'a>(&'a self) -> BuilderRef {\n         self.local().builder.b\n     }"}]}