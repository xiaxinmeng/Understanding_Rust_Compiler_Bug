{"sha": "cebd2dda1d9071f2209079370c412f4ef9ef2b82", "node_id": "C_kwDOAAsO6NoAKGNlYmQyZGRhMWQ5MDcxZjIyMDkwNzkzNzBjNDEyZjRlZjllZjJiODI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-21T21:20:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-21T21:20:20Z"}, "message": "Auto merge of #90352 - camsteffen:for-loop-desugar, r=oli-obk\n\nSimplify `for` loop desugar\n\nBasically two intermediate bindings are inlined. I could have left one intermediate binding in place as this would simplify some diagnostic logic, but I think the difference in that regard would be negligible, so it is better to have a minimal HIR.\n\nFor checking that the pattern is irrefutable, I added a special case when the `match` is found to be non-exhaustive.\n\nThe reordering of the arms is purely stylistic. I don't *think* there are any perf implications.\n\n```diff\n  match IntoIterator::into_iter($head) {\n      mut iter => {\n          $label: loop {\n-             let mut __next;\n              match Iterator::next(&mut iter) {\n-                 Some(val) => __next = val,\n                  None => break,\n+                 Some($pat) => $block,\n              }\n-             let $pat = __next;\n-             $block\n          }\n      }\n  }\n```", "tree": {"sha": "ff90842dc821a514ae5a8fd9bf429f353eef64cb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ff90842dc821a514ae5a8fd9bf429f353eef64cb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cebd2dda1d9071f2209079370c412f4ef9ef2b82", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cebd2dda1d9071f2209079370c412f4ef9ef2b82", "html_url": "https://github.com/rust-lang/rust/commit/cebd2dda1d9071f2209079370c412f4ef9ef2b82", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cebd2dda1d9071f2209079370c412f4ef9ef2b82/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "65f3f8b220f020e562c5dd848ff7319257a7ba45", "url": "https://api.github.com/repos/rust-lang/rust/commits/65f3f8b220f020e562c5dd848ff7319257a7ba45", "html_url": "https://github.com/rust-lang/rust/commit/65f3f8b220f020e562c5dd848ff7319257a7ba45"}, {"sha": "66da8faf176cf5fbdd198371f80ff58b3ed50cf9", "url": "https://api.github.com/repos/rust-lang/rust/commits/66da8faf176cf5fbdd198371f80ff58b3ed50cf9", "html_url": "https://github.com/rust-lang/rust/commit/66da8faf176cf5fbdd198371f80ff58b3ed50cf9"}], "stats": {"total": 890, "additions": 321, "deletions": 569}, "files": [{"sha": "a0a63620c08a9e02fae235ec9ed36a2b56a71cb5", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 38, "deletions": 99, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/cebd2dda1d9071f2209079370c412f4ef9ef2b82/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebd2dda1d9071f2209079370c412f4ef9ef2b82/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=cebd2dda1d9071f2209079370c412f4ef9ef2b82", "patch": "@@ -13,7 +13,7 @@ use rustc_session::parse::feature_err;\n use rustc_span::hygiene::ExpnId;\n use rustc_span::source_map::{respan, DesugaringKind, Span, Spanned};\n use rustc_span::symbol::{sym, Ident, Symbol};\n-use rustc_span::{hygiene::ForLoopLoc, DUMMY_SP};\n+use rustc_span::DUMMY_SP;\n \n impl<'hir> LoweringContext<'_, 'hir> {\n     fn lower_exprs(&mut self, exprs: &[AstP<Expr>]) -> &'hir [hir::Expr<'hir>] {\n@@ -1308,16 +1308,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     /// Desugar `ExprForLoop` from: `[opt_ident]: for <pat> in <head> <body>` into:\n     /// ```rust\n     /// {\n-    ///     let result = match ::std::iter::IntoIterator::into_iter(<head>) {\n+    ///     let result = match IntoIterator::into_iter(<head>) {\n     ///         mut iter => {\n     ///             [opt_ident]: loop {\n-    ///                 let mut __next;\n-    ///                 match ::std::iter::Iterator::next(&mut iter) {\n-    ///                     ::std::option::Option::Some(val) => __next = val,\n-    ///                     ::std::option::Option::None => break\n+    ///                 match Iterator::next(&mut iter) {\n+    ///                     None => break,\n+    ///                     Some(<pat>) => <body>,\n     ///                 };\n-    ///                 let <pat> = __next;\n-    ///                 StmtKind::Expr(<body>);\n     ///             }\n     ///         }\n     ///     };\n@@ -1332,133 +1329,75 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         body: &Block,\n         opt_label: Option<Label>,\n     ) -> hir::Expr<'hir> {\n-        // expand <head>\n         let head = self.lower_expr_mut(head);\n-        let desugared_span =\n-            self.mark_span_with_reason(DesugaringKind::ForLoop(ForLoopLoc::Head), head.span, None);\n-        let e_span = self.lower_span(e.span);\n-\n-        let iter = Ident::with_dummy_span(sym::iter);\n-\n-        let next_ident = Ident::with_dummy_span(sym::__next);\n-        let (next_pat, next_pat_hid) = self.pat_ident_binding_mode(\n-            desugared_span,\n-            next_ident,\n-            hir::BindingAnnotation::Mutable,\n-        );\n-\n-        // `::std::option::Option::Some(val) => __next = val`\n-        let pat_arm = {\n-            let val_ident = Ident::with_dummy_span(sym::val);\n-            let pat_span = self.lower_span(pat.span);\n-            let (val_pat, val_pat_hid) = self.pat_ident(pat_span, val_ident);\n-            let val_expr = self.expr_ident(pat_span, val_ident, val_pat_hid);\n-            let next_expr = self.expr_ident(pat_span, next_ident, next_pat_hid);\n-            let assign = self.arena.alloc(self.expr(\n-                pat_span,\n-                hir::ExprKind::Assign(next_expr, val_expr, self.lower_span(pat_span)),\n-                ThinVec::new(),\n-            ));\n-            let some_pat = self.pat_some(pat_span, val_pat);\n-            self.arm(some_pat, assign)\n-        };\n+        let pat = self.lower_pat(pat);\n+        let for_span =\n+            self.mark_span_with_reason(DesugaringKind::ForLoop, self.lower_span(e.span), None);\n+        let head_span = self.mark_span_with_reason(DesugaringKind::ForLoop, head.span, None);\n+        let pat_span = self.mark_span_with_reason(DesugaringKind::ForLoop, pat.span, None);\n \n-        // `::std::option::Option::None => break`\n-        let break_arm = {\n+        // `None => break`\n+        let none_arm = {\n             let break_expr =\n-                self.with_loop_scope(e.id, |this| this.expr_break_alloc(e_span, ThinVec::new()));\n-            let pat = self.pat_none(e_span);\n+                self.with_loop_scope(e.id, |this| this.expr_break_alloc(for_span, ThinVec::new()));\n+            let pat = self.pat_none(for_span);\n             self.arm(pat, break_expr)\n         };\n \n+        // Some(<pat>) => <body>,\n+        let some_arm = {\n+            let some_pat = self.pat_some(pat_span, pat);\n+            let body_block = self.with_loop_scope(e.id, |this| this.lower_block(body, false));\n+            let body_expr = self.arena.alloc(self.expr_block(body_block, ThinVec::new()));\n+            self.arm(some_pat, body_expr)\n+        };\n+\n         // `mut iter`\n+        let iter = Ident::with_dummy_span(sym::iter);\n         let (iter_pat, iter_pat_nid) =\n-            self.pat_ident_binding_mode(desugared_span, iter, hir::BindingAnnotation::Mutable);\n+            self.pat_ident_binding_mode(head_span, iter, hir::BindingAnnotation::Mutable);\n \n-        // `match ::std::iter::Iterator::next(&mut iter) { ... }`\n+        // `match Iterator::next(&mut iter) { ... }`\n         let match_expr = {\n-            let iter = self.expr_ident(desugared_span, iter, iter_pat_nid);\n-            let ref_mut_iter = self.expr_mut_addr_of(desugared_span, iter);\n+            let iter = self.expr_ident(head_span, iter, iter_pat_nid);\n+            let ref_mut_iter = self.expr_mut_addr_of(head_span, iter);\n             let next_expr = self.expr_call_lang_item_fn(\n-                desugared_span,\n+                head_span,\n                 hir::LangItem::IteratorNext,\n                 arena_vec![self; ref_mut_iter],\n             );\n-            let arms = arena_vec![self; pat_arm, break_arm];\n+            let arms = arena_vec![self; none_arm, some_arm];\n \n-            self.expr_match(desugared_span, next_expr, arms, hir::MatchSource::ForLoopDesugar)\n+            self.expr_match(head_span, next_expr, arms, hir::MatchSource::ForLoopDesugar)\n         };\n-        let match_stmt = self.stmt_expr(desugared_span, match_expr);\n-\n-        let next_expr = self.expr_ident(desugared_span, next_ident, next_pat_hid);\n-\n-        // `let mut __next`\n-        let next_let = self.stmt_let_pat(\n-            None,\n-            desugared_span,\n-            None,\n-            next_pat,\n-            hir::LocalSource::ForLoopDesugar,\n-        );\n+        let match_stmt = self.stmt_expr(for_span, match_expr);\n \n-        // `let <pat> = __next`\n-        let pat = self.lower_pat(pat);\n-        let pat_let = self.stmt_let_pat(\n-            None,\n-            desugared_span,\n-            Some(next_expr),\n-            pat,\n-            hir::LocalSource::ForLoopDesugar,\n-        );\n-\n-        let body_block = self.with_loop_scope(e.id, |this| this.lower_block(body, false));\n-        let body_expr = self.expr_block(body_block, ThinVec::new());\n-        let body_stmt = self.stmt_expr(body_block.span, body_expr);\n-\n-        let loop_block = self.block_all(\n-            e_span,\n-            arena_vec![self; next_let, match_stmt, pat_let, body_stmt],\n-            None,\n-        );\n+        let loop_block = self.block_all(for_span, arena_vec![self; match_stmt], None);\n \n         // `[opt_ident]: loop { ... }`\n         let kind = hir::ExprKind::Loop(\n             loop_block,\n             self.lower_label(opt_label),\n             hir::LoopSource::ForLoop,\n-            self.lower_span(e_span.with_hi(head.span.hi())),\n+            self.lower_span(for_span.with_hi(head.span.hi())),\n         );\n-        let loop_expr = self.arena.alloc(hir::Expr {\n-            hir_id: self.lower_node_id(e.id),\n-            kind,\n-            span: self.lower_span(e.span),\n-        });\n+        let loop_expr =\n+            self.arena.alloc(hir::Expr { hir_id: self.lower_node_id(e.id), kind, span: for_span });\n \n         // `mut iter => { ... }`\n         let iter_arm = self.arm(iter_pat, loop_expr);\n \n-        let into_iter_span = self.mark_span_with_reason(\n-            DesugaringKind::ForLoop(ForLoopLoc::IntoIter),\n-            head.span,\n-            None,\n-        );\n-\n         // `match ::std::iter::IntoIterator::into_iter(<head>) { ... }`\n         let into_iter_expr = {\n             self.expr_call_lang_item_fn(\n-                into_iter_span,\n+                head_span,\n                 hir::LangItem::IntoIterIntoIter,\n                 arena_vec![self; head],\n             )\n         };\n \n-        // #82462: to correctly diagnose borrow errors, the block that contains\n-        // the iter expr needs to have a span that covers the loop body.\n-        let desugared_full_span =\n-            self.mark_span_with_reason(DesugaringKind::ForLoop(ForLoopLoc::Head), e_span, None);\n-\n         let match_expr = self.arena.alloc(self.expr_match(\n-            desugared_full_span,\n+            for_span,\n             into_iter_expr,\n             arena_vec![self; iter_arm],\n             hir::MatchSource::ForLoopDesugar,\n@@ -1472,7 +1411,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         // surrounding scope of the `match` since the `match` is not a terminating scope.\n         //\n         // Also, add the attributes to the outer returned expr node.\n-        self.expr_drop_temps_mut(desugared_full_span, match_expr, attrs.into())\n+        self.expr_drop_temps_mut(for_span, match_expr, attrs.into())\n     }\n \n     /// Desugar `ExprKind::Try` from: `<expr>?` into:"}, {"sha": "db8268c8e2e89bfbdd275d68956328e1f5d14503", "filename": "compiler/rustc_borrowck/src/diagnostics/explain_borrow.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cebd2dda1d9071f2209079370c412f4ef9ef2b82/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebd2dda1d9071f2209079370c412f4ef9ef2b82/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs?ref=cebd2dda1d9071f2209079370c412f4ef9ef2b82", "patch": "@@ -13,7 +13,7 @@ use rustc_middle::mir::{\n use rustc_middle::ty::adjustment::PointerCast;\n use rustc_middle::ty::{self, RegionVid, TyCtxt};\n use rustc_span::symbol::Symbol;\n-use rustc_span::Span;\n+use rustc_span::{sym, DesugaringKind, Span};\n \n use crate::region_infer::BlameConstraint;\n use crate::{\n@@ -135,7 +135,16 @@ impl BorrowExplanation {\n                 should_note_order,\n             } => {\n                 let local_decl = &body.local_decls[dropped_local];\n-                let (dtor_desc, type_desc) = match local_decl.ty.kind() {\n+                let mut ty = local_decl.ty;\n+                if local_decl.source_info.span.desugaring_kind() == Some(DesugaringKind::ForLoop) {\n+                    if let ty::Adt(adt, substs) = local_decl.ty.kind() {\n+                        if tcx.is_diagnostic_item(sym::Option, adt.did) {\n+                            // in for loop desugaring, only look at the `Some(..)` inner type\n+                            ty = substs.type_at(0);\n+                        }\n+                    }\n+                }\n+                let (dtor_desc, type_desc) = match ty.kind() {\n                     // If type is an ADT that implements Drop, then\n                     // simplify output by reporting just the ADT name.\n                     ty::Adt(adt, _substs) if adt.has_dtor(tcx) && !adt.is_box() => {"}, {"sha": "79623e26eb710d304d4556ad30a335aa42a07fbe", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cebd2dda1d9071f2209079370c412f4ef9ef2b82/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebd2dda1d9071f2209079370c412f4ef9ef2b82/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=cebd2dda1d9071f2209079370c412f4ef9ef2b82", "patch": "@@ -13,11 +13,7 @@ use rustc_middle::mir::{\n use rustc_middle::ty::print::Print;\n use rustc_middle::ty::{self, DefIdTree, Instance, Ty, TyCtxt};\n use rustc_mir_dataflow::move_paths::{InitLocation, LookupResult};\n-use rustc_span::{\n-    hygiene::{DesugaringKind, ForLoopLoc},\n-    symbol::sym,\n-    Span,\n-};\n+use rustc_span::{hygiene::DesugaringKind, symbol::sym, Span};\n use rustc_target::abi::VariantIdx;\n \n use super::borrow_set::BorrowData;\n@@ -955,10 +951,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             let kind = kind.unwrap_or_else(|| {\n                 // This isn't a 'special' use of `self`\n                 debug!(\"move_spans: method_did={:?}, fn_call_span={:?}\", method_did, fn_call_span);\n-                let implicit_into_iter = matches!(\n-                    fn_call_span.desugaring_kind(),\n-                    Some(DesugaringKind::ForLoop(ForLoopLoc::IntoIter))\n-                );\n+                let implicit_into_iter = Some(method_did) == tcx.lang_items().into_iter_fn()\n+                    && fn_call_span.desugaring_kind() == Some(DesugaringKind::ForLoop);\n                 let parent_self_ty = parent\n                     .filter(|did| tcx.def_kind(*did) == rustc_hir::def::DefKind::Impl)\n                     .and_then(|did| match tcx.type_of(did).kind() {"}, {"sha": "46e2a99a0d0940cd381dafef4ee1fda32267913b", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cebd2dda1d9071f2209079370c412f4ef9ef2b82/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebd2dda1d9071f2209079370c412f4ef9ef2b82/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=cebd2dda1d9071f2209079370c412f4ef9ef2b82", "patch": "@@ -445,15 +445,23 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                                 },\n                             ))) => {\n                                 // check if the RHS is from desugaring\n-                                let locations = self.body.find_assignments(local);\n-                                let opt_assignment_rhs_span = locations\n-                                    .first()\n-                                    .map(|&location| self.body.source_info(location).span);\n-                                let opt_desugaring_kind =\n-                                    opt_assignment_rhs_span.and_then(|span| span.desugaring_kind());\n-                                match opt_desugaring_kind {\n+                                let opt_assignment_rhs_span =\n+                                    self.body.find_assignments(local).first().map(|&location| {\n+                                        let stmt = &self.body[location.block].statements\n+                                            [location.statement_index];\n+                                        match stmt.kind {\n+                                            mir::StatementKind::Assign(box (\n+                                                _,\n+                                                mir::Rvalue::Use(mir::Operand::Copy(place)),\n+                                            )) => {\n+                                                self.body.local_decls[place.local].source_info.span\n+                                            }\n+                                            _ => self.body.source_info(location).span,\n+                                        }\n+                                    });\n+                                match opt_assignment_rhs_span.and_then(|s| s.desugaring_kind()) {\n                                     // on for loops, RHS points to the iterator part\n-                                    Some(DesugaringKind::ForLoop(_)) => {\n+                                    Some(DesugaringKind::ForLoop) => {\n                                         self.suggest_similar_mut_method_for_for_loop(&mut err);\n                                         Some((\n                                             false,"}, {"sha": "c67d3df3dedd85b9d4457e50ecdcf9b669809ebd", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cebd2dda1d9071f2209079370c412f4ef9ef2b82/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebd2dda1d9071f2209079370c412f4ef9ef2b82/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=cebd2dda1d9071f2209079370c412f4ef9ef2b82", "patch": "@@ -1821,8 +1821,6 @@ impl<'hir> QPath<'hir> {\n pub enum LocalSource {\n     /// A `match _ { .. }`.\n     Normal,\n-    /// A desugared `for _ in _ { .. }` loop.\n-    ForLoopDesugar,\n     /// When lowering async functions, we create locals within the `async move` so that\n     /// all parameters are dropped after the future is polled.\n     ///"}, {"sha": "b30076100bb2c5f665aeb164db7a6208f522b838", "filename": "compiler/rustc_hir/src/pat_util.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cebd2dda1d9071f2209079370c412f4ef9ef2b82/compiler%2Frustc_hir%2Fsrc%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebd2dda1d9071f2209079370c412f4ef9ef2b82/compiler%2Frustc_hir%2Fsrc%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fpat_util.rs?ref=cebd2dda1d9071f2209079370c412f4ef9ef2b82", "patch": "@@ -2,6 +2,7 @@ use crate::def::{CtorOf, DefKind, Res};\n use crate::def_id::DefId;\n use crate::hir::{self, HirId, PatKind};\n use rustc_data_structures::stable_set::FxHashSet;\n+use rustc_span::hygiene::DesugaringKind;\n use rustc_span::symbol::Ident;\n use rustc_span::Span;\n \n@@ -143,4 +144,14 @@ impl hir::Pat<'_> {\n         });\n         result\n     }\n+\n+    /// If the pattern is `Some(<pat>)` from a desugared for loop, returns the inner pattern\n+    pub fn for_loop_some(&self) -> Option<&Self> {\n+        if self.span.desugaring_kind() == Some(DesugaringKind::ForLoop) {\n+            if let hir::PatKind::Struct(_, [pat_field], _) = self.kind {\n+                return Some(pat_field.pat);\n+            }\n+        }\n+        None\n+    }\n }"}, {"sha": "a7e019a53ee13586c835b1991c38109fa0e32915", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cebd2dda1d9071f2209079370c412f4ef9ef2b82/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebd2dda1d9071f2209079370c412f4ef9ef2b82/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=cebd2dda1d9071f2209079370c412f4ef9ef2b82", "patch": "@@ -5,13 +5,12 @@ use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Namespace};\n use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n-use rustc_hir::{Body, Expr, ExprKind, FnRetTy, HirId, Local, Pat};\n+use rustc_hir::{Body, Expr, ExprKind, FnRetTy, HirId, Local, MatchSource, Pat};\n use rustc_middle::hir::map::Map;\n use rustc_middle::infer::unify_key::ConstVariableOriginKind;\n use rustc_middle::ty::print::Print;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind};\n use rustc_middle::ty::{self, DefIdTree, InferConst, Ty, TyCtxt};\n-use rustc_span::source_map::DesugaringKind;\n use rustc_span::symbol::kw;\n use rustc_span::Span;\n use std::borrow::Cow;\n@@ -26,6 +25,7 @@ struct FindHirNodeVisitor<'a, 'tcx> {\n     found_closure: Option<&'tcx Expr<'tcx>>,\n     found_method_call: Option<&'tcx Expr<'tcx>>,\n     found_exact_method_call: Option<&'tcx Expr<'tcx>>,\n+    found_for_loop_iter: Option<&'tcx Expr<'tcx>>,\n     found_use_diagnostic: Option<UseDiagnostic<'tcx>>,\n }\n \n@@ -41,6 +41,7 @@ impl<'a, 'tcx> FindHirNodeVisitor<'a, 'tcx> {\n             found_closure: None,\n             found_method_call: None,\n             found_exact_method_call: None,\n+            found_for_loop_iter: None,\n             found_use_diagnostic: None,\n         }\n     }\n@@ -111,6 +112,15 @@ impl<'a, 'tcx> Visitor<'tcx> for FindHirNodeVisitor<'a, 'tcx> {\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n+        if let ExprKind::Match(scrutinee, [_, arm], MatchSource::ForLoopDesugar) = expr.kind {\n+            if let Some(pat) = arm.pat.for_loop_some() {\n+                if let Some(ty) = self.node_ty_contains_target(pat.hir_id) {\n+                    self.found_for_loop_iter = Some(scrutinee);\n+                    self.found_node_ty = Some(ty);\n+                    return;\n+                }\n+            }\n+        }\n         if let ExprKind::MethodCall(_, call_span, exprs, _) = expr.kind {\n             if call_span == self.target_span\n                 && Some(self.target)\n@@ -643,10 +653,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             let msg = if let Some(simple_ident) = pattern.simple_ident() {\n                 match pattern.span.desugaring_kind() {\n                     None => format!(\"consider giving `{}` {}\", simple_ident, suffix),\n-                    Some(DesugaringKind::ForLoop(_)) => {\n-                        \"the element type for this iterator is not specified\".to_string()\n-                    }\n-                    _ => format!(\"this needs {}\", suffix),\n+                    Some(_) => format!(\"this needs {}\", suffix),\n                 }\n             } else {\n                 format!(\"consider giving this pattern {}\", suffix)\n@@ -719,6 +726,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 //    = note: type must be known at this point\n                 self.annotate_method_call(segment, e, &mut err);\n             }\n+        } else if let Some(scrutinee) = local_visitor.found_for_loop_iter {\n+            err.span_label(\n+                scrutinee.span,\n+                \"the element type for this iterator is not specified\".to_string(),\n+            );\n         }\n         // Instead of the following:\n         // error[E0282]: type annotations needed"}, {"sha": "881b14278e99ed7186329facf09a70210e997ed0", "filename": "compiler/rustc_middle/src/lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cebd2dda1d9071f2209079370c412f4ef9ef2b82/compiler%2Frustc_middle%2Fsrc%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebd2dda1d9071f2209079370c412f4ef9ef2b82/compiler%2Frustc_middle%2Fsrc%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flint.rs?ref=cebd2dda1d9071f2209079370c412f4ef9ef2b82", "patch": "@@ -395,7 +395,7 @@ pub fn in_external_macro(sess: &Session, span: Span) -> bool {\n     match expn_data.kind {\n         ExpnKind::Inlined\n         | ExpnKind::Root\n-        | ExpnKind::Desugaring(DesugaringKind::ForLoop(_) | DesugaringKind::WhileLoop) => false,\n+        | ExpnKind::Desugaring(DesugaringKind::ForLoop | DesugaringKind::WhileLoop) => false,\n         ExpnKind::AstPass(_) | ExpnKind::Desugaring(_) => true, // well, it's \"external\"\n         ExpnKind::Macro(MacroKind::Bang, _) => {\n             // Dummy span for the `def_site` means it's an external macro."}, {"sha": "d74c53fae533b425eac31501a70a6240edf2a825", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/cebd2dda1d9071f2209079370c412f4ef9ef2b82/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebd2dda1d9071f2209079370c412f4ef9ef2b82/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=cebd2dda1d9071f2209079370c412f4ef9ef2b82", "patch": "@@ -74,19 +74,16 @@ impl<'tcx> Visitor<'tcx> for MatchVisitor<'_, '_, 'tcx> {\n \n         let (msg, sp) = match loc.source {\n             hir::LocalSource::Normal => (\"local binding\", Some(loc.span)),\n-            hir::LocalSource::ForLoopDesugar => (\"`for` loop binding\", None),\n             hir::LocalSource::AsyncFn => (\"async fn binding\", None),\n             hir::LocalSource::AwaitDesugar => (\"`await` future binding\", None),\n             hir::LocalSource::AssignDesugar(_) => (\"destructuring assignment binding\", None),\n         };\n         self.check_irrefutable(&loc.pat, msg, sp);\n-        self.check_patterns(&loc.pat, Irrefutable);\n     }\n \n     fn visit_param(&mut self, param: &'tcx hir::Param<'tcx>) {\n         intravisit::walk_param(self, param);\n         self.check_irrefutable(&param.pat, \"function argument\", None);\n-        self.check_patterns(&param.pat, Irrefutable);\n     }\n }\n \n@@ -161,12 +158,12 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n     fn check_match(\n         &mut self,\n         scrut: &hir::Expr<'_>,\n-        arms: &'tcx [hir::Arm<'tcx>],\n+        hir_arms: &'tcx [hir::Arm<'tcx>],\n         source: hir::MatchSource,\n     ) {\n         let mut cx = self.new_cx(scrut.hir_id);\n \n-        for arm in arms {\n+        for arm in hir_arms {\n             // Check the arm for some things unrelated to exhaustiveness.\n             self.check_patterns(&arm.pat, Refutable);\n             if let Some(hir::Guard::IfLet(ref pat, _)) = arm.guard {\n@@ -178,7 +175,7 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n \n         let mut have_errors = false;\n \n-        let arms: Vec<_> = arms\n+        let arms: Vec<_> = hir_arms\n             .iter()\n             .map(|hir::Arm { pat, guard, .. }| MatchArm {\n                 pat: self.lower_pattern(&mut cx, pat, &mut have_errors),\n@@ -196,6 +193,9 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n         let report = compute_match_usefulness(&cx, &arms, scrut.hir_id, scrut_ty);\n \n         match source {\n+            // Don't report arm reachability of desugared `match $iter.into_iter() { iter => .. }`\n+            // when the iterator is an uninhabited type. unreachable_code will trigger instead.\n+            hir::MatchSource::ForLoopDesugar if arms.len() == 1 => {}\n             hir::MatchSource::ForLoopDesugar | hir::MatchSource::Normal => {\n                 report_arm_reachability(&cx, &report)\n             }\n@@ -208,7 +208,13 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n         let is_empty_match = arms.is_empty();\n         let witnesses = report.non_exhaustiveness_witnesses;\n         if !witnesses.is_empty() {\n-            non_exhaustive_match(&cx, scrut_ty, scrut.span, witnesses, is_empty_match);\n+            if source == hir::MatchSource::ForLoopDesugar && hir_arms.len() == 2 {\n+                // the for loop pattern is not irrefutable\n+                let pat = hir_arms[1].pat.for_loop_some().unwrap();\n+                self.check_irrefutable(pat, \"`for` loop binding\", None);\n+            } else {\n+                non_exhaustive_match(&cx, scrut_ty, scrut.span, witnesses, is_empty_match);\n+            }\n         }\n     }\n \n@@ -225,6 +231,7 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n         let witnesses = report.non_exhaustiveness_witnesses;\n         if witnesses.is_empty() {\n             // The pattern is irrefutable.\n+            self.check_patterns(pat, Irrefutable);\n             return;\n         }\n "}, {"sha": "d590776676bef53dd3067f5bc6b542a0c21fcefd", "filename": "compiler/rustc_span/src/hygiene.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cebd2dda1d9071f2209079370c412f4ef9ef2b82/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebd2dda1d9071f2209079370c412f4ef9ef2b82/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs?ref=cebd2dda1d9071f2209079370c412f4ef9ef2b82", "patch": "@@ -1099,18 +1099,11 @@ pub enum DesugaringKind {\n     OpaqueTy,\n     Async,\n     Await,\n-    ForLoop(ForLoopLoc),\n+    ForLoop,\n     LetElse,\n     WhileLoop,\n }\n \n-/// A location in the desugaring of a `for` loop\n-#[derive(Clone, Copy, PartialEq, Debug, Encodable, Decodable, HashStable_Generic)]\n-pub enum ForLoopLoc {\n-    Head,\n-    IntoIter,\n-}\n-\n impl DesugaringKind {\n     /// The description wording should combine well with \"desugaring of {}\".\n     pub fn descr(self) -> &'static str {\n@@ -1121,7 +1114,7 @@ impl DesugaringKind {\n             DesugaringKind::QuestionMark => \"operator `?`\",\n             DesugaringKind::TryBlock => \"`try` block\",\n             DesugaringKind::OpaqueTy => \"`impl Trait`\",\n-            DesugaringKind::ForLoop(_) => \"`for` loop\",\n+            DesugaringKind::ForLoop => \"`for` loop\",\n             DesugaringKind::LetElse => \"`let...else`\",\n             DesugaringKind::WhileLoop => \"`while` loop\",\n         }"}, {"sha": "66c01140abc17e1e8c1360f92633933cb4931f3f", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cebd2dda1d9071f2209079370c412f4ef9ef2b82/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebd2dda1d9071f2209079370c412f4ef9ef2b82/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=cebd2dda1d9071f2209079370c412f4ef9ef2b82", "patch": "@@ -41,7 +41,7 @@ pub mod edition;\n use edition::Edition;\n pub mod hygiene;\n use hygiene::Transparency;\n-pub use hygiene::{DesugaringKind, ExpnKind, ForLoopLoc, MacroKind};\n+pub use hygiene::{DesugaringKind, ExpnKind, MacroKind};\n pub use hygiene::{ExpnData, ExpnHash, ExpnId, LocalExpnId, SyntaxContext};\n pub mod def_id;\n use def_id::{CrateNum, DefId, DefPathHash, LocalDefId, LOCAL_CRATE};"}, {"sha": "0d556b5eda609133fe988d581b51d0dee208a6f4", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cebd2dda1d9071f2209079370c412f4ef9ef2b82/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebd2dda1d9071f2209079370c412f4ef9ef2b82/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=cebd2dda1d9071f2209079370c412f4ef9ef2b82", "patch": "@@ -269,7 +269,6 @@ symbols! {\n         __D,\n         __H,\n         __S,\n-        __next,\n         __try_var,\n         _args,\n         _d,"}, {"sha": "a90140a9b50b924ded3a3ec7e52e5c2b3bbbcb45", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cebd2dda1d9071f2209079370c412f4ef9ef2b82/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebd2dda1d9071f2209079370c412f4ef9ef2b82/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=cebd2dda1d9071f2209079370c412f4ef9ef2b82", "patch": "@@ -27,7 +27,7 @@ use rustc_middle::ty::{TypeAndMut, TypeckResults};\n use rustc_session::Limit;\n use rustc_span::def_id::LOCAL_CRATE;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n-use rustc_span::{BytePos, DesugaringKind, ExpnKind, ForLoopLoc, MultiSpan, Span, DUMMY_SP};\n+use rustc_span::{BytePos, DesugaringKind, ExpnKind, MultiSpan, Span, DUMMY_SP};\n use rustc_target::spec::abi;\n use std::fmt;\n \n@@ -685,7 +685,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             &obligation.cause.code\n         {\n             parent_code.clone()\n-        } else if let ExpnKind::Desugaring(DesugaringKind::ForLoop(ForLoopLoc::IntoIter)) =\n+        } else if let ExpnKind::Desugaring(DesugaringKind::ForLoop) =\n             span.ctxt().outer_expn_data().kind\n         {\n             Lrc::new(obligation.cause.code.clone())\n@@ -765,8 +765,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     // This if is to prevent a special edge-case\n                     if matches!(\n                         span.ctxt().outer_expn_data().kind,\n-                        ExpnKind::Root\n-                            | ExpnKind::Desugaring(DesugaringKind::ForLoop(ForLoopLoc::IntoIter))\n+                        ExpnKind::Root | ExpnKind::Desugaring(DesugaringKind::ForLoop)\n                     ) {\n                         // We don't want a borrowing suggestion on the fields in structs,\n                         // ```"}, {"sha": "a370485102e35a85cafaf6cd6b0f505016a2d072", "filename": "library/std/src/keyword_docs.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cebd2dda1d9071f2209079370c412f4ef9ef2b82/library%2Fstd%2Fsrc%2Fkeyword_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebd2dda1d9071f2209079370c412f4ef9ef2b82/library%2Fstd%2Fsrc%2Fkeyword_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fkeyword_docs.rs?ref=cebd2dda1d9071f2209079370c412f4ef9ef2b82", "patch": "@@ -549,13 +549,10 @@ mod fn_keyword {}\n /// {\n ///     let result = match IntoIterator::into_iter(iterator) {\n ///         mut iter => loop {\n-///             let next;\n ///             match iter.next() {\n-///                 Some(val) => next = val,\n ///                 None => break,\n+///                 Some(loop_variable) => { code(); },\n ///             };\n-///             let loop_variable = next;\n-///             let () = { code(); };\n ///         },\n ///     };\n ///     result"}, {"sha": "d3687d5b9081ea28b01063a37a41f565b9257b04", "filename": "src/test/incremental/hashes/for_loops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cebd2dda1d9071f2209079370c412f4ef9ef2b82/src%2Ftest%2Fincremental%2Fhashes%2Ffor_loops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebd2dda1d9071f2209079370c412f4ef9ef2b82/src%2Ftest%2Fincremental%2Fhashes%2Ffor_loops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Ffor_loops.rs?ref=cebd2dda1d9071f2209079370c412f4ef9ef2b82", "patch": "@@ -183,7 +183,7 @@ pub fn add_loop_label_to_break() {\n #[cfg(not(any(cfail1,cfail4)))]\n #[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes\")]\n #[rustc_clean(cfg=\"cfail3\")]\n-#[rustc_clean(cfg=\"cfail5\", except=\"hir_owner_nodes\")]\n+#[rustc_clean(cfg=\"cfail5\", except=\"hir_owner_nodes, optimized_mir\")]\n #[rustc_clean(cfg=\"cfail6\")]\n pub fn add_loop_label_to_break() {\n     let mut _x = 0;"}, {"sha": "2dfc94f21868e149049e70df81fd68b84b875663", "filename": "src/test/mir-opt/remove_storage_markers.main.RemoveStorageMarkers.diff", "status": "modified", "additions": 46, "deletions": 69, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/cebd2dda1d9071f2209079370c412f4ef9ef2b82/src%2Ftest%2Fmir-opt%2Fremove_storage_markers.main.RemoveStorageMarkers.diff", "raw_url": "https://github.com/rust-lang/rust/raw/cebd2dda1d9071f2209079370c412f4ef9ef2b82/src%2Ftest%2Fmir-opt%2Fremove_storage_markers.main.RemoveStorageMarkers.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fremove_storage_markers.main.RemoveStorageMarkers.diff?ref=cebd2dda1d9071f2209079370c412f4ef9ef2b82", "patch": "@@ -7,39 +7,29 @@\n       let mut _2: std::ops::Range<i32>;    // in scope 0 at $DIR/remove_storage_markers.rs:8:14: 8:19\n       let mut _3: std::ops::Range<i32>;    // in scope 0 at $DIR/remove_storage_markers.rs:8:14: 8:19\n       let mut _5: ();                      // in scope 0 at $DIR/remove_storage_markers.rs:6:1: 11:2\n-      let _7: ();                          // in scope 0 at $DIR/remove_storage_markers.rs:8:14: 8:19\n-      let mut _8: std::option::Option<i32>; // in scope 0 at $DIR/remove_storage_markers.rs:8:14: 8:19\n+      let _6: ();                          // in scope 0 at $DIR/remove_storage_markers.rs:8:14: 8:19\n+      let mut _7: std::option::Option<i32>; // in scope 0 at $DIR/remove_storage_markers.rs:8:14: 8:19\n+      let mut _8: &mut std::ops::Range<i32>; // in scope 0 at $DIR/remove_storage_markers.rs:8:14: 8:19\n       let mut _9: &mut std::ops::Range<i32>; // in scope 0 at $DIR/remove_storage_markers.rs:8:14: 8:19\n-      let mut _10: &mut std::ops::Range<i32>; // in scope 0 at $DIR/remove_storage_markers.rs:8:14: 8:19\n-      let mut _11: isize;                  // in scope 0 at $DIR/remove_storage_markers.rs:8:9: 8:10\n-      let mut _13: i32;                    // in scope 0 at $DIR/remove_storage_markers.rs:8:9: 8:10\n-      let mut _14: !;                      // in scope 0 at $DIR/remove_storage_markers.rs:8:5: 10:6\n-      let _16: ();                         // in scope 0 at $DIR/remove_storage_markers.rs:8:20: 10:6\n-      let mut _17: i32;                    // in scope 0 at $DIR/remove_storage_markers.rs:9:16: 9:17\n+      let mut _10: isize;                  // in scope 0 at $DIR/remove_storage_markers.rs:8:5: 10:6\n+      let mut _11: !;                      // in scope 0 at $DIR/remove_storage_markers.rs:8:5: 10:6\n+      let mut _13: i32;                    // in scope 0 at $DIR/remove_storage_markers.rs:9:16: 9:17\n       scope 1 {\n           debug sum => _1;                 // in scope 1 at $DIR/remove_storage_markers.rs:7:9: 7:16\n           let mut _4: std::ops::Range<i32>; // in scope 1 at $DIR/remove_storage_markers.rs:8:14: 8:19\n           scope 2 {\n               debug iter => _4;            // in scope 2 at $DIR/remove_storage_markers.rs:8:14: 8:19\n-              let mut _6: i32;             // in scope 2 at $DIR/remove_storage_markers.rs:8:14: 8:19\n+              let _12: i32;                // in scope 2 at $DIR/remove_storage_markers.rs:8:9: 8:10\n               scope 3 {\n-                  debug __next => _6;      // in scope 3 at $DIR/remove_storage_markers.rs:8:14: 8:19\n-                  let _12: i32;            // in scope 3 at $DIR/remove_storage_markers.rs:8:9: 8:10\n-                  let _15: i32;            // in scope 3 at $DIR/remove_storage_markers.rs:8:9: 8:10\n-                  scope 4 {\n-                      debug val => _12;    // in scope 4 at $DIR/remove_storage_markers.rs:8:9: 8:10\n-                  }\n-                  scope 5 {\n-                      debug i => _15;      // in scope 5 at $DIR/remove_storage_markers.rs:8:9: 8:10\n-                  }\n-                  scope 7 (inlined iter::range::<impl Iterator for std::ops::Range<i32>>::next) { // at $DIR/remove_storage_markers.rs:8:14: 8:19\n-                      debug self => _9;    // in scope 7 at $DIR/remove_storage_markers.rs:8:14: 8:19\n-                      let mut _18: &mut std::ops::Range<i32>; // in scope 7 at $DIR/remove_storage_markers.rs:8:14: 8:19\n-                  }\n+                  debug i => _12;          // in scope 3 at $DIR/remove_storage_markers.rs:8:9: 8:10\n+              }\n+              scope 5 (inlined iter::range::<impl Iterator for std::ops::Range<i32>>::next) { // at $DIR/remove_storage_markers.rs:8:14: 8:19\n+                  debug self => _8;        // in scope 5 at $DIR/remove_storage_markers.rs:8:14: 8:19\n+                  let mut _14: &mut std::ops::Range<i32>; // in scope 5 at $DIR/remove_storage_markers.rs:8:14: 8:19\n               }\n           }\n-          scope 6 (inlined <std::ops::Range<i32> as IntoIterator>::into_iter) { // at $DIR/remove_storage_markers.rs:8:14: 8:19\n-              debug self => _3;            // in scope 6 at $DIR/remove_storage_markers.rs:8:14: 8:19\n+          scope 4 (inlined <std::ops::Range<i32> as IntoIterator>::into_iter) { // at $DIR/remove_storage_markers.rs:8:14: 8:19\n+              debug self => _3;            // in scope 4 at $DIR/remove_storage_markers.rs:8:14: 8:19\n           }\n       }\n   \n@@ -50,7 +40,7 @@\n -         StorageLive(_3);                 // scope 1 at $DIR/remove_storage_markers.rs:8:14: 8:19\n           (_3.0: i32) = const 0_i32;       // scope 1 at $DIR/remove_storage_markers.rs:8:14: 8:19\n           (_3.1: i32) = const 10_i32;      // scope 1 at $DIR/remove_storage_markers.rs:8:14: 8:19\n-          _2 = move _3;                    // scope 6 at $DIR/remove_storage_markers.rs:8:14: 8:19\n+          _2 = move _3;                    // scope 4 at $DIR/remove_storage_markers.rs:8:14: 8:19\n -         StorageDead(_3);                 // scope 1 at $DIR/remove_storage_markers.rs:8:18: 8:19\n -         StorageLive(_4);                 // scope 1 at $DIR/remove_storage_markers.rs:8:14: 8:19\n           _4 = move _2;                    // scope 1 at $DIR/remove_storage_markers.rs:8:14: 8:19\n@@ -59,64 +49,51 @@\n   \n       bb1: {\n -         StorageLive(_6);                 // scope 2 at $DIR/remove_storage_markers.rs:8:14: 8:19\n--         StorageLive(_7);                 // scope 3 at $DIR/remove_storage_markers.rs:8:14: 8:19\n--         StorageLive(_8);                 // scope 3 at $DIR/remove_storage_markers.rs:8:14: 8:19\n--         StorageLive(_9);                 // scope 3 at $DIR/remove_storage_markers.rs:8:14: 8:19\n--         StorageLive(_10);                // scope 3 at $DIR/remove_storage_markers.rs:8:14: 8:19\n-          _10 = &mut _4;                   // scope 3 at $DIR/remove_storage_markers.rs:8:14: 8:19\n-          _9 = &mut (*_10);                // scope 3 at $DIR/remove_storage_markers.rs:8:14: 8:19\n--         StorageLive(_18);                // scope 7 at $DIR/remove_storage_markers.rs:8:14: 8:19\n-          _18 = &mut (*_9);                // scope 7 at $DIR/remove_storage_markers.rs:8:14: 8:19\n-          _8 = <std::ops::Range<i32> as iter::range::RangeIteratorImpl>::spec_next(move _18) -> bb4; // scope 7 at $DIR/remove_storage_markers.rs:8:14: 8:19\n+-         StorageLive(_7);                 // scope 2 at $DIR/remove_storage_markers.rs:8:14: 8:19\n+-         StorageLive(_8);                 // scope 2 at $DIR/remove_storage_markers.rs:8:14: 8:19\n+-         StorageLive(_9);                 // scope 2 at $DIR/remove_storage_markers.rs:8:14: 8:19\n+          _9 = &mut _4;                    // scope 2 at $DIR/remove_storage_markers.rs:8:14: 8:19\n+          _8 = &mut (*_9);                 // scope 2 at $DIR/remove_storage_markers.rs:8:14: 8:19\n+-         StorageLive(_14);                // scope 5 at $DIR/remove_storage_markers.rs:8:14: 8:19\n+          _14 = &mut (*_8);                // scope 5 at $DIR/remove_storage_markers.rs:8:14: 8:19\n+          _7 = <std::ops::Range<i32> as iter::range::RangeIteratorImpl>::spec_next(move _14) -> bb4; // scope 5 at $DIR/remove_storage_markers.rs:8:14: 8:19\n                                            // mir::Constant\n                                            // + span: $DIR/remove_storage_markers.rs:8:14: 8:19\n                                            // + literal: Const { ty: for<'r> fn(&'r mut std::ops::Range<i32>) -> std::option::Option<<std::ops::Range<i32> as std::iter::range::RangeIteratorImpl>::Item> {<std::ops::Range<i32> as std::iter::range::RangeIteratorImpl>::spec_next}, val: Value(Scalar(<ZST>)) }\n       }\n   \n       bb2: {\n-          _0 = const ();                   // scope 3 at $DIR/remove_storage_markers.rs:8:5: 10:6\n--         StorageDead(_10);                // scope 3 at $DIR/remove_storage_markers.rs:8:18: 8:19\n--         StorageDead(_8);                 // scope 3 at $DIR/remove_storage_markers.rs:8:18: 8:19\n--         StorageDead(_7);                 // scope 3 at $DIR/remove_storage_markers.rs:8:18: 8:19\n+-         StorageLive(_12);                // scope 2 at $DIR/remove_storage_markers.rs:8:9: 8:10\n+          _12 = ((_7 as Some).0: i32);     // scope 2 at $DIR/remove_storage_markers.rs:8:9: 8:10\n+-         StorageLive(_13);                // scope 3 at $DIR/remove_storage_markers.rs:9:16: 9:17\n+          _13 = _12;                       // scope 3 at $DIR/remove_storage_markers.rs:9:16: 9:17\n+          _1 = Add(_1, move _13);          // scope 3 at $DIR/remove_storage_markers.rs:9:9: 9:17\n+-         StorageDead(_13);                // scope 3 at $DIR/remove_storage_markers.rs:9:16: 9:17\n+          _6 = const ();                   // scope 3 at $DIR/remove_storage_markers.rs:8:20: 10:6\n+-         StorageDead(_12);                // scope 2 at $DIR/remove_storage_markers.rs:10:5: 10:6\n+-         StorageDead(_9);                 // scope 2 at $DIR/remove_storage_markers.rs:10:5: 10:6\n+-         StorageDead(_7);                 // scope 2 at $DIR/remove_storage_markers.rs:10:5: 10:6\n -         StorageDead(_6);                 // scope 2 at $DIR/remove_storage_markers.rs:10:5: 10:6\n--         StorageDead(_4);                 // scope 1 at $DIR/remove_storage_markers.rs:10:5: 10:6\n--         StorageDead(_2);                 // scope 1 at $DIR/remove_storage_markers.rs:10:5: 10:6\n--         StorageDead(_1);                 // scope 0 at $DIR/remove_storage_markers.rs:11:1: 11:2\n-          return;                          // scope 0 at $DIR/remove_storage_markers.rs:11:2: 11:2\n+          _5 = const ();                   // scope 2 at $DIR/remove_storage_markers.rs:8:5: 10:6\n+          goto -> bb1;                     // scope 2 at $DIR/remove_storage_markers.rs:8:5: 10:6\n       }\n   \n       bb3: {\n--         StorageLive(_12);                // scope 3 at $DIR/remove_storage_markers.rs:8:9: 8:10\n-          _12 = ((_8 as Some).0: i32);     // scope 3 at $DIR/remove_storage_markers.rs:8:9: 8:10\n--         StorageLive(_13);                // scope 4 at $DIR/remove_storage_markers.rs:8:9: 8:10\n-          _13 = _12;                       // scope 4 at $DIR/remove_storage_markers.rs:8:9: 8:10\n-          _6 = move _13;                   // scope 4 at $DIR/remove_storage_markers.rs:8:9: 8:10\n-          _7 = const ();                   // scope 4 at $DIR/remove_storage_markers.rs:8:9: 8:10\n--         StorageDead(_13);                // scope 4 at $DIR/remove_storage_markers.rs:8:9: 8:10\n--         StorageDead(_12);                // scope 3 at $DIR/remove_storage_markers.rs:8:9: 8:10\n--         StorageDead(_10);                // scope 3 at $DIR/remove_storage_markers.rs:8:18: 8:19\n--         StorageDead(_8);                 // scope 3 at $DIR/remove_storage_markers.rs:8:18: 8:19\n--         StorageDead(_7);                 // scope 3 at $DIR/remove_storage_markers.rs:8:18: 8:19\n--         StorageLive(_15);                // scope 3 at $DIR/remove_storage_markers.rs:8:9: 8:10\n-          _15 = _6;                        // scope 3 at $DIR/remove_storage_markers.rs:8:14: 8:19\n--         StorageLive(_16);                // scope 5 at $DIR/remove_storage_markers.rs:8:20: 10:6\n--         StorageLive(_17);                // scope 5 at $DIR/remove_storage_markers.rs:9:16: 9:17\n-          _17 = _15;                       // scope 5 at $DIR/remove_storage_markers.rs:9:16: 9:17\n-          _1 = Add(_1, move _17);          // scope 5 at $DIR/remove_storage_markers.rs:9:9: 9:17\n--         StorageDead(_17);                // scope 5 at $DIR/remove_storage_markers.rs:9:16: 9:17\n-          _16 = const ();                  // scope 5 at $DIR/remove_storage_markers.rs:8:20: 10:6\n--         StorageDead(_16);                // scope 5 at $DIR/remove_storage_markers.rs:10:5: 10:6\n-          _5 = const ();                   // scope 2 at $DIR/remove_storage_markers.rs:8:5: 10:6\n--         StorageDead(_15);                // scope 3 at $DIR/remove_storage_markers.rs:10:5: 10:6\n+          _0 = const ();                   // scope 2 at $DIR/remove_storage_markers.rs:8:5: 10:6\n+-         StorageDead(_9);                 // scope 2 at $DIR/remove_storage_markers.rs:10:5: 10:6\n+-         StorageDead(_7);                 // scope 2 at $DIR/remove_storage_markers.rs:10:5: 10:6\n -         StorageDead(_6);                 // scope 2 at $DIR/remove_storage_markers.rs:10:5: 10:6\n-          goto -> bb1;                     // scope 2 at $DIR/remove_storage_markers.rs:8:5: 10:6\n+-         StorageDead(_4);                 // scope 1 at $DIR/remove_storage_markers.rs:10:5: 10:6\n+-         StorageDead(_2);                 // scope 1 at $DIR/remove_storage_markers.rs:10:5: 10:6\n+-         StorageDead(_1);                 // scope 0 at $DIR/remove_storage_markers.rs:11:1: 11:2\n+          return;                          // scope 0 at $DIR/remove_storage_markers.rs:11:2: 11:2\n       }\n   \n       bb4: {\n--         StorageDead(_18);                // scope 7 at $DIR/remove_storage_markers.rs:8:14: 8:19\n--         StorageDead(_9);                 // scope 3 at $DIR/remove_storage_markers.rs:8:18: 8:19\n-          _11 = discriminant(_8);          // scope 3 at $DIR/remove_storage_markers.rs:8:14: 8:19\n-          switchInt(move _11) -> [0_isize: bb2, otherwise: bb3]; // scope 3 at $DIR/remove_storage_markers.rs:8:14: 8:19\n+-         StorageDead(_14);                // scope 5 at $DIR/remove_storage_markers.rs:8:14: 8:19\n+-         StorageDead(_8);                 // scope 2 at $DIR/remove_storage_markers.rs:8:18: 8:19\n+          _10 = discriminant(_7);          // scope 2 at $DIR/remove_storage_markers.rs:8:14: 8:19\n+          switchInt(move _10) -> [0_isize: bb3, otherwise: bb2]; // scope 2 at $DIR/remove_storage_markers.rs:8:14: 8:19\n       }\n   }\n   "}, {"sha": "1c64ead9f2674e37fb967968434ad7b4a0bcf9d4", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.continue.txt", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cebd2dda1d9071f2209079370c412f4ef9ef2b82/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.continue.txt", "raw_url": "https://github.com/rust-lang/rust/raw/cebd2dda1d9071f2209079370c412f4ef9ef2b82/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.continue.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.continue.txt?ref=cebd2dda1d9071f2209079370c412f4ef9ef2b82", "patch": "@@ -5,7 +5,6 @@\n     5|      1|\n     6|      1|    let mut x = 0;\n     7|     11|    for _ in 0..10 {\n-                      ^10\n     8|     10|        match is_true {\n     9|       |            true => {\n    10|     10|                continue;\n@@ -17,7 +16,6 @@\n    16|      0|        x = 3;\n    17|       |    }\n    18|     11|    for _ in 0..10 {\n-                      ^10\n    19|     10|        match is_true {\n    20|      0|            false => {\n    21|      0|                x = 1;\n@@ -29,7 +27,6 @@\n    27|      0|        x = 3;\n    28|       |    }\n    29|     11|    for _ in 0..10 {\n-                      ^10\n    30|     10|        match is_true {\n    31|     10|            true => {\n    32|     10|                x = 1;\n@@ -41,14 +38,12 @@\n    38|     10|        x = 3;\n    39|       |    }\n    40|     11|    for _ in 0..10 {\n-                      ^10\n    41|     10|        if is_true {\n    42|     10|            continue;\n    43|      0|        }\n    44|      0|        x = 3;\n    45|       |    }\n    46|     11|    for _ in 0..10 {\n-                      ^10\n    47|     10|        match is_true {\n    48|      0|            false => {\n    49|      0|                x = 1;"}, {"sha": "6f5d1544fa0349c9ada9952fc61de41e064fed63", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.inline.txt", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cebd2dda1d9071f2209079370c412f4ef9ef2b82/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.inline.txt", "raw_url": "https://github.com/rust-lang/rust/raw/cebd2dda1d9071f2209079370c412f4ef9ef2b82/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.inline.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.inline.txt?ref=cebd2dda1d9071f2209079370c412f4ef9ef2b82", "patch": "@@ -40,7 +40,8 @@\n    39|     30|}\n    40|       |\n    41|      6|fn display<T: Display>(xs: &[T]) {\n-   42|     18|    for x in xs {\n+   42|     24|    for x in xs {\n+                      ^18\n    43|     18|        print!(\"{}\", x);\n    44|     18|    }\n    45|      6|    println!();"}, {"sha": "b7ad79a24844c665ddfe7d59eae60c97cb89278e", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.loops_branches.txt", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cebd2dda1d9071f2209079370c412f4ef9ef2b82/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.loops_branches.txt", "raw_url": "https://github.com/rust-lang/rust/raw/cebd2dda1d9071f2209079370c412f4ef9ef2b82/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.loops_branches.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.loops_branches.txt?ref=cebd2dda1d9071f2209079370c412f4ef9ef2b82", "patch": "@@ -17,7 +17,8 @@\n    16|      0|        } else {\n    17|      0|        }\n    18|       |\n-   19|     10|        for i in 0..10 {\n+   19|     11|        for i in 0..10 {\n+                          ^10\n    20|     10|            if true {\n    21|     10|                if false {\n    22|      0|                    while true {}\n@@ -43,7 +44,8 @@\n    41|      1|            write!(f, \"cool\")?;\n                                            ^0\n    42|       |        }\n-   43|     10|        for i in 0..10 {\n+   43|     11|        for i in 0..10 {\n+                          ^10\n    44|     10|            if false {\n    45|      0|            } else {\n    46|     10|                if false {"}, {"sha": "b9298213111c028739af4468b03f4bca26eb815e", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.simple_match.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cebd2dda1d9071f2209079370c412f4ef9ef2b82/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.simple_match.txt", "raw_url": "https://github.com/rust-lang/rust/raw/cebd2dda1d9071f2209079370c412f4ef9ef2b82/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.simple_match.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.simple_match.txt?ref=cebd2dda1d9071f2209079370c412f4ef9ef2b82", "patch": "@@ -13,7 +13,7 @@\n                    ^0\n    13|       |\n    14|       |    for\n-   15|      2|        _\n+   15|       |        _\n    16|       |    in\n    17|      3|        0..2\n    18|       |    {"}, {"sha": "0ad0180b76149852c16287ebc32740191359020c", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.try_error_result.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cebd2dda1d9071f2209079370c412f4ef9ef2b82/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.try_error_result.txt", "raw_url": "https://github.com/rust-lang/rust/raw/cebd2dda1d9071f2209079370c412f4ef9ef2b82/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.try_error_result.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.try_error_result.txt?ref=cebd2dda1d9071f2209079370c412f4ef9ef2b82", "patch": "@@ -14,7 +14,7 @@\n    14|      1|        countdown = 10\n    15|       |    ;\n    16|       |    for\n-   17|      6|        _\n+   17|       |        _\n    18|       |    in\n    19|      6|        0..10\n    20|       |    {\n@@ -64,7 +64,7 @@\n    63|      1|        countdown = 10\n    64|       |    ;\n    65|       |    for\n-   66|      6|        _\n+   66|       |        _\n    67|       |    in\n    68|      6|        0..10\n    69|       |    {"}, {"sha": "c6643edf5a9547f2f6393e4f3df30ccde3142b02", "filename": "src/test/ui/borrowck/return-local-binding-from-desugaring.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cebd2dda1d9071f2209079370c412f4ef9ef2b82/src%2Ftest%2Fui%2Fborrowck%2Freturn-local-binding-from-desugaring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebd2dda1d9071f2209079370c412f4ef9ef2b82/src%2Ftest%2Fui%2Fborrowck%2Freturn-local-binding-from-desugaring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Freturn-local-binding-from-desugaring.rs?ref=cebd2dda1d9071f2209079370c412f4ef9ef2b82", "patch": "@@ -27,7 +27,7 @@ where\n         let key = f(x);\n         result.entry(key).or_insert(Vec::new()).push(x);\n     }\n-    result //~ ERROR cannot return value referencing local binding\n+    result //~ ERROR cannot return value referencing temporary value\n }\n \n fn main() {}"}, {"sha": "9f952542e18b0348c5b1c7bc113afb00e1e5fac1", "filename": "src/test/ui/borrowck/return-local-binding-from-desugaring.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cebd2dda1d9071f2209079370c412f4ef9ef2b82/src%2Ftest%2Fui%2Fborrowck%2Freturn-local-binding-from-desugaring.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cebd2dda1d9071f2209079370c412f4ef9ef2b82/src%2Ftest%2Fui%2Fborrowck%2Freturn-local-binding-from-desugaring.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Freturn-local-binding-from-desugaring.stderr?ref=cebd2dda1d9071f2209079370c412f4ef9ef2b82", "patch": "@@ -1,8 +1,8 @@\n-error[E0515]: cannot return value referencing local binding\n+error[E0515]: cannot return value referencing temporary value\n   --> $DIR/return-local-binding-from-desugaring.rs:30:5\n    |\n LL |     for ref x in xs {\n-   |                  -- local binding introduced here\n+   |                  -- temporary value created here\n ...\n LL |     result\n    |     ^^^^^^ returns a value referencing data owned by the current function"}, {"sha": "580b135ac2d712fdff96b5cc299c226f74f48c6b", "filename": "src/test/ui/for/for-loop-unconstrained-element-type.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cebd2dda1d9071f2209079370c412f4ef9ef2b82/src%2Ftest%2Fui%2Ffor%2Ffor-loop-unconstrained-element-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cebd2dda1d9071f2209079370c412f4ef9ef2b82/src%2Ftest%2Fui%2Ffor%2Ffor-loop-unconstrained-element-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffor%2Ffor-loop-unconstrained-element-type.stderr?ref=cebd2dda1d9071f2209079370c412f4ef9ef2b82", "patch": "@@ -1,8 +1,10 @@\n error[E0282]: type annotations needed\n-  --> $DIR/for-loop-unconstrained-element-type.rs:8:14\n+  --> $DIR/for-loop-unconstrained-element-type.rs:8:9\n    |\n LL |     for i in Vec::new() { }\n-   |              ^^^^^^^^^^ the element type for this iterator is not specified\n+   |         ^    ---------- the element type for this iterator is not specified\n+   |         |\n+   |         cannot infer type\n \n error: aborting due to previous error\n "}, {"sha": "6330364c92b6a68e62061c3dc46c31f5ef4dfe4b", "filename": "src/test/ui/issues/issue-20261.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cebd2dda1d9071f2209079370c412f4ef9ef2b82/src%2Ftest%2Fui%2Fissues%2Fissue-20261.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cebd2dda1d9071f2209079370c412f4ef9ef2b82/src%2Ftest%2Fui%2Fissues%2Fissue-20261.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-20261.stderr?ref=cebd2dda1d9071f2209079370c412f4ef9ef2b82", "patch": "@@ -1,8 +1,8 @@\n-error[E0282]: type annotations needed for `&(_,)`\n+error[E0282]: type annotations needed for `(_,)`\n   --> $DIR/issue-20261.rs:4:11\n    |\n LL |     for (ref i,) in [].iter() {\n-   |                     --------- the element type for this iterator is not specified\n+   |                     --------- this method call resolves to `std::slice::Iter<'_, T>`\n LL |         i.clone();\n    |           ^^^^^ cannot infer type\n    |"}, {"sha": "ccaa6334856b45f55487e44c1301abdd1d7b83a9", "filename": "src/test/ui/issues/issue-33941.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cebd2dda1d9071f2209079370c412f4ef9ef2b82/src%2Ftest%2Fui%2Fissues%2Fissue-33941.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebd2dda1d9071f2209079370c412f4ef9ef2b82/src%2Ftest%2Fui%2Fissues%2Fissue-33941.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-33941.rs?ref=cebd2dda1d9071f2209079370c412f4ef9ef2b82", "patch": "@@ -3,5 +3,4 @@ use std::collections::HashMap;\n fn main() {\n     for _ in HashMap::new().iter().cloned() {} //~ ERROR type mismatch\n     //~^ ERROR type mismatch\n-    //~| ERROR type mismatch\n }"}, {"sha": "eb98a3a29a6981ff524fde56a9dba6abae84d5b8", "filename": "src/test/ui/issues/issue-33941.stderr", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cebd2dda1d9071f2209079370c412f4ef9ef2b82/src%2Ftest%2Fui%2Fissues%2Fissue-33941.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cebd2dda1d9071f2209079370c412f4ef9ef2b82/src%2Ftest%2Fui%2Fissues%2Fissue-33941.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-33941.stderr?ref=cebd2dda1d9071f2209079370c412f4ef9ef2b82", "patch": "@@ -23,16 +23,6 @@ LL |     for _ in HashMap::new().iter().cloned() {}\n    = note: required because of the requirements on the impl of `Iterator` for `Cloned<std::collections::hash_map::Iter<'_, _, _>>`\n    = note: required because of the requirements on the impl of `IntoIterator` for `Cloned<std::collections::hash_map::Iter<'_, _, _>>`\n \n-error[E0271]: type mismatch resolving `<std::collections::hash_map::Iter<'_, _, _> as Iterator>::Item == &_`\n-  --> $DIR/issue-33941.rs:4:14\n-   |\n-LL |     for _ in HashMap::new().iter().cloned() {}\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected reference, found tuple\n-   |\n-   = note: expected reference `&_`\n-                  found tuple `(&_, &_)`\n-   = note: required because of the requirements on the impl of `Iterator` for `Cloned<std::collections::hash_map::Iter<'_, _, _>>`\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0271`."}, {"sha": "fad6121cbca52f4da0e2c0031dea932e322e78ea", "filename": "src/test/ui/nll/dont-print-desugared.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cebd2dda1d9071f2209079370c412f4ef9ef2b82/src%2Ftest%2Fui%2Fnll%2Fdont-print-desugared.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cebd2dda1d9071f2209079370c412f4ef9ef2b82/src%2Ftest%2Fui%2Fnll%2Fdont-print-desugared.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fdont-print-desugared.stderr?ref=cebd2dda1d9071f2209079370c412f4ef9ef2b82", "patch": "@@ -2,7 +2,7 @@ error[E0596]: cannot borrow data in a `&` reference as mutable\n   --> $DIR/dont-print-desugared.rs:4:10\n    |\n LL |     for &ref mut x in s {}\n-   |          ^^^^^^^^^ cannot borrow as mutable through `&` reference\n+   |          ^^^^^^^^^ cannot borrow as mutable\n \n error[E0597]: `y` does not live long enough\n   --> $DIR/dont-print-desugared.rs:17:16"}, {"sha": "90cba2a145f5592fbdfb7f2b42dc81753b3f143f", "filename": "src/test/ui/nll/issue-53773.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cebd2dda1d9071f2209079370c412f4ef9ef2b82/src%2Ftest%2Fui%2Fnll%2Fissue-53773.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cebd2dda1d9071f2209079370c412f4ef9ef2b82/src%2Ftest%2Fui%2Fnll%2Fissue-53773.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-53773.stderr?ref=cebd2dda1d9071f2209079370c412f4ef9ef2b82", "patch": "@@ -2,12 +2,10 @@ error[E0713]: borrow may still be in use when destructor runs\n   --> $DIR/issue-53773.rs:41:22\n    |\n LL |         members.push(child.raw);\n-   |                      ^^^^^^^^^\n+   |         -------------^^^^^^^^^- borrow later used here\n LL |\n LL |     }\n    |     - here, drop of `child` needs exclusive access to `*child.raw`, because the type `C<'_>` implements the `Drop` trait\n-LL |     members.len();\n-   |     ------------- borrow later used here\n    |\n    = note: consider using a `let` binding to create a longer lived value\n "}, {"sha": "e9cef5f47d4aa555e6c8e010c5f4c17cbfe8b858", "filename": "src/test/ui/reachable/unreachable-loop-patterns.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cebd2dda1d9071f2209079370c412f4ef9ef2b82/src%2Ftest%2Fui%2Freachable%2Funreachable-loop-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebd2dda1d9071f2209079370c412f4ef9ef2b82/src%2Ftest%2Fui%2Freachable%2Funreachable-loop-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Funreachable-loop-patterns.rs?ref=cebd2dda1d9071f2209079370c412f4ef9ef2b82", "patch": "@@ -17,5 +17,4 @@ impl Iterator for Void {\n fn main() {\n     for _ in unimplemented!() as Void {}\n     //~^ ERROR unreachable pattern\n-    //~^^ ERROR unreachable pattern\n }"}, {"sha": "80ffa5d73f034224bf4ddef273c0038740735f45", "filename": "src/test/ui/reachable/unreachable-loop-patterns.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cebd2dda1d9071f2209079370c412f4ef9ef2b82/src%2Ftest%2Fui%2Freachable%2Funreachable-loop-patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cebd2dda1d9071f2209079370c412f4ef9ef2b82/src%2Ftest%2Fui%2Freachable%2Funreachable-loop-patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Funreachable-loop-patterns.stderr?ref=cebd2dda1d9071f2209079370c412f4ef9ef2b82", "patch": "@@ -10,11 +10,5 @@ note: the lint level is defined here\n LL | #![deny(unreachable_patterns)]\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n-error: unreachable pattern\n-  --> $DIR/unreachable-loop-patterns.rs:18:14\n-   |\n-LL |     for _ in unimplemented!() as Void {}\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n "}, {"sha": "6f213d7a699030e9852bae7f6ca30c70df28eda2", "filename": "src/tools/clippy/clippy_lints/src/loops/explicit_counter_loop.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cebd2dda1d9071f2209079370c412f4ef9ef2b82/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fexplicit_counter_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebd2dda1d9071f2209079370c412f4ef9ef2b82/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fexplicit_counter_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fexplicit_counter_loop.rs?ref=cebd2dda1d9071f2209079370c412f4ef9ef2b82", "patch": "@@ -1,6 +1,4 @@\n-use super::{\n-    get_span_of_entire_for_loop, make_iterator_snippet, IncrementVisitor, InitializeVisitor, EXPLICIT_COUNTER_LOOP,\n-};\n+use super::{make_iterator_snippet, IncrementVisitor, InitializeVisitor, EXPLICIT_COUNTER_LOOP};\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::{get_enclosing_block, is_integer_const};\n@@ -37,12 +35,10 @@ pub(super) fn check<'tcx>(\n                 then {\n                     let mut applicability = Applicability::MachineApplicable;\n \n-                    let for_span = get_span_of_entire_for_loop(expr);\n-\n                     span_lint_and_sugg(\n                         cx,\n                         EXPLICIT_COUNTER_LOOP,\n-                        for_span.with_hi(arg.span.hi()),\n+                        expr.span.with_hi(arg.span.hi()),\n                         &format!(\"the variable `{}` is used as a loop counter\", name),\n                         \"consider using\",\n                         format!("}, {"sha": "2362b4b20670f842b2cacebc17bdcfc02729a0a8", "filename": "src/tools/clippy/clippy_lints/src/loops/manual_memcpy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cebd2dda1d9071f2209079370c412f4ef9ef2b82/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebd2dda1d9071f2209079370c412f4ef9ef2b82/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs?ref=cebd2dda1d9071f2209079370c412f4ef9ef2b82", "patch": "@@ -1,4 +1,4 @@\n-use super::{get_span_of_entire_for_loop, IncrementVisitor, InitializeVisitor, MANUAL_MEMCPY};\n+use super::{IncrementVisitor, InitializeVisitor, MANUAL_MEMCPY};\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet;\n use clippy_utils::sugg::Sugg;\n@@ -86,7 +86,7 @@ pub(super) fn check<'tcx>(\n                 span_lint_and_sugg(\n                     cx,\n                     MANUAL_MEMCPY,\n-                    get_span_of_entire_for_loop(expr),\n+                    expr.span,\n                     \"it looks like you're manually copying between slices\",\n                     \"try replacing the loop by\",\n                     big_sugg,"}, {"sha": "fd4881b29474f95b36a7df6c8eb30171010ae362", "filename": "src/tools/clippy/clippy_lints/src/loops/mod.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cebd2dda1d9071f2209079370c412f4ef9ef2b82/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebd2dda1d9071f2209079370c412f4ef9ef2b82/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmod.rs?ref=cebd2dda1d9071f2209079370c412f4ef9ef2b82", "patch": "@@ -23,7 +23,7 @@ use rustc_hir::{Expr, ExprKind, LoopSource, Pat};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n-use utils::{get_span_of_entire_for_loop, make_iterator_snippet, IncrementVisitor, InitializeVisitor};\n+use utils::{make_iterator_snippet, IncrementVisitor, InitializeVisitor};\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -566,14 +566,25 @@ declare_lint_pass!(Loops => [\n impl<'tcx> LateLintPass<'tcx> for Loops {\n     #[allow(clippy::too_many_lines)]\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let Some(higher::ForLoop { pat, arg, body, span }) = higher::ForLoop::hir(expr) {\n+        let for_loop = higher::ForLoop::hir(expr);\n+        if let Some(higher::ForLoop {\n+            pat,\n+            arg,\n+            body,\n+            loop_id,\n+            span,\n+        }) = for_loop\n+        {\n             // we don't want to check expanded macros\n             // this check is not at the top of the function\n             // since higher::for_loop expressions are marked as expansions\n             if body.span.from_expansion() {\n                 return;\n             }\n             check_for_loop(cx, pat, arg, body, expr, span);\n+            if let ExprKind::Block(block, _) = body.kind {\n+                never_loop::check(cx, block, loop_id, span, for_loop.as_ref());\n+            }\n         }\n \n         // we don't want to check expanded macros\n@@ -582,7 +593,9 @@ impl<'tcx> LateLintPass<'tcx> for Loops {\n         }\n \n         // check for never_loop\n-        never_loop::check(cx, expr);\n+        if let ExprKind::Loop(block, ..) = expr.kind {\n+            never_loop::check(cx, block, expr.hir_id, expr.span, None);\n+        }\n \n         // check for `loop { if let {} else break }` that could be `while let`\n         // (also matches an explicit \"match\" instead of \"if let\")"}, {"sha": "86b7d6d989acc75fd6fc3dde238947886588aa51", "filename": "src/tools/clippy/clippy_lints/src/loops/never_loop.rs", "status": "modified", "additions": 32, "deletions": 26, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/cebd2dda1d9071f2209079370c412f4ef9ef2b82/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebd2dda1d9071f2209079370c412f4ef9ef2b82/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fnever_loop.rs?ref=cebd2dda1d9071f2209079370c412f4ef9ef2b82", "patch": "@@ -4,35 +4,41 @@ use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::higher::ForLoop;\n use clippy_utils::source::snippet;\n use rustc_errors::Applicability;\n-use rustc_hir::{Block, Expr, ExprKind, HirId, InlineAsmOperand, LoopSource, Node, Pat, Stmt, StmtKind};\n+use rustc_hir::{Block, Expr, ExprKind, HirId, InlineAsmOperand, Pat, Stmt, StmtKind};\n use rustc_lint::LateContext;\n+use rustc_span::Span;\n use std::iter::{once, Iterator};\n \n-pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-    if let ExprKind::Loop(block, _, source, _) = expr.kind {\n-        match never_loop_block(block, expr.hir_id) {\n-            NeverLoopResult::AlwaysBreak => {\n-                span_lint_and_then(cx, NEVER_LOOP, expr.span, \"this loop never actually loops\", |diag| {\n-                    if_chain! {\n-                        if source == LoopSource::ForLoop;\n-                        if let Some((_, Node::Expr(parent_match))) = cx.tcx.hir().parent_iter(expr.hir_id).nth(1);\n-                        if let Some(ForLoop { arg: iterator, pat, span: for_span, .. }) = ForLoop::hir(parent_match);\n-                        then {\n-                            // Suggests using an `if let` instead. This is `Unspecified` because the\n-                            // loop may (probably) contain `break` statements which would be invalid\n-                            // in an `if let`.\n-                            diag.span_suggestion_verbose(\n-                                for_span.with_hi(iterator.span.hi()),\n-                                \"if you need the first element of the iterator, try writing\",\n-                                for_to_if_let_sugg(cx, iterator, pat),\n-                                Applicability::Unspecified,\n-                            );\n-                        }\n-                    };\n-                });\n-            },\n-            NeverLoopResult::MayContinueMainLoop | NeverLoopResult::Otherwise => (),\n-        }\n+pub(super) fn check(\n+    cx: &LateContext<'tcx>,\n+    block: &'tcx Block<'_>,\n+    loop_id: HirId,\n+    span: Span,\n+    for_loop: Option<&ForLoop<'_>>,\n+) {\n+    match never_loop_block(block, loop_id) {\n+        NeverLoopResult::AlwaysBreak => {\n+            span_lint_and_then(cx, NEVER_LOOP, span, \"this loop never actually loops\", |diag| {\n+                if let Some(ForLoop {\n+                    arg: iterator,\n+                    pat,\n+                    span: for_span,\n+                    ..\n+                }) = for_loop\n+                {\n+                    // Suggests using an `if let` instead. This is `Unspecified` because the\n+                    // loop may (probably) contain `break` statements which would be invalid\n+                    // in an `if let`.\n+                    diag.span_suggestion_verbose(\n+                        for_span.with_hi(iterator.span.hi()),\n+                        \"if you need the first element of the iterator, try writing\",\n+                        for_to_if_let_sugg(cx, iterator, pat),\n+                        Applicability::Unspecified,\n+                    );\n+                }\n+            });\n+        },\n+        NeverLoopResult::MayContinueMainLoop | NeverLoopResult::Otherwise => (),\n     }\n }\n "}, {"sha": "e39605f3e7d621d79ede824a4c62b37603e1b8b7", "filename": "src/tools/clippy/clippy_lints/src/loops/single_element_loop.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cebd2dda1d9071f2209079370c412f4ef9ef2b82/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fsingle_element_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebd2dda1d9071f2209079370c412f4ef9ef2b82/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fsingle_element_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fsingle_element_loop.rs?ref=cebd2dda1d9071f2209079370c412f4ef9ef2b82", "patch": "@@ -1,4 +1,4 @@\n-use super::{get_span_of_entire_for_loop, SINGLE_ELEMENT_LOOP};\n+use super::SINGLE_ELEMENT_LOOP;\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::single_segment_path;\n use clippy_utils::source::{indent_of, snippet};\n@@ -30,7 +30,6 @@ pub(super) fn check<'tcx>(\n         if !block.stmts.is_empty();\n \n         then {\n-            let for_span = get_span_of_entire_for_loop(expr);\n             let mut block_str = snippet(cx, block.span, \"..\").into_owned();\n             block_str.remove(0);\n             block_str.pop();\n@@ -39,7 +38,7 @@ pub(super) fn check<'tcx>(\n             span_lint_and_sugg(\n                 cx,\n                 SINGLE_ELEMENT_LOOP,\n-                for_span,\n+                expr.span,\n                 \"for loop over a single element\",\n                 \"try\",\n                 format!(\"{{\\n{}let {} = &{};{}}}\", \" \".repeat(indent_of(cx, block.stmts[0].span).unwrap_or(0)), target.name, list_item_name, block_str),"}, {"sha": "c3939a66c6accdced10229bdc3612975b71c03cf", "filename": "src/tools/clippy/clippy_lints/src/loops/utils.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cebd2dda1d9071f2209079370c412f4ef9ef2b82/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebd2dda1d9071f2209079370c412f4ef9ef2b82/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Futils.rs?ref=cebd2dda1d9071f2209079370c412f4ef9ef2b82", "patch": "@@ -7,7 +7,6 @@ use rustc_hir::HirIdMap;\n use rustc_hir::{BinOpKind, BorrowKind, Expr, ExprKind, HirId, Mutability, Pat, PatKind, Stmt, StmtKind};\n use rustc_lint::LateContext;\n use rustc_middle::hir::map::Map;\n-use rustc_span::source_map::Span;\n use rustc_span::symbol::{sym, Symbol};\n use std::iter::Iterator;\n \n@@ -300,17 +299,6 @@ impl<'tcx> Visitor<'tcx> for LoopNestVisitor {\n     }\n }\n \n-// this function assumes the given expression is a `for` loop.\n-pub(super) fn get_span_of_entire_for_loop(expr: &Expr<'_>) -> Span {\n-    // for some reason this is the only way to get the `Span`\n-    // of the entire `for` loop\n-    if let ExprKind::Match(_, arms, _) = &expr.kind {\n-        arms[0].body.span\n-    } else {\n-        unreachable!()\n-    }\n-}\n-\n /// If `arg` was the argument to a `for` loop, return the \"cleanest\" way of writing the\n /// actual `Iterator` that the loop uses.\n pub(super) fn make_iterator_snippet(cx: &LateContext<'_>, arg: &Expr<'_>, applic_ref: &mut Applicability) -> String {"}, {"sha": "78183add9cc7c465b14b369158ae186afa7231dd", "filename": "src/tools/clippy/clippy_lints/src/misc.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cebd2dda1d9071f2209079370c412f4ef9ef2b82/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebd2dda1d9071f2209079370c412f4ef9ef2b82/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs?ref=cebd2dda1d9071f2209079370c412f4ef9ef2b82", "patch": "@@ -20,8 +20,8 @@ use rustc_span::symbol::sym;\n use clippy_utils::consts::{constant, Constant};\n use clippy_utils::sugg::Sugg;\n use clippy_utils::{\n-    expr_path_res, get_item_name, get_parent_expr, higher, in_constant, is_diag_trait_item, is_integer_const,\n-    iter_input_pats, last_path_segment, match_any_def_paths, paths, unsext, SpanlessEq,\n+    expr_path_res, get_item_name, get_parent_expr, in_constant, is_diag_trait_item, is_integer_const, iter_input_pats,\n+    last_path_segment, match_any_def_paths, paths, unsext, SpanlessEq,\n };\n \n declare_clippy_lint! {\n@@ -312,7 +312,6 @@ impl<'tcx> LateLintPass<'tcx> for MiscLints {\n             if let StmtKind::Local(local) = stmt.kind;\n             if let PatKind::Binding(an, .., name, None) = local.pat.kind;\n             if let Some(init) = local.init;\n-            if !higher::is_from_for_desugar(local);\n             if an == BindingAnnotation::Ref || an == BindingAnnotation::RefMut;\n             then {\n                 // use the macro callsite when the init span (but not the whole local span)"}, {"sha": "018e6d611db77aa1e66744dc9dbb8d45bf3bbc87", "filename": "src/tools/clippy/clippy_lints/src/pattern_type_mismatch.rs", "status": "modified", "additions": 43, "deletions": 164, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/cebd2dda1d9071f2209079370c412f4ef9ef2b82/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpattern_type_mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebd2dda1d9071f2209079370c412f4ef9ef2b82/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpattern_type_mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpattern_type_mismatch.rs?ref=cebd2dda1d9071f2209079370c412f4ef9ef2b82", "patch": "@@ -1,16 +1,12 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n-use clippy_utils::last_path_segment;\n use rustc_hir::{\n-    intravisit, Body, Expr, ExprKind, FnDecl, HirId, LocalSource, MatchSource, Mutability, Pat, PatField, PatKind,\n-    QPath, Stmt, StmtKind,\n+    intravisit, Body, Expr, ExprKind, FnDecl, HirId, LocalSource, Mutability, Pat, PatKind, Stmt, StmtKind,\n };\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty::subst::SubstsRef;\n-use rustc_middle::ty::{AdtDef, FieldDef, Ty, TyKind, VariantDef};\n+use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n-use std::iter;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -87,43 +83,28 @@ declare_lint_pass!(PatternTypeMismatch => [PATTERN_TYPE_MISMATCH]);\n impl<'tcx> LateLintPass<'tcx> for PatternTypeMismatch {\n     fn check_stmt(&mut self, cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) {\n         if let StmtKind::Local(local) = stmt.kind {\n-            if let Some(init) = &local.init {\n-                if let Some(init_ty) = cx.typeck_results().node_type_opt(init.hir_id) {\n-                    let pat = &local.pat;\n-                    if in_external_macro(cx.sess(), pat.span) {\n-                        return;\n-                    }\n-                    let deref_possible = match local.source {\n-                        LocalSource::Normal => DerefPossible::Possible,\n-                        _ => DerefPossible::Impossible,\n-                    };\n-                    apply_lint(cx, pat, init_ty, deref_possible);\n-                }\n+            if in_external_macro(cx.sess(), local.pat.span) {\n+                return;\n             }\n+            let deref_possible = match local.source {\n+                LocalSource::Normal => DerefPossible::Possible,\n+                _ => DerefPossible::Impossible,\n+            };\n+            apply_lint(cx, local.pat, deref_possible);\n         }\n     }\n \n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let ExprKind::Match(scrutinee, arms, MatchSource::Normal) = expr.kind {\n-            if let Some(expr_ty) = cx.typeck_results().node_type_opt(scrutinee.hir_id) {\n-                'pattern_checks: for arm in arms {\n-                    let pat = &arm.pat;\n-                    if in_external_macro(cx.sess(), pat.span) {\n-                        continue 'pattern_checks;\n-                    }\n-                    if apply_lint(cx, pat, expr_ty, DerefPossible::Possible) {\n-                        break 'pattern_checks;\n-                    }\n+        if let ExprKind::Match(_, arms, _) = expr.kind {\n+            for arm in arms {\n+                let pat = &arm.pat;\n+                if apply_lint(cx, pat, DerefPossible::Possible) {\n+                    break;\n                 }\n             }\n         }\n-        if let ExprKind::Let(let_pat, let_expr, _) = expr.kind {\n-            if let Some(expr_ty) = cx.typeck_results().node_type_opt(let_expr.hir_id) {\n-                if in_external_macro(cx.sess(), let_pat.span) {\n-                    return;\n-                }\n-                apply_lint(cx, let_pat, expr_ty, DerefPossible::Possible);\n-            }\n+        if let ExprKind::Let(let_pat, ..) = expr.kind {\n+            apply_lint(cx, let_pat, DerefPossible::Possible);\n         }\n     }\n \n@@ -134,12 +115,10 @@ impl<'tcx> LateLintPass<'tcx> for PatternTypeMismatch {\n         _: &'tcx FnDecl<'_>,\n         body: &'tcx Body<'_>,\n         _: Span,\n-        hir_id: HirId,\n+        _: HirId,\n     ) {\n-        if let Some(fn_sig) = cx.typeck_results().liberated_fn_sigs().get(hir_id) {\n-            for (param, ty) in iter::zip(body.params, fn_sig.inputs()) {\n-                apply_lint(cx, param.pat, ty, DerefPossible::Impossible);\n-            }\n+        for param in body.params {\n+            apply_lint(cx, param.pat, DerefPossible::Impossible);\n         }\n     }\n }\n@@ -150,8 +129,8 @@ enum DerefPossible {\n     Impossible,\n }\n \n-fn apply_lint<'tcx>(cx: &LateContext<'tcx>, pat: &Pat<'_>, expr_ty: Ty<'tcx>, deref_possible: DerefPossible) -> bool {\n-    let maybe_mismatch = find_first_mismatch(cx, pat, expr_ty, Level::Top);\n+fn apply_lint<'tcx>(cx: &LateContext<'tcx>, pat: &Pat<'_>, deref_possible: DerefPossible) -> bool {\n+    let maybe_mismatch = find_first_mismatch(cx, pat);\n     if let Some((span, mutability, level)) = maybe_mismatch {\n         span_lint_and_help(\n             cx,\n@@ -184,132 +163,32 @@ enum Level {\n }\n \n #[allow(rustc::usage_of_ty_tykind)]\n-fn find_first_mismatch<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    pat: &Pat<'_>,\n-    ty: Ty<'tcx>,\n-    level: Level,\n-) -> Option<(Span, Mutability, Level)> {\n-    if let PatKind::Ref(sub_pat, _) = pat.kind {\n-        if let TyKind::Ref(_, sub_ty, _) = ty.kind() {\n-            return find_first_mismatch(cx, sub_pat, sub_ty, Level::Lower);\n-        }\n-    }\n-\n-    if let TyKind::Ref(_, _, mutability) = *ty.kind() {\n-        if is_non_ref_pattern(&pat.kind) {\n-            return Some((pat.span, mutability, level));\n-        }\n-    }\n-\n-    if let PatKind::Struct(ref qpath, field_pats, _) = pat.kind {\n-        if let TyKind::Adt(adt_def, substs_ref) = ty.kind() {\n-            if let Some(variant) = get_variant(adt_def, qpath) {\n-                let field_defs = &variant.fields;\n-                return find_first_mismatch_in_struct(cx, field_pats, field_defs, substs_ref);\n-            }\n+fn find_first_mismatch<'tcx>(cx: &LateContext<'tcx>, pat: &Pat<'_>) -> Option<(Span, Mutability, Level)> {\n+    let mut result = None;\n+    pat.walk(|p| {\n+        if result.is_some() {\n+            return false;\n         }\n-    }\n-\n-    if let PatKind::TupleStruct(ref qpath, pats, _) = pat.kind {\n-        if let TyKind::Adt(adt_def, substs_ref) = ty.kind() {\n-            if let Some(variant) = get_variant(adt_def, qpath) {\n-                let field_defs = &variant.fields;\n-                let ty_iter = field_defs.iter().map(|field_def| field_def.ty(cx.tcx, substs_ref));\n-                return find_first_mismatch_in_tuple(cx, pats, ty_iter);\n-            }\n-        }\n-    }\n-\n-    if let PatKind::Tuple(pats, _) = pat.kind {\n-        if let TyKind::Tuple(..) = ty.kind() {\n-            return find_first_mismatch_in_tuple(cx, pats, ty.tuple_fields());\n+        if in_external_macro(cx.sess(), p.span) {\n+            return true;\n         }\n-    }\n-\n-    if let PatKind::Or(sub_pats) = pat.kind {\n-        for pat in sub_pats {\n-            let maybe_mismatch = find_first_mismatch(cx, pat, ty, level);\n-            if let Some(mismatch) = maybe_mismatch {\n-                return Some(mismatch);\n-            }\n-        }\n-    }\n-\n-    None\n-}\n-\n-fn get_variant<'a>(adt_def: &'a AdtDef, qpath: &QPath<'_>) -> Option<&'a VariantDef> {\n-    if adt_def.is_struct() {\n-        if let Some(variant) = adt_def.variants.iter().next() {\n-            return Some(variant);\n-        }\n-    }\n-\n-    if adt_def.is_enum() {\n-        let pat_ident = last_path_segment(qpath).ident;\n-        for variant in &adt_def.variants {\n-            if variant.ident == pat_ident {\n-                return Some(variant);\n-            }\n-        }\n-    }\n-\n-    None\n-}\n-\n-fn find_first_mismatch_in_tuple<'tcx, I>(\n-    cx: &LateContext<'tcx>,\n-    pats: &[Pat<'_>],\n-    ty_iter_src: I,\n-) -> Option<(Span, Mutability, Level)>\n-where\n-    I: IntoIterator<Item = Ty<'tcx>>,\n-{\n-    let mut field_tys = ty_iter_src.into_iter();\n-    'fields: for pat in pats {\n-        let field_ty = if let Some(ty) = field_tys.next() {\n-            ty\n-        } else {\n-            break 'fields;\n+        let adjust_pat = match p.kind {\n+            PatKind::Or([p, ..]) => p,\n+            _ => p,\n         };\n-\n-        let maybe_mismatch = find_first_mismatch(cx, pat, field_ty, Level::Lower);\n-        if let Some(mismatch) = maybe_mismatch {\n-            return Some(mismatch);\n-        }\n-    }\n-\n-    None\n-}\n-\n-fn find_first_mismatch_in_struct<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    field_pats: &[PatField<'_>],\n-    field_defs: &[FieldDef],\n-    substs_ref: SubstsRef<'tcx>,\n-) -> Option<(Span, Mutability, Level)> {\n-    for field_pat in field_pats {\n-        'definitions: for field_def in field_defs {\n-            if field_pat.ident == field_def.ident {\n-                let field_ty = field_def.ty(cx.tcx, substs_ref);\n-                let pat = &field_pat.pat;\n-                let maybe_mismatch = find_first_mismatch(cx, pat, field_ty, Level::Lower);\n-                if let Some(mismatch) = maybe_mismatch {\n-                    return Some(mismatch);\n+        if let Some(adjustments) = cx.typeck_results().pat_adjustments().get(adjust_pat.hir_id) {\n+            if let [first, ..] = **adjustments {\n+                if let ty::Ref(.., mutability) = *first.kind() {\n+                    let level = if p.hir_id == pat.hir_id {\n+                        Level::Top\n+                    } else {\n+                        Level::Lower\n+                    };\n+                    result = Some((p.span, mutability, level));\n                 }\n-                break 'definitions;\n             }\n         }\n-    }\n-\n-    None\n-}\n-\n-fn is_non_ref_pattern(pat_kind: &PatKind<'_>) -> bool {\n-    match pat_kind {\n-        PatKind::Struct(..) | PatKind::Tuple(..) | PatKind::TupleStruct(..) | PatKind::Path(..) => true,\n-        PatKind::Or(sub_pats) => sub_pats.iter().any(|pat| is_non_ref_pattern(&pat.kind)),\n-        _ => false,\n-    }\n+        result.is_none()\n+    });\n+    result\n }"}, {"sha": "b25a6e3375bb4176b3d45f610e633a8f9ce1086b", "filename": "src/tools/clippy/clippy_lints/src/unit_types/let_unit_value.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cebd2dda1d9071f2209079370c412f4ef9ef2b82/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_types%2Flet_unit_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebd2dda1d9071f2209079370c412f4ef9ef2b82/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_types%2Flet_unit_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_types%2Flet_unit_value.rs?ref=cebd2dda1d9071f2209079370c412f4ef9ef2b82", "patch": "@@ -1,5 +1,4 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::higher;\n use clippy_utils::source::snippet_with_macro_callsite;\n use rustc_errors::Applicability;\n use rustc_hir::{Stmt, StmtKind};\n@@ -14,9 +13,6 @@ pub(super) fn check(cx: &LateContext<'_>, stmt: &Stmt<'_>) {\n             if in_external_macro(cx.sess(), stmt.span) || local.pat.span.from_expansion() {\n                 return;\n             }\n-            if higher::is_from_for_desugar(local) {\n-                return;\n-            }\n             span_lint_and_then(\n                 cx,\n                 LET_UNIT_VALUE,"}, {"sha": "7297265d08cfbf214db556486f3d96289454b521", "filename": "src/tools/clippy/clippy_utils/src/higher.rs", "status": "modified", "additions": 15, "deletions": 47, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/cebd2dda1d9071f2209079370c412f4ef9ef2b82/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebd2dda1d9071f2209079370c412f4ef9ef2b82/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhigher.rs?ref=cebd2dda1d9071f2209079370c412f4ef9ef2b82", "patch": "@@ -22,31 +22,31 @@ pub struct ForLoop<'tcx> {\n     pub arg: &'tcx hir::Expr<'tcx>,\n     /// `for` loop body\n     pub body: &'tcx hir::Expr<'tcx>,\n+    /// Compare this against `hir::Destination.target`\n+    pub loop_id: HirId,\n     /// entire `for` loop span\n     pub span: Span,\n }\n \n impl<'tcx> ForLoop<'tcx> {\n-    #[inline]\n     /// Parses a desugared `for` loop\n     pub fn hir(expr: &Expr<'tcx>) -> Option<Self> {\n         if_chain! {\n-            if let hir::ExprKind::Match(iterexpr, arms, hir::MatchSource::ForLoopDesugar) = expr.kind;\n-            if let Some(first_arm) = arms.get(0);\n-            if let hir::ExprKind::Call(_, iterargs) = iterexpr.kind;\n-            if let Some(first_arg) = iterargs.get(0);\n-            if iterargs.len() == 1 && arms.len() == 1 && first_arm.guard.is_none();\n-            if let hir::ExprKind::Loop(block, ..) = first_arm.body.kind;\n-            if block.expr.is_none();\n-            if let [ _, _, ref let_stmt, ref body ] = *block.stmts;\n-            if let hir::StmtKind::Local(local) = let_stmt.kind;\n-            if let hir::StmtKind::Expr(body_expr) = body.kind;\n+            if let hir::ExprKind::DropTemps(e) = expr.kind;\n+            if let hir::ExprKind::Match(iterexpr, [arm], hir::MatchSource::ForLoopDesugar) = e.kind;\n+            if let hir::ExprKind::Call(_, [arg]) = iterexpr.kind;\n+            if let hir::ExprKind::Loop(block, ..) = arm.body.kind;\n+            if let [stmt] = &*block.stmts;\n+            if let hir::StmtKind::Expr(e) = stmt.kind;\n+            if let hir::ExprKind::Match(_, [_, some_arm], _) = e.kind;\n+            if let hir::PatKind::Struct(_, [field], _) = some_arm.pat.kind;\n             then {\n                 return Some(Self {\n-                    pat: &*local.pat,\n-                    arg: first_arg,\n-                    body: body_expr,\n-                    span: first_arm.span\n+                    pat: field.pat,\n+                    arg,\n+                    body: some_arm.body,\n+                    loop_id: arm.body.hir_id,\n+                    span: expr.span.ctxt().outer_expn_data().call_site,\n                 });\n             }\n         }\n@@ -678,38 +678,6 @@ impl<'tcx> FormatArgsArg<'tcx> {\n     }\n }\n \n-/// Checks if a `let` statement is from a `for` loop desugaring.\n-pub fn is_from_for_desugar(local: &hir::Local<'_>) -> bool {\n-    // This will detect plain for-loops without an actual variable binding:\n-    //\n-    // ```\n-    // for x in some_vec {\n-    //     // do stuff\n-    // }\n-    // ```\n-    if_chain! {\n-        if let Some(expr) = local.init;\n-        if let hir::ExprKind::Match(_, _, hir::MatchSource::ForLoopDesugar) = expr.kind;\n-        then {\n-            return true;\n-        }\n-    }\n-\n-    // This detects a variable binding in for loop to avoid `let_unit_value`\n-    // lint (see issue #1964).\n-    //\n-    // ```\n-    // for _ in vec![()] {\n-    //     // anything\n-    // }\n-    // ```\n-    if let hir::LocalSource::ForLoopDesugar = local.source {\n-        return true;\n-    }\n-\n-    false\n-}\n-\n /// A parsed `panic!` expansion\n pub struct PanicExpn<'tcx> {\n     /// Span of `panic!(..)`"}, {"sha": "4d0e13c833fd768a7b0086769476aa1382d1c825", "filename": "src/tools/clippy/tests/ui/author/for_loop.stdout", "status": "modified", "additions": 19, "deletions": 34, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/cebd2dda1d9071f2209079370c412f4ef9ef2b82/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauthor%2Ffor_loop.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/cebd2dda1d9071f2209079370c412f4ef9ef2b82/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauthor%2Ffor_loop.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauthor%2Ffor_loop.stdout?ref=cebd2dda1d9071f2209079370c412f4ef9ef2b82", "patch": "@@ -11,11 +11,8 @@ if_chain! {\n     // unimplemented: field checks\n     if arms.len() == 1;\n     if let ExprKind::Loop(ref body, ref label, LoopSource::ForLoop) = arms[0].body.kind;\n-    if body.stmts.len() == 4;\n-    if let StmtKind::Local(ref local) = body.stmts[0].kind;\n-    if let PatKind::Binding(BindingAnnotation::Mutable, _, name, None) = local.pat.kind;\n-    if name.as_str() == \"__next\";\n-    if let StmtKind::Expr(ref e, _) = body.stmts[1].kind\n+    if body.stmts.len() == 1;\n+    if let StmtKind::Expr(ref e, _) = body.stmts[0].kind\n     if let ExprKind::Match(ref expr2, ref arms1, MatchSource::ForLoopDesugar) = e.kind;\n     if let ExprKind::Call(ref func1, ref args1) = expr2.kind;\n     if let ExprKind::Path(ref path2) = func1.kind;\n@@ -25,39 +22,27 @@ if_chain! {\n     if let ExprKind::Path(ref path3) = inner.kind;\n     if match_qpath(path3, &[\"iter\"]);\n     if arms1.len() == 2;\n-    if let ExprKind::Assign(ref target, ref value, ref _span) = arms1[0].body.kind;\n-    if let ExprKind::Path(ref path4) = target.kind;\n-    if match_qpath(path4, &[\"__next\"]);\n-    if let ExprKind::Path(ref path5) = value.kind;\n-    if match_qpath(path5, &[\"val\"]);\n-    if let PatKind::Struct(ref path6, ref fields1, false) = arms1[0].pat.kind;\n-    if matches!(path6, QPath::LangItem(LangItem::OptionSome, _));\n-    if fields1.len() == 1;\n-    // unimplemented: field checks\n-    if let ExprKind::Break(ref destination, None) = arms1[1].body.kind;\n-    if let PatKind::Struct(ref path7, ref fields2, false) = arms1[1].pat.kind;\n-    if matches!(path7, QPath::LangItem(LangItem::OptionNone, _));\n-    if fields2.len() == 0;\n+    if let ExprKind::Break(ref destination, None) = arms1[0].body.kind;\n+    if let PatKind::Struct(ref path4, ref fields1, false) = arms1[0].pat.kind;\n+    if matches!(path4, QPath::LangItem(LangItem::OptionNone, _));\n+    if fields1.len() == 0;\n     // unimplemented: field checks\n-    if let StmtKind::Local(ref local1) = body.stmts[2].kind;\n-    if let Some(ref init) = local1.init;\n-    if let ExprKind::Path(ref path8) = init.kind;\n-    if match_qpath(path8, &[\"__next\"]);\n-    if let PatKind::Binding(BindingAnnotation::Unannotated, _, name1, None) = local1.pat.kind;\n-    if name1.as_str() == \"y\";\n-    if let StmtKind::Expr(ref e1, _) = body.stmts[3].kind\n-    if let ExprKind::Block(ref block) = e1.kind;\n+    if let ExprKind::Block(ref block) = arms1[1].body.kind;\n     if block.stmts.len() == 1;\n-    if let StmtKind::Local(ref local2) = block.stmts[0].kind;\n-    if let Some(ref init1) = local2.init;\n-    if let ExprKind::Path(ref path9) = init1.kind;\n-    if match_qpath(path9, &[\"y\"]);\n-    if let PatKind::Binding(BindingAnnotation::Unannotated, _, name2, None) = local2.pat.kind;\n-    if name2.as_str() == \"z\";\n+    if let StmtKind::Local(ref local) = block.stmts[0].kind;\n+    if let Some(ref init) = local.init;\n+    if let ExprKind::Path(ref path5) = init.kind;\n+    if match_qpath(path5, &[\"y\"]);\n+    if let PatKind::Binding(BindingAnnotation::Unannotated, _, name, None) = local.pat.kind;\n+    if name.as_str() == \"z\";\n     if block.expr.is_none();\n+    if let PatKind::Struct(ref path6, ref fields2, false) = arms1[1].pat.kind;\n+    if matches!(path6, QPath::LangItem(LangItem::OptionSome, _));\n+    if fields2.len() == 1;\n+    // unimplemented: field checks\n     if body.expr.is_none();\n-    if let PatKind::Binding(BindingAnnotation::Mutable, _, name3, None) = arms[0].pat.kind;\n-    if name3.as_str() == \"iter\";\n+    if let PatKind::Binding(BindingAnnotation::Mutable, _, name1, None) = arms[0].pat.kind;\n+    if name1.as_str() == \"iter\";\n     then {\n         // report your lint here\n     }"}]}