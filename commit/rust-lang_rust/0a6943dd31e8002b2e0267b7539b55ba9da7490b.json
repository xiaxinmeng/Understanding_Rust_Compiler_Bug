{"sha": "0a6943dd31e8002b2e0267b7539b55ba9da7490b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhNjk0M2RkMzFlODAwMmIyZTAyNjdiNzUzOWI1NWJhOWRhNzQ5MGI=", "commit": {"author": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2012-06-21T03:45:19Z"}, "committer": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2012-06-21T03:45:19Z"}, "message": "Merge pull request #2684 from mozilla/incoming\n\nIncoming", "tree": {"sha": "d120c202b44e6eaaf1374b3dc6487aa017e06b7a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d120c202b44e6eaaf1374b3dc6487aa017e06b7a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0a6943dd31e8002b2e0267b7539b55ba9da7490b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0a6943dd31e8002b2e0267b7539b55ba9da7490b", "html_url": "https://github.com/rust-lang/rust/commit/0a6943dd31e8002b2e0267b7539b55ba9da7490b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0a6943dd31e8002b2e0267b7539b55ba9da7490b/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8395305e71895b152e3f0abefb6cbc9e74f15a16", "url": "https://api.github.com/repos/rust-lang/rust/commits/8395305e71895b152e3f0abefb6cbc9e74f15a16", "html_url": "https://github.com/rust-lang/rust/commit/8395305e71895b152e3f0abefb6cbc9e74f15a16"}, {"sha": "f331cd9324e4c4246fb3f332720a444042267e69", "url": "https://api.github.com/repos/rust-lang/rust/commits/f331cd9324e4c4246fb3f332720a444042267e69", "html_url": "https://github.com/rust-lang/rust/commit/f331cd9324e4c4246fb3f332720a444042267e69"}], "stats": {"total": 1531, "additions": 639, "deletions": 892}, "files": [{"sha": "3f4e39d95c8653e31d57156300cdf0c27da9c57d", "filename": "doc/rust.md", "status": "modified", "additions": 16, "deletions": 51, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -330,24 +330,32 @@ An _integer literal_ has one of three forms:\n   * A _binary literal_ starts with the character sequence `U+0030` `U+0062`\n     (`0b`) and continues as any mixture binary digits and underscores.\n \n-By default, an integer literal is of type `int`. An integer literal may be\n-followed (immediately, without any spaces) by an _integer suffix_, which\n-changes the type of the literal. There are two kinds of integer literal\n-suffix:\n+An integer literal may be followed (immediately, without any spaces) by an\n+_integer suffix_, which changes the type of the literal. There are two kinds\n+of integer literal suffix:\n \n-  * The `u` suffix gives the literal type `uint`.\n+  * The `i` and `u` suffixes give the literal type `int` or `uint`,\n+    respectively.\n   * Each of the signed and unsigned machine types `u8`, `i8`,\n     `u16`, `i16`, `u32`, `i32`, `u64` and `i64`\n     give the literal the corresponding machine type.\n \n+The type of an _unsuffixed_ integer literal is determined by type inference.\n+If a integer type can be _uniquely_ determined from the surrounding program\n+context, the unsuffixed integer literal has that type.  If the program context\n+underconstrains the type, the unsuffixed integer literal's type is `int`; if\n+the program context overconstrains the type, it is considered a static type\n+error.\n \n Examples of integer literals of various forms:\n \n ~~~~\n-123;                               // type int\n+123; 0xff00;                       // type determined by program context; \n+                                   // defaults to int in absence of type\n+\t\t\t\t   // information\n+\n 123u;                              // type uint\n 123_u;                             // type uint\n-0xff00;                            // type int\n 0xff_u8;                           // type u8\n 0b1111_1111_1001_0000_i32;         // type i32\n ~~~~\n@@ -980,7 +988,7 @@ fn pure_foldl<T, U: copy>(ls: list<T>, u: U, f: fn(&&T, &&U) -> U) -> U {\n pure fn pure_length<T>(ls: list<T>) -> uint {\n     fn count<T>(_t: T, &&u: uint) -> uint { u + 1u }\n     unchecked {\n-        pure_foldl(ls, 0u, count(_, _))\n+        pure_foldl(ls, 0u, count)\n     }\n }\n ~~~~\n@@ -1941,49 +1949,6 @@ An example of a call expression:\n let x: int = add(1, 2);\n ~~~~\n \n-\n-### Bind expressions\n-\n-A _bind expression_ constructs a new function from an existing function.^[The\n-`bind` expression is analogous to the `bind` expression in the Sather\n-language.] The new function has zero or more of its arguments *bound* into a\n-new, hidden boxed tuple that holds the bindings. For each concrete argument\n-passed in the `bind` expression, the corresponding parameter in the existing\n-function is *omitted* as a parameter of the new function. For each argument\n-passed the placeholder symbol `_` in the `bind` expression, the corresponding\n-parameter of the existing function is *retained* as a parameter of the new\n-function.\n-\n-Any subsequent invocation of the new function with residual arguments causes\n-invocation of the existing function with the combination of bound arguments\n-and residual arguments that was specified during the binding.\n-\n-An example of a `bind` expression:\n-\n-~~~~{.xfail-test}\n-fn add(x: int, y: int) -> int {\n-    ret x + y;\n-}\n-type single_param_fn = fn(int) -> int;\n-\n-let add4: single_param_fn = bind add(4, _);\n-\n-let add5: single_param_fn = bind add(_, 5);\n-\n-assert (add(4,5) == add4(5));\n-assert (add(4,5) == add5(4));\n-\n-~~~~\n-\n-A `bind` expression generally stores a copy of the bound arguments in a\n-hidden, boxed tuple, owned by the resulting first-class function. For each\n-bound slot in the bound function's signature, space is allocated in the hidden\n-tuple and populated with a copy of the bound value.\n-\n-A `bind` expression is an alternative way of constructing a shared function\n-closure; the [`fn@` expression](#shared-function-expressions) form is another\n-way.\n-\n ### Shared function expressions\n \n *TODO*."}, {"sha": "f6c2aef30ea3528019162ad626415296f67f8c2f", "filename": "doc/tutorial.md", "status": "modified", "additions": 51, "deletions": 19, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -396,22 +396,67 @@ synonym.\n \n ## Literals\n \n+### Numeric literals\n+\n Integers can be written in decimal (`144`), hexadecimal (`0x90`), and\n-binary (`0b10010000`) base. Without a suffix, an integer literal is\n-considered to be of type `int`. Add a `u` (`144u`) to make it a `uint`\n-instead. Literals of the fixed-size integer types can be created by\n-the literal with the type name (`255u8`, `50i64`, etc).\n+binary (`0b10010000`) base.\n+\n+If you write an integer literal without a suffix (`3`, `-500`, etc.),\n+the Rust compiler will try to infer its type based on type annotations\n+and function signatures in the surrounding program.  For example, here\n+the type of `x` is inferred to be `u16` because it is passed to a\n+function that takes a `u16` argument:\n+\n+~~~~~\n+let x = 3;\n+\n+fn identity_u16(n: u16) -> u16 { n }\n+\n+identity_u16(x);\n+~~~~\n+\n+On the other hand, if the program gives conflicting information about\n+what the type of the unsuffixed literal should be, you'll get an error\n+message.\n+\n+~~~~~{.xfail-test}\n+let x = 3;\n+let y: i32 = 3;\n+\n+fn identity_u8(n: u8) -> u8 { n }\n+fn identity_u16(n: u16) -> u16 { n }\n+\n+identity_u8(x);  // after this, `x` is assumed to have type `u8`\n+identity_u16(x); // raises a type error (expected `u16` but found `u8`)\n+identity_u16(y); // raises a type error (expected `u16` but found `i32`)\n+~~~~\n+\n+In the absence of any type annotations at all, Rust will assume that\n+an unsuffixed integer literal has type `int`.\n+\n+~~~~\n+let n = 50;\n+log(error, n); // n is an int\n+~~~~\n+\n+It's also possible to avoid any type ambiguity by writing integer\n+literals with a suffix.  The suffixes `i` and `u` are for the types\n+`int` and `uint`, respectively: the literal `-3i` has type `int`,\n+while `127u` has type `uint`.  For the fixed-size integer types, just\n+suffix the literal with the type name: `255u8`, `50i64`, etc.\n \n Note that, in Rust, no implicit conversion between integer types\n-happens. If you are adding one to a variable of type `uint`, you must\n-type `v += 1u`\u2014saying `+= 1` will give you a type error.\n+happens. If you are adding one to a variable of type `uint`, saying\n+`+= 1u8` will give you a type error.\n \n Floating point numbers are written `0.0`, `1e6`, or `2.1e-4`. Without\n a suffix, the literal is assumed to be of type `float`. Suffixes `f32`\n and `f64` can be used to create literals of a specific type. The\n suffix `f` can be used to write `float` literals without a dot or\n exponent: `3f`.\n \n+### Other literals\n+\n The nil literal is written just like the type: `()`. The keywords\n `true` and `false` produce the boolean literals.\n \n@@ -903,19 +948,6 @@ argument to every element of a vector, producing a new vector.\n Even when a closure takes no parameters, you must still write the bars\n for the parameter list, as in `{|| ...}`.\n \n-## Binding\n-\n-Partial application is done using the `bind` keyword in Rust.\n-\n-~~~~\n-let findx = bind str::find_char(_, 'x');\n-~~~~\n-\n-Binding a function produces a boxed closure (`fn@` type) in which some\n-of the arguments to the bound function have already been provided.\n-`findx` will be a function taking a single string argument, and\n-returning the position where the letter `x` occurs.\n-\n ## Iteration\n \n Functions taking closures provide a good way to define non-trivial"}, {"sha": "a8fea66b1920bd38841b24ca9991f93254567610", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -328,8 +328,8 @@ fn load_crate(filename: str) -> option<crate> {\n         mut deps: []\n     };\n     let v = visit::mk_simple_visitor(@{\n-        visit_view_item: bind goto_view_item(e, _),\n-        visit_item: bind goto_item(e, _),\n+        visit_view_item: {|a|goto_view_item(e, a)},\n+        visit_item: {|a|goto_item(e, a)},\n         with *visit::default_simple_visitor()\n     });\n "}, {"sha": "5afe663f23bb13d08b8d471da47ce40ec6da0004", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -325,7 +325,7 @@ fn compose_and_run_compiler(\n         let abs_ab = path::connect(config.aux_base, rel_ab);\n         let aux_args =\n             make_compile_args(config, props, [\"--lib\"] + extra_link_args,\n-                              bind make_lib_name(_, _, testfile), abs_ab);\n+                              {|a,b|make_lib_name(a, b, testfile)}, abs_ab);\n         let auxres = compose_and_run(config, abs_ab, aux_args, [],\n                                      config.compile_lib_path, option::none);\n         if auxres.status != 0 {"}, {"sha": "95abb6636a83ba7e16429c59776b6cfc3a1bfc05", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -139,8 +139,8 @@ fn steal(crate: ast::crate, tm: test_mode) -> stolen_stuff {\n     let exprs = @mut [];\n     let tys = @mut [];\n     let v = visit::mk_simple_visitor(@{\n-        visit_expr: bind stash_expr_if(safe_to_steal_expr, exprs, _, tm),\n-        visit_ty: bind stash_ty_if(safe_to_steal_ty, tys, _, tm)\n+        visit_expr: {|a|stash_expr_if(safe_to_steal_expr, exprs, a, tm)},\n+        visit_ty: {|a|stash_ty_if(safe_to_steal_ty, tys, a, tm)}\n         with *visit::default_simple_visitor()\n     });\n     visit::visit_crate(crate, (), v);\n@@ -188,8 +188,8 @@ fn replace_expr_in_crate(crate: ast::crate, i: uint,\n         }\n     }\n     let afp =\n-        @{fold_expr: fold::wrap(bind fold_expr_rep(j, i,\n-                                                   newexpr.node, _, _, tm))\n+        @{fold_expr: fold::wrap({|a,b|\n+        fold_expr_rep(j, i, newexpr.node, a, b, tm)})\n           with *fold::default_ast_fold()};\n     let af = fold::make_fold(afp);\n     let crate2: @ast::crate = @af.fold_crate(crate);\n@@ -211,7 +211,7 @@ fn replace_ty_in_crate(crate: ast::crate, i: uint, newty: ast::ty,\n         } else { fold::noop_fold_ty(original, fld) }\n     }\n     let afp =\n-        @{fold_ty: fold::wrap(bind fold_ty_rep(j, i, newty.node, _, _, tm))\n+        @{fold_ty: fold::wrap({|a,b|fold_ty_rep(j, i, newty.node, a, b, tm)})\n          with *fold::default_ast_fold()};\n     let af = fold::make_fold(afp);\n     let crate2: @ast::crate = @af.fold_crate(crate);\n@@ -235,7 +235,7 @@ fn check_variants_of_ast(crate: ast::crate, codemap: codemap::codemap,\n                          filename: str, cx: context) {\n     let stolen = steal(crate, cx.mode);\n     let extra_exprs = vec::filter(common_exprs(),\n-                                  bind safe_to_use_expr(_, cx.mode));\n+                                  {|a|safe_to_use_expr(a, cx.mode)});\n     check_variants_T(crate, codemap, filename, \"expr\",\n                      extra_exprs + stolen.exprs, pprust::expr_to_str,\n                      replace_expr_in_crate, cx);\n@@ -268,13 +268,13 @@ fn check_variants_T<T: copy>(\n                 // testing the string for stability is easier and ok for now.\n                 let handler = diagnostic::mk_handler(none);\n                 let str3 =\n-                    @as_str(bind pprust::print_crate(\n+                    @as_str({|a|pprust::print_crate(\n                         codemap,\n                         diagnostic::mk_span_handler(handler, codemap),\n                         crate2,\n                         filename,\n-                        io::str_reader(\"\"), _,\n-                        pprust::no_ann()));\n+                        io::str_reader(\"\"), a,\n+                        pprust::no_ann())});\n                 alt cx.mode {\n                   tm_converge {\n                     check_roundtrip_convergence(str3, 1u);\n@@ -421,12 +421,12 @@ fn parse_and_print(code: @str) -> str {\n     let crate = parse::parse_crate_from_source_str(\n         filename, code, [], sess);\n     io::with_str_reader(*code) { |rdr|\n-        as_str(bind pprust::print_crate(sess.cm,\n+        as_str({|a|pprust::print_crate(sess.cm,\n                                         sess.span_diagnostic,\n                                         crate,\n                                         filename,\n-                                        rdr, _,\n-                                        pprust::no_ann()))\n+                                        rdr, a,\n+                                       pprust::no_ann())})\n     }\n }\n \n@@ -439,7 +439,7 @@ fn has_raw_pointers(c: ast::crate) -> bool {\n         }\n     }\n     let v =\n-        visit::mk_simple_visitor(@{visit_ty: bind visit_ty(has_rp, _)\n+        visit::mk_simple_visitor(@{visit_ty: {|a|visit_ty(has_rp, a)}\n                                       with *visit::default_simple_visitor()});\n     visit::visit_crate(c, (), v);\n     ret *has_rp;\n@@ -565,12 +565,12 @@ fn check_variants(files: [str], cx: context) {\n                 s, [], sess);\n         io::with_str_reader(*s) { |rdr|\n             #error(\"%s\",\n-                   as_str(bind pprust::print_crate(sess.cm,\n+                   as_str({|a|pprust::print_crate(sess.cm,\n                                                    sess.span_diagnostic,\n                                                    crate,\n                                                    file,\n-                                                   rdr, _,\n-                                                   pprust::no_ann())));\n+                                                   rdr, a,\n+                                                  pprust::no_ann())}));\n         }\n         check_variants_of_ast(*crate, sess.cm, file, cx);\n     }"}, {"sha": "7c2a9737f04a1b7233fca7cd17a081e43c485618", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -177,11 +177,11 @@ fn peek<T: send>(p: port<T>) -> bool { peek_(***p) }\n \n #[doc(hidden)]\n fn recv_chan<T: send>(ch: comm::chan<T>) -> T {\n-    as_raw_port(ch, recv_(_))\n+    as_raw_port(ch, {|x|recv_(x)})\n }\n \n fn peek_chan<T: send>(ch: comm::chan<T>) -> bool {\n-    as_raw_port(ch, peek_(_))\n+    as_raw_port(ch, {|x|peek_(x)})\n }\n \n #[doc = \"Receive on a raw port pointer\"]"}, {"sha": "1ae690467154a8d7ebb8ba5eb360e994ada37b8f", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -174,7 +174,7 @@ mod ct {\n             let curr: [flag] = [f];\n             ret {flags: curr + rest, next: j};\n         }\n-        let more = bind more_(_, s, i, lim);\n+        let more = {|x|more_(x, s, i, lim)};\n         let f = s[i];\n         ret if f == '-' as u8 {\n                 more(flag_left_justify)"}, {"sha": "1be4d12d23ed8a803d946b70e220965a438a8a80", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -185,7 +185,7 @@ Converts the bitvector to a vector of uint with the same length.\n Each uint in the resulting vector has either value 0u or 1u.\n \"]\n fn to_vec(v: bitv) -> [uint] {\n-    let sub = bind init_to_vec(v, _);\n+    let sub = {|x|init_to_vec(v, x)};\n     ret vec::from_fn::<uint>(v.nbits, sub);\n }\n "}, {"sha": "57fff2cdcbd31b4ff8da6d307901f0b098026fc3", "filename": "src/libstd/c_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Flibstd%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Flibstd%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_vec.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -136,7 +136,7 @@ mod tests {\n         assert mem as int != 0;\n \n         ret unsafe { c_vec_with_dtor(mem as *mut u8, n as uint,\n-                                     bind free(mem)) };\n+                                     {||free(mem)}) };\n     }\n \n     #[test]"}, {"sha": "1e9b2224a63f414bebbfcfd4c8807fff2a4998d9", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -292,7 +292,7 @@ mod tests {\n                                     two(17, 42));\n \n         #debug(\"*** test parameterized: taggypar<int>\");\n-        let eq4: eqfn<taggypar<int>> = bind taggypareq::<int>(_, _);\n+        let eq4: eqfn<taggypar<int>> = {|x,y|taggypareq::<int>(x, y)};\n         test_parameterized::<taggypar<int>>(eq4, onepar::<int>(1),\n                                             twopar::<int>(1, 2),\n                                             threepar::<int>(1, 2, 3),"}, {"sha": "01b413054fb61c85fea6269c09e3014de5a2bac7", "filename": "src/libstd/test.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -162,7 +162,7 @@ fn run_tests_console(opts: test_opts,\n           mut ignored: 0u,\n           mut failures: []};\n \n-    run_tests(opts, tests, bind callback(_, st));\n+    run_tests(opts, tests, {|x|callback(x, st)});\n \n     assert (st.passed + st.failed + st.ignored == st.total);\n     let success = st.failed == 0u;\n@@ -349,7 +349,7 @@ fn filter_tests(opts: test_opts,\n             } else { ret option::none; }\n         }\n \n-        let filter = bind filter_fn(_, filter_str);\n+        let filter = {|x|filter_fn(x, filter_str)};\n \n         vec::filter_map(filtered, filter)\n     };\n@@ -367,7 +367,7 @@ fn filter_tests(opts: test_opts,\n             } else { ret option::none; }\n         };\n \n-        vec::filter_map(filtered, bind filter(_))\n+        vec::filter_map(filtered, {|x|filter(x)})\n     };\n \n     // Sort the tests alphabetically\n@@ -376,7 +376,7 @@ fn filter_tests(opts: test_opts,\n             fn lteq(t1: test_desc, t2: test_desc) -> bool {\n                 str::le(t1.name, t2.name)\n             }\n-            sort::merge_sort(bind lteq(_, _), filtered)\n+        sort::merge_sort({|x,y|lteq(x, y)}, filtered)\n         };\n \n     ret filtered;"}, {"sha": "6cf98f93fe391db8d2921ed0fec825c30019b2b0", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -125,7 +125,7 @@ mod tests {\n         fn t(n: @mut int, &&k: int, &&_v: ()) {\n             assert (*n == k); *n += 1;\n         }\n-        traverse(m, bind t(n, _, _));\n+        traverse(m, {|x,y|t(n, x, y)});\n     }\n \n     #[test]"}, {"sha": "98cf35efdc8abe4114789b5173ed632e6e28527d", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -300,7 +300,6 @@ enum expr_ {\n     expr_rec([field], option<@expr>),\n     expr_call(@expr, [@expr], bool), // True iff last argument is a block\n     expr_tup([@expr]),\n-    expr_bind(@expr, [option<@expr>]),\n     expr_binary(binop, @expr, @expr),\n     expr_unary(unop, @expr),\n     expr_lit(@lit),"}, {"sha": "75a88fb221b6fafe5a5bbd9b1683fbae777b74a1", "filename": "src/libsyntax/ext/auto_serialize.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_serialize.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -267,7 +267,7 @@ impl helpers for ext_ctxt {\n         }\n \n         let fld = fold::make_fold(@{\n-            new_span: repl_sp(_, ast_util::dummy_sp(), span)\n+            new_span: {|a|repl_sp(a, ast_util::dummy_sp(), span)}\n             with *fold::default_ast_fold()\n         });\n \n@@ -757,8 +757,8 @@ fn ty_fns(cx: ext_ctxt, name: ast::ident, ty: @ast::ty, tps: [ast::ty_param])\n \n     let span = ty.span;\n     [\n-        mk_ser_fn(cx, span, name, tps, ser_ty(_, _, ty, _, _)),\n-        mk_deser_fn(cx, span, name, tps, deser_ty(_, _, ty, _))\n+        mk_ser_fn(cx, span, name, tps, {|a,b,c,d|ser_ty(a, b, ty, c, d)}),\n+        mk_deser_fn(cx, span, name, tps, {|a,b,c|deser_ty(a, b, ty, c)})\n     ]\n }\n \n@@ -860,8 +860,8 @@ fn enum_fns(cx: ext_ctxt, e_name: ast::ident, e_span: span,\n     -> [@ast::item] {\n     [\n         mk_ser_fn(cx, e_span, e_name, tps,\n-                  ser_enum(_, _, e_name, e_span, variants, _, _)),\n+                  {|a,b,c,d|ser_enum(a, b, e_name, e_span, variants, c, d)}),\n         mk_deser_fn(cx, e_span, e_name, tps,\n-                    deser_enum(_, _, e_name, e_span, variants, _))\n+                    {|a,b,c|deser_enum(a, b, e_name, e_span, variants, c)})\n     ]\n }"}, {"sha": "ba44404fe24a127df47da6bcc7067fb0f188aa42", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -130,10 +130,10 @@ fn expand_crate(parse_sess: parse::parse_sess,\n     let afp = default_ast_fold();\n     let cx: ext_ctxt = mk_ctxt(parse_sess, cfg);\n     let f_pre =\n-        @{fold_expr: bind expand_expr(exts, cx, _, _, _, afp.fold_expr),\n-          fold_mod: bind expand_mod_items(exts, cx, _, _, afp.fold_mod),\n-          fold_item: bind expand_item(cx, _, _, afp.fold_item),\n-          new_span: bind new_span(cx, _)\n+        @{fold_expr: {|a,b,c|expand_expr(exts, cx, a, b, c, afp.fold_expr)},\n+          fold_mod: {|a,b|expand_mod_items(exts, cx, a, b, afp.fold_mod)},\n+          fold_item: {|a,b|expand_item(cx, a, b, afp.fold_item)},\n+          new_span: {|a|new_span(cx, a)}\n           with *afp};\n     let f = make_fold(f_pre);\n     let cm = parse_expr_from_source_str(\"<core-macros>\","}, {"sha": "5ea8b677675c5da9758860d83dbbf5ebb0bb74ff", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -23,7 +23,9 @@ fn expand_syntax_ext(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n     fn parse_fmt_err_(cx: ext_ctxt, sp: span, msg: str) -> ! {\n         cx.span_fatal(sp, msg);\n     }\n-    let parse_fmt_err = bind parse_fmt_err_(cx, fmtspan, _);\n+    let parse_fmt_err = fn@(s: str) -> ! {\n+        parse_fmt_err_(cx, fmtspan, s)\n+    };\n     let pieces = parse_fmt_string(fmt, parse_fmt_err);\n     ret pieces_to_expr(cx, sp, pieces, args);\n }"}, {"sha": "9830c379ef656728e08b6e1a2c4e03fabfe0ec45", "filename": "src/libsyntax/ext/qquote.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Flibsyntax%2Fext%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Flibsyntax%2Fext%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fqquote.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -274,10 +274,10 @@ fn replace<T>(node: T, repls: [fragment], ff: fn (ast_fold, T) -> T)\n     -> T\n {\n     let aft = default_ast_fold();\n-    let f_pre = @{fold_expr: bind replace_expr(repls, _, _, _,\n-                                               aft.fold_expr),\n-                  fold_ty: bind replace_ty(repls, _, _, _,\n-                                           aft.fold_ty)\n+    let f_pre = @{fold_expr: {|a,b,c|replace_expr(repls, a, b, c,\n+                                                  aft.fold_expr)},\n+                  fold_ty: {|a,b,c|replace_ty(repls, a, b, c,\n+                                              aft.fold_ty)}\n                   with *aft};\n     ret ff(make_fold(f_pre), node);\n }"}, {"sha": "bf3014d1621fb8f6e26f8b5a0755431bbb718fd5", "filename": "src/libsyntax/ext/simplext.rs", "status": "modified", "additions": 29, "deletions": 21, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Flibsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Flibsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsimplext.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -113,7 +113,7 @@ fn a_d_map(ad: arb_depth<matchable>, f: selector) -> match_result {\n     alt ad {\n       leaf(x) { ret f(x); }\n       seq(ads, span) {\n-        alt option_flatten_map(bind a_d_map(_, f), *ads) {\n+        alt option_flatten_map({|x| a_d_map(x, f)}, *ads) {\n           none { ret none; }\n           some(ts) { ret some(seq(@ts, span)); }\n         }\n@@ -128,7 +128,7 @@ fn compose_sels(s1: selector, s2: selector) -> selector {\n               some(matches) { a_d_map(matches, s2) }\n             }\n     }\n-    ret bind scomp(s1, s2, _);\n+    ret {|x|scomp(s1, s2, x)};\n }\n \n \n@@ -190,16 +190,22 @@ fn transcribe(cx: ext_ctxt, b: bindings, body: @expr) -> @expr {\n     }\n     let afp = default_ast_fold();\n     let f_pre =\n-        @{fold_ident: bind transcribe_ident(cx, b, idx_path, _, _),\n-          fold_path: bind transcribe_path(cx, b, idx_path, _, _),\n-          fold_expr:\n-              bind transcribe_expr(cx, b, idx_path, _, _, _, afp.fold_expr),\n-          fold_ty: bind transcribe_type(cx, b, idx_path,\n-                                        _, _, _, afp.fold_ty),\n-          fold_block:\n-              bind transcribe_block(cx, b, idx_path, _, _, _, afp.fold_block),\n-          map_exprs: bind transcribe_exprs(cx, b, idx_path, _, _),\n-          new_id: bind new_id(_, cx)\n+        @{fold_ident: {|x,y|transcribe_ident(cx, b, idx_path, x, y)},\n+          fold_path: {|x,y|transcribe_path(cx, b, idx_path, x, y)},\n+          fold_expr: {|x,y,z|\n+              transcribe_expr(cx, b, idx_path, x, y, z, afp.fold_expr)\n+          },\n+          fold_ty: {|x,y,z|\n+              transcribe_type(cx, b, idx_path,\n+                              x, y, z, afp.fold_ty)\n+          },\n+          fold_block: {|x,y,z|\n+              transcribe_block(cx, b, idx_path, x, y, z, afp.fold_block)\n+          },\n+          map_exprs: {|x,y|\n+              transcribe_exprs(cx, b, idx_path, x, y)\n+          },\n+          new_id: {|x|new_id(x, cx)}\n           with *afp};\n     let f = make_fold(f_pre);\n     let result = f.fold_expr(body);\n@@ -249,7 +255,7 @@ fn free_vars(b: bindings, e: @expr, it: fn(ident)) {\n     // using fold is a hack: we want visit, but it doesn't hit idents ) :\n     // solve this with macros\n     let f_pre =\n-        @{fold_ident: bind mark_ident(_, _, b, idents)\n+        @{fold_ident: {|x,y|mark_ident(x, y, b, idents)}\n           with *default_ast_fold()};\n     let f = make_fold(f_pre);\n     f.fold_expr(e); // ignore result\n@@ -475,7 +481,7 @@ fn p_t_s_rec(cx: ext_ctxt, m: matchable, s: selector, b: binders) {\n                       _ { cx.bug(\"broken traversal in p_t_s_r\") }\n                     }\n             }\n-            b.literal_ast_matchers.push(bind select(cx, _, e));\n+            b.literal_ast_matchers.push({|x|select(cx, x, e)});\n           }\n         }\n       }\n@@ -517,7 +523,7 @@ fn p_t_s_r_path(cx: ext_ctxt, p: @path, s: selector, b: binders) {\n         if b.real_binders.contains_key(p_id) {\n             cx.span_fatal(p.span, \"duplicate binding identifier\");\n         }\n-        b.real_binders.insert(p_id, compose_sels(s, bind select(cx, _)));\n+        b.real_binders.insert(p_id, compose_sels(s, {|x|select(cx, x)}));\n       }\n       none { }\n     }\n@@ -562,7 +568,7 @@ fn p_t_s_r_mac(cx: ext_ctxt, mac: ast::mac, s: selector, b: binders) {\n                           _ { none }\n                         }\n                 }\n-                let final_step = bind select_pt_1(cx, _, select_pt_2);\n+                let final_step = {|x|select_pt_1(cx, x, select_pt_2)};\n                 b.real_binders.insert(id, compose_sels(s, final_step));\n               }\n               none { no_des(cx, pth.span, \"under `#<>`\"); }\n@@ -582,7 +588,7 @@ fn p_t_s_r_mac(cx: ext_ctxt, mac: ast::mac, s: selector, b: binders) {\n                       _ { none }\n                     }\n             }\n-            let final_step = bind select_pt_1(cx, _, select_pt_2);\n+            let final_step = {|x|select_pt_1(cx, x, select_pt_2)};\n             b.real_binders.insert(id, compose_sels(s, final_step));\n           }\n           none { no_des(cx, blk.span, \"under `#{}`\"); }\n@@ -619,7 +625,7 @@ fn p_t_s_r_ellipses(cx: ext_ctxt, repeat_me: @expr, offset: uint, s: selector,\n             }\n     }\n     p_t_s_rec(cx, match_expr(repeat_me),\n-              compose_sels(s, bind select(cx, repeat_me, offset, _)), b);\n+              compose_sels(s, {|x|select(cx, repeat_me, offset, x)}), b);\n }\n \n \n@@ -643,7 +649,7 @@ fn p_t_s_r_length(cx: ext_ctxt, len: uint, at_least: bool, s: selector,\n             }\n     }\n     b.literal_ast_matchers.push(\n-        compose_sels(s, bind len_select(cx, _, at_least, len)));\n+        compose_sels(s, {|x|len_select(cx, x, at_least, len)}));\n }\n \n fn p_t_s_r_actual_vector(cx: ext_ctxt, elts: [@expr], _repeat_after: bool,\n@@ -664,7 +670,7 @@ fn p_t_s_r_actual_vector(cx: ext_ctxt, elts: [@expr], _repeat_after: bool,\n                 }\n         }\n         p_t_s_rec(cx, match_expr(elts[idx]),\n-                  compose_sels(s, bind select(cx, _, idx)), b);\n+                  compose_sels(s, {|x, copy idx|select(cx, x, idx)}), b);\n         idx += 1u;\n     }\n }\n@@ -739,7 +745,9 @@ fn add_new_extension(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n         }\n     }\n \n-    let ext = bind generic_extension(_, _, _, _, clauses);\n+    let ext = {|a,b,c,d, move clauses|\n+        generic_extension(a,b,c,d,clauses)\n+    };\n \n     ret {ident:\n              alt macro_name {"}, {"sha": "0589e48489cab82a90a3049d862579aa44d0175e", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -87,7 +87,7 @@ fn fold_meta_item_(&&mi: @meta_item, fld: ast_fold) -> @meta_item {\n               alt mi.node {\n                 meta_word(id) { meta_word(fld.fold_ident(id)) }\n                 meta_list(id, mis) {\n-                  let fold_meta_item = bind fold_meta_item_(_, fld);\n+                  let fold_meta_item = {|x|fold_meta_item_(x, fld)};\n                   meta_list(/* FIXME: bad */ copy id,\n                             vec::map(mis, fold_meta_item))\n                 }\n@@ -130,7 +130,7 @@ fn fold_mac_(m: mac, fld: ast_fold) -> mac {\n }\n \n fn fold_fn_decl(decl: ast::fn_decl, fld: ast_fold) -> ast::fn_decl {\n-    ret {inputs: vec::map(decl.inputs, bind fold_arg_(_, fld)),\n+    ret {inputs: vec::map(decl.inputs, {|x| fold_arg_(x, fld)}),\n          output: fld.fold_ty(decl.output),\n          purity: decl.purity,\n          cf: decl.cf,\n@@ -147,16 +147,16 @@ fn fold_ty_param_bound(tpb: ty_param_bound, fld: ast_fold) -> ty_param_bound {\n fn fold_ty_param(tp: ty_param, fld: ast_fold) -> ty_param {\n     {ident: /* FIXME: bad */ copy tp.ident,\n      id: fld.new_id(tp.id),\n-     bounds: @vec::map(*tp.bounds, fold_ty_param_bound(_, fld))}\n+     bounds: @vec::map(*tp.bounds, {|x|fold_ty_param_bound(x, fld)})}\n }\n \n fn fold_ty_params(tps: [ty_param], fld: ast_fold) -> [ty_param] {\n-    vec::map(tps, fold_ty_param(_, fld))\n+    vec::map(tps, {|x|fold_ty_param(x, fld)})\n }\n \n fn noop_fold_crate(c: crate_, fld: ast_fold) -> crate_ {\n-    let fold_meta_item = bind fold_meta_item_(_, fld);\n-    let fold_attribute = bind fold_attribute_(_, fld);\n+    let fold_meta_item = {|x|fold_meta_item_(x, fld)};\n+    let fold_attribute = {|x|fold_attribute_(x, fld)};\n \n     ret {directives: vec::map(c.directives, fld.fold_crate_directive),\n          module: fld.fold_mod(c.module),\n@@ -186,8 +186,8 @@ fn noop_fold_view_item(vi: view_item_, _fld: ast_fold) -> view_item_ {\n \n \n fn noop_fold_native_item(&&ni: @native_item, fld: ast_fold) -> @native_item {\n-    let fold_arg = bind fold_arg_(_, fld);\n-    let fold_attribute = bind fold_attribute_(_, fld);\n+    let fold_arg = {|x|fold_arg_(x, fld)};\n+    let fold_attribute = {|x|fold_attribute_(x, fld)};\n \n     ret @{ident: fld.fold_ident(ni.ident),\n           attrs: vec::map(ni.attrs, fold_attribute),\n@@ -209,7 +209,7 @@ fn noop_fold_native_item(&&ni: @native_item, fld: ast_fold) -> @native_item {\n }\n \n fn noop_fold_item(&&i: @item, fld: ast_fold) -> @item {\n-    let fold_attribute = bind fold_attribute_(_, fld);\n+    let fold_attribute = {|x|fold_attribute_(x, fld)};\n \n     ret @{ident: fld.fold_ident(i.ident),\n           attrs: vec::map(i.attrs, fold_attribute),\n@@ -381,9 +381,9 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n                   expr: fld.fold_expr(field.node.expr)},\n              span: fld.new_span(field.span)};\n     }\n-    let fold_field = bind fold_field_(_, fld);\n+    let fold_field = {|x|fold_field_(x, fld)};\n \n-    let fold_mac = bind fold_mac_(_, fld);\n+    let fold_mac = {|x|fold_mac_(x, fld)};\n \n     ret alt e {\n           expr_new(p, i, v) {\n@@ -406,10 +406,6 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n             expr_call(fld.fold_expr(f), fld.map_exprs(fld.fold_expr, args),\n                       blk)\n           }\n-          expr_bind(f, args) {\n-            let opt_map_se = bind option::map(_, fld.fold_expr);\n-            expr_bind(fld.fold_expr(f), vec::map(args, opt_map_se))\n-          }\n           expr_binary(binop, lhs, rhs) {\n             expr_binary(binop, fld.fold_expr(lhs), fld.fold_expr(rhs))\n           }\n@@ -483,7 +479,7 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n }\n \n fn noop_fold_ty(t: ty_, fld: ast_fold) -> ty_ {\n-    let fold_mac = bind fold_mac_(_, fld);\n+    let fold_mac = {|x|fold_mac_(x, fld)};\n     fn fold_mt(mt: mt, fld: ast_fold) -> mt {\n         {ty: fld.fold_ty(mt.ty), mutbl: mt.mutbl}\n     }\n@@ -536,10 +532,10 @@ fn noop_fold_variant(v: variant_, fld: ast_fold) -> variant_ {\n     fn fold_variant_arg_(va: variant_arg, fld: ast_fold) -> variant_arg {\n         ret {ty: fld.fold_ty(va.ty), id: fld.new_id(va.id)};\n     }\n-    let fold_variant_arg = bind fold_variant_arg_(_, fld);\n+    let fold_variant_arg = {|x|fold_variant_arg_(x, fld)};\n     let args = vec::map(v.args, fold_variant_arg);\n \n-    let fold_attribute = bind fold_attribute_(_, fld);\n+    let fold_attribute = {|x|fold_attribute_(x, fld)};\n     let attrs = vec::map(v.attrs, fold_attribute);\n \n     let de = alt v.disr_expr {"}, {"sha": "4ebdd0dd5b54d3b36321913669c9124ee10ccbb1", "filename": "src/libsyntax/parse.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Flibsyntax%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Flibsyntax%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -17,8 +17,9 @@ import attr::parser_attr;\n import common::parser_common;\n import ast::node_id;\n import util::interner;\n-import lexer::{string_reader_as_reader, tt_reader_as_reader,\n-               reader, string_reader, tt_reader};\n+// FIXME: resolve badness\n+import lexer::*;//{string_reader_as_reader, tt_reader_as_reader,\n+               //reader, string_reader, tt_reader};\n import diagnostic::{span_handler, mk_span_handler, mk_handler, emitter};\n \n type parse_sess = @{"}, {"sha": "146c3ab3de97eedd867b4b9759f01d5945ac59d8", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 3, "deletions": 24, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -829,14 +829,6 @@ class parser {\n             let ex_ext = self.parse_syntax_ext();\n             hi = ex_ext.span.hi;\n             ex = ex_ext.node;\n-        } else if self.eat_keyword(\"bind\") {\n-            let e = self.parse_expr_res(RESTRICT_NO_CALL_EXPRS);\n-            let es = self.parse_unspanned_seq(\n-                token::LPAREN, token::RPAREN,\n-                seq_sep_trailing_disallowed(token::COMMA),\n-                {|p| p.parse_expr_or_hole()});\n-            hi = self.span.hi;\n-            ex = expr_bind(e, es);\n         } else if self.eat_keyword(\"fail\") {\n             if can_begin_expr(self.token) {\n                 let e = self.parse_expr();\n@@ -1008,19 +1000,13 @@ class parser {\n             alt copy self.token {\n               // expr(...)\n               token::LPAREN if self.permits_call() {\n-                let es_opt = self.parse_unspanned_seq(\n+                let es = self.parse_unspanned_seq(\n                     token::LPAREN, token::RPAREN,\n                     seq_sep_trailing_disallowed(token::COMMA),\n-                    {|p| p.parse_expr_or_hole()});\n+                    {|p| p.parse_expr()});\n                 hi = self.span.hi;\n \n-                let nd =\n-                    if vec::any(es_opt, {|e| option::is_none(e) }) {\n-                    expr_bind(self.to_expr(e), es_opt)\n-                } else {\n-                    let es = vec::map(es_opt) {|e| option::get(e) };\n-                    expr_call(self.to_expr(e), es, false)\n-                };\n+                let nd = expr_call(self.to_expr(e), es, false);\n                 e = self.mk_pexpr(lo, hi, nd);\n               }\n \n@@ -1370,13 +1356,6 @@ class parser {\n         ret self.parse_expr_res(UNRESTRICTED);\n     }\n \n-    fn parse_expr_or_hole() -> option<@expr> {\n-        alt self.token {\n-          token::UNDERSCORE { self.bump(); ret none; }\n-          _ { ret some(self.parse_expr()); }\n-        }\n-    }\n-\n     fn parse_expr_res(r: restriction) -> @expr {\n         let old = self.restriction;\n         self.restriction = r;"}, {"sha": "39327f1efadbc5fa45201c4f29a2384a1cbe83f1", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -250,7 +250,6 @@ fn contextual_keyword_table() -> hashmap<str, ()> {\n     let words = str_hash();\n     let keys = [\n         \"as\",\n-        \"bind\",\n         \"else\",\n         \"implements\",\n         \"move\","}, {"sha": "6bd9e79b727e4ccaee8c1d2d43e50490548b20fa", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -102,7 +102,7 @@ fn typarams_to_str(tps: [ast::ty_param]) -> str {\n }\n \n fn path_to_str(&&p: @ast::path) -> str {\n-    ret to_str(p, bind print_path(_, _, false));\n+    ret to_str(p, {|a,b|print_path(a, b, false)});\n }\n \n fn fun_to_str(decl: ast::fn_decl, name: ast::ident,\n@@ -840,7 +840,7 @@ fn print_mac(s: ps, m: ast::mac) {\n           some(@{node: ast::expr_vec(_, _), _}) { }\n           _ { word(s.s, \" \"); }\n         }\n-        option::iter(arg, bind print_expr(s, _));\n+        option::iter(arg, {|a|print_expr(s, a)});\n         // FIXME: extension 'body' (#2339)\n       }\n       ast::mac_embed_type(ty) {\n@@ -938,24 +938,6 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n             print_expr(s, option::get(blk));\n         }\n       }\n-      ast::expr_bind(func, args) {\n-        fn print_opt(s: ps, expr: option<@ast::expr>) {\n-            alt expr {\n-              some(expr) { print_expr(s, expr); }\n-              _ { word(s.s, \"_\"); }\n-            }\n-        }\n-\n-        // \"bind\" keyword is only needed if there are no \"_\" arguments.\n-        if !vec::any(args) {|arg| option::is_none(arg) } {\n-            word_nbsp(s, \"bind\");\n-        }\n-\n-        print_expr(s, func);\n-        popen(s);\n-        commasep(s, inconsistent, args, print_opt);\n-        pclose(s);\n-      }\n       ast::expr_binary(op, lhs, rhs) {\n         let prec = operator_prec(op);\n         print_op_maybe_parens(s, lhs, prec);\n@@ -1780,7 +1762,7 @@ fn ast_ty_fn_constr_to_str(&&c: @ast::constr) -> str {\n }\n \n fn ast_fn_constr_to_str(decl: ast::fn_decl, &&c: @ast::constr) -> str {\n-    let arg_to_str = bind fn_arg_idx_to_str(decl, _);\n+    let arg_to_str = {|a|fn_arg_idx_to_str(decl, a)};\n     ret path_to_str(c.node.path) +\n             constr_args_to_str(arg_to_str, c.node.args);\n }"}, {"sha": "3b5b73d78deb2983c2f27a322a71dc818be7acd1", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 43, "deletions": 38, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -65,22 +65,22 @@ type visitor<E> =\n       visit_class_item: fn@(@class_member, E, vt<E>)};\n \n fn default_visitor<E>() -> visitor<E> {\n-    ret @{visit_mod: bind visit_mod::<E>(_, _, _, _, _),\n-          visit_view_item: bind visit_view_item::<E>(_, _, _),\n-          visit_native_item: bind visit_native_item::<E>(_, _, _),\n-          visit_item: bind visit_item::<E>(_, _, _),\n-          visit_local: bind visit_local::<E>(_, _, _),\n-          visit_block: bind visit_block::<E>(_, _, _),\n-          visit_stmt: bind visit_stmt::<E>(_, _, _),\n-          visit_arm: bind visit_arm::<E>(_, _, _),\n-          visit_pat: bind visit_pat::<E>(_, _, _),\n-          visit_decl: bind visit_decl::<E>(_, _, _),\n-          visit_expr: bind visit_expr::<E>(_, _, _),\n-          visit_ty: bind skip_ty::<E>(_, _, _),\n-          visit_ty_params: bind visit_ty_params::<E>(_, _, _),\n-          visit_constr: bind visit_constr::<E>(_, _, _, _, _),\n-          visit_fn: bind visit_fn::<E>(_, _, _, _, _, _, _),\n-          visit_class_item: bind visit_class_item::<E>(_,_,_)};\n+    ret @{visit_mod: {|a,b,c,d,e|visit_mod::<E>(a, b, c, d, e)},\n+          visit_view_item: {|a,b,c|visit_view_item::<E>(a, b, c)},\n+          visit_native_item: {|a,b,c|visit_native_item::<E>(a, b, c)},\n+          visit_item: {|a,b,c|visit_item::<E>(a, b, c)},\n+          visit_local: {|a,b,c|visit_local::<E>(a, b, c)},\n+          visit_block: {|a,b,c|visit_block::<E>(a, b, c)},\n+          visit_stmt: {|a,b,c|visit_stmt::<E>(a, b, c)},\n+          visit_arm: {|a,b,c|visit_arm::<E>(a, b, c)},\n+          visit_pat: {|a,b,c|visit_pat::<E>(a, b, c)},\n+          visit_decl: {|a,b,c|visit_decl::<E>(a, b, c)},\n+          visit_expr: {|a,b,c|visit_expr::<E>(a, b, c)},\n+          visit_ty: {|a,b,c|skip_ty::<E>(a, b, c)},\n+          visit_ty_params: {|a,b,c|visit_ty_params::<E>(a, b, c)},\n+          visit_constr: {|a,b,c,d,e|visit_constr::<E>(a, b, c, d, e)},\n+          visit_fn: {|a,b,c,d,e,f,g|visit_fn::<E>(a, b, c, d, e, f, g)},\n+          visit_class_item: {|a,b,c|visit_class_item::<E>(a, b, c)}};\n }\n \n fn visit_crate<E>(c: crate, e: E, v: vt<E>) {\n@@ -377,10 +377,6 @@ fn visit_expr<E>(ex: @expr, e: E, v: vt<E>) {\n         visit_exprs(args, e, v);\n         v.visit_expr(callee, e, v);\n       }\n-      expr_bind(callee, args) {\n-        v.visit_expr(callee, e, v);\n-        for args.each {|eo| visit_expr_opt(eo, e, v); }\n-      }\n       expr_binary(_, a, b) { v.visit_expr(a, e, v); v.visit_expr(b, e, v); }\n       expr_addr_of(_, x) | expr_unary(_, x) |\n       expr_loop_body(x) | expr_do_body(x) |\n@@ -559,34 +555,43 @@ fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n         visit_fn(fk, decl, body, sp, id, e, v);\n     }\n     let visit_ty = if v.visit_ty == simple_ignore_ty {\n-        bind skip_ty(_, _, _)\n+        {|a,b,c| skip_ty(a, b, c)}\n     } else {\n-        bind v_ty(v.visit_ty, _, _, _)\n+        {|a,b,c| v_ty(v.visit_ty, a, b, c)}\n     };\n     fn v_class_item(f: fn@(@class_member),\n                     cm: @class_member, &&e: (),\n                     v: vt<()>) {\n         f(cm);\n         visit_class_item(cm, e, v);\n     }\n-    ret mk_vt(@{visit_mod: bind v_mod(v.visit_mod, _, _, _, _, _),\n-                visit_view_item: bind v_view_item(v.visit_view_item, _, _, _),\n+    ret mk_vt(@{visit_mod: {|a,b,c,d,e|v_mod(v.visit_mod, a, b, c, d, e)},\n+                visit_view_item: {|a,b,c|\n+                    v_view_item(v.visit_view_item, a, b, c)\n+                },\n                 visit_native_item:\n-                    bind v_native_item(v.visit_native_item, _, _, _),\n-                visit_item: bind v_item(v.visit_item, _, _, _),\n-                visit_local: bind v_local(v.visit_local, _, _, _),\n-                visit_block: bind v_block(v.visit_block, _, _, _),\n-                visit_stmt: bind v_stmt(v.visit_stmt, _, _, _),\n-                visit_arm: bind v_arm(v.visit_arm, _, _, _),\n-                visit_pat: bind v_pat(v.visit_pat, _, _, _),\n-                visit_decl: bind v_decl(v.visit_decl, _, _, _),\n-                visit_expr: bind v_expr(v.visit_expr, _, _, _),\n+                    {|a,b,c|v_native_item(v.visit_native_item, a, b, c)},\n+                visit_item: {|a,b,c|v_item(v.visit_item, a, b, c)},\n+                visit_local: {|a,b,c|v_local(v.visit_local, a, b, c)},\n+                visit_block: {|a,b,c|v_block(v.visit_block, a, b, c)},\n+                visit_stmt: {|a,b,c|v_stmt(v.visit_stmt, a, b, c)},\n+                visit_arm: {|a,b,c|v_arm(v.visit_arm, a, b, c)},\n+                visit_pat: {|a,b,c|v_pat(v.visit_pat, a, b, c)},\n+                visit_decl: {|a,b,c|v_decl(v.visit_decl, a, b, c)},\n+                visit_expr: {|a,b,c|v_expr(v.visit_expr, a, b, c)},\n                 visit_ty: visit_ty,\n-                visit_ty_params: bind v_ty_params(v.visit_ty_params, _, _, _),\n-                visit_constr: bind v_constr(v.visit_constr, _, _, _, _, _),\n-                visit_fn: bind v_fn(v.visit_fn, _, _, _, _, _, _, _),\n-                visit_class_item: bind v_class_item(v.visit_class_item, _, _,\n-                                                    _)\n+                visit_ty_params: {|a,b,c|\n+                    v_ty_params(v.visit_ty_params, a, b, c)\n+                },\n+                visit_constr: {|a,b,c,d,e|\n+                    v_constr(v.visit_constr, a, b, c, d, e)\n+                },\n+                visit_fn: {|a,b,c,d,e,f,g|\n+                    v_fn(v.visit_fn, a, b, c, d, e, f, g)\n+                },\n+                visit_class_item: {|a,b,c|\n+                    v_class_item(v.visit_class_item, a, b, c)\n+                }\n                });\n }\n "}, {"sha": "e37d4270215808e93aff9fcd77c00316b55c5018", "filename": "src/rustc/back/rpath.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Frpath.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -94,7 +94,10 @@ fn get_rpaths_relative_to_output(os: session::os,\n                                  cwd: path::path,\n                                  output: path::path,\n                                  libs: [path::path]) -> [str] {\n-    vec::map(libs, bind get_rpath_relative_to_output(os, cwd, output, _))\n+    vec::map(libs, {|a|\n+        check not_win32(os);\n+        get_rpath_relative_to_output(os, cwd, output, a)\n+    })\n }\n \n fn get_rpath_relative_to_output(os: session::os,\n@@ -149,7 +152,7 @@ fn get_relative_to(abs1: path::path, abs2: path::path) -> path::path {\n }\n \n fn get_absolute_rpaths(cwd: path::path, libs: [path::path]) -> [str] {\n-    vec::map(libs, bind get_absolute_rpath(cwd, _))\n+    vec::map(libs, {|a|get_absolute_rpath(cwd, a)})\n }\n \n fn get_absolute_rpath(cwd: path::path, &&lib: path::path) -> str {"}, {"sha": "e6a61a1d07835602168be3df73ba8ff6ea5ccd93", "filename": "src/rustc/back/upcall.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Fupcall.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -43,8 +43,8 @@ fn declare_upcalls(targ_cfg: @session::config,\n     fn nothrow(f: ValueRef) -> ValueRef {\n         base::set_no_unwind(f); f\n     }\n-    let d = bind decl(llmod, \"upcall_\", _, _, _);\n-    let dv = bind decl(llmod, \"upcall_\", _, _, T_void());\n+    let d = {|a,b,c|decl(llmod, \"upcall_\", a, b, c)};\n+    let dv = {|a,b|decl(llmod, \"upcall_\", a, b, T_void())};\n \n     let int_t = T_int(targ_cfg);\n     let size_t = T_size_t(targ_cfg);"}, {"sha": "2cd9c392ef4f4891d08183cbd3bfe883e3c7327f", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 59, "deletions": 47, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -132,83 +132,95 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n     -> {crate: @ast::crate, tcx: option<ty::ctxt>} {\n     let time_passes = sess.time_passes();\n     let mut crate = time(time_passes, \"parsing\",\n-                         bind parse_input(sess, cfg, input));\n+                         {||parse_input(sess, cfg, input)});\n     if upto == cu_parse { ret {crate: crate, tcx: none}; }\n \n     sess.building_library = session::building_library(\n         sess.opts.crate_type, crate, sess.opts.test);\n \n     crate =\n         time(time_passes, \"configuration\",\n-             bind front::config::strip_unconfigured_items(crate));\n+             {|copy crate|front::config::strip_unconfigured_items(crate)});\n     crate =\n         time(time_passes, \"maybe building test harness\",\n-             bind front::test::modify_for_testing(sess, crate));\n+             {|copy crate|front::test::modify_for_testing(sess, crate)});\n     crate =\n         time(time_passes, \"expansion\",\n-             bind syntax::ext::expand::expand_crate(\n-                 sess.parse_sess, sess.opts.cfg, crate));\n+             {|copy crate|syntax::ext::expand::expand_crate(\n+                 sess.parse_sess, sess.opts.cfg, crate)});\n \n     if upto == cu_expand { ret {crate: crate, tcx: none}; }\n \n     crate =\n-        time(time_passes, \"intrinsic injection\",\n-             bind front::intrinsic_inject::inject_intrinsic(sess, crate));\n+        time(time_passes, \"intrinsic injection\", {|copy crate|\n+            front::intrinsic_inject::inject_intrinsic(sess, crate)\n+        });\n \n     crate =\n-        time(time_passes, \"core injection\",\n-             bind front::core_inject::maybe_inject_libcore_ref(sess, crate));\n+        time(time_passes, \"core injection\", {|copy crate|\n+            front::core_inject::maybe_inject_libcore_ref(sess, crate)\n+        });\n \n-    time(time_passes, \"building warning settings table\",\n-         bind lint::build_settings_crate(sess, crate));\n+    time(time_passes, \"building warning settings table\", {|copy crate|\n+        lint::build_settings_crate(sess, crate)\n+    });\n \n     let ast_map =\n-        time(time_passes, \"ast indexing\",\n-             bind syntax::ast_map::map_crate(sess.diagnostic(), *crate));\n-    time(time_passes, \"external crate/lib resolution\",\n-         bind creader::read_crates(\n-             sess.diagnostic(), *crate, sess.cstore,\n-             sess.filesearch,\n-             session::sess_os_to_meta_os(sess.targ_cfg.os),\n-             sess.opts.static));\n+        time(time_passes, \"ast indexing\", {|copy crate|\n+            syntax::ast_map::map_crate(sess.diagnostic(), *crate)\n+        });\n+    time(time_passes, \"external crate/lib resolution\", {|copy crate|\n+        creader::read_crates(\n+            sess.diagnostic(), *crate, sess.cstore,\n+            sess.filesearch,\n+            session::sess_os_to_meta_os(sess.targ_cfg.os),\n+            sess.opts.static)\n+    });\n     let {def_map, exp_map, impl_map} =\n-        time(time_passes, \"resolution\",\n-             bind resolve::resolve_crate(sess, ast_map, crate));\n+        time(time_passes, \"resolution\", {|copy crate|\n+            resolve::resolve_crate(sess, ast_map, crate)\n+        });\n     let freevars =\n-        time(time_passes, \"freevar finding\",\n-             bind freevars::annotate_freevars(def_map, crate));\n+        time(time_passes, \"freevar finding\", {|copy crate|\n+            freevars::annotate_freevars(def_map, crate)\n+        });\n     let region_map =\n-        time(time_passes, \"region resolution\",\n-             bind middle::region::resolve_crate(sess, def_map, crate));\n+        time(time_passes, \"region resolution\", {|copy crate|\n+            middle::region::resolve_crate(sess, def_map, crate)\n+        });\n     let ty_cx = ty::mk_ctxt(sess, def_map, ast_map, freevars, region_map);\n     let (method_map, vtable_map) =\n-        time(time_passes, \"typechecking\",\n-             bind typeck::check_crate(ty_cx, impl_map, crate));\n-    time(time_passes, \"const checking\",\n-         bind middle::check_const::check_crate(sess, crate, ast_map, def_map,\n-                                               method_map, ty_cx));\n+        time(time_passes, \"typechecking\", {|copy crate|\n+            typeck::check_crate(ty_cx, impl_map, crate)\n+        });\n+    time(time_passes, \"const checking\", {|copy crate|\n+        middle::check_const::check_crate(\n+            sess, crate, ast_map, def_map, method_map, ty_cx)\n+    });\n \n     if upto == cu_typeck { ret {crate: crate, tcx: some(ty_cx)}; }\n \n     time(time_passes, \"block-use checking\",\n-         bind middle::block_use::check_crate(ty_cx, crate));\n+         {|copy crate|middle::block_use::check_crate(ty_cx, crate)});\n     time(time_passes, \"loop checking\",\n-         bind middle::check_loop::check_crate(ty_cx, crate));\n+         {|copy crate|middle::check_loop::check_crate(ty_cx, crate)});\n     time(time_passes, \"alt checking\",\n-         bind middle::check_alt::check_crate(ty_cx, crate));\n+         {|copy crate|middle::check_alt::check_crate(ty_cx, crate)});\n     let last_use_map =\n-        time(time_passes, \"liveness checking\",\n-             bind middle::liveness::check_crate(ty_cx, method_map, crate));\n+        time(time_passes, \"liveness checking\", {|copy crate|\n+            middle::liveness::check_crate(ty_cx, method_map, crate)\n+        });\n     time(time_passes, \"typestate checking\",\n-         bind middle::tstate::ck::check_crate(ty_cx, crate));\n+         {|copy crate|middle::tstate::ck::check_crate(ty_cx, crate)});\n     let (root_map, mutbl_map) = time(\n         time_passes, \"borrow checking\",\n-        bind middle::borrowck::check_crate(ty_cx, method_map,\n-                                           last_use_map, crate));\n-    time(time_passes, \"kind checking\",\n-         bind kind::check_crate(ty_cx, method_map, last_use_map, crate));\n+        {|copy crate|middle::borrowck::check_crate(ty_cx, method_map,\n+                                         last_use_map, crate)});\n+    time(time_passes, \"kind checking\", {|copy crate|\n+        kind::check_crate(ty_cx, method_map, last_use_map, crate)\n+    });\n     time(time_passes, \"lint checking\",\n-         bind lint::check_crate(ty_cx, crate));\n+         {|copy crate|lint::check_crate(ty_cx, crate)});\n \n     if upto == cu_no_trans { ret {crate: crate, tcx: some(ty_cx)}; }\n     let outputs = option::get(outputs);\n@@ -220,11 +232,11 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n \n     let (llmod, link_meta) =\n         time(time_passes, \"translation\",\n-             bind trans::base::trans_crate(\n+             {|copy crate|trans::base::trans_crate(\n                  sess, crate, ty_cx, outputs.obj_filename,\n-                 exp_map, maps));\n+                 exp_map, maps)});\n     time(time_passes, \"LLVM passes\",\n-         bind link::write::run_passes(sess, llmod, outputs.obj_filename));\n+         {||link::write::run_passes(sess, llmod, outputs.obj_filename)});\n \n     let stop_after_codegen =\n         sess.opts.output_type != link::output_type_exe ||\n@@ -233,8 +245,8 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n     if stop_after_codegen { ret {crate: crate, tcx: some(ty_cx)}; }\n \n     time(time_passes, \"linking\",\n-         bind link::link_binary(sess, outputs.obj_filename,\n-                                outputs.out_filename, link_meta));\n+         {||link::link_binary(sess, outputs.obj_filename,\n+                              outputs.out_filename, link_meta)});\n     ret {crate: crate, tcx: some(ty_cx)};\n }\n \n@@ -303,7 +315,7 @@ fn pretty_print_input(sess: session, cfg: ast::crate_cfg, input: input,\n     alt ppm {\n       ppm_typed {\n         ann = {pre: ann_paren_for_expr,\n-               post: bind ann_typed_post(option::get(tcx), _)};\n+               post: {|a|ann_typed_post(option::get(tcx), a)}};\n       }\n       ppm_identified | ppm_expanded_identified {\n         ann = {pre: ann_paren_for_expr, post: ann_identified_post};"}, {"sha": "bc88609d274fd5941d2e6b52141eb628677fb393", "filename": "src/rustc/driver/rustc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Frustc.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -169,7 +169,7 @@ fn run_compiler(args: [str], demitter: diagnostic::emitter) {\n     let pretty =\n         option::map(getopts::opt_default(match, \"pretty\",\n                                          \"normal\"),\n-                    bind parse_pretty(sess, _));\n+                    {|a|parse_pretty(sess, a)});\n     alt pretty {\n       some::<pp_mode>(ppm) { pretty_print_input(sess, cfg, input, ppm); ret; }\n       none::<pp_mode> {/* continue */ }"}, {"sha": "57c1f587f8c645f17e1cf844ad5d24f495a5486c", "filename": "src/rustc/front/config.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Fconfig.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -24,9 +24,9 @@ fn strip_items(crate: @ast::crate, in_cfg: in_cfg_pred)\n     let ctxt = @{in_cfg: in_cfg};\n \n     let precursor =\n-        @{fold_mod: bind fold_mod(ctxt, _, _),\n-          fold_block: fold::wrap(bind fold_block(ctxt, _, _)),\n-          fold_native_mod: bind fold_native_mod(ctxt, _, _)\n+        @{fold_mod: {|a,b|fold_mod(ctxt, a, b)},\n+          fold_block: fold::wrap({|a,b|fold_block(ctxt, a, b)}),\n+          fold_native_mod: {|a,b|fold_native_mod(ctxt, a, b)}\n           with *fold::default_ast_fold()};\n \n     let fold = fold::make_fold(precursor);\n@@ -41,7 +41,7 @@ fn filter_item(cx: ctxt, &&item: @ast::item) ->\n \n fn fold_mod(cx: ctxt, m: ast::_mod, fld: fold::ast_fold) ->\n    ast::_mod {\n-    let filter = bind filter_item(cx, _);\n+    let filter = {|a|filter_item(cx, a)};\n     let filtered_items = vec::filter_map(m.items, filter);\n     ret {view_items: vec::map(m.view_items, fld.fold_view_item),\n          items: vec::map(filtered_items, fld.fold_item)};\n@@ -56,7 +56,7 @@ fn filter_native_item(cx: ctxt, &&item: @ast::native_item) ->\n \n fn fold_native_mod(cx: ctxt, nm: ast::native_mod,\n                    fld: fold::ast_fold) -> ast::native_mod {\n-    let filter = bind filter_native_item(cx, _);\n+    let filter = {|a|filter_native_item(cx, a)};\n     let filtered_items = vec::filter_map(nm.items, filter);\n     ret {view_items: vec::map(nm.view_items, fld.fold_view_item),\n          items: filtered_items};\n@@ -81,7 +81,7 @@ fn filter_stmt(cx: ctxt, &&stmt: @ast::stmt) ->\n \n fn fold_block(cx: ctxt, b: ast::blk_, fld: fold::ast_fold) ->\n    ast::blk_ {\n-    let filter = bind filter_stmt(cx, _);\n+    let filter = {|a|filter_stmt(cx, a)};\n     let filtered_stmts = vec::filter_map(b.stmts, filter);\n     ret {view_items: b.view_items,\n          stmts: vec::map(filtered_stmts, fld.fold_stmt),"}, {"sha": "473d25841b8130b81ab04083b72e99c21b880983", "filename": "src/rustc/front/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Ftest.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -44,9 +44,9 @@ fn generate_test_harness(sess: session::session,\n           testfns: dvec()};\n \n     let precursor =\n-        @{fold_crate: fold::wrap(bind fold_crate(cx, _, _)),\n-          fold_item: bind fold_item(cx, _, _),\n-          fold_mod: bind fold_mod(cx, _, _) with *fold::default_ast_fold()};\n+        @{fold_crate: fold::wrap({|a,b|fold_crate(cx, a, b)}),\n+          fold_item: {|a,b|fold_item(cx, a, b)},\n+          fold_mod: {|a,b|fold_mod(cx, a, b)} with *fold::default_ast_fold()};\n \n     let fold = fold::make_fold(precursor);\n     let res = @fold.fold_crate(*crate);"}, {"sha": "97ccb1d3f246f59b848ce36b43889f1726bcce84", "filename": "src/rustc/metadata/creader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcreader.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -31,8 +31,8 @@ fn read_crates(diag: span_handler, crate: ast::crate,\n               mut next_crate_num: 1};\n     let v =\n         visit::mk_simple_visitor(@{visit_view_item:\n-                                       bind visit_view_item(e, _),\n-                                   visit_item: bind visit_item(e, _)\n+                                       {|a|visit_view_item(e, a)},\n+                                   visit_item: {|a|visit_item(e, a)}\n                                       with *visit::default_simple_visitor()});\n     visit::visit_crate(crate, (), v);\n     dump_crates(e.crate_cache);"}, {"sha": "e8e367656c1230e006895196532d7f5b1d1cc5dc", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -77,7 +77,7 @@ fn maybe_find_item(item_id: int, items: ebml::doc) -> option<ebml::doc> {\n     fn eq_item(bytes: [u8], item_id: int) -> bool {\n         ret io::u64_from_be_bytes(bytes, 0u, 4u) as int == item_id;\n     }\n-    let eqer = bind eq_item(_, item_id);\n+    let eqer = {|a|eq_item(a, item_id)};\n     let found = lookup_hash(items, eqer, hash_node_id(item_id));\n     if vec::len(found) == 0u {\n         ret option::none::<ebml::doc>;\n@@ -213,7 +213,7 @@ fn resolve_path(path: [ast::ident], data: @[u8]) -> [ast::def_id] {\n     let s = ast_util::path_name_i(path);\n     let md = ebml::doc(data);\n     let paths = ebml::get_doc(md, tag_paths);\n-    let eqer = bind eq_item(_, s);\n+    let eqer = {|a|eq_item(a, s)};\n     let mut result: [ast::def_id] = [];\n     #debug(\"resolve_path: looking up %s\", s);\n     for lookup_hash(paths, eqer, hash_path(s)).each {|doc|"}, {"sha": "e8fb1a3596ededf69c092111190768cdcdcd9b6a", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -271,7 +271,7 @@ fn encode_type_param_bounds(ebml_w: ebml::writer, ecx: @encode_ctxt,\n     let ty_str_ctxt = @{diag: ecx.diag,\n                         ds: def_to_str,\n                         tcx: ecx.tcx,\n-                        reachable: reachable(ecx, _),\n+                        reachable: {|a|reachable(ecx, a)},\n                         abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n     for params.each {|param|\n         ebml_w.start_tag(tag_items_data_item_ty_param_bounds);\n@@ -292,7 +292,7 @@ fn write_type(ecx: @encode_ctxt, ebml_w: ebml::writer, typ: ty::t) {\n         @{diag: ecx.diag,\n           ds: def_to_str,\n           tcx: ecx.tcx,\n-          reachable: reachable(ecx, _),\n+          reachable: {|a|reachable(ecx, a)},\n           abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n     tyencode::enc_ty(ebml_w.writer, ty_str_ctxt, typ);\n }\n@@ -551,7 +551,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n                      index: @mut [entry<int>]) {\n         *index += [{val: item.id, pos: ebml_w.writer.tell()}];\n     }\n-    let add_to_index = bind add_to_index_(item, copy ebml_w, index);\n+    let add_to_index = {|copy ebml_w|add_to_index_(item, ebml_w, index)};\n \n     alt item.node {\n       item_const(_, _) {"}, {"sha": "f7c4628e51ca4aedf4e0b94cbe7d181760f0faec", "filename": "src/rustc/metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftydecode.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -37,7 +37,7 @@ fn next_byte(st: @pstate) -> u8 {\n \n fn parse_ident(st: @pstate, last: char) -> ast::ident {\n     fn is_last(b: char, c: char) -> bool { ret c == b; }\n-    ret parse_ident_(st, bind is_last(last, _));\n+    ret parse_ident_(st, {|a|is_last(last, a)});\n }\n \n fn parse_ident_(st: @pstate, is_last: fn@(char) -> bool) ->"}, {"sha": "b275ebcb3ae1556e7faccffaa973e21256f391fc", "filename": "src/rustc/middle/astencode.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fastencode.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -445,8 +445,8 @@ fn decode_ast(par_doc: ebml::doc) -> ast::inlined_item {\n fn renumber_ast(xcx: extended_decode_ctxt, ii: ast::inlined_item)\n     -> ast::inlined_item {\n     let fld = fold::make_fold(@{\n-        new_id: xcx.tr_id(_),\n-        new_span: xcx.tr_span(_)\n+        new_id: {|a|xcx.tr_id(a)},\n+        new_span: {|a|xcx.tr_span(a)}\n         with *fold::default_ast_fold()\n     });\n \n@@ -697,7 +697,7 @@ impl helpers for @e::encode_ctxt {\n         @{diag: self.tcx.sess.diagnostic(),\n           ds: e::def_to_str,\n           tcx: self.tcx,\n-          reachable: encoder::reachable(self, _),\n+          reachable: {|a|encoder::reachable(self, a)},\n           abbrevs: tyencode::ac_use_abbrevs(self.type_abbrevs)}\n     }\n }\n@@ -903,7 +903,7 @@ impl decoder for ebml::ebml_deserializer {\n \n         tydecode::parse_ty_data(\n             self.parent.data, xcx.dcx.cdata.cnum, self.pos, xcx.dcx.tcx,\n-            xcx.tr_def_id(_))\n+            {|a|xcx.tr_def_id(a)})\n     }\n \n     fn read_tys(xcx: extended_decode_ctxt) -> [ty::t] {\n@@ -913,7 +913,7 @@ impl decoder for ebml::ebml_deserializer {\n     fn read_bounds(xcx: extended_decode_ctxt) -> @[ty::param_bound] {\n         tydecode::parse_bounds_data(\n             self.parent.data, self.pos, xcx.dcx.cdata.cnum, xcx.dcx.tcx,\n-            xcx.tr_def_id(_))\n+            {|a|xcx.tr_def_id(a)})\n     }\n \n     fn read_ty_param_bounds_and_ty(xcx: extended_decode_ctxt)"}, {"sha": "cdfb2a08c6860bd75d764e9ae75e74d26ba68508", "filename": "src/rustc/middle/borrowck/categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -170,7 +170,7 @@ impl public_methods for borrowck_ctxt {\n             self.cat_def(expr.id, expr.span, expr_ty, def)\n           }\n \n-          ast::expr_addr_of(*) | ast::expr_call(*) | ast::expr_bind(*) |\n+          ast::expr_addr_of(*) | ast::expr_call(*) |\n           ast::expr_swap(*) | ast::expr_move(*) | ast::expr_assign(*) |\n           ast::expr_assign_op(*) | ast::expr_fn(*) | ast::expr_fn_block(*) |\n           ast::expr_assert(*) | ast::expr_check(*) | ast::expr_ret(*) |"}, {"sha": "20bbce07d75ffb17380fe595b84e68044044d10b", "filename": "src/rustc/middle/check_alt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_alt.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -13,8 +13,8 @@ import std::map::hashmap;\n \n fn check_crate(tcx: ty::ctxt, crate: @crate) {\n     visit::visit_crate(*crate, (), visit::mk_vt(@{\n-        visit_expr: bind check_expr(tcx, _, _, _),\n-        visit_local: bind check_local(tcx, _, _, _)\n+        visit_expr: {|a,b,c|check_expr(tcx, a, b, c)},\n+        visit_local: {|a,b,c|check_local(tcx, a, b, c)}\n         with *visit::default_visitor::<()>()\n     }));\n     tcx.sess.abort_if_errors();"}, {"sha": "9abeda8dded0847bf01eab9091a70ffdded1cdae", "filename": "src/rustc/middle/check_const.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_const.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -8,9 +8,11 @@ fn check_crate(sess: session, crate: @crate, ast_map: ast_map::map,\n                def_map: resolve::def_map,\n                 method_map: typeck::method_map, tcx: ty::ctxt) {\n     visit::visit_crate(*crate, false, visit::mk_vt(@{\n-        visit_item: check_item(sess, ast_map, def_map, _, _, _),\n+        visit_item: {|a,b,c|check_item(sess, ast_map, def_map, a, b, c)},\n         visit_pat: check_pat,\n-        visit_expr: bind check_expr(sess, def_map, method_map, tcx, _, _, _)\n+        visit_expr: {|a,b,c|\n+            check_expr(sess, def_map, method_map, tcx, a, b, c)\n+        }\n         with *visit::default_visitor()\n     }));\n     sess.abort_if_errors();"}, {"sha": "2f9e8472022e165ae36b46a9b30bf81b0c31db7c", "filename": "src/rustc/middle/kind.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fkind.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -240,9 +240,6 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n       expr_tup(exprs) | expr_vec(exprs, _) {\n         for exprs.each {|expr| maybe_copy(cx, expr); }\n       }\n-      expr_bind(_, args) {\n-        for args.each {|a| alt a { some(ex) { maybe_copy(cx, ex); } _ {} } }\n-      }\n       expr_call(f, args, _) {\n         let mut i = 0u;\n         for ty::ty_fn_args(ty::expr_ty(cx.tcx, f)).each {|arg_t|"}, {"sha": "8006b7987952e35a85cfccaedaf534ad58bcb10a", "filename": "src/rustc/middle/lint.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flint.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -331,7 +331,7 @@ fn check_item_while_true(cx: ty::ctxt, it: @ast::item) {\n                 alt cond.node {\n                     ast::expr_lit(@{node: ast::lit_bool(true),_}) {\n                             cx.sess.span_lint(\n-                                while_true, it.id, e.id,\n+                                while_true, e.id, it.id,\n                                 e.span,\n                                 \"denote infinite loops with loop { ... }\");\n                     }\n@@ -357,14 +357,14 @@ fn check_item_ctypes(cx: ty::ctxt, it: @ast::item) {\n                 alt cx.def_map.get(id) {\n                   ast::def_prim_ty(ast::ty_int(ast::ty_i)) {\n                     cx.sess.span_lint(\n-                        ctypes, fn_id, id,\n+                        ctypes, id, fn_id,\n                         ty.span,\n                         \"found rust type `int` in native module, while \\\n                          libc::c_int or libc::c_long should be used\");\n                   }\n                   ast::def_prim_ty(ast::ty_uint(ast::ty_u)) {\n                     cx.sess.span_lint(\n-                        ctypes, fn_id, id,\n+                        ctypes, id, fn_id,\n                         ty.span,\n                         \"found rust type `uint` in native module, while \\\n                          libc::c_uint or libc::c_ulong should be used\");\n@@ -400,7 +400,7 @@ fn check_item_path_statement(cx: ty::ctxt, it: @ast::item) {\n                                node: ast::expr_path(@path),\n                                span: _}, _) {\n                 cx.sess.span_lint(\n-                    path_statement, it.id, id,\n+                    path_statement, id, it.id,\n                     s.span,\n                     \"path statement with no effect\");\n               }\n@@ -423,7 +423,7 @@ fn check_item_old_vecs(cx: ty::ctxt, it: @ast::item) {\n               ast::expr_lit(@{node: ast::lit_str(_), span:_})\n               if ! uses_vstore.contains_key(e.id) {\n                 cx.sess.span_lint(\n-                    old_vecs, it.id, e.id,\n+                    old_vecs, e.id, it.id,\n                     e.span, \"deprecated vec/str expr\");\n               }\n               ast::expr_vstore(@inner, _) {\n@@ -438,15 +438,15 @@ fn check_item_old_vecs(cx: ty::ctxt, it: @ast::item) {\n               ast::ty_vec(_)\n               if ! uses_vstore.contains_key(t.id) {\n                 cx.sess.span_lint(\n-                    old_vecs, it.id, t.id,\n+                    old_vecs, t.id, it.id,\n                     t.span, \"deprecated vec type\");\n               }\n \n               ast::ty_path(@{span: _, global: _, idents: ids,\n                              rp: none, types: _}, _)\n               if ids == [@\"str\"] && (! uses_vstore.contains_key(t.id)) {\n                 cx.sess.span_lint(\n-                    old_vecs, it.id, t.id,\n+                    old_vecs, t.id, it.id,\n                     t.span, \"deprecated str type\");\n               }\n "}, {"sha": "cc8b0383e360577ad79e054db9df2168d9616db6", "filename": "src/rustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fliveness.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -468,7 +468,7 @@ fn visit_expr(expr: @expr, &&self: @ir_maps, vt: vt<@ir_maps>) {\n       // otherwise, live nodes are not required:\n       expr_index(*) | expr_field(*) | expr_vstore(*) |\n       expr_vec(*) | expr_rec(*) | expr_call(*) | expr_tup(*) |\n-      expr_bind(*) | expr_new(*) | expr_log(*) | expr_binary(*) |\n+      expr_new(*) | expr_log(*) | expr_binary(*) |\n       expr_assert(*) | expr_check(*) | expr_addr_of(*) | expr_copy(*) |\n       expr_loop_body(*) | expr_do_body(*) | expr_cast(*) |\n       expr_unary(*) | expr_fail(*) |\n@@ -1081,16 +1081,6 @@ class liveness {\n             self.propagate_through_exprs(exprs, succ)\n           }\n \n-          expr_bind(f, args) {\n-            let succ = args.foldr(succ) { |arg, succ|\n-                alt arg {\n-                  none {succ}\n-                  some(e) {self.propagate_through_expr(e, succ)}\n-                }\n-            };\n-            self.propagate_through_expr(f, succ)\n-          }\n-\n           expr_binary(op, l, r) if ast_util::lazy_binop(op) {\n             let r_succ = self.propagate_through_expr(r, succ);\n \n@@ -1464,7 +1454,7 @@ fn check_expr(expr: @expr, &&self: @liveness, vt: vt<@liveness>) {\n       expr_while(*) | expr_loop(*) |\n       expr_index(*) | expr_field(*) | expr_vstore(*) |\n       expr_vec(*) | expr_rec(*) | expr_tup(*) |\n-      expr_bind(*) | expr_new(*) | expr_log(*) | expr_binary(*) |\n+      expr_new(*) | expr_log(*) | expr_binary(*) |\n       expr_assert(*) | expr_check(*) | expr_copy(*) |\n       expr_loop_body(*) | expr_do_body(*) |\n       expr_cast(*) | expr_unary(*) | expr_fail(*) |"}, {"sha": "fd0ecaa4fd506a7eb4e91e67abef884a066756ee", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -328,8 +328,8 @@ fn map_crate(e: @env, c: @ast::crate) {\n \n     // First, find all the modules, and index the names that they contain\n     let v_map_mod =\n-        @{visit_view_item: bind index_vi(e, _, _, _),\n-          visit_item: bind index_i(e, _, _, _),\n+        @{visit_view_item: {|a,b,c|index_vi(e, a, b, c)},\n+          visit_item: {|a,b,c|index_i(e, a, b, c)},\n           visit_block: visit_block_with_scope\n           with *visit::default_visitor::<scopes>()};\n     visit::visit_crate(*c, top_scope(), visit::mk_vt(v_map_mod));\n@@ -345,9 +345,9 @@ fn map_crate(e: @env, c: @ast::crate) {\n \n     // Next, assemble the links for globbed imports and exports.\n     let v_link_glob =\n-        @{visit_view_item: bind link_glob(e, _, _, _),\n+        @{visit_view_item: {|a,b,c|link_glob(e, a, b, c)},\n           visit_block: visit_block_with_scope,\n-          visit_item: bind visit_item_with_scope(e, _, _, _)\n+          visit_item: {|a,b,c|visit_item_with_scope(e, a, b, c)}\n           with *visit::default_visitor::<scopes>()};\n     visit::visit_crate(*c, top_scope(), visit::mk_vt(v_link_glob));\n \n@@ -414,17 +414,19 @@ fn resolve_names(e: @env, c: @ast::crate) {\n     e.used_imports.track = true;\n     let v =\n         @{visit_native_item: visit_native_item_with_scope,\n-          visit_item: bind walk_item(e, _, _, _),\n+          visit_item: {|a,b,c|walk_item(e, a, b, c)},\n           visit_block: visit_block_with_scope,\n           visit_decl: visit_decl_with_scope,\n           visit_arm: visit_arm_with_scope,\n-          visit_local: bind visit_local_with_scope(e, _, _, _),\n-          visit_pat: bind walk_pat(e, _, _, _),\n-          visit_expr: bind walk_expr(e, _, _, _),\n-          visit_ty: bind walk_ty(e, _, _, _),\n-          visit_ty_params: bind walk_tps(e, _, _, _),\n-          visit_constr: bind walk_constr(e, _, _, _, _, _),\n-          visit_fn: bind visit_fn_with_scope(e, _, _, _, _, _, _, _)\n+          visit_local: {|a,b,c|visit_local_with_scope(e, a, b, c)},\n+          visit_pat: {|a,b,c|walk_pat(e, a, b, c)},\n+          visit_expr: {|a,b,c|walk_expr(e, a, b ,c)},\n+          visit_ty: {|a,b,c|walk_ty(e, a, b, c)},\n+          visit_ty_params: {|a,b,c|walk_tps(e, a, b, c)},\n+          visit_constr: {|a,b,c,d,f|walk_constr(e, a, b, c, d, f)},\n+          visit_fn: {|a,b,c,d,f,g,h|\n+              visit_fn_with_scope(e, a, b, c, d, f, g, h)\n+          }\n           with *visit::default_visitor()};\n     visit::visit_crate(*c, top_scope(), visit::mk_vt(v));\n     e.used_imports.track = false;\n@@ -1713,11 +1715,12 @@ fn check_for_collisions(e: @env, c: ast::crate) {\n     };\n     // Other scopes have to be checked the hard way.\n     let v =\n-        @{visit_item: bind check_item(e, _, _, _),\n-          visit_block: bind check_block(e, _, _, _),\n-          visit_arm: bind check_arm(e, _, _, _),\n-          visit_expr: bind check_expr(e, _, _, _),\n-          visit_ty: bind check_ty(e, _, _, _) with *visit::default_visitor()};\n+        @{visit_item: {|a,b,c|check_item(e, a, b, c)},\n+          visit_block: {|a,b,c|check_block(e, a, b, c)},\n+          visit_arm: {|a,b,c|check_arm(e, a, b, c)},\n+          visit_expr: {|a,b,c|check_expr(e, a, b, c)},\n+          visit_ty: {|a,b,c|check_ty(e, a, b, c)}\n+          with *visit::default_visitor()};\n     visit::visit_crate(c, (), visit::mk_vt(v));\n }\n \n@@ -2157,9 +2160,9 @@ type iscopes = @list<@[@_impl]>;\n \n fn resolve_impls(e: @env, c: @ast::crate) {\n     visit::visit_crate(*c, @nil, visit::mk_vt(@{\n-        visit_block: bind visit_block_with_impl_scope(e, _, _, _),\n-        visit_mod: bind visit_mod_with_impl_scope(e, _, _, _, _, _),\n-        visit_expr: bind resolve_impl_in_expr(e, _, _, _)\n+        visit_block: {|a,b,c|visit_block_with_impl_scope(e, a, b, c)},\n+        visit_mod: {|a,b,c,d,f|visit_mod_with_impl_scope(e, a, b, c, d, f)},\n+        visit_expr: {|a,b,c|resolve_impl_in_expr(e, a, b, c)}\n         with *visit::default_visitor()\n     }));\n }"}, {"sha": "f3f53804c2039bfede58b887d7adc3a954527874", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -663,7 +663,7 @@ fn trans_alt_inner(scope_cx: block, expr: @ast::expr, arms: [ast::arm],\n             *done = some(fail_cx.llbb);\n             ret fail_cx.llbb;\n         }\n-        some(bind mk_fail(scope_cx, expr.span, fail_cx))\n+        some({||mk_fail(scope_cx, expr.span, fail_cx)})\n       }\n       ast::alt_exhaustive { none }\n     };"}, {"sha": "44bb515393e8f52c5b37c18a2c53e2951dc660e8", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -920,7 +920,7 @@ enum scalar_type { nil_type, signed_int, unsigned_int, floating_point, }\n \n fn compare_scalar_types(cx: block, lhs: ValueRef, rhs: ValueRef,\n                         t: ty::t, op: ast::binop) -> result {\n-    let f = bind compare_scalar_values(cx, lhs, rhs, _, op);\n+    let f = {|a|compare_scalar_values(cx, lhs, rhs, a, op)};\n \n     alt ty::get(t).struct {\n       ty::ty_nil { ret rslt(cx, f(nil_type)); }\n@@ -950,7 +950,7 @@ fn compare_scalar_values(cx: block, lhs: ValueRef, rhs: ValueRef,\n         cx.tcx().sess.bug(\"compare_scalar_values: must be a\\\n           comparison operator\");\n     }\n-    let die = bind die_(cx);\n+    let die = fn@() -> ! { die_(cx) };\n     alt nt {\n       nil_type {\n         // We don't need to do actual comparisons for nil.\n@@ -1609,7 +1609,8 @@ fn trans_compare(cx: block, op: ast::binop, lhs: ValueRef,\n fn cast_shift_expr_rhs(cx: block, op: ast::binop,\n                        lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     cast_shift_rhs(op, lhs, rhs,\n-                   bind Trunc(cx, _, _), bind ZExt(cx, _, _))\n+                   {|a,b|Trunc(cx, a, b)},\n+                   {|a,b|ZExt(cx, a, b)})\n }\n \n fn cast_shift_const_rhs(op: ast::binop,\n@@ -2343,7 +2344,9 @@ fn maybe_instantiate_inline(ccx: @crate_ctxt, fn_id: ast::def_id)\n       none { // Not seen yet\n         alt csearch::maybe_get_item_ast(\n             ccx.tcx, fn_id,\n-            bind astencode::decode_inlined_item(_, _, ccx.maps, _, _)) {\n+            {|a,b,c,d|\n+                astencode::decode_inlined_item(a, b, ccx.maps, c, d)\n+            }) {\n \n           csearch::not_found {\n             ccx.external.insert(fn_id, none);\n@@ -3664,10 +3667,6 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n           ast::expr_do_body(blk) {\n             ret trans_expr(bcx, blk, dest);\n           }\n-          ast::expr_bind(f, args) {\n-            ret closure::trans_bind(\n-                bcx, f, args, e.id, dest);\n-          }\n           ast::expr_copy(a) {\n             if !expr_is_lval(bcx, a) {\n                 ret trans_expr(bcx, a, dest);\n@@ -5351,7 +5350,7 @@ fn trans_constant(ccx: @crate_ctxt, it: @ast::item) {\n \n fn trans_constants(ccx: @crate_ctxt, crate: @ast::crate) {\n     visit::visit_crate(*crate, (), visit::mk_simple_visitor(@{\n-        visit_item: bind trans_constant(ccx, _)\n+        visit_item: {|a|trans_constant(ccx, a)}\n         with *visit::default_simple_visitor()\n     }));\n }\n@@ -5495,14 +5494,14 @@ fn crate_ctxt_to_encode_parms(cx: @crate_ctxt)\n     -> encoder::encode_parms {\n \n     let encode_inlined_item =\n-        bind astencode::encode_inlined_item(_, _, _, _, cx.maps);\n+        {|a,b,c,d|astencode::encode_inlined_item(a, b, c, d, cx.maps)};\n \n     ret {\n         diag: cx.sess.diagnostic(),\n         tcx: cx.tcx,\n         reachable: cx.reachable,\n         reexports: reexports(cx),\n-        impl_map: impl_map(cx, _),\n+        impl_map: {|a|impl_map(cx, a)},\n         item_symbols: cx.item_symbols,\n         discrim_symbols: cx.discrim_symbols,\n         link_meta: cx.link_meta,"}, {"sha": "fd66b34c8167596cfec7934268045ac7ec402675", "filename": "src/rustc/middle/trans/closure.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -426,14 +426,6 @@ fn trans_expr_fn(bcx: block,\n     ret bcx;\n }\n \n-fn trans_bind(cx: block, f: @ast::expr, args: [option<@ast::expr>],\n-              id: ast::node_id, dest: dest) -> block {\n-    let _icx = cx.insn_ctxt(\"closure::trans_bind\");\n-    let f_res = trans_callee(cx, f);\n-    ret trans_bind_1(cx, expr_ty(cx, f), f_res, args,\n-                     node_id_type(cx, id), dest);\n-}\n-\n fn trans_bind_1(cx: block, outgoing_fty: ty::t,\n                 f_res: lval_maybe_callee,\n                 args: [option<@ast::expr>], pair_ty: ty::t,"}, {"sha": "d3f75d3c07db179e9ad771fe5119011820343fcb", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -232,7 +232,7 @@ fn add_clean(cx: block, val: ValueRef, ty: ty::t) {\n            ty_to_str(cx.ccx().tcx, ty)];\n     let cleanup_type = cleanup_type(cx.tcx(), ty);\n     in_scope_cx(cx) {|info|\n-        info.cleanups += [clean(bind base::drop_ty(_, val, ty),\n+        info.cleanups += [clean({|a|base::drop_ty(a, val, ty)},\n                                 cleanup_type)];\n         scope_clean_changed(info);\n     }\n@@ -252,7 +252,7 @@ fn add_clean_temp(cx: block, val: ValueRef, ty: ty::t) {\n         }\n     }\n     in_scope_cx(cx) {|info|\n-        info.cleanups += [clean_temp(val, bind do_drop(_, val, ty),\n+        info.cleanups += [clean_temp(val, {|a|do_drop(a, val, ty)},\n                                      cleanup_type)];\n         scope_clean_changed(info);\n     }\n@@ -264,14 +264,14 @@ fn add_clean_temp_mem(cx: block, val: ValueRef, ty: ty::t) {\n            ty_to_str(cx.ccx().tcx, ty)];\n     let cleanup_type = cleanup_type(cx.tcx(), ty);\n     in_scope_cx(cx) {|info|\n-        info.cleanups += [clean_temp(val, bind base::drop_ty(_, val, ty),\n+        info.cleanups += [clean_temp(val, {|a|base::drop_ty(a, val, ty)},\n                                      cleanup_type)];\n         scope_clean_changed(info);\n     }\n }\n fn add_clean_free(cx: block, ptr: ValueRef, shared: bool) {\n-    let free_fn = if shared { bind base::trans_unique_free(_, ptr) }\n-                  else { bind base::trans_free(_, ptr) };\n+    let free_fn = if shared { {|a|base::trans_unique_free(a, ptr)} }\n+    else { {|a|base::trans_free(a, ptr)} };\n     in_scope_cx(cx) {|info|\n         info.cleanups += [clean_temp(ptr, free_fn,\n                                      normal_exit_and_unwind)];"}, {"sha": "7f87c6f74e22792fd2fc775efdafa164892fee09", "filename": "src/rustc/middle/trans/type_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -223,7 +223,7 @@ fn mark_for_expr(cx: ctx, e: @expr) {\n       expr_while(_, _) | expr_fail(_) | expr_break | expr_cont |\n       expr_unary(_, _) | expr_lit(_) | expr_assert(_) | expr_check(_, _) |\n       expr_if_check(_, _, _) | expr_mac(_) | expr_addr_of(_, _) |\n-      expr_ret(_) | expr_loop(_) | expr_bind(_, _) |\n+      expr_ret(_) | expr_loop(_) |\n       expr_loop_body(_) | expr_do_body(_) {}\n     }\n }"}, {"sha": "be38692c49e61dab1e668b6b1ea6648412b7df95", "filename": "src/rustc/middle/tstate/annotate.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fmiddle%2Ftstate%2Fannotate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fmiddle%2Ftstate%2Fannotate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fannotate.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -27,11 +27,11 @@ fn collect_ids_local(tcx: ty::ctxt, l: @local, rs: @mut [node_id]) {\n \n fn node_ids_in_fn(tcx: ty::ctxt, body: blk, rs: @mut [node_id]) {\n     let collect_ids =\n-        visit::mk_simple_visitor(@{visit_expr: bind collect_ids_expr(_, rs),\n-                                   visit_block: bind collect_ids_block(_, rs),\n-                                   visit_stmt: bind collect_ids_stmt(_, rs),\n-                                   visit_local:\n-                                       bind collect_ids_local(tcx, _, rs)\n+        visit::mk_simple_visitor(@{visit_expr: {|a|collect_ids_expr(a, rs)},\n+                                   visit_block: {|a|collect_ids_block(a, rs)},\n+                                   visit_stmt: {|a|collect_ids_stmt(a, rs)},\n+                                   visit_local: {|a|\n+                                       collect_ids_local(tcx, a, rs)}\n                                    with *visit::default_simple_visitor()});\n     collect_ids.visit_block(body, (), collect_ids);\n }\n@@ -59,7 +59,7 @@ fn annotate_in_fn(ccx: crate_ctxt, _fk: visit::fn_kind, _decl: fn_decl,\n fn annotate_crate(ccx: crate_ctxt, crate: crate) {\n     let do_ann =\n         visit::mk_simple_visitor(\n-            @{visit_fn: bind annotate_in_fn(ccx, _, _, _, _, _)\n+            @{visit_fn: {|a,b,c,d,e|annotate_in_fn(ccx, a, b, c, d, e)}\n               with *visit::default_simple_visitor()});\n     visit::visit_crate(crate, (), do_ann);\n }"}, {"sha": "1ccb19cd53fd1a95b6d4794e09bfc7c4bd261357", "filename": "src/rustc/middle/tstate/auxiliary.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -551,7 +551,7 @@ fn expr_to_constr_arg(tcx: ty::ctxt, e: @expr) -> @constr_arg_use {\n }\n \n fn exprs_to_constr_args(tcx: ty::ctxt, args: [@expr]) -> [@constr_arg_use] {\n-    let f = bind expr_to_constr_arg(tcx, _);\n+    let f = {|a|expr_to_constr_arg(tcx, a)};\n     let mut rslt: [@constr_arg_use] = [];\n     for args.each {|e| rslt += [f(e)]; }\n     rslt"}, {"sha": "4524684bc6054024336e8cbdec3b66b1a96f661f", "filename": "src/rustc/middle/tstate/bitvectors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fmiddle%2Ftstate%2Fbitvectors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fmiddle%2Ftstate%2Fbitvectors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fbitvectors.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -138,7 +138,7 @@ fn relax_precond_block(fcx: fn_ctxt, i: node_id, b: blk) {\n           visit_stmt: relax_precond_stmt,\n           visit_item:\n               fn@(_i: @item, _cx: relax_ctxt, _vt: visit::vt<relax_ctxt>) { },\n-          visit_fn: bind do_nothing(_, _, _, _, _, _, _)\n+          visit_fn: do_nothing\n              with *visitor};\n     let v1 = visit::mk_vt(visitor);\n     v1.visit_block(b, cx, v1);"}, {"sha": "5283c3b6f05b0ab0ae2332ba7dd547955c0010c2", "filename": "src/rustc/middle/tstate/ck.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fmiddle%2Ftstate%2Fck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fmiddle%2Ftstate%2Fck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fck.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -80,7 +80,9 @@ fn check_states_against_conditions(fcx: fn_ctxt,\n     let visitor = visit::mk_vt(\n         @{visit_stmt: check_states_stmt,\n           visit_expr: check_states_expr,\n-          visit_fn: bind do_nothing::<fn_ctxt>(_, _, _, _, _, _, _)\n+          visit_fn: {|a,b,c,d,e,f,g|\n+              do_nothing::<fn_ctxt>(a, b, c, d, e, f, g)\n+          }\n           with *visit::default_visitor::<fn_ctxt>()});\n     visit::visit_fn(fk, f_decl, f_body, sp, id, fcx, visitor);\n }"}, {"sha": "33a5b1ab0b075f2ef6b0c40434029785f933e5b0", "filename": "src/rustc/middle/tstate/collect_locals.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -43,7 +43,7 @@ fn find_locals(tcx: ty::ctxt,\n     let visitor = visit::default_visitor::<ctxt>();\n     let visitor =\n         @{visit_expr: collect_pred,\n-          visit_fn: bind do_nothing(_, _, _, _, _, _, _)\n+          visit_fn: do_nothing\n           with *visitor};\n     visit::visit_fn(fk, f_decl, f_body, sp,\n                     id, cx, visit::mk_vt(visitor));\n@@ -147,9 +147,11 @@ fn mk_fn_info(ccx: crate_ctxt,\n    to bit number) */\n fn mk_f_to_fn_info(ccx: crate_ctxt, c: @crate) {\n     let visitor =\n-        visit::mk_simple_visitor(@{visit_fn:\n-                                       bind mk_fn_info(ccx, _, _, _, _, _)\n-                                   with *visit::default_simple_visitor()});\n+        visit::mk_simple_visitor(@{\n+            visit_fn: {|a,b,c,d,e|\n+                mk_fn_info(ccx, a, b, c, d, e)\n+            }\n+            with *visit::default_simple_visitor()});\n     visit::visit_crate(*c, (), visitor);\n }\n //"}, {"sha": "e1d0bf332c0d8c746eda31fa2d62f58ca95f338c", "filename": "src/rustc/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 3, "deletions": 19, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -81,7 +81,7 @@ fn find_pre_post_exprs(fcx: fn_ctxt, args: [@expr], id: node_id) {\n     fn get_pp(ccx: crate_ctxt, &&e: @expr) -> pre_and_post {\n         ret expr_pp(ccx, e);\n     }\n-    let pps = vec::map(args, bind get_pp(fcx.ccx, _));\n+    let pps = vec::map(args, {|a|get_pp(fcx.ccx, a)});\n \n     set_pre_and_post(fcx.ccx, id, seq_preconds(fcx, pps),\n                      seq_postconds(fcx, vec::map(pps, get_post)));\n@@ -414,7 +414,7 @@ fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n         let e_pp =\n             {precondition: empty_prestate(num_local_vars),\n              postcondition: false_postcond(num_local_vars)};\n-        let g = bind combine_pp(antec_pp, fcx, _, _);\n+        let g = {|a,b|combine_pp(antec_pp, fcx, a, b)};\n         let alts_overall_pp =\n             vec::foldl(e_pp, alt_pps, g);\n         set_pre_and_post(fcx.ccx, e.id, alts_overall_pp.precondition,\n@@ -449,22 +449,6 @@ fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n       expr_if_check(p, conseq, maybe_alt) {\n         join_then_else(fcx, p, conseq, maybe_alt, e.id, if_check);\n       }\n-      expr_bind(operator, maybe_args) {\n-        let mut args = [];\n-        let mut cmodes = callee_modes(fcx, operator.id);\n-        let mut modes = [];\n-        let mut i = 0;\n-        for maybe_args.each {|expr_opt|\n-            alt expr_opt {\n-              none {/* no-op */ }\n-              some(expr) { modes += [cmodes[i]]; args += [expr]; }\n-            }\n-            i += 1;\n-        }\n-        args += [operator]; /* ??? order of eval? */\n-        forget_args_moved_in(fcx, e, modes, args);\n-        find_pre_post_exprs(fcx, args, e.id);\n-      }\n       expr_break { clear_pp(expr_pp(fcx.ccx, e)); }\n       expr_cont { clear_pp(expr_pp(fcx.ccx, e)); }\n       expr_mac(_) { fcx.ccx.tcx.sess.bug(\"unexpanded macro\"); }\n@@ -572,7 +556,7 @@ fn find_pre_post_block(fcx: fn_ctxt, b: blk) {\n     }\n     for b.node.stmts.each {|s| do_one_(fcx, s); }\n     fn do_inner_(fcx: fn_ctxt, &&e: @expr) { find_pre_post_expr(fcx, e); }\n-    let do_inner = bind do_inner_(fcx, _);\n+    let do_inner = {|a|do_inner_(fcx, a)};\n     option::map::<@expr, ()>(b.node.expr, do_inner);\n \n     let mut pps: [pre_and_post] = [];"}, {"sha": "2948d097ab61198cd355e2884ac1075dec5743c9", "filename": "src/rustc/middle/tstate/states.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fstates.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -305,21 +305,6 @@ fn find_pre_post_state_expr(fcx: fn_ctxt, pres: prestate, e: @expr) -> bool {\n                                      operands,\n                                      controlflow_expr(fcx.ccx, operator));\n       }\n-      expr_bind(operator, maybe_args) {\n-        let mut args = [];\n-        let callee_ops = callee_arg_init_ops(fcx, operator.id);\n-        let mut ops = [];\n-        let mut i = 0;\n-        for maybe_args.each {|a_opt|\n-            alt a_opt {\n-              none {/* no-op */ }\n-              some(a) { ops += [callee_ops[i]]; args += [a]; }\n-            }\n-            i += 1;\n-        }\n-        ret find_pre_post_state_call(fcx, pres, operator, e.id, ops, args,\n-                                     return_val);\n-      }\n       expr_path(_) { ret pure_exp(fcx.ccx, e.id, pres); }\n       expr_log(_, lvl, ex) {\n         ret find_pre_post_state_two(fcx, pres, lvl, ex, e.id, oper_pure);"}, {"sha": "92ed7da8ace4b313d15c12a6df34bc06c43eb7f3", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -2991,8 +2991,8 @@ fn is_binopable(_cx: ctxt, ty: t, op: ast::binop) -> bool {\n           ty_bool { tycat_bool }\n           ty_int(_) | ty_uint(_) | ty_var_integral(_) { tycat_int }\n           ty_float(_) { tycat_float }\n-          ty_estr(_) | ty_str { tycat_str }\n-          ty_evec(_, _) | ty_vec(_) { tycat_vec }\n+          ty_str { tycat_str }\n+          ty_vec(_) { tycat_vec }\n           ty_rec(_) | ty_tup(_) | ty_enum(_, _) { tycat_struct }\n           ty_bot { tycat_bot }\n           _ { tycat_other }\n@@ -3002,21 +3002,18 @@ fn is_binopable(_cx: ctxt, ty: t, op: ast::binop) -> bool {\n     const t: bool = true;\n     const f: bool = false;\n \n+    let tbl = [\n     /*.          add,     shift,   bit\n       .             sub,     rel,     logic\n       .                mult,    eq,         */\n-    /*other*/\n-    /*bool*/\n-    /*int*/\n-    /*float*/\n-    /*str*/\n-    /*vec*/\n-    /*bot*/\n-    let tbl =\n-        [[f, f, f, f, t, t, f, f], [f, f, f, f, t, t, t, t],\n-         [t, t, t, t, t, t, t, f], [t, t, t, f, t, t, f, f],\n-         [t, f, f, f, t, t, f, f], [t, f, f, f, t, t, f, f],\n-         [f, f, f, f, t, t, f, f], [t, t, t, t, t, t, t, t]]; /*struct*/\n+    /*other*/   [f, f, f, f, t, t, f, f],\n+    /*bool*/    [f, f, f, f, t, t, t, t],\n+    /*int*/     [t, t, t, t, t, t, t, f],\n+    /*float*/   [t, t, t, f, t, t, f, f],\n+    /*str*/     [t, f, f, f, t, t, f, f],\n+    /*vec*/     [t, f, f, f, t, t, f, f],\n+    /*bot*/     [f, f, f, f, t, t, f, f],\n+    /*struct*/  [t, t, t, t, t, t, t, t]];\n \n     ret tbl[tycat(ty)][opcat(op)];\n }"}, {"sha": "de12fcb389ab8b5eae71285e3394013034cfe5dc", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 43, "deletions": 93, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -134,7 +134,7 @@ impl methods for isr_alist {\n \n fn check_item_types(ccx: @crate_ctxt, crate: @ast::crate) {\n     let visit = visit::mk_simple_visitor(@{\n-        visit_item: bind check_item(ccx, _)\n+        visit_item: {|a|check_item(ccx, a)}\n         with *visit::default_simple_visitor()\n     });\n     visit::visit_crate(*crate, (), visit);\n@@ -1132,7 +1132,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         // and so forth. - Niko\n         fcx.write_nil(expr.id);\n       }\n-      ast::expr_unary(unop, oper) {\n+      ast::expr_unary(unop, oprnd) {\n         let exp_inner = unpack_expected(fcx, expected) {|sty|\n             alt unop {\n               ast::box(_) | ast::uniq(_) {\n@@ -1145,17 +1145,17 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n               ast::deref { none }\n             }\n         };\n-        bot = check_expr(fcx, oper, exp_inner);\n-        let mut oper_t = fcx.expr_ty(oper);\n+        bot = check_expr(fcx, oprnd, exp_inner);\n+        let mut oprnd_t = fcx.expr_ty(oprnd);\n         alt unop {\n           ast::box(mutbl) {\n-            oper_t = ty::mk_box(tcx, {ty: oper_t, mutbl: mutbl});\n+            oprnd_t = ty::mk_box(tcx, {ty: oprnd_t, mutbl: mutbl});\n           }\n           ast::uniq(mutbl) {\n-            oper_t = ty::mk_uniq(tcx, {ty: oper_t, mutbl: mutbl});\n+            oprnd_t = ty::mk_uniq(tcx, {ty: oprnd_t, mutbl: mutbl});\n           }\n           ast::deref {\n-            let sty = structure_of(fcx, expr.span, oper_t);\n+            let sty = structure_of(fcx, expr.span, oprnd_t);\n \n             // deref'ing an unsafe pointer requires that we be in an unsafe\n             // context\n@@ -1169,7 +1169,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n             }\n \n             alt ty::deref_sty(tcx, sty, true) {\n-              some(mt) { oper_t = mt.ty }\n+              some(mt) { oprnd_t = mt.ty }\n               none {\n                 alt sty {\n                   ty::ty_enum(*) {\n@@ -1183,39 +1183,46 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                     tcx.sess.span_err(\n                         expr.span,\n                         #fmt[\"type %s cannot be dereferenced\",\n-                             fcx.infcx.ty_to_str(oper_t)]);\n+                             fcx.infcx.ty_to_str(oprnd_t)]);\n                   }\n                 }\n               }\n             }\n           }\n           ast::not {\n-            oper_t = structurally_resolved_type(fcx, oper.span, oper_t);\n-            if !(ty::type_is_integral(oper_t) ||\n-                 ty::get(oper_t).struct == ty::ty_bool) {\n-                oper_t = check_user_unop(fcx, \"!\", \"!\", expr,\n-                                         oper, oper_t);\n+            oprnd_t = structurally_resolved_type(fcx, oprnd.span, oprnd_t);\n+            if !(ty::type_is_integral(oprnd_t) ||\n+                 ty::get(oprnd_t).struct == ty::ty_bool) {\n+                oprnd_t = check_user_unop(fcx, \"!\", \"!\", expr,\n+                                         oprnd, oprnd_t);\n             }\n           }\n           ast::neg {\n-            oper_t = structurally_resolved_type(fcx, oper.span, oper_t);\n-            if !(ty::type_is_integral(oper_t) ||\n-                 ty::type_is_fp(oper_t)) {\n-                oper_t = check_user_unop(fcx, \"-\", \"unary-\", expr,\n-                                         oper, oper_t);\n+            // If the operand's type is an integral type variable, we\n+            // don't want to resolve it yet, because the rest of the\n+            // typing context might not have had the opportunity to\n+            // constrain it yet.\n+            if !(ty::type_is_var_integral(oprnd_t)) {\n+                oprnd_t = structurally_resolved_type(fcx, oprnd.span,\n+                                                     oprnd_t);\n+            }\n+            if !(ty::type_is_integral(oprnd_t) ||\n+                 ty::type_is_fp(oprnd_t)) {\n+                oprnd_t = check_user_unop(fcx, \"-\", \"unary-\", expr,\n+                                         oprnd, oprnd_t);\n             }\n           }\n         }\n-        fcx.write_ty(id, oper_t);\n+        fcx.write_ty(id, oprnd_t);\n       }\n-      ast::expr_addr_of(mutbl, oper) {\n-        bot = check_expr(fcx, oper, unpack_expected(fcx, expected) {|ty|\n+      ast::expr_addr_of(mutbl, oprnd) {\n+        bot = check_expr(fcx, oprnd, unpack_expected(fcx, expected) {|ty|\n             alt ty { ty::ty_rptr(_, mt) { some(mt.ty) } _ { none } }\n         });\n-        let region = region_of(fcx, oper);\n-        let tm = { ty: fcx.expr_ty(oper), mutbl: mutbl };\n-        let oper_t = ty::mk_rptr(tcx, region, tm);\n-        fcx.write_ty(id, oper_t);\n+        let region = region_of(fcx, oprnd);\n+        let tm = { ty: fcx.expr_ty(oprnd), mutbl: mutbl };\n+        let oprnd_t = ty::mk_rptr(tcx, region, tm);\n+        fcx.write_ty(id, oprnd_t);\n       }\n       ast::expr_path(pth) {\n         let defn = lookup_def(fcx, pth.span, id);\n@@ -1327,7 +1334,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                 tcx.sess.span_fatal(\n                     expr.span, #fmt(\"a loop function's last argument \\\n                                      should return `bool`, not `%s`\",\n-                                    ty_to_str(tcx, fty.output)));\n+                                    fcx.infcx.ty_to_str(fty.output)));\n               }\n             }\n             (ty::mk_fn(tcx, {output: ty::mk_nil(tcx) with fty}), fty.proto)\n@@ -1389,63 +1396,6 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n             };\n         fcx.write_ty(id, typ);\n       }\n-      ast::expr_bind(f, args) {\n-        // Call the generic checker.\n-        bot = check_expr(fcx, f, none);\n-\n-        let {fty, bot: ccob_bot} = {\n-            let fn_ty = fcx.expr_ty(f);\n-            check_call_or_bind(fcx, expr.span, expr.id, fn_ty, args)\n-        };\n-        bot |= ccob_bot;\n-\n-        // TODO: Perform substitutions on the return type.\n-\n-        // Pull the argument and return types out.\n-        let mut proto, arg_tys, rt, cf, constrs;\n-        alt structure_of(fcx, expr.span, fty) {\n-          // FIXME:\n-          // probably need to munge the constrs to drop constraints\n-          // for any bound args (contingent on #2588 not getting accepted)\n-          ty::ty_fn(f) {\n-            proto = f.proto;\n-            arg_tys = f.inputs;\n-            rt = f.output;\n-            cf = f.ret_style;\n-            constrs = f.constraints;\n-          }\n-          _ { fail \"LHS of bind expr didn't have a function type?!\"; }\n-        }\n-\n-        let proto = alt proto {\n-          ast::proto_bare | ast::proto_box | ast::proto_uniq {\n-            ast::proto_box\n-          }\n-          ast::proto_any | ast::proto_block {\n-            tcx.sess.span_err(expr.span,\n-                              #fmt[\"cannot bind %s closures\",\n-                                   proto_to_str(proto)]);\n-            proto // dummy value so compilation can proceed\n-          }\n-        };\n-\n-        // For each blank argument, add the type of that argument\n-        // to the resulting function type.\n-        let mut out_args = [];\n-        let mut i = 0u;\n-        while i < vec::len(args) {\n-            alt args[i] {\n-              some(_) {/* no-op */ }\n-              none { out_args += [arg_tys[i]]; }\n-            }\n-            i += 1u;\n-        }\n-\n-        let ft = ty::mk_fn(tcx, {purity: ast::impure_fn, proto: proto,\n-                                 inputs: out_args, output: rt,\n-                                 ret_style: cf, constraints: constrs});\n-        fcx.write_ty(id, ft);\n-      }\n       ast::expr_call(f, args, _) {\n         bot = check_call(fcx, expr.span, expr.id, f, args);\n       }\n@@ -1464,12 +1414,12 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n           _ {\n             if ty::type_is_nil(t_e) {\n                 tcx.sess.span_err(expr.span, \"cast from nil: \" +\n-                                  ty_to_str(tcx, t_e) + \" as \" +\n-                                  ty_to_str(tcx, t_1));\n+                                  fcx.infcx.ty_to_str(t_e) + \" as \" +\n+                                  fcx.infcx.ty_to_str(t_1));\n             } else if ty::type_is_nil(t_1) {\n                 tcx.sess.span_err(expr.span, \"cast to nil: \" +\n-                                  ty_to_str(tcx, t_e) + \" as \" +\n-                                  ty_to_str(tcx, t_1));\n+                                  fcx.infcx.ty_to_str(t_e) + \" as \" +\n+                                  fcx.infcx.ty_to_str(t_1));\n             }\n \n             let t_1_is_scalar = type_is_scalar(fcx, expr.span, t_1);\n@@ -1483,8 +1433,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                 */\n                 tcx.sess.span_err(expr.span,\n                                   \"non-scalar cast: \" +\n-                                  ty_to_str(tcx, t_e) + \" as \" +\n-                                  ty_to_str(tcx, t_1));\n+                                  fcx.infcx.ty_to_str(t_e) + \" as \" +\n+                                  fcx.infcx.ty_to_str(t_1));\n             }\n           }\n         }\n@@ -1632,7 +1582,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                 let t_err = fcx.infcx.resolve_type_vars_if_possible(expr_t);\n                 let msg = #fmt[\"attempted access of field %s on type %s, but \\\n                           no public field or method with that name was found\",\n-                               *field, ty_to_str(tcx, t_err)];\n+                               *field, fcx.infcx.ty_to_str(t_err)];\n                 tcx.sess.span_err(expr.span, msg);\n                 // NB: Adding a bogus type to allow typechecking to continue\n                 fcx.write_ty(id, fcx.infcx.next_ty_var());\n@@ -1660,7 +1610,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n               _ {\n                 tcx.sess.span_fatal(\n                     expr.span, \"cannot index a value of type `\" +\n-                    ty_to_str(tcx, base_t) + \"`\");\n+                    fcx.infcx.ty_to_str(base_t) + \"`\");\n               }\n             }\n           }\n@@ -1701,7 +1651,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n           none {\n             let t_err = fcx.infcx.resolve_type_vars_if_possible(p_ty);\n             let msg = #fmt[\"no `alloc()` method found for type `%s`\",\n-                           ty_to_str(tcx, t_err)];\n+                           fcx.infcx.ty_to_str(t_err)];\n             tcx.sess.span_err(expr.span, msg);\n           }\n         }"}, {"sha": "bb9bc0a6653ca51f50ca5bf5b4db2269fa080b3e", "filename": "src/rustc/middle/typeck/check/alt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -198,7 +198,7 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n             ret str::eq(*name, *f.ident);\n         }\n         for fields.each {|f|\n-            alt vec::find(ex_fields, bind matches(f.ident, _)) {\n+            alt vec::find(ex_fields, {|a|matches(f.ident, a)}) {\n               some(field) {\n                 check_pat(pcx, f.pat, field.mt.ty);\n               }"}, {"sha": "490656eccbe5d95c3fe67e9dad580c9ed7a7b25f", "filename": "src/rustc/middle/typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -53,8 +53,8 @@ fn collect_item_types(ccx: @crate_ctxt, crate: @ast::crate) {\n     }\n \n     visit::visit_crate(*crate, (), visit::mk_simple_visitor(@{\n-        visit_item: bind convert(ccx, _),\n-        visit_native_item: bind convert_native(ccx, _)\n+        visit_item: {|a|convert(ccx, a)},\n+        visit_native_item: {|a|convert_native(ccx, a)}\n         with *visit::default_simple_visitor()\n     }));\n }"}, {"sha": "b188f990a6818309a4f43e91e2bc5296db76264f", "filename": "src/rustc/middle/typeck/infer.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -119,6 +119,28 @@ is valid.  This basically corresponds to the block nesting structure:\n the regions for outer block scopes are superregions of those for inner\n block scopes.\n \n+## Integral type variables\n+\n+There is a third variety of type variable that we use only for\n+inferring the types of unsuffixed integer literals.  Integral type\n+variables differ from general-purpose type variables in that there's\n+no subtyping relationship among the various integral types, so instead\n+of associating each variable with an upper and lower bound, we\n+represent the set of possible integral types it can take on with an\n+`int_ty_set`, which is a bitvector with one bit for each integral\n+type.  Because intersecting these sets with each other is simpler than\n+merging bounds, we don't need to do so transactionally as we do for\n+general-purpose type variables.\n+\n+We could conceivably define a subtyping relationship among integral\n+types based on their ranges, but we choose not to open that particular\n+can of worms.  Our strategy is to treat integral type variables as\n+unknown until the typing context constrains them to a unique integral\n+type, at which point they take on that type.  If the typing context\n+overconstrains the type, it's a type error; if we reach the point at\n+which type variables must be resolved and an integral type variable is\n+still underconstrained, it defaults to `int` as a last resort.\n+\n ## GLB/LUB\n \n Computing the greatest-lower-bound and least-upper-bound of two\n@@ -829,7 +851,7 @@ impl unify_methods for infer_ctxt {\n             }\n         } else if nde_a.rank < nde_b.rank {\n             #debug[\"vars(): b has smaller rank\"];\n-            // b has geater rank, so a should redirect to b.\n+            // b has greater rank, so a should redirect to b.\n             self.set(vb, a_id, redirect(b_id));\n             self.set_var_to_merged_bounds(\n                 vb, b_id, a_bounds, b_bounds, nde_b.rank).then {||"}, {"sha": "e12aa98b67af859de13aeff9045bdf4d346c4b78", "filename": "src/rustc/util/common.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fcommon.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -34,25 +34,33 @@ fn field_exprs(fields: [ast::field]) -> [@ast::expr] {\n }\n \n // Takes a predicate p, returns true iff p is true for any subexpressions\n-// of b\n-fn block_expr_query(b: ast::blk, p: fn@(ast::expr_) -> bool) -> bool {\n+// of b -- skipping any inner loops (loop, while, loop_body)\n+fn loop_query(b: ast::blk, p: fn@(ast::expr_) -> bool) -> bool {\n     let rs = @mut false;\n-    let visit_expr = {|flag: @mut bool, e: @ast::expr| *flag |= p(e.node)};\n-    let v =\n-        visit::mk_simple_visitor(@{visit_expr: bind visit_expr(rs, _)\n-                                      with *visit::default_simple_visitor()});\n-    visit::visit_block(b, (), v);\n+    let visit_expr = {|e: @ast::expr, &&flag: @mut bool,\n+                       v: visit::vt<@mut bool>|\n+        *flag |= p(e.node);\n+        alt e.node {\n+          // Skip inner loops, since a break in the inner loop isn't a\n+          // break inside the outer loop\n+          ast::expr_loop(*) | ast::expr_while(*) | ast::expr_loop_body(*) {}\n+          _ { visit::visit_expr(e, flag, v); }\n+        }\n+    };\n+    let v = visit::mk_vt(@{visit_expr: visit_expr\n+                           with *visit::default_visitor()});\n+    visit::visit_block(b, rs, v);\n     ret *rs;\n }\n \n fn has_nonlocal_exits(b: ast::blk) -> bool {\n-    block_expr_query(b) {|e| alt e {\n+    loop_query(b) {|e| alt e {\n       ast::expr_break | ast::expr_cont { true }\n       _ { false }}}\n }\n \n fn may_break(b: ast::blk) -> bool {\n-    block_expr_query(b) {|e| alt e {\n+    loop_query(b) {|e| alt e {\n       ast::expr_break { true }\n       _ { false }}}\n }"}, {"sha": "d581ead494a9d3e41891d3a2a620ff7a9a0b114e", "filename": "src/rustdoc/prune_unexported_pass.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustdoc%2Fprune_unexported_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustdoc%2Fprune_unexported_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fprune_unexported_pass.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -62,7 +62,9 @@ fn exported_items_from_mod(\n     srv: astsrv::srv,\n     doc: doc::moddoc\n ) -> [doc::itemtag] {\n-    exported_items_from(srv, doc, bind is_exported_from_mod(_, doc.id(), _))\n+    exported_items_from(srv, doc, {|a,b|\n+        is_exported_from_mod(a, doc.id(), b)\n+    })\n }\n \n fn exported_items_from("}, {"sha": "b79d8e88f5041014460e3f1c706abdb95de19c88", "filename": "src/rustdoc/reexport_pass.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustdoc%2Freexport_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Frustdoc%2Freexport_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Freexport_pass.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -68,13 +68,13 @@ fn from_assoc_list<K:copy, V:copy>(\n fn from_def_assoc_list<V:copy>(\n     list: [(ast::def_id, V)]\n ) -> map::hashmap<ast::def_id, V> {\n-    from_assoc_list(list, bind ast_util::new_def_hash())\n+    from_assoc_list(list, ast_util::new_def_hash)\n }\n \n fn from_str_assoc_list<V:copy>(\n     list: [(str, V)]\n ) -> map::hashmap<str, V> {\n-    from_assoc_list(list, bind map::str_hash())\n+    from_assoc_list(list, map::str_hash)\n }\n \n fn build_reexport_def_set(srv: astsrv::srv) -> def_set {\n@@ -256,7 +256,7 @@ fn for_each_reexported_impl(\n     f: fn@(ast::node_id, resolve::_impl)\n ) {\n     let visitor = @{\n-        visit_mod: bind visit_mod(ctxt, f, _, _, _)\n+        visit_mod: {|a,b,c|visit_mod(ctxt, f, a, b, c)}\n         with *visit::default_simple_visitor()\n     };\n     let visitor = visit::mk_simple_visitor(visitor);"}, {"sha": "e2f0c151889adca4a41c591dceedd546591f6938", "filename": "src/snapshots.txt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -1,3 +1,11 @@\n+S 2012-06-19 de491ea\n+  freebsd-x86_64 b5c1080df70136bb316286e1973fa2b5734c9a01\n+  winnt-i386 fa1c7b2295dbde00269f859b8cb637a59a8deec4\n+  linux-i386 88886207b1f594ce9b3d6db1a6fcbaf94d710c0a\n+  linux-x86_64 d8711b88786d58d0079623beeace070ca6a85635\n+  macos-i386 9074b395dc92f1e54dec2e757daaf05dc86d6208\n+  macos-x86_64 2cb02b7063191ed9400b3ed91c6aefad2799593d\n+\n S 2012-06-14 623d825\n   macos-x86_64 ab8d81cf3f538cd259cbec2be9615688482f9bc1\n   macos-i386 1ec2b3425fab510684858bb7b28f2c2ad474d5af"}, {"sha": "e7947cf583a8f9310c6aea22ddff091bb7f5b62e", "filename": "src/test/auxiliary/issue_2242_a.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Fauxiliary%2Fissue_2242_a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Fauxiliary%2Fissue_2242_a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_2242_a.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -0,0 +1,10 @@\n+#[link(name = \"a\", vers = \"0.1\")];\n+#[crate_type = \"lib\"];\n+\n+iface to_str {\n+    fn to_str() -> str;\n+}\n+\n+impl of to_str for str {\n+    fn to_str() -> str { self }\n+}"}, {"sha": "6371e55dde47ca938a382f5d4c34e93cd7f17242", "filename": "src/test/auxiliary/issue_2242_b.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Fauxiliary%2Fissue_2242_b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Fauxiliary%2Fissue_2242_b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_2242_b.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -0,0 +1,9 @@\n+#[link(name = \"b\", vers = \"0.1\")];\n+#[crate_type = \"lib\"];\n+\n+use a;\n+import a::to_str;\n+\n+impl of to_str for int {\n+    fn to_str() -> str { #fmt(\"%?\", self) }\n+}"}, {"sha": "2497be8a42e26d15a9afeccedd762bc163510a85", "filename": "src/test/auxiliary/issue_2242_c.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Fauxiliary%2Fissue_2242_c.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Fauxiliary%2Fissue_2242_c.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_2242_c.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -0,0 +1,10 @@\n+#[link(name = \"c\", vers = \"0.1\")];\n+#[crate_type = \"lib\"];\n+\n+use a;\n+\n+import a::to_str;\n+\n+impl of to_str for bool {\n+    fn to_str() -> str { #fmt(\"%b\", self) }\n+}"}, {"sha": "3973905c807de2f28a6680fc5664d47e0b66ec77", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -77,7 +77,7 @@ fn solve_grid(g: grid_t) {\n             if color != 0u8 { bitv::set(colors, color as uint, false); }\n         }\n \n-        let it = bind drop_color(g, avail, _, _);\n+        let it = {|a,b|drop_color(g, avail, a, b)};\n \n         for u8::range(0u8, 9u8) { |idx|\n             it(idx, col); /* check same column fields */"}, {"sha": "f43f27f425f163773e2ef3924d4880d69f248d81", "filename": "src/test/bench/task-perf-word-count-generic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -129,7 +129,7 @@ mod map_reduce {\n             send(c, emit_val(val));\n         }\n \n-        map(input, bind emit(intermediates, ctrl, _, _));\n+        map(input, {|a,b|emit(intermediates, ctrl, a, b)});\n \n         fn finish<K: copy send, V: copy send>(_k: K, v: chan<reduce_proto<V>>)\n         {\n@@ -148,8 +148,8 @@ mod map_reduce {\n \n         send(out, chan(p));\n \n-        let ref_count = 0;\n-        let is_done = false;\n+        let mut ref_count = 0;\n+        let mut is_done = false;\n \n         fn get<V: copy send>(p: port<reduce_proto<V>>,\n                              &ref_count: int, &is_done: bool)\n@@ -171,7 +171,7 @@ mod map_reduce {\n             ret none;\n         }\n \n-        reduce(key, bind get(p, ref_count, is_done));\n+        reduce(key, {||get(p, ref_count, is_done)});\n     }\n \n     fn map_reduce<K1: copy send, K2: copy send, V: copy send>("}, {"sha": "12fd0943b4c5667e700de1f8f6f3bb4959fe24e3", "filename": "src/test/bench/task-perf-word-count.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -91,7 +91,7 @@ mod map_reduce {\n             send(c, emit_val(val));\n         }\n \n-        map(input, bind emit(intermediates, ctrl, _, _));\n+        map(input, {|a,b|emit(intermediates, ctrl, a, b)});\n \n         for intermediates.each_value {|v| send(v, release); }\n \n@@ -125,7 +125,7 @@ mod map_reduce {\n             ret none;\n         }\n \n-        reduce(key, bind get(p, state));\n+        reduce(key, {||get(p, state)});\n     }\n \n     fn map_reduce(-inputs: [str]) {"}, {"sha": "b218ddd122a38ec539c11c293cf5274244a2ba14", "filename": "src/test/compile-fail/auto-deref-bind.rs", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8395305e71895b152e3f0abefb6cbc9e74f15a16/src%2Ftest%2Fcompile-fail%2Fauto-deref-bind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8395305e71895b152e3f0abefb6cbc9e74f15a16/src%2Ftest%2Fcompile-fail%2Fauto-deref-bind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fauto-deref-bind.rs?ref=8395305e71895b152e3f0abefb6cbc9e74f15a16", "patch": "@@ -1,4 +0,0 @@\n-// error-pattern: mismatched types\n-\n-fn add1(i: int) -> int { ret i + 1; }\n-fn main() { let f = @add1; let g = bind f(5); }"}, {"sha": "6a08b9b56c0b8d506a0957160e75e25e05df8eb9", "filename": "src/test/compile-fail/bind-stack-closure.rs", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8395305e71895b152e3f0abefb6cbc9e74f15a16/src%2Ftest%2Fcompile-fail%2Fbind-stack-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8395305e71895b152e3f0abefb6cbc9e74f15a16/src%2Ftest%2Fcompile-fail%2Fbind-stack-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbind-stack-closure.rs?ref=8395305e71895b152e3f0abefb6cbc9e74f15a16", "patch": "@@ -1,10 +0,0 @@\n-fn foo(x: fn()) {\n-    bind x(); //! ERROR cannot bind fn closures\n-}\n-\n-fn bar(x: fn&()) {\n-    bind x(); //! ERROR cannot bind fn& closures\n-}\n-\n-fn main() {\n-}"}, {"sha": "66ba4e4dad957dbbdfde5e694322c7813ed7dd7d", "filename": "src/test/compile-fail/crust-no-bind.rs", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8395305e71895b152e3f0abefb6cbc9e74f15a16/src%2Ftest%2Fcompile-fail%2Fcrust-no-bind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8395305e71895b152e3f0abefb6cbc9e74f15a16/src%2Ftest%2Fcompile-fail%2Fcrust-no-bind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcrust-no-bind.rs?ref=8395305e71895b152e3f0abefb6cbc9e74f15a16", "patch": "@@ -1,7 +0,0 @@\n-// error-pattern:expected function or native function but found *u8\n-crust fn f() {\n-}\n-\n-fn main() {\n-    let x = bind f();\n-}\n\\ No newline at end of file"}, {"sha": "a9d2f38f6170fea938196bd87354414573752cf8", "filename": "src/test/compile-fail/fn-bare-bind.rs", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8395305e71895b152e3f0abefb6cbc9e74f15a16/src%2Ftest%2Fcompile-fail%2Ffn-bare-bind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8395305e71895b152e3f0abefb6cbc9e74f15a16/src%2Ftest%2Fcompile-fail%2Ffn-bare-bind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffn-bare-bind.rs?ref=8395305e71895b152e3f0abefb6cbc9e74f15a16", "patch": "@@ -1,8 +0,0 @@\n-fn f() {\n-}\n-\n-fn main() {\n-    // Can't produce a bare function by binding\n-    let g: native fn() = bind f();\n-    //!^ ERROR mismatched types: expected `native fn()` but found `fn@()`\n-}"}, {"sha": "4c8a9f10e665ab037db8a84066ac43d6d437f9eb", "filename": "src/test/compile-fail/index_message.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Fcompile-fail%2Findex_message.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Fcompile-fail%2Findex_message.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Findex_message.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -0,0 +1,4 @@\n+fn main() {\n+    let z = ();\n+    log(debug, z[0]); //! ERROR cannot index a value of type `()`\n+}"}, {"sha": "678a063284ef6e078b710d39fe30faa9031976f6", "filename": "src/test/compile-fail/liveness-uninit-after-item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Fcompile-fail%2Fliveness-uninit-after-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Fcompile-fail%2Fliveness-uninit-after-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-uninit-after-item.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -1,6 +1,6 @@\n fn main() {\n     let bar;\n     fn baz(_x: int) { }\n-    bind baz(bar); //! ERROR use of possibly uninitialized variable: `bar`\n+    baz(bar); //! ERROR use of possibly uninitialized variable: `bar`\n }\n "}, {"sha": "03fc1d326f68f57c79b93a04c50b2e09d79a7cad", "filename": "src/test/compile-fail/tstate-unsat-after-item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Fcompile-fail%2Ftstate-unsat-after-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Fcompile-fail%2Ftstate-unsat-after-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftstate-unsat-after-item.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -4,6 +4,6 @@ fn even(i: int) : is_even(i) -> int { i }\n fn main() {\n     let x = 4;\n     fn baz(_x: int) { }\n-    bind baz(even(x)); //! ERROR unsatisfied precondition\n+    baz(even(x)); //! ERROR unsatisfied precondition\n }\n "}, {"sha": "fa07be952c119b5ebd84d64028cac407ff202776", "filename": "src/test/compile-fail/tutorial-suffix-inference-test.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Fcompile-fail%2Ftutorial-suffix-inference-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Fcompile-fail%2Ftutorial-suffix-inference-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftutorial-suffix-inference-test.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -0,0 +1,22 @@\n+fn main() {\n+    let x = 3;\n+    let y: i32 = 3;\n+\n+    fn identity_u8(n: u8) -> u8 { n }\n+    fn identity_u16(n: u16) -> u16 { n }\n+\n+    identity_u8(x);  // after this, `x` is assumed to have type `u8`\n+    identity_u16(x);\n+    //!^ ERROR mismatched types: expected `u16` but found `u8`\n+    identity_u16(y);\n+    //!^ ERROR mismatched types: expected `u16` but found `i32`\n+\n+    let a = 3i;\n+    \n+    fn identity_i(n: int) -> int { n }\n+\n+    identity_i(a); // ok\n+    identity_u16(a); \n+    //!^ ERROR mismatched types: expected `u16` but found `int`\n+\n+}\n\\ No newline at end of file"}, {"sha": "0e9a93390ec93ea0d08779f05c2246a1f49eec30", "filename": "src/test/compile-fail/unsafe-fn-used-in-bind.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8395305e71895b152e3f0abefb6cbc9e74f15a16/src%2Ftest%2Fcompile-fail%2Funsafe-fn-used-in-bind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8395305e71895b152e3f0abefb6cbc9e74f15a16/src%2Ftest%2Fcompile-fail%2Funsafe-fn-used-in-bind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-fn-used-in-bind.rs?ref=8395305e71895b152e3f0abefb6cbc9e74f15a16", "patch": "@@ -1,9 +0,0 @@\n-// -*- rust -*-\n-\n-unsafe fn f(x: int, y: int) -> int { ret x + y; }\n-\n-fn main() {\n-    let x = bind f(3, _);\n-    //!^ ERROR access to unsafe function requires unsafe function or block\n-    let y = x(4);\n-}"}, {"sha": "1a1bfdd7d4998e58038bf9c02ef09a3ca574099c", "filename": "src/test/run-fail/unwind-closure.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Frun-fail%2Funwind-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Frun-fail%2Funwind-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-closure.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -5,6 +5,7 @@ fn f(a: @int) {\n }\n \n fn main() {\n-    let g = bind f(@0);\n+    let b = @0;\n+    let g = {|move b|f(b)};\n     g();\n }\n\\ No newline at end of file"}, {"sha": "deb87b813d1ae8d6842bc99b1bc0180e581607b7", "filename": "src/test/run-pass/auto_serialize.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Frun-pass%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Frun-pass%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto_serialize.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -81,55 +81,55 @@ fn main() {\n                             @plus(@val(22u), @val(5u))),\n                        \"plus(@minus(@val(3u), @val(10u)), \\\n                         @plus(@val(22u), @val(5u)))\",\n-                       serialize_expr(_, _),\n-                       deserialize_expr(_),\n-                       serialize_expr(_, _));\n+                       serialize_expr,\n+                       deserialize_expr,\n+                       serialize_expr);\n \n     test_ser_and_deser({lo: 0u, hi: 5u, node: 22u},\n                        \"{lo: 0u, hi: 5u, node: 22u}\",\n-                       serialize_spanned_uint(_, _),\n-                       deserialize_spanned_uint(_),\n-                       serialize_spanned_uint(_, _));\n+                       serialize_spanned_uint,\n+                       deserialize_spanned_uint,\n+                       serialize_spanned_uint);\n \n     test_ser_and_deser(an_enum({v: [1u, 2u, 3u]}),\n                        \"an_enum({v: [1u, 2u, 3u]})\",\n-                       serialize_an_enum(_, _),\n-                       deserialize_an_enum(_),\n-                       serialize_an_enum(_, _));\n+                       serialize_an_enum,\n+                       deserialize_an_enum,\n+                       serialize_an_enum);\n \n     test_ser_and_deser({x: 3u, y: 5u},\n                        \"{x: 3u, y: 5u}\",\n-                       serialize_point(_, _),\n-                       deserialize_point(_),\n-                       serialize_point(_, _));\n+                       serialize_point,\n+                       deserialize_point,\n+                       serialize_point);\n \n     test_ser_and_deser([1u, 2u, 3u],\n                        \"[1u, 2u, 3u]\",\n-                       serialize_uint_vec(_, _),\n-                       deserialize_uint_vec(_),\n-                       serialize_uint_vec(_, _));\n+                       serialize_uint_vec,\n+                       deserialize_uint_vec,\n+                       serialize_uint_vec);\n \n     test_ser_and_deser(top(22u),\n                        \"top(22u)\",\n-                       serialize_uint_quark(_, _),\n-                       deserialize_uint_quark(_),\n-                       serialize_uint_quark(_, _));\n+                       serialize_uint_quark,\n+                       deserialize_uint_quark,\n+                       serialize_uint_quark);\n \n     test_ser_and_deser(bottom(222u),\n                        \"bottom(222u)\",\n-                       serialize_uint_quark(_, _),\n-                       deserialize_uint_quark(_),\n-                       serialize_uint_quark(_, _));\n+                       serialize_uint_quark,\n+                       deserialize_uint_quark,\n+                       serialize_uint_quark);\n \n     test_ser_and_deser(a,\n                        \"a\",\n-                       serialize_c_like(_, _),\n-                       deserialize_c_like(_),\n-                       serialize_c_like(_, _));\n+                       serialize_c_like,\n+                       deserialize_c_like,\n+                       serialize_c_like);\n \n     test_ser_and_deser(b,\n                        \"b\",\n-                       serialize_c_like(_, _),\n-                       deserialize_c_like(_),\n-                       serialize_c_like(_, _));\n+                       serialize_c_like,\n+                       deserialize_c_like,\n+                       serialize_c_like);\n }\n\\ No newline at end of file"}, {"sha": "67784fa12d0aa800753cc99cba3e59f62b45ec1f", "filename": "src/test/run-pass/bind-exterior.rs", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8395305e71895b152e3f0abefb6cbc9e74f15a16/src%2Ftest%2Frun-pass%2Fbind-exterior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8395305e71895b152e3f0abefb6cbc9e74f15a16/src%2Ftest%2Frun-pass%2Fbind-exterior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbind-exterior.rs?ref=8395305e71895b152e3f0abefb6cbc9e74f15a16", "patch": "@@ -1,5 +0,0 @@\n-\n-\n-fn foo(a: @int, b: @int) -> int { ret *a + *b; }\n-\n-fn main() { let f1 = bind foo(@10, @12); assert (f1() == 22); }"}, {"sha": "579b304f839e9abe602a66fc04c4f46cd6402200", "filename": "src/test/run-pass/bind-generic.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8395305e71895b152e3f0abefb6cbc9e74f15a16/src%2Ftest%2Frun-pass%2Fbind-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8395305e71895b152e3f0abefb6cbc9e74f15a16/src%2Ftest%2Frun-pass%2Fbind-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbind-generic.rs?ref=8395305e71895b152e3f0abefb6cbc9e74f15a16", "patch": "@@ -1,16 +0,0 @@\n-fn wrapper3<T: copy>(i: T, j: int) {\n-    log(debug, i);\n-    log(debug, j);\n-    // This is a regression test that the spawn3 thunk to wrapper3\n-    // correctly finds the value of j\n-    assert j == 123456789;\n-}\n-\n-fn spawn3<T: copy>(i: T, j: int) {\n-    let wrapped = bind wrapper3(i, j);\n-    wrapped();\n-}\n-\n-fn main() {\n-    spawn3(127u8, 123456789);\n-}\n\\ No newline at end of file"}, {"sha": "980a1e568f6612441fc8b1168a5aa3d98f10a2b9", "filename": "src/test/run-pass/bind-interior.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8395305e71895b152e3f0abefb6cbc9e74f15a16/src%2Ftest%2Frun-pass%2Fbind-interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8395305e71895b152e3f0abefb6cbc9e74f15a16/src%2Ftest%2Frun-pass%2Fbind-interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbind-interior.rs?ref=8395305e71895b152e3f0abefb6cbc9e74f15a16", "patch": "@@ -1,11 +0,0 @@\n-\n-\n-\n-// -*- rust -*-\n-fn f(n: int) -> int { ret n; }\n-\n-fn main() {\n-    let g: fn@() -> int = bind f(10);\n-    let i: int = g();\n-    assert (i == 10);\n-}"}, {"sha": "2eb20ed0e9d2c8c9c883ad212d1d2a0d9dbbec1d", "filename": "src/test/run-pass/bind-methods.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8395305e71895b152e3f0abefb6cbc9e74f15a16/src%2Ftest%2Frun-pass%2Fbind-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8395305e71895b152e3f0abefb6cbc9e74f15a16/src%2Ftest%2Frun-pass%2Fbind-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbind-methods.rs?ref=8395305e71895b152e3f0abefb6cbc9e74f15a16", "patch": "@@ -1,20 +0,0 @@\n-iface foo {\n-    fn foo() -> int;\n-    fn bar(p: int) -> int;\n-}\n-impl of foo for int {\n-    fn foo() -> int { self }\n-    fn bar(p: int) -> int { p * self.foo() }\n-}\n-impl <T: foo> of foo for [T] {\n-    fn foo() -> int { vec::foldl(0, self, {|a, b| a + b.foo()}) }\n-    fn bar(p: int) -> int { p + self.len() as int }\n-}\n-\n-fn main() {\n-    let x = [1, 2, 3];\n-    let y = x.foo, z = [4, 5, 6].foo;\n-    assert y() + z() == 21;\n-    let a = x.bar, b = bind [4, 5, 6].bar(_);\n-    assert a(1) + b(2) + z() == 24;\n-}"}, {"sha": "93e54db6aa27c7ceab86fb53b8f35f53a638bc16", "filename": "src/test/run-pass/bind-native-fn.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8395305e71895b152e3f0abefb6cbc9e74f15a16/src%2Ftest%2Frun-pass%2Fbind-native-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8395305e71895b152e3f0abefb6cbc9e74f15a16/src%2Ftest%2Frun-pass%2Fbind-native-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbind-native-fn.rs?ref=8395305e71895b152e3f0abefb6cbc9e74f15a16", "patch": "@@ -1,21 +0,0 @@\n-// From #1174:\n-// xfail-fast\n-\n-use std;\n-import str;\n-import libc::*;\n-\n-#[nolink]\n-native mod libc {\n-    fn write(fd: core::libc::c_int, buf: *u8, nbyte: core::libc::size_t);\n-}\n-\n-fn main() {\n-    let s = \"hello world\\n\";\n-    let b = str::bytes(s);\n-    let l = str::len(s) as core::libc::size_t;\n-    let b8 = unsafe { vec::unsafe::to_ptr(b) };\n-    libc::write(0i32, b8, l);\n-    let a = bind libc::write(0i32, _, _);\n-    a(b8, l);\n-}"}, {"sha": "1b9e05d4fe6d05351cdd17482fe0ba7abade6c6d", "filename": "src/test/run-pass/bind-native.rs", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8395305e71895b152e3f0abefb6cbc9e74f15a16/src%2Ftest%2Frun-pass%2Fbind-native.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8395305e71895b152e3f0abefb6cbc9e74f15a16/src%2Ftest%2Frun-pass%2Fbind-native.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbind-native.rs?ref=8395305e71895b152e3f0abefb6cbc9e74f15a16", "patch": "@@ -1,10 +0,0 @@\n-/*\n-Can we bind native things?\n-*/\n-\n-#[abi = \"cdecl\"]\n-native mod rustrt {\n-    fn rand_new() -> *libc::c_void;\n-}\n-\n-fn main() { bind rustrt::rand_new(); }"}, {"sha": "997bc2b17990a950415d16f013e92787e44edb92", "filename": "src/test/run-pass/bind-parameterized-args-2.rs", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8395305e71895b152e3f0abefb6cbc9e74f15a16/src%2Ftest%2Frun-pass%2Fbind-parameterized-args-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8395305e71895b152e3f0abefb6cbc9e74f15a16/src%2Ftest%2Frun-pass%2Fbind-parameterized-args-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbind-parameterized-args-2.rs?ref=8395305e71895b152e3f0abefb6cbc9e74f15a16", "patch": "@@ -1,7 +0,0 @@\n-fn main() {\n-    fn echo<T>(c: int, x: fn@(T)) { #error(\"wee\"); }\n-\n-    let y = echo(42, _);\n-\n-    y(fn@(&&i: str) { });\n-}"}, {"sha": "a990ecc4da17857721006661240b2d9fbb4533c2", "filename": "src/test/run-pass/bind-parameterized-args.rs", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8395305e71895b152e3f0abefb6cbc9e74f15a16/src%2Ftest%2Frun-pass%2Fbind-parameterized-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8395305e71895b152e3f0abefb6cbc9e74f15a16/src%2Ftest%2Frun-pass%2Fbind-parameterized-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbind-parameterized-args.rs?ref=8395305e71895b152e3f0abefb6cbc9e74f15a16", "patch": "@@ -1,7 +0,0 @@\n-fn main() {\n-    fn echo<T>(c: int, x: [T]) { }\n-\n-    let y: fn@([int]) = echo(42, _);\n-\n-    y([1]);\n-}"}, {"sha": "52bae30b8ff61de64d40d9fe9b6ebd33125acd7a", "filename": "src/test/run-pass/bind-thunk.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8395305e71895b152e3f0abefb6cbc9e74f15a16/src%2Ftest%2Frun-pass%2Fbind-thunk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8395305e71895b152e3f0abefb6cbc9e74f15a16/src%2Ftest%2Frun-pass%2Fbind-thunk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbind-thunk.rs?ref=8395305e71895b152e3f0abefb6cbc9e74f15a16", "patch": "@@ -1,11 +0,0 @@\n-\n-\n-\n-// -*- rust -*-\n-fn f() -> int { ret 42; }\n-\n-fn main() {\n-    let g: fn@() -> int = bind f();\n-    let i: int = g();\n-    assert (i == 42);\n-}"}, {"sha": "205809a2b6943fc1794007b12cdf65e181a05b4a", "filename": "src/test/run-pass/bind-trivial.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8395305e71895b152e3f0abefb6cbc9e74f15a16/src%2Ftest%2Frun-pass%2Fbind-trivial.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8395305e71895b152e3f0abefb6cbc9e74f15a16/src%2Ftest%2Frun-pass%2Fbind-trivial.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbind-trivial.rs?ref=8395305e71895b152e3f0abefb6cbc9e74f15a16", "patch": "@@ -1,11 +0,0 @@\n-\n-\n-\n-// -*- rust -*-\n-fn f(n: int) -> int { ret n; }\n-\n-fn main() {\n-    let g: fn@(int) -> int = f(_);\n-    let i: int = g(42);\n-    assert (i == 42);\n-}"}, {"sha": "70e6c432c91ee12e7fd2ba6fb99e8311c69e8a3d", "filename": "src/test/run-pass/block-fn-coerce.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Frun-pass%2Fblock-fn-coerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Frun-pass%2Fblock-fn-coerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-fn-coerce.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -2,6 +2,6 @@ fn force(f: fn() -> int) -> int { ret f(); }\n fn main() {\n     fn f() -> int { ret 7; }\n     assert (force(f) == 7);\n-    let g = bind force(f);\n+    let g = {||force(f)};\n     assert (g() == 7);\n }"}, {"sha": "4a050761538a89885d0189aba8c576c728b6a4f5", "filename": "src/test/run-pass/cycle-collection2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Frun-pass%2Fcycle-collection2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Frun-pass%2Fcycle-collection2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcycle-collection2.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -4,7 +4,7 @@ fn nop() { }\n fn nop_foo(_x : @foo) { }\n \n fn main() {\n-    let w = @{ mut z: bind nop() };\n-    let x = bind nop_foo(w);\n+    let w = @{ mut z: {||nop()} };\n+    let x = {||nop_foo(w)};\n     w.z = x;\n }\n\\ No newline at end of file"}, {"sha": "ccbcdf6037b215cfc5c71874f3f1fc2bbc18c4b7", "filename": "src/test/run-pass/cycle-collection4.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Frun-pass%2Fcycle-collection4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Frun-pass%2Fcycle-collection4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcycle-collection4.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -4,7 +4,7 @@ fn nop() { }\n fn nop_foo(_y: [int], _x : @foo) { }\n \n fn main() {\n-    let w = @{ mut z: bind nop() };\n-    let x = bind nop_foo([], w);\n+    let w = @{ mut z: {||nop()} };\n+    let x = {||nop_foo([], w)};\n     w.z = x;\n }\n\\ No newline at end of file"}, {"sha": "b75e559aae2715e942e92e12851976319db0e6c9", "filename": "src/test/run-pass/cycle-collection5.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Frun-pass%2Fcycle-collection5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Frun-pass%2Fcycle-collection5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcycle-collection5.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -6,7 +6,7 @@ fn nop_foo(_y: @int, _x : @foo) { }\n fn o() -> @int { @10 }\n \n fn main() {\n-    let w = @{ mut z: bind nop() };\n-    let x = bind nop_foo(o(), w);\n+    let w = @{ mut z: {||nop()} };\n+    let x = {||nop_foo(o(), w)};\n     w.z = x;\n }\n\\ No newline at end of file"}, {"sha": "e75320c1e7549da9f22aa39fd7ba5b578e4cd512", "filename": "src/test/run-pass/drop-bind-thunk-args.rs", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8395305e71895b152e3f0abefb6cbc9e74f15a16/src%2Ftest%2Frun-pass%2Fdrop-bind-thunk-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8395305e71895b152e3f0abefb6cbc9e74f15a16/src%2Ftest%2Frun-pass%2Fdrop-bind-thunk-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdrop-bind-thunk-args.rs?ref=8395305e71895b152e3f0abefb6cbc9e74f15a16", "patch": "@@ -1,5 +0,0 @@\n-\n-\n-fn f(x: @int) { }\n-\n-fn main() { let x = @10; let ff = f(_); ff(x); ff(x); }"}, {"sha": "39785d10bbf287ab7ede67aa897590ff9a27a2de", "filename": "src/test/run-pass/drop-parametric-closure-with-bound-box.rs", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8395305e71895b152e3f0abefb6cbc9e74f15a16/src%2Ftest%2Frun-pass%2Fdrop-parametric-closure-with-bound-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8395305e71895b152e3f0abefb6cbc9e74f15a16/src%2Ftest%2Frun-pass%2Fdrop-parametric-closure-with-bound-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdrop-parametric-closure-with-bound-box.rs?ref=8395305e71895b152e3f0abefb6cbc9e74f15a16", "patch": "@@ -1,5 +0,0 @@\n-\n-\n-fn f<T>(i: @uint, t: T) { }\n-\n-fn main() { let x = f::<char>(@0xdeafbeefu, _); }"}, {"sha": "1a3e6edd151d9fec0acea43ef5abaf6a919e216a", "filename": "src/test/run-pass/empty-tag.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Frun-pass%2Fempty-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Frun-pass%2Fempty-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fempty-tag.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -5,6 +5,6 @@ fn wrapper3(i: chan) {\n }\n \n fn main() {\n-    let wrapped = bind wrapper3(chan_t);\n+    let wrapped = {||wrapper3(chan_t)};\n     wrapped();\n }"}, {"sha": "aa90fb785ec7efa9eab98bfb23031955f99ce0a3", "filename": "src/test/run-pass/expr-alt-generic-box1.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box1.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -11,8 +11,7 @@ fn test_generic<T>(expected: @T, eq: compare<T>) {\n \n fn test_box() {\n     fn compare_box(b1: @bool, b2: @bool) -> bool { ret *b1 == *b2; }\n-    let eq = compare_box(_, _);\n-    test_generic::<bool>(@true, eq);\n+    test_generic::<bool>(@true, compare_box);\n }\n \n fn main() { test_box(); }"}, {"sha": "78383513cd46ce295db3c90edadce9ef58cadf6d", "filename": "src/test/run-pass/expr-alt-generic-box2.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box2.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -11,8 +11,7 @@ fn test_generic<T: copy>(expected: T, eq: compare<T>) {\n \n fn test_vec() {\n     fn compare_box(&&v1: @int, &&v2: @int) -> bool { ret v1 == v2; }\n-    let eq = compare_box(_, _);\n-    test_generic::<@int>(@1, eq);\n+    test_generic::<@int>(@1, compare_box);\n }\n \n fn main() { test_vec(); }"}, {"sha": "d7d639bcbcb45632dab887ccb4385284ba31b7dd", "filename": "src/test/run-pass/expr-alt-generic-unique1.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-unique1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-unique1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-unique1.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -10,8 +10,7 @@ fn test_generic<T: copy>(expected: ~T, eq: compare<T>) {\n \n fn test_box() {\n     fn compare_box(b1: ~bool, b2: ~bool) -> bool { ret *b1 == *b2; }\n-    let eq = compare_box(_, _);\n-    test_generic::<bool>(~true, eq);\n+    test_generic::<bool>(~true, compare_box);\n }\n \n fn main() { test_box(); }"}, {"sha": "a1923e2dd8c76fcc184ef2e42fee55e4cc1933c9", "filename": "src/test/run-pass/expr-alt-generic-unique2.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-unique2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-unique2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-unique2.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -11,8 +11,7 @@ fn test_generic<T: copy>(expected: T, eq: compare<T>) {\n \n fn test_vec() {\n     fn compare_box(&&v1: ~int, &&v2: ~int) -> bool { ret v1 == v2; }\n-    let eq = compare_box(_, _);\n-    test_generic::<~int>(~1, eq);\n+    test_generic::<~int>(~1, compare_box);\n }\n \n fn main() { test_vec(); }"}, {"sha": "57d519b62cbffc8cbb73bfb531462cce1022e4bf", "filename": "src/test/run-pass/expr-alt-generic.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Frun-pass%2Fexpr-alt-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Frun-pass%2Fexpr-alt-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-generic.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -11,16 +11,14 @@ fn test_generic<T: copy>(expected: T, eq: compare<T>) {\n \n fn test_bool() {\n     fn compare_bool(&&b1: bool, &&b2: bool) -> bool { ret b1 == b2; }\n-    let eq = compare_bool(_, _);\n-    test_generic::<bool>(true, eq);\n+    test_generic::<bool>(true, compare_bool);\n }\n \n fn test_rec() {\n     type t = {a: int, b: int};\n \n     fn compare_rec(t1: t, t2: t) -> bool { ret t1 == t2; }\n-    let eq = compare_rec(_, _);\n-    test_generic::<t>({a: 1, b: 2}, eq);\n+    test_generic::<t>({a: 1, b: 2}, compare_rec);\n }\n \n fn main() { test_bool(); test_rec(); }"}, {"sha": "f4be90bfe342fc9a1da585d198c677ab832622ed", "filename": "src/test/run-pass/expr-block-generic-box1.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box1.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -15,8 +15,7 @@ fn test_box() {\n         log(debug, *b2);\n         ret *b1 == *b2;\n     }\n-    let eq = compare_box(_, _);\n-    test_generic::<bool>(@true, eq);\n+    test_generic::<bool>(@true, compare_box);\n }\n \n fn main() { test_box(); }"}, {"sha": "8d8fc5020d5dde9410baa91da6745fa50bd721bd", "filename": "src/test/run-pass/expr-block-generic-box2.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box2.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -11,8 +11,7 @@ fn test_generic<T: copy>(expected: T, eq: compare<T>) {\n \n fn test_vec() {\n     fn compare_vec(&&v1: @int, &&v2: @int) -> bool { ret v1 == v2; }\n-    let eq = compare_vec(_, _);\n-    test_generic::<@int>(@1, eq);\n+    test_generic::<@int>(@1, compare_vec);\n }\n \n fn main() { test_vec(); }"}, {"sha": "c7953536546f49e3afc01eb24e52dd73893e2da0", "filename": "src/test/run-pass/expr-block-generic-unique1.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Frun-pass%2Fexpr-block-generic-unique1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Frun-pass%2Fexpr-block-generic-unique1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-generic-unique1.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -14,8 +14,7 @@ fn test_box() {\n         log(debug, *b2);\n         ret *b1 == *b2;\n     }\n-    let eq = compare_box(_, _);\n-    test_generic::<bool>(~true, eq);\n+    test_generic::<bool>(~true, compare_box);\n }\n \n fn main() { test_box(); }"}, {"sha": "7b210b66f1f78a5396db5efa86e02bfc70318b93", "filename": "src/test/run-pass/expr-block-generic-unique2.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Frun-pass%2Fexpr-block-generic-unique2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Frun-pass%2Fexpr-block-generic-unique2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-generic-unique2.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -11,8 +11,7 @@ fn test_generic<T: copy>(expected: T, eq: compare<T>) {\n \n fn test_vec() {\n     fn compare_vec(&&v1: ~int, &&v2: ~int) -> bool { ret v1 == v2; }\n-    let eq = compare_vec(_, _);\n-    test_generic::<~int>(~1, eq);\n+    test_generic::<~int>(~1, compare_vec);\n }\n \n fn main() { test_vec(); }"}, {"sha": "d5a329189b51174fb9ddcd4b67f5f758bb411a30", "filename": "src/test/run-pass/expr-block-generic.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Frun-pass%2Fexpr-block-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Frun-pass%2Fexpr-block-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-generic.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -13,16 +13,14 @@ fn test_generic<T: copy>(expected: T, eq: compare<T>) {\n \n fn test_bool() {\n     fn compare_bool(&&b1: bool, &&b2: bool) -> bool { ret b1 == b2; }\n-    let eq = compare_bool(_, _);\n-    test_generic::<bool>(true, eq);\n+    test_generic::<bool>(true, compare_bool);\n }\n \n fn test_rec() {\n     type t = {a: int, b: int};\n \n     fn compare_rec(t1: t, t2: t) -> bool { ret t1 == t2; }\n-    let eq = compare_rec(_, _);\n-    test_generic::<t>({a: 1, b: 2}, eq);\n+    test_generic::<t>({a: 1, b: 2}, compare_rec);\n }\n \n fn main() { test_bool(); test_rec(); }"}, {"sha": "0eea4a8ee3421c4e1da60ca284f85922e23d4dfe", "filename": "src/test/run-pass/expr-if-generic-box1.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box1.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -11,8 +11,7 @@ fn test_generic<T>(expected: @T, not_expected: @T, eq: compare<T>) {\n \n fn test_box() {\n     fn compare_box(b1: @bool, b2: @bool) -> bool { ret *b1 == *b2; }\n-    let eq = compare_box(_, _);\n-    test_generic::<bool>(@true, @false, eq);\n+    test_generic::<bool>(@true, @false, compare_box);\n }\n \n fn main() { test_box(); }"}, {"sha": "e4379e22e807ae00ef3bf0ac14d62db333256d2e", "filename": "src/test/run-pass/expr-if-generic-box2.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box2.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -11,8 +11,7 @@ fn test_generic<T: copy>(expected: T, not_expected: T, eq: compare<T>) {\n \n fn test_vec() {\n     fn compare_box(&&v1: @int, &&v2: @int) -> bool { ret v1 == v2; }\n-    let eq = compare_box(_, _);\n-    test_generic::<@int>(@1, @2, eq);\n+    test_generic::<@int>(@1, @2, compare_box);\n }\n \n fn main() { test_vec(); }"}, {"sha": "cb44a03af2dacd91da025ccbaeae1ebe32c75f1a", "filename": "src/test/run-pass/expr-if-generic.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Frun-pass%2Fexpr-if-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Frun-pass%2Fexpr-if-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-if-generic.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -13,16 +13,14 @@ fn test_generic<T: copy>(expected: T, not_expected: T, eq: compare<T>) {\n \n fn test_bool() {\n     fn compare_bool(&&b1: bool, &&b2: bool) -> bool { ret b1 == b2; }\n-    let eq = compare_bool(_, _);\n-    test_generic::<bool>(true, false, eq);\n+    test_generic::<bool>(true, false, compare_bool);\n }\n \n fn test_rec() {\n     type t = {a: int, b: int};\n \n     fn compare_rec(t1: t, t2: t) -> bool { ret t1 == t2; }\n-    let eq = compare_rec(_, _);\n-    test_generic::<t>({a: 1, b: 2}, {a: 2, b: 3}, eq);\n+    test_generic::<t>({a: 1, b: 2}, {a: 2, b: 3}, compare_rec);\n }\n \n fn main() { test_bool(); test_rec(); }"}, {"sha": "a9d0e3e077dab3d1b59ccf4bf170439475e550b7", "filename": "src/test/run-pass/fixed-point-bind-box.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Frun-pass%2Ffixed-point-bind-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Frun-pass%2Ffixed-point-bind-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffixed-point-bind-box.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -1,9 +1,9 @@\n fn fix_help<A, B>(f: native fn(fn@(A) -> B, A) -> B, x: A) -> B {\n-    ret f(fix_help(f, _), x);\n+    ret f({|a|fix_help(f, a)}, x);\n }\n \n fn fix<A, B>(f: native fn(fn@(A) -> B, A) -> B) -> fn@(A) -> B {\n-    ret fix_help(f, _);\n+    ret {|a|fix_help(f, a)};\n }\n \n fn fact_(f: fn@(&&int) -> int, &&n: int) -> int {"}, {"sha": "75315243a7452a456020268a3a5ba1c04a1d3dd2", "filename": "src/test/run-pass/fixed-point-bind-unique.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Frun-pass%2Ffixed-point-bind-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Frun-pass%2Ffixed-point-bind-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffixed-point-bind-unique.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -1,9 +1,9 @@\n fn fix_help<A, B: send>(f: native fn(fn@(A) -> B, A) -> B, x: A) -> B {\n-    ret f(fix_help(f, _), x);\n+    ret f({|a|fix_help(f, a)}, x);\n }\n \n fn fix<A, B: send>(f: native fn(fn@(A) -> B, A) -> B) -> fn@(A) -> B {\n-    ret fix_help(f, _);\n+    ret {|a|fix_help(f, a)};\n }\n \n fn fact_(f: fn@(&&int) -> int, &&n: int) -> int {"}, {"sha": "58b28df63ae897b02e43f3b01103543d58e44943", "filename": "src/test/run-pass/fn-bare-bind-generic.rs", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8395305e71895b152e3f0abefb6cbc9e74f15a16/src%2Ftest%2Frun-pass%2Ffn-bare-bind-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8395305e71895b152e3f0abefb6cbc9e74f15a16/src%2Ftest%2Frun-pass%2Ffn-bare-bind-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffn-bare-bind-generic.rs?ref=8395305e71895b152e3f0abefb6cbc9e74f15a16", "patch": "@@ -1,10 +0,0 @@\n-fn f<T>(i: T, j: T, k: T) {\n-    assert i == j;\n-    assert j != k;\n-}\n-\n-fn main() {\n-    // Binding a bare function turns it into a shared closure\n-    let g: fn@() = bind f(10, 10, 20);\n-    g();\n-}\n\\ No newline at end of file"}, {"sha": "064e6430f8ad31a88cd0efd7a10c86d1a121650a", "filename": "src/test/run-pass/fn-bare-bind.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8395305e71895b152e3f0abefb6cbc9e74f15a16/src%2Ftest%2Frun-pass%2Ffn-bare-bind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8395305e71895b152e3f0abefb6cbc9e74f15a16/src%2Ftest%2Frun-pass%2Ffn-bare-bind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffn-bare-bind.rs?ref=8395305e71895b152e3f0abefb6cbc9e74f15a16", "patch": "@@ -1,9 +0,0 @@\n-fn f(i: int) {\n-    assert i == 10;\n-}\n-\n-fn main() {\n-    // Binding a bare function turns it into a shared closure\n-    let g: fn@() = bind f(10);\n-    g();\n-}\n\\ No newline at end of file"}, {"sha": "408bd665534bf821ea3b6e7a710897f353974d0c", "filename": "src/test/run-pass/fun-call-variants.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Frun-pass%2Ffun-call-variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Frun-pass%2Ffun-call-variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffun-call-variants.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -7,7 +7,5 @@ fn main() {\n     let a: int = direct(3); // direct\n     let b: int = ho(direct); // indirect unbound\n \n-    let c: int = ho(direct(_)); // indirect bound\n     assert (a == b);\n-    assert (b == c);\n }"}, {"sha": "eeb9cf25f8ffdaa9072709471390abc4686c8494", "filename": "src/test/run-pass/generic-bind-2.rs", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8395305e71895b152e3f0abefb6cbc9e74f15a16/src%2Ftest%2Frun-pass%2Fgeneric-bind-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8395305e71895b152e3f0abefb6cbc9e74f15a16/src%2Ftest%2Frun-pass%2Fgeneric-bind-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-bind-2.rs?ref=8395305e71895b152e3f0abefb6cbc9e74f15a16", "patch": "@@ -1,10 +0,0 @@\n-\n-\n-fn id<T: copy>(t: T) -> T { ret t; }\n-\n-fn main() {\n-    let t = {a: 1, b: 2, c: 3, d: 4, e: 5, f: 6, g: 7};\n-    assert (t.f == 6);\n-    let f0 = bind id(t);\n-    assert (f0().f == 6);\n-}"}, {"sha": "5a9795d7ec60f629f0f3d47376c482e470b87093", "filename": "src/test/run-pass/generic-bind.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8395305e71895b152e3f0abefb6cbc9e74f15a16/src%2Ftest%2Frun-pass%2Fgeneric-bind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8395305e71895b152e3f0abefb6cbc9e74f15a16/src%2Ftest%2Frun-pass%2Fgeneric-bind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-bind.rs?ref=8395305e71895b152e3f0abefb6cbc9e74f15a16", "patch": "@@ -1,17 +0,0 @@\n-\n-\n-fn id<T: copy>(t: T) -> T { ret t; }\n-\n-fn main() {\n-    let t = {_0: 1, _1: 2, _2: 3, _3: 4, _4: 5, _5: 6, _6: 7};\n-    assert (t._5 == 6);\n-    let f1 =\n-        id::<{_0: int,\n-              _1: int,\n-              _2: int,\n-              _3: int,\n-              _4: int,\n-              _5: int,\n-              _6: int}>(_);\n-    assert (f1(t)._5 == 6);\n-}"}, {"sha": "9d8e7ec116e9a1dece988a8afc51f33a5cb1d3a6", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -59,7 +59,7 @@ mod map_reduce {\n             }\n         }\n \n-        map(input, emit(intermediates, ctrl, _, _));\n+        map(input, {|a,b|emit(intermediates, ctrl, a, b)});\n         send(ctrl, mapper_done);\n     }\n "}, {"sha": "e2ad9dccf67a1ce1eafd7fee485f97eb14a6807f", "filename": "src/test/run-pass/integer-literal-suffix-inference.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Frun-pass%2Finteger-literal-suffix-inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Frun-pass%2Finteger-literal-suffix-inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Finteger-literal-suffix-inference.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -1,8 +1,4 @@\n fn main() {\n-\n-    // The commented-out lines are ones that fail currently.  I'm\n-    // working on figuring out why (#1425). -- lkuper\n-\n     fn id_i8(n: i8) -> i8 { n }\n     fn id_i16(n: i16) -> i16 { n }\n     fn id_i32(n: i32) -> i32 { n }\n@@ -16,22 +12,22 @@ fn main() {\n \n     let _i: i8 = -128;\n     let j = -128;\n-    // id_i8(j);\n+    id_i8(j);\n     id_i8(-128);\n \n     let _i: i16 = -32_768;\n     let j = -32_768;\n-    // id_i16(j);\n+    id_i16(j);\n     id_i16(-32_768);\n \n     let _i: i32 = -2_147_483_648;\n     let j = -2_147_483_648;\n-    // id_i32(j);\n+    id_i32(j);\n     id_i32(-2_147_483_648);\n \n     let _i: i64 = -9_223_372_036_854_775_808;\n     let j = -9_223_372_036_854_775_808;\n-    // id_i64(j);\n+    id_i64(j);\n     id_i64(-9_223_372_036_854_775_808);\n \n     let _i: uint = 1;"}, {"sha": "77cf0b7e08961310fe151cdfee92e59723c8f463", "filename": "src/test/run-pass/issue-1899.rs", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8395305e71895b152e3f0abefb6cbc9e74f15a16/src%2Ftest%2Frun-pass%2Fissue-1899.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8395305e71895b152e3f0abefb6cbc9e74f15a16/src%2Ftest%2Frun-pass%2Fissue-1899.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-1899.rs?ref=8395305e71895b152e3f0abefb6cbc9e74f15a16", "patch": "@@ -1,4 +0,0 @@\n-fn main()\n-{\n-    let _b = [bind (fn~() { })()];\n-}"}, {"sha": "151361660f567b7d78f518e627dd90d5312c608a", "filename": "src/test/run-pass/issue-2185.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Frun-pass%2Fissue-2185.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Frun-pass%2Fissue-2185.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2185.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -37,11 +37,11 @@ fn range(lo: uint, hi: uint, it: fn(uint)) {\n }\n \n fn main() {\n-    let range = bind range(0u, 1000u, _);\n-    let filt = bind filter(\n+    let range = {|a|range(0u, 1000u, a)};\n+    let filt = {|a|filter(\n         range,\n         {|&&n: uint| n % 3u != 0u && n % 5u != 0u },\n-        _);\n+        a)};\n     let sum = foldl(filt, 0u) {|accum, &&n: uint| accum + n };\n \n     io::println(#fmt(\"%u\", sum));"}, {"sha": "c6f2cc99e33cb34042bab2286ae03ddbca32b5b1", "filename": "src/test/run-pass/issue-2242-d.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Frun-pass%2Fissue-2242-d.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Frun-pass%2Fissue-2242-d.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2242-d.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -0,0 +1,17 @@\n+// xfail-test\n+// aux-build:issue_2242_a.rs\n+// aux-build:issue_2242_b.rs\n+// aux-build:issue_2242_c.rs\n+\n+use a;\n+use b;\n+use c;\n+\n+import b::to_str;\n+import c::to_str;\n+\n+fn main() {\n+    io::println(\"foo\".to_str());\n+    io::println(1.to_str());\n+    io::println(true.to_str());\n+}"}, {"sha": "63e1fda60a8ae1a18c4aefac909ad69da4bc8d1b", "filename": "src/test/run-pass/issue-2642.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Frun-pass%2Fissue-2642.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Frun-pass%2Fissue-2642.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2642.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -0,0 +1,6 @@\n+fn f() {\n+   let _x: uint = loop { loop { break; } };\n+}\n+\n+fn main() {\n+}"}, {"sha": "06202bc1c0b2ec88536bbce5c9b5570c6f0f2178", "filename": "src/test/run-pass/issue-333.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Frun-pass%2Fissue-333.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Frun-pass%2Fissue-333.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-333.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -1,4 +1,4 @@\n-fn quux<T: copy>(x: T) -> T { let f = id::<T>(_); ret f(x); }\n+fn quux<T: copy>(x: T) -> T { let f = id::<T>; ret f(x); }\n \n fn id<T: copy>(x: T) -> T { ret x; }\n "}, {"sha": "7b6f3033ab41393ecf7da569b270e13b2095c5ea", "filename": "src/test/run-pass/issue-898.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8395305e71895b152e3f0abefb6cbc9e74f15a16/src%2Ftest%2Frun-pass%2Fissue-898.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8395305e71895b152e3f0abefb6cbc9e74f15a16/src%2Ftest%2Frun-pass%2Fissue-898.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-898.rs?ref=8395305e71895b152e3f0abefb6cbc9e74f15a16", "patch": "@@ -1,11 +0,0 @@\n-fn even(&&e: int) -> bool {\n-    e % 2 == 0\n-}\n-\n-fn log_if<T>(c: native fn(T)->bool, e: T) {\n-    if c(e) { log(debug, e); }\n-}\n-\n-fn main() {\n-    (log_if(even, _))(2);\n-}"}, {"sha": "49cc7ef6d5a9b03f0abd59bf8721726ee8b84358", "filename": "src/test/run-pass/rebind-fn.rs", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8395305e71895b152e3f0abefb6cbc9e74f15a16/src%2Ftest%2Frun-pass%2Frebind-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8395305e71895b152e3f0abefb6cbc9e74f15a16/src%2Ftest%2Frun-pass%2Frebind-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frebind-fn.rs?ref=8395305e71895b152e3f0abefb6cbc9e74f15a16", "patch": "@@ -1,8 +0,0 @@\n-fn add(i: int, j: int) -> int { ret i + j; }\n-fn binder(n: int) -> fn@() -> int { let f = add(n, _); ret bind f(2); }\n-fn main() {\n-    binder(5);\n-    let f = binder(1);\n-    assert (f() == 3);\n-    assert (binder(8)() == 10);\n-}"}, {"sha": "99131811ae1c63eb28ea5c59ad86dbeb75818106", "filename": "src/test/run-pass/unchecked-predicates.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Frun-pass%2Funchecked-predicates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Frun-pass%2Funchecked-predicates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funchecked-predicates.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -18,7 +18,7 @@ fn pure_foldl<T: copy, U: copy>(ls: @list<T>, u: U, f: fn(T, U) -> U) -> U {\n // fn from a pure fn\n pure fn pure_length<T: copy>(ls: @list<T>) -> uint {\n     fn count<T>(_t: T, &&u: uint) -> uint { u + 1u }\n-    unchecked{ pure_foldl(ls, 0u, count(_, _)) }\n+    unchecked{ pure_foldl(ls, 0u, count) }\n }\n \n pure fn nonempty_list<T: copy>(ls: @list<T>) -> bool { pure_length(ls) > 0u }"}, {"sha": "e8758237bb7cd0152f29124198bd11338dbec809", "filename": "src/test/run-pass/weird-exprs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Frun-pass%2Fweird-exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6943dd31e8002b2e0267b7539b55ba9da7490b/src%2Ftest%2Frun-pass%2Fweird-exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fweird-exprs.rs?ref=0a6943dd31e8002b2e0267b7539b55ba9da7490b", "patch": "@@ -10,7 +10,7 @@ fn funny() {\n fn what() {\n     fn the(x: @mut bool) { ret while !*x { *x = true; }; }\n     let i = @mut false;\n-    let dont = bind the(i);\n+    let dont = {||the(i)};\n     dont();\n     assert (*i);\n }"}]}