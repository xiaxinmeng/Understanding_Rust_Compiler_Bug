{"sha": "d201c812d40932509b2b5307c0b20c1ce78d21da", "node_id": "C_kwDOAAsO6NoAKGQyMDFjODEyZDQwOTMyNTA5YjJiNTMwN2MwYjIwYzFjZTc4ZDIxZGE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-30T13:52:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-30T13:52:29Z"}, "message": "Auto merge of #93803 - cjgillot:unify-bounds, r=oli-obk\n\nHandle generic bounds in a uniform way in HIR\n\nGeneric bounds in HIR used to be split between bounds in the parameter definition and bounds in a where clause. This PR attempts to store all of those as where predicates.\n\nThis effectively desugars\n```rust\nfn foo<T: Default, U>(x: impl Copy) where U: Clone\n```\ninto\n```rust\nfn foo<T, U, _V>(x: _V) where T: Default, U: Clone, _V: Copy\n```\n(where _V is actually hidden and called \"impl Copy\").\n\nI managed to make compiler warnings more uniform.\nAbout rustdoc: is making this desugaring user-visible acceptable?\nAbout clippy: I don't understand the subtle logic in the `needless-lifetimes` lint.\n\nr? `@estebank`", "tree": {"sha": "febd00751fa6caa1f704cdcabe5249a7643643e7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/febd00751fa6caa1f704cdcabe5249a7643643e7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d201c812d40932509b2b5307c0b20c1ce78d21da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d201c812d40932509b2b5307c0b20c1ce78d21da", "html_url": "https://github.com/rust-lang/rust/commit/d201c812d40932509b2b5307c0b20c1ce78d21da", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d201c812d40932509b2b5307c0b20c1ce78d21da/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "76d4862fdd131b6f79dc0a31857f888d26bcdb27", "url": "https://api.github.com/repos/rust-lang/rust/commits/76d4862fdd131b6f79dc0a31857f888d26bcdb27", "html_url": "https://github.com/rust-lang/rust/commit/76d4862fdd131b6f79dc0a31857f888d26bcdb27"}, {"sha": "b4e3e62c9cde00637fc2e69b24581ba77494035b", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4e3e62c9cde00637fc2e69b24581ba77494035b", "html_url": "https://github.com/rust-lang/rust/commit/b4e3e62c9cde00637fc2e69b24581ba77494035b"}], "stats": {"total": 2960, "additions": 1498, "deletions": 1462}, "files": [{"sha": "cdcd221e811a77c2f21888b6eccd617897b94f2f", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -397,6 +397,7 @@ pub struct GenericParam {\n     pub bounds: GenericBounds,\n     pub is_placeholder: bool,\n     pub kind: GenericParamKind,\n+    pub colon_span: Option<Span>,\n }\n \n impl GenericParam {"}, {"sha": "d7b1bc6a7f580bc514f0b47ca4ab4590df04e156", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -867,9 +867,12 @@ pub fn noop_flat_map_generic_param<T: MutVisitor>(\n     mut param: GenericParam,\n     vis: &mut T,\n ) -> SmallVec<[GenericParam; 1]> {\n-    let GenericParam { id, ident, attrs, bounds, kind, is_placeholder: _ } = &mut param;\n+    let GenericParam { id, ident, attrs, bounds, kind, colon_span, is_placeholder: _ } = &mut param;\n     vis.visit_id(id);\n     vis.visit_ident(ident);\n+    if let Some(ref mut colon_span) = colon_span {\n+        vis.visit_span(colon_span);\n+    }\n     visit_thin_attrs(attrs, vis);\n     visit_vec(bounds, |bound| noop_visit_param_bound(bound, vis));\n     match kind {"}, {"sha": "125acdcc27d9723e208799e511b88af77b543c85", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 108, "deletions": 28, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -267,9 +267,14 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         this.lower_maybe_async_body(span, &decl, asyncness, body.as_deref());\n \n                     let (generics, decl) =\n-                        this.add_implicit_generics(generics, id, |this, idty| {\n+                        this.add_implicit_generics(generics, id, |this, idty, idpb| {\n                             let ret_id = asyncness.opt_return_id();\n-                            this.lower_fn_decl(&decl, Some((id, idty)), FnDeclKind::Fn, ret_id)\n+                            this.lower_fn_decl(\n+                                &decl,\n+                                Some((id, idty, idpb)),\n+                                FnDeclKind::Fn,\n+                                ret_id,\n+                            )\n                         });\n                     let sig = hir::FnSig {\n                         decl,\n@@ -384,7 +389,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 // lifetime to be added, but rather a reference to a\n                 // parent lifetime.\n                 let (generics, (trait_ref, lowered_ty)) =\n-                    self.add_implicit_generics(ast_generics, id, |this, _| {\n+                    self.add_implicit_generics(ast_generics, id, |this, _, _| {\n                         let trait_ref = trait_ref.as_ref().map(|trait_ref| {\n                             this.lower_trait_ref(\n                                 trait_ref,\n@@ -410,7 +415,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     ImplPolarity::Positive => ImplPolarity::Positive,\n                     ImplPolarity::Negative(s) => ImplPolarity::Negative(self.lower_span(s)),\n                 };\n-                hir::ItemKind::Impl(hir::Impl {\n+                hir::ItemKind::Impl(self.arena.alloc(hir::Impl {\n                     unsafety: self.lower_unsafety(unsafety),\n                     polarity,\n                     defaultness,\n@@ -420,7 +425,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     of_trait: trait_ref,\n                     self_ty: lowered_ty,\n                     items: new_impl_items,\n-                })\n+                }))\n             }\n             ItemKind::Trait(box Trait {\n                 is_auto,\n@@ -649,7 +654,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 ForeignItemKind::Fn(box Fn { ref sig, ref generics, .. }) => {\n                     let fdec = &sig.decl;\n                     let (generics, (fn_dec, fn_args)) =\n-                        self.add_implicit_generics(generics, i.id, |this, _| {\n+                        self.add_implicit_generics(generics, i.id, |this, _, _| {\n                             (\n                                 // Disallow `impl Trait` in foreign items.\n                                 this.lower_fn_decl(fdec, None, FnDeclKind::ExternFn, None),\n@@ -1226,10 +1231,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         id: NodeId,\n         kind: FnDeclKind,\n         is_async: Option<NodeId>,\n-    ) -> (hir::Generics<'hir>, hir::FnSig<'hir>) {\n+    ) -> (&'hir hir::Generics<'hir>, hir::FnSig<'hir>) {\n         let header = self.lower_fn_header(sig.header);\n-        let (generics, decl) = self.add_implicit_generics(generics, id, |this, idty| {\n-            this.lower_fn_decl(&sig.decl, Some((id, idty)), kind, is_async)\n+        let (generics, decl) = self.add_implicit_generics(generics, id, |this, idty, idpb| {\n+            this.lower_fn_decl(&sig.decl, Some((id, idty, idpb)), kind, is_async)\n         });\n         (generics, hir::FnSig { header, decl, span: self.lower_span(sig.span) })\n     }\n@@ -1289,7 +1294,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     pub(super) fn lower_generics_mut(\n         &mut self,\n         generics: &Generics,\n-        itctx: ImplTraitContext<'_, 'hir>,\n+        mut itctx: ImplTraitContext<'_, 'hir>,\n     ) -> GenericsCtor<'hir> {\n         // Error if `?Trait` bounds in where clauses don't refer directly to type parameters.\n         // Note: we used to clone these bounds directly onto the type parameter (and avoid lowering\n@@ -1338,9 +1343,24 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             }\n         }\n \n+        let mut predicates = SmallVec::new();\n+        predicates.extend(generics.params.iter().filter_map(|param| {\n+            let bounds = self.lower_param_bounds(&param.bounds, itctx.reborrow());\n+            self.lower_generic_bound_predicate(param.ident, param.id, &param.kind, bounds)\n+        }));\n+        predicates.extend(\n+            generics\n+                .where_clause\n+                .predicates\n+                .iter()\n+                .map(|predicate| self.lower_where_predicate(predicate)),\n+        );\n+\n         GenericsCtor {\n-            params: self.lower_generic_params_mut(&generics.params, itctx).collect(),\n-            where_clause: self.lower_where_clause(&generics.where_clause),\n+            params: self.lower_generic_params_mut(&generics.params).collect(),\n+            predicates,\n+            has_where_clause: !generics.where_clause.predicates.is_empty(),\n+            where_clause_span: self.lower_span(generics.where_clause.span),\n             span: self.lower_span(generics.span),\n         }\n     }\n@@ -1349,17 +1369,74 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         &mut self,\n         generics: &Generics,\n         itctx: ImplTraitContext<'_, 'hir>,\n-    ) -> hir::Generics<'hir> {\n+    ) -> &'hir hir::Generics<'hir> {\n         let generics_ctor = self.lower_generics_mut(generics, itctx);\n         generics_ctor.into_generics(self.arena)\n     }\n \n-    fn lower_where_clause(&mut self, wc: &WhereClause) -> hir::WhereClause<'hir> {\n-        hir::WhereClause {\n-            predicates: self.arena.alloc_from_iter(\n-                wc.predicates.iter().map(|predicate| self.lower_where_predicate(predicate)),\n-            ),\n-            span: self.lower_span(wc.span),\n+    pub(super) fn lower_generic_bound_predicate(\n+        &mut self,\n+        ident: Ident,\n+        id: NodeId,\n+        kind: &GenericParamKind,\n+        bounds: &'hir [hir::GenericBound<'hir>],\n+    ) -> Option<hir::WherePredicate<'hir>> {\n+        // Do not create a clause if we do not have anything inside it.\n+        if bounds.is_empty() {\n+            return None;\n+        }\n+        let ident = self.lower_ident(ident);\n+        let param_span = ident.span;\n+        let span = bounds\n+            .iter()\n+            .fold(Some(param_span.shrink_to_hi()), |span: Option<Span>, bound| {\n+                let bound_span = bound.span();\n+                // We include bounds that come from a `#[derive(_)]` but point at the user's code,\n+                // as we use this method to get a span appropriate for suggestions.\n+                if !bound_span.can_be_used_for_suggestions() {\n+                    None\n+                } else if let Some(span) = span {\n+                    Some(span.to(bound_span))\n+                } else {\n+                    Some(bound_span)\n+                }\n+            })\n+            .unwrap_or(param_span.shrink_to_hi());\n+        match kind {\n+            GenericParamKind::Const { .. } => None,\n+            GenericParamKind::Type { .. } => {\n+                let def_id = self.resolver.local_def_id(id).to_def_id();\n+                let ty_path = self.arena.alloc(hir::Path {\n+                    span: param_span,\n+                    res: Res::Def(DefKind::TyParam, def_id),\n+                    segments: self.arena.alloc_from_iter([hir::PathSegment::from_ident(ident)]),\n+                });\n+                let ty_id = self.next_id();\n+                let bounded_ty =\n+                    self.ty_path(ty_id, param_span, hir::QPath::Resolved(None, ty_path));\n+                Some(hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate {\n+                    bounded_ty: self.arena.alloc(bounded_ty),\n+                    bounds,\n+                    span,\n+                    bound_generic_params: &[],\n+                    in_where_clause: false,\n+                }))\n+            }\n+            GenericParamKind::Lifetime => {\n+                let ident_span = self.lower_span(ident.span);\n+                let ident = self.lower_ident(ident);\n+                let res = self.resolver.get_lifetime_res(id).unwrap_or_else(|| {\n+                    panic!(\"Missing resolution for lifetime {:?} at {:?}\", id, ident.span)\n+                });\n+                let lt_id = self.resolver.next_node_id();\n+                let lifetime = self.new_named_lifetime_with_res(lt_id, ident_span, ident, res);\n+                Some(hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate {\n+                    lifetime,\n+                    span,\n+                    bounds,\n+                    in_where_clause: false,\n+                }))\n+            }\n         }\n     }\n \n@@ -1371,10 +1448,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 ref bounds,\n                 span,\n             }) => hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate {\n-                bound_generic_params: self.lower_generic_params(\n-                    bound_generic_params,\n-                    ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n-                ),\n+                bound_generic_params: self.lower_generic_params(bound_generic_params),\n                 bounded_ty: self\n                     .lower_ty(bounded_ty, ImplTraitContext::Disallowed(ImplTraitPosition::Type)),\n                 bounds: self.arena.alloc_from_iter(bounds.iter().map(|bound| {\n@@ -1384,6 +1458,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     )\n                 })),\n                 span: self.lower_span(span),\n+                in_where_clause: true,\n             }),\n             WherePredicate::RegionPredicate(WhereRegionPredicate {\n                 ref lifetime,\n@@ -1396,6 +1471,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     bounds,\n                     ImplTraitContext::Disallowed(ImplTraitPosition::Bound),\n                 ),\n+                in_where_clause: true,\n             }),\n             WherePredicate::EqPredicate(WhereEqPredicate { id, ref lhs_ty, ref rhs_ty, span }) => {\n                 hir::WherePredicate::EqPredicate(hir::WhereEqPredicate {\n@@ -1414,16 +1490,20 @@ impl<'hir> LoweringContext<'_, 'hir> {\n /// Helper struct for delayed construction of Generics.\n pub(super) struct GenericsCtor<'hir> {\n     pub(super) params: SmallVec<[hir::GenericParam<'hir>; 4]>,\n-    where_clause: hir::WhereClause<'hir>,\n+    pub(super) predicates: SmallVec<[hir::WherePredicate<'hir>; 4]>,\n+    has_where_clause: bool,\n+    where_clause_span: Span,\n     span: Span,\n }\n \n impl<'hir> GenericsCtor<'hir> {\n-    pub(super) fn into_generics(self, arena: &'hir Arena<'hir>) -> hir::Generics<'hir> {\n-        hir::Generics {\n+    pub(super) fn into_generics(self, arena: &'hir Arena<'hir>) -> &'hir hir::Generics<'hir> {\n+        arena.alloc(hir::Generics {\n             params: arena.alloc_from_iter(self.params),\n-            where_clause: self.where_clause,\n+            predicates: arena.alloc_from_iter(self.predicates),\n+            has_where_clause: self.has_where_clause,\n+            where_clause_span: self.where_clause_span,\n             span: self.span,\n-        }\n+        })\n     }\n }"}, {"sha": "d433775f85cf3eeae2670ae182b19c7b096bdf2a", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 64, "deletions": 45, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -259,7 +259,7 @@ enum ImplTraitContext<'b, 'a> {\n     /// equivalent to a fresh universal parameter like `fn foo<T: Debug>(x: T)`.\n     ///\n     /// Newly generated parameters should be inserted into the given `Vec`.\n-    Universal(&'b mut Vec<hir::GenericParam<'a>>, LocalDefId),\n+    Universal(&'b mut Vec<hir::GenericParam<'a>>, &'b mut Vec<hir::WherePredicate<'a>>, LocalDefId),\n \n     /// Treat `impl Trait` as shorthand for a new opaque type.\n     /// Example: `fn foo() -> impl Debug`, where `impl Debug` is conceptually\n@@ -303,7 +303,7 @@ impl<'a> ImplTraitContext<'_, 'a> {\n     fn reborrow<'this>(&'this mut self) -> ImplTraitContext<'this, 'a> {\n         use self::ImplTraitContext::*;\n         match self {\n-            Universal(params, parent) => Universal(params, *parent),\n+            Universal(params, bounds, parent) => Universal(params, bounds, *parent),\n             ReturnPositionOpaqueTy { origin } => ReturnPositionOpaqueTy { origin: *origin },\n             TypeAliasesOpaqueTy => TypeAliasesOpaqueTy,\n             Disallowed(pos) => Disallowed(*pos),\n@@ -704,10 +704,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         Some(hir::GenericParam {\n             hir_id,\n             name,\n-            bounds: &[],\n             span: self.lower_span(ident.span),\n             pure_wrt_drop: false,\n             kind: hir::GenericParamKind::Lifetime { kind },\n+            colon_span: None,\n         })\n     }\n \n@@ -718,14 +718,23 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         &mut self,\n         generics: &Generics,\n         parent_node_id: NodeId,\n-        f: impl FnOnce(&mut Self, &mut Vec<hir::GenericParam<'hir>>) -> T,\n-    ) -> (hir::Generics<'hir>, T) {\n+        f: impl FnOnce(\n+            &mut Self,\n+            &mut Vec<hir::GenericParam<'hir>>,\n+            &mut Vec<hir::WherePredicate<'hir>>,\n+        ) -> T,\n+    ) -> (&'hir hir::Generics<'hir>, T) {\n         let mut impl_trait_defs = Vec::new();\n+        let mut impl_trait_bounds = Vec::new();\n         let mut lowered_generics = self.lower_generics_mut(\n             generics,\n-            ImplTraitContext::Universal(&mut impl_trait_defs, self.current_hir_id_owner),\n+            ImplTraitContext::Universal(\n+                &mut impl_trait_defs,\n+                &mut impl_trait_bounds,\n+                self.current_hir_id_owner,\n+            ),\n         );\n-        let res = f(self, &mut impl_trait_defs);\n+        let res = f(self, &mut impl_trait_defs, &mut impl_trait_bounds);\n \n         let extra_lifetimes = self.resolver.take_extra_lifetime_params(parent_node_id);\n         lowered_generics.params.extend(\n@@ -736,6 +745,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 })\n                 .chain(impl_trait_defs),\n         );\n+        lowered_generics.predicates.extend(impl_trait_bounds);\n \n         let lowered_generics = lowered_generics.into_generics(self.arena);\n         (lowered_generics, res)\n@@ -999,7 +1009,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     // so desugar to\n                     //\n                     //     fn foo(x: dyn Iterator<Item = impl Debug>)\n-                    ImplTraitContext::Universal(_, parent) if self.is_in_dyn_type => {\n+                    ImplTraitContext::Universal(_, _, parent) if self.is_in_dyn_type => {\n                         parent_def_id = parent;\n                         (true, itctx)\n                     }\n@@ -1188,10 +1198,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             }\n             TyKind::BareFn(ref f) => self.with_lifetime_binder(t.id, |this| {\n                 hir::TyKind::BareFn(this.arena.alloc(hir::BareFnTy {\n-                    generic_params: this.lower_generic_params(\n-                        &f.generic_params,\n-                        ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n-                    ),\n+                    generic_params: this.lower_generic_params(&f.generic_params),\n                     unsafety: this.lower_unsafety(f.unsafety),\n                     abi: this.lower_extern(f.ext),\n                     decl: this.lower_fn_decl(&f.decl, None, FnDeclKind::Pointer, None),\n@@ -1274,24 +1281,40 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             |this| this.lower_param_bounds(bounds, nested_itctx),\n                         )\n                     }\n-                    ImplTraitContext::Universal(in_band_ty_params, parent_def_id) => {\n+                    ImplTraitContext::Universal(\n+                        in_band_ty_params,\n+                        in_band_ty_bounds,\n+                        parent_def_id,\n+                    ) => {\n                         // Add a definition for the in-band `Param`.\n                         let def_id = self.resolver.local_def_id(def_node_id);\n \n                         let hir_bounds = self.lower_param_bounds(\n                             bounds,\n-                            ImplTraitContext::Universal(in_band_ty_params, parent_def_id),\n+                            ImplTraitContext::Universal(\n+                                in_band_ty_params,\n+                                in_band_ty_bounds,\n+                                parent_def_id,\n+                            ),\n                         );\n                         // Set the name to `impl Bound1 + Bound2`.\n                         let ident = Ident::from_str_and_span(&pprust::ty_to_string(t), span);\n                         in_band_ty_params.push(hir::GenericParam {\n                             hir_id: self.lower_node_id(def_node_id),\n                             name: ParamName::Plain(self.lower_ident(ident)),\n                             pure_wrt_drop: false,\n-                            bounds: hir_bounds,\n                             span: self.lower_span(span),\n                             kind: hir::GenericParamKind::Type { default: None, synthetic: true },\n+                            colon_span: None,\n                         });\n+                        if let Some(preds) = self.lower_generic_bound_predicate(\n+                            ident,\n+                            def_node_id,\n+                            &GenericParamKind::Type { default: None },\n+                            hir_bounds,\n+                        ) {\n+                            in_band_ty_bounds.push(preds)\n+                        }\n \n                         hir::TyKind::Path(hir::QPath::Resolved(\n                             None,\n@@ -1374,20 +1397,22 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         name: p_name,\n                         span,\n                         pure_wrt_drop: false,\n-                        bounds: &[],\n                         kind: hir::GenericParamKind::Lifetime { kind },\n+                        colon_span: None,\n                     }\n                 },\n             ));\n \n             debug!(\"lower_opaque_impl_trait: lifetime_defs={:#?}\", lifetime_defs);\n \n             let opaque_ty_item = hir::OpaqueTy {\n-                generics: hir::Generics {\n+                generics: self.arena.alloc(hir::Generics {\n                     params: lifetime_defs,\n-                    where_clause: hir::WhereClause { predicates: &[], span: lctx.lower_span(span) },\n+                    predicates: &[],\n+                    has_where_clause: false,\n+                    where_clause_span: lctx.lower_span(span),\n                     span: lctx.lower_span(span),\n-                },\n+                }),\n                 bounds: hir_bounds,\n                 origin,\n             };\n@@ -1462,7 +1487,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lower_fn_decl(\n         &mut self,\n         decl: &FnDecl,\n-        mut in_band_ty_params: Option<(NodeId, &mut Vec<hir::GenericParam<'hir>>)>,\n+        mut in_band_ty_params: Option<(\n+            NodeId,\n+            &mut Vec<hir::GenericParam<'hir>>,\n+            &mut Vec<hir::WherePredicate<'hir>>,\n+        )>,\n         kind: FnDeclKind,\n         make_ret_async: Option<NodeId>,\n     ) -> &'hir hir::FnDecl<'hir> {\n@@ -1485,10 +1514,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             inputs = &inputs[..inputs.len() - 1];\n         }\n         let inputs = self.arena.alloc_from_iter(inputs.iter().map(|param| {\n-            if let Some((_, ibty)) = &mut in_band_ty_params {\n+            if let Some((_, ibty, ibpb)) = &mut in_band_ty_params {\n                 self.lower_ty_direct(\n                     &param.ty,\n-                    ImplTraitContext::Universal(ibty, self.current_hir_id_owner),\n+                    ImplTraitContext::Universal(ibty, ibpb, self.current_hir_id_owner),\n                 )\n             } else {\n                 self.lower_ty_direct(\n@@ -1517,7 +1546,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             match decl.output {\n                 FnRetTy::Ty(ref ty) => {\n                     let context = match in_band_ty_params {\n-                        Some((node_id, _)) if kind.impl_trait_return_allowed() => {\n+                        Some((node_id, _, _)) if kind.impl_trait_return_allowed() => {\n                             let fn_def_id = self.resolver.local_def_id(node_id);\n                             ImplTraitContext::ReturnPositionOpaqueTy {\n                                 origin: hir::OpaqueTyOrigin::FnReturn(fn_def_id),\n@@ -1708,18 +1737,20 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         name: p_name,\n                         span,\n                         pure_wrt_drop: false,\n-                        bounds: &[],\n                         kind: hir::GenericParamKind::Lifetime { kind },\n+                        colon_span: None,\n                     }\n                 }));\n             debug!(\"lower_async_fn_ret_ty: generic_params={:#?}\", generic_params);\n \n             let opaque_ty_item = hir::OpaqueTy {\n-                generics: hir::Generics {\n+                generics: this.arena.alloc(hir::Generics {\n                     params: generic_params,\n-                    where_clause: hir::WhereClause { predicates: &[], span: this.lower_span(span) },\n+                    predicates: &[],\n+                    has_where_clause: false,\n+                    where_clause_span: this.lower_span(span),\n                     span: this.lower_span(span),\n-                },\n+                }),\n                 bounds: arena_vec![this; future_bound],\n                 origin: hir::OpaqueTyOrigin::AsyncFn(fn_def_id),\n             };\n@@ -1923,26 +1954,15 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lower_generic_params_mut<'s>(\n         &'s mut self,\n         params: &'s [GenericParam],\n-        mut itctx: ImplTraitContext<'s, 'hir>,\n     ) -> impl Iterator<Item = hir::GenericParam<'hir>> + Captures<'a> + Captures<'s> {\n-        params.iter().map(move |param| self.lower_generic_param(param, itctx.reborrow()))\n+        params.iter().map(move |param| self.lower_generic_param(param))\n     }\n \n-    fn lower_generic_params(\n-        &mut self,\n-        params: &[GenericParam],\n-        itctx: ImplTraitContext<'_, 'hir>,\n-    ) -> &'hir [hir::GenericParam<'hir>] {\n-        self.arena.alloc_from_iter(self.lower_generic_params_mut(params, itctx))\n+    fn lower_generic_params(&mut self, params: &[GenericParam]) -> &'hir [hir::GenericParam<'hir>] {\n+        self.arena.alloc_from_iter(self.lower_generic_params_mut(params))\n     }\n \n-    fn lower_generic_param(\n-        &mut self,\n-        param: &GenericParam,\n-        mut itctx: ImplTraitContext<'_, 'hir>,\n-    ) -> hir::GenericParam<'hir> {\n-        let bounds: Vec<_> = self.lower_param_bounds_mut(&param.bounds, itctx.reborrow()).collect();\n-\n+    fn lower_generic_param(&mut self, param: &GenericParam) -> hir::GenericParam<'hir> {\n         let (name, kind) = match param.kind {\n             GenericParamKind::Lifetime => {\n                 let param_name = if param.ident.name == kw::StaticLifetime\n@@ -1989,8 +2009,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             name,\n             span: self.lower_span(param.span()),\n             pure_wrt_drop: self.sess.contains_name(&param.attrs, sym::may_dangle),\n-            bounds: self.arena.alloc_from_iter(bounds),\n             kind,\n+            colon_span: param.colon_span.map(|s| self.lower_span(s)),\n         }\n     }\n \n@@ -2012,8 +2032,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         p: &PolyTraitRef,\n         mut itctx: ImplTraitContext<'_, 'hir>,\n     ) -> hir::PolyTraitRef<'hir> {\n-        let bound_generic_params =\n-            self.lower_generic_params(&p.bound_generic_params, itctx.reborrow());\n+        let bound_generic_params = self.lower_generic_params(&p.bound_generic_params);\n \n         let trait_ref = self.with_lifetime_binder(p.trait_ref.ref_id, |this| {\n             this.lower_trait_ref(&p.trait_ref, itctx.reborrow())"}, {"sha": "391c46d18132feb7d1ff29fdee3d1e72fcb3d29b", "filename": "compiler/rustc_builtin_macros/src/derive.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -95,6 +95,7 @@ fn dummy_annotatable() -> Annotatable {\n         bounds: Default::default(),\n         is_placeholder: false,\n         kind: GenericParamKind::Lifetime,\n+        colon_span: None,\n     })\n }\n "}, {"sha": "301c67f70264502cd06244ad36dc287f045b8cea", "filename": "compiler/rustc_expand/src/build.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -113,6 +113,7 @@ impl<'a> ExtCtxt<'a> {\n             bounds,\n             kind: ast::GenericParamKind::Type { default },\n             is_placeholder: false,\n+            colon_span: None,\n         }\n     }\n "}, {"sha": "0d5d6ee07944f4a002e1fad66a6eda38f4146906", "filename": "compiler/rustc_expand/src/placeholders.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -149,6 +149,7 @@ pub fn placeholder(\n                 ident,\n                 is_placeholder: true,\n                 kind: ast::GenericParamKind::Lifetime,\n+                colon_span: None,\n             }\n         }]),\n         AstFragmentKind::Params => AstFragment::Params(smallvec![ast::Param {"}, {"sha": "5d1314ebb488d08bd39fc386d1d3d50921f06393", "filename": "compiler/rustc_hir/src/arena.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_hir%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_hir%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Farena.rs?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -15,11 +15,13 @@ macro_rules! arena_types {\n             [] block: rustc_hir::Block<'tcx>,\n             [] bare_fn_ty: rustc_hir::BareFnTy<'tcx>,\n             [] body: rustc_hir::Body<'tcx>,\n+            [] generics: rustc_hir::Generics<'tcx>,\n             [] generic_arg: rustc_hir::GenericArg<'tcx>,\n             [] generic_args: rustc_hir::GenericArgs<'tcx>,\n             [] generic_bound: rustc_hir::GenericBound<'tcx>,\n             [] generic_param: rustc_hir::GenericParam<'tcx>,\n             [] expr: rustc_hir::Expr<'tcx>,\n+            [] impl_: rustc_hir::Impl<'tcx>,\n             [] let_expr: rustc_hir::Let<'tcx>,\n             [] expr_field: rustc_hir::ExprField<'tcx>,\n             [] pat_field: rustc_hir::PatField<'tcx>,"}, {"sha": "dfeee3f356ffb3f8cb2a78fe8cf91a7573c0c801", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 181, "deletions": 92, "changes": 273, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -17,7 +17,7 @@ use rustc_error_messages::MultiSpan;\n use rustc_index::vec::IndexVec;\n use rustc_macros::HashStable_Generic;\n use rustc_span::hygiene::MacroKind;\n-use rustc_span::source_map::{SourceMap, Spanned};\n+use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{def_id::LocalDefId, BytePos, Span, DUMMY_SP};\n use rustc_target::asm::InlineAsmRegOrRegClass;\n@@ -496,61 +496,25 @@ pub enum GenericParamKind<'hir> {\n pub struct GenericParam<'hir> {\n     pub hir_id: HirId,\n     pub name: ParamName,\n-    pub bounds: GenericBounds<'hir>,\n     pub span: Span,\n     pub pure_wrt_drop: bool,\n     pub kind: GenericParamKind<'hir>,\n+    pub colon_span: Option<Span>,\n }\n \n impl<'hir> GenericParam<'hir> {\n-    pub fn bounds_span_for_suggestions(&self) -> Option<Span> {\n-        self.bounds\n-            .iter()\n-            .fold(None, |span: Option<Span>, bound| {\n-                // We include bounds that come from a `#[derive(_)]` but point at the user's code,\n-                // as we use this method to get a span appropriate for suggestions.\n-                if !bound.span().can_be_used_for_suggestions() {\n-                    None\n-                } else {\n-                    let span = span.map(|s| s.to(bound.span())).unwrap_or_else(|| bound.span());\n-                    Some(span)\n-                }\n-            })\n-            .map(|sp| sp.shrink_to_hi())\n+    /// Synthetic type-parameters are inserted after normal ones.\n+    /// In order for normal parameters to be able to refer to synthetic ones,\n+    /// scans them first.\n+    pub fn is_impl_trait(&self) -> bool {\n+        matches!(self.kind, GenericParamKind::Type { synthetic: true, .. })\n     }\n \n-    /// Returns the span of `:` after a generic parameter.\n+    /// This can happen for `async fn`, e.g. `async fn f<'_>(&'_ self)`.\n     ///\n-    /// For example:\n-    ///\n-    /// ```text\n-    /// fn a<T:>()\n-    ///       ^\n-    ///       |      here\n-    ///       here   |\n-    ///              v\n-    /// fn b<T       :>()\n-    ///\n-    /// fn c<T\n-    ///\n-    /// :>()\n-    /// ^\n-    /// |\n-    /// here\n-    /// ```\n-    pub fn colon_span_for_suggestions(&self, source_map: &SourceMap) -> Option<Span> {\n-        let sp = source_map\n-            .span_extend_while(self.span.shrink_to_hi(), |c| c.is_whitespace() || c == ':')\n-            .ok()?;\n-\n-        let snippet = source_map.span_to_snippet(sp).ok()?;\n-        let offset = snippet.find(':')?;\n-\n-        let colon_sp = sp\n-            .with_lo(BytePos(sp.lo().0 + offset as u32))\n-            .with_hi(BytePos(sp.lo().0 + (offset + ':'.len_utf8()) as u32));\n-\n-        Some(colon_sp)\n+    /// See `lifetime_to_generic_param` in `rustc_ast_lowering` for more information.\n+    pub fn is_elided_lifetime(&self) -> bool {\n+        matches!(self.kind, GenericParamKind::Lifetime { kind: LifetimeParamKind::Elided })\n     }\n }\n \n@@ -567,17 +531,22 @@ pub struct GenericParamCount {\n #[derive(Debug, HashStable_Generic)]\n pub struct Generics<'hir> {\n     pub params: &'hir [GenericParam<'hir>],\n-    pub where_clause: WhereClause<'hir>,\n+    pub predicates: &'hir [WherePredicate<'hir>],\n+    pub has_where_clause: bool,\n+    pub where_clause_span: Span,\n     pub span: Span,\n }\n \n impl<'hir> Generics<'hir> {\n-    pub const fn empty() -> Generics<'hir> {\n-        Generics {\n+    pub const fn empty() -> &'hir Generics<'hir> {\n+        const NOPE: Generics<'_> = Generics {\n             params: &[],\n-            where_clause: WhereClause { predicates: &[], span: DUMMY_SP },\n+            predicates: &[],\n+            has_where_clause: false,\n+            where_clause_span: DUMMY_SP,\n             span: DUMMY_SP,\n-        }\n+        };\n+        &NOPE\n     }\n \n     pub fn get_named(&self, name: Symbol) -> Option<&GenericParam<'_>> {\n@@ -596,32 +565,122 @@ impl<'hir> Generics<'hir> {\n             self.params.iter().map(|p| p.span).collect::<Vec<Span>>().into()\n         }\n     }\n-}\n \n-/// A where-clause in a definition.\n-#[derive(Debug, HashStable_Generic)]\n-pub struct WhereClause<'hir> {\n-    pub predicates: &'hir [WherePredicate<'hir>],\n-    // Only valid if predicates aren't empty.\n-    pub span: Span,\n-}\n+    /// If there are generic parameters, return where to introduce a new one.\n+    pub fn span_for_param_suggestion(&self) -> Option<Span> {\n+        if self.params.iter().any(|p| self.span.contains(p.span)) {\n+            // `fn foo<A>(t: impl Trait)`\n+            //          ^ suggest `, T: Trait` here\n+            let span = self.span.with_lo(self.span.hi() - BytePos(1)).shrink_to_lo();\n+            Some(span)\n+        } else {\n+            None\n+        }\n+    }\n \n-impl WhereClause<'_> {\n-    pub fn span(&self) -> Option<Span> {\n-        if self.predicates.is_empty() { None } else { Some(self.span) }\n+    pub fn where_clause_span(&self) -> Option<Span> {\n+        if self.predicates.is_empty() { None } else { Some(self.where_clause_span) }\n     }\n \n-    /// The `WhereClause` under normal circumstances points at either the predicates or the empty\n+    /// The `where_span` under normal circumstances points at either the predicates or the empty\n     /// space where the `where` clause should be. Only of use for diagnostic suggestions.\n     pub fn span_for_predicates_or_empty_place(&self) -> Span {\n-        self.span\n+        self.where_clause_span\n     }\n \n     /// `Span` where further predicates would be suggested, accounting for trailing commas, like\n     ///  in `fn foo<T>(t: T) where T: Foo,` so we don't suggest two trailing commas.\n-    pub fn tail_span_for_suggestion(&self) -> Span {\n+    pub fn tail_span_for_predicate_suggestion(&self) -> Span {\n         let end = self.span_for_predicates_or_empty_place().shrink_to_hi();\n-        self.predicates.last().map_or(end, |p| p.span()).shrink_to_hi().to(end)\n+        if self.has_where_clause {\n+            self.predicates\n+                .iter()\n+                .filter(|p| p.in_where_clause())\n+                .last()\n+                .map_or(end, |p| p.span())\n+                .shrink_to_hi()\n+                .to(end)\n+        } else {\n+            end\n+        }\n+    }\n+\n+    pub fn bounds_for_param(\n+        &self,\n+        param_def_id: LocalDefId,\n+    ) -> impl Iterator<Item = &WhereBoundPredicate<'_>> {\n+        self.predicates.iter().filter_map(move |pred| match pred {\n+            WherePredicate::BoundPredicate(bp) if bp.is_param_bound(param_def_id.to_def_id()) => {\n+                Some(bp)\n+            }\n+            _ => None,\n+        })\n+    }\n+\n+    pub fn bounds_span_for_suggestions(&self, param_def_id: LocalDefId) -> Option<Span> {\n+        self.bounds_for_param(param_def_id).flat_map(|bp| bp.bounds.iter().rev()).find_map(\n+            |bound| {\n+                // We include bounds that come from a `#[derive(_)]` but point at the user's code,\n+                // as we use this method to get a span appropriate for suggestions.\n+                let bs = bound.span();\n+                if bs.can_be_used_for_suggestions() { Some(bs.shrink_to_hi()) } else { None }\n+            },\n+        )\n+    }\n+\n+    pub fn span_for_predicate_removal(&self, pos: usize) -> Span {\n+        let predicate = &self.predicates[pos];\n+        let span = predicate.span();\n+\n+        if !predicate.in_where_clause() {\n+            // <T: ?Sized, U>\n+            //   ^^^^^^^^\n+            return span;\n+        }\n+\n+        // We need to find out which comma to remove.\n+        if pos < self.predicates.len() - 1 {\n+            let next_pred = &self.predicates[pos + 1];\n+            if next_pred.in_where_clause() {\n+                // where T: ?Sized, Foo: Bar,\n+                //       ^^^^^^^^^^^\n+                return span.until(next_pred.span());\n+            }\n+        }\n+\n+        if pos > 0 {\n+            let prev_pred = &self.predicates[pos - 1];\n+            if prev_pred.in_where_clause() {\n+                // where Foo: Bar, T: ?Sized,\n+                //               ^^^^^^^^^^^\n+                return prev_pred.span().shrink_to_hi().to(span);\n+            }\n+        }\n+\n+        // This is the only predicate in the where clause.\n+        // where T: ?Sized\n+        // ^^^^^^^^^^^^^^^\n+        self.where_clause_span\n+    }\n+\n+    pub fn span_for_bound_removal(&self, predicate_pos: usize, bound_pos: usize) -> Span {\n+        let predicate = &self.predicates[predicate_pos];\n+        let bounds = predicate.bounds();\n+\n+        if bounds.len() == 1 {\n+            return self.span_for_predicate_removal(predicate_pos);\n+        }\n+\n+        let span = bounds[bound_pos].span();\n+        if bound_pos == 0 {\n+            // where T: ?Sized + Bar, Foo: Bar,\n+            //          ^^^^^^^^^\n+            span.to(bounds[1].span().shrink_to_lo())\n+        } else {\n+            // where T: Bar + ?Sized, Foo: Bar,\n+            //             ^^^^^^^^^\n+            bounds[bound_pos - 1].span().shrink_to_hi().to(span)\n+        }\n     }\n }\n \n@@ -644,12 +703,29 @@ impl<'hir> WherePredicate<'hir> {\n             WherePredicate::EqPredicate(p) => p.span,\n         }\n     }\n+\n+    pub fn in_where_clause(&self) -> bool {\n+        match self {\n+            WherePredicate::BoundPredicate(p) => p.in_where_clause,\n+            WherePredicate::RegionPredicate(p) => p.in_where_clause,\n+            WherePredicate::EqPredicate(_) => false,\n+        }\n+    }\n+\n+    pub fn bounds(&self) -> GenericBounds<'hir> {\n+        match self {\n+            WherePredicate::BoundPredicate(p) => p.bounds,\n+            WherePredicate::RegionPredicate(p) => p.bounds,\n+            WherePredicate::EqPredicate(_) => &[],\n+        }\n+    }\n }\n \n /// A type bound (e.g., `for<'c> Foo: Send + Clone + 'c`).\n #[derive(Debug, HashStable_Generic)]\n pub struct WhereBoundPredicate<'hir> {\n     pub span: Span,\n+    pub in_where_clause: bool,\n     /// Any generics from a `for` binding.\n     pub bound_generic_params: &'hir [GenericParam<'hir>],\n     /// The type being bounded.\n@@ -661,21 +737,15 @@ pub struct WhereBoundPredicate<'hir> {\n impl<'hir> WhereBoundPredicate<'hir> {\n     /// Returns `true` if `param_def_id` matches the `bounded_ty` of this predicate.\n     pub fn is_param_bound(&self, param_def_id: DefId) -> bool {\n-        let TyKind::Path(QPath::Resolved(None, path)) = self.bounded_ty.kind else {\n-            return false;\n-        };\n-        match path.res {\n-            Res::Def(DefKind::TyParam, def_id)\n-            | Res::SelfTy { trait_: Some(def_id), alias_to: None } => def_id == param_def_id,\n-            _ => false,\n-        }\n+        self.bounded_ty.as_generic_param().map_or(false, |(def_id, _)| def_id == param_def_id)\n     }\n }\n \n /// A lifetime predicate (e.g., `'a: 'b + 'c`).\n #[derive(Debug, HashStable_Generic)]\n pub struct WhereRegionPredicate<'hir> {\n     pub span: Span,\n+    pub in_where_clause: bool,\n     pub lifetime: Lifetime,\n     pub bounds: GenericBounds<'hir>,\n }\n@@ -2075,7 +2145,7 @@ impl TraitItemId {\n pub struct TraitItem<'hir> {\n     pub ident: Ident,\n     pub def_id: LocalDefId,\n-    pub generics: Generics<'hir>,\n+    pub generics: &'hir Generics<'hir>,\n     pub kind: TraitItemKind<'hir>,\n     pub span: Span,\n }\n@@ -2135,7 +2205,7 @@ impl ImplItemId {\n pub struct ImplItem<'hir> {\n     pub ident: Ident,\n     pub def_id: LocalDefId,\n-    pub generics: Generics<'hir>,\n+    pub generics: &'hir Generics<'hir>,\n     pub kind: ImplItemKind<'hir>,\n     pub span: Span,\n     pub vis_span: Span,\n@@ -2241,6 +2311,23 @@ pub struct Ty<'hir> {\n     pub span: Span,\n }\n \n+impl<'hir> Ty<'hir> {\n+    /// Returns `true` if `param_def_id` matches the `bounded_ty` of this predicate.\n+    pub fn as_generic_param(&self) -> Option<(DefId, Ident)> {\n+        let TyKind::Path(QPath::Resolved(None, path)) = self.kind else {\n+            return None;\n+        };\n+        let [segment] = &path.segments else {\n+            return None;\n+        };\n+        match path.res {\n+            Res::Def(DefKind::TyParam, def_id)\n+            | Res::SelfTy { trait_: Some(def_id), alias_to: None } => Some((def_id, segment.ident)),\n+            _ => None,\n+        }\n+    }\n+}\n+\n /// Not represented directly in the AST; referred to by name through a `ty_path`.\n #[derive(Copy, Clone, PartialEq, Eq, Encodable, Decodable, Hash, Debug)]\n #[derive(HashStable_Generic)]\n@@ -2340,7 +2427,7 @@ pub struct BareFnTy<'hir> {\n \n #[derive(Debug, HashStable_Generic)]\n pub struct OpaqueTy<'hir> {\n-    pub generics: Generics<'hir>,\n+    pub generics: &'hir Generics<'hir>,\n     pub bounds: GenericBounds<'hir>,\n     pub origin: OpaqueTyOrigin,\n }\n@@ -2814,7 +2901,7 @@ pub enum ItemKind<'hir> {\n     /// A `const` item.\n     Const(&'hir Ty<'hir>, BodyId),\n     /// A function declaration.\n-    Fn(FnSig<'hir>, Generics<'hir>, BodyId),\n+    Fn(FnSig<'hir>, &'hir Generics<'hir>, BodyId),\n     /// A MBE macro definition (`macro_rules!` or `macro`).\n     Macro(ast::MacroDef, MacroKind),\n     /// A module.\n@@ -2824,22 +2911,22 @@ pub enum ItemKind<'hir> {\n     /// Module-level inline assembly (from `global_asm!`).\n     GlobalAsm(&'hir InlineAsm<'hir>),\n     /// A type alias, e.g., `type Foo = Bar<u8>`.\n-    TyAlias(&'hir Ty<'hir>, Generics<'hir>),\n+    TyAlias(&'hir Ty<'hir>, &'hir Generics<'hir>),\n     /// An opaque `impl Trait` type alias, e.g., `type Foo = impl Bar;`.\n     OpaqueTy(OpaqueTy<'hir>),\n     /// An enum definition, e.g., `enum Foo<A, B> {C<A>, D<B>}`.\n-    Enum(EnumDef<'hir>, Generics<'hir>),\n+    Enum(EnumDef<'hir>, &'hir Generics<'hir>),\n     /// A struct definition, e.g., `struct Foo<A> {x: A}`.\n-    Struct(VariantData<'hir>, Generics<'hir>),\n+    Struct(VariantData<'hir>, &'hir Generics<'hir>),\n     /// A union definition, e.g., `union Foo<A, B> {x: A, y: B}`.\n-    Union(VariantData<'hir>, Generics<'hir>),\n+    Union(VariantData<'hir>, &'hir Generics<'hir>),\n     /// A trait definition.\n-    Trait(IsAuto, Unsafety, Generics<'hir>, GenericBounds<'hir>, &'hir [TraitItemRef]),\n+    Trait(IsAuto, Unsafety, &'hir Generics<'hir>, GenericBounds<'hir>, &'hir [TraitItemRef]),\n     /// A trait alias.\n-    TraitAlias(Generics<'hir>, GenericBounds<'hir>),\n+    TraitAlias(&'hir Generics<'hir>, GenericBounds<'hir>),\n \n     /// An implementation, e.g., `impl<A> Trait for Foo { .. }`.\n-    Impl(Impl<'hir>),\n+    Impl(&'hir Impl<'hir>),\n }\n \n #[derive(Debug, HashStable_Generic)]\n@@ -2851,7 +2938,7 @@ pub struct Impl<'hir> {\n     // decoding as `Span`s cannot be decoded when a `Session` is not available.\n     pub defaultness_span: Option<Span>,\n     pub constness: Constness,\n-    pub generics: Generics<'hir>,\n+    pub generics: &'hir Generics<'hir>,\n \n     /// The trait being implemented, if any.\n     pub of_trait: Option<TraitRef<'hir>>,\n@@ -2993,7 +3080,7 @@ impl ForeignItem<'_> {\n #[derive(Debug, HashStable_Generic)]\n pub enum ForeignItemKind<'hir> {\n     /// A foreign function.\n-    Fn(&'hir FnDecl<'hir>, &'hir [Ident], Generics<'hir>),\n+    Fn(&'hir FnDecl<'hir>, &'hir [Ident], &'hir Generics<'hir>),\n     /// A foreign static item (`static ext: u8`).\n     Static(&'hir Ty<'hir>, Mutability),\n     /// A foreign type.\n@@ -3326,9 +3413,11 @@ mod size_asserts {\n     rustc_data_structures::static_assert_size!(super::QPath<'static>, 24);\n     rustc_data_structures::static_assert_size!(super::Ty<'static>, 72);\n     rustc_data_structures::static_assert_size!(super::GenericBound<'_>, 48);\n+    rustc_data_structures::static_assert_size!(super::Generics<'static>, 56);\n+    rustc_data_structures::static_assert_size!(super::Impl<'static>, 80);\n \n-    rustc_data_structures::static_assert_size!(super::Item<'static>, 160);\n-    rustc_data_structures::static_assert_size!(super::TraitItem<'static>, 128);\n-    rustc_data_structures::static_assert_size!(super::ImplItem<'static>, 120);\n-    rustc_data_structures::static_assert_size!(super::ForeignItem<'static>, 112);\n+    rustc_data_structures::static_assert_size!(super::Item<'static>, 80);\n+    rustc_data_structures::static_assert_size!(super::TraitItem<'static>, 88);\n+    rustc_data_structures::static_assert_size!(super::ImplItem<'static>, 80);\n+    rustc_data_structures::static_assert_size!(super::ForeignItem<'static>, 72);\n }"}, {"sha": "d41b85fd20f7b24085ea7bd6add6000dc497bea5", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -619,7 +619,7 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item<'v>) {\n             visitor.visit_generics(generics);\n             walk_list!(visitor, visit_trait_ref, of_trait);\n             visitor.visit_ty(self_ty);\n-            walk_list!(visitor, visit_impl_item_ref, items);\n+            walk_list!(visitor, visit_impl_item_ref, *items);\n         }\n         ItemKind::Struct(ref struct_definition, ref generics)\n         | ItemKind::Union(ref struct_definition, ref generics) => {\n@@ -899,7 +899,6 @@ pub fn walk_generic_param<'v, V: Visitor<'v>>(visitor: &mut V, param: &'v Generi\n             }\n         }\n     }\n-    walk_list!(visitor, visit_param_bound, param.bounds);\n }\n \n pub fn walk_const_param_default<'v, V: Visitor<'v>>(visitor: &mut V, ct: &'v AnonConst) {\n@@ -908,7 +907,7 @@ pub fn walk_const_param_default<'v, V: Visitor<'v>>(visitor: &mut V, ct: &'v Ano\n \n pub fn walk_generics<'v, V: Visitor<'v>>(visitor: &mut V, generics: &'v Generics<'v>) {\n     walk_list!(visitor, visit_generic_param, generics.params);\n-    walk_list!(visitor, visit_where_predicate, generics.where_clause.predicates);\n+    walk_list!(visitor, visit_where_predicate, generics.predicates);\n }\n \n pub fn walk_where_predicate<'v, V: Visitor<'v>>("}, {"sha": "7af9622b2cf76753b142dd3d1fcfeceaabb5a4da", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 18, "deletions": 35, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -445,7 +445,7 @@ impl<'a> State<'a> {\n         if let Some(bounds) = bounds {\n             self.print_bounds(\":\", bounds);\n         }\n-        self.print_where_clause(&generics.where_clause);\n+        self.print_where_clause(generics);\n         if let Some(ty) = ty {\n             self.space();\n             self.word_space(\"=\");\n@@ -465,7 +465,7 @@ impl<'a> State<'a> {\n         self.print_generic_params(&generics.params);\n         self.end(); // end the inner ibox\n \n-        self.print_where_clause(&generics.where_clause);\n+        self.print_where_clause(generics);\n         self.space();\n         inner(self);\n         self.word(\";\");\n@@ -626,16 +626,16 @@ impl<'a> State<'a> {\n                 items,\n             }) => {\n                 self.head(\"\");\n-                self.print_defaultness(defaultness);\n-                self.print_unsafety(unsafety);\n+                self.print_defaultness(*defaultness);\n+                self.print_unsafety(*unsafety);\n                 self.word_nbsp(\"impl\");\n \n                 if !generics.params.is_empty() {\n                     self.print_generic_params(&generics.params);\n                     self.space();\n                 }\n \n-                if constness == hir::Constness::Const {\n+                if *constness == hir::Constness::Const {\n                     self.word_nbsp(\"const\");\n                 }\n \n@@ -650,12 +650,12 @@ impl<'a> State<'a> {\n                 }\n \n                 self.print_type(&self_ty);\n-                self.print_where_clause(&generics.where_clause);\n+                self.print_where_clause(generics);\n \n                 self.space();\n                 self.bopen();\n                 self.print_inner_attributes(attrs);\n-                for impl_item in items {\n+                for impl_item in *items {\n                     self.ann.nested(self, Nested::ImplItem(impl_item.id));\n                 }\n                 self.bclose(item.span);\n@@ -678,7 +678,7 @@ impl<'a> State<'a> {\n                     }\n                 }\n                 self.print_bounds(\":\", real_bounds);\n-                self.print_where_clause(&generics.where_clause);\n+                self.print_where_clause(generics);\n                 self.word(\" \");\n                 self.bopen();\n                 for trait_item in trait_items {\n@@ -703,7 +703,7 @@ impl<'a> State<'a> {\n                 }\n                 self.nbsp();\n                 self.print_bounds(\"=\", real_bounds);\n-                self.print_where_clause(&generics.where_clause);\n+                self.print_where_clause(generics);\n                 self.word(\";\");\n                 self.end(); // end inner head-block\n                 self.end(); // end outer head-block\n@@ -739,7 +739,7 @@ impl<'a> State<'a> {\n         self.head(\"enum\");\n         self.print_name(name);\n         self.print_generic_params(&generics.params);\n-        self.print_where_clause(&generics.where_clause);\n+        self.print_where_clause(generics);\n         self.space();\n         self.print_variants(&enum_definition.variants, span)\n     }\n@@ -787,15 +787,15 @@ impl<'a> State<'a> {\n                     });\n                     self.pclose();\n                 }\n-                self.print_where_clause(&generics.where_clause);\n+                self.print_where_clause(generics);\n                 if print_finalizer {\n                     self.word(\";\");\n                 }\n                 self.end();\n                 self.end() // close the outer-box\n             }\n             hir::VariantData::Struct(..) => {\n-                self.print_where_clause(&generics.where_clause);\n+                self.print_where_clause(generics);\n                 self.nbsp();\n                 self.bopen();\n                 self.hardbreak_if_not_bol();\n@@ -1995,7 +1995,7 @@ impl<'a> State<'a> {\n         self.pclose();\n \n         self.print_fn_output(decl);\n-        self.print_where_clause(&generics.where_clause)\n+        self.print_where_clause(generics)\n     }\n \n     fn print_closure_params(&mut self, decl: &hir::FnDecl<'_>, body_id: hir::BodyId) {\n@@ -2096,21 +2096,8 @@ impl<'a> State<'a> {\n         self.print_ident(param.name.ident());\n \n         match param.kind {\n-            GenericParamKind::Lifetime { .. } => {\n-                let mut sep = \":\";\n-                for bound in param.bounds {\n-                    match bound {\n-                        GenericBound::Outlives(ref lt) => {\n-                            self.word(sep);\n-                            self.print_lifetime(lt);\n-                            sep = \"+\";\n-                        }\n-                        _ => panic!(),\n-                    }\n-                }\n-            }\n+            GenericParamKind::Lifetime { .. } => {}\n             GenericParamKind::Type { ref default, .. } => {\n-                self.print_bounds(\":\", param.bounds);\n                 if let Some(default) = default {\n                     self.space();\n                     self.word_space(\"=\");\n@@ -2133,15 +2120,15 @@ impl<'a> State<'a> {\n         self.print_ident(lifetime.name.ident())\n     }\n \n-    pub fn print_where_clause(&mut self, where_clause: &hir::WhereClause<'_>) {\n-        if where_clause.predicates.is_empty() {\n+    pub fn print_where_clause(&mut self, generics: &hir::Generics<'_>) {\n+        if generics.predicates.is_empty() {\n             return;\n         }\n \n         self.space();\n         self.word_space(\"where\");\n \n-        for (i, predicate) in where_clause.predicates.iter().enumerate() {\n+        for (i, predicate) in generics.predicates.iter().enumerate() {\n             if i != 0 {\n                 self.word_space(\",\");\n             }\n@@ -2236,11 +2223,7 @@ impl<'a> State<'a> {\n     ) {\n         self.ibox(INDENT_UNIT);\n         self.print_formal_generic_params(generic_params);\n-        let generics = hir::Generics {\n-            params: &[],\n-            where_clause: hir::WhereClause { predicates: &[], span: rustc_span::DUMMY_SP },\n-            span: rustc_span::DUMMY_SP,\n-        };\n+        let generics = hir::Generics::empty();\n         self.print_fn(\n             decl,\n             hir::FnHeader {"}, {"sha": "2e50dbff51089a9df7a52808e293bc115f198c27", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 25, "deletions": 46, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -2327,6 +2327,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             _ => span,\n         };\n \n+        // type_param_span is (span, has_bounds)\n         let type_param_span = match (generics, bound_kind) {\n             (Some((_, ref generics, _)), GenericKind::Param(ref param)) => {\n                 // Account for the case where `param` corresponds to `Self`,\n@@ -2337,25 +2338,18 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         // Get the `hir::Param` to verify whether it already has any bounds.\n                         // We do this to avoid suggesting code that ends up as `T: 'a'b`,\n                         // instead we suggest `T: 'a + 'b` in that case.\n-                        let id = hir.local_def_id_to_hir_id(def_id);\n-                        let mut has_bounds = false;\n-                        if let Node::GenericParam(param) = hir.get(id) {\n-                            has_bounds = !param.bounds.is_empty();\n-                        }\n-                        let sp = self.tcx.def_span(def_id);\n+                        let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n+                        let ast_generics = self.tcx.hir().get_generics(hir_id.owner);\n+                        let bounds =\n+                            ast_generics.and_then(|g| g.bounds_span_for_suggestions(def_id));\n                         // `sp` only covers `T`, change it so that it covers\n                         // `T:` when appropriate\n-                        let is_impl_trait = bound_kind.to_string().starts_with(\"impl \");\n-                        let sp = if has_bounds && !is_impl_trait {\n-                            sp.to(self\n-                                .tcx\n-                                .sess\n-                                .source_map()\n-                                .next_point(self.tcx.sess.source_map().next_point(sp)))\n+                        if let Some(span) = bounds {\n+                            (span, true)\n                         } else {\n-                            sp\n-                        };\n-                        (sp, has_bounds, is_impl_trait)\n+                            let sp = self.tcx.def_span(def_id);\n+                            (sp.shrink_to_hi(), false)\n+                        }\n                     })\n                 } else {\n                     None\n@@ -2411,52 +2405,37 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n         fn binding_suggestion<'tcx, S: fmt::Display>(\n             err: &mut Diagnostic,\n-            type_param_span: Option<(Span, bool, bool)>,\n+            type_param_span: Option<(Span, bool)>,\n             bound_kind: GenericKind<'tcx>,\n             sub: S,\n         ) {\n             let msg = \"consider adding an explicit lifetime bound\";\n-            if let Some((sp, has_lifetimes, is_impl_trait)) = type_param_span {\n-                let suggestion = if is_impl_trait {\n-                    format!(\"{} + {}\", bound_kind, sub)\n-                } else {\n-                    let tail = if has_lifetimes { \" + \" } else { \"\" };\n-                    format!(\"{}: {}{}\", bound_kind, sub, tail)\n-                };\n-                err.span_suggestion(\n+            if let Some((sp, has_lifetimes)) = type_param_span {\n+                let suggestion =\n+                    if has_lifetimes { format!(\" + {}\", sub) } else { format!(\": {}\", sub) };\n+                err.span_suggestion_verbose(\n                     sp,\n                     &format!(\"{}...\", msg),\n                     suggestion,\n                     Applicability::MaybeIncorrect, // Issue #41966\n                 );\n             } else {\n-                let consider = format!(\n-                    \"{} {}...\",\n-                    msg,\n-                    if type_param_span.map_or(false, |(_, _, is_impl_trait)| is_impl_trait) {\n-                        format!(\" `{}` to `{}`\", sub, bound_kind)\n-                    } else {\n-                        format!(\"`{}: {}`\", bound_kind, sub)\n-                    },\n-                );\n+                let consider = format!(\"{} `{}: {}`...\", msg, bound_kind, sub,);\n                 err.help(&consider);\n             }\n         }\n \n         let new_binding_suggestion =\n-            |err: &mut Diagnostic,\n-             type_param_span: Option<(Span, bool, bool)>,\n-             bound_kind: GenericKind<'tcx>| {\n+            |err: &mut Diagnostic, type_param_span: Option<(Span, bool)>| {\n                 let msg = \"consider introducing an explicit lifetime bound\";\n-                if let Some((sp, has_lifetimes, is_impl_trait)) = type_param_span {\n-                    let suggestion = if is_impl_trait {\n-                        (sp.shrink_to_hi(), format!(\" + {}\", new_lt))\n+                if let Some((sp, has_lifetimes)) = type_param_span {\n+                    let suggestion = if has_lifetimes {\n+                        format!(\" + {}\", new_lt)\n                     } else {\n-                        let tail = if has_lifetimes { \" +\" } else { \"\" };\n-                        (sp, format!(\"{}: {}{}\", bound_kind, new_lt, tail))\n+                        format!(\": {}\", new_lt)\n                     };\n                     let mut sugg =\n-                        vec![suggestion, (span.shrink_to_hi(), format!(\" + {}\", new_lt))];\n+                        vec![(sp, suggestion), (span.shrink_to_hi(), format!(\" + {}\", new_lt))];\n                     if let Some(lt) = add_lt_sugg {\n                         sugg.push(lt);\n                         sugg.rotate_right(1);\n@@ -2543,11 +2522,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 let pred = format!(\"{}: {}\", bound_kind, sub);\n                 let suggestion = format!(\n                     \"{} {}\",\n-                    if !generics.where_clause.predicates.is_empty() { \",\" } else { \" where\" },\n+                    if !generics.predicates.is_empty() { \",\" } else { \" where\" },\n                     pred,\n                 );\n                 err.span_suggestion(\n-                    generics.where_clause.tail_span_for_suggestion(),\n+                    generics.tail_span_for_predicate_suggestion(),\n                     \"consider adding a where clause\",\n                     suggestion,\n                     Applicability::MaybeIncorrect,\n@@ -2615,7 +2594,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         // suggest:\n                         // fn get_later<'a, G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ + 'a\n                         ty::Closure(_, _substs) | ty::Opaque(_, _substs) if return_impl_trait => {\n-                            new_binding_suggestion(&mut err, type_param_span, bound_kind);\n+                            new_binding_suggestion(&mut err, type_param_span);\n                         }\n                         _ => {\n                             binding_suggestion(&mut err, type_param_span, bound_kind, new_lt);"}, {"sha": "cbdcf01352271cca90e40244e62c61553fb3befd", "filename": "compiler/rustc_infer/src/infer/error_reporting/note.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -372,8 +372,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         .hir()\n                         .get_generics(impl_item_def_id)\n                         .unwrap()\n-                        .where_clause\n-                        .tail_span_for_suggestion();\n+                        .where_clause_span\n+                        .shrink_to_hi();\n \n                     let suggestion = format!(\n                         \"{} {}\","}, {"sha": "3564f15e210ad74efa7a99aa7dcf71fcbca60719", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 67, "deletions": 113, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -1199,8 +1199,8 @@ impl<'tcx> LateLintPass<'tcx> for InvalidNoMangleItems {\n                     });\n                 }\n             }\n-            hir::ItemKind::Impl(hir::Impl { ref generics, items, .. }) => {\n-                for it in items {\n+            hir::ItemKind::Impl(hir::Impl { generics, items, .. }) => {\n+                for it in *items {\n                     if let hir::AssocItemKind::Fn { .. } = it.kind {\n                         if let Some(no_mangle_attr) = cx\n                             .sess()\n@@ -1517,59 +1517,61 @@ impl<'tcx> LateLintPass<'tcx> for TypeAliasBounds {\n             // Bounds are respected for `type X = impl Trait`\n             return;\n         }\n-        let mut suggested_changing_assoc_types = false;\n         // There must not be a where clause\n-        if !type_alias_generics.where_clause.predicates.is_empty() {\n-            cx.lint(\n-                TYPE_ALIAS_BOUNDS,\n-                |lint| {\n-                    let mut err = lint.build(\"where clauses are not enforced in type aliases\");\n-                    let spans: Vec<_> = type_alias_generics\n-                        .where_clause\n-                        .predicates\n-                        .iter()\n-                        .map(|pred| pred.span())\n-                        .collect();\n-                    err.set_span(spans);\n-                    err.span_suggestion(\n-                        type_alias_generics.where_clause.span_for_predicates_or_empty_place(),\n-                        \"the clause will not be checked when the type alias is used, and should be removed\",\n-                        String::new(),\n-                        Applicability::MachineApplicable,\n-                    );\n-                    if !suggested_changing_assoc_types {\n-                        TypeAliasBounds::suggest_changing_assoc_types(ty, &mut err);\n-                        suggested_changing_assoc_types = true;\n-                    }\n-                    err.emit();\n-                },\n-            );\n+        if type_alias_generics.predicates.is_empty() {\n+            return;\n         }\n-        // The parameters must not have bounds\n-        for param in type_alias_generics.params.iter() {\n-            let spans: Vec<_> = param.bounds.iter().map(|b| b.span()).collect();\n-            let suggestion = spans\n-                .iter()\n-                .map(|sp| {\n-                    let start = param.span.between(*sp); // Include the `:` in `T: Bound`.\n-                    (start.to(*sp), String::new())\n-                })\n-                .collect();\n-            if !spans.is_empty() {\n-                cx.struct_span_lint(TYPE_ALIAS_BOUNDS, spans, |lint| {\n-                    let mut err =\n-                        lint.build(\"bounds on generic parameters are not enforced in type aliases\");\n-                    let msg = \"the bound will not be checked when the type alias is used, \\\n-                                   and should be removed\";\n-                    err.multipart_suggestion(msg, suggestion, Applicability::MachineApplicable);\n-                    if !suggested_changing_assoc_types {\n-                        TypeAliasBounds::suggest_changing_assoc_types(ty, &mut err);\n-                        suggested_changing_assoc_types = true;\n-                    }\n-                    err.emit();\n-                });\n+\n+        let mut where_spans = Vec::new();\n+        let mut inline_spans = Vec::new();\n+        let mut inline_sugg = Vec::new();\n+        for p in type_alias_generics.predicates {\n+            let span = p.span();\n+            if p.in_where_clause() {\n+                where_spans.push(span);\n+            } else {\n+                for b in p.bounds() {\n+                    inline_spans.push(b.span());\n+                }\n+                inline_sugg.push((span, String::new()));\n             }\n         }\n+\n+        let mut suggested_changing_assoc_types = false;\n+        if !where_spans.is_empty() {\n+            cx.lint(TYPE_ALIAS_BOUNDS, |lint| {\n+                let mut err = lint.build(\"where clauses are not enforced in type aliases\");\n+                err.set_span(where_spans);\n+                err.span_suggestion(\n+                    type_alias_generics.where_clause_span,\n+                    \"the clause will not be checked when the type alias is used, and should be removed\",\n+                    String::new(),\n+                    Applicability::MachineApplicable,\n+                );\n+                if !suggested_changing_assoc_types {\n+                    TypeAliasBounds::suggest_changing_assoc_types(ty, &mut err);\n+                    suggested_changing_assoc_types = true;\n+                }\n+                err.emit();\n+            });\n+        }\n+\n+        if !inline_spans.is_empty() {\n+            cx.lint(TYPE_ALIAS_BOUNDS, |lint| {\n+                let mut err =\n+                    lint.build(\"bounds on generic parameters are not enforced in type aliases\");\n+                err.set_span(inline_spans);\n+                err.multipart_suggestion(\n+                    \"the bound will not be checked when the type alias is used, and should be removed\",\n+                    inline_sugg,\n+                    Applicability::MachineApplicable,\n+                );\n+                if !suggested_changing_assoc_types {\n+                    TypeAliasBounds::suggest_changing_assoc_types(ty, &mut err);\n+                }\n+                err.emit();\n+            });\n+        }\n     }\n }\n \n@@ -2085,27 +2087,6 @@ impl ExplicitOutlivesRequirements {\n             .collect()\n     }\n \n-    fn collect_outlived_lifetimes<'tcx>(\n-        &self,\n-        param: &'tcx hir::GenericParam<'tcx>,\n-        tcx: TyCtxt<'tcx>,\n-        inferred_outlives: &'tcx [(ty::Predicate<'tcx>, Span)],\n-        ty_generics: &'tcx ty::Generics,\n-    ) -> Vec<ty::Region<'tcx>> {\n-        let index =\n-            ty_generics.param_def_id_to_index[&tcx.hir().local_def_id(param.hir_id).to_def_id()];\n-\n-        match param.kind {\n-            hir::GenericParamKind::Lifetime { .. } => {\n-                Self::lifetimes_outliving_lifetime(inferred_outlives, index)\n-            }\n-            hir::GenericParamKind::Type { .. } => {\n-                Self::lifetimes_outliving_type(inferred_outlives, index)\n-            }\n-            hir::GenericParamKind::Const { .. } => Vec::new(),\n-        }\n-    }\n-\n     fn collect_outlives_bound_spans<'tcx>(\n         &self,\n         tcx: TyCtxt<'tcx>,\n@@ -2213,41 +2194,11 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n \n             let mut bound_count = 0;\n             let mut lint_spans = Vec::new();\n-\n-            for param in hir_generics.params {\n-                let has_lifetime_bounds = param\n-                    .bounds\n-                    .iter()\n-                    .any(|bound| matches!(bound, hir::GenericBound::Outlives(_)));\n-                if !has_lifetime_bounds {\n-                    continue;\n-                }\n-\n-                let relevant_lifetimes =\n-                    self.collect_outlived_lifetimes(param, cx.tcx, inferred_outlives, ty_generics);\n-                if relevant_lifetimes.is_empty() {\n-                    continue;\n-                }\n-\n-                let bound_spans = self.collect_outlives_bound_spans(\n-                    cx.tcx,\n-                    &param.bounds,\n-                    &relevant_lifetimes,\n-                    infer_static,\n-                );\n-                bound_count += bound_spans.len();\n-                lint_spans.extend(self.consolidate_outlives_bound_spans(\n-                    param.span.shrink_to_hi(),\n-                    &param.bounds,\n-                    bound_spans,\n-                ));\n-            }\n-\n             let mut where_lint_spans = Vec::new();\n             let mut dropped_predicate_count = 0;\n-            let num_predicates = hir_generics.where_clause.predicates.len();\n-            for (i, where_predicate) in hir_generics.where_clause.predicates.iter().enumerate() {\n-                let (relevant_lifetimes, bounds, span) = match where_predicate {\n+            let num_predicates = hir_generics.predicates.len();\n+            for (i, where_predicate) in hir_generics.predicates.iter().enumerate() {\n+                let (relevant_lifetimes, bounds, span, in_where_clause) = match where_predicate {\n                     hir::WherePredicate::RegionPredicate(predicate) => {\n                         if let Some(Region::EarlyBound(index, ..)) =\n                             cx.tcx.named_region(predicate.lifetime.hir_id)\n@@ -2256,6 +2207,7 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n                                 Self::lifetimes_outliving_lifetime(inferred_outlives, index),\n                                 &predicate.bounds,\n                                 predicate.span,\n+                                predicate.in_where_clause,\n                             )\n                         } else {\n                             continue;\n@@ -2274,6 +2226,7 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n                                     Self::lifetimes_outliving_type(inferred_outlives, index),\n                                     &predicate.bounds,\n                                     predicate.span,\n+                                    predicate.in_where_clause,\n                                 )\n                             }\n                             _ => {\n@@ -2300,10 +2253,12 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n                     dropped_predicate_count += 1;\n                 }\n \n-                // If all the bounds on a predicate were inferable and there are\n-                // further predicates, we want to eat the trailing comma.\n-                if drop_predicate && i + 1 < num_predicates {\n-                    let next_predicate_span = hir_generics.where_clause.predicates[i + 1].span();\n+                if drop_predicate && !in_where_clause {\n+                    lint_spans.push(span);\n+                } else if drop_predicate && i + 1 < num_predicates {\n+                    // If all the bounds on a predicate were inferable and there are\n+                    // further predicates, we want to eat the trailing comma.\n+                    let next_predicate_span = hir_generics.predicates[i + 1].span();\n                     where_lint_spans.push(span.to(next_predicate_span.shrink_to_lo()));\n                 } else {\n                     where_lint_spans.extend(self.consolidate_outlives_bound_spans(\n@@ -2316,10 +2271,9 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n \n             // If all predicates are inferable, drop the entire clause\n             // (including the `where`)\n-            if num_predicates > 0 && dropped_predicate_count == num_predicates {\n+            if hir_generics.has_where_clause && dropped_predicate_count == num_predicates {\n                 let where_span = hir_generics\n-                    .where_clause\n-                    .span()\n+                    .where_clause_span()\n                     .expect(\"span of (nonempty) where clause should exist\");\n                 // Extend the where clause back to the closing `>` of the\n                 // generics, except for tuple struct, which have the `where`\n@@ -2346,7 +2300,7 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n                             },\n                             lint_spans\n                                 .into_iter()\n-                                .map(|span| (span, \"\".to_owned()))\n+                                .map(|span| (span, String::new()))\n                                 .collect::<Vec<_>>(),\n                             Applicability::MachineApplicable,\n                         )"}, {"sha": "b46ea955a3a82541fd44e6795c6ca88bc67d6dc3", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -1462,8 +1462,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 }))\n             }\n             hir::ItemKind::Impl(hir::Impl { defaultness, constness, .. }) => {\n-                self.tables.impl_defaultness.set(def_id.index, defaultness);\n-                self.tables.impl_constness.set(def_id.index, constness);\n+                self.tables.impl_defaultness.set(def_id.index, *defaultness);\n+                self.tables.impl_constness.set(def_id.index, *constness);\n \n                 let trait_ref = self.tcx.impl_trait_ref(def_id);\n                 if let Some(trait_ref) = trait_ref {"}, {"sha": "f53dc0000ca3e8c28dcf33cbd0721758ca9a2140", "filename": "compiler/rustc_middle/src/ty/diagnostics.rs", "status": "modified", "additions": 110, "deletions": 250, "changes": 360, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -11,7 +11,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::{Applicability, Diagnostic, DiagnosticArgValue, IntoDiagnosticArg};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n-use rustc_hir::{QPath, TyKind, WhereBoundPredicate, WherePredicate};\n+use rustc_hir::WherePredicate;\n use rustc_span::Span;\n \n impl<'tcx> IntoDiagnosticArg for Ty<'tcx> {\n@@ -156,13 +156,13 @@ pub fn suggest_arbitrary_trait_bound(\n         _ => {}\n     }\n     // Suggest a where clause bound for a non-type parameter.\n-    let (action, prefix) = if generics.where_clause.predicates.is_empty() {\n-        (\"introducing a\", \" where \")\n-    } else {\n+    let (action, prefix) = if generics.has_where_clause {\n         (\"extending the\", \", \")\n+    } else {\n+        (\"introducing a\", \" where \")\n     };\n     err.span_suggestion_verbose(\n-        generics.where_clause.tail_span_for_suggestion(),\n+        generics.tail_span_for_predicate_suggestion(),\n         &format!(\n             \"consider {} `where` bound, but there might be an alternative better way to express \\\n              this requirement\",\n@@ -183,104 +183,37 @@ enum SuggestChangingConstraintsMessage<'a> {\n }\n \n fn suggest_removing_unsized_bound(\n+    tcx: TyCtxt<'_>,\n     generics: &hir::Generics<'_>,\n     suggestions: &mut Vec<(Span, String, SuggestChangingConstraintsMessage<'_>)>,\n-    param_name: &str,\n     param: &hir::GenericParam<'_>,\n     def_id: Option<DefId>,\n ) {\n     // See if there's a `?Sized` bound that can be removed to suggest that.\n     // First look at the `where` clause because we can have `where T: ?Sized`,\n     // then look at params.\n-    for (where_pos, predicate) in generics.where_clause.predicates.iter().enumerate() {\n-        match predicate {\n-            WherePredicate::BoundPredicate(WhereBoundPredicate {\n-                bounded_ty:\n-                    hir::Ty {\n-                        kind:\n-                            hir::TyKind::Path(hir::QPath::Resolved(\n-                                None,\n-                                hir::Path {\n-                                    segments: [segment],\n-                                    res: hir::def::Res::Def(hir::def::DefKind::TyParam, _),\n-                                    ..\n-                                },\n-                            )),\n-                        ..\n-                    },\n-                bounds,\n-                span,\n-                ..\n-            }) if segment.ident.as_str() == param_name => {\n-                for (pos, bound) in bounds.iter().enumerate() {\n-                    match bound {\n-                        hir::GenericBound::Trait(poly, hir::TraitBoundModifier::Maybe)\n-                            if poly.trait_ref.trait_def_id() == def_id => {}\n-                        _ => continue,\n-                    }\n-                    let sp = match (\n-                        bounds.len(),\n-                        pos,\n-                        generics.where_clause.predicates.len(),\n-                        where_pos,\n-                    ) {\n-                        // where T: ?Sized\n-                        // ^^^^^^^^^^^^^^^\n-                        (1, _, 1, _) => generics.where_clause.span,\n-                        // where Foo: Bar, T: ?Sized,\n-                        //               ^^^^^^^^^^^\n-                        (1, _, len, pos) if pos == len - 1 => generics.where_clause.predicates\n-                            [pos - 1]\n-                            .span()\n-                            .shrink_to_hi()\n-                            .to(*span),\n-                        // where T: ?Sized, Foo: Bar,\n-                        //       ^^^^^^^^^^^\n-                        (1, _, _, pos) => {\n-                            span.until(generics.where_clause.predicates[pos + 1].span())\n-                        }\n-                        // where T: ?Sized + Bar, Foo: Bar,\n-                        //          ^^^^^^^^^\n-                        (_, 0, _, _) => bound.span().to(bounds[1].span().shrink_to_lo()),\n-                        // where T: Bar + ?Sized, Foo: Bar,\n-                        //             ^^^^^^^^^\n-                        (_, pos, _, _) => bounds[pos - 1].span().shrink_to_hi().to(bound.span()),\n-                    };\n+    let param_def_id = tcx.hir().local_def_id(param.hir_id);\n+    for (where_pos, predicate) in generics.predicates.iter().enumerate() {\n+        let WherePredicate::BoundPredicate(predicate) = predicate else {\n+            continue;\n+        };\n+        if !predicate.is_param_bound(param_def_id.to_def_id()) {\n+            continue;\n+        };\n \n-                    suggestions.push((\n-                        sp,\n-                        String::new(),\n-                        SuggestChangingConstraintsMessage::RemovingQSized,\n-                    ));\n-                }\n+        for (pos, bound) in predicate.bounds.iter().enumerate() {\n+            let    hir::GenericBound::Trait(poly, hir::TraitBoundModifier::Maybe) = bound else {\n+                continue;\n+            };\n+            if poly.trait_ref.trait_def_id() != def_id {\n+                continue;\n             }\n-            _ => {}\n-        }\n-    }\n-    for (pos, bound) in param.bounds.iter().enumerate() {\n-        match bound {\n-            hir::GenericBound::Trait(poly, hir::TraitBoundModifier::Maybe)\n-                if poly.trait_ref.trait_def_id() == def_id =>\n-            {\n-                let sp = match (param.bounds.len(), pos) {\n-                    // T: ?Sized,\n-                    //  ^^^^^^^^\n-                    (1, _) => param.span.shrink_to_hi().to(bound.span()),\n-                    // T: ?Sized + Bar,\n-                    //    ^^^^^^^^^\n-                    (_, 0) => bound.span().to(param.bounds[1].span().shrink_to_lo()),\n-                    // T: Bar + ?Sized,\n-                    //       ^^^^^^^^^\n-                    (_, pos) => param.bounds[pos - 1].span().shrink_to_hi().to(bound.span()),\n-                };\n-\n-                suggestions.push((\n-                    sp,\n-                    String::new(),\n-                    SuggestChangingConstraintsMessage::RemovingQSized,\n-                ));\n-            }\n-            _ => {}\n+            let sp = generics.span_for_bound_removal(where_pos, pos);\n+            suggestions.push((\n+                sp,\n+                String::new(),\n+                SuggestChangingConstraintsMessage::RemovingQSized,\n+            ));\n         }\n     }\n }\n@@ -331,13 +264,7 @@ pub fn suggest_constraining_type_params<'a>(\n                     param.span,\n                     &format!(\"this type parameter needs to be `{}`\", constraint),\n                 );\n-                suggest_removing_unsized_bound(\n-                    generics,\n-                    &mut suggestions,\n-                    param_name,\n-                    param,\n-                    def_id,\n-                );\n+                suggest_removing_unsized_bound(tcx, generics, &mut suggestions, param, def_id);\n             }\n         }\n \n@@ -358,76 +285,45 @@ pub fn suggest_constraining_type_params<'a>(\n             ))\n         };\n \n-        if param_name.starts_with(\"impl \") {\n-            // If there's an `impl Trait` used in argument position, suggest\n-            // restricting it:\n-            //\n-            //   fn foo(t: impl Foo) { ... }\n-            //             --------\n-            //             |\n-            //             help: consider further restricting this bound with `+ Bar`\n-            //\n-            // Suggestion for tools in this case is:\n-            //\n-            //   fn foo(t: impl Foo) { ... }\n-            //             --------\n-            //             |\n-            //             replace with: `impl Foo + Bar`\n-\n-            // `impl Trait` must have at least one trait in the list\n-            let bound_list_non_empty = true;\n-\n-            suggest_restrict(param.span.shrink_to_hi(), bound_list_non_empty);\n+        // When the type parameter has been provided bounds\n+        //\n+        //    Message:\n+        //      fn foo<T>(t: T) where T: Foo { ... }\n+        //                            ^^^^^^\n+        //                            |\n+        //                            help: consider further restricting this bound with `+ Bar`\n+        //\n+        //    Suggestion:\n+        //      fn foo<T>(t: T) where T: Foo { ... }\n+        //                                  ^\n+        //                                  |\n+        //                                  replace with: ` + Bar`\n+        //\n+        // Or, if user has provided some bounds, suggest restricting them:\n+        //\n+        //   fn foo<T: Foo>(t: T) { ... }\n+        //             ---\n+        //             |\n+        //             help: consider further restricting this bound with `+ Bar`\n+        //\n+        // Suggestion for tools in this case is:\n+        //\n+        //   fn foo<T: Foo>(t: T) { ... }\n+        //          --\n+        //          |\n+        //          replace with: `T: Bar +`\n+        let param_def_id = tcx.hir().local_def_id(param.hir_id);\n+        if let Some(span) = generics.bounds_span_for_suggestions(param_def_id) {\n+            suggest_restrict(span, true);\n             continue;\n         }\n \n-        if generics.where_clause.predicates.is_empty()\n-        // Given `trait Base<T = String>: Super<T>` where `T: Copy`, suggest restricting in the\n-        // `where` clause instead of `trait Base<T: Copy = String>: Super<T>`.\n-        && !matches!(param.kind, hir::GenericParamKind::Type { default: Some(_), .. })\n-        {\n-            if let Some(span) = param.bounds_span_for_suggestions() {\n-                // If user has provided some bounds, suggest restricting them:\n-                //\n-                //   fn foo<T: Foo>(t: T) { ... }\n-                //             ---\n-                //             |\n-                //             help: consider further restricting this bound with `+ Bar`\n-                //\n-                // Suggestion for tools in this case is:\n-                //\n-                //   fn foo<T: Foo>(t: T) { ... }\n-                //          --\n-                //          |\n-                //          replace with: `T: Bar +`\n-\n-                // `bounds_span_for_suggestions` returns `None` if the list is empty\n-                let bound_list_non_empty = true;\n-\n-                suggest_restrict(span, bound_list_non_empty);\n-            } else {\n-                let (colon, span) = match param.colon_span_for_suggestions(tcx.sess.source_map()) {\n-                    // If there is already a colon after generic, do not suggest adding it again\n-                    Some(sp) => (\"\", sp.shrink_to_hi()),\n-                    None => (\":\", param.span.shrink_to_hi()),\n-                };\n-\n-                // If user hasn't provided any bounds, suggest adding a new one:\n-                //\n-                //   fn foo<T>(t: T) { ... }\n-                //          - help: consider restricting this type parameter with `T: Foo`\n-                suggestions.push((\n-                    span,\n-                    format!(\"{colon} {constraint}\"),\n-                    SuggestChangingConstraintsMessage::RestrictType { ty: param_name },\n-                ));\n-            }\n-        } else {\n+        if generics.has_where_clause {\n             // This part is a bit tricky, because using the `where` clause user can\n             // provide zero, one or many bounds for the same type parameter, so we\n             // have following cases to consider:\n             //\n-            // 1) When the type parameter has been provided zero bounds\n+            // When the type parameter has been provided zero bounds\n             //\n             //    Message:\n             //      fn foo<X, Y>(x: X, y: Y) where Y: Foo { ... }\n@@ -436,95 +332,59 @@ pub fn suggest_constraining_type_params<'a>(\n             //    Suggestion:\n             //      fn foo<X, Y>(x: X, y: Y) where Y: Foo { ... }\n             //                                           - insert: `, X: Bar`\n-            //\n-            //\n-            // 2) When the type parameter has been provided one bound\n-            //\n-            //    Message:\n-            //      fn foo<T>(t: T) where T: Foo { ... }\n-            //                            ^^^^^^\n-            //                            |\n-            //                            help: consider further restricting this bound with `+ Bar`\n-            //\n-            //    Suggestion:\n-            //      fn foo<T>(t: T) where T: Foo { ... }\n-            //                            ^^\n-            //                            |\n-            //                            replace with: `T: Bar +`\n-            //\n-            //\n-            // 3) When the type parameter has been provided many bounds\n-            //\n-            //    Message:\n-            //      fn foo<T>(t: T) where T: Foo, T: Bar {... }\n-            //             - help: consider further restricting this type parameter with `where T: Zar`\n-            //\n-            //    Suggestion:\n-            //      fn foo<T>(t: T) where T: Foo, T: Bar {... }\n-            //                                          - insert: `, T: Zar`\n-            //\n-            // Additionally, there may be no `where` clause whatsoever in the case that this was\n-            // reached because the generic parameter has a default:\n-            //\n-            //    Message:\n-            //      trait Foo<T=()> {... }\n-            //             - help: consider further restricting this type parameter with `where T: Zar`\n-            //\n-            //    Suggestion:\n-            //      trait Foo<T=()> where T: Zar {... }\n-            //                     - insert: `where T: Zar`\n-\n-            if matches!(param.kind, hir::GenericParamKind::Type { default: Some(_), .. })\n-                && generics.where_clause.predicates.len() == 0\n-            {\n-                // Suggest a bound, but there is no existing `where` clause *and* the type param has a\n-                // default (`<T=Foo>`), so we suggest adding `where T: Bar`.\n-                suggestions.push((\n-                    generics.where_clause.tail_span_for_suggestion(),\n-                    format!(\" where {}: {}\", param_name, constraint),\n-                    SuggestChangingConstraintsMessage::RestrictTypeFurther { ty: param_name },\n-                ));\n-            } else {\n-                let mut param_spans = Vec::new();\n-                let mut non_empty = false;\n-\n-                for predicate in generics.where_clause.predicates {\n-                    if let WherePredicate::BoundPredicate(WhereBoundPredicate {\n-                        span,\n-                        bounded_ty,\n-                        bounds,\n-                        ..\n-                    }) = predicate\n-                    {\n-                        if let TyKind::Path(QPath::Resolved(_, path)) = &bounded_ty.kind {\n-                            if let Some(segment) = path.segments.first() {\n-                                if segment.ident.to_string() == param_name {\n-                                    non_empty = !bounds.is_empty();\n-\n-                                    param_spans.push(span);\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n+            suggestions.push((\n+                generics.tail_span_for_predicate_suggestion(),\n+                constraints\n+                    .iter()\n+                    .map(|&(constraint, _)| format!(\", {}: {}\", param_name, constraint))\n+                    .collect::<String>(),\n+                SuggestChangingConstraintsMessage::RestrictTypeFurther { ty: param_name },\n+            ));\n+            continue;\n+        }\n \n-                match param_spans[..] {\n-                    [&param_span] => suggest_restrict(param_span.shrink_to_hi(), non_empty),\n-                    _ => {\n-                        suggestions.push((\n-                            generics.where_clause.tail_span_for_suggestion(),\n-                            constraints\n-                                .iter()\n-                                .map(|&(constraint, _)| format!(\", {}: {}\", param_name, constraint))\n-                                .collect::<String>(),\n-                            SuggestChangingConstraintsMessage::RestrictTypeFurther {\n-                                ty: param_name,\n-                            },\n-                        ));\n-                    }\n-                }\n-            }\n+        // Additionally, there may be no `where` clause but the generic parameter has a default:\n+        //\n+        //    Message:\n+        //      trait Foo<T=()> {... }\n+        //                - help: consider further restricting this type parameter with `where T: Zar`\n+        //\n+        //    Suggestion:\n+        //      trait Foo<T=()> {... }\n+        //                     - insert: `where T: Zar`\n+        if matches!(param.kind, hir::GenericParamKind::Type { default: Some(_), .. }) {\n+            // Suggest a bound, but there is no existing `where` clause *and* the type param has a\n+            // default (`<T=Foo>`), so we suggest adding `where T: Bar`.\n+            suggestions.push((\n+                generics.tail_span_for_predicate_suggestion(),\n+                format!(\" where {}: {}\", param_name, constraint),\n+                SuggestChangingConstraintsMessage::RestrictTypeFurther { ty: param_name },\n+            ));\n+            continue;\n         }\n+\n+        // If user has provided a colon, don't suggest adding another:\n+        //\n+        //   fn foo<T:>(t: T) { ... }\n+        //            - insert: consider restricting this type parameter with `T: Foo`\n+        if let Some(colon_span) = param.colon_span {\n+            suggestions.push((\n+                colon_span.shrink_to_hi(),\n+                format!(\" {}\", constraint),\n+                SuggestChangingConstraintsMessage::RestrictType { ty: param_name },\n+            ));\n+            continue;\n+        }\n+\n+        // If user hasn't provided any bounds, suggest adding a new one:\n+        //\n+        //   fn foo<T>(t: T) { ... }\n+        //          - help: consider restricting this type parameter with `T: Foo`\n+        suggestions.push((\n+            param.span.shrink_to_hi(),\n+            format!(\": {}\", constraint),\n+            SuggestChangingConstraintsMessage::RestrictType { ty: param_name },\n+        ));\n     }\n \n     if suggestions.len() == 1 {"}, {"sha": "da0934b67c5df70d0c87e5245fad7957c0c586c2", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 15, "deletions": 44, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -602,53 +602,24 @@ impl<T> Trait<T> for X {\n                 } else {\n                     return false;\n                 };\n+                let Some(def_id) = def_id.as_local() else {\n+                    return false;\n+                };\n \n                 // First look in the `where` clause, as this might be\n                 // `fn foo<T>(x: T) where T: Trait`.\n-                for predicate in hir_generics.where_clause.predicates {\n-                    if let hir::WherePredicate::BoundPredicate(pred) = predicate {\n-                        if let hir::TyKind::Path(hir::QPath::Resolved(None, path)) =\n-                            pred.bounded_ty.kind\n-                        {\n-                            if path.res.opt_def_id() == Some(def_id) {\n-                                // This predicate is binding type param `A` in `<A as T>::Foo` to\n-                                // something, potentially `T`.\n-                            } else {\n-                                continue;\n-                            }\n-                        } else {\n-                            continue;\n-                        }\n-\n-                        if self.constrain_generic_bound_associated_type_structured_suggestion(\n-                            diag,\n-                            &trait_ref,\n-                            pred.bounds,\n-                            &assoc,\n-                            assoc_substs,\n-                            ty,\n-                            msg,\n-                            false,\n-                        ) {\n-                            return true;\n-                        }\n-                    }\n-                }\n-                for param in hir_generics.params {\n-                    if self.hir().opt_local_def_id(param.hir_id).map(|id| id.to_def_id())\n-                        == Some(def_id)\n-                    {\n-                        // This is type param `A` in `<A as T>::Foo`.\n-                        return self.constrain_generic_bound_associated_type_structured_suggestion(\n-                            diag,\n-                            &trait_ref,\n-                            param.bounds,\n-                            &assoc,\n-                            assoc_substs,\n-                            ty,\n-                            msg,\n-                            false,\n-                        );\n+                for pred in hir_generics.bounds_for_param(def_id) {\n+                    if self.constrain_generic_bound_associated_type_structured_suggestion(\n+                        diag,\n+                        &trait_ref,\n+                        pred.bounds,\n+                        &assoc,\n+                        assoc_substs,\n+                        ty,\n+                        msg,\n+                        false,\n+                    ) {\n+                        return true;\n                     }\n                 }\n             }"}, {"sha": "8081bac7cfd920a46155b7909557900e7ea0c630", "filename": "compiler/rustc_parse/src/parser/generics.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fgenerics.rs?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -30,8 +30,10 @@ impl<'a> Parser<'a> {\n         let ident = self.parse_ident()?;\n \n         // Parse optional colon and param bounds.\n+        let mut colon_span = None;\n         let bounds = if self.eat(&token::Colon) {\n-            self.parse_generic_bounds(Some(self.prev_token.span))?\n+            colon_span = Some(self.prev_token.span);\n+            self.parse_generic_bounds(colon_span)?\n         } else {\n             Vec::new()\n         };\n@@ -45,6 +47,7 @@ impl<'a> Parser<'a> {\n             bounds,\n             kind: GenericParamKind::Type { default },\n             is_placeholder: false,\n+            colon_span,\n         })\n     }\n \n@@ -69,6 +72,7 @@ impl<'a> Parser<'a> {\n             bounds: Vec::new(),\n             kind: GenericParamKind::Const { ty, kw_span: const_span, default },\n             is_placeholder: false,\n+            colon_span: None,\n         })\n     }\n \n@@ -97,10 +101,10 @@ impl<'a> Parser<'a> {\n                     let param = if this.check_lifetime() {\n                         let lifetime = this.expect_lifetime();\n                         // Parse lifetime parameter.\n-                        let bounds = if this.eat(&token::Colon) {\n-                            this.parse_lt_param_bounds()\n+                        let (colon_span, bounds) = if this.eat(&token::Colon) {\n+                            (Some(this.prev_token.span), this.parse_lt_param_bounds())\n                         } else {\n-                            Vec::new()\n+                            (None, Vec::new())\n                         };\n                         Some(ast::GenericParam {\n                             ident: lifetime.ident,\n@@ -109,6 +113,7 @@ impl<'a> Parser<'a> {\n                             bounds,\n                             kind: ast::GenericParamKind::Lifetime,\n                             is_placeholder: false,\n+                            colon_span,\n                         })\n                     } else if this.check_keyword(kw::Const) {\n                         // Parse const parameter."}, {"sha": "3cd183902855491a0163d4338651a2d0ff047107", "filename": "compiler/rustc_passes/src/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdead.rs?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -512,7 +512,7 @@ impl<'v, 'tcx> ItemLikeVisitor<'v> for LifeSeeder<'tcx> {\n                 if of_trait.is_some() {\n                     self.worklist.push(item.def_id);\n                 }\n-                for impl_item_ref in items {\n+                for impl_item_ref in *items {\n                     let impl_item = self.tcx.hir().impl_item(impl_item_ref.id);\n                     if of_trait.is_some()\n                         || has_allow_dead_code_or_lang_attr(self.tcx, impl_item.hir_id())"}, {"sha": "10dc587be6e48a9304ba5e18c746e7864b820b63", "filename": "compiler/rustc_passes/src/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fstability.rs?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -737,7 +737,7 @@ impl<'tcx> Visitor<'tcx> for Checker<'tcx> {\n                     }\n                 }\n \n-                for impl_item_ref in items {\n+                for impl_item_ref in *items {\n                     let impl_item = self.tcx.associated_item(impl_item_ref.id.def_id);\n \n                     if let Some(def_id) = impl_item.trait_item_def_id {"}, {"sha": "619e0d0341f07c0ca65cf99ce898712cc1f3b1fa", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -1585,12 +1585,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     }\n \n     fn visit_generics(&mut self, generics: &'tcx hir::Generics<'tcx>) {\n-        for param in generics.params {\n-            for bound in param.bounds {\n-                self.check_generic_bound(bound);\n-            }\n-        }\n-        for predicate in generics.where_clause.predicates {\n+        for predicate in generics.predicates {\n             match predicate {\n                 hir::WherePredicate::BoundPredicate(bound_pred) => {\n                     for bound in bound_pred.bounds.iter() {"}, {"sha": "a5243bf8ac3f8ee86f4703e73713487cc9bc063f", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -86,7 +86,7 @@ impl ForLifetimeSpanType {\n     }\n }\n \n-impl<'tcx> Into<MissingLifetimeSpot<'tcx>> for &'tcx hir::Generics<'tcx> {\n+impl<'tcx> Into<MissingLifetimeSpot<'tcx>> for &&'tcx hir::Generics<'tcx> {\n     fn into(self) -> MissingLifetimeSpot<'tcx> {\n         MissingLifetimeSpot::Generics(self)\n     }"}, {"sha": "787536d2a38ed04ecf40649f7dbcb809f1ef0bc6", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 28, "deletions": 62, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -1328,21 +1328,19 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 match param.kind {\n                     GenericParamKind::Lifetime { .. } => {}\n                     GenericParamKind::Type { ref default, .. } => {\n-                        walk_list!(this, visit_param_bound, param.bounds);\n                         if let Some(ref ty) = default {\n                             this.visit_ty(&ty);\n                         }\n                     }\n                     GenericParamKind::Const { ref ty, default } => {\n-                        walk_list!(this, visit_param_bound, param.bounds);\n                         this.visit_ty(&ty);\n                         if let Some(default) = default {\n                             this.visit_body(this.tcx.hir().body(default.body));\n                         }\n                     }\n                 }\n             }\n-            for predicate in generics.where_clause.predicates {\n+            for predicate in generics.predicates {\n                 match predicate {\n                     &hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate {\n                         ref bounded_ty,\n@@ -1393,6 +1391,32 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     }) => {\n                         this.visit_lifetime(lifetime);\n                         walk_list!(this, visit_param_bound, bounds);\n+\n+                        if lifetime.name != hir::LifetimeName::Static {\n+                            for bound in bounds {\n+                                let hir::GenericBound::Outlives(ref lt) = bound else {\n+                                    continue;\n+                                };\n+                                if lt.name != hir::LifetimeName::Static {\n+                                    continue;\n+                                }\n+                                this.insert_lifetime(lt, Region::Static);\n+                                this.tcx\n+                                    .sess\n+                                    .struct_span_warn(\n+                                        lifetime.span,\n+                                        &format!(\n+                                            \"unnecessary lifetime parameter `{}`\",\n+                                            lifetime.name.ident(),\n+                                        ),\n+                                    )\n+                                    .help(&format!(\n+                                        \"you can use the `'static` lifetime directly, in place of `{}`\",\n+                                        lifetime.name.ident(),\n+                                    ))\n+                                    .emit();\n+                            }\n+                        }\n                     }\n                     &hir::WherePredicate::EqPredicate(hir::WhereEqPredicate {\n                         ref lhs_ty,\n@@ -1714,10 +1738,8 @@ fn object_lifetime_defaults_for_item<'tcx>(\n         GenericParamKind::Type { .. } => {\n             let mut set = Set1::Empty;\n \n-            add_bounds(&mut set, &param.bounds);\n-\n             let param_def_id = tcx.hir().local_def_id(param.hir_id);\n-            for predicate in generics.where_clause.predicates {\n+            for predicate in generics.predicates {\n                 // Look for `type: ...` where clauses.\n                 let hir::WherePredicate::BoundPredicate(ref data) = *predicate else { continue };\n \n@@ -3124,50 +3146,6 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n             // It is a soft error to shadow a lifetime within a parent scope.\n             self.check_lifetime_param_for_shadowing(old_scope, &lifetime_i);\n-\n-            for bound in lifetime_i.bounds {\n-                match bound {\n-                    hir::GenericBound::Outlives(ref lt) => match lt.name {\n-                        hir::LifetimeName::Underscore => {\n-                            self.tcx.sess.delay_span_bug(\n-                                lt.span,\n-                                \"use of `'_` in illegal place, but not caught by lowering\",\n-                            );\n-                        }\n-                        hir::LifetimeName::Static => {\n-                            self.insert_lifetime(lt, Region::Static);\n-                            self.tcx\n-                                .sess\n-                                .struct_span_warn(\n-                                    lifetime_i.span.to(lt.span),\n-                                    &format!(\n-                                        \"unnecessary lifetime parameter `{}`\",\n-                                        lifetime_i.name.ident(),\n-                                    ),\n-                                )\n-                                .help(&format!(\n-                                    \"you can use the `'static` lifetime directly, in place of `{}`\",\n-                                    lifetime_i.name.ident(),\n-                                ))\n-                                .emit();\n-                        }\n-                        hir::LifetimeName::Param(_) | hir::LifetimeName::Implicit => {\n-                            self.resolve_lifetime_ref(lt);\n-                        }\n-                        hir::LifetimeName::ImplicitObjectLifetimeDefault => {\n-                            self.tcx.sess.delay_span_bug(\n-                                lt.span,\n-                                \"lowering generated `ImplicitObjectLifetimeDefault` \\\n-                                 outside of an object type\",\n-                            );\n-                        }\n-                        hir::LifetimeName::Error => {\n-                            // No need to do anything, error already reported.\n-                        }\n-                    },\n-                    _ => bug!(),\n-                }\n-            }\n         }\n     }\n \n@@ -3326,18 +3304,6 @@ fn insert_late_bound_lifetimes(\n     // ignore binders here and scrape up all names we see.\n     let mut appears_in_where_clause = AllCollector::default();\n     appears_in_where_clause.visit_generics(generics);\n-\n-    for param in generics.params {\n-        if let hir::GenericParamKind::Lifetime { .. } = param.kind {\n-            if !param.bounds.is_empty() {\n-                // `'a: 'b` means both `'a` and `'b` are referenced\n-                appears_in_where_clause\n-                    .regions\n-                    .insert(hir::LifetimeName::Param(param.name.normalize_to_macros_2_0()));\n-            }\n-        }\n-    }\n-\n     debug!(?appears_in_where_clause.regions);\n \n     // Late bound regions are those that:"}, {"sha": "b4230a144f813384d5bbf018f2951f94379167ac", "filename": "compiler/rustc_save_analysis/src/dump_visitor.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -1267,21 +1267,19 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n             match param.kind {\n                 hir::GenericParamKind::Lifetime { .. } => {}\n                 hir::GenericParamKind::Type { ref default, .. } => {\n-                    self.process_bounds(param.bounds);\n                     if let Some(ref ty) = default {\n                         self.visit_ty(ty);\n                     }\n                 }\n                 hir::GenericParamKind::Const { ref ty, ref default } => {\n-                    self.process_bounds(param.bounds);\n                     self.visit_ty(ty);\n                     if let Some(default) = default {\n                         self.visit_anon_const(default);\n                     }\n                 }\n             }\n         }\n-        for pred in generics.where_clause.predicates {\n+        for pred in generics.predicates {\n             if let hir::WherePredicate::BoundPredicate(ref wbp) = *pred {\n                 self.process_bounds(wbp.bounds);\n                 self.visit_ty(wbp.bounded_ty);"}, {"sha": "d1286c9b8b0dfeb083a4e2585f57aa3d4d8eb1a5", "filename": "compiler/rustc_save_analysis/src/sig.rs", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_save_analysis%2Fsrc%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_save_analysis%2Fsrc%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Fsig.rs?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -630,31 +630,6 @@ impl<'hir> Sig for hir::Generics<'hir> {\n                     param_text.push_str(&id_to_string(&scx.tcx.hir(), default.hir_id));\n                 }\n             }\n-            if !param.bounds.is_empty() {\n-                param_text.push_str(\": \");\n-                match param.kind {\n-                    hir::GenericParamKind::Lifetime { .. } => {\n-                        let bounds = param\n-                            .bounds\n-                            .iter()\n-                            .map(|bound| match bound {\n-                                hir::GenericBound::Outlives(lt) => lt.name.ident().to_string(),\n-                                _ => panic!(),\n-                            })\n-                            .collect::<Vec<_>>()\n-                            .join(\" + \");\n-                        param_text.push_str(&bounds);\n-                        // FIXME add lifetime bounds refs.\n-                    }\n-                    hir::GenericParamKind::Type { .. } => {\n-                        param_text.push_str(&bounds_to_string(param.bounds));\n-                        // FIXME descend properly into bounds.\n-                    }\n-                    hir::GenericParamKind::Const { .. } => {\n-                        // Const generics cannot contain bounds.\n-                    }\n-                }\n-            }\n             text.push_str(&param_text);\n             text.push(',');\n         }"}, {"sha": "7a3579eb1cc853193bbda3e3ecdb74c3c5d65cf6", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 12, "deletions": 21, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -2419,26 +2419,15 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n         };\n         let sized_trait = self.tcx.lang_items().sized_trait();\n         debug!(\"maybe_suggest_unsized_generics: generics.params={:?}\", generics.params);\n-        debug!(\"maybe_suggest_unsized_generics: generics.where_clause={:?}\", generics.where_clause);\n-        let param = generics.params.iter().filter(|param| param.span == span).find(|param| {\n-            // Check that none of the explicit trait bounds is `Sized`. Assume that an explicit\n-            // `Sized` bound is there intentionally and we don't need to suggest relaxing it.\n-            param\n-                .bounds\n-                .iter()\n-                .all(|bound| bound.trait_ref().and_then(|tr| tr.trait_def_id()) != sized_trait)\n-        });\n-        let Some(param) = param else {\n+        debug!(\"maybe_suggest_unsized_generics: generics.predicates={:?}\", generics.predicates);\n+        let Some(param) = generics.params.iter().find(|param| param.span == span) else {\n             return;\n         };\n-        let param_def_id = self.tcx.hir().local_def_id(param.hir_id).to_def_id();\n-        let preds = generics.where_clause.predicates.iter();\n-        let explicitly_sized = preds\n-            .filter_map(|pred| match pred {\n-                hir::WherePredicate::BoundPredicate(bp) => Some(bp),\n-                _ => None,\n-            })\n-            .filter(|bp| bp.is_param_bound(param_def_id))\n+        let param_def_id = self.tcx.hir().local_def_id(param.hir_id);\n+        // Check that none of the explicit trait bounds is `Sized`. Assume that an explicit\n+        // `Sized` bound is there intentionally and we don't need to suggest relaxing it.\n+        let explicitly_sized = generics\n+            .bounds_for_param(param_def_id)\n             .flat_map(|bp| bp.bounds)\n             .any(|bound| bound.trait_ref().and_then(|tr| tr.trait_def_id()) == sized_trait);\n         if explicitly_sized {\n@@ -2461,9 +2450,11 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n             _ => {}\n         };\n         // Didn't add an indirection suggestion, so add a general suggestion to relax `Sized`.\n-        let (span, separator) = match param.bounds {\n-            [] => (span.shrink_to_hi(), \":\"),\n-            [.., bound] => (bound.span().shrink_to_hi(), \" +\"),\n+        let (span, separator) = if let Some(s) = generics.bounds_span_for_suggestions(param_def_id)\n+        {\n+            (s, \" +\")\n+        } else {\n+            (span.shrink_to_hi(), \":\")\n         };\n         err.span_suggestion_verbose(\n             span,"}, {"sha": "446b14a17ae92ff268e276cbb5238a98d99e4323", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 7, "deletions": 22, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -319,12 +319,8 @@ pub trait InferCtxtExt<'tcx> {\n \n fn predicate_constraint(generics: &hir::Generics<'_>, pred: String) -> (Span, String) {\n     (\n-        generics.where_clause.tail_span_for_suggestion(),\n-        format!(\n-            \"{} {}\",\n-            if !generics.where_clause.predicates.is_empty() { \",\" } else { \" where\" },\n-            pred,\n-        ),\n+        generics.tail_span_for_predicate_suggestion(),\n+        format!(\"{} {}\", if generics.has_where_clause { \",\" } else { \" where\" }, pred,),\n     )\n }\n \n@@ -346,7 +342,7 @@ fn suggest_restriction<'tcx>(\n     //              -  ^^^^^^^^^ GenericBounds\n     //              |\n     //              &Ident\n-    let span = generics.where_clause.span_for_predicates_or_empty_place();\n+    let span = generics.span_for_predicates_or_empty_place();\n     if span.from_expansion() || span.desugaring_kind().is_some() {\n         return;\n     }\n@@ -396,21 +392,10 @@ fn suggest_restriction<'tcx>(\n         let pred = trait_pred.to_predicate(tcx).to_string();\n         let pred = pred.replace(&impl_trait_str, &type_param_name);\n         let mut sugg = vec![\n-            // Find the last of the generic parameters contained within the span of\n-            // the generics\n-            match generics\n-                .params\n-                .iter()\n-                .map(|p| p.bounds_span_for_suggestions().unwrap_or(p.span.shrink_to_hi()))\n-                .filter(|&span| generics.span.contains(span) && span.can_be_used_for_suggestions())\n-                .max_by_key(|span| span.hi())\n-            {\n-                // `fn foo(t: impl Trait)`\n-                //        ^ suggest `<T: Trait>` here\n-                None => (generics.span, format!(\"<{}>\", type_param)),\n-                // `fn foo<A>(t: impl Trait)`\n-                //        ^^^ suggest `<A, T: Trait>` here\n-                Some(span) => (span, format!(\", {}\", type_param)),\n+            if let Some(span) = generics.span_for_param_suggestion() {\n+                (span, format!(\", {}\", type_param))\n+            } else {\n+                (generics.span, format!(\"<{}>\", type_param))\n             },\n             // `fn foo(t: impl Trait)`\n             //                       ^ suggest `where <T as Trait>::A: Bound`"}, {"sha": "b39310d12942d752979f2d78b3ff464ff8e146df", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -221,7 +221,6 @@ fn get_sized_bounds(tcx: TyCtxt<'_>, trait_def_id: DefId) -> SmallVec<[Span; 1]>\n                 ..\n             }) => Some(\n                 generics\n-                    .where_clause\n                     .predicates\n                     .iter()\n                     .filter_map(|pred| {\n@@ -399,8 +398,8 @@ fn virtual_call_violation_for_method<'tcx>(\n         // We'll attempt to provide a structured suggestion for `Self: Sized`.\n         let sugg =\n             tcx.hir().get_if_local(method.def_id).as_ref().and_then(|node| node.generics()).map(\n-                |generics| match generics.where_clause.predicates {\n-                    [] => (\" where Self: Sized\", generics.where_clause.span),\n+                |generics| match generics.predicates {\n+                    [] => (\" where Self: Sized\", generics.where_clause_span),\n                     [.., pred] => (\", Self: Sized\", pred.span().shrink_to_hi()),\n                 },\n             );"}, {"sha": "b8422ce3208f136b18b458c011a5f4e9e3f080df", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -924,14 +924,9 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             let self_ty_def_id = tcx.hir().local_def_id(self_ty).to_def_id();\n             for clause in where_clause {\n                 if let hir::WherePredicate::BoundPredicate(pred) = clause {\n-                    match pred.bounded_ty.kind {\n-                        hir::TyKind::Path(hir::QPath::Resolved(_, path)) => match path.res {\n-                            Res::Def(DefKind::TyParam, def_id) if def_id == self_ty_def_id => {}\n-                            _ => continue,\n-                        },\n-                        _ => continue,\n+                    if pred.is_param_bound(self_ty_def_id) {\n+                        search_bounds(pred.bounds);\n                     }\n-                    search_bounds(pred.bounds);\n                 }\n             }\n         }\n@@ -2389,7 +2384,6 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     bf.unsafety,\n                     bf.abi,\n                     bf.decl,\n-                    &hir::Generics::empty(),\n                     None,\n                     Some(ast_ty),\n                 ))\n@@ -2551,8 +2545,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         unsafety: hir::Unsafety,\n         abi: abi::Abi,\n         decl: &hir::FnDecl<'_>,\n-        generics: &hir::Generics<'_>,\n-        ident_span: Option<Span>,\n+        generics: Option<&hir::Generics<'_>>,\n         hir_ty: Option<&hir::Ty<'_>>,\n     ) -> ty::PolyFnSig<'tcx> {\n         debug!(\"ty_of_fn\");\n@@ -2565,7 +2558,9 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let mut visitor = HirPlaceholderCollector::default();\n         let mut infer_replacements = vec![];\n \n-        walk_generics(&mut visitor, generics);\n+        if let Some(generics) = generics {\n+            walk_generics(&mut visitor, generics);\n+        }\n \n         let input_tys: Vec<_> = decl\n             .inputs\n@@ -2617,8 +2612,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n             let mut diag = crate::collect::placeholder_type_error_diag(\n                 tcx,\n-                ident_span.map(|sp| sp.shrink_to_hi()),\n-                generics.params,\n+                generics,\n                 visitor.0,\n                 infer_replacements.iter().map(|(s, _)| *s).collect(),\n                 true,"}, {"sha": "6d78a863d54cf97bdf0911899899684441f1e1d7", "filename": "compiler/rustc_typeck/src/check/compare_method.rs", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -804,7 +804,8 @@ fn compare_synthetic_generics<'tcx>(\n         iter::zip(impl_m_type_params, trait_m_type_params)\n     {\n         if impl_synthetic != trait_synthetic {\n-            let impl_hir_id = tcx.hir().local_def_id_to_hir_id(impl_def_id.expect_local());\n+            let impl_def_id = impl_def_id.expect_local();\n+            let impl_hir_id = tcx.hir().local_def_id_to_hir_id(impl_def_id);\n             let impl_span = tcx.hir().span(impl_hir_id);\n             let trait_span = tcx.def_span(trait_def_id);\n             let mut err = struct_span_err!(\n@@ -868,14 +869,14 @@ fn compare_synthetic_generics<'tcx>(\n                             hir::ImplItemKind::Fn(ref sig, _) => sig.decl.inputs,\n                             _ => unreachable!(),\n                         };\n-                        struct Visitor(Option<Span>, hir::def_id::DefId);\n+                        struct Visitor(Option<Span>, hir::def_id::LocalDefId);\n                         impl<'v> intravisit::Visitor<'v> for Visitor {\n                             fn visit_ty(&mut self, ty: &'v hir::Ty<'v>) {\n                                 intravisit::walk_ty(self, ty);\n                                 if let hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) =\n                                     ty.kind\n                                     && let Res::Def(DefKind::TyParam, def_id) = path.res\n-                                    && def_id == self.1\n+                                    && def_id == self.1.to_def_id()\n                                 {\n                                     self.0 = Some(ty.span);\n                                 }\n@@ -887,17 +888,7 @@ fn compare_synthetic_generics<'tcx>(\n                         }\n                         let span = visitor.0?;\n \n-                        let bounds =\n-                            impl_m.generics.params.iter().find_map(|param| match param.kind {\n-                                GenericParamKind::Lifetime { .. } => None,\n-                                GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {\n-                                    if param.hir_id == impl_hir_id {\n-                                        Some(&param.bounds)\n-                                    } else {\n-                                        None\n-                                    }\n-                                }\n-                            })?;\n+                        let bounds = impl_m.generics.bounds_for_param(impl_def_id).next()?.bounds;\n                         let bounds = bounds.first()?.span().to(bounds.last()?.span());\n                         let bounds = tcx.sess.source_map().span_to_snippet(bounds).ok()?;\n "}, {"sha": "681d1e37f86f1317486616e91aa7b887a29f7ca8", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/suggestions.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -599,17 +599,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             kind:\n                 hir::ItemKind::Fn(\n                     hir::FnSig { decl: hir::FnDecl { inputs: fn_parameters, output: fn_return, .. }, .. },\n-                    hir::Generics { params, where_clause, .. },\n+                    hir::Generics { params, predicates, .. },\n                     _body_id,\n                 ),\n             ..\n         })) = fn_node else { return };\n \n-        let Some(expected_generic_param) = params.get(expected_ty_as_param.index as usize) else { return };\n+        if params.get(expected_ty_as_param.index as usize).is_none() {\n+            return;\n+        };\n \n         // get all where BoundPredicates here, because they are used in to cases below\n-        let where_predicates = where_clause\n-            .predicates\n+        let where_predicates = predicates\n             .iter()\n             .filter_map(|p| match p {\n                 WherePredicate::BoundPredicate(hir::WhereBoundPredicate {\n@@ -640,10 +641,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             where_predicates.iter().flatten().flat_map(|bounds| bounds.iter());\n \n         // extract all bounds from the source code using their spans\n-        let all_matching_bounds_strs = expected_generic_param\n-            .bounds\n-            .iter()\n-            .chain(predicates_from_where)\n+        let all_matching_bounds_strs = predicates_from_where\n             .filter_map(|bound| match bound {\n                 GenericBound::Trait(_, _) => {\n                     self.tcx.sess.source_map().span_to_snippet(bound.span()).ok()"}, {"sha": "640dccf66b0b4672293d7266743e0b170c3a0219", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 29, "deletions": 37, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -533,12 +533,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 };\n                                 if let Some(hir::Node::Item(hir::Item { kind, .. })) = node {\n                                     if let Some(g) = kind.generics() {\n-                                        let key = match g.where_clause.predicates {\n+                                        let key = match g.predicates {\n                                             [.., pred] => (pred.span().shrink_to_hi(), false),\n-                                            [] => (\n-                                                g.where_clause.span_for_predicates_or_empty_place(),\n-                                                true,\n-                                            ),\n+                                            [] => (g.span_for_predicates_or_empty_place(), true),\n                                         };\n                                         type_params\n                                             .entry(key)\n@@ -1871,37 +1868,30 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     // instead we suggest `T: Foo + Bar` in that case.\n                     match hir.get(id) {\n                         Node::GenericParam(param) => {\n-                            let mut impl_trait = false;\n-                            let has_bounds =\n-                                if let hir::GenericParamKind::Type { synthetic: true, .. } =\n-                                    &param.kind\n-                                {\n-                                    // We've found `fn foo(x: impl Trait)` instead of\n-                                    // `fn foo<T>(x: T)`. We want to suggest the correct\n-                                    // `fn foo(x: impl Trait + TraitBound)` instead of\n-                                    // `fn foo<T: TraitBound>(x: T)`. (#63706)\n-                                    impl_trait = true;\n-                                    param.bounds.get(1)\n-                                } else {\n-                                    param.bounds.get(0)\n-                                };\n-                            let sp = hir.span(id);\n-                            let sp = if let Some(first_bound) = has_bounds {\n-                                sp.until(first_bound.span())\n-                            } else if let Some(colon_sp) =\n-                                // If the generic param is declared with a colon but without bounds:\n-                                // fn foo<T:>(t: T) { ... }\n-                                param.colon_span_for_suggestions(\n-                                    self.inh.tcx.sess.source_map(),\n-                                )\n+                            enum Introducer {\n+                                Plus,\n+                                Colon,\n+                                Nothing,\n+                            }\n+                            let ast_generics = hir.get_generics(id.owner).unwrap();\n+                            let (sp, mut introducer) = if let Some(span) =\n+                                ast_generics.bounds_span_for_suggestions(def_id)\n                             {\n-                                sp.to(colon_sp)\n+                                (span, Introducer::Plus)\n+                            } else if let Some(colon_span) = param.colon_span {\n+                                (colon_span.shrink_to_hi(), Introducer::Nothing)\n                             } else {\n-                                sp\n+                                (param.span.shrink_to_hi(), Introducer::Colon)\n                             };\n-                            let trait_def_ids: FxHashSet<DefId> = param\n-                                .bounds\n-                                .iter()\n+                            if matches!(\n+                                param.kind,\n+                                hir::GenericParamKind::Type { synthetic: true, .. },\n+                            ) {\n+                                introducer = Introducer::Plus\n+                            }\n+                            let trait_def_ids: FxHashSet<DefId> = ast_generics\n+                                .bounds_for_param(def_id)\n+                                .flat_map(|bp| bp.bounds.iter())\n                                 .filter_map(|bound| bound.trait_ref()?.trait_def_id())\n                                 .collect();\n                             if !candidates.iter().any(|t| trait_def_ids.contains(&t.def_id)) {\n@@ -1913,11 +1903,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     )),\n                                     candidates.iter().map(|t| {\n                                         format!(\n-                                            \"{}{} {}{}\",\n-                                            param.name.ident(),\n-                                            if impl_trait { \" +\" } else { \":\" },\n+                                            \"{} {}\",\n+                                            match introducer {\n+                                                Introducer::Plus => \" +\",\n+                                                Introducer::Colon => \":\",\n+                                                Introducer::Nothing => \"\",\n+                                            },\n                                             self.tcx.def_path_str(t.def_id),\n-                                            if has_bounds.is_some() { \" + \" } else { \"\" },\n                                         )\n                                     }),\n                                     Applicability::MaybeIncorrect,"}, {"sha": "76c955d6f690d672319217ce765caf9cf3ae6206", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -373,16 +373,7 @@ fn typeck_with_fallback<'tcx>(\n         let (fcx, wf_tys) = if let Some(hir::FnSig { header, decl, .. }) = fn_sig {\n             let fn_sig = if crate::collect::get_infer_ret_ty(&decl.output).is_some() {\n                 let fcx = FnCtxt::new(&inh, param_env, body.value.hir_id);\n-                <dyn AstConv<'_>>::ty_of_fn(\n-                    &fcx,\n-                    id,\n-                    header.unsafety,\n-                    header.abi,\n-                    decl,\n-                    &hir::Generics::empty(),\n-                    None,\n-                    None,\n-                )\n+                <dyn AstConv<'_>>::ty_of_fn(&fcx, id, header.unsafety, header.abi, decl, None, None)\n             } else {\n                 tcx.fn_sig(def_id)\n             };"}, {"sha": "ec2b7c13ff33c5325ae7ddeed69ab67ae8eaea8e", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -420,15 +420,11 @@ fn check_gat_where_clauses(tcx: TyCtxt<'_>, associated_items: &[hir::TraitItemRe\n \n             let suggestion = format!(\n                 \"{} {}\",\n-                if !gat_item_hir.generics.where_clause.predicates.is_empty() {\n-                    \",\"\n-                } else {\n-                    \" where\"\n-                },\n+                if !gat_item_hir.generics.predicates.is_empty() { \",\" } else { \" where\" },\n                 unsatisfied_bounds.join(\", \"),\n             );\n             err.span_suggestion(\n-                gat_item_hir.generics.where_clause.tail_span_for_suggestion(),\n+                gat_item_hir.generics.tail_span_for_predicate_suggestion(),\n                 &format!(\"add the required where clause{plural}\"),\n                 suggestion,\n                 Applicability::MachineApplicable,\n@@ -1733,7 +1729,6 @@ fn check_variances_for_type_defn<'tcx>(\n     let explicitly_bounded_params = Lazy::new(|| {\n         let icx = crate::collect::ItemCtxt::new(tcx, item.def_id.to_def_id());\n         hir_generics\n-            .where_clause\n             .predicates\n             .iter()\n             .filter_map(|predicate| match predicate {\n@@ -1760,8 +1755,7 @@ fn check_variances_for_type_defn<'tcx>(\n         match param.name {\n             hir::ParamName::Error => {}\n             _ => {\n-                let has_explicit_bounds =\n-                    !param.bounds.is_empty() || explicitly_bounded_params.contains(&parameter);\n+                let has_explicit_bounds = explicitly_bounded_params.contains(&parameter);\n                 report_bivariance(tcx, param, has_explicit_bounds);\n             }\n         }\n@@ -1819,13 +1813,12 @@ fn check_false_global_bounds(fcx: &FnCtxt<'_, '_>, mut span: Span, id: hir::HirI\n \n             // only use the span of the predicate clause (#90869)\n \n-            if let Some(hir::Generics { where_clause, .. }) =\n+            if let Some(hir::Generics { predicates, .. }) =\n                 hir_node.and_then(|node| node.generics())\n             {\n                 let obligation_span = obligation.cause.span(fcx.tcx);\n \n-                span = where_clause\n-                    .predicates\n+                span = predicates\n                     .iter()\n                     // There seems to be no better way to find out which predicate we are in\n                     .find(|pred| pred.span().contains(obligation_span))"}, {"sha": "f85735ec57bf7ab43a999d8a7ca81b1fdc312561", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 51, "deletions": 134, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -1,4 +1,3 @@\n-// ignore-tidy-filelength\n //! \"Collection\" is the process of determining the type and other external\n //! details of each item in Rust. Collection is specifically concerned\n //! with *inter-procedural* things -- for example, for a function\n@@ -149,8 +148,7 @@ struct CollectItemTypesVisitor<'tcx> {\n /// all already existing generic type parameters to avoid suggesting a name that is already in use.\n crate fn placeholder_type_error<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    span: Option<Span>,\n-    generics: &[hir::GenericParam<'_>],\n+    generics: Option<&hir::Generics<'_>>,\n     placeholder_types: Vec<Span>,\n     suggest: bool,\n     hir_ty: Option<&hir::Ty<'_>>,\n@@ -160,23 +158,13 @@ crate fn placeholder_type_error<'tcx>(\n         return;\n     }\n \n-    placeholder_type_error_diag(\n-        tcx,\n-        span,\n-        generics,\n-        placeholder_types,\n-        vec![],\n-        suggest,\n-        hir_ty,\n-        kind,\n-    )\n-    .emit();\n+    placeholder_type_error_diag(tcx, generics, placeholder_types, vec![], suggest, hir_ty, kind)\n+        .emit();\n }\n \n crate fn placeholder_type_error_diag<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    span: Option<Span>,\n-    generics: &[hir::GenericParam<'_>],\n+    generics: Option<&hir::Generics<'_>>,\n     placeholder_types: Vec<Span>,\n     additional_spans: Vec<Span>,\n     suggest: bool,\n@@ -187,26 +175,24 @@ crate fn placeholder_type_error_diag<'tcx>(\n         return bad_placeholder(tcx, additional_spans, kind);\n     }\n \n-    let type_name = generics.next_type_param_name(None);\n+    let params = generics.map(|g| g.params).unwrap_or_default();\n+    let type_name = params.next_type_param_name(None);\n     let mut sugg: Vec<_> =\n         placeholder_types.iter().map(|sp| (*sp, (*type_name).to_string())).collect();\n \n-    if generics.is_empty() {\n-        if let Some(span) = span {\n-            sugg.push((span, format!(\"<{}>\", type_name)));\n+    if let Some(generics) = generics {\n+        if let Some(arg) = params.iter().find(|arg| {\n+            matches!(arg.name, hir::ParamName::Plain(Ident { name: kw::Underscore, .. }))\n+        }) {\n+            // Account for `_` already present in cases like `struct S<_>(_);` and suggest\n+            // `struct S<T>(T);` instead of `struct S<_, T>(T);`.\n+            sugg.push((arg.span, (*type_name).to_string()));\n+        } else if let Some(span) = generics.span_for_param_suggestion() {\n+            // Account for bounds, we want `fn foo<T: E, K>(_: K)` not `fn foo<T, K: E>(_: K)`.\n+            sugg.push((span, format!(\", {}\", type_name)));\n+        } else {\n+            sugg.push((generics.span, format!(\"<{}>\", type_name)));\n         }\n-    } else if let Some(arg) = generics\n-        .iter()\n-        .find(|arg| matches!(arg.name, hir::ParamName::Plain(Ident { name: kw::Underscore, .. })))\n-    {\n-        // Account for `_` already present in cases like `struct S<_>(_);` and suggest\n-        // `struct S<T>(T);` instead of `struct S<_, T>(T);`.\n-        sugg.push((arg.span, (*type_name).to_string()));\n-    } else {\n-        let last = generics.iter().last().unwrap();\n-        // Account for bounds, we want `fn foo<T: E, K>(_: K)` not `fn foo<T, K: E>(_: K)`.\n-        let span = last.bounds_span_for_suggestions().unwrap_or(last.span.shrink_to_hi());\n-        sugg.push((span, format!(\", {}\", type_name)));\n     }\n \n     let mut err =\n@@ -270,15 +256,7 @@ fn reject_placeholder_type_signatures_in_item<'tcx>(\n     let mut visitor = HirPlaceholderCollector::default();\n     visitor.visit_item(item);\n \n-    placeholder_type_error(\n-        tcx,\n-        Some(generics.span),\n-        generics.params,\n-        visitor.0,\n-        suggest,\n-        None,\n-        item.kind.descr(),\n-    );\n+    placeholder_type_error(tcx, Some(generics), visitor.0, suggest, None, item.kind.descr());\n }\n \n impl<'tcx> Visitor<'tcx> for CollectItemTypesVisitor<'tcx> {\n@@ -680,27 +658,8 @@ impl<'tcx> ItemCtxt<'tcx> {\n         only_self_bounds: OnlySelfBounds,\n         assoc_name: Option<Ident>,\n     ) -> Vec<(ty::Predicate<'tcx>, Span)> {\n-        let from_ty_params = ast_generics\n-            .params\n-            .iter()\n-            .filter_map(|param| match param.kind {\n-                GenericParamKind::Type { .. } | GenericParamKind::Const { .. }\n-                    if param.hir_id == param_id =>\n-                {\n-                    Some(&param.bounds)\n-                }\n-                _ => None,\n-            })\n-            .flat_map(|bounds| bounds.iter())\n-            .filter(|b| match assoc_name {\n-                Some(assoc_name) => self.bound_defines_assoc_item(b, assoc_name),\n-                None => true,\n-            })\n-            .flat_map(|b| predicates_from_bound(self, ty, b, ty::List::empty()));\n-\n         let param_def_id = self.tcx.hir().local_def_id(param_id).to_def_id();\n-        let from_where_clauses = ast_generics\n-            .where_clause\n+        ast_generics\n             .predicates\n             .iter()\n             .filter_map(|wp| match *wp {\n@@ -725,9 +684,8 @@ impl<'tcx> ItemCtxt<'tcx> {\n                     })\n                     .filter_map(move |b| bt.map(|bt| (bt, b, bvars)))\n             })\n-            .flat_map(|(bt, b, bvars)| predicates_from_bound(self, bt, b, bvars));\n-\n-        from_ty_params.chain(from_where_clauses).collect()\n+            .flat_map(|(bt, b, bvars)| predicates_from_bound(self, bt, b, bvars))\n+            .collect()\n     }\n \n     fn bound_defines_assoc_item(&self, b: &hir::GenericBound<'_>, assoc_name: Ident) -> bool {\n@@ -773,7 +731,6 @@ fn convert_item(tcx: TyCtxt<'_>, item_id: hir::ItemId) {\n                         placeholder_type_error(\n                             tcx,\n                             None,\n-                            &[],\n                             visitor.0,\n                             false,\n                             None,\n@@ -853,15 +810,7 @@ fn convert_item(tcx: TyCtxt<'_>, item_id: hir::ItemId) {\n                     if let hir::TyKind::TraitObject(..) = ty.kind {\n                         let mut visitor = HirPlaceholderCollector::default();\n                         visitor.visit_item(it);\n-                        placeholder_type_error(\n-                            tcx,\n-                            None,\n-                            &[],\n-                            visitor.0,\n-                            false,\n-                            None,\n-                            it.kind.descr(),\n-                        );\n+                        placeholder_type_error(tcx, None, visitor.0, false, None, it.kind.descr());\n                     }\n                 }\n                 _ => (),\n@@ -889,7 +838,7 @@ fn convert_trait_item(tcx: TyCtxt<'_>, trait_item_id: hir::TraitItemId) {\n             // Account for `const C: _;`.\n             let mut visitor = HirPlaceholderCollector::default();\n             visitor.visit_trait_item(trait_item);\n-            placeholder_type_error(tcx, None, &[], visitor.0, false, None, \"constant\");\n+            placeholder_type_error(tcx, None, visitor.0, false, None, \"constant\");\n         }\n \n         hir::TraitItemKind::Type(_, Some(_)) => {\n@@ -898,7 +847,7 @@ fn convert_trait_item(tcx: TyCtxt<'_>, trait_item_id: hir::TraitItemId) {\n             // Account for `type T = _;`.\n             let mut visitor = HirPlaceholderCollector::default();\n             visitor.visit_trait_item(trait_item);\n-            placeholder_type_error(tcx, None, &[], visitor.0, false, None, \"associated type\");\n+            placeholder_type_error(tcx, None, visitor.0, false, None, \"associated type\");\n         }\n \n         hir::TraitItemKind::Type(_, None) => {\n@@ -908,7 +857,7 @@ fn convert_trait_item(tcx: TyCtxt<'_>, trait_item_id: hir::TraitItemId) {\n             let mut visitor = HirPlaceholderCollector::default();\n             visitor.visit_trait_item(trait_item);\n \n-            placeholder_type_error(tcx, None, &[], visitor.0, false, None, \"associated type\");\n+            placeholder_type_error(tcx, None, visitor.0, false, None, \"associated type\");\n         }\n     };\n \n@@ -930,7 +879,7 @@ fn convert_impl_item(tcx: TyCtxt<'_>, impl_item_id: hir::ImplItemId) {\n             let mut visitor = HirPlaceholderCollector::default();\n             visitor.visit_impl_item(impl_item);\n \n-            placeholder_type_error(tcx, None, &[], visitor.0, false, None, \"associated type\");\n+            placeholder_type_error(tcx, None, visitor.0, false, None, \"associated type\");\n         }\n         hir::ImplItemKind::Const(..) => {}\n     }\n@@ -1893,15 +1842,14 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n     match tcx.hir().get(hir_id) {\n         TraitItem(hir::TraitItem {\n             kind: TraitItemKind::Fn(sig, TraitFn::Provided(_)),\n-            ident,\n             generics,\n             ..\n         })\n-        | Item(hir::Item { kind: ItemKind::Fn(sig, generics, _), ident, .. }) => {\n-            infer_return_ty_for_fn_sig(tcx, sig, *ident, generics, def_id, &icx)\n+        | Item(hir::Item { kind: ItemKind::Fn(sig, generics, _), .. }) => {\n+            infer_return_ty_for_fn_sig(tcx, sig, generics, def_id, &icx)\n         }\n \n-        ImplItem(hir::ImplItem { kind: ImplItemKind::Fn(sig, _), ident, generics, .. }) => {\n+        ImplItem(hir::ImplItem { kind: ImplItemKind::Fn(sig, _), generics, .. }) => {\n             // Do not try to inference the return type for a impl method coming from a trait\n             if let Item(hir::Item { kind: ItemKind::Impl(i), .. }) =\n                 tcx.hir().get(tcx.hir().get_parent_node(hir_id))\n@@ -1913,18 +1861,16 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n                     sig.header.unsafety,\n                     sig.header.abi,\n                     sig.decl,\n-                    generics,\n-                    Some(ident.span),\n+                    Some(generics),\n                     None,\n                 )\n             } else {\n-                infer_return_ty_for_fn_sig(tcx, sig, *ident, generics, def_id, &icx)\n+                infer_return_ty_for_fn_sig(tcx, sig, generics, def_id, &icx)\n             }\n         }\n \n         TraitItem(hir::TraitItem {\n             kind: TraitItemKind::Fn(FnSig { header, decl, span: _ }, _),\n-            ident,\n             generics,\n             ..\n         }) => <dyn AstConv<'_>>::ty_of_fn(\n@@ -1933,16 +1879,13 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n             header.unsafety,\n             header.abi,\n             decl,\n-            generics,\n-            Some(ident.span),\n+            Some(generics),\n             None,\n         ),\n \n-        ForeignItem(&hir::ForeignItem {\n-            kind: ForeignItemKind::Fn(fn_decl, _, _), ident, ..\n-        }) => {\n+        ForeignItem(&hir::ForeignItem { kind: ForeignItemKind::Fn(fn_decl, _, _), .. }) => {\n             let abi = tcx.hir().get_foreign_abi(hir_id);\n-            compute_sig_of_foreign_fn_decl(tcx, def_id.to_def_id(), fn_decl, abi, ident)\n+            compute_sig_of_foreign_fn_decl(tcx, def_id.to_def_id(), fn_decl, abi)\n         }\n \n         Ctor(data) | Variant(hir::Variant { data, .. }) if data.ctor_hir_id().is_some() => {\n@@ -1983,7 +1926,6 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n fn infer_return_ty_for_fn_sig<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     sig: &hir::FnSig<'_>,\n-    ident: Ident,\n     generics: &hir::Generics<'_>,\n     def_id: LocalDefId,\n     icx: &ItemCtxt<'tcx>,\n@@ -2038,8 +1980,7 @@ fn infer_return_ty_for_fn_sig<'tcx>(\n             sig.header.unsafety,\n             sig.header.abi,\n             sig.decl,\n-            generics,\n-            Some(ident.span),\n+            Some(generics),\n             None,\n         ),\n     }\n@@ -2200,16 +2141,16 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n \n     let icx = ItemCtxt::new(tcx, def_id);\n \n-    const NO_GENERICS: &hir::Generics<'_> = &hir::Generics::empty();\n+    const NO_GENERICS: &hir::Generics<'_> = hir::Generics::empty();\n \n     // We use an `IndexSet` to preserves order of insertion.\n     // Preserving the order of insertion is important here so as not to break UI tests.\n     let mut predicates: FxIndexSet<(ty::Predicate<'_>, Span)> = FxIndexSet::default();\n \n     let ast_generics = match node {\n-        Node::TraitItem(item) => &item.generics,\n+        Node::TraitItem(item) => item.generics,\n \n-        Node::ImplItem(item) => &item.generics,\n+        Node::ImplItem(item) => item.generics,\n \n         Node::Item(item) => {\n             match item.kind {\n@@ -2223,15 +2164,15 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n                 | ItemKind::TyAlias(_, ref generics)\n                 | ItemKind::Enum(_, ref generics)\n                 | ItemKind::Struct(_, ref generics)\n-                | ItemKind::Union(_, ref generics) => generics,\n+                | ItemKind::Union(_, ref generics) => *generics,\n \n                 ItemKind::Trait(_, _, ref generics, ..) => {\n                     is_trait = Some(ty::TraitRef::identity(tcx, def_id));\n-                    generics\n+                    *generics\n                 }\n                 ItemKind::TraitAlias(ref generics, _) => {\n                     is_trait = Some(ty::TraitRef::identity(tcx, def_id));\n-                    generics\n+                    *generics\n                 }\n                 ItemKind::OpaqueTy(OpaqueTy {\n                     origin: hir::OpaqueTyOrigin::AsyncFn(..) | hir::OpaqueTyOrigin::FnReturn(..),\n@@ -2268,7 +2209,7 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n \n         Node::ForeignItem(item) => match item.kind {\n             ForeignItemKind::Static(..) => NO_GENERICS,\n-            ForeignItemKind::Fn(_, _, ref generics) => generics,\n+            ForeignItemKind::Fn(_, _, ref generics) => *generics,\n             ForeignItemKind::Type => NO_GENERICS,\n         },\n \n@@ -2302,29 +2243,9 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n     // Collect the region predicates that were declared inline as\n     // well. In the case of parameters declared on a fn or method, we\n     // have to be careful to only iterate over early-bound regions.\n-    let mut index = parent_count + has_own_self as u32;\n-    for param in early_bound_lifetimes_from_generics(tcx, hir_id.owner, ast_generics) {\n-        let region = tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n-            def_id: tcx.hir().local_def_id(param.hir_id).to_def_id(),\n-            index,\n-            name: param.name.ident().name,\n-        }));\n-        index += 1;\n-\n-        match param.kind {\n-            GenericParamKind::Lifetime { .. } => {\n-                param.bounds.iter().for_each(|bound| match bound {\n-                    hir::GenericBound::Outlives(lt) => {\n-                        let bound = <dyn AstConv<'_>>::ast_region_to_region(&icx, lt, None);\n-                        let outlives = ty::Binder::dummy(ty::OutlivesPredicate(region, bound));\n-                        predicates.insert((outlives.to_predicate(tcx), lt.span));\n-                    }\n-                    _ => bug!(),\n-                });\n-            }\n-            _ => bug!(),\n-        }\n-    }\n+    let mut index = parent_count\n+        + has_own_self as u32\n+        + early_bound_lifetimes_from_generics(tcx, hir_id.owner, ast_generics).count() as u32;\n \n     // Collect the predicates that were written inline by the user on each\n     // type parameter (e.g., `<T: Foo>`).\n@@ -2337,28 +2258,26 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n                 let param_ty = ty::ParamTy::new(index, name).to_ty(tcx);\n                 index += 1;\n \n-                let mut bounds = <dyn AstConv<'_>>::compute_bounds(&icx, param_ty, param.bounds);\n+                let mut bounds = Bounds::default();\n                 // Params are implicitly sized unless a `?Sized` bound is found\n                 <dyn AstConv<'_>>::add_implicitly_sized(\n                     &icx,\n                     &mut bounds,\n-                    param.bounds,\n-                    Some((param.hir_id, ast_generics.where_clause.predicates)),\n+                    &[],\n+                    Some((param.hir_id, ast_generics.predicates)),\n                     param.span,\n                 );\n                 predicates.extend(bounds.predicates(tcx, param_ty));\n             }\n             GenericParamKind::Const { .. } => {\n                 // Bounds on const parameters are currently not possible.\n-                debug_assert!(param.bounds.is_empty());\n                 index += 1;\n             }\n         }\n     }\n \n     // Add in the bounds that appear in the where-clause.\n-    let where_clause = &ast_generics.where_clause;\n-    for predicate in where_clause.predicates {\n+    for predicate in ast_generics.predicates {\n         match predicate {\n             hir::WherePredicate::BoundPredicate(bound_pred) => {\n                 let ty = icx.to_ty(bound_pred.bounded_ty);\n@@ -2616,7 +2535,6 @@ fn compute_sig_of_foreign_fn_decl<'tcx>(\n     def_id: DefId,\n     decl: &'tcx hir::FnDecl<'tcx>,\n     abi: abi::Abi,\n-    ident: Ident,\n ) -> ty::PolyFnSig<'tcx> {\n     let unsafety = if abi == abi::Abi::RustIntrinsic {\n         intrinsic_operation_unsafety(tcx.item_name(def_id))\n@@ -2630,8 +2548,7 @@ fn compute_sig_of_foreign_fn_decl<'tcx>(\n         unsafety,\n         abi,\n         decl,\n-        &hir::Generics::empty(),\n-        Some(ident.span),\n+        None,\n         None,\n     );\n "}, {"sha": "495b8d3b4eeb38470a3a3976f35884d56d658f29", "filename": "compiler/rustc_typeck/src/collect/type_of.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -337,8 +337,8 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                         icx.to_ty(ty)\n                     }\n                 }\n-                ItemKind::TyAlias(self_ty, _)\n-                | ItemKind::Impl(hir::Impl { self_ty, .. }) => icx.to_ty(self_ty),\n+                ItemKind::TyAlias(self_ty, _) => icx.to_ty(self_ty),\n+                ItemKind::Impl(hir::Impl { self_ty, .. }) => icx.to_ty(*self_ty),\n                 ItemKind::Fn(..) => {\n                     let substs = InternalSubsts::identity_for_item(tcx, def_id.to_def_id());\n                     tcx.mk_fn_def(def_id.to_def_id(), substs)"}, {"sha": "03b3d68d59f4cb2cf5ab40790d980321ea815faa", "filename": "compiler/rustc_typeck/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Flib.rs?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -213,7 +213,7 @@ fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: DefId) {\n         let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n         match tcx.hir().find(hir_id) {\n             Some(Node::Item(hir::Item { kind: hir::ItemKind::Fn(_, ref generics, _), .. })) => {\n-                generics.where_clause.span()\n+                generics.where_clause_span()\n             }\n             _ => {\n                 span_bug!(tcx.def_span(def_id), \"main has a non-function type\");\n@@ -408,7 +408,7 @@ fn check_start_fn_ty(tcx: TyCtxt<'_>, start_def_id: DefId) {\n                         .emit();\n                         error = true;\n                     }\n-                    if let Some(sp) = generics.where_clause.span() {\n+                    if let Some(sp) = generics.where_clause_span() {\n                         struct_span_err!(\n                             tcx.sess,\n                             sp,"}, {"sha": "343dd0387f47987c011c2334c80f0c8d0f914ea4", "filename": "src/etc/check_missing_items.py", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Fetc%2Fcheck_missing_items.py", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Fetc%2Fcheck_missing_items.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fcheck_missing_items.py?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -49,8 +49,6 @@ def check_generic_param(param):\n         ty = param[\"kind\"][\"type\"]\n         if ty[\"default\"]:\n             check_type(ty[\"default\"])\n-        for bound in ty[\"bounds\"]:\n-            check_generic_bound(bound)\n     elif \"const\" in param[\"kind\"]:\n         check_type(param[\"kind\"][\"const\"])\n "}, {"sha": "d458deddae335afc44724e5290ff9e42d981b335", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 77, "deletions": 42, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -238,9 +238,12 @@ impl Clean<Option<Lifetime>> for ty::Region<'_> {\n     }\n }\n \n-impl Clean<WherePredicate> for hir::WherePredicate<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> WherePredicate {\n-        match *self {\n+impl Clean<Option<WherePredicate>> for hir::WherePredicate<'_> {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Option<WherePredicate> {\n+        if !self.in_where_clause() {\n+            return None;\n+        }\n+        Some(match *self {\n             hir::WherePredicate::BoundPredicate(ref wbp) => {\n                 let bound_params = wbp\n                     .bound_generic_params\n@@ -250,11 +253,7 @@ impl Clean<WherePredicate> for hir::WherePredicate<'_> {\n                         // Higher-ranked lifetimes can't have bounds.\n                         assert_matches!(\n                             param,\n-                            hir::GenericParam {\n-                                kind: hir::GenericParamKind::Lifetime { .. },\n-                                bounds: [],\n-                                ..\n-                            }\n+                            hir::GenericParam { kind: hir::GenericParamKind::Lifetime { .. }, .. }\n                         );\n                         Lifetime(param.name.ident().name)\n                     })\n@@ -275,7 +274,7 @@ impl Clean<WherePredicate> for hir::WherePredicate<'_> {\n                 lhs: wrp.lhs_ty.clean(cx),\n                 rhs: wrp.rhs_ty.clean(cx).into(),\n             },\n-        }\n+        })\n     }\n }\n \n@@ -456,44 +455,75 @@ impl Clean<GenericParamDef> for ty::GenericParamDef {\n     }\n }\n \n-impl Clean<GenericParamDef> for hir::GenericParam<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> GenericParamDef {\n-        let (name, kind) = match self.kind {\n-            hir::GenericParamKind::Lifetime { .. } => {\n-                let outlives = self\n-                    .bounds\n+fn clean_generic_param(\n+    cx: &mut DocContext<'_>,\n+    generics: Option<&hir::Generics<'_>>,\n+    param: &hir::GenericParam<'_>,\n+) -> GenericParamDef {\n+    let (name, kind) = match param.kind {\n+        hir::GenericParamKind::Lifetime { .. } => {\n+            let outlives = if let Some(generics) = generics {\n+                generics\n+                    .predicates\n                     .iter()\n+                    .flat_map(|pred| {\n+                        match pred {\n+                            hir::WherePredicate::RegionPredicate(rp)\n+                                if rp.lifetime.name == hir::LifetimeName::Param(param.name)\n+                                    && !rp.in_where_clause =>\n+                            {\n+                                rp.bounds\n+                            }\n+                            _ => &[],\n+                        }\n+                        .iter()\n+                    })\n                     .map(|bound| match bound {\n                         hir::GenericBound::Outlives(lt) => lt.clean(cx),\n                         _ => panic!(),\n                     })\n-                    .collect();\n-                (self.name.ident().name, GenericParamDefKind::Lifetime { outlives })\n-            }\n-            hir::GenericParamKind::Type { ref default, synthetic } => (\n-                self.name.ident().name,\n+                    .collect()\n+            } else {\n+                Vec::new()\n+            };\n+            (param.name.ident().name, GenericParamDefKind::Lifetime { outlives })\n+        }\n+        hir::GenericParamKind::Type { ref default, synthetic } => {\n+            let did = cx.tcx.hir().local_def_id(param.hir_id);\n+            let bounds = if let Some(generics) = generics {\n+                generics\n+                    .bounds_for_param(did)\n+                    .filter(|bp| !bp.in_where_clause)\n+                    .flat_map(|bp| bp.bounds)\n+                    .filter_map(|x| x.clean(cx))\n+                    .collect()\n+            } else {\n+                Vec::new()\n+            };\n+            (\n+                param.name.ident().name,\n                 GenericParamDefKind::Type {\n-                    did: cx.tcx.hir().local_def_id(self.hir_id).to_def_id(),\n-                    bounds: self.bounds.iter().filter_map(|x| x.clean(cx)).collect(),\n+                    did: did.to_def_id(),\n+                    bounds,\n                     default: default.map(|t| t.clean(cx)).map(Box::new),\n                     synthetic,\n                 },\n-            ),\n-            hir::GenericParamKind::Const { ref ty, default } => (\n-                self.name.ident().name,\n-                GenericParamDefKind::Const {\n-                    did: cx.tcx.hir().local_def_id(self.hir_id).to_def_id(),\n-                    ty: Box::new(ty.clean(cx)),\n-                    default: default.map(|ct| {\n-                        let def_id = cx.tcx.hir().local_def_id(ct.hir_id);\n-                        Box::new(ty::Const::from_anon_const(cx.tcx, def_id).to_string())\n-                    }),\n-                },\n-            ),\n-        };\n+            )\n+        }\n+        hir::GenericParamKind::Const { ref ty, default } => (\n+            param.name.ident().name,\n+            GenericParamDefKind::Const {\n+                did: cx.tcx.hir().local_def_id(param.hir_id).to_def_id(),\n+                ty: Box::new(ty.clean(cx)),\n+                default: default.map(|ct| {\n+                    let def_id = cx.tcx.hir().local_def_id(ct.hir_id);\n+                    Box::new(ty::Const::from_anon_const(cx.tcx, def_id).to_string())\n+                }),\n+            },\n+        ),\n+    };\n \n-        GenericParamDef { name, kind }\n-    }\n+    GenericParamDef { name, kind }\n }\n \n impl Clean<Generics> for hir::Generics<'_> {\n@@ -524,7 +554,7 @@ impl Clean<Generics> for hir::Generics<'_> {\n             .iter()\n             .filter(|param| is_impl_trait(param))\n             .map(|param| {\n-                let param: GenericParamDef = param.clean(cx);\n+                let param = clean_generic_param(cx, Some(self), param);\n                 match param.kind {\n                     GenericParamDefKind::Lifetime { .. } => unreachable!(),\n                     GenericParamDefKind::Type { did, ref bounds, .. } => {\n@@ -538,14 +568,14 @@ impl Clean<Generics> for hir::Generics<'_> {\n \n         let mut params = Vec::with_capacity(self.params.len());\n         for p in self.params.iter().filter(|p| !is_impl_trait(p) && !is_elided_lifetime(p)) {\n-            let p = p.clean(cx);\n+            let p = clean_generic_param(cx, Some(self), p);\n             params.push(p);\n         }\n         params.extend(impl_trait_params);\n \n         let mut generics = Generics {\n             params,\n-            where_predicates: self.where_clause.predicates.iter().map(|x| x.clean(cx)).collect(),\n+            where_predicates: self.predicates.iter().filter_map(|x| x.clean(cx)).collect(),\n         };\n \n         // Some duplicates are generated for ?Sized bounds between type params and where\n@@ -954,7 +984,11 @@ impl Clean<PolyTrait> for hir::PolyTraitRef<'_> {\n     fn clean(&self, cx: &mut DocContext<'_>) -> PolyTrait {\n         PolyTrait {\n             trait_: self.trait_ref.clean(cx),\n-            generic_params: self.bound_generic_params.iter().map(|x| x.clean(cx)).collect(),\n+            generic_params: self\n+                .bound_generic_params\n+                .iter()\n+                .map(|x| clean_generic_param(cx, None, x))\n+                .collect(),\n         }\n     }\n }\n@@ -1823,7 +1857,8 @@ impl Clean<BareFunctionDecl> for hir::BareFnTy<'_> {\n     fn clean(&self, cx: &mut DocContext<'_>) -> BareFunctionDecl {\n         let (generic_params, decl) = enter_impl_trait(cx, |cx| {\n             // NOTE: generics must be cleaned before args\n-            let generic_params = self.generic_params.iter().map(|x| x.clean(cx)).collect();\n+            let generic_params =\n+                self.generic_params.iter().map(|x| clean_generic_param(cx, None, x)).collect();\n             let args = clean_args_from_types_and_names(cx, self.decl.inputs, self.param_names);\n             let decl = clean_fn_decl_with_args(cx, self.decl, args);\n             (generic_params, decl)"}, {"sha": "b5502309560eeb8712b6bc926b3183ec04234485", "filename": "src/librustdoc/html/render/span_map.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Flibrustdoc%2Fhtml%2Frender%2Fspan_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Flibrustdoc%2Fhtml%2Frender%2Fspan_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fspan_map.rs?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -5,7 +5,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::{self, Visitor};\n-use rustc_hir::{ExprKind, GenericParam, GenericParamKind, HirId, Mod, Node};\n+use rustc_hir::{ExprKind, GenericParam, HirId, Mod, Node};\n use rustc_middle::hir::nested_filter;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::Span;\n@@ -100,16 +100,7 @@ impl<'tcx> Visitor<'tcx> for SpanMapVisitor<'tcx> {\n         self.tcx.hir()\n     }\n \n-    fn visit_generic_param(&mut self, p: &'tcx GenericParam<'tcx>) {\n-        if !matches!(p.kind, GenericParamKind::Type { .. }) {\n-            return;\n-        }\n-        for bound in p.bounds {\n-            if let Some(trait_ref) = bound.trait_ref() {\n-                self.handle_path(trait_ref.path, None);\n-            }\n-        }\n-    }\n+    fn visit_generic_param(&mut self, _: &'tcx GenericParam<'tcx>) {}\n \n     fn visit_path(&mut self, path: &'tcx rustc_hir::Path<'tcx>, _id: HirId) {\n         self.handle_path(path, None);"}, {"sha": "5bbc20359c64a09f3c1fd762dbc50a0369bc077d", "filename": "src/test/ui/async-await/issue-86507.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fasync-await%2Fissue-86507.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fasync-await%2Fissue-86507.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-86507.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -14,10 +14,10 @@ note: captured value is not `Send` because `&` references cannot be sent unless\n LL |                     let x = x;\n    |                             ^ has type `&T` which is not `Send`, because `T` is not `Sync`\n    = note: required for the cast to the object type `dyn Future<Output = ()> + Send`\n-help: consider further restricting type parameter `T`\n+help: consider further restricting this bound\n    |\n-LL |         where 'me:'async_trait, T: std::marker::Sync {\n-   |                               ++++++++++++++++++++++\n+LL |     fn bar<'me, 'async_trait, T: Send + std::marker::Sync>(x: &'me T)\n+   |                                       +++++++++++++++++++\n \n error: aborting due to previous error\n "}, {"sha": "b1e59e9d5de362a70b3ef16d636045279732f5f2", "filename": "src/test/ui/builtin-superkinds/builtin-superkinds-self-type.stderr", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fbuiltin-superkinds%2Fbuiltin-superkinds-self-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fbuiltin-superkinds%2Fbuiltin-superkinds-self-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbuiltin-superkinds%2Fbuiltin-superkinds-self-type.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -2,9 +2,12 @@ error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/builtin-superkinds-self-type.rs:10:16\n    |\n LL | impl <T: Sync> Foo for T { }\n-   |       --       ^^^ ...so that the type `T` will meet its required lifetime bounds\n-   |       |\n-   |       help: consider adding an explicit lifetime bound...: `T: 'static +`\n+   |                ^^^ ...so that the type `T` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | impl <T: Sync + 'static> Foo for T { }\n+   |               +++++++++\n \n error: aborting due to previous error\n "}, {"sha": "7ffebab415334ea26629d5a57b452a7a4b02be29", "filename": "src/test/ui/feature-gates/feature-gate-infer_static_outlives_requirements.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-infer_static_outlives_requirements.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-infer_static_outlives_requirements.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-infer_static_outlives_requirements.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -1,8 +1,6 @@\n error[E0310]: the parameter type `U` may not live long enough\n   --> $DIR/feature-gate-infer_static_outlives_requirements.rs:5:10\n    |\n-LL | struct Foo<U> {\n-   |            - help: consider adding an explicit lifetime bound...: `U: 'static`\n LL |     bar: Bar<U>\n    |          ^^^^^^ ...so that the type `U` will meet its required lifetime bounds...\n    |\n@@ -11,6 +9,10 @@ note: ...that is required by this bound\n    |\n LL | struct Bar<T: 'static> {\n    |               ^^^^^^^\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | struct Foo<U: 'static> {\n+   |             +++++++++\n \n error: aborting due to previous error\n "}, {"sha": "a13dc043dc52bc57163e45ce321e5fd9d8663cf9", "filename": "src/test/ui/generic-associated-types/issue-86483.stderr", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-86483.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-86483.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-86483.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -1,10 +1,7 @@\n error[E0311]: the parameter type `T` may not live long enough\n   --> $DIR/issue-86483.rs:5:1\n    |\n-LL |   pub trait IceIce<T>\n-   |   ^                - help: consider adding an explicit lifetime bound...: `T: 'a`\n-   |  _|\n-   | |\n+LL | / pub trait IceIce<T>\n LL | | where\n LL | |     for<'a> T: 'a,\n LL | | {\n@@ -19,13 +16,14 @@ note: ...that is required by this bound\n    |\n LL |     for<'a> T: 'a,\n    |                ^^\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL |     for<'a> T: 'a + 'a,\n+   |                   ++++\n \n error[E0311]: the parameter type `T` may not live long enough\n   --> $DIR/issue-86483.rs:9:5\n    |\n-LL | pub trait IceIce<T>\n-   |                  - help: consider adding an explicit lifetime bound...: `T: 'a`\n-...\n LL |     type Ice<'v>: IntoIterator<Item = &'v T>;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds...\n    |\n@@ -34,6 +32,10 @@ note: ...that is required by this bound\n    |\n LL |     for<'a> T: 'a,\n    |                ^^\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL |     for<'a> T: 'a + 'a,\n+   |                   ++++\n \n error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/issue-86483.rs:9:32"}, {"sha": "b424d9a2fdb0c593beb015117848beb2b7e732cf", "filename": "src/test/ui/generic-associated-types/issue-91139.migrate.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-91139.migrate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-91139.migrate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-91139.migrate.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -1,10 +1,13 @@\n error[E0311]: the parameter type `T` may not live long enough\n   --> $DIR/issue-91139.rs:27:12\n    |\n-LL | fn foo<T>() {\n-   |        - help: consider adding an explicit lifetime bound...: `T: 'a`\n LL |     let _: for<'a> fn(<() as Foo<T>>::Type<'a>, &'a T) = |_, _| ();\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn foo<T: 'a>() {\n+   |         ++++\n \n error: aborting due to previous error\n "}, {"sha": "c74161cd3e059fb3c642069e410269e845d6e76d", "filename": "src/test/ui/generic-associated-types/issue-92096.migrate.stderr", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-92096.migrate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-92096.migrate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-92096.migrate.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -2,17 +2,23 @@ error[E0311]: the parameter type `C` may not live long enough\n   --> $DIR/issue-92096.rs:20:33\n    |\n LL | fn call_connect<C>(c: &'_ C) -> impl '_ + Future + Send\n-   |                 -               ^^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `C` will meet its required lifetime bounds\n-   |                 |\n-   |                 help: consider adding an explicit lifetime bound...: `C: 'a`\n+   |                                 ^^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `C` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL |     C: Client + Send + Sync + 'a,\n+   |                             ++++\n \n error[E0311]: the parameter type `C` may not live long enough\n   --> $DIR/issue-92096.rs:20:33\n    |\n LL | fn call_connect<C>(c: &'_ C) -> impl '_ + Future + Send\n-   |                 -               ^^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `C` will meet its required lifetime bounds\n-   |                 |\n-   |                 help: consider adding an explicit lifetime bound...: `C: 'a`\n+   |                                 ^^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `C` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL |     C: Client + Send + Sync + 'a,\n+   |                             ++++\n \n error: aborting due to 2 previous errors\n "}, {"sha": "5323ee172267f20ae4c56d2137247b4f9dbd003c", "filename": "src/test/ui/generic-associated-types/missing-bounds.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -87,10 +87,10 @@ note: tuple struct defined here\n    |\n LL | struct E<B>(B);\n    |        ^\n-help: consider further restricting type parameter `B`\n+help: consider further restricting this bound\n    |\n-LL | impl<B: Add> Add for E<B> where <B as Add>::Output = B, B: Add<Output = B> {\n-   |                                                       ++++++++++++++++++++\n+LL | impl<B: Add + Add<Output = B>> Add for E<B> where <B as Add>::Output = B {\n+   |             +++++++++++++++++\n \n error: aborting due to 5 previous errors\n "}, {"sha": "ae52010cc50a294b62579322bd234f31e2ed67ad", "filename": "src/test/ui/generic-associated-types/unsatified-item-lifetime-bound.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fgeneric-associated-types%2Funsatified-item-lifetime-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fgeneric-associated-types%2Funsatified-item-lifetime-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Funsatified-item-lifetime-bound.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -2,7 +2,7 @@ warning: unnecessary lifetime parameter `'a`\n   --> $DIR/unsatified-item-lifetime-bound.rs:4:12\n    |\n LL |     type Y<'a: 'static>;\n-   |            ^^^^^^^^^^^\n+   |            ^^\n    |\n    = help: you can use the `'static` lifetime directly, in place of `'a`\n "}, {"sha": "3e48aef553b16c8f9b987ebcd00fd23f95a56611", "filename": "src/test/ui/impl-trait/equal-hidden-lifetimes.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fimpl-trait%2Fequal-hidden-lifetimes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fimpl-trait%2Fequal-hidden-lifetimes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fequal-hidden-lifetimes.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -2,7 +2,7 @@ warning: unnecessary lifetime parameter `'a`\n   --> $DIR/equal-hidden-lifetimes.rs:7:25\n    |\n LL | fn equal_regions_static<'a: 'static>(x: &'a i32) -> impl Sized {\n-   |                         ^^^^^^^^^^^\n+   |                         ^^\n    |\n    = help: you can use the `'static` lifetime directly, in place of `'a`\n "}, {"sha": "db737a9c544c0497320ab6f868c07aba42b00112", "filename": "src/test/ui/impl-trait/must_outlive_least_region_or_bound.nll.stderr", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.nll.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -112,11 +112,13 @@ LL | fn move_lifetime_into_fn<'a, 'b>(x: &'a u32, y: &'b u32) -> impl Fn(&'a u32\n error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/must_outlive_least_region_or_bound.rs:40:5\n    |\n-LL | fn ty_param_wont_outlive_static<T:Debug>(x: T) -> impl Debug + 'static {\n-   |                                 -- help: consider adding an explicit lifetime bound...: `T: 'static +`\n-LL |\n LL |     x\n    |     ^ ...so that the type `T` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn ty_param_wont_outlive_static<T:Debug + 'static>(x: T) -> impl Debug + 'static {\n+   |                                         +++++++++\n \n error: aborting due to 9 previous errors\n "}, {"sha": "dade2b91fe0b6cfcb55cf71f03d9f59e83c1e79e", "filename": "src/test/ui/impl-trait/must_outlive_least_region_or_bound.stderr", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -128,9 +128,12 @@ error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/must_outlive_least_region_or_bound.rs:38:51\n    |\n LL | fn ty_param_wont_outlive_static<T:Debug>(x: T) -> impl Debug + 'static {\n-   |                                 --                ^^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n-   |                                 |\n-   |                                 help: consider adding an explicit lifetime bound...: `T: 'static +`\n+   |                                                   ^^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn ty_param_wont_outlive_static<T:Debug + 'static>(x: T) -> impl Debug + 'static {\n+   |                                         +++++++++\n \n error[E0759]: `x` has an anonymous lifetime `'_` but it needs to satisfy a `'static` lifetime requirement\n   --> $DIR/must_outlive_least_region_or_bound.rs:16:50"}, {"sha": "3050f10b2057d05f5d1e8f03ae1267c4e2e1447d", "filename": "src/test/ui/impl-trait/type_parameters_captured.nll.stderr", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fimpl-trait%2Ftype_parameters_captured.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fimpl-trait%2Ftype_parameters_captured.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Ftype_parameters_captured.nll.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -1,11 +1,13 @@\n error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/type_parameters_captured.rs:9:5\n    |\n-LL | fn foo<T>(x: T) -> impl Any + 'static {\n-   |        - help: consider adding an explicit lifetime bound...: `T: 'static`\n-LL |\n LL |     x\n    |     ^ ...so that the type `T` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn foo<T: 'static>(x: T) -> impl Any + 'static {\n+   |         +++++++++\n \n error: aborting due to previous error\n "}, {"sha": "9f28a8d44a7b722551ff709fc0dfc374ccfe4333", "filename": "src/test/ui/impl-trait/type_parameters_captured.stderr", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fimpl-trait%2Ftype_parameters_captured.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fimpl-trait%2Ftype_parameters_captured.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Ftype_parameters_captured.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -2,9 +2,12 @@ error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/type_parameters_captured.rs:7:20\n    |\n LL | fn foo<T>(x: T) -> impl Any + 'static {\n-   |        -           ^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n-   |        |\n-   |        help: consider adding an explicit lifetime bound...: `T: 'static`\n+   |                    ^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn foo<T: 'static>(x: T) -> impl Any + 'static {\n+   |         +++++++++\n \n error: aborting due to previous error\n "}, {"sha": "4cf634245be1b30cb7c693634dce3538dfe8a8b2", "filename": "src/test/ui/issues/issue-30438-c.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fissues%2Fissue-30438-c.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fissues%2Fissue-30438-c.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-30438-c.rs?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -5,6 +5,7 @@ trait Trait { type Out; }\n struct Test<'a> { s: &'a str }\n \n fn silly<'y, 'z>(_s: &'y Test<'z>) -> &'y <Test<'z> as Trait>::Out where 'z: 'static {\n+    //~^ WARN unnecessary lifetime parameter `'z`\n     let x = Test { s: \"this cannot last\" };\n     &x\n     //~^ ERROR: cannot return reference to local variable `x`"}, {"sha": "a7a5c0500fd236e753e93c1b12363a5a782b82b4", "filename": "src/test/ui/issues/issue-30438-c.stderr", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fissues%2Fissue-30438-c.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fissues%2Fissue-30438-c.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-30438-c.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -1,9 +1,17 @@\n+warning: unnecessary lifetime parameter `'z`\n+  --> $DIR/issue-30438-c.rs:7:74\n+   |\n+LL | fn silly<'y, 'z>(_s: &'y Test<'z>) -> &'y <Test<'z> as Trait>::Out where 'z: 'static {\n+   |                                                                          ^^\n+   |\n+   = help: you can use the `'static` lifetime directly, in place of `'z`\n+\n error[E0515]: cannot return reference to local variable `x`\n-  --> $DIR/issue-30438-c.rs:9:5\n+  --> $DIR/issue-30438-c.rs:10:5\n    |\n LL |     &x\n    |     ^^ returns a reference to data owned by the current function\n \n-error: aborting due to previous error\n+error: aborting due to previous error; 1 warning emitted\n \n For more information about this error, try `rustc --explain E0515`."}, {"sha": "33f6c498b6f35ca2f97ebcd0c6aab1d3d7c7ae51", "filename": "src/test/ui/lifetimes/lifetime-doesnt-live-long-enough.stderr", "status": "modified", "additions": 27, "deletions": 12, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Flifetimes%2Flifetime-doesnt-live-long-enough.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Flifetimes%2Flifetime-doesnt-live-long-enough.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Flifetime-doesnt-live-long-enough.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -1,18 +1,24 @@\n error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/lifetime-doesnt-live-long-enough.rs:19:10\n    |\n-LL | struct Foo<T> {\n-   |            - help: consider adding an explicit lifetime bound...: `T: 'static`\n LL |     foo: &'static T\n    |          ^^^^^^^^^^ ...so that the reference type `&'static T` does not outlive the data it points at\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | struct Foo<T: 'static> {\n+   |             +++++++++\n \n error[E0309]: the parameter type `K` may not live long enough\n   --> $DIR/lifetime-doesnt-live-long-enough.rs:24:19\n    |\n-LL | trait X<K>: Sized {\n-   |         - help: consider adding an explicit lifetime bound...: `K: 'a`\n LL |     fn foo<'a, L: X<&'a Nested<K>>>();\n    |                   ^^^^^^^^^^^^^^^^ ...so that the reference type `&'a Nested<K>` does not outlive the data it points at\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | trait X<K: 'a>: Sized {\n+   |          ++++\n \n error[E0309]: the parameter type `Self` may not live long enough\n   --> $DIR/lifetime-doesnt-live-long-enough.rs:28:19\n@@ -27,25 +33,34 @@ error[E0309]: the parameter type `L` may not live long enough\n   --> $DIR/lifetime-doesnt-live-long-enough.rs:32:22\n    |\n LL |     fn baz<'a, L, M: X<&'a Nested<L>>>() {\n-   |                -     ^^^^^^^^^^^^^^^^ ...so that the reference type `&'a Nested<L>` does not outlive the data it points at\n-   |                |\n-   |                help: consider adding an explicit lifetime bound...: `L: 'a`\n+   |                      ^^^^^^^^^^^^^^^^ ...so that the reference type `&'a Nested<L>` does not outlive the data it points at\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL |     fn baz<'a, L: 'a, M: X<&'a Nested<L>>>() {\n+   |                 ++++\n \n error[E0309]: the parameter type `K` may not live long enough\n   --> $DIR/lifetime-doesnt-live-long-enough.rs:41:33\n    |\n-LL | impl<K> Nested<K> {\n-   |      - help: consider adding an explicit lifetime bound...: `K: 'a`\n LL |     fn generic_in_parent<'a, L: X<&'a Nested<K>>>() {\n    |                                 ^^^^^^^^^^^^^^^^ ...so that the reference type `&'a Nested<K>` does not outlive the data it points at\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | impl<K: 'a> Nested<K> {\n+   |       ++++\n \n error[E0309]: the parameter type `M` may not live long enough\n   --> $DIR/lifetime-doesnt-live-long-enough.rs:44:36\n    |\n LL |     fn generic_in_child<'a, 'b, L: X<&'a Nested<M>>, M: 'b>() {\n-   |                                    ^^^^^^^^^^^^^^^^  -- help: consider adding an explicit lifetime bound...: `M: 'a +`\n-   |                                    |\n-   |                                    ...so that the reference type `&'a Nested<M>` does not outlive the data it points at\n+   |                                    ^^^^^^^^^^^^^^^^ ...so that the reference type `&'a Nested<M>` does not outlive the data it points at\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL |     fn generic_in_child<'a, 'b, L: X<&'a Nested<M>>, M: 'b + 'a>() {\n+   |                                                            ++++\n \n error: aborting due to 6 previous errors\n "}, {"sha": "2906c05864bae896970016b21481061568586408", "filename": "src/test/ui/lifetimes/lifetime-errors/issue_74400.nll.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fissue_74400.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fissue_74400.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fissue_74400.nll.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -1,10 +1,13 @@\n error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/issue_74400.rs:12:5\n    |\n-LL | fn g<T>(data: &[T]) {\n-   |      - help: consider adding an explicit lifetime bound...: `T: 'static`\n LL |     f(data, identity)\n    |     ^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn g<T: 'static>(data: &[T]) {\n+   |       +++++++++\n \n error[E0308]: mismatched types\n   --> $DIR/issue_74400.rs:12:5"}, {"sha": "ba1b745ba84229115cbcd68041bef850ab1f8fa2", "filename": "src/test/ui/moves/use_of_moved_value_copy_suggestions.fixed", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fmoves%2Fuse_of_moved_value_copy_suggestions.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fmoves%2Fuse_of_moved_value_copy_suggestions.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fuse_of_moved_value_copy_suggestions.fixed?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -54,17 +54,17 @@ where\n \n fn duplicate_custom_3<T>(t: S<T>) -> (S<T>, S<T>)\n where\n-    T: A,\n-    T: B, T: Trait, T: Copy\n-    //~^ HELP consider further restricting type parameter `T`\n+    T: A + Trait + Copy,\n+    //~^ HELP consider further restricting this bound\n+    T: B,\n {\n     (t, t) //~ use of moved value: `t`\n }\n \n-fn duplicate_custom_4<T: A>(t: S<T>) -> (S<T>, S<T>)\n+fn duplicate_custom_4<T: A + Trait + Copy>(t: S<T>) -> (S<T>, S<T>)\n+//~^ HELP consider further restricting this bound\n where\n-    T: B + Trait + Copy,\n-    //~^ HELP consider further restricting this bound\n+    T: B,\n {\n     (t, t) //~ use of moved value: `t`\n }\n@@ -77,8 +77,8 @@ fn existing_colon<T: Copy>(t: T) {\n \n fn existing_colon_in_where<T>(t: T)\n where\n-    T: Copy,\n-    //~^ HELP consider further restricting this bound\n+    T:, T: Copy\n+    //~^ HELP consider further restricting type parameter `T`\n {\n     [t, t]; //~ use of moved value: `t`\n }"}, {"sha": "0a43dd1a9a38722f42141fcf7052448fccb9f5f6", "filename": "src/test/ui/moves/use_of_moved_value_copy_suggestions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fmoves%2Fuse_of_moved_value_copy_suggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fmoves%2Fuse_of_moved_value_copy_suggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fuse_of_moved_value_copy_suggestions.rs?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -55,16 +55,16 @@ where\n fn duplicate_custom_3<T>(t: S<T>) -> (S<T>, S<T>)\n where\n     T: A,\n+    //~^ HELP consider further restricting this bound\n     T: B,\n-    //~^ HELP consider further restricting type parameter `T`\n {\n     (t, t) //~ use of moved value: `t`\n }\n \n fn duplicate_custom_4<T: A>(t: S<T>) -> (S<T>, S<T>)\n+//~^ HELP consider further restricting this bound\n where\n     T: B,\n-    //~^ HELP consider further restricting this bound\n {\n     (t, t) //~ use of moved value: `t`\n }\n@@ -78,7 +78,7 @@ fn existing_colon<T:>(t: T) {\n fn existing_colon_in_where<T>(t: T)\n where\n     T:,\n-    //~^ HELP consider further restricting this bound\n+    //~^ HELP consider further restricting type parameter `T`\n {\n     [t, t]; //~ use of moved value: `t`\n }"}, {"sha": "2353cd079a3704fab897aab06c24a99f19ae64b2", "filename": "src/test/ui/moves/use_of_moved_value_copy_suggestions.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fmoves%2Fuse_of_moved_value_copy_suggestions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fmoves%2Fuse_of_moved_value_copy_suggestions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fuse_of_moved_value_copy_suggestions.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -121,10 +121,10 @@ LL |     (t, t)\n    |      |\n    |      value moved here\n    |\n-help: consider further restricting type parameter `T`\n+help: consider further restricting this bound\n    |\n-LL |     T: B, T: Trait, T: Copy\n-   |         ~~~~~~~~~~~~~~~~~~~\n+LL |     T: A + Trait + Copy,\n+   |          ++++++++++++++\n \n error[E0382]: use of moved value: `t`\n   --> $DIR/use_of_moved_value_copy_suggestions.rs:69:9\n@@ -139,8 +139,8 @@ LL |     (t, t)\n    |\n help: consider further restricting this bound\n    |\n-LL |     T: B + Trait + Copy,\n-   |          ++++++++++++++\n+LL | fn duplicate_custom_4<T: A + Trait + Copy>(t: S<T>) -> (S<T>, S<T>)\n+   |                            ++++++++++++++\n \n error[E0382]: use of moved value: `t`\n   --> $DIR/use_of_moved_value_copy_suggestions.rs:83:9\n@@ -153,10 +153,10 @@ LL |     [t, t];\n    |      |\n    |      value moved here\n    |\n-help: consider further restricting this bound\n+help: consider further restricting type parameter `T`\n    |\n-LL |     T: Copy,\n-   |        ++++\n+LL |     T:, T: Copy\n+   |       ~~~~~~~~~\n \n error[E0382]: use of moved value: `t`\n   --> $DIR/use_of_moved_value_copy_suggestions.rs:75:9"}, {"sha": "08605efa2ea9cba750e333d96162a8f7754f1d13", "filename": "src/test/ui/nll/closure-requirements/propagate-from-trait-match.stderr", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-from-trait-match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-from-trait-match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-from-trait-match.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -36,9 +36,6 @@ LL | | }\n error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/propagate-from-trait-match.rs:32:36\n    |\n-LL |   fn supply<'a, T>(value: T)\n-   |                 - help: consider adding an explicit lifetime bound...: `T: 'a`\n-...\n LL |       establish_relationships(value, |value| {\n    |  ____________________________________^\n LL | |\n@@ -48,6 +45,11 @@ LL | |         // This function call requires that\n LL | |         require(value);\n LL | |     });\n    | |_____^ ...so that the type `T` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL |     T: Trait<'a> + 'a,\n+   |                  ++++\n \n error: aborting due to previous error\n "}, {"sha": "64b08a9b32fb31be779fe6e03bdd398eb525cbd6", "filename": "src/test/ui/nll/ty-outlives/impl-trait-outlives.stderr", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-outlives.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-outlives.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-outlives.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -1,20 +1,24 @@\n error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/impl-trait-outlives.rs:11:5\n    |\n-LL | fn no_region<'a, T>(x: Box<T>) -> impl Debug + 'a\n-   |                  - help: consider adding an explicit lifetime bound...: `T: 'a`\n-...\n LL |     x\n    |     ^ ...so that the type `T` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL |     T: Debug + 'a,\n+   |              ++++\n \n error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/impl-trait-outlives.rs:26:5\n    |\n-LL | fn wrong_region<'a, 'b, T>(x: Box<T>) -> impl Debug + 'a\n-   |                         - help: consider adding an explicit lifetime bound...: `T: 'a`\n-...\n LL |     x\n    |     ^ ...so that the type `T` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL |     T: 'b + Debug + 'a,\n+   |                   ++++\n \n error: aborting due to 2 previous errors\n "}, {"sha": "3b9b2956c5183b47571f1f6561107e44d25280f2", "filename": "src/test/ui/nll/ty-outlives/projection-implied-bounds.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-implied-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-implied-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-implied-bounds.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -1,10 +1,13 @@\n error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/projection-implied-bounds.rs:30:18\n    |\n-LL | fn generic2<T: Iterator>(value: T) {\n-   |             -- help: consider adding an explicit lifetime bound...: `T: 'static +`\n LL |     twice(value, |value_ref, item| invoke2(value_ref, item));\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn generic2<T: Iterator + 'static>(value: T) {\n+   |                         +++++++++\n \n error: aborting due to previous error\n "}, {"sha": "caf2e3c47475564a69ef1dda33abc380a417441f", "filename": "src/test/ui/nll/ty-outlives/projection-one-region-closure.stderr", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -31,11 +31,13 @@ LL | | }\n error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/projection-one-region-closure.rs:45:29\n    |\n-LL | fn no_relationships_late<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n-   |                                  - help: consider adding an explicit lifetime bound...: `T: 'a`\n-...\n LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL |     T: Anything<'b> + 'a,\n+   |                     ++++\n \n error: lifetime may not live long enough\n   --> $DIR/projection-one-region-closure.rs:45:39\n@@ -82,11 +84,13 @@ LL | | }\n error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/projection-one-region-closure.rs:56:29\n    |\n-LL | fn no_relationships_early<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n-   |                                   - help: consider adding an explicit lifetime bound...: `T: 'a`\n-...\n LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL |     T: Anything<'b> + 'a,\n+   |                     ++++\n \n error: lifetime may not live long enough\n   --> $DIR/projection-one-region-closure.rs:56:39"}, {"sha": "e28b89580bc4c346d3ad310eeb4d06edc5855fa5", "filename": "src/test/ui/nll/ty-outlives/projection-where-clause-none.stderr", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-where-clause-none.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-where-clause-none.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-where-clause-none.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -1,11 +1,13 @@\n error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/projection-where-clause-none.rs:16:5\n    |\n-LL | fn foo<'a, T>() -> &'a ()\n-   |            - help: consider adding an explicit lifetime bound...: `T: 'a`\n-...\n LL |     bar::<T::Output>()\n    |     ^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL |     T: MyTrait<'a> + 'a,\n+   |                    ++++\n \n error: aborting due to previous error\n "}, {"sha": "a4588730b3f8746d26c3dd1fb51e944509012405", "filename": "src/test/ui/nll/ty-outlives/ty-param-closure-approximate-lower-bound.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-approximate-lower-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-approximate-lower-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-approximate-lower-bound.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -52,10 +52,13 @@ LL | | }\n error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/ty-param-closure-approximate-lower-bound.rs:29:24\n    |\n-LL | fn generic_fail<'a, T>(cell: Cell<&'a ()>, value: T) {\n-   |                     - help: consider adding an explicit lifetime bound...: `T: 'a`\n LL |     twice(cell, value, |a, b| invoke(a, b));\n    |                        ^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn generic_fail<'a, T: 'a>(cell: Cell<&'a ()>, value: T) {\n+   |                      ++++\n \n error: aborting due to previous error\n "}, {"sha": "084dd93cb86b9b3376312c46d03ea202a0c201f9", "filename": "src/test/ui/nll/ty-outlives/ty-param-closure-outlives-from-return-type.stderr", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-return-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-return-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-return-type.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -29,20 +29,24 @@ LL | | }\n error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/ty-param-closure-outlives-from-return-type.rs:26:23\n    |\n-LL | fn no_region<'a, T>(x: Box<T>) -> Box<dyn Debug + 'a>\n-   |                  - help: consider adding an explicit lifetime bound...: `T: 'a`\n-...\n LL |     with_signature(x, |y| y)\n    |                       ^^^^^ ...so that the type `T` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL |     T: Debug + 'a,\n+   |              ++++\n \n error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/ty-param-closure-outlives-from-return-type.rs:41:5\n    |\n-LL | fn wrong_region<'a, 'b, T>(x: Box<T>) -> Box<Debug + 'a>\n-   |                         - help: consider adding an explicit lifetime bound...: `T: 'a`\n-...\n LL |     x\n    |     ^ ...so that the type `T` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL |     T: 'b + Debug + 'a,\n+   |                   ++++\n \n error: aborting due to 2 previous errors\n "}, {"sha": "11a737ba291f06670be5603f2556d8a35b27a795", "filename": "src/test/ui/nll/ty-outlives/ty-param-closure-outlives-from-where-clause.stderr", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-where-clause.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-where-clause.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-where-clause.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -37,8 +37,6 @@ LL | | }\n error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/ty-param-closure-outlives-from-where-clause.rs:27:26\n    |\n-LL |   fn no_region<'a, T>(a: Cell<&'a ()>, b: T) {\n-   |                    - help: consider adding an explicit lifetime bound...: `T: 'a`\n LL |       with_signature(a, b, |x, y| {\n    |  __________________________^\n LL | |\n@@ -48,6 +46,11 @@ LL | |         // See `correct_region`, which explains the point of this\n LL | |         require(&x, &y)\n LL | |     })\n    | |_____^ ...so that the type `T` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn no_region<'a, T: 'a>(a: Cell<&'a ()>, b: T) {\n+   |                   ++++\n \n note: external requirements\n   --> $DIR/ty-param-closure-outlives-from-where-clause.rs:43:26\n@@ -121,16 +124,18 @@ LL | | }\n error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/ty-param-closure-outlives-from-where-clause.rs:64:26\n    |\n-LL |   fn wrong_region<'a, 'b, T>(a: Cell<&'a ()>, b: T)\n-   |                           - help: consider adding an explicit lifetime bound...: `T: 'a`\n-...\n LL |       with_signature(a, b, |x, y| {\n    |  __________________________^\n LL | |\n LL | |         // See `correct_region`\n LL | |         require(&x, &y)\n LL | |     })\n    | |_____^ ...so that the type `T` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL |     T: 'b + 'a,\n+   |           ++++\n \n note: external requirements\n   --> $DIR/ty-param-closure-outlives-from-where-clause.rs:77:26"}, {"sha": "ba79137d18d8cb832aff363bd90bbd1bb454041c", "filename": "src/test/ui/nll/ty-outlives/ty-param-fn-body.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-fn-body.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-fn-body.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-fn-body.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -1,10 +1,13 @@\n error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/ty-param-fn-body.rs:19:5\n    |\n-LL | fn region_static<'a, T>(cell: Cell<&'a usize>, t: T) {\n-   |                      - help: consider adding an explicit lifetime bound...: `T: 'a`\n LL |     outlives(cell, t)\n    |     ^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn region_static<'a, T: 'a>(cell: Cell<&'a usize>, t: T) {\n+   |                       ++++\n \n error: aborting due to previous error\n "}, {"sha": "729f14d84adafe589b634a595fecd98057070b9e", "filename": "src/test/ui/nll/ty-outlives/ty-param-fn.stderr", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-fn.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -1,20 +1,24 @@\n error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/ty-param-fn.rs:11:5\n    |\n-LL | fn no_region<'a, T>(x: Box<T>) -> Box<Debug + 'a>\n-   |                  - help: consider adding an explicit lifetime bound...: `T: 'a`\n-...\n LL |     x\n    |     ^ ...so that the type `T` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL |     T: Debug + 'a,\n+   |              ++++\n \n error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/ty-param-fn.rs:26:5\n    |\n-LL | fn wrong_region<'a, 'b, T>(x: Box<T>) -> Box<Debug + 'a>\n-   |                         - help: consider adding an explicit lifetime bound...: `T: 'a`\n-...\n LL |     x\n    |     ^ ...so that the type `T` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL |     T: 'b + Debug + 'a,\n+   |                   ++++\n \n error: aborting due to 2 previous errors\n "}, {"sha": "66d3102225ecc809ddd2885266ee3829ca184791", "filename": "src/test/ui/regions/regions-close-object-into-object-4.nll.stderr", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-4.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-4.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-4.nll.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -1,26 +1,35 @@\n error[E0310]: the parameter type `U` may not live long enough\n   --> $DIR/regions-close-object-into-object-4.rs:13:5\n    |\n-LL | fn i<'a, T, U>(v: Box<dyn A<U>+'a>) -> Box<dyn X + 'static> {\n-   |             - help: consider adding an explicit lifetime bound...: `U: 'static`\n LL |     Box::new(B(&*v)) as Box<dyn X>\n    |     ^^^^^^^^ ...so that the type `U` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn i<'a, T, U: 'static>(v: Box<dyn A<U>+'a>) -> Box<dyn X + 'static> {\n+   |              +++++++++\n \n error[E0310]: the parameter type `U` may not live long enough\n   --> $DIR/regions-close-object-into-object-4.rs:13:5\n    |\n-LL | fn i<'a, T, U>(v: Box<dyn A<U>+'a>) -> Box<dyn X + 'static> {\n-   |             - help: consider adding an explicit lifetime bound...: `U: 'static`\n LL |     Box::new(B(&*v)) as Box<dyn X>\n    |     ^^^^^^^^^^^^^^^^ ...so that the type `U` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn i<'a, T, U: 'static>(v: Box<dyn A<U>+'a>) -> Box<dyn X + 'static> {\n+   |              +++++++++\n \n error[E0310]: the parameter type `U` may not live long enough\n   --> $DIR/regions-close-object-into-object-4.rs:13:5\n    |\n-LL | fn i<'a, T, U>(v: Box<dyn A<U>+'a>) -> Box<dyn X + 'static> {\n-   |             - help: consider adding an explicit lifetime bound...: `U: 'static`\n LL |     Box::new(B(&*v)) as Box<dyn X>\n    |     ^^^^^^^^^^^^^^^^ ...so that the type `U` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn i<'a, T, U: 'static>(v: Box<dyn A<U>+'a>) -> Box<dyn X + 'static> {\n+   |              +++++++++\n \n error: lifetime may not live long enough\n   --> $DIR/regions-close-object-into-object-4.rs:13:5\n@@ -51,10 +60,13 @@ LL |     Box::new(B(&*v)) as Box<dyn X>\n error[E0310]: the parameter type `U` may not live long enough\n   --> $DIR/regions-close-object-into-object-4.rs:13:14\n    |\n-LL | fn i<'a, T, U>(v: Box<dyn A<U>+'a>) -> Box<dyn X + 'static> {\n-   |             - help: consider adding an explicit lifetime bound...: `U: 'static`\n LL |     Box::new(B(&*v)) as Box<dyn X>\n    |              ^^^^^^ ...so that the type `U` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn i<'a, T, U: 'static>(v: Box<dyn A<U>+'a>) -> Box<dyn X + 'static> {\n+   |              +++++++++\n \n error: aborting due to 6 previous errors\n "}, {"sha": "1a78079b638d8c17025d1c7326ad8c6b5f9bc301", "filename": "src/test/ui/regions/regions-close-object-into-object-5.base.stderr", "status": "modified", "additions": 32, "deletions": 21, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-5.base.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-5.base.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-5.base.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -1,9 +1,6 @@\n error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/regions-close-object-into-object-5.rs:21:5\n    |\n-LL | fn f<'a, T, U>(v: Box<A<T> + 'static>) -> Box<X + 'static> {\n-   |          - help: consider adding an explicit lifetime bound...: `T: 'static`\n-LL |     // oh dear!\n LL |     Box::new(B(&*v)) as Box<dyn X>\n    |     ^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds...\n    |\n@@ -12,22 +9,25 @@ note: ...that is required by this bound\n    |\n LL | struct B<'a, T: 'a>(&'a (A<T> + 'a));\n    |                 ^^\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn f<'a, T: 'static, U>(v: Box<A<T> + 'static>) -> Box<X + 'static> {\n+   |           +++++++++\n \n error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/regions-close-object-into-object-5.rs:21:5\n    |\n-LL | fn f<'a, T, U>(v: Box<A<T> + 'static>) -> Box<X + 'static> {\n-   |          - help: consider adding an explicit lifetime bound...: `T: 'static`\n-LL |     // oh dear!\n LL |     Box::new(B(&*v)) as Box<dyn X>\n    |     ^^^^^^^^^^^^^^^^ ...so that the type `B<'_, T>` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn f<'a, T: 'static, U>(v: Box<A<T> + 'static>) -> Box<X + 'static> {\n+   |           +++++++++\n \n error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/regions-close-object-into-object-5.rs:21:14\n    |\n-LL | fn f<'a, T, U>(v: Box<A<T> + 'static>) -> Box<X + 'static> {\n-   |          - help: consider adding an explicit lifetime bound...: `T: 'static`\n-LL |     // oh dear!\n LL |     Box::new(B(&*v)) as Box<dyn X>\n    |              ^ ...so that the type `T` will meet its required lifetime bounds...\n    |\n@@ -36,13 +36,14 @@ note: ...that is required by this bound\n    |\n LL | struct B<'a, T: 'a>(&'a (A<T> + 'a));\n    |                 ^^\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn f<'a, T: 'static, U>(v: Box<A<T> + 'static>) -> Box<X + 'static> {\n+   |           +++++++++\n \n error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/regions-close-object-into-object-5.rs:21:14\n    |\n-LL | fn f<'a, T, U>(v: Box<A<T> + 'static>) -> Box<X + 'static> {\n-   |          - help: consider adding an explicit lifetime bound...: `T: 'static`\n-LL |     // oh dear!\n LL |     Box::new(B(&*v)) as Box<dyn X>\n    |              ^^^^^^ ...so that the type `T` will meet its required lifetime bounds...\n    |\n@@ -51,33 +52,43 @@ note: ...that is required by this bound\n    |\n LL | struct B<'a, T: 'a>(&'a (A<T> + 'a));\n    |                 ^^\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn f<'a, T: 'static, U>(v: Box<A<T> + 'static>) -> Box<X + 'static> {\n+   |           +++++++++\n \n error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/regions-close-object-into-object-5.rs:21:16\n    |\n-LL | fn f<'a, T, U>(v: Box<A<T> + 'static>) -> Box<X + 'static> {\n-   |          - help: consider adding an explicit lifetime bound...: `T: 'static`\n-LL |     // oh dear!\n LL |     Box::new(B(&*v)) as Box<dyn X>\n    |                ^^^ ...so that the reference type `&dyn A<T>` does not outlive the data it points at\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn f<'a, T: 'static, U>(v: Box<A<T> + 'static>) -> Box<X + 'static> {\n+   |           +++++++++\n \n error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/regions-close-object-into-object-5.rs:21:16\n    |\n-LL | fn f<'a, T, U>(v: Box<A<T> + 'static>) -> Box<X + 'static> {\n-   |          - help: consider adding an explicit lifetime bound...: `T: 'static`\n-LL |     // oh dear!\n LL |     Box::new(B(&*v)) as Box<dyn X>\n    |                ^^^ ...so that the type `(dyn A<T> + 'static)` is not borrowed for too long\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn f<'a, T: 'static, U>(v: Box<A<T> + 'static>) -> Box<X + 'static> {\n+   |           +++++++++\n \n error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/regions-close-object-into-object-5.rs:21:16\n    |\n-LL | fn f<'a, T, U>(v: Box<A<T> + 'static>) -> Box<X + 'static> {\n-   |          - help: consider adding an explicit lifetime bound...: `T: 'static`\n-LL |     // oh dear!\n LL |     Box::new(B(&*v)) as Box<dyn X>\n    |                ^^^ ...so that the type `(dyn A<T> + 'static)` is not borrowed for too long\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn f<'a, T: 'static, U>(v: Box<A<T> + 'static>) -> Box<X + 'static> {\n+   |           +++++++++\n \n error: aborting due to 7 previous errors\n "}, {"sha": "cb06326130e10c800b602f19670685e7359eb101", "filename": "src/test/ui/regions/regions-close-object-into-object-5.nll.stderr", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-5.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-5.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-5.nll.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -1,29 +1,35 @@\n error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/regions-close-object-into-object-5.rs:21:5\n    |\n-LL | fn f<'a, T, U>(v: Box<A<T> + 'static>) -> Box<X + 'static> {\n-   |          - help: consider adding an explicit lifetime bound...: `T: 'static`\n-LL |     // oh dear!\n LL |     Box::new(B(&*v)) as Box<dyn X>\n    |     ^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn f<'a, T: 'static, U>(v: Box<A<T> + 'static>) -> Box<X + 'static> {\n+   |           +++++++++\n \n error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/regions-close-object-into-object-5.rs:21:5\n    |\n-LL | fn f<'a, T, U>(v: Box<A<T> + 'static>) -> Box<X + 'static> {\n-   |          - help: consider adding an explicit lifetime bound...: `T: 'static`\n-LL |     // oh dear!\n LL |     Box::new(B(&*v)) as Box<dyn X>\n    |     ^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn f<'a, T: 'static, U>(v: Box<A<T> + 'static>) -> Box<X + 'static> {\n+   |           +++++++++\n \n error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/regions-close-object-into-object-5.rs:21:5\n    |\n-LL | fn f<'a, T, U>(v: Box<A<T> + 'static>) -> Box<X + 'static> {\n-   |          - help: consider adding an explicit lifetime bound...: `T: 'static`\n-LL |     // oh dear!\n LL |     Box::new(B(&*v)) as Box<dyn X>\n    |     ^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn f<'a, T: 'static, U>(v: Box<A<T> + 'static>) -> Box<X + 'static> {\n+   |           +++++++++\n \n error[E0515]: cannot return value referencing local data `*v`\n   --> $DIR/regions-close-object-into-object-5.rs:21:5\n@@ -37,11 +43,13 @@ LL |     Box::new(B(&*v)) as Box<dyn X>\n error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/regions-close-object-into-object-5.rs:21:14\n    |\n-LL | fn f<'a, T, U>(v: Box<A<T> + 'static>) -> Box<X + 'static> {\n-   |          - help: consider adding an explicit lifetime bound...: `T: 'static`\n-LL |     // oh dear!\n LL |     Box::new(B(&*v)) as Box<dyn X>\n    |              ^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn f<'a, T: 'static, U>(v: Box<A<T> + 'static>) -> Box<X + 'static> {\n+   |           +++++++++\n \n error: aborting due to 5 previous errors\n "}, {"sha": "d8f77ad85c96689ee50f0832f0a0ceca864e22bd", "filename": "src/test/ui/regions/regions-close-over-type-parameter-1.base.stderr", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fregions%2Fregions-close-over-type-parameter-1.base.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fregions%2Fregions-close-over-type-parameter-1.base.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-close-over-type-parameter-1.base.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -1,18 +1,24 @@\n error[E0310]: the parameter type `A` may not live long enough\n   --> $DIR/regions-close-over-type-parameter-1.rs:15:5\n    |\n-LL | fn make_object1<A: SomeTrait>(v: A) -> Box<dyn SomeTrait + 'static> {\n-   |                 -- help: consider adding an explicit lifetime bound...: `A: 'static +`\n LL |     Box::new(v) as Box<dyn SomeTrait + 'static>\n    |     ^^^^^^^^^^^ ...so that the type `A` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn make_object1<A: SomeTrait + 'static>(v: A) -> Box<dyn SomeTrait + 'static> {\n+   |                              +++++++++\n \n error[E0309]: the parameter type `A` may not live long enough\n   --> $DIR/regions-close-over-type-parameter-1.rs:24:5\n    |\n-LL | fn make_object3<'a, 'b, A: SomeTrait + 'a>(v: A) -> Box<dyn SomeTrait + 'b> {\n-   |                         -- help: consider adding an explicit lifetime bound...: `A: 'b +`\n LL |     Box::new(v) as Box<dyn SomeTrait + 'b>\n    |     ^^^^^^^^^^^ ...so that the type `A` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn make_object3<'a, 'b, A: SomeTrait + 'a + 'b>(v: A) -> Box<dyn SomeTrait + 'b> {\n+   |                                           ++++\n \n error: aborting due to 2 previous errors\n "}, {"sha": "d8f77ad85c96689ee50f0832f0a0ceca864e22bd", "filename": "src/test/ui/regions/regions-close-over-type-parameter-1.nll.stderr", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fregions%2Fregions-close-over-type-parameter-1.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fregions%2Fregions-close-over-type-parameter-1.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-close-over-type-parameter-1.nll.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -1,18 +1,24 @@\n error[E0310]: the parameter type `A` may not live long enough\n   --> $DIR/regions-close-over-type-parameter-1.rs:15:5\n    |\n-LL | fn make_object1<A: SomeTrait>(v: A) -> Box<dyn SomeTrait + 'static> {\n-   |                 -- help: consider adding an explicit lifetime bound...: `A: 'static +`\n LL |     Box::new(v) as Box<dyn SomeTrait + 'static>\n    |     ^^^^^^^^^^^ ...so that the type `A` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn make_object1<A: SomeTrait + 'static>(v: A) -> Box<dyn SomeTrait + 'static> {\n+   |                              +++++++++\n \n error[E0309]: the parameter type `A` may not live long enough\n   --> $DIR/regions-close-over-type-parameter-1.rs:24:5\n    |\n-LL | fn make_object3<'a, 'b, A: SomeTrait + 'a>(v: A) -> Box<dyn SomeTrait + 'b> {\n-   |                         -- help: consider adding an explicit lifetime bound...: `A: 'b +`\n LL |     Box::new(v) as Box<dyn SomeTrait + 'b>\n    |     ^^^^^^^^^^^ ...so that the type `A` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn make_object3<'a, 'b, A: SomeTrait + 'a + 'b>(v: A) -> Box<dyn SomeTrait + 'b> {\n+   |                                           ++++\n \n error: aborting due to 2 previous errors\n "}, {"sha": "79a5d34dea89d73a1fd4ff3b6c2071a5d3756915", "filename": "src/test/ui/regions/regions-close-param-into-object.base.stderr", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fregions%2Fregions-close-param-into-object.base.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fregions%2Fregions-close-param-into-object.base.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-close-param-into-object.base.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -1,38 +1,46 @@\n error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/regions-close-param-into-object.rs:10:5\n    |\n-LL | fn p1<T>(v: T) -> Box<dyn X + 'static>\n-   |       - help: consider adding an explicit lifetime bound...: `T: 'static`\n-...\n LL |     Box::new(v)\n    |     ^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL |     where T : X + 'static\n+   |                 +++++++++\n \n error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/regions-close-param-into-object.rs:16:5\n    |\n-LL | fn p2<T>(v: Box<T>) -> Box<dyn X + 'static>\n-   |       - help: consider adding an explicit lifetime bound...: `T: 'static`\n-...\n LL |     Box::new(v)\n    |     ^^^^^^^^^^^ ...so that the type `Box<T>` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn p2<T: 'static>(v: Box<T>) -> Box<dyn X + 'static>\n+   |        +++++++++\n \n error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/regions-close-param-into-object.rs:22:5\n    |\n-LL | fn p3<'a,T>(v: T) -> Box<dyn X + 'a>\n-   |          - help: consider adding an explicit lifetime bound...: `T: 'a`\n-...\n LL |     Box::new(v)\n    |     ^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL |     where T : X + 'a\n+   |                 ++++\n \n error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/regions-close-param-into-object.rs:28:5\n    |\n-LL | fn p4<'a,T>(v: Box<T>) -> Box<dyn X + 'a>\n-   |          - help: consider adding an explicit lifetime bound...: `T: 'a`\n-...\n LL |     Box::new(v)\n    |     ^^^^^^^^^^^ ...so that the type `Box<T>` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn p4<'a,T: 'a>(v: Box<T>) -> Box<dyn X + 'a>\n+   |           ++++\n \n error: aborting due to 4 previous errors\n "}, {"sha": "6ee12d5b82c6910add9eeb26b46481bd34fef3ba", "filename": "src/test/ui/regions/regions-close-param-into-object.nll.stderr", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fregions%2Fregions-close-param-into-object.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fregions%2Fregions-close-param-into-object.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-close-param-into-object.nll.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -1,38 +1,46 @@\n error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/regions-close-param-into-object.rs:10:5\n    |\n-LL | fn p1<T>(v: T) -> Box<dyn X + 'static>\n-   |       - help: consider adding an explicit lifetime bound...: `T: 'static`\n-...\n LL |     Box::new(v)\n    |     ^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL |     where T : X + 'static\n+   |                 +++++++++\n \n error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/regions-close-param-into-object.rs:16:5\n    |\n-LL | fn p2<T>(v: Box<T>) -> Box<dyn X + 'static>\n-   |       - help: consider adding an explicit lifetime bound...: `T: 'static`\n-...\n LL |     Box::new(v)\n    |     ^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn p2<T: 'static>(v: Box<T>) -> Box<dyn X + 'static>\n+   |        +++++++++\n \n error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/regions-close-param-into-object.rs:22:5\n    |\n-LL | fn p3<'a,T>(v: T) -> Box<dyn X + 'a>\n-   |          - help: consider adding an explicit lifetime bound...: `T: 'a`\n-...\n LL |     Box::new(v)\n    |     ^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL |     where T : X + 'a\n+   |                 ++++\n \n error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/regions-close-param-into-object.rs:28:5\n    |\n-LL | fn p4<'a,T>(v: Box<T>) -> Box<dyn X + 'a>\n-   |          - help: consider adding an explicit lifetime bound...: `T: 'a`\n-...\n LL |     Box::new(v)\n    |     ^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn p4<'a,T: 'a>(v: Box<T>) -> Box<dyn X + 'a>\n+   |           ++++\n \n error: aborting due to 4 previous errors\n "}, {"sha": "7c2e1aeeea619bcabc9b2be24e855afac37af61c", "filename": "src/test/ui/regions/regions-free-region-outlives-static-outlives-free-region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fregions%2Fregions-free-region-outlives-static-outlives-free-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fregions%2Fregions-free-region-outlives-static-outlives-free-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-free-region-outlives-static-outlives-free-region.rs?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -9,7 +9,7 @@\n //     'a : 'b\n \n fn test<'a,'b>(x: &'a i32) -> &'b i32\n-    where 'a: 'static\n+    where 'a: 'static //~ WARN unnecessary lifetime parameter `'a`\n {\n     x\n }"}, {"sha": "70ed418d5cbbb4802b9cb0198409d6ee8061cf94", "filename": "src/test/ui/regions/regions-free-region-outlives-static-outlives-free-region.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fregions%2Fregions-free-region-outlives-static-outlives-free-region.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fregions%2Fregions-free-region-outlives-static-outlives-free-region.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-free-region-outlives-static-outlives-free-region.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -0,0 +1,10 @@\n+warning: unnecessary lifetime parameter `'a`\n+  --> $DIR/regions-free-region-outlives-static-outlives-free-region.rs:12:11\n+   |\n+LL |     where 'a: 'static\n+   |           ^^\n+   |\n+   = help: you can use the `'static` lifetime directly, in place of `'a`\n+\n+warning: 1 warning emitted\n+"}, {"sha": "85ced4b524111532e5f6be5939a93f19ef21c0e3", "filename": "src/test/ui/regions/regions-implied-bounds-projection-gap-1.base.stderr", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fregions%2Fregions-implied-bounds-projection-gap-1.base.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fregions%2Fregions-implied-bounds-projection-gap-1.base.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-implied-bounds-projection-gap-1.base.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -1,11 +1,13 @@\n error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/regions-implied-bounds-projection-gap-1.rs:20:10\n    |\n-LL | fn func<'x, T:Trait1<'x>>(t: &'x T::Foo)\n-   |             -- help: consider adding an explicit lifetime bound...: `T: 'x +`\n-LL | {\n LL |     wf::<&'x T>();\n    |          ^^^^^ ...so that the reference type `&'x T` does not outlive the data it points at\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn func<'x, T:Trait1<'x> + 'x>(t: &'x T::Foo)\n+   |                          ++++\n \n error: aborting due to previous error\n "}, {"sha": "1a428eb25d7d0a1c17d47e0143e1662ba62e085c", "filename": "src/test/ui/regions/regions-implied-bounds-projection-gap-1.nll.stderr", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fregions%2Fregions-implied-bounds-projection-gap-1.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fregions%2Fregions-implied-bounds-projection-gap-1.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-implied-bounds-projection-gap-1.nll.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -1,11 +1,13 @@\n error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/regions-implied-bounds-projection-gap-1.rs:20:5\n    |\n-LL | fn func<'x, T:Trait1<'x>>(t: &'x T::Foo)\n-   |             -- help: consider adding an explicit lifetime bound...: `T: 'x +`\n-LL | {\n LL |     wf::<&'x T>();\n    |     ^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn func<'x, T:Trait1<'x> + 'x>(t: &'x T::Foo)\n+   |                          ++++\n \n error: aborting due to previous error\n "}, {"sha": "658740f3f871c2c3db7ad448d3b95f6ea66cf9f4", "filename": "src/test/ui/regions/regions-infer-bound-from-trait.base.stderr", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fregions%2Fregions-infer-bound-from-trait.base.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fregions%2Fregions-infer-bound-from-trait.base.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-infer-bound-from-trait.base.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -1,8 +1,6 @@\n error[E0309]: the parameter type `A` may not live long enough\n   --> $DIR/regions-infer-bound-from-trait.rs:37:5\n    |\n-LL | fn bar1<'a,A>(x: Inv<'a>, a: A) {\n-   |            - help: consider adding an explicit lifetime bound...: `A: 'a`\n LL |     check_bound(x, a)\n    |     ^^^^^^^^^^^ ...so that the type `A` will meet its required lifetime bounds...\n    |\n@@ -11,12 +9,14 @@ note: ...that is required by this bound\n    |\n LL | fn check_bound<'a,A:'a>(x: Inv<'a>, a: A) { }\n    |                     ^^\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn bar1<'a,A: 'a>(x: Inv<'a>, a: A) {\n+   |             ++++\n \n error[E0309]: the parameter type `A` may not live long enough\n   --> $DIR/regions-infer-bound-from-trait.rs:41:5\n    |\n-LL | fn bar2<'a,'b,A:Is<'b>>(x: Inv<'a>, y: Inv<'b>, a: A) {\n-   |               -- help: consider adding an explicit lifetime bound...: `A: 'a +`\n LL |     check_bound(x, a)\n    |     ^^^^^^^^^^^ ...so that the type `A` will meet its required lifetime bounds...\n    |\n@@ -25,6 +25,10 @@ note: ...that is required by this bound\n    |\n LL | fn check_bound<'a,A:'a>(x: Inv<'a>, a: A) { }\n    |                     ^^\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn bar2<'a,'b,A:Is<'b> + 'a>(x: Inv<'a>, y: Inv<'b>, a: A) {\n+   |                        ++++\n \n error: aborting due to 2 previous errors\n "}, {"sha": "5cc2d20c2e0d16129b5c59fa2c0bfe5898815ffa", "filename": "src/test/ui/regions/regions-infer-bound-from-trait.nll.stderr", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fregions%2Fregions-infer-bound-from-trait.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fregions%2Fregions-infer-bound-from-trait.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-infer-bound-from-trait.nll.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -1,18 +1,24 @@\n error[E0309]: the parameter type `A` may not live long enough\n   --> $DIR/regions-infer-bound-from-trait.rs:37:5\n    |\n-LL | fn bar1<'a,A>(x: Inv<'a>, a: A) {\n-   |            - help: consider adding an explicit lifetime bound...: `A: 'a`\n LL |     check_bound(x, a)\n    |     ^^^^^^^^^^^^^^^^^ ...so that the type `A` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn bar1<'a,A: 'a>(x: Inv<'a>, a: A) {\n+   |             ++++\n \n error[E0309]: the parameter type `A` may not live long enough\n   --> $DIR/regions-infer-bound-from-trait.rs:41:5\n    |\n-LL | fn bar2<'a,'b,A:Is<'b>>(x: Inv<'a>, y: Inv<'b>, a: A) {\n-   |               -- help: consider adding an explicit lifetime bound...: `A: 'a +`\n LL |     check_bound(x, a)\n    |     ^^^^^^^^^^^^^^^^^ ...so that the type `A` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn bar2<'a,'b,A:Is<'b> + 'a>(x: Inv<'a>, y: Inv<'b>, a: A) {\n+   |                        ++++\n \n error: aborting due to 2 previous errors\n "}, {"sha": "25232b455b687329e69a19a16f5cbd0692ff9be3", "filename": "src/test/ui/regions/regions-static-bound-rpass.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fregions%2Fregions-static-bound-rpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fregions%2Fregions-static-bound-rpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-static-bound-rpass.rs?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -1,10 +1,17 @@\n // run-pass\n+\n fn invariant_id<'a,'b>(t: &'b mut &'static ()) -> &'b mut &'a ()\n     where 'a: 'static { t }\n+//~^ WARN unnecessary lifetime parameter `'a`\n+\n fn static_id<'a>(t: &'a ()) -> &'static ()\n     where 'a: 'static { t }\n+//~^ WARN unnecessary lifetime parameter `'a`\n+\n fn static_id_indirect<'a,'b>(t: &'a ()) -> &'static ()\n     where 'a: 'b, 'b: 'static { t }\n+//~^ WARN unnecessary lifetime parameter `'b`\n+\n fn ref_id<'a>(t: &'a ()) -> &'a () where 'static: 'a { t }\n \n static UNIT: () = ();"}, {"sha": "9355a409d5099a733e0e2eebccf711d595e7ec4c", "filename": "src/test/ui/regions/regions-static-bound-rpass.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fregions%2Fregions-static-bound-rpass.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fregions%2Fregions-static-bound-rpass.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-static-bound-rpass.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -0,0 +1,26 @@\n+warning: unnecessary lifetime parameter `'a`\n+  --> $DIR/regions-static-bound-rpass.rs:4:11\n+   |\n+LL |     where 'a: 'static { t }\n+   |           ^^\n+   |\n+   = help: you can use the `'static` lifetime directly, in place of `'a`\n+\n+warning: unnecessary lifetime parameter `'a`\n+  --> $DIR/regions-static-bound-rpass.rs:8:11\n+   |\n+LL |     where 'a: 'static { t }\n+   |           ^^\n+   |\n+   = help: you can use the `'static` lifetime directly, in place of `'a`\n+\n+warning: unnecessary lifetime parameter `'b`\n+  --> $DIR/regions-static-bound-rpass.rs:12:19\n+   |\n+LL |     where 'a: 'b, 'b: 'static { t }\n+   |                   ^^\n+   |\n+   = help: you can use the `'static` lifetime directly, in place of `'b`\n+\n+warning: 3 warnings emitted\n+"}, {"sha": "6b8120444d067a5c56f796c771250624764f3c15", "filename": "src/test/ui/regions/regions-static-bound.base.stderr", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fregions%2Fregions-static-bound.base.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fregions%2Fregions-static-bound.base.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-static-bound.base.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -1,32 +1,48 @@\n+warning: unnecessary lifetime parameter `'a`\n+  --> $DIR/regions-static-bound.rs:6:11\n+   |\n+LL |     where 'a: 'static { t }\n+   |           ^^\n+   |\n+   = help: you can use the `'static` lifetime directly, in place of `'a`\n+\n+warning: unnecessary lifetime parameter `'b`\n+  --> $DIR/regions-static-bound.rs:10:19\n+   |\n+LL |     where 'a: 'b, 'b: 'static { t }\n+   |                   ^^\n+   |\n+   = help: you can use the `'static` lifetime directly, in place of `'b`\n+\n error[E0312]: lifetime of reference outlives lifetime of borrowed content...\n-  --> $DIR/regions-static-bound.rs:10:5\n+  --> $DIR/regions-static-bound.rs:14:5\n    |\n LL |     t\n    |     ^\n    |\n    = note: ...the reference is valid for the static lifetime...\n note: ...but the borrowed content is only valid for the lifetime `'a` as defined here\n-  --> $DIR/regions-static-bound.rs:9:24\n+  --> $DIR/regions-static-bound.rs:13:24\n    |\n LL | fn static_id_wrong_way<'a>(t: &'a ()) -> &'static () where 'static: 'a {\n    |                        ^^\n \n error[E0759]: `u` has an anonymous lifetime `'_` but it needs to satisfy a `'static` lifetime requirement\n-  --> $DIR/regions-static-bound.rs:16:5\n+  --> $DIR/regions-static-bound.rs:20:5\n    |\n LL | fn error(u: &(), v: &()) {\n    |             --- this data with an anonymous lifetime `'_`...\n LL |     static_id(&u);\n    |     ^^^^^^^^^ -- ...is used here...\n    |\n note: ...and is required to live as long as `'static` here\n-  --> $DIR/regions-static-bound.rs:16:5\n+  --> $DIR/regions-static-bound.rs:20:5\n    |\n LL |     static_id(&u);\n    |     ^^^^^^^^^\n \n error[E0759]: `v` has an anonymous lifetime `'_` but it needs to satisfy a `'static` lifetime requirement\n-  --> $DIR/regions-static-bound.rs:19:5\n+  --> $DIR/regions-static-bound.rs:23:5\n    |\n LL | fn error(u: &(), v: &()) {\n    |                     --- this data with an anonymous lifetime `'_`...\n@@ -35,12 +51,12 @@ LL |     static_id_indirect(&v);\n    |     ^^^^^^^^^^^^^^^^^^ -- ...is used here...\n    |\n note: ...and is required to live as long as `'static` here\n-  --> $DIR/regions-static-bound.rs:19:5\n+  --> $DIR/regions-static-bound.rs:23:5\n    |\n LL |     static_id_indirect(&v);\n    |     ^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 3 previous errors; 2 warnings emitted\n \n Some errors have detailed explanations: E0312, E0759.\n For more information about an error, try `rustc --explain E0312`."}, {"sha": "68e36f3aeea8f514fe2513f9d5de1126fac48e24", "filename": "src/test/ui/regions/regions-static-bound.nll.stderr", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fregions%2Fregions-static-bound.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fregions%2Fregions-static-bound.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-static-bound.nll.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -1,13 +1,29 @@\n+warning: unnecessary lifetime parameter `'a`\n+  --> $DIR/regions-static-bound.rs:6:11\n+   |\n+LL |     where 'a: 'static { t }\n+   |           ^^\n+   |\n+   = help: you can use the `'static` lifetime directly, in place of `'a`\n+\n+warning: unnecessary lifetime parameter `'b`\n+  --> $DIR/regions-static-bound.rs:10:19\n+   |\n+LL |     where 'a: 'b, 'b: 'static { t }\n+   |                   ^^\n+   |\n+   = help: you can use the `'static` lifetime directly, in place of `'b`\n+\n error: lifetime may not live long enough\n-  --> $DIR/regions-static-bound.rs:10:5\n+  --> $DIR/regions-static-bound.rs:14:5\n    |\n LL | fn static_id_wrong_way<'a>(t: &'a ()) -> &'static () where 'static: 'a {\n    |                        -- lifetime `'a` defined here\n LL |     t\n    |     ^ returning this value requires that `'a` must outlive `'static`\n \n error[E0521]: borrowed data escapes outside of function\n-  --> $DIR/regions-static-bound.rs:16:5\n+  --> $DIR/regions-static-bound.rs:20:5\n    |\n LL | fn error(u: &(), v: &()) {\n    |          -  - let's call the lifetime of this reference `'1`\n@@ -20,7 +36,7 @@ LL |     static_id(&u);\n    |     argument requires that `'1` must outlive `'static`\n \n error[E0521]: borrowed data escapes outside of function\n-  --> $DIR/regions-static-bound.rs:19:5\n+  --> $DIR/regions-static-bound.rs:23:5\n    |\n LL | fn error(u: &(), v: &()) {\n    |                  -  - let's call the lifetime of this reference `'2`\n@@ -33,6 +49,6 @@ LL |     static_id_indirect(&v);\n    |     `v` escapes the function body here\n    |     argument requires that `'2` must outlive `'static`\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 3 previous errors; 2 warnings emitted\n \n For more information about this error, try `rustc --explain E0521`."}, {"sha": "1eed7e71745d8f3877c6ba8e7f1b7a415d235274", "filename": "src/test/ui/regions/regions-static-bound.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fregions%2Fregions-static-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fregions%2Fregions-static-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-static-bound.rs?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -4,8 +4,12 @@\n \n fn static_id<'a,'b>(t: &'a ()) -> &'static ()\n     where 'a: 'static { t }\n+//~^ WARN unnecessary lifetime parameter `'a`\n+\n fn static_id_indirect<'a,'b>(t: &'a ()) -> &'static ()\n     where 'a: 'b, 'b: 'static { t }\n+//~^ WARN unnecessary lifetime parameter `'b`\n+\n fn static_id_wrong_way<'a>(t: &'a ()) -> &'static () where 'static: 'a {\n     t\n     //[base]~^ ERROR E0312"}, {"sha": "950ffd6c89bd31ed2757c2d17d1a95b7ba628562", "filename": "src/test/ui/rfc-2093-infer-outlives/dont-infer-static.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fdont-infer-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fdont-infer-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fdont-infer-static.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -1,8 +1,6 @@\n error[E0310]: the parameter type `U` may not live long enough\n   --> $DIR/dont-infer-static.rs:8:10\n    |\n-LL | struct Foo<U> {\n-   |            - help: consider adding an explicit lifetime bound...: `U: 'static`\n LL |     bar: Bar<U>\n    |          ^^^^^^ ...so that the type `U` will meet its required lifetime bounds...\n    |\n@@ -11,6 +9,10 @@ note: ...that is required by this bound\n    |\n LL | struct Bar<T: 'static> {\n    |               ^^^^^^^\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | struct Foo<U: 'static> {\n+   |             +++++++++\n \n error: aborting due to previous error\n "}, {"sha": "2c660b285009723961eadea6d1dc5f120a019de9", "filename": "src/test/ui/rfc-2093-infer-outlives/regions-enum-not-wf.stderr", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fregions-enum-not-wf.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fregions-enum-not-wf.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fregions-enum-not-wf.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -1,27 +1,35 @@\n error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/regions-enum-not-wf.rs:17:18\n    |\n-LL | enum Ref1<'a, T> {\n-   |               - help: consider adding an explicit lifetime bound...: `T: 'a`\n LL |     Ref1Variant1(RequireOutlives<'a, T>),\n    |                  ^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | enum Ref1<'a, T: 'a> {\n+   |                ++++\n \n error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/regions-enum-not-wf.rs:22:25\n    |\n-LL | enum Ref2<'a, T> {\n-   |               - help: consider adding an explicit lifetime bound...: `T: 'a`\n-LL |     Ref2Variant1,\n LL |     Ref2Variant2(isize, RequireOutlives<'a, T>),\n    |                         ^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | enum Ref2<'a, T: 'a> {\n+   |                ++++\n \n error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/regions-enum-not-wf.rs:35:23\n    |\n-LL | enum RefDouble<'a, 'b, T> {\n-   |                        - help: consider adding an explicit lifetime bound...: `T: 'b`\n LL |     RefDoubleVariant1(&'a RequireOutlives<'b, T>),\n    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | enum RefDouble<'a, 'b, T: 'b> {\n+   |                         ++++\n \n error: aborting due to 3 previous errors\n "}, {"sha": "34ff1362cf32336d3d2dd1f441cbc848c6784129", "filename": "src/test/ui/rfc-2093-infer-outlives/regions-struct-not-wf.stderr", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fregions-struct-not-wf.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fregions-struct-not-wf.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fregions-struct-not-wf.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -1,16 +1,17 @@\n error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/regions-struct-not-wf.rs:13:16\n    |\n-LL | impl<'a, T> Trait<'a, T> for usize {\n-   |          - help: consider adding an explicit lifetime bound...: `T: 'a`\n LL |     type Out = &'a T;\n    |                ^^^^^ ...so that the reference type `&'a T` does not outlive the data it points at\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | impl<'a, T: 'a> Trait<'a, T> for usize {\n+   |           ++++\n \n error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/regions-struct-not-wf.rs:21:16\n    |\n-LL | impl<'a, T> Trait<'a, T> for u32 {\n-   |          - help: consider adding an explicit lifetime bound...: `T: 'a`\n LL |     type Out = RefOk<'a, T>;\n    |                ^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds...\n    |\n@@ -19,6 +20,10 @@ note: ...that is required by this bound\n    |\n LL | struct RefOk<'a, T:'a> {\n    |                    ^^\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | impl<'a, T: 'a> Trait<'a, T> for u32 {\n+   |           ++++\n \n error[E0491]: in type `&'a &'b T`, reference has a longer lifetime than the data it references\n   --> $DIR/regions-struct-not-wf.rs:25:16"}, {"sha": "ef07a89315f4088ddd653b649a5e0d8cf1f99fd3", "filename": "src/test/ui/static/static-lifetime-bound.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fstatic%2Fstatic-lifetime-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fstatic%2Fstatic-lifetime-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstatic%2Fstatic-lifetime-bound.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -2,7 +2,7 @@ warning: unnecessary lifetime parameter `'a`\n   --> $DIR/static-lifetime-bound.rs:1:6\n    |\n LL | fn f<'a: 'static>(_: &'a i32) {}\n-   |      ^^^^^^^^^^^\n+   |      ^^\n    |\n    = help: you can use the `'static` lifetime directly, in place of `'a`\n "}, {"sha": "17a019c69849f0174b014633b8da9dc65e765497", "filename": "src/test/ui/suggestions/bound-suggestions.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fsuggestions%2Fbound-suggestions.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fsuggestions%2Fbound-suggestions.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fbound-suggestions.fixed?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -35,7 +35,7 @@ fn test_one_bound_where<X>(x: X) where X: Sized + std::fmt::Debug {\n }\n \n #[allow(dead_code)]\n-fn test_many_bounds_where<X>(x: X) where X: Sized, X: Sized, X: std::fmt::Debug {\n+fn test_many_bounds_where<X>(x: X) where X: Sized + std::fmt::Debug, X: Sized {\n     println!(\"{:?}\", x);\n     //~^ ERROR doesn't implement\n }"}, {"sha": "e5e19444d2435c3a5796c9f194ffdb65d679d96b", "filename": "src/test/ui/suggestions/bound-suggestions.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fsuggestions%2Fbound-suggestions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fsuggestions%2Fbound-suggestions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fbound-suggestions.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -65,10 +65,10 @@ LL |     println!(\"{:?}\", x);\n    |                      ^ `X` cannot be formatted using `{:?}` because it doesn't implement `Debug`\n    |\n    = note: this error originates in the macro `$crate::format_args_nl` (in Nightly builds, run with -Z macro-backtrace for more info)\n-help: consider further restricting type parameter `X`\n+help: consider further restricting this bound\n    |\n-LL | fn test_many_bounds_where<X>(x: X) where X: Sized, X: Sized, X: std::fmt::Debug {\n-   |                                                            ++++++++++++++++++++\n+LL | fn test_many_bounds_where<X>(x: X) where X: Sized + std::fmt::Debug, X: Sized {\n+   |                                                   +++++++++++++++++\n \n error[E0277]: the size for values of type `Self` cannot be known at compilation time\n   --> $DIR/bound-suggestions.rs:44:46"}, {"sha": "8ec7b7bf496581e19e3436cef18e3172f91f76d6", "filename": "src/test/ui/suggestions/impl-trait-with-missing-trait-bounds-in-arg.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-trait-with-missing-trait-bounds-in-arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-trait-with-missing-trait-bounds-in-arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-trait-with-missing-trait-bounds-in-arg.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -8,7 +8,7 @@ LL |     foo.hello();\n help: the following trait defines an item `hello`, perhaps you need to restrict type parameter `impl Foo` with it:\n    |\n LL | fn test(foo: impl Foo + Bar) {\n-   |              ~~~~~~~~~~~~~~\n+   |                       +++++\n \n error: aborting due to previous error\n "}, {"sha": "0a4aaa61bc784cfc3b441d853e8b6c377831d8aa", "filename": "src/test/ui/suggestions/issue-21673.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fsuggestions%2Fissue-21673.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fsuggestions%2Fissue-21673.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-21673.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -7,8 +7,8 @@ LL |     x.method()\n    = help: items from traits can only be used if the type parameter is bounded by the trait\n help: the following trait defines an item `method`, perhaps you need to restrict type parameter `T` with it:\n    |\n-LL | fn call_method<T: Foo + std::fmt::Debug>(x: &T) {\n-   |                ~~~~~~~~\n+LL | fn call_method<T: std::fmt::Debug + Foo>(x: &T) {\n+   |                                   +++++\n \n error[E0599]: no method named `method` found for type parameter `T` in the current scope\n   --> $DIR/issue-21673.rs:10:7\n@@ -20,7 +20,7 @@ LL |     x.method()\n help: the following trait defines an item `method`, perhaps you need to restrict type parameter `T` with it:\n    |\n LL | fn call_method_2<T: Foo>(x: T) {\n-   |                  ~~~~~~\n+   |                   +++++\n \n error: aborting due to 2 previous errors\n "}, {"sha": "0212c2d712cb35014746a94f5dfd360780b3fdd8", "filename": "src/test/ui/suggestions/lifetimes/missing-lifetimes-in-signature-2.nll.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature-2.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature-2.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature-2.nll.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -1,8 +1,6 @@\n error[E0311]: the parameter type `T` may not live long enough\n   --> $DIR/missing-lifetimes-in-signature-2.rs:20:5\n    |\n-LL |   fn func<T: Test>(foo: &Foo, t: T) {\n-   |           -- help: consider adding an explicit lifetime bound...: `T: 'a +`\n LL | /     foo.bar(move |_| {\n LL | |\n LL | |         t.test();\n@@ -22,6 +20,10 @@ LL | |\n LL | |         t.test();\n LL | |     });\n    | |______^\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn func<T: Test + 'a>(foo: &Foo, t: T) {\n+   |                 ++++\n \n error: aborting due to previous error\n "}, {"sha": "5d195e5ff32f76eabfe1a4834151edba0b2d8ade", "filename": "src/test/ui/suggestions/lifetimes/missing-lifetimes-in-signature-2.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature-2.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -1,8 +1,6 @@\n error[E0311]: the parameter type `T` may not live long enough\n   --> $DIR/missing-lifetimes-in-signature-2.rs:20:9\n    |\n-LL | fn func<T: Test>(foo: &Foo, t: T) {\n-   |         -- help: consider adding an explicit lifetime bound...: `T: 'a +`\n LL |     foo.bar(move |_| {\n    |         ^^^\n    |\n@@ -21,6 +19,10 @@ note: ...that is required by this bound\n    |\n LL |         F: 'a,\n    |            ^^\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn func<T: Test + 'a>(foo: &Foo, t: T) {\n+   |                 ++++\n \n error: aborting due to previous error\n "}, {"sha": "24eac64d334da81934e311cbb4b0fb74eaa795b3", "filename": "src/test/ui/suggestions/lifetimes/missing-lifetimes-in-signature.nll.stderr", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.nll.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -26,9 +26,6 @@ LL | fn foo<G, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n error[E0311]: the parameter type `G` may not live long enough\n   --> $DIR/missing-lifetimes-in-signature.rs:31:5\n    |\n-LL |   fn bar<G, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n-   |          - help: consider adding an explicit lifetime bound...: `G: 'a`\n-...\n LL | /     move || {\n LL | |         *dest = g.get();\n LL | |     }\n@@ -46,13 +43,14 @@ LL | /     move || {\n LL | |         *dest = g.get();\n LL | |     }\n    | |_____^\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL |     G: Get<T> + 'a,\n+   |               ++++\n \n error[E0311]: the parameter type `G` may not live long enough\n   --> $DIR/missing-lifetimes-in-signature.rs:53:5\n    |\n-LL |   fn qux<'a, G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n-   |              -- help: consider adding an explicit lifetime bound...: `G: 'b +`\n-...\n LL | /     move || {\n LL | |         *dest = g.get();\n LL | |     }\n@@ -70,13 +68,14 @@ LL | /     move || {\n LL | |         *dest = g.get();\n LL | |     }\n    | |_____^\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn qux<'a, G: 'a + 'b, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+   |                  ++++\n \n error[E0311]: the parameter type `G` may not live long enough\n   --> $DIR/missing-lifetimes-in-signature.rs:62:9\n    |\n-LL |       fn qux<'b, G: Get<T> + 'b, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ {\n-   |                  -- help: consider adding an explicit lifetime bound...: `G: 'c +`\n-LL |\n LL | /         move || {\n LL | |             *dest = g.get();\n LL | |         }\n@@ -94,13 +93,14 @@ LL | /         move || {\n LL | |             *dest = g.get();\n LL | |         }\n    | |_________^\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL |     fn qux<'b, G: Get<T> + 'b + 'c, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ {\n+   |                               ++++\n \n error[E0311]: the parameter type `G` may not live long enough\n   --> $DIR/missing-lifetimes-in-signature.rs:74:5\n    |\n-LL |   fn bat<'a, G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ + 'a\n-   |              -- help: consider adding an explicit lifetime bound...: `G: 'b +`\n-...\n LL | /     move || {\n LL | |         *dest = g.get();\n LL | |     }\n@@ -118,6 +118,10 @@ LL | /     move || {\n LL | |         *dest = g.get();\n LL | |     }\n    | |_____^\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn bat<'a, G: 'a + 'b, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ + 'a\n+   |                  ++++\n \n error[E0621]: explicit lifetime required in the type of `dest`\n   --> $DIR/missing-lifetimes-in-signature.rs:74:5\n@@ -133,13 +137,15 @@ LL | |     }\n error[E0309]: the parameter type `G` may not live long enough\n   --> $DIR/missing-lifetimes-in-signature.rs:85:5\n    |\n-LL |   fn bak<'a, G, T>(g: G, dest: &'a mut T) -> impl FnOnce() + 'a\n-   |              - help: consider adding an explicit lifetime bound...: `G: 'a`\n-...\n LL | /     move || {\n LL | |         *dest = g.get();\n LL | |     }\n    | |_____^ ...so that the type `G` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL |     G: Get<T> + 'a,\n+   |               ++++\n \n error: aborting due to 8 previous errors\n "}, {"sha": "ae9a020a099f49c1ba175f597a63656493878ba2", "filename": "src/test/ui/suggestions/lifetimes/missing-lifetimes-in-signature.stderr", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -41,8 +41,11 @@ LL | fn bar<G, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n    |                                     ^^^^^^^^^^^^^^^^^^\n help: consider introducing an explicit lifetime bound\n    |\n-LL | fn bar<'a, G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ + 'a\n-   |        ~~~~~                                                   ++++\n+LL ~ fn bar<'a, G, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ + 'a\n+LL |\n+LL | where\n+LL ~     G: Get<T> + 'a,\n+   |\n \n error[E0311]: the parameter type `G` may not live long enough\n   --> $DIR/missing-lifetimes-in-signature.rs:48:45\n@@ -62,8 +65,8 @@ LL | fn qux<'a, G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n    |                                             ^^^^^^^^^^^^^^^^^^\n help: consider introducing an explicit lifetime bound\n    |\n-LL | fn qux<'b, 'a, G: 'b + 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ + 'b\n-   |        +++     ~~~~~~~                                                  ++++\n+LL | fn qux<'b, 'a, G: 'a + 'b, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ + 'b\n+   |        +++           ++++                                               ++++\n \n error[E0311]: the parameter type `G` may not live long enough\n   --> $DIR/missing-lifetimes-in-signature.rs:60:58\n@@ -83,8 +86,8 @@ LL |     fn qux<'b, G: Get<T> + 'b, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n    |                                                          ^^^^^^^^^^^^^^^^^^\n help: consider introducing an explicit lifetime bound\n    |\n-LL |     fn qux<'c, 'b, G: 'c + Get<T> + 'b, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ + 'c {\n-   |            +++     ~~~~~~~                                                           ++++\n+LL |     fn qux<'c, 'b, G: Get<T> + 'b + 'c, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ + 'c {\n+   |            +++                    ++++                                               ++++\n \n error[E0621]: explicit lifetime required in the type of `dest`\n   --> $DIR/missing-lifetimes-in-signature.rs:69:45\n@@ -98,9 +101,12 @@ error[E0309]: the parameter type `G` may not live long enough\n   --> $DIR/missing-lifetimes-in-signature.rs:80:44\n    |\n LL | fn bak<'a, G, T>(g: G, dest: &'a mut T) -> impl FnOnce() + 'a\n-   |            -                               ^^^^^^^^^^^^^^^^^^ ...so that the type `[closure@$DIR/missing-lifetimes-in-signature.rs:85:5: 87:6]` will meet its required lifetime bounds\n-   |            |\n-   |            help: consider adding an explicit lifetime bound...: `G: 'a`\n+   |                                            ^^^^^^^^^^^^^^^^^^ ...so that the type `[closure@$DIR/missing-lifetimes-in-signature.rs:85:5: 87:6]` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL |     G: Get<T> + 'a,\n+   |               ++++\n \n error: aborting due to 7 previous errors\n "}, {"sha": "01c2de7986419bed90a66cdce1f833ae9c503c4f", "filename": "src/test/ui/suggestions/restrict-type-argument.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fsuggestions%2Frestrict-type-argument.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fsuggestions%2Frestrict-type-argument.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Frestrict-type-argument.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -85,8 +85,8 @@ LL | fn is_send<T: Send>(val: T) {}\n    |               ^^^^ required by this bound in `is_send`\n help: consider further restricting this bound\n    |\n-LL | fn use_bound_and_where<S: Sync>(val: S) where S: std::fmt::Debug + std::marker::Send {\n-   |                                                                  +++++++++++++++++++\n+LL | fn use_bound_and_where<S: Sync + std::marker::Send>(val: S) where S: std::fmt::Debug {\n+   |                                +++++++++++++++++++\n \n error[E0277]: `S` cannot be sent between threads safely\n   --> $DIR/restrict-type-argument.rs:28:13"}, {"sha": "cf912f4aac201284d87fd333382496edb3dfcdd3", "filename": "src/test/ui/suggestions/suggest-impl-trait-lifetime.nll.stderr", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-impl-trait-lifetime.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-impl-trait-lifetime.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-impl-trait-lifetime.nll.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -1,11 +1,13 @@\n error[E0310]: the parameter type `impl Debug` may not live long enough\n   --> $DIR/suggest-impl-trait-lifetime.rs:7:5\n    |\n-LL | fn foo(d: impl Debug) {\n-   |           ---------- help: consider adding an explicit lifetime bound...: `impl Debug + 'static`\n-LL |\n LL |     bar(d);\n    |     ^^^^^^ ...so that the type `impl Debug` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn foo(d: impl Debug + 'static) {\n+   |                      +++++++++\n \n error: aborting due to previous error\n "}, {"sha": "4a99c3a14d7bbc9c7146e4fa36553e7e3c51f4fc", "filename": "src/test/ui/suggestions/suggest-impl-trait-lifetime.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-impl-trait-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-impl-trait-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-impl-trait-lifetime.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -1,9 +1,6 @@\n error[E0310]: the parameter type `impl Debug` may not live long enough\n   --> $DIR/suggest-impl-trait-lifetime.rs:7:5\n    |\n-LL | fn foo(d: impl Debug) {\n-   |           ---------- help: consider adding an explicit lifetime bound...: `impl Debug + 'static`\n-LL |\n LL |     bar(d);\n    |     ^^^ ...so that the type `impl Debug` will meet its required lifetime bounds...\n    |\n@@ -12,6 +9,10 @@ note: ...that is required by this bound\n    |\n LL | fn bar(d: impl Debug + 'static) {\n    |                        ^^^^^^^\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn foo(d: impl Debug + 'static) {\n+   |                      +++++++++\n \n error: aborting due to previous error\n "}, {"sha": "35d41c6266761680735097ff32e80c8418f3ad32", "filename": "src/test/ui/traits/issue-65284-suggest-generic-trait-bound.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Ftraits%2Fissue-65284-suggest-generic-trait-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Ftraits%2Fissue-65284-suggest-generic-trait-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fissue-65284-suggest-generic-trait-bound.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -7,8 +7,8 @@ LL |     t.foo()\n    = help: items from traits can only be used if the type parameter is bounded by the trait\n help: the following trait defines an item `foo`, perhaps you need to restrict type parameter `T` with it:\n    |\n-LL | fn do_stuff<T: Foo + Bar>(t : T) {\n-   |             ~~~~~~~~\n+LL | fn do_stuff<T : Bar + Foo>(t : T) {\n+   |                     +++++\n \n error: aborting due to previous error\n "}, {"sha": "0a58ad4b663eb3ee4174c802dbd289308bae4bfa", "filename": "src/test/ui/traits/issue-95898.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Ftraits%2Fissue-95898.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Ftraits%2Fissue-95898.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fissue-95898.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -8,7 +8,7 @@ LL |     t.clone();\n help: the following trait defines an item `clone`, perhaps you need to restrict type parameter `T` with it:\n    |\n LL | fn foo<T: Clone>(t: T) {\n-   |        ~~~~~~~~\n+   |           +++++\n \n error: aborting due to previous error\n "}, {"sha": "920eef11da4b993dcdf66fb168602371b8145781", "filename": "src/test/ui/type-alias-impl-trait/bounds-are-checked.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbounds-are-checked.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbounds-are-checked.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbounds-are-checked.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -2,7 +2,7 @@ warning: unnecessary lifetime parameter `'a`\n   --> $DIR/bounds-are-checked.rs:8:6\n    |\n LL | fn f<'a: 'static>(t: &'a str) -> X<'a> {\n-   |      ^^^^^^^^^^^\n+   |      ^^\n    |\n    = help: you can use the `'static` lifetime directly, in place of `'a`\n "}, {"sha": "593fb8af32f30400a1ce4f9bf9ed41a335b876a2", "filename": "src/test/ui/type-alias-impl-trait/generic_type_does_not_live_long_enough.base.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.base.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.base.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.base.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -19,10 +19,13 @@ LL | type WrongGeneric<T> = impl 'static;\n error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/generic_type_does_not_live_long_enough.rs:18:5\n    |\n-LL | fn wrong_generic<T>(t: T) -> WrongGeneric<T> {\n-   |                  - help: consider adding an explicit lifetime bound...: `T: 'static`\n LL |     t\n    |     ^ ...so that the type `T` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn wrong_generic<T: 'static>(t: T) -> WrongGeneric<T> {\n+   |                   +++++++++\n \n error: aborting due to 3 previous errors\n "}, {"sha": "593fb8af32f30400a1ce4f9bf9ed41a335b876a2", "filename": "src/test/ui/type-alias-impl-trait/generic_type_does_not_live_long_enough.nll.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.nll.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -19,10 +19,13 @@ LL | type WrongGeneric<T> = impl 'static;\n error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/generic_type_does_not_live_long_enough.rs:18:5\n    |\n-LL | fn wrong_generic<T>(t: T) -> WrongGeneric<T> {\n-   |                  - help: consider adding an explicit lifetime bound...: `T: 'static`\n LL |     t\n    |     ^ ...so that the type `T` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn wrong_generic<T: 'static>(t: T) -> WrongGeneric<T> {\n+   |                   +++++++++\n \n error: aborting due to 3 previous errors\n "}, {"sha": "b9d4857a3efde0d57ab0c92a8657a27e86377e9b", "filename": "src/test/ui/wf/wf-impl-associated-type-region.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fwf%2Fwf-impl-associated-type-region.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fwf%2Fwf-impl-associated-type-region.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-impl-associated-type-region.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -1,10 +1,13 @@\n error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/wf-impl-associated-type-region.rs:10:16\n    |\n-LL | impl<'a, T> Foo<'a> for T {\n-   |          - help: consider adding an explicit lifetime bound...: `T: 'a`\n LL |     type Bar = &'a T;\n    |                ^^^^^ ...so that the reference type `&'a T` does not outlive the data it points at\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | impl<'a, T: 'a> Foo<'a> for T {\n+   |           ++++\n \n error: aborting due to previous error\n "}, {"sha": "73fbb9ca670b021cfb77b75010ea08c39b4a9353", "filename": "src/test/ui/wf/wf-in-fn-type-static.stderr", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fwf%2Fwf-in-fn-type-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fwf%2Fwf-in-fn-type-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-in-fn-type-static.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -1,20 +1,24 @@\n error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/wf-in-fn-type-static.rs:13:8\n    |\n-LL | struct Foo<T> {\n-   |            - help: consider adding an explicit lifetime bound...: `T: 'static`\n-LL |     // needs T: 'static\n LL |     x: fn() -> &'static T\n    |        ^^^^^^^^^^^^^^^^^^ ...so that the reference type `&'static T` does not outlive the data it points at\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | struct Foo<T: 'static> {\n+   |             +++++++++\n \n error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/wf-in-fn-type-static.rs:18:8\n    |\n-LL | struct Bar<T> {\n-   |            - help: consider adding an explicit lifetime bound...: `T: 'static`\n-LL |     // needs T: Copy\n LL |     x: fn(&'static T)\n    |        ^^^^^^^^^^^^^^ ...so that the reference type `&'static T` does not outlive the data it points at\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | struct Bar<T: 'static> {\n+   |             +++++++++\n \n error: aborting due to 2 previous errors\n "}, {"sha": "c3ad42dd5d5ac0b878d73dbafb76c8daf45230d6", "filename": "src/test/ui/wf/wf-in-obj-type-static.stderr", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fwf%2Fwf-in-obj-type-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fwf%2Fwf-in-obj-type-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-in-obj-type-static.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -1,11 +1,13 @@\n error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/wf-in-obj-type-static.rs:14:8\n    |\n-LL | struct Foo<T> {\n-   |            - help: consider adding an explicit lifetime bound...: `T: 'static`\n-LL |     // needs T: 'static\n LL |     x: dyn Object<&'static T>\n    |        ^^^^^^^^^^^^^^^^^^^^^^ ...so that the reference type `&'static T` does not outlive the data it points at\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | struct Foo<T: 'static> {\n+   |             +++++++++\n \n error: aborting due to previous error\n "}, {"sha": "4d4d8b2ab4d463e1d12e783828a001e6a1873c56", "filename": "src/test/ui/wf/wf-outlives-ty-in-fn-or-trait.stderr", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fwf%2Fwf-outlives-ty-in-fn-or-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftest%2Fui%2Fwf%2Fwf-outlives-ty-in-fn-or-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-outlives-ty-in-fn-or-trait.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -1,18 +1,24 @@\n error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/wf-outlives-ty-in-fn-or-trait.rs:9:16\n    |\n-LL | impl<'a, T> Trait<'a, T> for usize {\n-   |          - help: consider adding an explicit lifetime bound...: `T: 'a`\n LL |     type Out = &'a fn(T);\n    |                ^^^^^^^^^ ...so that the reference type `&'a fn(T)` does not outlive the data it points at\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | impl<'a, T: 'a> Trait<'a, T> for usize {\n+   |           ++++\n \n error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/wf-outlives-ty-in-fn-or-trait.rs:19:16\n    |\n-LL | impl<'a, T> Trait<'a, T> for u32 {\n-   |          - help: consider adding an explicit lifetime bound...: `T: 'a`\n LL |     type Out = &'a dyn Baz<T>;\n    |                ^^^^^^^^^^^^^^ ...so that the reference type `&'a (dyn Baz<T> + 'a)` does not outlive the data it points at\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | impl<'a, T: 'a> Trait<'a, T> for u32 {\n+   |           ++++\n \n error: aborting due to 2 previous errors\n "}, {"sha": "662a561f171e91c49450f05d4818ff68ce973531", "filename": "src/tools/clippy/clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 33, "deletions": 28, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -8,7 +8,7 @@ use rustc_hir::FnRetTy::Return;\n use rustc_hir::{\n     BareFnTy, BodyId, FnDecl, GenericArg, GenericBound, GenericParam, GenericParamKind, Generics, ImplItem,\n     ImplItemKind, Item, ItemKind, LangItem, Lifetime, LifetimeName, ParamName, PolyTraitRef, TraitBoundModifier,\n-    TraitFn, TraitItem, TraitItemKind, Ty, TyKind, WhereClause, WherePredicate,\n+    TraitFn, TraitItem, TraitItemKind, Ty, TyKind, WherePredicate,\n };\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -130,7 +130,7 @@ fn check_fn_inner<'tcx>(\n     span: Span,\n     report_extra_lifetimes: bool,\n ) {\n-    if span.from_expansion() || has_where_lifetimes(cx, &generics.where_clause) {\n+    if span.from_expansion() || has_where_lifetimes(cx, generics) {\n         return;\n     }\n \n@@ -139,28 +139,35 @@ fn check_fn_inner<'tcx>(\n         .iter()\n         .filter(|param| matches!(param.kind, GenericParamKind::Type { .. }));\n     for typ in types {\n-        for bound in typ.bounds {\n-            let mut visitor = RefVisitor::new(cx);\n-            walk_param_bound(&mut visitor, bound);\n-            if visitor.lts.iter().any(|lt| matches!(lt, RefLt::Named(_))) {\n-                return;\n+        for pred in generics.bounds_for_param(cx.tcx.hir().local_def_id(typ.hir_id)) {\n+            if pred.in_where_clause {\n+                // has_where_lifetimes checked that this predicate contains no lifetime.\n+                continue;\n             }\n-            if let GenericBound::Trait(ref trait_ref, _) = *bound {\n-                let params = &trait_ref\n-                    .trait_ref\n-                    .path\n-                    .segments\n-                    .last()\n-                    .expect(\"a path must have at least one segment\")\n-                    .args;\n-                if let Some(params) = *params {\n-                    let lifetimes = params.args.iter().filter_map(|arg| match arg {\n-                        GenericArg::Lifetime(lt) => Some(lt),\n-                        _ => None,\n-                    });\n-                    for bound in lifetimes {\n-                        if bound.name != LifetimeName::Static && !bound.is_elided() {\n-                            return;\n+\n+            for bound in pred.bounds {\n+                let mut visitor = RefVisitor::new(cx);\n+                walk_param_bound(&mut visitor, bound);\n+                if visitor.lts.iter().any(|lt| matches!(lt, RefLt::Named(_))) {\n+                    return;\n+                }\n+                if let GenericBound::Trait(ref trait_ref, _) = *bound {\n+                    let params = &trait_ref\n+                        .trait_ref\n+                        .path\n+                        .segments\n+                        .last()\n+                        .expect(\"a path must have at least one segment\")\n+                        .args;\n+                    if let Some(params) = *params {\n+                        let lifetimes = params.args.iter().filter_map(|arg| match arg {\n+                            GenericArg::Lifetime(lt) => Some(lt),\n+                            _ => None,\n+                        });\n+                        for bound in lifetimes {\n+                            if bound.name != LifetimeName::Static && !bound.is_elided() {\n+                                return;\n+                            }\n                         }\n                     }\n                 }\n@@ -322,9 +329,7 @@ fn allowed_lts_from(named_generics: &[GenericParam<'_>]) -> FxHashSet<RefLt> {\n     let mut allowed_lts = FxHashSet::default();\n     for par in named_generics.iter() {\n         if let GenericParamKind::Lifetime { .. } = par.kind {\n-            if par.bounds.is_empty() {\n-                allowed_lts.insert(RefLt::Named(par.name.ident().name));\n-            }\n+            allowed_lts.insert(RefLt::Named(par.name.ident().name));\n         }\n     }\n     allowed_lts.insert(RefLt::Unnamed);\n@@ -445,8 +450,8 @@ impl<'a, 'tcx> Visitor<'tcx> for RefVisitor<'a, 'tcx> {\n \n /// Are any lifetimes mentioned in the `where` clause? If so, we don't try to\n /// reason about elision.\n-fn has_where_lifetimes<'tcx>(cx: &LateContext<'tcx>, where_clause: &'tcx WhereClause<'_>) -> bool {\n-    for predicate in where_clause.predicates {\n+fn has_where_lifetimes<'tcx>(cx: &LateContext<'tcx>, generics: &'tcx Generics<'_>) -> bool {\n+    for predicate in generics.predicates {\n         match *predicate {\n             WherePredicate::RegionPredicate(..) => return true,\n             WherePredicate::BoundPredicate(ref pred) => {"}, {"sha": "96c00c205ff2e9401e0589e1a9786fb47c2c2356", "filename": "src/tools/clippy/clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnew_without_default.rs?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -68,7 +68,7 @@ impl<'tcx> LateLintPass<'tcx> for NewWithoutDefault {\n             ..\n         }) = item.kind\n         {\n-            for assoc_item in items {\n+            for assoc_item in *items {\n                 if assoc_item.kind == (hir::AssocItemKind::Fn { has_self: false }) {\n                     let impl_item = cx.tcx.hir().impl_item(assoc_item.id);\n                     if in_external_macro(cx.sess(), impl_item.span) {"}, {"sha": "1469cb434c00c07dfeb0190d14c5527bf5e96c25", "filename": "src/tools/clippy/clippy_lints/src/partialeq_ne_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -42,7 +42,7 @@ impl<'tcx> LateLintPass<'tcx> for PartialEqNeImpl {\n             if let Some(eq_trait) = cx.tcx.lang_items().eq_trait();\n             if trait_ref.path.res.def_id() == eq_trait;\n             then {\n-                for impl_item in impl_items {\n+                for impl_item in *impl_items {\n                     if impl_item.ident.name == sym::ne {\n                         span_lint_hir(\n                             cx,"}, {"sha": "fc1c2af9257bf98484d807b775a7a2da416a56e2", "filename": "src/tools/clippy/clippy_lints/src/serde_api.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fserde_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fserde_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fserde_api.rs?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -36,7 +36,7 @@ impl<'tcx> LateLintPass<'tcx> for SerdeApi {\n                 if did == visit_did {\n                     let mut seen_str = None;\n                     let mut seen_string = None;\n-                    for item in items {\n+                    for item in *items {\n                         match item.ident.as_str() {\n                             \"visit_str\" => seen_str = Some(item.span),\n                             \"visit_string\" => seen_string = Some(item.span),"}, {"sha": "3d1b2ee925bcebfd9d5511895d51e7ebf1f8c987", "filename": "src/tools/clippy/clippy_lints/src/trait_bounds.rs", "status": "modified", "additions": 13, "deletions": 23, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrait_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrait_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrait_bounds.rs?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -8,8 +8,7 @@ use rustc_data_structures::unhash::UnhashMap;\n use rustc_errors::Applicability;\n use rustc_hir::def::Res;\n use rustc_hir::{\n-    GenericBound, Generics, Item, ItemKind, Node, ParamName, Path, PathSegment, QPath, TraitItem, Ty, TyKind,\n-    WherePredicate,\n+    GenericBound, Generics, Item, ItemKind, Node, Path, PathSegment, QPath, TraitItem, Ty, TyKind, WherePredicate,\n };\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n@@ -90,10 +89,9 @@ impl<'tcx> LateLintPass<'tcx> for TraitBounds {\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx TraitItem<'tcx>) {\n-        let Generics { where_clause, .. } = &item.generics;\n         let mut self_bounds_map = FxHashMap::default();\n \n-        for predicate in where_clause.predicates {\n+        for predicate in item.generics.predicates {\n             if_chain! {\n                 if let WherePredicate::BoundPredicate(ref bound_predicate) = predicate;\n                 if !bound_predicate.span.from_expansion();\n@@ -166,7 +164,7 @@ impl TraitBounds {\n         }\n         let mut map: UnhashMap<SpanlessTy<'_, '_>, Vec<&GenericBound<'_>>> = UnhashMap::default();\n         let mut applicability = Applicability::MaybeIncorrect;\n-        for bound in gen.where_clause.predicates {\n+        for bound in gen.predicates {\n             if_chain! {\n                 if let WherePredicate::BoundPredicate(ref p) = bound;\n                 if p.bounds.len() as u64 <= self.max_trait_bounds;\n@@ -216,34 +214,23 @@ impl TraitBounds {\n }\n \n fn check_trait_bound_duplication(cx: &LateContext<'_>, gen: &'_ Generics<'_>) {\n-    if gen.span.from_expansion() || gen.params.is_empty() || gen.where_clause.predicates.is_empty() {\n+    if gen.span.from_expansion() || gen.params.is_empty() || gen.predicates.is_empty() {\n         return;\n     }\n \n-    let mut map = FxHashMap::default();\n-    for param in gen.params {\n-        if let ParamName::Plain(ref ident) = param.name {\n-            let res = param\n-                .bounds\n-                .iter()\n-                .filter_map(get_trait_info_from_bound)\n-                .collect::<Vec<_>>();\n-            map.insert(*ident, res);\n-        }\n-    }\n-\n-    for predicate in gen.where_clause.predicates {\n+    let mut map = FxHashMap::<_, Vec<_>>::default();\n+    for predicate in gen.predicates {\n         if_chain! {\n             if let WherePredicate::BoundPredicate(ref bound_predicate) = predicate;\n             if !bound_predicate.span.from_expansion();\n             if let TyKind::Path(QPath::Resolved(_, Path { segments, .. })) = bound_predicate.bounded_ty.kind;\n             if let Some(segment) = segments.first();\n-            if let Some(trait_resolutions_direct) = map.get(&segment.ident);\n             then {\n-                for (res_where, _,  _) in bound_predicate.bounds.iter().filter_map(get_trait_info_from_bound) {\n-                    if let Some((_, _, span_direct)) = trait_resolutions_direct\n+                for (res_where, _, span_where) in bound_predicate.bounds.iter().filter_map(get_trait_info_from_bound) {\n+                    let trait_resolutions_direct = map.entry(segment.ident).or_default();\n+                    if let Some((_, span_direct)) = trait_resolutions_direct\n                                                 .iter()\n-                                                .find(|(res_direct, _, _)| *res_direct == res_where) {\n+                                                .find(|(res_direct, _)| *res_direct == res_where) {\n                         span_lint_and_help(\n                             cx,\n                             TRAIT_DUPLICATION_IN_BOUNDS,\n@@ -253,6 +240,9 @@ fn check_trait_bound_duplication(cx: &LateContext<'_>, gen: &'_ Generics<'_>) {\n                             \"consider removing this trait bound\",\n                         );\n                     }\n+                    else {\n+                        trait_resolutions_direct.push((res_where, span_where))\n+                    }\n                 }\n             }\n         }"}, {"sha": "f35f44eda5679fb34f365965dac7433983875010", "filename": "src/tools/clippy/clippy_lints/src/types/borrowed_box.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fborrowed_box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fborrowed_box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fborrowed_box.rs?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -104,8 +104,10 @@ fn get_bounds_if_impl_trait<'tcx>(cx: &LateContext<'tcx>, qpath: &QPath<'_>, id:\n         if let Some(Node::GenericParam(generic_param)) = cx.tcx.hir().get_if_local(did);\n         if let GenericParamKind::Type { synthetic, .. } = generic_param.kind;\n         if synthetic;\n+        if let Some(generics) = cx.tcx.hir().get_generics(id.owner);\n+        if let Some(pred) = generics.bounds_for_param(did.expect_local()).next();\n         then {\n-            Some(generic_param.bounds)\n+            Some(pred.bounds)\n         } else {\n             None\n         }"}, {"sha": "9143fb2c208a05604d86a10e3fdb59f569b7b3b6", "filename": "src/tools/clippy/tests/ui/extra_unused_lifetimes.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fextra_unused_lifetimes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fextra_unused_lifetimes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fextra_unused_lifetimes.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -6,12 +6,6 @@ LL | fn unused_lt<'a>(x: u8) {}\n    |\n    = note: `-D clippy::extra-unused-lifetimes` implied by `-D warnings`\n \n-error: this lifetime isn't used in the function definition\n-  --> $DIR/extra_unused_lifetimes.rs:16:25\n-   |\n-LL | fn unused_lt_transitive<'a, 'b: 'a>(x: &'b u8) {\n-   |                         ^^\n-\n error: this lifetime isn't used in the function definition\n   --> $DIR/extra_unused_lifetimes.rs:41:10\n    |\n@@ -24,5 +18,5 @@ error: this lifetime isn't used in the function definition\n LL |         fn unused_lt<'a>(x: u8) {}\n    |                      ^^\n \n-error: aborting due to 4 previous errors\n+error: aborting due to 3 previous errors\n "}, {"sha": "a488bc01fffa289257f8cd7032c32eacf32ab3f3", "filename": "src/tools/clippy/tests/ui/needless_lifetimes.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_lifetimes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d201c812d40932509b2b5307c0b20c1ce78d21da/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_lifetimes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_lifetimes.stderr?ref=d201c812d40932509b2b5307c0b20c1ce78d21da", "patch": "@@ -108,12 +108,6 @@ error: explicit lifetimes given in parameter types where they could be elided (o\n LL |         fn baz<'a>(&'a self) -> impl Foo + 'a {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n-  --> $DIR/needless_lifetimes.rs:307:5\n-   |\n-LL |     fn impl_trait_elidable_nested_named_lifetimes<'a>(i: &'a i32, f: impl for<'b> Fn(&'b i32) -> &'b i32) -> &'a i32 {\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n   --> $DIR/needless_lifetimes.rs:310:5\n    |\n@@ -192,5 +186,5 @@ error: explicit lifetimes given in parameter types where they could be elided (o\n LL |         fn lifetime_elsewhere_provided<'a>(self: Box<Self>, here: &'a ()) -> &'a () {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 32 previous errors\n+error: aborting due to 31 previous errors\n "}]}