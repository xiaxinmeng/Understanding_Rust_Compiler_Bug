{"sha": "32431440469f403b1532e25dfd60c3d958840dc1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyNDMxNDQwNDY5ZjQwM2IxNTMyZTI1ZGZkNjBjM2Q5NTg4NDBkYzE=", "commit": {"author": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-07-08T00:10:17Z"}, "committer": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-07-08T00:29:15Z"}, "message": "Fix a bug that was interfering with method overriding.  Issue #543.\n\nPreviously, we were creating both a normal vtable entry and a\nforwarding function for overriding methods, when they should have just\ngotten a vtable entry.  This patch fixes that.", "tree": {"sha": "99d3e0c082357e94081ad2a508e047c8f93b1752", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/99d3e0c082357e94081ad2a508e047c8f93b1752"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/32431440469f403b1532e25dfd60c3d958840dc1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/32431440469f403b1532e25dfd60c3d958840dc1", "html_url": "https://github.com/rust-lang/rust/commit/32431440469f403b1532e25dfd60c3d958840dc1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/32431440469f403b1532e25dfd60c3d958840dc1/comments", "author": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "301f6aaa31594f996ae70ed84cf4e2ba7d8b3030", "url": "https://api.github.com/repos/rust-lang/rust/commits/301f6aaa31594f996ae70ed84cf4e2ba7d8b3030", "html_url": "https://github.com/rust-lang/rust/commit/301f6aaa31594f996ae70ed84cf4e2ba7d8b3030"}], "stats": {"total": 73, "additions": 38, "deletions": 35}, "files": [{"sha": "e232ce97d362b25c3abbb4f23695a582a04e15ac", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 36, "deletions": 23, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/32431440469f403b1532e25dfd60c3d958840dc1/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32431440469f403b1532e25dfd60c3d958840dc1/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=32431440469f403b1532e25dfd60c3d958840dc1", "patch": "@@ -8152,34 +8152,47 @@ fn create_vtbl(@local_ctxt cx, &span sp, TypeRef llself_ty, ty::t self_ty,\n                 }\n             }\n \n-            // Now, filter out any methods that are being replaced.\n-            fn filtering_fn(&vtbl_mthd m, vec[vtbl_mthd] addtl_meths) ->\n-                option::t[vtbl_mthd] {\n-\n-                let option::t[vtbl_mthd] rslt;\n-                if (std::vec::member[vtbl_mthd](m, addtl_meths)) {\n-                    rslt = none;\n-                } else {\n-                    rslt = some(m);\n+            // Now, filter out any methods that we don't need forwarding slots\n+            // for, because they're being replaced.\n+            fn filtering_fn(@local_ctxt cx, &vtbl_mthd m,\n+                            (@ast::method)[] addtl_meths) \n+                -> option::t[vtbl_mthd] {\n+\n+                alt (m) {\n+                    case (fwding_mthd(?fm)) {\n+                        // Since fm is a fwding_mthd, and we're checking to\n+                        // see if it's in addtl_meths (which only contains\n+                        // normal_mthds), we can't just check if fm is a\n+                        // member of addtl_meths.  Instead, we have to go\n+                        // through addtl_meths and see if there's some method\n+                        // in it that has the same name as fm.\n+\n+                        // FIXME (part of #543): We're only checking names\n+                        // here.  If a method is replacing another, it also\n+                        // needs to have the same type, but this should\n+                        // probably be enforced in typechecking.\n+                        for (@ast::method am in addtl_meths) {\n+                            if (str::eq(am.node.ident, fm.ident)) {\n+                                ret none;\n+                            }\n+                        }\n+                        ret some(fwding_mthd(fm));\n+                    }\n+                    case (normal_mthd(_)) {\n+                        // Should never happen.\n+                        cx.ccx.sess.bug(\"create_vtbl(): shouldn't be any\"\n+                                        + \" normal_mthds in meths here\");\n+                    }\n                 }\n-                ret rslt;\n             }\n-\n-            // NB: addtl_meths is just like ob.methods except that it's of\n-            // type vec[vtbl_mthd], not vec[@ast::method].\n-            let vec[vtbl_mthd] addtl_meths = [];\n-            for (@ast::method m in ob.methods) {\n-                addtl_meths += [normal_mthd(m)];\n-            }\n-            auto f = bind filtering_fn(_, addtl_meths);\n-\n-            // Filter out any methods that we don't need forwarding slots for\n-            // (namely, those that are being replaced).\n+            auto f = bind filtering_fn(cx, _, ob.methods);\n             meths = std::vec::filter_map[vtbl_mthd, vtbl_mthd](f, meths);\n             \n             // And now add the additional ones (both replacements and entirely\n-            // new ones).\n-            meths += addtl_meths;\n+            // new ones).  These'll just be normal methods.\n+            for (@ast::method m in ob.methods) {\n+                meths += [normal_mthd(m)];\n+            }\n         }\n     } \n     "}, {"sha": "d71244cc3133dd93b525643978d2e22389fa43e3", "filename": "src/test/run-pass/anon-obj-overloading.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/32431440469f403b1532e25dfd60c3d958840dc1/src%2Ftest%2Frun-pass%2Fanon-obj-overloading.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32431440469f403b1532e25dfd60c3d958840dc1/src%2Ftest%2Frun-pass%2Fanon-obj-overloading.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fanon-obj-overloading.rs?ref=32431440469f403b1532e25dfd60c3d958840dc1", "patch": "@@ -16,9 +16,7 @@ fn main() {\n \n     auto my_a = a();\n \n-    // An anonymous object that overloads the 'foo' method.  Adding\n-    // support for this is issue #543 (making this work in the\n-    // presence of self-calls is the tricky part).\n+    // An anonymous object that overloads the 'foo' method.\n     auto my_b = obj() {\n         fn foo() -> int {\n             ret 3;\n@@ -27,15 +25,7 @@ fn main() {\n         with my_a\n     };\n \n+    // FIXME: raises a valgrind error (issue #543).\n     assert (my_b.foo() == 3);\n-\n-    // The tricky part -- have to be sure to tie the knot in the right\n-    // place, so that bar() knows about the new foo().\n-\n-    // Right now, this just fails with \"unknown method 'bar' of obj\",\n-    // but that's the easier of our worries; that'll be fixed when\n-    // issue #539 is fixed.  The bigger problem will be when we do\n-    // 'fall through' to bar() on the original object -- then we have\n-    // to be sure that self refers to the extended object.\n     assert (my_b.bar() == 3);\n }"}]}