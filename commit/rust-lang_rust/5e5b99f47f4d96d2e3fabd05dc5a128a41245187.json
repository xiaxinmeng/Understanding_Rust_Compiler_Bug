{"sha": "5e5b99f47f4d96d2e3fabd05dc5a128a41245187", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlNWI5OWY0N2Y0ZDk2ZDJlM2ZhYmQwNWRjNWExMjhhNDEyNDUxODc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-22T11:42:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-22T11:42:36Z"}, "message": "Auto merge of #27892 - nikomatsakis:issue-27583, r=pnkfelix\n\nIssue #27583 was caused by the fact that `LUB('a,'b)` yielded `'static`, even if there existed a region `'tcx:'a+'b`. This PR replaces the old very hacky code for computing how free regions relate to one another with something rather more robust. This solves the issue for #27583, though I think that similar bizarro bugs can no doubt arise in other ways -- the root of the problem is that the region-inference code was written in an era when a LUB always existed, but that hasn't held for some time. To *truly* solve this problem, it needs to be generalized to cope with that reality. But let's leave that battle for another day.\r\n\r\nr? @aturon", "tree": {"sha": "cad67fd3c8f4bb99a5a8c4197254a71e53b882df", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cad67fd3c8f4bb99a5a8c4197254a71e53b882df"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e5b99f47f4d96d2e3fabd05dc5a128a41245187", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e5b99f47f4d96d2e3fabd05dc5a128a41245187", "html_url": "https://github.com/rust-lang/rust/commit/5e5b99f47f4d96d2e3fabd05dc5a128a41245187", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e5b99f47f4d96d2e3fabd05dc5a128a41245187/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "94ee3b5a54a9f4965b82f5e4eda512966e96ac63", "url": "https://api.github.com/repos/rust-lang/rust/commits/94ee3b5a54a9f4965b82f5e4eda512966e96ac63", "html_url": "https://github.com/rust-lang/rust/commit/94ee3b5a54a9f4965b82f5e4eda512966e96ac63"}, {"sha": "81eab1cab6e96b4430409245b83cc51cd40c2f9f", "url": "https://api.github.com/repos/rust-lang/rust/commits/81eab1cab6e96b4430409245b83cc51cd40c2f9f", "html_url": "https://github.com/rust-lang/rust/commit/81eab1cab6e96b4430409245b83cc51cd40c2f9f"}], "stats": {"total": 1041, "additions": 925, "deletions": 116}, "files": [{"sha": "744ceb3701dba862478d370ffd6d731b477dd9a6", "filename": "src/librustc/middle/free_region.rs", "status": "modified", "additions": 65, "deletions": 28, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/5e5b99f47f4d96d2e3fabd05dc5a128a41245187/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e5b99f47f4d96d2e3fabd05dc5a128a41245187/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=5e5b99f47f4d96d2e3fabd05dc5a128a41245187", "patch": "@@ -8,26 +8,26 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! This file defines\n-\n+//! This file handles the relationships between free regions --\n+//! meaning lifetime parameters. Ordinarily, free regions are\n+//! unrelated to one another, but they can be related vai implied or\n+//! explicit bounds.  In that case, we track the bounds using the\n+//! `TransitiveRelation` type and use that to decide when one free\n+//! region outlives another and so forth.\n+\n+use middle::ty::{self, FreeRegion, Region};\n use middle::wf::ImpliedBound;\n-use middle::ty::{self, FreeRegion};\n-use util::common::can_reach;\n-use util::nodemap::{FnvHashMap, FnvHashSet};\n+use rustc_data_structures::transitive_relation::TransitiveRelation;\n \n #[derive(Clone)]\n pub struct FreeRegionMap {\n-    /// `map` maps from a free region `a` to a list of\n-    /// free regions `bs` such that `a <= b for all b in bs`\n-    map: FnvHashMap<FreeRegion, Vec<FreeRegion>>,\n-    /// regions that are required to outlive (and therefore be\n-    /// equal to) 'static.\n-    statics: FnvHashSet<FreeRegion>\n+    // Stores the relation `a < b`, where `a` and `b` are regions.\n+    relation: TransitiveRelation<Region>\n }\n \n impl FreeRegionMap {\n     pub fn new() -> FreeRegionMap {\n-        FreeRegionMap { map: FnvHashMap(), statics: FnvHashSet() }\n+        FreeRegionMap { relation: TransitiveRelation::new() }\n     }\n \n     pub fn relate_free_regions_from_implied_bounds<'tcx>(&mut self,\n@@ -84,22 +84,38 @@ impl FreeRegionMap {\n     }\n \n     fn relate_to_static(&mut self, sup: FreeRegion) {\n-        self.statics.insert(sup);\n+        self.relation.add(ty::ReStatic, ty::ReFree(sup));\n     }\n \n     fn relate_free_regions(&mut self, sub: FreeRegion, sup: FreeRegion) {\n-       let mut sups = self.map.entry(sub).or_insert(Vec::new());\n-        if !sups.contains(&sup) {\n-            sups.push(sup);\n-        }\n+        self.relation.add(ty::ReFree(sub), ty::ReFree(sup))\n     }\n \n     /// Determines whether two free regions have a subregion relationship\n     /// by walking the graph encoded in `map`.  Note that\n     /// it is possible that `sub != sup` and `sub <= sup` and `sup <= sub`\n     /// (that is, the user can give two different names to the same lifetime).\n     pub fn sub_free_region(&self, sub: FreeRegion, sup: FreeRegion) -> bool {\n-        can_reach(&self.map, sub, sup) || self.is_static(&sup)\n+        let result = sub == sup || {\n+            let sub = ty::ReFree(sub);\n+            let sup = ty::ReFree(sup);\n+            self.relation.contains(&sub, &sup) || self.relation.contains(&ty::ReStatic, &sup)\n+        };\n+        debug!(\"sub_free_region(sub={:?}, sup={:?}) = {:?}\", sub, sup, result);\n+        result\n+    }\n+\n+    pub fn lub_free_regions(&self, fr_a: FreeRegion, fr_b: FreeRegion) -> Region {\n+        let r_a = ty::ReFree(fr_a);\n+        let r_b = ty::ReFree(fr_b);\n+        let result = if fr_a == fr_b { r_a } else {\n+            match self.relation.postdom_upper_bound(&r_a, &r_b) {\n+                None => ty::ReStatic,\n+                Some(r) => *r,\n+            }\n+        };\n+        debug!(\"lub_free_regions(fr_a={:?}, fr_b={:?}) = {:?}\", fr_a, fr_b, result);\n+        result\n     }\n \n     /// Determines whether one region is a subregion of another.  This is intended to run *after\n@@ -109,10 +125,7 @@ impl FreeRegionMap {\n                            sub_region: ty::Region,\n                            super_region: ty::Region)\n                            -> bool {\n-        debug!(\"is_subregion_of(sub_region={:?}, super_region={:?})\",\n-               sub_region, super_region);\n-\n-        sub_region == super_region || {\n+        let result = sub_region == super_region || {\n             match (sub_region, super_region) {\n                 (ty::ReEmpty, _) |\n                 (_, ty::ReStatic) =>\n@@ -121,23 +134,47 @@ impl FreeRegionMap {\n                 (ty::ReScope(sub_scope), ty::ReScope(super_scope)) =>\n                     tcx.region_maps.is_subscope_of(sub_scope, super_scope),\n \n-                (ty::ReScope(sub_scope), ty::ReFree(ref fr)) =>\n-                    tcx.region_maps.is_subscope_of(sub_scope, fr.scope.to_code_extent()),\n+                (ty::ReScope(sub_scope), ty::ReFree(fr)) =>\n+                    tcx.region_maps.is_subscope_of(sub_scope, fr.scope.to_code_extent()) ||\n+                    self.is_static(fr),\n \n                 (ty::ReFree(sub_fr), ty::ReFree(super_fr)) =>\n                     self.sub_free_region(sub_fr, super_fr),\n \n-                (ty::ReStatic, ty::ReFree(ref sup_fr)) => self.is_static(sup_fr),\n+                (ty::ReStatic, ty::ReFree(sup_fr)) =>\n+                    self.is_static(sup_fr),\n \n                 _ =>\n                     false,\n             }\n-        }\n+        };\n+        debug!(\"is_subregion_of(sub_region={:?}, super_region={:?}) = {:?}\",\n+               sub_region, super_region, result);\n+        result\n     }\n \n     /// Determines whether this free-region is required to be 'static\n-    pub fn is_static(&self, super_region: &ty::FreeRegion) -> bool {\n+    pub fn is_static(&self, super_region: ty::FreeRegion) -> bool {\n         debug!(\"is_static(super_region={:?})\", super_region);\n-        self.statics.iter().any(|s| can_reach(&self.map, *s, *super_region))\n+        self.relation.contains(&ty::ReStatic, &ty::ReFree(super_region))\n     }\n }\n+\n+#[cfg(test)]\n+fn free_region(index: u32) -> FreeRegion {\n+    use middle::region::DestructionScopeData;\n+    FreeRegion { scope: DestructionScopeData::new(0),\n+                 bound_region: ty::BoundRegion::BrAnon(index) }\n+}\n+\n+#[test]\n+fn lub() {\n+    // a very VERY basic test, but see the tests in\n+    // TransitiveRelation, which are much more thorough.\n+    let frs: Vec<_> = (0..3).map(|i| free_region(i)).collect();\n+    let mut map = FreeRegionMap::new();\n+    map.relate_free_regions(frs[0], frs[2]);\n+    map.relate_free_regions(frs[1], frs[2]);\n+    assert_eq!(map.lub_free_regions(frs[0], frs[1]), ty::ReFree(frs[2]));\n+}\n+"}, {"sha": "e04f2955ddc18a2b348e22a4ec07644b0c1f4480", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 4, "deletions": 33, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/5e5b99f47f4d96d2e3fabd05dc5a128a41245187/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e5b99f47f4d96d2e3fabd05dc5a128a41245187/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=5e5b99f47f4d96d2e3fabd05dc5a128a41245187", "patch": "@@ -812,8 +812,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             ReScope(self.tcx.region_maps.nearest_common_ancestor(a_id, b_id))\n           }\n \n-          (ReFree(ref a_fr), ReFree(ref b_fr)) => {\n-             self.lub_free_regions(free_regions, a_fr, b_fr)\n+          (ReFree(a_fr), ReFree(b_fr)) => {\n+            free_regions.lub_free_regions(a_fr, b_fr)\n           }\n \n           // For these types, we cannot define any additional\n@@ -825,35 +825,6 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         }\n     }\n \n-    /// Computes a region that encloses both free region arguments. Guarantee that if the same two\n-    /// regions are given as argument, in any order, a consistent result is returned.\n-    fn lub_free_regions(&self,\n-                        free_regions: &FreeRegionMap,\n-                        a: &FreeRegion,\n-                        b: &FreeRegion)\n-                        -> ty::Region\n-    {\n-        return match a.cmp(b) {\n-            Less => helper(self, free_regions, a, b),\n-            Greater => helper(self, free_regions, b, a),\n-            Equal => ty::ReFree(*a)\n-        };\n-\n-        fn helper(_this: &RegionVarBindings,\n-                  free_regions: &FreeRegionMap,\n-                  a: &FreeRegion,\n-                  b: &FreeRegion) -> ty::Region\n-        {\n-            if free_regions.sub_free_region(*a, *b) {\n-                ty::ReFree(*b)\n-            } else if free_regions.sub_free_region(*b, *a) {\n-                ty::ReFree(*a)\n-            } else {\n-                ty::ReStatic\n-            }\n-        }\n-    }\n-\n     fn glb_concrete_regions(&self,\n                             free_regions: &FreeRegionMap,\n                             a: Region,\n@@ -892,8 +863,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                             b));\n             }\n \n-            (ReFree(ref fr), ReScope(s_id)) |\n-            (ReScope(s_id), ReFree(ref fr)) => {\n+            (ReFree(fr), ReScope(s_id)) |\n+            (ReScope(s_id), ReFree(fr)) => {\n                 let s = ReScope(s_id);\n                 // Free region is something \"at least as big as\n                 // `fr.scope_id`.\"  If we find that the scope `fr.scope_id` is bigger"}, {"sha": "1ad5ae9917d97f9aed0adce65c7f1b7da8a064bc", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/5e5b99f47f4d96d2e3fabd05dc5a128a41245187/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e5b99f47f4d96d2e3fabd05dc5a128a41245187/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=5e5b99f47f4d96d2e3fabd05dc5a128a41245187", "patch": "@@ -203,49 +203,6 @@ pub fn block_query<P>(b: &ast::Block, p: P) -> bool where P: FnMut(&ast::Expr) -\n     return v.flag;\n }\n \n-/// K: Eq + Hash<S>, V, S, H: Hasher<S>\n-///\n-/// Determines whether there exists a path from `source` to `destination`.  The\n-/// graph is defined by the `edges_map`, which maps from a node `S` to a list of\n-/// its adjacent nodes `T`.\n-///\n-/// Efficiency note: This is implemented in an inefficient way because it is\n-/// typically invoked on very small graphs. If the graphs become larger, a more\n-/// efficient graph representation and algorithm would probably be advised.\n-pub fn can_reach<T, S>(edges_map: &HashMap<T, Vec<T>, S>, source: T,\n-                       destination: T) -> bool\n-    where S: HashState, T: Hash + Eq + Clone,\n-{\n-    if source == destination {\n-        return true;\n-    }\n-\n-    // Do a little breadth-first-search here.  The `queue` list\n-    // doubles as a way to detect if we've seen a particular FR\n-    // before.  Note that we expect this graph to be an *extremely\n-    // shallow* tree.\n-    let mut queue = vec!(source);\n-    let mut i = 0;\n-    while i < queue.len() {\n-        match edges_map.get(&queue[i]) {\n-            Some(edges) => {\n-                for target in edges {\n-                    if *target == destination {\n-                        return true;\n-                    }\n-\n-                    if !queue.iter().any(|x| x == target) {\n-                        queue.push((*target).clone());\n-                    }\n-                }\n-            }\n-            None => {}\n-        }\n-        i += 1;\n-    }\n-    return false;\n-}\n-\n /// Memoizes a one-argument closure using the given RefCell containing\n /// a type implementing MutableMap to serve as a cache.\n ///"}, {"sha": "f26307fd8c58e202a3372e19c4de0c857ae98bfe", "filename": "src/librustc_data_structures/bitvec.rs", "status": "modified", "additions": 183, "deletions": 9, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/5e5b99f47f4d96d2e3fabd05dc5a128a41245187/src%2Flibrustc_data_structures%2Fbitvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e5b99f47f4d96d2e3fabd05dc5a128a41245187/src%2Flibrustc_data_structures%2Fbitvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbitvec.rs?ref=5e5b99f47f4d96d2e3fabd05dc5a128a41245187", "patch": "@@ -15,26 +15,200 @@ pub struct BitVector {\n \n impl BitVector {\n     pub fn new(num_bits: usize) -> BitVector {\n-        let num_words = (num_bits + 63) / 64;\n+        let num_words = u64s(num_bits);\n         BitVector { data: vec![0; num_words] }\n     }\n \n-    fn word_mask(&self, bit: usize) -> (usize, u64) {\n-        let word = bit / 64;\n-        let mask = 1 << (bit % 64);\n-        (word, mask)\n-    }\n-\n     pub fn contains(&self, bit: usize) -> bool {\n-        let (word, mask) = self.word_mask(bit);\n+        let (word, mask) = word_mask(bit);\n         (self.data[word] & mask) != 0\n     }\n \n     pub fn insert(&mut self, bit: usize) -> bool {\n-        let (word, mask) = self.word_mask(bit);\n+        let (word, mask) = word_mask(bit);\n         let data = &mut self.data[word];\n         let value = *data;\n         *data = value | mask;\n         (value | mask) != value\n     }\n+\n+    pub fn insert_all(&mut self, all: &BitVector) -> bool {\n+        assert!(self.data.len() == all.data.len());\n+        let mut changed = false;\n+        for (i, j) in self.data.iter_mut().zip(&all.data) {\n+            let value = *i;\n+            *i = value | *j;\n+            if value != *i { changed = true; }\n+        }\n+        changed\n+    }\n+\n+    pub fn grow(&mut self, num_bits: usize) {\n+        let num_words = u64s(num_bits);\n+        let extra_words = self.data.len() - num_words;\n+        self.data.extend((0..extra_words).map(|_| 0));\n+    }\n+}\n+\n+/// A \"bit matrix\" is basically a square matrix of booleans\n+/// represented as one gigantic bitvector. In other words, it is as if\n+/// you have N bitvectors, each of length N. Note that `elements` here is `N`/\n+#[derive(Clone)]\n+pub struct BitMatrix {\n+    elements: usize,\n+    vector: Vec<u64>,\n+}\n+\n+impl BitMatrix {\n+    // Create a new `elements x elements` matrix, initially empty.\n+    pub fn new(elements: usize) -> BitMatrix {\n+        // For every element, we need one bit for every other\n+        // element. Round up to an even number of u64s.\n+        let u64s_per_elem = u64s(elements);\n+        BitMatrix {\n+            elements: elements,\n+            vector: vec![0; elements * u64s_per_elem]\n+        }\n+    }\n+\n+    /// The range of bits for a given element.\n+    fn range(&self, element: usize) -> (usize, usize) {\n+        let u64s_per_elem = u64s(self.elements);\n+        let start = element * u64s_per_elem;\n+        (start, start + u64s_per_elem)\n+    }\n+\n+    pub fn add(&mut self, source: usize, target: usize) -> bool {\n+        let (start, _) = self.range(source);\n+        let (word, mask) = word_mask(target);\n+        let mut vector = &mut self.vector[..];\n+        let v1 = vector[start+word];\n+        let v2 = v1 | mask;\n+        vector[start+word] = v2;\n+        v1 != v2\n+    }\n+\n+    /// Do the bits from `source` contain `target`?\n+    ///\n+    /// Put another way, if the matrix represents (transitive)\n+    /// reachability, can `source` reach `target`?\n+    pub fn contains(&self, source: usize, target: usize) -> bool {\n+        let (start, _) = self.range(source);\n+        let (word, mask) = word_mask(target);\n+        (self.vector[start+word] & mask) != 0\n+    }\n+\n+    /// Returns those indices that are reachable from both `a` and\n+    /// `b`. This is an O(n) operation where `n` is the number of\n+    /// elements (somewhat independent from the actual size of the\n+    /// intersection, in particular).\n+    pub fn intersection(&self, a: usize, b: usize) -> Vec<usize> {\n+        let (a_start, a_end) = self.range(a);\n+        let (b_start, b_end) = self.range(b);\n+        let mut result = Vec::with_capacity(self.elements);\n+        for (base, (i, j)) in (a_start..a_end).zip(b_start..b_end).enumerate() {\n+            let mut v = self.vector[i] & self.vector[j];\n+            for bit in 0..64 {\n+                if v == 0 { break; }\n+                if v & 0x1 != 0 { result.push(base*64 + bit); }\n+                v >>= 1;\n+            }\n+        }\n+        result\n+    }\n+\n+    /// Add the bits from `read` to the bits from `write`,\n+    /// return true if anything changed.\n+    ///\n+    /// This is used when computing transitive reachability because if\n+    /// you have an edge `write -> read`, because in that case\n+    /// `write` can reach everything that `read` can (and\n+    /// potentially more).\n+    pub fn merge(&mut self, read: usize, write: usize) -> bool {\n+        let (read_start, read_end) = self.range(read);\n+        let (write_start, write_end) = self.range(write);\n+        let vector = &mut self.vector[..];\n+        let mut changed = false;\n+        for (read_index, write_index) in\n+            (read_start..read_end).zip(write_start..write_end)\n+        {\n+            let v1 = vector[write_index];\n+            let v2 = v1 | vector[read_index];\n+            vector[write_index] = v2;\n+            changed = changed | (v1 != v2);\n+        }\n+        changed\n+    }\n+}\n+\n+fn u64s(elements: usize) -> usize {\n+    (elements + 63) / 64\n+}\n+\n+fn word_mask(index: usize) -> (usize, u64) {\n+    let word = index / 64;\n+    let mask = 1 << (index % 64);\n+    (word, mask)\n+}\n+\n+#[test]\n+fn union_two_vecs() {\n+    let mut vec1 = BitVector::new(65);\n+    let mut vec2 = BitVector::new(65);\n+    assert!(vec1.insert(3));\n+    assert!(!vec1.insert(3));\n+    assert!(vec2.insert(5));\n+    assert!(vec2.insert(64));\n+    assert!(vec1.insert_all(&vec2));\n+    assert!(!vec1.insert_all(&vec2));\n+    assert!(vec1.contains(3));\n+    assert!(!vec1.contains(4));\n+    assert!(vec1.contains(5));\n+    assert!(!vec1.contains(63));\n+    assert!(vec1.contains(64));\n+}\n+\n+#[test]\n+fn grow() {\n+    let mut vec1 = BitVector::new(65);\n+    assert!(vec1.insert(3));\n+    assert!(!vec1.insert(3));\n+    assert!(vec1.insert(5));\n+    assert!(vec1.insert(64));\n+    vec1.grow(128);\n+    assert!(vec1.contains(3));\n+    assert!(vec1.contains(5));\n+    assert!(vec1.contains(64));\n+    assert!(!vec1.contains(126));\n+}\n+\n+#[test]\n+fn matrix_intersection() {\n+    let mut vec1 = BitMatrix::new(200);\n+\n+    // (*) Elements reachable from both 2 and 65.\n+\n+    vec1.add(2, 3);\n+    vec1.add(2, 6);\n+    vec1.add(2, 10); // (*)\n+    vec1.add(2, 64); // (*)\n+    vec1.add(2, 65);\n+    vec1.add(2, 130);\n+    vec1.add(2, 160); // (*)\n+\n+    vec1.add(64, 133);\n+\n+    vec1.add(65, 2);\n+    vec1.add(65, 8);\n+    vec1.add(65, 10); // (*)\n+    vec1.add(65, 64); // (*)\n+    vec1.add(65, 68);\n+    vec1.add(65, 133);\n+    vec1.add(65, 160); // (*)\n+\n+    let intersection = vec1.intersection(2, 64);\n+    assert!(intersection.is_empty());\n+\n+    let intersection = vec1.intersection(2, 65);\n+    assert_eq!(intersection, &[10, 64, 160]);\n }"}, {"sha": "78edae76253a927f99d331b4af1b72261719d80f", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5e5b99f47f4d96d2e3fabd05dc5a128a41245187/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e5b99f47f4d96d2e3fabd05dc5a128a41245187/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=5e5b99f47f4d96d2e3fabd05dc5a128a41245187", "patch": "@@ -33,10 +33,11 @@\n #[macro_use] extern crate log;\n extern crate serialize as rustc_serialize; // used by deriving\n \n-pub mod snapshot_vec;\n-pub mod graph;\n pub mod bitvec;\n+pub mod graph;\n pub mod ivar;\n+pub mod snapshot_vec;\n+pub mod transitive_relation;\n pub mod unify;\n \n // See comments in src/librustc/lib.rs"}, {"sha": "728137f4ae99d11d986e6c59689d8399c26df1ac", "filename": "src/librustc_data_structures/transitive_relation.rs", "status": "added", "additions": 589, "deletions": 0, "changes": 589, "blob_url": "https://github.com/rust-lang/rust/blob/5e5b99f47f4d96d2e3fabd05dc5a128a41245187/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e5b99f47f4d96d2e3fabd05dc5a128a41245187/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftransitive_relation.rs?ref=5e5b99f47f4d96d2e3fabd05dc5a128a41245187", "patch": "@@ -0,0 +1,589 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use bitvec::BitMatrix;\n+use std::cell::RefCell;\n+use std::fmt::Debug;\n+use std::mem;\n+\n+#[derive(Clone)]\n+pub struct TransitiveRelation<T:Debug+PartialEq> {\n+    // List of elements. This is used to map from a T to a usize.  We\n+    // expect domain to be small so just use a linear list versus a\n+    // hashmap or something.\n+    elements: Vec<T>,\n+\n+    // List of base edges in the graph. Require to compute transitive\n+    // closure.\n+    edges: Vec<Edge>,\n+\n+    // This is a cached transitive closure derived from the edges.\n+    // Currently, we build it lazilly and just throw out any existing\n+    // copy whenever a new edge is added. (The RefCell is to permit\n+    // the lazy computation.) This is kind of silly, except for the\n+    // fact its size is tied to `self.elements.len()`, so I wanted to\n+    // wait before building it up to avoid reallocating as new edges\n+    // are added with new elements. Perhaps better would be to ask the\n+    // user for a batch of edges to minimize this effect, but I\n+    // already wrote the code this way. :P -nmatsakis\n+    closure: RefCell<Option<BitMatrix>>\n+}\n+\n+#[derive(Clone, PartialEq, PartialOrd)]\n+struct Index(usize);\n+\n+#[derive(Clone, PartialEq)]\n+struct Edge {\n+    source: Index,\n+    target: Index,\n+}\n+\n+impl<T:Debug+PartialEq> TransitiveRelation<T> {\n+    pub fn new() -> TransitiveRelation<T> {\n+        TransitiveRelation { elements: vec![],\n+                             edges: vec![],\n+                             closure: RefCell::new(None) }\n+    }\n+\n+    fn index(&self, a: &T) -> Option<Index> {\n+        self.elements.iter().position(|e| *e == *a).map(Index)\n+    }\n+\n+    fn add_index(&mut self, a: T) -> Index {\n+        match self.index(&a) {\n+            Some(i) => i,\n+            None => {\n+                self.elements.push(a);\n+\n+                // if we changed the dimensions, clear the cache\n+                *self.closure.borrow_mut() = None;\n+\n+                Index(self.elements.len() - 1)\n+            }\n+        }\n+    }\n+\n+    /// Indicate that `a < b` (where `<` is this relation)\n+    pub fn add(&mut self, a: T, b: T) {\n+        let a = self.add_index(a);\n+        let b = self.add_index(b);\n+        let edge = Edge { source: a, target: b };\n+        if !self.edges.contains(&edge) {\n+            self.edges.push(edge);\n+\n+            // added an edge, clear the cache\n+            *self.closure.borrow_mut() = None;\n+        }\n+    }\n+\n+    /// Check whether `a < target` (transitively)\n+    pub fn contains(&self, a: &T, b: &T) -> bool {\n+        match (self.index(a), self.index(b)) {\n+            (Some(a), Some(b)) =>\n+                self.with_closure(|closure| closure.contains(a.0, b.0)),\n+            (None, _) | (_, None) =>\n+                false,\n+        }\n+    }\n+\n+    /// Picks what I am referring to as the \"postdominating\"\n+    /// upper-bound for `a` and `b`. This is usually the least upper\n+    /// bound, but in cases where there is no single least upper\n+    /// bound, it is the \"mutual immediate postdominator\", if you\n+    /// imagine a graph where `a < b` means `a -> b`.\n+    ///\n+    /// This function is needed because region inference currently\n+    /// requires that we produce a single \"UB\", and there is no best\n+    /// choice for the LUB. Rather than pick arbitrarily, I pick a\n+    /// less good, but predictable choice. This should help ensure\n+    /// that region inference yields predictable results (though it\n+    /// itself is not fully sufficient).\n+    ///\n+    /// Examples are probably clearer than any prose I could write\n+    /// (there are corresponding tests below, btw). In each case,\n+    /// the query is `postdom_upper_bound(a, b)`:\n+    ///\n+    /// ```\n+    /// // returns Some(x), which is also LUB\n+    /// a -> a1 -> x\n+    ///            ^\n+    ///            |\n+    /// b -> b1 ---+\n+    ///\n+    /// // returns Some(x), which is not LUB (there is none)\n+    /// // diagonal edges run left-to-right\n+    /// a -> a1 -> x\n+    ///   \\/       ^\n+    ///   /\\       |\n+    /// b -> b1 ---+\n+    ///\n+    /// // returns None\n+    /// a -> a1\n+    /// b -> b1\n+    /// ```\n+    pub fn postdom_upper_bound(&self, a: &T, b: &T) -> Option<&T> {\n+        let mut mubs = self.minimal_upper_bounds(a, b);\n+        loop {\n+            match mubs.len() {\n+                0 => return None,\n+                1 => return Some(mubs[0]),\n+                _ => {\n+                    let m = mubs.pop().unwrap();\n+                    let n = mubs.pop().unwrap();\n+                    mubs.extend(self.minimal_upper_bounds(n, m));\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Returns the set of bounds `X` such that:\n+    ///\n+    /// - `a < X` and `b < X`\n+    /// - there is no `Y != X` such that `a < Y` and `Y < X`\n+    ///   - except for the case where `X < a` (i.e., a strongly connected\n+    ///     component in the graph). In that case, the smallest\n+    ///     representative of the SCC is returned (as determined by the\n+    ///     internal indices).\n+    ///\n+    /// Note that this set can, in principle, have any size.\n+    pub fn minimal_upper_bounds(&self, a: &T, b: &T) -> Vec<&T> {\n+        let (mut a, mut b) = match (self.index(a), self.index(b)) {\n+            (Some(a), Some(b)) => (a, b),\n+            (None, _) | (_, None) => { return vec![]; }\n+        };\n+\n+        // in some cases, there are some arbitrary choices to be made;\n+        // it doesn't really matter what we pick, as long as we pick\n+        // the same thing consistently when queried, so ensure that\n+        // (a, b) are in a consistent relative order\n+        if a > b {\n+            mem::swap(&mut a, &mut b);\n+        }\n+\n+        let lub_indices = self.with_closure(|closure| {\n+            // Easy case is when either a < b or b < a:\n+            if closure.contains(a.0, b.0) {\n+                return vec![b.0];\n+            }\n+            if closure.contains(b.0, a.0) {\n+                return vec![a.0];\n+            }\n+\n+            // Otherwise, the tricky part is that there may be some c\n+            // where a < c and b < c. In fact, there may be many such\n+            // values. So here is what we do:\n+            //\n+            // 1. Find the vector `[X | a < X && b < X]` of all values\n+            //    `X` where `a < X` and `b < X`.  In terms of the\n+            //    graph, this means all values reachable from both `a`\n+            //    and `b`. Note that this vector is also a set, but we\n+            //    use the term vector because the order matters\n+            //    to the steps below.\n+            //    - This vector contains upper bounds, but they are\n+            //      not minimal upper bounds. So you may have e.g.\n+            //      `[x, y, tcx, z]` where `x < tcx` and `y < tcx` and\n+            //      `z < x` and `z < y`:\n+            //\n+            //           z --+---> x ----+----> tcx\n+            //               |           |\n+            //               |           |\n+            //               +---> y ----+\n+            //\n+            //      In this case, we really want to return just `[z]`.\n+            //      The following steps below achieve this by gradually\n+            //      reducing the list.\n+            // 2. Pare down the vector using `pare_down`. This will\n+            //    remove elements from the vector that can be reached\n+            //    by an earlier element.\n+            //    - In the example above, this would convert `[x, y,\n+            //      tcx, z]` to `[x, y, z]`. Note that `x` and `y` are\n+            //      still in the vector; this is because while `z < x`\n+            //      (and `z < y`) holds, `z` comes after them in the\n+            //      vector.\n+            // 3. Reverse the vector and repeat the pare down process.\n+            //    - In the example above, we would reverse to\n+            //      `[z, y, x]` and then pare down to `[z]`.\n+            // 4. Reverse once more just so that we yield a vector in\n+            //    increasing order of index. Not necessary, but why not.\n+            //\n+            // I believe this algorithm yields a minimal set. The\n+            // argument is that, after step 2, we know that no element\n+            // can reach its successors (in the vector, not the graph).\n+            // After step 3, we know that no element can reach any of\n+            // its predecesssors (because of step 2) nor successors\n+            // (because we just called `pare_down`)\n+\n+            let mut candidates = closure.intersection(a.0, b.0); // (1)\n+            pare_down(&mut candidates, closure); // (2)\n+            candidates.reverse(); // (3a)\n+            pare_down(&mut candidates, closure); // (3b)\n+            candidates\n+        });\n+\n+        lub_indices.into_iter()\n+                   .rev() // (4)\n+                   .map(|i| &self.elements[i])\n+                   .collect()\n+    }\n+\n+    fn with_closure<OP,R>(&self, op: OP) -> R\n+        where OP: FnOnce(&BitMatrix) -> R\n+    {\n+        let mut closure_cell = self.closure.borrow_mut();\n+        let mut closure = closure_cell.take();\n+        if closure.is_none() {\n+            closure = Some(self.compute_closure());\n+        }\n+        let result = op(closure.as_ref().unwrap());\n+        *closure_cell = closure;\n+        result\n+    }\n+\n+    fn compute_closure(&self) -> BitMatrix {\n+        let mut matrix = BitMatrix::new(self.elements.len());\n+        let mut changed = true;\n+        while changed {\n+            changed = false;\n+            for edge in self.edges.iter() {\n+                // add an edge from S -> T\n+                changed |= matrix.add(edge.source.0, edge.target.0);\n+\n+                // add all outgoing edges from T into S\n+                changed |= matrix.merge(edge.target.0, edge.source.0);\n+            }\n+        }\n+        matrix\n+    }\n+}\n+\n+/// Pare down is used as a step in the LUB computation. It edits the\n+/// candidates array in place by removing any element j for which\n+/// there exists an earlier element i<j such that i -> j. That is,\n+/// after you run `pare_down`, you know that for all elements that\n+/// remain in candidates, they cannot reach any of the elements that\n+/// come after them.\n+///\n+/// Examples follow. Assume that a -> b -> c and x -> y -> z.\n+///\n+/// - Input: `[a, b, x]`. Output: `[a, x]`.\n+/// - Input: `[b, a, x]`. Output: `[b, a, x]`.\n+/// - Input: `[a, x, b, y]`. Output: `[a, x]`.\n+fn pare_down(candidates: &mut Vec<usize>, closure: &BitMatrix) {\n+    let mut i = 0;\n+    while i < candidates.len() {\n+        let candidate_i = candidates[i];\n+        i += 1;\n+\n+        let mut j = i;\n+        let mut dead = 0;\n+        while j < candidates.len() {\n+            let candidate_j = candidates[j];\n+            if closure.contains(candidate_i, candidate_j) {\n+                // If `i` can reach `j`, then we can remove `j`. So just\n+                // mark it as dead and move on; subsequent indices will be\n+                // shifted into its place.\n+                dead += 1;\n+            } else {\n+                candidates[j - dead] = candidate_j;\n+            }\n+            j += 1;\n+        }\n+        candidates.truncate(j - dead);\n+    }\n+}\n+\n+#[test]\n+fn test_one_step() {\n+    let mut relation = TransitiveRelation::new();\n+    relation.add(\"a\", \"b\");\n+    relation.add(\"a\", \"c\");\n+    assert!(relation.contains(&\"a\", &\"c\"));\n+    assert!(relation.contains(&\"a\", &\"b\"));\n+    assert!(!relation.contains(&\"b\", &\"a\"));\n+    assert!(!relation.contains(&\"a\", &\"d\"));\n+}\n+\n+#[test]\n+fn test_many_steps() {\n+    let mut relation = TransitiveRelation::new();\n+    relation.add(\"a\", \"b\");\n+    relation.add(\"a\", \"c\");\n+    relation.add(\"a\", \"f\");\n+\n+    relation.add(\"b\", \"c\");\n+    relation.add(\"b\", \"d\");\n+    relation.add(\"b\", \"e\");\n+\n+    relation.add(\"e\", \"g\");\n+\n+    assert!(relation.contains(&\"a\", &\"b\"));\n+    assert!(relation.contains(&\"a\", &\"c\"));\n+    assert!(relation.contains(&\"a\", &\"d\"));\n+    assert!(relation.contains(&\"a\", &\"e\"));\n+    assert!(relation.contains(&\"a\", &\"f\"));\n+    assert!(relation.contains(&\"a\", &\"g\"));\n+\n+    assert!(relation.contains(&\"b\", &\"g\"));\n+\n+    assert!(!relation.contains(&\"a\", &\"x\"));\n+    assert!(!relation.contains(&\"b\", &\"f\"));\n+}\n+\n+#[test]\n+fn mubs_triange() {\n+    let mut relation = TransitiveRelation::new();\n+    relation.add(\"a\", \"tcx\");\n+    relation.add(\"b\", \"tcx\");\n+    assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"tcx\"]);\n+}\n+\n+#[test]\n+fn mubs_best_choice1() {\n+    // 0 -> 1 <- 3\n+    // |    ^    |\n+    // |    |    |\n+    // +--> 2 <--+\n+    //\n+    // mubs(0,3) = [1]\n+\n+    // This tests a particular state in the algorithm, in which we\n+    // need the second pare down call to get the right result (after\n+    // intersection, we have [1, 2], but 2 -> 1).\n+\n+    let mut relation = TransitiveRelation::new();\n+    relation.add(\"0\", \"1\");\n+    relation.add(\"0\", \"2\");\n+\n+    relation.add(\"2\", \"1\");\n+\n+    relation.add(\"3\", \"1\");\n+    relation.add(\"3\", \"2\");\n+\n+    assert_eq!(relation.minimal_upper_bounds(&\"0\", &\"3\"), vec![&\"2\"]);\n+}\n+\n+#[test]\n+fn mubs_best_choice2() {\n+    // 0 -> 1 <- 3\n+    // |    |    |\n+    // |    v    |\n+    // +--> 2 <--+\n+    //\n+    // mubs(0,3) = [2]\n+\n+    // Like the precedecing test, but in this case intersection is [2,\n+    // 1], and hence we rely on the first pare down call.\n+\n+    let mut relation = TransitiveRelation::new();\n+    relation.add(\"0\", \"1\");\n+    relation.add(\"0\", \"2\");\n+\n+    relation.add(\"1\", \"2\");\n+\n+    relation.add(\"3\", \"1\");\n+    relation.add(\"3\", \"2\");\n+\n+    assert_eq!(relation.minimal_upper_bounds(&\"0\", &\"3\"), vec![&\"1\"]);\n+}\n+\n+#[test]\n+fn mubs_no_best_choice() {\n+    // in this case, the intersection yields [1, 2], and the \"pare\n+    // down\" calls find nothing to remove.\n+    let mut relation = TransitiveRelation::new();\n+    relation.add(\"0\", \"1\");\n+    relation.add(\"0\", \"2\");\n+\n+    relation.add(\"3\", \"1\");\n+    relation.add(\"3\", \"2\");\n+\n+    assert_eq!(relation.minimal_upper_bounds(&\"0\", &\"3\"), vec![&\"1\", &\"2\"]);\n+}\n+\n+#[test]\n+fn mubs_best_choice_scc() {\n+    let mut relation = TransitiveRelation::new();\n+    relation.add(\"0\", \"1\");\n+    relation.add(\"0\", \"2\");\n+\n+    relation.add(\"1\", \"2\");\n+    relation.add(\"2\", \"1\");\n+\n+    relation.add(\"3\", \"1\");\n+    relation.add(\"3\", \"2\");\n+\n+    assert_eq!(relation.minimal_upper_bounds(&\"0\", &\"3\"), vec![&\"1\"]);\n+}\n+\n+#[test]\n+fn pdub_crisscross() {\n+    // diagonal edges run left-to-right\n+    // a -> a1 -> x\n+    //   \\/       ^\n+    //   /\\       |\n+    // b -> b1 ---+\n+\n+    let mut relation = TransitiveRelation::new();\n+    relation.add(\"a\",  \"a1\");\n+    relation.add(\"a\",  \"b1\");\n+    relation.add(\"b\",  \"a1\");\n+    relation.add(\"b\",  \"b1\");\n+    relation.add(\"a1\", \"x\");\n+    relation.add(\"b1\", \"x\");\n+\n+    assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"a1\", &\"b1\"]);\n+    assert_eq!(relation.postdom_upper_bound(&\"a\", &\"b\"), Some(&\"x\"));\n+}\n+\n+#[test]\n+fn pdub_crisscross_more() {\n+    // diagonal edges run left-to-right\n+    // a -> a1 -> a2 -> a3 -> x\n+    //   \\/    \\/             ^\n+    //   /\\    /\\             |\n+    // b -> b1 -> b2 ---------+\n+\n+    let mut relation = TransitiveRelation::new();\n+    relation.add(\"a\",  \"a1\");\n+    relation.add(\"a\",  \"b1\");\n+    relation.add(\"b\",  \"a1\");\n+    relation.add(\"b\",  \"b1\");\n+\n+    relation.add(\"a1\",  \"a2\");\n+    relation.add(\"a1\",  \"b2\");\n+    relation.add(\"b1\",  \"a2\");\n+    relation.add(\"b1\",  \"b2\");\n+\n+    relation.add(\"a2\", \"a3\");\n+\n+    relation.add(\"a3\", \"x\");\n+    relation.add(\"b2\", \"x\");\n+\n+    assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"a1\", &\"b1\"]);\n+    assert_eq!(relation.minimal_upper_bounds(&\"a1\", &\"b1\"), vec![&\"a2\", &\"b2\"]);\n+    assert_eq!(relation.postdom_upper_bound(&\"a\", &\"b\"), Some(&\"x\"));\n+}\n+\n+#[test]\n+fn pdub_lub() {\n+    // a -> a1 -> x\n+    //            ^\n+    //            |\n+    // b -> b1 ---+\n+\n+    let mut relation = TransitiveRelation::new();\n+    relation.add(\"a\",  \"a1\");\n+    relation.add(\"b\",  \"b1\");\n+    relation.add(\"a1\", \"x\");\n+    relation.add(\"b1\", \"x\");\n+\n+    assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"x\"]);\n+    assert_eq!(relation.postdom_upper_bound(&\"a\", &\"b\"), Some(&\"x\"));\n+}\n+\n+#[test]\n+fn mubs_intermediate_node_on_one_side_only() {\n+    // a -> c -> d\n+    //           ^\n+    //           |\n+    //           b\n+\n+    // \"digraph { a -> c -> d; b -> d; }\",\n+    let mut relation = TransitiveRelation::new();\n+    relation.add(\"a\",  \"c\");\n+    relation.add(\"c\",  \"d\");\n+    relation.add(\"b\",  \"d\");\n+\n+    assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"d\"]);\n+}\n+\n+#[test]\n+fn mubs_scc_1() {\n+    // +-------------+\n+    // |    +----+   |\n+    // |    v    |   |\n+    // a -> c -> d <-+\n+    //           ^\n+    //           |\n+    //           b\n+\n+    // \"digraph { a -> c -> d; d -> c; a -> d; b -> d; }\",\n+    let mut relation = TransitiveRelation::new();\n+    relation.add(\"a\",  \"c\");\n+    relation.add(\"c\",  \"d\");\n+    relation.add(\"d\",  \"c\");\n+    relation.add(\"a\",  \"d\");\n+    relation.add(\"b\",  \"d\");\n+\n+    assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"c\"]);\n+}\n+\n+#[test]\n+fn mubs_scc_2() {\n+    //      +----+\n+    //      v    |\n+    // a -> c -> d\n+    //      ^    ^\n+    //      |    |\n+    //      +--- b\n+\n+    // \"digraph { a -> c -> d; d -> c; b -> d; b -> c; }\",\n+    let mut relation = TransitiveRelation::new();\n+    relation.add(\"a\",  \"c\");\n+    relation.add(\"c\",  \"d\");\n+    relation.add(\"d\",  \"c\");\n+    relation.add(\"b\",  \"d\");\n+    relation.add(\"b\",  \"c\");\n+\n+    assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"c\"]);\n+}\n+\n+#[test]\n+fn mubs_scc_3() {\n+    //      +---------+\n+    //      v         |\n+    // a -> c -> d -> e\n+    //           ^    ^\n+    //           |    |\n+    //           b ---+\n+\n+    // \"digraph { a -> c -> d -> e -> c; b -> d; b -> e; }\",\n+    let mut relation = TransitiveRelation::new();\n+    relation.add(\"a\",  \"c\");\n+    relation.add(\"c\",  \"d\");\n+    relation.add(\"d\",  \"e\");\n+    relation.add(\"e\",  \"c\");\n+    relation.add(\"b\",  \"d\");\n+    relation.add(\"b\",  \"e\");\n+\n+    assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"c\"]);\n+}\n+\n+#[test]\n+fn mubs_scc_4() {\n+    //      +---------+\n+    //      v         |\n+    // a -> c -> d -> e\n+    // |         ^    ^\n+    // +---------+    |\n+    //                |\n+    //           b ---+\n+\n+    // \"digraph { a -> c -> d -> e -> c; a -> d; b -> e; }\"\n+    let mut relation = TransitiveRelation::new();\n+    relation.add(\"a\",  \"c\");\n+    relation.add(\"c\",  \"d\");\n+    relation.add(\"d\",  \"e\");\n+    relation.add(\"e\",  \"c\");\n+    relation.add(\"a\",  \"d\");\n+    relation.add(\"b\",  \"e\");\n+\n+    assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"c\"]);\n+}"}, {"sha": "089e629a569d3ff43d39b4f73ccd09016c3becbb", "filename": "src/librustc_data_structures/unify/tests.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e5b99f47f4d96d2e3fabd05dc5a128a41245187/src%2Flibrustc_data_structures%2Funify%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e5b99f47f4d96d2e3fabd05dc5a128a41245187/src%2Flibrustc_data_structures%2Funify%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Funify%2Ftests.rs?ref=5e5b99f47f4d96d2e3fabd05dc5a128a41245187", "patch": "@@ -12,7 +12,6 @@\n \n extern crate test;\n use self::test::Bencher;\n-use std::collections::HashSet;\n use unify::{UnifyKey, UnificationTable};\n \n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]"}, {"sha": "df1b2c2cf43aa66adf58dc9e6113b6f7f25d832d", "filename": "src/test/run-pass/issue-27583.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/5e5b99f47f4d96d2e3fabd05dc5a128a41245187/src%2Ftest%2Frun-pass%2Fissue-27583.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e5b99f47f4d96d2e3fabd05dc5a128a41245187/src%2Ftest%2Frun-pass%2Fissue-27583.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-27583.rs?ref=5e5b99f47f4d96d2e3fabd05dc5a128a41245187", "patch": "@@ -0,0 +1,56 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for issue #27583. Unclear how useful this will be\n+// going forward, since the issue in question was EXTREMELY sensitive\n+// to compiler internals (like the precise numbering of nodes), but\n+// what the hey.\n+\n+#![allow(warnings)]\n+\n+use std::cell::Cell;\n+use std::marker::PhantomData;\n+\n+pub trait Delegate<'tcx> { }\n+\n+pub struct InferCtxt<'a, 'tcx: 'a> {\n+    x: PhantomData<&'a Cell<&'tcx ()>>\n+}\n+\n+pub struct MemCategorizationContext<'t, 'a: 't, 'tcx : 'a> {\n+    x: &'t InferCtxt<'a, 'tcx>,\n+}\n+\n+pub struct ExprUseVisitor<'d, 't, 'a: 't, 'tcx:'a+'d> {\n+    typer: &'t InferCtxt<'a, 'tcx>,\n+    mc: MemCategorizationContext<'t, 'a, 'tcx>,\n+    delegate: &'d mut (Delegate<'tcx>+'d),\n+}\n+\n+impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n+    pub fn new(delegate: &'d mut Delegate<'tcx>,\n+               typer: &'t InferCtxt<'a, 'tcx>)\n+               -> ExprUseVisitor<'d,'t,'a,'tcx>\n+    {\n+        ExprUseVisitor {\n+            typer: typer,\n+            mc: MemCategorizationContext::new(typer),\n+            delegate: delegate,\n+        }\n+    }\n+}\n+\n+impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n+    pub fn new(typer: &'t InferCtxt<'a, 'tcx>) -> MemCategorizationContext<'t, 'a, 'tcx> {\n+        MemCategorizationContext { x: typer }\n+    }\n+}\n+\n+fn main() { }"}, {"sha": "09c8d1f23a26da58423628d7e543df0363466132", "filename": "src/test/run-pass/regions-free-region-outlives-static-outlives-free-region.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5e5b99f47f4d96d2e3fabd05dc5a128a41245187/src%2Ftest%2Frun-pass%2Fregions-free-region-outlives-static-outlives-free-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e5b99f47f4d96d2e3fabd05dc5a128a41245187/src%2Ftest%2Frun-pass%2Fregions-free-region-outlives-static-outlives-free-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-free-region-outlives-static-outlives-free-region.rs?ref=5e5b99f47f4d96d2e3fabd05dc5a128a41245187", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we recognize that if you have\n+//\n+//     'a : 'static\n+//\n+// then\n+//\n+//     'a : 'b\n+\n+fn test<'a,'b>(x: &'a i32) -> &'b i32\n+    where 'a: 'static\n+{\n+    x\n+}\n+\n+fn main() { }"}]}