{"sha": "03b845a41f1666654ecffcbaa6a582170ec0ed8d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzYjg0NWE0MWYxNjY2NjU0ZWNmZmNiYWE2YTU4MjE3MGVjMGVkOGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-20T22:52:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-20T22:52:49Z"}, "message": "Auto merge of #85980 - ssomers:btree_cleanup_LeafRange, r=Mark-Simulacrum\n\nBTree: encapsulate LeafRange better & some debug asserts\n\nLooking at iterators again, I think #81937 didn't house enough code in `LeafRange`. Moving the API boundary a little makes things more local in navigate.rs and less complicated in map.rs.\n\nr? `@Mark-Simulacrum`", "tree": {"sha": "221b0f9607b742386ec454b76000559fef10f150", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/221b0f9607b742386ec454b76000559fef10f150"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/03b845a41f1666654ecffcbaa6a582170ec0ed8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/03b845a41f1666654ecffcbaa6a582170ec0ed8d", "html_url": "https://github.com/rust-lang/rust/commit/03b845a41f1666654ecffcbaa6a582170ec0ed8d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/03b845a41f1666654ecffcbaa6a582170ec0ed8d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e82b65026dcadf0998e3abf9dabc677f63160de7", "url": "https://api.github.com/repos/rust-lang/rust/commits/e82b65026dcadf0998e3abf9dabc677f63160de7", "html_url": "https://github.com/rust-lang/rust/commit/e82b65026dcadf0998e3abf9dabc677f63160de7"}, {"sha": "b9d43c603b0cd4ec516d0d6404331f3a73aa0689", "url": "https://api.github.com/repos/rust-lang/rust/commits/b9d43c603b0cd4ec516d0d6404331f3a73aa0689", "html_url": "https://github.com/rust-lang/rust/commit/b9d43c603b0cd4ec516d0d6404331f3a73aa0689"}], "stats": {"total": 384, "additions": 291, "deletions": 93}, "files": [{"sha": "920a5ca7db067891c871adc1173f2b56254cf7ff", "filename": "library/alloc/benches/btree/map.rs", "status": "modified", "additions": 32, "deletions": 7, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/03b845a41f1666654ecffcbaa6a582170ec0ed8d/library%2Falloc%2Fbenches%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b845a41f1666654ecffcbaa6a582170ec0ed8d/library%2Falloc%2Fbenches%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fbenches%2Fbtree%2Fmap.rs?ref=03b845a41f1666654ecffcbaa6a582170ec0ed8d", "patch": "@@ -177,7 +177,7 @@ pub fn iteration_mut_100000(b: &mut Bencher) {\n     bench_iteration_mut(b, 100000);\n }\n \n-fn bench_first_and_last(b: &mut Bencher, size: i32) {\n+fn bench_first_and_last_nightly(b: &mut Bencher, size: i32) {\n     let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n     b.iter(|| {\n         for _ in 0..10 {\n@@ -187,19 +187,44 @@ fn bench_first_and_last(b: &mut Bencher, size: i32) {\n     });\n }\n \n+fn bench_first_and_last_stable(b: &mut Bencher, size: i32) {\n+    let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n+    b.iter(|| {\n+        for _ in 0..10 {\n+            black_box(map.iter().next());\n+            black_box(map.iter().next_back());\n+        }\n+    });\n+}\n+\n+#[bench]\n+pub fn first_and_last_0_nightly(b: &mut Bencher) {\n+    bench_first_and_last_nightly(b, 0);\n+}\n+\n+#[bench]\n+pub fn first_and_last_0_stable(b: &mut Bencher) {\n+    bench_first_and_last_stable(b, 0);\n+}\n+\n+#[bench]\n+pub fn first_and_last_100_nightly(b: &mut Bencher) {\n+    bench_first_and_last_nightly(b, 100);\n+}\n+\n #[bench]\n-pub fn first_and_last_0(b: &mut Bencher) {\n-    bench_first_and_last(b, 0);\n+pub fn first_and_last_100_stable(b: &mut Bencher) {\n+    bench_first_and_last_stable(b, 100);\n }\n \n #[bench]\n-pub fn first_and_last_100(b: &mut Bencher) {\n-    bench_first_and_last(b, 100);\n+pub fn first_and_last_10k_nightly(b: &mut Bencher) {\n+    bench_first_and_last_nightly(b, 10_000);\n }\n \n #[bench]\n-pub fn first_and_last_10k(b: &mut Bencher) {\n-    bench_first_and_last(b, 10_000);\n+pub fn first_and_last_10k_stable(b: &mut Bencher) {\n+    bench_first_and_last_stable(b, 10_000);\n }\n \n const BENCH_RANGE_SIZE: i32 = 145;"}, {"sha": "d7519c6d0936c186490cc0ba43f3f81e8c78d590", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 12, "deletions": 36, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/03b845a41f1666654ecffcbaa6a582170ec0ed8d/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b845a41f1666654ecffcbaa6a582170ec0ed8d/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=03b845a41f1666654ecffcbaa6a582170ec0ed8d", "patch": "@@ -1299,7 +1299,7 @@ impl<'a, K: 'a, V: 'a> Iterator for Iter<'a, K, V> {\n             None\n         } else {\n             self.length -= 1;\n-            Some(unsafe { self.range.next_unchecked() })\n+            Some(unsafe { self.range.inner.next_unchecked() })\n         }\n     }\n \n@@ -1330,7 +1330,7 @@ impl<'a, K: 'a, V: 'a> DoubleEndedIterator for Iter<'a, K, V> {\n             None\n         } else {\n             self.length -= 1;\n-            Some(unsafe { self.range.next_back_unchecked() })\n+            Some(unsafe { self.range.inner.next_back_unchecked() })\n         }\n     }\n }\n@@ -1368,7 +1368,7 @@ impl<'a, K: 'a, V: 'a> Iterator for IterMut<'a, K, V> {\n             None\n         } else {\n             self.length -= 1;\n-            Some(unsafe { self.range.next_unchecked() })\n+            Some(unsafe { self.range.inner.next_unchecked() })\n         }\n     }\n \n@@ -1396,7 +1396,7 @@ impl<'a, K: 'a, V: 'a> DoubleEndedIterator for IterMut<'a, K, V> {\n             None\n         } else {\n             self.length -= 1;\n-            Some(unsafe { self.range.next_back_unchecked() })\n+            Some(unsafe { self.range.inner.next_back_unchecked() })\n         }\n     }\n }\n@@ -1475,7 +1475,7 @@ impl<K, V> Drop for Dropper<K, V> {\n #[stable(feature = \"btree_drop\", since = \"1.7.0\")]\n impl<K, V> Drop for IntoIter<K, V> {\n     fn drop(&mut self) {\n-        if let Some(front) = self.range.front.take() {\n+        if let Some(front) = self.range.take_front() {\n             Dropper { front, remaining_length: self.length };\n         }\n     }\n@@ -1490,8 +1490,7 @@ impl<K, V> Iterator for IntoIter<K, V> {\n             None\n         } else {\n             self.length -= 1;\n-            let front = self.range.front.as_mut().unwrap();\n-            let kv = unsafe { front.deallocating_next_unchecked() };\n+            let kv = unsafe { self.range.deallocating_next_unchecked() };\n             Some(kv.into_key_val())\n         }\n     }\n@@ -1508,8 +1507,7 @@ impl<K, V> DoubleEndedIterator for IntoIter<K, V> {\n             None\n         } else {\n             self.length -= 1;\n-            let back = self.range.back.as_mut().unwrap();\n-            let kv = unsafe { back.deallocating_next_back_unchecked() };\n+            let kv = unsafe { self.range.deallocating_next_back_unchecked() };\n             Some(kv.into_key_val())\n         }\n     }\n@@ -1727,7 +1725,7 @@ impl<'a, K, V> Iterator for Range<'a, K, V> {\n     type Item = (&'a K, &'a V);\n \n     fn next(&mut self) -> Option<(&'a K, &'a V)> {\n-        if self.inner.is_empty() { None } else { Some(unsafe { self.next_unchecked() }) }\n+        self.inner.next_checked()\n     }\n \n     fn last(mut self) -> Option<(&'a K, &'a V)> {\n@@ -1777,12 +1775,6 @@ impl<K, V> ExactSizeIterator for ValuesMut<'_, K, V> {\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<K, V> FusedIterator for ValuesMut<'_, K, V> {}\n \n-impl<'a, K, V> Range<'a, K, V> {\n-    unsafe fn next_unchecked(&mut self) -> (&'a K, &'a V) {\n-        unsafe { self.inner.front.as_mut().unwrap_unchecked().next_unchecked() }\n-    }\n-}\n-\n #[stable(feature = \"map_into_keys_values\", since = \"1.54.0\")]\n impl<K, V> Iterator for IntoKeys<K, V> {\n     type Item = K;\n@@ -1862,13 +1854,7 @@ impl<K, V> FusedIterator for IntoValues<K, V> {}\n #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n impl<'a, K, V> DoubleEndedIterator for Range<'a, K, V> {\n     fn next_back(&mut self) -> Option<(&'a K, &'a V)> {\n-        if self.inner.is_empty() { None } else { Some(unsafe { self.next_back_unchecked() }) }\n-    }\n-}\n-\n-impl<'a, K, V> Range<'a, K, V> {\n-    unsafe fn next_back_unchecked(&mut self) -> (&'a K, &'a V) {\n-        unsafe { self.inner.back.as_mut().unwrap_unchecked().next_back_unchecked() }\n+        self.inner.next_back_checked()\n     }\n }\n \n@@ -1878,7 +1864,7 @@ impl<K, V> FusedIterator for Range<'_, K, V> {}\n #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n impl<K, V> Clone for Range<'_, K, V> {\n     fn clone(&self) -> Self {\n-        Range { inner: LeafRange { front: self.inner.front, back: self.inner.back } }\n+        Range { inner: self.inner.clone() }\n     }\n }\n \n@@ -1887,7 +1873,7 @@ impl<'a, K, V> Iterator for RangeMut<'a, K, V> {\n     type Item = (&'a K, &'a mut V);\n \n     fn next(&mut self) -> Option<(&'a K, &'a mut V)> {\n-        if self.inner.is_empty() { None } else { Some(unsafe { self.next_unchecked() }) }\n+        self.inner.next_checked()\n     }\n \n     fn last(mut self) -> Option<(&'a K, &'a mut V)> {\n@@ -1904,10 +1890,6 @@ impl<'a, K, V> Iterator for RangeMut<'a, K, V> {\n }\n \n impl<'a, K, V> RangeMut<'a, K, V> {\n-    unsafe fn next_unchecked(&mut self) -> (&'a K, &'a mut V) {\n-        unsafe { self.inner.front.as_mut().unwrap_unchecked().next_unchecked() }\n-    }\n-\n     /// Returns an iterator of references over the remaining items.\n     #[inline]\n     pub(super) fn iter(&self) -> Range<'_, K, V> {\n@@ -1918,19 +1900,13 @@ impl<'a, K, V> RangeMut<'a, K, V> {\n #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n impl<'a, K, V> DoubleEndedIterator for RangeMut<'a, K, V> {\n     fn next_back(&mut self) -> Option<(&'a K, &'a mut V)> {\n-        if self.inner.is_empty() { None } else { Some(unsafe { self.next_back_unchecked() }) }\n+        self.inner.next_back_checked()\n     }\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<K, V> FusedIterator for RangeMut<'_, K, V> {}\n \n-impl<'a, K, V> RangeMut<'a, K, V> {\n-    unsafe fn next_back_unchecked(&mut self) -> (&'a K, &'a mut V) {\n-        unsafe { self.inner.back.as_mut().unwrap_unchecked().next_back_unchecked() }\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Ord, V> FromIterator<(K, V)> for BTreeMap<K, V> {\n     fn from_iter<T: IntoIterator<Item = (K, V)>>(iter: T) -> BTreeMap<K, V> {"}, {"sha": "17568f7b005ba64d5b28e503027d0068d2ee68bf", "filename": "library/alloc/src/collections/btree/navigate.rs", "status": "modified", "additions": 99, "deletions": 15, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/03b845a41f1666654ecffcbaa6a582170ec0ed8d/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b845a41f1666654ecffcbaa6a582170ec0ed8d/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs?ref=03b845a41f1666654ecffcbaa6a582170ec0ed8d", "patch": "@@ -4,17 +4,24 @@ use core::ptr;\n \n use super::node::{marker, ForceResult::*, Handle, NodeRef};\n \n+// `front` and `back` are always both `None` or both `Some`.\n pub struct LeafRange<BorrowType, K, V> {\n-    pub front: Option<Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge>>,\n-    pub back: Option<Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge>>,\n+    front: Option<Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge>>,\n+    back: Option<Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge>>,\n+}\n+\n+impl<'a, K: 'a, V: 'a> Clone for LeafRange<marker::Immut<'a>, K, V> {\n+    fn clone(&self) -> Self {\n+        LeafRange { front: self.front.clone(), back: self.back.clone() }\n+    }\n }\n \n impl<BorrowType, K, V> LeafRange<BorrowType, K, V> {\n     pub fn none() -> Self {\n         LeafRange { front: None, back: None }\n     }\n \n-    pub fn is_empty(&self) -> bool {\n+    fn is_empty(&self) -> bool {\n         self.front == self.back\n     }\n \n@@ -27,6 +34,81 @@ impl<BorrowType, K, V> LeafRange<BorrowType, K, V> {\n     }\n }\n \n+impl<'a, K, V> LeafRange<marker::Immut<'a>, K, V> {\n+    #[inline]\n+    pub fn next_checked(&mut self) -> Option<(&'a K, &'a V)> {\n+        if self.is_empty() { None } else { Some(unsafe { self.next_unchecked() }) }\n+    }\n+\n+    #[inline]\n+    pub fn next_back_checked(&mut self) -> Option<(&'a K, &'a V)> {\n+        if self.is_empty() { None } else { Some(unsafe { self.next_back_unchecked() }) }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn next_unchecked(&mut self) -> (&'a K, &'a V) {\n+        debug_assert!(self.front.is_some());\n+        unsafe { self.front.as_mut().unwrap_unchecked().next_unchecked() }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn next_back_unchecked(&mut self) -> (&'a K, &'a V) {\n+        debug_assert!(self.back.is_some());\n+        unsafe { self.back.as_mut().unwrap_unchecked().next_back_unchecked() }\n+    }\n+}\n+\n+impl<'a, K, V> LeafRange<marker::ValMut<'a>, K, V> {\n+    #[inline]\n+    pub fn next_checked(&mut self) -> Option<(&'a K, &'a mut V)> {\n+        if self.is_empty() { None } else { Some(unsafe { self.next_unchecked() }) }\n+    }\n+\n+    #[inline]\n+    pub fn next_back_checked(&mut self) -> Option<(&'a K, &'a mut V)> {\n+        if self.is_empty() { None } else { Some(unsafe { self.next_back_unchecked() }) }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn next_unchecked(&mut self) -> (&'a K, &'a mut V) {\n+        debug_assert!(self.front.is_some());\n+        unsafe { self.front.as_mut().unwrap_unchecked().next_unchecked() }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn next_back_unchecked(&mut self) -> (&'a K, &'a mut V) {\n+        debug_assert!(self.back.is_some());\n+        unsafe { self.back.as_mut().unwrap_unchecked().next_back_unchecked() }\n+    }\n+}\n+\n+impl<K, V> LeafRange<marker::Dying, K, V> {\n+    #[inline]\n+    pub fn take_front(\n+        &mut self,\n+    ) -> Option<Handle<NodeRef<marker::Dying, K, V, marker::Leaf>, marker::Edge>> {\n+        self.front.take()\n+    }\n+\n+    #[inline]\n+    pub unsafe fn deallocating_next_unchecked(\n+        &mut self,\n+    ) -> Handle<NodeRef<marker::Dying, K, V, marker::LeafOrInternal>, marker::KV> {\n+        debug_assert!(self.front.is_some());\n+        let front = self.front.as_mut().unwrap();\n+        unsafe { front.deallocating_next_unchecked() }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn deallocating_next_back_unchecked(\n+        &mut self,\n+    ) -> Handle<NodeRef<marker::Dying, K, V, marker::LeafOrInternal>, marker::KV> {\n+        debug_assert!(self.back.is_some());\n+        let back = self.back.as_mut().unwrap();\n+        unsafe { back.deallocating_next_back_unchecked() }\n+    }\n+}\n+\n impl<BorrowType: marker::BorrowType, K, V> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n     /// Finds the distinct leaf edges delimiting a specified range in a tree.\n     ///\n@@ -36,7 +118,7 @@ impl<BorrowType: marker::BorrowType, K, V> NodeRef<BorrowType, K, V, marker::Lea\n     /// result will eventually reach the same edge.\n     ///\n     /// If there are no such edges, i.e., if the tree contains no key within\n-    /// the range, returns a pair of empty options.\n+    /// the range, returns an empty `front` and `back`.\n     ///\n     /// # Safety\n     /// Unless `BorrowType` is `Immut`, do not use the handles to visit the same\n@@ -191,7 +273,7 @@ impl<BorrowType: marker::BorrowType, K, V>\n     /// Given a leaf edge handle, returns [`Result::Ok`] with a handle to the neighboring KV\n     /// on the left side, which is either in the same leaf node or in an ancestor node.\n     /// If the leaf edge is the first one in the tree, returns [`Result::Err`] with the root node.\n-    pub fn next_back_kv(\n+    fn next_back_kv(\n         self,\n     ) -> Result<\n         Handle<NodeRef<BorrowType, K, V, marker::LeafOrInternal>, marker::KV>,\n@@ -216,7 +298,7 @@ impl<BorrowType: marker::BorrowType, K, V>\n     /// Given an internal edge handle, returns [`Result::Ok`] with a handle to the neighboring KV\n     /// on the right side, which is either in the same internal node or in an ancestor node.\n     /// If the internal edge is the last one in the tree, returns [`Result::Err`] with the root node.\n-    pub fn next_kv(\n+    fn next_kv(\n         self,\n     ) -> Result<\n         Handle<NodeRef<BorrowType, K, V, marker::Internal>, marker::KV>,\n@@ -250,7 +332,7 @@ impl<K, V> Handle<NodeRef<marker::Dying, K, V, marker::Leaf>, marker::Edge> {\n     /// - The returned KV handle is only valid to access the key and value,\n     ///   and only valid until the next call to this method or counterpart\n     ///   `deallocating_next_back`.\n-    pub unsafe fn deallocating_next(\n+    unsafe fn deallocating_next(\n         self,\n     ) -> Option<(Self, Handle<NodeRef<marker::Dying, K, V, marker::LeafOrInternal>, marker::KV>)>\n     {\n@@ -316,9 +398,10 @@ impl<'a, K, V> Handle<NodeRef<marker::Immut<'a>, K, V, marker::Leaf>, marker::Ed\n     ///\n     /// # Safety\n     /// There must be another KV in the direction travelled.\n-    pub unsafe fn next_unchecked(&mut self) -> (&'a K, &'a V) {\n+    unsafe fn next_unchecked(&mut self) -> (&'a K, &'a V) {\n         super::mem::replace(self, |leaf_edge| {\n             let kv = leaf_edge.next_kv();\n+            debug_assert!(kv.is_ok());\n             let kv = unsafe { kv.ok().unwrap_unchecked() };\n             (kv.next_leaf_edge(), kv.into_kv())\n         })\n@@ -329,9 +412,10 @@ impl<'a, K, V> Handle<NodeRef<marker::Immut<'a>, K, V, marker::Leaf>, marker::Ed\n     ///\n     /// # Safety\n     /// There must be another KV in the direction travelled.\n-    pub unsafe fn next_back_unchecked(&mut self) -> (&'a K, &'a V) {\n+    unsafe fn next_back_unchecked(&mut self) -> (&'a K, &'a V) {\n         super::mem::replace(self, |leaf_edge| {\n             let kv = leaf_edge.next_back_kv();\n+            debug_assert!(kv.is_ok());\n             let kv = unsafe { kv.ok().unwrap_unchecked() };\n             (kv.next_back_leaf_edge(), kv.into_kv())\n         })\n@@ -344,9 +428,10 @@ impl<'a, K, V> Handle<NodeRef<marker::ValMut<'a>, K, V, marker::Leaf>, marker::E\n     ///\n     /// # Safety\n     /// There must be another KV in the direction travelled.\n-    pub unsafe fn next_unchecked(&mut self) -> (&'a K, &'a mut V) {\n+    unsafe fn next_unchecked(&mut self) -> (&'a K, &'a mut V) {\n         let kv = super::mem::replace(self, |leaf_edge| {\n             let kv = leaf_edge.next_kv();\n+            debug_assert!(kv.is_ok());\n             let kv = unsafe { kv.ok().unwrap_unchecked() };\n             (unsafe { ptr::read(&kv) }.next_leaf_edge(), kv)\n         });\n@@ -359,9 +444,10 @@ impl<'a, K, V> Handle<NodeRef<marker::ValMut<'a>, K, V, marker::Leaf>, marker::E\n     ///\n     /// # Safety\n     /// There must be another KV in the direction travelled.\n-    pub unsafe fn next_back_unchecked(&mut self) -> (&'a K, &'a mut V) {\n+    unsafe fn next_back_unchecked(&mut self) -> (&'a K, &'a mut V) {\n         let kv = super::mem::replace(self, |leaf_edge| {\n             let kv = leaf_edge.next_back_kv();\n+            debug_assert!(kv.is_ok());\n             let kv = unsafe { kv.ok().unwrap_unchecked() };\n             (unsafe { ptr::read(&kv) }.next_back_leaf_edge(), kv)\n         });\n@@ -403,7 +489,7 @@ impl<K, V> Handle<NodeRef<marker::Dying, K, V, marker::Leaf>, marker::Edge> {\n     ///\n     /// The only safe way to proceed with the updated handle is to compare it, drop it,\n     /// or call this method or counterpart `deallocating_next_unchecked` again.\n-    pub unsafe fn deallocating_next_back_unchecked(\n+    unsafe fn deallocating_next_back_unchecked(\n         &mut self,\n     ) -> Handle<NodeRef<marker::Dying, K, V, marker::LeafOrInternal>, marker::KV> {\n         super::mem::replace(self, |leaf_edge| unsafe {\n@@ -508,9 +594,7 @@ impl<BorrowType: marker::BorrowType, K, V>\n     }\n \n     /// Returns the leaf edge closest to a KV for backward navigation.\n-    pub fn next_back_leaf_edge(\n-        self,\n-    ) -> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge> {\n+    fn next_back_leaf_edge(self) -> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge> {\n         match self.force() {\n             Leaf(leaf_kv) => leaf_kv.left_edge(),\n             Internal(internal_kv) => {"}, {"sha": "4b653238aa75032cd6e9aeeb9c332bd5308fd1ff", "filename": "src/test/ui/variance/variance-btree-invariant-types.nll.stderr", "status": "modified", "additions": 49, "deletions": 9, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/03b845a41f1666654ecffcbaa6a582170ec0ed8d/src%2Ftest%2Fui%2Fvariance%2Fvariance-btree-invariant-types.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/03b845a41f1666654ecffcbaa6a582170ec0ed8d/src%2Ftest%2Fui%2Fvariance%2Fvariance-btree-invariant-types.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fvariance%2Fvariance-btree-invariant-types.nll.stderr?ref=03b845a41f1666654ecffcbaa6a582170ec0ed8d", "patch": "@@ -39,7 +39,47 @@ LL |     v\n    = help: consider replacing `'new` with `'static`\n \n error: lifetime may not live long enough\n-  --> $DIR/variance-btree-invariant-types.rs:18:5\n+  --> $DIR/variance-btree-invariant-types.rs:17:5\n+   |\n+LL | fn range_cov_key<'a, 'new>(v: RangeMut<'a, &'static (), ()>) -> RangeMut<'a, &'new (), ()> {\n+   |                      ---- lifetime `'new` defined here\n+LL |     v\n+   |     ^ returning this value requires that `'new` must outlive `'static`\n+   |\n+   = help: consider replacing `'new` with `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/variance-btree-invariant-types.rs:20:5\n+   |\n+LL | fn range_cov_val<'a, 'new>(v: RangeMut<'a, (), &'static ()>) -> RangeMut<'a, (), &'new ()> {\n+   |                      ---- lifetime `'new` defined here\n+LL |     v\n+   |     ^ returning this value requires that `'new` must outlive `'static`\n+   |\n+   = help: consider replacing `'new` with `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/variance-btree-invariant-types.rs:23:5\n+   |\n+LL | fn range_contra_key<'a, 'new>(v: RangeMut<'a, &'new (), ()>) -> RangeMut<'a, &'static (), ()> {\n+   |                         ---- lifetime `'new` defined here\n+LL |     v\n+   |     ^ returning this value requires that `'new` must outlive `'static`\n+   |\n+   = help: consider replacing `'new` with `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/variance-btree-invariant-types.rs:26:5\n+   |\n+LL | fn range_contra_val<'a, 'new>(v: RangeMut<'a, (), &'new ()>) -> RangeMut<'a, (), &'static ()> {\n+   |                         ---- lifetime `'new` defined here\n+LL |     v\n+   |     ^ returning this value requires that `'new` must outlive `'static`\n+   |\n+   = help: consider replacing `'new` with `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/variance-btree-invariant-types.rs:31:5\n    |\n LL | fn occ_cov_key<'a, 'new>(v: OccupiedEntry<'a, &'static (), ()>)\n    |                    ---- lifetime `'new` defined here\n@@ -50,7 +90,7 @@ LL |     v\n    = help: consider replacing `'new` with `'static`\n \n error: lifetime may not live long enough\n-  --> $DIR/variance-btree-invariant-types.rs:22:5\n+  --> $DIR/variance-btree-invariant-types.rs:35:5\n    |\n LL | fn occ_cov_val<'a, 'new>(v: OccupiedEntry<'a, (), &'static ()>)\n    |                    ---- lifetime `'new` defined here\n@@ -61,7 +101,7 @@ LL |     v\n    = help: consider replacing `'new` with `'static`\n \n error: lifetime may not live long enough\n-  --> $DIR/variance-btree-invariant-types.rs:26:5\n+  --> $DIR/variance-btree-invariant-types.rs:39:5\n    |\n LL | fn occ_contra_key<'a, 'new>(v: OccupiedEntry<'a, &'new (), ()>)\n    |                       ---- lifetime `'new` defined here\n@@ -72,7 +112,7 @@ LL |     v\n    = help: consider replacing `'new` with `'static`\n \n error: lifetime may not live long enough\n-  --> $DIR/variance-btree-invariant-types.rs:30:5\n+  --> $DIR/variance-btree-invariant-types.rs:43:5\n    |\n LL | fn occ_contra_val<'a, 'new>(v: OccupiedEntry<'a, (), &'new ()>)\n    |                       ---- lifetime `'new` defined here\n@@ -83,7 +123,7 @@ LL |     v\n    = help: consider replacing `'new` with `'static`\n \n error: lifetime may not live long enough\n-  --> $DIR/variance-btree-invariant-types.rs:35:5\n+  --> $DIR/variance-btree-invariant-types.rs:48:5\n    |\n LL | fn vac_cov_key<'a, 'new>(v: VacantEntry<'a, &'static (), ()>)\n    |                    ---- lifetime `'new` defined here\n@@ -94,7 +134,7 @@ LL |     v\n    = help: consider replacing `'new` with `'static`\n \n error: lifetime may not live long enough\n-  --> $DIR/variance-btree-invariant-types.rs:39:5\n+  --> $DIR/variance-btree-invariant-types.rs:52:5\n    |\n LL | fn vac_cov_val<'a, 'new>(v: VacantEntry<'a, (), &'static ()>)\n    |                    ---- lifetime `'new` defined here\n@@ -105,7 +145,7 @@ LL |     v\n    = help: consider replacing `'new` with `'static`\n \n error: lifetime may not live long enough\n-  --> $DIR/variance-btree-invariant-types.rs:43:5\n+  --> $DIR/variance-btree-invariant-types.rs:56:5\n    |\n LL | fn vac_contra_key<'a, 'new>(v: VacantEntry<'a, &'new (), ()>)\n    |                       ---- lifetime `'new` defined here\n@@ -116,7 +156,7 @@ LL |     v\n    = help: consider replacing `'new` with `'static`\n \n error: lifetime may not live long enough\n-  --> $DIR/variance-btree-invariant-types.rs:47:5\n+  --> $DIR/variance-btree-invariant-types.rs:60:5\n    |\n LL | fn vac_contra_val<'a, 'new>(v: VacantEntry<'a, (), &'new ()>)\n    |                       ---- lifetime `'new` defined here\n@@ -126,5 +166,5 @@ LL |     v\n    |\n    = help: consider replacing `'new` with `'static`\n \n-error: aborting due to 12 previous errors\n+error: aborting due to 16 previous errors\n "}, {"sha": "4549622f24ac3276710b150c2e0c4cda970bc6b2", "filename": "src/test/ui/variance/variance-btree-invariant-types.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/03b845a41f1666654ecffcbaa6a582170ec0ed8d/src%2Ftest%2Fui%2Fvariance%2Fvariance-btree-invariant-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b845a41f1666654ecffcbaa6a582170ec0ed8d/src%2Ftest%2Fui%2Fvariance%2Fvariance-btree-invariant-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fvariance%2Fvariance-btree-invariant-types.rs?ref=03b845a41f1666654ecffcbaa6a582170ec0ed8d", "patch": "@@ -1,4 +1,4 @@\n-use std::collections::btree_map::{IterMut, OccupiedEntry, VacantEntry};\n+use std::collections::btree_map::{IterMut, OccupiedEntry, RangeMut, VacantEntry};\n \n fn iter_cov_key<'a, 'new>(v: IterMut<'a, &'static (), ()>) -> IterMut<'a, &'new (), ()> {\n     v //~ ERROR mismatched types\n@@ -13,6 +13,19 @@ fn iter_contra_val<'a, 'new>(v: IterMut<'a, (), &'new ()>) -> IterMut<'a, (), &'\n     v //~ ERROR mismatched types\n }\n \n+fn range_cov_key<'a, 'new>(v: RangeMut<'a, &'static (), ()>) -> RangeMut<'a, &'new (), ()> {\n+    v //~ ERROR mismatched types\n+}\n+fn range_cov_val<'a, 'new>(v: RangeMut<'a, (), &'static ()>) -> RangeMut<'a, (), &'new ()> {\n+    v //~ ERROR mismatched types\n+}\n+fn range_contra_key<'a, 'new>(v: RangeMut<'a, &'new (), ()>) -> RangeMut<'a, &'static (), ()> {\n+    v //~ ERROR mismatched types\n+}\n+fn range_contra_val<'a, 'new>(v: RangeMut<'a, (), &'new ()>) -> RangeMut<'a, (), &'static ()> {\n+    v //~ ERROR mismatched types\n+}\n+\n fn occ_cov_key<'a, 'new>(v: OccupiedEntry<'a, &'static (), ()>)\n                          -> OccupiedEntry<'a, &'new (), ()> {\n     v //~ ERROR mismatched types"}, {"sha": "ba47bdff281a2afe6422db485e2761d09bca29e2", "filename": "src/test/ui/variance/variance-btree-invariant-types.stderr", "status": "modified", "additions": 85, "deletions": 25, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/03b845a41f1666654ecffcbaa6a582170ec0ed8d/src%2Ftest%2Fui%2Fvariance%2Fvariance-btree-invariant-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/03b845a41f1666654ecffcbaa6a582170ec0ed8d/src%2Ftest%2Fui%2Fvariance%2Fvariance-btree-invariant-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fvariance%2Fvariance-btree-invariant-types.stderr?ref=03b845a41f1666654ecffcbaa6a582170ec0ed8d", "patch": "@@ -59,125 +59,185 @@ LL | fn iter_contra_val<'a, 'new>(v: IterMut<'a, (), &'new ()>) -> IterMut<'a, (\n    = note: ...does not necessarily outlive the static lifetime\n \n error[E0308]: mismatched types\n-  --> $DIR/variance-btree-invariant-types.rs:18:5\n+  --> $DIR/variance-btree-invariant-types.rs:17:5\n+   |\n+LL |     v\n+   |     ^ lifetime mismatch\n+   |\n+   = note: expected struct `RangeMut<'_, &'new (), _>`\n+              found struct `RangeMut<'_, &'static (), _>`\n+note: the lifetime `'new` as defined on the function body at 16:22...\n+  --> $DIR/variance-btree-invariant-types.rs:16:22\n+   |\n+LL | fn range_cov_key<'a, 'new>(v: RangeMut<'a, &'static (), ()>) -> RangeMut<'a, &'new (), ()> {\n+   |                      ^^^^\n+   = note: ...does not necessarily outlive the static lifetime\n+\n+error[E0308]: mismatched types\n+  --> $DIR/variance-btree-invariant-types.rs:20:5\n+   |\n+LL |     v\n+   |     ^ lifetime mismatch\n+   |\n+   = note: expected struct `RangeMut<'_, _, &'new ()>`\n+              found struct `RangeMut<'_, _, &'static ()>`\n+note: the lifetime `'new` as defined on the function body at 19:22...\n+  --> $DIR/variance-btree-invariant-types.rs:19:22\n+   |\n+LL | fn range_cov_val<'a, 'new>(v: RangeMut<'a, (), &'static ()>) -> RangeMut<'a, (), &'new ()> {\n+   |                      ^^^^\n+   = note: ...does not necessarily outlive the static lifetime\n+\n+error[E0308]: mismatched types\n+  --> $DIR/variance-btree-invariant-types.rs:23:5\n+   |\n+LL |     v\n+   |     ^ lifetime mismatch\n+   |\n+   = note: expected struct `RangeMut<'_, &'static (), _>`\n+              found struct `RangeMut<'_, &'new (), _>`\n+note: the lifetime `'new` as defined on the function body at 22:25...\n+  --> $DIR/variance-btree-invariant-types.rs:22:25\n+   |\n+LL | fn range_contra_key<'a, 'new>(v: RangeMut<'a, &'new (), ()>) -> RangeMut<'a, &'static (), ()> {\n+   |                         ^^^^\n+   = note: ...does not necessarily outlive the static lifetime\n+\n+error[E0308]: mismatched types\n+  --> $DIR/variance-btree-invariant-types.rs:26:5\n+   |\n+LL |     v\n+   |     ^ lifetime mismatch\n+   |\n+   = note: expected struct `RangeMut<'_, _, &'static ()>`\n+              found struct `RangeMut<'_, _, &'new ()>`\n+note: the lifetime `'new` as defined on the function body at 25:25...\n+  --> $DIR/variance-btree-invariant-types.rs:25:25\n+   |\n+LL | fn range_contra_val<'a, 'new>(v: RangeMut<'a, (), &'new ()>) -> RangeMut<'a, (), &'static ()> {\n+   |                         ^^^^\n+   = note: ...does not necessarily outlive the static lifetime\n+\n+error[E0308]: mismatched types\n+  --> $DIR/variance-btree-invariant-types.rs:31:5\n    |\n LL |     v\n    |     ^ lifetime mismatch\n    |\n    = note: expected struct `std::collections::btree_map::OccupiedEntry<'_, &'new (), _>`\n               found struct `std::collections::btree_map::OccupiedEntry<'_, &'static (), _>`\n-note: the lifetime `'new` as defined on the function body at 16:20...\n-  --> $DIR/variance-btree-invariant-types.rs:16:20\n+note: the lifetime `'new` as defined on the function body at 29:20...\n+  --> $DIR/variance-btree-invariant-types.rs:29:20\n    |\n LL | fn occ_cov_key<'a, 'new>(v: OccupiedEntry<'a, &'static (), ()>)\n    |                    ^^^^\n    = note: ...does not necessarily outlive the static lifetime\n \n error[E0308]: mismatched types\n-  --> $DIR/variance-btree-invariant-types.rs:22:5\n+  --> $DIR/variance-btree-invariant-types.rs:35:5\n    |\n LL |     v\n    |     ^ lifetime mismatch\n    |\n    = note: expected struct `std::collections::btree_map::OccupiedEntry<'_, _, &'new ()>`\n               found struct `std::collections::btree_map::OccupiedEntry<'_, _, &'static ()>`\n-note: the lifetime `'new` as defined on the function body at 20:20...\n-  --> $DIR/variance-btree-invariant-types.rs:20:20\n+note: the lifetime `'new` as defined on the function body at 33:20...\n+  --> $DIR/variance-btree-invariant-types.rs:33:20\n    |\n LL | fn occ_cov_val<'a, 'new>(v: OccupiedEntry<'a, (), &'static ()>)\n    |                    ^^^^\n    = note: ...does not necessarily outlive the static lifetime\n \n error[E0308]: mismatched types\n-  --> $DIR/variance-btree-invariant-types.rs:26:5\n+  --> $DIR/variance-btree-invariant-types.rs:39:5\n    |\n LL |     v\n    |     ^ lifetime mismatch\n    |\n    = note: expected struct `std::collections::btree_map::OccupiedEntry<'_, &'static (), _>`\n               found struct `std::collections::btree_map::OccupiedEntry<'_, &'new (), _>`\n-note: the lifetime `'new` as defined on the function body at 24:23...\n-  --> $DIR/variance-btree-invariant-types.rs:24:23\n+note: the lifetime `'new` as defined on the function body at 37:23...\n+  --> $DIR/variance-btree-invariant-types.rs:37:23\n    |\n LL | fn occ_contra_key<'a, 'new>(v: OccupiedEntry<'a, &'new (), ()>)\n    |                       ^^^^\n    = note: ...does not necessarily outlive the static lifetime\n \n error[E0308]: mismatched types\n-  --> $DIR/variance-btree-invariant-types.rs:30:5\n+  --> $DIR/variance-btree-invariant-types.rs:43:5\n    |\n LL |     v\n    |     ^ lifetime mismatch\n    |\n    = note: expected struct `std::collections::btree_map::OccupiedEntry<'_, _, &'static ()>`\n               found struct `std::collections::btree_map::OccupiedEntry<'_, _, &'new ()>`\n-note: the lifetime `'new` as defined on the function body at 28:23...\n-  --> $DIR/variance-btree-invariant-types.rs:28:23\n+note: the lifetime `'new` as defined on the function body at 41:23...\n+  --> $DIR/variance-btree-invariant-types.rs:41:23\n    |\n LL | fn occ_contra_val<'a, 'new>(v: OccupiedEntry<'a, (), &'new ()>)\n    |                       ^^^^\n    = note: ...does not necessarily outlive the static lifetime\n \n error[E0308]: mismatched types\n-  --> $DIR/variance-btree-invariant-types.rs:35:5\n+  --> $DIR/variance-btree-invariant-types.rs:48:5\n    |\n LL |     v\n    |     ^ lifetime mismatch\n    |\n    = note: expected struct `std::collections::btree_map::VacantEntry<'_, &'new (), _>`\n               found struct `std::collections::btree_map::VacantEntry<'_, &'static (), _>`\n-note: the lifetime `'new` as defined on the function body at 33:20...\n-  --> $DIR/variance-btree-invariant-types.rs:33:20\n+note: the lifetime `'new` as defined on the function body at 46:20...\n+  --> $DIR/variance-btree-invariant-types.rs:46:20\n    |\n LL | fn vac_cov_key<'a, 'new>(v: VacantEntry<'a, &'static (), ()>)\n    |                    ^^^^\n    = note: ...does not necessarily outlive the static lifetime\n \n error[E0308]: mismatched types\n-  --> $DIR/variance-btree-invariant-types.rs:39:5\n+  --> $DIR/variance-btree-invariant-types.rs:52:5\n    |\n LL |     v\n    |     ^ lifetime mismatch\n    |\n    = note: expected struct `std::collections::btree_map::VacantEntry<'_, _, &'new ()>`\n               found struct `std::collections::btree_map::VacantEntry<'_, _, &'static ()>`\n-note: the lifetime `'new` as defined on the function body at 37:20...\n-  --> $DIR/variance-btree-invariant-types.rs:37:20\n+note: the lifetime `'new` as defined on the function body at 50:20...\n+  --> $DIR/variance-btree-invariant-types.rs:50:20\n    |\n LL | fn vac_cov_val<'a, 'new>(v: VacantEntry<'a, (), &'static ()>)\n    |                    ^^^^\n    = note: ...does not necessarily outlive the static lifetime\n \n error[E0308]: mismatched types\n-  --> $DIR/variance-btree-invariant-types.rs:43:5\n+  --> $DIR/variance-btree-invariant-types.rs:56:5\n    |\n LL |     v\n    |     ^ lifetime mismatch\n    |\n    = note: expected struct `std::collections::btree_map::VacantEntry<'_, &'static (), _>`\n               found struct `std::collections::btree_map::VacantEntry<'_, &'new (), _>`\n-note: the lifetime `'new` as defined on the function body at 41:23...\n-  --> $DIR/variance-btree-invariant-types.rs:41:23\n+note: the lifetime `'new` as defined on the function body at 54:23...\n+  --> $DIR/variance-btree-invariant-types.rs:54:23\n    |\n LL | fn vac_contra_key<'a, 'new>(v: VacantEntry<'a, &'new (), ()>)\n    |                       ^^^^\n    = note: ...does not necessarily outlive the static lifetime\n \n error[E0308]: mismatched types\n-  --> $DIR/variance-btree-invariant-types.rs:47:5\n+  --> $DIR/variance-btree-invariant-types.rs:60:5\n    |\n LL |     v\n    |     ^ lifetime mismatch\n    |\n    = note: expected struct `std::collections::btree_map::VacantEntry<'_, _, &'static ()>`\n               found struct `std::collections::btree_map::VacantEntry<'_, _, &'new ()>`\n-note: the lifetime `'new` as defined on the function body at 45:23...\n-  --> $DIR/variance-btree-invariant-types.rs:45:23\n+note: the lifetime `'new` as defined on the function body at 58:23...\n+  --> $DIR/variance-btree-invariant-types.rs:58:23\n    |\n LL | fn vac_contra_val<'a, 'new>(v: VacantEntry<'a, (), &'new ()>)\n    |                       ^^^^\n    = note: ...does not necessarily outlive the static lifetime\n \n-error: aborting due to 12 previous errors\n+error: aborting due to 16 previous errors\n \n For more information about this error, try `rustc --explain E0308`."}]}