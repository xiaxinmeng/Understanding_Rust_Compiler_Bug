{"sha": "ce3f3a5ffa7452131cde06c003cc2eaa7c729bfb", "node_id": "C_kwDOAAsO6NoAKGNlM2YzYTVmZmE3NDUyMTMxY2RlMDZjMDAzY2MyZWFhN2M3MjliZmI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-19T03:00:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-19T03:00:46Z"}, "message": "Auto merge of #90329 - nbdd0121:typeck, r=nagisa\n\nTry all stable method candidates first before trying unstable ones\n\nCurrently we try methods in this order in each step:\n* Stable by value\n* Unstable by value\n* Stable autoref\n* Unstable autoref\n* ...\n\nThis PR changes it to first try pick methods without any unstable candidates, and if none is found, try again to pick unstable ones.\n\nFix #90320\nCC #88971, hopefully would allow us to rename the \"unstable_*\" methods for integer impls back.\n\n`@rustbot` label T-compiler T-libs-api", "tree": {"sha": "6c0492edfde76c9496cf09fcc6500f0c0f59fdda", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6c0492edfde76c9496cf09fcc6500f0c0f59fdda"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ce3f3a5ffa7452131cde06c003cc2eaa7c729bfb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ce3f3a5ffa7452131cde06c003cc2eaa7c729bfb", "html_url": "https://github.com/rust-lang/rust/commit/ce3f3a5ffa7452131cde06c003cc2eaa7c729bfb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ce3f3a5ffa7452131cde06c003cc2eaa7c729bfb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "548c1088eff51fd92ad94d56b8c5b2d48b7088f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/548c1088eff51fd92ad94d56b8c5b2d48b7088f0", "html_url": "https://github.com/rust-lang/rust/commit/548c1088eff51fd92ad94d56b8c5b2d48b7088f0"}, {"sha": "6ad626fb5c79bbaafcf533780e30b03d73737c57", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ad626fb5c79bbaafcf533780e30b03d73737c57", "html_url": "https://github.com/rust-lang/rust/commit/6ad626fb5c79bbaafcf533780e30b03d73737c57"}], "stats": {"total": 218, "additions": 191, "deletions": 27}, "files": [{"sha": "ab12c9367101469a7d35f4b8b429e4aa1b495bac", "filename": "compiler/rustc_interface/src/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ce3f3a5ffa7452131cde06c003cc2eaa7c729bfb/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce3f3a5ffa7452131cde06c003cc2eaa7c729bfb/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ftests.rs?ref=ce3f3a5ffa7452131cde06c003cc2eaa7c729bfb", "patch": "@@ -752,6 +752,7 @@ fn test_debugging_options_tracking_hash() {\n     tracked!(panic_abort_tests, true);\n     tracked!(panic_in_drop, PanicStrategy::Abort);\n     tracked!(partially_uninit_const_threshold, Some(123));\n+    tracked!(pick_stable_methods_before_any_unstable, false);\n     tracked!(plt, Some(true));\n     tracked!(polonius, true);\n     tracked!(precise_enum_drop_elaboration, false);"}, {"sha": "cba05f6aa59855e9e449646a7f649e7102ef2903", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce3f3a5ffa7452131cde06c003cc2eaa7c729bfb/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce3f3a5ffa7452131cde06c003cc2eaa7c729bfb/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=ce3f3a5ffa7452131cde06c003cc2eaa7c729bfb", "patch": "@@ -1240,6 +1240,8 @@ options! {\n         and set the maximum total size of a const allocation for which this is allowed (default: never)\"),\n     perf_stats: bool = (false, parse_bool, [UNTRACKED],\n         \"print some performance-related statistics (default: no)\"),\n+    pick_stable_methods_before_any_unstable: bool = (true, parse_bool, [TRACKED],\n+        \"try to pick stable methods first before picking any unstable methods (default: yes)\"),\n     plt: Option<bool> = (None, parse_opt_bool, [TRACKED],\n         \"whether to use the PLT when calling into shared libraries;\n         only has effect for PIC code on systems with ELF binaries"}, {"sha": "95fe6c9b93c406890407e038cc71cba393a080fa", "filename": "compiler/rustc_typeck/src/check/method/probe.rs", "status": "modified", "additions": 113, "deletions": 25, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/ce3f3a5ffa7452131cde06c003cc2eaa7c729bfb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce3f3a5ffa7452131cde06c003cc2eaa7c729bfb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=ce3f3a5ffa7452131cde06c003cc2eaa7c729bfb", "patch": "@@ -92,7 +92,7 @@ impl<'a, 'tcx> Deref for ProbeContext<'a, 'tcx> {\n     }\n }\n \n-#[derive(Debug)]\n+#[derive(Debug, Clone)]\n struct Candidate<'tcx> {\n     // Candidates are (I'm not quite sure, but they are mostly) basically\n     // some metadata on top of a `ty::AssocItem` (without substs).\n@@ -132,7 +132,7 @@ struct Candidate<'tcx> {\n     import_ids: SmallVec<[LocalDefId; 1]>,\n }\n \n-#[derive(Debug)]\n+#[derive(Debug, Clone)]\n enum CandidateKind<'tcx> {\n     InherentImplCandidate(\n         SubstsRef<'tcx>,\n@@ -204,6 +204,7 @@ pub struct Pick<'tcx> {\n     /// Indicates that we want to add an autoref (and maybe also unsize it), or if the receiver is\n     /// `*mut T`, convert it to `*const T`.\n     pub autoref_or_ptr_adjustment: Option<AutorefOrPtrAdjustment<'tcx>>,\n+    pub self_ty: Ty<'tcx>,\n }\n \n #[derive(Clone, Debug, PartialEq, Eq)]\n@@ -1101,13 +1102,37 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n     }\n \n     fn pick_core(&mut self) -> Option<PickResult<'tcx>> {\n-        let steps = self.steps.clone();\n+        let mut unstable_candidates = Vec::new();\n+        let pick = self.pick_all_method(Some(&mut unstable_candidates));\n+\n+        // In this case unstable picking is done by `pick_method`.\n+        if !self.tcx.sess.opts.debugging_opts.pick_stable_methods_before_any_unstable {\n+            return pick;\n+        }\n \n-        // find the first step that works\n+        match pick {\n+            // Emit a lint if there are unstable candidates alongside the stable ones.\n+            //\n+            // We suppress warning if we're picking the method only because it is a\n+            // suggestion.\n+            Some(Ok(ref p)) if !self.is_suggestion.0 && !unstable_candidates.is_empty() => {\n+                self.emit_unstable_name_collision_hint(p, &unstable_candidates);\n+                pick\n+            }\n+            Some(_) => pick,\n+            None => self.pick_all_method(None),\n+        }\n+    }\n+\n+    fn pick_all_method(\n+        &mut self,\n+        mut unstable_candidates: Option<&mut Vec<(Candidate<'tcx>, Symbol)>>,\n+    ) -> Option<PickResult<'tcx>> {\n+        let steps = self.steps.clone();\n         steps\n             .iter()\n             .filter(|step| {\n-                debug!(\"pick_core: step={:?}\", step);\n+                debug!(\"pick_all_method: step={:?}\", step);\n                 // skip types that are from a type error or that would require dereferencing\n                 // a raw pointer\n                 !step.self_ty.references_error() && !step.from_unsafe_deref\n@@ -1123,11 +1148,30 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                     .unwrap_or_else(|_| {\n                         span_bug!(self.span, \"{:?} was applicable but now isn't?\", step.self_ty)\n                     });\n-                self.pick_by_value_method(step, self_ty).or_else(|| {\n-                    self.pick_autorefd_method(step, self_ty, hir::Mutability::Not)\n-                        .or_else(|| self.pick_autorefd_method(step, self_ty, hir::Mutability::Mut))\n-                        .or_else(|| self.pick_const_ptr_method(step, self_ty))\n-                })\n+                self.pick_by_value_method(step, self_ty, unstable_candidates.as_deref_mut())\n+                    .or_else(|| {\n+                        self.pick_autorefd_method(\n+                            step,\n+                            self_ty,\n+                            hir::Mutability::Not,\n+                            unstable_candidates.as_deref_mut(),\n+                        )\n+                        .or_else(|| {\n+                            self.pick_autorefd_method(\n+                                step,\n+                                self_ty,\n+                                hir::Mutability::Mut,\n+                                unstable_candidates.as_deref_mut(),\n+                            )\n+                        })\n+                        .or_else(|| {\n+                            self.pick_const_ptr_method(\n+                                step,\n+                                self_ty,\n+                                unstable_candidates.as_deref_mut(),\n+                            )\n+                        })\n+                    })\n             })\n             .next()\n     }\n@@ -1142,12 +1186,13 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         &mut self,\n         step: &CandidateStep<'tcx>,\n         self_ty: Ty<'tcx>,\n+        unstable_candidates: Option<&mut Vec<(Candidate<'tcx>, Symbol)>>,\n     ) -> Option<PickResult<'tcx>> {\n         if step.unsize {\n             return None;\n         }\n \n-        self.pick_method(self_ty).map(|r| {\n+        self.pick_method(self_ty, unstable_candidates).map(|r| {\n             r.map(|mut pick| {\n                 pick.autoderefs = step.autoderefs;\n \n@@ -1170,14 +1215,15 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         step: &CandidateStep<'tcx>,\n         self_ty: Ty<'tcx>,\n         mutbl: hir::Mutability,\n+        unstable_candidates: Option<&mut Vec<(Candidate<'tcx>, Symbol)>>,\n     ) -> Option<PickResult<'tcx>> {\n         let tcx = self.tcx;\n \n         // In general, during probing we erase regions.\n         let region = tcx.lifetimes.re_erased;\n \n         let autoref_ty = tcx.mk_ref(region, ty::TypeAndMut { ty: self_ty, mutbl });\n-        self.pick_method(autoref_ty).map(|r| {\n+        self.pick_method(autoref_ty, unstable_candidates).map(|r| {\n             r.map(|mut pick| {\n                 pick.autoderefs = step.autoderefs;\n                 pick.autoref_or_ptr_adjustment = Some(AutorefOrPtrAdjustment::Autoref {\n@@ -1196,6 +1242,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         &mut self,\n         step: &CandidateStep<'tcx>,\n         self_ty: Ty<'tcx>,\n+        unstable_candidates: Option<&mut Vec<(Candidate<'tcx>, Symbol)>>,\n     ) -> Option<PickResult<'tcx>> {\n         // Don't convert an unsized reference to ptr\n         if step.unsize {\n@@ -1209,7 +1256,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n \n         let const_self_ty = ty::TypeAndMut { ty, mutbl: hir::Mutability::Not };\n         let const_ptr_ty = self.tcx.mk_ptr(const_self_ty);\n-        self.pick_method(const_ptr_ty).map(|r| {\n+        self.pick_method(const_ptr_ty, unstable_candidates).map(|r| {\n             r.map(|mut pick| {\n                 pick.autoderefs = step.autoderefs;\n                 pick.autoref_or_ptr_adjustment = Some(AutorefOrPtrAdjustment::ToConstPtr);\n@@ -1218,8 +1265,8 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         })\n     }\n \n-    fn pick_method(&mut self, self_ty: Ty<'tcx>) -> Option<PickResult<'tcx>> {\n-        debug!(\"pick_method(self_ty={})\", self.ty_to_string(self_ty));\n+    fn pick_method_with_unstable(&mut self, self_ty: Ty<'tcx>) -> Option<PickResult<'tcx>> {\n+        debug!(\"pick_method_with_unstable(self_ty={})\", self.ty_to_string(self_ty));\n \n         let mut possibly_unsatisfied_predicates = Vec::new();\n         let mut unstable_candidates = Vec::new();\n@@ -1241,7 +1288,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                         //\n                         // We suppress warning if we're picking the method only because it is a\n                         // suggestion.\n-                        self.emit_unstable_name_collision_hint(p, &unstable_candidates, self_ty);\n+                        self.emit_unstable_name_collision_hint(p, &unstable_candidates);\n                     }\n                 }\n                 return Some(pick);\n@@ -1251,7 +1298,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         debug!(\"searching unstable candidates\");\n         let res = self.consider_candidates(\n             self_ty,\n-            unstable_candidates.into_iter().map(|(c, _)| c),\n+            unstable_candidates.iter().map(|(c, _)| c),\n             &mut possibly_unsatisfied_predicates,\n             None,\n         );\n@@ -1261,6 +1308,42 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         res\n     }\n \n+    fn pick_method(\n+        &mut self,\n+        self_ty: Ty<'tcx>,\n+        mut unstable_candidates: Option<&mut Vec<(Candidate<'tcx>, Symbol)>>,\n+    ) -> Option<PickResult<'tcx>> {\n+        if !self.tcx.sess.opts.debugging_opts.pick_stable_methods_before_any_unstable {\n+            return self.pick_method_with_unstable(self_ty);\n+        }\n+\n+        debug!(\"pick_method(self_ty={})\", self.ty_to_string(self_ty));\n+\n+        let mut possibly_unsatisfied_predicates = Vec::new();\n+\n+        for (kind, candidates) in\n+            &[(\"inherent\", &self.inherent_candidates), (\"extension\", &self.extension_candidates)]\n+        {\n+            debug!(\"searching {} candidates\", kind);\n+            let res = self.consider_candidates(\n+                self_ty,\n+                candidates.iter(),\n+                &mut possibly_unsatisfied_predicates,\n+                unstable_candidates.as_deref_mut(),\n+            );\n+            if let Some(pick) = res {\n+                return Some(pick);\n+            }\n+        }\n+\n+        // `pick_method` may be called twice for the same self_ty if no stable methods\n+        // match. Only extend once.\n+        if unstable_candidates.is_some() {\n+            self.unsatisfied_predicates.extend(possibly_unsatisfied_predicates);\n+        }\n+        None\n+    }\n+\n     fn consider_candidates<'b, ProbesIter>(\n         &self,\n         self_ty: Ty<'tcx>,\n@@ -1269,10 +1352,11 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             ty::Predicate<'tcx>,\n             Option<ty::Predicate<'tcx>>,\n         )>,\n-        unstable_candidates: Option<&mut Vec<(&'b Candidate<'tcx>, Symbol)>>,\n+        unstable_candidates: Option<&mut Vec<(Candidate<'tcx>, Symbol)>>,\n     ) -> Option<PickResult<'tcx>>\n     where\n         ProbesIter: Iterator<Item = &'b Candidate<'tcx>> + Clone,\n+        'tcx: 'b,\n     {\n         let mut applicable_candidates: Vec<_> = probes\n             .clone()\n@@ -1285,7 +1369,9 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         debug!(\"applicable_candidates: {:?}\", applicable_candidates);\n \n         if applicable_candidates.len() > 1 {\n-            if let Some(pick) = self.collapse_candidates_to_trait_pick(&applicable_candidates[..]) {\n+            if let Some(pick) =\n+                self.collapse_candidates_to_trait_pick(self_ty, &applicable_candidates[..])\n+            {\n                 return Some(Ok(pick));\n             }\n         }\n@@ -1295,7 +1381,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 if let stability::EvalResult::Deny { feature, .. } =\n                     self.tcx.eval_stability(p.item.def_id, None, self.span, None)\n                 {\n-                    uc.push((p, feature));\n+                    uc.push((p.clone(), feature));\n                     return false;\n                 }\n                 true\n@@ -1309,7 +1395,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n \n         applicable_candidates.pop().map(|(probe, status)| {\n             if status == ProbeResult::Match {\n-                Ok(probe.to_unadjusted_pick())\n+                Ok(probe.to_unadjusted_pick(self_ty))\n             } else {\n                 Err(MethodError::BadReturnType)\n             }\n@@ -1319,8 +1405,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n     fn emit_unstable_name_collision_hint(\n         &self,\n         stable_pick: &Pick<'_>,\n-        unstable_candidates: &[(&Candidate<'tcx>, Symbol)],\n-        self_ty: Ty<'tcx>,\n+        unstable_candidates: &[(Candidate<'tcx>, Symbol)],\n     ) {\n         self.tcx.struct_span_lint_hir(\n             lint::builtin::UNSTABLE_NAME_COLLISIONS,\n@@ -1351,7 +1436,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                             \"use the fully qualified path to the associated const\",\n                             format!(\n                                 \"<{} as {}>::{}\",\n-                                self_ty,\n+                                stable_pick.self_ty,\n                                 self.tcx.def_path_str(def_id),\n                                 stable_pick.item.ident\n                             ),\n@@ -1591,6 +1676,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n     /// use, so it's ok to just commit to \"using the method from the trait Foo\".\n     fn collapse_candidates_to_trait_pick(\n         &self,\n+        self_ty: Ty<'tcx>,\n         probes: &[(&Candidate<'tcx>, ProbeResult)],\n     ) -> Option<Pick<'tcx>> {\n         // Do all probes correspond to the same trait?\n@@ -1610,6 +1696,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             import_ids: probes[0].0.import_ids.clone(),\n             autoderefs: 0,\n             autoref_or_ptr_adjustment: None,\n+            self_ty,\n         })\n     }\n \n@@ -1828,7 +1915,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n }\n \n impl<'tcx> Candidate<'tcx> {\n-    fn to_unadjusted_pick(&self) -> Pick<'tcx> {\n+    fn to_unadjusted_pick(&self, self_ty: Ty<'tcx>) -> Pick<'tcx> {\n         Pick {\n             item: self.item,\n             kind: match self.kind {\n@@ -1852,6 +1939,7 @@ impl<'tcx> Candidate<'tcx> {\n             import_ids: self.import_ids.clone(),\n             autoderefs: 0,\n             autoref_or_ptr_adjustment: None,\n+            self_ty,\n         }\n     }\n }"}, {"sha": "04bc0b1a8ac4a1b11033eb3b00cf3c4474f935b8", "filename": "src/test/ui/inference/auxiliary/inference_unstable_iterator.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ce3f3a5ffa7452131cde06c003cc2eaa7c729bfb/src%2Ftest%2Fui%2Finference%2Fauxiliary%2Finference_unstable_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce3f3a5ffa7452131cde06c003cc2eaa7c729bfb/src%2Ftest%2Fui%2Finference%2Fauxiliary%2Finference_unstable_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fauxiliary%2Finference_unstable_iterator.rs?ref=ce3f3a5ffa7452131cde06c003cc2eaa7c729bfb", "patch": "@@ -1,4 +1,5 @@\n #![feature(staged_api)]\n+#![feature(arbitrary_self_types)]\n \n #![stable(feature = \"ipu_iterator\", since = \"1.0.0\")]\n \n@@ -8,6 +9,22 @@ pub trait IpuIterator {\n     fn ipu_flatten(&self) -> u32 {\n         0\n     }\n+\n+    #[unstable(feature = \"ipu_flatten\", issue = \"99999\")]\n+    fn ipu_by_value_vs_by_ref(self) -> u32 where Self: Sized {\n+        0\n+    }\n+\n+    #[unstable(feature = \"ipu_flatten\", issue = \"99999\")]\n+    fn ipu_by_ref_vs_by_ref_mut(&self) -> u32 {\n+        0\n+    }\n+\n+    #[unstable(feature = \"ipu_flatten\", issue = \"99999\")]\n+    fn ipu_by_mut_ptr_vs_by_const_ptr(self: *mut Self) -> u32 {\n+        0\n+    }\n+\n     #[unstable(feature = \"assoc_const_ipu_iter\", issue = \"99999\")]\n     const C: i32;\n }"}, {"sha": "fa1efbcfefc5d926b55381e2bb28b3a557a9ce2f", "filename": "src/test/ui/inference/auxiliary/inference_unstable_itertools.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ce3f3a5ffa7452131cde06c003cc2eaa7c729bfb/src%2Ftest%2Fui%2Finference%2Fauxiliary%2Finference_unstable_itertools.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce3f3a5ffa7452131cde06c003cc2eaa7c729bfb/src%2Ftest%2Fui%2Finference%2Fauxiliary%2Finference_unstable_itertools.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fauxiliary%2Finference_unstable_itertools.rs?ref=ce3f3a5ffa7452131cde06c003cc2eaa7c729bfb", "patch": "@@ -1,8 +1,22 @@\n+#![feature(arbitrary_self_types)]\n+\n pub trait IpuItertools {\n     fn ipu_flatten(&self) -> u32 {\n         1\n     }\n \n+    fn ipu_by_value_vs_by_ref(&self) -> u32 {\n+        1\n+    }\n+\n+    fn ipu_by_ref_vs_by_ref_mut(&mut self) -> u32 {\n+        1\n+    }\n+\n+    fn ipu_by_mut_ptr_vs_by_const_ptr(self: *const Self) -> u32 {\n+        1\n+    }\n+\n     const C: i32;\n }\n "}, {"sha": "daf0cf042c40234b40fbe83f84c40ff22ff55d4b", "filename": "src/test/ui/inference/inference_unstable.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ce3f3a5ffa7452131cde06c003cc2eaa7c729bfb/src%2Ftest%2Fui%2Finference%2Finference_unstable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce3f3a5ffa7452131cde06c003cc2eaa7c729bfb/src%2Ftest%2Fui%2Finference%2Finference_unstable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Finference_unstable.rs?ref=ce3f3a5ffa7452131cde06c003cc2eaa7c729bfb", "patch": "@@ -15,6 +15,15 @@ use inference_unstable_itertools::IpuItertools;\n fn main() {\n     assert_eq!('x'.ipu_flatten(), 1);\n //~^ WARN an associated function with this name may be added to the standard library in the future\n+//~| WARN once this associated item is added to the standard library, the ambiguity may cause an\n+    assert_eq!('x'.ipu_by_value_vs_by_ref(), 1);\n+//~^ WARN an associated function with this name may be added to the standard library in the future\n+//~| WARN once this associated item is added to the standard library, the ambiguity may cause an\n+    assert_eq!('x'.ipu_by_ref_vs_by_ref_mut(), 1);\n+//~^ WARN an associated function with this name may be added to the standard library in the future\n+//~| WARN once this associated item is added to the standard library, the ambiguity may cause an\n+    assert_eq!((&mut 'x' as *mut char).ipu_by_mut_ptr_vs_by_const_ptr(), 1);\n+//~^ WARN an associated function with this name may be added to the standard library in the future\n //~| WARN once this associated item is added to the standard library, the ambiguity may cause an\n     assert_eq!(char::C, 1);\n //~^ WARN an associated constant with this name may be added to the standard library in the future"}, {"sha": "df7a09686bf8501d8500c6a2bd6e0ac6d03bc308", "filename": "src/test/ui/inference/inference_unstable.stderr", "status": "modified", "additions": 35, "deletions": 2, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/ce3f3a5ffa7452131cde06c003cc2eaa7c729bfb/src%2Ftest%2Fui%2Finference%2Finference_unstable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ce3f3a5ffa7452131cde06c003cc2eaa7c729bfb/src%2Ftest%2Fui%2Finference%2Finference_unstable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Finference_unstable.stderr?ref=ce3f3a5ffa7452131cde06c003cc2eaa7c729bfb", "patch": "@@ -10,8 +10,41 @@ LL |     assert_eq!('x'.ipu_flatten(), 1);\n    = help: call with fully qualified syntax `inference_unstable_itertools::IpuItertools::ipu_flatten(...)` to keep using the current method\n    = help: add `#![feature(ipu_flatten)]` to the crate attributes to enable `inference_unstable_iterator::IpuIterator::ipu_flatten`\n \n+warning: an associated function with this name may be added to the standard library in the future\n+  --> $DIR/inference_unstable.rs:19:20\n+   |\n+LL |     assert_eq!('x'.ipu_by_value_vs_by_ref(), 1);\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = warning: once this associated item is added to the standard library, the ambiguity may cause an error or change in behavior!\n+   = note: for more information, see issue #48919 <https://github.com/rust-lang/rust/issues/48919>\n+   = help: call with fully qualified syntax `inference_unstable_itertools::IpuItertools::ipu_by_value_vs_by_ref(...)` to keep using the current method\n+   = help: add `#![feature(ipu_flatten)]` to the crate attributes to enable `inference_unstable_iterator::IpuIterator::ipu_by_value_vs_by_ref`\n+\n+warning: an associated function with this name may be added to the standard library in the future\n+  --> $DIR/inference_unstable.rs:22:20\n+   |\n+LL |     assert_eq!('x'.ipu_by_ref_vs_by_ref_mut(), 1);\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = warning: once this associated item is added to the standard library, the ambiguity may cause an error or change in behavior!\n+   = note: for more information, see issue #48919 <https://github.com/rust-lang/rust/issues/48919>\n+   = help: call with fully qualified syntax `inference_unstable_itertools::IpuItertools::ipu_by_ref_vs_by_ref_mut(...)` to keep using the current method\n+   = help: add `#![feature(ipu_flatten)]` to the crate attributes to enable `inference_unstable_iterator::IpuIterator::ipu_by_ref_vs_by_ref_mut`\n+\n+warning: an associated function with this name may be added to the standard library in the future\n+  --> $DIR/inference_unstable.rs:25:40\n+   |\n+LL |     assert_eq!((&mut 'x' as *mut char).ipu_by_mut_ptr_vs_by_const_ptr(), 1);\n+   |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = warning: once this associated item is added to the standard library, the ambiguity may cause an error or change in behavior!\n+   = note: for more information, see issue #48919 <https://github.com/rust-lang/rust/issues/48919>\n+   = help: call with fully qualified syntax `inference_unstable_itertools::IpuItertools::ipu_by_mut_ptr_vs_by_const_ptr(...)` to keep using the current method\n+   = help: add `#![feature(ipu_flatten)]` to the crate attributes to enable `inference_unstable_iterator::IpuIterator::ipu_by_mut_ptr_vs_by_const_ptr`\n+\n warning: an associated constant with this name may be added to the standard library in the future\n-  --> $DIR/inference_unstable.rs:19:16\n+  --> $DIR/inference_unstable.rs:28:16\n    |\n LL |     assert_eq!(char::C, 1);\n    |                ^^^^^^^ help: use the fully qualified path to the associated const: `<char as IpuItertools>::C`\n@@ -20,5 +53,5 @@ LL |     assert_eq!(char::C, 1);\n    = note: for more information, see issue #48919 <https://github.com/rust-lang/rust/issues/48919>\n    = help: add `#![feature(assoc_const_ipu_iter)]` to the crate attributes to enable `inference_unstable_iterator::IpuIterator::C`\n \n-warning: 2 warnings emitted\n+warning: 5 warnings emitted\n "}]}