{"sha": "1dec35a1b0df406da5d7cae55a7fa8d186a2b028", "node_id": "C_kwDOAAsO6NoAKDFkZWMzNWExYjBkZjQwNmRhNWQ3Y2FlNTVhN2ZhOGQxODZhMmIwMjg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-21T10:38:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-21T10:38:43Z"}, "message": "Auto merge of #96003 - aswild:pr/bootstrap-subcommands-cleanup, r=jyn514\n\nbootstrap: consolidate subcommand parsing and matching\n\nThere's several places where the x.py command names are matched as\nstrings, leading to some inconsistencies and opportunities for cleanup.\n\n* Add Format, Clean, and Setup variants to builder::Kind.\n* Use Kind to parse the x.py subcommand name (including aliases)\n* Match on the subcommand Kind rather than strings when handling\n  options and help text.\n* Several subcommands don't display any paths when run with `-h -v` even\n  though the help text indicates that they should. Fix this and refactor\n  so that manually keeping matches in sync isn't necessary.\n\nFixes #95937", "tree": {"sha": "cfc112c39c83a8786564506512a55caaf204d5b4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cfc112c39c83a8786564506512a55caaf204d5b4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1dec35a1b0df406da5d7cae55a7fa8d186a2b028", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1dec35a1b0df406da5d7cae55a7fa8d186a2b028", "html_url": "https://github.com/rust-lang/rust/commit/1dec35a1b0df406da5d7cae55a7fa8d186a2b028", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1dec35a1b0df406da5d7cae55a7fa8d186a2b028/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d3dafb771fb714baeb36793f2d4cd333a8e9c34", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d3dafb771fb714baeb36793f2d4cd333a8e9c34", "html_url": "https://github.com/rust-lang/rust/commit/3d3dafb771fb714baeb36793f2d4cd333a8e9c34"}, {"sha": "870cb8ef922dc6f4a1537572cd302e5a35e1869a", "url": "https://api.github.com/repos/rust-lang/rust/commits/870cb8ef922dc6f4a1537572cd302e5a35e1869a", "html_url": "https://github.com/rust-lang/rust/commit/870cb8ef922dc6f4a1537572cd302e5a35e1869a"}], "stats": {"total": 188, "additions": 85, "deletions": 103}, "files": [{"sha": "0c4f3265dbf9e7869d0fb7599cceb70981a7b336", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 35, "deletions": 27, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/1dec35a1b0df406da5d7cae55a7fa8d186a2b028/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dec35a1b0df406da5d7cae55a7fa8d186a2b028/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=1dec35a1b0df406da5d7cae55a7fa8d186a2b028", "patch": "@@ -3,7 +3,7 @@ use std::cell::{Cell, RefCell};\n use std::collections::BTreeSet;\n use std::env;\n use std::ffi::OsStr;\n-use std::fmt::Debug;\n+use std::fmt::{Debug, Write};\n use std::fs;\n use std::hash::Hash;\n use std::ops::Deref;\n@@ -125,7 +125,8 @@ impl TaskPath {\n                     if found_kind.is_empty() {\n                         panic!(\"empty kind in task path {}\", path.display());\n                     }\n-                    kind = Some(Kind::parse(found_kind));\n+                    kind = Kind::parse(found_kind);\n+                    assert!(kind.is_some());\n                     path = Path::new(found_prefix).join(components.as_path());\n                 }\n             }\n@@ -431,43 +432,53 @@ pub enum Kind {\n     Check,\n     Clippy,\n     Fix,\n+    Format,\n     Test,\n     Bench,\n-    Dist,\n     Doc,\n+    Clean,\n+    Dist,\n     Install,\n     Run,\n+    Setup,\n }\n \n impl Kind {\n-    fn parse(string: &str) -> Kind {\n-        match string {\n-            \"build\" => Kind::Build,\n-            \"check\" => Kind::Check,\n+    pub fn parse(string: &str) -> Option<Kind> {\n+        // these strings, including the one-letter aliases, must match the x.py help text\n+        Some(match string {\n+            \"build\" | \"b\" => Kind::Build,\n+            \"check\" | \"c\" => Kind::Check,\n             \"clippy\" => Kind::Clippy,\n             \"fix\" => Kind::Fix,\n-            \"test\" => Kind::Test,\n+            \"fmt\" => Kind::Format,\n+            \"test\" | \"t\" => Kind::Test,\n             \"bench\" => Kind::Bench,\n+            \"doc\" | \"d\" => Kind::Doc,\n+            \"clean\" => Kind::Clean,\n             \"dist\" => Kind::Dist,\n-            \"doc\" => Kind::Doc,\n             \"install\" => Kind::Install,\n-            \"run\" => Kind::Run,\n-            other => panic!(\"unknown kind: {}\", other),\n-        }\n+            \"run\" | \"r\" => Kind::Run,\n+            \"setup\" => Kind::Setup,\n+            _ => return None,\n+        })\n     }\n \n-    fn as_str(&self) -> &'static str {\n+    pub fn as_str(&self) -> &'static str {\n         match self {\n             Kind::Build => \"build\",\n             Kind::Check => \"check\",\n             Kind::Clippy => \"clippy\",\n             Kind::Fix => \"fix\",\n+            Kind::Format => \"fmt\",\n             Kind::Test => \"test\",\n             Kind::Bench => \"bench\",\n-            Kind::Dist => \"dist\",\n             Kind::Doc => \"doc\",\n+            Kind::Clean => \"clean\",\n+            Kind::Dist => \"dist\",\n             Kind::Install => \"install\",\n             Kind::Run => \"run\",\n+            Kind::Setup => \"setup\",\n         }\n     }\n }\n@@ -511,7 +522,7 @@ impl<'a> Builder<'a> {\n                 native::Lld,\n                 native::CrtBeginEnd\n             ),\n-            Kind::Check | Kind::Clippy { .. } | Kind::Fix => describe!(\n+            Kind::Check => describe!(\n                 check::Std,\n                 check::Rustc,\n                 check::Rustdoc,\n@@ -641,32 +652,29 @@ impl<'a> Builder<'a> {\n                 install::Rustc\n             ),\n             Kind::Run => describe!(run::ExpandYamlAnchors, run::BuildManifest, run::BumpStage0),\n+            // These commands either don't use paths, or they're special-cased in Build::build()\n+            Kind::Clean | Kind::Clippy | Kind::Fix | Kind::Format | Kind::Setup => vec![],\n         }\n     }\n \n-    pub fn get_help(build: &Build, subcommand: &str) -> Option<String> {\n-        let kind = match subcommand {\n-            \"build\" | \"b\" => Kind::Build,\n-            \"doc\" | \"d\" => Kind::Doc,\n-            \"test\" | \"t\" => Kind::Test,\n-            \"bench\" => Kind::Bench,\n-            \"dist\" => Kind::Dist,\n-            \"install\" => Kind::Install,\n-            _ => return None,\n-        };\n+    pub fn get_help(build: &Build, kind: Kind) -> Option<String> {\n+        let step_descriptions = Builder::get_step_descriptions(kind);\n+        if step_descriptions.is_empty() {\n+            return None;\n+        }\n \n         let builder = Self::new_internal(build, kind, vec![]);\n         let builder = &builder;\n         // The \"build\" kind here is just a placeholder, it will be replaced with something else in\n         // the following statement.\n         let mut should_run = ShouldRun::new(builder, Kind::Build);\n-        for desc in Builder::get_step_descriptions(builder.kind) {\n+        for desc in step_descriptions {\n             should_run.kind = desc.kind;\n             should_run = (desc.should_run)(should_run);\n         }\n         let mut help = String::from(\"Available paths:\\n\");\n         let mut add_path = |path: &Path| {\n-            help.push_str(&format!(\"    ./x.py {} {}\\n\", subcommand, path.display()));\n+            t!(write!(help, \"    ./x.py {} {}\\n\", kind.as_str(), path.display()));\n         };\n         for pathset in should_run.paths {\n             match pathset {"}, {"sha": "a82eb52e232b4725af9860c8768028c2e12d9ab4", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 50, "deletions": 76, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/1dec35a1b0df406da5d7cae55a7fa8d186a2b028/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dec35a1b0df406da5d7cae55a7fa8d186a2b028/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=1dec35a1b0df406da5d7cae55a7fa8d186a2b028", "patch": "@@ -8,7 +8,7 @@ use std::process;\n \n use getopts::Options;\n \n-use crate::builder::Builder;\n+use crate::builder::{Builder, Kind};\n use crate::config::{Config, TargetSelection};\n use crate::setup::Profile;\n use crate::util::t;\n@@ -243,27 +243,7 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\",\n         // the subcommand. Therefore we must manually identify the subcommand first, so that we can\n         // complete the definition of the options.  Then we can use the getopt::Matches object from\n         // there on out.\n-        let subcommand = args.iter().find(|&s| {\n-            (s == \"build\")\n-                || (s == \"b\")\n-                || (s == \"check\")\n-                || (s == \"c\")\n-                || (s == \"clippy\")\n-                || (s == \"fix\")\n-                || (s == \"fmt\")\n-                || (s == \"test\")\n-                || (s == \"t\")\n-                || (s == \"bench\")\n-                || (s == \"doc\")\n-                || (s == \"d\")\n-                || (s == \"clean\")\n-                || (s == \"dist\")\n-                || (s == \"install\")\n-                || (s == \"run\")\n-                || (s == \"r\")\n-                || (s == \"setup\")\n-        });\n-        let subcommand = match subcommand {\n+        let subcommand = match args.iter().find_map(|s| Kind::parse(&s)) {\n             Some(s) => s,\n             None => {\n                 // No or an invalid subcommand -- show the general usage and subcommand help\n@@ -276,8 +256,8 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\",\n         };\n \n         // Some subcommands get extra options\n-        match subcommand.as_str() {\n-            \"test\" | \"t\" => {\n+        match subcommand {\n+            Kind::Test => {\n                 opts.optflag(\"\", \"no-fail-fast\", \"Run all tests regardless of failure\");\n                 opts.optmulti(\n                     \"\",\n@@ -316,48 +296,45 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\",\n                         `/<build_base>/rustfix_missing_coverage.txt`\",\n                 );\n             }\n-            \"check\" | \"c\" => {\n+            Kind::Check => {\n                 opts.optflag(\"\", \"all-targets\", \"Check all targets\");\n             }\n-            \"bench\" => {\n+            Kind::Bench => {\n                 opts.optmulti(\"\", \"test-args\", \"extra arguments\", \"ARGS\");\n             }\n-            \"clippy\" => {\n+            Kind::Clippy => {\n                 opts.optflag(\"\", \"fix\", \"automatically apply lint suggestions\");\n             }\n-            \"doc\" | \"d\" => {\n+            Kind::Doc => {\n                 opts.optflag(\"\", \"open\", \"open the docs in a browser\");\n             }\n-            \"clean\" => {\n+            Kind::Clean => {\n                 opts.optflag(\"\", \"all\", \"clean all build artifacts\");\n             }\n-            \"fmt\" => {\n+            Kind::Format => {\n                 opts.optflag(\"\", \"check\", \"check formatting instead of applying.\");\n             }\n             _ => {}\n         };\n \n         // fn usage()\n         let usage = |exit_code: i32, opts: &Options, verbose: bool, subcommand_help: &str| -> ! {\n-            let mut extra_help = String::new();\n-\n-            // All subcommands except `clean` can have an optional \"Available paths\" section\n-            if verbose {\n-                let config = Config::parse(&[\"build\".to_string()]);\n-                let build = Build::new(config);\n-\n-                let maybe_rules_help = Builder::get_help(&build, subcommand.as_str());\n-                extra_help.push_str(maybe_rules_help.unwrap_or_default().as_str());\n-            } else if !(subcommand.as_str() == \"clean\" || subcommand.as_str() == \"fmt\") {\n-                extra_help.push_str(\n-                    format!(\"Run `./x.py {} -h -v` to see a list of available paths.\", subcommand)\n-                        .as_str(),\n-                );\n-            }\n+            let config = Config::parse(&[\"build\".to_string()]);\n+            let build = Build::new(config);\n+            let paths = Builder::get_help(&build, subcommand);\n \n             println!(\"{}\", opts.usage(subcommand_help));\n-            if !extra_help.is_empty() {\n-                println!(\"{}\", extra_help);\n+            if let Some(s) = paths {\n+                if verbose {\n+                    println!(\"{}\", s);\n+                } else {\n+                    println!(\n+                        \"Run `./x.py {} -h -v` to see a list of available paths.\",\n+                        subcommand.as_str()\n+                    );\n+                }\n+            } else if verbose {\n+                panic!(\"No paths available for subcommand `{}`\", subcommand.as_str());\n             }\n             process::exit(exit_code);\n         };\n@@ -375,7 +352,7 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\",\n         //            ^-- option  ^     ^- actual subcommand\n         //                        \\_ arg to option could be mistaken as subcommand\n         let mut pass_sanity_check = true;\n-        match matches.free.get(0) {\n+        match matches.free.get(0).and_then(|s| Kind::parse(&s)) {\n             Some(check_subcommand) => {\n                 if check_subcommand != subcommand {\n                     pass_sanity_check = false;\n@@ -394,8 +371,8 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\",\n             process::exit(1);\n         }\n         // Extra help text for some commands\n-        match subcommand.as_str() {\n-            \"build\" | \"b\" => {\n+        match subcommand {\n+            Kind::Build => {\n                 subcommand_help.push_str(\n                     \"\\n\n Arguments:\n@@ -415,7 +392,7 @@ Arguments:\n         ./x.py build \",\n                 );\n             }\n-            \"check\" | \"c\" => {\n+            Kind::Check => {\n                 subcommand_help.push_str(\n                     \"\\n\n Arguments:\n@@ -427,7 +404,7 @@ Arguments:\n     If no arguments are passed then many artifacts are checked.\",\n                 );\n             }\n-            \"clippy\" => {\n+            Kind::Clippy => {\n                 subcommand_help.push_str(\n                     \"\\n\n Arguments:\n@@ -438,7 +415,7 @@ Arguments:\n         ./x.py clippy library/core library/proc_macro\",\n                 );\n             }\n-            \"fix\" => {\n+            Kind::Fix => {\n                 subcommand_help.push_str(\n                     \"\\n\n Arguments:\n@@ -449,7 +426,7 @@ Arguments:\n         ./x.py fix library/core library/proc_macro\",\n                 );\n             }\n-            \"fmt\" => {\n+            Kind::Format => {\n                 subcommand_help.push_str(\n                     \"\\n\n Arguments:\n@@ -460,7 +437,7 @@ Arguments:\n         ./x.py fmt --check\",\n                 );\n             }\n-            \"test\" | \"t\" => {\n+            Kind::Test => {\n                 subcommand_help.push_str(\n                     \"\\n\n Arguments:\n@@ -488,7 +465,7 @@ Arguments:\n         ./x.py test --stage 1\",\n                 );\n             }\n-            \"doc\" | \"d\" => {\n+            Kind::Doc => {\n                 subcommand_help.push_str(\n                     \"\\n\n Arguments:\n@@ -506,7 +483,7 @@ Arguments:\n         ./x.py doc --stage 1\",\n                 );\n             }\n-            \"run\" | \"r\" => {\n+            Kind::Run => {\n                 subcommand_help.push_str(\n                     \"\\n\n Arguments:\n@@ -518,7 +495,7 @@ Arguments:\n     At least a tool needs to be called.\",\n                 );\n             }\n-            \"setup\" => {\n+            Kind::Setup => {\n                 subcommand_help.push_str(&format!(\n                     \"\\n\n x.py setup creates a `config.toml` which changes the defaults for x.py itself.\n@@ -535,7 +512,7 @@ Arguments:\n                     Profile::all_for_help(\"        \").trim_end()\n                 ));\n             }\n-            _ => {}\n+            Kind::Bench | Kind::Clean | Kind::Dist | Kind::Install => {}\n         };\n         // Get any optional paths which occur after the subcommand\n         let mut paths = matches.free[1..].iter().map(|p| p.into()).collect::<Vec<PathBuf>>();\n@@ -547,19 +524,19 @@ Arguments:\n             usage(0, &opts, verbose, &subcommand_help);\n         }\n \n-        let cmd = match subcommand.as_str() {\n-            \"build\" | \"b\" => Subcommand::Build { paths },\n-            \"check\" | \"c\" => {\n+        let cmd = match subcommand {\n+            Kind::Build => Subcommand::Build { paths },\n+            Kind::Check => {\n                 if matches.opt_present(\"all-targets\") {\n                     eprintln!(\n                         \"Warning: --all-targets is now on by default and does not need to be passed explicitly.\"\n                     );\n                 }\n                 Subcommand::Check { paths }\n             }\n-            \"clippy\" => Subcommand::Clippy { paths, fix: matches.opt_present(\"fix\") },\n-            \"fix\" => Subcommand::Fix { paths },\n-            \"test\" | \"t\" => Subcommand::Test {\n+            Kind::Clippy => Subcommand::Clippy { paths, fix: matches.opt_present(\"fix\") },\n+            Kind::Fix => Subcommand::Fix { paths },\n+            Kind::Test => Subcommand::Test {\n                 paths,\n                 bless: matches.opt_present(\"bless\"),\n                 force_rerun: matches.opt_present(\"force-rerun\"),\n@@ -578,27 +555,27 @@ Arguments:\n                     DocTests::Yes\n                 },\n             },\n-            \"bench\" => Subcommand::Bench { paths, test_args: matches.opt_strs(\"test-args\") },\n-            \"doc\" | \"d\" => Subcommand::Doc { paths, open: matches.opt_present(\"open\") },\n-            \"clean\" => {\n+            Kind::Bench => Subcommand::Bench { paths, test_args: matches.opt_strs(\"test-args\") },\n+            Kind::Doc => Subcommand::Doc { paths, open: matches.opt_present(\"open\") },\n+            Kind::Clean => {\n                 if !paths.is_empty() {\n                     println!(\"\\nclean does not take a path argument\\n\");\n                     usage(1, &opts, verbose, &subcommand_help);\n                 }\n \n                 Subcommand::Clean { all: matches.opt_present(\"all\") }\n             }\n-            \"fmt\" => Subcommand::Format { check: matches.opt_present(\"check\"), paths },\n-            \"dist\" => Subcommand::Dist { paths },\n-            \"install\" => Subcommand::Install { paths },\n-            \"run\" | \"r\" => {\n+            Kind::Format => Subcommand::Format { check: matches.opt_present(\"check\"), paths },\n+            Kind::Dist => Subcommand::Dist { paths },\n+            Kind::Install => Subcommand::Install { paths },\n+            Kind::Run => {\n                 if paths.is_empty() {\n                     println!(\"\\nrun requires at least a path!\\n\");\n                     usage(1, &opts, verbose, &subcommand_help);\n                 }\n                 Subcommand::Run { paths }\n             }\n-            \"setup\" => {\n+            Kind::Setup => {\n                 let profile = if paths.len() > 1 {\n                     println!(\"\\nat most one profile can be passed to setup\\n\");\n                     usage(1, &opts, verbose, &subcommand_help)\n@@ -618,9 +595,6 @@ Arguments:\n                 };\n                 Subcommand::Setup { profile }\n             }\n-            _ => {\n-                usage(1, &opts, verbose, &subcommand_help);\n-            }\n         };\n \n         if let Subcommand::Check { .. } = &cmd {"}]}