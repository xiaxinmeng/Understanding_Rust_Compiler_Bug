{"sha": "daa89e086156099e3aa95577ec97f761e056e65e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhYTg5ZTA4NjE1NjA5OWUzYWE5NTU3N2VjOTdmNzYxZTA1NmU2NWU=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-11-28T19:48:34Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-11-30T02:10:11Z"}, "message": "rustc: Remove existing inheritance code from coherence\n\nInheritance will be implemented differently, hopefully simpler", "tree": {"sha": "135ed093e35a4b268cc8eb7e7a3a2588bcee33e6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/135ed093e35a4b268cc8eb7e7a3a2588bcee33e6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/daa89e086156099e3aa95577ec97f761e056e65e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/daa89e086156099e3aa95577ec97f761e056e65e", "html_url": "https://github.com/rust-lang/rust/commit/daa89e086156099e3aa95577ec97f761e056e65e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/daa89e086156099e3aa95577ec97f761e056e65e/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "28ecef7bf5c25439a565a000fe9acad1463a05c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/28ecef7bf5c25439a565a000fe9acad1463a05c7", "html_url": "https://github.com/rust-lang/rust/commit/28ecef7bf5c25439a565a000fe9acad1463a05c7"}], "stats": {"total": 138, "additions": 48, "deletions": 90}, "files": [{"sha": "674bb8d6f85b9f4bf32119a745e89af5cef90ea8", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 2, "deletions": 40, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/daa89e086156099e3aa95577ec97f761e056e65e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daa89e086156099e3aa95577ec97f761e056e65e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=daa89e086156099e3aa95577ec97f761e056e65e", "patch": "@@ -124,46 +124,8 @@ fn lookup_vtable_covariant(vcx: &VtableContext,\n            vcx.infcx.ty_to_str(ty),\n            vcx.infcx.ty_to_str(trait_ty));\n \n-    let worklist = dvec::DVec();\n-    worklist.push(trait_ty);\n-    while worklist.len() > 0 {\n-        let trait_ty = worklist.pop();\n-        let result = lookup_vtable_invariant(vcx, location_info, ty, trait_ty,\n-                                             allow_unsafe, is_early);\n-        if result.is_some() {\n-            return result;\n-        }\n-\n-        // Add subtraits to the worklist, if applicable.\n-        match ty::get(trait_ty).sty {\n-            ty::ty_trait(trait_id, _, _) => {\n-                let table = vcx.ccx.coherence_info.supertrait_to_subtraits;\n-                match table.find(trait_id) {\n-                    None => {}\n-                    Some(subtraits) => {\n-                        for subtraits.each |subtrait_id| {\n-                            // XXX: This is wrong; subtraits should themselves\n-                            // have substs.\n-                            let substs =\n-                                { self_r: None, self_ty: None, tps: ~[] };\n-                            let trait_ty = ty::mk_trait(vcx.tcx(),\n-                                                        *subtrait_id,\n-                                                        substs,\n-                                                        ty::vstore_box);\n-                            worklist.push(trait_ty);\n-                        }\n-                    }\n-                }\n-            }\n-            _ => {\n-                vcx.tcx().sess.impossible_case(location_info.span,\n-                                               \"lookup_vtable_covariant: \\\n-                                                non-trait in worklist\");\n-            }\n-        }\n-    }\n-\n-    return None;\n+    lookup_vtable_invariant(vcx, location_info, ty, trait_ty,\n+                            allow_unsafe, is_early)\n }\n \n // Look up the vtable to use when treating an item of type `t` as if it has"}, {"sha": "d441f11959d07d0a0127f05584ab9ae36cfa1ab3", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 46, "deletions": 50, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/daa89e086156099e3aa95577ec97f761e056e65e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daa89e086156099e3aa95577ec97f761e056e65e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=daa89e086156099e3aa95577ec97f761e056e65e", "patch": "@@ -144,9 +144,6 @@ struct CoherenceInfo {\n     // the associated trait must be imported at the call site.\n     extension_methods: HashMap<def_id,@DVec<@Impl>>,\n \n-    // A mapping from a supertrait to its subtraits.\n-    supertrait_to_subtraits: HashMap<def_id,@DVec<def_id>>,\n-\n     // A mapping from an implementation ID to the method info and trait method\n     // ID of the provided (a.k.a. default) methods in the traits that that\n     // implementation implements.\n@@ -157,7 +154,6 @@ fn CoherenceInfo() -> CoherenceInfo {\n     CoherenceInfo {\n         inherent_methods: HashMap(),\n         extension_methods: HashMap(),\n-        supertrait_to_subtraits: HashMap(),\n         provided_methods: HashMap(),\n     }\n }\n@@ -204,9 +200,6 @@ impl CoherenceChecker {\n                     item_class(struct_def, _) => {\n                         self.check_implementation(item, struct_def.traits);\n                     }\n-                    item_trait(_, supertraits, _) => {\n-                        self.register_inherited_trait(item, supertraits);\n-                    }\n                     _ => {\n                         // Nothing to do.\n                     }\n@@ -215,12 +208,8 @@ impl CoherenceChecker {\n             .. *default_simple_visitor()\n         }));\n \n-        // Check trait coherence.\n-        for self.crate_context.coherence_info.extension_methods.each\n-                |def_id, items| {\n-\n-            self.check_implementation_coherence(def_id, items);\n-        }\n+        // Check that there are no overlapping trait instances\n+        self.check_implementation_coherence();\n \n         // Check whether traits with base types are in privileged scopes.\n         self.check_privileged_scopes(crate);\n@@ -377,27 +366,6 @@ impl CoherenceChecker {\n         }\n     }\n \n-    fn register_inherited_trait(item: @item, supertraits: ~[@trait_ref]) {\n-        // XXX: This is wrong. We need to support substitutions; e.g.\n-        // trait Foo : Bar<int>.\n-        let supertrait_to_subtraits =\n-            self.crate_context.coherence_info.supertrait_to_subtraits;\n-        let subtrait_id = local_def(item.id);\n-        for supertraits.each |supertrait| {\n-            let supertrait_id = self.trait_ref_to_trait_def_id(*supertrait);\n-            match supertrait_to_subtraits.find(supertrait_id) {\n-                None => {\n-                    let new_vec = @dvec::DVec();\n-                    new_vec.push(subtrait_id);\n-                    supertrait_to_subtraits.insert(supertrait_id, new_vec);\n-                }\n-                Some(existing_vec) => {\n-                    existing_vec.push(subtrait_id);\n-                }\n-            }\n-        }\n-    }\n-\n     fn add_inherent_method(base_def_id: def_id, implementation: @Impl) {\n         let implementation_list;\n         match self.crate_context.coherence_info.inherent_methods\n@@ -432,29 +400,57 @@ impl CoherenceChecker {\n         implementation_list.push(implementation);\n     }\n \n-    fn check_implementation_coherence(_trait_def_id: def_id,\n-                                      implementations: @DVec<@Impl>) {\n+    fn check_implementation_coherence() {\n+        let coherence_info = &self.crate_context.coherence_info;\n+        let extension_methods = &coherence_info.extension_methods;\n+\n+        for extension_methods.each_key |trait_id| {\n+            self.check_implementation_coherence_of(trait_id);\n+        }\n+    }\n+\n+    fn check_implementation_coherence_of(trait_def_id: def_id) {\n \n         // Unify pairs of polytypes.\n-        for range(0, implementations.len()) |i| {\n-            let implementation_a = implementations.get_elt(i);\n+        do self.iter_impls_of_trait(trait_def_id) |a| {\n+            let implementation_a = a;\n             let polytype_a =\n                 self.get_self_type_for_implementation(implementation_a);\n-            for range(i + 1, implementations.len()) |j| {\n-                let implementation_b = implementations.get_elt(j);\n-                let polytype_b =\n-                    self.get_self_type_for_implementation(implementation_b);\n+            do self.iter_impls_of_trait(trait_def_id) |b| {\n+                let implementation_b = b;\n \n-                if self.polytypes_unify(polytype_a, polytype_b) {\n-                    let session = self.crate_context.tcx.sess;\n-                    session.span_err(self.span_of_impl(implementation_b),\n-                                     ~\"conflicting implementations for a \\\n-                                       trait\");\n-                    session.span_note(self.span_of_impl(implementation_a),\n-                                      ~\"note conflicting implementation \\\n-                                        here\");\n+                // An impl is coherent with itself\n+                if a.did != b.did {\n+                    let polytype_b = self.get_self_type_for_implementation(\n+                            implementation_b);\n+\n+                    if self.polytypes_unify(polytype_a, polytype_b) {\n+                        let session = self.crate_context.tcx.sess;\n+                        session.span_err(self.span_of_impl(implementation_b),\n+                                         ~\"conflicting implementations for a \\\n+                                           trait\");\n+                        session.span_note(self.span_of_impl(implementation_a),\n+                                          ~\"note conflicting implementation \\\n+                                            here\");\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn iter_impls_of_trait(trait_def_id: def_id,\n+                           f: &fn(@Impl)) {\n+\n+        let coherence_info = &self.crate_context.coherence_info;\n+        let extension_methods = &coherence_info.extension_methods;\n+\n+        match extension_methods.find(trait_def_id) {\n+            Some(impls) => {\n+                for uint::range(0, impls.len()) |i| {\n+                    f(impls[i]);\n                 }\n             }\n+            None => { /* no impls? */ }\n         }\n     }\n "}]}