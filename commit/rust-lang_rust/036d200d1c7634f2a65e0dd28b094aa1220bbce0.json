{"sha": "036d200d1c7634f2a65e0dd28b094aa1220bbce0", "node_id": "C_kwDOAAsO6NoAKDAzNmQyMDBkMWM3NjM0ZjJhNjVlMGRkMjhiMDk0YWExMjIwYmJjZTA", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-04-19T12:43:20Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-04-19T12:43:20Z"}, "message": "Rollup merge of #96122 - TaKO8Ki:fix-invalid-error-for-suggestion-to-add-slice-in-pattern-matching, r=nagisa\n\nFix an invalid error for a suggestion to add a slice in pattern-matching\n\ncloses #96103", "tree": {"sha": "8eaebb468b759b544c5a58bd60f8953800e33cac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8eaebb468b759b544c5a58bd60f8953800e33cac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/036d200d1c7634f2a65e0dd28b094aa1220bbce0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiXq5oCRBK7hj4Ov3rIwAAOD4IAFroDgaw6JtVdOn1XphF1kJp\nIjzctw7nTzPW10lgwWcwfuXnD+drcYTkqNgnGAWCyB+Czur4/uP47yQfLgAR27Sw\n0JpKErPcS4Q2wmVYU95u3u69/5b8NNG5fRuTwnljty/YUi7kSb7uB//naTdMnUxm\nf4a6egNUQzS9cVSPWx4Wy7FExsfdvLxgQvp3l1x8YDPXhuwIRZNgK5MbaeA9qq+Y\n0lsY6A81ZdvIU9rFtWJc3On/4HPY9MisJ1Cebm90VbSeDd/erxGNXWIxbPmWTSlH\nxBsAbaA/i02RHgZK3IBeTlsRpJto3rWBC7oYogXDW9yjcRF1koNGh5GXY0JaWMw=\n=ACg1\n-----END PGP SIGNATURE-----\n", "payload": "tree 8eaebb468b759b544c5a58bd60f8953800e33cac\nparent 35188440b5e3d02acdb02f616aad800c9c377dca\nparent efe438b47441203c8e881e87f2f2e29db76d3ff7\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1650372200 +0200\ncommitter GitHub <noreply@github.com> 1650372200 +0200\n\nRollup merge of #96122 - TaKO8Ki:fix-invalid-error-for-suggestion-to-add-slice-in-pattern-matching, r=nagisa\n\nFix an invalid error for a suggestion to add a slice in pattern-matching\n\ncloses #96103\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/036d200d1c7634f2a65e0dd28b094aa1220bbce0", "html_url": "https://github.com/rust-lang/rust/commit/036d200d1c7634f2a65e0dd28b094aa1220bbce0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/036d200d1c7634f2a65e0dd28b094aa1220bbce0/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "35188440b5e3d02acdb02f616aad800c9c377dca", "url": "https://api.github.com/repos/rust-lang/rust/commits/35188440b5e3d02acdb02f616aad800c9c377dca", "html_url": "https://github.com/rust-lang/rust/commit/35188440b5e3d02acdb02f616aad800c9c377dca"}, {"sha": "efe438b47441203c8e881e87f2f2e29db76d3ff7", "url": "https://api.github.com/repos/rust-lang/rust/commits/efe438b47441203c8e881e87f2f2e29db76d3ff7", "html_url": "https://github.com/rust-lang/rust/commit/efe438b47441203c8e881e87f2f2e29db76d3ff7"}], "stats": {"total": 145, "additions": 96, "deletions": 49}, "files": [{"sha": "cf0c5703cd0ee7c724ff760b13ef9987ac79bab1", "filename": "compiler/rustc_typeck/src/check/pat.rs", "status": "modified", "additions": 46, "deletions": 49, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/036d200d1c7634f2a65e0dd28b094aa1220bbce0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/036d200d1c7634f2a65e0dd28b094aa1220bbce0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs?ref=036d200d1c7634f2a65e0dd28b094aa1220bbce0", "patch": "@@ -2042,63 +2042,60 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             self.tcx.sess,\n             span,\n             E0529,\n-            \"expected an array or slice, found `{}`\",\n-            expected_ty\n+            \"expected an array or slice, found `{expected_ty}`\"\n         );\n-        if let ty::Ref(_, ty, _) = expected_ty.kind() {\n-            if let ty::Array(..) | ty::Slice(..) = ty.kind() {\n-                err.help(\"the semantics of slice patterns changed recently; see issue #62254\");\n-            }\n+        if let ty::Ref(_, ty, _) = expected_ty.kind()\n+            && let ty::Array(..) | ty::Slice(..) = ty.kind()\n+        {\n+            err.help(\"the semantics of slice patterns changed recently; see issue #62254\");\n         } else if Autoderef::new(&self.infcx, self.param_env, self.body_id, span, expected_ty, span)\n             .any(|(ty, _)| matches!(ty.kind(), ty::Slice(..) | ty::Array(..)))\n+            && let (Some(span), true) = (ti.span, ti.origin_expr)\n+            && let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span)\n         {\n-            if let (Some(span), true) = (ti.span, ti.origin_expr) {\n-                if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n-                    let applicability = Autoderef::new(\n-                        &self.infcx,\n-                        self.param_env,\n-                        self.body_id,\n-                        span,\n-                        self.resolve_vars_if_possible(ti.expected),\n+            let ty = self.resolve_vars_if_possible(ti.expected);\n+            let is_slice_or_array_or_vector = self.is_slice_or_array_or_vector(&mut err, snippet.clone(), ty);\n+            match is_slice_or_array_or_vector.1.kind() {\n+                ty::Adt(adt_def, _)\n+                    if self.tcx.is_diagnostic_item(sym::Option, adt_def.did())\n+                        || self.tcx.is_diagnostic_item(sym::Result, adt_def.did()) =>\n+                {\n+                    // Slicing won't work here, but `.as_deref()` might (issue #91328).\n+                    err.span_suggestion(\n                         span,\n-                    )\n-                    .find_map(|(ty, _)| {\n-                        match ty.kind() {\n-                            ty::Adt(adt_def, _)\n-                                if self.tcx.is_diagnostic_item(sym::Option, adt_def.did())\n-                                    || self.tcx.is_diagnostic_item(sym::Result, adt_def.did()) =>\n-                            {\n-                                // Slicing won't work here, but `.as_deref()` might (issue #91328).\n-                                err.span_suggestion(\n-                                    span,\n-                                    \"consider using `as_deref` here\",\n-                                    format!(\"{}.as_deref()\", snippet),\n-                                    Applicability::MaybeIncorrect,\n-                                );\n-                                Some(None)\n-                            }\n-\n-                            ty::Slice(..) | ty::Array(..) => {\n-                                Some(Some(Applicability::MachineApplicable))\n-                            }\n-\n-                            _ => None,\n-                        }\n-                    })\n-                    .unwrap_or(Some(Applicability::MaybeIncorrect));\n-\n-                    if let Some(applicability) = applicability {\n-                        err.span_suggestion(\n-                            span,\n-                            \"consider slicing here\",\n-                            format!(\"{}[..]\", snippet),\n-                            applicability,\n-                        );\n-                    }\n+                        \"consider using `as_deref` here\",\n+                        format!(\"{snippet}.as_deref()\"),\n+                        Applicability::MaybeIncorrect,\n+                    );\n                 }\n+                _ => ()\n+            }\n+            if is_slice_or_array_or_vector.0 {\n+                err.span_suggestion(\n+                    span,\n+                    \"consider slicing here\",\n+                    format!(\"{snippet}[..]\"),\n+                    Applicability::MachineApplicable,\n+                );\n             }\n         }\n-        err.span_label(span, format!(\"pattern cannot match with input type `{}`\", expected_ty));\n+        err.span_label(span, format!(\"pattern cannot match with input type `{expected_ty}`\"));\n         err.emit();\n     }\n+\n+    fn is_slice_or_array_or_vector(\n+        &self,\n+        err: &mut Diagnostic,\n+        snippet: String,\n+        ty: Ty<'tcx>,\n+    ) -> (bool, Ty<'tcx>) {\n+        match ty.kind() {\n+            ty::Adt(adt_def, _) if self.tcx.is_diagnostic_item(sym::Vec, adt_def.did()) => {\n+                (true, ty)\n+            }\n+            ty::Ref(_, ty, _) => self.is_slice_or_array_or_vector(err, snippet, *ty),\n+            ty::Slice(..) | ty::Array(..) => (true, ty),\n+            _ => (false, ty),\n+        }\n+    }\n }"}, {"sha": "5b223a91f508f1c714bb34afe55bee50ad384797", "filename": "src/test/ui/suggestions/pattern-struct-with-slice-vec-field.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/036d200d1c7634f2a65e0dd28b094aa1220bbce0/src%2Ftest%2Fui%2Fsuggestions%2Fpattern-struct-with-slice-vec-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/036d200d1c7634f2a65e0dd28b094aa1220bbce0/src%2Ftest%2Fui%2Fsuggestions%2Fpattern-struct-with-slice-vec-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fpattern-struct-with-slice-vec-field.rs?ref=036d200d1c7634f2a65e0dd28b094aa1220bbce0", "patch": "@@ -0,0 +1,35 @@\n+use std::ops::Deref;\n+\n+struct Foo {\n+    v: Vec<u32>,\n+}\n+\n+struct Bar {\n+    v: Vec<u32>,\n+}\n+\n+impl Deref for Bar {\n+    type Target = Vec<u32>;\n+\n+    fn deref(&self) -> &Self::Target {\n+        &self.v\n+    }\n+}\n+\n+fn f(foo: &Foo) {\n+    match foo {\n+        Foo { v: [1, 2] } => {}\n+        //~^ ERROR expected an array or slice, found `Vec<u32>\n+        _ => {}\n+    }\n+}\n+\n+fn bar(bar: &Bar) {\n+    match bar {\n+        Bar { v: [1, 2] } => {}\n+        //~^ ERROR expected an array or slice, found `Vec<u32>\n+        _ => {}\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "5b48a8b18a5147cdd371b77e6dfa2060fd63d600", "filename": "src/test/ui/suggestions/pattern-struct-with-slice-vec-field.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/036d200d1c7634f2a65e0dd28b094aa1220bbce0/src%2Ftest%2Fui%2Fsuggestions%2Fpattern-struct-with-slice-vec-field.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/036d200d1c7634f2a65e0dd28b094aa1220bbce0/src%2Ftest%2Fui%2Fsuggestions%2Fpattern-struct-with-slice-vec-field.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fpattern-struct-with-slice-vec-field.stderr?ref=036d200d1c7634f2a65e0dd28b094aa1220bbce0", "patch": "@@ -0,0 +1,15 @@\n+error[E0529]: expected an array or slice, found `Vec<u32>`\n+  --> $DIR/pattern-struct-with-slice-vec-field.rs:21:18\n+   |\n+LL |         Foo { v: [1, 2] } => {}\n+   |                  ^^^^^^ pattern cannot match with input type `Vec<u32>`\n+\n+error[E0529]: expected an array or slice, found `Vec<u32>`\n+  --> $DIR/pattern-struct-with-slice-vec-field.rs:29:18\n+   |\n+LL |         Bar { v: [1, 2] } => {}\n+   |                  ^^^^^^ pattern cannot match with input type `Vec<u32>`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0529`."}]}