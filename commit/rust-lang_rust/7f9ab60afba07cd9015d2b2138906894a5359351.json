{"sha": "7f9ab60afba07cd9015d2b2138906894a5359351", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmOWFiNjBhZmJhMDdjZDkwMTVkMmIyMTM4OTA2ODk0YTUzNTkzNTE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-09-27T13:43:22Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-10-27T13:06:03Z"}, "message": "extend query response to potentially contain fresh universes\n\nThe idea here is that an incoming query may refer to some universes,\nand they query response may contain fresh universes that go beyond\nthose. When we instantiate the query response in the caller's scope,\ntherefore, we map those new universes into fresh universes for the\ncaller.", "tree": {"sha": "d2694d491a87b7c145b2a064b88f5cd1719e4987", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d2694d491a87b7c145b2a064b88f5cd1719e4987"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f9ab60afba07cd9015d2b2138906894a5359351", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f9ab60afba07cd9015d2b2138906894a5359351", "html_url": "https://github.com/rust-lang/rust/commit/7f9ab60afba07cd9015d2b2138906894a5359351", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f9ab60afba07cd9015d2b2138906894a5359351/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ef27d82e0623554962e96a9b06921326da861d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ef27d82e0623554962e96a9b06921326da861d2", "html_url": "https://github.com/rust-lang/rust/commit/3ef27d82e0623554962e96a9b06921326da861d2"}], "stats": {"total": 172, "additions": 144, "deletions": 28}, "files": [{"sha": "2109c4950e50832338ccb362e4290e9301ebb3ca", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7f9ab60afba07cd9015d2b2138906894a5359351/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f9ab60afba07cd9015d2b2138906894a5359351/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=7f9ab60afba07cd9015d2b2138906894a5359351", "patch": "@@ -1285,6 +1285,7 @@ impl_stable_hash_for!(struct infer::canonical::CanonicalVarInfo {\n impl_stable_hash_for!(enum infer::canonical::CanonicalVarKind {\n     Ty(k),\n     Region(ui),\n+    PlaceholderRegion(placeholder),\n });\n \n impl_stable_hash_for!(enum infer::canonical::CanonicalTyVarKind {"}, {"sha": "72bf8f96fe19ecdfec7b7df4cb4e9952a7d7136e", "filename": "src/librustc/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 28, "deletions": 7, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/7f9ab60afba07cd9015d2b2138906894a5359351/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f9ab60afba07cd9015d2b2138906894a5359351/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=7f9ab60afba07cd9015d2b2138906894a5359351", "patch": "@@ -162,11 +162,18 @@ struct CanonicalizeQueryResponse;\n impl CanonicalizeRegionMode for CanonicalizeQueryResponse {\n     fn canonicalize_free_region(\n         &self,\n-        _canonicalizer: &mut Canonicalizer<'_, '_, 'tcx>,\n+        canonicalizer: &mut Canonicalizer<'_, '_, 'tcx>,\n         r: ty::Region<'tcx>,\n     ) -> ty::Region<'tcx> {\n         match r {\n             ty::ReFree(_) | ty::ReEmpty | ty::ReErased | ty::ReStatic | ty::ReEarlyBound(..) => r,\n+            ty::RePlaceholder(placeholder) => {\n+                let info = CanonicalVarInfo {\n+                    kind: CanonicalVarKind::PlaceholderRegion(*placeholder),\n+                };\n+                let cvar = canonicalizer.canonical_var(info, r.into());\n+                canonicalizer.tcx.mk_region(ty::ReCanonical(cvar.var))\n+            }\n             _ => {\n                 // Other than `'static` or `'empty`, the query\n                 // response should be executing in a fully\n@@ -190,7 +197,7 @@ impl CanonicalizeRegionMode for CanonicalizeAllFreeRegions {\n         canonicalizer: &mut Canonicalizer<'_, '_, 'tcx>,\n         r: ty::Region<'tcx>,\n     ) -> ty::Region<'tcx> {\n-        canonicalizer.canonical_var_for_region(r)\n+        canonicalizer.canonical_var_for_region_in_root_universe(r)\n     }\n \n     fn any(&self) -> bool {\n@@ -209,7 +216,7 @@ impl CanonicalizeRegionMode for CanonicalizeFreeRegionsOtherThanStatic {\n         if let ty::ReStatic = r {\n             r\n         } else {\n-            canonicalizer.canonical_var_for_region(r)\n+            canonicalizer.canonical_var_for_region_in_root_universe(r)\n         }\n     }\n \n@@ -252,7 +259,7 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for Canonicalizer<'cx, 'gcx, 'tcx>\n                      opportunistically resolved to {:?}\",\n                     vid, r\n                 );\n-                self.canonical_var_for_region(r)\n+                self.canonical_var_for_region_in_root_universe(r)\n             }\n \n             ty::ReStatic\n@@ -459,9 +466,23 @@ impl<'cx, 'gcx, 'tcx> Canonicalizer<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn canonical_var_for_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n-        // TODO: root is not always what we want here, but we'll\n-        // address that in a later commit.\n+    /// Shorthand helper that creates a canonical region variable for\n+    /// `r` (always in the root universe). The reason that we always\n+    /// put these variables into the root universe is because this\n+    /// method is used during **query construction:** in that case, we\n+    /// are taking all the regions and just putting them into the most\n+    /// generic context we can. This may generate solutions that don't\n+    /// fit (e.g., that equate some region variable with a placeholder\n+    /// it can't name) on the caller side, but that's ok, the caller\n+    /// can figure that out. In the meantime, it maximizes our\n+    /// caching.\n+    ///\n+    /// (This works because unification never fails -- and hence trait\n+    /// selection is never affected -- due to a universe mismatch.)\n+    fn canonical_var_for_region_in_root_universe(\n+        &mut self,\n+        r: ty::Region<'tcx>,\n+    ) -> ty::Region<'tcx> {\n         let info = CanonicalVarInfo {\n             kind: CanonicalVarKind::Region(ty::UniverseIndex::ROOT),\n         };"}, {"sha": "f2b7c6e0d0d986760762fae0e4f42cf39f654ee6", "filename": "src/librustc/infer/canonical/mod.rs", "status": "modified", "additions": 84, "deletions": 18, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/7f9ab60afba07cd9015d2b2138906894a5359351/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f9ab60afba07cd9015d2b2138906894a5359351/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs?ref=7f9ab60afba07cd9015d2b2138906894a5359351", "patch": "@@ -33,14 +33,14 @@\n \n use infer::{InferCtxt, RegionVariableOrigin, TypeVariableOrigin};\n use rustc_data_structures::indexed_vec::IndexVec;\n-use smallvec::SmallVec;\n use rustc_data_structures::sync::Lrc;\n use serialize::UseSpecializedDecodable;\n+use smallvec::SmallVec;\n use std::ops::Index;\n use syntax::source_map::Span;\n use ty::fold::TypeFoldable;\n use ty::subst::Kind;\n-use ty::{self, BoundTyIndex, Lift, Region, List, TyCtxt};\n+use ty::{self, BoundTyIndex, Lift, List, Region, TyCtxt};\n \n mod canonicalizer;\n \n@@ -80,13 +80,31 @@ pub struct CanonicalVarValues<'tcx> {\n /// various parts of it with canonical variables. This struct stores\n /// those replaced bits to remember for when we process the query\n /// result.\n-#[derive(Clone, Debug, Default, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable)]\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable)]\n pub struct OriginalQueryValues<'tcx> {\n+    /// Map from the universes that appear in the query to the\n+    /// universes in the caller context. For the time being, we only\n+    /// ever put ROOT values into the query, so this map is very\n+    /// simple.\n+    pub universe_map: SmallVec<[ty::UniverseIndex; 4]>,\n+\n     /// This is equivalent to `CanonicalVarValues`, but using a\n     /// `SmallVec` yields a significant performance win.\n     pub var_values: SmallVec<[Kind<'tcx>; 8]>,\n }\n \n+impl Default for OriginalQueryValues<'tcx> {\n+    fn default() -> Self {\n+        let mut universe_map = SmallVec::default();\n+        universe_map.push(ty::UniverseIndex::ROOT);\n+\n+        Self {\n+            universe_map,\n+            var_values: SmallVec::default(),\n+        }\n+    }\n+}\n+\n /// Information about a canonical variable that is included with the\n /// canonical value. This is sufficient information for code to create\n /// a copy of the canonical value in some other inference context,\n@@ -97,9 +115,17 @@ pub struct CanonicalVarInfo {\n }\n \n impl CanonicalVarInfo {\n-    pub fn universe(self) -> ty::UniverseIndex {\n+    pub fn universe(&self) -> ty::UniverseIndex {\n         self.kind.universe()\n     }\n+\n+    pub fn is_existential(&self) -> bool {\n+        match self.kind {\n+            CanonicalVarKind::Ty(_) => true,\n+            CanonicalVarKind::Region(_) => true,\n+            CanonicalVarKind::PlaceholderRegion(..) => false,\n+        }\n+    }\n }\n \n /// Describes the \"kind\" of the canonical variable. This is a \"kind\"\n@@ -112,8 +138,12 @@ pub enum CanonicalVarKind {\n \n     /// Region variable `'?R`.\n     Region(ty::UniverseIndex),\n-}\n \n+    /// A \"placeholder\" that represents \"any region\". Created when you\n+    /// are solving a goal like `for<'a> T: Foo<'a>` to represent the\n+    /// bound region `'a`.\n+    PlaceholderRegion(ty::Placeholder),\n+}\n \n impl CanonicalVarKind {\n     pub fn universe(self) -> ty::UniverseIndex {\n@@ -125,6 +155,7 @@ impl CanonicalVarKind {\n \n             // Region variables can be created in sub-universes.\n             CanonicalVarKind::Region(ui) => ui,\n+            CanonicalVarKind::PlaceholderRegion(placeholder) => placeholder.universe,\n         }\n     }\n }\n@@ -242,8 +273,16 @@ impl<'gcx, V> Canonical<'gcx, V> {\n     /// let b: Canonical<'tcx, (T, Ty<'tcx>)> = a.unchecked_map(|v| (v, ty));\n     /// ```\n     pub fn unchecked_map<W>(self, map_op: impl FnOnce(V) -> W) -> Canonical<'gcx, W> {\n-        let Canonical { max_universe, variables, value } = self;\n-        Canonical { max_universe, variables, value: map_op(value) }\n+        let Canonical {\n+            max_universe,\n+            variables,\n+            value,\n+        } = self;\n+        Canonical {\n+            max_universe,\n+            variables,\n+            value: map_op(value),\n+        }\n     }\n }\n \n@@ -271,35 +310,50 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     where\n         T: TypeFoldable<'tcx>,\n     {\n+        // For each universe that is referred to in the incoming\n+        // query, create a universe in our local inference context. In\n+        // practice, as of this writing, all queries have no universes\n+        // in them, so this code has no effect, but it is looking\n+        // forward to the day when we *do* want to carry universes\n+        // through into queries.\n+        let universes: IndexVec<ty::UniverseIndex, _> = std::iter::once(ty::UniverseIndex::ROOT)\n+            .chain((0..canonical.max_universe.as_u32()).map(|_| self.create_next_universe()))\n+            .collect();\n+\n         let canonical_inference_vars =\n-            self.fresh_inference_vars_for_canonical_vars(span, canonical.variables);\n+            self.instantiate_canonical_vars(span, canonical.variables, |ui| universes[ui]);\n         let result = canonical.substitute(self.tcx, &canonical_inference_vars);\n         (result, canonical_inference_vars)\n     }\n \n     /// Given the \"infos\" about the canonical variables from some\n-    /// canonical, creates fresh inference variables with the same\n-    /// characteristics. You can then use `substitute` to instantiate\n-    /// the canonical variable with these inference variables.\n-    fn fresh_inference_vars_for_canonical_vars(\n+    /// canonical, creates fresh variables with the same\n+    /// characteristics (see `instantiate_canonical_var` for\n+    /// details). You can then use `substitute` to instantiate the\n+    /// canonical variable with these inference variables.\n+    fn instantiate_canonical_vars(\n         &self,\n         span: Span,\n         variables: &List<CanonicalVarInfo>,\n+        universe_map: impl Fn(ty::UniverseIndex) -> ty::UniverseIndex,\n     ) -> CanonicalVarValues<'tcx> {\n         let var_values: IndexVec<BoundTyIndex, Kind<'tcx>> = variables\n             .iter()\n-            .map(|info| self.fresh_inference_var_for_canonical_var(span, *info))\n+            .map(|info| self.instantiate_canonical_var(span, *info, &universe_map))\n             .collect();\n \n         CanonicalVarValues { var_values }\n     }\n \n     /// Given the \"info\" about a canonical variable, creates a fresh\n-    /// inference variable with the same characteristics.\n-    fn fresh_inference_var_for_canonical_var(\n+    /// variable for it. If this is an existentially quantified\n+    /// variable, then you'll get a new inference variable; if it is a\n+    /// universally quantified variable, you get a placeholder.\n+    fn instantiate_canonical_var(\n         &self,\n         span: Span,\n         cv_info: CanonicalVarInfo,\n+        universe_map: impl Fn(ty::UniverseIndex) -> ty::UniverseIndex,\n     ) -> Kind<'tcx> {\n         match cv_info.kind {\n             CanonicalVarKind::Ty(ty_kind) => {\n@@ -315,9 +369,21 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n                 ty.into()\n             }\n \n-            CanonicalVarKind::Region(ui) => self\n-                .next_region_var_in_universe(RegionVariableOrigin::MiscVariable(span), ui)\n-                .into(),\n+            CanonicalVarKind::Region(ui) => self.next_region_var_in_universe(\n+                RegionVariableOrigin::MiscVariable(span),\n+                universe_map(ui),\n+            ).into(),\n+\n+            CanonicalVarKind::PlaceholderRegion(ty::Placeholder { universe, name }) => {\n+                let universe_mapped = universe_map(universe);\n+                let placeholder_mapped = ty::Placeholder {\n+                    universe: universe_mapped,\n+                    name,\n+                };\n+                self.tcx\n+                    .mk_region(ty::RePlaceholder(placeholder_mapped))\n+                    .into()\n+            }\n         }\n     }\n }"}, {"sha": "b3ce5eb7e56c26dee4fac39f0f845186b99824e2", "filename": "src/librustc/infer/canonical/query_response.rs", "status": "modified", "additions": 29, "deletions": 3, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7f9ab60afba07cd9015d2b2138906894a5359351/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f9ab60afba07cd9015d2b2138906894a5359351/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=7f9ab60afba07cd9015d2b2138906894a5359351", "patch": "@@ -394,6 +394,21 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n             original_values, query_response,\n         );\n \n+        // For each new universe created in the query result that did\n+        // not appear in the original query, create a local\n+        // superuniverse.\n+        let mut universe_map = original_values.universe_map.clone();\n+        let num_universes_in_query = original_values.universe_map.len();\n+        let num_universes_in_response = query_response.max_universe.as_usize() + 1;\n+        for _ in num_universes_in_query..num_universes_in_response {\n+            universe_map.push(self.create_next_universe());\n+        }\n+        assert!(universe_map.len() >= 1); // always have the root universe\n+        assert_eq!(\n+            universe_map[ty::UniverseIndex::ROOT.as_usize()],\n+            ty::UniverseIndex::ROOT\n+        );\n+\n         // Every canonical query result includes values for each of\n         // the inputs to the query. Therefore, we begin by unifying\n         // these values with the original inputs that were\n@@ -440,9 +455,20 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n                 .variables\n                 .iter()\n                 .enumerate()\n-                .map(|(index, info)| opt_values[BoundTyIndex::new(index)].unwrap_or_else(||\n-                    self.fresh_inference_var_for_canonical_var(cause.span, *info)\n-                ))\n+                .map(|(index, info)| {\n+                    if info.is_existential() {\n+                        match opt_values[BoundTyIndex::new(index)] {\n+                            Some(k) => k,\n+                            None => self.instantiate_canonical_var(cause.span, *info, |u| {\n+                                universe_map[u.as_usize()]\n+                            }),\n+                        }\n+                    } else {\n+                        self.instantiate_canonical_var(cause.span, *info, |u| {\n+                            universe_map[u.as_usize()]\n+                        })\n+                    }\n+                })\n                 .collect(),\n         };\n "}, {"sha": "4e21439439911737b7bf63687052a71547ef6ce0", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f9ab60afba07cd9015d2b2138906894a5359351/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f9ab60afba07cd9015d2b2138906894a5359351/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=7f9ab60afba07cd9015d2b2138906894a5359351", "patch": "@@ -1540,6 +1540,8 @@ pub struct Placeholder {\n     pub name: BoundRegion,\n }\n \n+impl_stable_hash_for!(struct Placeholder { universe, name });\n+\n /// When type checking, we use the `ParamEnv` to track\n /// details about the set of where-clauses that are in scope at this\n /// particular point."}]}