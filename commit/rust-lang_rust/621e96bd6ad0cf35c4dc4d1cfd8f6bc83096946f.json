{"sha": "621e96bd6ad0cf35c4dc4d1cfd8f6bc83096946f", "node_id": "C_kwDOAAsO6NoAKDYyMWU5NmJkNmFkMGNmMzVjNGRjNGQxY2ZkOGY2YmM4MzA5Njk0NmY", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-01-09T19:47:51Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-01-09T20:06:13Z"}, "message": "Encode one level of cfg_attr in attr_id", "tree": {"sha": "c6b79249b438b3d196e4a3e0b5eff0b178797466", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c6b79249b438b3d196e4a3e0b5eff0b178797466"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/621e96bd6ad0cf35c4dc4d1cfd8f6bc83096946f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/621e96bd6ad0cf35c4dc4d1cfd8f6bc83096946f", "html_url": "https://github.com/rust-lang/rust/commit/621e96bd6ad0cf35c4dc4d1cfd8f6bc83096946f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/621e96bd6ad0cf35c4dc4d1cfd8f6bc83096946f/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68723043db2e7ee6e780c7f42cd9e57df72a1fd0", "url": "https://api.github.com/repos/rust-lang/rust/commits/68723043db2e7ee6e780c7f42cd9e57df72a1fd0", "html_url": "https://github.com/rust-lang/rust/commit/68723043db2e7ee6e780c7f42cd9e57df72a1fd0"}], "stats": {"total": 151, "additions": 99, "deletions": 52}, "files": [{"sha": "a0113fd048ce5f008e81ce251d5a54819117e9fa", "filename": "crates/hir-def/src/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/621e96bd6ad0cf35c4dc4d1cfd8f6bc83096946f/crates%2Fhir-def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/621e96bd6ad0cf35c4dc4d1cfd8f6bc83096946f/crates%2Fhir-def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fattr.rs?ref=621e96bd6ad0cf35c4dc4d1cfd8f6bc83096946f", "patch": "@@ -546,7 +546,7 @@ impl AttrSourceMap {\n     }\n \n     fn source_of_id(&self, id: AttrId) -> InFile<&Either<ast::Attr, ast::Comment>> {\n-        let ast_idx = id.ast_index as usize;\n+        let ast_idx = id.ast_index();\n         let file_id = match self.mod_def_site_file_id {\n             Some((file_id, def_site_cut)) if def_site_cut <= ast_idx => file_id,\n             _ => self.file_id,"}, {"sha": "19d2fe956f098b964a6e773f57acbbcf1304b044", "filename": "crates/hir-def/src/child_by_source.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/621e96bd6ad0cf35c4dc4d1cfd8f6bc83096946f/crates%2Fhir-def%2Fsrc%2Fchild_by_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/621e96bd6ad0cf35c4dc4d1cfd8f6bc83096946f/crates%2Fhir-def%2Fsrc%2Fchild_by_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fchild_by_source.rs?ref=621e96bd6ad0cf35c4dc4d1cfd8f6bc83096946f", "patch": "@@ -117,7 +117,7 @@ impl ChildBySource for ItemScope {\n                 let adt = ast_id.to_node(db.upcast());\n                 calls.for_each(|(attr_id, call_id, calls)| {\n                     if let Some(Either::Left(attr)) =\n-                        adt.doc_comments_and_attrs().nth(attr_id.ast_index as usize)\n+                        adt.doc_comments_and_attrs().nth(attr_id.ast_index())\n                     {\n                         res[keys::DERIVE_MACRO_CALL].insert(attr, (attr_id, call_id, calls.into()));\n                     }"}, {"sha": "8eae2e92f4262676727de7fad6daad606ac14d89", "filename": "crates/hir-def/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/621e96bd6ad0cf35c4dc4d1cfd8f6bc83096946f/crates%2Fhir-def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/621e96bd6ad0cf35c4dc4d1cfd8f6bc83096946f/crates%2Fhir-def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Flib.rs?ref=621e96bd6ad0cf35c4dc4d1cfd8f6bc83096946f", "patch": "@@ -941,7 +941,7 @@ pub fn macro_id_to_def_id(db: &dyn db::DefDatabase, id: MacroId) -> MacroDefId {\n fn derive_macro_as_call_id(\n     db: &dyn db::DefDatabase,\n     item_attr: &AstIdWithPath<ast::Adt>,\n-    derive_attr: AttrId,\n+    derive_attr_index: AttrId,\n     derive_pos: u32,\n     krate: CrateId,\n     resolver: impl Fn(path::ModPath) -> Option<(MacroId, MacroDefId)>,\n@@ -954,7 +954,7 @@ fn derive_macro_as_call_id(\n         MacroCallKind::Derive {\n             ast_id: item_attr.ast_id,\n             derive_index: derive_pos,\n-            derive_attr_index: derive_attr.ast_index,\n+            derive_attr_index,\n         },\n     );\n     Ok((macro_id, def_id, call_id))\n@@ -982,7 +982,7 @@ fn attr_macro_as_call_id(\n         MacroCallKind::Attr {\n             ast_id: item_attr.ast_id,\n             attr_args: Arc::new(arg),\n-            invoc_attr_index: macro_attr.id.ast_index,\n+            invoc_attr_index: macro_attr.id,\n             is_derive,\n         },\n     );"}, {"sha": "33a787fd9f95d6ec8ea4a9f32ea96cc7e6ffc239", "filename": "crates/hir-def/src/nameres/collector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/621e96bd6ad0cf35c4dc4d1cfd8f6bc83096946f/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/621e96bd6ad0cf35c4dc4d1cfd8f6bc83096946f/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs?ref=621e96bd6ad0cf35c4dc4d1cfd8f6bc83096946f", "patch": "@@ -452,7 +452,7 @@ impl DefCollector<'_> {\n                         MacroCallKind::Attr {\n                             ast_id: ast_id.ast_id,\n                             attr_args: Default::default(),\n-                            invoc_attr_index: attr.id.ast_index,\n+                            invoc_attr_index: attr.id,\n                             is_derive: false,\n                         },\n                         attr.path().clone(),\n@@ -1407,7 +1407,7 @@ impl DefCollector<'_> {\n                         directive.module_id,\n                         MacroCallKind::Derive {\n                             ast_id: ast_id.ast_id,\n-                            derive_attr_index: derive_attr.ast_index,\n+                            derive_attr_index: *derive_attr,\n                             derive_index: *derive_pos as u32,\n                         },\n                         ast_id.path.clone(),"}, {"sha": "b024d7c6777c03ee4a4ba0b0eea4affbeea58ab7", "filename": "crates/hir-def/src/nameres/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/621e96bd6ad0cf35c4dc4d1cfd8f6bc83096946f/crates%2Fhir-def%2Fsrc%2Fnameres%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/621e96bd6ad0cf35c4dc4d1cfd8f6bc83096946f/crates%2Fhir-def%2Fsrc%2Fnameres%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fdiagnostics.rs?ref=621e96bd6ad0cf35c4dc4d1cfd8f6bc83096946f", "patch": "@@ -31,9 +31,9 @@ pub enum DefDiagnosticKind {\n \n     UnimplementedBuiltinMacro { ast: AstId<ast::Macro> },\n \n-    InvalidDeriveTarget { ast: AstId<ast::Item>, id: u32 },\n+    InvalidDeriveTarget { ast: AstId<ast::Item>, id: usize },\n \n-    MalformedDerive { ast: AstId<ast::Adt>, id: u32 },\n+    MalformedDerive { ast: AstId<ast::Adt>, id: usize },\n }\n \n #[derive(Debug, PartialEq, Eq)]\n@@ -119,7 +119,7 @@ impl DefDiagnostic {\n     ) -> Self {\n         Self {\n             in_module: container,\n-            kind: DefDiagnosticKind::InvalidDeriveTarget { ast, id: id.ast_index },\n+            kind: DefDiagnosticKind::InvalidDeriveTarget { ast, id: id.ast_index() },\n         }\n     }\n \n@@ -130,7 +130,7 @@ impl DefDiagnostic {\n     ) -> Self {\n         Self {\n             in_module: container,\n-            kind: DefDiagnosticKind::MalformedDerive { ast, id: id.ast_index },\n+            kind: DefDiagnosticKind::MalformedDerive { ast, id: id.ast_index() },\n         }\n     }\n }"}, {"sha": "c7135732b8a2a8d7ac2663692a9d9b3dd0c9572f", "filename": "crates/hir-expand/src/attrs.rs", "status": "modified", "additions": 56, "deletions": 23, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/621e96bd6ad0cf35c4dc4d1cfd8f6bc83096946f/crates%2Fhir-expand%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/621e96bd6ad0cf35c4dc4d1cfd8f6bc83096946f/crates%2Fhir-expand%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Fattrs.rs?ref=621e96bd6ad0cf35c4dc4d1cfd8f6bc83096946f", "patch": "@@ -1,3 +1,4 @@\n+//! A higher level attributes based on TokenTree, with also some shortcuts.\n use std::{fmt, ops, sync::Arc};\n \n use base_db::CrateId;\n@@ -65,14 +66,16 @@ impl RawAttrs {\n             (None, entries @ Some(_)) => Self { entries },\n             (Some(entries), None) => Self { entries: Some(entries.clone()) },\n             (Some(a), Some(b)) => {\n-                let last_ast_index = a.last().map_or(0, |it| it.id.ast_index + 1);\n+                let last_ast_index = a.last().map_or(0, |it| it.id.ast_index() + 1) as u32;\n                 Self {\n                     entries: Some(\n                         a.iter()\n                             .cloned()\n                             .chain(b.iter().map(|it| {\n                                 let mut it = it.clone();\n-                                it.id.ast_index += last_ast_index;\n+                                it.id.id = it.id.ast_index() as u32 + last_ast_index\n+                                    | (it.id.cfg_attr_index().unwrap_or(0) as u32)\n+                                        << AttrId::AST_INDEX_BITS;\n                                 it\n                             }))\n                             .collect(),\n@@ -83,6 +86,7 @@ impl RawAttrs {\n     }\n \n     /// Processes `cfg_attr`s, returning the resulting semantic `Attrs`.\n+    // FIXME: This should return a different type\n     pub fn filter(self, db: &dyn AstDatabase, krate: CrateId) -> RawAttrs {\n         let has_cfg_attrs = self\n             .iter()\n@@ -106,27 +110,22 @@ impl RawAttrs {\n                     _ => return smallvec![attr.clone()],\n                 };\n \n-                // Input subtree is: `(cfg, $(attr),+)`\n-                // Split it up into a `cfg` subtree and the `attr` subtrees.\n-                // FIXME: There should be a common API for this.\n-                let mut parts = subtree.token_trees.split(|tt| {\n-                    matches!(tt, tt::TokenTree::Leaf(tt::Leaf::Punct(Punct { char: ',', .. })))\n-                });\n-                let cfg = match parts.next() {\n+                let (cfg, parts) = match parse_cfg_attr_input(subtree) {\n                     Some(it) => it,\n-                    None => return smallvec![],\n+                    None => return smallvec![attr.clone()],\n                 };\n-                let cfg = Subtree { delimiter: subtree.delimiter, token_trees: cfg.to_vec() };\n-                let cfg = CfgExpr::parse(&cfg);\n                 let index = attr.id;\n-                let attrs = parts.filter(|a| !a.is_empty()).filter_map(|attr| {\n-                    let tree = Subtree { delimiter: None, token_trees: attr.to_vec() };\n-                    // FIXME hygiene\n-                    let hygiene = Hygiene::new_unhygienic();\n-                    Attr::from_tt(db, &tree, &hygiene, index)\n-                });\n+                let attrs =\n+                    parts.enumerate().take(1 << AttrId::CFG_ATTR_BITS).filter_map(|(idx, attr)| {\n+                        let tree = Subtree { delimiter: None, token_trees: attr.to_vec() };\n+                        // FIXME hygiene\n+                        let hygiene = Hygiene::new_unhygienic();\n+                        Attr::from_tt(db, &tree, &hygiene, index.with_cfg_attr(idx))\n+                    });\n \n                 let cfg_options = &crate_graph[krate].cfg_options;\n+                let cfg = Subtree { delimiter: subtree.delimiter, token_trees: cfg.to_vec() };\n+                let cfg = CfgExpr::parse(&cfg);\n                 if cfg_options.check(&cfg) == Some(false) {\n                     smallvec![]\n                 } else {\n@@ -143,7 +142,32 @@ impl RawAttrs {\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct AttrId {\n-    pub ast_index: u32,\n+    id: u32,\n+}\n+\n+// FIXME: This only handles a single level of cfg_attr nesting\n+// that is `#[cfg_attr(all(), cfg_attr(all(), cfg(any())))]` breaks again\n+impl AttrId {\n+    const CFG_ATTR_BITS: usize = 7;\n+    const AST_INDEX_MASK: usize = 0x00FF_FFFF;\n+    const AST_INDEX_BITS: usize = Self::AST_INDEX_MASK.count_ones() as usize;\n+    const CFG_ATTR_SET_BITS: u32 = 1 << 31;\n+\n+    pub fn ast_index(&self) -> usize {\n+        self.id as usize & Self::AST_INDEX_MASK\n+    }\n+\n+    pub fn cfg_attr_index(&self) -> Option<usize> {\n+        if self.id & Self::CFG_ATTR_SET_BITS == 0 {\n+            None\n+        } else {\n+            Some(self.id as usize >> Self::AST_INDEX_BITS)\n+        }\n+    }\n+\n+    pub fn with_cfg_attr(self, idx: usize) -> AttrId {\n+        AttrId { id: self.id | (idx as u32) << Self::AST_INDEX_BITS | Self::CFG_ATTR_SET_BITS }\n+    }\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -272,10 +296,7 @@ pub fn collect_attrs(\n             Either::Left(attr) => attr.kind().is_outer(),\n             Either::Right(comment) => comment.is_outer(),\n         });\n-    outer_attrs\n-        .chain(inner_attrs)\n-        .enumerate()\n-        .map(|(id, attr)| (AttrId { ast_index: id as u32 }, attr))\n+    outer_attrs.chain(inner_attrs).enumerate().map(|(id, attr)| (AttrId { id: id as u32 }, attr))\n }\n \n fn inner_attributes(\n@@ -311,3 +332,15 @@ fn inner_attributes(\n     });\n     Some(attrs)\n }\n+\n+// Input subtree is: `(cfg, $(attr),+)`\n+// Split it up into a `cfg` subtree and the `attr` subtrees.\n+pub fn parse_cfg_attr_input(\n+    subtree: &Subtree,\n+) -> Option<(&[tt::TokenTree], impl Iterator<Item = &[tt::TokenTree]>)> {\n+    let mut parts = subtree\n+        .token_trees\n+        .split(|tt| matches!(tt, tt::TokenTree::Leaf(tt::Leaf::Punct(Punct { char: ',', .. }))));\n+    let cfg = parts.next()?;\n+    Some((cfg, parts.filter(|it| !it.is_empty())))\n+}"}, {"sha": "ec5886824f8610b03416bbb90f93a651f76862d4", "filename": "crates/hir-expand/src/db.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/621e96bd6ad0cf35c4dc4d1cfd8f6bc83096946f/crates%2Fhir-expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/621e96bd6ad0cf35c4dc4d1cfd8f6bc83096946f/crates%2Fhir-expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Fdb.rs?ref=621e96bd6ad0cf35c4dc4d1cfd8f6bc83096946f", "patch": "@@ -168,7 +168,9 @@ pub fn expand_speculative(\n                 // Attributes may have an input token tree, build the subtree and map for this as well\n                 // then try finding a token id for our token if it is inside this input subtree.\n                 let item = ast::Item::cast(speculative_args.clone())?;\n-                item.doc_comments_and_attrs().nth(invoc_attr_index as usize).and_then(Either::left)\n+                item.doc_comments_and_attrs()\n+                    .nth(invoc_attr_index.ast_index())\n+                    .and_then(Either::left)\n             }?;\n             match attr.token_tree() {\n                 Some(token_tree) => {\n@@ -321,14 +323,15 @@ fn macro_arg(\n }\n \n fn censor_for_macro_input(loc: &MacroCallLoc, node: &SyntaxNode) -> FxHashSet<SyntaxNode> {\n+    // FIXME: handle `cfg_attr`\n     (|| {\n         let censor = match loc.kind {\n             MacroCallKind::FnLike { .. } => return None,\n             MacroCallKind::Derive { derive_attr_index, .. } => {\n                 cov_mark::hit!(derive_censoring);\n                 ast::Item::cast(node.clone())?\n                     .attrs()\n-                    .take(derive_attr_index as usize + 1)\n+                    .take(derive_attr_index.ast_index() + 1)\n                     // FIXME, this resolution should not be done syntactically\n                     // derive is a proper macro now, no longer builtin\n                     // But we do not have resolution at this stage, this means\n@@ -343,7 +346,7 @@ fn censor_for_macro_input(loc: &MacroCallLoc, node: &SyntaxNode) -> FxHashSet<Sy\n                 cov_mark::hit!(attribute_macro_attr_censoring);\n                 ast::Item::cast(node.clone())?\n                     .doc_comments_and_attrs()\n-                    .nth(invoc_attr_index as usize)\n+                    .nth(invoc_attr_index.ast_index())\n                     .and_then(Either::left)\n                     .map(|attr| attr.syntax().clone())\n                     .into_iter()"}, {"sha": "5a55dc5c9e25cd113d5905a10af6088cfef65b39", "filename": "crates/hir-expand/src/hygiene.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/621e96bd6ad0cf35c4dc4d1cfd8f6bc83096946f/crates%2Fhir-expand%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/621e96bd6ad0cf35c4dc4d1cfd8f6bc83096946f/crates%2Fhir-expand%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Fhygiene.rs?ref=621e96bd6ad0cf35c4dc4d1cfd8f6bc83096946f", "patch": "@@ -191,7 +191,7 @@ fn make_hygiene_info(\n             let tt = ast_id\n                 .to_node(db)\n                 .doc_comments_and_attrs()\n-                .nth(invoc_attr_index as usize)\n+                .nth(invoc_attr_index.ast_index())\n                 .and_then(Either::left)?\n                 .token_tree()?;\n             Some(InFile::new(ast_id.file_id, tt))"}, {"sha": "5554c7517f5accd4e1cce69412e70c6f72b7fad9", "filename": "crates/hir-expand/src/lib.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/621e96bd6ad0cf35c4dc4d1cfd8f6bc83096946f/crates%2Fhir-expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/621e96bd6ad0cf35c4dc4d1cfd8f6bc83096946f/crates%2Fhir-expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Flib.rs?ref=621e96bd6ad0cf35c4dc4d1cfd8f6bc83096946f", "patch": "@@ -38,6 +38,7 @@ use syntax::{\n \n use crate::{\n     ast_id_map::FileAstId,\n+    attrs::AttrId,\n     builtin_attr_macro::BuiltinAttrExpander,\n     builtin_derive_macro::BuiltinDeriveExpander,\n     builtin_fn_macro::{BuiltinFnLikeExpander, EagerExpander},\n@@ -146,7 +147,7 @@ pub enum MacroCallKind {\n         ///\n         /// Outer attributes are counted first, then inner attributes. This does not support\n         /// out-of-line modules, which may have attributes spread across 2 files!\n-        derive_attr_index: u32,\n+        derive_attr_index: AttrId,\n         /// Index of the derive macro in the derive attribute\n         derive_index: u32,\n     },\n@@ -157,7 +158,7 @@ pub enum MacroCallKind {\n         ///\n         /// Outer attributes are counted first, then inner attributes. This does not support\n         /// out-of-line modules, which may have attributes spread across 2 files!\n-        invoc_attr_index: u32,\n+        invoc_attr_index: AttrId,\n         /// Whether this attribute is the `#[derive]` attribute.\n         is_derive: bool,\n     },\n@@ -262,10 +263,11 @@ impl HirFileId {\n         });\n         let attr_input_or_mac_def = def.or_else(|| match loc.kind {\n             MacroCallKind::Attr { ast_id, invoc_attr_index, .. } => {\n+                // FIXME: handle `cfg_attr`\n                 let tt = ast_id\n                     .to_node(db)\n                     .doc_comments_and_attrs()\n-                    .nth(invoc_attr_index as usize)\n+                    .nth(invoc_attr_index.ast_index())\n                     .and_then(Either::left)?\n                     .token_tree()?;\n                 Some(InFile::new(ast_id.file_id, tt))\n@@ -398,8 +400,7 @@ impl MacroDefId {\n     }\n }\n \n-// FIXME: attribute indices do not account for `cfg_attr`, which means that we'll strip the whole\n-// `cfg_attr` instead of just one of the attributes it expands to\n+// FIXME: attribute indices do not account for nested `cfg_attr`\n \n impl MacroCallKind {\n     /// Returns the file containing the macro invocation.\n@@ -420,7 +421,7 @@ impl MacroCallKind {\n                 // FIXME: handle `cfg_attr`\n                 ast_id.with_value(ast_id.to_node(db)).map(|it| {\n                     it.doc_comments_and_attrs()\n-                        .nth(*derive_attr_index as usize)\n+                        .nth(derive_attr_index.ast_index())\n                         .and_then(|it| match it {\n                             Either::Left(attr) => Some(attr.syntax().clone()),\n                             Either::Right(_) => None,\n@@ -432,7 +433,7 @@ impl MacroCallKind {\n                 // FIXME: handle `cfg_attr`\n                 ast_id.with_value(ast_id.to_node(db)).map(|it| {\n                     it.doc_comments_and_attrs()\n-                        .nth(*invoc_attr_index as usize)\n+                        .nth(invoc_attr_index.ast_index())\n                         .and_then(|it| match it {\n                             Either::Left(attr) => Some(attr.syntax().clone()),\n                             Either::Right(_) => None,\n@@ -489,19 +490,21 @@ impl MacroCallKind {\n             MacroCallKind::FnLike { ast_id, .. } => ast_id.to_node(db).syntax().text_range(),\n             MacroCallKind::Derive { ast_id, derive_attr_index, .. } => {\n                 // FIXME: should be the range of the macro name, not the whole derive\n+                // FIXME: handle `cfg_attr`\n                 ast_id\n                     .to_node(db)\n                     .doc_comments_and_attrs()\n-                    .nth(derive_attr_index as usize)\n+                    .nth(derive_attr_index.ast_index())\n                     .expect(\"missing derive\")\n                     .expect_left(\"derive is a doc comment?\")\n                     .syntax()\n                     .text_range()\n             }\n+            // FIXME: handle `cfg_attr`\n             MacroCallKind::Attr { ast_id, invoc_attr_index, .. } => ast_id\n                 .to_node(db)\n                 .doc_comments_and_attrs()\n-                .nth(invoc_attr_index as usize)\n+                .nth(invoc_attr_index.ast_index())\n                 .expect(\"missing attribute\")\n                 .expect_left(\"attribute macro is a doc comment?\")\n                 .syntax()\n@@ -593,9 +596,10 @@ impl ExpansionInfo {\n             let token_range = token.value.text_range();\n             match &loc.kind {\n                 MacroCallKind::Attr { attr_args, invoc_attr_index, is_derive, .. } => {\n+                    // FIXME: handle `cfg_attr`\n                     let attr = item\n                         .doc_comments_and_attrs()\n-                        .nth(*invoc_attr_index as usize)\n+                        .nth(invoc_attr_index.ast_index())\n                         .and_then(Either::left)?;\n                     match attr.token_tree() {\n                         Some(token_tree)"}, {"sha": "ec66660f34a539dfdc12c9489002a60ce42a794c", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/621e96bd6ad0cf35c4dc4d1cfd8f6bc83096946f/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/621e96bd6ad0cf35c4dc4d1cfd8f6bc83096946f/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=621e96bd6ad0cf35c4dc4d1cfd8f6bc83096946f", "patch": "@@ -785,7 +785,7 @@ fn precise_macro_call_location(\n             let token = (|| {\n                 let derive_attr = node\n                     .doc_comments_and_attrs()\n-                    .nth(*derive_attr_index as usize)\n+                    .nth(derive_attr_index.ast_index())\n                     .and_then(Either::left)?;\n                 let token_tree = derive_attr.meta()?.token_tree()?;\n                 let group_by = token_tree\n@@ -813,9 +813,11 @@ fn precise_macro_call_location(\n             let node = ast_id.to_node(db.upcast());\n             let attr = node\n                 .doc_comments_and_attrs()\n-                .nth((*invoc_attr_index) as usize)\n+                .nth(invoc_attr_index.ast_index())\n                 .and_then(Either::left)\n-                .unwrap_or_else(|| panic!(\"cannot find attribute #{invoc_attr_index}\"));\n+                .unwrap_or_else(|| {\n+                    panic!(\"cannot find attribute #{}\", invoc_attr_index.ast_index())\n+                });\n \n             (\n                 ast_id.with_value(SyntaxNodePtr::from(AstPtr::new(&attr))),"}, {"sha": "78007fc860ff446c15671c8d00f0e982760d76da", "filename": "crates/intern/Cargo.toml", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/621e96bd6ad0cf35c4dc4d1cfd8f6bc83096946f/crates%2Fintern%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/621e96bd6ad0cf35c4dc4d1cfd8f6bc83096946f/crates%2Fintern%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fintern%2FCargo.toml?ref=621e96bd6ad0cf35c4dc4d1cfd8f6bc83096946f", "patch": "@@ -1,9 +1,14 @@\n [package]\n name = \"intern\"\n version = \"0.0.0\"\n+description = \"TBD\"\n+license = \"MIT OR Apache-2.0\"\n edition = \"2021\"\n+rust-version = \"1.65\"\n+\n+[lib]\n+doctest = false\n \n-# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n \n [dependencies]\n # We need to freeze the version of the crate, as the raw-api feature is considered unstable"}]}