{"sha": "49d36d733dc3906120cc0ecb268b839fb05e170d", "node_id": "C_kwDOAAsO6NoAKDQ5ZDM2ZDczM2RjMzkwNjEyMGNjMGVjYjI2OGI4MzlmYjA1ZTE3MGQ", "commit": {"author": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2022-01-18T03:51:04Z"}, "committer": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2022-01-18T03:51:04Z"}, "message": "Improve documentation of splatted constants", "tree": {"sha": "2d9abe6d4c13b080a19f32ac43176a71d13d820a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d9abe6d4c13b080a19f32ac43176a71d13d820a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/49d36d733dc3906120cc0ecb268b839fb05e170d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/49d36d733dc3906120cc0ecb268b839fb05e170d", "html_url": "https://github.com/rust-lang/rust/commit/49d36d733dc3906120cc0ecb268b839fb05e170d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/49d36d733dc3906120cc0ecb268b839fb05e170d/comments", "author": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "committer": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d5bf6bc28ccb3e5988a160bcbda66b6b6c8fe7d", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d5bf6bc28ccb3e5988a160bcbda66b6b6c8fe7d", "html_url": "https://github.com/rust-lang/rust/commit/1d5bf6bc28ccb3e5988a160bcbda66b6b6c8fe7d"}], "stats": {"total": 54, "additions": 28, "deletions": 26}, "files": [{"sha": "5a06fb4610587963b923e46be227a4e85fc61499", "filename": "compiler/rustc_codegen_ssa/src/traits/builder.rs", "status": "modified", "additions": 28, "deletions": 26, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/49d36d733dc3906120cc0ecb268b839fb05e170d/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49d36d733dc3906120cc0ecb268b839fb05e170d/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs?ref=49d36d733dc3906120cc0ecb268b839fb05e170d", "patch": "@@ -279,32 +279,6 @@ pub trait BuilderMethods<'a, 'tcx>:\n             assert!(rounded_max.value.is_finite());\n             (rounded_min.value.to_bits(), rounded_max.value.to_bits())\n         };\n-\n-        let maybe_splat = |bx: &mut Self, val| {\n-            if bx.cx().type_kind(dest_ty) == TypeKind::Vector {\n-                bx.vector_splat(bx.vector_length(dest_ty), val)\n-            } else {\n-                val\n-            }\n-        };\n-\n-        let float_bits_to_llval = |bx: &mut Self, bits| {\n-            let bits_llval = match float_width {\n-                32 => bx.cx().const_u32(bits as u32),\n-                64 => bx.cx().const_u64(bits as u64),\n-                n => bug!(\"unsupported float width {}\", n),\n-            };\n-            bx.bitcast(bits_llval, float_ty)\n-        };\n-        let (f_min, f_max) = match float_width {\n-            32 => compute_clamp_bounds_single(signed, int_width),\n-            64 => compute_clamp_bounds_double(signed, int_width),\n-            n => bug!(\"unsupported float width {}\", n),\n-        };\n-        let f_min = float_bits_to_llval(self, f_min);\n-        let f_max = float_bits_to_llval(self, f_max);\n-        let f_min = maybe_splat(self, f_min);\n-        let f_max = maybe_splat(self, f_max);\n         // To implement saturation, we perform the following steps:\n         //\n         // 1. Cast x to an integer with fpto[su]i. This may result in undef.\n@@ -332,9 +306,37 @@ pub trait BuilderMethods<'a, 'tcx>:\n         //     int_ty::MIN and therefore the return value of int_ty::MIN is correct.\n         // QED.\n \n+        let float_bits_to_llval = |bx: &mut Self, bits| {\n+            let bits_llval = match float_width {\n+                32 => bx.cx().const_u32(bits as u32),\n+                64 => bx.cx().const_u64(bits as u64),\n+                n => bug!(\"unsupported float width {}\", n),\n+            };\n+            bx.bitcast(bits_llval, float_ty)\n+        };\n+        let (f_min, f_max) = match float_width {\n+            32 => compute_clamp_bounds_single(signed, int_width),\n+            64 => compute_clamp_bounds_double(signed, int_width),\n+            n => bug!(\"unsupported float width {}\", n),\n+        };\n+        let f_min = float_bits_to_llval(self, f_min);\n+        let f_max = float_bits_to_llval(self, f_max);\n         let int_max = self.cx().const_uint_big(int_ty, int_max(signed, int_width));\n         let int_min = self.cx().const_uint_big(int_ty, int_min(signed, int_width) as u128);\n         let zero = self.cx().const_uint(int_ty, 0);\n+\n+        // If we're working with vectors, constants must be \"splatted\": the constant is duplicated\n+        // into each lane of the vector.  The algorithm stays the same, we are just using the\n+        // same constant across all lanes.\n+        let maybe_splat = |bx: &mut Self, val| {\n+            if bx.cx().type_kind(dest_ty) == TypeKind::Vector {\n+                bx.vector_splat(bx.vector_length(dest_ty), val)\n+            } else {\n+                val\n+            }\n+        };\n+        let f_min = maybe_splat(self, f_min);\n+        let f_max = maybe_splat(self, f_max);\n         let int_max = maybe_splat(self, int_max);\n         let int_min = maybe_splat(self, int_min);\n         let zero = maybe_splat(self, zero);"}]}