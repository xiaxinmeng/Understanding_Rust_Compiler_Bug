{"sha": "d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0", "node_id": "C_kwDOAAsO6NoAKGQwZGM5ZWZmZjE0YWMwYTFlZWNlZmZkMWU2MDVlMzdlZWI4MzYyYTA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-18T18:44:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-18T18:44:37Z"}, "message": "Auto merge of #105876 - matthiaskrgr:rollup-a9dgzjt, r=matthiaskrgr\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #96584 (Fix `x setup -h -v` should work)\n - #105420 (Remove dead code after destination propagation)\n - #105844 (Make the x tool use the x and x.ps1 scripts)\n - #105854 (remove redundant clone)\n - #105858 (Another `as_chunks` example)\n - #105870 (avoid .into() conversion to identical types)\n - #105875 (don't destuct references just to reborrow)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "a8a822106633ae58a80f28af77cc817111af9d36", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a8a822106633ae58a80f28af77cc817111af9d36"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0", "html_url": "https://github.com/rust-lang/rust/commit/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "37efc8107293edb5970551920ba1128240b87c68", "url": "https://api.github.com/repos/rust-lang/rust/commits/37efc8107293edb5970551920ba1128240b87c68", "html_url": "https://github.com/rust-lang/rust/commit/37efc8107293edb5970551920ba1128240b87c68"}, {"sha": "22379779b5842c4347b966e783a09e238f32369e", "url": "https://api.github.com/repos/rust-lang/rust/commits/22379779b5842c4347b966e783a09e238f32369e", "html_url": "https://github.com/rust-lang/rust/commit/22379779b5842c4347b966e783a09e238f32369e"}], "stats": {"total": 418, "additions": 287, "deletions": 131}, "files": [{"sha": "f8761653bf5b7d80dde81339468a465eb1f0cfb3", "filename": "compiler/rustc_builtin_macros/src/global_allocator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_allocator.rs?ref=d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0", "patch": "@@ -35,7 +35,7 @@ pub fn expand(\n             (item, true, ecx.with_def_site_ctxt(ty.span))\n         } else {\n             ecx.sess.parse_sess.span_diagnostic.span_err(item.span(), \"allocators must be statics\");\n-            return vec![orig_item.clone()]\n+            return vec![orig_item];\n         };\n \n     // Generate a bunch of new items using the AllocFnFactory"}, {"sha": "729ae4071e2008b53e1e7276484ab8fb4e021ceb", "filename": "compiler/rustc_builtin_macros/src/test.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs?ref=d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0", "patch": "@@ -239,8 +239,7 @@ pub fn expand_test_or_bench(\n             cx.attr_nested_word(sym::cfg, sym::test, attr_sp),\n             // #[rustc_test_marker = \"test_case_sort_key\"]\n             cx.attr_name_value_str(sym::rustc_test_marker, test_path_symbol, attr_sp),\n-        ]\n-        .into(),\n+        ],\n         // const $ident: test::TestDescAndFn =\n         ast::ItemKind::Const(\n             ast::Defaultness::Final,"}, {"sha": "6c0faf37a63ce453b906185924ccb6d420dffb09", "filename": "compiler/rustc_codegen_llvm/src/back/lto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs?ref=d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0", "patch": "@@ -425,7 +425,7 @@ fn thin_lto(\n         info!(\"going for that thin, thin LTO\");\n \n         let green_modules: FxHashMap<_, _> =\n-            cached_modules.iter().map(|&(_, ref wp)| (wp.cgu_name.clone(), wp.clone())).collect();\n+            cached_modules.iter().map(|(_, wp)| (wp.cgu_name.clone(), wp.clone())).collect();\n \n         let full_scope_len = modules.len() + serialized_modules.len() + cached_modules.len();\n         let mut thin_buffers = Vec::with_capacity(modules.len());"}, {"sha": "a1c77ec0cfca7b7f24a90324cf10bb666b0f0a17", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0", "patch": "@@ -722,7 +722,7 @@ fn link_natively<'a>(\n \n     linker::disable_localization(&mut cmd);\n \n-    for &(ref k, ref v) in sess.target.link_env.as_ref() {\n+    for (k, v) in sess.target.link_env.as_ref() {\n         cmd.env(k.as_ref(), v.as_ref());\n     }\n     for k in sess.target.link_env_remove.as_ref() {"}, {"sha": "0268659d3b9a13d8515eace64f9d4d2851945bec", "filename": "compiler/rustc_codegen_ssa/src/back/linker.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs?ref=d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0", "patch": "@@ -108,7 +108,7 @@ pub fn get_linker<'a>(\n     if sess.target.is_like_msvc {\n         if let Some(ref tool) = msvc_tool {\n             cmd.args(tool.args());\n-            for &(ref k, ref v) in tool.env() {\n+            for (k, v) in tool.env() {\n                 if k == \"PATH\" {\n                     new_path.extend(env::split_paths(v));\n                     msvc_changed_path = true;"}, {"sha": "986b6d655300168046dad275e318667b1adff014", "filename": "compiler/rustc_const_eval/src/interpret/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs?ref=d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0", "patch": "@@ -332,7 +332,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     Immediate::new_slice(ptr, length.eval_usize(*self.tcx, self.param_env), self);\n                 self.write_immediate(val, dest)\n             }\n-            (&ty::Dynamic(ref data_a, ..), &ty::Dynamic(ref data_b, ..)) => {\n+            (ty::Dynamic(data_a, ..), ty::Dynamic(data_b, ..)) => {\n                 let val = self.read_immediate(src)?;\n                 if data_a.principal() == data_b.principal() {\n                     // A NOP cast that doesn't actually change anything, should be allowed even with mismatching vtables."}, {"sha": "f9e3a2bdc06fe528dcb3bcfa7ef980a2cf3a2d41", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0", "patch": "@@ -39,7 +39,7 @@ pub enum Immediate<Prov: Provenance = AllocId> {\n impl<Prov: Provenance> From<Scalar<Prov>> for Immediate<Prov> {\n     #[inline(always)]\n     fn from(val: Scalar<Prov>) -> Self {\n-        Immediate::Scalar(val.into())\n+        Immediate::Scalar(val)\n     }\n }\n \n@@ -53,15 +53,15 @@ impl<Prov: Provenance> Immediate<Prov> {\n     }\n \n     pub fn new_slice(val: Scalar<Prov>, len: u64, cx: &impl HasDataLayout) -> Self {\n-        Immediate::ScalarPair(val.into(), Scalar::from_machine_usize(len, cx).into())\n+        Immediate::ScalarPair(val, Scalar::from_machine_usize(len, cx))\n     }\n \n     pub fn new_dyn_trait(\n         val: Scalar<Prov>,\n         vtable: Pointer<Option<Prov>>,\n         cx: &impl HasDataLayout,\n     ) -> Self {\n-        Immediate::ScalarPair(val.into(), Scalar::from_maybe_pointer(vtable, cx))\n+        Immediate::ScalarPair(val, Scalar::from_maybe_pointer(vtable, cx))\n     }\n \n     #[inline]\n@@ -341,10 +341,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     alloc_range(b_offset, b_size),\n                     /*read_provenance*/ b.is_ptr(),\n                 )?;\n-                Some(ImmTy {\n-                    imm: Immediate::ScalarPair(a_val.into(), b_val.into()),\n-                    layout: mplace.layout,\n-                })\n+                Some(ImmTy { imm: Immediate::ScalarPair(a_val, b_val), layout: mplace.layout })\n             }\n             _ => {\n                 // Neither a scalar nor scalar pair."}, {"sha": "e8ff70e3a4095075ebe765e16a18549decfd866d", "filename": "compiler/rustc_const_eval/src/interpret/operator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperator.rs?ref=d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0", "patch": "@@ -36,7 +36,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         if let Abi::ScalarPair(..) = dest.layout.abi {\n             // We can use the optimized path and avoid `place_field` (which might do\n             // `force_allocation`).\n-            let pair = Immediate::ScalarPair(val.into(), Scalar::from_bool(overflowed).into());\n+            let pair = Immediate::ScalarPair(val, Scalar::from_bool(overflowed));\n             self.write_immediate(pair, dest)?;\n         } else {\n             assert!(self.tcx.sess.opts.unstable_opts.randomize_layout);"}, {"sha": "97a73e98abcbca9d563027620fc8a74630014606", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0", "patch": "@@ -141,7 +141,7 @@ impl<Prov: Provenance> MemPlace<Prov> {\n         match self.meta {\n             MemPlaceMeta::None => Immediate::from(Scalar::from_maybe_pointer(self.ptr, cx)),\n             MemPlaceMeta::Meta(meta) => {\n-                Immediate::ScalarPair(Scalar::from_maybe_pointer(self.ptr, cx).into(), meta.into())\n+                Immediate::ScalarPair(Scalar::from_maybe_pointer(self.ptr, cx), meta)\n             }\n         }\n     }"}, {"sha": "0b8847f827df1aa6ad9b8a056ccadba7d03ed9aa", "filename": "compiler/rustc_expand/src/mbe/macro_check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs?ref=d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0", "patch": "@@ -468,7 +468,7 @@ fn check_nested_occurrences(\n                 // We check that the meta-variable is correctly used.\n                 check_occurrences(sess, node_id, tt, macros, binders, ops, valid);\n             }\n-            (NestedMacroState::MacroName, &TokenTree::Delimited(_, ref del))\n+            (NestedMacroState::MacroName, TokenTree::Delimited(_, del))\n                 if del.delim == Delimiter::Parenthesis =>\n             {\n                 state = NestedMacroState::MacroNameParen;\n@@ -483,7 +483,7 @@ fn check_nested_occurrences(\n                     valid,\n                 );\n             }\n-            (NestedMacroState::MacroNameParen, &TokenTree::Delimited(_, ref del))\n+            (NestedMacroState::MacroNameParen, TokenTree::Delimited(_, del))\n                 if del.delim == Delimiter::Brace =>\n             {\n                 state = NestedMacroState::Empty;"}, {"sha": "320c533a66e5d0bfc1b47367765394d928277d10", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0", "patch": "@@ -792,7 +792,7 @@ impl<'tt> FirstSets<'tt> {\n                 TokenTree::Sequence(sp, ref seq_rep) => {\n                     let subfirst_owned;\n                     let subfirst = match self.first.get(&sp.entire()) {\n-                        Some(&Some(ref subfirst)) => subfirst,\n+                        Some(Some(subfirst)) => subfirst,\n                         Some(&None) => {\n                             subfirst_owned = self.first(&seq_rep.tts);\n                             &subfirst_owned"}, {"sha": "87abd01c7fd8fb90679ad147f38cea605db1b80c", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0", "patch": "@@ -1275,7 +1275,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             };\n \n         match (&expected_ty.kind(), &checked_ty.kind()) {\n-            (&ty::Int(ref exp), &ty::Int(ref found)) => {\n+            (ty::Int(exp), ty::Int(found)) => {\n                 let (f2e_is_fallible, e2f_is_fallible) = match (exp.bit_width(), found.bit_width())\n                 {\n                     (Some(exp), Some(found)) if exp < found => (true, false),\n@@ -1288,7 +1288,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 suggest_to_change_suffix_or_into(err, f2e_is_fallible, e2f_is_fallible);\n                 true\n             }\n-            (&ty::Uint(ref exp), &ty::Uint(ref found)) => {\n+            (ty::Uint(exp), ty::Uint(found)) => {\n                 let (f2e_is_fallible, e2f_is_fallible) = match (exp.bit_width(), found.bit_width())\n                 {\n                     (Some(exp), Some(found)) if exp < found => (true, false),\n@@ -1321,7 +1321,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 suggest_to_change_suffix_or_into(err, f2e_is_fallible, e2f_is_fallible);\n                 true\n             }\n-            (&ty::Float(ref exp), &ty::Float(ref found)) => {\n+            (ty::Float(exp), ty::Float(found)) => {\n                 if found.bit_width() < exp.bit_width() {\n                     suggest_to_change_suffix_or_into(err, false, true);\n                 } else if literal_is_ty_suffixed(expr) {\n@@ -1357,7 +1357,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n                 true\n             }\n-            (&ty::Float(ref exp), &ty::Uint(ref found)) => {\n+            (ty::Float(exp), ty::Uint(found)) => {\n                 // if `found` is `None` (meaning found is `usize`), don't suggest `.into()`\n                 if exp.bit_width() > found.bit_width().unwrap_or(256) {\n                     err.multipart_suggestion_verbose(\n@@ -1386,7 +1386,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n                 true\n             }\n-            (&ty::Float(ref exp), &ty::Int(ref found)) => {\n+            (ty::Float(exp), ty::Int(found)) => {\n                 // if `found` is `None` (meaning found is `isize`), don't suggest `.into()`\n                 if exp.bit_width() > found.bit_width().unwrap_or(256) {\n                     err.multipart_suggestion_verbose("}, {"sha": "edbbb7272ac77d899b02d2aa3116a2decf497c04", "filename": "compiler/rustc_hir_typeck/src/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs?ref=d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0", "patch": "@@ -1874,7 +1874,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // I don't use 'is_range_literal' because only double-sided, half-open ranges count.\n         if let ExprKind::Struct(\n                 QPath::LangItem(LangItem::Range, ..),\n-                &[ref range_start, ref range_end],\n+                [range_start, range_end],\n                 _,\n             ) = last_expr_field.expr.kind\n             && let variant_field ="}, {"sha": "ca4c50c49aae253dc973cb4b9c8730bc108b7003", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/suggestions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs?ref=d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0", "patch": "@@ -754,7 +754,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     return true\n                 }\n             }\n-            &hir::FnRetTy::Return(ref ty) => {\n+            hir::FnRetTy::Return(ty) => {\n                 // Only point to return type if the expected type is the return type, as if they\n                 // are not, the expectation must have been caused by something else.\n                 debug!(\"suggest_missing_return_type: return type {:?} node {:?}\", ty, ty.kind);"}, {"sha": "b4bf9f4bcc767a3688f7a9b2965cf399c46d718e", "filename": "compiler/rustc_incremental/src/assert_dep_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs?ref=d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0", "patch": "@@ -249,7 +249,7 @@ fn dump_graph(query: &DepGraphQuery) {\n         // dump a .txt file with just the edges:\n         let txt_path = format!(\"{}.txt\", path);\n         let mut file = BufWriter::new(File::create(&txt_path).unwrap());\n-        for &(ref source, ref target) in &edges {\n+        for (source, target) in &edges {\n             write!(file, \"{:?} -> {:?}\\n\", source, target).unwrap();\n         }\n     }"}, {"sha": "268b3bf1dcd4b23c01fe1d69f15e3d1b528a3133", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0", "patch": "@@ -1920,7 +1920,7 @@ impl<'tcx> TypeTrace<'tcx> {\n     ) -> TypeTrace<'tcx> {\n         TypeTrace {\n             cause: cause.clone(),\n-            values: PolyTraitRefs(ExpectedFound::new(a_is_expected, a.into(), b.into())),\n+            values: PolyTraitRefs(ExpectedFound::new(a_is_expected, a, b)),\n         }\n     }\n "}, {"sha": "ac455055b430375ce8aa245d092498ed9a67e199", "filename": "compiler/rustc_infer/src/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fproject.rs?ref=d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0", "patch": "@@ -200,7 +200,7 @@ impl<'tcx> ProjectionCache<'_, 'tcx> {\n     pub fn complete(&mut self, key: ProjectionCacheKey<'tcx>, result: EvaluationResult) {\n         let mut map = self.map();\n         match map.get(&key) {\n-            Some(&ProjectionCacheEntry::NormalizedTy { ref ty, complete: _ }) => {\n+            Some(ProjectionCacheEntry::NormalizedTy { ty, complete: _ }) => {\n                 info!(\"ProjectionCacheEntry::complete({:?}) - completing {:?}\", key, ty);\n                 let mut ty = ty.clone();\n                 if result.must_apply_considering_regions() {"}, {"sha": "0417f375588cc8a0500e17307b1878efa69ff603", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0", "patch": "@@ -438,18 +438,18 @@ impl LintStore {\n                         return CheckLintNameResult::Tool(Ok(&lint_ids));\n                     }\n                 },\n-                Some(&Id(ref id)) => return CheckLintNameResult::Tool(Ok(slice::from_ref(id))),\n+                Some(Id(id)) => return CheckLintNameResult::Tool(Ok(slice::from_ref(id))),\n                 // If the lint was registered as removed or renamed by the lint tool, we don't need\n                 // to treat tool_lints and rustc lints different and can use the code below.\n                 _ => {}\n             }\n         }\n         match self.by_name.get(&complete_name) {\n-            Some(&Renamed(ref new_name, _)) => CheckLintNameResult::Warning(\n+            Some(Renamed(new_name, _)) => CheckLintNameResult::Warning(\n                 format!(\"lint `{}` has been renamed to `{}`\", complete_name, new_name),\n                 Some(new_name.to_owned()),\n             ),\n-            Some(&Removed(ref reason)) => CheckLintNameResult::Warning(\n+            Some(Removed(reason)) => CheckLintNameResult::Warning(\n                 format!(\"lint `{}` has been removed: {}\", complete_name, reason),\n                 None,\n             ),\n@@ -470,7 +470,7 @@ impl LintStore {\n                     CheckLintNameResult::Ok(&lint_ids)\n                 }\n             },\n-            Some(&Id(ref id)) => CheckLintNameResult::Ok(slice::from_ref(id)),\n+            Some(Id(id)) => CheckLintNameResult::Ok(slice::from_ref(id)),\n             Some(&Ignored) => CheckLintNameResult::Ok(&[]),\n         }\n     }\n@@ -513,7 +513,7 @@ impl LintStore {\n                     CheckLintNameResult::Tool(Err((Some(&lint_ids), complete_name)))\n                 }\n             },\n-            Some(&Id(ref id)) => {\n+            Some(Id(id)) => {\n                 CheckLintNameResult::Tool(Err((Some(slice::from_ref(id)), complete_name)))\n             }\n             Some(other) => {"}, {"sha": "3b8df61a0eab771a704f9ed9006bbd1807b612fa", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0", "patch": "@@ -1279,7 +1279,7 @@ impl UnusedImportBraces {\n     fn check_use_tree(&self, cx: &EarlyContext<'_>, use_tree: &ast::UseTree, item: &ast::Item) {\n         if let ast::UseTreeKind::Nested(ref items) = use_tree.kind {\n             // Recursively check nested UseTrees\n-            for &(ref tree, _) in items {\n+            for (tree, _) in items {\n                 self.check_use_tree(cx, tree, item);\n             }\n "}, {"sha": "96f15a6f758f2aa9b09fa8a24278429c89a6e1a1", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0", "patch": "@@ -1849,7 +1849,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         // the assumption that they are numbered 1 to n.\n         // FIXME (#2166): This is not nearly enough to support correct versioning\n         // but is enough to get transitive crate dependencies working.\n-        self.lazy_array(deps.iter().map(|&(_, ref dep)| dep))\n+        self.lazy_array(deps.iter().map(|(_, dep)| dep))\n     }\n \n     fn encode_lib_features(&mut self) -> LazyArray<(Symbol, Option<Symbol>)> {\n@@ -1986,7 +1986,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         self.lazy_array(\n             exported_symbols\n                 .iter()\n-                .filter(|&&(ref exported_symbol, _)| match *exported_symbol {\n+                .filter(|&(exported_symbol, _)| match *exported_symbol {\n                     ExportedSymbol::NoDefId(symbol_name) => symbol_name != metadata_symbol_name,\n                     _ => true,\n                 })"}, {"sha": "1e289fc4abec3d4817d49f5521690e0792b193be", "filename": "compiler/rustc_middle/src/mir/tcx.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs?ref=d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0", "patch": "@@ -235,7 +235,7 @@ impl<'tcx> Operand<'tcx> {\n     {\n         match self {\n             &Operand::Copy(ref l) | &Operand::Move(ref l) => l.ty(local_decls, tcx).ty,\n-            &Operand::Constant(ref c) => c.literal.ty(),\n+            Operand::Constant(c) => c.literal.ty(),\n         }\n     }\n }"}, {"sha": "042b89bc4b01f6b4a5271e9ec4dc5d51611fabcd", "filename": "compiler/rustc_middle/src/ty/flags.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs?ref=d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0", "patch": "@@ -95,7 +95,7 @@ impl FlagComputation {\n                 self.add_flags(TypeFlags::STILL_FURTHER_SPECIALIZABLE);\n             }\n \n-            &ty::Generator(_, ref substs, _) => {\n+            ty::Generator(_, substs, _) => {\n                 let substs = substs.as_generator();\n                 let should_remove_further_specializable =\n                     !self.flags.contains(TypeFlags::STILL_FURTHER_SPECIALIZABLE);\n@@ -186,7 +186,7 @@ impl FlagComputation {\n \n             &ty::Slice(tt) => self.add_ty(tt),\n \n-            &ty::RawPtr(ref m) => {\n+            ty::RawPtr(m) => {\n                 self.add_ty(m.ty);\n             }\n "}, {"sha": "4d34ca3d66b5fd20b86a7b9fbbec7b0e51f60bdd", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0", "patch": "@@ -428,7 +428,7 @@ pub fn super_relate_tys<'tcx, R: TypeRelation<'tcx>>(\n             Ok(a)\n         }\n \n-        (&ty::Param(ref a_p), &ty::Param(ref b_p)) if a_p.index == b_p.index => Ok(a),\n+        (ty::Param(a_p), ty::Param(b_p)) if a_p.index == b_p.index => Ok(a),\n \n         (ty::Placeholder(p1), ty::Placeholder(p2)) if p1 == p2 => Ok(a),\n "}, {"sha": "f77bd9f0c6ffc320d6222f03130feff9550ab844", "filename": "compiler/rustc_middle/src/ty/vtable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvtable.rs?ref=d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0", "patch": "@@ -88,8 +88,8 @@ pub(super) fn vtable_allocation_provider<'tcx>(\n                 let fn_ptr = Pointer::from(fn_alloc_id);\n                 Scalar::from_pointer(fn_ptr, &tcx)\n             }\n-            VtblEntry::MetadataSize => Scalar::from_uint(size, ptr_size).into(),\n-            VtblEntry::MetadataAlign => Scalar::from_uint(align, ptr_size).into(),\n+            VtblEntry::MetadataSize => Scalar::from_uint(size, ptr_size),\n+            VtblEntry::MetadataAlign => Scalar::from_uint(align, ptr_size),\n             VtblEntry::Vacant => continue,\n             VtblEntry::Method(instance) => {\n                 // Prepare the fn ptr we write into the vtable."}, {"sha": "23a4f85386b8d5f29d2c46d8f3b5f70f7e38b583", "filename": "compiler/rustc_mir_build/src/build/expr/as_place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs?ref=d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0", "patch": "@@ -356,7 +356,7 @@ impl<'tcx> PlaceBuilder<'tcx> {\n         match self {\n             PlaceBuilder::Local { local, projection } => PlaceBuilder::Local {\n                 local: *local,\n-                projection: Vec::from_iter(projection.iter().copied().chain([elem.into()])),\n+                projection: Vec::from_iter(projection.iter().copied().chain([elem])),\n             },\n             PlaceBuilder::Upvar { upvar, projection } => PlaceBuilder::Upvar {\n                 upvar: *upvar,"}, {"sha": "6c10704c5db51a64d7b73c93a2fcb1e2ca731b52", "filename": "compiler/rustc_mir_build/src/build/matches/test.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs?ref=d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0", "patch": "@@ -551,16 +551,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             //\n             // FIXME(#29623) we could use PatKind::Range to rule\n             // things out here, in some cases.\n-            (\n-                &TestKind::SwitchInt { switch_ty: _, ref options },\n-                &PatKind::Constant { ref value },\n-            ) if is_switch_ty(match_pair.pattern.ty) => {\n+            (TestKind::SwitchInt { switch_ty: _, options }, PatKind::Constant { value })\n+                if is_switch_ty(match_pair.pattern.ty) =>\n+            {\n                 let index = options.get_index_of(value).unwrap();\n                 self.candidate_without_match_pair(match_pair_index, candidate);\n                 Some(index)\n             }\n \n-            (&TestKind::SwitchInt { switch_ty: _, ref options }, &PatKind::Range(ref range)) => {\n+            (TestKind::SwitchInt { switch_ty: _, options }, PatKind::Range(range)) => {\n                 let not_contained =\n                     self.values_not_contained_in_range(&*range, options).unwrap_or(false);\n \n@@ -578,7 +577,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n             (\n                 &TestKind::Len { len: test_len, op: BinOp::Eq },\n-                &PatKind::Slice { ref prefix, ref slice, ref suffix },\n+                PatKind::Slice { prefix, slice, suffix },\n             ) => {\n                 let pat_len = (prefix.len() + suffix.len()) as u64;\n                 match (test_len.cmp(&pat_len), slice) {\n@@ -615,7 +614,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n             (\n                 &TestKind::Len { len: test_len, op: BinOp::Ge },\n-                &PatKind::Slice { ref prefix, ref slice, ref suffix },\n+                PatKind::Slice { prefix, slice, suffix },\n             ) => {\n                 // the test is `$actual_len >= test_len`\n                 let pat_len = (prefix.len() + suffix.len()) as u64;\n@@ -651,7 +650,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 }\n             }\n \n-            (&TestKind::Range(ref test), &PatKind::Range(ref pat)) => {\n+            (TestKind::Range(test), PatKind::Range(pat)) => {\n                 use std::cmp::Ordering::*;\n \n                 if test == pat {\n@@ -678,7 +677,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 no_overlap\n             }\n \n-            (&TestKind::Range(ref range), &PatKind::Constant { value }) => {\n+            (TestKind::Range(range), &PatKind::Constant { value }) => {\n                 if let Some(false) = self.const_range_contains(&*range, value) {\n                     // `value` is not contained in the testing range,\n                     // so `value` can be matched only if this test fails."}, {"sha": "e384cfe165990c47940bde2566b8da034d49fe33", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0", "patch": "@@ -701,8 +701,8 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                     BinOp::Mul if const_arg.layout.ty.is_integral() && arg_value == 0 => {\n                         if let Rvalue::CheckedBinaryOp(_, _) = rvalue {\n                             let val = Immediate::ScalarPair(\n-                                const_arg.to_scalar().into(),\n-                                Scalar::from_bool(false).into(),\n+                                const_arg.to_scalar(),\n+                                Scalar::from_bool(false),\n                             );\n                             this.ecx.write_immediate(val, &dest)\n                         } else {"}, {"sha": "74d8337653f034f968ea516556563ebd1dc068c1", "filename": "compiler/rustc_mir_transform/src/dest_prop.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_mir_transform%2Fsrc%2Fdest_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_mir_transform%2Fsrc%2Fdest_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdest_prop.rs?ref=d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0", "patch": "@@ -129,6 +129,7 @@\n \n use std::collections::hash_map::{Entry, OccupiedEntry};\n \n+use crate::simplify::remove_dead_blocks;\n use crate::MirPass;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_index::bit_set::BitSet;\n@@ -235,6 +236,12 @@ impl<'tcx> MirPass<'tcx> for DestinationPropagation {\n             apply_merges(body, tcx, &merges, &merged_locals);\n         }\n \n+        if round_count != 0 {\n+            // Merging can introduce overlap between moved arguments and/or call destination in an\n+            // unreachable code, which validator considers to be ill-formed.\n+            remove_dead_blocks(tcx, body);\n+        }\n+\n         trace!(round_count);\n     }\n }"}, {"sha": "40b88788caa6743c66a5e7f9c0e6dba47fd6cb9a", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0", "patch": "@@ -25,7 +25,7 @@ use rustc_ast::tokenstream::{TokenStream, TokenTree};\n use rustc_ast::util::case::Case;\n use rustc_ast::AttrId;\n use rustc_ast::DUMMY_NODE_ID;\n-use rustc_ast::{self as ast, AnonConst, AttrStyle, AttrVec, Const, DelimArgs, Extern};\n+use rustc_ast::{self as ast, AnonConst, AttrStyle, Const, DelimArgs, Extern};\n use rustc_ast::{Async, AttrArgs, AttrArgsEq, Expr, ExprKind, MacDelimiter, Mutability, StrLit};\n use rustc_ast::{HasAttrs, HasTokens, Unsafe, Visibility, VisibilityKind};\n use rustc_ast_pretty::pprust;\n@@ -1217,11 +1217,7 @@ impl<'a> Parser<'a> {\n             value: self.mk_expr(blk.span, ExprKind::Block(blk, None)),\n         };\n         let blk_span = anon_const.value.span;\n-        Ok(self.mk_expr_with_attrs(\n-            span.to(blk_span),\n-            ExprKind::ConstBlock(anon_const),\n-            AttrVec::from(attrs),\n-        ))\n+        Ok(self.mk_expr_with_attrs(span.to(blk_span), ExprKind::ConstBlock(anon_const), attrs))\n     }\n \n     /// Parses mutability (`mut` or nothing)."}, {"sha": "272386f313e8d0736aecdd274652c4374e1fca6e", "filename": "compiler/rustc_passes/src/hir_stats.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs?ref=d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0", "patch": "@@ -121,7 +121,7 @@ impl<'k> StatCollector<'k> {\n \n     fn print(&self, title: &str, prefix: &str) {\n         let mut nodes: Vec<_> = self.nodes.iter().collect();\n-        nodes.sort_by_key(|&(_, ref node)| node.stats.count * node.stats.size);\n+        nodes.sort_by_key(|(_, node)| node.stats.count * node.stats.size);\n \n         let total_size = nodes.iter().map(|(_, node)| node.stats.count * node.stats.size).sum();\n \n@@ -147,7 +147,7 @@ impl<'k> StatCollector<'k> {\n             );\n             if !node.subnodes.is_empty() {\n                 let mut subnodes: Vec<_> = node.subnodes.iter().collect();\n-                subnodes.sort_by_key(|&(_, ref subnode)| subnode.count * subnode.size);\n+                subnodes.sort_by_key(|(_, subnode)| subnode.count * subnode.size);\n \n                 for (label, subnode) in subnodes {\n                     let size = subnode.count * subnode.size;"}, {"sha": "9a40b847d8552ebd9800fa42f6a6791b17562f73", "filename": "compiler/rustc_passes/src/lang_items.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_passes%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_passes%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flang_items.rs?ref=d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0", "patch": "@@ -83,7 +83,6 @@ impl<'tcx> LanguageItemCollector<'tcx> {\n                         .map(|p| p.display().to_string())\n                         .collect::<Vec<_>>()\n                         .join(\", \")\n-                        .into()\n                 };\n                 let first_defined_span = self.tcx.hir().span_if_local(original_def_id);\n                 let mut orig_crate_name = Empty;\n@@ -98,7 +97,6 @@ impl<'tcx> LanguageItemCollector<'tcx> {\n                         .map(|p| p.display().to_string())\n                         .collect::<Vec<_>>()\n                         .join(\", \")\n-                        .into()\n                 };\n                 if first_defined_span.is_none() {\n                     orig_crate_name = self.tcx.crate_name(original_def_id.krate);"}, {"sha": "cf63599626866203f41feeaca0bf156bd9d0ce75", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0", "patch": "@@ -576,7 +576,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 // Ensure there is at most one `self` in the list\n                 let self_spans = items\n                     .iter()\n-                    .filter_map(|&(ref use_tree, _)| {\n+                    .filter_map(|(use_tree, _)| {\n                         if let ast::UseTreeKind::Simple(..) = use_tree.kind {\n                             if use_tree.ident().name == kw::SelfLower {\n                                 return Some(use_tree.span);"}, {"sha": "01a9b1000882bd5c77a20b64a697a57ea409d260", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0", "patch": "@@ -1323,7 +1323,7 @@ pub fn build_session(\n     let warnings_allow = sopts\n         .lint_opts\n         .iter()\n-        .rfind(|&&(ref key, _)| *key == \"warnings\")\n+        .rfind(|&(key, _)| *key == \"warnings\")\n         .map_or(false, |&(_, level)| level == lint::Allow);\n     let cap_lints_allow = sopts.lint_cap.map_or(false, |cap| cap == lint::Allow);\n     let can_emit_warnings = !(warnings_allow || cap_lints_allow);"}, {"sha": "b89f489a641ed175de351255e21fc1d1e1a8d8e9", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0", "patch": "@@ -226,7 +226,7 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n             let arg_length = arguments.len();\n             let distinct = matches!(other, &[ArgKind::Tuple(..)]);\n             match (arg_length, arguments.get(0)) {\n-                (1, Some(&ArgKind::Tuple(_, ref fields))) => {\n+                (1, Some(ArgKind::Tuple(_, fields))) => {\n                     format!(\"a single {}-tuple as argument\", fields.len())\n                 }\n                 _ => format!(\n@@ -1735,8 +1735,8 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 values.map(|(_, is_normalized_ty_expected, normalized_ty, expected_ty)| {\n                     infer::ValuePairs::Terms(ExpectedFound::new(\n                         is_normalized_ty_expected,\n-                        normalized_ty.into(),\n-                        expected_ty.into(),\n+                        normalized_ty,\n+                        expected_ty,\n                     ))\n                 }),\n                 err,"}, {"sha": "2c469f61854f3cb2acff0185738b73b8d7228bc6", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0", "patch": "@@ -1002,6 +1002,17 @@ impl<T> [T] {\n     /// assert_eq!(chunks, &[['l', 'o'], ['r', 'e']]);\n     /// assert_eq!(remainder, &['m']);\n     /// ```\n+    ///\n+    /// If you expect the slice to be an exact multiple, you can combine\n+    /// `let`-`else` with an empty slice pattern:\n+    /// ```\n+    /// #![feature(slice_as_chunks)]\n+    /// let slice = ['R', 'u', 's', 't'];\n+    /// let (chunks, []) = slice.as_chunks::<2>() else {\n+    ///     panic!(\"slice didn't have even length\")\n+    /// };\n+    /// assert_eq!(chunks, &[['R', 'u'], ['s', 't']]);\n+    /// ```\n     #[unstable(feature = \"slice_as_chunks\", issue = \"74985\")]\n     #[inline]\n     #[must_use]"}, {"sha": "1d37d68c1d4050d807d4e73fe68591d434e05158", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0", "patch": "@@ -19,6 +19,7 @@ use crate::flags::{Color, Subcommand};\n use crate::install;\n use crate::native;\n use crate::run;\n+use crate::setup;\n use crate::test;\n use crate::tool::{self, SourceType};\n use crate::util::{self, add_dylib_path, add_link_lib_path, exe, libdir, output, t};\n@@ -433,8 +434,11 @@ impl<'a> ShouldRun<'a> {\n \n     // single alias, which does not correspond to any on-disk path\n     pub fn alias(mut self, alias: &str) -> Self {\n+        // exceptional case for `Kind::Setup` because its `library`\n+        // and `compiler` options would otherwise naively match with\n+        // `compiler` and `library` folders respectively.\n         assert!(\n-            !self.builder.src.join(alias).exists(),\n+            self.kind == Kind::Setup || !self.builder.src.join(alias).exists(),\n             \"use `builder.path()` for real paths: {}\",\n             alias\n         );\n@@ -758,8 +762,9 @@ impl<'a> Builder<'a> {\n                 run::CollectLicenseMetadata,\n                 run::GenerateCopyright,\n             ),\n+            Kind::Setup => describe!(setup::Profile),\n             // These commands either don't use paths, or they're special-cased in Build::build()\n-            Kind::Clean | Kind::Format | Kind::Setup => vec![],\n+            Kind::Clean | Kind::Format => vec![],\n         }\n     }\n \n@@ -822,7 +827,11 @@ impl<'a> Builder<'a> {\n             Subcommand::Install { ref paths } => (Kind::Install, &paths[..]),\n             Subcommand::Run { ref paths, .. } => (Kind::Run, &paths[..]),\n             Subcommand::Format { .. } => (Kind::Format, &[][..]),\n-            Subcommand::Clean { .. } | Subcommand::Setup { .. } => {\n+            Subcommand::Setup { profile: ref path } => (\n+                Kind::Setup,\n+                path.as_ref().map_or([].as_slice(), |path| std::slice::from_ref(path)),\n+            ),\n+            Subcommand::Clean { .. } => {\n                 panic!()\n             }\n         };"}, {"sha": "851cb5ecf4c2694ee7c77b7b97e4bd92a1c7d6a4", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0", "patch": "@@ -143,7 +143,7 @@ pub enum Subcommand {\n         args: Vec<String>,\n     },\n     Setup {\n-        profile: Option<Profile>,\n+        profile: Option<PathBuf>,\n     },\n }\n \n@@ -351,7 +351,7 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\",\n \n         // fn usage()\n         let usage = |exit_code: i32, opts: &Options, verbose: bool, subcommand_help: &str| -> ! {\n-            let config = Config::parse(&[\"build\".to_string()]);\n+            let config = Config::parse(&[\"setup\".to_string()]);\n             let build = Build::new(config);\n             let paths = Builder::get_help(&build, subcommand);\n \n@@ -621,7 +621,7 @@ Arguments:\n             }\n             Kind::Setup => {\n                 let profile = if paths.len() > 1 {\n-                    println!(\"\\nat most one profile can be passed to setup\\n\");\n+                    eprintln!(\"\\nerror: At most one profile can be passed to setup\\n\");\n                     usage(1, &opts, verbose, &subcommand_help)\n                 } else if let Some(path) = paths.pop() {\n                     let profile_string = t!(path.into_os_string().into_string().map_err("}, {"sha": "47fb4a38d05be381e074f199401b03c7b1de9db4", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0", "patch": "@@ -730,10 +730,6 @@ impl Build {\n             return clean::clean(self, all);\n         }\n \n-        if let Subcommand::Setup { profile } = &self.config.cmd {\n-            return setup::setup(&self.config, *profile);\n-        }\n-\n         // Download rustfmt early so that it can be used in rust-analyzer configs.\n         let _ = &builder::Builder::new(&self).initial_rustfmt();\n "}, {"sha": "57426ce3d51094b259f863addc6a3509e098befb", "filename": "src/bootstrap/setup.rs", "status": "modified", "additions": 59, "deletions": 11, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/src%2Fbootstrap%2Fsetup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/src%2Fbootstrap%2Fsetup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsetup.rs?ref=d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0", "patch": "@@ -1,3 +1,4 @@\n+use crate::builder::{Builder, RunConfig, ShouldRun, Step};\n use crate::Config;\n use crate::{t, VERSION};\n use std::env::consts::EXE_SUFFIX;\n@@ -9,7 +10,7 @@ use std::process::Command;\n use std::str::FromStr;\n use std::{fmt, fs, io};\n \n-#[derive(Clone, Copy, Debug, Eq, PartialEq)]\n+#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]\n pub enum Profile {\n     Compiler,\n     Codegen,\n@@ -48,6 +49,16 @@ impl Profile {\n         }\n         out\n     }\n+\n+    pub fn as_str(&self) -> &'static str {\n+        match self {\n+            Profile::Compiler => \"compiler\",\n+            Profile::Codegen => \"codegen\",\n+            Profile::Library => \"library\",\n+            Profile::Tools => \"tools\",\n+            Profile::User => \"user\",\n+        }\n+    }\n }\n \n impl FromStr for Profile {\n@@ -69,24 +80,58 @@ impl FromStr for Profile {\n \n impl fmt::Display for Profile {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self {\n-            Profile::Compiler => write!(f, \"compiler\"),\n-            Profile::Codegen => write!(f, \"codegen\"),\n-            Profile::Library => write!(f, \"library\"),\n-            Profile::User => write!(f, \"user\"),\n-            Profile::Tools => write!(f, \"tools\"),\n+        f.write_str(self.as_str())\n+    }\n+}\n+\n+impl Step for Profile {\n+    type Output = ();\n+    const DEFAULT: bool = true;\n+\n+    fn should_run(mut run: ShouldRun<'_>) -> ShouldRun<'_> {\n+        for choice in Profile::all() {\n+            run = run.alias(choice.as_str());\n         }\n+        run\n+    }\n+\n+    fn make_run(run: RunConfig<'_>) {\n+        // for Profile, `run.paths` will have 1 and only 1 element\n+        // this is because we only accept at most 1 path from user input.\n+        // If user calls `x.py setup` without arguments, the interactive TUI\n+        // will guide user to provide one.\n+        let profile = if run.paths.len() > 1 {\n+            // HACK: `builder` runs this step with all paths if no path was passed.\n+            t!(interactive_path())\n+        } else {\n+            run.paths\n+                .first()\n+                .unwrap()\n+                .assert_single_path()\n+                .path\n+                .as_path()\n+                .as_os_str()\n+                .to_str()\n+                .unwrap()\n+                .parse()\n+                .unwrap()\n+        };\n+\n+        run.builder.ensure(profile);\n+    }\n+\n+    fn run(self, builder: &Builder<'_>) {\n+        setup(&builder.build.config, self)\n     }\n }\n \n-pub fn setup(config: &Config, profile: Option<Profile>) {\n-    let profile = profile.unwrap_or_else(|| t!(interactive_path()));\n+pub fn setup(config: &Config, profile: Profile) {\n     let stage_path =\n         [\"build\", config.build.rustc_target_arg(), \"stage1\"].join(&MAIN_SEPARATOR.to_string());\n \n     if !rustup_installed() && profile != Profile::User {\n         eprintln!(\"`rustup` is not installed; cannot link `stage1` toolchain\");\n-    } else if stage_dir_exists(&stage_path[..]) {\n+    } else if stage_dir_exists(&stage_path[..]) && !config.dry_run() {\n         attempt_toolchain_link(&stage_path[..]);\n     }\n \n@@ -104,7 +149,9 @@ pub fn setup(config: &Config, profile: Option<Profile>) {\n         Profile::User => &[\"dist\", \"build\"],\n     };\n \n-    t!(install_git_hook_maybe(&config));\n+    if !config.dry_run() {\n+        t!(install_git_hook_maybe(&config));\n+    }\n \n     println!();\n \n@@ -144,6 +191,7 @@ fn setup_config_toml(path: &PathBuf, profile: Profile, config: &Config) {\n     changelog-seen = {}\\n\",\n         profile, VERSION\n     );\n+\n     t!(fs::write(path, settings));\n \n     let include_path = profile.include_path(&config.src);"}, {"sha": "9ea756c271298de5a6651f01389609837ee30d6f", "filename": "src/test/mir-opt/dest-prop/unreachable.f.DestinationPropagation.diff", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/src%2Ftest%2Fmir-opt%2Fdest-prop%2Funreachable.f.DestinationPropagation.diff", "raw_url": "https://github.com/rust-lang/rust/raw/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/src%2Ftest%2Fmir-opt%2Fdest-prop%2Funreachable.f.DestinationPropagation.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdest-prop%2Funreachable.f.DestinationPropagation.diff?ref=d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0", "patch": "@@ -0,0 +1,86 @@\n+- // MIR for `f` before DestinationPropagation\n++ // MIR for `f` after DestinationPropagation\n+  \n+  fn f(_1: T) -> () {\n+      debug a => _1;                       // in scope 0 at $DIR/unreachable.rs:+0:19: +0:20\n+      let mut _0: ();                      // return place in scope 0 at $DIR/unreachable.rs:+0:25: +0:25\n+      let _2: T;                           // in scope 0 at $DIR/unreachable.rs:+1:9: +1:10\n+      let mut _3: bool;                    // in scope 0 at $DIR/unreachable.rs:+2:8: +2:13\n+      let _4: ();                          // in scope 0 at $DIR/unreachable.rs:+3:9: +3:16\n+      let mut _5: T;                       // in scope 0 at $DIR/unreachable.rs:+3:11: +3:12\n+      let mut _6: T;                       // in scope 0 at $DIR/unreachable.rs:+3:14: +3:15\n+      let _7: ();                          // in scope 0 at $DIR/unreachable.rs:+5:9: +5:16\n+      let mut _8: T;                       // in scope 0 at $DIR/unreachable.rs:+5:11: +5:12\n+      let mut _9: T;                       // in scope 0 at $DIR/unreachable.rs:+5:14: +5:15\n+      scope 1 {\n+-         debug b => _2;                   // in scope 1 at $DIR/unreachable.rs:+1:9: +1:10\n++         debug b => _1;                   // in scope 1 at $DIR/unreachable.rs:+1:9: +1:10\n+      }\n+  \n+      bb0: {\n+-         StorageLive(_2);                 // scope 0 at $DIR/unreachable.rs:+1:9: +1:10\n+-         _2 = _1;                         // scope 0 at $DIR/unreachable.rs:+1:13: +1:14\n++         nop;                             // scope 0 at $DIR/unreachable.rs:+1:9: +1:10\n++         nop;                             // scope 0 at $DIR/unreachable.rs:+1:13: +1:14\n+          StorageLive(_3);                 // scope 1 at $DIR/unreachable.rs:+2:8: +2:13\n+          _3 = const false;                // scope 1 at $DIR/unreachable.rs:+2:8: +2:13\n+-         goto -> bb3;                     // scope 1 at $DIR/unreachable.rs:+2:8: +2:13\n++         goto -> bb1;                     // scope 1 at $DIR/unreachable.rs:+2:8: +2:13\n+      }\n+  \n+      bb1: {\n+-         StorageLive(_4);                 // scope 1 at $DIR/unreachable.rs:+3:9: +3:16\n+-         StorageLive(_5);                 // scope 1 at $DIR/unreachable.rs:+3:11: +3:12\n+-         _5 = _1;                         // scope 1 at $DIR/unreachable.rs:+3:11: +3:12\n+-         StorageLive(_6);                 // scope 1 at $DIR/unreachable.rs:+3:14: +3:15\n+-         _6 = _2;                         // scope 1 at $DIR/unreachable.rs:+3:14: +3:15\n+-         _4 = g::<T>(move _5, move _6) -> bb2; // scope 1 at $DIR/unreachable.rs:+3:9: +3:16\n+-                                          // mir::Constant\n+-                                          // + span: $DIR/unreachable.rs:11:9: 11:10\n+-                                          // + literal: Const { ty: fn(T, T) {g::<T>}, val: Value(<ZST>) }\n+-     }\n+- \n+-     bb2: {\n+-         StorageDead(_6);                 // scope 1 at $DIR/unreachable.rs:+3:15: +3:16\n+-         StorageDead(_5);                 // scope 1 at $DIR/unreachable.rs:+3:15: +3:16\n+-         StorageDead(_4);                 // scope 1 at $DIR/unreachable.rs:+3:16: +3:17\n+-         _0 = const ();                   // scope 1 at $DIR/unreachable.rs:+2:14: +4:6\n+-         goto -> bb5;                     // scope 1 at $DIR/unreachable.rs:+2:5: +6:6\n+-     }\n+- \n+-     bb3: {\n+          StorageLive(_7);                 // scope 1 at $DIR/unreachable.rs:+5:9: +5:16\n+-         StorageLive(_8);                 // scope 1 at $DIR/unreachable.rs:+5:11: +5:12\n+-         _8 = _2;                         // scope 1 at $DIR/unreachable.rs:+5:11: +5:12\n++         nop;                             // scope 1 at $DIR/unreachable.rs:+5:11: +5:12\n++         nop;                             // scope 1 at $DIR/unreachable.rs:+5:11: +5:12\n+          StorageLive(_9);                 // scope 1 at $DIR/unreachable.rs:+5:14: +5:15\n+-         _9 = _2;                         // scope 1 at $DIR/unreachable.rs:+5:14: +5:15\n+-         _7 = g::<T>(move _8, move _9) -> bb4; // scope 1 at $DIR/unreachable.rs:+5:9: +5:16\n++         _9 = _1;                         // scope 1 at $DIR/unreachable.rs:+5:14: +5:15\n++         _7 = g::<T>(move _1, move _9) -> bb2; // scope 1 at $DIR/unreachable.rs:+5:9: +5:16\n+                                           // mir::Constant\n+                                           // + span: $DIR/unreachable.rs:13:9: 13:10\n+                                           // + literal: Const { ty: fn(T, T) {g::<T>}, val: Value(<ZST>) }\n+      }\n+  \n+-     bb4: {\n++     bb2: {\n+          StorageDead(_9);                 // scope 1 at $DIR/unreachable.rs:+5:15: +5:16\n+-         StorageDead(_8);                 // scope 1 at $DIR/unreachable.rs:+5:15: +5:16\n++         nop;                             // scope 1 at $DIR/unreachable.rs:+5:15: +5:16\n+          StorageDead(_7);                 // scope 1 at $DIR/unreachable.rs:+5:16: +5:17\n+          _0 = const ();                   // scope 1 at $DIR/unreachable.rs:+4:12: +6:6\n+-         goto -> bb5;                     // scope 1 at $DIR/unreachable.rs:+2:5: +6:6\n++         goto -> bb3;                     // scope 1 at $DIR/unreachable.rs:+2:5: +6:6\n+      }\n+  \n+-     bb5: {\n++     bb3: {\n+          StorageDead(_3);                 // scope 1 at $DIR/unreachable.rs:+6:5: +6:6\n+-         StorageDead(_2);                 // scope 0 at $DIR/unreachable.rs:+7:1: +7:2\n++         nop;                             // scope 0 at $DIR/unreachable.rs:+7:1: +7:2\n+          return;                          // scope 0 at $DIR/unreachable.rs:+7:2: +7:2\n+      }\n+  }\n+  "}, {"sha": "32b5def984a8053614e071fe22a8199bb6eb9458", "filename": "src/test/mir-opt/dest-prop/unreachable.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/src%2Ftest%2Fmir-opt%2Fdest-prop%2Funreachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/src%2Ftest%2Fmir-opt%2Fdest-prop%2Funreachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdest-prop%2Funreachable.rs?ref=d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0", "patch": "@@ -0,0 +1,18 @@\n+// Check that unreachable code is removed after the destination propagation.\n+// Regression test for issue #105428.\n+//\n+// compile-flags: --crate-type=lib -Zmir-opt-level=0\n+// compile-flags: -Zmir-enable-passes=+ConstProp,+SimplifyConstCondition-after-const-prop,+DestinationPropagation\n+\n+// EMIT_MIR unreachable.f.DestinationPropagation.diff\n+pub fn f<T: Copy>(a: T) {\n+    let b = a;\n+    if false {\n+        g(a, b);\n+    } else {\n+        g(b, b);\n+    }\n+}\n+\n+#[inline(never)]\n+pub fn g<T: Copy>(_: T, _: T) {}"}, {"sha": "f07ff43efe987fec445e76d8102f6c2bbdcabd4a", "filename": "src/tools/x/src/main.rs", "status": "modified", "additions": 32, "deletions": 40, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/src%2Ftools%2Fx%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0/src%2Ftools%2Fx%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fx%2Fsrc%2Fmain.rs?ref=d0dc9efff14ac0a1eeceffd1e605e37eeb8362a0", "patch": "@@ -1,51 +1,43 @@\n-//! Run `x.py` from any subdirectory of a rust compiler checkout.\n+//! Run bootstrap from any subdirectory of a rust compiler checkout.\n //!\n //! We prefer `exec`, to avoid adding an extra process in the process tree.\n //! However, since `exec` isn't available on Windows, we indirect through\n //! `exec_or_status`, which will call `exec` on unix and `status` on Windows.\n //!\n-//! We use `python`, `python3`, or `python2` as the python interpreter to run\n-//! `x.py`, in that order of preference.\n+//! We use `powershell.exe x.ps1` on Windows, and `sh -c x` on Unix, those are\n+//! the ones that call `x.py`. We use `sh -c` on Unix, because it is a standard.\n+//! We also don't use `pwsh` on Windows, because it is not installed by default;\n \n use std::{\n-    env::{self, consts::EXE_EXTENSION},\n-    io,\n+    env, io,\n+    path::Path,\n     process::{self, Command, ExitStatus},\n };\n \n-const PYTHON: &str = \"python\";\n-const PYTHON2: &str = \"python2\";\n-const PYTHON3: &str = \"python3\";\n-\n-fn python() -> &'static str {\n-    let val = match env::var_os(\"PATH\") {\n-        Some(val) => val,\n-        None => return PYTHON,\n-    };\n-\n-    let mut python2 = false;\n-    let mut python3 = false;\n-\n-    for dir in env::split_paths(&val) {\n-        // `python` should always take precedence over python2 / python3 if it exists\n-        if dir.join(PYTHON).with_extension(EXE_EXTENSION).exists() {\n-            return PYTHON;\n-        }\n+#[cfg(windows)]\n+fn x_command(dir: &Path) -> Command {\n+    let mut cmd = Command::new(\"powershell.exe\");\n+    cmd.args([\n+        \"-NoLogo\",\n+        \"-NoProfile\",\n+        \"-NonInteractive\",\n+        \"-ExecutionPolicy\",\n+        \"RemoteSigned\",\n+        \"-Command\",\n+        \"./x.ps1\",\n+    ])\n+    .current_dir(dir);\n+    cmd\n+}\n \n-        python2 |= dir.join(PYTHON2).with_extension(EXE_EXTENSION).exists();\n-        python3 |= dir.join(PYTHON3).with_extension(EXE_EXTENSION).exists();\n-    }\n+#[cfg(unix)]\n+fn x_command(dir: &Path) -> Command {\n+    Command::new(dir.join(\"x\"))\n+}\n \n-    // try 3 before 2\n-    if python3 {\n-        PYTHON3\n-    } else if python2 {\n-        PYTHON2\n-    } else {\n-        // Python was not found on path, so exit\n-        eprintln!(\"Unable to find python in your PATH. Please check it is installed.\");\n-        process::exit(1);\n-    }\n+#[cfg(not(any(windows, unix)))]\n+fn x_command(_dir: &Path) -> Command {\n+    compile_error!(\"Unsupported platform\");\n }\n \n #[cfg(unix)]\n@@ -72,15 +64,15 @@ fn main() {\n         let candidate = dir.join(\"x.py\");\n \n         if candidate.exists() {\n-            let mut python = Command::new(python());\n+            let mut cmd = x_command(dir);\n \n-            python.arg(&candidate).args(env::args().skip(1)).current_dir(dir);\n+            cmd.args(env::args().skip(1)).current_dir(dir);\n \n-            let result = exec_or_status(&mut python);\n+            let result = exec_or_status(&mut cmd);\n \n             match result {\n                 Err(error) => {\n-                    eprintln!(\"Failed to invoke `{}`: {}\", candidate.display(), error);\n+                    eprintln!(\"Failed to invoke `{:?}`: {}\", cmd, error);\n                 }\n                 Ok(status) => {\n                     process::exit(status.code().unwrap_or(1));"}]}