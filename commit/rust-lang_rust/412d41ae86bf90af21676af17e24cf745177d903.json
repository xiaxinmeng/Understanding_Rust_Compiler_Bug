{"sha": "412d41ae86bf90af21676af17e24cf745177d903", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxMmQ0MWFlODZiZjkwYWYyMTY3NmFmMTdlMjRjZjc0NTE3N2Q5MDM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-26T10:43:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-26T10:43:50Z"}, "message": "Auto merge of #3814 - ljedrz:HirIdification_lockstep_upgrade, r=phansch\n\nHirIdify some lints\n\nUnblocks https://github.com/rust-lang/rust/pull/58561 (a part of [rust-lang/rust#57578](https://github.com/rust-lang/rust/pull/57578)). Can we branch it like with https://github.com/rust-lang/rust-clippy/pull/3790? I can rebase on a different commit if need be.\n\nHaven't had time to run tests yet, so I'd wait for Travis \ud83d\ude48.", "tree": {"sha": "c3e20d4b5a559a2e7f790d853c9c8f0b3352fc57", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c3e20d4b5a559a2e7f790d853c9c8f0b3352fc57"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/412d41ae86bf90af21676af17e24cf745177d903", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/412d41ae86bf90af21676af17e24cf745177d903", "html_url": "https://github.com/rust-lang/rust/commit/412d41ae86bf90af21676af17e24cf745177d903", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/412d41ae86bf90af21676af17e24cf745177d903/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d0717d1f9531a03d154aaeb0cad94c243915a146", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0717d1f9531a03d154aaeb0cad94c243915a146", "html_url": "https://github.com/rust-lang/rust/commit/d0717d1f9531a03d154aaeb0cad94c243915a146"}, {"sha": "c1b65ec363e552e1698949e34fc59a9196cbbcd9", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1b65ec363e552e1698949e34fc59a9196cbbcd9", "html_url": "https://github.com/rust-lang/rust/commit/c1b65ec363e552e1698949e34fc59a9196cbbcd9"}], "stats": {"total": 257, "additions": 131, "deletions": 126}, "files": [{"sha": "376751f860d102a329e9b0f2a28723629978dfea", "filename": "clippy_lints/src/assign_ops.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/412d41ae86bf90af21676af17e24cf745177d903/clippy_lints%2Fsrc%2Fassign_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/412d41ae86bf90af21676af17e24cf745177d903/clippy_lints%2Fsrc%2Fassign_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassign_ops.rs?ref=412d41ae86bf90af21676af17e24cf745177d903", "patch": "@@ -6,7 +6,6 @@ use rustc::hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n-use syntax::ast;\n \n /// **What it does:** Checks for `a = a op b` or `a = b commutative_op a`\n /// patterns.\n@@ -140,12 +139,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n                                             return; // useless if the trait doesn't exist\n                                         };\n                                         // check that we are not inside an `impl AssignOp` of this exact operation\n-                                        let parent_fn = cx.tcx.hir().get_parent(e.id);\n-                                        let parent_impl = cx.tcx.hir().get_parent(parent_fn);\n+                                        let parent_fn = cx.tcx.hir().get_parent_item(e.hir_id);\n+                                        let parent_impl = cx.tcx.hir().get_parent_item(parent_fn);\n                                         // the crate node is the only one that is not in the map\n                                         if_chain! {\n-                                            if parent_impl != ast::CRATE_NODE_ID;\n-                                            if let hir::Node::Item(item) = cx.tcx.hir().get(parent_impl);\n+                                            if parent_impl != hir::CRATE_HIR_ID;\n+                                            if let hir::Node::Item(item) = cx.tcx.hir().get_by_hir_id(parent_impl);\n                                             if let hir::ItemKind::Impl(_, _, _, _, Some(trait_ref), _, _) =\n                                                 &item.node;\n                                             if trait_ref.path.def.def_id() == trait_id;"}, {"sha": "3b76f288b6b380845323d97a31a4ff39cd93c7c2", "filename": "clippy_lints/src/booleans.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/412d41ae86bf90af21676af17e24cf745177d903/clippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/412d41ae86bf90af21676af17e24cf745177d903/clippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbooleans.rs?ref=412d41ae86bf90af21676af17e24cf745177d903", "patch": "@@ -7,7 +7,7 @@ use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n use rustc_data_structures::thin_vec::ThinVec;\n use rustc_errors::Applicability;\n-use syntax::ast::{LitKind, DUMMY_NODE_ID};\n+use syntax::ast::LitKind;\n use syntax::source_map::{dummy_spanned, Span, DUMMY_SP};\n \n /// **What it does:** Checks for boolean expressions that can be written more\n@@ -132,7 +132,6 @@ impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n                     }\n \n                     let mk_expr = |op| Expr {\n-                        id: DUMMY_NODE_ID,\n                         hir_id: DUMMY_HIR_ID,\n                         span: DUMMY_SP,\n                         attrs: ThinVec::new(),"}, {"sha": "2c4b335c13269a158c641286d13da0ec7be919f8", "filename": "clippy_lints/src/copies.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/412d41ae86bf90af21676af17e24cf745177d903/clippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/412d41ae86bf90af21676af17e24cf745177d903/clippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopies.rs?ref=412d41ae86bf90af21676af17e24cf745177d903", "patch": "@@ -125,7 +125,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CopyAndPaste {\n                 ..\n             }) = get_parent_expr(cx, expr)\n             {\n-                if else_expr.id == expr.id {\n+                if else_expr.hir_id == expr.hir_id {\n                     return;\n                 }\n             }"}, {"sha": "502937878530e43543846afcd2263d4b76ceb667", "filename": "clippy_lints/src/cyclomatic_complexity.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/412d41ae86bf90af21676af17e24cf745177d903/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/412d41ae86bf90af21676af17e24cf745177d903/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs?ref=412d41ae86bf90af21676af17e24cf745177d903", "patch": "@@ -222,8 +222,7 @@ fn report_cc_bug(\n     span: Span,\n     id: HirId,\n ) {\n-    let node_id = cx.tcx.hir().hir_to_node_id(id);\n-    if !is_allowed(cx, CYCLOMATIC_COMPLEXITY, node_id) {\n+    if !is_allowed(cx, CYCLOMATIC_COMPLEXITY, id) {\n         cx.sess().span_note_without_error(\n             span,\n             &format!("}, {"sha": "3fa2ceda5d7d7ca57e97472ff9faec7aadcc4468", "filename": "clippy_lints/src/default_trait_access.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/412d41ae86bf90af21676af17e24cf745177d903/clippy_lints%2Fsrc%2Fdefault_trait_access.rs", "raw_url": "https://github.com/rust-lang/rust/raw/412d41ae86bf90af21676af17e24cf745177d903/clippy_lints%2Fsrc%2Fdefault_trait_access.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdefault_trait_access.rs?ref=412d41ae86bf90af21676af17e24cf745177d903", "patch": "@@ -45,7 +45,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DefaultTraitAccess {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if_chain! {\n             if let ExprKind::Call(ref path, ..) = expr.node;\n-            if !any_parent_is_automatically_derived(cx.tcx, expr.id);\n+            if !any_parent_is_automatically_derived(cx.tcx, expr.hir_id);\n             if let ExprKind::Path(ref qpath) = path.node;\n             if let Some(def_id) = opt_def_id(cx.tables.qpath_def(qpath, path.hir_id));\n             if match_def_path(cx.tcx, def_id, &paths::DEFAULT_TRAIT_METHOD);"}, {"sha": "3f49cbdc0f2c6a419e4df968a45ed5341a1a8ef4", "filename": "clippy_lints/src/escape.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/412d41ae86bf90af21676af17e24cf745177d903/clippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/412d41ae86bf90af21676af17e24cf745177d903/clippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fescape.rs?ref=412d41ae86bf90af21676af17e24cf745177d903", "patch": "@@ -100,7 +100,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n }\n \n impl<'a, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n-    fn consume(&mut self, _: NodeId, _: Span, cmt: &cmt_<'tcx>, mode: ConsumeMode) {\n+    fn consume(&mut self, _: HirId, _: Span, cmt: &cmt_<'tcx>, mode: ConsumeMode) {\n         if let Categorization::Local(lid) = cmt.cat {\n             if let Move(DirectRefMove) = mode {\n                 // moved out or in. clearly can't be localized\n@@ -150,7 +150,7 @@ impl<'a, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n     }\n     fn borrow(\n         &mut self,\n-        _: NodeId,\n+        _: HirId,\n         _: Span,\n         cmt: &cmt_<'tcx>,\n         _: ty::Region<'_>,\n@@ -178,7 +178,7 @@ impl<'a, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n         }\n     }\n     fn decl_without_init(&mut self, _: NodeId, _: Span) {}\n-    fn mutate(&mut self, _: NodeId, _: Span, _: &cmt_<'tcx>, _: MutateMode) {}\n+    fn mutate(&mut self, _: HirId, _: Span, _: &cmt_<'tcx>, _: MutateMode) {}\n }\n \n impl<'a, 'tcx> EscapeDelegate<'a, 'tcx> {"}, {"sha": "81e653b6c42c2e51b943b727df876892a2bbc86f", "filename": "clippy_lints/src/eval_order_dependence.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/412d41ae86bf90af21676af17e24cf745177d903/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/412d41ae86bf90af21676af17e24cf745177d903/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feval_order_dependence.rs?ref=412d41ae86bf90af21676af17e24cf745177d903", "patch": "@@ -186,13 +186,13 @@ impl<'a, 'tcx> Visitor<'tcx> for DivergenceVisitor<'a, 'tcx> {\n /// When such a read is found, the lint is triggered.\n fn check_for_unsequenced_reads(vis: &mut ReadVisitor<'_, '_>) {\n     let map = &vis.cx.tcx.hir();\n-    let mut cur_id = vis.write_expr.id;\n+    let mut cur_id = vis.write_expr.hir_id;\n     loop {\n-        let parent_id = map.get_parent_node(cur_id);\n+        let parent_id = map.get_parent_node_by_hir_id(cur_id);\n         if parent_id == cur_id {\n             break;\n         }\n-        let parent_node = match map.find(parent_id) {\n+        let parent_node = match map.find_by_hir_id(parent_id) {\n             Some(parent) => parent,\n             None => break,\n         };\n@@ -224,7 +224,7 @@ enum StopEarly {\n }\n \n fn check_expr<'a, 'tcx>(vis: &mut ReadVisitor<'a, 'tcx>, expr: &'tcx Expr) -> StopEarly {\n-    if expr.id == vis.last_expr.id {\n+    if expr.hir_id == vis.last_expr.hir_id {\n         return StopEarly::KeepGoing;\n     }\n \n@@ -298,7 +298,7 @@ struct ReadVisitor<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> Visitor<'tcx> for ReadVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx Expr) {\n-        if expr.id == self.last_expr.id {\n+        if expr.hir_id == self.last_expr.hir_id {\n             return;\n         }\n \n@@ -355,7 +355,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ReadVisitor<'a, 'tcx> {\n fn is_in_assignment_position(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n     if let Some(parent) = get_parent_expr(cx, expr) {\n         if let ExprKind::Assign(ref lhs, _) = parent.node {\n-            return lhs.id == expr.id;\n+            return lhs.hir_id == expr.hir_id;\n         }\n     }\n     false"}, {"sha": "b09031b553f9ffccfc7c4b9e18b298c332201baa", "filename": "clippy_lints/src/identity_conversion.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/412d41ae86bf90af21676af17e24cf745177d903/clippy_lints%2Fsrc%2Fidentity_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/412d41ae86bf90af21676af17e24cf745177d903/clippy_lints%2Fsrc%2Fidentity_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fidentity_conversion.rs?ref=412d41ae86bf90af21676af17e24cf745177d903", "patch": "@@ -6,7 +6,6 @@ use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n-use syntax::ast::NodeId;\n \n /// **What it does:** Checks for always-identical `Into`/`From`/`IntoIter` conversions.\n ///\n@@ -27,7 +26,7 @@ declare_clippy_lint! {\n \n #[derive(Default)]\n pub struct IdentityConversion {\n-    try_desugar_arm: Vec<NodeId>,\n+    try_desugar_arm: Vec<HirId>,\n }\n \n impl LintPass for IdentityConversion {\n@@ -46,7 +45,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IdentityConversion {\n             return;\n         }\n \n-        if Some(&e.id) == self.try_desugar_arm.last() {\n+        if Some(&e.hir_id) == self.try_desugar_arm.last() {\n             return;\n         }\n \n@@ -57,7 +56,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IdentityConversion {\n                     _ => return,\n                 };\n                 if let ExprKind::Call(_, ref args) = e.node {\n-                    self.try_desugar_arm.push(args[0].id);\n+                    self.try_desugar_arm.push(args[0].hir_id);\n                 } else {\n                     return;\n                 }\n@@ -126,7 +125,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IdentityConversion {\n     }\n \n     fn check_expr_post(&mut self, _: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n-        if Some(&e.id) == self.try_desugar_arm.last() {\n+        if Some(&e.hir_id) == self.try_desugar_arm.last() {\n             self.try_desugar_arm.pop();\n         }\n     }"}, {"sha": "34de33bd546ab7fb0ec03fe6c07eccbdbc883b0e", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/412d41ae86bf90af21676af17e24cf745177d903/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/412d41ae86bf90af21676af17e24cf745177d903/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=412d41ae86bf90af21676af17e24cf745177d903", "patch": "@@ -319,7 +319,7 @@ impl<'v, 't> RefVisitor<'v, 't> {\n                     _ => false,\n                 })\n             {\n-                let hir_id = self.cx.tcx.hir().node_to_hir_id(ty.id);\n+                let hir_id = ty.hir_id;\n                 match self.cx.tables.qpath_def(qpath, hir_id) {\n                     Def::TyAlias(def_id) | Def::Struct(def_id) => {\n                         let generics = self.cx.tcx.generics_of(def_id);"}, {"sha": "73da2467f59c2d64cd03b62581aabde93e2e5183", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 30, "deletions": 26, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/412d41ae86bf90af21676af17e24cf745177d903/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/412d41ae86bf90af21676af17e24cf745177d903/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=412d41ae86bf90af21676af17e24cf745177d903", "patch": "@@ -486,7 +486,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         // check for never_loop\n         match expr.node {\n             ExprKind::While(_, ref block, _) | ExprKind::Loop(ref block, _, _) => {\n-                match never_loop_block(block, expr.id) {\n+                let node_id = cx.tcx.hir().hir_to_node_id(expr.hir_id);\n+                match never_loop_block(block, node_id) {\n                     NeverLoopResult::AlwaysBreak => {\n                         span_lint(cx, NEVER_LOOP, expr.span, \"this loop never actually loops\")\n                     },\n@@ -1109,8 +1110,8 @@ fn check_for_loop_range<'a, 'tcx>(\n \n                 // ensure that the indexed variable was declared before the loop, see #601\n                 if let Some(indexed_extent) = indexed_extent {\n-                    let parent_id = cx.tcx.hir().get_parent(expr.id);\n-                    let parent_def_id = cx.tcx.hir().local_def_id(parent_id);\n+                    let parent_id = cx.tcx.hir().get_parent_item(expr.hir_id);\n+                    let parent_def_id = cx.tcx.hir().local_def_id_from_hir_id(parent_id);\n                     let region_scope_tree = cx.tcx.region_scope_tree(parent_def_id);\n                     let pat_extent = region_scope_tree.var_scope(pat.hir_id.local_id);\n                     if region_scope_tree.is_subscope_of(indexed_extent, pat_extent) {\n@@ -1469,8 +1470,9 @@ fn check_for_loop_explicit_counter<'a, 'tcx>(\n     // For each candidate, check the parent block to see if\n     // it's initialized to zero at the start of the loop.\n     let map = &cx.tcx.hir();\n+    let expr_node_id = map.hir_to_node_id(expr.hir_id);\n     let parent_scope = map\n-        .get_enclosing_scope(expr.id)\n+        .get_enclosing_scope(expr_node_id)\n         .and_then(|id| map.get_enclosing_scope(id));\n     if let Some(parent_id) = parent_scope {\n         if let Node::Block(block) = map.get(parent_id) {\n@@ -1567,13 +1569,13 @@ struct MutatePairDelegate {\n }\n \n impl<'tcx> Delegate<'tcx> for MutatePairDelegate {\n-    fn consume(&mut self, _: NodeId, _: Span, _: &cmt_<'tcx>, _: ConsumeMode) {}\n+    fn consume(&mut self, _: HirId, _: Span, _: &cmt_<'tcx>, _: ConsumeMode) {}\n \n     fn matched_pat(&mut self, _: &Pat, _: &cmt_<'tcx>, _: MatchMode) {}\n \n     fn consume_pat(&mut self, _: &Pat, _: &cmt_<'tcx>, _: ConsumeMode) {}\n \n-    fn borrow(&mut self, _: NodeId, sp: Span, cmt: &cmt_<'tcx>, _: ty::Region<'_>, bk: ty::BorrowKind, _: LoanCause) {\n+    fn borrow(&mut self, _: HirId, sp: Span, cmt: &cmt_<'tcx>, _: ty::Region<'_>, bk: ty::BorrowKind, _: LoanCause) {\n         if let ty::BorrowKind::MutBorrow = bk {\n             if let Categorization::Local(id) = cmt.cat {\n                 if Some(id) == self.node_id_low {\n@@ -1586,7 +1588,7 @@ impl<'tcx> Delegate<'tcx> for MutatePairDelegate {\n         }\n     }\n \n-    fn mutate(&mut self, _: NodeId, sp: Span, cmt: &cmt_<'tcx>, _: MutateMode) {\n+    fn mutate(&mut self, _: HirId, sp: Span, cmt: &cmt_<'tcx>, _: MutateMode) {\n         if let Categorization::Local(id) = cmt.cat {\n             if Some(id) == self.node_id_low {\n                 self.span_low = Some(sp)\n@@ -1778,8 +1780,8 @@ impl<'a, 'tcx> VarVisitor<'a, 'tcx> {\n                         Def::Local(node_id) | Def::Upvar(node_id, ..) => {\n                             let hir_id = self.cx.tcx.hir().node_to_hir_id(node_id);\n \n-                            let parent_id = self.cx.tcx.hir().get_parent(expr.id);\n-                            let parent_def_id = self.cx.tcx.hir().local_def_id(parent_id);\n+                            let parent_id = self.cx.tcx.hir().get_parent_item(expr.hir_id);\n+                            let parent_def_id = self.cx.tcx.hir().local_def_id_from_hir_id(parent_id);\n                             let extent = self.cx.tcx.region_scope_tree(parent_def_id).var_scope(hir_id.local_id);\n                             if indexed_indirectly {\n                                 self.indexed_indirectly.insert(seqvar.segments[0].ident.name, Some(extent));\n@@ -1932,11 +1934,12 @@ fn is_iterator_used_after_while_let<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, it\n     let mut visitor = VarUsedAfterLoopVisitor {\n         cx,\n         def_id,\n-        iter_expr_id: iter_expr.id,\n+        iter_expr_id: iter_expr.hir_id,\n         past_while_let: false,\n         var_used_after_while_let: false,\n     };\n-    if let Some(enclosing_block) = get_enclosing_block(cx, def_id) {\n+    let def_hir_id = cx.tcx.hir().node_to_hir_id(def_id);\n+    if let Some(enclosing_block) = get_enclosing_block(cx, def_hir_id) {\n         walk_block(&mut visitor, enclosing_block);\n     }\n     visitor.var_used_after_while_let\n@@ -1945,7 +1948,7 @@ fn is_iterator_used_after_while_let<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, it\n struct VarUsedAfterLoopVisitor<'a, 'tcx: 'a> {\n     cx: &'a LateContext<'a, 'tcx>,\n     def_id: NodeId,\n-    iter_expr_id: NodeId,\n+    iter_expr_id: HirId,\n     past_while_let: bool,\n     var_used_after_while_let: bool,\n }\n@@ -1956,7 +1959,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarUsedAfterLoopVisitor<'a, 'tcx> {\n             if Some(self.def_id) == var_def_id(self.cx, expr) {\n                 self.var_used_after_while_let = true;\n             }\n-        } else if self.iter_expr_id == expr.id {\n+        } else if self.iter_expr_id == expr.hir_id {\n             self.past_while_let = true;\n         }\n         walk_expr(self, expr);\n@@ -2068,7 +2071,7 @@ impl<'a, 'tcx> Visitor<'tcx> for IncrementVisitor<'a, 'tcx> {\n \n                 match parent.node {\n                     ExprKind::AssignOp(op, ref lhs, ref rhs) => {\n-                        if lhs.id == expr.id {\n+                        if lhs.hir_id == expr.hir_id {\n                             if op.node == BinOpKind::Add && is_integer_literal(rhs, 1) {\n                                 *state = match *state {\n                                     VarState::Initial if self.depth == 0 => VarState::IncrOnce,\n@@ -2080,7 +2083,7 @@ impl<'a, 'tcx> Visitor<'tcx> for IncrementVisitor<'a, 'tcx> {\n                             }\n                         }\n                     },\n-                    ExprKind::Assign(ref lhs, _) if lhs.id == expr.id => *state = VarState::DontWarn,\n+                    ExprKind::Assign(ref lhs, _) if lhs.hir_id == expr.hir_id => *state = VarState::DontWarn,\n                     ExprKind::AddrOf(mutability, _) if mutability == MutMutable => *state = VarState::DontWarn,\n                     _ => (),\n                 }\n@@ -2153,10 +2156,10 @@ impl<'a, 'tcx> Visitor<'tcx> for InitializeVisitor<'a, 'tcx> {\n         if var_def_id(self.cx, expr) == Some(self.var_id) {\n             if let Some(parent) = get_parent_expr(self.cx, expr) {\n                 match parent.node {\n-                    ExprKind::AssignOp(_, ref lhs, _) if lhs.id == expr.id => {\n+                    ExprKind::AssignOp(_, ref lhs, _) if lhs.hir_id == expr.hir_id => {\n                         self.state = VarState::DontWarn;\n                     },\n-                    ExprKind::Assign(ref lhs, ref rhs) if lhs.id == expr.id => {\n+                    ExprKind::Assign(ref lhs, ref rhs) if lhs.hir_id == expr.hir_id => {\n                         self.state = if is_integer_literal(rhs, 0) && self.depth == 0 {\n                             VarState::Warn\n                         } else {\n@@ -2214,8 +2217,9 @@ fn is_conditional(expr: &Expr) -> bool {\n \n fn is_nested(cx: &LateContext<'_, '_>, match_expr: &Expr, iter_expr: &Expr) -> bool {\n     if_chain! {\n-        if let Some(loop_block) = get_enclosing_block(cx, match_expr.id);\n-        if let Some(Node::Expr(loop_expr)) = cx.tcx.hir().find(cx.tcx.hir().get_parent_node(loop_block.id));\n+        if let Some(loop_block) = get_enclosing_block(cx, match_expr.hir_id);\n+        let parent_node = cx.tcx.hir().get_parent_node_by_hir_id(loop_block.hir_id);\n+        if let Some(Node::Expr(loop_expr)) = cx.tcx.hir().find_by_hir_id(parent_node);\n         then {\n             return is_loop_nested(cx, loop_expr, iter_expr)\n         }\n@@ -2224,18 +2228,18 @@ fn is_nested(cx: &LateContext<'_, '_>, match_expr: &Expr, iter_expr: &Expr) -> b\n }\n \n fn is_loop_nested(cx: &LateContext<'_, '_>, loop_expr: &Expr, iter_expr: &Expr) -> bool {\n-    let mut id = loop_expr.id;\n+    let mut id = loop_expr.hir_id;\n     let iter_name = if let Some(name) = path_name(iter_expr) {\n         name\n     } else {\n         return true;\n     };\n     loop {\n-        let parent = cx.tcx.hir().get_parent_node(id);\n+        let parent = cx.tcx.hir().get_parent_node_by_hir_id(id);\n         if parent == id {\n             return false;\n         }\n-        match cx.tcx.hir().find(parent) {\n+        match cx.tcx.hir().find_by_hir_id(parent) {\n             Some(Node::Expr(expr)) => match expr.node {\n                 ExprKind::Loop(..) | ExprKind::While(..) => {\n                     return true;\n@@ -2244,7 +2248,7 @@ fn is_loop_nested(cx: &LateContext<'_, '_>, loop_expr: &Expr, iter_expr: &Expr)\n             },\n             Some(Node::Block(block)) => {\n                 let mut block_visitor = LoopNestVisitor {\n-                    id,\n+                    hir_id: id,\n                     iterator: iter_name,\n                     nesting: Unknown,\n                 };\n@@ -2272,14 +2276,14 @@ enum Nesting {\n use self::Nesting::{LookFurther, RuledOut, Unknown};\n \n struct LoopNestVisitor {\n-    id: NodeId,\n+    hir_id: HirId,\n     iterator: Name,\n     nesting: Nesting,\n }\n \n impl<'tcx> Visitor<'tcx> for LoopNestVisitor {\n     fn visit_stmt(&mut self, stmt: &'tcx Stmt) {\n-        if stmt.id == self.id {\n+        if stmt.hir_id == self.hir_id {\n             self.nesting = LookFurther;\n         } else if self.nesting == Unknown {\n             walk_stmt(self, stmt);\n@@ -2290,7 +2294,7 @@ impl<'tcx> Visitor<'tcx> for LoopNestVisitor {\n         if self.nesting != Unknown {\n             return;\n         }\n-        if expr.id == self.id {\n+        if expr.hir_id == self.hir_id {\n             self.nesting = LookFurther;\n             return;\n         }"}, {"sha": "e762e2b3a80ba45c2b28c5e9e3fc7dc1499cbe2f", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/412d41ae86bf90af21676af17e24cf745177d903/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/412d41ae86bf90af21676af17e24cf745177d903/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=412d41ae86bf90af21676af17e24cf745177d903", "patch": "@@ -266,7 +266,7 @@ fn check_single_match(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm], expr: &\n             return;\n         };\n         let ty = cx.tables.expr_ty(ex);\n-        if ty.sty != ty::Bool || is_allowed(cx, MATCH_BOOL, ex.id) {\n+        if ty.sty != ty::Bool || is_allowed(cx, MATCH_BOOL, ex.hir_id) {\n             check_single_match_single_pattern(cx, ex, arms, expr, els);\n             check_single_match_opt_like(cx, ex, arms, expr, ty, els);\n         }"}, {"sha": "dd75c8aff37b1fdaf20fb7486650311f3ca8c215", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/412d41ae86bf90af21676af17e24cf745177d903/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/412d41ae86bf90af21676af17e24cf745177d903/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=412d41ae86bf90af21676af17e24cf745177d903", "patch": "@@ -1082,7 +1082,7 @@ fn lint_or_fun_call(cx: &LateContext<'_, '_>, expr: &hir::Expr, method_span: Spa\n         }\n \n         // don't lint for constant values\n-        let owner_def = cx.tcx.hir().get_parent_did(arg.id);\n+        let owner_def = cx.tcx.hir().get_parent_did_by_hir_id(arg.hir_id);\n         let promotable = cx.tcx.rvalue_promotable_map(owner_def).contains(&arg.hir_id.local_id);\n         if promotable {\n             return;\n@@ -1341,8 +1341,8 @@ fn lint_clone_on_copy(cx: &LateContext<'_, '_>, expr: &hir::Expr, arg: &hir::Exp\n             if cx.tables.expr_ty(arg) == ty {\n                 snip = Some((\"try removing the `clone` call\", format!(\"{}\", snippet)));\n             } else {\n-                let parent = cx.tcx.hir().get_parent_node(expr.id);\n-                match cx.tcx.hir().get(parent) {\n+                let parent = cx.tcx.hir().get_parent_node_by_hir_id(expr.hir_id);\n+                match cx.tcx.hir().get_by_hir_id(parent) {\n                     hir::Node::Expr(parent) => match parent.node {\n                         // &*x is a nop, &x.clone() is not\n                         hir::ExprKind::AddrOf(..) |"}, {"sha": "7125c77ec8e0b65e315c0575681fd60b0a58b59f", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/412d41ae86bf90af21676af17e24cf745177d903/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/412d41ae86bf90af21676af17e24cf745177d903/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=412d41ae86bf90af21676af17e24cf745177d903", "patch": "@@ -460,7 +460,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n }\n \n fn check_nan(cx: &LateContext<'_, '_>, path: &Path, expr: &Expr) {\n-    if !in_constant(cx, expr.id) {\n+    if !in_constant(cx, expr.hir_id) {\n         if let Some(seg) = path.segments.last() {\n             if seg.ident.name == \"NAN\" {\n                 span_lint(\n@@ -615,7 +615,7 @@ fn check_cast(cx: &LateContext<'_, '_>, span: Span, e: &Expr, ty: &Ty) {\n         if let ExprKind::Lit(ref lit) = e.node;\n         if let LitKind::Int(value, ..) = lit.node;\n         if value == 0;\n-        if !in_constant(cx, e.id);\n+        if !in_constant(cx, e.hir_id);\n         then {\n             let msg = match mutbl {\n                 Mutability::MutMutable => \"`0 as *mut _` detected. Consider using `ptr::null_mut()`\","}, {"sha": "164fb82f00f69365719b60cbb15188ba9144aa43", "filename": "clippy_lints/src/needless_bool.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/412d41ae86bf90af21676af17e24cf745177d903/clippy_lints%2Fsrc%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/412d41ae86bf90af21676af17e24cf745177d903/clippy_lints%2Fsrc%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_bool.rs?ref=412d41ae86bf90af21676af17e24cf745177d903", "patch": "@@ -126,8 +126,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBool {\n }\n \n fn parent_node_is_if_expr<'a, 'b>(expr: &Expr, cx: &LateContext<'a, 'b>) -> bool {\n-    let parent_id = cx.tcx.hir().get_parent_node(expr.id);\n-    let parent_node = cx.tcx.hir().get(parent_id);\n+    let parent_id = cx.tcx.hir().get_parent_node_by_hir_id(expr.hir_id);\n+    let parent_node = cx.tcx.hir().get_by_hir_id(parent_id);\n \n     if let rustc::hir::Node::Expr(e) = parent_node {\n         if let ExprKind::If(_, _, _) = e.node {"}, {"sha": "69d04ff7495e7ea43c4f819c6702da6f08d19cfc", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/412d41ae86bf90af21676af17e24cf745177d903/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/412d41ae86bf90af21676af17e24cf745177d903/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=412d41ae86bf90af21676af17e24cf745177d903", "patch": "@@ -341,7 +341,7 @@ impl<'a, 'tcx> MovedVariablesCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn move_common(&mut self, _consume_id: NodeId, _span: Span, cmt: &mc::cmt_<'tcx>) {\n+    fn move_common(&mut self, _consume_id: HirId, _span: Span, cmt: &mc::cmt_<'tcx>) {\n         let cmt = unwrap_downcast_or_interior(cmt);\n \n         if let mc::Categorization::Local(vid) = cmt.cat {\n@@ -399,29 +399,29 @@ impl<'a, 'tcx> MovedVariablesCtxt<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> euv::Delegate<'tcx> for MovedVariablesCtxt<'a, 'tcx> {\n-    fn consume(&mut self, consume_id: NodeId, consume_span: Span, cmt: &mc::cmt_<'tcx>, mode: euv::ConsumeMode) {\n+    fn consume(&mut self, consume_id: HirId, consume_span: Span, cmt: &mc::cmt_<'tcx>, mode: euv::ConsumeMode) {\n         if let euv::ConsumeMode::Move(_) = mode {\n             self.move_common(consume_id, consume_span, cmt);\n         }\n     }\n \n     fn matched_pat(&mut self, matched_pat: &Pat, cmt: &mc::cmt_<'tcx>, mode: euv::MatchMode) {\n         if let euv::MatchMode::MovingMatch = mode {\n-            self.move_common(matched_pat.id, matched_pat.span, cmt);\n+            self.move_common(matched_pat.hir_id, matched_pat.span, cmt);\n         } else {\n             self.non_moving_pat(matched_pat, cmt);\n         }\n     }\n \n     fn consume_pat(&mut self, consume_pat: &Pat, cmt: &mc::cmt_<'tcx>, mode: euv::ConsumeMode) {\n         if let euv::ConsumeMode::Move(_) = mode {\n-            self.move_common(consume_pat.id, consume_pat.span, cmt);\n+            self.move_common(consume_pat.hir_id, consume_pat.span, cmt);\n         }\n     }\n \n     fn borrow(\n         &mut self,\n-        _: NodeId,\n+        _: HirId,\n         _: Span,\n         _: &mc::cmt_<'tcx>,\n         _: ty::Region<'_>,\n@@ -430,7 +430,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for MovedVariablesCtxt<'a, 'tcx> {\n     ) {\n     }\n \n-    fn mutate(&mut self, _: NodeId, _: Span, _: &mc::cmt_<'tcx>, _: euv::MutateMode) {}\n+    fn mutate(&mut self, _: HirId, _: Span, _: &mc::cmt_<'tcx>, _: euv::MutateMode) {}\n \n     fn decl_without_init(&mut self, _: NodeId, _: Span) {}\n }"}, {"sha": "ce8b1db505ee473a16bc65d8ccaa65b72ad5789f", "filename": "clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/412d41ae86bf90af21676af17e24cf745177d903/clippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/412d41ae86bf90af21676af17e24cf745177d903/clippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnew_without_default.rs?ref=412d41ae86bf90af21676af17e24cf745177d903", "patch": "@@ -110,7 +110,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NewWithoutDefault {\n                     }\n                     if let hir::ImplItemKind::Method(ref sig, _) = impl_item.node {\n                         let name = impl_item.ident.name;\n-                        let id = impl_item.id;\n+                        let id = impl_item.hir_id;\n+                        let node_id = cx.tcx.hir().hir_to_node_id(id);\n                         if sig.header.constness == hir::Constness::Const {\n                             // can't be implemented by default\n                             return;\n@@ -128,11 +129,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NewWithoutDefault {\n                             // impl of `Default`\n                             return;\n                         }\n-                        if sig.decl.inputs.is_empty() && name == \"new\" && cx.access_levels.is_reachable(id) {\n-                            let self_did = cx.tcx.hir().local_def_id(cx.tcx.hir().get_parent(id));\n+                        if sig.decl.inputs.is_empty() && name == \"new\" && cx.access_levels.is_reachable(node_id) {\n+                            let self_did = cx.tcx.hir().local_def_id_from_hir_id(cx.tcx.hir().get_parent_item(id));\n                             let self_ty = cx.tcx.type_of(self_did);\n                             if_chain! {\n-                                if same_tys(cx, self_ty, return_ty(cx, id));\n+                                if same_tys(cx, self_ty, return_ty(cx, node_id));\n                                 if let Some(default_trait_id) = get_trait_def_id(cx, &paths::DEFAULT_TRAIT);\n                                 then {\n                                     if self.impling_types.is_none() {"}, {"sha": "3bc46f53308f6d0c1c2041d734b22d64db9b559d", "filename": "clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/412d41ae86bf90af21676af17e24cf745177d903/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/412d41ae86bf90af21676af17e24cf745177d903/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=412d41ae86bf90af21676af17e24cf745177d903", "patch": "@@ -197,7 +197,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonCopyConst {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if let ExprKind::Path(qpath) = &expr.node {\n             // Only lint if we use the const item inside a function.\n-            if in_constant(cx, expr.id) {\n+            if in_constant(cx, expr.hir_id) {\n                 return;\n             }\n \n@@ -212,11 +212,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonCopyConst {\n             let mut dereferenced_expr = expr;\n             let mut needs_check_adjustment = true;\n             loop {\n-                let parent_id = cx.tcx.hir().get_parent_node(cur_expr.id);\n-                if parent_id == cur_expr.id {\n+                let parent_id = cx.tcx.hir().get_parent_node_by_hir_id(cur_expr.hir_id);\n+                if parent_id == cur_expr.hir_id {\n                     break;\n                 }\n-                if let Some(Node::Expr(parent_expr)) = cx.tcx.hir().find(parent_id) {\n+                if let Some(Node::Expr(parent_expr)) = cx.tcx.hir().find_by_hir_id(parent_id) {\n                     match &parent_expr.node {\n                         ExprKind::AddrOf(..) => {\n                             // `&e` => `e` must be referenced"}, {"sha": "f57fd22c0707d71f0ae0982a643567df726d0c88", "filename": "clippy_lints/src/partialeq_ne_impl.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/412d41ae86bf90af21676af17e24cf745177d903/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/412d41ae86bf90af21676af17e24cf745177d903/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs?ref=412d41ae86bf90af21676af17e24cf745177d903", "patch": "@@ -51,10 +51,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             then {\n                 for impl_item in impl_items {\n                     if impl_item.ident.name == \"ne\" {\n+                        let hir_id = cx.tcx.hir().node_to_hir_id(impl_item.id.node_id);\n                         span_lint_node(\n                             cx,\n                             PARTIALEQ_NE_IMPL,\n-                            impl_item.id.node_id,\n+                            hir_id,\n                             impl_item.span,\n                             \"re-implementing `PartialEq::ne` is unnecessary\",\n                         );"}, {"sha": "eaaa6b93b3b992b8fbf406183b1d2ccdc70e25b9", "filename": "clippy_lints/src/regex.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/412d41ae86bf90af21676af17e24cf745177d903/clippy_lints%2Fsrc%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/412d41ae86bf90af21676af17e24cf745177d903/clippy_lints%2Fsrc%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fregex.rs?ref=412d41ae86bf90af21676af17e24cf745177d903", "patch": "@@ -7,7 +7,7 @@ use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n use rustc_data_structures::fx::FxHashSet;\n use std::convert::TryFrom;\n-use syntax::ast::{LitKind, NodeId, StrStyle};\n+use syntax::ast::{LitKind, StrStyle};\n use syntax::source_map::{BytePos, Span};\n \n /// **What it does:** Checks [regex](https://crates.io/crates/regex) creation\n@@ -69,7 +69,7 @@ declare_clippy_lint! {\n #[derive(Clone, Default)]\n pub struct Pass {\n     spans: FxHashSet<Span>,\n-    last: Option<NodeId>,\n+    last: Option<HirId>,\n }\n \n impl LintPass for Pass {\n@@ -102,13 +102,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                               Please use `Regex::new(_)`, which is faster for now.\");\n                     self.spans.insert(span);\n                 }\n-                self.last = Some(block.id);\n+                self.last = Some(block.hir_id);\n             }\n         }\n     }\n \n     fn check_block_post(&mut self, _: &LateContext<'a, 'tcx>, block: &'tcx Block) {\n-        if self.last.map_or(false, |id| block.id == id) {\n+        if self.last.map_or(false, |id| block.hir_id == id) {\n             self.last = None;\n         }\n     }"}, {"sha": "e8f480a22c91443769fcd26c0a026032342ee69d", "filename": "clippy_lints/src/slow_vector_initialization.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/412d41ae86bf90af21676af17e24cf745177d903/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/412d41ae86bf90af21676af17e24cf745177d903/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs?ref=412d41ae86bf90af21676af17e24cf745177d903", "patch": "@@ -6,7 +6,7 @@ use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, Lint, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n-use syntax::ast::{LitKind, NodeId};\n+use syntax::ast::LitKind;\n use syntax_pos::symbol::Symbol;\n \n /// **What it does:** Checks slow zero-filled vector initialization\n@@ -87,7 +87,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                     len_expr: len_arg,\n                 };\n \n-                Self::search_initialization(cx, vi, expr.id);\n+                Self::search_initialization(cx, vi, expr.hir_id);\n             }\n         }\n     }\n@@ -107,7 +107,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                     len_expr: len_arg,\n                 };\n \n-                Self::search_initialization(cx, vi, stmt.id);\n+                Self::search_initialization(cx, vi, stmt.hir_id);\n             }\n         }\n     }\n@@ -132,7 +132,7 @@ impl Pass {\n     }\n \n     /// Search initialization for the given vector\n-    fn search_initialization<'tcx>(cx: &LateContext<'_, 'tcx>, vec_alloc: VecAllocation<'tcx>, parent_node: NodeId) {\n+    fn search_initialization<'tcx>(cx: &LateContext<'_, 'tcx>, vec_alloc: VecAllocation<'tcx>, parent_node: HirId) {\n         let enclosing_body = get_enclosing_block(cx, parent_node);\n \n         if enclosing_body.is_none() {\n@@ -317,7 +317,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VectorInitializationVisitor<'a, 'tcx> {\n \n     fn visit_expr(&mut self, expr: &'tcx Expr) {\n         // Skip all the expressions previous to the vector initialization\n-        if self.vec_alloc.allocation_expr.id == expr.id {\n+        if self.vec_alloc.allocation_expr.hir_id == expr.hir_id {\n             self.initialization_found = true;\n         }\n "}, {"sha": "ba085396e7aec2a99a6292c0302077ad436d1108", "filename": "clippy_lints/src/strings.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/412d41ae86bf90af21676af17e24cf745177d903/clippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/412d41ae86bf90af21676af17e24cf745177d903/clippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstrings.rs?ref=412d41ae86bf90af21676af17e24cf745177d903", "patch": "@@ -96,7 +96,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StringAdd {\n         ) = e.node\n         {\n             if is_string(cx, left) {\n-                if !is_allowed(cx, STRING_ADD_ASSIGN, e.id) {\n+                if !is_allowed(cx, STRING_ADD_ASSIGN, e.hir_id) {\n                     let parent = get_parent_expr(cx, e);\n                     if let Some(p) = parent {\n                         if let ExprKind::Assign(ref target, _) = p.node {"}, {"sha": "135ffd772db31202c7d0364c80298b80fe65916f", "filename": "clippy_lints/src/suspicious_trait_impl.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/412d41ae86bf90af21676af17e24cf745177d903/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/412d41ae86bf90af21676af17e24cf745177d903/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs?ref=412d41ae86bf90af21676af17e24cf745177d903", "patch": "@@ -4,7 +4,6 @@ use rustc::hir;\n use rustc::hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n-use syntax::ast;\n \n /// **What it does:** Lints for suspicious operations in impls of arithmetic operators, e.g.\n /// subtracting elements in an Add impl.\n@@ -77,17 +76,17 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for SuspiciousImpl {\n             }\n             // Check if the binary expression is part of another bi/unary expression\n             // as a child node\n-            let mut parent_expr = cx.tcx.hir().get_parent_node(expr.id);\n-            while parent_expr != ast::CRATE_NODE_ID {\n-                if let hir::Node::Expr(e) = cx.tcx.hir().get(parent_expr) {\n+            let mut parent_expr = cx.tcx.hir().get_parent_node_by_hir_id(expr.hir_id);\n+            while parent_expr != hir::CRATE_HIR_ID {\n+                if let hir::Node::Expr(e) = cx.tcx.hir().get_by_hir_id(parent_expr) {\n                     match e.node {\n                         hir::ExprKind::Binary(..)\n                         | hir::ExprKind::Unary(hir::UnOp::UnNot, _)\n                         | hir::ExprKind::Unary(hir::UnOp::UnNeg, _) => return,\n                         _ => {},\n                     }\n                 }\n-                parent_expr = cx.tcx.hir().get_parent_node(parent_expr);\n+                parent_expr = cx.tcx.hir().get_parent_node_by_hir_id(parent_expr);\n             }\n             // as a parent node\n             let mut visitor = BinaryExprVisitor { in_binary_expr: false };\n@@ -177,12 +176,12 @@ fn check_binop<'a>(\n     }\n \n     // Get the actually implemented trait\n-    let parent_fn = cx.tcx.hir().get_parent(expr.id);\n-    let parent_impl = cx.tcx.hir().get_parent(parent_fn);\n+    let parent_fn = cx.tcx.hir().get_parent_item(expr.hir_id);\n+    let parent_impl = cx.tcx.hir().get_parent_item(parent_fn);\n \n     if_chain! {\n-        if parent_impl != ast::CRATE_NODE_ID;\n-        if let hir::Node::Item(item) = cx.tcx.hir().get(parent_impl);\n+        if parent_impl != hir::CRATE_HIR_ID;\n+        if let hir::Node::Item(item) = cx.tcx.hir().get_by_hir_id(parent_impl);\n         if let hir::ItemKind::Impl(_, _, _, _, Some(ref trait_ref), _, _) = item.node;\n         if let Some(idx) = trait_ids.iter().position(|&tid| tid == trait_ref.path.def.def_id());\n         if binop != expected_ops[idx];"}, {"sha": "7356f957d3111e1dea3dfa78456134e75c2573b7", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/412d41ae86bf90af21676af17e24cf745177d903/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/412d41ae86bf90af21676af17e24cf745177d903/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=412d41ae86bf90af21676af17e24cf745177d903", "patch": "@@ -225,7 +225,7 @@ fn match_type_parameter(cx: &LateContext<'_, '_>, qpath: &QPath, path: &[&str])\n             _ => None,\n         });\n         if let TyKind::Path(ref qpath) = ty.node;\n-        if let Some(did) = opt_def_id(cx.tables.qpath_def(qpath, cx.tcx.hir().node_to_hir_id(ty.id)));\n+        if let Some(did) = opt_def_id(cx.tables.qpath_def(qpath, ty.hir_id));\n         if match_def_path(cx.tcx, did, path);\n         then {\n             return true;\n@@ -246,7 +246,7 @@ fn check_ty(cx: &LateContext<'_, '_>, hir_ty: &hir::Ty, is_local: bool) {\n     }\n     match hir_ty.node {\n         TyKind::Path(ref qpath) if !is_local => {\n-            let hir_id = cx.tcx.hir().node_to_hir_id(hir_ty.id);\n+            let hir_id = hir_ty.hir_id;\n             let def = cx.tables.qpath_def(qpath, hir_id);\n             if let Some(def_id) = opt_def_id(def) {\n                 if Some(def_id) == cx.tcx.lang_items().owned_box() {\n@@ -375,7 +375,7 @@ fn check_ty(cx: &LateContext<'_, '_>, hir_ty: &hir::Ty, is_local: bool) {\n fn check_ty_rptr(cx: &LateContext<'_, '_>, hir_ty: &hir::Ty, is_local: bool, lt: &Lifetime, mut_ty: &MutTy) {\n     match mut_ty.ty.node {\n         TyKind::Path(ref qpath) => {\n-            let hir_id = cx.tcx.hir().node_to_hir_id(mut_ty.ty.id);\n+            let hir_id = mut_ty.ty.hir_id;\n             let def = cx.tables.qpath_def(qpath, hir_id);\n             if_chain! {\n                 if let Some(def_id) = opt_def_id(def);\n@@ -617,7 +617,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnitArg {\n         }\n         if_chain! {\n             let map = &cx.tcx.hir();\n-            let opt_parent_node = map.find(map.get_parent_node(expr.id));\n+            let opt_parent_node = map.find_by_hir_id(map.get_parent_node_by_hir_id(expr.hir_id));\n             if let Some(hir::Node::Expr(parent_expr)) = opt_parent_node;\n             if is_questionmark_desugar_marked_call(parent_expr);\n             then {\n@@ -961,7 +961,7 @@ fn should_strip_parens(op: &Expr, snip: &str) -> bool {\n \n fn span_lossless_lint(cx: &LateContext<'_, '_>, expr: &Expr, op: &Expr, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n     // Do not suggest using From in consts/statics until it is valid to do so (see #2267).\n-    if in_constant(cx, expr.id) {\n+    if in_constant(cx, expr.hir_id) {\n         return;\n     }\n     // The suggestion is to use a function call, so if the original expression"}, {"sha": "c31a8aebc351b6242eda73fab04fbc6a26abe194", "filename": "clippy_lints/src/unicode.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/412d41ae86bf90af21676af17e24cf745177d903/clippy_lints%2Fsrc%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/412d41ae86bf90af21676af17e24cf745177d903/clippy_lints%2Fsrc%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funicode.rs?ref=412d41ae86bf90af21676af17e24cf745177d903", "patch": "@@ -2,7 +2,7 @@ use crate::utils::{is_allowed, snippet, span_help_and_lint};\n use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n-use syntax::ast::{LitKind, NodeId};\n+use syntax::ast::LitKind;\n use syntax::source_map::Span;\n use unicode_normalization::UnicodeNormalization;\n \n@@ -75,7 +75,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Unicode {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if let ExprKind::Lit(ref lit) = expr.node {\n             if let LitKind::Str(_, _) = lit.node {\n-                check_str(cx, lit.span, expr.id)\n+                check_str(cx, lit.span, expr.hir_id)\n             }\n         }\n     }\n@@ -95,7 +95,7 @@ fn escape<T: Iterator<Item = char>>(s: T) -> String {\n     result\n }\n \n-fn check_str(cx: &LateContext<'_, '_>, span: Span, id: NodeId) {\n+fn check_str(cx: &LateContext<'_, '_>, span: Span, id: HirId) {\n     let string = snippet(cx, span, \"\");\n     if string.contains('\\u{200B}') {\n         span_help_and_lint("}, {"sha": "5aaf2f9f7cc704da2a189ab6970ca20b01296dd2", "filename": "clippy_lints/src/utils/diagnostics.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/412d41ae86bf90af21676af17e24cf745177d903/clippy_lints%2Fsrc%2Futils%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/412d41ae86bf90af21676af17e24cf745177d903/clippy_lints%2Fsrc%2Futils%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fdiagnostics.rs?ref=412d41ae86bf90af21676af17e24cf745177d903", "patch": "@@ -1,6 +1,6 @@\n //! Clippy wrappers around rustc's diagnostic functions.\n \n-use crate::reexport::*;\n+use rustc::hir::HirId;\n use rustc::lint::{LateContext, Lint, LintContext};\n use rustc_errors::{Applicability, CodeSuggestion, Substitution, SubstitutionPart, SuggestionStyle};\n use std::env;\n@@ -134,19 +134,21 @@ pub fn span_lint_and_then<'a, 'tcx: 'a, T: LintContext<'tcx>, F>(\n     db.docs_link(lint);\n }\n \n-pub fn span_lint_node(cx: &LateContext<'_, '_>, lint: &'static Lint, node: NodeId, sp: Span, msg: &str) {\n-    DiagnosticWrapper(cx.tcx.struct_span_lint_node(lint, node, sp, msg)).docs_link(lint);\n+pub fn span_lint_node(cx: &LateContext<'_, '_>, lint: &'static Lint, node: HirId, sp: Span, msg: &str) {\n+    let node_id = cx.tcx.hir().hir_to_node_id(node);\n+    DiagnosticWrapper(cx.tcx.struct_span_lint_node(lint, node_id, sp, msg)).docs_link(lint);\n }\n \n pub fn span_lint_node_and_then(\n     cx: &LateContext<'_, '_>,\n     lint: &'static Lint,\n-    node: NodeId,\n+    node: HirId,\n     sp: Span,\n     msg: &str,\n     f: impl FnOnce(&mut DiagnosticBuilder<'_>),\n ) {\n-    let mut db = DiagnosticWrapper(cx.tcx.struct_span_lint_node(lint, node, sp, msg));\n+    let node_id = cx.tcx.hir().hir_to_node_id(node);\n+    let mut db = DiagnosticWrapper(cx.tcx.struct_span_lint_node(lint, node_id, sp, msg));\n     f(&mut db.0);\n     db.docs_link(lint);\n }"}, {"sha": "ee148ce35588ff9831bff6f4895461af9a93f9a2", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/412d41ae86bf90af21676af17e24cf745177d903/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/412d41ae86bf90af21676af17e24cf745177d903/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=412d41ae86bf90af21676af17e24cf745177d903", "patch": "@@ -62,9 +62,9 @@ pub fn differing_macro_contexts(lhs: Span, rhs: Span) -> bool {\n ///     // Do something\n /// }\n /// ```\n-pub fn in_constant(cx: &LateContext<'_, '_>, id: NodeId) -> bool {\n-    let parent_id = cx.tcx.hir().get_parent(id);\n-    match cx.tcx.hir().get(parent_id) {\n+pub fn in_constant(cx: &LateContext<'_, '_>, id: HirId) -> bool {\n+    let parent_id = cx.tcx.hir().get_parent_item(id);\n+    match cx.tcx.hir().get_by_hir_id(parent_id) {\n         Node::Item(&Item {\n             node: ItemKind::Const(..),\n             ..\n@@ -378,8 +378,8 @@ pub fn is_entrypoint_fn(cx: &LateContext<'_, '_>, def_id: DefId) -> bool {\n \n /// Get the name of the item the expression is in, if available.\n pub fn get_item_name(cx: &LateContext<'_, '_>, expr: &Expr) -> Option<Name> {\n-    let parent_id = cx.tcx.hir().get_parent(expr.id);\n-    match cx.tcx.hir().find(parent_id) {\n+    let parent_id = cx.tcx.hir().get_parent_item(expr.hir_id);\n+    match cx.tcx.hir().find_by_hir_id(parent_id) {\n         Some(Node::Item(&Item { ref ident, .. })) => Some(ident.name),\n         Some(Node::TraitItem(&TraitItem { ident, .. })) | Some(Node::ImplItem(&ImplItem { ident, .. })) => {\n             Some(ident.name)\n@@ -571,12 +571,12 @@ fn trim_multiline_inner(s: Cow<'_, str>, ignore_first: bool, ch: char) -> Cow<'_\n /// Get a parent expressions if any \u2013 this is useful to constrain a lint.\n pub fn get_parent_expr<'c>(cx: &'c LateContext<'_, '_>, e: &Expr) -> Option<&'c Expr> {\n     let map = &cx.tcx.hir();\n-    let node_id: NodeId = e.id;\n-    let parent_id: NodeId = map.get_parent_node(node_id);\n-    if node_id == parent_id {\n+    let hir_id = e.hir_id;\n+    let parent_id = map.get_parent_node_by_hir_id(hir_id);\n+    if hir_id == parent_id {\n         return None;\n     }\n-    map.find(parent_id).and_then(|node| {\n+    map.find_by_hir_id(parent_id).and_then(|node| {\n         if let Node::Expr(parent) = node {\n             Some(parent)\n         } else {\n@@ -585,10 +585,11 @@ pub fn get_parent_expr<'c>(cx: &'c LateContext<'_, '_>, e: &Expr) -> Option<&'c\n     })\n }\n \n-pub fn get_enclosing_block<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, node: NodeId) -> Option<&'tcx Block> {\n+pub fn get_enclosing_block<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, node: HirId) -> Option<&'tcx Block> {\n     let map = &cx.tcx.hir();\n+    let node_id = map.hir_to_node_id(node);\n     let enclosing_node = map\n-        .get_enclosing_scope(node)\n+        .get_enclosing_scope(node_id)\n         .and_then(|enclosing_id| map.find(enclosing_id));\n     if let Some(node) = enclosing_node {\n         match node {\n@@ -927,8 +928,9 @@ pub fn is_try(expr: &Expr) -> Option<&Expr> {\n /// Returns true if the lint is allowed in the current context\n ///\n /// Useful for skipping long running code when it's unnecessary\n-pub fn is_allowed(cx: &LateContext<'_, '_>, lint: &'static Lint, id: NodeId) -> bool {\n-    cx.tcx.lint_level_at_node(lint, id).0 == Level::Allow\n+pub fn is_allowed(cx: &LateContext<'_, '_>, lint: &'static Lint, id: HirId) -> bool {\n+    let node_id = cx.tcx.hir().hir_to_node_id(id);\n+    cx.tcx.lint_level_at_node(lint, node_id).0 == Level::Allow\n }\n \n pub fn get_arg_name(pat: &Pat) -> Option<ast::Name> {\n@@ -1001,16 +1003,16 @@ pub fn without_block_comments(lines: Vec<&str>) -> Vec<&str> {\n     without\n }\n \n-pub fn any_parent_is_automatically_derived(tcx: TyCtxt<'_, '_, '_>, node: NodeId) -> bool {\n+pub fn any_parent_is_automatically_derived(tcx: TyCtxt<'_, '_, '_>, node: HirId) -> bool {\n     let map = &tcx.hir();\n     let mut prev_enclosing_node = None;\n     let mut enclosing_node = node;\n     while Some(enclosing_node) != prev_enclosing_node {\n-        if is_automatically_derived(map.attrs(enclosing_node)) {\n+        if is_automatically_derived(map.attrs_by_hir_id(enclosing_node)) {\n             return true;\n         }\n         prev_enclosing_node = Some(enclosing_node);\n-        enclosing_node = map.get_parent(enclosing_node);\n+        enclosing_node = map.get_parent_item(enclosing_node);\n     }\n     false\n }"}, {"sha": "1f649829f810c772cf89fa3b2d88eb2a979b1fea", "filename": "clippy_lints/src/utils/usage.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/412d41ae86bf90af21676af17e24cf745177d903/clippy_lints%2Fsrc%2Futils%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/412d41ae86bf90af21676af17e24cf745177d903/clippy_lints%2Fsrc%2Futils%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fusage.rs?ref=412d41ae86bf90af21676af17e24cf745177d903", "patch": "@@ -63,19 +63,19 @@ impl<'tcx> MutVarsDelegate {\n }\n \n impl<'tcx> Delegate<'tcx> for MutVarsDelegate {\n-    fn consume(&mut self, _: NodeId, _: Span, _: &cmt_<'tcx>, _: ConsumeMode) {}\n+    fn consume(&mut self, _: HirId, _: Span, _: &cmt_<'tcx>, _: ConsumeMode) {}\n \n     fn matched_pat(&mut self, _: &Pat, _: &cmt_<'tcx>, _: MatchMode) {}\n \n     fn consume_pat(&mut self, _: &Pat, _: &cmt_<'tcx>, _: ConsumeMode) {}\n \n-    fn borrow(&mut self, _: NodeId, _: Span, cmt: &cmt_<'tcx>, _: ty::Region<'_>, bk: ty::BorrowKind, _: LoanCause) {\n+    fn borrow(&mut self, _: HirId, _: Span, cmt: &cmt_<'tcx>, _: ty::Region<'_>, bk: ty::BorrowKind, _: LoanCause) {\n         if let ty::BorrowKind::MutBorrow = bk {\n             self.update(&cmt.cat)\n         }\n     }\n \n-    fn mutate(&mut self, _: NodeId, _: Span, cmt: &cmt_<'tcx>, _: MutateMode) {\n+    fn mutate(&mut self, _: HirId, _: Span, cmt: &cmt_<'tcx>, _: MutateMode) {\n         self.update(&cmt.cat)\n     }\n "}]}