{"sha": "982a1a47830ae0419db620374ffe2f0e018843cf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4MmExYTQ3ODMwYWUwNDE5ZGI2MjAzNzRmZmUyZjBlMDE4ODQzY2Y=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-12T12:24:12Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-12T12:24:46Z"}, "message": "Rename alias to reference in docs and error messages\n\nUpdate docs to reflect new approach to aliases", "tree": {"sha": "024f648228736efe4b3937bbc930c22fbff45141", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/024f648228736efe4b3937bbc930c22fbff45141"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/982a1a47830ae0419db620374ffe2f0e018843cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/982a1a47830ae0419db620374ffe2f0e018843cf", "html_url": "https://github.com/rust-lang/rust/commit/982a1a47830ae0419db620374ffe2f0e018843cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/982a1a47830ae0419db620374ffe2f0e018843cf/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bcf60c66004f2bbea5bc4d618e4ee2fbc0f13423", "url": "https://api.github.com/repos/rust-lang/rust/commits/bcf60c66004f2bbea5bc4d618e4ee2fbc0f13423", "html_url": "https://github.com/rust-lang/rust/commit/bcf60c66004f2bbea5bc4d618e4ee2fbc0f13423"}], "stats": {"total": 96, "additions": 45, "deletions": 51}, "files": [{"sha": "175552bc42ff06d72da25cf86515002ce2b92dd4", "filename": "doc/rust.texi", "status": "modified", "additions": 32, "deletions": 39, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/982a1a47830ae0419db620374ffe2f0e018843cf/doc%2Frust.texi", "raw_url": "https://github.com/rust-lang/rust/raw/982a1a47830ae0419db620374ffe2f0e018843cf/doc%2Frust.texi", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.texi?ref=982a1a47830ae0419db620374ffe2f0e018843cf", "patch": "@@ -253,21 +253,21 @@ way. To allocate such values in the heap, they must be explicitly\n value, its @emph{content}. Boxes may be either shared or unique, depending\n on which sort of storage management is desired.\n \n-Boxing and unboxing in Rust is explicit, though in many cases (arithmetic\n-operations, name-component dereferencing) Rust will automatically ``reach\n-through'' the box to access its content. Box values can be passed and assigned\n+Boxing and unboxing in Rust is explicit, though in many cases (such as\n+name-component dereferencing) Rust will automatically ``reach through'' the\n+box to access its content. Box values can be passed and assigned\n independently, like pointers in C; the difference is that in Rust they always\n point to live contents, and are not subject to pointer arithmetic.\n \n-In addition to boxes, Rust supports a kind of pass-by-reference slot called an\n-alias. Forming or releasing an alias does not perform reference-count\n-operations; aliases can only be formed on referents that will provably outlive\n-the alias, and are therefore only used for passing arguments to\n-functions. Aliases are not ``general values'', in the sense that they cannot\n-be independently manipulated. They are more like C++ references, except that\n-like boxes, aliases are safe: they always point to live values.\n+In addition to boxes, Rust supports a kind of pass-by-pointer slot called a\n+reference. Forming or releasing a reference does not perform reference-count\n+operations; references can only be formed on values that will provably outlive\n+the reference. References are not ``general values'', in the sense that they\n+cannot be independently manipulated. They are a lot like C++'s references,\n+except that they are safe: the compiler ensures that they always point to live\n+values.\n \n-In addition, every slot (stack-local allocation or alias) has a static\n+In addition, every slot (stack-local allocation or reference) has a static\n initialization state that is calculated by the typestate system. This permits\n late initialization of slots in functions with complex control-flow, while\n still guaranteeing that every use of a slot occurs after it has been\n@@ -1283,7 +1283,7 @@ references to any boxes.\n @cindex Stack\n @cindex Slot\n @cindex Local slot\n-@cindex Alias slot\n+@cindex Reference slot\n \n A task's stack contains slots.\n \n@@ -1293,10 +1293,9 @@ an @emph{alias}.\n A @dfn{local} slot (or @emph{stack-local} allocation) holds a value directly,\n allocated within the stack's memory. The value is a part of the stack frame.\n \n-An @dfn{alias} references a value outside the frame. An alias may refer to a\n+A @dfn{reference} references a value outside the frame. It may refer to a\n value allocated in another frame @emph{or} a boxed value in the heap. The\n-alias-formation rules ensure that the referent of an alias will outlive the\n-alias.\n+reference-formation rules ensure that the referent will outlive the reference.\n \n Local slots are always implicitly mutable.\n \n@@ -1306,24 +1305,18 @@ state. Subsequent statements within a function may or may not initialize the\n local slots. Local slots can only be used after they have been initialized;\n this condition is guaranteed by the typestate system.\n \n-Aliases can @emph{only} be declared as arguments in a function or iterator\n-signature, bound to the lifetime of a stack frame. Aliases are not general\n-values and cannot be held in boxed allocations or other general data types.\n+References are created for function arguments. If the compiler can not prove\n+that the referred-to value will outlive the reference, it will try to set\n+aside a copy of that value to refer to. If this is not sematically safe (for\n+example, if the referred-to value contains mutable fields), it reject the\n+program. If the compiler deems copying the value expensive, it will warn.\n \n-Alias slots are indicated by the @emph{ampersand} sigil @code{&}.\n+A function can be declared to take an argument by mutable reference. This\n+allows the function to write to the slot that the reference refers to.\n \n-An example function that accepts an alias parameter:\n+An example function that accepts an value by mutable reference:\n @example\n-type point3d = @{x: int, y: int, z: int@};\n-\n-fn extract_z(p: &point3d) -> int @{\n-    ret p.z;\n-@}\n-@end example\n-\n-An example function that accepts an alias to a mutable value:\n-@example\n-fn incr(i: &mutable int) @{\n+fn incr(&i: int) @{\n     i = i + 1;\n @}\n @end example\n@@ -1912,9 +1905,9 @@ pure fn lt_42(x: int) -> bool @{\n A non-boolean function may also be declared with @code{pure fn}. This allows\n predicates to call non-boolean functions as long as they are pure. For example:\n @example\n-pure fn pure_length<@@T>(ls: &list<T>) -> uint @{ /* ... */ @}\n+pure fn pure_length<@@T>(ls: list<T>) -> uint @{ /* ... */ @}\n \n-pure fn nonempty_list<@@T>(ls: &list<T>) -> bool @{ pure_length(ls) > 0u @}\n+pure fn nonempty_list<@@T>(ls: list<T>) -> bool @{ pure_length(ls) > 0u @}\n @end example\n \n In this example, @code{nonempty_list} is a predicate---it can be used in a\n@@ -1941,15 +1934,15 @@ obligation to verify the semantics of the predicates they write.\n \n An example of a predicate that uses an unchecked block:\n @example\n-fn pure_foldl<@@T, @@U>(ls: &list<T>, u: &U, f: &block(&T, &U) -> U) -> U @{\n+fn pure_foldl<@@T, @@U>(ls: list<T>, u: U, f: block(&T, &U) -> U) -> U @{\n     alt ls @{\n       nil. @{ u @}\n       cons(hd, tl) @{ f(hd, pure_foldl(*tl, f(hd, u), f)) @}\n     @}\n @}\n \n-pure fn pure_length<@@T>(ls: &list<T>) -> uint @{\n-    fn count<T>(_t: &T, u: &uint) -> uint @{ u + 1u @}\n+pure fn pure_length<@@T>(ls: list<T>) -> uint @{\n+    fn count<T>(_t: T, u: uint) -> uint @{ u + 1u @}\n     unchecked @{\n         pure_foldl(ls, 0u, count)\n     @}\n@@ -2280,7 +2273,7 @@ The primitive types are the following:\n @item\n The ``nil'' type @code{()}, having the single ``nil'' value\n @code{()}.@footnote{The ``nil'' value @code{()} is @emph{not} a sentinel\n-``null pointer'' value for alias slots; the ``nil'' type is the implicit\n+``null pointer'' value for reference slots; the ``nil'' type is the implicit\n return type from functions otherwise lacking a return type, and can be used in\n other contexts (such as message-sending or type-parametric code) as a\n zero-size type.}\n@@ -3062,7 +3055,7 @@ x.y = z + 2;\n @cindex Function calls\n \n A @dfn{call expression} invokes a function, providing a tuple of input slots\n-and an alias slot to serve as the function's output, bound to the @var{lval}\n+and an reference slot to serve as the function's output, bound to the @var{lval}\n on the right hand side of the call. If the function eventually returns, then\n the expression completes.\n \n@@ -3247,7 +3240,7 @@ diagnostic buffer.\n \n An example of a @code{note} expression:\n @example\n-fn read_file_lines(path: &str) -> [str] @{\n+fn read_file_lines(path: str) -> [str] @{\n     note path;\n     let r: [str];\n     let f: file = open_read(path);\n@@ -3541,7 +3534,7 @@ and statically comparing implied states and their\n specifications. @xref{Ref.Typestate}.\n \n @example\n-pure fn even(x: &int) -> bool @{\n+pure fn even(x: int) -> bool @{\n     ret x & 1 == 0;\n @}\n "}, {"sha": "602554cb0d0a3c7ca029cf393e077763376e37b2", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/982a1a47830ae0419db620374ffe2f0e018843cf/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/982a1a47830ae0419db620374ffe2f0e018843cf/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=982a1a47830ae0419db620374ffe2f0e018843cf", "patch": "@@ -266,9 +266,10 @@ fn check_call(cx: ctx, f: @ast::expr, args: [@ast::expr], sc: scope) ->\n                 alt r.root_var {\n                   some(root) {\n                     if node == root && cant_copy(cx, r) {\n-                        cx.tcx.sess.span_err(args[arg].span,\n-                                             \"passing a mutable alias to a \\\n-                            variable that roots another alias\");\n+                        cx.tcx.sess.span_err\n+                            (args[arg].span,\n+                             \"passing a mutable reference to a \\\n+                              variable that roots another reference\");\n                         break;\n                     }\n                   }\n@@ -415,7 +416,7 @@ fn test_scope(cx: ctx, sc: scope, r: restrict, p: ast::path) {\n               }\n             };\n         cx.tcx.sess.span_err(msg.span,\n-                             msg.msg + \" will invalidate alias \" +\n+                             msg.msg + \" will invalidate reference \" +\n                                  ast_util::path_name(p) +\n                                  \", which is still used\");\n     }"}, {"sha": "2aa3ddc66c8b4e3ee1d728ff5c128d14d4f8f3e9", "filename": "src/comp/middle/mut.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/982a1a47830ae0419db620374ffe2f0e018843cf/src%2Fcomp%2Fmiddle%2Fmut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/982a1a47830ae0419db620374ffe2f0e018843cf/src%2Fcomp%2Fmiddle%2Fmut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmut.rs?ref=982a1a47830ae0419db620374ffe2f0e018843cf", "patch": "@@ -130,15 +130,15 @@ fn check_crate(tcx: ty::ctxt, crate: @crate) -> mut_map {\n     ret cx.mut_map;\n }\n \n-tag msg { msg_assign; msg_move_out; msg_mut_alias; }\n+tag msg { msg_assign; msg_move_out; msg_mut_ref; }\n \n fn mk_err(cx: @ctx, span: syntax::codemap::span, msg: msg, name: str) {\n     cx.tcx.sess.span_err(span,\n                          alt msg {\n                            msg_assign. { \"assigning to \" + name }\n                            msg_move_out. { \"moving out of \" + name }\n-                           msg_mut_alias. {\n-                             \"passing \" + name + \" by mutable alias\"\n+                           msg_mut_ref. {\n+                             \"passing \" + name + \" by mutable reference\"\n                            }\n                          });\n }\n@@ -234,7 +234,7 @@ fn check_call(cx: @ctx, f: @expr, args: [@expr]) {\n                        ty::type_autoderef(cx.tcx, ty::expr_ty(cx.tcx, f)));\n     let i = 0u;\n     for arg_t: ty::arg in arg_ts {\n-        if arg_t.mode != by_ref { check_lval(cx, args[i], msg_mut_alias); }\n+        if arg_t.mode != by_ref { check_lval(cx, args[i], msg_mut_ref); }\n         i += 1u;\n     }\n }"}, {"sha": "9f28c6190efb0478f3844cd1b9bdf8ed7de3d30d", "filename": "src/test/compile-fail/unsafe-alias-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/982a1a47830ae0419db620374ffe2f0e018843cf/src%2Ftest%2Fcompile-fail%2Funsafe-alias-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/982a1a47830ae0419db620374ffe2f0e018843cf/src%2Ftest%2Fcompile-fail%2Funsafe-alias-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-alias-2.rs?ref=982a1a47830ae0419db620374ffe2f0e018843cf", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern:invalidate alias x\n+// error-pattern:invalidate reference x\n \n fn whoknows(x: @mutable int) { *x = 10; }\n "}, {"sha": "b83147715614aa28f9b2cc69c740e48253c1410f", "filename": "src/test/compile-fail/unsafe-alt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/982a1a47830ae0419db620374ffe2f0e018843cf/src%2Ftest%2Fcompile-fail%2Funsafe-alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/982a1a47830ae0419db620374ffe2f0e018843cf/src%2Ftest%2Fcompile-fail%2Funsafe-alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-alt.rs?ref=982a1a47830ae0419db620374ffe2f0e018843cf", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern:invalidate alias i\n+// error-pattern:invalidate reference i\n \n tag foo { left(int); right(bool); }\n "}, {"sha": "cac88b410c757bf5b42ac3a393773007e8902a49", "filename": "src/test/compile-fail/unsafe-for.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/982a1a47830ae0419db620374ffe2f0e018843cf/src%2Ftest%2Fcompile-fail%2Funsafe-for.rs", "raw_url": "https://github.com/rust-lang/rust/raw/982a1a47830ae0419db620374ffe2f0e018843cf/src%2Ftest%2Fcompile-fail%2Funsafe-for.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-for.rs?ref=982a1a47830ae0419db620374ffe2f0e018843cf", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern:invalidate alias x\n+// error-pattern:invalidate reference x\n \n fn main() {\n     let v: [mutable int] = [mutable 1, 2, 3];"}, {"sha": "f6b52bef34b4c21bccd6f8090659e6a6694c1105", "filename": "src/test/compile-fail/unsafe-mutable-alias.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/982a1a47830ae0419db620374ffe2f0e018843cf/src%2Ftest%2Fcompile-fail%2Funsafe-mutable-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/982a1a47830ae0419db620374ffe2f0e018843cf/src%2Ftest%2Fcompile-fail%2Funsafe-mutable-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-mutable-alias.rs?ref=982a1a47830ae0419db620374ffe2f0e018843cf", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern:mutable alias to a variable that roots another alias\n+// error-pattern:mutable reference to a variable that roots another reference\n \n fn f(a: {mutable x: int}, &b: {mutable x: int}) -> int {\n     b.x += 1;"}]}