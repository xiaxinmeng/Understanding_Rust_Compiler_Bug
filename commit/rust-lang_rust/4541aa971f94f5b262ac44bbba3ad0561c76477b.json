{"sha": "4541aa971f94f5b262ac44bbba3ad0561c76477b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1NDFhYTk3MWY5NGY1YjI2MmFjNDRiYmJhM2FkMDU2MWM3NjQ3N2I=", "commit": {"author": {"name": "Alexis Bourget", "email": "alexis.bourget@gmail.com", "date": "2021-07-14T13:31:12Z"}, "committer": {"name": "Alexis Bourget", "email": "alexis.bourget@gmail.com", "date": "2021-07-14T13:31:12Z"}, "message": "Add safety comments in private core::slice::rotate::ptr_rotate function", "tree": {"sha": "fd4df71305d9a5b296276847c48ee9d4be56287e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fd4df71305d9a5b296276847c48ee9d4be56287e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4541aa971f94f5b262ac44bbba3ad0561c76477b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4541aa971f94f5b262ac44bbba3ad0561c76477b", "html_url": "https://github.com/rust-lang/rust/commit/4541aa971f94f5b262ac44bbba3ad0561c76477b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4541aa971f94f5b262ac44bbba3ad0561c76477b/comments", "author": {"login": "poliorcetics", "id": 7951708, "node_id": "MDQ6VXNlcjc5NTE3MDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7951708?v=4", "gravatar_id": "", "url": "https://api.github.com/users/poliorcetics", "html_url": "https://github.com/poliorcetics", "followers_url": "https://api.github.com/users/poliorcetics/followers", "following_url": "https://api.github.com/users/poliorcetics/following{/other_user}", "gists_url": "https://api.github.com/users/poliorcetics/gists{/gist_id}", "starred_url": "https://api.github.com/users/poliorcetics/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/poliorcetics/subscriptions", "organizations_url": "https://api.github.com/users/poliorcetics/orgs", "repos_url": "https://api.github.com/users/poliorcetics/repos", "events_url": "https://api.github.com/users/poliorcetics/events{/privacy}", "received_events_url": "https://api.github.com/users/poliorcetics/received_events", "type": "User", "site_admin": false}, "committer": {"login": "poliorcetics", "id": 7951708, "node_id": "MDQ6VXNlcjc5NTE3MDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7951708?v=4", "gravatar_id": "", "url": "https://api.github.com/users/poliorcetics", "html_url": "https://github.com/poliorcetics", "followers_url": "https://api.github.com/users/poliorcetics/followers", "following_url": "https://api.github.com/users/poliorcetics/following{/other_user}", "gists_url": "https://api.github.com/users/poliorcetics/gists{/gist_id}", "starred_url": "https://api.github.com/users/poliorcetics/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/poliorcetics/subscriptions", "organizations_url": "https://api.github.com/users/poliorcetics/orgs", "repos_url": "https://api.github.com/users/poliorcetics/repos", "events_url": "https://api.github.com/users/poliorcetics/events{/privacy}", "received_events_url": "https://api.github.com/users/poliorcetics/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a08f25a7ef2800af5525762e981c24d96c14febe", "url": "https://api.github.com/repos/rust-lang/rust/commits/a08f25a7ef2800af5525762e981c24d96c14febe", "html_url": "https://github.com/rust-lang/rust/commit/a08f25a7ef2800af5525762e981c24d96c14febe"}], "stats": {"total": 56, "additions": 54, "deletions": 2}, "files": [{"sha": "7528927ef33b9a57297f8330e323856cd518a5bb", "filename": "library/core/src/slice/rotate.rs", "status": "modified", "additions": 54, "deletions": 2, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/4541aa971f94f5b262ac44bbba3ad0561c76477b/library%2Fcore%2Fsrc%2Fslice%2Frotate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4541aa971f94f5b262ac44bbba3ad0561c76477b/library%2Fcore%2Fsrc%2Fslice%2Frotate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Frotate.rs?ref=4541aa971f94f5b262ac44bbba3ad0561c76477b", "patch": "@@ -1,5 +1,3 @@\n-// ignore-tidy-undocumented-unsafe\n-\n use crate::cmp;\n use crate::mem::{self, MaybeUninit};\n use crate::ptr;\n@@ -79,8 +77,10 @@ pub unsafe fn ptr_rotate<T>(mut left: usize, mut mid: *mut T, mut right: usize)\n             // the way until about `left + right == 32`, but the worst case performance breaks even\n             // around 16. 24 was chosen as middle ground. If the size of `T` is larger than 4\n             // `usize`s, this algorithm also outperforms other algorithms.\n+            // SAFETY: callers must ensure `mid - left` is valid for reading and writing.\n             let x = unsafe { mid.sub(left) };\n             // beginning of first round\n+            // SAFETY: see previous comment.\n             let mut tmp: T = unsafe { x.read() };\n             let mut i = right;\n             // `gcd` can be found before hand by calculating `gcd(left + right, right)`,\n@@ -92,6 +92,21 @@ pub unsafe fn ptr_rotate<T>(mut left: usize, mut mid: *mut T, mut right: usize)\n             // the very end. This is possibly due to the fact that swapping or replacing temporaries\n             // uses only one memory address in the loop instead of needing to manage two.\n             loop {\n+                // [long-safety-expl]\n+                // SAFETY: callers must ensure `[left, left+mid+right)` are all valid for reading and\n+                // writing.\n+                //\n+                // - `i` start with `right` so `mid-left <= x+i = x+right = mid-left+right < mid+right`\n+                // - `i <= left+right-1` is always true\n+                //   - if `i < left`, `right` is added so `i < left+right` and on the next\n+                //     iteration `left` is removed from `i` so it doesn't go further\n+                //   - if `i >= left`, `left` is removed immediately and so it doesn't go further.\n+                // - overflows cannot happen for `i` since the function's safety contract ask for\n+                //   `mid+right-1 = x+left+right` to be valid for writing\n+                // - underflows cannot happen because `i` must be bigger or equal to `left` for\n+                //   a substraction of `left` to happen.\n+                //\n+                // So `x+i` is valid for reading and writing if the caller respected the contract\n                 tmp = unsafe { x.add(i).replace(tmp) };\n                 // instead of incrementing `i` and then checking if it is outside the bounds, we\n                 // check if `i` will go outside the bounds on the next increment. This prevents\n@@ -100,6 +115,8 @@ pub unsafe fn ptr_rotate<T>(mut left: usize, mut mid: *mut T, mut right: usize)\n                     i -= left;\n                     if i == 0 {\n                         // end of first round\n+                        // SAFETY: tmp has been read from a valid source and x is valid for writing\n+                        // according to the caller.\n                         unsafe { x.write(tmp) };\n                         break;\n                     }\n@@ -113,13 +130,24 @@ pub unsafe fn ptr_rotate<T>(mut left: usize, mut mid: *mut T, mut right: usize)\n             }\n             // finish the chunk with more rounds\n             for start in 1..gcd {\n+                // SAFETY: `gcd` is at most equal to `right` so all values in `1..gcd` are valid for\n+                // reading and writing as per the function's safety contract, see [long-safety-expl]\n+                // above\n                 tmp = unsafe { x.add(start).read() };\n+                // [safety-expl-addition]\n+                //\n+                // Here `start < gcd` so `start < right` so `i < right+right`: `right` being the\n+                // greatest common divisor of `(left+right, right)` means that `left = right` so\n+                // `i < left+right` so `x+i = mid-left+i` is always valid for reading and writing\n+                // according to the function's safety contract.\n                 i = start + right;\n                 loop {\n+                    // SAFETY: see [long-safety-expl] and [safety-expl-addition]\n                     tmp = unsafe { x.add(i).replace(tmp) };\n                     if i >= left {\n                         i -= left;\n                         if i == start {\n+                            // SAFETY: see [long-safety-expl] and [safety-expl-addition]\n                             unsafe { x.add(start).write(tmp) };\n                             break;\n                         }\n@@ -135,14 +163,30 @@ pub unsafe fn ptr_rotate<T>(mut left: usize, mut mid: *mut T, mut right: usize)\n             // The `[T; 0]` here is to ensure this is appropriately aligned for T\n             let mut rawarray = MaybeUninit::<(BufType, [T; 0])>::uninit();\n             let buf = rawarray.as_mut_ptr() as *mut T;\n+            // SAFETY: `mid-left <= mid-left+right < mid+right`\n             let dim = unsafe { mid.sub(left).add(right) };\n             if left <= right {\n+                // SAFETY:\n+                //\n+                // 1) The `else if` condition about the sizes ensures `[mid-left; left]` will fit in\n+                //    `buf` without overflow and `buf` was created just above and so cannot be\n+                //    overlapped with any value of `[mid-left; left]`\n+                // 2) [mid-left, mid+right) are all valid for reading and writing and we don't care\n+                //    about overlaps here.\n+                // 3) The `if` condition about `left <= right` ensures writing `left` elements to\n+                //    `dim = mid-left+right` is valid because:\n+                //    - `buf` is valid and `left` elements were written in it in 1)\n+                //    - `dim+left = mid-left+right+left = mid+right` and we write `[dim, dim+left)`\n                 unsafe {\n+                    // 1)\n                     ptr::copy_nonoverlapping(mid.sub(left), buf, left);\n+                    // 2)\n                     ptr::copy(mid, mid.sub(left), right);\n+                    // 3)\n                     ptr::copy_nonoverlapping(buf, dim, left);\n                 }\n             } else {\n+                // SAFETY: same reasoning as above but with `left` and `right` reversed\n                 unsafe {\n                     ptr::copy_nonoverlapping(mid, buf, right);\n                     ptr::copy(mid.sub(left), dim, left);\n@@ -156,6 +200,10 @@ pub unsafe fn ptr_rotate<T>(mut left: usize, mut mid: *mut T, mut right: usize)\n             // of this algorithm would be, and swapping using that last chunk instead of swapping\n             // adjacent chunks like this algorithm is doing, but this way is still faster.\n             loop {\n+                // SAFETY:\n+                // `left >= right` so `[mid-right, mid+right)` is valid for reading and writing\n+                // Substracting `right` from `mid` each turn is counterbalanced by the addition and\n+                // check after it.\n                 unsafe {\n                     ptr::swap_nonoverlapping(mid.sub(right), mid, right);\n                     mid = mid.sub(right);\n@@ -168,6 +216,10 @@ pub unsafe fn ptr_rotate<T>(mut left: usize, mut mid: *mut T, mut right: usize)\n         } else {\n             // Algorithm 3, `left < right`\n             loop {\n+                // SAFETY: `[mid-left, mid+left)` is valid for reading and writing because\n+                // `left < right` so `mid+left < mid+right`.\n+                // Adding `left` to `mid` each turn is counterbalanced by the substraction and check\n+                // after it.\n                 unsafe {\n                     ptr::swap_nonoverlapping(mid.sub(left), mid, left);\n                     mid = mid.add(left);"}]}