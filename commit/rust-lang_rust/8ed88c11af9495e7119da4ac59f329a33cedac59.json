{"sha": "8ed88c11af9495e7119da4ac59f329a33cedac59", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlZDg4YzExYWY5NDk1ZTcxMTlkYTRhYzU5ZjMyOWEzM2NlZGFjNTk=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-08T17:22:10Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-08T17:22:10Z"}, "message": "rollup merge of #20751: nikomatsakis/issue-20232\n\nIssue #20232. Fun.\n\nr? @eddyb you prob know this system best", "tree": {"sha": "2e892e43837ab4ad5db41de2ef1b16c1970edc48", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2e892e43837ab4ad5db41de2ef1b16c1970edc48"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ed88c11af9495e7119da4ac59f329a33cedac59", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ed88c11af9495e7119da4ac59f329a33cedac59", "html_url": "https://github.com/rust-lang/rust/commit/8ed88c11af9495e7119da4ac59f329a33cedac59", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ed88c11af9495e7119da4ac59f329a33cedac59/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a09aa208ff652d4fad385c7eb6c0e4db0c0e073", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a09aa208ff652d4fad385c7eb6c0e4db0c0e073", "html_url": "https://github.com/rust-lang/rust/commit/6a09aa208ff652d4fad385c7eb6c0e4db0c0e073"}, {"sha": "ba87b540a4521282aa26fee4d3394befee978351", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba87b540a4521282aa26fee4d3394befee978351", "html_url": "https://github.com/rust-lang/rust/commit/ba87b540a4521282aa26fee4d3394befee978351"}], "stats": {"total": 374, "additions": 263, "deletions": 111}, "files": [{"sha": "51ec75284326c4f76f9b790ef99b19cc654b76a4", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 97, "deletions": 39, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/8ed88c11af9495e7119da4ac59f329a33cedac59/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed88c11af9495e7119da4ac59f329a33cedac59/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=8ed88c11af9495e7119da4ac59f329a33cedac59", "patch": "@@ -75,7 +75,7 @@ use middle::def;\n use middle::region;\n use middle::ty::{self, Ty};\n use util::nodemap::{NodeMap};\n-use util::ppaux::{Repr};\n+use util::ppaux::{Repr, UserString};\n \n use syntax::ast::{MutImmutable, MutMutable};\n use syntax::ast;\n@@ -113,10 +113,17 @@ pub struct Upvar {\n // different kinds of pointers:\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Show)]\n pub enum PointerKind {\n+    /// `Box<T>`\n     Unique,\n+\n+    /// `&T`\n     BorrowedPtr(ty::BorrowKind, ty::Region),\n-    Implicit(ty::BorrowKind, ty::Region),     // Implicit deref of a borrowed ptr.\n-    UnsafePtr(ast::Mutability)\n+\n+    /// `*T`\n+    UnsafePtr(ast::Mutability),\n+\n+    /// Implicit deref of the `&T` that results from an overloaded index `[]`.\n+    Implicit(ty::BorrowKind, ty::Region),\n }\n \n // We use the term \"interior\" to mean \"something reachable from the\n@@ -453,7 +460,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                autoderefs,\n                cmt.repr(self.tcx()));\n         for deref in range(1u, autoderefs + 1) {\n-            cmt = try!(self.cat_deref(expr, cmt, deref, false));\n+            cmt = try!(self.cat_deref(expr, cmt, deref));\n         }\n         return Ok(cmt);\n     }\n@@ -465,7 +472,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         match expr.node {\n           ast::ExprUnary(ast::UnDeref, ref e_base) => {\n             let base_cmt = try!(self.cat_expr(&**e_base));\n-            self.cat_deref(expr, base_cmt, 0, false)\n+            self.cat_deref(expr, base_cmt, 0)\n           }\n \n           ast::ExprField(ref base, f_name) => {\n@@ -489,10 +496,23 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                     // If this is an index implemented by a method call, then it\n                     // will include an implicit deref of the result.\n                     let ret_ty = self.overloaded_method_return_ty(method_ty);\n-                    self.cat_deref(expr,\n-                                   self.cat_rvalue_node(expr.id(),\n-                                                        expr.span(),\n-                                                        ret_ty), 1, true)\n+\n+                    // The index method always returns an `&T`, so\n+                    // dereference it to find the result type.\n+                    let elem_ty = match ret_ty.sty {\n+                        ty::ty_rptr(_, mt) => mt.ty,\n+                        _ => {\n+                            debug!(\"cat_expr_unadjusted: return type of overloaded index is {}?\",\n+                                   ret_ty.repr(self.tcx()));\n+                            return Err(());\n+                        }\n+                    };\n+\n+                    // The call to index() returns a `&T` value, which\n+                    // is an rvalue. That is what we will be\n+                    // dereferencing.\n+                    let base_cmt = self.cat_rvalue_node(expr.id(), expr.span(), ret_ty);\n+                    self.cat_deref_common(expr, base_cmt, 1, elem_ty, true)\n                 }\n                 None => {\n                     self.cat_index(expr, try!(self.cat_expr(&**base)))\n@@ -837,8 +857,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n     fn cat_deref<N:ast_node>(&self,\n                              node: &N,\n                              base_cmt: cmt<'tcx>,\n-                             deref_cnt: uint,\n-                             implicit: bool)\n+                             deref_cnt: uint)\n                              -> McResult<cmt<'tcx>> {\n         let adjustment = match self.typer.adjustments().borrow().get(&node.id()) {\n             Some(adj) if ty::adjust_is_object(adj) => ty::AutoObject,\n@@ -866,7 +885,8 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         };\n         let base_cmt_ty = base_cmt.ty;\n         match ty::deref(base_cmt_ty, true) {\n-            Some(mt) => self.cat_deref_common(node, base_cmt, deref_cnt, mt.ty, implicit),\n+            Some(mt) => self.cat_deref_common(node, base_cmt, deref_cnt, mt.ty,\n+                                              /* implicit: */ false),\n             None => {\n                 debug!(\"Explicit deref of non-derefable type: {}\",\n                        base_cmt_ty.repr(self.tcx()));\n@@ -1236,7 +1256,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             // box p1, &p1, &mut p1.  we can ignore the mutability of\n             // PatRegion since that information is already contained\n             // in the type.\n-            let subcmt = try!(self.cat_deref(pat, cmt, 0, false));\n+            let subcmt = try!(self.cat_deref(pat, cmt, 0));\n               try!(self.cat_pattern_(subcmt, &**subpat, op));\n           }\n \n@@ -1392,22 +1412,6 @@ impl<'tcx> cmt_<'tcx> {\n \n \n     pub fn descriptive_string(&self, tcx: &ty::ctxt) -> String {\n-        fn upvar_to_string(upvar: &Upvar, is_copy: bool) -> String {\n-            if upvar.is_unboxed {\n-                let kind = match upvar.kind {\n-                    ty::FnUnboxedClosureKind => \"Fn\",\n-                    ty::FnMutUnboxedClosureKind => \"FnMut\",\n-                    ty::FnOnceUnboxedClosureKind => \"FnOnce\"\n-                };\n-                format!(\"captured outer variable in an `{}` closure\", kind)\n-            } else {\n-                (match (upvar.kind, is_copy) {\n-                    (ty::FnOnceUnboxedClosureKind, true) => \"captured outer variable in a proc\",\n-                    _ => \"captured outer variable\"\n-                }).to_string()\n-            }\n-        }\n-\n         match self.cat {\n             cat_static_item => {\n                 \"static item\".to_string()\n@@ -1427,16 +1431,23 @@ impl<'tcx> cmt_<'tcx> {\n                 let upvar = self.upvar();\n                 match upvar.as_ref().map(|i| &i.cat) {\n                     Some(&cat_upvar(ref var)) => {\n-                        upvar_to_string(var, false)\n+                        var.user_string(tcx)\n                     }\n                     Some(_) => unreachable!(),\n                     None => {\n                         match pk {\n                             Implicit(..) => {\n-                                \"dereference (dereference is implicit, due to indexing)\".to_string()\n+                                format!(\"indexed content\")\n+                            }\n+                            Unique => {\n+                                format!(\"`Box` content\")\n+                            }\n+                            UnsafePtr(..) => {\n+                                format!(\"dereference of unsafe pointer\")\n+                            }\n+                            BorrowedPtr(..) => {\n+                                format!(\"borrowed content\")\n                             }\n-                            Unique => format!(\"dereference of `{}`\", ptr_sigil(pk)),\n-                            _ => format!(\"dereference of `{}`-pointer\", ptr_sigil(pk))\n                         }\n                     }\n                 }\n@@ -1447,14 +1458,12 @@ impl<'tcx> cmt_<'tcx> {\n             cat_interior(_, InteriorField(PositionalField(_))) => {\n                 \"anonymous field\".to_string()\n             }\n-            cat_interior(_, InteriorElement(VecElement)) => {\n-                \"vec content\".to_string()\n-            }\n+            cat_interior(_, InteriorElement(VecElement)) |\n             cat_interior(_, InteriorElement(OtherElement)) => {\n                 \"indexed content\".to_string()\n             }\n             cat_upvar(ref var) => {\n-                upvar_to_string(var, true)\n+                var.user_string(tcx)\n             }\n             cat_downcast(ref cmt, _) => {\n                 cmt.descriptive_string(tcx)\n@@ -1483,7 +1492,7 @@ impl<'tcx> Repr<'tcx> for categorization<'tcx> {\n                 format!(\"{:?}\", *self)\n             }\n             cat_deref(ref cmt, derefs, ptr) => {\n-                format!(\"{}-{}{}->\", cmt.cat.repr(tcx), ptr_sigil(ptr), derefs)\n+                format!(\"{}-{}{}->\", cmt.cat.repr(tcx), ptr.repr(tcx), derefs)\n             }\n             cat_interior(ref cmt, interior) => {\n                 format!(\"{}.{}\", cmt.cat.repr(tcx), interior.repr(tcx))\n@@ -1504,7 +1513,32 @@ pub fn ptr_sigil(ptr: PointerKind) -> &'static str {\n         Implicit(ty::MutBorrow, _) => \"&mut\",\n         BorrowedPtr(ty::UniqueImmBorrow, _) |\n         Implicit(ty::UniqueImmBorrow, _) => \"&unique\",\n-        UnsafePtr(_) => \"*\"\n+        UnsafePtr(_) => \"*\",\n+    }\n+}\n+\n+impl<'tcx> Repr<'tcx> for PointerKind {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+        match *self {\n+            Unique => {\n+                format!(\"Box\")\n+            }\n+            BorrowedPtr(ty::ImmBorrow, ref r) |\n+            Implicit(ty::ImmBorrow, ref r) => {\n+                format!(\"&{}\", r.repr(tcx))\n+            }\n+            BorrowedPtr(ty::MutBorrow, ref r) |\n+            Implicit(ty::MutBorrow, ref r) => {\n+                format!(\"&{} mut\", r.repr(tcx))\n+            }\n+            BorrowedPtr(ty::UniqueImmBorrow, ref r) |\n+            Implicit(ty::UniqueImmBorrow, ref r) => {\n+                format!(\"&{} uniq\", r.repr(tcx))\n+            }\n+            UnsafePtr(_) => {\n+                format!(\"*\")\n+            }\n+        }\n     }\n }\n \n@@ -1531,3 +1565,27 @@ fn element_kind(t: Ty) -> ElementKind {\n         _ => OtherElement\n     }\n }\n+\n+impl<'tcx> Repr<'tcx> for ty::UnboxedClosureKind {\n+    fn repr(&self, _: &ty::ctxt) -> String {\n+        format!(\"Upvar({:?})\", self)\n+    }\n+}\n+\n+impl<'tcx> Repr<'tcx> for Upvar {\n+    fn repr(&self, tcx: &ty::ctxt) -> String {\n+        format!(\"Upvar({})\", self.kind.repr(tcx))\n+    }\n+}\n+\n+impl<'tcx> UserString<'tcx> for Upvar {\n+    fn user_string(&self, _: &ty::ctxt) -> String {\n+        let kind = match self.kind {\n+            ty::FnUnboxedClosureKind => \"Fn\",\n+            ty::FnMutUnboxedClosureKind => \"FnMut\",\n+            ty::FnOnceUnboxedClosureKind => \"FnOnce\",\n+        };\n+        format!(\"captured outer variable in an `{}` closure\", kind)\n+    }\n+}\n+"}, {"sha": "28d02161eebd7e470ef93c3e76679e9d7a4bd2d0", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8ed88c11af9495e7119da4ac59f329a33cedac59/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed88c11af9495e7119da4ac59f329a33cedac59/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=8ed88c11af9495e7119da4ac59f329a33cedac59", "patch": "@@ -115,29 +115,31 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     match move_from.cat {\n         mc::cat_deref(_, _, mc::BorrowedPtr(..)) |\n         mc::cat_deref(_, _, mc::Implicit(..)) |\n-        mc::cat_deref(_, _, mc::UnsafePtr(..)) |\n         mc::cat_static_item => {\n-            bccx.span_err(\n-                move_from.span,\n-                &format!(\"cannot move out of {}\",\n-                        bccx.cmt_to_string(&*move_from))[]);\n+            bccx.span_err(move_from.span,\n+                          &format!(\"cannot move out of {}\",\n+                                  move_from.descriptive_string(bccx.tcx))[]);\n         }\n \n         mc::cat_downcast(ref b, _) |\n         mc::cat_interior(ref b, _) => {\n             match b.ty.sty {\n-                ty::ty_struct(did, _)\n-                | ty::ty_enum(did, _) if ty::has_dtor(bccx.tcx, did) => {\n+                ty::ty_struct(did, _) |\n+                ty::ty_enum(did, _) if ty::has_dtor(bccx.tcx, did) => {\n                     bccx.span_err(\n                         move_from.span,\n                         &format!(\"cannot move out of type `{}`, \\\n                                  which defines the `Drop` trait\",\n                                 b.ty.user_string(bccx.tcx))[]);\n                 },\n-                _ => panic!(\"this path should not cause illegal move\")\n+                _ => {\n+                    bccx.span_bug(move_from.span, \"this path should not cause illegal move\")\n+                }\n             }\n         }\n-        _ => panic!(\"this path should not cause illegal move\")\n+        _ => {\n+            bccx.span_bug(move_from.span, \"this path should not cause illegal move\")\n+        }\n     }\n }\n "}, {"sha": "b87fed1601c51a3db3a33906464774547cec731d", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ed88c11af9495e7119da4ac59f329a33cedac59/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed88c11af9495e7119da4ac59f329a33cedac59/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=8ed88c11af9495e7119da4ac59f329a33cedac59", "patch": "@@ -681,6 +681,10 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         self.tcx.sess.span_err(s, m);\n     }\n \n+    pub fn span_bug(&self, s: Span, m: &str) {\n+        self.tcx.sess.span_bug(s, m);\n+    }\n+\n     pub fn span_note(&self, s: Span, m: &str) {\n         self.tcx.sess.span_note(s, m);\n     }"}, {"sha": "19a88dfc553b68159675280fc4f9195c8e54f5a7", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ed88c11af9495e7119da4ac59f329a33cedac59/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed88c11af9495e7119da4ac59f329a33cedac59/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=8ed88c11af9495e7119da4ac59f329a33cedac59", "patch": "@@ -73,7 +73,7 @@ pub fn check_call<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         autoderef(fcx,\n                   callee_expr.span,\n                   original_callee_ty,\n-                  Some(callee_expr.id),\n+                  Some(callee_expr),\n                   LvaluePreference::NoPreference,\n                   |adj_ty, idx| {\n                       let autoderefref = ty::AutoDerefRef { autoderefs: idx, autoref: None };"}, {"sha": "7946077485976e4cd3bbfa8128f4f7b97865f8b0", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8ed88c11af9495e7119da4ac59f329a33cedac59/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed88c11af9495e7119da4ac59f329a33cedac59/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=8ed88c11af9495e7119da4ac59f329a33cedac59", "patch": "@@ -143,7 +143,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         // time writing the results into the various tables.\n         let (autoderefd_ty, n, result) =\n             check::autoderef(\n-                self.fcx, self.span, unadjusted_self_ty, Some(self.self_expr.id), NoPreference,\n+                self.fcx, self.span, unadjusted_self_ty, Some(self.self_expr), NoPreference,\n                 |_, n| if n == auto_deref_ref.autoderefs { Some(()) } else { None });\n         assert_eq!(n, auto_deref_ref.autoderefs);\n         assert_eq!(result, Some(()));\n@@ -492,7 +492,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                exprs.repr(self.tcx()));\n \n         // Fix up autoderefs and derefs.\n-        for (i, expr) in exprs.iter().rev().enumerate() {\n+        for (i, &expr) in exprs.iter().rev().enumerate() {\n             // Count autoderefs.\n             let autoderef_count = match self.fcx\n                                             .inh\n@@ -512,8 +512,8 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n             if autoderef_count > 0 {\n                 check::autoderef(self.fcx,\n                                  expr.span,\n-                                 self.fcx.expr_ty(*expr),\n-                                 Some(expr.id),\n+                                 self.fcx.expr_ty(expr),\n+                                 Some(expr),\n                                  PreferMutLvalue,\n                                  |_, autoderefs| {\n                                      if autoderefs == autoderef_count + 1 {\n@@ -567,7 +567,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                         let result = check::try_index_step(\n                             self.fcx,\n                             MethodCall::expr(expr.id),\n-                            *expr,\n+                            expr,\n                             &**base_expr,\n                             adjusted_base_ty,\n                             base_adjustment,\n@@ -577,7 +577,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                         if let Some((input_ty, return_ty)) = result {\n                             demand::suptype(self.fcx, index_expr.span, input_ty, index_expr_ty);\n \n-                            let expr_ty = self.fcx.expr_ty(&**expr);\n+                            let expr_ty = self.fcx.expr_ty(&*expr);\n                             demand::suptype(self.fcx, expr.span, expr_ty, return_ty);\n                         }\n                     }"}, {"sha": "0c53a16a8118b2a76d746d6f0e749b2aa02c311d", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8ed88c11af9495e7119da4ac59f329a33cedac59/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed88c11af9495e7119da4ac59f329a33cedac59/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=8ed88c11af9495e7119da4ac59f329a33cedac59", "patch": "@@ -102,9 +102,9 @@ pub fn lookup<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     Ok(confirm::confirm(fcx, span, self_expr, call_expr, self_ty, pick, supplied_method_types))\n }\n \n-pub fn lookup_in_trait<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n+pub fn lookup_in_trait<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                  span: Span,\n-                                 self_expr: Option<&'a ast::Expr>,\n+                                 self_expr: Option<&ast::Expr>,\n                                  m_name: ast::Name,\n                                  trait_def_id: DefId,\n                                  self_ty: Ty<'tcx>,\n@@ -125,9 +125,9 @@ pub fn lookup_in_trait<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n /// method-lookup code. In particular, autoderef on index is basically identical to autoderef with\n /// normal probes, except that the test also looks for built-in indexing. Also, the second half of\n /// this method is basically the same as confirmation.\n-pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n+pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                           span: Span,\n-                                          self_expr: Option<&'a ast::Expr>,\n+                                          self_expr: Option<&ast::Expr>,\n                                           m_name: ast::Name,\n                                           trait_def_id: DefId,\n                                           autoderefref: ty::AutoDerefRef<'tcx>,"}, {"sha": "084a457909c5ce5dacd9e2f8afc4dfd2418d9a54", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 26, "deletions": 9, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/8ed88c11af9495e7119da4ac59f329a33cedac59/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed88c11af9495e7119da4ac59f329a33cedac59/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=8ed88c11af9495e7119da4ac59f329a33cedac59", "patch": "@@ -2268,12 +2268,17 @@ pub enum LvaluePreference {\n pub fn autoderef<'a, 'tcx, T, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                  sp: Span,\n                                  base_ty: Ty<'tcx>,\n-                                 expr_id: Option<ast::NodeId>,\n+                                 opt_expr: Option<&ast::Expr>,\n                                  mut lvalue_pref: LvaluePreference,\n                                  mut should_stop: F)\n-                                 -> (Ty<'tcx>, uint, Option<T>) where\n-    F: FnMut(Ty<'tcx>, uint) -> Option<T>,\n+                                 -> (Ty<'tcx>, uint, Option<T>)\n+    where F: FnMut(Ty<'tcx>, uint) -> Option<T>,\n {\n+    debug!(\"autoderef(base_ty={}, opt_expr={}, lvalue_pref={:?})\",\n+           base_ty.repr(fcx.tcx()),\n+           opt_expr.repr(fcx.tcx()),\n+           lvalue_pref);\n+\n     let mut t = base_ty;\n     for autoderefs in range(0, fcx.tcx().sess.recursion_limit.get()) {\n         let resolved_t = structurally_resolved_type(fcx, sp, t);\n@@ -2291,7 +2296,19 @@ pub fn autoderef<'a, 'tcx, T, F>(fcx: &FnCtxt<'a, 'tcx>,\n         let mt = match ty::deref(resolved_t, false) {\n             Some(mt) => Some(mt),\n             None => {\n-                let method_call = expr_id.map(|id| MethodCall::autoderef(id, autoderefs));\n+                let method_call = opt_expr.map(|expr| MethodCall::autoderef(expr.id, autoderefs));\n+\n+                // Super subtle: it might seem as though we should\n+                // pass `opt_expr` to `try_overloaded_deref`, so that\n+                // the (implicit) autoref of using an overloaded deref\n+                // would get added to the adjustment table. However we\n+                // do not do that, because it's kind of a\n+                // \"meta-adjustment\" -- instead, we just leave it\n+                // unrecorded and know that there \"will be\" an\n+                // autoref. regionck and other bits of the code base,\n+                // when they encounter an overloaded autoderef, have\n+                // to do some reconstructive surgery. This is a pretty\n+                // complex mess that is begging for a proper MIR.\n                 try_overloaded_deref(fcx, sp, method_call, None, resolved_t, lvalue_pref)\n             }\n         };\n@@ -2324,7 +2341,7 @@ fn try_overloaded_deref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // Try DerefMut first, if preferred.\n     let method = match (lvalue_pref, fcx.tcx().lang_items.deref_mut_trait()) {\n         (PreferMutLvalue, Some(trait_did)) => {\n-            method::lookup_in_trait(fcx, span, base_expr.map(|x| &*x),\n+            method::lookup_in_trait(fcx, span, base_expr,\n                                     token::intern(\"deref_mut\"), trait_did,\n                                     base_ty, None)\n         }\n@@ -2334,7 +2351,7 @@ fn try_overloaded_deref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // Otherwise, fall back to Deref.\n     let method = match (method, fcx.tcx().lang_items.deref_trait()) {\n         (None, Some(trait_did)) => {\n-            method::lookup_in_trait(fcx, span, base_expr.map(|x| &*x),\n+            method::lookup_in_trait(fcx, span, base_expr,\n                                     token::intern(\"deref\"), trait_did,\n                                     base_ty, None)\n         }\n@@ -2390,7 +2407,7 @@ fn autoderef_for_index<'a, 'tcx, T, F>(fcx: &FnCtxt<'a, 'tcx>,\n     // consolidated.\n \n     let (ty, autoderefs, final_mt) =\n-        autoderef(fcx, base_expr.span, base_ty, Some(base_expr.id), lvalue_pref, |adj_ty, idx| {\n+        autoderef(fcx, base_expr.span, base_ty, Some(base_expr), lvalue_pref, |adj_ty, idx| {\n             let autoderefref = ty::AutoDerefRef { autoderefs: idx, autoref: None };\n             step(adj_ty, autoderefref)\n         });\n@@ -3360,7 +3377,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                                 fcx.expr_ty(base));\n         // FIXME(eddyb) #12808 Integrate privacy into this auto-deref loop.\n         let (_, autoderefs, field_ty) =\n-            autoderef(fcx, expr.span, expr_t, Some(base.id), lvalue_pref, |base_t, _| {\n+            autoderef(fcx, expr.span, expr_t, Some(base), lvalue_pref, |base_t, _| {\n                 match base_t.sty {\n                     ty::ty_struct(base_id, substs) => {\n                         debug!(\"struct named {}\", ppaux::ty_to_string(tcx, base_t));\n@@ -3421,7 +3438,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         let mut tuple_like = false;\n         // FIXME(eddyb) #12808 Integrate privacy into this auto-deref loop.\n         let (_, autoderefs, field_ty) =\n-            autoderef(fcx, expr.span, expr_t, Some(base.id), lvalue_pref, |base_t, _| {\n+            autoderef(fcx, expr.span, expr_t, Some(base), lvalue_pref, |base_t, _| {\n                 match base_t.sty {\n                     ty::ty_struct(base_id, substs) => {\n                         tuple_like = ty::is_tuple_struct(tcx, base_id);"}, {"sha": "3b5027dbb9e69c22a0eedc4a26e9354386ba0928", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 35, "deletions": 11, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/8ed88c11af9495e7119da4ac59f329a33cedac59/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed88c11af9495e7119da4ac59f329a33cedac59/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=8ed88c11af9495e7119da4ac59f329a33cedac59", "patch": "@@ -936,37 +936,55 @@ fn constrain_call<'a, I: Iterator<Item=&'a ast::Expr>>(rcx: &mut Rcx,\n fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                                   deref_expr: &ast::Expr,\n                                   derefs: uint,\n-                                  mut derefd_ty: Ty<'tcx>) {\n+                                  mut derefd_ty: Ty<'tcx>)\n+{\n+    debug!(\"constrain_autoderefs(deref_expr={}, derefs={}, derefd_ty={})\",\n+           deref_expr.repr(rcx.tcx()),\n+           derefs,\n+           derefd_ty.repr(rcx.tcx()));\n+\n     let r_deref_expr = ty::ReScope(CodeExtent::from_node_id(deref_expr.id));\n     for i in range(0u, derefs) {\n-        debug!(\"constrain_autoderefs(deref_expr=?, derefd_ty={}, derefs={}/{}\",\n-               rcx.fcx.infcx().ty_to_string(derefd_ty),\n-               i, derefs);\n-\n         let method_call = MethodCall::autoderef(deref_expr.id, i);\n+        debug!(\"constrain_autoderefs: method_call={:?} (of {:?} total)\", method_call, derefs);\n+\n         derefd_ty = match rcx.fcx.inh.method_map.borrow().get(&method_call) {\n             Some(method) => {\n+                debug!(\"constrain_autoderefs: #{} is overloaded, method={}\",\n+                       i, method.repr(rcx.tcx()));\n+\n                 // Treat overloaded autoderefs as if an AutoRef adjustment\n                 // was applied on the base type, as that is always the case.\n                 let fn_sig = ty::ty_fn_sig(method.ty);\n-                let self_ty = fn_sig.0.inputs[0];\n+                let fn_sig = // late-bound regions should have been instantiated\n+                    ty::assert_no_late_bound_regions(rcx.tcx(), fn_sig);\n+                let self_ty = fn_sig.inputs[0];\n                 let (m, r) = match self_ty.sty {\n                     ty::ty_rptr(r, ref m) => (m.mutbl, r),\n-                    _ => rcx.tcx().sess.span_bug(deref_expr.span,\n+                    _ => {\n+                        rcx.tcx().sess.span_bug(\n+                            deref_expr.span,\n                             &format!(\"bad overloaded deref type {}\",\n-                                    method.ty.repr(rcx.tcx()))[])\n+                                     method.ty.repr(rcx.tcx()))[])\n+                    }\n                 };\n+\n+                debug!(\"constrain_autoderefs: receiver r={:?} m={:?}\",\n+                       r.repr(rcx.tcx()), m);\n+\n                 {\n                     let mc = mc::MemCategorizationContext::new(rcx.fcx);\n                     let self_cmt = ignore_err!(mc.cat_expr_autoderefd(deref_expr, i));\n+                    debug!(\"constrain_autoderefs: self_cmt={:?}\",\n+                           self_cmt.repr(rcx.tcx()));\n                     link_region(rcx, deref_expr.span, *r,\n                                 ty::BorrowKind::from_mutbl(m), self_cmt);\n                 }\n \n                 // Specialized version of constrain_call.\n                 type_must_outlive(rcx, infer::CallRcvr(deref_expr.span),\n                                   self_ty, r_deref_expr);\n-                match fn_sig.0.output {\n+                match fn_sig.output {\n                     ty::FnConverging(return_type) => {\n                         type_must_outlive(rcx, infer::CallReturn(deref_expr.span),\n                                           return_type, r_deref_expr);\n@@ -1049,13 +1067,16 @@ fn type_of_node_must_outlive<'a, 'tcx>(\n /// Computes the guarantor for an expression `&base` and then ensures that the lifetime of the\n /// resulting pointer is linked to the lifetime of its guarantor (if any).\n fn link_addr_of(rcx: &mut Rcx, expr: &ast::Expr,\n-               mutability: ast::Mutability, base: &ast::Expr) {\n-    debug!(\"link_addr_of(base=?)\");\n+                mutability: ast::Mutability, base: &ast::Expr) {\n+    debug!(\"link_addr_of(expr={}, base={})\", expr.repr(rcx.tcx()), base.repr(rcx.tcx()));\n \n     let cmt = {\n         let mc = mc::MemCategorizationContext::new(rcx.fcx);\n         ignore_err!(mc.cat_expr(base))\n     };\n+\n+    debug!(\"link_addr_of: cmt={}\", cmt.repr(rcx.tcx()));\n+\n     link_region_from_node_type(rcx, expr.span, expr.id, mutability, cmt);\n }\n \n@@ -1182,6 +1203,9 @@ fn link_region_from_node_type<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n                                         id: ast::NodeId,\n                                         mutbl: ast::Mutability,\n                                         cmt_borrowed: mc::cmt<'tcx>) {\n+    debug!(\"link_region_from_node_type(id={:?}, mutbl={:?}, cmt_borrowed={})\",\n+           id, mutbl, cmt_borrowed.repr(rcx.tcx()));\n+\n     let rptr_ty = rcx.resolve_node_type(id);\n     if !ty::type_is_error(rptr_ty) {\n         let tcx = rcx.fcx.ccx.tcx;"}, {"sha": "cff0064497aff34ac814b8be55d4a1b9c4e64b9d", "filename": "src/test/compile-fail/binop-move-semantics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ed88c11af9495e7119da4ac59f329a33cedac59/src%2Ftest%2Fcompile-fail%2Fbinop-move-semantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed88c11af9495e7119da4ac59f329a33cedac59/src%2Ftest%2Fcompile-fail%2Fbinop-move-semantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbinop-move-semantics.rs?ref=8ed88c11af9495e7119da4ac59f329a33cedac59", "patch": "@@ -37,9 +37,9 @@ fn illegal_dereference<T: Add<Output=()>>(mut x: T, y: T) {\n     let m = &mut x;\n     let n = &y;\n \n-    *m  //~ ERROR: cannot move out of dereference of `&mut`-pointer\n+    *m  //~ ERROR: cannot move out of borrowed content\n     +\n-    *n;  //~ ERROR: cannot move out of dereference of `&`-pointer\n+    *n;  //~ ERROR: cannot move out of borrowed content\n }\n \n struct Foo;"}, {"sha": "794e0fc6e3aba95ab10168acd24d51a96b0d0ffd", "filename": "src/test/compile-fail/borrowck-borrow-immut-deref-of-box-as-mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ed88c11af9495e7119da4ac59f329a33cedac59/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-immut-deref-of-box-as-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed88c11af9495e7119da4ac59f329a33cedac59/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-immut-deref-of-box-as-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-immut-deref-of-box-as-mut.rs?ref=8ed88c11af9495e7119da4ac59f329a33cedac59", "patch": "@@ -20,5 +20,5 @@ impl A {\n pub fn main() {\n     let a = box A;\n     a.foo();\n-    //~^ ERROR cannot borrow immutable dereference of `Box` `*a` as mutable\n+    //~^ ERROR cannot borrow immutable `Box` content `*a` as mutable\n }"}, {"sha": "d5df12513465644ac06031915856439635158720", "filename": "src/test/compile-fail/borrowck-call-is-borrow-issue-12224.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ed88c11af9495e7119da4ac59f329a33cedac59/src%2Ftest%2Fcompile-fail%2Fborrowck-call-is-borrow-issue-12224.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed88c11af9495e7119da4ac59f329a33cedac59/src%2Ftest%2Fcompile-fail%2Fborrowck-call-is-borrow-issue-12224.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-call-is-borrow-issue-12224.rs?ref=8ed88c11af9495e7119da4ac59f329a33cedac59", "patch": "@@ -33,15 +33,15 @@ fn test1() {\n }\n \n fn test2<F>(f: &F) where F: FnMut() {\n-    (*f)(); //~ ERROR: cannot borrow immutable dereference of `&`-pointer `*f` as mutable\n+    (*f)(); //~ ERROR: cannot borrow immutable borrowed content `*f` as mutable\n }\n \n fn test3<F>(f: &mut F) where F: FnMut() {\n     (*f)();\n }\n \n fn test4(f: &Test) {\n-    f.f.call_mut(()) //~ ERROR: cannot borrow immutable dereference of `Box` `*f.f` as mutable\n+    f.f.call_mut(()) //~ ERROR: cannot borrow immutable `Box` content `*f.f` as mutable\n }\n \n fn test5(f: &mut Test) {"}, {"sha": "ec505faf88502ca3de07e5014f1b0c75dcd84f33", "filename": "src/test/compile-fail/borrowck-move-in-irrefut-pat.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8ed88c11af9495e7119da4ac59f329a33cedac59/src%2Ftest%2Fcompile-fail%2Fborrowck-move-in-irrefut-pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed88c11af9495e7119da4ac59f329a33cedac59/src%2Ftest%2Fcompile-fail%2Fborrowck-move-in-irrefut-pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-in-irrefut-pat.rs?ref=8ed88c11af9495e7119da4ac59f329a33cedac59", "patch": "@@ -11,16 +11,16 @@\n fn with<F>(f: F) where F: FnOnce(&String) {}\n \n fn arg_item(&_x: &String) {}\n-    //~^ ERROR cannot move out of dereference of `&`-pointer\n+    //~^ ERROR cannot move out of borrowed content\n \n fn arg_closure() {\n     with(|&_x| ())\n-    //~^ ERROR cannot move out of dereference of `&`-pointer\n+    //~^ ERROR cannot move out of borrowed content\n }\n \n fn let_pat() {\n     let &_x = &\"hi\".to_string();\n-    //~^ ERROR cannot move out of dereference of `&`-pointer\n+    //~^ ERROR cannot move out of borrowed content\n }\n \n pub fn main() {}"}, {"sha": "a13efdea5621e1e8c96d2716dfa4dd908ae97d61", "filename": "src/test/compile-fail/borrowck-move-out-of-overloaded-auto-deref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ed88c11af9495e7119da4ac59f329a33cedac59/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-overloaded-auto-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed88c11af9495e7119da4ac59f329a33cedac59/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-overloaded-auto-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-overloaded-auto-deref.rs?ref=8ed88c11af9495e7119da4ac59f329a33cedac59", "patch": "@@ -12,5 +12,5 @@ use std::rc::Rc;\n \n pub fn main() {\n     let _x = Rc::new(vec!(1i, 2)).into_iter();\n-    //~^ ERROR cannot move out of dereference of `&`-pointer\n+    //~^ ERROR cannot move out of borrowed content\n }"}, {"sha": "fffcf575ab08e49318f50d2325da200465d31f6c", "filename": "src/test/compile-fail/borrowck-move-out-of-overloaded-deref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ed88c11af9495e7119da4ac59f329a33cedac59/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-overloaded-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed88c11af9495e7119da4ac59f329a33cedac59/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-overloaded-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-overloaded-deref.rs?ref=8ed88c11af9495e7119da4ac59f329a33cedac59", "patch": "@@ -12,5 +12,5 @@ use std::rc::Rc;\n \n pub fn main() {\n     let _x = *Rc::new(\"hi\".to_string());\n-    //~^ ERROR cannot move out of dereference of `&`-pointer\n+    //~^ ERROR cannot move out of borrowed content\n }"}, {"sha": "75596af10d70ede28c6702cf690f32141fe3b97a", "filename": "src/test/compile-fail/borrowck-move-out-of-vec-tail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ed88c11af9495e7119da4ac59f329a33cedac59/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-vec-tail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed88c11af9495e7119da4ac59f329a33cedac59/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-vec-tail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-vec-tail.rs?ref=8ed88c11af9495e7119da4ac59f329a33cedac59", "patch": "@@ -25,7 +25,7 @@ pub fn main() {\n     match x {\n         [_, tail..] => {\n             match tail {\n-                [Foo { string: a }, //~ ERROR cannot move out of dereference of `&`-pointer\n+                [Foo { string: a }, //~ ERROR cannot move out of borrowed content\n                  Foo { string: b }] => {\n                     //~^^ NOTE attempting to move value to here\n                     //~^^ NOTE and here"}, {"sha": "334f14349d723dd219e1a5191ebeab07a9c4ce66", "filename": "src/test/compile-fail/borrowck-overloaded-index-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ed88c11af9495e7119da4ac59f329a33cedac59/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed88c11af9495e7119da4ac59f329a33cedac59/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index-2.rs?ref=8ed88c11af9495e7119da4ac59f329a33cedac59", "patch": "@@ -28,5 +28,5 @@ fn main() {\n     let v = MyVec { data: vec!(box 1i, box 2, box 3) };\n     let good = &v[0]; // Shouldn't fail here\n     let bad = v[0];\n-    //~^ ERROR cannot move out of dereference (dereference is implicit, due to indexing)\n+    //~^ ERROR cannot move out of indexed content\n }"}, {"sha": "4188cf001423e53dea4eeef13872dba94cbedbdf", "filename": "src/test/compile-fail/borrowck-overloaded-index-and-overloaded-deref.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/8ed88c11af9495e7119da4ac59f329a33cedac59/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index-and-overloaded-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed88c11af9495e7119da4ac59f329a33cedac59/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index-and-overloaded-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index-and-overloaded-deref.rs?ref=8ed88c11af9495e7119da4ac59f329a33cedac59", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that we properly record borrows when we are doing an\n+// overloaded, autoderef of a value obtained via an overloaded index\n+// operator. The accounting of the all the implicit things going on\n+// here is rather subtle. Issue #20232.\n+\n+use std::ops::{Deref, Index};\n+\n+struct MyVec<T> { x: T }\n+\n+impl<T> Index<usize> for MyVec<T> {\n+    type Output = T;\n+    fn index(&self, _: &usize) -> &T {\n+        &self.x\n+    }\n+}\n+\n+struct MyPtr<T> { x: T }\n+\n+impl<T> Deref for MyPtr<T> {\n+    type Target = T;\n+    fn deref(&self) -> &T {\n+        &self.x\n+    }\n+}\n+\n+struct Foo { f: usize }\n+\n+fn main() {\n+    let mut v = MyVec { x: MyPtr { x: Foo { f: 22 } } };\n+    let i = &v[0].f;\n+    v = MyVec { x: MyPtr { x: Foo { f: 23 } } };\n+    //~^ ERROR cannot assign to `v`\n+    read(*i);\n+}\n+\n+fn read(_: usize) { }\n+"}, {"sha": "f4f4d983e009b998c0f01f44a470f3d40d51eab1", "filename": "src/test/compile-fail/borrowck-overloaded-index.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ed88c11af9495e7119da4ac59f329a33cedac59/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed88c11af9495e7119da4ac59f329a33cedac59/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index.rs?ref=8ed88c11af9495e7119da4ac59f329a33cedac59", "patch": "@@ -66,5 +66,5 @@ fn main() {\n         x: 1,\n     };\n     s[2] = 20;\n-    //~^ ERROR cannot assign to immutable dereference (dereference is implicit, due to indexing)\n+    //~^ ERROR cannot assign to immutable indexed content\n }"}, {"sha": "c64cc13bbe2eaab5ae6f38de3a0fb84fc81d2026", "filename": "src/test/compile-fail/dst-index.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ed88c11af9495e7119da4ac59f329a33cedac59/src%2Ftest%2Fcompile-fail%2Fdst-index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed88c11af9495e7119da4ac59f329a33cedac59/src%2Ftest%2Fcompile-fail%2Fdst-index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-index.rs?ref=8ed88c11af9495e7119da4ac59f329a33cedac59", "patch": "@@ -41,9 +41,9 @@ impl Index<uint> for T {\n \n fn main() {\n     S[0];\n-    //~^ ERROR cannot move out of dereference\n+    //~^ ERROR cannot move out of indexed content\n     //~^^ ERROR E0161\n     T[0];\n-    //~^ ERROR cannot move out of dereference\n+    //~^ ERROR cannot move out of indexed content\n     //~^^ ERROR E0161\n }"}, {"sha": "faae0009a934c4eb4d6adb0ff8fab3e2ef06274c", "filename": "src/test/compile-fail/dst-rvalue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ed88c11af9495e7119da4ac59f329a33cedac59/src%2Ftest%2Fcompile-fail%2Fdst-rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed88c11af9495e7119da4ac59f329a33cedac59/src%2Ftest%2Fcompile-fail%2Fdst-rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-rvalue.rs?ref=8ed88c11af9495e7119da4ac59f329a33cedac59", "patch": "@@ -15,10 +15,10 @@\n pub fn main() {\n     let _x: Box<str> = box *\"hello world\";\n     //~^ ERROR E0161\n-    //~^^ ERROR cannot move out of dereference\n+    //~^^ ERROR cannot move out of borrowed content\n \n     let array: &[int] = &[1, 2, 3];\n     let _x: Box<[int]> = box *array;\n     //~^ ERROR E0161\n-    //~^^ ERROR cannot move out of dereference\n+    //~^^ ERROR cannot move out of borrowed content\n }"}, {"sha": "d186a83676a804abf601b48d5372eaa6eacfe09b", "filename": "src/test/compile-fail/issue-12567.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8ed88c11af9495e7119da4ac59f329a33cedac59/src%2Ftest%2Fcompile-fail%2Fissue-12567.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed88c11af9495e7119da4ac59f329a33cedac59/src%2Ftest%2Fcompile-fail%2Fissue-12567.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-12567.rs?ref=8ed88c11af9495e7119da4ac59f329a33cedac59", "patch": "@@ -12,11 +12,11 @@ fn match_vecs<'a, T>(l1: &'a [T], l2: &'a [T]) {\n     match (l1, l2) {\n         ([], []) => println!(\"both empty\"),\n         ([], [hd, tl..]) | ([hd, tl..], []) => println!(\"one empty\"),\n-        //~^ ERROR: cannot move out of dereference\n-        //~^^ ERROR: cannot move out of dereference\n+        //~^ ERROR: cannot move out of borrowed content\n+        //~^^ ERROR: cannot move out of borrowed content\n         ([hd1, tl1..], [hd2, tl2..]) => println!(\"both nonempty\"),\n-        //~^ ERROR: cannot move out of dereference\n-        //~^^ ERROR: cannot move out of dereference\n+        //~^ ERROR: cannot move out of borrowed content\n+        //~^^ ERROR: cannot move out of borrowed content\n     }\n }\n "}, {"sha": "fbecd0487bf6f5d7811752cfd71c9a24a3d12e80", "filename": "src/test/compile-fail/issue-17651.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ed88c11af9495e7119da4ac59f329a33cedac59/src%2Ftest%2Fcompile-fail%2Fissue-17651.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed88c11af9495e7119da4ac59f329a33cedac59/src%2Ftest%2Fcompile-fail%2Fissue-17651.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17651.rs?ref=8ed88c11af9495e7119da4ac59f329a33cedac59", "patch": "@@ -15,6 +15,6 @@\n \n fn main() {\n     (|&:| box *[0us].as_slice())();\n-    //~^ ERROR cannot move out of dereference\n+    //~^ ERROR cannot move out of borrowed content\n     //~^^ ERROR cannot move a value of type [usize]\n }"}, {"sha": "07aea4fd633b427d5b6b6f495e5d8d8acba05d72", "filename": "src/test/compile-fail/issue-2590.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ed88c11af9495e7119da4ac59f329a33cedac59/src%2Ftest%2Fcompile-fail%2Fissue-2590.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed88c11af9495e7119da4ac59f329a33cedac59/src%2Ftest%2Fcompile-fail%2Fissue-2590.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2590.rs?ref=8ed88c11af9495e7119da4ac59f329a33cedac59", "patch": "@@ -19,7 +19,7 @@ trait parse {\n \n impl parse for parser {\n     fn parse(&self) -> Vec<int> {\n-        self.tokens //~ ERROR cannot move out of dereference of `&`-pointer\n+        self.tokens //~ ERROR cannot move out of borrowed content\n     }\n }\n "}, {"sha": "ad255ecd9c0642f96c1e6782f5ac04c1e0f91ab9", "filename": "src/test/compile-fail/method-self-arg-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ed88c11af9495e7119da4ac59f329a33cedac59/src%2Ftest%2Fcompile-fail%2Fmethod-self-arg-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed88c11af9495e7119da4ac59f329a33cedac59/src%2Ftest%2Fcompile-fail%2Fmethod-self-arg-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmethod-self-arg-2.rs?ref=8ed88c11af9495e7119da4ac59f329a33cedac59", "patch": "@@ -23,5 +23,5 @@ fn main() {\n     Foo::bar(&x); //~ERROR cannot borrow `x`\n \n     let x = Foo;\n-    Foo::baz(&x); //~ERROR cannot borrow immutable dereference of `&`-pointer as mutable\n+    Foo::baz(&x); //~ERROR cannot borrow immutable borrowed content as mutable\n }"}, {"sha": "09357d328cd18c08f27831e72953dcfd6505b135", "filename": "src/test/compile-fail/slice-mut-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ed88c11af9495e7119da4ac59f329a33cedac59/src%2Ftest%2Fcompile-fail%2Fslice-mut-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed88c11af9495e7119da4ac59f329a33cedac59/src%2Ftest%2Fcompile-fail%2Fslice-mut-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fslice-mut-2.rs?ref=8ed88c11af9495e7119da4ac59f329a33cedac59", "patch": "@@ -14,5 +14,5 @@ fn main() {\n     let x: &[int] = &[1, 2, 3, 4, 5];\n     // Can't mutably slice an immutable slice\n     let slice: &mut [int] = &mut [0, 1];\n-    let _ = &mut x[2..4]; //~ERROR cannot borrow immutable dereference of `&`-pointer `*x` as mutabl\n+    let _ = &mut x[2..4]; //~ERROR cannot borrow immutable borrowed content `*x` as mutable\n }"}, {"sha": "f68554b9ec79e256eb04925c56037f869612690c", "filename": "src/test/compile-fail/slice-mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ed88c11af9495e7119da4ac59f329a33cedac59/src%2Ftest%2Fcompile-fail%2Fslice-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed88c11af9495e7119da4ac59f329a33cedac59/src%2Ftest%2Fcompile-fail%2Fslice-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fslice-mut.rs?ref=8ed88c11af9495e7119da4ac59f329a33cedac59", "patch": "@@ -13,5 +13,5 @@\n fn main() {\n     let x: &[int] = &[1, 2, 3, 4, 5];\n     // Immutable slices are not mutable.\n-    let y: &mut[_] = &x[2..4]; //~ ERROR cannot borrow immutable dereference of `&`-pointer as mutab\n+    let y: &mut[_] = &x[2..4]; //~ ERROR cannot borrow immutable borrowed content as mutable\n }"}, {"sha": "81cf9c1bdcf1a1b5953c728eaa5feb0d93c5744a", "filename": "src/test/compile-fail/std-uncopyable-atomics.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8ed88c11af9495e7119da4ac59f329a33cedac59/src%2Ftest%2Fcompile-fail%2Fstd-uncopyable-atomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed88c11af9495e7119da4ac59f329a33cedac59/src%2Ftest%2Fcompile-fail%2Fstd-uncopyable-atomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstd-uncopyable-atomics.rs?ref=8ed88c11af9495e7119da4ac59f329a33cedac59", "patch": "@@ -16,11 +16,11 @@ use std::ptr;\n \n fn main() {\n     let x = ATOMIC_BOOL_INIT;\n-    let x = *&x; //~ ERROR: cannot move out of dereference\n+    let x = *&x; //~ ERROR: cannot move out of borrowed content\n     let x = ATOMIC_INT_INIT;\n-    let x = *&x; //~ ERROR: cannot move out of dereference\n+    let x = *&x; //~ ERROR: cannot move out of borrowed content\n     let x = ATOMIC_UINT_INIT;\n-    let x = *&x; //~ ERROR: cannot move out of dereference\n+    let x = *&x; //~ ERROR: cannot move out of borrowed content\n     let x: AtomicPtr<uint> = AtomicPtr::new(ptr::null_mut());\n-    let x = *&x; //~ ERROR: cannot move out of dereference\n+    let x = *&x; //~ ERROR: cannot move out of borrowed content\n }"}, {"sha": "946566675981e7020327aa8aca735f9e14490e75", "filename": "src/test/compile-fail/unop-move-semantics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ed88c11af9495e7119da4ac59f329a33cedac59/src%2Ftest%2Fcompile-fail%2Funop-move-semantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed88c11af9495e7119da4ac59f329a33cedac59/src%2Ftest%2Fcompile-fail%2Funop-move-semantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funop-move-semantics.rs?ref=8ed88c11af9495e7119da4ac59f329a33cedac59", "patch": "@@ -31,9 +31,9 @@ fn illegal_dereference<T: Not<Output=T>>(mut x: T, y: T) {\n     let m = &mut x;\n     let n = &y;\n \n-    !*m;  //~ ERROR: cannot move out of dereference of `&mut`-pointer\n+    !*m;  //~ ERROR: cannot move out of borrowed content\n \n-    !*n;  //~ ERROR: cannot move out of dereference of `&`-pointer\n+    !*n;  //~ ERROR: cannot move out of borrowed content\n }\n \n fn main() {}"}]}