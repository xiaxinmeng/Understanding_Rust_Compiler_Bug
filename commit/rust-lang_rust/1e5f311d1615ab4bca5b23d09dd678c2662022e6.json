{"sha": "1e5f311d1615ab4bca5b23d09dd678c2662022e6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlNWYzMTFkMTYxNWFiNGJjYTViMjNkMDlkZDY3OGMyNjYyMDIyZTY=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-10-30T01:21:37Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-11-06T01:12:14Z"}, "message": "Fix fallout of DSTifying PartialEq, PartialOrd, Eq, Ord", "tree": {"sha": "cf69b14249e1d7b8be7cd2c61ad46f0f39a748fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf69b14249e1d7b8be7cd2c61ad46f0f39a748fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e5f311d1615ab4bca5b23d09dd678c2662022e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e5f311d1615ab4bca5b23d09dd678c2662022e6", "html_url": "https://github.com/rust-lang/rust/commit/1e5f311d1615ab4bca5b23d09dd678c2662022e6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e5f311d1615ab4bca5b23d09dd678c2662022e6/comments", "author": null, "committer": null, "parents": [{"sha": "2896278313ede1b24b47c88bafe684adabbc92d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/2896278313ede1b24b47c88bafe684adabbc92d4", "html_url": "https://github.com/rust-lang/rust/commit/2896278313ede1b24b47c88bafe684adabbc92d4"}], "stats": {"total": 172, "additions": 172, "deletions": 0}, "files": [{"sha": "79c1f720794f2c729c14440875236db78af9838f", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1e5f311d1615ab4bca5b23d09dd678c2662022e6/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e5f311d1615ab4bca5b23d09dd678c2662022e6/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=1e5f311d1615ab4bca5b23d09dd678c2662022e6", "patch": "@@ -532,10 +532,17 @@ impl<'a> PartialOrd for MaybeOwned<'a> {\n }\n \n impl<'a> Ord for MaybeOwned<'a> {\n+    // NOTE(stage0): remove method after a snapshot\n+    #[cfg(stage0)]\n     #[inline]\n     fn cmp(&self, other: &MaybeOwned) -> Ordering {\n         self.as_slice().cmp(&other.as_slice())\n     }\n+    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+    #[inline]\n+    fn cmp(&self, other: &MaybeOwned) -> Ordering {\n+        self.as_slice().cmp(other.as_slice())\n+    }\n }\n \n impl<'a, S: Str> Equiv<S> for MaybeOwned<'a> {"}, {"sha": "4b6921ed0c0d98b57b15436c03510463325be999", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1e5f311d1615ab4bca5b23d09dd678c2662022e6/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e5f311d1615ab4bca5b23d09dd678c2662022e6/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=1e5f311d1615ab4bca5b23d09dd678c2662022e6", "patch": "@@ -506,10 +506,17 @@ impl<T: PartialEq> PartialEq for Vec<T> {\n \n #[unstable = \"waiting on PartialOrd stability\"]\n impl<T: PartialOrd> PartialOrd for Vec<T> {\n+    // NOTE(stage0): remove method after a snapshot\n+    #[cfg(stage0)]\n     #[inline]\n     fn partial_cmp(&self, other: &Vec<T>) -> Option<Ordering> {\n         self.as_slice().partial_cmp(&other.as_slice())\n     }\n+    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+    #[inline]\n+    fn partial_cmp(&self, other: &Vec<T>) -> Option<Ordering> {\n+        self.as_slice().partial_cmp(other.as_slice())\n+    }\n }\n \n #[unstable = \"waiting on Eq stability\"]\n@@ -523,10 +530,17 @@ impl<T: PartialEq, V: AsSlice<T>> Equiv<V> for Vec<T> {\n \n #[unstable = \"waiting on Ord stability\"]\n impl<T: Ord> Ord for Vec<T> {\n+    // NOTE(stage0): remove method after a snapshot\n+    #[cfg(stage0)]\n     #[inline]\n     fn cmp(&self, other: &Vec<T>) -> Ordering {\n         self.as_slice().cmp(&other.as_slice())\n     }\n+    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+    #[inline]\n+    fn cmp(&self, other: &Vec<T>) -> Ordering {\n+        self.as_slice().cmp(other.as_slice())\n+    }\n }\n \n // FIXME: #13996: need a way to mark the return value as `noalias`"}, {"sha": "3a89d8b3f81cd522d687b18aebb35d406d7a6157", "filename": "src/libgraphviz/maybe_owned_vec.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1e5f311d1615ab4bca5b23d09dd678c2662022e6/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e5f311d1615ab4bca5b23d09dd678c2662022e6/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Fmaybe_owned_vec.rs?ref=1e5f311d1615ab4bca5b23d09dd678c2662022e6", "patch": "@@ -76,15 +76,27 @@ impl<'a, T: PartialEq> PartialEq for MaybeOwnedVector<'a, T> {\n impl<'a, T: Eq> Eq for MaybeOwnedVector<'a, T> {}\n \n impl<'a, T: PartialOrd> PartialOrd for MaybeOwnedVector<'a, T> {\n+    // NOTE(stage0): remove method after a snapshot\n+    #[cfg(stage0)]\n     fn partial_cmp(&self, other: &MaybeOwnedVector<T>) -> Option<Ordering> {\n         self.as_slice().partial_cmp(&other.as_slice())\n     }\n+    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+    fn partial_cmp(&self, other: &MaybeOwnedVector<T>) -> Option<Ordering> {\n+        self.as_slice().partial_cmp(other.as_slice())\n+    }\n }\n \n impl<'a, T: Ord> Ord for MaybeOwnedVector<'a, T> {\n+    // NOTE(stage0): remove method after a snapshot\n+    #[cfg(stage0)]\n     fn cmp(&self, other: &MaybeOwnedVector<T>) -> Ordering {\n         self.as_slice().cmp(&other.as_slice())\n     }\n+    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+    fn cmp(&self, other: &MaybeOwnedVector<T>) -> Ordering {\n+        self.as_slice().cmp(other.as_slice())\n+    }\n }\n \n impl<'a, T: PartialEq, V: AsSlice<T>> Equiv<V> for MaybeOwnedVector<'a, T> {"}, {"sha": "6723ea725a356de73aaf68a9141e59cbca581421", "filename": "src/libregex/parse.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1e5f311d1615ab4bca5b23d09dd678c2662022e6/src%2Flibregex%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e5f311d1615ab4bca5b23d09dd678c2662022e6/src%2Flibregex%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fparse.rs?ref=1e5f311d1615ab4bca5b23d09dd678c2662022e6", "patch": "@@ -1020,13 +1020,23 @@ fn is_valid_cap(c: char) -> bool {\n     || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')\n }\n \n+// NOTE(stage0): remove function after a snapshot\n+#[cfg(stage0)]\n fn find_class(classes: NamedClasses, name: &str) -> Option<Vec<(char, char)>> {\n     match classes.binary_search(|&(s, _)| s.cmp(&name)) {\n         slice::Found(i) => Some(classes[i].val1().to_vec()),\n         slice::NotFound(_) => None,\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+fn find_class(classes: NamedClasses, name: &str) -> Option<Vec<(char, char)>> {\n+    match classes.binary_search(|&(s, _)| s.cmp(name)) {\n+        slice::Found(i) => Some(classes[i].val1().to_vec()),\n+        slice::NotFound(_) => None,\n+    }\n+}\n+\n type Class = &'static [(char, char)];\n type NamedClasses = &'static [(&'static str, &'static Class)];\n "}, {"sha": "8753795d9e25d59905a21c6f140698c4fe561bb1", "filename": "src/librustc/driver/mod.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1e5f311d1615ab4bca5b23d09dd678c2662022e6/src%2Flibrustc%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e5f311d1615ab4bca5b23d09dd678c2662022e6/src%2Flibrustc%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fmod.rs?ref=1e5f311d1615ab4bca5b23d09dd678c2662022e6", "patch": "@@ -182,6 +182,8 @@ Available lint options:\n \n \");\n \n+    // NOTE(stage0): remove function after a snapshot\n+    #[cfg(stage0)]\n     fn sort_lints(lints: Vec<(&'static Lint, bool)>) -> Vec<&'static Lint> {\n         let mut lints: Vec<_> = lints.into_iter().map(|(x, _)| x).collect();\n         lints.sort_by(|x: &&Lint, y: &&Lint| {\n@@ -194,6 +196,21 @@ Available lint options:\n         lints\n     }\n \n+    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+    fn sort_lints(lints: Vec<(&'static Lint, bool)>) -> Vec<&'static Lint> {\n+        let mut lints: Vec<_> = lints.into_iter().map(|(x, _)| x).collect();\n+        lints.sort_by(|x: &&Lint, y: &&Lint| {\n+            match x.default_level.cmp(&y.default_level) {\n+                // The sort doesn't case-fold but it's doubtful we care.\n+                Equal => x.name.cmp(y.name),\n+                r => r,\n+            }\n+        });\n+        lints\n+    }\n+\n+    // NOTE(stage0): remove function after a snapshot\n+    #[cfg(stage0)]\n     fn sort_lint_groups(lints: Vec<(&'static str, Vec<lint::LintId>, bool)>)\n                      -> Vec<(&'static str, Vec<lint::LintId>)> {\n         let mut lints: Vec<_> = lints.into_iter().map(|(x, y, _)| (x, y)).collect();\n@@ -204,6 +221,17 @@ Available lint options:\n         lints\n     }\n \n+    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+    fn sort_lint_groups(lints: Vec<(&'static str, Vec<lint::LintId>, bool)>)\n+                     -> Vec<(&'static str, Vec<lint::LintId>)> {\n+        let mut lints: Vec<_> = lints.into_iter().map(|(x, y, _)| (x, y)).collect();\n+        lints.sort_by(|&(x, _): &(&'static str, Vec<lint::LintId>),\n+                       &(y, _): &(&'static str, Vec<lint::LintId>)| {\n+            x.cmp(y)\n+        });\n+        lints\n+    }\n+\n     let (plugin, builtin) = lint_store.get_lints().partitioned(|&(_, p)| p);\n     let plugin = sort_lints(plugin);\n     let builtin = sort_lints(builtin);"}, {"sha": "b7a2c8f947341be13f3e4889fbba8939ad0ef304", "filename": "src/librustrt/c_str.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1e5f311d1615ab4bca5b23d09dd678c2662022e6/src%2Flibrustrt%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e5f311d1615ab4bca5b23d09dd678c2662022e6/src%2Flibrustrt%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fc_str.rs?ref=1e5f311d1615ab4bca5b23d09dd678c2662022e6", "patch": "@@ -121,10 +121,17 @@ impl PartialEq for CString {\n }\n \n impl PartialOrd for CString {\n+    // NOTE(stage0): remove method after a snapshot\n+    #[cfg(stage0)]\n     #[inline]\n     fn partial_cmp(&self, other: &CString) -> Option<Ordering> {\n         self.as_bytes().partial_cmp(&other.as_bytes())\n     }\n+    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+    #[inline]\n+    fn partial_cmp(&self, other: &CString) -> Option<Ordering> {\n+        self.as_bytes().partial_cmp(other.as_bytes())\n+    }\n }\n \n impl Eq for CString {}"}, {"sha": "dbdfa17bfc2285198d67b38f2b9de1a1f26d8797", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/1e5f311d1615ab4bca5b23d09dd678c2662022e6/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e5f311d1615ab4bca5b23d09dd678c2662022e6/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=1e5f311d1615ab4bca5b23d09dd678c2662022e6", "patch": "@@ -890,13 +890,25 @@ impl Json {\n \n      /// If the Json value is an Object, returns the value associated with the provided key.\n     /// Otherwise, returns None.\n+    // NOTE(stage0): remove function after a snapshot\n+    #[cfg(stage0)]\n     pub fn find<'a>(&'a self, key: &str) -> Option<&'a Json>{\n         match self {\n             &Object(ref map) => map.find_with(|s| key.cmp(&s.as_slice())),\n             _ => None\n         }\n     }\n \n+     /// If the Json value is an Object, returns the value associated with the provided key.\n+    /// Otherwise, returns None.\n+    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+    pub fn find<'a>(&'a self, key: &str) -> Option<&'a Json>{\n+        match self {\n+            &Object(ref map) => map.find_with(|s| key.cmp(s.as_slice())),\n+            _ => None\n+        }\n+    }\n+\n     /// Attempts to get a nested Json Object for each key in `keys`.\n     /// If any key is found not to exist, find_path will return None.\n     /// Otherwise, it will return the Json value associated with the final key.\n@@ -914,6 +926,8 @@ impl Json {\n     /// If the Json value is an Object, performs a depth-first search until\n     /// a value associated with the provided key is found. If no value is found\n     /// or the Json value is not an Object, returns None.\n+    // NOTE(stage0): remove function after a snapshot\n+    #[cfg(stage0)]\n     pub fn search<'a>(&'a self, key: &str) -> Option<&'a Json> {\n         match self {\n             &Object(ref map) => {\n@@ -934,6 +948,30 @@ impl Json {\n         }\n     }\n \n+    /// If the Json value is an Object, performs a depth-first search until\n+    /// a value associated with the provided key is found. If no value is found\n+    /// or the Json value is not an Object, returns None.\n+    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+    pub fn search<'a>(&'a self, key: &str) -> Option<&'a Json> {\n+        match self {\n+            &Object(ref map) => {\n+                match map.find_with(|s| key.cmp(s.as_slice())) {\n+                    Some(json_value) => Some(json_value),\n+                    None => {\n+                        for (_, v) in map.iter() {\n+                            match v.search(key) {\n+                                x if x.is_some() => return x,\n+                                _ => ()\n+                            }\n+                        }\n+                        None\n+                    }\n+                }\n+            },\n+            _ => None\n+        }\n+    }\n+\n     /// Returns true if the Json value is an Object. Returns false otherwise.\n     pub fn is_object<'a>(&'a self) -> bool {\n         self.as_object().is_some()"}, {"sha": "e6c98a9e3d09abdce17ebcd70619a2280675d4a1", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1e5f311d1615ab4bca5b23d09dd678c2662022e6/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e5f311d1615ab4bca5b23d09dd678c2662022e6/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=1e5f311d1615ab4bca5b23d09dd678c2662022e6", "patch": "@@ -97,9 +97,15 @@ pub struct RcStr {\n impl Eq for RcStr {}\n \n impl Ord for RcStr {\n+    // NOTE(stage0): remove method after a snapshot\n+    #[cfg(stage0)]\n     fn cmp(&self, other: &RcStr) -> Ordering {\n         self.as_slice().cmp(&other.as_slice())\n     }\n+    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+    fn cmp(&self, other: &RcStr) -> Ordering {\n+        self.as_slice().cmp(other.as_slice())\n+    }\n }\n \n impl Str for RcStr {"}, {"sha": "74bead9e5f2ddee67760115105cf9f7065861b21", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/1e5f311d1615ab4bca5b23d09dd678c2662022e6/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e5f311d1615ab4bca5b23d09dd678c2662022e6/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=1e5f311d1615ab4bca5b23d09dd678c2662022e6", "patch": "@@ -973,6 +973,8 @@ fn get_concurrency() -> uint {\n     }\n }\n \n+// NOTE(stage0): remove function after a snapshot\n+#[cfg(stage0)]\n pub fn filter_tests(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> Vec<TestDescAndFn> {\n     let mut filtered = tests;\n \n@@ -1020,6 +1022,54 @@ pub fn filter_tests(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> Vec<TestDescA\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+pub fn filter_tests(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> Vec<TestDescAndFn> {\n+    let mut filtered = tests;\n+\n+    // Remove tests that don't match the test filter\n+    filtered = match opts.filter {\n+        None => filtered,\n+        Some(ref re) => {\n+            filtered.into_iter()\n+                .filter(|test| re.is_match(test.desc.name.as_slice())).collect()\n+        }\n+    };\n+\n+    // Maybe pull out the ignored test and unignore them\n+    filtered = if !opts.run_ignored {\n+        filtered\n+    } else {\n+        fn filter(test: TestDescAndFn) -> Option<TestDescAndFn> {\n+            if test.desc.ignore {\n+                let TestDescAndFn {desc, testfn} = test;\n+                Some(TestDescAndFn {\n+                    desc: TestDesc {ignore: false, ..desc},\n+                    testfn: testfn\n+                })\n+            } else {\n+                None\n+            }\n+        };\n+        filtered.into_iter().filter_map(|x| filter(x)).collect()\n+    };\n+\n+    // Sort the tests alphabetically\n+    filtered.sort_by(|t1, t2| t1.desc.name.as_slice().cmp(t2.desc.name.as_slice()));\n+\n+    // Shard the remaining tests, if sharding requested.\n+    match opts.test_shard {\n+        None => filtered,\n+        Some((a,b)) => {\n+            filtered.into_iter().enumerate()\n+            // note: using a - 1 so that the valid shards, for example, are\n+            // 1.2 and 2.2 instead of 0.2 and 1.2\n+            .filter(|&(i,_)| i % b == (a - 1))\n+            .map(|(_,t)| t)\n+            .collect()\n+        }\n+    }\n+}\n+\n pub fn run_test(opts: &TestOpts,\n                 force_ignore: bool,\n                 test: TestDescAndFn,"}]}