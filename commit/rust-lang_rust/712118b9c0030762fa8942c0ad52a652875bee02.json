{"sha": "712118b9c0030762fa8942c0ad52a652875bee02", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxMjExOGI5YzAwMzA3NjJmYTg5NDJjMGFkNTJhNjUyODc1YmVlMDI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-23T05:00:18Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-25T08:17:14Z"}, "message": "rustdoc: Inline documentation of `pub use`\n\nThis commit teaches rustdoc to inline the documentation for the destination of a\n`pub use` statement across crate boundaries. This is intended for the standard\nlibrary's facade to show the fact that the facade is just an implementation\ndetail rather than the api of the standard library itself.\n\nThis starts out by inlining traits and functions, but more items will come soon.\nThe current drawback of this system is that hyperlinks across crates sill go to\nthe original item's definition rather than the reexported location.", "tree": {"sha": "e167d3d8a24852b4d71187f7aaff8d72eeb18fb7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e167d3d8a24852b4d71187f7aaff8d72eeb18fb7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/712118b9c0030762fa8942c0ad52a652875bee02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/712118b9c0030762fa8942c0ad52a652875bee02", "html_url": "https://github.com/rust-lang/rust/commit/712118b9c0030762fa8942c0ad52a652875bee02", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/712118b9c0030762fa8942c0ad52a652875bee02/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "html_url": "https://github.com/rust-lang/rust/commit/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5"}], "stats": {"total": 193, "additions": 140, "deletions": 53}, "files": [{"sha": "8f98ccc04050a46e6f045c7420c61f72037a43dd", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 113, "deletions": 18, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/712118b9c0030762fa8942c0ad52a652875bee02/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712118b9c0030762fa8942c0ad52a652875bee02/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=712118b9c0030762fa8942c0ad52a652875bee02", "patch": "@@ -15,7 +15,7 @@ use syntax;\n use syntax::ast;\n use syntax::ast_util;\n use syntax::attr;\n-use syntax::attr::AttributeMethods;\n+use syntax::attr::{AttributeMethods, AttrMetaMethods};\n use syntax::codemap::Pos;\n use syntax::parse::token::InternedString;\n use syntax::parse::token;\n@@ -250,7 +250,8 @@ impl Clean<Item> for doctree::Module {\n             self.statics.clean().move_iter().collect(),\n             self.traits.clean().move_iter().collect(),\n             self.impls.clean().move_iter().collect(),\n-            self.view_items.clean().move_iter().collect(),\n+            self.view_items.clean().move_iter()\n+                           .flat_map(|s| s.move_iter()).collect(),\n             self.macros.clean().move_iter().collect()\n         );\n \n@@ -832,10 +833,6 @@ impl Clean<TraitMethod> for ty::Method {\n             core::Typed(ref tcx) => tcx,\n             core::NotTyped(_) => fail!(),\n         };\n-        let mut attrs = Vec::new();\n-        csearch::get_item_attrs(&tcx.sess.cstore, self.def_id, |v| {\n-            attrs.extend(v.move_iter().map(|i| i.clean()));\n-        });\n         let (self_, sig) = match self.explicit_self {\n             ast::SelfStatic => (ast::SelfStatic.clean(), self.fty.sig.clone()),\n             s => {\n@@ -861,7 +858,7 @@ impl Clean<TraitMethod> for ty::Method {\n             name: Some(self.ident.clean()),\n             visibility: Some(ast::Inherited),\n             def_id: self.def_id,\n-            attrs: attrs,\n+            attrs: load_attrs(tcx, self.def_id),\n             source: Span {\n                 filename: \"\".to_strbuf(),\n                 loline: 0, locol: 0, hiline: 0, hicol: 0,\n@@ -1404,21 +1401,105 @@ pub struct ViewItem {\n     pub inner: ViewItemInner,\n }\n \n-impl Clean<Item> for ast::ViewItem {\n-    fn clean(&self) -> Item {\n-        Item {\n-            name: None,\n-            attrs: self.attrs.clean().move_iter().collect(),\n-            source: self.span.clean(),\n-            def_id: ast_util::local_def(0),\n-            visibility: self.vis.clean(),\n-            inner: ViewItemItem(ViewItem {\n-                inner: self.node.clean()\n-            }),\n+impl Clean<Vec<Item>> for ast::ViewItem {\n+    fn clean(&self) -> Vec<Item> {\n+        let denied = self.vis != ast::Public || self.attrs.iter().any(|a| {\n+            a.name().get() == \"doc\" && match a.meta_item_list() {\n+                Some(l) => attr::contains_name(l, \"noinline\"),\n+                None => false,\n+            }\n+        });\n+        let convert = |node: &ast::ViewItem_| {\n+            Item {\n+                name: None,\n+                attrs: self.attrs.clean().move_iter().collect(),\n+                source: self.span.clean(),\n+                def_id: ast_util::local_def(0),\n+                visibility: self.vis.clean(),\n+                inner: ViewItemItem(ViewItem { inner: node.clean() }),\n+            }\n+        };\n+        let mut ret = Vec::new();\n+        match self.node {\n+            ast::ViewItemUse(ref path) if !denied => {\n+                match path.node {\n+                    ast::ViewPathGlob(..) => ret.push(convert(&self.node)),\n+                    ast::ViewPathList(ref a, ref list, ref b) => {\n+                        let remaining = list.iter().filter(|path| {\n+                            match try_inline(path.node.id) {\n+                                Some(item) => { ret.push(item); false }\n+                                None => true,\n+                            }\n+                        }).map(|a| a.clone()).collect::<Vec<ast::PathListIdent>>();\n+                        if remaining.len() > 0 {\n+                            let path = ast::ViewPathList(a.clone(),\n+                                                         remaining,\n+                                                         b.clone());\n+                            let path = syntax::codemap::dummy_spanned(path);\n+                            ret.push(convert(&ast::ViewItemUse(@path)));\n+                        }\n+                    }\n+                    ast::ViewPathSimple(_, _, id) => {\n+                        match try_inline(id) {\n+                            Some(item) => ret.push(item),\n+                            None => ret.push(convert(&self.node)),\n+                        }\n+                    }\n+                }\n+            }\n+            ref n => ret.push(convert(n)),\n         }\n+        return ret;\n     }\n }\n \n+fn try_inline(id: ast::NodeId) -> Option<Item> {\n+    let cx = super::ctxtkey.get().unwrap();\n+    let tcx = match cx.maybe_typed {\n+        core::Typed(ref tycx) => tycx,\n+        core::NotTyped(_) => return None,\n+    };\n+    let def = match tcx.def_map.borrow().find(&id) {\n+        Some(def) => *def,\n+        None => return None,\n+    };\n+    let did = ast_util::def_id_of_def(def);\n+    if ast_util::is_local(did) { return None }\n+    let inner = match def {\n+        ast::DefTrait(did) => TraitItem(build_external_trait(tcx, did)),\n+        ast::DefFn(did, style) =>\n+            FunctionItem(build_external_function(tcx, did, style)),\n+        _ => return None,\n+    };\n+    let fqn = csearch::get_item_path(tcx, did);\n+    Some(Item {\n+        source: Span {\n+            filename: \"\".to_strbuf(), loline: 0, locol: 0, hiline: 0, hicol: 0,\n+        },\n+        name: Some(fqn.last().unwrap().to_str().to_strbuf()),\n+        attrs: load_attrs(tcx, did),\n+        inner: inner,\n+        visibility: Some(ast::Public),\n+        def_id: did,\n+    })\n+}\n+\n+fn load_attrs(tcx: &ty::ctxt, did: ast::DefId) -> Vec<Attribute> {\n+    let mut attrs = Vec::new();\n+    csearch::get_item_attrs(&tcx.sess.cstore, did, |v| {\n+        attrs.extend(v.move_iter().map(|item| {\n+            let mut a = attr::mk_attr_outer(item);\n+            // FIXME this isn't quite always true, it's just true about 99% of\n+            //       the time when dealing with documentation\n+            if a.name().get() == \"doc\" && a.value_str().is_some() {\n+                a.node.is_sugared_doc = true;\n+            }\n+            a.clean()\n+        }));\n+    });\n+    attrs\n+}\n+\n #[deriving(Clone, Encodable, Decodable)]\n pub enum ViewItemInner {\n     ExternCrate(String, Option<String>, ast::NodeId),\n@@ -1654,6 +1735,20 @@ fn build_external_trait(tcx: &ty::ctxt, did: ast::DefId) -> Trait {\n     }\n }\n \n+fn build_external_function(tcx: &ty::ctxt,\n+                           did: ast::DefId,\n+                           style: ast::FnStyle) -> Function {\n+    let t = csearch::get_type(tcx, did);\n+    Function {\n+        decl: match ty::get(t.ty).sty {\n+            ty::ty_bare_fn(ref f) => f.sig.clean(),\n+            _ => fail!(\"bad function\"),\n+        },\n+        generics: t.generics.clean(),\n+        fn_style: style,\n+    }\n+}\n+\n fn resolve_use_source(path: Path, id: ast::NodeId) -> ImportSource {\n     ImportSource {\n         path: path,"}, {"sha": "76b7a7a2101e2ca5f3066dddf46ba84583e37078", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 27, "deletions": 35, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/712118b9c0030762fa8942c0ad52a652875bee02/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712118b9c0030762fa8942c0ad52a652875bee02/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=712118b9c0030762fa8942c0ad52a652875bee02", "patch": "@@ -157,9 +157,9 @@ pub struct Cache {\n \n     // Private fields only used when initially crawling a crate to build a cache\n \n-    stack: Vec<String> ,\n-    parent_stack: Vec<ast::NodeId> ,\n-    search_index: Vec<IndexItem> ,\n+    stack: Vec<String>,\n+    parent_stack: Vec<ast::DefId>,\n+    search_index: Vec<IndexItem>,\n     privmod: bool,\n     public_items: NodeSet,\n \n@@ -198,7 +198,7 @@ struct IndexItem {\n     name: String,\n     path: String,\n     desc: String,\n-    parent: Option<ast::NodeId>,\n+    parent: Option<ast::DefId>,\n }\n \n // TLS keys used to carry information around during rendering.\n@@ -302,7 +302,7 @@ pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n                         path: fqp.slice_to(fqp.len() - 1).connect(\"::\")\n                                                          .to_strbuf(),\n                         desc: shorter(item.doc_value()).to_strbuf(),\n-                        parent: Some(pid),\n+                        parent: Some(did),\n                     });\n                 },\n                 None => {}\n@@ -360,9 +360,8 @@ pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n \n         try!(write!(&mut w, r#\"],\"paths\":[\"#));\n \n-        for (i, &nodeid) in pathid_to_nodeid.iter().enumerate() {\n-            let def = ast_util::local_def(nodeid);\n-            let &(ref fqp, short) = cache.paths.find(&def).unwrap();\n+        for (i, &did) in pathid_to_nodeid.iter().enumerate() {\n+            let &(ref fqp, short) = cache.paths.find(&did).unwrap();\n             if i > 0 {\n                 try!(write!(&mut w, \",\"));\n             }\n@@ -730,14 +729,13 @@ impl DocFolder for Cache {\n                     clean::VariantItem(..) => {\n                         (Some(*self.parent_stack.last().unwrap()),\n                          Some(self.stack.slice_to(self.stack.len() - 1)))\n-\n                     }\n                     clean::MethodItem(..) => {\n                         if self.parent_stack.len() == 0 {\n                             (None, None)\n                         } else {\n                             let last = self.parent_stack.last().unwrap();\n-                            let did = ast_util::local_def(*last);\n+                            let did = *last;\n                             let path = match self.paths.find(&did) {\n                                 Some(&(_, item_type::Trait)) =>\n                                     Some(self.stack.slice_to(self.stack.len() - 1)),\n@@ -766,9 +764,11 @@ impl DocFolder for Cache {\n                         });\n                     }\n                     (Some(parent), None) if !self.privmod => {\n-                        // We have a parent, but we don't know where they're\n-                        // defined yet. Wait for later to index this item.\n-                        self.orphan_methods.push((parent, item.clone()))\n+                        if ast_util::is_local(parent) {\n+                            // We have a parent, but we don't know where they're\n+                            // defined yet. Wait for later to index this item.\n+                            self.orphan_methods.push((parent.node, item.clone()))\n+                        }\n                     }\n                     _ => {}\n                 }\n@@ -789,19 +789,17 @@ impl DocFolder for Cache {\n             clean::TypedefItem(..) | clean::TraitItem(..) |\n             clean::FunctionItem(..) | clean::ModuleItem(..) |\n             clean::ForeignFunctionItem(..) => {\n-                if ast_util::is_local(item.def_id) {\n-                    // Reexported items mean that the same id can show up twice\n-                    // in the rustdoc ast that we're looking at. We know,\n-                    // however, that a reexported item doesn't show up in the\n-                    // `public_items` map, so we can skip inserting into the\n-                    // paths map if there was already an entry present and we're\n-                    // not a public item.\n-                    let id = item.def_id.node;\n-                    if !self.paths.contains_key(&item.def_id) ||\n-                       self.public_items.contains(&id) {\n-                        self.paths.insert(item.def_id,\n-                                          (self.stack.clone(), shortty(&item)));\n-                    }\n+                // Reexported items mean that the same id can show up twice\n+                // in the rustdoc ast that we're looking at. We know,\n+                // however, that a reexported item doesn't show up in the\n+                // `public_items` map, so we can skip inserting into the\n+                // paths map if there was already an entry present and we're\n+                // not a public item.\n+                let id = item.def_id.node;\n+                if !self.paths.contains_key(&item.def_id) ||\n+                   self.public_items.contains(&id) {\n+                    self.paths.insert(item.def_id,\n+                                      (self.stack.clone(), shortty(&item)));\n                 }\n             }\n             // link variants to their parent enum because pages aren't emitted\n@@ -817,20 +815,14 @@ impl DocFolder for Cache {\n         // Maintain the parent stack\n         let parent_pushed = match item.inner {\n             clean::TraitItem(..) | clean::EnumItem(..) | clean::StructItem(..) => {\n-                if ast_util::is_local(item.def_id) {\n-                    self.parent_stack.push(item.def_id.node);\n-                }\n+                self.parent_stack.push(item.def_id);\n                 true\n             }\n             clean::ImplItem(ref i) => {\n                 match i.for_ {\n                     clean::ResolvedPath{ did, .. } => {\n-                        if ast_util::is_local(did) {\n-                            self.parent_stack.push(did.node);\n-                            true\n-                        } else {\n-                            false\n-                        }\n+                        self.parent_stack.push(did);\n+                        true\n                     }\n                     _ => false\n                 }"}]}