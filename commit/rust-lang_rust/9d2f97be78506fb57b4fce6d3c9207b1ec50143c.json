{"sha": "9d2f97be78506fb57b4fce6d3c9207b1ec50143c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkMmY5N2JlNzg1MDZmYjU3YjRmY2U2ZDNjOTIwN2IxZWM1MDE0M2M=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2018-11-27T11:39:19Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2018-11-30T08:44:16Z"}, "message": "Test float assign ops", "tree": {"sha": "9292fed0a0437a87ee0a5332e39889ca2ca30450", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9292fed0a0437a87ee0a5332e39889ca2ca30450"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9d2f97be78506fb57b4fce6d3c9207b1ec50143c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9d2f97be78506fb57b4fce6d3c9207b1ec50143c", "html_url": "https://github.com/rust-lang/rust/commit/9d2f97be78506fb57b4fce6d3c9207b1ec50143c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9d2f97be78506fb57b4fce6d3c9207b1ec50143c/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "42e5317f1d24d117afad5e77c0ac98eee41a714d", "url": "https://api.github.com/repos/rust-lang/rust/commits/42e5317f1d24d117afad5e77c0ac98eee41a714d", "html_url": "https://github.com/rust-lang/rust/commit/42e5317f1d24d117afad5e77c0ac98eee41a714d"}], "stats": {"total": 279, "additions": 279, "deletions": 0}, "files": [{"sha": "2c7262df367a399d9a10d1ccfc592519c41a7f22", "filename": "src/test/ui/consts/const_let_eq_float.rs", "status": "added", "additions": 279, "deletions": 0, "changes": 279, "blob_url": "https://github.com/rust-lang/rust/blob/9d2f97be78506fb57b4fce6d3c9207b1ec50143c/src%2Ftest%2Fui%2Fconsts%2Fconst_let_eq_float.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d2f97be78506fb57b4fce6d3c9207b1ec50143c/src%2Ftest%2Fui%2Fconsts%2Fconst_let_eq_float.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_let_eq_float.rs?ref=9d2f97be78506fb57b4fce6d3c9207b1ec50143c", "patch": "@@ -0,0 +1,279 @@\n+// compile-pass\n+\n+#![feature(const_let, const_fn)]\n+\n+struct Foo<T>(T);\n+struct Bar<T> { x: T }\n+struct W(f32);\n+struct A { a: f32 }\n+\n+const fn basics((a,): (f32,)) -> f32 {\n+    // Deferred assignment:\n+    let b: f32;\n+    b = a + 1.0;\n+\n+    // Immediate assignment:\n+    let c: f32 = b + 1.0;\n+\n+    // Mutables:\n+    let mut d: f32 = c + 1.0;\n+    d = d + 1.0;\n+    // +4 so far.\n+\n+    // No effect statements work:\n+    ; ;\n+    1;\n+\n+    // Array projection\n+    let mut arr: [f32; 1] = [0.0];\n+    arr[0] = 1.0;\n+    d = d + arr[0];\n+    // +5\n+\n+    // Field projection:\n+    let mut foo: Foo<f32> = Foo(0.0);\n+    let mut bar: Bar<f32> = Bar { x: 0.0 };\n+    foo.0 = 1.0;\n+    bar.x = 1.0;\n+    d = d + foo.0 + bar.x;\n+    // +7\n+\n+    // Array + Field projection:\n+    let mut arr: [Foo<f32>; 1] = [Foo(0.0)];\n+    arr[0].0 = 1.0;\n+    d = d + arr[0].0;\n+    let mut arr: [Bar<f32>; 1] = [Bar { x: 0.0 }];\n+    arr[0].x = 1.0;\n+    d = d + arr[0].x;\n+    // +9\n+\n+    // Field + Array projection:\n+    let mut arr: Foo<[f32; 1]> = Foo([0.0]);\n+    (arr.0)[0] = 1.0;\n+    d = d + (arr.0)[0];\n+    let mut arr: Bar<[f32; 1]> = Bar { x: [0.0] };\n+    arr.x[0] = 1.0;\n+    d = d + arr.x[0];\n+    // +11\n+\n+    d\n+}\n+\n+const fn add_assign(W(a): W) -> f32 {\n+    // Mutables:\n+    let mut d: f32 = a + 1.0;\n+    d += 1.0;\n+    // +2 so far.\n+\n+    // Array projection\n+    let mut arr: [f32; 1] = [0.0];\n+    arr[0] += 1.0;\n+    d += arr[0];\n+    // +3\n+\n+    // Field projection:\n+    let mut foo: Foo<f32> = Foo(0.0);\n+    let mut bar: Bar<f32> = Bar { x: 0.0 };\n+    foo.0 += 1.0;\n+    bar.x += 1.0;\n+    d += foo.0 + bar.x;\n+    // +5\n+\n+    // Array + Field projection:\n+    let mut arr: [Foo<f32>; 1] = [Foo(0.0)];\n+    arr[0].0 += 1.0;\n+    d += arr[0].0;\n+    let mut arr: [Bar<f32>; 1] = [Bar { x: 0.0 }];\n+    arr[0].x += 1.0;\n+    d += arr[0].x;\n+    // +7\n+\n+    // Field + Array projection:\n+    let mut arr: Foo<[f32; 1]> = Foo([0.0]);\n+    (arr.0)[0] += 1.0;\n+    d += (arr.0)[0];\n+    let mut arr: Bar<[f32; 1]> = Bar { x: [0.0] };\n+    arr.x[0] += 1.0;\n+    d += arr.x[0];\n+    // +9\n+\n+    d\n+}\n+\n+const fn mul_assign(A { a }: A) -> f32 {\n+    // Mutables:\n+    let mut d: f32 = a + 1.0;\n+    d *= 2.0;\n+    // 2^1 * (a + 1)\n+\n+    // Array projection\n+    let mut arr: [f32; 1] = [1.0];\n+    arr[0] *= 2.0;\n+    d *= arr[0];\n+    // 2^2 * (a + 1)\n+\n+    // Field projection:\n+    let mut foo: Foo<f32> = Foo(1.0);\n+    let mut bar: Bar<f32> = Bar { x: 1.0 };\n+    foo.0 *= 2.0;\n+    bar.x *= 2.0;\n+    d *= foo.0 + bar.x;\n+    // 2^4 * (a + 1)\n+\n+    // Array + Field projection:\n+    let mut arr: [Foo<f32>; 1] = [Foo(1.0)];\n+    arr[0].0 *= 2.0;\n+    d *= arr[0].0;\n+    let mut arr: [Bar<f32>; 1] = [Bar { x: 1.0 }];\n+    arr[0].x *= 2.0;\n+    d *= arr[0].x;\n+    // 2^6 * (a + 1)\n+\n+    // Field + Array projection:\n+    let mut arr: Foo<[f32; 1]> = Foo([1.0]);\n+    (arr.0)[0] *= 2.0;\n+    d *= (arr.0)[0];\n+    let mut arr: Bar<[f32; 1]> = Bar { x: [1.0] };\n+    arr.x[0] *= 2.0;\n+    d *= arr.x[0];\n+    // 2^8 * (a + 1)\n+\n+    d\n+}\n+\n+const fn div_assign(a: [f32; 1]) -> f32 {\n+    let a = a[0];\n+    // Mutables:\n+    let mut d: f32 = 1024.0 * a;\n+    d /= 2.0;\n+    // 512\n+\n+    // Array projection\n+    let mut arr: [f32; 1] = [4.0];\n+    arr[0] /= 2.0;\n+    d /= arr[0];\n+    // 256\n+\n+    // Field projection:\n+    let mut foo: Foo<f32> = Foo(4.0);\n+    let mut bar: Bar<f32> = Bar { x: 4.0 };\n+    foo.0 /= 2.0;\n+    bar.x /= 2.0;\n+    d /= foo.0;\n+    d /= bar.x;\n+    // 64\n+\n+    // Array + Field projection:\n+    let mut arr: [Foo<f32>; 1] = [Foo(4.0)];\n+    arr[0].0 /= 2.0;\n+    d /= arr[0].0;\n+    let mut arr: [Bar<f32>; 1] = [Bar { x: 4.0 }];\n+    arr[0].x /= 2.0;\n+    d /= arr[0].x;\n+    // 16\n+\n+    // Field + Array projection:\n+    let mut arr: Foo<[f32; 1]> = Foo([4.0]);\n+    (arr.0)[0] /= 2.0;\n+    d /= (arr.0)[0];\n+    let mut arr: Bar<[f32; 1]> = Bar { x: [4.0] };\n+    arr.x[0] /= 2.0;\n+    d /= arr.x[0];\n+    // 4\n+\n+    d\n+}\n+\n+const fn rem_assign(W(a): W) -> f32 {\n+    // Mutables:\n+    let mut d: f32 = a;\n+    d %= 10.0;\n+    d += 10.0;\n+\n+    // Array projection\n+    let mut arr: [f32; 1] = [3.0];\n+    arr[0] %= 2.0;\n+    d %= 9.0 + arr[0];\n+    d += 10.0;\n+\n+    // Field projection:\n+    let mut foo: Foo<f32> = Foo(5.0);\n+    let mut bar: Bar<f32> = Bar { x: 7.0 };\n+    foo.0 %= 2.0;\n+    bar.x %= 2.0;\n+    d %= 8.0 + foo.0 + bar.x;\n+    d += 10.0;\n+\n+    // Array + Field projection:\n+    let mut arr: [Foo<f32>; 1] = [Foo(4.0)];\n+    arr[0].0 %= 3.0;\n+    d %= 9.0 + arr[0].0;\n+    d += 10.0;\n+    let mut arr: [Bar<f32>; 1] = [Bar { x: 7.0 }];\n+    arr[0].x %= 3.0;\n+    d %= 9.0 + arr[0].x;\n+    d += 10.0;\n+\n+    // Field + Array projection:\n+    let mut arr: Foo<[f32; 1]> = Foo([6.0]);\n+    (arr.0)[0] %= 5.0;\n+    d %= 9.0 + (arr.0)[0];\n+    let mut arr: Bar<[f32; 1]> = Bar { x: [11.0] };\n+    arr.x[0] %= 5.0;\n+    d %= 9.0 + arr.x[0];\n+\n+    d\n+}\n+\n+const fn sub_assign(W(a): W) -> f32 {\n+    // Mutables:\n+    let mut d: f32 = a;\n+    d -= 1.0;\n+\n+    // Array projection\n+    let mut arr: [f32; 1] = [2.0];\n+    arr[0] -= 1.0;\n+    d -= arr[0];\n+\n+    // Field projection:\n+    let mut foo: Foo<f32> = Foo(2.0);\n+    let mut bar: Bar<f32> = Bar { x: 2.0 };\n+    foo.0 -= 1.0;\n+    bar.x -= 1.0;\n+    d -= foo.0 + bar.x;\n+\n+    // Array + Field projection:\n+    let mut arr: [Foo<f32>; 1] = [Foo(2.0)];\n+    arr[0].0 -= 1.0;\n+    d -= arr[0].0;\n+    let mut arr: [Bar<f32>; 1] = [Bar { x: 2.0 }];\n+    arr[0].x -= 1.0;\n+    d -= arr[0].x;\n+\n+    // Field + Array projection:\n+    let mut arr: Foo<[f32; 1]> = Foo([2.0]);\n+    (arr.0)[0] -= 1.0;\n+    d -= (arr.0)[0];\n+    let mut arr: Bar<[f32; 1]> = Bar { x: [2.0] };\n+    arr.x[0] -= 1.0;\n+    d -= arr.x[0];\n+\n+    d\n+}\n+\n+macro_rules! test {\n+    ($c:ident, $e:expr, $r:expr) => {\n+        const $c: f32 = $e;\n+        assert_eq!($c, $r);\n+        assert_eq!($e, $r);\n+    }\n+}\n+\n+fn main() {\n+    test!(BASICS, basics((2.0,)), 13.0);\n+    test!(ADD, add_assign(W(1.0)), 10.0);\n+    test!(MUL, mul_assign(A { a: 0.0 }), 256.0);\n+    test!(DIV, div_assign([1.0]), 4.0);\n+    test!(REM, rem_assign(W(5.0)), 5.0);\n+    test!(SUB, sub_assign(W(8.0)), 0.0);\n+}"}]}