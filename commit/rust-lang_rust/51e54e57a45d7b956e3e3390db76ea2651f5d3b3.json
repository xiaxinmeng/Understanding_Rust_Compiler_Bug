{"sha": "51e54e57a45d7b956e3e3390db76ea2651f5d3b3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxZTU0ZTU3YTQ1ZDdiOTU2ZTNlMzM5MGRiNzZlYTI2NTFmNWQzYjM=", "commit": {"author": {"name": "Wang Xuerui", "email": "idontknw.wang@gmail.com", "date": "2016-06-02T13:47:34Z"}, "committer": {"name": "Wang Xuerui", "email": "idontknw.wang@gmail.com", "date": "2016-07-13T19:10:47Z"}, "message": "syntax_ext: format: better code documentation", "tree": {"sha": "cf01da6f9cceebd4167061a4b700cea76daceed4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf01da6f9cceebd4167061a4b700cea76daceed4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/51e54e57a45d7b956e3e3390db76ea2651f5d3b3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v2\n\niQIcBAABCAAGBQJXhpI3AAoJEHg5bO9pIxDsSWcP/joKen2W4j1KD54SelHql+yM\nLkSyX1Ril2hUPGjJ+X2AcF9+Jz5ylzu9strBn/eJL6ZculqvMyDnundTYsaDD7oc\np7UG1mw9hhdJsUGUV21A1CI28ujZK9zZ9cJF7y6oYLnGgKKy3QYTpa+z6GLncNhM\n/8x/1njNu1vdU7izNewbS6gL/0Us3EaiJM6NbzoW6ByucX1StY9IsYSBjAO06kl/\nlWcekfwpa1TpNei71NU/tWU4N4tpcevaJzsLscbYcjFryYKF8YchlW8VfiW2rw7R\nrMVjvAfF5IIDsXYl2wtjvXNpsW1ahrQ/m1FKMsb/LRvTvqZlJhIUwu3eRyM1/Ajs\nl6Qm0Q/U0tN1nQ4FJnl5Axuexm7H2iw25QhzzUwZLKIa49dUnhV0MHKOT/jgtN2V\nb6pCygJPN5KU3XNyBuIrjk/Pk3nFCO2i1A2EcF0Gxwx/0ngvXxpeSqWF/MoJqP1p\n5ixEt142GJ4CbVr+8OcJrzYxNo0BkTNbxxHXsEPayB8lJFtTlhCXU7MXIB8kJUFG\n97IhZfms/WdVLc4H1YFZmZ6+akX/AlONRH/g1fI8k/vEgvArH5D+IYqym+KoTm5K\nOELR2SgEjQlqzUIY5smNG8eYgX/YvkESogyAr6IKJ4fqXx725AYJWTH6k00QgXDI\nDXTa52yMhMCmZTDzprns\n=Gc9s\n-----END PGP SIGNATURE-----", "payload": "tree cf01da6f9cceebd4167061a4b700cea76daceed4\nparent 03563b12e8705f7d8fedf6e1bc48f2bcf22c20bf\nauthor Wang Xuerui <idontknw.wang@gmail.com> 1464875254 +0800\ncommitter Wang Xuerui <idontknw.wang@gmail.com> 1468437047 +0800\n\nsyntax_ext: format: better code documentation\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/51e54e57a45d7b956e3e3390db76ea2651f5d3b3", "html_url": "https://github.com/rust-lang/rust/commit/51e54e57a45d7b956e3e3390db76ea2651f5d3b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/51e54e57a45d7b956e3e3390db76ea2651f5d3b3/comments", "author": {"login": "xen0n", "id": 1175567, "node_id": "MDQ6VXNlcjExNzU1Njc=", "avatar_url": "https://avatars.githubusercontent.com/u/1175567?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xen0n", "html_url": "https://github.com/xen0n", "followers_url": "https://api.github.com/users/xen0n/followers", "following_url": "https://api.github.com/users/xen0n/following{/other_user}", "gists_url": "https://api.github.com/users/xen0n/gists{/gist_id}", "starred_url": "https://api.github.com/users/xen0n/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xen0n/subscriptions", "organizations_url": "https://api.github.com/users/xen0n/orgs", "repos_url": "https://api.github.com/users/xen0n/repos", "events_url": "https://api.github.com/users/xen0n/events{/privacy}", "received_events_url": "https://api.github.com/users/xen0n/received_events", "type": "User", "site_admin": false}, "committer": {"login": "xen0n", "id": 1175567, "node_id": "MDQ6VXNlcjExNzU1Njc=", "avatar_url": "https://avatars.githubusercontent.com/u/1175567?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xen0n", "html_url": "https://github.com/xen0n", "followers_url": "https://api.github.com/users/xen0n/followers", "following_url": "https://api.github.com/users/xen0n/following{/other_user}", "gists_url": "https://api.github.com/users/xen0n/gists{/gist_id}", "starred_url": "https://api.github.com/users/xen0n/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xen0n/subscriptions", "organizations_url": "https://api.github.com/users/xen0n/orgs", "repos_url": "https://api.github.com/users/xen0n/repos", "events_url": "https://api.github.com/users/xen0n/events{/privacy}", "received_events_url": "https://api.github.com/users/xen0n/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "03563b12e8705f7d8fedf6e1bc48f2bcf22c20bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/03563b12e8705f7d8fedf6e1bc48f2bcf22c20bf", "html_url": "https://github.com/rust-lang/rust/commit/03563b12e8705f7d8fedf6e1bc48f2bcf22c20bf"}], "stats": {"total": 58, "additions": 46, "deletions": 12}, "files": [{"sha": "94bb78edaacdb617110784fc50dad9c8c8c0ac6b", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 46, "deletions": 12, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/51e54e57a45d7b956e3e3390db76ea2651f5d3b3/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51e54e57a45d7b956e3e3390db76ea2651f5d3b3/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=51e54e57a45d7b956e3e3390db76ea2651f5d3b3", "patch": "@@ -45,12 +45,22 @@ struct Context<'a, 'b:'a> {\n     /// The span of the format string literal.\n     fmtsp: Span,\n \n-    /// Parsed argument expressions and the types that we've found so far for\n-    /// them.\n+    /// List of parsed argument expressions.\n     /// Named expressions are resolved early, and are appended to the end of\n     /// argument expressions.\n+    ///\n+    /// Example showing the various data structures in motion:\n+    ///\n+    /// * Original: `\"{foo:o} {:o} {foo:x} {0:x} {1:o} {:x} {1:x} {0:o}\"`\n+    /// * Implicit argument resolution: `\"{foo:o} {0:o} {foo:x} {0:x} {1:o} {1:x} {1:x} {0:o}\"`\n+    /// * Name resolution: `\"{2:o} {0:o} {2:x} {0:x} {1:o} {1:x} {1:x} {0:o}\"`\n+    /// * `arg_types` (in JSON): `[[0, 1, 0], [0, 1, 1], [0, 1]]`\n+    /// * `arg_unique_types` (in simplified JSON): `[[\"o\", \"x\"], [\"o\", \"x\"], [\"o\", \"x\"]]`\n+    /// * `names` (in JSON): `{\"foo\": 2}`\n     args: Vec<P<ast::Expr>>,\n+    /// Placeholder slot numbers indexed by argument.\n     arg_types: Vec<Vec<usize>>,\n+    /// Unique format specs seen for each argument.\n     arg_unique_types: Vec<Vec<ArgumentType>>,\n     /// Map from named arguments to their resolved indices.\n     names: HashMap<String, usize>,\n@@ -69,13 +79,31 @@ struct Context<'a, 'b:'a> {\n     /// final generated static argument array. We record the starting indices\n     /// corresponding to each positional argument, and number of references\n     /// consumed so far for each argument, to facilitate correct `Position`\n-    /// mapping in `trans_piece`.\n+    /// mapping in `trans_piece`. In effect this can be seen as a \"flattened\"\n+    /// version of `arg_unique_types`.\n+    ///\n+    /// Again with the example described above in docstring for `args`:\n+    ///\n+    /// * `arg_index_map` (in JSON): `[[0, 1, 0], [2, 3, 3], [4, 5]]`\n     arg_index_map: Vec<Vec<usize>>,\n \n+    /// Starting offset of count argument slots.\n     count_args_index_offset: usize,\n \n+    /// Count argument slots and tracking data structures.\n+    /// Count arguments are separately tracked for de-duplication in case\n+    /// multiple references are made to one argument. For example, in this\n+    /// format string:\n+    ///\n+    /// * Original: `\"{:.*} {:.foo$} {1:.*} {:.0$}\"`\n+    /// * Implicit argument resolution: `\"{1:.0$} {2:.foo$} {1:.3$} {4:.0$}\"`\n+    /// * Name resolution: `\"{1:.0$} {2:.5$} {1:.3$} {4:.0$}\"`\n+    /// * `count_positions` (in JSON): `{0: 0, 5: 1, 3: 2}`\n+    /// * `count_args`: `vec![Exact(0), Exact(5), Exact(3)]`\n     count_args: Vec<Position>,\n+    /// Relative slot numbers for count arguments.\n     count_positions: HashMap<usize, usize>,\n+    /// Number of count slots assigned.\n     count_positions_count: usize,\n \n     /// Current position of the implicit positional arg pointer, as if it\n@@ -160,6 +188,8 @@ fn parse_args(ecx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n \n impl<'a, 'b> Context<'a, 'b> {\n     fn resolve_name_inplace(&self, p: &mut parse::Piece) {\n+        // NOTE: the `unwrap_or` branch is needed in case of invalid format\n+        // arguments, e.g. `format_args!(\"{foo}\")`.\n         let lookup = |s| *self.names.get(s).unwrap_or(&0);\n \n         match *p {\n@@ -178,9 +208,9 @@ impl<'a, 'b> Context<'a, 'b> {\n         }\n     }\n \n-    /// Verifies one piece of a parse string. All errors are not emitted as\n-    /// fatal so we can continue giving errors about this and possibly other\n-    /// format strings.\n+    /// Verifies one piece of a parse string, and remembers it if valid.\n+    /// All errors are not emitted as fatal so we can continue giving errors\n+    /// about this and possibly other format strings.\n     fn verify_piece(&mut self, p: &parse::Piece) {\n         match *p {\n             parse::String(..) => {}\n@@ -223,6 +253,8 @@ impl<'a, 'b> Context<'a, 'b> {\n         }\n     }\n \n+    /// Actually verifies and tracks a given format placeholder\n+    /// (a.k.a. argument).\n     fn verify_arg_type(&mut self, arg: Position, ty: ArgumentType) {\n         match arg {\n             Exact(arg) => {\n@@ -276,14 +308,15 @@ impl<'a, 'b> Context<'a, 'b> {\n         }\n     }\n \n-    // NOTE: Keep the ordering the same as `into_expr`'s expansion would do!\n+    /// Builds the mapping between format placeholders and argument objects.\n     fn build_index_map(&mut self) {\n+        // NOTE: Keep the ordering the same as `into_expr`'s expansion would do!\n         let args_len = self.args.len();\n         self.arg_index_map.reserve(args_len);\n \n         let mut sofar = 0usize;\n \n-        // Generate mapping for positional args\n+        // Map the arguments\n         for i in 0..args_len {\n             let ref arg_types = self.arg_types[i];\n             let mut arg_offsets = Vec::with_capacity(arg_types.len());\n@@ -294,8 +327,7 @@ impl<'a, 'b> Context<'a, 'b> {\n             sofar += self.arg_unique_types[i].len();\n         }\n \n-        // Record starting index for counts, which appear just\n-        // after the positional args\n+        // Record starting index for counts, which appear just after arguments\n         self.count_args_index_offset = sofar;\n     }\n \n@@ -471,8 +503,8 @@ impl<'a, 'b> Context<'a, 'b> {\n         ecx.expr_block(ecx.block(sp, vec![stmt, ecx.stmt_expr(ecx.expr_ident(sp, name))]))\n     }\n \n-    /// Actually builds the expression which the iformat! block will be expanded\n-    /// to\n+    /// Actually builds the expression which the format_args! block will be\n+    /// expanded to\n     fn into_expr(mut self) -> P<ast::Expr> {\n         let mut locals = Vec::new();\n         let mut counts = Vec::new();\n@@ -642,6 +674,8 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n                                     args: Vec<P<ast::Expr>>,\n                                     names: HashMap<String, usize>)\n                                     -> P<ast::Expr> {\n+    // NOTE: this verbose way of initializing `Vec<Vec<ArgumentType>>` is because\n+    // `ArgumentType` does not derive `Clone`.\n     let arg_types: Vec<_> = (0..args.len()).map(|_| Vec::new()).collect();\n     let arg_unique_types: Vec<_> = (0..args.len()).map(|_| Vec::new()).collect();\n     let macsp = ecx.call_site();"}]}