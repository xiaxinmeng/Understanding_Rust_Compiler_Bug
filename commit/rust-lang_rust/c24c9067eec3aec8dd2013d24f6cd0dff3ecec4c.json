{"sha": "c24c9067eec3aec8dd2013d24f6cd0dff3ecec4c", "node_id": "C_kwDOAAsO6NoAKGMyNGM5MDY3ZWVjM2FlYzhkZDIwMTNkMjRmNmNkMGRmZjNlY2VjNGM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-10-03T06:24:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-10-03T06:24:06Z"}, "message": "Auto merge of #88060 - TennyZhuang:optimize-vec-retain, r=dtolnay\n\nOptimize unnecessary check in Vec::retain\n\nThe function `vec::Vec::retain` only have two stages:\n\n1. Nothing was deleted.\n2. Some elements were deleted.\n\nHere is an unnecessary check `if g.deleted_cnt > 0` in the loop, and it's difficult for compiler to optimize it. I split the loop into two stages manully and keep the code clean using const generics.\n\nI write a special but common bench case for this optimization. I call retain on vec but keep all elements.\n\nBefore and after this optimization:\n\n```\ntest vec::bench_retain_whole_100000                      ... bench:      84,803 ns/iter (+/- 17,314)\n```\n\n```\ntest vec::bench_retain_whole_100000                      ... bench:      42,638 ns/iter (+/- 16,910)\n```\n\nThe result is expected, there are two `if`s before the optimization and one `if` after.", "tree": {"sha": "b62248940bca22a87b7914bab51600d62b5dd246", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b62248940bca22a87b7914bab51600d62b5dd246"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c24c9067eec3aec8dd2013d24f6cd0dff3ecec4c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c24c9067eec3aec8dd2013d24f6cd0dff3ecec4c", "html_url": "https://github.com/rust-lang/rust/commit/c24c9067eec3aec8dd2013d24f6cd0dff3ecec4c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c24c9067eec3aec8dd2013d24f6cd0dff3ecec4c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "77f1e504a953efbbd59673a75c3cd530d5b3c530", "url": "https://api.github.com/repos/rust-lang/rust/commits/77f1e504a953efbbd59673a75c3cd530d5b3c530", "html_url": "https://github.com/rust-lang/rust/commit/77f1e504a953efbbd59673a75c3cd530d5b3c530"}, {"sha": "3839ca9953e47ad91751fdfffa10c9ae8a210e3c", "url": "https://api.github.com/repos/rust-lang/rust/commits/3839ca9953e47ad91751fdfffa10c9ae8a210e3c", "html_url": "https://github.com/rust-lang/rust/commit/3839ca9953e47ad91751fdfffa10c9ae8a210e3c"}], "stats": {"total": 42, "additions": 39, "deletions": 3}, "files": [{"sha": "8e1d374b5d42b4c3cb3d9b88d1976dc7f801ebc1", "filename": "library/alloc/benches/vec.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c24c9067eec3aec8dd2013d24f6cd0dff3ecec4c/library%2Falloc%2Fbenches%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c24c9067eec3aec8dd2013d24f6cd0dff3ecec4c/library%2Falloc%2Fbenches%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fbenches%2Fvec.rs?ref=c24c9067eec3aec8dd2013d24f6cd0dff3ecec4c", "patch": "@@ -732,3 +732,18 @@ fn bench_flat_map_collect(b: &mut Bencher) {\n     let v = vec![777u32; 500000];\n     b.iter(|| v.iter().flat_map(|color| color.rotate_left(8).to_be_bytes()).collect::<Vec<_>>());\n }\n+\n+#[bench]\n+fn bench_retain_100000(b: &mut Bencher) {\n+    let v = (1..=100000).collect::<Vec<u32>>();\n+    b.iter(|| {\n+        let mut v = v.clone();\n+        v.retain(|x| x & 1 == 0)\n+    });\n+}\n+\n+#[bench]\n+fn bench_retain_whole_100000(b: &mut Bencher) {\n+    let mut v = black_box(vec![826u32; 100000]);\n+    b.iter(|| v.retain(|x| *x == 826u32));\n+}"}, {"sha": "f3a30d0982569cf8ba0dc9e9f9fd034cb0a9f4bd", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c24c9067eec3aec8dd2013d24f6cd0dff3ecec4c/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c24c9067eec3aec8dd2013d24f6cd0dff3ecec4c/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=c24c9067eec3aec8dd2013d24f6cd0dff3ecec4c", "patch": "@@ -1488,7 +1488,15 @@ impl<T, A: Allocator> Vec<T, A> {\n \n         let mut g = BackshiftOnDrop { v: self, processed_len: 0, deleted_cnt: 0, original_len };\n \n-        while g.processed_len < original_len {\n+        // process_one return a bool indicates whether the processing element should be retained.\n+        #[inline(always)]\n+        fn process_one<F, T, A: Allocator, const DELETED: bool>(\n+            f: &mut F,\n+            g: &mut BackshiftOnDrop<'_, T, A>,\n+        ) -> bool\n+        where\n+            F: FnMut(&T) -> bool,\n+        {\n             // SAFETY: Unchecked element must be valid.\n             let cur = unsafe { &mut *g.v.as_mut_ptr().add(g.processed_len) };\n             if !f(cur) {\n@@ -1498,9 +1506,9 @@ impl<T, A: Allocator> Vec<T, A> {\n                 // SAFETY: We never touch this element again after dropped.\n                 unsafe { ptr::drop_in_place(cur) };\n                 // We already advanced the counter.\n-                continue;\n+                return false;\n             }\n-            if g.deleted_cnt > 0 {\n+            if DELETED {\n                 // SAFETY: `deleted_cnt` > 0, so the hole slot must not overlap with current element.\n                 // We use copy for move, and never touch this element again.\n                 unsafe {\n@@ -1509,6 +1517,19 @@ impl<T, A: Allocator> Vec<T, A> {\n                 }\n             }\n             g.processed_len += 1;\n+            return true;\n+        }\n+\n+        // Stage 1: Nothing was deleted.\n+        while g.processed_len != original_len {\n+            if !process_one::<F, T, A, false>(&mut f, &mut g) {\n+                break;\n+            }\n+        }\n+\n+        // Stage 2: Some elements were deleted.\n+        while g.processed_len != original_len {\n+            process_one::<F, T, A, true>(&mut f, &mut g);\n         }\n \n         // All item are processed. This can be optimized to `set_len` by LLVM."}]}