{"sha": "7ffd408d86e3fc9b8e9aafaef20ec4e096f1b55b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmZmQ0MDhkODZlM2ZjOWI4ZTlhYWZhZWYyMGVjNGUwOTZmMWI1NWI=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-01-20T02:34:52Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-01-20T02:58:59Z"}, "message": "Fix a bug with caching ids in the HIR lowering with nested lowered nodes\n\nBlocks #30884", "tree": {"sha": "b914362923d38a0238f1dcb3b27ae13259512d04", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b914362923d38a0238f1dcb3b27ae13259512d04"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7ffd408d86e3fc9b8e9aafaef20ec4e096f1b55b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7ffd408d86e3fc9b8e9aafaef20ec4e096f1b55b", "html_url": "https://github.com/rust-lang/rust/commit/7ffd408d86e3fc9b8e9aafaef20ec4e096f1b55b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7ffd408d86e3fc9b8e9aafaef20ec4e096f1b55b/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "08886499cf0f7fea5de2cc555ea7bfe9ceb0b40f", "url": "https://api.github.com/repos/rust-lang/rust/commits/08886499cf0f7fea5de2cc555ea7bfe9ceb0b40f", "html_url": "https://github.com/rust-lang/rust/commit/08886499cf0f7fea5de2cc555ea7bfe9ceb0b40f"}], "stats": {"total": 113, "additions": 61, "deletions": 52}, "files": [{"sha": "f6342831143256ce0709603d945a7cddc07986cb", "filename": "src/librustc_front/lowering.rs", "status": "modified", "additions": 61, "deletions": 52, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/7ffd408d86e3fc9b8e9aafaef20ec4e096f1b55b/src%2Flibrustc_front%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ffd408d86e3fc9b8e9aafaef20ec4e096f1b55b/src%2Flibrustc_front%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Flowering.rs?ref=7ffd408d86e3fc9b8e9aafaef20ec4e096f1b55b", "patch": "@@ -87,7 +87,8 @@ pub struct LoweringContext<'a> {\n     cached_id: Cell<u32>,\n     // Keep track of gensym'ed idents.\n     gensym_cache: RefCell<HashMap<(NodeId, &'static str), hir::Ident>>,\n-    // A copy of cached_id, but is also set to an id while it is being cached.\n+    // A copy of cached_id, but is also set to an id while a node is lowered for\n+    // the first time.\n     gensym_key: Cell<u32>,\n }\n \n@@ -114,32 +115,79 @@ impl<'a, 'hir> LoweringContext<'a> {\n     }\n \n     fn next_id(&self) -> NodeId {\n-        let cached = self.cached_id.get();\n-        if cached == 0 {\n+        let cached_id = self.cached_id.get();\n+        if cached_id == 0 {\n             return self.id_assigner.next_node_id();\n         }\n \n-        self.cached_id.set(cached + 1);\n-        cached\n+        self.cached_id.set(cached_id + 1);\n+        cached_id\n     }\n \n     fn str_to_ident(&self, s: &'static str) -> hir::Ident {\n-        let cached_id = self.gensym_key.get();\n-        if cached_id == 0 {\n+        let gensym_key = self.gensym_key.get();\n+        if gensym_key == 0 {\n             return hir::Ident::from_name(token::gensym(s));\n         }\n \n-        let cached = self.gensym_cache.borrow().contains_key(&(cached_id, s));\n+        let cached = self.gensym_cache.borrow().contains_key(&(gensym_key, s));\n         if cached {\n-            self.gensym_cache.borrow()[&(cached_id, s)]\n+            self.gensym_cache.borrow()[&(gensym_key, s)]\n         } else {\n             let result = hir::Ident::from_name(token::gensym(s));\n-            self.gensym_cache.borrow_mut().insert((cached_id, s), result);\n+            self.gensym_cache.borrow_mut().insert((gensym_key, s), result);\n             result\n         }\n     }\n }\n \n+// Utility fn for setting and unsetting the cached id.\n+fn cache_ids<'a, OP, R>(lctx: &LoweringContext, expr_id: NodeId, op: OP) -> R\n+    where OP: FnOnce(&LoweringContext) -> R\n+{\n+    // Only reset the id if it was previously 0, i.e., was not cached.\n+    // If it was cached, we are in a nested node, but our id count will\n+    // still count towards the parent's count.\n+    let reset_cached_id = lctx.cached_id.get() == 0;\n+    // We always reset gensym_key so that if we use the same name in a nested\n+    // node and after that node, they get different values.\n+    let old_gensym_key = lctx.gensym_key.get();\n+\n+    {\n+        let id_cache: &mut HashMap<_, _> = &mut lctx.id_cache.borrow_mut();\n+\n+        if id_cache.contains_key(&expr_id) {\n+            let cached_id = lctx.cached_id.get();\n+            if cached_id == 0 {\n+                // We're entering a node where we need to track ids, but are not\n+                // yet tracking.\n+                lctx.cached_id.set(id_cache[&expr_id]);\n+            } else {\n+                // We're already tracking - check that the tracked id is the same\n+                // as the expected id.\n+                assert!(cached_id == id_cache[&expr_id], \"id mismatch\");\n+            }\n+            lctx.gensym_key.set(id_cache[&expr_id]);\n+        } else {\n+            // We've never lowered this node before, remember it for next time.\n+            let next_id = lctx.id_assigner.peek_node_id();\n+            id_cache.insert(expr_id, next_id);\n+            lctx.gensym_key.set(next_id);\n+            // self.cached_id is not set when we lower a node for the first time,\n+            // only on re-lowering.\n+        }\n+    }\n+\n+    let result = op(lctx);\n+\n+    if reset_cached_id {\n+        lctx.cached_id.set(0);\n+    }\n+    lctx.gensym_key.set(old_gensym_key);\n+\n+    result\n+}\n+\n pub fn lower_ident(_lctx: &LoweringContext, ident: Ident) -> hir::Ident {\n     hir::Ident {\n         name: mtwt::resolve(ident),\n@@ -918,47 +966,6 @@ pub fn lower_pat(lctx: &LoweringContext, p: &Pat) -> P<hir::Pat> {\n     })\n }\n \n-// Utility fn for setting and unsetting the cached id.\n-fn cache_ids<'a, OP, R>(lctx: &LoweringContext, expr_id: NodeId, op: OP) -> R\n-    where OP: FnOnce(&LoweringContext) -> R\n-{\n-    // Only reset the id if it was previously 0, i.e., was not cached.\n-    // If it was cached, we are in a nested node, but our id count will\n-    // still count towards the parent's count.\n-    let reset_cached_id = lctx.cached_id.get() == 0;\n-\n-    {\n-        let id_cache: &mut HashMap<_, _> = &mut lctx.id_cache.borrow_mut();\n-\n-        if id_cache.contains_key(&expr_id) {\n-            let cached_id = lctx.cached_id.get();\n-            if cached_id == 0 {\n-                // We're entering a node where we need to track ids, but are not\n-                // yet tracking.\n-                lctx.cached_id.set(id_cache[&expr_id]);\n-                lctx.gensym_key.set(id_cache[&expr_id]);\n-            } else {\n-                // We're already tracking - check that the tracked id is the same\n-                // as the expected id.\n-                assert!(cached_id == id_cache[&expr_id], \"id mismatch\");\n-            }\n-        } else {\n-            let next_id = lctx.id_assigner.peek_node_id();\n-            id_cache.insert(expr_id, next_id);\n-            lctx.gensym_key.set(next_id);\n-        }\n-    }\n-\n-    let result = op(lctx);\n-\n-    if reset_cached_id {\n-        lctx.cached_id.set(0);\n-        lctx.gensym_key.set(0);\n-    }\n-\n-    result\n-}\n-\n pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n     P(hir::Expr {\n         id: e.id,\n@@ -1935,7 +1942,9 @@ mod test {\n         let ast_while_let = assigner.fold_expr(ast_while_let);\n         let ast_for = quote_expr!(&cx,\n                                   for i in 0..10 {\n-                                      foo(i);\n+                                      for j in 0..10 {\n+                                          foo(i, j);\n+                                      }\n                                   });\n         let ast_for = assigner.fold_expr(ast_for);\n         let ast_in = quote_expr!(&cx, in HEAP { foo() });"}]}