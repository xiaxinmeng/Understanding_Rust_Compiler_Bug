{"sha": "5633d4641f7d63805e3c12c899f8401410bd825f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2MzNkNDY0MWY3ZDYzODA1ZTNjMTJjODk5Zjg0MDE0MTBiZDgyNWY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-05-20T00:23:26Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-05-22T21:42:02Z"}, "message": "libstd: Remove all uses of `~str` from `libstd`", "tree": {"sha": "f391ab3aedba4112c3bc36b796eee62d1e850fa4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f391ab3aedba4112c3bc36b796eee62d1e850fa4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5633d4641f7d63805e3c12c899f8401410bd825f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5633d4641f7d63805e3c12c899f8401410bd825f", "html_url": "https://github.com/rust-lang/rust/commit/5633d4641f7d63805e3c12c899f8401410bd825f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5633d4641f7d63805e3c12c899f8401410bd825f/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a9dd903d79b053eb85302572e53717ad865c813d", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9dd903d79b053eb85302572e53717ad865c813d", "html_url": "https://github.com/rust-lang/rust/commit/a9dd903d79b053eb85302572e53717ad865c813d"}], "stats": {"total": 500, "additions": 238, "deletions": 262}, "files": [{"sha": "1c9940c5b1fe130951567eda3ea9cd69c2076906", "filename": "src/libcollections/bitv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Flibcollections%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Flibcollections%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbitv.rs?ref=5633d4641f7d63805e3c12c899f8401410bd825f", "patch": "@@ -538,7 +538,7 @@ impl Bitv {\n      * The resulting string has the same length as `self`, and each\n      * character is either '0' or '1'.\n      */\n-     pub fn to_str(&self) -> ~str {\n+     pub fn to_str(&self) -> StrBuf {\n         let mut rs = StrBuf::new();\n         for i in self.iter() {\n             if i {\n@@ -547,7 +547,7 @@ impl Bitv {\n                 rs.push_char('0');\n             }\n         };\n-        rs.into_owned()\n+        rs\n      }\n \n "}, {"sha": "60528776294e98a7761c253edc46b79c0a0b4548", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=5633d4641f7d63805e3c12c899f8401410bd825f", "patch": "@@ -661,7 +661,7 @@ pub fn getopts(args: &[StrBuf], optgrps: &[OptGroup]) -> Result {\n /// Derive a usage message from a set of long options.\n pub fn usage(brief: &str, opts: &[OptGroup]) -> StrBuf {\n \n-    let desc_sep = \"\\n\" + \" \".repeat(24);\n+    let desc_sep = format!(\"\\n{}\", \" \".repeat(24));\n \n     let mut rows = opts.iter().map(|optref| {\n         let OptGroup{short_name: short_name,\n@@ -713,7 +713,7 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> StrBuf {\n                 row.push_char(' ');\n             }\n         } else {\n-            row.push_str(desc_sep)\n+            row.push_str(desc_sep.as_slice())\n         }\n \n         // Normalize desc to contain words separated by one space character\n@@ -734,7 +734,7 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> StrBuf {\n \n         // FIXME: #5516 should be graphemes not codepoints\n         // wrapped description\n-        row.push_str(desc_rows.connect(desc_sep));\n+        row.push_str(desc_rows.connect(desc_sep.as_slice()).as_slice());\n \n         row\n     });\n@@ -784,7 +784,11 @@ fn format_option(opt: &OptGroup) -> StrBuf {\n /// Derive a short one-line usage summary from a set of long options.\n pub fn short_usage(program_name: &str, opts: &[OptGroup]) -> StrBuf {\n     let mut line = format_strbuf!(\"Usage: {} \", program_name);\n-    line.push_str(opts.iter().map(format_option).collect::<Vec<StrBuf>>().connect(\" \"));\n+    line.push_str(opts.iter()\n+                      .map(format_option)\n+                      .collect::<Vec<StrBuf>>()\n+                      .connect(\" \")\n+                      .as_slice());\n     line\n }\n "}, {"sha": "9d7c07498ff3fad50a810ae697bd126fea2b0c22", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=5633d4641f7d63805e3c12c899f8401410bd825f", "patch": "@@ -369,7 +369,8 @@ pub mod write {\n                     sess.note(format!(\"{}\", &cmd).as_slice());\n                     let mut note = prog.error.clone();\n                     note.push_all(prog.output.as_slice());\n-                    sess.note(str::from_utf8(note.as_slice()).unwrap().to_owned());\n+                    sess.note(str::from_utf8(note.as_slice()).unwrap()\n+                                                             .as_slice());\n                     sess.abort_if_errors();\n                 }\n             },\n@@ -538,8 +539,8 @@ pub fn find_crate_id(attrs: &[ast::Attribute], out_filestem: &str) -> CrateId {\n     match attr::find_crateid(attrs) {\n         None => from_str(out_filestem).unwrap_or_else(|| {\n             let mut s = out_filestem.chars().filter(|c| c.is_XID_continue());\n-            from_str(s.collect::<StrBuf>()\n-                      .to_owned()).or(from_str(\"rust-out\")).unwrap()\n+            from_str(s.collect::<StrBuf>().as_slice())\n+                .or(from_str(\"rust-out\")).unwrap()\n         }),\n         Some(s) => s,\n     }\n@@ -698,7 +699,7 @@ pub fn exported_name(path: PathElems, hash: &str, vers: &str) -> StrBuf {\n     // The version will get mangled to have a leading '_', but it makes more\n     // sense to lead with a 'v' b/c this is a version...\n     let vers = if vers.len() > 0 && !char::is_XID_start(vers.char_at(0)) {\n-        \"v\" + vers\n+        format!(\"v{}\", vers)\n     } else {\n         vers.to_owned()\n     };\n@@ -1075,7 +1076,8 @@ fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n                 sess.note(format!(\"{}\", &cmd).as_slice());\n                 let mut output = prog.error.clone();\n                 output.push_all(prog.output.as_slice());\n-                sess.note(str::from_utf8(output.as_slice()).unwrap().to_owned());\n+                sess.note(str::from_utf8(output.as_slice()).unwrap()\n+                                                           .as_slice());\n                 sess.abort_if_errors();\n             }\n         },"}, {"sha": "2fb730e4daeecd79e8457f95b6173e1fcaa04d3b", "filename": "src/librustc/driver/mod.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Flibrustc%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Flibrustc%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fmod.rs?ref=5633d4641f7d63805e3c12c899f8401410bd825f", "patch": "@@ -143,8 +143,8 @@ Available lint options:\n     for &(_, name) in lint_dict.iter() {\n         max_key = cmp::max(name.len(), max_key);\n     }\n-    fn padded(max: uint, s: &str) -> ~str {\n-        \" \".repeat(max - s.len()) + s\n+    fn padded(max: uint, s: &str) -> StrBuf {\n+        format!(\"{}{}\", \" \".repeat(max - s.len()), s)\n     }\n     println!(\"\\nAvailable lint checks:\\n\");\n     println!(\"    {}  {:7.7s}  {}\",\n@@ -154,7 +154,7 @@ Available lint options:\n     for (spec, name) in lint_dict.move_iter() {\n         let name = name.replace(\"_\", \"-\");\n         println!(\"    {}  {:7.7s}  {}\",\n-                 padded(max_key, name),\n+                 padded(max_key, name.as_slice()),\n                  lint::level_to_str(spec.default),\n                  spec.desc);\n     }\n@@ -400,11 +400,12 @@ fn monitor(f: proc():Send) {\n \n                 let xs = [\n                     \"the compiler hit an unexpected failure path. this is a bug.\".to_owned(),\n-                    \"we would appreciate a bug report: \" + BUG_REPORT_URL,\n+                    format!(\"we would appreciate a bug report: {}\",\n+                            BUG_REPORT_URL),\n                     \"run with `RUST_BACKTRACE=1` for a backtrace\".to_owned(),\n                 ];\n                 for note in xs.iter() {\n-                    emitter.emit(None, *note, diagnostic::Note)\n+                    emitter.emit(None, note.as_slice(), diagnostic::Note)\n                 }\n \n                 match r.read_to_str() {"}, {"sha": "a0742669cc07e9a38be051ada15aa4d1865df2b0", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=5633d4641f7d63805e3c12c899f8401410bd825f", "patch": "@@ -602,7 +602,7 @@ fn encode_visibility(ebml_w: &mut Encoder, visibility: Visibility) {\n         Public => 'y',\n         Inherited => 'i',\n     };\n-    ebml_w.wr_str(str::from_char(ch));\n+    ebml_w.wr_str(str::from_char(ch).as_slice());\n     ebml_w.end_tag();\n }\n \n@@ -848,7 +848,7 @@ fn encode_sized(ebml_w: &mut Encoder, sized: Sized) {\n         DynSize => 'd',\n         StaticSize => 's',\n     };\n-    ebml_w.wr_str(str::from_char(ch));\n+    ebml_w.wr_str(str::from_char(ch).as_slice());\n     ebml_w.end_tag();\n }\n \n@@ -1885,5 +1885,5 @@ pub fn encoded_ty(tcx: &ty::ctxt, t: ty::t) -> StrBuf {\n         tcx: tcx,\n         abbrevs: &RefCell::new(HashMap::new())\n     }, t);\n-    str::from_utf8_owned(wr.get_ref().to_owned()).unwrap().to_strbuf()\n+    str::from_utf8_owned(Vec::from_slice(wr.get_ref())).unwrap().to_strbuf()\n }"}, {"sha": "9a63aad893f5f22a82282f8a83fa3d8d015010fe", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=5633d4641f7d63805e3c12c899f8401410bd825f", "patch": "@@ -552,7 +552,7 @@ fn get_metadata_section_imp(os: Os, filename: &Path) -> Result<MetadataBlob, Str\n             let name_len = llvm::LLVMRustGetSectionName(si.llsi, &mut name_buf);\n             let name = str::raw::from_buf_len(name_buf as *u8, name_len as uint);\n             debug!(\"get_metadata_section: name {}\", name);\n-            if read_meta_section_name(os) == name {\n+            if read_meta_section_name(os).as_slice() == name.as_slice() {\n                 let cbuf = llvm::LLVMGetSectionContents(si.llsi);\n                 let csz = llvm::LLVMGetSectionSize(si.llsi) as uint;\n                 let mut found ="}, {"sha": "2cc6a9028dca17d1798b23425465c8f9474f271d", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=5633d4641f7d63805e3c12c899f8401410bd825f", "patch": "@@ -452,7 +452,7 @@ fn parse_abi_set(st: &mut PState) -> abi::Abi {\n     assert_eq!(next(st), '[');\n     scan(st, |c| c == ']', |bytes| {\n         let abi_str = str::from_utf8(bytes).unwrap().to_owned();\n-        abi::lookup(abi_str).expect(abi_str)\n+        abi::lookup(abi_str.as_slice()).expect(abi_str)\n     })\n }\n "}, {"sha": "3d69e84b63c92e66609a55db2b17266c09dcc206", "filename": "src/librustc/middle/cfg/graphviz.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs?ref=5633d4641f7d63805e3c12c899f8401410bd825f", "patch": "@@ -37,7 +37,8 @@ fn replace_newline_with_backslash_l(s: StrBuf) -> StrBuf {\n         // \\l, not the line that follows; so, add \\l at end of string\n         // if not already present, ensuring last line gets left-aligned\n         // as well.\n-        let mut last_two : Vec<_> = s.chars().rev().take(2).collect();\n+        let mut last_two: Vec<_> =\n+            s.as_slice().chars().rev().take(2).collect();\n         last_two.reverse();\n         if last_two.as_slice() != ['\\\\', 'l'] {\n             s = s.append(\"\\\\l\");"}, {"sha": "fa299dc05036c0053fd66b06caba0206c7610de4", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=5633d4641f7d63805e3c12c899f8401410bd825f", "patch": "@@ -67,7 +67,8 @@ pub fn trans_inline_asm<'a>(bcx: &'a Block<'a>, ia: &ast::InlineAsm)\n         StrBuf::from_str(constraints.iter()\n                                     .map(|s| s.get().to_strbuf())\n                                     .collect::<Vec<StrBuf>>()\n-                                    .connect(\",\"));\n+                                    .connect(\",\")\n+                                    .as_slice());\n \n     let mut clobbers = getClobbers();\n     if !ia.clobbers.get().is_empty() && !clobbers.is_empty() {"}, {"sha": "c103a44aa754363aad881a381247ffad68050c42", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=5633d4641f7d63805e3c12c899f8401410bd825f", "patch": "@@ -454,7 +454,10 @@ pub fn declare_tydesc(ccx: &CrateContext, t: ty::t) -> tydesc_info {\n fn declare_generic_glue(ccx: &CrateContext, t: ty::t, llfnty: Type,\n                         name: &str) -> ValueRef {\n     let _icx = push_ctxt(\"declare_generic_glue\");\n-    let fn_nm = mangle_internal_name_by_type_and_seq(ccx, t, \"glue_\".to_owned() + name);\n+    let fn_nm = mangle_internal_name_by_type_and_seq(\n+        ccx,\n+        t,\n+        format!(\"glue_{}\", name).as_slice());\n     debug!(\"{} is for type {}\", fn_nm, ppaux::ty_to_str(ccx.tcx(), t));\n     let llfn = decl_cdecl_fn(ccx.llmod,\n                              fn_nm.as_slice(),"}, {"sha": "a0184e2cbe3b52391663273e82936c9fb5701a12", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=5633d4641f7d63805e3c12c899f8401410bd825f", "patch": "@@ -87,7 +87,8 @@ impl<'a, 'b> Reflector<'a, 'b> {\n     pub fn visit(&mut self, ty_name: &str, args: &[ValueRef]) {\n         let fcx = self.bcx.fcx;\n         let tcx = self.bcx.tcx();\n-        let mth_idx = ty::method_idx(token::str_to_ident(\"visit_\".to_owned() + ty_name),\n+        let mth_idx = ty::method_idx(token::str_to_ident(format!(\n+                        \"visit_{}\", ty_name).as_slice()),\n                                      self.visitor_methods.as_slice()).expect(\n                 format!(\"couldn't find visit method for {}\", ty_name));\n         let mth_ty =\n@@ -154,7 +155,7 @@ impl<'a, 'b> Reflector<'a, 'b> {\n           ty::ty_vec(ref mt, Some(sz)) => {\n               let extra = (vec!(self.c_uint(sz))).append(self.c_size_and_align(t).as_slice());\n               let extra = extra.append(self.c_mt(mt).as_slice());\n-              self.visit(\"evec_fixed\".to_owned(), extra.as_slice())\n+              self.visit(\"evec_fixed\", extra.as_slice())\n           }\n           ty::ty_vec(..) | ty::ty_str => fail!(\"unexpected unsized type\"),\n           // Should remove mt from box and uniq.\n@@ -170,9 +171,9 @@ impl<'a, 'b> Reflector<'a, 'b> {\n                   ty::ty_vec(ref mt, None) => {\n                       let extra = Vec::new();\n                       let extra = extra.append(self.c_mt(mt).as_slice());\n-                      self.visit(\"evec_uniq\".to_owned(), extra.as_slice())\n+                      self.visit(\"evec_uniq\", extra.as_slice())\n                   }\n-                  ty::ty_str => self.visit(\"estr_uniq\".to_owned(), &[]),\n+                  ty::ty_str => self.visit(\"estr_uniq\", &[]),\n                   _ => {\n                       let extra = self.c_mt(&ty::mt {\n                           ty: typ,\n@@ -191,9 +192,10 @@ impl<'a, 'b> Reflector<'a, 'b> {\n                   ty::ty_vec(ref mt, None) => {\n                       let (name, extra) = (\"slice\".to_owned(), Vec::new());\n                       let extra = extra.append(self.c_mt(mt).as_slice());\n-                      self.visit(\"evec_\".to_owned() + name, extra.as_slice())\n+                      self.visit(format!(\"evec_{}\", name).as_slice(),\n+                                 extra.as_slice())\n                   }\n-                  ty::ty_str => self.visit(\"estr_slice\".to_owned(), &[]),\n+                  ty::ty_str => self.visit(\"estr_slice\", &[]),\n                   _ => {\n                       let extra = self.c_mt(mt);\n                       self.visit(\"rptr\", extra.as_slice())"}, {"sha": "087a4e58d497808299dcf75127e0969e387ddb32", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=5633d4641f7d63805e3c12c899f8401410bd825f", "patch": "@@ -327,7 +327,7 @@ pub fn ty_to_str(cx: &ctxt, typ: t) -> StrBuf {\n                        sig: &ty::FnSig) {\n         s.push_char(bra);\n         let strs: Vec<StrBuf> = sig.inputs.iter().map(|a| fn_input_to_str(cx, *a)).collect();\n-        s.push_str(strs.connect(\", \"));\n+        s.push_str(strs.connect(\", \").as_slice());\n         if sig.variadic {\n             s.push_str(\", ...\");\n         }"}, {"sha": "e6f46ea715919c006144b865eb2e4e3f71b65a68", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=5633d4641f7d63805e3c12c899f8401410bd825f", "patch": "@@ -425,7 +425,9 @@ impl<'a> ::Encoder<io::IoError> for Encoder<'a> {\n     }\n     fn emit_f32(&mut self, v: f32) -> EncodeResult { self.emit_f64(v as f64) }\n \n-    fn emit_char(&mut self, v: char) -> EncodeResult { self.emit_str(str::from_char(v)) }\n+    fn emit_char(&mut self, v: char) -> EncodeResult {\n+        self.emit_str(str::from_char(v).as_slice())\n+    }\n     fn emit_str(&mut self, v: &str) -> EncodeResult {\n         write!(self.wr, \"{}\", escape_str(v))\n     }\n@@ -614,9 +616,13 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n     fn emit_f64(&mut self, v: f64) -> EncodeResult {\n         write!(self.wr, \"{}\", f64::to_str_digits(v, 6u))\n     }\n-    fn emit_f32(&mut self, v: f32) -> EncodeResult { self.emit_f64(v as f64) }\n+    fn emit_f32(&mut self, v: f32) -> EncodeResult {\n+        self.emit_f64(v as f64)\n+    }\n \n-    fn emit_char(&mut self, v: char) -> EncodeResult { self.emit_str(str::from_char(v)) }\n+    fn emit_char(&mut self, v: char) -> EncodeResult {\n+        self.emit_str(str::from_char(v).as_slice())\n+    }\n     fn emit_str(&mut self, v: &str) -> EncodeResult {\n         write!(self.wr, \"{}\", escape_str(v))\n     }"}, {"sha": "0b3dd414967074fd033f0345d534dcf167216c24", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=5633d4641f7d63805e3c12c899f8401410bd825f", "patch": "@@ -419,8 +419,8 @@ unsafe fn str_map_bytes(string: StrBuf, map: &'static [u8]) -> StrBuf {\n \n #[inline]\n unsafe fn str_copy_map_bytes(string: &str, map: &'static [u8]) -> StrBuf {\n-    let mut s = string.to_owned();\n-    for b in str::raw::as_owned_vec(&mut s).mut_iter() {\n+    let mut s = string.to_strbuf();\n+    for b in s.as_mut_bytes().mut_iter() {\n         *b = map[*b as uint];\n     }\n     s.into_strbuf()"}, {"sha": "4622c0934fe44b06a6abad43d50770ab1fd6e16e", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=5633d4641f7d63805e3c12c899f8401410bd825f", "patch": "@@ -323,29 +323,6 @@ impl<'a> ToCStr for &'a str {\n     }\n }\n \n-impl ToCStr for ~str {\n-    #[inline]\n-    fn to_c_str(&self) -> CString {\n-        self.as_bytes().to_c_str()\n-    }\n-\n-    #[inline]\n-    unsafe fn to_c_str_unchecked(&self) -> CString {\n-        self.as_bytes().to_c_str_unchecked()\n-    }\n-\n-    #[inline]\n-    fn with_c_str<T>(&self, f: |*libc::c_char| -> T) -> T {\n-        self.as_bytes().with_c_str(f)\n-    }\n-\n-    #[inline]\n-    unsafe fn with_c_str_unchecked<T>(&self, f: |*libc::c_char| -> T) -> T {\n-        self.as_bytes().with_c_str_unchecked(f)\n-    }\n-}\n-\n-\n impl ToCStr for StrBuf {\n     #[inline]\n     fn to_c_str(&self) -> CString {"}, {"sha": "22ac397c702c32d7c1c947b7ad1ed11b3ba1fa84", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=5633d4641f7d63805e3c12c899f8401410bd825f", "patch": "@@ -47,9 +47,9 @@\n //! for which the [`slice`](slice/index.html) module defines many\n //! methods.\n //!\n-//! UTF-8 strings, `~str` and `&str`, are built-in types, and the\n-//! standard library defines methods for them on a variety of traits\n-//! in the [`str`](str/index.html) module. Rust strings are immutable;\n+//! `&str`, a UTF-8 string, is a built-in type, and the standard library\n+//! defines methods for it on a variety of traits in the\n+//! [`str`](str/index.html) module. Rust strings are immutable;\n //! use the `StrBuf` type defined in [`strbuf`](strbuf/index.html)\n //! for a mutable string builder.\n //!"}, {"sha": "f406cc9532fc2994cd6cd62a42ecb799871e7fcb", "filename": "src/libstd/str.rs", "status": "modified", "additions": 121, "deletions": 164, "changes": 285, "blob_url": "https://github.com/rust-lang/rust/blob/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=5633d4641f7d63805e3c12c899f8401410bd825f", "patch": "@@ -17,37 +17,29 @@ Unicode string manipulation (`str` type)\n Rust's string type is one of the core primitive types of the language. While\n represented by the name `str`, the name `str` is not actually a valid type in\n Rust. Each string must also be decorated with its ownership. This means that\n-there are two common kinds of strings in Rust:\n-\n-* `~str` - This is an owned string. This type obeys all of the normal semantics\n-           of the `Box<T>` types, meaning that it has one, and only one,\n-           owner. This type cannot be implicitly copied, and is moved out of\n-           when passed to other functions.\n+there is one common kind of string in Rust:\n \n * `&str` - This is the borrowed string type. This type of string can only be\n            created from the other kind of string. As the name \"borrowed\"\n            implies, this type of string is owned elsewhere, and this string\n            cannot be moved out of.\n \n-As an example, here's a few different kinds of strings.\n+As an example, here's the one kind of string.\n \n ```rust\n fn main() {\n-    let owned_string = \"I am an owned string\".to_owned();\n-    let borrowed_string1 = \"This string is borrowed with the 'static lifetime\";\n-    let borrowed_string2: &str = owned_string;   // owned strings can be borrowed\n+    let borrowed_string = \"This string is borrowed with the 'static lifetime\";\n }\n ```\n \n-From the example above, you can see that Rust has 2 different kinds of string\n-literals. The owned literals correspond to the owned string types, but the\n-\"borrowed literal\" is actually more akin to C's concept of a static string.\n+From the example above, you can see that Rust has 1 different kind of string\n+literal. The \"borrowed literal\" is akin to C's concept of a static string.\n \n-When a string is declared without a `~` sigil, then the string is allocated\n-statically in the rodata of the executable/library. The string then has the\n-type `&'static str` meaning that the string is valid for the `'static`\n-lifetime, otherwise known as the lifetime of the entire program. As can be\n-inferred from the type, these static strings are not mutable.\n+String literals are allocated statically in the rodata of the\n+executable/library. The string then has the type `&'static str` meaning that\n+the string is valid for the `'static` lifetime, otherwise known as the\n+lifetime of the entire program. As can be inferred from the type, these static\n+strings are not mutable.\n \n # Mutability\n \n@@ -67,10 +59,8 @@ stream of UTF-8 bytes. All safely-created strings are guaranteed to be validly\n encoded UTF-8 sequences. Additionally, strings are not null-terminated\n and can contain null codepoints.\n \n-The actual representation of strings have direct mappings to vectors:\n-\n-* `~str` is the same as `~[u8]`\n-* `&str` is the same as `&[u8]`\n+The actual representation of strings have direct mappings to vectors: `&str`\n+is the same as `&[u8]`.\n \n */\n \n@@ -81,13 +71,12 @@ use cmp::{Eq, TotalEq, Ord, TotalOrd, Equiv, Ordering};\n use container::Container;\n use default::Default;\n use fmt;\n-use from_str::FromStr;\n use io::Writer;\n use iter::{Iterator, range, AdditiveIterator};\n use mem::transmute;\n use mem;\n use option::{None, Option, Some};\n-use result::{Result, Ok, Err};\n+use result::Result;\n use slice::Vector;\n use slice::{ImmutableVector, MutableVector, CloneableVector};\n use strbuf::StrBuf;\n@@ -109,53 +98,46 @@ Section: Creating a string\n ///\n /// Returns `Err` with the original vector if the vector contains invalid\n /// UTF-8.\n-pub fn from_utf8_owned(vv: ~[u8]) -> Result<~str, ~[u8]> {\n-    if is_utf8(vv) {\n-        Ok(unsafe { raw::from_utf8_owned(vv) })\n-    } else {\n-        Err(vv)\n-    }\n-}\n-\n-impl FromStr for ~str {\n-    #[inline]\n-    fn from_str(s: &str) -> Option<~str> { Some(s.to_owned()) }\n+pub fn from_utf8_owned(vv: Vec<u8>) -> Result<StrBuf, Vec<u8>> {\n+    StrBuf::from_utf8(vv)\n }\n \n /// Convert a byte to a UTF-8 string\n ///\n /// # Failure\n ///\n /// Fails if invalid UTF-8\n-pub fn from_byte(b: u8) -> ~str {\n+pub fn from_byte(b: u8) -> StrBuf {\n     assert!(b < 128u8);\n-    unsafe { ::mem::transmute(box [b]) }\n+    StrBuf::from_char(1, b as char)\n }\n \n /// Convert a char to a string\n-pub fn from_char(ch: char) -> ~str {\n+pub fn from_char(ch: char) -> StrBuf {\n     let mut buf = StrBuf::new();\n     buf.push_char(ch);\n-    buf.into_owned()\n+    buf\n }\n \n /// Convert a vector of chars to a string\n-pub fn from_chars(chs: &[char]) -> ~str {\n+pub fn from_chars(chs: &[char]) -> StrBuf {\n     chs.iter().map(|c| *c).collect()\n }\n \n /// Methods for vectors of strings\n pub trait StrVector {\n     /// Concatenate a vector of strings.\n-    fn concat(&self) -> ~str;\n+    fn concat(&self) -> StrBuf;\n \n     /// Concatenate a vector of strings, placing a given separator between each.\n-    fn connect(&self, sep: &str) -> ~str;\n+    fn connect(&self, sep: &str) -> StrBuf;\n }\n \n impl<'a, S: Str> StrVector for &'a [S] {\n-    fn concat(&self) -> ~str {\n-        if self.is_empty() { return \"\".to_owned(); }\n+    fn concat(&self) -> StrBuf {\n+        if self.is_empty() {\n+            return StrBuf::new();\n+        }\n \n         // `len` calculation may overflow but push_str but will check boundaries\n         let len = self.iter().map(|s| s.as_slice().len()).sum();\n@@ -166,14 +148,18 @@ impl<'a, S: Str> StrVector for &'a [S] {\n             result.push_str(s.as_slice())\n         }\n \n-        result.into_owned()\n+        result\n     }\n \n-    fn connect(&self, sep: &str) -> ~str {\n-        if self.is_empty() { return \"\".to_owned(); }\n+    fn connect(&self, sep: &str) -> StrBuf {\n+        if self.is_empty() {\n+            return StrBuf::new();\n+        }\n \n         // concat is faster\n-        if sep.is_empty() { return self.concat(); }\n+        if sep.is_empty() {\n+            return self.concat();\n+        }\n \n         // this is wrong without the guarantee that `self` is non-empty\n         // `len` calculation may overflow but push_str but will check boundaries\n@@ -190,18 +176,18 @@ impl<'a, S: Str> StrVector for &'a [S] {\n             }\n             result.push_str(s.as_slice());\n         }\n-        result.into_owned()\n+        result\n     }\n }\n \n impl<'a, S: Str> StrVector for Vec<S> {\n     #[inline]\n-    fn concat(&self) -> ~str {\n+    fn concat(&self) -> StrBuf {\n         self.as_slice().concat()\n     }\n \n     #[inline]\n-    fn connect(&self, sep: &str) -> ~str {\n+    fn connect(&self, sep: &str) -> StrBuf {\n         self.as_slice().connect(sep)\n     }\n }\n@@ -317,7 +303,7 @@ impl<'a> Iterator<char> for Decompositions<'a> {\n /// # Return value\n ///\n /// The original string with all occurrences of `from` replaced with `to`\n-pub fn replace(s: &str, from: &str, to: &str) -> ~str {\n+pub fn replace(s: &str, from: &str, to: &str) -> StrBuf {\n     let mut result = StrBuf::new();\n     let mut last_end = 0;\n     for (start, end) in s.match_indices(from) {\n@@ -326,7 +312,7 @@ pub fn replace(s: &str, from: &str, to: &str) -> ~str {\n         last_end = end;\n     }\n     result.push_str(unsafe{raw::slice_bytes(s, last_end, s.len())});\n-    result.into_owned()\n+    result\n }\n \n /*\n@@ -350,15 +336,15 @@ Section: Misc\n /// v[4] = 0xD800;\n /// assert_eq!(str::from_utf16(v), None);\n /// ```\n-pub fn from_utf16(v: &[u16]) -> Option<~str> {\n+pub fn from_utf16(v: &[u16]) -> Option<StrBuf> {\n     let mut s = StrBuf::with_capacity(v.len() / 2);\n     for c in utf16_items(v) {\n         match c {\n             ScalarValue(c) => s.push_char(c),\n             LoneSurrogate(_) => return None\n         }\n     }\n-    Some(s.into_owned())\n+    Some(s)\n }\n \n /// Decode a UTF-16 encoded vector `v` into a string, replacing\n@@ -376,7 +362,7 @@ pub fn from_utf16(v: &[u16]) -> Option<~str> {\n /// assert_eq!(str::from_utf16_lossy(v),\n ///            \"\ud834\udd1emus\\uFFFDic\\uFFFD\".to_owned());\n /// ```\n-pub fn from_utf16_lossy(v: &[u16]) -> ~str {\n+pub fn from_utf16_lossy(v: &[u16]) -> StrBuf {\n     utf16_items(v).map(|c| c.to_char_lossy()).collect()\n }\n \n@@ -523,14 +509,14 @@ pub fn from_utf8_lossy<'a>(v: &'a [u8]) -> MaybeOwned<'a> {\n Section: MaybeOwned\n */\n \n-/// A MaybeOwned is a string that can hold either a ~str or a &str.\n+/// A MaybeOwned is a string that can hold either a StrBuf or a &str.\n /// This can be useful as an optimization when an allocation is sometimes\n /// needed but not always.\n pub enum MaybeOwned<'a> {\n     /// A borrowed string\n     Slice(&'a str),\n     /// An owned string\n-    Owned(~str)\n+    Owned(StrBuf)\n }\n \n /// SendStr is a specialization of `MaybeOwned` to be sendable\n@@ -562,15 +548,10 @@ pub trait IntoMaybeOwned<'a> {\n     fn into_maybe_owned(self) -> MaybeOwned<'a>;\n }\n \n-impl<'a> IntoMaybeOwned<'a> for ~str {\n-    #[inline]\n-    fn into_maybe_owned(self) -> MaybeOwned<'a> { Owned(self) }\n-}\n-\n impl<'a> IntoMaybeOwned<'a> for StrBuf {\n     #[inline]\n     fn into_maybe_owned(self) -> MaybeOwned<'a> {\n-        Owned(self.into_owned())\n+        Owned(self)\n     }\n }\n \n@@ -626,7 +607,7 @@ impl<'a> Str for MaybeOwned<'a> {\n \n impl<'a> StrAllocating for MaybeOwned<'a> {\n     #[inline]\n-    fn into_owned(self) -> ~str {\n+    fn into_owned(self) -> StrBuf {\n         match self {\n             Slice(s) => s.to_owned(),\n             Owned(s) => s\n@@ -676,58 +657,37 @@ impl<'a> fmt::Show for MaybeOwned<'a> {\n \n /// Unsafe operations\n pub mod raw {\n+    use c_str::CString;\n     use libc;\n     use mem;\n-    use ptr::RawPtr;\n-    use raw::Slice;\n-    use slice::CloneableVector;\n-    use str::{is_utf8, StrAllocating};\n+    use strbuf::StrBuf;\n+    use vec::Vec;\n \n     pub use core::str::raw::{from_utf8, c_str_to_static_slice, slice_bytes};\n     pub use core::str::raw::{slice_unchecked};\n \n     /// Create a Rust string from a *u8 buffer of the given length\n-    pub unsafe fn from_buf_len(buf: *u8, len: uint) -> ~str {\n-        let v = Slice { data: buf, len: len };\n-        let bytes: &[u8] = ::mem::transmute(v);\n-        assert!(is_utf8(bytes));\n-        let s: &str = ::mem::transmute(bytes);\n-        s.to_owned()\n-    }\n-\n-    #[lang=\"strdup_uniq\"]\n-    #[cfg(not(test))]\n-    #[inline]\n-    unsafe fn strdup_uniq(ptr: *u8, len: uint) -> ~str {\n-        from_buf_len(ptr, len)\n+    pub unsafe fn from_buf_len(buf: *u8, len: uint) -> StrBuf {\n+        StrBuf::from_raw_parts(len, len, mem::transmute(buf))\n     }\n \n     /// Create a Rust string from a null-terminated C string\n-    pub unsafe fn from_c_str(buf: *libc::c_char) -> ~str {\n-        let mut curr = buf;\n-        let mut i = 0;\n-        while *curr != 0 {\n-            i += 1;\n-            curr = buf.offset(i);\n-        }\n-        from_buf_len(buf as *u8, i as uint)\n+    pub unsafe fn from_c_str(c_string: *libc::c_char) -> StrBuf {\n+        let mut buf = StrBuf::new();\n+        buf.push_bytes(CString::new(c_string, false).as_bytes_no_nul());\n+        buf\n     }\n \n     /// Converts an owned vector of bytes to a new owned string. This assumes\n     /// that the utf-8-ness of the vector has already been validated\n     #[inline]\n-    pub unsafe fn from_utf8_owned(v: ~[u8]) -> ~str {\n+    pub unsafe fn from_utf8_owned(v: Vec<u8>) -> StrBuf {\n         mem::transmute(v)\n     }\n \n     /// Converts a byte to a string.\n-    pub unsafe fn from_byte(u: u8) -> ~str { from_utf8_owned(box [u]) }\n-\n-    /// Access the str in its vector representation.\n-    /// The caller must preserve the valid UTF-8 property when modifying.\n-    #[inline]\n-    pub unsafe fn as_owned_vec<'a>(s: &'a mut ~str) -> &'a mut ~[u8] {\n-        mem::transmute(s)\n+    pub unsafe fn from_byte(u: u8) -> StrBuf {\n+        from_utf8_owned(vec![u])\n     }\n \n     /// Sets the length of a string\n@@ -755,8 +715,8 @@ Section: Trait implementations\n \n /// Any string that can be represented as a slice\n pub trait StrAllocating: Str {\n-    /// Convert `self` into a ~str, not making a copy if possible.\n-    fn into_owned(self) -> ~str;\n+    /// Convert `self` into a `StrBuf`, not making a copy if possible.\n+    fn into_owned(self) -> StrBuf;\n \n     /// Convert `self` into a `StrBuf`.\n     #[inline]\n@@ -767,27 +727,27 @@ pub trait StrAllocating: Str {\n     /// Convert `self` into a `StrBuf`, not making a copy if possible.\n     #[inline]\n     fn into_strbuf(self) -> StrBuf {\n-        StrBuf::from_owned_str(self.into_owned())\n+        self.into_owned()\n     }\n \n     /// Escape each char in `s` with `char::escape_default`.\n-    fn escape_default(&self) -> ~str {\n+    fn escape_default(&self) -> StrBuf {\n         let me = self.as_slice();\n         let mut out = StrBuf::with_capacity(me.len());\n         for c in me.chars() {\n             c.escape_default(|c| out.push_char(c));\n         }\n-        out.into_owned()\n+        out\n     }\n \n     /// Escape each char in `s` with `char::escape_unicode`.\n-    fn escape_unicode(&self) -> ~str {\n+    fn escape_unicode(&self) -> StrBuf {\n         let me = self.as_slice();\n         let mut out = StrBuf::with_capacity(me.len());\n         for c in me.chars() {\n             c.escape_unicode(|c| out.push_char(c));\n         }\n-        out.into_owned()\n+        out\n     }\n \n     /// Replace all occurrences of one string with another.\n@@ -814,7 +774,7 @@ pub trait StrAllocating: Str {\n     /// // not found, so no change.\n     /// assert_eq!(s.replace(\"cookie monster\", \"little lamb\"), s);\n     /// ```\n-    fn replace(&self, from: &str, to: &str) -> ~str {\n+    fn replace(&self, from: &str, to: &str) -> StrBuf {\n         let me = self.as_slice();\n         let mut result = StrBuf::new();\n         let mut last_end = 0;\n@@ -824,16 +784,16 @@ pub trait StrAllocating: Str {\n             last_end = end;\n         }\n         result.push_str(unsafe{raw::slice_bytes(me, last_end, me.len())});\n-        result.into_owned()\n+        result\n     }\n \n-    /// Copy a slice into a new owned str.\n+    /// Copy a slice into a new `StrBuf`.\n     #[inline]\n-    fn to_owned(&self) -> ~str {\n+    fn to_owned(&self) -> StrBuf {\n         use slice::Vector;\n \n         unsafe {\n-            ::mem::transmute(self.as_slice().as_bytes().to_owned())\n+            ::mem::transmute(Vec::from_slice(self.as_slice().as_bytes()))\n         }\n     }\n \n@@ -850,13 +810,13 @@ pub trait StrAllocating: Str {\n     }\n \n     /// Given a string, make a new string with repeated copies of it.\n-    fn repeat(&self, nn: uint) -> ~str {\n+    fn repeat(&self, nn: uint) -> StrBuf {\n         let me = self.as_slice();\n         let mut ret = StrBuf::with_capacity(nn * me.len());\n         for _ in range(0, nn) {\n             ret.push_str(me);\n         }\n-        ret.into_owned()\n+        ret\n     }\n \n     /// Levenshtein Distance between two strings.\n@@ -921,36 +881,33 @@ pub trait StrAllocating: Str {\n \n impl<'a> StrAllocating for &'a str {\n     #[inline]\n-    fn into_owned(self) -> ~str { self.to_owned() }\n-}\n-\n-impl<'a> StrAllocating for ~str {\n-    #[inline]\n-    fn into_owned(self) -> ~str { self }\n+    fn into_owned(self) -> StrBuf {\n+        self.to_owned()\n+    }\n }\n \n /// Methods for owned strings\n pub trait OwnedStr {\n     /// Consumes the string, returning the underlying byte buffer.\n     ///\n     /// The buffer does not have a null terminator.\n-    fn into_bytes(self) -> ~[u8];\n+    fn into_bytes(self) -> Vec<u8>;\n \n     /// Pushes the given string onto this string, returning the concatenation of the two strings.\n-    fn append(self, rhs: &str) -> ~str;\n+    fn append(self, rhs: &str) -> StrBuf;\n }\n \n-impl OwnedStr for ~str {\n+impl OwnedStr for StrBuf {\n     #[inline]\n-    fn into_bytes(self) -> ~[u8] {\n+    fn into_bytes(self) -> Vec<u8> {\n         unsafe { mem::transmute(self) }\n     }\n \n     #[inline]\n-    fn append(self, rhs: &str) -> ~str {\n+    fn append(self, rhs: &str) -> StrBuf {\n         let mut new_str = StrBuf::from_owned_str(self);\n         new_str.push_str(rhs);\n-        new_str.into_owned()\n+        new_str\n     }\n }\n \n@@ -1027,10 +984,10 @@ mod tests {\n     #[test]\n     fn test_collect() {\n         let empty = \"\".to_owned();\n-        let s: ~str = empty.chars().collect();\n+        let s: StrBuf = empty.chars().collect();\n         assert_eq!(empty, s);\n         let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\".to_owned();\n-        let s: ~str = data.chars().collect();\n+        let s: StrBuf = data.chars().collect();\n         assert_eq!(data, s);\n     }\n \n@@ -1086,25 +1043,25 @@ mod tests {\n \n     #[test]\n     fn test_concat() {\n-        fn t(v: &[~str], s: &str) {\n+        fn t(v: &[StrBuf], s: &str) {\n             assert_eq!(v.concat(), s.to_str().into_owned());\n         }\n         t([\"you\".to_owned(), \"know\".to_owned(), \"I'm\".to_owned(),\n           \"no\".to_owned(), \"good\".to_owned()], \"youknowI'mnogood\");\n-        let v: &[~str] = [];\n+        let v: &[StrBuf] = [];\n         t(v, \"\");\n         t([\"hi\".to_owned()], \"hi\");\n     }\n \n     #[test]\n     fn test_connect() {\n-        fn t(v: &[~str], sep: &str, s: &str) {\n+        fn t(v: &[StrBuf], sep: &str, s: &str) {\n             assert_eq!(v.connect(sep), s.to_str().into_owned());\n         }\n         t([\"you\".to_owned(), \"know\".to_owned(), \"I'm\".to_owned(),\n            \"no\".to_owned(), \"good\".to_owned()],\n           \" \", \"you know I'm no good\");\n-        let v: &[~str] = [];\n+        let v: &[StrBuf] = [];\n         t(v, \" \", \"\");\n         t([\"hi\".to_owned()], \" \", \"hi\");\n     }\n@@ -1145,23 +1102,23 @@ mod tests {\n         assert_eq!(\"ab\", unsafe {raw::slice_bytes(\"abc\", 0, 2)});\n         assert_eq!(\"bc\", unsafe {raw::slice_bytes(\"abc\", 1, 3)});\n         assert_eq!(\"\", unsafe {raw::slice_bytes(\"abc\", 1, 1)});\n-        fn a_million_letter_a() -> ~str {\n+        fn a_million_letter_a() -> StrBuf {\n             let mut i = 0;\n             let mut rs = StrBuf::new();\n             while i < 100000 {\n                 rs.push_str(\"aaaaaaaaaa\");\n                 i += 1;\n             }\n-            rs.into_owned()\n+            rs\n         }\n-        fn half_a_million_letter_a() -> ~str {\n+        fn half_a_million_letter_a() -> StrBuf {\n             let mut i = 0;\n             let mut rs = StrBuf::new();\n             while i < 100000 {\n                 rs.push_str(\"aaaaa\");\n                 i += 1;\n             }\n-            rs.into_owned()\n+            rs\n         }\n         let letters = a_million_letter_a();\n         assert!(half_a_million_letter_a() ==\n@@ -1260,23 +1217,23 @@ mod tests {\n         assert_eq!(\"\", data.slice(3, 3));\n         assert_eq!(\"\u534e\", data.slice(30, 33));\n \n-        fn a_million_letter_X() -> ~str {\n+        fn a_million_letter_X() -> StrBuf {\n             let mut i = 0;\n             let mut rs = StrBuf::new();\n             while i < 100000 {\n                 rs.push_str(\"\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\");\n                 i += 1;\n             }\n-            rs.into_owned()\n+            rs\n         }\n-        fn half_a_million_letter_X() -> ~str {\n+        fn half_a_million_letter_X() -> StrBuf {\n             let mut i = 0;\n             let mut rs = StrBuf::new();\n             while i < 100000 {\n                 rs.push_str(\"\u534e\u534e\u534e\u534e\u534e\");\n                 i += 1;\n             }\n-            rs.into_owned()\n+            rs\n         }\n         let letters = a_million_letter_X();\n         assert!(half_a_million_letter_X() ==\n@@ -1573,10 +1530,10 @@ mod tests {\n \n     #[test]\n     fn vec_str_conversions() {\n-        let s1: ~str = \"All mimsy were the borogoves\".to_owned();\n+        let s1: StrBuf = \"All mimsy were the borogoves\".to_strbuf();\n \n-        let v: ~[u8] = s1.as_bytes().to_owned();\n-        let s2: ~str = from_utf8(v).unwrap().to_owned();\n+        let v: Vec<u8> = Vec::from_slice(s1.as_bytes());\n+        let s2: StrBuf = from_utf8(v).unwrap().to_strbuf();\n         let mut i: uint = 0u;\n         let n1: uint = s1.len();\n         let n2: uint = v.len();\n@@ -2027,30 +1984,30 @@ mod tests {\n \n     #[test]\n     fn test_nfd_chars() {\n-        assert_eq!(\"abc\".nfd_chars().collect::<~str>(), \"abc\".to_owned());\n-        assert_eq!(\"\\u1e0b\\u01c4\".nfd_chars().collect::<~str>(), \"d\\u0307\\u01c4\".to_owned());\n-        assert_eq!(\"\\u2026\".nfd_chars().collect::<~str>(), \"\\u2026\".to_owned());\n-        assert_eq!(\"\\u2126\".nfd_chars().collect::<~str>(), \"\\u03a9\".to_owned());\n-        assert_eq!(\"\\u1e0b\\u0323\".nfd_chars().collect::<~str>(), \"d\\u0323\\u0307\".to_owned());\n-        assert_eq!(\"\\u1e0d\\u0307\".nfd_chars().collect::<~str>(), \"d\\u0323\\u0307\".to_owned());\n-        assert_eq!(\"a\\u0301\".nfd_chars().collect::<~str>(), \"a\\u0301\".to_owned());\n-        assert_eq!(\"\\u0301a\".nfd_chars().collect::<~str>(), \"\\u0301a\".to_owned());\n-        assert_eq!(\"\\ud4db\".nfd_chars().collect::<~str>(), \"\\u1111\\u1171\\u11b6\".to_owned());\n-        assert_eq!(\"\\uac1c\".nfd_chars().collect::<~str>(), \"\\u1100\\u1162\".to_owned());\n+        assert_eq!(\"abc\".nfd_chars().collect::<StrBuf>(), \"abc\".to_strbuf());\n+        assert_eq!(\"\\u1e0b\\u01c4\".nfd_chars().collect::<StrBuf>(), \"d\\u0307\\u01c4\".to_strbuf());\n+        assert_eq!(\"\\u2026\".nfd_chars().collect::<StrBuf>(), \"\\u2026\".to_strbuf());\n+        assert_eq!(\"\\u2126\".nfd_chars().collect::<StrBuf>(), \"\\u03a9\".to_strbuf());\n+        assert_eq!(\"\\u1e0b\\u0323\".nfd_chars().collect::<StrBuf>(), \"d\\u0323\\u0307\".to_strbuf());\n+        assert_eq!(\"\\u1e0d\\u0307\".nfd_chars().collect::<StrBuf>(), \"d\\u0323\\u0307\".to_strbuf());\n+        assert_eq!(\"a\\u0301\".nfd_chars().collect::<StrBuf>(), \"a\\u0301\".to_strbuf());\n+        assert_eq!(\"\\u0301a\".nfd_chars().collect::<StrBuf>(), \"\\u0301a\".to_strbuf());\n+        assert_eq!(\"\\ud4db\".nfd_chars().collect::<StrBuf>(), \"\\u1111\\u1171\\u11b6\".to_strbuf());\n+        assert_eq!(\"\\uac1c\".nfd_chars().collect::<StrBuf>(), \"\\u1100\\u1162\".to_strbuf());\n     }\n \n     #[test]\n     fn test_nfkd_chars() {\n-        assert_eq!(\"abc\".nfkd_chars().collect::<~str>(), \"abc\".to_owned());\n-        assert_eq!(\"\\u1e0b\\u01c4\".nfkd_chars().collect::<~str>(), \"d\\u0307DZ\\u030c\".to_owned());\n-        assert_eq!(\"\\u2026\".nfkd_chars().collect::<~str>(), \"...\".to_owned());\n-        assert_eq!(\"\\u2126\".nfkd_chars().collect::<~str>(), \"\\u03a9\".to_owned());\n-        assert_eq!(\"\\u1e0b\\u0323\".nfkd_chars().collect::<~str>(), \"d\\u0323\\u0307\".to_owned());\n-        assert_eq!(\"\\u1e0d\\u0307\".nfkd_chars().collect::<~str>(), \"d\\u0323\\u0307\".to_owned());\n-        assert_eq!(\"a\\u0301\".nfkd_chars().collect::<~str>(), \"a\\u0301\".to_owned());\n-        assert_eq!(\"\\u0301a\".nfkd_chars().collect::<~str>(), \"\\u0301a\".to_owned());\n-        assert_eq!(\"\\ud4db\".nfkd_chars().collect::<~str>(), \"\\u1111\\u1171\\u11b6\".to_owned());\n-        assert_eq!(\"\\uac1c\".nfkd_chars().collect::<~str>(), \"\\u1100\\u1162\".to_owned());\n+        assert_eq!(\"abc\".nfkd_chars().collect::<StrBuf>(), \"abc\".to_strbuf());\n+        assert_eq!(\"\\u1e0b\\u01c4\".nfkd_chars().collect::<StrBuf>(), \"d\\u0307DZ\\u030c\".to_strbuf());\n+        assert_eq!(\"\\u2026\".nfkd_chars().collect::<StrBuf>(), \"...\".to_strbuf());\n+        assert_eq!(\"\\u2126\".nfkd_chars().collect::<StrBuf>(), \"\\u03a9\".to_strbuf());\n+        assert_eq!(\"\\u1e0b\\u0323\".nfkd_chars().collect::<StrBuf>(), \"d\\u0323\\u0307\".to_strbuf());\n+        assert_eq!(\"\\u1e0d\\u0307\".nfkd_chars().collect::<StrBuf>(), \"d\\u0323\\u0307\".to_strbuf());\n+        assert_eq!(\"a\\u0301\".nfkd_chars().collect::<StrBuf>(), \"a\\u0301\".to_strbuf());\n+        assert_eq!(\"\\u0301a\".nfkd_chars().collect::<StrBuf>(), \"\\u0301a\".to_strbuf());\n+        assert_eq!(\"\\ud4db\".nfkd_chars().collect::<StrBuf>(), \"\\u1111\\u1171\\u11b6\".to_strbuf());\n+        assert_eq!(\"\\uac1c\".nfkd_chars().collect::<StrBuf>(), \"\\u1100\\u1162\".to_strbuf());\n     }\n \n     #[test]\n@@ -2095,7 +2052,7 @@ mod tests {\n         }\n \n         t::<&str>();\n-        t::<~str>();\n+        t::<StrBuf>();\n     }\n \n     #[test]\n@@ -2169,8 +2126,8 @@ mod tests {\n \n     #[test]\n     fn test_from_str() {\n-      let owned: Option<~str> = from_str(\"string\");\n-      assert_eq!(owned, Some(\"string\".to_owned()));\n+      let owned: Option<StrBuf> = from_str(\"string\");\n+      assert_eq!(owned, Some(\"string\".to_strbuf()));\n     }\n \n     #[test]"}, {"sha": "8f5d8340526e0cbc327980f71a65a74680add7bf", "filename": "src/libstd/strbuf.rs", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Flibstd%2Fstrbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Flibstd%2Fstrbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstrbuf.rs?ref=5633d4641f7d63805e3c12c899f8401410bd825f", "patch": "@@ -15,15 +15,16 @@ use char::Char;\n use cmp::Equiv;\n use container::{Container, Mutable};\n use fmt;\n+use from_str::FromStr;\n use io::Writer;\n use iter::{Extendable, FromIterator, Iterator, range};\n use mem;\n use option::{None, Option, Some};\n use ptr::RawPtr;\n use ptr;\n use result::{Result, Ok, Err};\n-use slice::{OwnedVector, Vector, CloneableVector};\n-use str::{CharRange, OwnedStr, Str, StrSlice, StrAllocating};\n+use slice::Vector;\n+use str::{CharRange, Str, StrSlice, StrAllocating};\n use str;\n use vec::Vec;\n \n@@ -68,10 +69,8 @@ impl StrBuf {\n \n     /// Creates a new string buffer from the given owned string, taking care not to copy it.\n     #[inline]\n-    pub fn from_owned_str(string: ~str) -> StrBuf {\n-        StrBuf {\n-            vec: string.into_bytes().move_iter().collect(),\n-        }\n+    pub fn from_owned_str(string: StrBuf) -> StrBuf {\n+        string\n     }\n \n     /// Returns the vector as a string buffer, if possible, taking care not to\n@@ -192,6 +191,13 @@ impl StrBuf {\n         self.vec.as_slice()\n     }\n \n+    /// Works with the underlying buffer as a mutable byte slice. Unsafe\n+    /// because this can be used to violate the UTF-8 property.\n+    #[inline]\n+    pub unsafe fn as_mut_bytes<'a>(&'a mut self) -> &'a mut [u8] {\n+        self.vec.as_mut_slice()\n+    }\n+\n     /// Shorten a string to the specified length (which must be <= the current length)\n     #[inline]\n     pub fn truncate(&mut self, len: uint) {\n@@ -315,14 +321,14 @@ impl Str for StrBuf {\n \n impl StrAllocating for StrBuf {\n     #[inline]\n-    fn into_owned(self) -> ~str {\n-        unsafe {\n-            mem::transmute(self.vec.as_slice().to_owned())\n-        }\n+    fn into_owned(self) -> StrBuf {\n+        self\n     }\n \n     #[inline]\n-    fn into_strbuf(self) -> StrBuf { self }\n+    fn into_strbuf(self) -> StrBuf {\n+        self\n+    }\n }\n \n impl fmt::Show for StrBuf {\n@@ -345,6 +351,13 @@ impl<'a, S: Str> Equiv<S> for StrBuf {\n     }\n }\n \n+impl FromStr for StrBuf {\n+    #[inline]\n+    fn from_str(s: &str) -> Option<StrBuf> {\n+        Some(s.to_strbuf())\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     extern crate test;"}, {"sha": "dc699bb985068e9768ad4e74c1ecd96f616b9390", "filename": "src/libsyntax/crateid.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Flibsyntax%2Fcrateid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Flibsyntax%2Fcrateid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcrateid.rs?ref=5633d4641f7d63805e3c12c899f8401410bd825f", "patch": "@@ -54,12 +54,14 @@ impl FromStr for CrateId {\n         let pieces: Vec<&str> = s.splitn('#', 1).collect();\n         let path = pieces.get(0).to_owned();\n \n-        if path.starts_with(\"/\") || path.ends_with(\"/\") ||\n-            path.starts_with(\".\") || path.is_empty() {\n+        if path.as_slice().starts_with(\"/\") || path.as_slice().ends_with(\"/\") ||\n+            path.as_slice().starts_with(\".\") || path.is_empty() {\n             return None;\n         }\n \n-        let path_pieces: Vec<&str> = path.rsplitn('/', 1).collect();\n+        let path_pieces: Vec<&str> = path.as_slice()\n+                                         .rsplitn('/', 1)\n+                                         .collect();\n         let inferred_name = *path_pieces.get(0);\n \n         let (name, version) = if pieces.len() == 1 {"}, {"sha": "446a8f93753c327b403fe5149852daa8e4244c15", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=5633d4641f7d63805e3c12c899f8401410bd825f", "patch": "@@ -106,7 +106,7 @@ impl SpanHandler {\n         fail!(ExplicitBug);\n     }\n     pub fn span_unimpl(&self, sp: Span, msg: &str) -> ! {\n-        self.span_bug(sp, \"unimplemented \".to_owned() + msg);\n+        self.span_bug(sp, format!(\"unimplemented {}\", msg).as_slice());\n     }\n     pub fn handler<'a>(&'a self) -> &'a Handler {\n         &self.handler\n@@ -162,7 +162,7 @@ impl Handler {\n         fail!(ExplicitBug);\n     }\n     pub fn unimpl(&self, msg: &str) -> ! {\n-        self.bug(\"unimplemented \".to_owned() + msg);\n+        self.bug(format!(\"unimplemented {}\", msg).as_slice());\n     }\n     pub fn emit(&self,\n                 cmsp: Option<(&codemap::CodeMap, Span)>,\n@@ -434,7 +434,8 @@ fn highlight_lines(err: &mut EmitterWriter,\n                 s.push_char('~');\n             }\n         }\n-        try!(print_maybe_styled(err, s.into_owned() + \"\\n\",\n+        try!(print_maybe_styled(err,\n+                                format!(\"{}\\n\", s).as_slice(),\n                                 term::attr::ForegroundColor(lvl.color())));\n     }\n     Ok(())\n@@ -479,7 +480,7 @@ fn custom_highlight_lines(w: &mut EmitterWriter,\n     s.push_char('^');\n     s.push_char('\\n');\n     print_maybe_styled(w,\n-                       s.into_owned(),\n+                       s.as_slice(),\n                        term::attr::ForegroundColor(lvl.color()))\n }\n "}, {"sha": "f9f5322625f52bdc11b3b625ab78f8aa9808dc65", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=5633d4641f7d63805e3c12c899f8401410bd825f", "patch": "@@ -217,7 +217,7 @@ pub fn expand_asm(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n         node: ast::ExprInlineAsm(ast::InlineAsm {\n             asm: token::intern_and_get_ident(asm.get()),\n             asm_str_style: asm_str_style.unwrap(),\n-            clobbers: token::intern_and_get_ident(cons),\n+            clobbers: token::intern_and_get_ident(cons.as_slice()),\n             inputs: inputs,\n             outputs: outputs,\n             volatile: volatile,"}, {"sha": "b2baff8d286ec9de8c365dbecda06ea393d29962", "filename": "src/libsyntax/ext/concat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Flibsyntax%2Fext%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Flibsyntax%2Fext%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat.rs?ref=5633d4641f7d63805e3c12c899f8401410bd825f", "patch": "@@ -59,5 +59,5 @@ pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n     }\n     base::MacExpr::new(cx.expr_str(\n             sp,\n-            token::intern_and_get_ident(accumulator.into_owned())))\n+            token::intern_and_get_ident(accumulator.as_slice())))\n }"}, {"sha": "24478358d7951241a3552176aeb8907383335ced", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=5633d4641f7d63805e3c12c899f8401410bd825f", "patch": "@@ -42,7 +42,7 @@ pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n             }\n         }\n     }\n-    let res = str_to_ident(res_str.into_owned());\n+    let res = str_to_ident(res_str.as_slice());\n \n     let e = @ast::Expr {\n         id: ast::DUMMY_NODE_ID,"}, {"sha": "bb3a88f44e4bbe07f340a87260f880cab899f312", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=5633d4641f7d63805e3c12c899f8401410bd825f", "patch": "@@ -436,7 +436,7 @@ fn mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> @ast::Expr {\n                 ast::TyI32 => \"TyI32\".to_owned(),\n                 ast::TyI64 => \"TyI64\".to_owned()\n             };\n-            let e_ity = cx.expr_ident(sp, id_ext(s_ity));\n+            let e_ity = cx.expr_ident(sp, id_ext(s_ity.as_slice()));\n \n             let e_i64 = cx.expr_lit(sp, ast::LitInt(i, ast::TyI64));\n \n@@ -453,7 +453,7 @@ fn mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> @ast::Expr {\n                 ast::TyU32 => \"TyU32\".to_owned(),\n                 ast::TyU64 => \"TyU64\".to_owned()\n             };\n-            let e_uty = cx.expr_ident(sp, id_ext(s_uty));\n+            let e_uty = cx.expr_ident(sp, id_ext(s_uty.as_slice()));\n \n             let e_u64 = cx.expr_lit(sp, ast::LitUint(u, ast::TyU64));\n \n@@ -476,7 +476,7 @@ fn mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> @ast::Expr {\n                 ast::TyF64 => \"TyF64\".to_owned(),\n                 ast::TyF128 => \"TyF128\".to_owned()\n             };\n-            let e_fty = cx.expr_ident(sp, id_ext(s_fty));\n+            let e_fty = cx.expr_ident(sp, id_ext(s_fty.as_slice()));\n \n             let e_fident = mk_ident(cx, sp, fident);\n "}, {"sha": "452719d2dd8819915dd4d5c634fc45c05b08f19d", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=5633d4641f7d63805e3c12c899f8401410bd825f", "patch": "@@ -76,7 +76,9 @@ pub fn expand_mod(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                    .map(|x| token::get_ident(*x).get().to_strbuf())\n                    .collect::<Vec<StrBuf>>()\n                    .connect(\"::\");\n-    base::MacExpr::new(cx.expr_str(sp, token::intern_and_get_ident(string)))\n+    base::MacExpr::new(cx.expr_str(\n+            sp,\n+            token::intern_and_get_ident(string.as_slice())))\n }\n \n // include! : parse the given file as an expr"}, {"sha": "54308536ab27a3a4bb9473642c0e554e6c374c1d", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=5633d4641f7d63805e3c12c899f8401410bd825f", "patch": "@@ -455,6 +455,9 @@ pub fn parse_nt(p: &mut Parser, name: &str) -> Nonterminal {\n         res\n       }\n       \"matchers\" => token::NtMatchers(p.parse_matchers()),\n-      _ => p.fatal(\"unsupported builtin nonterminal parser: \".to_owned() + name)\n+      _ => {\n+          p.fatal(format!(\"unsupported builtin nonterminal parser: {}\",\n+                          name).as_slice())\n+      }\n     }\n }"}, {"sha": "5a7a816dbb3e01ce91626929277f9f128f62e2b9", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=5633d4641f7d63805e3c12c899f8401410bd825f", "patch": "@@ -589,13 +589,13 @@ fn scan_number(c: char, rdr: &mut StringReader) -> token::Token {\n             bump(rdr);\n             bump(rdr);\n             check_float_base(rdr, start_bpos, rdr.last_pos, base);\n-            return token::LIT_FLOAT(str_to_ident(num_str.into_owned()),\n+            return token::LIT_FLOAT(str_to_ident(num_str.as_slice()),\n                                     ast::TyF32);\n         } else if c == '6' && n == '4' {\n             bump(rdr);\n             bump(rdr);\n             check_float_base(rdr, start_bpos, rdr.last_pos, base);\n-            return token::LIT_FLOAT(str_to_ident(num_str.into_owned()),\n+            return token::LIT_FLOAT(str_to_ident(num_str.as_slice()),\n                                     ast::TyF64);\n             /* FIXME (#2252): if this is out of range for either a\n             32-bit or 64-bit float, it won't be noticed till the\n@@ -612,8 +612,7 @@ fn scan_number(c: char, rdr: &mut StringReader) -> token::Token {\n     }\n     if is_float {\n         check_float_base(rdr, start_bpos, rdr.last_pos, base);\n-        return token::LIT_FLOAT_UNSUFFIXED(str_to_ident(\n-                num_str.into_owned()));\n+        return token::LIT_FLOAT_UNSUFFIXED(str_to_ident(num_str.as_slice()));\n     } else {\n         if num_str.len() == 0u {\n             fatal_span(rdr, start_bpos, rdr.last_pos,"}, {"sha": "7d0276ae16f7b2d009915b9fd71e7f9eea19819a", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=5633d4641f7d63805e3c12c899f8401410bd825f", "patch": "@@ -4242,8 +4242,8 @@ impl<'a> Parser<'a> {\n             Some(d) => (dir_path.join(d), true),\n             None => {\n                 let mod_name = mod_string.get().to_owned();\n-                let default_path_str = mod_name + \".rs\";\n-                let secondary_path_str = mod_name + \"/mod.rs\";\n+                let default_path_str = format!(\"{}.rs\", mod_name);\n+                let secondary_path_str = format!(\"{}/mod.rs\", mod_name);\n                 let default_path = dir_path.join(default_path_str.as_slice());\n                 let secondary_path = dir_path.join(secondary_path_str.as_slice());\n                 let default_exists = default_path.exists();\n@@ -4310,7 +4310,7 @@ impl<'a> Parser<'a> {\n                     err.push_str(\" -> \");\n                 }\n                 err.push_str(path.display().as_maybe_owned().as_slice());\n-                self.span_fatal(id_sp, err.into_owned());\n+                self.span_fatal(id_sp, err.as_slice());\n             }\n             None => ()\n         }"}, {"sha": "60cf7a67cbe59001a60f63767ba31e067f914193", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=5633d4641f7d63805e3c12c899f8401410bd825f", "patch": "@@ -141,7 +141,8 @@ pub fn to_str(f: |&mut State| -> IoResult<()>) -> StrBuf {\n         // that we \"know\" to be a `MemWriter` that works around the lack of checked\n         // downcasts.\n         let (_, wr): (uint, Box<MemWriter>) = mem::transmute_copy(&s.s.out);\n-        let result = str::from_utf8_owned(wr.get_ref().to_owned()).unwrap();\n+        let result =\n+            str::from_utf8_owned(Vec::from_slice(wr.get_ref())).unwrap();\n         mem::forget(wr);\n         result.to_strbuf()\n     }\n@@ -2234,7 +2235,7 @@ impl<'a> State<'a> {\n                 let mut res = StrBuf::from_str(\"'\");\n                 ch.escape_default(|c| res.push_char(c));\n                 res.push_char('\\'');\n-                word(&mut self.s, res.into_owned())\n+                word(&mut self.s, res.as_slice())\n             }\n             ast::LitInt(i, t) => {\n                 word(&mut self.s,"}, {"sha": "687e27f4282a9567a5fc4e4cb6cbc3937e685099", "filename": "src/libterm/terminfo/parser/compiled.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs?ref=5633d4641f7d63805e3c12c899f8401410bd825f", "patch": "@@ -221,7 +221,8 @@ pub fn parse(file: &mut io::Reader, longnames: bool)\n         None => return Err(\"input not utf-8\".to_strbuf()),\n     };\n \n-    let term_names: Vec<StrBuf> = names_str.split('|')\n+    let term_names: Vec<StrBuf> = names_str.as_slice()\n+                                           .split('|')\n                                            .map(|s| s.to_strbuf())\n                                            .collect();\n "}]}