{"sha": "65cc68b3fd164f351287ac88daf4302e9842cb37", "node_id": "C_kwDOAAsO6NoAKDY1Y2M2OGIzZmQxNjRmMzUxMjg3YWM4OGRhZjQzMDJlOTg0MmNiMzc", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-08-09T05:05:56Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-08-09T05:05:56Z"}, "message": "Rollup merge of #100212 - GuillaumeGomez:rm-clean-impls, r=Dylan-DPC\n\nRemove more Clean trait implementations\n\nFollow-up of https://github.com/rust-lang/rust/pull/99638.\n\nr? `@notriddle`", "tree": {"sha": "8d6609b086a8d32fd8a68edae8a7e55bec33b52c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8d6609b086a8d32fd8a68edae8a7e55bec33b52c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/65cc68b3fd164f351287ac88daf4302e9842cb37", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJi8es0CRBK7hj4Ov3rIwAAsk8IALF3hvzSY3WryApqvy0SARyD\nLXcXxzoK7Xo8QFMJbkEUc1935Mch5fcut2mkqVj+gQ61u9n++pkSyuLY1ImtZgpl\nsrFSfrh+DxfoNX0MHgoNH/Z5KrdsjEXn0BmXPeom/UtzSsTbSK1BZhFVi/lGTkHZ\nVx4wjQg4KCyhWUc3OVup8nJRF58rhHr90KNL4fw3kpi5TnDsxd69AoLmeXWupt16\niFgC6n2nflhsA+hwzYNb79ycbrhZBQIJ3iqR+lMcisOyH72my8VjJtm9Nzp3i3zD\nWGCFArXRa9faOPQZBFBuj1wdmIYF5l8stlzsCZKr+ZZ9a4CaT+n0ANTS4ciOtN8=\n=9j9M\n-----END PGP SIGNATURE-----\n", "payload": "tree 8d6609b086a8d32fd8a68edae8a7e55bec33b52c\nparent a1829bbed030db738ade4ca298d037fe06a4c8be\nparent a238d1284e3efc67bf97687a0701d8b1449bfae3\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1660021556 +0200\ncommitter GitHub <noreply@github.com> 1660021556 +0200\n\nRollup merge of #100212 - GuillaumeGomez:rm-clean-impls, r=Dylan-DPC\n\nRemove more Clean trait implementations\n\nFollow-up of https://github.com/rust-lang/rust/pull/99638.\n\nr? `@notriddle`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/65cc68b3fd164f351287ac88daf4302e9842cb37", "html_url": "https://github.com/rust-lang/rust/commit/65cc68b3fd164f351287ac88daf4302e9842cb37", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/65cc68b3fd164f351287ac88daf4302e9842cb37/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a1829bbed030db738ade4ca298d037fe06a4c8be", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1829bbed030db738ade4ca298d037fe06a4c8be", "html_url": "https://github.com/rust-lang/rust/commit/a1829bbed030db738ade4ca298d037fe06a4c8be"}, {"sha": "a238d1284e3efc67bf97687a0701d8b1449bfae3", "url": "https://api.github.com/repos/rust-lang/rust/commits/a238d1284e3efc67bf97687a0701d8b1449bfae3", "html_url": "https://github.com/rust-lang/rust/commit/a238d1284e3efc67bf97687a0701d8b1449bfae3"}], "stats": {"total": 122, "additions": 64, "deletions": 58}, "files": [{"sha": "5a208768a758d8333409788face20f304cce5ad5", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/65cc68b3fd164f351287ac88daf4302e9842cb37/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65cc68b3fd164f351287ac88daf4302e9842cb37/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=65cc68b3fd164f351287ac88daf4302e9842cb37", "patch": "@@ -474,7 +474,7 @@ where\n         let mut ty_to_fn: FxHashMap<Type, (Option<PolyTrait>, Option<Type>)> = Default::default();\n \n         for p in clean_where_predicates {\n-            let (orig_p, p) = (p, p.clean(self.cx));\n+            let (orig_p, p) = (p, clean_predicate(p, self.cx));\n             if p.is_none() {\n                 continue;\n             }"}, {"sha": "78b93725537be9b6e9d6c194587a3b8afafb0a3f", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 63, "deletions": 57, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/65cc68b3fd164f351287ac88daf4302e9842cb37/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65cc68b3fd164f351287ac88daf4302e9842cb37/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=65cc68b3fd164f351287ac88daf4302e9842cb37", "patch": "@@ -259,66 +259,68 @@ pub(crate) fn clean_middle_region<'tcx>(region: ty::Region<'tcx>) -> Option<Life\n     }\n }\n \n-impl<'tcx> Clean<'tcx, Option<WherePredicate>> for hir::WherePredicate<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> Option<WherePredicate> {\n-        if !self.in_where_clause() {\n-            return None;\n-        }\n-        Some(match *self {\n-            hir::WherePredicate::BoundPredicate(ref wbp) => {\n-                let bound_params = wbp\n-                    .bound_generic_params\n-                    .iter()\n-                    .map(|param| {\n-                        // Higher-ranked params must be lifetimes.\n-                        // Higher-ranked lifetimes can't have bounds.\n-                        assert_matches!(\n-                            param,\n-                            hir::GenericParam { kind: hir::GenericParamKind::Lifetime { .. }, .. }\n-                        );\n-                        Lifetime(param.name.ident().name)\n-                    })\n-                    .collect();\n-                WherePredicate::BoundPredicate {\n-                    ty: clean_ty(wbp.bounded_ty, cx),\n-                    bounds: wbp.bounds.iter().filter_map(|x| clean_generic_bound(x, cx)).collect(),\n-                    bound_params,\n-                }\n+fn clean_where_predicate<'tcx>(\n+    predicate: &hir::WherePredicate<'tcx>,\n+    cx: &mut DocContext<'tcx>,\n+) -> Option<WherePredicate> {\n+    if !predicate.in_where_clause() {\n+        return None;\n+    }\n+    Some(match *predicate {\n+        hir::WherePredicate::BoundPredicate(ref wbp) => {\n+            let bound_params = wbp\n+                .bound_generic_params\n+                .iter()\n+                .map(|param| {\n+                    // Higher-ranked params must be lifetimes.\n+                    // Higher-ranked lifetimes can't have bounds.\n+                    assert_matches!(\n+                        param,\n+                        hir::GenericParam { kind: hir::GenericParamKind::Lifetime { .. }, .. }\n+                    );\n+                    Lifetime(param.name.ident().name)\n+                })\n+                .collect();\n+            WherePredicate::BoundPredicate {\n+                ty: clean_ty(wbp.bounded_ty, cx),\n+                bounds: wbp.bounds.iter().filter_map(|x| clean_generic_bound(x, cx)).collect(),\n+                bound_params,\n             }\n+        }\n \n-            hir::WherePredicate::RegionPredicate(ref wrp) => WherePredicate::RegionPredicate {\n-                lifetime: clean_lifetime(wrp.lifetime, cx),\n-                bounds: wrp.bounds.iter().filter_map(|x| clean_generic_bound(x, cx)).collect(),\n-            },\n+        hir::WherePredicate::RegionPredicate(ref wrp) => WherePredicate::RegionPredicate {\n+            lifetime: clean_lifetime(wrp.lifetime, cx),\n+            bounds: wrp.bounds.iter().filter_map(|x| clean_generic_bound(x, cx)).collect(),\n+        },\n \n-            hir::WherePredicate::EqPredicate(ref wrp) => WherePredicate::EqPredicate {\n-                lhs: clean_ty(wrp.lhs_ty, cx),\n-                rhs: clean_ty(wrp.rhs_ty, cx).into(),\n-            },\n-        })\n-    }\n+        hir::WherePredicate::EqPredicate(ref wrp) => WherePredicate::EqPredicate {\n+            lhs: clean_ty(wrp.lhs_ty, cx),\n+            rhs: clean_ty(wrp.rhs_ty, cx).into(),\n+        },\n+    })\n }\n \n-impl<'tcx> Clean<'tcx, Option<WherePredicate>> for ty::Predicate<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> Option<WherePredicate> {\n-        let bound_predicate = self.kind();\n-        match bound_predicate.skip_binder() {\n-            ty::PredicateKind::Trait(pred) => {\n-                clean_poly_trait_predicate(bound_predicate.rebind(pred), cx)\n-            }\n-            ty::PredicateKind::RegionOutlives(pred) => clean_region_outlives_predicate(pred),\n-            ty::PredicateKind::TypeOutlives(pred) => clean_type_outlives_predicate(pred, cx),\n-            ty::PredicateKind::Projection(pred) => Some(clean_projection_predicate(pred, cx)),\n-            ty::PredicateKind::ConstEvaluatable(..) => None,\n-            ty::PredicateKind::WellFormed(..) => None,\n-\n-            ty::PredicateKind::Subtype(..)\n-            | ty::PredicateKind::Coerce(..)\n-            | ty::PredicateKind::ObjectSafe(..)\n-            | ty::PredicateKind::ClosureKind(..)\n-            | ty::PredicateKind::ConstEquate(..)\n-            | ty::PredicateKind::TypeWellFormedFromEnv(..) => panic!(\"not user writable\"),\n+pub(crate) fn clean_predicate<'tcx>(\n+    predicate: ty::Predicate<'tcx>,\n+    cx: &mut DocContext<'tcx>,\n+) -> Option<WherePredicate> {\n+    let bound_predicate = predicate.kind();\n+    match bound_predicate.skip_binder() {\n+        ty::PredicateKind::Trait(pred) => {\n+            clean_poly_trait_predicate(bound_predicate.rebind(pred), cx)\n         }\n+        ty::PredicateKind::RegionOutlives(pred) => clean_region_outlives_predicate(pred),\n+        ty::PredicateKind::TypeOutlives(pred) => clean_type_outlives_predicate(pred, cx),\n+        ty::PredicateKind::Projection(pred) => Some(clean_projection_predicate(pred, cx)),\n+        ty::PredicateKind::ConstEvaluatable(..) => None,\n+        ty::PredicateKind::WellFormed(..) => None,\n+\n+        ty::PredicateKind::Subtype(..)\n+        | ty::PredicateKind::Coerce(..)\n+        | ty::PredicateKind::ObjectSafe(..)\n+        | ty::PredicateKind::ClosureKind(..)\n+        | ty::PredicateKind::ConstEquate(..)\n+        | ty::PredicateKind::TypeWellFormedFromEnv(..) => panic!(\"not user writable\"),\n     }\n }\n \n@@ -594,7 +596,11 @@ impl<'tcx> Clean<'tcx, Generics> for hir::Generics<'tcx> {\n \n         let mut generics = Generics {\n             params,\n-            where_predicates: self.predicates.iter().filter_map(|x| x.clean(cx)).collect(),\n+            where_predicates: self\n+                .predicates\n+                .iter()\n+                .filter_map(|x| clean_where_predicate(x, cx))\n+                .collect(),\n         };\n \n         // Some duplicates are generated for ?Sized bounds between type params and where\n@@ -695,7 +701,7 @@ fn clean_ty_generics<'tcx>(\n \n             if let Some(param_idx) = param_idx {\n                 if let Some(b) = impl_trait.get_mut(&param_idx.into()) {\n-                    let p: WherePredicate = p.clean(cx)?;\n+                    let p: WherePredicate = clean_predicate(*p, cx)?;\n \n                     b.extend(\n                         p.get_bounds()\n@@ -752,7 +758,7 @@ fn clean_ty_generics<'tcx>(\n     // Now that `cx.impl_trait_bounds` is populated, we can process\n     // remaining predicates which could contain `impl Trait`.\n     let mut where_predicates =\n-        where_predicates.into_iter().flat_map(|p| p.clean(cx)).collect::<Vec<_>>();\n+        where_predicates.into_iter().flat_map(|p| clean_predicate(*p, cx)).collect::<Vec<_>>();\n \n     // Type parameters have a Sized bound by default unless removed with\n     // ?Sized. Scan through the predicates and mark any type parameter with"}]}