{"sha": "a94124488ae0dba1a8a4552a4724cddf9d266e2f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5NDEyNDQ4OGFlMGRiYTFhOGE0NTUyYTQ3MjRjZGRmOWQyNjZlMmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-23T02:13:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-23T02:13:55Z"}, "message": "Auto merge of #41437 - cuviper:remove-unstable-deprecated, r=alexcrichton\n\nRemove items that are unstable and deprecated\n\nThis removes unstable items that have been deprecated for more than one cycle.\n\n- Since 1.16.0, `#![feature(enumset)]`\n    - All of `mod collections::enum_set`\n- Since 1.15.0, `#![feature(borrow_state)]`\n    - `cell::BorrowState`\n    - `RefCell::borrow_state()`\n- Since 1.15.0, `#![feature(is_unique)]`\n    - `Rc::is_unique()` (made private like `Arc::is_unique()`)\n- Since 1.15.0, `#![feature(rc_would_unwrap)]`\n    - `Rc::would_wrap()`\n- Since 1.13.0, `#![feature(binary_heap_extras)]`\n    - `BinaryHeap::push_pop()`\n    - `BinaryHeap::replace()`\n- Since 1.12.0, `#![feature(as_unsafe_cell)]`\n    - `Cell::as_unsafe_cell()`\n    - `RefCell::as_unsafe_cell()`\n- Since 1.12.0, `#![feature(map_entry_recover_keys)]`\n    - `btree_map::OccupiedEntry::remove_pair()`\n    - `hash_map::OccupiedEntry::remove_pair()`\n- Since 1.11.0, `#![feature(float_extras)]`\n    - `Float::nan()`\n    - `Float::infinity()`\n    - `Float::neg_infinity()`\n    - `Float::neg_zero()`\n    - `Float::zero()`\n    - `Float::one()`\n    - `Float::integer_decode()`\n    - `f32::integer_decode()`\n    - `f32::ldexp()`\n    - `f32::frexp()`\n    - `f32::next_after()`\n    - `f64::integer_decode()`\n    - `f64::ldexp()`\n    - `f64::frexp()`\n    - `f64::next_after()`\n- Since 1.11.0, `#![feature(zero_one)]`\n    - `num::Zero`\n    - `num::One`", "tree": {"sha": "01ae0509c80cc36afc8b22e1ec618178b080ed29", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/01ae0509c80cc36afc8b22e1ec618178b080ed29"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a94124488ae0dba1a8a4552a4724cddf9d266e2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a94124488ae0dba1a8a4552a4724cddf9d266e2f", "html_url": "https://github.com/rust-lang/rust/commit/a94124488ae0dba1a8a4552a4724cddf9d266e2f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a94124488ae0dba1a8a4552a4724cddf9d266e2f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "252d3da8a6c715ccafcf77d83b826f6fb899cfe5", "url": "https://api.github.com/repos/rust-lang/rust/commits/252d3da8a6c715ccafcf77d83b826f6fb899cfe5", "html_url": "https://github.com/rust-lang/rust/commit/252d3da8a6c715ccafcf77d83b826f6fb899cfe5"}, {"sha": "13d2534fd3040520622a2b2a262ed9e7079c9fd8", "url": "https://api.github.com/repos/rust-lang/rust/commits/13d2534fd3040520622a2b2a262ed9e7079c9fd8", "html_url": "https://github.com/rust-lang/rust/commit/13d2534fd3040520622a2b2a262ed9e7079c9fd8"}], "stats": {"total": 1387, "additions": 103, "deletions": 1284}, "files": [{"sha": "613475730417015b7e8d6ffba7a7c717b0230916", "filename": "src/doc/unstable-book/src/SUMMARY.md", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a94124488ae0dba1a8a4552a4724cddf9d266e2f/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/a94124488ae0dba1a8a4552a4724cddf9d266e2f/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md?ref=a94124488ae0dba1a8a4552a4724cddf9d266e2f", "patch": "@@ -102,11 +102,8 @@\n     - [alloc_system](library-features/alloc-system.md)\n     - [alloc](library-features/alloc.md)\n     - [as_c_str](library-features/as-c-str.md)\n-    - [as_unsafe_cell](library-features/as-unsafe-cell.md)\n     - [ascii_ctype](library-features/ascii-ctype.md)\n-    - [binary_heap_extras](library-features/binary-heap-extras.md)\n     - [binary_heap_peek_mut_pop](library-features/binary-heap-peek-mut-pop.md)\n-    - [borrow_state](library-features/borrow-state.md)\n     - [box_heap](library-features/box-heap.md)\n     - [c_void_variant](library-features/c-void-variant.md)\n     - [char_escape_debug](library-features/char-escape-debug.md)\n@@ -131,14 +128,12 @@\n     - [derive_clone_copy](library-features/derive-clone-copy.md)\n     - [derive_eq](library-features/derive-eq.md)\n     - [discriminant_value](library-features/discriminant-value.md)\n-    - [enumset](library-features/enumset.md)\n     - [error_type_id](library-features/error-type-id.md)\n     - [exact_size_is_empty](library-features/exact-size-is-empty.md)\n     - [fd](library-features/fd.md)\n     - [fd_read](library-features/fd-read.md)\n     - [fixed_size_array](library-features/fixed-size-array.md)\n     - [float_bits_conv](library-features/float-bits-conv.md)\n-    - [float_extras](library-features/float-extras.md)\n     - [flt2dec](library-features/flt2dec.md)\n     - [fmt_flags_align](library-features/fmt-flags-align.md)\n     - [fmt_internals](library-features/fmt-internals.md)\n@@ -158,15 +153,13 @@\n     - [io_error_internals](library-features/io-error-internals.md)\n     - [io](library-features/io.md)\n     - [ip](library-features/ip.md)\n-    - [is_unique](library-features/is-unique.md)\n     - [iter_rfind](library-features/iter-rfind.md)\n     - [libstd_io_internals](library-features/libstd-io-internals.md)\n     - [libstd_sys_internals](library-features/libstd-sys-internals.md)\n     - [libstd_thread_internals](library-features/libstd-thread-internals.md)\n     - [linked_list_extras](library-features/linked-list-extras.md)\n     - [lookup_host](library-features/lookup-host.md)\n     - [manually_drop](library-features/manually-drop.md)\n-    - [map_entry_recover_keys](library-features/map-entry-recover-keys.md)\n     - [mpsc_select](library-features/mpsc-select.md)\n     - [n16](library-features/n16.md)\n     - [never_type_impls](library-features/never-type-impls.md)\n@@ -189,7 +182,6 @@\n     - [rand](library-features/rand.md)\n     - [range_contains](library-features/range-contains.md)\n     - [raw](library-features/raw.md)\n-    - [rc_would_unwrap](library-features/rc-would-unwrap.md)\n     - [retain_hash_collection](library-features/retain-hash-collection.md)\n     - [reverse_cmp_key](library-features/reverse-cmp-key.md)\n     - [rt](library-features/rt.md)\n@@ -225,5 +217,3 @@\n     - [windows_handle](library-features/windows-handle.md)\n     - [windows_net](library-features/windows-net.md)\n     - [windows_stdio](library-features/windows-stdio.md)\n-    - [zero_one](library-features/zero-one.md)\n->>>>>> Add top level sections to the Unstable Book."}, {"sha": "79d7a7cad0b6e232c869ec59bf1ccc6a2eb11f7a", "filename": "src/doc/unstable-book/src/library-features/as-unsafe-cell.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fas-unsafe-cell.md", "raw_url": "https://github.com/rust-lang/rust/raw/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fas-unsafe-cell.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fas-unsafe-cell.md?ref=252d3da8a6c715ccafcf77d83b826f6fb899cfe5", "patch": "@@ -1,7 +0,0 @@\n-# `as_unsafe_cell`\n-\n-The tracking issue for this feature is: [#27708]\n-\n-[#27708]: https://github.com/rust-lang/rust/issues/27708\n-\n-------------------------"}, {"sha": "aa535f3b67840cd51a80aec11c38d9648be17cbd", "filename": "src/doc/unstable-book/src/library-features/binary-heap-extras.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fbinary-heap-extras.md", "raw_url": "https://github.com/rust-lang/rust/raw/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fbinary-heap-extras.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fbinary-heap-extras.md?ref=252d3da8a6c715ccafcf77d83b826f6fb899cfe5", "patch": "@@ -1,7 +0,0 @@\n-# `binary_heap_extras`\n-\n-The tracking issue for this feature is: [#28147]\n-\n-[#28147]: https://github.com/rust-lang/rust/issues/28147\n-\n-------------------------"}, {"sha": "304b8dffe98679c9f6fea3e7d2558757c1797563", "filename": "src/doc/unstable-book/src/library-features/borrow-state.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fborrow-state.md", "raw_url": "https://github.com/rust-lang/rust/raw/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fborrow-state.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fborrow-state.md?ref=252d3da8a6c715ccafcf77d83b826f6fb899cfe5", "patch": "@@ -1,7 +0,0 @@\n-# `borrow_state`\n-\n-The tracking issue for this feature is: [#27733]\n-\n-[#27733]: https://github.com/rust-lang/rust/issues/27733\n-\n-------------------------"}, {"sha": "24c8d8fa7dbb914ae7243fb81af9b67bb544791e", "filename": "src/doc/unstable-book/src/library-features/enumset.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fenumset.md", "raw_url": "https://github.com/rust-lang/rust/raw/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fenumset.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fenumset.md?ref=252d3da8a6c715ccafcf77d83b826f6fb899cfe5", "patch": "@@ -1,7 +0,0 @@\n-# `enumset`\n-\n-The tracking issue for this feature is: [#37966]\n-\n-[#37966]: https://github.com/rust-lang/rust/issues/37966\n-\n-------------------------"}, {"sha": "ff2d20a545fe5d1dfc4f5daadf332e113411ce81", "filename": "src/doc/unstable-book/src/library-features/float-extras.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ffloat-extras.md", "raw_url": "https://github.com/rust-lang/rust/raw/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ffloat-extras.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ffloat-extras.md?ref=252d3da8a6c715ccafcf77d83b826f6fb899cfe5", "patch": "@@ -1,7 +0,0 @@\n-# `float_extras`\n-\n-The tracking issue for this feature is: [#27752]\n-\n-[#27752]: https://github.com/rust-lang/rust/issues/27752\n-\n-------------------------"}, {"sha": "6070006758b7ac86a29f3c01de14a22ad9d1080f", "filename": "src/doc/unstable-book/src/library-features/is-unique.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fis-unique.md", "raw_url": "https://github.com/rust-lang/rust/raw/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fis-unique.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fis-unique.md?ref=252d3da8a6c715ccafcf77d83b826f6fb899cfe5", "patch": "@@ -1,7 +0,0 @@\n-# `is_unique`\n-\n-The tracking issue for this feature is: [#28356]\n-\n-[#28356]: https://github.com/rust-lang/rust/issues/28356\n-\n-------------------------"}, {"sha": "2d15aa0e90de8e18b4b6dfafe7ab1ae759e3ddf8", "filename": "src/doc/unstable-book/src/library-features/map-entry-recover-keys.md", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fmap-entry-recover-keys.md", "raw_url": "https://github.com/rust-lang/rust/raw/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fmap-entry-recover-keys.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fmap-entry-recover-keys.md?ref=252d3da8a6c715ccafcf77d83b826f6fb899cfe5", "patch": "@@ -1,5 +0,0 @@\n-# `map_entry_recover_keys`\n-\n-The tracking issue for this feature is: [#34285]\n-\n-[#34285]: https://github.com/rust-lang/rust/issues/34285"}, {"sha": "462387dfdcc4024034cfaef26b369010969fc095", "filename": "src/doc/unstable-book/src/library-features/rc-would-unwrap.md", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Frc-would-unwrap.md", "raw_url": "https://github.com/rust-lang/rust/raw/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Frc-would-unwrap.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Frc-would-unwrap.md?ref=252d3da8a6c715ccafcf77d83b826f6fb899cfe5", "patch": "@@ -1,5 +0,0 @@\n-# `rc_would_unwrap`\n-\n-The tracking issue for this feature is: [#28356]\n-\n-[#28356]: https://github.com/rust-lang/rust/issues/28356"}, {"sha": "4d1cf38c3c2ea6205823e9c8c461f734afe51a2d", "filename": "src/doc/unstable-book/src/library-features/zero-one.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fzero-one.md", "raw_url": "https://github.com/rust-lang/rust/raw/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fzero-one.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fzero-one.md?ref=252d3da8a6c715ccafcf77d83b826f6fb899cfe5", "patch": "@@ -1,7 +0,0 @@\n-# `zero_one`\n-\n-The tracking issue for this feature is: [#27739]\n-\n-[#27739]: https://github.com/rust-lang/rust/issues/27739\n-\n-------------------------"}, {"sha": "38dc914583517f9410e1f685fbe0b50e47286ec6", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a94124488ae0dba1a8a4552a4724cddf9d266e2f/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a94124488ae0dba1a8a4552a4724cddf9d266e2f/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=a94124488ae0dba1a8a4552a4724cddf9d266e2f", "patch": "@@ -340,19 +340,6 @@ impl<T> Rc<T> {\n         }\n     }\n \n-    /// Checks whether [`Rc::try_unwrap`][try_unwrap] would return\n-    /// [`Ok`].\n-    ///\n-    /// [try_unwrap]: struct.Rc.html#method.try_unwrap\n-    /// [`Ok`]: ../../std/result/enum.Result.html#variant.Ok\n-    #[unstable(feature = \"rc_would_unwrap\",\n-               reason = \"just added for niche usecase\",\n-               issue = \"28356\")]\n-    #[rustc_deprecated(since = \"1.15.0\", reason = \"too niche; use `strong_count` instead\")]\n-    pub fn would_unwrap(this: &Self) -> bool {\n-        Rc::strong_count(&this) == 1\n-    }\n-\n     /// Consumes the `Rc`, returning the wrapped pointer.\n     ///\n     /// To avoid a memory leak the pointer must be converted back to an `Rc` using\n@@ -532,11 +519,7 @@ impl<T: ?Sized> Rc<T> {\n     ///\n     /// [weak]: struct.Weak.html\n     #[inline]\n-    #[unstable(feature = \"is_unique\", reason = \"uniqueness has unclear meaning\",\n-               issue = \"28356\")]\n-    #[rustc_deprecated(since = \"1.15.0\",\n-                       reason = \"too niche; use `strong_count` and `weak_count` instead\")]\n-    pub fn is_unique(this: &Self) -> bool {\n+    fn is_unique(this: &Self) -> bool {\n         Rc::weak_count(this) == 0 && Rc::strong_count(this) == 1\n     }\n "}, {"sha": "7d972403f65db47dd923dc257487de5a5b08ab9a", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 0, "deletions": 76, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/a94124488ae0dba1a8a4552a4724cddf9d266e2f/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a94124488ae0dba1a8a4552a4724cddf9d266e2f/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=a94124488ae0dba1a8a4552a4724cddf9d266e2f", "patch": "@@ -555,82 +555,6 @@ impl<T: Ord> BinaryHeap<T> {\n         self.sift_up(0, old_len);\n     }\n \n-    /// Pushes an item onto the binary heap, then pops the greatest item off the queue in\n-    /// an optimized fashion.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// #![feature(binary_heap_extras)]\n-    /// #![allow(deprecated)]\n-    ///\n-    /// use std::collections::BinaryHeap;\n-    /// let mut heap = BinaryHeap::new();\n-    /// heap.push(1);\n-    /// heap.push(5);\n-    ///\n-    /// assert_eq!(heap.push_pop(3), 5);\n-    /// assert_eq!(heap.push_pop(9), 9);\n-    /// assert_eq!(heap.len(), 2);\n-    /// assert_eq!(heap.peek(), Some(&3));\n-    /// ```\n-    #[unstable(feature = \"binary_heap_extras\",\n-               reason = \"needs to be audited\",\n-               issue = \"28147\")]\n-    #[rustc_deprecated(since = \"1.13.0\", reason = \"use `peek_mut` instead\")]\n-    pub fn push_pop(&mut self, mut item: T) -> T {\n-        match self.data.get_mut(0) {\n-            None => return item,\n-            Some(top) => {\n-                if *top > item {\n-                    swap(&mut item, top);\n-                } else {\n-                    return item;\n-                }\n-            }\n-        }\n-\n-        self.sift_down(0);\n-        item\n-    }\n-\n-    /// Pops the greatest item off the binary heap, then pushes an item onto the queue in\n-    /// an optimized fashion. The push is done regardless of whether the binary heap\n-    /// was empty.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// #![feature(binary_heap_extras)]\n-    /// #![allow(deprecated)]\n-    ///\n-    /// use std::collections::BinaryHeap;\n-    /// let mut heap = BinaryHeap::new();\n-    ///\n-    /// assert_eq!(heap.replace(1), None);\n-    /// assert_eq!(heap.replace(3), Some(1));\n-    /// assert_eq!(heap.len(), 1);\n-    /// assert_eq!(heap.peek(), Some(&3));\n-    /// ```\n-    #[unstable(feature = \"binary_heap_extras\",\n-               reason = \"needs to be audited\",\n-               issue = \"28147\")]\n-    #[rustc_deprecated(since = \"1.13.0\", reason = \"use `peek_mut` instead\")]\n-    pub fn replace(&mut self, mut item: T) -> Option<T> {\n-        if !self.is_empty() {\n-            swap(&mut item, &mut self.data[0]);\n-            self.sift_down(0);\n-            Some(item)\n-        } else {\n-            self.push(item);\n-            None\n-        }\n-    }\n-\n     /// Consumes the `BinaryHeap` and returns the underlying vector\n     /// in arbitrary order.\n     ///"}, {"sha": "d73c0254a74574221e1cd44d9ff12fe858cf588d", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a94124488ae0dba1a8a4552a4724cddf9d266e2f/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a94124488ae0dba1a8a4552a4724cddf9d266e2f/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=a94124488ae0dba1a8a4552a4724cddf9d266e2f", "patch": "@@ -2217,13 +2217,6 @@ impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n         self.handle.reborrow().into_kv().0\n     }\n \n-    /// Deprecated, renamed to `remove_entry`\n-    #[unstable(feature = \"map_entry_recover_keys\", issue = \"34285\")]\n-    #[rustc_deprecated(since = \"1.12.0\", reason = \"renamed to `remove_entry`\")]\n-    pub fn remove_pair(self) -> (K, V) {\n-        self.remove_entry()\n-    }\n-\n     /// Take ownership of the key and value from the map.\n     ///\n     /// # Examples"}, {"sha": "aaee567bf1dbfe475b13951d6e28fdddb7c75eab", "filename": "src/libcollections/enum_set.rs", "status": "removed", "additions": 0, "deletions": 313, "changes": 313, "blob_url": "https://github.com/rust-lang/rust/blob/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=252d3da8a6c715ccafcf77d83b826f6fb899cfe5", "patch": "@@ -1,313 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! A structure for holding a set of enum variants.\n-//!\n-//! This module defines a container which uses an efficient bit mask\n-//! representation to hold C-like enum variants.\n-\n-#![unstable(feature = \"enumset\",\n-            reason = \"matches collection reform specification, \\\n-                      waiting for dust to settle\",\n-            issue = \"37966\")]\n-#![rustc_deprecated(since = \"1.16.0\", reason = \"long since replaced\")]\n-#![allow(deprecated)]\n-\n-use core::marker;\n-use core::fmt;\n-use core::iter::{FromIterator, FusedIterator};\n-use core::ops::{Sub, BitOr, BitAnd, BitXor};\n-\n-// FIXME(contentions): implement union family of methods? (general design may be\n-// wrong here)\n-\n-/// A specialized set implementation to use enum types.\n-///\n-/// It is a logic error for an item to be modified in such a way that the\n-/// transformation of the item to or from a `usize`, as determined by the\n-/// `CLike` trait, changes while the item is in the set. This is normally only\n-/// possible through `Cell`, `RefCell`, global state, I/O, or unsafe code.\n-#[derive(PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub struct EnumSet<E> {\n-    // We must maintain the invariant that no bits are set\n-    // for which no variant exists\n-    bits: usize,\n-    marker: marker::PhantomData<E>,\n-}\n-\n-impl<E> Copy for EnumSet<E> {}\n-\n-impl<E> Clone for EnumSet<E> {\n-    fn clone(&self) -> EnumSet<E> {\n-        *self\n-    }\n-}\n-\n-impl<E: CLike + fmt::Debug> fmt::Debug for EnumSet<E> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        fmt.debug_set().entries(self).finish()\n-    }\n-}\n-\n-/// An interface for casting C-like enum to usize and back.\n-/// A typically implementation is as below.\n-///\n-/// ```{rust,ignore}\n-/// #[repr(usize)]\n-/// enum Foo {\n-///     A, B, C\n-/// }\n-///\n-/// impl CLike for Foo {\n-///     fn to_usize(&self) -> usize {\n-///         *self as usize\n-///     }\n-///\n-///     fn from_usize(v: usize) -> Foo {\n-///         unsafe { mem::transmute(v) }\n-///     }\n-/// }\n-/// ```\n-pub trait CLike {\n-    /// Converts a C-like enum to a `usize`.\n-    fn to_usize(&self) -> usize;\n-    /// Converts a `usize` to a C-like enum.\n-    fn from_usize(usize) -> Self;\n-}\n-\n-fn bit<E: CLike>(e: &E) -> usize {\n-    use core::mem;\n-    let value = e.to_usize();\n-    let bits = mem::size_of::<usize>() * 8;\n-    assert!(value < bits,\n-            \"EnumSet only supports up to {} variants.\",\n-            bits - 1);\n-    1 << value\n-}\n-\n-impl<E: CLike> EnumSet<E> {\n-    /// Returns an empty `EnumSet`.\n-    pub fn new() -> EnumSet<E> {\n-        EnumSet {\n-            bits: 0,\n-            marker: marker::PhantomData,\n-        }\n-    }\n-\n-    /// Returns the number of elements in the given `EnumSet`.\n-    pub fn len(&self) -> usize {\n-        self.bits.count_ones() as usize\n-    }\n-\n-    /// Returns `true` if the `EnumSet` is empty.\n-    pub fn is_empty(&self) -> bool {\n-        self.bits == 0\n-    }\n-\n-    pub fn clear(&mut self) {\n-        self.bits = 0;\n-    }\n-\n-    /// Returns `false` if the `EnumSet` contains any enum of the given `EnumSet`.\n-    pub fn is_disjoint(&self, other: &EnumSet<E>) -> bool {\n-        (self.bits & other.bits) == 0\n-    }\n-\n-    /// Returns `true` if a given `EnumSet` is included in this `EnumSet`.\n-    pub fn is_superset(&self, other: &EnumSet<E>) -> bool {\n-        (self.bits & other.bits) == other.bits\n-    }\n-\n-    /// Returns `true` if this `EnumSet` is included in the given `EnumSet`.\n-    pub fn is_subset(&self, other: &EnumSet<E>) -> bool {\n-        other.is_superset(self)\n-    }\n-\n-    /// Returns the union of both `EnumSets`.\n-    pub fn union(&self, e: EnumSet<E>) -> EnumSet<E> {\n-        EnumSet {\n-            bits: self.bits | e.bits,\n-            marker: marker::PhantomData,\n-        }\n-    }\n-\n-    /// Returns the intersection of both `EnumSets`.\n-    pub fn intersection(&self, e: EnumSet<E>) -> EnumSet<E> {\n-        EnumSet {\n-            bits: self.bits & e.bits,\n-            marker: marker::PhantomData,\n-        }\n-    }\n-\n-    /// Adds an enum to the `EnumSet`, and returns `true` if it wasn't there before\n-    pub fn insert(&mut self, e: E) -> bool {\n-        let result = !self.contains(&e);\n-        self.bits |= bit(&e);\n-        result\n-    }\n-\n-    /// Removes an enum from the EnumSet\n-    pub fn remove(&mut self, e: &E) -> bool {\n-        let result = self.contains(e);\n-        self.bits &= !bit(e);\n-        result\n-    }\n-\n-    /// Returns `true` if an `EnumSet` contains a given enum.\n-    pub fn contains(&self, e: &E) -> bool {\n-        (self.bits & bit(e)) != 0\n-    }\n-\n-    /// Returns an iterator over an `EnumSet`.\n-    pub fn iter(&self) -> Iter<E> {\n-        Iter::new(self.bits)\n-    }\n-}\n-\n-impl<E: CLike> Sub for EnumSet<E> {\n-    type Output = EnumSet<E>;\n-\n-    fn sub(self, e: EnumSet<E>) -> EnumSet<E> {\n-        EnumSet {\n-            bits: self.bits & !e.bits,\n-            marker: marker::PhantomData,\n-        }\n-    }\n-}\n-\n-impl<E: CLike> BitOr for EnumSet<E> {\n-    type Output = EnumSet<E>;\n-\n-    fn bitor(self, e: EnumSet<E>) -> EnumSet<E> {\n-        EnumSet {\n-            bits: self.bits | e.bits,\n-            marker: marker::PhantomData,\n-        }\n-    }\n-}\n-\n-impl<E: CLike> BitAnd for EnumSet<E> {\n-    type Output = EnumSet<E>;\n-\n-    fn bitand(self, e: EnumSet<E>) -> EnumSet<E> {\n-        EnumSet {\n-            bits: self.bits & e.bits,\n-            marker: marker::PhantomData,\n-        }\n-    }\n-}\n-\n-impl<E: CLike> BitXor for EnumSet<E> {\n-    type Output = EnumSet<E>;\n-\n-    fn bitxor(self, e: EnumSet<E>) -> EnumSet<E> {\n-        EnumSet {\n-            bits: self.bits ^ e.bits,\n-            marker: marker::PhantomData,\n-        }\n-    }\n-}\n-\n-/// An iterator over an `EnumSet`\n-pub struct Iter<E> {\n-    index: usize,\n-    bits: usize,\n-    marker: marker::PhantomData<E>,\n-}\n-\n-impl<E: fmt::Debug> fmt::Debug for Iter<E> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_tuple(\"Iter\")\n-         .field(&self.index)\n-         .field(&self.bits)\n-         .finish()\n-    }\n-}\n-\n-// FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-impl<E> Clone for Iter<E> {\n-    fn clone(&self) -> Iter<E> {\n-        Iter {\n-            index: self.index,\n-            bits: self.bits,\n-            marker: marker::PhantomData,\n-        }\n-    }\n-}\n-\n-impl<E: CLike> Iter<E> {\n-    fn new(bits: usize) -> Iter<E> {\n-        Iter {\n-            index: 0,\n-            bits: bits,\n-            marker: marker::PhantomData,\n-        }\n-    }\n-}\n-\n-impl<E: CLike> Iterator for Iter<E> {\n-    type Item = E;\n-\n-    fn next(&mut self) -> Option<E> {\n-        if self.bits == 0 {\n-            return None;\n-        }\n-\n-        while (self.bits & 1) == 0 {\n-            self.index += 1;\n-            self.bits >>= 1;\n-        }\n-        let elem = CLike::from_usize(self.index);\n-        self.index += 1;\n-        self.bits >>= 1;\n-        Some(elem)\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let exact = self.bits.count_ones() as usize;\n-        (exact, Some(exact))\n-    }\n-}\n-\n-#[unstable(feature = \"fused\", issue = \"35602\")]\n-impl<E: CLike> FusedIterator for Iter<E> {}\n-\n-impl<E: CLike> FromIterator<E> for EnumSet<E> {\n-    fn from_iter<I: IntoIterator<Item = E>>(iter: I) -> EnumSet<E> {\n-        let mut ret = EnumSet::new();\n-        ret.extend(iter);\n-        ret\n-    }\n-}\n-\n-impl<'a, E> IntoIterator for &'a EnumSet<E>\n-    where E: CLike\n-{\n-    type Item = E;\n-    type IntoIter = Iter<E>;\n-\n-    fn into_iter(self) -> Iter<E> {\n-        self.iter()\n-    }\n-}\n-\n-impl<E: CLike> Extend<E> for EnumSet<E> {\n-    fn extend<I: IntoIterator<Item = E>>(&mut self, iter: I) {\n-        for element in iter {\n-            self.insert(element);\n-        }\n-    }\n-}\n-\n-impl<'a, E: 'a + CLike + Copy> Extend<&'a E> for EnumSet<E> {\n-    fn extend<I: IntoIterator<Item = &'a E>>(&mut self, iter: I) {\n-        self.extend(iter.into_iter().cloned());\n-    }\n-}"}, {"sha": "8d056afdb571a4881ed1e86399fc3cc3294bbb06", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a94124488ae0dba1a8a4552a4724cddf9d266e2f/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a94124488ae0dba1a8a4552a4724cddf9d266e2f/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=a94124488ae0dba1a8a4552a4724cddf9d266e2f", "patch": "@@ -89,9 +89,6 @@ pub use btree_set::BTreeSet;\n #[doc(no_inline)]\n pub use linked_list::LinkedList;\n #[doc(no_inline)]\n-#[allow(deprecated)]\n-pub use enum_set::EnumSet;\n-#[doc(no_inline)]\n pub use vec_deque::VecDeque;\n #[doc(no_inline)]\n pub use string::String;\n@@ -107,7 +104,6 @@ mod macros;\n pub mod binary_heap;\n mod btree;\n pub mod borrow;\n-pub mod enum_set;\n pub mod fmt;\n pub mod linked_list;\n pub mod range;"}, {"sha": "af18cddaddb013050ce91c6c98e32e06c6ba2ebe", "filename": "src/libcollections/tests/binary_heap.rs", "status": "modified", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/a94124488ae0dba1a8a4552a4724cddf9d266e2f/src%2Flibcollections%2Ftests%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a94124488ae0dba1a8a4552a4724cddf9d266e2f/src%2Flibcollections%2Ftests%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftests%2Fbinary_heap.rs?ref=a94124488ae0dba1a8a4552a4724cddf9d266e2f", "patch": "@@ -152,36 +152,6 @@ fn test_push_unique() {\n     assert!(*heap.peek().unwrap() == box 103);\n }\n \n-#[test]\n-#[allow(deprecated)]\n-fn test_push_pop() {\n-    let mut heap = BinaryHeap::from(vec![5, 5, 2, 1, 3]);\n-    assert_eq!(heap.len(), 5);\n-    assert_eq!(heap.push_pop(6), 6);\n-    assert_eq!(heap.len(), 5);\n-    assert_eq!(heap.push_pop(0), 5);\n-    assert_eq!(heap.len(), 5);\n-    assert_eq!(heap.push_pop(4), 5);\n-    assert_eq!(heap.len(), 5);\n-    assert_eq!(heap.push_pop(1), 4);\n-    assert_eq!(heap.len(), 5);\n-}\n-\n-#[test]\n-#[allow(deprecated)]\n-fn test_replace() {\n-    let mut heap = BinaryHeap::from(vec![5, 5, 2, 1, 3]);\n-    assert_eq!(heap.len(), 5);\n-    assert_eq!(heap.replace(6).unwrap(), 5);\n-    assert_eq!(heap.len(), 5);\n-    assert_eq!(heap.replace(0).unwrap(), 6);\n-    assert_eq!(heap.len(), 5);\n-    assert_eq!(heap.replace(4).unwrap(), 5);\n-    assert_eq!(heap.len(), 5);\n-    assert_eq!(heap.replace(1).unwrap(), 4);\n-    assert_eq!(heap.len(), 5);\n-}\n-\n fn check_to_vec(mut data: Vec<i32>) {\n     let heap = BinaryHeap::from(data.clone());\n     let mut v = heap.clone().into_vec();\n@@ -227,13 +197,6 @@ fn test_empty_peek_mut() {\n     assert!(empty.peek_mut().is_none());\n }\n \n-#[test]\n-#[allow(deprecated)]\n-fn test_empty_replace() {\n-    let mut heap = BinaryHeap::new();\n-    assert!(heap.replace(5).is_none());\n-}\n-\n #[test]\n fn test_from_iter() {\n     let xs = vec![9, 8, 7, 6, 5, 4, 3, 2, 1];"}, {"sha": "9c6e31d70a541c12ac1d460ee28475aebdfab769", "filename": "src/libcollections/tests/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a94124488ae0dba1a8a4552a4724cddf9d266e2f/src%2Flibcollections%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a94124488ae0dba1a8a4552a4724cddf9d266e2f/src%2Flibcollections%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftests%2Flib.rs?ref=a94124488ae0dba1a8a4552a4724cddf9d266e2f", "patch": "@@ -10,7 +10,6 @@\n \n #![deny(warnings)]\n \n-#![feature(binary_heap_extras)]\n #![feature(binary_heap_peek_mut_pop)]\n #![feature(box_syntax)]\n #![feature(inclusive_range_syntax)]"}, {"sha": "ba04cbb0543cd6de56de80d2412cda33e8525bfc", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 0, "deletions": 89, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/a94124488ae0dba1a8a4552a4724cddf9d266e2f/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a94124488ae0dba1a8a4552a4724cddf9d266e2f/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=a94124488ae0dba1a8a4552a4724cddf9d266e2f", "patch": "@@ -310,26 +310,6 @@ impl<T> Cell<T> {\n         }\n     }\n \n-    /// Returns a reference to the underlying `UnsafeCell`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(as_unsafe_cell)]\n-    ///\n-    /// use std::cell::Cell;\n-    ///\n-    /// let c = Cell::new(5);\n-    ///\n-    /// let uc = c.as_unsafe_cell();\n-    /// ```\n-    #[inline]\n-    #[unstable(feature = \"as_unsafe_cell\", issue = \"27708\")]\n-    #[rustc_deprecated(since = \"1.12.0\", reason = \"renamed to as_ptr\")]\n-    pub fn as_unsafe_cell(&self) -> &UnsafeCell<T> {\n-        &self.value\n-    }\n-\n     /// Returns a raw pointer to the underlying data in this cell.\n     ///\n     /// # Examples\n@@ -480,20 +460,6 @@ pub struct RefCell<T: ?Sized> {\n     value: UnsafeCell<T>,\n }\n \n-/// An enumeration of values returned from the `state` method on a `RefCell<T>`.\n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-#[unstable(feature = \"borrow_state\", issue = \"27733\")]\n-#[rustc_deprecated(since = \"1.15.0\", reason = \"use `try_borrow` instead\")]\n-#[allow(deprecated)]\n-pub enum BorrowState {\n-    /// The cell is currently being read, there is at least one active `borrow`.\n-    Reading,\n-    /// The cell is currently being written to, there is an active `borrow_mut`.\n-    Writing,\n-    /// There are no outstanding borrows on this cell.\n-    Unused,\n-}\n-\n /// An error returned by [`RefCell::try_borrow`](struct.RefCell.html#method.try_borrow).\n #[stable(feature = \"try_borrow\", since = \"1.13.0\")]\n pub struct BorrowError {\n@@ -582,38 +548,6 @@ impl<T> RefCell<T> {\n }\n \n impl<T: ?Sized> RefCell<T> {\n-    /// Query the current state of this `RefCell`\n-    ///\n-    /// The returned value can be dispatched on to determine if a call to\n-    /// `borrow` or `borrow_mut` would succeed.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(borrow_state)]\n-    ///\n-    /// use std::cell::{BorrowState, RefCell};\n-    ///\n-    /// let c = RefCell::new(5);\n-    ///\n-    /// match c.borrow_state() {\n-    ///     BorrowState::Writing => println!(\"Cannot be borrowed\"),\n-    ///     BorrowState::Reading => println!(\"Cannot be borrowed mutably\"),\n-    ///     BorrowState::Unused => println!(\"Can be borrowed (mutably as well)\"),\n-    /// }\n-    /// ```\n-    #[unstable(feature = \"borrow_state\", issue = \"27733\")]\n-    #[rustc_deprecated(since = \"1.15.0\", reason = \"use `try_borrow` instead\")]\n-    #[allow(deprecated)]\n-    #[inline]\n-    pub fn borrow_state(&self) -> BorrowState {\n-        match self.borrow.get() {\n-            WRITING => BorrowState::Writing,\n-            UNUSED => BorrowState::Unused,\n-            _ => BorrowState::Reading,\n-        }\n-    }\n-\n     /// Immutably borrows the wrapped value.\n     ///\n     /// The borrow lasts until the returned `Ref` exits scope. Multiple\n@@ -769,29 +703,6 @@ impl<T: ?Sized> RefCell<T> {\n         }\n     }\n \n-    /// Returns a reference to the underlying `UnsafeCell`.\n-    ///\n-    /// This can be used to circumvent `RefCell`'s safety checks.\n-    ///\n-    /// This function is `unsafe` because `UnsafeCell`'s field is public.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(as_unsafe_cell)]\n-    ///\n-    /// use std::cell::RefCell;\n-    ///\n-    /// let c = RefCell::new(5);\n-    /// let c = unsafe { c.as_unsafe_cell() };\n-    /// ```\n-    #[inline]\n-    #[unstable(feature = \"as_unsafe_cell\", issue = \"27708\")]\n-    #[rustc_deprecated(since = \"1.12.0\", reason = \"renamed to as_ptr\")]\n-    pub unsafe fn as_unsafe_cell(&self) -> &UnsafeCell<T> {\n-        &self.value\n-    }\n-\n     /// Returns a raw pointer to the underlying data in this cell.\n     ///\n     /// # Examples"}, {"sha": "4ca303dee43f2ad600237d82680c0a6ddfa6d0f7", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a94124488ae0dba1a8a4552a4724cddf9d266e2f/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a94124488ae0dba1a8a4552a4724cddf9d266e2f/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=a94124488ae0dba1a8a4552a4724cddf9d266e2f", "patch": "@@ -15,16 +15,16 @@\n // FIXME: #6220 Implement floating point formatting\n \n use fmt;\n-use num::Zero;\n use ops::{Div, Rem, Sub};\n use str;\n use slice;\n use ptr;\n use mem;\n \n #[doc(hidden)]\n-trait Int: Zero + PartialEq + PartialOrd + Div<Output=Self> + Rem<Output=Self> +\n+trait Int: PartialEq + PartialOrd + Div<Output=Self> + Rem<Output=Self> +\n            Sub<Output=Self> + Copy {\n+    fn zero() -> Self;\n     fn from_u8(u: u8) -> Self;\n     fn to_u8(&self) -> u8;\n     fn to_u16(&self) -> u16;\n@@ -35,6 +35,7 @@ trait Int: Zero + PartialEq + PartialOrd + Div<Output=Self> + Rem<Output=Self> +\n \n macro_rules! doit {\n     ($($t:ident)*) => ($(impl Int for $t {\n+        fn zero() -> $t { 0 }\n         fn from_u8(u: u8) -> $t { u as $t }\n         fn to_u8(&self) -> u8 { *self as u8 }\n         fn to_u16(&self) -> u16 { *self as u16 }"}, {"sha": "2a60292d0232e1e525606edc20ecc0a9821abc68", "filename": "src/libcore/num/dec2flt/rawfp.rs", "status": "modified", "additions": 34, "deletions": 7, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/a94124488ae0dba1a8a4552a4724cddf9d266e2f/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a94124488ae0dba1a8a4552a4724cddf9d266e2f/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs?ref=a94124488ae0dba1a8a4552a4724cddf9d266e2f", "patch": "@@ -63,11 +63,8 @@ pub trait RawFloat : Float + Copy + Debug + LowerExp\n     const NAN: Self;\n     const ZERO: Self;\n \n-    // suffix of \"2\" because Float::integer_decode is deprecated\n-    #[allow(deprecated)]\n-    fn integer_decode2(self) -> (u64, i16, i8) {\n-        Float::integer_decode(self)\n-    }\n+    /// Returns the mantissa, exponent and sign as integers.\n+    fn integer_decode(self) -> (u64, i16, i8);\n \n     /// Get the raw binary representation of the float.\n     fn transmute(self) -> u64;\n@@ -160,6 +157,21 @@ impl RawFloat for f32 {\n     const ZERO_CUTOFF: i64 = -48;\n     other_constants!(f32);\n \n+    /// Returns the mantissa, exponent and sign as integers.\n+    fn integer_decode(self) -> (u64, i16, i8) {\n+        let bits: u32 = unsafe { transmute(self) };\n+        let sign: i8 = if bits >> 31 == 0 { 1 } else { -1 };\n+        let mut exponent: i16 = ((bits >> 23) & 0xff) as i16;\n+        let mantissa = if exponent == 0 {\n+            (bits & 0x7fffff) << 1\n+        } else {\n+            (bits & 0x7fffff) | 0x800000\n+        };\n+        // Exponent bias + mantissa shift\n+        exponent -= 127 + 23;\n+        (mantissa as u64, exponent, sign)\n+    }\n+\n     fn transmute(self) -> u64 {\n         let bits: u32 = unsafe { transmute(self) };\n         bits as u64\n@@ -171,7 +183,7 @@ impl RawFloat for f32 {\n     }\n \n     fn unpack(self) -> Unpacked {\n-        let (sig, exp, _sig) = self.integer_decode2();\n+        let (sig, exp, _sig) = self.integer_decode();\n         Unpacked::new(sig, exp)\n     }\n \n@@ -196,6 +208,21 @@ impl RawFloat for f64 {\n     const ZERO_CUTOFF: i64 = -326;\n     other_constants!(f64);\n \n+    /// Returns the mantissa, exponent and sign as integers.\n+    fn integer_decode(self) -> (u64, i16, i8) {\n+        let bits: u64 = unsafe { transmute(self) };\n+        let sign: i8 = if bits >> 63 == 0 { 1 } else { -1 };\n+        let mut exponent: i16 = ((bits >> 52) & 0x7ff) as i16;\n+        let mantissa = if exponent == 0 {\n+            (bits & 0xfffffffffffff) << 1\n+        } else {\n+            (bits & 0xfffffffffffff) | 0x10000000000000\n+        };\n+        // Exponent bias + mantissa shift\n+        exponent -= 1023 + 52;\n+        (mantissa, exponent, sign)\n+    }\n+\n     fn transmute(self) -> u64 {\n         let bits: u64 = unsafe { transmute(self) };\n         bits\n@@ -206,7 +233,7 @@ impl RawFloat for f64 {\n     }\n \n     fn unpack(self) -> Unpacked {\n-        let (sig, exp, _sig) = self.integer_decode2();\n+        let (sig, exp, _sig) = self.integer_decode();\n         Unpacked::new(sig, exp)\n     }\n "}, {"sha": "91ca213e96e0d19b84c38b83668d193790804020", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/a94124488ae0dba1a8a4552a4724cddf9d266e2f/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a94124488ae0dba1a8a4552a4724cddf9d266e2f/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=a94124488ae0dba1a8a4552a4724cddf9d266e2f", "patch": "@@ -143,36 +143,6 @@ pub mod consts {\n            reason = \"stable interface is via `impl f{32,64}` in later crates\",\n            issue = \"32110\")]\n impl Float for f32 {\n-    #[inline]\n-    fn nan() -> f32 {\n-        NAN\n-    }\n-\n-    #[inline]\n-    fn infinity() -> f32 {\n-        INFINITY\n-    }\n-\n-    #[inline]\n-    fn neg_infinity() -> f32 {\n-        NEG_INFINITY\n-    }\n-\n-    #[inline]\n-    fn zero() -> f32 {\n-        0.0\n-    }\n-\n-    #[inline]\n-    fn neg_zero() -> f32 {\n-        -0.0\n-    }\n-\n-    #[inline]\n-    fn one() -> f32 {\n-        1.0\n-    }\n-\n     /// Returns `true` if the number is NaN.\n     #[inline]\n     fn is_nan(self) -> bool {\n@@ -214,21 +184,6 @@ impl Float for f32 {\n         }\n     }\n \n-    /// Returns the mantissa, exponent and sign as integers.\n-    fn integer_decode(self) -> (u64, i16, i8) {\n-        let bits: u32 = unsafe { mem::transmute(self) };\n-        let sign: i8 = if bits >> 31 == 0 { 1 } else { -1 };\n-        let mut exponent: i16 = ((bits >> 23) & 0xff) as i16;\n-        let mantissa = if exponent == 0 {\n-            (bits & 0x7fffff) << 1\n-        } else {\n-            (bits & 0x7fffff) | 0x800000\n-        };\n-        // Exponent bias + mantissa shift\n-        exponent -= 127 + 23;\n-        (mantissa as u64, exponent, sign)\n-    }\n-\n     /// Computes the absolute value of `self`. Returns `Float::nan()` if the\n     /// number is `Float::nan()`.\n     #[inline]"}, {"sha": "7d6d6cef049772f3f2d267a394cf44125015ad69", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/a94124488ae0dba1a8a4552a4724cddf9d266e2f/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a94124488ae0dba1a8a4552a4724cddf9d266e2f/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=a94124488ae0dba1a8a4552a4724cddf9d266e2f", "patch": "@@ -143,36 +143,6 @@ pub mod consts {\n            reason = \"stable interface is via `impl f{32,64}` in later crates\",\n            issue = \"32110\")]\n impl Float for f64 {\n-    #[inline]\n-    fn nan() -> f64 {\n-        NAN\n-    }\n-\n-    #[inline]\n-    fn infinity() -> f64 {\n-        INFINITY\n-    }\n-\n-    #[inline]\n-    fn neg_infinity() -> f64 {\n-        NEG_INFINITY\n-    }\n-\n-    #[inline]\n-    fn zero() -> f64 {\n-        0.0\n-    }\n-\n-    #[inline]\n-    fn neg_zero() -> f64 {\n-        -0.0\n-    }\n-\n-    #[inline]\n-    fn one() -> f64 {\n-        1.0\n-    }\n-\n     /// Returns `true` if the number is NaN.\n     #[inline]\n     fn is_nan(self) -> bool {\n@@ -214,21 +184,6 @@ impl Float for f64 {\n         }\n     }\n \n-    /// Returns the mantissa, exponent and sign as integers.\n-    fn integer_decode(self) -> (u64, i16, i8) {\n-        let bits: u64 = unsafe { mem::transmute(self) };\n-        let sign: i8 = if bits >> 63 == 0 { 1 } else { -1 };\n-        let mut exponent: i16 = ((bits >> 52) & 0x7ff) as i16;\n-        let mantissa = if exponent == 0 {\n-            (bits & 0xfffffffffffff) << 1\n-        } else {\n-            (bits & 0xfffffffffffff) | 0x10000000000000\n-        };\n-        // Exponent bias + mantissa shift\n-        exponent -= 1023 + 52;\n-        (mantissa, exponent, sign)\n-    }\n-\n     /// Computes the absolute value of `self`. Returns `Float::nan()` if the\n     /// number is `Float::nan()`.\n     #[inline]"}, {"sha": "b779eefce5752c1bf100488f35106454c83c7770", "filename": "src/libcore/num/flt2dec/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a94124488ae0dba1a8a4552a4724cddf9d266e2f/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a94124488ae0dba1a8a4552a4724cddf9d266e2f/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs?ref=a94124488ae0dba1a8a4552a4724cddf9d266e2f", "patch": "@@ -67,7 +67,7 @@ impl DecodableFloat for f64 {\n /// Returns a sign (true when negative) and `FullDecoded` value\n /// from given floating point number.\n pub fn decode<T: DecodableFloat>(v: T) -> (/*negative?*/ bool, FullDecoded) {\n-    let (mant, exp, sign) = v.integer_decode2();\n+    let (mant, exp, sign) = v.integer_decode();\n     let even = (mant & 1) == 0;\n     let decoded = match v.classify() {\n         FpCategory::Nan => FullDecoded::Nan,\n@@ -81,7 +81,7 @@ pub fn decode<T: DecodableFloat>(v: T) -> (/*negative?*/ bool, FullDecoded) {\n                                           exp: exp, inclusive: even })\n         }\n         FpCategory::Normal => {\n-            let minnorm = <T as DecodableFloat>::min_pos_norm_value().integer_decode2();\n+            let minnorm = <T as DecodableFloat>::min_pos_norm_value().integer_decode();\n             if mant == minnorm.0 {\n                 // neighbors: (maxmant, exp - 1) -- (minnormmant, exp) -- (minnormmant + 1, exp)\n                 // where maxmant = minnormmant * 2 - 1"}, {"sha": "5c4a43fbd110a4e4a86202146e8d0ddb05abdde2", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 0, "deletions": 123, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/a94124488ae0dba1a8a4552a4724cddf9d266e2f/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a94124488ae0dba1a8a4552a4724cddf9d266e2f/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=a94124488ae0dba1a8a4552a4724cddf9d266e2f", "patch": "@@ -96,78 +96,6 @@ pub mod dec2flt;\n pub mod bignum;\n pub mod diy_float;\n \n-/// Types that have a \"zero\" value.\n-///\n-/// This trait is intended for use in conjunction with `Add`, as an identity:\n-/// `x + T::zero() == x`.\n-#[unstable(feature = \"zero_one\",\n-           reason = \"unsure of placement, wants to use associated constants\",\n-           issue = \"27739\")]\n-#[rustc_deprecated(since = \"1.11.0\", reason = \"no longer used for \\\n-                                               Iterator::sum\")]\n-pub trait Zero: Sized {\n-    /// The \"zero\" (usually, additive identity) for this type.\n-    fn zero() -> Self;\n-}\n-\n-/// Types that have a \"one\" value.\n-///\n-/// This trait is intended for use in conjunction with `Mul`, as an identity:\n-/// `x * T::one() == x`.\n-#[unstable(feature = \"zero_one\",\n-           reason = \"unsure of placement, wants to use associated constants\",\n-           issue = \"27739\")]\n-#[rustc_deprecated(since = \"1.11.0\", reason = \"no longer used for \\\n-                                               Iterator::product\")]\n-pub trait One: Sized {\n-    /// The \"one\" (usually, multiplicative identity) for this type.\n-    fn one() -> Self;\n-}\n-\n-macro_rules! zero_one_impl {\n-    ($($t:ty)*) => ($(\n-        #[unstable(feature = \"zero_one\",\n-                   reason = \"unsure of placement, wants to use associated constants\",\n-                   issue = \"27739\")]\n-        #[allow(deprecated)]\n-        impl Zero for $t {\n-            #[inline]\n-            fn zero() -> Self { 0 }\n-        }\n-        #[unstable(feature = \"zero_one\",\n-                   reason = \"unsure of placement, wants to use associated constants\",\n-                   issue = \"27739\")]\n-        #[allow(deprecated)]\n-        impl One for $t {\n-            #[inline]\n-            fn one() -> Self { 1 }\n-        }\n-    )*)\n-}\n-zero_one_impl! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }\n-\n-macro_rules! zero_one_impl_float {\n-    ($($t:ty)*) => ($(\n-        #[unstable(feature = \"zero_one\",\n-                   reason = \"unsure of placement, wants to use associated constants\",\n-                   issue = \"27739\")]\n-        #[allow(deprecated)]\n-        impl Zero for $t {\n-            #[inline]\n-            fn zero() -> Self { 0.0 }\n-        }\n-        #[unstable(feature = \"zero_one\",\n-                   reason = \"unsure of placement, wants to use associated constants\",\n-                   issue = \"27739\")]\n-        #[allow(deprecated)]\n-        impl One for $t {\n-            #[inline]\n-            fn one() -> Self { 1.0 }\n-        }\n-    )*)\n-}\n-zero_one_impl_float! { f32 f64 }\n-\n macro_rules! checked_op {\n     ($U:ty, $op:path, $x:expr, $y:expr) => {{\n         let (result, overflowed) = unsafe { $op($x as $U, $y as $U) };\n@@ -2525,49 +2453,6 @@ pub enum FpCategory {\n            reason = \"stable interface is via `impl f{32,64}` in later crates\",\n            issue = \"32110\")]\n pub trait Float: Sized {\n-    /// Returns the NaN value.\n-    #[unstable(feature = \"float_extras\", reason = \"needs removal\",\n-               issue = \"27752\")]\n-    #[rustc_deprecated(since = \"1.11.0\",\n-                       reason = \"never really came to fruition and easily \\\n-                                 implementable outside the standard library\")]\n-    fn nan() -> Self;\n-    /// Returns the infinite value.\n-    #[unstable(feature = \"float_extras\", reason = \"needs removal\",\n-               issue = \"27752\")]\n-    #[rustc_deprecated(since = \"1.11.0\",\n-                       reason = \"never really came to fruition and easily \\\n-                                 implementable outside the standard library\")]\n-    fn infinity() -> Self;\n-    /// Returns the negative infinite value.\n-    #[unstable(feature = \"float_extras\", reason = \"needs removal\",\n-               issue = \"27752\")]\n-    #[rustc_deprecated(since = \"1.11.0\",\n-                       reason = \"never really came to fruition and easily \\\n-                                 implementable outside the standard library\")]\n-    fn neg_infinity() -> Self;\n-    /// Returns -0.0.\n-    #[unstable(feature = \"float_extras\", reason = \"needs removal\",\n-               issue = \"27752\")]\n-    #[rustc_deprecated(since = \"1.11.0\",\n-                       reason = \"never really came to fruition and easily \\\n-                                 implementable outside the standard library\")]\n-    fn neg_zero() -> Self;\n-    /// Returns 0.0.\n-    #[unstable(feature = \"float_extras\", reason = \"needs removal\",\n-               issue = \"27752\")]\n-    #[rustc_deprecated(since = \"1.11.0\",\n-                       reason = \"never really came to fruition and easily \\\n-                                 implementable outside the standard library\")]\n-    fn zero() -> Self;\n-    /// Returns 1.0.\n-    #[unstable(feature = \"float_extras\", reason = \"needs removal\",\n-               issue = \"27752\")]\n-    #[rustc_deprecated(since = \"1.11.0\",\n-                       reason = \"never really came to fruition and easily \\\n-                                 implementable outside the standard library\")]\n-    fn one() -> Self;\n-\n     /// Returns `true` if this value is NaN and false otherwise.\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn is_nan(self) -> bool;\n@@ -2585,14 +2470,6 @@ pub trait Float: Sized {\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn classify(self) -> FpCategory;\n \n-    /// Returns the mantissa, exponent and sign as integers, respectively.\n-    #[unstable(feature = \"float_extras\", reason = \"signature is undecided\",\n-               issue = \"27752\")]\n-    #[rustc_deprecated(since = \"1.11.0\",\n-                       reason = \"never really came to fruition and easily \\\n-                                 implementable outside the standard library\")]\n-    fn integer_decode(self) -> (u64, i16, i8);\n-\n     /// Computes the absolute value of `self`. Returns `Float::nan()` if the\n     /// number is `Float::nan()`.\n     #[stable(feature = \"core\", since = \"1.6.0\")]"}, {"sha": "2b0afc402027f11f1c999846583241f231ed66d0", "filename": "src/libcore/tests/num/dec2flt/rawfp.rs", "status": "modified", "additions": 35, "deletions": 12, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/a94124488ae0dba1a8a4552a4724cddf9d266e2f/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Frawfp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a94124488ae0dba1a8a4552a4724cddf9d266e2f/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Frawfp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Frawfp.rs?ref=a94124488ae0dba1a8a4552a4724cddf9d266e2f", "patch": "@@ -8,23 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::f32;\n use std::f64;\n-use std::mem;\n use core::num::diy_float::Fp;\n use core::num::dec2flt::rawfp::{fp_to_float, prev_float, next_float, round_normal};\n+use core::num::dec2flt::rawfp::RawFloat;\n \n fn integer_decode(f: f64) -> (u64, i16, i8) {\n-    let bits: u64 = unsafe { mem::transmute(f) };\n-    let sign: i8 = if bits >> 63 == 0 { 1 } else { -1 };\n-    let mut exponent: i16 = ((bits >> 52) & 0x7ff) as i16;\n-    let mantissa = if exponent == 0 {\n-        (bits & 0xfffffffffffff) << 1\n-    } else {\n-        (bits & 0xfffffffffffff) | 0x10000000000000\n-    };\n-    // Exponent bias + mantissa shift\n-    exponent -= 1023 + 52;\n-    (mantissa, exponent, sign)\n+    RawFloat::integer_decode(f)\n }\n \n #[test]\n@@ -152,3 +143,35 @@ fn next_float_monotonic() {\n     }\n     assert!(x > 0.5);\n }\n+\n+#[test]\n+fn test_f32_integer_decode() {\n+    assert_eq!(3.14159265359f32.integer_decode(), (13176795, -22, 1));\n+    assert_eq!((-8573.5918555f32).integer_decode(), (8779358, -10, -1));\n+    assert_eq!(2f32.powf(100.0).integer_decode(), (8388608, 77, 1));\n+    assert_eq!(0f32.integer_decode(), (0, -150, 1));\n+    assert_eq!((-0f32).integer_decode(), (0, -150, -1));\n+    assert_eq!(f32::INFINITY.integer_decode(), (8388608, 105, 1));\n+    assert_eq!(f32::NEG_INFINITY.integer_decode(), (8388608, 105, -1));\n+\n+    // Ignore the \"sign\" (quiet / signalling flag) of NAN.\n+    // It can vary between runtime operations and LLVM folding.\n+    let (nan_m, nan_e, _nan_s) = f32::NAN.integer_decode();\n+    assert_eq!((nan_m, nan_e), (12582912, 105));\n+}\n+\n+#[test]\n+fn test_f64_integer_decode() {\n+    assert_eq!(3.14159265359f64.integer_decode(), (7074237752028906, -51, 1));\n+    assert_eq!((-8573.5918555f64).integer_decode(), (4713381968463931, -39, -1));\n+    assert_eq!(2f64.powf(100.0).integer_decode(), (4503599627370496, 48, 1));\n+    assert_eq!(0f64.integer_decode(), (0, -1075, 1));\n+    assert_eq!((-0f64).integer_decode(), (0, -1075, -1));\n+    assert_eq!(f64::INFINITY.integer_decode(), (4503599627370496, 972, 1));\n+    assert_eq!(f64::NEG_INFINITY.integer_decode(), (4503599627370496, 972, -1));\n+\n+    // Ignore the \"sign\" (quiet / signalling flag) of NAN.\n+    // It can vary between runtime operations and LLVM folding.\n+    let (nan_m, nan_e, _nan_s) = f64::NAN.integer_decode();\n+    assert_eq!((nan_m, nan_e), (6755399441055744, 972));\n+}"}, {"sha": "51d127f8ba79a246c33745356c94ab0888f4bf98", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a94124488ae0dba1a8a4552a4724cddf9d266e2f/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a94124488ae0dba1a8a4552a4724cddf9d266e2f/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=a94124488ae0dba1a8a4552a4724cddf9d266e2f", "patch": "@@ -2017,13 +2017,6 @@ impl<'a, K, V> OccupiedEntry<'a, K, V> {\n         self.elem.read().0\n     }\n \n-    /// Deprecated, renamed to `remove_entry`\n-    #[unstable(feature = \"map_entry_recover_keys\", issue = \"34285\")]\n-    #[rustc_deprecated(since = \"1.12.0\", reason = \"renamed to `remove_entry`\")]\n-    pub fn remove_pair(self) -> (K, V) {\n-        self.remove_entry()\n-    }\n-\n     /// Take the ownership of the key and value from the map.\n     ///\n     /// # Examples"}, {"sha": "4abad7e24f8107a6b2690399190104eec2bf07ba", "filename": "src/libstd/f32.rs", "status": "modified", "additions": 1, "deletions": 205, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/a94124488ae0dba1a8a4552a4724cddf9d266e2f/src%2Flibstd%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a94124488ae0dba1a8a4552a4724cddf9d266e2f/src%2Flibstd%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff32.rs?ref=a94124488ae0dba1a8a4552a4724cddf9d266e2f", "patch": "@@ -22,8 +22,6 @@ use core::num;\n #[cfg(not(test))]\n use intrinsics;\n #[cfg(not(test))]\n-use libc::c_int;\n-#[cfg(not(test))]\n use num::FpCategory;\n \n \n@@ -73,8 +71,6 @@ mod cmath {\n         pub fn atan2f(a: c_float, b: c_float) -> c_float;\n         pub fn atanf(n: c_float) -> c_float;\n         pub fn coshf(n: c_float) -> c_float;\n-        pub fn frexpf(n: c_float, value: &mut c_int) -> c_float;\n-        pub fn ldexpf(x: c_float, n: c_int) -> c_float;\n         pub fn sinhf(n: c_float) -> c_float;\n         pub fn tanf(n: c_float) -> c_float;\n         pub fn tanhf(n: c_float) -> c_float;\n@@ -84,7 +80,7 @@ mod cmath {\n     pub use self::shims::*;\n     #[cfg(target_env = \"msvc\")]\n     mod shims {\n-        use libc::{c_float, c_int};\n+        use libc::c_float;\n \n         #[inline]\n         pub unsafe fn acosf(n: c_float) -> c_float {\n@@ -111,20 +107,6 @@ mod cmath {\n             f64::cosh(n as f64) as c_float\n         }\n \n-        #[inline]\n-        #[allow(deprecated)]\n-        pub unsafe fn frexpf(x: c_float, value: &mut c_int) -> c_float {\n-            let (a, b) = f64::frexp(x as f64);\n-            *value = b as c_int;\n-            a as c_float\n-        }\n-\n-        #[inline]\n-        #[allow(deprecated)]\n-        pub unsafe fn ldexpf(x: c_float, n: c_int) -> c_float {\n-            f64::ldexp(x as f64, n as isize) as c_float\n-        }\n-\n         #[inline]\n         pub unsafe fn sinhf(n: c_float) -> c_float {\n             f64::sinh(n as f64) as c_float\n@@ -244,40 +226,6 @@ impl f32 {\n     #[inline]\n     pub fn classify(self) -> FpCategory { num::Float::classify(self) }\n \n-    /// Returns the mantissa, base 2 exponent, and sign as integers, respectively.\n-    /// The original number can be recovered by `sign * mantissa * 2 ^ exponent`.\n-    /// The floating point encoding is documented in the [Reference][floating-point].\n-    ///\n-    /// ```\n-    /// #![feature(float_extras)]\n-    ///\n-    /// use std::f32;\n-    ///\n-    /// let num = 2.0f32;\n-    ///\n-    /// // (8388608, -22, 1)\n-    /// let (mantissa, exponent, sign) = num.integer_decode();\n-    /// let sign_f = sign as f32;\n-    /// let mantissa_f = mantissa as f32;\n-    /// let exponent_f = num.powf(exponent as f32);\n-    ///\n-    /// // 1 * 8388608 * 2^(-22) == 2\n-    /// let abs_difference = (sign_f * mantissa_f * exponent_f - num).abs();\n-    ///\n-    /// assert!(abs_difference <= f32::EPSILON);\n-    /// ```\n-    /// [floating-point]: ../reference/types.html#machine-types\n-    #[unstable(feature = \"float_extras\", reason = \"signature is undecided\",\n-               issue = \"27752\")]\n-    #[rustc_deprecated(since = \"1.11.0\",\n-                       reason = \"never really came to fruition and easily \\\n-                                 implementable outside the standard library\")]\n-    #[inline]\n-    #[allow(deprecated)]\n-    pub fn integer_decode(self) -> (u64, i16, i8) {\n-        num::Float::integer_decode(self)\n-    }\n-\n     /// Returns the largest integer less than or equal to a number.\n     ///\n     /// ```\n@@ -712,89 +660,6 @@ impl f32 {\n     #[inline]\n     pub fn to_radians(self) -> f32 { num::Float::to_radians(self) }\n \n-    /// Constructs a floating point number of `x*2^exp`.\n-    ///\n-    /// ```\n-    /// #![feature(float_extras)]\n-    ///\n-    /// use std::f32;\n-    /// // 3*2^2 - 12 == 0\n-    /// let abs_difference = (f32::ldexp(3.0, 2) - 12.0).abs();\n-    ///\n-    /// assert!(abs_difference <= f32::EPSILON);\n-    /// ```\n-    #[unstable(feature = \"float_extras\",\n-               reason = \"pending integer conventions\",\n-               issue = \"27752\")]\n-    #[rustc_deprecated(since = \"1.11.0\",\n-                       reason = \"never really came to fruition and easily \\\n-                                 implementable outside the standard library\")]\n-    #[inline]\n-    pub fn ldexp(x: f32, exp: isize) -> f32 {\n-        unsafe { cmath::ldexpf(x, exp as c_int) }\n-    }\n-\n-    /// Breaks the number into a normalized fraction and a base-2 exponent,\n-    /// satisfying:\n-    ///\n-    ///  * `self = x * 2^exp`\n-    ///  * `0.5 <= abs(x) < 1.0`\n-    ///\n-    /// ```\n-    /// #![feature(float_extras)]\n-    ///\n-    /// use std::f32;\n-    ///\n-    /// let x = 4.0f32;\n-    ///\n-    /// // (1/2)*2^3 -> 1 * 8/2 -> 4.0\n-    /// let f = x.frexp();\n-    /// let abs_difference_0 = (f.0 - 0.5).abs();\n-    /// let abs_difference_1 = (f.1 as f32 - 3.0).abs();\n-    ///\n-    /// assert!(abs_difference_0 <= f32::EPSILON);\n-    /// assert!(abs_difference_1 <= f32::EPSILON);\n-    /// ```\n-    #[unstable(feature = \"float_extras\",\n-               reason = \"pending integer conventions\",\n-               issue = \"27752\")]\n-    #[rustc_deprecated(since = \"1.11.0\",\n-                       reason = \"never really came to fruition and easily \\\n-                                 implementable outside the standard library\")]\n-    #[inline]\n-    pub fn frexp(self) -> (f32, isize) {\n-        unsafe {\n-            let mut exp = 0;\n-            let x = cmath::frexpf(self, &mut exp);\n-            (x, exp as isize)\n-        }\n-    }\n-\n-    /// Returns the next representable floating-point value in the direction of\n-    /// `other`.\n-    ///\n-    /// ```\n-    /// #![feature(float_extras)]\n-    ///\n-    /// use std::f32;\n-    ///\n-    /// let x = 1.0f32;\n-    ///\n-    /// let abs_diff = (x.next_after(2.0) - 1.00000011920928955078125_f32).abs();\n-    ///\n-    /// assert!(abs_diff <= f32::EPSILON);\n-    /// ```\n-    #[unstable(feature = \"float_extras\",\n-               reason = \"unsure about its place in the world\",\n-               issue = \"27752\")]\n-    #[rustc_deprecated(since = \"1.11.0\",\n-                       reason = \"never really came to fruition and easily \\\n-                                 implementable outside the standard library\")]\n-    #[inline]\n-    pub fn next_after(self, other: f32) -> f32 {\n-        unsafe { cmath::nextafterf(self, other) }\n-    }\n-\n     /// Returns the maximum of the two numbers.\n     ///\n     /// ```\n@@ -1462,23 +1327,6 @@ mod tests {\n         assert_eq!(1e-38f32.classify(), Fp::Subnormal);\n     }\n \n-    #[test]\n-    #[allow(deprecated)]\n-    fn test_integer_decode() {\n-        assert_eq!(3.14159265359f32.integer_decode(), (13176795, -22, 1));\n-        assert_eq!((-8573.5918555f32).integer_decode(), (8779358, -10, -1));\n-        assert_eq!(2f32.powf(100.0).integer_decode(), (8388608, 77, 1));\n-        assert_eq!(0f32.integer_decode(), (0, -150, 1));\n-        assert_eq!((-0f32).integer_decode(), (0, -150, -1));\n-        assert_eq!(INFINITY.integer_decode(), (8388608, 105, 1));\n-        assert_eq!(NEG_INFINITY.integer_decode(), (8388608, 105, -1));\n-\n-        // Ignore the \"sign\" (quiet / signalling flag) of NAN.\n-        // It can vary between runtime operations and LLVM folding.\n-        let (nan_m, nan_e, _nan_s) = NAN.integer_decode();\n-        assert_eq!((nan_m, nan_e), (12582912, 105));\n-    }\n-\n     #[test]\n     fn test_floor() {\n         assert_approx_eq!(1.0f32.floor(), 1.0f32);\n@@ -1790,58 +1638,6 @@ mod tests {\n         assert_eq!(neg_inf.to_radians(), neg_inf);\n     }\n \n-    #[test]\n-    #[allow(deprecated)]\n-    fn test_ldexp() {\n-        let f1 = 2.0f32.powi(-123);\n-        let f2 = 2.0f32.powi(-111);\n-        let f3 = 1.75 * 2.0f32.powi(-12);\n-        assert_eq!(f32::ldexp(1f32, -123), f1);\n-        assert_eq!(f32::ldexp(1f32, -111), f2);\n-        assert_eq!(f32::ldexp(1.75f32, -12), f3);\n-\n-        assert_eq!(f32::ldexp(0f32, -123), 0f32);\n-        assert_eq!(f32::ldexp(-0f32, -123), -0f32);\n-\n-        let inf: f32 = f32::INFINITY;\n-        let neg_inf: f32 = f32::NEG_INFINITY;\n-        let nan: f32 = f32::NAN;\n-        assert_eq!(f32::ldexp(inf, -123), inf);\n-        assert_eq!(f32::ldexp(neg_inf, -123), neg_inf);\n-        assert!(f32::ldexp(nan, -123).is_nan());\n-    }\n-\n-    #[test]\n-    #[allow(deprecated)]\n-    fn test_frexp() {\n-        let f1 = 2.0f32.powi(-123);\n-        let f2 = 2.0f32.powi(-111);\n-        let f3 = 1.75 * 2.0f32.powi(-123);\n-        let (x1, exp1) = f1.frexp();\n-        let (x2, exp2) = f2.frexp();\n-        let (x3, exp3) = f3.frexp();\n-        assert_eq!((x1, exp1), (0.5f32, -122));\n-        assert_eq!((x2, exp2), (0.5f32, -110));\n-        assert_eq!((x3, exp3), (0.875f32, -122));\n-        assert_eq!(f32::ldexp(x1, exp1), f1);\n-        assert_eq!(f32::ldexp(x2, exp2), f2);\n-        assert_eq!(f32::ldexp(x3, exp3), f3);\n-\n-        assert_eq!(0f32.frexp(), (0f32, 0));\n-        assert_eq!((-0f32).frexp(), (-0f32, 0));\n-    }\n-\n-    #[test] #[cfg_attr(windows, ignore)] // FIXME #8755\n-    #[allow(deprecated)]\n-    fn test_frexp_nowin() {\n-        let inf: f32 = f32::INFINITY;\n-        let neg_inf: f32 = f32::NEG_INFINITY;\n-        let nan: f32 = f32::NAN;\n-        assert_eq!(match inf.frexp() { (x, _) => x }, inf);\n-        assert_eq!(match neg_inf.frexp() { (x, _) => x }, neg_inf);\n-        assert!(match nan.frexp() { (x, _) => x.is_nan() })\n-    }\n-\n     #[test]\n     fn test_asinh() {\n         assert_eq!(0.0f32.asinh(), 0.0f32);"}, {"sha": "82e3903eec7b13d8270b39115d3402fa7ee9a689", "filename": "src/libstd/f64.rs", "status": "modified", "additions": 0, "deletions": 179, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/a94124488ae0dba1a8a4552a4724cddf9d266e2f/src%2Flibstd%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a94124488ae0dba1a8a4552a4724cddf9d266e2f/src%2Flibstd%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff64.rs?ref=a94124488ae0dba1a8a4552a4724cddf9d266e2f", "patch": "@@ -22,8 +22,6 @@ use core::num;\n #[cfg(not(test))]\n use intrinsics;\n #[cfg(not(test))]\n-use libc::c_int;\n-#[cfg(not(test))]\n use num::FpCategory;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -188,36 +186,6 @@ impl f64 {\n     #[inline]\n     pub fn classify(self) -> FpCategory { num::Float::classify(self) }\n \n-    /// Returns the mantissa, base 2 exponent, and sign as integers, respectively.\n-    /// The original number can be recovered by `sign * mantissa * 2 ^ exponent`.\n-    /// The floating point encoding is documented in the [Reference][floating-point].\n-    ///\n-    /// ```\n-    /// #![feature(float_extras)]\n-    ///\n-    /// let num = 2.0f64;\n-    ///\n-    /// // (8388608, -22, 1)\n-    /// let (mantissa, exponent, sign) = num.integer_decode();\n-    /// let sign_f = sign as f64;\n-    /// let mantissa_f = mantissa as f64;\n-    /// let exponent_f = num.powf(exponent as f64);\n-    ///\n-    /// // 1 * 8388608 * 2^(-22) == 2\n-    /// let abs_difference = (sign_f * mantissa_f * exponent_f - num).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    /// [floating-point]: ../reference/types.html#machine-types\n-    #[unstable(feature = \"float_extras\", reason = \"signature is undecided\",\n-               issue = \"27752\")]\n-    #[rustc_deprecated(since = \"1.11.0\",\n-                       reason = \"never really came to fruition and easily \\\n-                                 implementable outside the standard library\")]\n-    #[inline]\n-    #[allow(deprecated)]\n-    pub fn integer_decode(self) -> (u64, i16, i8) { num::Float::integer_decode(self) }\n-\n     /// Returns the largest integer less than or equal to a number.\n     ///\n     /// ```\n@@ -606,84 +574,6 @@ impl f64 {\n     #[inline]\n     pub fn to_radians(self) -> f64 { num::Float::to_radians(self) }\n \n-    /// Constructs a floating point number of `x*2^exp`.\n-    ///\n-    /// ```\n-    /// #![feature(float_extras)]\n-    ///\n-    /// // 3*2^2 - 12 == 0\n-    /// let abs_difference = (f64::ldexp(3.0, 2) - 12.0).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[unstable(feature = \"float_extras\",\n-               reason = \"pending integer conventions\",\n-               issue = \"27752\")]\n-    #[rustc_deprecated(since = \"1.11.0\",\n-                       reason = \"never really came to fruition and easily \\\n-                                 implementable outside the standard library\")]\n-    #[inline]\n-    pub fn ldexp(x: f64, exp: isize) -> f64 {\n-        unsafe { cmath::ldexp(x, exp as c_int) }\n-    }\n-\n-    /// Breaks the number into a normalized fraction and a base-2 exponent,\n-    /// satisfying:\n-    ///\n-    ///  * `self = x * 2^exp`\n-    ///  * `0.5 <= abs(x) < 1.0`\n-    ///\n-    /// ```\n-    /// #![feature(float_extras)]\n-    ///\n-    /// let x = 4.0_f64;\n-    ///\n-    /// // (1/2)*2^3 -> 1 * 8/2 -> 4.0\n-    /// let f = x.frexp();\n-    /// let abs_difference_0 = (f.0 - 0.5).abs();\n-    /// let abs_difference_1 = (f.1 as f64 - 3.0).abs();\n-    ///\n-    /// assert!(abs_difference_0 < 1e-10);\n-    /// assert!(abs_difference_1 < 1e-10);\n-    /// ```\n-    #[unstable(feature = \"float_extras\",\n-               reason = \"pending integer conventions\",\n-               issue = \"27752\")]\n-    #[rustc_deprecated(since = \"1.11.0\",\n-                       reason = \"never really came to fruition and easily \\\n-                                 implementable outside the standard library\")]\n-    #[inline]\n-    pub fn frexp(self) -> (f64, isize) {\n-        unsafe {\n-            let mut exp = 0;\n-            let x = cmath::frexp(self, &mut exp);\n-            (x, exp as isize)\n-        }\n-    }\n-\n-    /// Returns the next representable floating-point value in the direction of\n-    /// `other`.\n-    ///\n-    /// ```\n-    /// #![feature(float_extras)]\n-    ///\n-    /// let x = 1.0f64;\n-    ///\n-    /// let abs_diff = (x.next_after(2.0) - 1.0000000000000002220446049250313_f64).abs();\n-    ///\n-    /// assert!(abs_diff < 1e-10);\n-    /// ```\n-    #[unstable(feature = \"float_extras\",\n-               reason = \"unsure about its place in the world\",\n-               issue = \"27752\")]\n-    #[rustc_deprecated(since = \"1.11.0\",\n-                       reason = \"never really came to fruition and easily \\\n-                                 implementable outside the standard library\")]\n-    #[inline]\n-    pub fn next_after(self, other: f64) -> f64 {\n-        unsafe { cmath::nextafter(self, other) }\n-    }\n-\n     /// Returns the maximum of the two numbers.\n     ///\n     /// ```\n@@ -1353,23 +1243,6 @@ mod tests {\n         assert_eq!(1e-308f64.classify(), Fp::Subnormal);\n     }\n \n-    #[test]\n-    #[allow(deprecated)]\n-    fn test_integer_decode() {\n-        assert_eq!(3.14159265359f64.integer_decode(), (7074237752028906, -51, 1));\n-        assert_eq!((-8573.5918555f64).integer_decode(), (4713381968463931, -39, -1));\n-        assert_eq!(2f64.powf(100.0).integer_decode(), (4503599627370496, 48, 1));\n-        assert_eq!(0f64.integer_decode(), (0, -1075, 1));\n-        assert_eq!((-0f64).integer_decode(), (0, -1075, -1));\n-        assert_eq!(INFINITY.integer_decode(), (4503599627370496, 972, 1));\n-        assert_eq!(NEG_INFINITY.integer_decode(), (4503599627370496, 972, -1));\n-\n-        // Ignore the \"sign\" (quiet / signalling flag) of NAN.\n-        // It can vary between runtime operations and LLVM folding.\n-        let (nan_m, nan_e, _nan_s) = NAN.integer_decode();\n-        assert_eq!((nan_m, nan_e), (6755399441055744, 972));\n-    }\n-\n     #[test]\n     fn test_floor() {\n         assert_approx_eq!(1.0f64.floor(), 1.0f64);\n@@ -1681,58 +1554,6 @@ mod tests {\n         assert_eq!(neg_inf.to_radians(), neg_inf);\n     }\n \n-    #[test]\n-    #[allow(deprecated)]\n-    fn test_ldexp() {\n-        let f1 = 2.0f64.powi(-123);\n-        let f2 = 2.0f64.powi(-111);\n-        let f3 = 1.75 * 2.0f64.powi(-12);\n-        assert_eq!(f64::ldexp(1f64, -123), f1);\n-        assert_eq!(f64::ldexp(1f64, -111), f2);\n-        assert_eq!(f64::ldexp(1.75f64, -12), f3);\n-\n-        assert_eq!(f64::ldexp(0f64, -123), 0f64);\n-        assert_eq!(f64::ldexp(-0f64, -123), -0f64);\n-\n-        let inf: f64 = INFINITY;\n-        let neg_inf: f64 = NEG_INFINITY;\n-        let nan: f64 = NAN;\n-        assert_eq!(f64::ldexp(inf, -123), inf);\n-        assert_eq!(f64::ldexp(neg_inf, -123), neg_inf);\n-        assert!(f64::ldexp(nan, -123).is_nan());\n-    }\n-\n-    #[test]\n-    #[allow(deprecated)]\n-    fn test_frexp() {\n-        let f1 = 2.0f64.powi(-123);\n-        let f2 = 2.0f64.powi(-111);\n-        let f3 = 1.75 * 2.0f64.powi(-123);\n-        let (x1, exp1) = f1.frexp();\n-        let (x2, exp2) = f2.frexp();\n-        let (x3, exp3) = f3.frexp();\n-        assert_eq!((x1, exp1), (0.5f64, -122));\n-        assert_eq!((x2, exp2), (0.5f64, -110));\n-        assert_eq!((x3, exp3), (0.875f64, -122));\n-        assert_eq!(f64::ldexp(x1, exp1), f1);\n-        assert_eq!(f64::ldexp(x2, exp2), f2);\n-        assert_eq!(f64::ldexp(x3, exp3), f3);\n-\n-        assert_eq!(0f64.frexp(), (0f64, 0));\n-        assert_eq!((-0f64).frexp(), (-0f64, 0));\n-    }\n-\n-    #[test] #[cfg_attr(windows, ignore)] // FIXME #8755\n-    #[allow(deprecated)]\n-    fn test_frexp_nowin() {\n-        let inf: f64 = INFINITY;\n-        let neg_inf: f64 = NEG_INFINITY;\n-        let nan: f64 = NAN;\n-        assert_eq!(match inf.frexp() { (x, _) => x }, inf);\n-        assert_eq!(match neg_inf.frexp() { (x, _) => x }, neg_inf);\n-        assert!(match nan.frexp() { (x, _) => x.is_nan() })\n-    }\n-\n     #[test]\n     fn test_asinh() {\n         assert_eq!(0.0f64.asinh(), 0.0f64);"}, {"sha": "70225da5f3355c2150b722b4a3bdc20f15deaa7d", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a94124488ae0dba1a8a4552a4724cddf9d266e2f/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a94124488ae0dba1a8a4552a4724cddf9d266e2f/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=a94124488ae0dba1a8a4552a4724cddf9d266e2f", "patch": "@@ -248,7 +248,6 @@\n #![feature(allow_internal_unstable)]\n #![feature(asm)]\n #![feature(associated_consts)]\n-#![feature(borrow_state)]\n #![feature(box_syntax)]\n #![feature(cfg_target_has_atomic)]\n #![feature(cfg_target_thread_local)]\n@@ -263,7 +262,6 @@\n #![feature(core_intrinsics)]\n #![feature(dropck_eyepatch)]\n #![feature(exact_size_is_empty)]\n-#![feature(float_extras)]\n #![feature(float_from_str_radix)]\n #![feature(fn_traits)]\n #![feature(fnbox)]\n@@ -319,7 +317,6 @@\n #![feature(untagged_unions)]\n #![feature(unwind_attributes)]\n #![feature(vec_push_all)]\n-#![feature(zero_one)]\n #![cfg_attr(test, feature(update_panic_count))]\n #![cfg_attr(stage0, feature(pub_restricted))]\n #![cfg_attr(test, feature(float_bits_conv))]"}, {"sha": "ff89887ac92c3c59369a75ffcf5e9df20d3f224e", "filename": "src/libstd/num.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a94124488ae0dba1a8a4552a4724cddf9d266e2f/src%2Flibstd%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a94124488ae0dba1a8a4552a4724cddf9d266e2f/src%2Flibstd%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum.rs?ref=a94124488ae0dba1a8a4552a4724cddf9d266e2f", "patch": "@@ -16,9 +16,6 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![allow(missing_docs)]\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(deprecated)]\n-pub use core::num::{Zero, One};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::num::{FpCategory, ParseIntError, ParseFloatError, TryFromIntError};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "17ea5b9a79489855c314adc38a5f985f53c5f5d5", "filename": "src/test/run-pass/issue-8460.rs", "status": "modified", "additions": 23, "deletions": 12, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a94124488ae0dba1a8a4552a4724cddf9d266e2f/src%2Ftest%2Frun-pass%2Fissue-8460.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a94124488ae0dba1a8a4552a4724cddf9d266e2f/src%2Ftest%2Frun-pass%2Fissue-8460.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-8460.rs?ref=a94124488ae0dba1a8a4552a4724cddf9d266e2f", "patch": "@@ -9,11 +9,22 @@\n // except according to those terms.\n \n // ignore-emscripten no threads support\n-#![feature(rustc_attrs, zero_one)]\n+#![feature(rustc_attrs)]\n \n-use std::num::Zero;\n use std::thread;\n \n+trait Int {\n+    fn zero() -> Self;\n+    fn one() -> Self;\n+}\n+macro_rules! doit {\n+    ($($t:ident)*) => ($(impl Int for $t {\n+        fn zero() -> $t { 0 }\n+        fn one() -> $t { 1 }\n+    })*)\n+}\n+doit! { i8 i16 i32 i64 isize }\n+\n macro_rules! check {\n     ($($e:expr),*) => {\n         $(assert!(thread::spawn({\n@@ -24,21 +35,21 @@ macro_rules! check {\n \n fn main() {\n     check![\n-        isize::min_value() / -1,\n-        i8::min_value() / -1,\n-        i16::min_value() / -1,\n-        i32::min_value() / -1,\n-        i64::min_value() / -1,\n+        isize::min_value() / -isize::one(),\n+        i8::min_value() / -i8::one(),\n+        i16::min_value() / -i16::one(),\n+        i32::min_value() / -i32::one(),\n+        i64::min_value() / -i64::one(),\n         1isize / isize::zero(),\n         1i8 / i8::zero(),\n         1i16 / i16::zero(),\n         1i32 / i32::zero(),\n         1i64 / i64::zero(),\n-        isize::min_value() % -1,\n-        i8::min_value() % -1,\n-        i16::min_value() % -1,\n-        i32::min_value() % -1,\n-        i64::min_value() % -1,\n+        isize::min_value() % -isize::one(),\n+        i8::min_value() % -i8::one(),\n+        i16::min_value() % -i16::one(),\n+        i32::min_value() % -i32::one(),\n+        i64::min_value() % -i64::one(),\n         1isize % isize::zero(),\n         1i8 % i8::zero(),\n         1i16 % i16::zero(),"}, {"sha": "ea154590deef0af432ff2ce192a7cb76ee60be33", "filename": "src/test/run-pass/sync-send-iterators-in-libcollections.rs", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a94124488ae0dba1a8a4552a4724cddf9d266e2f/src%2Ftest%2Frun-pass%2Fsync-send-iterators-in-libcollections.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a94124488ae0dba1a8a4552a4724cddf9d266e2f/src%2Ftest%2Frun-pass%2Fsync-send-iterators-in-libcollections.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsync-send-iterators-in-libcollections.rs?ref=a94124488ae0dba1a8a4552a4724cddf9d266e2f", "patch": "@@ -10,13 +10,12 @@\n \n #![allow(warnings)]\n #![feature(collections)]\n-#![feature(drain, enumset, collections_bound, btree_range, vecmap)]\n+#![feature(drain, collections_bound, btree_range, vecmap)]\n \n extern crate collections;\n \n use collections::BinaryHeap;\n use collections::{BTreeMap, BTreeSet};\n-use collections::EnumSet;\n use collections::LinkedList;\n use collections::String;\n use collections::Vec;\n@@ -25,7 +24,6 @@ use std::collections::HashMap;\n use std::collections::HashSet;\n \n use collections::Bound::Included;\n-use collections::enum_set::CLike;\n use std::mem;\n \n fn is_sync<T>(_: T) where T: Sync {}\n@@ -76,21 +74,6 @@ fn main() {\n \n     all_sync_send!(LinkedList::<usize>::new(), iter, iter_mut, into_iter);\n \n-    #[derive(Copy, Clone)]\n-    #[repr(usize)]\n-    #[allow(dead_code)]\n-    enum Foo { A, B, C }\n-    impl CLike for Foo {\n-        fn to_usize(&self) -> usize {\n-            *self as usize\n-        }\n-\n-        fn from_usize(v: usize) -> Foo {\n-            unsafe { mem::transmute(v) }\n-        }\n-    }\n-    all_sync_send!(EnumSet::<Foo>::new(), iter);\n-\n     all_sync_send!(VecDeque::<usize>::new(), iter, iter_mut, into_iter);\n     is_sync_send!(VecDeque::<usize>::new(), drain(..));\n "}, {"sha": "7a0b4c6aaca4922b62eddf73c0ab65a0096b2fca", "filename": "src/test/run-pass/union/union-transmute.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a94124488ae0dba1a8a4552a4724cddf9d266e2f/src%2Ftest%2Frun-pass%2Funion%2Funion-transmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a94124488ae0dba1a8a4552a4724cddf9d266e2f/src%2Ftest%2Frun-pass%2Funion%2Funion-transmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funion%2Funion-transmute.rs?ref=a94124488ae0dba1a8a4552a4724cddf9d266e2f", "patch": "@@ -8,12 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(core_float)]\n-#![feature(float_extras)]\n #![feature(untagged_unions)]\n \n extern crate core;\n-use core::num::Float;\n+use core::f32;\n \n union U {\n     a: (u8, u8),\n@@ -33,8 +31,8 @@ fn main() {\n         assert_eq!(u.a, (2, 2));\n \n         let mut w = W { a: 0b0_11111111_00000000000000000000000 };\n-        assert_eq!(w.b, f32::infinity());\n-        w.b = f32::neg_infinity();\n+        assert_eq!(w.b, f32::INFINITY);\n+        w.b = f32::NEG_INFINITY;\n         assert_eq!(w.a, 0b1_11111111_00000000000000000000000);\n     }\n }"}, {"sha": "aed6986c5fe5d380b71a1fefc1fff776e0186ebe", "filename": "src/test/run-pass/while-let.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a94124488ae0dba1a8a4552a4724cddf9d266e2f/src%2Ftest%2Frun-pass%2Fwhile-let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a94124488ae0dba1a8a4552a4724cddf9d266e2f/src%2Ftest%2Frun-pass%2Fwhile-let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwhile-let.rs?ref=a94124488ae0dba1a8a4552a4724cddf9d266e2f", "patch": "@@ -9,8 +9,6 @@\n // except according to those terms.\n \n \n-#![feature(binary_heap_extras)]\n-\n use std::collections::BinaryHeap;\n \n fn make_pq() -> BinaryHeap<isize> {"}]}