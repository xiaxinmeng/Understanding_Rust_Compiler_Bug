{"sha": "3f17ab9618d147a3f16d49a10fff44c5e8da4e60", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmMTdhYjk2MThkMTQ3YTNmMTZkNDlhMTBmZmY0NGM1ZThkYTRlNjA=", "commit": {"author": {"name": "Mark-Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-12-11T03:35:02Z"}, "committer": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-12-21T03:01:40Z"}, "message": "Remove unreachable and terminated from Block", "tree": {"sha": "d04bdfafc90c6e855c2d4bfac13a66fe43d2190b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d04bdfafc90c6e855c2d4bfac13a66fe43d2190b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3f17ab9618d147a3f16d49a10fff44c5e8da4e60", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3f17ab9618d147a3f16d49a10fff44c5e8da4e60", "html_url": "https://github.com/rust-lang/rust/commit/3f17ab9618d147a3f16d49a10fff44c5e8da4e60", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3f17ab9618d147a3f16d49a10fff44c5e8da4e60/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf7d4534a7ed27f1a0b5c9b53b2af155da33f072", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf7d4534a7ed27f1a0b5c9b53b2af155da33f072", "html_url": "https://github.com/rust-lang/rust/commit/bf7d4534a7ed27f1a0b5c9b53b2af155da33f072"}], "stats": {"total": 112, "additions": 18, "deletions": 94}, "files": [{"sha": "4585dccfc8bd1c5fa3aa5afd6f400c442ac27f28", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f17ab9618d147a3f16d49a10fff44c5e8da4e60/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f17ab9618d147a3f16d49a10fff44c5e8da4e60/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=3f17ab9618d147a3f16d49a10fff44c5e8da4e60", "patch": "@@ -566,7 +566,7 @@ fn struct_field_ptr<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n                                 ix: usize, needs_cast: bool) -> ValueRef {\n     let fty = fields[ix];\n     let ccx = bcx.ccx();\n-    let ll_fty = type_of::in_memory_type_of(bcx.ccx(), fty);\n+    let ll_fty = type_of::in_memory_type_of(ccx, fty);\n \n     let ptr_val = if needs_cast {\n         let fields = st.field_index_by_increasing_offset().map(|i| {"}, {"sha": "d4f11df4e282811e96f402d103a18dc0148487e4", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 5, "deletions": 27, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3f17ab9618d147a3f16d49a10fff44c5e8da4e60/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f17ab9618d147a3f16d49a10fff44c5e8da4e60/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=3f17ab9618d147a3f16d49a10fff44c5e8da4e60", "patch": "@@ -467,10 +467,6 @@ pub fn invoke<'blk, 'tcx>(bcx: BlockAndBuilder<'blk, 'tcx>,\n                           debug_loc: DebugLoc)\n                           -> (ValueRef, BlockAndBuilder<'blk, 'tcx>) {\n     let _icx = push_ctxt(\"invoke_\");\n-    if bcx.is_unreachable() {\n-        return (C_null(Type::i8(bcx.ccx())), bcx);\n-    }\n-\n     if need_invoke(&bcx) {\n         debug!(\"invoking {:?} at {:?}\", Value(llfn), bcx.llbb());\n         for &llarg in llargs {\n@@ -562,10 +558,6 @@ pub fn load_ty_builder<'a, 'tcx>(b: &Builder<'a, 'tcx>, ptr: ValueRef, t: Ty<'tc\n /// Helper for storing values in memory. Does the necessary conversion if the in-memory type\n /// differs from the type used for SSA values.\n pub fn store_ty<'blk, 'tcx>(cx: &BlockAndBuilder<'blk, 'tcx>, v: ValueRef, dst: ValueRef, t: Ty<'tcx>) {\n-    if cx.is_unreachable() {\n-        return;\n-    }\n-\n     debug!(\"store_ty: {:?} : {:?} <- {:?}\", Value(dst), t, Value(v));\n \n     if common::type_is_fat_ptr(cx.tcx(), t) {\n@@ -592,12 +584,6 @@ pub fn load_fat_ptr<'blk, 'tcx>(cx: &BlockAndBuilder<'blk, 'tcx>,\n                                 ty: Ty<'tcx>)\n                                 -> (ValueRef, ValueRef)\n {\n-    if cx.is_unreachable() {\n-        // FIXME: remove me\n-        return (Load(cx, get_dataptr(cx, src)),\n-                Load(cx, get_meta(cx, src)));\n-    }\n-\n     load_fat_ptr_builder(cx, src, ty)\n }\n \n@@ -644,7 +630,7 @@ pub fn with_cond<'blk, 'tcx, F>(\n {\n     let _icx = push_ctxt(\"with_cond\");\n \n-    if bcx.is_unreachable() || common::const_to_opt_uint(val) == Some(0) {\n+    if common::const_to_opt_uint(val) == Some(0) {\n         return bcx;\n     }\n \n@@ -704,15 +690,11 @@ impl Lifetime {\n }\n \n pub fn call_lifetime_start(bcx: &BlockAndBuilder, ptr: ValueRef) {\n-    if !bcx.is_unreachable() {\n-        Lifetime::Start.call(bcx, ptr);\n-    }\n+    Lifetime::Start.call(bcx, ptr);\n }\n \n pub fn call_lifetime_end(bcx: &BlockAndBuilder, ptr: ValueRef) {\n-    if !bcx.is_unreachable() {\n-        Lifetime::End.call(bcx, ptr);\n-    }\n+    Lifetime::End.call(bcx, ptr);\n }\n \n // Generates code for resumption of unwind at the end of a landing pad.\n@@ -747,7 +729,7 @@ pub fn memcpy_ty<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>, dst: ValueRef, s\n     let _icx = push_ctxt(\"memcpy_ty\");\n     let ccx = bcx.ccx();\n \n-    if type_is_zero_size(ccx, t) || bcx.is_unreachable() {\n+    if type_is_zero_size(ccx, t) {\n         return;\n     }\n \n@@ -765,9 +747,6 @@ pub fn memcpy_ty<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>, dst: ValueRef, s\n }\n \n pub fn init_zero_mem<'blk, 'tcx>(cx: &BlockAndBuilder<'blk, 'tcx>, llptr: ValueRef, t: Ty<'tcx>) {\n-    if cx.is_unreachable() {\n-        return;\n-    }\n     let _icx = push_ctxt(\"init_zero_mem\");\n     let bcx = cx;\n     memfill(bcx, llptr, t, 0);\n@@ -926,8 +905,7 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n     // Builds the return block for a function.\n     pub fn build_return_block(&self, ret_cx: &BlockAndBuilder<'blk, 'tcx>,\n                               ret_debug_location: DebugLoc) {\n-        if self.llretslotptr.get().is_none() || ret_cx.is_unreachable() ||\n-           self.fn_ty.ret.is_indirect() {\n+        if self.llretslotptr.get().is_none() || self.fn_ty.ret.is_indirect() {\n             return RetVoid(ret_cx, ret_debug_location);\n         }\n "}, {"sha": "16f362da29fceb0faffc2c723740fa6252c1c6ff", "filename": "src/librustc_trans/build.rs", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3f17ab9618d147a3f16d49a10fff44c5e8da4e60/src%2Flibrustc_trans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f17ab9618d147a3f16d49a10fff44c5e8da4e60/src%2Flibrustc_trans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbuild.rs?ref=3f17ab9618d147a3f16d49a10fff44c5e8da4e60", "patch": "@@ -24,36 +24,24 @@ use debuginfo::DebugLoc;\n \n use libc::{c_uint, c_char};\n \n-// The difference between a block being unreachable and being terminated is\n-// somewhat obscure, and has to do with error checking. When a block is\n-// terminated, we're saying that trying to add any further statements in the\n-// block is an error. On the other hand, if something is unreachable, that\n-// means that the block was terminated in some way that we don't want to check\n-// for (panic/break/return statements, call to diverging functions, etc), and\n-// further instructions to the block should simply be ignored.\n-\n pub fn RetVoid(cx: &BlockAndBuilder, debug_loc: DebugLoc) {\n-    cx.terminate();\n     debug_loc.apply(cx.fcx());\n     cx.ret_void();\n }\n \n pub fn Ret(cx: &BlockAndBuilder, v: ValueRef, debug_loc: DebugLoc) {\n-    cx.terminate();\n     debug_loc.apply(cx.fcx());\n     cx.ret(v);\n }\n \n pub fn AggregateRet(cx: &BlockAndBuilder,\n     ret_vals: &[ValueRef],\n     debug_loc: DebugLoc) {\n-    cx.terminate();\n     debug_loc.apply(cx.fcx());\n     cx.aggregate_ret(ret_vals);\n }\n \n pub fn Br(cx: &BlockAndBuilder, dest: BasicBlockRef, debug_loc: DebugLoc) {\n-    cx.terminate();\n     debug_loc.apply(cx.fcx());\n     cx.br(dest);\n }\n@@ -63,14 +51,12 @@ pub fn CondBr(cx: &BlockAndBuilder,\n     then: BasicBlockRef,\n     else_: BasicBlockRef,\n     debug_loc: DebugLoc) {\n-    cx.terminate();\n     debug_loc.apply(cx.fcx());\n     cx.cond_br(if_, then, else_);\n }\n \n pub fn Switch(cx: &BlockAndBuilder, v: ValueRef, else_: BasicBlockRef, num_cases: usize)\n     -> ValueRef {\n-        cx.terminate();\n         cx.switch(v, else_, num_cases)\n     }\n \n@@ -85,7 +71,6 @@ pub fn IndirectBr(cx: &BlockAndBuilder,\n     addr: ValueRef,\n     num_dests: usize,\n     debug_loc: DebugLoc) {\n-    cx.terminate();\n     debug_loc.apply(cx.fcx());\n     cx.indirect_br(addr, num_dests);\n }\n@@ -97,7 +82,6 @@ pub fn Invoke(cx: &BlockAndBuilder,\n     catch: BasicBlockRef,\n     debug_loc: DebugLoc)\n     -> ValueRef {\n-    cx.terminate();\n     debug!(\"Invoke({:?} with arguments ({}))\",\n     Value(fn_),\n     args.iter().map(|a| {\n@@ -687,7 +671,6 @@ pub fn Trap(cx: &BlockAndBuilder) {\n \n pub fn LandingPad(cx: &BlockAndBuilder, ty: Type, pers_fn: ValueRef,\n     num_clauses: usize) -> ValueRef {\n-    assert!(!cx.is_unreachable());\n     cx.landing_pad(ty, pers_fn, num_clauses, cx.fcx().llfn)\n }\n \n@@ -720,34 +703,29 @@ pub fn AtomicRMW(cx: &BlockAndBuilder, op: AtomicRmwBinOp,\n pub fn CleanupPad(cx: &BlockAndBuilder,\n     parent: Option<ValueRef>,\n     args: &[ValueRef]) -> ValueRef {\n-    assert!(!cx.is_unreachable());\n     cx.cleanup_pad(parent, args)\n }\n \n pub fn CleanupRet(cx: &BlockAndBuilder,\n     cleanup: ValueRef,\n     unwind: Option<BasicBlockRef>) -> ValueRef {\n-    cx.terminate();\n     cx.cleanup_ret(cleanup, unwind)\n }\n \n pub fn CatchPad(cx: &BlockAndBuilder,\n     parent: ValueRef,\n     args: &[ValueRef]) -> ValueRef {\n-    assert!(!cx.is_unreachable());\n     cx.catch_pad(parent, args)\n }\n \n pub fn CatchRet(cx: &BlockAndBuilder, pad: ValueRef, unwind: BasicBlockRef) -> ValueRef {\n-    cx.terminate();\n     cx.catch_ret(pad, unwind)\n }\n \n pub fn CatchSwitch(cx: &BlockAndBuilder,\n     parent: Option<ValueRef>,\n     unwind: Option<BasicBlockRef>,\n     num_handlers: usize) -> ValueRef {\n-    cx.terminate();\n     cx.catch_switch(parent, unwind, num_handlers)\n }\n "}, {"sha": "7422c5f8805f96682311924f3d33513c2a4bc76a", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3f17ab9618d147a3f16d49a10fff44c5e8da4e60/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f17ab9618d147a3f16d49a10fff44c5e8da4e60/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=3f17ab9618d147a3f16d49a10fff44c5e8da4e60", "patch": "@@ -712,24 +712,20 @@ fn trans_call_inner<'a, 'blk, 'tcx>(bcx: BlockAndBuilder<'blk, 'tcx>,\n     };\n \n     let (llret, bcx) = base::invoke(bcx, llfn, &llargs, debug_loc);\n-    if !bcx.is_unreachable() {\n-        fn_ty.apply_attrs_callsite(llret);\n-\n-        // If the function we just called does not use an outpointer,\n-        // store the result into the rust outpointer. Cast the outpointer\n-        // type to match because some ABIs will use a different type than\n-        // the Rust type. e.g., a {u32,u32} struct could be returned as\n-        // u64.\n-        if !fn_ty.ret.is_indirect() {\n-            if let Some(llretslot) = opt_llretslot {\n-                fn_ty.ret.store(&bcx, llret, llretslot);\n-            }\n+    fn_ty.apply_attrs_callsite(llret);\n+\n+    // If the function we just called does not use an outpointer,\n+    // store the result into the rust outpointer. Cast the outpointer\n+    // type to match because some ABIs will use a different type than\n+    // the Rust type. e.g., a {u32,u32} struct could be returned as\n+    // u64.\n+    if !fn_ty.ret.is_indirect() {\n+        if let Some(llretslot) = opt_llretslot {\n+            fn_ty.ret.store(&bcx, llret, llretslot);\n         }\n     }\n \n     if fn_ret.0.is_never() {\n-        assert!(!bcx.is_terminated());\n-        bcx.set_unreachable();\n         bcx.unreachable();\n     }\n "}, {"sha": "3524d458e0105c3a057c922627d5bc6a31b24589", "filename": "src/librustc_trans/cleanup.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3f17ab9618d147a3f16d49a10fff44c5e8da4e60/src%2Flibrustc_trans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f17ab9618d147a3f16d49a10fff44c5e8da4e60/src%2Flibrustc_trans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcleanup.rs?ref=3f17ab9618d147a3f16d49a10fff44c5e8da4e60", "patch": "@@ -343,10 +343,8 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n                             scope: &CleanupScope<'tcx>) -> BlockAndBuilder<'blk, 'tcx> {\n \n         let mut bcx = bcx;\n-        if !bcx.is_unreachable() {\n-            for cleanup in scope.cleanups.iter().rev() {\n-                bcx = cleanup.trans(bcx, scope.debug_loc);\n-            }\n+        for cleanup in scope.cleanups.iter().rev() {\n+            bcx = cleanup.trans(bcx, scope.debug_loc);\n         }\n         bcx\n     }"}, {"sha": "84d30b6b97a42142d582eb77dd488e5ae42bda92", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3f17ab9618d147a3f16d49a10fff44c5e8da4e60/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f17ab9618d147a3f16d49a10fff44c5e8da4e60/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=3f17ab9618d147a3f16d49a10fff44c5e8da4e60", "patch": "@@ -449,8 +449,6 @@ pub struct BlockS<'blk, 'tcx: 'blk> {\n     // instructions into that block by way of this block context.\n     // The block pointing to this one in the function's digraph.\n     pub llbb: BasicBlockRef,\n-    pub terminated: Cell<bool>,\n-    pub unreachable: Cell<bool>,\n \n     // If this block part of a landing pad, then this is `Some` indicating what\n     // kind of landing pad its in, otherwise this is none.\n@@ -469,8 +467,6 @@ impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n                -> Block<'blk, 'tcx> {\n         fcx.block_arena.alloc(BlockS {\n             llbb: llbb,\n-            terminated: Cell::new(false),\n-            unreachable: Cell::new(false),\n             lpad: Cell::new(None),\n             fcx: fcx\n         })\n@@ -599,24 +595,6 @@ impl<'blk, 'tcx> BlockAndBuilder<'blk, 'tcx> {\n \n     // Methods delegated to bcx\n \n-    pub fn terminate(&self) {\n-        debug!(\"terminate({})\", self.bcx.to_str());\n-        self.bcx.terminated.set(true);\n-    }\n-\n-    pub fn set_unreachable(&self) {\n-        debug!(\"set_unreachable({})\", self.bcx.to_str());\n-        self.bcx.unreachable.set(true);\n-    }\n-\n-    pub fn is_unreachable(&self) -> bool {\n-        self.bcx.unreachable.get()\n-    }\n-\n-    pub fn is_terminated(&self) -> bool {\n-        self.bcx.terminated.get()\n-    }\n-\n     pub fn ccx(&self) -> &'blk CrateContext<'blk, 'tcx> {\n         self.bcx.ccx()\n     }"}, {"sha": "7044f8d58352080db8d0e01585ee659dca7b90bd", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f17ab9618d147a3f16d49a10fff44c5e8da4e60/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f17ab9618d147a3f16d49a10fff44c5e8da4e60/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=3f17ab9618d147a3f16d49a10fff44c5e8da4e60", "patch": "@@ -321,10 +321,6 @@ pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n         let align = C_uint(bcx.ccx(), align);\n         return (size, align);\n     }\n-    if bcx.is_unreachable() {\n-        let llty = Type::int(bcx.ccx());\n-        return (C_undef(llty), C_undef(llty));\n-    }\n     match t.sty {\n         ty::TyAdt(def, substs) => {\n             let ccx = bcx.ccx();"}]}