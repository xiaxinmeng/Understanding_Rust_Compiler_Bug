{"sha": "9784d3543f524f142aae52da9d2a6ce1eb9d702a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3ODRkMzU0M2Y1MjRmMTQyYWFlNTJkYTlkMmE2Y2UxZWI5ZDcwMmE=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-09-21T01:26:36Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-09-21T01:26:53Z"}, "message": "parser: Tweak function parameter parsing to avoid rollback on succesfull path", "tree": {"sha": "cec3130b8bfe07d805330552686df6d6d659a7cd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cec3130b8bfe07d805330552686df6d6d659a7cd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9784d3543f524f142aae52da9d2a6ce1eb9d702a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9784d3543f524f142aae52da9d2a6ce1eb9d702a", "html_url": "https://github.com/rust-lang/rust/commit/9784d3543f524f142aae52da9d2a6ce1eb9d702a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9784d3543f524f142aae52da9d2a6ce1eb9d702a/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2fa1390f6c1ca36b0cc1c126e6d295d360f42b6c", "url": "https://api.github.com/repos/rust-lang/rust/commits/2fa1390f6c1ca36b0cc1c126e6d295d360f42b6c", "html_url": "https://github.com/rust-lang/rust/commit/2fa1390f6c1ca36b0cc1c126e6d295d360f42b6c"}], "stats": {"total": 62, "additions": 26, "deletions": 36}, "files": [{"sha": "963a7206bd61e955ed0c2b209a59a2e83562caea", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 26, "deletions": 36, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/9784d3543f524f142aae52da9d2a6ce1eb9d702a/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9784d3543f524f142aae52da9d2a6ce1eb9d702a/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=9784d3543f524f142aae52da9d2a6ce1eb9d702a", "patch": "@@ -1780,27 +1780,32 @@ impl<'a> Parser<'a> {\n             (pat, self.parse_ty()?)\n         } else {\n             debug!(\"parse_arg_general ident_to_pat\");\n+            let parser_snapshot_before_ty = self.clone();\n+            let mut ty = self.parse_ty();\n+            if ty.is_ok() && self.token == token::Colon {\n+                // This wasn't actually a type, but a pattern looking like a type,\n+                // so we are going to rollback and re-parse for recovery.\n+                ty = self.unexpected();\n+            }\n+            match ty {\n+                Ok(ty) => {\n+                    let ident = Ident::new(keywords::Invalid.name(), self.prev_span);\n+                    let pat = P(Pat {\n+                        id: ast::DUMMY_NODE_ID,\n+                        node: PatKind::Ident(\n+                            BindingMode::ByValue(Mutability::Immutable), ident, None),\n+                        span: ty.span,\n+                    });\n+                    (pat, ty)\n+                }\n+                Err(mut err) => {\n+                    // Recover from attempting to parse the argument as a type without pattern.\n+                    err.cancel();\n+                    mem::replace(self, parser_snapshot_before_ty);\n+                    let pat = self.parse_pat()?;\n+                    self.expect(&token::Colon)?;\n+                    let ty = self.parse_ty()?;\n \n-            let parser_snapshot_before_pat = self.clone();\n-\n-            // Once we can use edition 2018 in the compiler,\n-            // replace this with real try blocks.\n-            macro_rules! try_block {\n-                ($($inside:tt)*) => (\n-                    (||{ ::std::ops::Try::from_ok({ $($inside)* }) })()\n-                )\n-            }\n-\n-            // We're going to try parsing the argument as a pattern (even though it's not\n-            // allowed). This way we can provide better errors to the user.\n-            let pat_arg: PResult<'a, _> = try_block! {\n-                let pat = self.parse_pat()?;\n-                self.expect(&token::Colon)?;\n-                (pat, self.parse_ty()?)\n-            };\n-\n-            match pat_arg {\n-                Ok((pat, ty)) => {\n                     let mut err = self.diagnostic().struct_span_err_with_code(\n                         pat.span,\n                         \"patterns aren't allowed in methods without bodies\",\n@@ -1813,6 +1818,7 @@ impl<'a> Parser<'a> {\n                         Applicability::MachineApplicable,\n                     );\n                     err.emit();\n+\n                     // Pretend the pattern is `_`, to avoid duplicate errors from AST validation.\n                     let pat = P(Pat {\n                         node: PatKind::Wild,\n@@ -1821,22 +1827,6 @@ impl<'a> Parser<'a> {\n                     });\n                     (pat, ty)\n                 }\n-                Err(mut err) => {\n-                    err.cancel();\n-                    // Recover from attempting to parse the argument as a pattern. This means\n-                    // the type is alone, with no name, e.g. `fn foo(u32)`.\n-                    mem::replace(self, parser_snapshot_before_pat);\n-                    debug!(\"parse_arg_general ident_to_pat\");\n-                    let ident = Ident::new(keywords::Invalid.name(), self.prev_span);\n-                    let ty = self.parse_ty()?;\n-                    let pat = P(Pat {\n-                        id: ast::DUMMY_NODE_ID,\n-                        node: PatKind::Ident(\n-                            BindingMode::ByValue(Mutability::Immutable), ident, None),\n-                        span: ty.span,\n-                    });\n-                    (pat, ty)\n-                }\n             }\n         };\n "}]}