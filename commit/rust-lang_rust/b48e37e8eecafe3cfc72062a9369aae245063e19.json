{"sha": "b48e37e8eecafe3cfc72062a9369aae245063e19", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0OGUzN2U4ZWVjYWZlM2NmYzcyMDYyYTkzNjlhYWUyNDUwNjNlMTk=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-07-16T05:05:50Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-07-16T05:05:50Z"}, "message": "syntax: make a macros-injection pass; conditionally define debug! to a noop based on cfg(debug).\n\nMacros can be conditionally defined because stripping occurs before macro\nexpansion, but, the built-in macros were only added as part of the actual\nexpansion process and so couldn't be stripped to have definitions conditional\non cfg flags.\n\ndebug! is defined conditionally in terms of the debug config, expanding to\nnothing unless the --cfg debug flag is passed (to be precise it expands to\n`if false { normal_debug!(...) }` so that they are still type checked, and\nto avoid unused variable lints).", "tree": {"sha": "6c4ea529211d02addc46588667ec9f9ac271a901", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6c4ea529211d02addc46588667ec9f9ac271a901"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b48e37e8eecafe3cfc72062a9369aae245063e19", "comment_count": 1, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b48e37e8eecafe3cfc72062a9369aae245063e19", "html_url": "https://github.com/rust-lang/rust/commit/b48e37e8eecafe3cfc72062a9369aae245063e19", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b48e37e8eecafe3cfc72062a9369aae245063e19/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "98c16549cb8f709c5e744360e7b3a37dce9fa1de", "url": "https://api.github.com/repos/rust-lang/rust/commits/98c16549cb8f709c5e744360e7b3a37dce9fa1de", "html_url": "https://github.com/rust-lang/rust/commit/98c16549cb8f709c5e744360e7b3a37dce9fa1de"}], "stats": {"total": 147, "additions": 104, "deletions": 43}, "files": [{"sha": "d41c1167c70ce706dbfc33b652b04bb276a7d905", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b48e37e8eecafe3cfc72062a9369aae245063e19/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b48e37e8eecafe3cfc72062a9369aae245063e19/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=b48e37e8eecafe3cfc72062a9369aae245063e19", "patch": "@@ -194,6 +194,10 @@ pub fn compile_rest(sess: Session,\n         //   mod bar { macro_rules! baz!(() => {{}}) }\n         //\n         // baz! should not use this definition unless foo is enabled.\n+        crate = time(time_passes, ~\"std macros injection\", ||\n+                     syntax::ext::expand::inject_std_macros(sess.parse_sess, copy cfg,\n+                                                             crate));\n+\n         crate = time(time_passes, ~\"configuration 1\", ||\n                      front::config::strip_unconfigured_items(crate));\n \n@@ -214,7 +218,7 @@ pub fn compile_rest(sess: Session,\n     assert!(phases.from != cu_no_trans);\n \n     let (llcx, llmod, link_meta) = {\n-        crate = time(time_passes, ~\"extra injection\", ||\n+        crate = time(time_passes, ~\"std injection\", ||\n                      front::std_inject::maybe_inject_libstd_ref(sess, crate));\n \n         let ast_map = time(time_passes, ~\"ast indexing\", ||"}, {"sha": "559186d316e768247d0e6bbbcfd7691649ef10e5", "filename": "src/librustdoc/astsrv.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b48e37e8eecafe3cfc72062a9369aae245063e19/src%2Flibrustdoc%2Fastsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b48e37e8eecafe3cfc72062a9369aae245063e19/src%2Flibrustdoc%2Fastsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fastsrv.rs?ref=b48e37e8eecafe3cfc72062a9369aae245063e19", "patch": "@@ -113,6 +113,8 @@ fn build_ctxt(sess: Session,\n \n     use rustc::front::config;\n \n+    let ast = syntax::ext::expand::inject_std_macros(sess.parse_sess,\n+                                                     copy sess.opts.cfg, ast);\n     let ast = config::strip_unconfigured_items(ast);\n     let ast = syntax::ext::expand::expand_crate(sess.parse_sess,\n                                                 copy sess.opts.cfg, ast);"}, {"sha": "d63d914edd3965839b5c440fabde65573afe3972", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 59, "deletions": 42, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/b48e37e8eecafe3cfc72062a9369aae245063e19/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b48e37e8eecafe3cfc72062a9369aae245063e19/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=b48e37e8eecafe3cfc72062a9369aae245063e19", "patch": "@@ -8,15 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{blk_, attribute_, attr_outer, meta_word};\n-use ast::{crate, expr_, expr_mac, mac_invoc_tt};\n+use ast::{blk_, crate, expr_, expr_mac, mac_invoc_tt};\n use ast::{item_mac, stmt_, stmt_mac, stmt_expr, stmt_semi};\n use ast::{illegal_ctxt};\n use ast;\n use ast_util::{new_rename, new_mark, resolve};\n use attr;\n use codemap;\n-use codemap::{span, ExpnInfo, NameAndSpan, spanned};\n+use codemap::{span, ExpnInfo, NameAndSpan};\n use ext::base::*;\n use fold::*;\n use parse;\n@@ -452,9 +451,11 @@ pub fn new_span(cx: @ExtCtxt, sp: span) -> span {\n // the default compilation environment. It would be much nicer to use\n // a mechanism like syntax_quote to ensure hygiene.\n \n-pub fn core_macros() -> @str {\n+pub fn std_macros() -> @str {\n     return\n-@\"pub mod macros {\n+@\"pub mod __std_macros {\n+    #[macro_escape];\n+\n     macro_rules! ignore (($($x:tt)*) => (()))\n \n     macro_rules! error (\n@@ -484,7 +485,9 @@ pub fn core_macros() -> @str {\n         )\n     )\n \n-    macro_rules! debug (\n+    // conditionally define debug!, but keep it type checking even\n+    // in non-debug builds.\n+    macro_rules! __debug (\n         ($arg:expr) => (\n             __log(4u32, fmt!( \\\"%?\\\", $arg ))\n         );\n@@ -493,6 +496,22 @@ pub fn core_macros() -> @str {\n         )\n     )\n \n+    #[cfg(debug)]\n+    #[macro_escape]\n+    mod debug_macro {\n+        macro_rules! debug (($($arg:expr),*) => {\n+            __debug!($($arg),*)\n+        })\n+    }\n+\n+    #[cfg(not(debug))]\n+    #[macro_escape]\n+    mod debug_macro {\n+        macro_rules! debug (($($arg:expr),*) => {\n+            if false { __debug!($($arg),*) }\n+        })\n+    }\n+\n     macro_rules! fail(\n         () => (\n             fail!(\\\"explicit failure\\\")\n@@ -668,6 +687,35 @@ pub fn core_macros() -> @str {\n }\";\n }\n \n+// add a bunch of macros as though they were placed at the head of the\n+// program (ick). This should run before cfg stripping.\n+pub fn inject_std_macros(parse_sess: @mut parse::ParseSess,\n+                         cfg: ast::crate_cfg, c: &crate) -> @crate {\n+    let sm = match parse_item_from_source_str(@\"<std-macros>\",\n+                                              std_macros(),\n+                                              copy cfg,\n+                                              ~[],\n+                                              parse_sess) {\n+        Some(item) => item,\n+        None => fail!(\"expected core macros to parse correctly\")\n+    };\n+\n+    let injecter = @AstFoldFns {\n+        fold_mod: |modd, _| {\n+            // just inject the std macros at the start of the first\n+            // module in the crate (i.e the crate file itself.)\n+            let items = vec::append(~[sm], modd.items);\n+            ast::_mod {\n+                items: items,\n+                // FIXME #2543: Bad copy.\n+                .. copy *modd\n+            }\n+        },\n+        .. *default_ast_fold()\n+    };\n+    @make_fold(injecter).fold_crate(c)\n+}\n+\n pub fn expand_crate(parse_sess: @mut parse::ParseSess,\n                     cfg: ast::crate_cfg, c: &crate) -> @crate {\n     // adding *another* layer of indirection here so that the block\n@@ -692,33 +740,6 @@ pub fn expand_crate(parse_sess: @mut parse::ParseSess,\n         new_span: |a| new_span(cx, a),\n         .. *afp};\n     let f = make_fold(f_pre);\n-    // add a bunch of macros as though they were placed at the\n-    // head of the program (ick).\n-    let attrs = ~[\n-        spanned {\n-            span: codemap::dummy_sp(),\n-            node: attribute_ {\n-                style: attr_outer,\n-                value: @spanned {\n-                    node: meta_word(@\"macro_escape\"),\n-                    span: codemap::dummy_sp(),\n-                },\n-                is_sugared_doc: false,\n-            }\n-        }\n-    ];\n-\n-    let cm = match parse_item_from_source_str(@\"<core-macros>\",\n-                                              core_macros(),\n-                                              copy cfg,\n-                                              attrs,\n-                                              parse_sess) {\n-        Some(item) => item,\n-        None => cx.bug(\"expected core macros to parse correctly\")\n-    };\n-    // This is run for its side-effects on the expander env,\n-    // as it registers all the core macros as expanders.\n-    f.fold_item(cm);\n \n     @f.fold_crate(c)\n }\n@@ -789,6 +810,8 @@ mod test {\n             @\"<test>\",\n             src,\n             ~[],sess);\n+        let crate_ast = inject_std_macros(sess, ~[], crate_ast);\n+        // don't bother with striping, doesn't affect fail!.\n         expand_crate(sess,~[],crate_ast);\n     }\n \n@@ -836,20 +859,14 @@ mod test {\n         expand_crate(sess,~[],crate_ast);\n     }\n \n-    #[test] fn core_macros_must_parse () {\n-        let src = @\"\n-  pub mod macros {\n-    macro_rules! ignore (($($x:tt)*) => (()))\n-\n-    macro_rules! error ( ($( $arg:expr ),+) => (\n-        log(::core::error, fmt!( $($arg),+ )) ))\n-}\";\n+    #[test] fn std_macros_must_parse () {\n+        let src = super::std_macros();\n         let sess = parse::new_parse_sess(None);\n         let cfg = ~[];\n         let item_ast = parse::parse_item_from_source_str(\n             @\"<test>\",\n             src,\n-            cfg,~[make_dummy_attr (@\"macro_escape\")],sess);\n+            cfg,~[],sess);\n         match item_ast {\n             Some(_) => (), // success\n             None => fail!(\"expected this to parse\")"}, {"sha": "f40c8112e0bba29dd449d4d3452ff59431370e40", "filename": "src/test/run-pass/conditional-debug-macro-off.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b48e37e8eecafe3cfc72062a9369aae245063e19/src%2Ftest%2Frun-pass%2Fconditional-debug-macro-off.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b48e37e8eecafe3cfc72062a9369aae245063e19/src%2Ftest%2Frun-pass%2Fconditional-debug-macro-off.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconditional-debug-macro-off.rs?ref=b48e37e8eecafe3cfc72062a9369aae245063e19", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-fast exec-env directive doesn't work for check-fast\n+// exec-env:RUST_LOG=conditional-debug-macro-off=4\n+\n+fn main() {\n+    // only fails if debug! evaluates its argument.\n+    debug!({ if true { fail!() } });\n+}\n\\ No newline at end of file"}, {"sha": "65b751a58264d372147679b13dee56e48586e455", "filename": "src/test/run-pass/conditional-debug-macro-on.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b48e37e8eecafe3cfc72062a9369aae245063e19/src%2Ftest%2Frun-pass%2Fconditional-debug-macro-on.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b48e37e8eecafe3cfc72062a9369aae245063e19/src%2Ftest%2Frun-pass%2Fconditional-debug-macro-on.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconditional-debug-macro-on.rs?ref=b48e37e8eecafe3cfc72062a9369aae245063e19", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-fast compile-flags directive doesn't work for check-fast\n+// compile-flags: --cfg debug\n+// exec-env:RUST_LOG=conditional-debug-macro-on=4\n+\n+fn main() {\n+    // exits early if debug! evaluates its arguments, otherwise it\n+    // will hit the fail.\n+    debug!({ if true { return; } });\n+\n+    fail!();\n+}\n\\ No newline at end of file"}]}