{"sha": "f15182fffc98c3dc73c04cb3bd1f50e096230f59", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxNTE4MmZmZmM5OGMzZGM3M2MwNGNiM2JkMWY1MGUwOTYyMzBmNTk=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-01-19T21:00:30Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-01-19T21:37:01Z"}, "message": "Use fn~ to simplify the core::test interface", "tree": {"sha": "af95f20c67a63da39a59a852f583db99a283881b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/af95f20c67a63da39a59a852f583db99a283881b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f15182fffc98c3dc73c04cb3bd1f50e096230f59", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f15182fffc98c3dc73c04cb3bd1f50e096230f59", "html_url": "https://github.com/rust-lang/rust/commit/f15182fffc98c3dc73c04cb3bd1f50e096230f59", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f15182fffc98c3dc73c04cb3bd1f50e096230f59/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c2dba1799f85e062ddc6c9dc4302ce500db07ac6", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2dba1799f85e062ddc6c9dc4302ce500db07ac6", "html_url": "https://github.com/rust-lang/rust/commit/c2dba1799f85e062ddc6c9dc4302ce500db07ac6"}], "stats": {"total": 177, "additions": 63, "deletions": 114}, "files": [{"sha": "1e0c9c22bba94500e93077d20e742be0feac8299", "filename": "src/comp/front/test.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f15182fffc98c3dc73c04cb3bd1f50e096230f59/src%2Fcomp%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f15182fffc98c3dc73c04cb3bd1f50e096230f59/src%2Fcomp%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Ftest.rs?ref=f15182fffc98c3dc73c04cb3bd1f50e096230f59", "patch": "@@ -249,19 +249,10 @@ fn mk_path(cx: test_ctxt, path: [ast::ident]) -> [ast::ident] {\n \n // The ast::ty of [std::test::test_desc]\n fn mk_test_desc_vec_ty(cx: test_ctxt) -> @ast::ty {\n-    let test_fn_ty: ast::ty = nospan(\n-        ast::ty_path(\n-            @nospan({\n-                global: false,\n-                idents: mk_path(cx, [\"test\", \"default_test_fn\"]),\n-                types: []\n-            }),\n-            cx.sess.next_node_id()));\n-\n     let test_desc_ty_path =\n         @nospan({global: false,\n                  idents: mk_path(cx, [\"test\", \"test_desc\"]),\n-                 types: [@test_fn_ty]});\n+                 types: []});\n \n     let test_desc_ty: ast::ty =\n         nospan(ast::ty_path(test_desc_ty_path, cx.sess.next_node_id()));"}, {"sha": "ccbafa0f1591af79f512f5263299c9dc21194ac1", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 17, "deletions": 32, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/f15182fffc98c3dc73c04cb3bd1f50e096230f59/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f15182fffc98c3dc73c04cb3bd1f50e096230f59/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=f15182fffc98c3dc73c04cb3bd1f50e096230f59", "patch": "@@ -115,7 +115,7 @@ fn run_tests(config: config) {\n     let opts = test_opts(config);\n     let cx = {config: config, procsrv: procsrv::mk()};\n     let tests = make_tests(cx);\n-    let res = test::run_tests_console_(opts, tests.tests, tests.to_task);\n+    let res = test::run_tests_console(opts, tests);\n     procsrv::close(cx.procsrv);\n     if !res { fail \"Some tests failed\"; }\n }\n@@ -129,23 +129,17 @@ fn test_opts(config: config) -> test::test_opts {\n      run_ignored: config.run_ignored}\n }\n \n-type tests_and_conv_fn = {\n-    tests: [test::test_desc<fn@()>],\n-    to_task: fn@(fn@()) -> test::joinable\n-};\n-\n-fn make_tests(cx: cx) -> tests_and_conv_fn {\n+fn make_tests(cx: cx) -> [test::test_desc] {\n     #debug(\"making tests from %s\", cx.config.src_base);\n-    let configport = port::<[u8]>();\n     let tests = [];\n     for file: str in fs::list_dir(cx.config.src_base) {\n         let file = file;\n         #debug(\"inspecting file %s\", file);\n         if is_test(cx.config, file) {\n-            tests += [make_test(cx, file, configport)];\n+            tests += [make_test(cx, file)]\n         }\n     }\n-    ret {tests: tests, to_task: bind closure_to_task(cx, configport, _)};\n+    ret tests;\n }\n \n fn is_test(config: config, testfile: str) -> bool {\n@@ -168,40 +162,31 @@ fn is_test(config: config, testfile: str) -> bool {\n     ret valid;\n }\n \n-fn make_test(cx: cx, testfile: str, configport: port<[u8]>) ->\n-   test::test_desc<fn@()> {\n-    {name: make_test_name(cx.config, testfile),\n-     fn: make_test_closure(testfile, chan(configport)),\n-     ignore: header::is_test_ignored(cx.config, testfile),\n-     should_fail: false}\n+fn make_test(cx: cx, testfile: str) ->\n+   test::test_desc {\n+    {\n+        name: make_test_name(cx.config, testfile),\n+        fn: make_test_closure(cx, testfile),\n+        ignore: header::is_test_ignored(cx.config, testfile),\n+        should_fail: false\n+    }\n }\n \n fn make_test_name(config: config, testfile: str) -> str {\n     #fmt[\"[%s] %s\", mode_str(config.mode), testfile]\n }\n \n-fn make_test_closure(testfile: str,\n-                     configchan: chan<[u8]>) -> test::test_fn<fn@()> {\n-    bind send_config(testfile, configchan)\n-}\n-\n-fn send_config(testfile: str, configchan: chan<[u8]>) {\n-    send(configchan, str::bytes(testfile));\n-}\n-\n-fn closure_to_task(cx: cx, configport: port<[u8]>, testfn: fn@()) ->\n-   test::joinable {\n-    testfn();\n-    let testfile = recv(configport);\n-    let (config, chan) = (cx.config, cx.procsrv.chan);\n-    ret task::spawn_joinable {||\n+fn make_test_closure(cx: cx, testfile: str) -> test::test_fn {\n+    let config = cx.config;\n+    let chan = cx.procsrv.chan;\n+    ret {||\n         run_test_task(config, chan, testfile);\n     };\n }\n \n fn run_test_task(config: common::config,\n                  procsrv_chan: procsrv::reqchan,\n-                 testfile: [u8]) {\n+                 testfile: str) {\n     test::configure_test_task();\n \n     let procsrv = procsrv::from_chan(procsrv_chan);"}, {"sha": "2d0f16870f4e241954465dce9dd2ebc473fa99d7", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f15182fffc98c3dc73c04cb3bd1f50e096230f59/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f15182fffc98c3dc73c04cb3bd1f50e096230f59/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=f15182fffc98c3dc73c04cb3bd1f50e096230f59", "patch": "@@ -15,8 +15,7 @@ import util::logv;\n \n export run;\n \n-fn run(cx: cx, -_testfile: [u8]) {\n-    let testfile = str::unsafe_from_bytes(_testfile);\n+fn run(cx: cx, testfile: str) {\n     if cx.config.verbose {\n         // We're going to be dumping a lot of info. Start on a new line.\n         io::stdout().write_str(\"\\n\\n\");"}, {"sha": "eb86b882718d8633aa97ea89643ebf1f0273b2ba", "filename": "src/libstd/test.rs", "status": "modified", "additions": 44, "deletions": 70, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/f15182fffc98c3dc73c04cb3bd1f50e096230f59/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f15182fffc98c3dc73c04cb3bd1f50e096230f59/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=f15182fffc98c3dc73c04cb3bd1f50e096230f59", "patch": "@@ -9,7 +9,6 @@ import core::ctypes;\n \n export test_name;\n export test_fn;\n-export default_test_fn;\n export test_desc;\n export test_main;\n export test_result;\n@@ -18,14 +17,7 @@ export tr_ok;\n export tr_failed;\n export tr_ignored;\n export run_tests_console;\n-export run_tests_console_;\n-export run_test;\n-export filter_tests;\n-export parse_opts;\n-export test_to_task;\n-export default_test_to_task;\n export configure_test_task;\n-export joinable;\n \n #[abi = \"cdecl\"]\n native mod rustrt {\n@@ -42,22 +34,20 @@ type test_name = str;\n // the test succeeds; if the function fails then the test fails. We\n // may need to come up with a more clever definition of test in order\n // to support isolation of tests into tasks.\n-type test_fn<T> = T;\n-\n-type default_test_fn = test_fn<fn~()>;\n+type test_fn = fn~();\n \n // The definition of a single test. A test runner will run a list of\n // these.\n-type test_desc<T> = {\n+type test_desc = {\n     name: test_name,\n-    fn: test_fn<T>,\n+    fn: test_fn,\n     ignore: bool,\n     should_fail: bool\n };\n \n // The default console test runner. It accepts the command line\n // arguments and a vector of test_descs (generated at compile time).\n-fn test_main(args: [str], tests: [test_desc<default_test_fn>]) {\n+fn test_main(args: [str], tests: [test_desc]) {\n     check (vec::is_not_empty(args));\n     let opts =\n         alt parse_opts(args) {\n@@ -96,22 +86,9 @@ fn parse_opts(args: [str]) : vec::is_not_empty(args) -> opt_res {\n \n tag test_result { tr_ok; tr_failed; tr_ignored; }\n \n-type joinable = (task::task, comm::port<task::task_notification>);\n-\n-// To get isolation and concurrency tests have to be run in their own tasks.\n-// In cases where test functions are closures it is not ok to just dump them\n-// into a task and run them, so this transformation gives the caller a chance\n-// to create the test task.\n-type test_to_task<T> = fn@(test_fn<T>) -> joinable;\n-\n // A simple console test runner\n fn run_tests_console(opts: test_opts,\n-                         tests: [test_desc<default_test_fn>]) -> bool {\n-    run_tests_console_(opts, tests, default_test_to_task)\n-}\n-\n-fn run_tests_console_<T: copy>(opts: test_opts, tests: [test_desc<T>],\n-                              to_task: test_to_task<T>) -> bool {\n+                     tests: [test_desc]) -> bool {\n \n     type test_state =\n         @{out: io::writer,\n@@ -120,9 +97,9 @@ fn run_tests_console_<T: copy>(opts: test_opts, tests: [test_desc<T>],\n           mutable passed: uint,\n           mutable failed: uint,\n           mutable ignored: uint,\n-          mutable failures: [test_desc<T>]};\n+          mutable failures: [test_desc]};\n \n-    fn callback<T: copy>(event: testevent<T>, st: test_state) {\n+    fn callback(event: testevent, st: test_state) {\n         alt event {\n           te_filtered(filtered_tests) {\n             st.total = vec::len(filtered_tests);\n@@ -161,14 +138,14 @@ fn run_tests_console_<T: copy>(opts: test_opts, tests: [test_desc<T>],\n           mutable ignored: 0u,\n           mutable failures: []};\n \n-    run_tests(opts, tests, to_task, bind callback(_, st));\n+    run_tests(opts, tests, bind callback(_, st));\n \n     assert (st.passed + st.failed + st.ignored == st.total);\n     let success = st.failed == 0u;\n \n     if !success {\n         st.out.write_line(\"\\nfailures:\");\n-        for test: test_desc<T> in st.failures {\n+        for test: test_desc in st.failures {\n             let testname = test.name; // Satisfy alias analysis\n             st.out.write_line(#fmt[\"    %s\", testname]);\n         }\n@@ -209,22 +186,20 @@ fn run_tests_console_<T: copy>(opts: test_opts, tests: [test_desc<T>],\n \n fn use_color() -> bool { ret get_concurrency() == 1u; }\n \n-tag testevent<T> {\n-    te_filtered([test_desc<T>]);\n-    te_wait(test_desc<T>);\n-    te_result(test_desc<T>, test_result);\n+tag testevent {\n+    te_filtered([test_desc]);\n+    te_wait(test_desc);\n+    te_result(test_desc, test_result);\n }\n \n-fn run_tests<T: copy>(opts: test_opts, tests: [test_desc<T>],\n-                     to_task: test_to_task<T>,\n-                     callback: fn@(testevent<T>)) {\n+fn run_tests(opts: test_opts, tests: [test_desc],\n+             callback: fn@(testevent)) {\n \n     let filtered_tests = filter_tests(opts, tests);\n     callback(te_filtered(filtered_tests));\n \n-    // It's tempting to just spawn all the tests at once but that doesn't\n-    // provide a great user experience because you might sit waiting for the\n-    // result of a particular test for an unusually long amount of time.\n+    // It's tempting to just spawn all the tests at once, but since we have many\n+    // tests that run in other processes we would be making a big mess.\n     let concurrency = get_concurrency();\n     #debug(\"using %u test tasks\", concurrency);\n     let total = vec::len(filtered_tests);\n@@ -234,7 +209,7 @@ fn run_tests<T: copy>(opts: test_opts, tests: [test_desc<T>],\n \n     while wait_idx < total {\n         while vec::len(futures) < concurrency && run_idx < total {\n-            futures += [run_test(filtered_tests[run_idx], to_task)];\n+            futures += [run_test(filtered_tests[run_idx])];\n             run_idx += 1u;\n         }\n \n@@ -249,8 +224,8 @@ fn run_tests<T: copy>(opts: test_opts, tests: [test_desc<T>],\n \n fn get_concurrency() -> uint { rustrt::sched_threads() }\n \n-fn filter_tests<T: copy>(opts: test_opts,\n-                        tests: [test_desc<T>]) -> [test_desc<T>] {\n+fn filter_tests(opts: test_opts,\n+                tests: [test_desc]) -> [test_desc] {\n     let filtered = tests;\n \n     // Remove tests that don't match the test filter\n@@ -263,8 +238,8 @@ fn filter_tests<T: copy>(opts: test_opts,\n           option::none { \"\" }\n         };\n \n-        fn filter_fn<T: copy>(test: test_desc<T>, filter_str: str) ->\n-            option::t<test_desc<T>> {\n+        fn filter_fn(test: test_desc, filter_str: str) ->\n+            option::t<test_desc> {\n             if str::find(test.name, filter_str) >= 0 {\n                 ret option::some(test);\n             } else { ret option::none; }\n@@ -279,7 +254,7 @@ fn filter_tests<T: copy>(opts: test_opts,\n     filtered = if !opts.run_ignored {\n         filtered\n     } else {\n-        fn filter<T: copy>(test: test_desc<T>) -> option::t<test_desc<T>> {\n+        fn filter(test: test_desc) -> option::t<test_desc> {\n             if test.ignore {\n                 ret option::some({name: test.name,\n                                   fn: test.fn,\n@@ -294,7 +269,7 @@ fn filter_tests<T: copy>(opts: test_opts,\n     // Sort the tests alphabetically\n     filtered =\n         {\n-            fn lteq<T>(t1: test_desc<T>, t2: test_desc<T>) -> bool {\n+            fn lteq(t1: test_desc, t2: test_desc) -> bool {\n                 str::lteq(t1.name, t2.name)\n             }\n             sort::merge_sort(bind lteq(_, _), filtered)\n@@ -303,15 +278,14 @@ fn filter_tests<T: copy>(opts: test_opts,\n     ret filtered;\n }\n \n-type test_future<T> = {test: test_desc<T>, wait: fn@() -> test_result};\n+type test_future = {test: test_desc, wait: fn@() -> test_result};\n \n-fn run_test<T: copy>(test: test_desc<T>,\n-                    to_task: test_to_task<T>) -> test_future<T> {\n+fn run_test(test: test_desc) -> test_future {\n     if test.ignore {\n         ret {test: test, wait: fn@() -> test_result { tr_ignored }};\n     }\n \n-    let test_task = to_task(test.fn);\n+    let test_task = test_to_task(test.fn);\n     ret {test: test,\n          wait: fn@() -> test_result {\n              alt task::join(test_task) {\n@@ -330,7 +304,7 @@ fn run_test<T: copy>(test: test_desc<T>,\n \n // We need to run our tests in another task in order to trap test failures.\n // This function only works with functions that don't contain closures.\n-fn default_test_to_task(&&f: default_test_fn) -> joinable {\n+fn test_to_task(&&f: test_fn) -> task::joinable_task {\n     ret task::spawn_joinable(fn~[copy f]() {\n         configure_test_task();\n         f();\n@@ -356,9 +330,9 @@ mod tests {\n             ignore: true,\n             should_fail: false\n         };\n-        let future = test::run_test(desc, test::default_test_to_task);\n+        let future = run_test(desc);\n         let result = future.wait();\n-        assert result != test::tr_ok;\n+        assert result != tr_ok;\n     }\n \n     #[test]\n@@ -370,8 +344,8 @@ mod tests {\n             ignore: true,\n             should_fail: false\n         };\n-        let res = test::run_test(desc, test::default_test_to_task).wait();\n-        assert (res == test::tr_ignored);\n+        let res = run_test(desc).wait();\n+        assert (res == tr_ignored);\n     }\n \n     #[test]\n@@ -384,8 +358,8 @@ mod tests {\n             ignore: false,\n             should_fail: true\n         };\n-        let res = test::run_test(desc, test::default_test_to_task).wait();\n-        assert res == test::tr_ok;\n+        let res = run_test(desc).wait();\n+        assert res == tr_ok;\n     }\n \n     #[test]\n@@ -397,23 +371,23 @@ mod tests {\n             ignore: false,\n             should_fail: true\n         };\n-        let res = test::run_test(desc, test::default_test_to_task).wait();\n-        assert res == test::tr_failed;\n+        let res = run_test(desc).wait();\n+        assert res == tr_failed;\n     }\n \n     #[test]\n     fn first_free_arg_should_be_a_filter() {\n         let args = [\"progname\", \"filter\"];\n         check (vec::is_not_empty(args));\n-        let opts = alt test::parse_opts(args) { either::left(o) { o } };\n+        let opts = alt parse_opts(args) { either::left(o) { o } };\n         assert (str::eq(\"filter\", option::get(opts.filter)));\n     }\n \n     #[test]\n     fn parse_ignored_flag() {\n         let args = [\"progname\", \"filter\", \"--ignored\"];\n         check (vec::is_not_empty(args));\n-        let opts = alt test::parse_opts(args) { either::left(o) { o } };\n+        let opts = alt parse_opts(args) { either::left(o) { o } };\n         assert (opts.run_ignored);\n     }\n \n@@ -424,9 +398,9 @@ mod tests {\n \n         let opts = {filter: option::none, run_ignored: true};\n         let tests =\n-            [{name: \"1\", fn: fn@() { }, ignore: true, should_fail: false},\n-             {name: \"2\", fn: fn@() { }, ignore: false, should_fail: false}];\n-        let filtered = test::filter_tests(opts, tests);\n+            [{name: \"1\", fn: fn~() { }, ignore: true, should_fail: false},\n+             {name: \"2\", fn: fn~() { }, ignore: false, should_fail: false}];\n+        let filtered = filter_tests(opts, tests);\n \n         assert (vec::len(filtered) == 1u);\n         assert (filtered[0].name == \"1\");\n@@ -446,7 +420,7 @@ mod tests {\n              \"test::sort_tests\"];\n         let tests =\n         {\n-        let testfn = fn@() { };\n+        let testfn = fn~() { };\n         let tests = [];\n         for name: str in names {\n             let test = {name: name, fn: testfn, ignore: false,\n@@ -455,7 +429,7 @@ mod tests {\n         }\n         tests\n     };\n-    let filtered = test::filter_tests(opts, tests);\n+    let filtered = filter_tests(opts, tests);\n \n     let expected =\n         [\"int::test_pow\", \"int::test_to_str\", \"sha1::test\",\n@@ -469,7 +443,7 @@ mod tests {\n \n \n     for (a, b) in pairs { assert (a == b.name); }\n-}\n+    }\n }\n \n "}]}