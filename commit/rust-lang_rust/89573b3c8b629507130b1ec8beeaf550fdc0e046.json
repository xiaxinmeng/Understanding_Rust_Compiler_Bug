{"sha": "89573b3c8b629507130b1ec8beeaf550fdc0e046", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5NTczYjNjOGI2Mjk1MDcxMzBiMWVjOGJlZWFmNTUwZmRjMGUwNDY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-21T14:28:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-21T14:28:18Z"}, "message": "Auto merge of #58422 - LukasKalbertodt:seek-convenience, r=alexcrichton\n\nAdd provided methods `Seek::{stream_len, stream_position}`\n\nThis adds two new, provided methods to the `io::Seek` trait:\n- `fn stream_len(&mut self) -> Result<u64>`\n- `fn stream_position(&mut self) -> Result<u64>`\n\nBoth are added for convenience and to improve readability in user code. Reading `file.stream_len()` is much better than to manually seek two or three times. Similarly, `file.stream_position()` is much more clear than `file.seek(SeekFrom::Current(0))`.\n\nYou can find prior discussions [in this internals thread](https://internals.rust-lang.org/t/pre-rfc-idea-extend-io-seek-with-convenience-methods-with-e-g-stream-len/9262). I think I addressed all concerns in that thread.\n\nI already wrote three RFCs to add a small new API to libstd but I noticed that many public changes to libstd happen without an RFC. So I figured I can try opening a PR directly without going through RFCs first. After all, we do have rfcbot here too. If you think this change is too big to merge without an RFC, I can still close this PR and write an RFC.", "tree": {"sha": "1ba57102396b918c7e59e7a73ddf69ddc1ae8856", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ba57102396b918c7e59e7a73ddf69ddc1ae8856"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/89573b3c8b629507130b1ec8beeaf550fdc0e046", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/89573b3c8b629507130b1ec8beeaf550fdc0e046", "html_url": "https://github.com/rust-lang/rust/commit/89573b3c8b629507130b1ec8beeaf550fdc0e046", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/89573b3c8b629507130b1ec8beeaf550fdc0e046/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "48e354d224ff38ccde3936479a7f514b6492e910", "url": "https://api.github.com/repos/rust-lang/rust/commits/48e354d224ff38ccde3936479a7f514b6492e910", "html_url": "https://github.com/rust-lang/rust/commit/48e354d224ff38ccde3936479a7f514b6492e910"}, {"sha": "f95219fa580a514b5ca6c1425335afadbe394b57", "url": "https://api.github.com/repos/rust-lang/rust/commits/f95219fa580a514b5ca6c1425335afadbe394b57", "html_url": "https://github.com/rust-lang/rust/commit/f95219fa580a514b5ca6c1425335afadbe394b57"}], "stats": {"total": 136, "additions": 134, "deletions": 2}, "files": [{"sha": "247d45c3ec91f6391522e04d1dad32bb7e772874", "filename": "src/libstd/io/cursor.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/89573b3c8b629507130b1ec8beeaf550fdc0e046/src%2Flibstd%2Fio%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89573b3c8b629507130b1ec8beeaf550fdc0e046/src%2Flibstd%2Fio%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcursor.rs?ref=89573b3c8b629507130b1ec8beeaf550fdc0e046", "patch": "@@ -212,6 +212,14 @@ impl<T> io::Seek for Cursor<T> where T: AsRef<[u8]> {\n                            \"invalid seek to a negative or overflowing position\"))\n         }\n     }\n+\n+    fn stream_len(&mut self) -> io::Result<u64> {\n+        Ok(self.inner.as_ref().len() as u64)\n+    }\n+\n+    fn stream_position(&mut self) -> io::Result<u64> {\n+        Ok(self.pos)\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "4c88fc889f31f277d47fc0d08ed143135be72bf4", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 126, "deletions": 2, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/89573b3c8b629507130b1ec8beeaf550fdc0e046/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89573b3c8b629507130b1ec8beeaf550fdc0e046/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=89573b3c8b629507130b1ec8beeaf550fdc0e046", "patch": "@@ -1345,6 +1345,85 @@ pub trait Seek {\n     /// [`SeekFrom::Start`]: enum.SeekFrom.html#variant.Start\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn seek(&mut self, pos: SeekFrom) -> Result<u64>;\n+\n+    /// Returns the length of this stream (in bytes).\n+    ///\n+    /// This method is implemented using up to three seek operations. If this\n+    /// method returns successfully, the seek position is unchanged (i.e. the\n+    /// position before calling this method is the same as afterwards).\n+    /// However, if this method returns an error, the seek position is\n+    /// unspecified.\n+    ///\n+    /// If you need to obtain the length of *many* streams and you don't care\n+    /// about the seek position afterwards, you can reduce the number of seek\n+    /// operations by simply calling `seek(SeekFrom::End(0))` and using its\n+    /// return value (it is also the stream length).\n+    ///\n+    /// Note that length of a stream can change over time (for example, when\n+    /// data is appended to a file). So calling this method multiple times does\n+    /// not necessarily return the same length each time.\n+    ///\n+    ///\n+    /// # Example\n+    ///\n+    /// ```no_run\n+    /// #![feature(seek_convenience)]\n+    /// use std::{\n+    ///     io::{self, Seek},\n+    ///     fs::File,\n+    /// };\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let mut f = File::open(\"foo.txt\")?;\n+    ///\n+    ///     let len = f.stream_len()?;\n+    ///     println!(\"The file is currently {} bytes long\", len);\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"seek_convenience\", issue = \"0\")]\n+    fn stream_len(&mut self) -> Result<u64> {\n+        let old_pos = self.stream_position()?;\n+        let len = self.seek(SeekFrom::End(0))?;\n+\n+        // Avoid seeking a third time when we were already at the end of the\n+        // stream. The branch is usually way cheaper than a seek operation.\n+        if old_pos != len {\n+            self.seek(SeekFrom::Start(old_pos))?;\n+        }\n+\n+        Ok(len)\n+    }\n+\n+    /// Returns the current seek position from the start of the stream.\n+    ///\n+    /// This is equivalent to `self.seek(SeekFrom::Current(0))`.\n+    ///\n+    ///\n+    /// # Example\n+    ///\n+    /// ```no_run\n+    /// #![feature(seek_convenience)]\n+    /// use std::{\n+    ///     io::{self, BufRead, BufReader, Seek},\n+    ///     fs::File,\n+    /// };\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let mut f = BufReader::new(File::open(\"foo.txt\")?);\n+    ///\n+    ///     let before = f.stream_position()?;\n+    ///     f.read_line(&mut String::new())?;\n+    ///     let after = f.stream_position()?;\n+    ///\n+    ///     println!(\"The first line was {} bytes long\", after - before);\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"seek_convenience\", issue = \"0\")]\n+    fn stream_position(&mut self) -> Result<u64> {\n+        self.seek(SeekFrom::Current(0))\n+    }\n }\n \n /// Enumeration of possible methods to seek within an I/O object.\n@@ -2173,8 +2252,7 @@ impl<B: BufRead> Iterator for Lines<B> {\n mod tests {\n     use crate::io::prelude::*;\n     use crate::io;\n-    use super::Cursor;\n-    use super::repeat;\n+    use super::{Cursor, SeekFrom, repeat};\n \n     #[test]\n     #[cfg_attr(target_os = \"emscripten\", ignore)]\n@@ -2396,4 +2474,50 @@ mod tests {\n             super::read_to_end(&mut lr, &mut vec)\n         });\n     }\n+\n+    #[test]\n+    fn seek_len() -> io::Result<()> {\n+        let mut c = Cursor::new(vec![0; 15]);\n+        assert_eq!(c.stream_len()?, 15);\n+\n+        c.seek(SeekFrom::End(0))?;\n+        let old_pos = c.stream_position()?;\n+        assert_eq!(c.stream_len()?, 15);\n+        assert_eq!(c.stream_position()?, old_pos);\n+\n+        c.seek(SeekFrom::Start(7))?;\n+        c.seek(SeekFrom::Current(2))?;\n+        let old_pos = c.stream_position()?;\n+        assert_eq!(c.stream_len()?, 15);\n+        assert_eq!(c.stream_position()?, old_pos);\n+\n+        Ok(())\n+    }\n+\n+    #[test]\n+    fn seek_position() -> io::Result<()> {\n+        // All `asserts` are duplicated here to make sure the method does not\n+        // change anything about the seek state.\n+        let mut c = Cursor::new(vec![0; 15]);\n+        assert_eq!(c.stream_position()?, 0);\n+        assert_eq!(c.stream_position()?, 0);\n+\n+        c.seek(SeekFrom::End(0))?;\n+        assert_eq!(c.stream_position()?, 15);\n+        assert_eq!(c.stream_position()?, 15);\n+\n+\n+        c.seek(SeekFrom::Start(7))?;\n+        c.seek(SeekFrom::Current(2))?;\n+        assert_eq!(c.stream_position()?, 9);\n+        assert_eq!(c.stream_position()?, 9);\n+\n+        c.seek(SeekFrom::End(-3))?;\n+        c.seek(SeekFrom::Current(1))?;\n+        c.seek(SeekFrom::Current(-5))?;\n+        assert_eq!(c.stream_position()?, 8);\n+        assert_eq!(c.stream_position()?, 8);\n+\n+        Ok(())\n+    }\n }"}]}