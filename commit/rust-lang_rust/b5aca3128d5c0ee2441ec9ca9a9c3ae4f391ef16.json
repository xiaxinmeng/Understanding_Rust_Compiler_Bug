{"sha": "b5aca3128d5c0ee2441ec9ca9a9c3ae4f391ef16", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1YWNhMzEyOGQ1YzBlZTI0NDFlYzljYTlhOWMzYWU0ZjM5MWVmMTY=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-02-05T03:45:13Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-02-05T09:48:01Z"}, "message": "typeck: refactor default binding mode logic & improve docs", "tree": {"sha": "132beb424ba387fe9d4675b36f8d7a5a94fed838", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/132beb424ba387fe9d4675b36f8d7a5a94fed838"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b5aca3128d5c0ee2441ec9ca9a9c3ae4f391ef16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b5aca3128d5c0ee2441ec9ca9a9c3ae4f391ef16", "html_url": "https://github.com/rust-lang/rust/commit/b5aca3128d5c0ee2441ec9ca9a9c3ae4f391ef16", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b5aca3128d5c0ee2441ec9ca9a9c3ae4f391ef16/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "17e632d382dfae46e9dfa684db9bddec3e8951a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/17e632d382dfae46e9dfa684db9bddec3e8951a7", "html_url": "https://github.com/rust-lang/rust/commit/17e632d382dfae46e9dfa684db9bddec3e8951a7"}], "stats": {"total": 113, "additions": 64, "deletions": 49}, "files": [{"sha": "81e10e7a54010f072b0efb0371b71edb11a7465a", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 64, "deletions": 49, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/b5aca3128d5c0ee2441ec9ca9a9c3ae4f391ef16/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5aca3128d5c0ee2441ec9ca9a9c3ae4f391ef16/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=b5aca3128d5c0ee2441ec9ca9a9c3ae4f391ef16", "patch": "@@ -89,6 +89,18 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n     }\n }\n \n+const INITIAL_BM: BindingMode = BindingMode::BindByValue(hir::Mutability::Not);\n+\n+/// Mode for adjusting the expected type and binding mode.\n+enum AdjustMode {\n+    /// Peel off all immediate reference types.\n+    Peel,\n+    /// Reset binding mode to the inital mode.\n+    Reset,\n+    /// Pass on the input binding mode and expected type.\n+    Pass,\n+}\n+\n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Type check the given top level pattern against the `expected` type.\n     ///\n@@ -105,8 +117,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         span: Option<Span>,\n         origin_expr: bool,\n     ) {\n-        let def_bm = BindingMode::BindByValue(hir::Mutability::Not);\n-        self.check_pat(pat, expected, def_bm, TopInfo { expected, origin_expr, span });\n+        self.check_pat(pat, expected, INITIAL_BM, TopInfo { expected, origin_expr, span });\n     }\n \n     /// Type check the given `pat` against the `expected` type\n@@ -123,12 +134,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) {\n         debug!(\"check_pat(pat={:?},expected={:?},def_bm={:?})\", pat, expected, def_bm);\n \n-        let path_resolution = match &pat.kind {\n+        let path_res = match &pat.kind {\n             PatKind::Path(qpath) => Some(self.resolve_ty_and_res_ufcs(qpath, pat.hir_id, pat.span)),\n             _ => None,\n         };\n-        let is_nrp = self.is_non_ref_pat(pat, path_resolution.map(|(res, ..)| res));\n-        let (expected, def_bm) = self.calc_default_binding_mode(pat, expected, def_bm, is_nrp);\n+        let adjust_mode = self.calc_adjust_mode(pat, path_res.map(|(res, ..)| res));\n+        let (expected, def_bm) = self.calc_default_binding_mode(pat, expected, def_bm, adjust_mode);\n \n         let ty = match pat.kind {\n             PatKind::Wild => expected,\n@@ -141,7 +152,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.check_pat_tuple_struct(pat, qpath, subpats, ddpos, expected, def_bm, ti)\n             }\n             PatKind::Path(ref qpath) => {\n-                self.check_pat_path(pat, path_resolution.unwrap(), qpath, expected)\n+                self.check_pat_path(pat, path_res.unwrap(), qpath, expected)\n             }\n             PatKind::Struct(ref qpath, fields, etc) => {\n                 self.check_pat_struct(pat, qpath, fields, etc, expected, def_bm, ti)\n@@ -223,64 +234,68 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         pat: &'tcx Pat<'tcx>,\n         expected: Ty<'tcx>,\n         def_bm: BindingMode,\n-        is_non_ref_pat: bool,\n+        adjust_mode: AdjustMode,\n     ) -> (Ty<'tcx>, BindingMode) {\n-        if is_non_ref_pat {\n-            debug!(\"pattern is non reference pattern\");\n-            self.peel_off_references(pat, expected, def_bm)\n-        } else {\n-            // When you encounter a `&pat` pattern, reset to \"by\n-            // value\". This is so that `x` and `y` here are by value,\n-            // as they appear to be:\n-            //\n-            // ```\n-            // match &(&22, &44) {\n-            //   (&x, &y) => ...\n-            // }\n-            // ```\n-            //\n-            // See issue #46688.\n-            let def_bm = match pat.kind {\n-                PatKind::Ref(..) => ty::BindByValue(hir::Mutability::Not),\n-                _ => def_bm,\n-            };\n-            (expected, def_bm)\n+        match adjust_mode {\n+            AdjustMode::Pass => (expected, def_bm),\n+            AdjustMode::Reset => (expected, INITIAL_BM),\n+            AdjustMode::Peel => self.peel_off_references(pat, expected, def_bm),\n         }\n     }\n \n-    /// Is the pattern a \"non reference pattern\"?\n+    /// How should the binding mode and expected type be adjusted?\n+    ///\n     /// When the pattern is a path pattern, `opt_path_res` must be `Some(res)`.\n-    fn is_non_ref_pat(&self, pat: &'tcx Pat<'tcx>, opt_path_res: Option<Res>) -> bool {\n-        match pat.kind {\n+    fn calc_adjust_mode(&self, pat: &'tcx Pat<'tcx>, opt_path_res: Option<Res>) -> AdjustMode {\n+        match &pat.kind {\n+            // Type checking these product-like types successfully always require\n+            // that the expected type be of those types and not reference types.\n             PatKind::Struct(..)\n             | PatKind::TupleStruct(..)\n             | PatKind::Tuple(..)\n             | PatKind::Box(_)\n             | PatKind::Range(..)\n-            | PatKind::Slice(..) => true,\n-            PatKind::Lit(ref lt) => {\n-                let ty = self.check_expr(lt);\n-                match ty.kind {\n-                    ty::Ref(..) => false,\n-                    _ => true,\n-                }\n-            }\n+            | PatKind::Slice(..) => AdjustMode::Peel,\n+            // String and byte-string literals result in types `&str` and `&[u8]` respectively.\n+            // All other literals result in non-reference types.\n+            // As a result, we allow `if let 0 = &&0 {}` but not `if let \"foo\" = &&\"foo {}`.\n+            PatKind::Lit(lt) => match self.check_expr(lt).kind {\n+                ty::Ref(..) => AdjustMode::Pass,\n+                _ => AdjustMode::Peel,\n+            },\n             PatKind::Path(_) => match opt_path_res.unwrap() {\n-                Res::Def(DefKind::Const, _) | Res::Def(DefKind::AssocConst, _) => false,\n-                _ => true,\n+                // These constants can be of a reference type, e.g. `const X: &u8 = &0;`.\n+                // Peeling the reference types too early will cause type checking failures.\n+                // Although it would be possible to *also* peel the types of the constants too.\n+                Res::Def(DefKind::Const, _) | Res::Def(DefKind::AssocConst, _) => AdjustMode::Pass,\n+                // In the `ValueNS`, we have `SelfCtor(..) | Ctor(_, Const), _)` remaining which\n+                // could successfully compile. The former being `Self` requires a unit struct.\n+                // In either case, and unlike constants, the pattern itself cannot be\n+                // a reference type wherefore peeling doesn't give up any expressivity.\n+                _ => AdjustMode::Peel,\n             },\n-            // FIXME(or_patterns; Centril | dlrobertson): To keep things compiling\n-            // for or-patterns at the top level, we need to make `p_0 | ... | p_n`\n-            // a \"non reference pattern\". For example the following currently compiles:\n+            // When encountering a `& mut? pat` pattern, reset to \"by value\".\n+            // This is so that `x` and `y` here are by value, as they appear to be:\n+            //\n             // ```\n-            // match &1 {\n-            //     e @ &(1...2) | e @ &(3...4) => {}\n-            //     _ => {}\n+            // match &(&22, &44) {\n+            //   (&x, &y) => ...\n             // }\n             // ```\n             //\n-            // We should consider whether we should do something special in nested or-patterns.\n-            PatKind::Or(_) | PatKind::Wild | PatKind::Binding(..) | PatKind::Ref(..) => false,\n+            // See issue #46688.\n+            PatKind::Ref(..) => AdjustMode::Reset,\n+            // A `_` pattern works with any expected type, so there's no need to do anything.\n+            PatKind::Wild\n+            // Bindings also work with whatever the expected type is,\n+            // and moreover if we peel references off, that will give us the wrong binding type.\n+            // Also, we can have a subpattern `binding @ pat`.\n+            // Each side of the `@` should be treated independently (like with OR-patterns).\n+            | PatKind::Binding(..)\n+            // An OR-pattern just propagates to each individual alternative.\n+            // This is maximally flexible, allowing e.g., `Some(mut x) | &Some(mut x)`.\n+            // In that example, `Some(mut x)` results in `Peel` whereas `&Some(mut x)` in `Reset`.\n+            | PatKind::Or(_) => AdjustMode::Pass,\n         }\n     }\n \n@@ -508,7 +523,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let local_ty = self.local_ty(pat.span, pat.hir_id).decl_ty;\n         let eq_ty = match bm {\n             ty::BindByReference(mutbl) => {\n-                // If the binding is like `ref x | ref const x | ref mut x`\n+                // If the binding is like `ref x | ref mut x`,\n                 // then `x` is assigned a value of type `&M T` where M is the\n                 // mutability and T is the expected type.\n                 //"}]}