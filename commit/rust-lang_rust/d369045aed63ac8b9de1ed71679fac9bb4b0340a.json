{"sha": "d369045aed63ac8b9de1ed71679fac9bb4b0340a", "node_id": "C_kwDOAAsO6NoAKGQzNjkwNDVhZWQ2M2FjOGI5ZGUxZWQ3MTY3OWZhYzliYjRiMDM0MGE", "commit": {"author": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2022-05-13T17:12:32Z"}, "committer": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2022-05-13T18:42:10Z"}, "message": "Use a pointer in cell::Ref so it's not noalias", "tree": {"sha": "0ac7594cef5dac749dade19118043a2f69992d39", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0ac7594cef5dac749dade19118043a2f69992d39"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d369045aed63ac8b9de1ed71679fac9bb4b0340a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d369045aed63ac8b9de1ed71679fac9bb4b0340a", "html_url": "https://github.com/rust-lang/rust/commit/d369045aed63ac8b9de1ed71679fac9bb4b0340a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d369045aed63ac8b9de1ed71679fac9bb4b0340a/comments", "author": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a7d6408b05912396618dfdcc9cc713d3ace2aa9a", "url": "https://api.github.com/repos/rust-lang/rust/commits/a7d6408b05912396618dfdcc9cc713d3ace2aa9a", "html_url": "https://github.com/rust-lang/rust/commit/a7d6408b05912396618dfdcc9cc713d3ace2aa9a"}], "stats": {"total": 28, "additions": 18, "deletions": 10}, "files": [{"sha": "04bbef4844b6a9909987eb738d5b1259b181e8a3", "filename": "library/core/src/cell.rs", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d369045aed63ac8b9de1ed71679fac9bb4b0340a/library%2Fcore%2Fsrc%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d369045aed63ac8b9de1ed71679fac9bb4b0340a/library%2Fcore%2Fsrc%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcell.rs?ref=d369045aed63ac8b9de1ed71679fac9bb4b0340a", "patch": "@@ -197,7 +197,7 @@ use crate::fmt::{self, Debug, Display};\n use crate::marker::Unsize;\n use crate::mem;\n use crate::ops::{CoerceUnsized, Deref, DerefMut};\n-use crate::ptr;\n+use crate::ptr::{self, NonNull};\n \n /// A mutable memory location.\n ///\n@@ -896,7 +896,8 @@ impl<T: ?Sized> RefCell<T> {\n \n                 // SAFETY: `BorrowRef` ensures that there is only immutable access\n                 // to the value while borrowed.\n-                Ok(Ref { value: unsafe { &*self.value.get() }, borrow: b })\n+                let value = unsafe { NonNull::new_unchecked(self.value.get()) };\n+                Ok(Ref { value, borrow: b })\n             }\n             None => Err(BorrowError {\n                 // If a borrow occurred, then we must already have an outstanding borrow,\n@@ -1314,7 +1315,9 @@ impl Clone for BorrowRef<'_> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[must_not_suspend = \"holding a Ref across suspend points can cause BorrowErrors\"]\n pub struct Ref<'b, T: ?Sized + 'b> {\n-    value: &'b T,\n+    // NB: we use a pointer instead of `&'b T` to avoid `noalias` violations, because a\n+    // `Ref` argument doesn't hold immutability for its whole scope, only until it drops.\n+    value: NonNull<T>,\n     borrow: BorrowRef<'b>,\n }\n \n@@ -1324,7 +1327,8 @@ impl<T: ?Sized> Deref for Ref<'_, T> {\n \n     #[inline]\n     fn deref(&self) -> &T {\n-        self.value\n+        // SAFETY: the value is accessible as long as we hold our borrow.\n+        unsafe { self.value.as_ref() }\n     }\n }\n \n@@ -1368,7 +1372,7 @@ impl<'b, T: ?Sized> Ref<'b, T> {\n     where\n         F: FnOnce(&T) -> &U,\n     {\n-        Ref { value: f(orig.value), borrow: orig.borrow }\n+        Ref { value: NonNull::from(f(&*orig)), borrow: orig.borrow }\n     }\n \n     /// Makes a new `Ref` for an optional component of the borrowed data. The\n@@ -1399,8 +1403,8 @@ impl<'b, T: ?Sized> Ref<'b, T> {\n     where\n         F: FnOnce(&T) -> Option<&U>,\n     {\n-        match f(orig.value) {\n-            Some(value) => Ok(Ref { value, borrow: orig.borrow }),\n+        match f(&*orig) {\n+            Some(value) => Ok(Ref { value: NonNull::from(value), borrow: orig.borrow }),\n             None => Err(orig),\n         }\n     }\n@@ -1431,9 +1435,12 @@ impl<'b, T: ?Sized> Ref<'b, T> {\n     where\n         F: FnOnce(&T) -> (&U, &V),\n     {\n-        let (a, b) = f(orig.value);\n+        let (a, b) = f(&*orig);\n         let borrow = orig.borrow.clone();\n-        (Ref { value: a, borrow }, Ref { value: b, borrow: orig.borrow })\n+        (\n+            Ref { value: NonNull::from(a), borrow },\n+            Ref { value: NonNull::from(b), borrow: orig.borrow },\n+        )\n     }\n \n     /// Convert into a reference to the underlying data.\n@@ -1467,7 +1474,8 @@ impl<'b, T: ?Sized> Ref<'b, T> {\n         // unique reference to the borrowed RefCell. No further mutable references can be created\n         // from the original cell.\n         mem::forget(orig.borrow);\n-        orig.value\n+        // SAFETY: after forgetting, we can form a reference for the rest of lifetime `'b`.\n+        unsafe { orig.value.as_ref() }\n     }\n }\n "}]}