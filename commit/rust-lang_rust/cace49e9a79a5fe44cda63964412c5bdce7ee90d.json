{"sha": "cace49e9a79a5fe44cda63964412c5bdce7ee90d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhY2U0OWU5YTc5YTVmZTQ0Y2RhNjM5NjQ0MTJjNWJkY2U3ZWU5MGQ=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-11-26T19:26:47Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-11-26T19:31:04Z"}, "message": "Decouple", "tree": {"sha": "6cb1c0b0ef3e24ad3a303c407f8335e4503cb619", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6cb1c0b0ef3e24ad3a303c407f8335e4503cb619"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cace49e9a79a5fe44cda63964412c5bdce7ee90d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cace49e9a79a5fe44cda63964412c5bdce7ee90d", "html_url": "https://github.com/rust-lang/rust/commit/cace49e9a79a5fe44cda63964412c5bdce7ee90d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cace49e9a79a5fe44cda63964412c5bdce7ee90d/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d770f22c53a88035e2836cc01533dab4223f80d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/d770f22c53a88035e2836cc01533dab4223f80d5", "html_url": "https://github.com/rust-lang/rust/commit/d770f22c53a88035e2836cc01533dab4223f80d5"}], "stats": {"total": 87, "additions": 42, "deletions": 45}, "files": [{"sha": "b4b47057de8ee536c9ec81cf407d66be484d2486", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cace49e9a79a5fe44cda63964412c5bdce7ee90d/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cace49e9a79a5fe44cda63964412c5bdce7ee90d/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=cace49e9a79a5fe44cda63964412c5bdce7ee90d", "patch": "@@ -945,7 +945,7 @@ impl ImplBlock {\n     }\n     pub fn for_trait(db: &impl HirDatabase, krate: Crate, trait_: Trait) -> Vec<ImplBlock> {\n         let impls = db.impls_in_crate(krate.crate_id);\n-        impls.lookup_impl_blocks_for_trait(trait_).map(Self::from).collect()\n+        impls.lookup_impl_blocks_for_trait(trait_.id).map(Self::from).collect()\n     }\n \n     pub fn target_trait(&self, db: &impl DefDatabase) -> Option<TypeRef> {"}, {"sha": "31b21ca840c8dbcc0d7ff4f6271da24bca961edd", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/cace49e9a79a5fe44cda63964412c5bdce7ee90d/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cace49e9a79a5fe44cda63964412c5bdce7ee90d/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=cace49e9a79a5fe44cda63964412c5bdce7ee90d", "patch": "@@ -2,6 +2,7 @@\n \n use std::sync::Arc;\n \n+use hir_def::{GenericDefId, LocalStructFieldId, TraitId, VariantId};\n use ra_arena::map::ArenaMap;\n use ra_db::{salsa, CrateId};\n \n@@ -12,19 +13,15 @@ use crate::{\n         CallableDef, FnSig, GenericPredicate, InferenceResult, Substs, Ty, TyDefId, TypeCtor,\n         ValueTyDefId,\n     },\n-    Crate, DefWithBody, ImplBlock, Trait,\n+    Crate, DefWithBody, ImplBlock,\n };\n \n-pub use hir_def::{\n-    db::{\n-        BodyQuery, BodyWithSourceMapQuery, ConstDataQuery, CrateDefMapQuery, CrateLangItemsQuery,\n-        DefDatabase, DefDatabaseStorage, DocumentationQuery, EnumDataQuery, ExprScopesQuery,\n-        FunctionDataQuery, GenericParamsQuery, ImplDataQuery, InternDatabase,\n-        InternDatabaseStorage, LangItemQuery, ModuleLangItemsQuery, RawItemsQuery,\n-        RawItemsWithSourceMapQuery, StaticDataQuery, StructDataQuery, TraitDataQuery,\n-        TypeAliasDataQuery,\n-    },\n-    GenericDefId, LocalStructFieldId, VariantId,\n+pub use hir_def::db::{\n+    BodyQuery, BodyWithSourceMapQuery, ConstDataQuery, CrateDefMapQuery, CrateLangItemsQuery,\n+    DefDatabase, DefDatabaseStorage, DocumentationQuery, EnumDataQuery, ExprScopesQuery,\n+    FunctionDataQuery, GenericParamsQuery, ImplDataQuery, InternDatabase, InternDatabaseStorage,\n+    LangItemQuery, ModuleLangItemsQuery, RawItemsQuery, RawItemsWithSourceMapQuery,\n+    StaticDataQuery, StructDataQuery, TraitDataQuery, TypeAliasDataQuery,\n };\n pub use hir_expand::db::{\n     AstDatabase, AstDatabaseStorage, AstIdMapQuery, MacroArgQuery, MacroDefQuery, MacroExpandQuery,\n@@ -66,7 +63,7 @@ pub trait HirDatabase: DefDatabase {\n     fn impls_in_crate(&self, krate: CrateId) -> Arc<CrateImplBlocks>;\n \n     #[salsa::invoke(crate::ty::traits::impls_for_trait_query)]\n-    fn impls_for_trait(&self, krate: Crate, trait_: Trait) -> Arc<[ImplBlock]>;\n+    fn impls_for_trait(&self, krate: CrateId, trait_: TraitId) -> Arc<[ImplBlock]>;\n \n     /// This provides the Chalk trait solver instance. Because Chalk always\n     /// works from a specific crate, this query is keyed on the crate; and"}, {"sha": "fdc87a28d08c0602801f8d808e3fd13f9840a859", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/cace49e9a79a5fe44cda63964412c5bdce7ee90d/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cace49e9a79a5fe44cda63964412c5bdce7ee90d/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=cace49e9a79a5fe44cda63964412c5bdce7ee90d", "patch": "@@ -6,9 +6,10 @@ use std::sync::Arc;\n \n use arrayvec::ArrayVec;\n use hir_def::{\n-    lang_item::LangItemTarget, resolver::HasResolver, resolver::Resolver, AssocItemId, AstItemDef,\n-    HasModule, ImplId, TraitId,\n+    lang_item::LangItemTarget, resolver::HasResolver, resolver::Resolver, type_ref::Mutability,\n+    AssocItemId, AstItemDef, HasModule, ImplId, TraitId,\n };\n+use hir_expand::name::Name;\n use ra_db::CrateId;\n use ra_prof::profile;\n use rustc_hash::FxHashMap;\n@@ -17,7 +18,7 @@ use crate::{\n     db::HirDatabase,\n     ty::primitive::{FloatBitness, Uncertain},\n     ty::{utils::all_super_traits, Ty, TypeCtor},\n-    AssocItem, Crate, Function, Mutability, Name, Trait,\n+    AssocItem, Function,\n };\n \n use super::{autoderef, Canonical, InEnvironment, TraitEnvironment, TraitRef};\n@@ -87,23 +88,27 @@ impl CrateImplBlocks {\n         fingerprint.and_then(|f| self.impls.get(&f)).into_iter().flatten().copied()\n     }\n \n-    pub fn lookup_impl_blocks_for_trait(&self, tr: Trait) -> impl Iterator<Item = ImplId> + '_ {\n-        self.impls_by_trait.get(&tr.id).into_iter().flatten().copied()\n+    pub fn lookup_impl_blocks_for_trait(&self, tr: TraitId) -> impl Iterator<Item = ImplId> + '_ {\n+        self.impls_by_trait.get(&tr).into_iter().flatten().copied()\n     }\n \n     pub fn all_impls<'a>(&'a self) -> impl Iterator<Item = ImplId> + 'a {\n         self.impls.values().chain(self.impls_by_trait.values()).flatten().copied()\n     }\n }\n \n-fn def_crates(db: &impl HirDatabase, cur_crate: Crate, ty: &Ty) -> Option<ArrayVec<[Crate; 2]>> {\n+fn def_crates(\n+    db: &impl HirDatabase,\n+    cur_crate: CrateId,\n+    ty: &Ty,\n+) -> Option<ArrayVec<[CrateId; 2]>> {\n     // Types like slice can have inherent impls in several crates, (core and alloc).\n     // The corresponding impls are marked with lang items, so we can use them to find the required crates.\n     macro_rules! lang_item_crate {\n         ($($name:expr),+ $(,)?) => {{\n             let mut v = ArrayVec::<[LangItemTarget; 2]>::new();\n             $(\n-                v.extend(db.lang_item(cur_crate.crate_id, $name.into()));\n+                v.extend(db.lang_item(cur_crate, $name.into()));\n             )+\n             v\n         }};\n@@ -112,7 +117,7 @@ fn def_crates(db: &impl HirDatabase, cur_crate: Crate, ty: &Ty) -> Option<ArrayV\n     let lang_item_targets = match ty {\n         Ty::Apply(a_ty) => match a_ty.ctor {\n             TypeCtor::Adt(def_id) => {\n-                return Some(std::iter::once(def_id.module(db).krate.into()).collect())\n+                return Some(std::iter::once(def_id.module(db).krate).collect())\n             }\n             TypeCtor::Bool => lang_item_crate!(\"bool\"),\n             TypeCtor::Char => lang_item_crate!(\"char\"),\n@@ -136,7 +141,7 @@ fn def_crates(db: &impl HirDatabase, cur_crate: Crate, ty: &Ty) -> Option<ArrayV\n             LangItemTarget::ImplBlockId(it) => Some(it),\n             _ => None,\n         })\n-        .map(|it| it.module(db).krate.into())\n+        .map(|it| it.module(db).krate)\n         .collect();\n     Some(res)\n }\n@@ -193,14 +198,9 @@ pub(crate) fn iterate_method_candidates<T>(\n             let environment = TraitEnvironment::lower(db, resolver);\n             let ty = InEnvironment { value: ty.clone(), environment };\n             for derefed_ty in autoderef::autoderef(db, resolver.krate(), ty) {\n-                if let Some(result) = iterate_inherent_methods(\n-                    &derefed_ty,\n-                    db,\n-                    name,\n-                    mode,\n-                    krate.into(),\n-                    &mut callback,\n-                ) {\n+                if let Some(result) =\n+                    iterate_inherent_methods(&derefed_ty, db, name, mode, krate, &mut callback)\n+                {\n                     return Some(result);\n                 }\n                 if let Some(result) = iterate_trait_method_candidates(\n@@ -283,11 +283,11 @@ fn iterate_inherent_methods<T>(\n     db: &impl HirDatabase,\n     name: Option<&Name>,\n     mode: LookupMode,\n-    krate: Crate,\n+    krate: CrateId,\n     mut callback: impl FnMut(&Ty, AssocItem) -> Option<T>,\n ) -> Option<T> {\n     for krate in def_crates(db, krate, &ty.value)? {\n-        let impls = db.impls_in_crate(krate.crate_id);\n+        let impls = db.impls_in_crate(krate);\n \n         for impl_block in impls.lookup_impl_blocks(&ty.value) {\n             for &item in db.impl_data(impl_block).items.iter() {\n@@ -327,7 +327,7 @@ pub(crate) fn implements_trait(\n     ty: &Canonical<Ty>,\n     db: &impl HirDatabase,\n     resolver: &Resolver,\n-    krate: Crate,\n+    krate: CrateId,\n     trait_: TraitId,\n ) -> bool {\n     if ty.value.inherent_trait() == Some(trait_) {\n@@ -337,7 +337,7 @@ pub(crate) fn implements_trait(\n     }\n     let env = TraitEnvironment::lower(db, resolver);\n     let goal = generic_implements_goal(db, env, trait_, ty.clone());\n-    let solution = db.trait_solve(krate, goal);\n+    let solution = db.trait_solve(krate.into(), goal);\n \n     solution.is_some()\n }\n@@ -348,11 +348,11 @@ impl Ty {\n     pub fn iterate_impl_items<T>(\n         self,\n         db: &impl HirDatabase,\n-        krate: Crate,\n+        krate: CrateId,\n         mut callback: impl FnMut(AssocItem) -> Option<T>,\n     ) -> Option<T> {\n         for krate in def_crates(db, krate, &self)? {\n-            let impls = db.impls_in_crate(krate.crate_id);\n+            let impls = db.impls_in_crate(krate);\n \n             for impl_block in impls.lookup_impl_blocks(&self) {\n                 for &item in db.impl_data(impl_block).items.iter() {"}, {"sha": "637e21e9c4348a5c27b4ffd698f96dc352aedb44", "filename": "crates/ra_hir/src/ty/traits.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cace49e9a79a5fe44cda63964412c5bdce7ee90d/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cace49e9a79a5fe44cda63964412c5bdce7ee90d/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs?ref=cace49e9a79a5fe44cda63964412c5bdce7ee90d", "patch": "@@ -2,13 +2,13 @@\n use std::sync::{Arc, Mutex};\n \n use chalk_ir::{cast::Cast, family::ChalkIr};\n-use hir_def::{expr::ExprId, DefWithBodyId};\n+use hir_def::{expr::ExprId, DefWithBodyId, TraitId};\n use log::debug;\n-use ra_db::{impl_intern_key, salsa};\n+use ra_db::{impl_intern_key, salsa, CrateId};\n use ra_prof::profile;\n use rustc_hash::FxHashSet;\n \n-use crate::{db::HirDatabase, Crate, ImplBlock, Trait, TypeAlias};\n+use crate::{db::HirDatabase, Crate, ImplBlock, TypeAlias};\n \n use super::{Canonical, GenericPredicate, HirDisplay, ProjectionTy, TraitRef, Ty, TypeWalk};\n \n@@ -77,19 +77,19 @@ pub(crate) fn trait_solver_query(\n /// Collects impls for the given trait in the whole dependency tree of `krate`.\n pub(crate) fn impls_for_trait_query(\n     db: &impl HirDatabase,\n-    krate: Crate,\n-    trait_: Trait,\n+    krate: CrateId,\n+    trait_: TraitId,\n ) -> Arc<[ImplBlock]> {\n     let mut impls = FxHashSet::default();\n     // We call the query recursively here. On the one hand, this means we can\n     // reuse results from queries for different crates; on the other hand, this\n     // will only ever get called for a few crates near the root of the tree (the\n     // ones the user is editing), so this may actually be a waste of memory. I'm\n     // doing it like this mainly for simplicity for now.\n-    for dep in krate.dependencies(db) {\n-        impls.extend(db.impls_for_trait(dep.krate, trait_).iter());\n+    for dep in db.crate_graph().dependencies(krate) {\n+        impls.extend(db.impls_for_trait(dep.crate_id, trait_).iter());\n     }\n-    let crate_impl_blocks = db.impls_in_crate(krate.crate_id);\n+    let crate_impl_blocks = db.impls_in_crate(krate);\n     impls.extend(crate_impl_blocks.lookup_impl_blocks_for_trait(trait_).map(ImplBlock::from));\n     impls.into_iter().collect()\n }"}, {"sha": "d879382a0e323f84c628f1da547a6c1ab930577b", "filename": "crates/ra_hir/src/ty/traits/chalk.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cace49e9a79a5fe44cda63964412c5bdce7ee90d/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cace49e9a79a5fe44cda63964412c5bdce7ee90d/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs?ref=cace49e9a79a5fe44cda63964412c5bdce7ee90d", "patch": "@@ -448,7 +448,7 @@ where\n         let trait_: TraitId = from_chalk(self.db, trait_id);\n         let mut result: Vec<_> = self\n             .db\n-            .impls_for_trait(self.krate, trait_.into())\n+            .impls_for_trait(self.krate.crate_id, trait_.into())\n             .iter()\n             .copied()\n             .map(Impl::ImplBlock)"}]}