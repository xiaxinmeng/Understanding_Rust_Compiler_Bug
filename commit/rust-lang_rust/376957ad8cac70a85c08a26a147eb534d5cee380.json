{"sha": "376957ad8cac70a85c08a26a147eb534d5cee380", "node_id": "C_kwDOAAsO6NoAKDM3Njk1N2FkOGNhYzcwYTg1YzA4YTI2YTE0N2ViNTM0ZDVjZWUzODA", "commit": {"author": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2022-04-11T05:38:07Z"}, "committer": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2022-04-15T06:00:50Z"}, "message": "Move integer functions to traits.", "tree": {"sha": "ee71fe7eea21cd3ebaaa81a74ba3036d8ba0f82c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee71fe7eea21cd3ebaaa81a74ba3036d8ba0f82c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/376957ad8cac70a85c08a26a147eb534d5cee380", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/376957ad8cac70a85c08a26a147eb534d5cee380", "html_url": "https://github.com/rust-lang/rust/commit/376957ad8cac70a85c08a26a147eb534d5cee380", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/376957ad8cac70a85c08a26a147eb534d5cee380/comments", "author": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "committer": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9718639d61b32d4efd2fac330ab1058732b3b758", "url": "https://api.github.com/repos/rust-lang/rust/commits/9718639d61b32d4efd2fac330ab1058732b3b758", "html_url": "https://github.com/rust-lang/rust/commit/9718639d61b32d4efd2fac330ab1058732b3b758"}], "stats": {"total": 753, "additions": 413, "deletions": 340}, "files": [{"sha": "0fb1f5b9fe978371ecd8a8dd0cb9d1569cf31d39", "filename": "crates/core_simd/src/elements.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/376957ad8cac70a85c08a26a147eb534d5cee380/crates%2Fcore_simd%2Fsrc%2Felements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/376957ad8cac70a85c08a26a147eb534d5cee380/crates%2Fcore_simd%2Fsrc%2Felements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Felements.rs?ref=376957ad8cac70a85c08a26a147eb534d5cee380", "patch": "@@ -0,0 +1,5 @@\n+mod int;\n+mod uint;\n+\n+pub use int::*;\n+pub use uint::*;"}, {"sha": "61135427456593d92d13b0a839e12f7f80b6ace8", "filename": "crates/core_simd/src/elements/int.rs", "status": "added", "additions": 273, "deletions": 0, "changes": 273, "blob_url": "https://github.com/rust-lang/rust/blob/376957ad8cac70a85c08a26a147eb534d5cee380/crates%2Fcore_simd%2Fsrc%2Felements%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/376957ad8cac70a85c08a26a147eb534d5cee380/crates%2Fcore_simd%2Fsrc%2Felements%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Felements%2Fint.rs?ref=376957ad8cac70a85c08a26a147eb534d5cee380", "patch": "@@ -0,0 +1,273 @@\n+use crate::simd::{\n+    intrinsics, LaneCount, Mask, Simd, SimdElement, SimdPartialOrd, SupportedLaneCount,\n+};\n+\n+/// Operations on SIMD vectors of signed integers.\n+pub trait SimdInt: Sized {\n+    /// Mask type used for manipulating this SIMD vector type.\n+    type Mask;\n+\n+    /// Scalar type contained by this SIMD vector type.\n+    type Scalar;\n+\n+    /// Lanewise saturating add.\n+    ///\n+    /// # Examples\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # use core::simd::Simd;\n+    /// use core::i32::{MIN, MAX};\n+    /// let x = Simd::from_array([MIN, 0, 1, MAX]);\n+    /// let max = Simd::splat(MAX);\n+    /// let unsat = x + max;\n+    /// let sat = x.saturating_add(max);\n+    /// assert_eq!(unsat, Simd::from_array([-1, MAX, MIN, -2]));\n+    /// assert_eq!(sat, Simd::from_array([-1, MAX, MAX, MAX]));\n+    /// ```\n+    fn saturating_add(self, second: Self) -> Self;\n+\n+    /// Lanewise saturating subtract.\n+    ///\n+    /// # Examples\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # use core::simd::Simd;\n+    /// use core::i32::{MIN, MAX};\n+    /// let x = Simd::from_array([MIN, -2, -1, MAX]);\n+    /// let max = Simd::splat(MAX);\n+    /// let unsat = x - max;\n+    /// let sat = x.saturating_sub(max);\n+    /// assert_eq!(unsat, Simd::from_array([1, MAX, MIN, 0]));\n+    /// assert_eq!(sat, Simd::from_array([MIN, MIN, MIN, 0]));\n+    fn saturating_sub(self, second: Self) -> Self;\n+\n+    /// Lanewise absolute value, implemented in Rust.\n+    /// Every lane becomes its absolute value.\n+    ///\n+    /// # Examples\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # use core::simd::Simd;\n+    /// use core::i32::{MIN, MAX};\n+    /// let xs = Simd::from_array([MIN, MIN +1, -5, 0]);\n+    /// assert_eq!(xs.abs(), Simd::from_array([MIN, MAX, 5, 0]));\n+    /// ```\n+    fn abs(self) -> Self;\n+\n+    /// Lanewise saturating absolute value, implemented in Rust.\n+    /// As abs(), except the MIN value becomes MAX instead of itself.\n+    ///\n+    /// # Examples\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # use core::simd::Simd;\n+    /// use core::i32::{MIN, MAX};\n+    /// let xs = Simd::from_array([MIN, -2, 0, 3]);\n+    /// let unsat = xs.abs();\n+    /// let sat = xs.saturating_abs();\n+    /// assert_eq!(unsat, Simd::from_array([MIN, 2, 0, 3]));\n+    /// assert_eq!(sat, Simd::from_array([MAX, 2, 0, 3]));\n+    /// ```\n+    fn saturating_abs(self) -> Self;\n+\n+    /// Lanewise saturating negation, implemented in Rust.\n+    /// As neg(), except the MIN value becomes MAX instead of itself.\n+    ///\n+    /// # Examples\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # use core::simd::Simd;\n+    /// use core::i32::{MIN, MAX};\n+    /// let x = Simd::from_array([MIN, -2, 3, MAX]);\n+    /// let unsat = -x;\n+    /// let sat = x.saturating_neg();\n+    /// assert_eq!(unsat, Simd::from_array([MIN, 2, -3, MIN + 1]));\n+    /// assert_eq!(sat, Simd::from_array([MAX, 2, -3, MIN + 1]));\n+    /// ```\n+    fn saturating_neg(self) -> Self;\n+\n+    /// Returns true for each positive lane and false if it is zero or negative.\n+    fn is_positive(self) -> Self::Mask;\n+\n+    /// Returns true for each negative lane and false if it is zero or positive.\n+    fn is_negative(self) -> Self::Mask;\n+\n+    /// Returns numbers representing the sign of each lane.\n+    /// * `0` if the number is zero\n+    /// * `1` if the number is positive\n+    /// * `-1` if the number is negative\n+    fn signum(self) -> Self;\n+\n+    /// Returns the sum of the lanes of the vector, with wrapping addition.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # use core::simd::i32x4;\n+    /// let v = i32x4::from_array([1, 2, 3, 4]);\n+    /// assert_eq!(v.reduce_sum(), 10);\n+    ///\n+    /// // SIMD integer addition is always wrapping\n+    /// let v = i32x4::from_array([i32::MAX, 1, 0, 0]);\n+    /// assert_eq!(v.reduce_sum(), i32::MIN);\n+    /// ```\n+    fn reduce_sum(self) -> Self::Scalar;\n+\n+    /// Returns the product of the lanes of the vector, with wrapping multiplication.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # use core::simd::i32x4;\n+    /// let v = i32x4::from_array([1, 2, 3, 4]);\n+    /// assert_eq!(v.reduce_product(), 24);\n+    ///\n+    /// // SIMD integer multiplication is always wrapping\n+    /// let v = i32x4::from_array([i32::MAX, 2, 1, 1]);\n+    /// assert!(v.reduce_product() < i32::MAX);\n+    /// ```\n+    fn reduce_product(self) -> Self::Scalar;\n+\n+    /// Returns the maximum lane in the vector.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # use core::simd::i32x4;\n+    /// let v = i32x4::from_array([1, 2, 3, 4]);\n+    /// assert_eq!(v.reduce_max(), 4);\n+    /// ```\n+    fn reduce_max(self) -> Self::Scalar;\n+\n+    /// Returns the minimum lane in the vector.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # use core::simd::i32x4;\n+    /// let v = i32x4::from_array([1, 2, 3, 4]);\n+    /// assert_eq!(v.reduce_min(), 1);\n+    /// ```\n+    fn reduce_min(self) -> Self::Scalar;\n+\n+    /// Returns the cumulative bitwise \"and\" across the lanes of the vector.\n+    fn reduce_and(self) -> Self::Scalar;\n+\n+    /// Returns the cumulative bitwise \"or\" across the lanes of the vector.\n+    fn reduce_or(self) -> Self::Scalar;\n+\n+    /// Returns the cumulative bitwise \"xor\" across the lanes of the vector.\n+    fn reduce_xor(self) -> Self::Scalar;\n+}\n+\n+macro_rules! impl_trait {\n+    { $($ty:ty),* } => {\n+        $(\n+        impl<const LANES: usize> SimdInt for Simd<$ty, LANES>\n+        where\n+            LaneCount<LANES>: SupportedLaneCount,\n+        {\n+            type Mask = Mask<<$ty as SimdElement>::Mask, LANES>;\n+            type Scalar = $ty;\n+\n+            #[inline]\n+            fn saturating_add(self, second: Self) -> Self {\n+                // Safety: `self` is a vector\n+                unsafe { intrinsics::simd_saturating_add(self, second) }\n+            }\n+\n+            #[inline]\n+            fn saturating_sub(self, second: Self) -> Self {\n+                // Safety: `self` is a vector\n+                unsafe { intrinsics::simd_saturating_sub(self, second) }\n+            }\n+\n+            #[inline]\n+            fn abs(self) -> Self {\n+                const SHR: $ty = <$ty>::BITS as $ty - 1;\n+                let m = self >> Simd::splat(SHR);\n+                (self^m) - m\n+            }\n+\n+            #[inline]\n+            fn saturating_abs(self) -> Self {\n+                // arith shift for -1 or 0 mask based on sign bit, giving 2s complement\n+                const SHR: $ty = <$ty>::BITS as $ty - 1;\n+                let m = self >> Simd::splat(SHR);\n+                (self^m).saturating_sub(m)\n+            }\n+\n+            #[inline]\n+            fn saturating_neg(self) -> Self {\n+                Self::splat(0).saturating_sub(self)\n+            }\n+\n+            #[inline]\n+            fn is_positive(self) -> Self::Mask {\n+                self.simd_gt(Self::splat(0))\n+            }\n+\n+            #[inline]\n+            fn is_negative(self) -> Self::Mask {\n+                self.simd_lt(Self::splat(0))\n+            }\n+\n+            #[inline]\n+            fn signum(self) -> Self {\n+                self.is_positive().select(\n+                    Self::splat(1),\n+                    self.is_negative().select(Self::splat(-1), Self::splat(0))\n+                )\n+            }\n+\n+            #[inline]\n+            fn reduce_sum(self) -> Self::Scalar {\n+                // Safety: `self` is an integer vector\n+                unsafe { intrinsics::simd_reduce_add_ordered(self, 0) }\n+            }\n+\n+            #[inline]\n+            fn reduce_product(self) -> Self::Scalar {\n+                // Safety: `self` is an integer vector\n+                unsafe { intrinsics::simd_reduce_mul_ordered(self, 1) }\n+            }\n+\n+            #[inline]\n+            fn reduce_max(self) -> Self::Scalar {\n+                // Safety: `self` is an integer vector\n+                unsafe { intrinsics::simd_reduce_max(self) }\n+            }\n+\n+            #[inline]\n+            fn reduce_min(self) -> Self::Scalar {\n+                // Safety: `self` is an integer vector\n+                unsafe { intrinsics::simd_reduce_min(self) }\n+            }\n+\n+            #[inline]\n+            fn reduce_and(self) -> Self::Scalar {\n+                // Safety: `self` is an integer vector\n+                unsafe { intrinsics::simd_reduce_and(self) }\n+            }\n+\n+            #[inline]\n+            fn reduce_or(self) -> Self::Scalar {\n+                // Safety: `self` is an integer vector\n+                unsafe { intrinsics::simd_reduce_or(self) }\n+            }\n+\n+            #[inline]\n+            fn reduce_xor(self) -> Self::Scalar {\n+                // Safety: `self` is an integer vector\n+                unsafe { intrinsics::simd_reduce_xor(self) }\n+            }\n+        }\n+        )*\n+    }\n+}\n+\n+impl_trait! { i8, i16, i32, i64, isize }"}, {"sha": "da3213535a30a76b380c50588c1d0c7a09126dd2", "filename": "crates/core_simd/src/elements/uint.rs", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/376957ad8cac70a85c08a26a147eb534d5cee380/crates%2Fcore_simd%2Fsrc%2Felements%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/376957ad8cac70a85c08a26a147eb534d5cee380/crates%2Fcore_simd%2Fsrc%2Felements%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Felements%2Fuint.rs?ref=376957ad8cac70a85c08a26a147eb534d5cee380", "patch": "@@ -0,0 +1,128 @@\n+use crate::simd::{intrinsics, LaneCount, Simd, SupportedLaneCount};\n+\n+/// Operations on SIMD vectors of unsigned integers.\n+pub trait SimdUint: Sized {\n+    /// Scalar type contained by this SIMD vector type.\n+    type Scalar;\n+\n+    /// Lanewise saturating add.\n+    ///\n+    /// # Examples\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # use core::simd::Simd;\n+    /// use core::u32::MAX;\n+    /// let x = Simd::from_array([2, 1, 0, MAX]);\n+    /// let max = Simd::splat(MAX);\n+    /// let unsat = x + max;\n+    /// let sat = x.saturating_add(max);\n+    /// assert_eq!(unsat, Simd::from_array([1, 0, MAX, MAX - 1]));\n+    /// assert_eq!(sat, max);\n+    /// ```\n+    fn saturating_add(self, second: Self) -> Self;\n+\n+    /// Lanewise saturating subtract.\n+    ///\n+    /// # Examples\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # use core::simd::Simd;\n+    /// use core::u32::MAX;\n+    /// let x = Simd::from_array([2, 1, 0, MAX]);\n+    /// let max = Simd::splat(MAX);\n+    /// let unsat = x - max;\n+    /// let sat = x.saturating_sub(max);\n+    /// assert_eq!(unsat, Simd::from_array([3, 2, 1, 0]));\n+    /// assert_eq!(sat, Simd::splat(0));\n+    fn saturating_sub(self, second: Self) -> Self;\n+\n+    /// Returns the sum of the lanes of the vector, with wrapping addition.\n+    fn reduce_sum(self) -> Self::Scalar;\n+\n+    /// Returns the product of the lanes of the vector, with wrapping multiplication.\n+    fn reduce_product(self) -> Self::Scalar;\n+\n+    /// Returns the maximum lane in the vector.\n+    fn reduce_max(self) -> Self::Scalar;\n+\n+    /// Returns the minimum lane in the vector.\n+    fn reduce_min(self) -> Self::Scalar;\n+\n+    /// Returns the cumulative bitwise \"and\" across the lanes of the vector.\n+    fn reduce_and(self) -> Self::Scalar;\n+\n+    /// Returns the cumulative bitwise \"or\" across the lanes of the vector.\n+    fn reduce_or(self) -> Self::Scalar;\n+\n+    /// Returns the cumulative bitwise \"xor\" across the lanes of the vector.\n+    fn reduce_xor(self) -> Self::Scalar;\n+}\n+\n+macro_rules! impl_trait {\n+    { $($ty:ty),* } => {\n+        $(\n+        impl<const LANES: usize> SimdUint for Simd<$ty, LANES>\n+        where\n+            LaneCount<LANES>: SupportedLaneCount,\n+        {\n+            type Scalar = $ty;\n+\n+            #[inline]\n+            fn saturating_add(self, second: Self) -> Self {\n+                // Safety: `self` is a vector\n+                unsafe { intrinsics::simd_saturating_add(self, second) }\n+            }\n+\n+            #[inline]\n+            fn saturating_sub(self, second: Self) -> Self {\n+                // Safety: `self` is a vector\n+                unsafe { intrinsics::simd_saturating_sub(self, second) }\n+            }\n+\n+            #[inline]\n+            fn reduce_sum(self) -> Self::Scalar {\n+                // Safety: `self` is an integer vector\n+                unsafe { intrinsics::simd_reduce_add_ordered(self, 0) }\n+            }\n+\n+            #[inline]\n+            fn reduce_product(self) -> Self::Scalar {\n+                // Safety: `self` is an integer vector\n+                unsafe { intrinsics::simd_reduce_mul_ordered(self, 1) }\n+            }\n+\n+            #[inline]\n+            fn reduce_max(self) -> Self::Scalar {\n+                // Safety: `self` is an integer vector\n+                unsafe { intrinsics::simd_reduce_max(self) }\n+            }\n+\n+            #[inline]\n+            fn reduce_min(self) -> Self::Scalar {\n+                // Safety: `self` is an integer vector\n+                unsafe { intrinsics::simd_reduce_min(self) }\n+            }\n+\n+            #[inline]\n+            fn reduce_and(self) -> Self::Scalar {\n+                // Safety: `self` is an integer vector\n+                unsafe { intrinsics::simd_reduce_and(self) }\n+            }\n+\n+            #[inline]\n+            fn reduce_or(self) -> Self::Scalar {\n+                // Safety: `self` is an integer vector\n+                unsafe { intrinsics::simd_reduce_or(self) }\n+            }\n+\n+            #[inline]\n+            fn reduce_xor(self) -> Self::Scalar {\n+                // Safety: `self` is an integer vector\n+                unsafe { intrinsics::simd_reduce_xor(self) }\n+            }\n+        }\n+        )*\n+    }\n+}\n+\n+impl_trait! { u8, u16, u32, u64, usize }"}, {"sha": "606021e983ed176b2c73c8117b9dde4f362bf808", "filename": "crates/core_simd/src/math.rs", "status": "removed", "additions": 0, "deletions": 156, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/9718639d61b32d4efd2fac330ab1058732b3b758/crates%2Fcore_simd%2Fsrc%2Fmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9718639d61b32d4efd2fac330ab1058732b3b758/crates%2Fcore_simd%2Fsrc%2Fmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmath.rs?ref=9718639d61b32d4efd2fac330ab1058732b3b758", "patch": "@@ -1,156 +0,0 @@\n-use crate::simd::intrinsics::{simd_saturating_add, simd_saturating_sub};\n-use crate::simd::{LaneCount, Simd, SupportedLaneCount};\n-\n-macro_rules! impl_uint_arith {\n-    ($($ty:ty),+) => {\n-        $( impl<const LANES: usize> Simd<$ty, LANES> where LaneCount<LANES>: SupportedLaneCount {\n-\n-            /// Lanewise saturating add.\n-            ///\n-            /// # Examples\n-            /// ```\n-            /// # #![feature(portable_simd)]\n-            /// # use core::simd::Simd;\n-            #[doc = concat!(\"# use core::\", stringify!($ty), \"::MAX;\")]\n-            /// let x = Simd::from_array([2, 1, 0, MAX]);\n-            /// let max = Simd::splat(MAX);\n-            /// let unsat = x + max;\n-            /// let sat = x.saturating_add(max);\n-            /// assert_eq!(unsat, Simd::from_array([1, 0, MAX, MAX - 1]));\n-            /// assert_eq!(sat, max);\n-            /// ```\n-            #[inline]\n-            pub fn saturating_add(self, second: Self) -> Self {\n-                // Safety: `self` is a vector\n-                unsafe { simd_saturating_add(self, second) }\n-            }\n-\n-            /// Lanewise saturating subtract.\n-            ///\n-            /// # Examples\n-            /// ```\n-            /// # #![feature(portable_simd)]\n-            /// # use core::simd::Simd;\n-            #[doc = concat!(\"# use core::\", stringify!($ty), \"::MAX;\")]\n-            /// let x = Simd::from_array([2, 1, 0, MAX]);\n-            /// let max = Simd::splat(MAX);\n-            /// let unsat = x - max;\n-            /// let sat = x.saturating_sub(max);\n-            /// assert_eq!(unsat, Simd::from_array([3, 2, 1, 0]));\n-            /// assert_eq!(sat, Simd::splat(0));\n-            #[inline]\n-            pub fn saturating_sub(self, second: Self) -> Self {\n-                // Safety: `self` is a vector\n-                unsafe { simd_saturating_sub(self, second) }\n-            }\n-        })+\n-    }\n-}\n-\n-macro_rules! impl_int_arith {\n-    ($($ty:ty),+) => {\n-        $( impl<const LANES: usize> Simd<$ty, LANES> where LaneCount<LANES>: SupportedLaneCount {\n-\n-            /// Lanewise saturating add.\n-            ///\n-            /// # Examples\n-            /// ```\n-            /// # #![feature(portable_simd)]\n-            /// # use core::simd::Simd;\n-            #[doc = concat!(\"# use core::\", stringify!($ty), \"::{MIN, MAX};\")]\n-            /// let x = Simd::from_array([MIN, 0, 1, MAX]);\n-            /// let max = Simd::splat(MAX);\n-            /// let unsat = x + max;\n-            /// let sat = x.saturating_add(max);\n-            /// assert_eq!(unsat, Simd::from_array([-1, MAX, MIN, -2]));\n-            /// assert_eq!(sat, Simd::from_array([-1, MAX, MAX, MAX]));\n-            /// ```\n-            #[inline]\n-            pub fn saturating_add(self, second: Self) -> Self {\n-                // Safety: `self` is a vector\n-                unsafe { simd_saturating_add(self, second) }\n-            }\n-\n-            /// Lanewise saturating subtract.\n-            ///\n-            /// # Examples\n-            /// ```\n-            /// # #![feature(portable_simd)]\n-            /// # use core::simd::Simd;\n-            #[doc = concat!(\"# use core::\", stringify!($ty), \"::{MIN, MAX};\")]\n-            /// let x = Simd::from_array([MIN, -2, -1, MAX]);\n-            /// let max = Simd::splat(MAX);\n-            /// let unsat = x - max;\n-            /// let sat = x.saturating_sub(max);\n-            /// assert_eq!(unsat, Simd::from_array([1, MAX, MIN, 0]));\n-            /// assert_eq!(sat, Simd::from_array([MIN, MIN, MIN, 0]));\n-            #[inline]\n-            pub fn saturating_sub(self, second: Self) -> Self {\n-                // Safety: `self` is a vector\n-                unsafe { simd_saturating_sub(self, second) }\n-            }\n-\n-            /// Lanewise absolute value, implemented in Rust.\n-            /// Every lane becomes its absolute value.\n-            ///\n-            /// # Examples\n-            /// ```\n-            /// # #![feature(portable_simd)]\n-            /// # use core::simd::Simd;\n-            #[doc = concat!(\"# use core::\", stringify!($ty), \"::{MIN, MAX};\")]\n-            /// let xs = Simd::from_array([MIN, MIN +1, -5, 0]);\n-            /// assert_eq!(xs.abs(), Simd::from_array([MIN, MAX, 5, 0]));\n-            /// ```\n-            #[inline]\n-            pub fn abs(self) -> Self {\n-                const SHR: $ty = <$ty>::BITS as $ty - 1;\n-                let m = self >> Simd::splat(SHR);\n-                (self^m) - m\n-            }\n-\n-            /// Lanewise saturating absolute value, implemented in Rust.\n-            /// As abs(), except the MIN value becomes MAX instead of itself.\n-            ///\n-            /// # Examples\n-            /// ```\n-            /// # #![feature(portable_simd)]\n-            /// # use core::simd::Simd;\n-            #[doc = concat!(\"# use core::\", stringify!($ty), \"::{MIN, MAX};\")]\n-            /// let xs = Simd::from_array([MIN, -2, 0, 3]);\n-            /// let unsat = xs.abs();\n-            /// let sat = xs.saturating_abs();\n-            /// assert_eq!(unsat, Simd::from_array([MIN, 2, 0, 3]));\n-            /// assert_eq!(sat, Simd::from_array([MAX, 2, 0, 3]));\n-            /// ```\n-            #[inline]\n-            pub fn saturating_abs(self) -> Self {\n-                // arith shift for -1 or 0 mask based on sign bit, giving 2s complement\n-                const SHR: $ty = <$ty>::BITS as $ty - 1;\n-                let m = self >> Simd::splat(SHR);\n-                (self^m).saturating_sub(m)\n-            }\n-\n-            /// Lanewise saturating negation, implemented in Rust.\n-            /// As neg(), except the MIN value becomes MAX instead of itself.\n-            ///\n-            /// # Examples\n-            /// ```\n-            /// # #![feature(portable_simd)]\n-            /// # use core::simd::Simd;\n-            #[doc = concat!(\"# use core::\", stringify!($ty), \"::{MIN, MAX};\")]\n-            /// let x = Simd::from_array([MIN, -2, 3, MAX]);\n-            /// let unsat = -x;\n-            /// let sat = x.saturating_neg();\n-            /// assert_eq!(unsat, Simd::from_array([MIN, 2, -3, MIN + 1]));\n-            /// assert_eq!(sat, Simd::from_array([MAX, 2, -3, MIN + 1]));\n-            /// ```\n-            #[inline]\n-            pub fn saturating_neg(self) -> Self {\n-                Self::splat(0).saturating_sub(self)\n-            }\n-        })+\n-    }\n-}\n-\n-impl_uint_arith! { u8, u16, u32, u64, usize }\n-impl_int_arith! { i8, i16, i32, i64, isize }"}, {"sha": "2d4fe2b7fde6c77d51373afa26feed1951fdf2c1", "filename": "crates/core_simd/src/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/376957ad8cac70a85c08a26a147eb534d5cee380/crates%2Fcore_simd%2Fsrc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/376957ad8cac70a85c08a26a147eb534d5cee380/crates%2Fcore_simd%2Fsrc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmod.rs?ref=376957ad8cac70a85c08a26a147eb534d5cee380", "patch": "@@ -9,12 +9,12 @@ pub(crate) mod intrinsics;\n #[cfg(feature = \"generic_const_exprs\")]\n mod to_bytes;\n \n+mod elements;\n mod eq;\n mod fmt;\n mod iter;\n mod lane_count;\n mod masks;\n-mod math;\n mod ops;\n mod ord;\n mod round;\n@@ -26,6 +26,7 @@ mod vendor;\n pub mod simd {\n     pub(crate) use crate::core_simd::intrinsics;\n \n+    pub use crate::core_simd::elements::*;\n     pub use crate::core_simd::eq::*;\n     pub use crate::core_simd::lane_count::{LaneCount, SupportedLaneCount};\n     pub use crate::core_simd::masks::*;"}, {"sha": "9d8639feeeed233bb9a777cacd57d238833e095e", "filename": "crates/core_simd/src/reduction.rs", "status": "modified", "additions": 2, "deletions": 142, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/376957ad8cac70a85c08a26a147eb534d5cee380/crates%2Fcore_simd%2Fsrc%2Freduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/376957ad8cac70a85c08a26a147eb534d5cee380/crates%2Fcore_simd%2Fsrc%2Freduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Freduction.rs?ref=376957ad8cac70a85c08a26a147eb534d5cee380", "patch": "@@ -1,105 +1,7 @@\n use crate::simd::intrinsics::{\n-    simd_reduce_add_ordered, simd_reduce_and, simd_reduce_max, simd_reduce_min,\n-    simd_reduce_mul_ordered, simd_reduce_or, simd_reduce_xor,\n+    simd_reduce_add_ordered, simd_reduce_max, simd_reduce_min, simd_reduce_mul_ordered,\n };\n-use crate::simd::{LaneCount, Simd, SimdElement, SupportedLaneCount};\n-use core::ops::{BitAnd, BitOr, BitXor};\n-\n-macro_rules! impl_integer_reductions {\n-    { $scalar:ty } => {\n-        impl<const LANES: usize> Simd<$scalar, LANES>\n-        where\n-            LaneCount<LANES>: SupportedLaneCount,\n-        {\n-            /// Reducing wrapping add.  Returns the sum of the lanes of the vector, with wrapping addition.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// # #![feature(portable_simd)]\n-            /// # use core::simd::Simd;\n-            #[doc = concat!(\"# use core::simd::\", stringify!($scalar), \"x4;\")]\n-            #[doc = concat!(\"let v = \", stringify!($scalar), \"x4::from_array([1, 2, 3, 4]);\")]\n-            /// assert_eq!(v.reduce_sum(), 10);\n-            ///\n-            /// // SIMD integer addition is always wrapping\n-            #[doc = concat!(\"let v = \", stringify!($scalar), \"x4::from_array([\", stringify!($scalar) ,\"::MAX, 1, 0, 0]);\")]\n-            #[doc = concat!(\"assert_eq!(v.reduce_sum(), \", stringify!($scalar), \"::MIN);\")]\n-            /// ```\n-            #[inline]\n-            pub fn reduce_sum(self) -> $scalar {\n-                // Safety: `self` is an integer vector\n-                unsafe { simd_reduce_add_ordered(self, 0) }\n-            }\n-\n-            /// Reducing wrapping multiply. Returns the product of the lanes of the vector, with wrapping multiplication.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// # #![feature(portable_simd)]\n-            /// # use core::simd::Simd;\n-            #[doc = concat!(\"# use core::simd::\", stringify!($scalar), \"x4;\")]\n-            #[doc = concat!(\"let v = \", stringify!($scalar), \"x4::from_array([1, 2, 3, 4]);\")]\n-            /// assert_eq!(v.reduce_product(), 24);\n-            ///\n-            /// // SIMD integer multiplication is always wrapping\n-            #[doc = concat!(\"let v = \", stringify!($scalar), \"x4::from_array([\", stringify!($scalar) ,\"::MAX, 2, 1, 1]);\")]\n-            #[doc = concat!(\"assert!(v.reduce_product() < \", stringify!($scalar), \"::MAX);\")]\n-            /// ```\n-            #[inline]\n-            pub fn reduce_product(self) -> $scalar {\n-                // Safety: `self` is an integer vector\n-                unsafe { simd_reduce_mul_ordered(self, 1) }\n-            }\n-\n-            /// Reducing maximum.  Returns the maximum lane in the vector.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// # #![feature(portable_simd)]\n-            /// # use core::simd::Simd;\n-            #[doc = concat!(\"# use core::simd::\", stringify!($scalar), \"x4;\")]\n-            #[doc = concat!(\"let v = \", stringify!($scalar), \"x4::from_array([1, 2, 3, 4]);\")]\n-            /// assert_eq!(v.reduce_max(), 4);\n-            /// ```\n-            #[inline]\n-            pub fn reduce_max(self) -> $scalar {\n-                // Safety: `self` is an integer vector\n-                unsafe { simd_reduce_max(self) }\n-            }\n-\n-            /// Reducing minimum.  Returns the minimum lane in the vector.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// # #![feature(portable_simd)]\n-            /// # use core::simd::Simd;\n-            #[doc = concat!(\"# use core::simd::\", stringify!($scalar), \"x4;\")]\n-            #[doc = concat!(\"let v = \", stringify!($scalar), \"x4::from_array([1, 2, 3, 4]);\")]\n-            /// assert_eq!(v.reduce_min(), 1);\n-            /// ```\n-            #[inline]\n-            pub fn reduce_min(self) -> $scalar {\n-                // Safety: `self` is an integer vector\n-                unsafe { simd_reduce_min(self) }\n-            }\n-        }\n-    }\n-}\n-\n-impl_integer_reductions! { i8 }\n-impl_integer_reductions! { i16 }\n-impl_integer_reductions! { i32 }\n-impl_integer_reductions! { i64 }\n-impl_integer_reductions! { isize }\n-impl_integer_reductions! { u8 }\n-impl_integer_reductions! { u16 }\n-impl_integer_reductions! { u32 }\n-impl_integer_reductions! { u64 }\n-impl_integer_reductions! { usize }\n+use crate::simd::{LaneCount, Simd, SupportedLaneCount};\n \n macro_rules! impl_float_reductions {\n     { $scalar:ty } => {\n@@ -223,45 +125,3 @@ macro_rules! impl_float_reductions {\n \n impl_float_reductions! { f32 }\n impl_float_reductions! { f64 }\n-\n-impl<T, const LANES: usize> Simd<T, LANES>\n-where\n-    Self: BitAnd<Self, Output = Self>,\n-    T: SimdElement + BitAnd<T, Output = T>,\n-    LaneCount<LANES>: SupportedLaneCount,\n-{\n-    /// Reducing bitwise \"and\".  Returns the cumulative bitwise \"and\" across the lanes of\n-    /// the vector.\n-    #[inline]\n-    pub fn reduce_and(self) -> T {\n-        unsafe { simd_reduce_and(self) }\n-    }\n-}\n-\n-impl<T, const LANES: usize> Simd<T, LANES>\n-where\n-    Self: BitOr<Self, Output = Self>,\n-    T: SimdElement + BitOr<T, Output = T>,\n-    LaneCount<LANES>: SupportedLaneCount,\n-{\n-    /// Reducing bitwise \"or\".  Returns the cumulative bitwise \"or\" across the lanes of\n-    /// the vector.\n-    #[inline]\n-    pub fn reduce_or(self) -> T {\n-        unsafe { simd_reduce_or(self) }\n-    }\n-}\n-\n-impl<T, const LANES: usize> Simd<T, LANES>\n-where\n-    Self: BitXor<Self, Output = Self>,\n-    T: SimdElement + BitXor<T, Output = T>,\n-    LaneCount<LANES>: SupportedLaneCount,\n-{\n-    /// Reducing bitwise \"xor\".  Returns the cumulative bitwise \"xor\" across the lanes of\n-    /// the vector.\n-    #[inline]\n-    pub fn reduce_xor(self) -> T {\n-        unsafe { simd_reduce_xor(self) }\n-    }\n-}"}, {"sha": "20e56c7dc6443bdca6b8922dc3659e4f554c665e", "filename": "crates/core_simd/src/vector/int.rs", "status": "modified", "additions": 1, "deletions": 41, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/376957ad8cac70a85c08a26a147eb534d5cee380/crates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/376957ad8cac70a85c08a26a147eb534d5cee380/crates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs?ref=376957ad8cac70a85c08a26a147eb534d5cee380", "patch": "@@ -1,46 +1,6 @@\n #![allow(non_camel_case_types)]\n \n-use crate::simd::{LaneCount, Mask, Simd, SimdPartialOrd, SupportedLaneCount};\n-\n-/// Implements additional integer traits (Eq, Ord, Hash) on the specified vector `$name`, holding multiple `$lanes` of `$type`.\n-macro_rules! impl_integer_vector {\n-    { $type:ty } => {\n-        impl<const LANES: usize> Simd<$type, LANES>\n-        where\n-            LaneCount<LANES>: SupportedLaneCount,\n-        {\n-            /// Returns true for each positive lane and false if it is zero or negative.\n-            #[inline]\n-            pub fn is_positive(self) -> Mask<$type, LANES> {\n-                self.simd_gt(Self::splat(0))\n-            }\n-\n-            /// Returns true for each negative lane and false if it is zero or positive.\n-            #[inline]\n-            pub fn is_negative(self) -> Mask<$type, LANES> {\n-                self.simd_lt(Self::splat(0))\n-            }\n-\n-            /// Returns numbers representing the sign of each lane.\n-            /// * `0` if the number is zero\n-            /// * `1` if the number is positive\n-            /// * `-1` if the number is negative\n-            #[inline]\n-            pub fn signum(self) -> Self {\n-                self.is_positive().select(\n-                    Self::splat(1),\n-                    self.is_negative().select(Self::splat(-1), Self::splat(0))\n-                )\n-            }\n-        }\n-    }\n-}\n-\n-impl_integer_vector! { isize }\n-impl_integer_vector! { i16 }\n-impl_integer_vector! { i32 }\n-impl_integer_vector! { i64 }\n-impl_integer_vector! { i8 }\n+use crate::simd::Simd;\n \n /// A SIMD vector with two elements of type `isize`.\n pub type isizex2 = Simd<isize, 2>;"}, {"sha": "48c512be7d0265cb71ce9d05e0d20b03c25108e4", "filename": "crates/core_simd/tests/ops_macros.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/376957ad8cac70a85c08a26a147eb534d5cee380/crates%2Fcore_simd%2Ftests%2Fops_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/376957ad8cac70a85c08a26a147eb534d5cee380/crates%2Fcore_simd%2Ftests%2Fops_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_macros.rs?ref=376957ad8cac70a85c08a26a147eb534d5cee380", "patch": "@@ -172,6 +172,7 @@ macro_rules! impl_common_integer_tests {\n macro_rules! impl_signed_tests {\n     { $scalar:tt } => {\n         mod $scalar {\n+            use core_simd::simd::SimdInt;\n             type Vector<const LANES: usize> = core_simd::Simd<Scalar, LANES>;\n             type Scalar = $scalar;\n \n@@ -312,6 +313,7 @@ macro_rules! impl_signed_tests {\n macro_rules! impl_unsigned_tests {\n     { $scalar:tt } => {\n         mod $scalar {\n+            use core_simd::simd::SimdUint;\n             type Vector<const LANES: usize> = core_simd::Simd<Scalar, LANES>;\n             type Scalar = $scalar;\n "}]}