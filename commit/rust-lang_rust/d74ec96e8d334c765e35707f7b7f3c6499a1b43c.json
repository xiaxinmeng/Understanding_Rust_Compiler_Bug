{"sha": "d74ec96e8d334c765e35707f7b7f3c6499a1b43c", "node_id": "C_kwDOAAsO6NoAKGQ3NGVjOTZlOGQzMzRjNzY1ZTM1NzA3ZjdiN2YzYzY0OTlhMWI0M2M", "commit": {"author": {"name": "est31", "email": "MTest31@outlook.com", "date": "2023-06-02T16:51:27Z"}, "committer": {"name": "est31", "email": "MTest31@outlook.com", "date": "2023-06-08T20:03:06Z"}, "message": "Move float breaking out of Parser::parse_expr_tuple_field_access_float\n\nPurely a refactor in preparation of using it in offset_of!() parsing", "tree": {"sha": "8c331661c0a3dae47eb50652e881365c866303cc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c331661c0a3dae47eb50652e881365c866303cc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d74ec96e8d334c765e35707f7b7f3c6499a1b43c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d74ec96e8d334c765e35707f7b7f3c6499a1b43c", "html_url": "https://github.com/rust-lang/rust/commit/d74ec96e8d334c765e35707f7b7f3c6499a1b43c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d74ec96e8d334c765e35707f7b7f3c6499a1b43c/comments", "author": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "committer": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a77659a1e1807ba567f513afe59115af2604dc30", "url": "https://api.github.com/repos/rust-lang/rust/commits/a77659a1e1807ba567f513afe59115af2604dc30", "html_url": "https://github.com/rust-lang/rust/commit/a77659a1e1807ba567f513afe59115af2604dc30"}], "stats": {"total": 75, "additions": 53, "deletions": 22}, "files": [{"sha": "9e5f85dc7dc0a4ec0565757ce595417ac19d0769", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 53, "deletions": 22, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/d74ec96e8d334c765e35707f7b7f3c6499a1b43c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d74ec96e8d334c765e35707f7b7f3c6499a1b43c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=d74ec96e8d334c765e35707f7b7f3c6499a1b43c", "patch": "@@ -91,6 +91,18 @@ impl From<P<Expr>> for LhsExpr {\n     }\n }\n \n+#[derive(Debug)]\n+enum DestructuredFloat {\n+    /// 1e2\n+    Single(Symbol, Span),\n+    /// 1.\n+    TrailingDot(Symbol, Span, Span),\n+    /// 1.2 | 1.2e3\n+    MiddleDot(Symbol, Span, Span, Symbol, Span),\n+    /// Invalid\n+    Error,\n+}\n+\n impl<'a> Parser<'a> {\n     /// Parses an expression.\n     #[inline]\n@@ -1013,13 +1025,8 @@ impl<'a> Parser<'a> {\n     // support pushing \"future tokens\" (would be also helpful to `break_and_eat`), or\n     // we should break everything including floats into more basic proc-macro style\n     // tokens in the lexer (probably preferable).\n-    fn parse_expr_tuple_field_access_float(\n-        &mut self,\n-        lo: Span,\n-        base: P<Expr>,\n-        float: Symbol,\n-        suffix: Option<Symbol>,\n-    ) -> P<Expr> {\n+    // See also `TokenKind::break_two_token_op` which does similar splitting of `>>` into `>`.\n+    fn break_up_float(&mut self, float: Symbol) -> DestructuredFloat {\n         #[derive(Debug)]\n         enum FloatComponent {\n             IdentLike(String),\n@@ -1056,7 +1063,7 @@ impl<'a> Parser<'a> {\n         match &*components {\n             // 1e2\n             [IdentLike(i)] => {\n-                self.parse_expr_tuple_field_access(lo, base, Symbol::intern(&i), suffix, None)\n+                DestructuredFloat::Single(Symbol::intern(&i), span)\n             }\n             // 1.\n             [IdentLike(i), Punct('.')] => {\n@@ -1068,11 +1075,8 @@ impl<'a> Parser<'a> {\n                 } else {\n                     (span, span)\n                 };\n-                assert!(suffix.is_none());\n                 let symbol = Symbol::intern(&i);\n-                self.token = Token::new(token::Ident(symbol, false), ident_span);\n-                let next_token = (Token::new(token::Dot, dot_span), self.token_spacing);\n-                self.parse_expr_tuple_field_access(lo, base, symbol, None, Some(next_token))\n+                DestructuredFloat::TrailingDot(symbol, ident_span, dot_span)\n             }\n             // 1.2 | 1.2e3\n             [IdentLike(i1), Punct('.'), IdentLike(i2)] => {\n@@ -1088,16 +1092,8 @@ impl<'a> Parser<'a> {\n                     (span, span, span)\n                 };\n                 let symbol1 = Symbol::intern(&i1);\n-                self.token = Token::new(token::Ident(symbol1, false), ident1_span);\n-                // This needs to be `Spacing::Alone` to prevent regressions.\n-                // See issue #76399 and PR #76285 for more details\n-                let next_token1 = (Token::new(token::Dot, dot_span), Spacing::Alone);\n-                let base1 =\n-                    self.parse_expr_tuple_field_access(lo, base, symbol1, None, Some(next_token1));\n                 let symbol2 = Symbol::intern(&i2);\n-                let next_token2 = Token::new(token::Ident(symbol2, false), ident2_span);\n-                self.bump_with((next_token2, self.token_spacing)); // `.`\n-                self.parse_expr_tuple_field_access(lo, base1, symbol2, suffix, None)\n+                DestructuredFloat::MiddleDot(symbol1, ident1_span, dot_span, symbol2, ident2_span)\n             }\n             // 1e+ | 1e- (recovered)\n             [IdentLike(_), Punct('+' | '-')] |\n@@ -1109,12 +1105,47 @@ impl<'a> Parser<'a> {\n             [IdentLike(_), Punct('.'), IdentLike(_), Punct('+' | '-'), IdentLike(_)] => {\n                 // See the FIXME about `TokenCursor` above.\n                 self.error_unexpected_after_dot();\n-                base\n+                DestructuredFloat::Error\n             }\n             _ => panic!(\"unexpected components in a float token: {:?}\", components),\n         }\n     }\n \n+    fn parse_expr_tuple_field_access_float(\n+        &mut self,\n+        lo: Span,\n+        base: P<Expr>,\n+        float: Symbol,\n+        suffix: Option<Symbol>,\n+    ) -> P<Expr> {\n+        match self.break_up_float(float) {\n+            // 1e2\n+            DestructuredFloat::Single(sym, _sp) => {\n+                self.parse_expr_tuple_field_access(lo, base, sym, suffix, None)\n+            }\n+            // 1.\n+            DestructuredFloat::TrailingDot(sym, ident_span, dot_span) => {\n+                assert!(suffix.is_none());\n+                self.token = Token::new(token::Ident(sym, false), ident_span);\n+                let next_token = (Token::new(token::Dot, dot_span), self.token_spacing);\n+                self.parse_expr_tuple_field_access(lo, base, sym, None, Some(next_token))\n+            }\n+            // 1.2 | 1.2e3\n+            DestructuredFloat::MiddleDot(symbol1, ident1_span, dot_span, symbol2, ident2_span) => {\n+                self.token = Token::new(token::Ident(symbol1, false), ident1_span);\n+                // This needs to be `Spacing::Alone` to prevent regressions.\n+                // See issue #76399 and PR #76285 for more details\n+                let next_token1 = (Token::new(token::Dot, dot_span), Spacing::Alone);\n+                let base1 =\n+                    self.parse_expr_tuple_field_access(lo, base, symbol1, None, Some(next_token1));\n+                let next_token2 = Token::new(token::Ident(symbol2, false), ident2_span);\n+                self.bump_with((next_token2, self.token_spacing)); // `.`\n+                self.parse_expr_tuple_field_access(lo, base1, symbol2, suffix, None)\n+            }\n+            DestructuredFloat::Error => base,\n+        }\n+    }\n+\n     fn parse_expr_tuple_field_access(\n         &mut self,\n         lo: Span,"}]}