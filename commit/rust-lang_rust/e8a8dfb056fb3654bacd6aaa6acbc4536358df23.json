{"sha": "e8a8dfb056fb3654bacd6aaa6acbc4536358df23", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4YThkZmIwNTZmYjM2NTRiYWNkNmFhYTZhY2JjNDUzNjM1OGRmMjM=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-04-06T10:51:55Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-04-06T10:51:55Z"}, "message": "rustc: retire hir::map's paths.", "tree": {"sha": "3d379b80f98e27fd27d953276830278942f0eefc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3d379b80f98e27fd27d953276830278942f0eefc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e8a8dfb056fb3654bacd6aaa6acbc4536358df23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e8a8dfb056fb3654bacd6aaa6acbc4536358df23", "html_url": "https://github.com/rust-lang/rust/commit/e8a8dfb056fb3654bacd6aaa6acbc4536358df23", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e8a8dfb056fb3654bacd6aaa6acbc4536358df23/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "20f0f3c1f131b54dcc6fdc7eeb1d04ea89f5f6fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/20f0f3c1f131b54dcc6fdc7eeb1d04ea89f5f6fd", "html_url": "https://github.com/rust-lang/rust/commit/20f0f3c1f131b54dcc6fdc7eeb1d04ea89f5f6fd"}], "stats": {"total": 717, "additions": 192, "deletions": 525}, "files": [{"sha": "94fa393ae3df8f08ff13ce64e66bea3335e90484", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e8a8dfb056fb3654bacd6aaa6acbc4536358df23/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a8dfb056fb3654bacd6aaa6acbc4536358df23/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=e8a8dfb056fb3654bacd6aaa6acbc4536358df23", "patch": "@@ -14,6 +14,7 @@ use super::MapEntry::*;\n use hir::*;\n use hir::intravisit::Visitor;\n use hir::def_id::{CRATE_DEF_INDEX, DefId, DefIndex};\n+use middle::cstore::InlinedItem;\n use std::iter::repeat;\n use syntax::ast::{NodeId, CRATE_NODE_ID, DUMMY_NODE_ID};\n use syntax::codemap::Span;\n@@ -46,7 +47,7 @@ impl<'ast> NodeCollector<'ast> {\n     }\n \n     pub fn extend(krate: &'ast Crate,\n-                  parent: &'ast InlinedParent,\n+                  parent: &'ast InlinedItem,\n                   parent_node: NodeId,\n                   parent_def_path: DefPath,\n                   parent_def_id: DefId,"}, {"sha": "e1b7afda58bbe5068e77c04d7e271955370aed76", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 50, "deletions": 189, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/e8a8dfb056fb3654bacd6aaa6acbc4536358df23/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a8dfb056fb3654bacd6aaa6acbc4536358df23/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=e8a8dfb056fb3654bacd6aaa6acbc4536358df23", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n pub use self::Node::*;\n-pub use self::PathElem::*;\n use self::MapEntry::*;\n use self::collector::NodeCollector;\n pub use self::definitions::{Definitions, DefKey, DefPath, DefPathData,\n@@ -25,93 +24,20 @@ use syntax::abi::Abi;\n use syntax::ast::{self, Name, NodeId, DUMMY_NODE_ID};\n use syntax::attr::ThinAttributesExt;\n use syntax::codemap::{Span, Spanned};\n-use syntax::parse::token;\n \n use hir::*;\n use hir::fold::Folder;\n use hir::print as pprust;\n \n use arena::TypedArena;\n use std::cell::RefCell;\n-use std::fmt;\n use std::io;\n-use std::iter;\n use std::mem;\n-use std::slice;\n \n pub mod blocks;\n mod collector;\n pub mod definitions;\n \n-#[derive(Clone, Copy, PartialEq, Debug)]\n-pub enum PathElem {\n-    PathMod(Name),\n-    PathName(Name)\n-}\n-\n-impl PathElem {\n-    pub fn name(&self) -> Name {\n-        match *self {\n-            PathMod(name) | PathName(name) => name\n-        }\n-    }\n-}\n-\n-impl fmt::Display for PathElem {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}\", self.name())\n-    }\n-}\n-\n-#[derive(Clone)]\n-pub struct LinkedPathNode<'a> {\n-    node: PathElem,\n-    next: LinkedPath<'a>,\n-}\n-\n-#[derive(Copy, Clone)]\n-pub struct LinkedPath<'a>(Option<&'a LinkedPathNode<'a>>);\n-\n-impl<'a> LinkedPath<'a> {\n-    pub fn empty() -> LinkedPath<'a> {\n-        LinkedPath(None)\n-    }\n-\n-    pub fn from(node: &'a LinkedPathNode) -> LinkedPath<'a> {\n-        LinkedPath(Some(node))\n-    }\n-}\n-\n-impl<'a> Iterator for LinkedPath<'a> {\n-    type Item = PathElem;\n-\n-    fn next(&mut self) -> Option<PathElem> {\n-        match self.0 {\n-            Some(node) => {\n-                *self = node.next;\n-                Some(node.node)\n-            }\n-            None => None\n-        }\n-    }\n-}\n-\n-/// The type of the iterator used by with_path.\n-pub type PathElems<'a, 'b> = iter::Chain<iter::Cloned<slice::Iter<'a, PathElem>>, LinkedPath<'b>>;\n-\n-pub fn path_to_string<PI: Iterator<Item=PathElem>>(path: PI) -> String {\n-    let itr = token::get_ident_interner();\n-\n-    path.fold(String::new(), |mut s, e| {\n-        let e = itr.get(e.name());\n-        if !s.is_empty() {\n-            s.push_str(\"::\");\n-        }\n-        s.push_str(&e[..]);\n-        s\n-    })\n-}\n-\n #[derive(Copy, Clone, Debug)]\n pub enum Node<'ast> {\n     NodeItem(&'ast Item),\n@@ -156,7 +82,7 @@ pub enum MapEntry<'ast> {\n \n     /// Roots for node trees.\n     RootCrate,\n-    RootInlinedParent(&'ast InlinedParent)\n+    RootInlinedParent(&'ast InlinedItem)\n }\n \n impl<'ast> Clone for MapEntry<'ast> {\n@@ -165,12 +91,6 @@ impl<'ast> Clone for MapEntry<'ast> {\n     }\n }\n \n-#[derive(Debug)]\n-pub struct InlinedParent {\n-    path: Vec<PathElem>,\n-    ii: InlinedItem\n-}\n-\n impl<'ast> MapEntry<'ast> {\n     fn from_node(p: NodeId, node: Node<'ast>) -> MapEntry<'ast> {\n         match node {\n@@ -233,7 +153,7 @@ impl<'ast> MapEntry<'ast> {\n pub struct Forest {\n     krate: Crate,\n     pub dep_graph: DepGraph,\n-    inlined_items: TypedArena<InlinedParent>\n+    inlined_items: TypedArena<InlinedItem>\n }\n \n impl Forest {\n@@ -351,8 +271,10 @@ impl<'ast> Map<'ast> {\n         self.definitions.borrow().def_key(def_id.index)\n     }\n \n-    pub fn def_path_from_id(&self, id: NodeId) -> DefPath {\n-        self.def_path(self.local_def_id(id))\n+    pub fn def_path_from_id(&self, id: NodeId) -> Option<DefPath> {\n+        self.opt_local_def_id(id).map(|def_id| {\n+            self.def_path(def_id)\n+        })\n     }\n \n     pub fn def_path(&self, def_id: DefId) -> DefPath {\n@@ -551,8 +473,8 @@ impl<'ast> Map<'ast> {\n     pub fn get_parent_did(&self, id: NodeId) -> DefId {\n         let parent = self.get_parent(id);\n         match self.find_entry(parent) {\n-            Some(RootInlinedParent(&InlinedParent {ii: II::TraitItem(did, _), ..})) => did,\n-            Some(RootInlinedParent(&InlinedParent {ii: II::ImplItem(did, _), ..})) => did,\n+            Some(RootInlinedParent(&II::TraitItem(did, _))) |\n+            Some(RootInlinedParent(&II::ImplItem(did, _))) => did,\n             _ => self.local_def_id(parent)\n         }\n     }\n@@ -634,80 +556,21 @@ impl<'ast> Map<'ast> {\n         }\n     }\n \n-    /// returns the name associated with the given NodeId's AST\n-    pub fn get_path_elem(&self, id: NodeId) -> PathElem {\n-        let node = self.get(id);\n-        match node {\n-            NodeItem(item) => {\n-                match item.node {\n-                    ItemMod(_) | ItemForeignMod(_) => {\n-                        PathMod(item.name)\n-                    }\n-                    _ => PathName(item.name)\n-                }\n-            }\n-            NodeForeignItem(i) => PathName(i.name),\n-            NodeImplItem(ii) => PathName(ii.name),\n-            NodeTraitItem(ti) => PathName(ti.name),\n-            NodeVariant(v) => PathName(v.node.name),\n-            NodeLifetime(lt) => PathName(lt.name),\n-            NodeTyParam(tp) => PathName(tp.name),\n+    /// Returns the name associated with the given NodeId's AST.\n+    pub fn name(&self, id: NodeId) -> Name {\n+        match self.get(id) {\n+            NodeItem(i) => i.name,\n+            NodeForeignItem(i) => i.name,\n+            NodeImplItem(ii) => ii.name,\n+            NodeTraitItem(ti) => ti.name,\n+            NodeVariant(v) => v.node.name,\n+            NodeLifetime(lt) => lt.name,\n+            NodeTyParam(tp) => tp.name,\n             NodeLocal(&Pat { node: PatKind::Ident(_,l,_), .. }) => {\n-                PathName(l.node.name)\n+                l.node.name\n             },\n-            _ => bug!(\"no path elem for {:?}\", node)\n-        }\n-    }\n-\n-    pub fn with_path<T, F>(&self, id: NodeId, f: F) -> T where\n-        F: FnOnce(PathElems) -> T,\n-    {\n-        self.with_path_next(id, LinkedPath::empty(), f)\n-    }\n-\n-    pub fn path_to_string(&self, id: NodeId) -> String {\n-        self.with_path(id, |path| path_to_string(path))\n-    }\n-\n-    fn path_to_str_with_name(&self, id: NodeId, name: Name) -> String {\n-        self.with_path(id, |path| {\n-            path_to_string(path.chain(Some(PathName(name))))\n-        })\n-    }\n-\n-    fn with_path_next<T, F>(&self, id: NodeId, next: LinkedPath, f: F) -> T where\n-        F: FnOnce(PathElems) -> T,\n-    {\n-        // This function reveals the name of the item and hence is a\n-        // kind of read. This is inefficient, since it walks ancestors\n-        // and we are walking them anyhow, but whatever.\n-        self.read(id);\n-\n-        let parent = self.get_parent(id);\n-        let parent = match self.find_entry(id) {\n-            Some(EntryForeignItem(..)) => {\n-                // Anonymous extern items go in the parent scope.\n-                self.get_parent(parent)\n-            }\n-            // But tuple struct ctors don't have names, so use the path of its\n-            // parent, the struct item. Similarly with closure expressions.\n-            Some(EntryStructCtor(..)) | Some(EntryExpr(..)) => {\n-                return self.with_path_next(parent, next, f);\n-            }\n-            _ => parent\n-        };\n-        if parent == id {\n-            match self.find_entry(id) {\n-                Some(RootInlinedParent(data)) => {\n-                    f(data.path.iter().cloned().chain(next))\n-                }\n-                _ => f([].iter().cloned().chain(next))\n-            }\n-        } else {\n-            self.with_path_next(parent, LinkedPath::from(&LinkedPathNode {\n-                node: self.get_path_elem(id),\n-                next: next\n-            }), f)\n+            NodeStructCtor(_) => self.name(self.get_parent(id)),\n+            _ => bug!(\"no name for {}\", self.node_to_string(id))\n         }\n     }\n \n@@ -958,7 +821,6 @@ pub fn map_crate<'ast>(forest: &'ast mut Forest) -> Map<'ast> {\n /// Used for items loaded from external crate that are being inlined into this\n /// crate.\n pub fn map_decoded_item<'ast, F: FoldOps>(map: &Map<'ast>,\n-                                          parent_path: Vec<PathElem>,\n                                           parent_def_path: DefPath,\n                                           parent_def_id: DefId,\n                                           ii: InlinedItem,\n@@ -978,27 +840,24 @@ pub fn map_decoded_item<'ast, F: FoldOps>(map: &Map<'ast>,\n         II::Foreign(i) => II::Foreign(i.map(|i| fld.fold_foreign_item(i)))\n     };\n \n-    let ii_parent = map.forest.inlined_items.alloc(InlinedParent {\n-        path: parent_path,\n-        ii: ii\n-    });\n+    let ii = map.forest.inlined_items.alloc(ii);\n \n     let ii_parent_id = fld.new_id(DUMMY_NODE_ID);\n     let mut collector =\n         NodeCollector::extend(\n             map.krate(),\n-            ii_parent,\n+            ii,\n             ii_parent_id,\n             parent_def_path,\n             parent_def_id,\n             mem::replace(&mut *map.map.borrow_mut(), vec![]),\n             mem::replace(&mut *map.definitions.borrow_mut(), Definitions::new()));\n-    ii_parent.ii.visit(&mut collector);\n+    ii.visit(&mut collector);\n \n     *map.map.borrow_mut() = collector.map;\n     *map.definitions.borrow_mut() = collector.definitions;\n \n-    &ii_parent.ii\n+    ii\n }\n \n pub trait NodePrinter {\n@@ -1032,9 +891,24 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n     let id_str = format!(\" (id={})\", id);\n     let id_str = if include_id { &id_str[..] } else { \"\" };\n \n+    let path_str = || {\n+        // This functionality is used for debugging, try to use TyCtxt to get\n+        // the user-friendly path, otherwise fall back to stringifying DefPath.\n+        ::ty::tls::with_opt(|tcx| {\n+            if let Some(tcx) = tcx {\n+                tcx.node_path_str(id)\n+            } else if let Some(path) = map.def_path_from_id(id) {\n+                path.data.into_iter().map(|elem| {\n+                    elem.data.to_string()\n+                }).collect::<Vec<_>>().join(\"::\")\n+            } else {\n+                String::from(\"<missing path>\")\n+            }\n+        })\n+    };\n+\n     match map.find(id) {\n         Some(NodeItem(item)) => {\n-            let path_str = map.path_to_str_with_name(id, item.name);\n             let item_str = match item.node {\n                 ItemExternCrate(..) => \"extern crate\",\n                 ItemUse(..) => \"use\",\n@@ -1050,30 +924,21 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n                 ItemImpl(..) => \"impl\",\n                 ItemDefaultImpl(..) => \"default impl\",\n             };\n-            format!(\"{} {}{}\", item_str, path_str, id_str)\n+            format!(\"{} {}{}\", item_str, path_str(), id_str)\n         }\n-        Some(NodeForeignItem(item)) => {\n-            let path_str = map.path_to_str_with_name(id, item.name);\n-            format!(\"foreign item {}{}\", path_str, id_str)\n+        Some(NodeForeignItem(_)) => {\n+            format!(\"foreign item {}{}\", path_str(), id_str)\n         }\n         Some(NodeImplItem(ii)) => {\n             match ii.node {\n                 ImplItemKind::Const(..) => {\n-                    format!(\"assoc const {} in {}{}\",\n-                            ii.name,\n-                            map.path_to_string(id),\n-                            id_str)\n+                    format!(\"assoc const {} in {}{}\", ii.name, path_str(), id_str)\n                 }\n                 ImplItemKind::Method(..) => {\n-                    format!(\"method {} in {}{}\",\n-                            ii.name,\n-                            map.path_to_string(id), id_str)\n+                    format!(\"method {} in {}{}\", ii.name, path_str(), id_str)\n                 }\n                 ImplItemKind::Type(_) => {\n-                    format!(\"assoc type {} in {}{}\",\n-                            ii.name,\n-                            map.path_to_string(id),\n-                            id_str)\n+                    format!(\"assoc type {} in {}{}\", ii.name, path_str(), id_str)\n                 }\n             }\n         }\n@@ -1084,16 +949,12 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n                 TypeTraitItem(..) => \"assoc type\",\n             };\n \n-            format!(\"{} {} in {}{}\",\n-                    kind,\n-                    ti.name,\n-                    map.path_to_string(id),\n-                    id_str)\n+            format!(\"{} {} in {}{}\", kind, ti.name, path_str(), id_str)\n         }\n         Some(NodeVariant(ref variant)) => {\n             format!(\"variant {} in {}{}\",\n                     variant.node.name,\n-                    map.path_to_string(id), id_str)\n+                    path_str(), id_str)\n         }\n         Some(NodeExpr(ref expr)) => {\n             format!(\"expr {}{}\", pprust::expr_to_string(&expr), id_str)\n@@ -1111,7 +972,7 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n             format!(\"block {}{}\", pprust::block_to_string(&block), id_str)\n         }\n         Some(NodeStructCtor(_)) => {\n-            format!(\"struct_ctor {}{}\", map.path_to_string(id), id_str)\n+            format!(\"struct_ctor {}{}\", path_str(), id_str)\n         }\n         Some(NodeLifetime(ref l)) => {\n             format!(\"lifetime {}{}\","}, {"sha": "6cc5a29062fd000e5730326a1f8ead1c7a88fb45", "filename": "src/librustc/hir/pat_util.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e8a8dfb056fb3654bacd6aaa6acbc4536358df23/src%2Flibrustc%2Fhir%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a8dfb056fb3654bacd6aaa6acbc4536358df23/src%2Flibrustc%2Fhir%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fpat_util.rs?ref=e8a8dfb056fb3654bacd6aaa6acbc4536358df23", "patch": "@@ -210,14 +210,8 @@ pub fn simple_name<'a>(pat: &'a hir::Pat) -> Option<ast::Name> {\n }\n \n pub fn def_to_path(tcx: &TyCtxt, id: DefId) -> hir::Path {\n-    tcx.with_path(id, |path| hir::Path {\n-        global: false,\n-        segments: path.last().map(|elem| hir::PathSegment {\n-            identifier: hir::Ident::from_name(elem.name()),\n-            parameters: hir::PathParameters::none(),\n-        }).into_iter().collect(),\n-        span: DUMMY_SP,\n-    })\n+    let name = tcx.item_name(id);\n+    hir::Path::from_ident(DUMMY_SP, hir::Ident::from_name(name))\n }\n \n /// Return variants that are necessary to exist for the pattern to match."}, {"sha": "a7553f4eb1f1cbed2a7dec545052f411789eb365", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e8a8dfb056fb3654bacd6aaa6acbc4536358df23/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a8dfb056fb3654bacd6aaa6acbc4536358df23/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=e8a8dfb056fb3654bacd6aaa6acbc4536358df23", "patch": "@@ -587,13 +587,9 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n             // Only external crates, if either is from a local\n             // module we could have false positives\n             if !(did1.is_local() || did2.is_local()) && did1.krate != did2.krate {\n-                let exp_path = self.tcx.with_path(did1,\n-                                                  |p| p.map(|x| x.to_string())\n-                                                       .collect::<Vec<_>>());\n-                let found_path = self.tcx.with_path(did2,\n-                                                    |p| p.map(|x| x.to_string())\n-                                                         .collect::<Vec<_>>());\n-                // We compare strings because PathMod and PathName can be different\n+                let exp_path = self.tcx.item_path_str(did1);\n+                let found_path = self.tcx.item_path_str(did2);\n+                // We compare strings because DefPath can be different\n                 // for imported and non-imported crates\n                 if exp_path == found_path {\n                     let crate_name = self.tcx.sess.cstore.crate_name(did1.krate);"}, {"sha": "1f6328187a59bebbbd5ad8848b745398cb034a37", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e8a8dfb056fb3654bacd6aaa6acbc4536358df23/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a8dfb056fb3654bacd6aaa6acbc4536358df23/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=e8a8dfb056fb3654bacd6aaa6acbc4536358df23", "patch": "@@ -166,9 +166,7 @@ pub trait CrateStore<'tcx> : Any {\n     fn repr_attrs(&self, def: DefId) -> Vec<attr::ReprAttr>;\n     fn item_type(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n                  -> ty::TypeScheme<'tcx>;\n-    fn relative_item_path(&self, def: DefId) -> Vec<hir_map::PathElem>;\n     fn visible_parent_map<'a>(&'a self) -> ::std::cell::RefMut<'a, DefIdMap<DefId>>;\n-    fn extern_item_path(&self, def: DefId) -> Vec<hir_map::PathElem>;\n     fn item_name(&self, def: DefId) -> ast::Name;\n     fn item_predicates(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n                        -> ty::GenericPredicates<'tcx>;\n@@ -345,12 +343,9 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn repr_attrs(&self, def: DefId) -> Vec<attr::ReprAttr> { bug!(\"repr_attrs\") }\n     fn item_type(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n                  -> ty::TypeScheme<'tcx> { bug!(\"item_type\") }\n-    fn relative_item_path(&self, def: DefId)\n-                          -> Vec<hir_map::PathElem> { bug!(\"relative_item_path\") }\n     fn visible_parent_map<'a>(&'a self) -> ::std::cell::RefMut<'a, DefIdMap<DefId>> {\n         bug!(\"visible_parent_map\")\n     }\n-    fn extern_item_path(&self, def: DefId) -> Vec<hir_map::PathElem> { bug!(\"extern_item_path\") }\n     fn item_name(&self, def: DefId) -> ast::Name { bug!(\"item_name\") }\n     fn item_predicates(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n                        -> ty::GenericPredicates<'tcx> { bug!(\"item_predicates\") }"}, {"sha": "5c1e19aee7b84d0b38fba018e64e6cac6ba365bc", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e8a8dfb056fb3654bacd6aaa6acbc4536358df23/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a8dfb056fb3654bacd6aaa6acbc4536358df23/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=e8a8dfb056fb3654bacd6aaa6acbc4536358df23", "patch": "@@ -24,6 +24,11 @@ impl<'tcx> TyCtxt<'tcx> {\n         buffer.into_string()\n     }\n \n+    /// Returns a string identifying this local node-id.\n+    pub fn node_path_str(&self, id: ast::NodeId) -> String {\n+        self.item_path_str(self.map.local_def_id(id))\n+    }\n+\n     /// Returns a string identifying this def-id. This string is\n     /// suitable for user output. It always begins with a crate identifier.\n     pub fn absolute_item_path_str(&self, def_id: DefId) -> String {"}, {"sha": "444fea0918f8d2615d4801fb591ce659150d02da", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 32, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e8a8dfb056fb3654bacd6aaa6acbc4536358df23/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a8dfb056fb3654bacd6aaa6acbc4536358df23/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=e8a8dfb056fb3654bacd6aaa6acbc4536358df23", "patch": "@@ -20,7 +20,6 @@ pub use self::fold::TypeFoldable;\n \n use dep_graph::{self, DepNode};\n use hir::map as ast_map;\n-use hir::map::LinkedPath;\n use middle;\n use middle::cstore::{self, CrateStore, LOCAL_CRATE};\n use hir::def::{self, Def, ExportMap};\n@@ -2231,39 +2230,9 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    pub fn with_path<T, F>(&self, id: DefId, f: F) -> T where\n-        F: FnOnce(ast_map::PathElems) -> T,\n-    {\n-        if let Some(id) = self.map.as_local_node_id(id) {\n-            self.map.with_path(id, f)\n-        } else {\n-            let mut path: Vec<_>;\n-            if let Some(extern_crate) = self.sess.cstore.extern_crate(id.krate) {\n-                if !extern_crate.direct {\n-                    // this comes from some crate that we don't have a direct\n-                    // path to; we'll settle for just prepending the name of\n-                    // the crate.\n-                    path = self.sess.cstore.extern_item_path(id)\n-                } else {\n-                    // start with the path to the extern crate, then\n-                    // add the relative path to the actual item\n-                    fn collector(elems: ast_map::PathElems) -> Vec<ast_map::PathElem> {\n-                        elems.collect()\n-                    }\n-                    path = self.with_path(extern_crate.def_id, collector);\n-                    path.extend(self.sess.cstore.relative_item_path(id));\n-                }\n-            } else {\n-                // if this was injected, just make a path with name of crate\n-                path = self.sess.cstore.extern_item_path(id);\n-            }\n-            f(path.iter().cloned().chain(LinkedPath::empty()))\n-        }\n-    }\n-\n     pub fn item_name(&self, id: DefId) -> ast::Name {\n         if let Some(id) = self.map.as_local_node_id(id) {\n-            self.map.get_path_elem(id).name()\n+            self.map.name(id)\n         } else {\n             self.sess.cstore.item_name(id)\n         }"}, {"sha": "cde5ba19859e03fa99d9c66681ddf331302abed2", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e8a8dfb056fb3654bacd6aaa6acbc4536358df23/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a8dfb056fb3654bacd6aaa6acbc4536358df23/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=e8a8dfb056fb3654bacd6aaa6acbc4536358df23", "patch": "@@ -256,6 +256,15 @@ trait HirPrinterSupport<'ast>: pprust_hir::PpAnn {\n     /// (Rust does not yet support upcasting from a trait object to\n     /// an object for one of its super-traits.)\n     fn pp_ann<'a>(&'a self) -> &'a pprust_hir::PpAnn;\n+\n+    /// Computes an user-readable representation of a path, if possible.\n+    fn node_path(&self, id: ast::NodeId) -> Option<String> {\n+        self.ast_map().and_then(|map| map.def_path_from_id(id)).map(|path| {\n+            path.data.into_iter().map(|elem| {\n+                elem.data.to_string()\n+            }).collect::<Vec<_>>().join(\"::\")\n+        })\n+    }\n }\n \n struct NoAnn<'ast> {\n@@ -452,6 +461,10 @@ impl<'b, 'tcx> HirPrinterSupport<'tcx> for TypedAnnotation<'b, 'tcx> {\n     fn pp_ann<'a>(&'a self) -> &'a pprust_hir::PpAnn {\n         self\n     }\n+\n+    fn node_path(&self, id: ast::NodeId) -> Option<String> {\n+        Some(self.tcx.node_path_str(id))\n+    }\n }\n \n impl<'a, 'tcx> pprust_hir::PpAnn for TypedAnnotation<'a, 'tcx> {\n@@ -794,7 +807,7 @@ pub fn pretty_print_input(sess: Session,\n                                        |annotation, (out,uii), _| {\n                 debug!(\"pretty printing source code {:?}\", s);\n                 let sess = annotation.sess();\n-                let ast_map = annotation.ast_map().expect(\"--pretty missing ast_map\");\n+                let ast_map = annotation.ast_map().expect(\"--unpretty missing HIR map\");\n                 let mut pp_state =\n                     pprust_hir::State::new_from_input(sess.codemap(),\n                                                       sess.diagnostic(),\n@@ -808,7 +821,9 @@ pub fn pretty_print_input(sess: Session,\n                     let node = ast_map.get(node_id);\n                     pp_state.print_node(&node)?;\n                     pp::space(&mut pp_state.s)?;\n-                    pp_state.synth_comment(ast_map.path_to_string(node_id))?;\n+                    let path = annotation.node_path(node_id)\n+                                         .expect(\"--unpretty missing node paths\");\n+                    pp_state.synth_comment(path)?;\n                     pp::hardbreak(&mut pp_state.s)?;\n                 }\n                 pp::eof(&mut pp_state.s)"}, {"sha": "5e3a47701ebbfb767a61f5960fcd4f86317df1e8", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e8a8dfb056fb3654bacd6aaa6acbc4536358df23/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a8dfb056fb3654bacd6aaa6acbc4536358df23/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=e8a8dfb056fb3654bacd6aaa6acbc4536358df23", "patch": "@@ -1087,10 +1087,7 @@ impl LateLintPass for MutableTransmutes {\n                 ty::TyFnDef(_, _, ref bfty) if bfty.abi == RustIntrinsic => (),\n                 _ => return false\n             }\n-            cx.tcx.with_path(def_id, |path| match path.last() {\n-                Some(ref last) => last.name().as_str() == \"transmute\",\n-                _ => false\n-            })\n+            cx.tcx.item_name(def_id).as_str() == \"transmute\"\n         }\n     }\n }"}, {"sha": "6fd9f27f0fb9fb9567911e01f0cb1ee5b07858b9", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e8a8dfb056fb3654bacd6aaa6acbc4536358df23/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a8dfb056fb3654bacd6aaa6acbc4536358df23/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=e8a8dfb056fb3654bacd6aaa6acbc4536358df23", "patch": "@@ -85,7 +85,7 @@ pub fn encode_inlined_item(ecx: &e::EncodeContext,\n         InlinedItemRef::ImplItem(_, ii) => ii.id,\n     };\n     debug!(\"> Encoding inlined item: {} ({:?})\",\n-           ecx.tcx.map.path_to_string(id),\n+           ecx.tcx.node_path_str(id),\n            rbml_w.writer.seek(SeekFrom::Current(0)));\n \n     // Folding could be avoided with a smarter encoder.\n@@ -99,7 +99,7 @@ pub fn encode_inlined_item(ecx: &e::EncodeContext,\n     rbml_w.end_tag();\n \n     debug!(\"< Encoded inlined fn: {} ({:?})\",\n-           ecx.tcx.map.path_to_string(id),\n+           ecx.tcx.node_path_str(id),\n            rbml_w.writer.seek(SeekFrom::Current(0)));\n }\n \n@@ -124,20 +124,12 @@ impl<'a, 'b, 'c, 'tcx> ast_map::FoldOps for &'a DecodeContext<'b, 'c, 'tcx> {\n /// ast-map.\n pub fn decode_inlined_item<'tcx>(cdata: &cstore::crate_metadata,\n                                  tcx: &TyCtxt<'tcx>,\n-                                 parent_path: Vec<ast_map::PathElem>,\n                                  parent_def_path: ast_map::DefPath,\n                                  parent_did: DefId,\n                                  ast_doc: rbml::Doc,\n                                  orig_did: DefId)\n                                  -> &'tcx InlinedItem {\n-    let mut path_as_str = None;\n-    debug!(\"> Decoding inlined fn: {:?}::?\",\n-    {\n-        // Do an Option dance to use the path after it is moved below.\n-        let s = ast_map::path_to_string(parent_path.iter().cloned());\n-        path_as_str = Some(s);\n-        path_as_str.as_ref().map(|x| &x[..])\n-    });\n+    debug!(\"> Decoding inlined fn: {:?}\", tcx.item_path_str(orig_did));\n     let mut ast_dsr = reader::Decoder::new(ast_doc);\n     let from_id_range = Decodable::decode(&mut ast_dsr).unwrap();\n     let to_id_range = reserve_id_range(&tcx.sess, from_id_range);\n@@ -149,7 +141,6 @@ pub fn decode_inlined_item<'tcx>(cdata: &cstore::crate_metadata,\n         last_filemap_index: Cell::new(0)\n     };\n     let ii = ast_map::map_decoded_item(&dcx.tcx.map,\n-                                       parent_path,\n                                        parent_def_path,\n                                        parent_did,\n                                        decode_ast(ast_doc),\n@@ -162,7 +153,7 @@ pub fn decode_inlined_item<'tcx>(cdata: &cstore::crate_metadata,\n     };\n     debug!(\"Fn named: {}\", name);\n     debug!(\"< Decoded inlined fn: {}::{}\",\n-            path_as_str.unwrap(),\n+            tcx.item_path_str(parent_did),\n             name);\n     region::resolve_inlined_item(&tcx.sess, &tcx.region_maps, ii);\n     decode_side_tables(dcx, ast_doc);"}, {"sha": "ea4e25754202c7ff23466d0a135306355bd70830", "filename": "src/librustc_metadata/common.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e8a8dfb056fb3654bacd6aaa6acbc4536358df23/src%2Flibrustc_metadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a8dfb056fb3654bacd6aaa6acbc4536358df23/src%2Flibrustc_metadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcommon.rs?ref=e8a8dfb056fb3654bacd6aaa6acbc4536358df23", "patch": "@@ -86,13 +86,10 @@ pub const tag_item_trait_ref: usize = 0x3b;\n // discriminator value for variants\n pub const tag_disr_val: usize = 0x3c;\n \n-// used to encode ast_map::PathElem\n-pub const tag_path: usize = 0x3d;\n-pub const tag_path_len: usize = 0x3e;\n-pub const tag_path_elem_mod: usize = 0x3f;\n-pub const tag_path_elem_name: usize = 0x40;\n-pub const tag_item_field: usize = 0x41;\n+// GAP 0x3d, 0x3e, 0x3f, 0x40\n \n+pub const tag_item_field: usize = 0x41;\n+// GAP 0x42\n pub const tag_item_variances: usize = 0x43;\n /*\n   trait items contain tag_item_trait_item elements,"}, {"sha": "0b90ad5b4e27695bef5708994d94cbf6ed218f8f", "filename": "src/librustc_metadata/csearch.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e8a8dfb056fb3654bacd6aaa6acbc4536358df23/src%2Flibrustc_metadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a8dfb056fb3654bacd6aaa6acbc4536358df23/src%2Flibrustc_metadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcsearch.rs?ref=e8a8dfb056fb3654bacd6aaa6acbc4536358df23", "patch": "@@ -128,22 +128,6 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         decoder::get_method_arg_names(&cdata, did.index)\n     }\n \n-    fn relative_item_path(&self, def: DefId) -> Vec<hir_map::PathElem> {\n-        let cdata = self.get_crate_data(def.krate);\n-        decoder::get_item_path(&cdata, def.index)\n-    }\n-\n-    fn extern_item_path(&self, def: DefId) -> Vec<hir_map::PathElem> {\n-        let cdata = self.get_crate_data(def.krate);\n-        let path = decoder::get_item_path(&cdata, def.index);\n-\n-        let mut r = Vec::with_capacity(path.len() + 1);\n-        let crate_name = hir_map::PathMod(token::intern(&cdata.name));\n-        r.push(crate_name);\n-        r.extend_from_slice(&path);\n-        r\n-    }\n-\n     fn item_name(&self, def: DefId) -> ast::Name {\n         let cdata = self.get_crate_data(def.krate);\n         decoder::get_item_name(&self.intr, &cdata, def.index)"}, {"sha": "6b53edbbff1d89c8a30bec7aeb5a1a9251189fe3", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e8a8dfb056fb3654bacd6aaa6acbc4536358df23/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a8dfb056fb3654bacd6aaa6acbc4536358df23/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=e8a8dfb056fb3654bacd6aaa6acbc4536358df23", "patch": "@@ -255,22 +255,6 @@ fn item_trait_ref<'tcx>(doc: rbml::Doc, tcx: &TyCtxt<'tcx>, cdata: Cmd)\n     doc_trait_ref(tp, tcx, cdata)\n }\n \n-fn item_path(item_doc: rbml::Doc) -> Vec<hir_map::PathElem> {\n-    let path_doc = reader::get_doc(item_doc, tag_path);\n-    reader::docs(path_doc).filter_map(|(tag, elt_doc)| {\n-        if tag == tag_path_elem_mod {\n-            let s = elt_doc.as_str_slice();\n-            Some(hir_map::PathMod(token::intern(s)))\n-        } else if tag == tag_path_elem_name {\n-            let s = elt_doc.as_str_slice();\n-            Some(hir_map::PathName(token::intern(s)))\n-        } else {\n-            // ignore tag_path_len element\n-            None\n-        }\n-    }).collect()\n-}\n-\n fn item_name(intr: &IdentInterner, item: rbml::Doc) -> ast::Name {\n     let name = reader::get_doc(item, tag_paths_data_name);\n     let string = name.as_str_slice();\n@@ -786,10 +770,6 @@ pub fn each_top_level_item_of_crate<F, G>(intr: Rc<IdentInterner>,\n                                 callback)\n }\n \n-pub fn get_item_path(cdata: Cmd, id: DefIndex) -> Vec<hir_map::PathElem> {\n-    item_path(cdata.lookup_item(id))\n-}\n-\n pub fn get_item_name(intr: &IdentInterner, cdata: Cmd, id: DefIndex) -> ast::Name {\n     item_name(intr, cdata.lookup_item(id))\n }\n@@ -803,14 +783,11 @@ pub fn maybe_get_item_ast<'tcx>(cdata: Cmd, tcx: &TyCtxt<'tcx>, id: DefIndex)\n         krate: cdata.cnum,\n         index: def_key(cdata, id).parent.unwrap()\n     };\n-    let mut parent_path = item_path(item_doc);\n-    parent_path.pop();\n     let mut parent_def_path = def_path(cdata, id);\n     parent_def_path.data.pop();\n     if let Some(ast_doc) = reader::maybe_get_doc(item_doc, tag_ast as usize) {\n         let ii = decode_inlined_item(cdata,\n                                      tcx,\n-                                     parent_path,\n                                      parent_def_path,\n                                      parent_def_id,\n                                      ast_doc,\n@@ -823,15 +800,12 @@ pub fn maybe_get_item_ast<'tcx>(cdata: Cmd, tcx: &TyCtxt<'tcx>, id: DefIndex)\n             krate: cdata.cnum,\n             index: def_key(cdata, parent_def_id.index).parent.unwrap()\n         };\n-        let mut grandparent_path = parent_path;\n-        grandparent_path.pop();\n         let mut grandparent_def_path = parent_def_path;\n         grandparent_def_path.data.pop();\n         let parent_doc = cdata.lookup_item(parent_did.index);\n         if let Some(ast_doc) = reader::maybe_get_doc(parent_doc, tag_ast as usize) {\n             let ii = decode_inlined_item(cdata,\n                                          tcx,\n-                                         grandparent_path,\n                                          grandparent_def_path,\n                                          grandparent_def_id,\n                                          ast_doc,"}, {"sha": "d45650159e3c82b6d2a77a5394a0c1dddbf95231", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 7, "deletions": 94, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/e8a8dfb056fb3654bacd6aaa6acbc4536358df23/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a8dfb056fb3654bacd6aaa6acbc4536358df23/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=e8a8dfb056fb3654bacd6aaa6acbc4536358df23", "patch": "@@ -31,8 +31,6 @@ use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::util::IntTypeExt;\n \n use rustc::hir::svh::Svh;\n-use rustc::hir::map::{LinkedPath, PathElem, PathElems};\n-use rustc::hir::map as ast_map;\n use rustc::mir::mir_map::MirMap;\n use rustc::session::config;\n use rustc::util::nodemap::{FnvHashMap, NodeMap, NodeSet};\n@@ -300,26 +298,11 @@ fn encode_enum_variant_info<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         }\n         encode_bounds_and_type_for_item(rbml_w, ecx, index, variant_node_id);\n \n-        ecx.tcx.map.with_path(variant_node_id, |path| encode_path(rbml_w, path));\n         rbml_w.end_tag();\n         disr_val = disr_val.wrap_incr();\n     }\n }\n \n-fn encode_path<PI: Iterator<Item=PathElem>>(rbml_w: &mut Encoder, path: PI) {\n-    let path = path.collect::<Vec<_>>();\n-    rbml_w.start_tag(tag_path);\n-    rbml_w.wr_tagged_u32(tag_path_len, path.len() as u32);\n-    for pe in &path {\n-        let tag = match *pe {\n-            ast_map::PathMod(_) => tag_path_elem_mod,\n-            ast_map::PathName(_) => tag_path_elem_name\n-        };\n-        rbml_w.wr_tagged_str(tag, &pe.name().as_str());\n-    }\n-    rbml_w.end_tag();\n-}\n-\n /// Iterates through \"auxiliary node IDs\", which are node IDs that describe\n /// top-level items that are sub-items of the given item. Specifically:\n ///\n@@ -371,7 +354,6 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n                        md: &hir::Mod,\n                        attrs: &[ast::Attribute],\n                        id: NodeId,\n-                       path: PathElems,\n                        name: Name,\n                        vis: hir::Visibility) {\n     rbml_w.start_tag(tag_items_data_item);\n@@ -393,7 +375,6 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n         });\n     }\n \n-    encode_path(rbml_w, path.clone());\n     encode_visibility(rbml_w, vis);\n \n     let stab = stability::lookup_stability(ecx.tcx, ecx.tcx.map.local_def_id(id));\n@@ -521,7 +502,6 @@ fn encode_info_for_struct_ctor<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     });\n     encode_bounds_and_type_for_item(rbml_w, ecx, index, ctor_id);\n     encode_name(rbml_w, name);\n-    ecx.tcx.map.with_path(ctor_id, |path| encode_path(rbml_w, path));\n     encode_parent_item(rbml_w, ecx.tcx.map.local_def_id(struct_id));\n \n     if ecx.item_symbols.borrow().contains_key(&ctor_id) {\n@@ -637,7 +617,6 @@ fn encode_info_for_associated_const<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                               rbml_w: &mut Encoder,\n                                               index: &mut CrateIndex<'tcx>,\n                                               associated_const: &ty::AssociatedConst,\n-                                              impl_path: PathElems,\n                                               parent_id: NodeId,\n                                               impl_item_opt: Option<&hir::ImplItem>) {\n     debug!(\"encode_info_for_associated_const({:?},{:?})\",\n@@ -663,9 +642,6 @@ fn encode_info_for_associated_const<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     encode_stability(rbml_w, stab);\n     encode_deprecation(rbml_w, depr);\n \n-    let elem = ast_map::PathName(associated_const.name);\n-    encode_path(rbml_w, impl_path.chain(Some(elem)));\n-\n     if let Some(ii) = impl_item_opt {\n         encode_attributes(rbml_w, &ii.attrs);\n         encode_defaultness(rbml_w, ii.defaultness);\n@@ -683,7 +659,6 @@ fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                     rbml_w: &mut Encoder,\n                                     index: &mut CrateIndex<'tcx>,\n                                     m: &ty::Method<'tcx>,\n-                                    impl_path: PathElems,\n                                     is_default_impl: bool,\n                                     parent_id: NodeId,\n                                     impl_item_opt: Option<&hir::ImplItem>) {\n@@ -705,8 +680,6 @@ fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     let m_node_id = ecx.local_id(m.def_id);\n     encode_bounds_and_type_for_item(rbml_w, ecx, index, m_node_id);\n \n-    let elem = ast_map::PathName(m.name);\n-    encode_path(rbml_w, impl_path.chain(Some(elem)));\n     if let Some(impl_item) = impl_item_opt {\n         if let hir::ImplItemKind::Method(ref sig, _) = impl_item.node {\n             encode_attributes(rbml_w, &impl_item.attrs);\n@@ -738,7 +711,6 @@ fn encode_info_for_associated_type<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                              rbml_w: &mut Encoder,\n                                              index: &mut CrateIndex<'tcx>,\n                                              associated_type: &ty::AssociatedType<'tcx>,\n-                                             impl_path: PathElems,\n                                              parent_id: NodeId,\n                                              impl_item_opt: Option<&hir::ImplItem>) {\n     debug!(\"encode_info_for_associated_type({:?},{:?})\",\n@@ -760,9 +732,6 @@ fn encode_info_for_associated_type<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     encode_stability(rbml_w, stab);\n     encode_deprecation(rbml_w, depr);\n \n-    let elem = ast_map::PathName(associated_type.name);\n-    encode_path(rbml_w, impl_path.chain(Some(elem)));\n-\n     if let Some(ii) = impl_item_opt {\n         encode_attributes(rbml_w, &ii.attrs);\n         encode_defaultness(rbml_w, ii.defaultness);\n@@ -886,14 +855,13 @@ fn encode_xrefs<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                   rbml_w: &mut Encoder,\n                                   item: &hir::Item,\n-                                  index: &mut CrateIndex<'tcx>,\n-                                  path: PathElems,\n-                                  vis: hir::Visibility) {\n+                                  index: &mut CrateIndex<'tcx>) {\n     let tcx = ecx.tcx;\n \n     debug!(\"encoding info for item at {}\",\n            tcx.sess.codemap().span_to_string(item.span));\n \n+    let vis = item.vis;\n     let def_id = ecx.tcx.map.local_def_id(item.id);\n     let stab = stability::lookup_stability(tcx, ecx.tcx.map.local_def_id(item.id));\n     let depr = stability::lookup_deprecation(tcx, ecx.tcx.map.local_def_id(item.id));\n@@ -911,7 +879,6 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         encode_bounds_and_type_for_item(rbml_w, ecx, index, item.id);\n         encode_symbol(ecx, rbml_w, item.id);\n         encode_name(rbml_w, item.name);\n-        encode_path(rbml_w, path);\n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n         encode_deprecation(rbml_w, depr);\n@@ -925,7 +892,6 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         encode_family(rbml_w, 'C');\n         encode_bounds_and_type_for_item(rbml_w, ecx, index, item.id);\n         encode_name(rbml_w, item.name);\n-        encode_path(rbml_w, path);\n         encode_attributes(rbml_w, &item.attrs);\n         encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(item));\n         encode_mir(ecx, rbml_w, item.id);\n@@ -942,7 +908,6 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         let tps_len = generics.ty_params.len();\n         encode_bounds_and_type_for_item(rbml_w, ecx, index, item.id);\n         encode_name(rbml_w, item.name);\n-        encode_path(rbml_w, path);\n         encode_attributes(rbml_w, &item.attrs);\n         let needs_inline = tps_len > 0 || attr::requests_inline(&item.attrs);\n         if needs_inline || constness == hir::Constness::Const {\n@@ -966,7 +931,6 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                             m,\n                             &item.attrs,\n                             item.id,\n-                            path,\n                             item.name,\n                             item.vis);\n       }\n@@ -976,7 +940,6 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         encode_def_id_and_key(ecx, rbml_w, def_id);\n         encode_family(rbml_w, 'n');\n         encode_name(rbml_w, item.name);\n-        encode_path(rbml_w, path);\n \n         // Encode all the items in this module.\n         for foreign_item in &fm.items {\n@@ -995,7 +958,6 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         encode_family(rbml_w, 'y');\n         encode_bounds_and_type_for_item(rbml_w, ecx, index, item.id);\n         encode_name(rbml_w, item.name);\n-        encode_path(rbml_w, path);\n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n         encode_deprecation(rbml_w, depr);\n@@ -1017,7 +979,6 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         }\n         encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(item));\n         encode_mir(ecx, rbml_w, item.id);\n-        encode_path(rbml_w, path);\n \n         // Encode inherent implementations for this enumeration.\n         encode_inherent_implementations(ecx, rbml_w, def_id);\n@@ -1053,7 +1014,6 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         encode_item_variances(rbml_w, ecx, item.id);\n         encode_name(rbml_w, item.name);\n         encode_attributes(rbml_w, &item.attrs);\n-        encode_path(rbml_w, path.clone());\n         encode_stability(rbml_w, stab);\n         encode_deprecation(rbml_w, depr);\n         encode_visibility(rbml_w, vis);\n@@ -1156,7 +1116,6 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                 });\n             encode_parent_impl(rbml_w, parent);\n         }\n-        encode_path(rbml_w, path.clone());\n         encode_stability(rbml_w, stab);\n         encode_deprecation(rbml_w, depr);\n         rbml_w.end_tag();\n@@ -1179,7 +1138,6 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                                      rbml_w,\n                                                      index,\n                                                      &associated_const,\n-                                                     path.clone(),\n                                                      item.id,\n                                                      ast_item)\n                 }\n@@ -1188,7 +1146,6 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                            rbml_w,\n                                            index,\n                                            &method_type,\n-                                           path.clone(),\n                                            false,\n                                            item.id,\n                                            ast_item)\n@@ -1198,7 +1155,6 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                                     rbml_w,\n                                                     index,\n                                                     &associated_type,\n-                                                    path.clone(),\n                                                     item.id,\n                                                     ast_item)\n                 }\n@@ -1250,7 +1206,6 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n             rbml_w.wr_tagged_u64(tag_mod_child,\n                                  def_to_u64(method_def_id.def_id()));\n         }\n-        encode_path(rbml_w, path.clone());\n \n         // Encode inherent implementations for this trait.\n         encode_inherent_implementations(ecx, rbml_w, def_id);\n@@ -1281,10 +1236,6 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                     encode_def_id_and_key(ecx, rbml_w, associated_const.def_id);\n                     encode_visibility(rbml_w, associated_const.vis);\n \n-                    let elem = ast_map::PathName(associated_const.name);\n-                    encode_path(rbml_w,\n-                                path.clone().chain(Some(elem)));\n-\n                     encode_family(rbml_w, 'C');\n \n                     encode_bounds_and_type_for_item(rbml_w, ecx, index,\n@@ -1297,10 +1248,6 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n \n                     encode_method_ty_fields(ecx, rbml_w, index, &method_ty);\n \n-                    let elem = ast_map::PathName(method_ty.name);\n-                    encode_path(rbml_w,\n-                                path.clone().chain(Some(elem)));\n-\n                     match method_ty.explicit_self {\n                         ty::ExplicitSelfCategory::Static => {\n                             encode_family(rbml_w,\n@@ -1320,11 +1267,6 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                 ty::TypeTraitItem(associated_type) => {\n                     encode_name(rbml_w, associated_type.name);\n                     encode_def_id_and_key(ecx, rbml_w, associated_type.def_id);\n-\n-                    let elem = ast_map::PathName(associated_type.name);\n-                    encode_path(rbml_w,\n-                                path.clone().chain(Some(elem)));\n-\n                     encode_item_sort(rbml_w, 't');\n                     encode_family(rbml_w, 'y');\n \n@@ -1386,10 +1328,10 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n fn encode_info_for_foreign_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                           rbml_w: &mut Encoder,\n                                           nitem: &hir::ForeignItem,\n-                                          index: &mut CrateIndex<'tcx>,\n-                                          path: PathElems,\n-                                          abi: Abi) {\n+                                          index: &mut CrateIndex<'tcx>) {\n+    debug!(\"writing foreign item {}\", ecx.tcx.node_path_str(nitem.id));\n     let def_id = ecx.tcx.map.local_def_id(nitem.id);\n+    let abi = ecx.tcx.map.get_foreign_abi(nitem.id);\n \n     index.record(def_id, rbml_w);\n     rbml_w.start_tag(tag_items_data_item);\n@@ -1429,7 +1371,6 @@ fn encode_info_for_foreign_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         encode_name(rbml_w, nitem.name);\n       }\n     }\n-    encode_path(rbml_w, path);\n     rbml_w.end_tag();\n }\n \n@@ -1454,8 +1395,6 @@ fn my_visit_expr(expr: &hir::Expr,\n             ecx.tcx.closure_kind(def_id).encode(rbml_w).unwrap();\n             rbml_w.end_tag();\n \n-            ecx.tcx.map.with_path(expr.id, |path| encode_path(rbml_w, path));\n-\n             assert!(ecx.mir_map.map.contains_key(&expr.id));\n             encode_mir(ecx, rbml_w, expr.id);\n \n@@ -1465,31 +1404,6 @@ fn my_visit_expr(expr: &hir::Expr,\n     }\n }\n \n-fn my_visit_item<'a, 'tcx>(i: &hir::Item,\n-                           rbml_w: &mut Encoder,\n-                           ecx: &EncodeContext<'a, 'tcx>,\n-                           index: &mut CrateIndex<'tcx>) {\n-    ecx.tcx.map.with_path(i.id, |path| {\n-        encode_info_for_item(ecx, rbml_w, i, index, path, i.vis);\n-    });\n-}\n-\n-fn my_visit_foreign_item<'a, 'tcx>(ni: &hir::ForeignItem,\n-                                   rbml_w: &mut Encoder,\n-                                   ecx: &EncodeContext<'a, 'tcx>,\n-                                   index: &mut CrateIndex<'tcx>) {\n-    debug!(\"writing foreign item {}::{}\",\n-            ecx.tcx.map.path_to_string(ni.id),\n-            ni.name);\n-\n-    let abi = ecx.tcx.map.get_foreign_abi(ni.id);\n-    ecx.tcx.map.with_path(ni.id, |path| {\n-        encode_info_for_foreign_item(ecx, rbml_w,\n-                                     ni, index,\n-                                     path, abi);\n-    });\n-}\n-\n struct EncodeVisitor<'a, 'b:'a, 'c:'a, 'tcx:'c> {\n     rbml_w_for_visit_item: &'a mut Encoder<'b>,\n     ecx: &'a EncodeContext<'c,'tcx>,\n@@ -1503,11 +1417,11 @@ impl<'a, 'b, 'c, 'tcx> Visitor<'tcx> for EncodeVisitor<'a, 'b, 'c, 'tcx> {\n     }\n     fn visit_item(&mut self, i: &'tcx hir::Item) {\n         intravisit::walk_item(self, i);\n-        my_visit_item(i, self.rbml_w_for_visit_item, self.ecx, self.index);\n+        encode_info_for_item(self.ecx, self.rbml_w_for_visit_item, i, self.index);\n     }\n     fn visit_foreign_item(&mut self, ni: &'tcx hir::ForeignItem) {\n         intravisit::walk_foreign_item(self, ni);\n-        my_visit_foreign_item(ni, self.rbml_w_for_visit_item, self.ecx, self.index);\n+        encode_info_for_foreign_item(self.ecx, self.rbml_w_for_visit_item, ni, self.index);\n     }\n }\n \n@@ -1528,7 +1442,6 @@ fn encode_info_for_items<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                         &krate.module,\n                         &[],\n                         CRATE_NODE_ID,\n-                        [].iter().cloned().chain(LinkedPath::empty()),\n                         syntax::parse::token::intern(&ecx.link_meta.crate_name),\n                         hir::Public);\n "}, {"sha": "069bd7826bcdc1fc9dca1453dd72cd9b3b08082f", "filename": "src/librustc_mir/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8a8dfb056fb3654bacd6aaa6acbc4536358df23/src%2Flibrustc_mir%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a8dfb056fb3654bacd6aaa6acbc4536358df23/src%2Flibrustc_mir%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fgraphviz.rs?ref=e8a8dfb056fb3654bacd6aaa6acbc4536358df23", "patch": "@@ -118,7 +118,7 @@ fn write_edges<W: Write>(source: BasicBlock, mir: &Mir, w: &mut W) -> io::Result\n /// all the variables and temporaries.\n fn write_graph_label<W: Write>(tcx: &ty::TyCtxt, nid: NodeId, mir: &Mir, w: &mut W)\n -> io::Result<()> {\n-    write!(w, \"    label=<fn {}(\", dot::escape_html(&tcx.map.path_to_string(nid)))?;\n+    write!(w, \"    label=<fn {}(\", dot::escape_html(&tcx.node_path_str(nid)))?;\n \n     // fn argument types.\n     for (i, arg) in mir.arg_decls.iter().enumerate() {"}, {"sha": "d0c66b340d96e28c1a804b8d870a6c3719284a91", "filename": "src/librustc_mir/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8a8dfb056fb3654bacd6aaa6acbc4536358df23/src%2Flibrustc_mir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a8dfb056fb3654bacd6aaa6acbc4536358df23/src%2Flibrustc_mir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fpretty.rs?ref=e8a8dfb056fb3654bacd6aaa6acbc4536358df23", "patch": "@@ -216,7 +216,7 @@ fn write_scope_tree(tcx: &TyCtxt,\n /// local variables (both user-defined bindings and compiler temporaries).\n fn write_mir_intro(tcx: &TyCtxt, nid: NodeId, mir: &Mir, w: &mut Write)\n                    -> io::Result<()> {\n-    write!(w, \"fn {}(\", tcx.map.path_to_string(nid))?;\n+    write!(w, \"fn {}(\", tcx.node_path_str(nid))?;\n \n     // fn argument types.\n     for (i, arg) in mir.arg_decls.iter().enumerate() {"}, {"sha": "da0e8ba78cfdbdf9ddd6b7cfa44376159d2b7754", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e8a8dfb056fb3654bacd6aaa6acbc4536358df23/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a8dfb056fb3654bacd6aaa6acbc4536358df23/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=e8a8dfb056fb3654bacd6aaa6acbc4536358df23", "patch": "@@ -519,7 +519,7 @@ where D: Dump\n                      span: Span,\n                      typ: &ast::Ty,\n                      expr: &ast::Expr) {\n-        let qualname = format!(\"::{}\", self.tcx.map.path_to_string(id));\n+        let qualname = format!(\"::{}\", self.tcx.node_path_str(id));\n \n         let sub_span = self.span.sub_span_after_keyword(span, keywords::Const);\n \n@@ -544,7 +544,7 @@ where D: Dump\n                       item: &ast::Item,\n                       def: &ast::VariantData,\n                       ty_params: &ast::Generics) {\n-        let qualname = format!(\"::{}\", self.tcx.map.path_to_string(item.id));\n+        let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n \n         let val = self.span.snippet(item.span);\n         let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Struct);\n@@ -677,7 +677,7 @@ where D: Dump\n                      generics: &ast::Generics,\n                      trait_refs: &ast::TyParamBounds,\n                      methods: &[ast::TraitItem]) {\n-        let qualname = format!(\"::{}\", self.tcx.map.path_to_string(item.id));\n+        let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n         let val = self.span.snippet(item.span);\n         let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Trait);\n         if !self.span.filter_generated(sub_span, item.span) {\n@@ -1108,7 +1108,7 @@ impl<'l, 'tcx, 'v, D: Dump + 'l> Visitor<'v> for DumpVisitor<'l, 'tcx, D> {\n                 self.nest(item.id, |v| visit::walk_mod(v, m));\n             }\n             Ty(ref ty, ref ty_params) => {\n-                let qualname = format!(\"::{}\", self.tcx.map.path_to_string(item.id));\n+                let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n                 let value = ty_to_string(&ty);\n                 let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Type);\n                 if !self.span.filter_generated(sub_span, item.span) {"}, {"sha": "da4c8770b7e36c7478472a9d34239a6bb2e9bdc9", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e8a8dfb056fb3654bacd6aaa6acbc4536358df23/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a8dfb056fb3654bacd6aaa6acbc4536358df23/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=e8a8dfb056fb3654bacd6aaa6acbc4536358df23", "patch": "@@ -116,7 +116,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n     pub fn get_item_data(&self, item: &ast::Item) -> Option<Data> {\n         match item.node {\n             ast::ItemKind::Fn(..) => {\n-                let name = self.tcx.map.path_to_string(item.id);\n+                let name = self.tcx.node_path_str(item.id);\n                 let qualname = format!(\"::{}\", name);\n                 let sub_span = self.span_utils.sub_span_after_keyword(item.span, keywords::Fn);\n                 filter!(self.span_utils, sub_span, item.span, None);\n@@ -130,7 +130,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 }))\n             }\n             ast::ItemKind::Static(ref typ, mt, ref expr) => {\n-                let qualname = format!(\"::{}\", self.tcx.map.path_to_string(item.id));\n+                let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n \n                 // If the variable is immutable, save the initialising expression.\n                 let (value, keyword) = match mt {\n@@ -153,7 +153,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 }))\n             }\n             ast::ItemKind::Const(ref typ, ref expr) => {\n-                let qualname = format!(\"::{}\", self.tcx.map.path_to_string(item.id));\n+                let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n                 let sub_span = self.span_utils.sub_span_after_keyword(item.span, keywords::Const);\n                 filter!(self.span_utils, sub_span, item.span, None);\n                 Some(Data::VariableData(VariableData {\n@@ -167,7 +167,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 }))\n             }\n             ast::ItemKind::Mod(ref m) => {\n-                let qualname = format!(\"::{}\", self.tcx.map.path_to_string(item.id));\n+                let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n \n                 let cm = self.tcx.sess.codemap();\n                 let filename = cm.span_to_filename(m.inner);\n@@ -184,7 +184,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 }))\n             }\n             ast::ItemKind::Enum(..) => {\n-                let enum_name = format!(\"::{}\", self.tcx.map.path_to_string(item.id));\n+                let enum_name = format!(\"::{}\", self.tcx.node_path_str(item.id));\n                 let val = self.span_utils.snippet(item.span);\n                 let sub_span = self.span_utils.sub_span_after_keyword(item.span, keywords::Enum);\n                 filter!(self.span_utils, sub_span, item.span, None);\n@@ -246,7 +246,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                           scope: NodeId) -> Option<VariableData> {\n         match field.node.kind {\n             ast::NamedField(ident, _) => {\n-                let qualname = format!(\"::{}::{}\", self.tcx.map.path_to_string(scope), ident);\n+                let qualname = format!(\"::{}::{}\", self.tcx.node_path_str(scope), ident);\n                 let typ = self.tcx.node_types().get(&field.node.id).unwrap().to_string();\n                 let sub_span = self.span_utils.sub_span_before_token(field.span, token::Colon);\n                 filter!(self.span_utils, sub_span, field.span, None);"}, {"sha": "c8ed4e629e4c1e39f7cdb2098d5e3f9349b51238", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e8a8dfb056fb3654bacd6aaa6acbc4536358df23/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a8dfb056fb3654bacd6aaa6acbc4536358df23/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=e8a8dfb056fb3654bacd6aaa6acbc4536358df23", "patch": "@@ -1351,7 +1351,7 @@ fn build_cfg(tcx: &TyCtxt, id: ast::NodeId) -> (ast::NodeId, Option<cfg::CFG>) {\n         None if id == ast::DUMMY_NODE_ID => return (ast::DUMMY_NODE_ID, None),\n \n         _ => bug!(\"unexpected variant in has_nested_returns: {}\",\n-                  tcx.map.path_to_string(id)),\n+                  tcx.node_path_str(id)),\n     };\n \n     (blk.id, Some(cfg::CFG::new(tcx, blk)))\n@@ -1412,9 +1412,7 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n         let local_id = def_id.and_then(|id| ccx.tcx().map.as_local_node_id(id));\n \n         debug!(\"FunctionContext::new(path={}, def_id={:?}, param_substs={:?})\",\n-            inlined_id.map_or(String::new(), |id| {\n-                ccx.tcx().map.path_to_string(id).to_string()\n-            }),\n+            inlined_id.map_or(String::new(), |id| ccx.tcx().node_path_str(id)),\n             def_id,\n             param_substs);\n \n@@ -1906,7 +1904,7 @@ pub fn trans_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                           llfndecl: ValueRef,\n                           param_substs: &'tcx Substs<'tcx>,\n                           id: ast::NodeId) {\n-    let _s = StatRecorder::new(ccx, ccx.tcx().map.path_to_string(id).to_string());\n+    let _s = StatRecorder::new(ccx, ccx.tcx().node_path_str(id));\n     debug!(\"trans_fn(param_substs={:?})\", param_substs);\n     let _icx = push_ctxt(\"trans_fn\");\n     let fn_ty = ccx.tcx().node_id_to_type(id);\n@@ -2446,8 +2444,7 @@ pub fn exported_name<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         _ => {\n             if attr::contains_name(attrs, \"no_mangle\") {\n                 // Don't mangle\n-                let path = ccx.tcx().map.def_path_from_id(id);\n-                path.data.last().unwrap().data.to_string()\n+                ccx.tcx().map.name(id).as_str().to_string()\n             } else {\n                 match weak_lang_items::link_name(attrs) {\n                     Some(name) => name.to_string(),"}, {"sha": "5272a4fbbb76b7ad3019ff0e478d170236e21830", "filename": "src/librustc_trans/debuginfo/namespace.rs", "status": "modified", "additions": 66, "deletions": 74, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/e8a8dfb056fb3654bacd6aaa6acbc4536358df23/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a8dfb056fb3654bacd6aaa6acbc4536358df23/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs?ref=e8a8dfb056fb3654bacd6aaa6acbc4536358df23", "patch": "@@ -19,6 +19,7 @@ use rustc::hir::map as hir_map;\n use common::CrateContext;\n \n use std::ffi::CString;\n+use std::iter::once;\n use std::ptr;\n use std::rc::{Rc, Weak};\n use syntax::ast;\n@@ -51,85 +52,76 @@ impl NamespaceTreeNode {\n     }\n }\n \n-pub fn crate_root_namespace<'a>(cx: &'a CrateContext) -> &'a str {\n-    &cx.link_meta().crate_name\n-}\n-\n pub fn namespace_for_item(cx: &CrateContext, def_id: DefId) -> Rc<NamespaceTreeNode> {\n-    cx.tcx().with_path(def_id, |path| {\n-        // prepend crate name if not already present\n-        let krate = if def_id.is_local() {\n-            let crate_namespace_name = token::intern(crate_root_namespace(cx));\n-            Some(hir_map::PathMod(crate_namespace_name))\n-        } else {\n-            None\n+    // prepend crate name.\n+    // This shouldn't need a roundtrip through InternedString.\n+    let krate = token::intern(&cx.tcx().crate_name(def_id.krate));\n+    let krate = hir_map::DefPathData::TypeNs(krate);\n+    let path = cx.tcx().def_path(def_id).data;\n+    let mut path = once(krate).chain(path.into_iter().map(|e| e.data)).peekable();\n+\n+    let mut current_key = Vec::new();\n+    let mut parent_node: Option<Rc<NamespaceTreeNode>> = None;\n+\n+    // Create/Lookup namespace for each element of the path.\n+    loop {\n+        // Emulate a for loop so we can use peek below.\n+        let path_element = match path.next() {\n+            Some(e) => e,\n+            None => break\n         };\n-        let mut path = krate.into_iter().chain(path).peekable();\n-\n-        let mut current_key = Vec::new();\n-        let mut parent_node: Option<Rc<NamespaceTreeNode>> = None;\n-\n-        // Create/Lookup namespace for each element of the path.\n-        loop {\n-            // Emulate a for loop so we can use peek below.\n-            let path_element = match path.next() {\n-                Some(e) => e,\n-                None => break\n-            };\n-            // Ignore the name of the item (the last path element).\n-            if path.peek().is_none() {\n-                break;\n-            }\n-\n-            let name = path_element.name();\n-            current_key.push(name);\n-\n-            let existing_node = debug_context(cx).namespace_map.borrow()\n-                                                 .get(&current_key).cloned();\n-            let current_node = match existing_node {\n-                Some(existing_node) => existing_node,\n-                None => {\n-                    // create and insert\n-                    let parent_scope = match parent_node {\n-                        Some(ref node) => node.scope,\n-                        None => ptr::null_mut()\n-                    };\n-                    let namespace_name = name.as_str();\n-                    let namespace_name = CString::new(namespace_name.as_bytes()).unwrap();\n-                    let scope = unsafe {\n-                        llvm::LLVMDIBuilderCreateNameSpace(\n-                            DIB(cx),\n-                            parent_scope,\n-                            namespace_name.as_ptr(),\n-                            // cannot reconstruct file ...\n-                            ptr::null_mut(),\n-                            // ... or line information, but that's not so important.\n-                            0)\n-                    };\n-\n-                    let node = Rc::new(NamespaceTreeNode {\n-                        name: name,\n-                        scope: scope,\n-                        parent: parent_node.map(|parent| Rc::downgrade(&parent)),\n-                    });\n-\n-                    debug_context(cx).namespace_map.borrow_mut()\n-                                     .insert(current_key.clone(), node.clone());\n-\n-                    node\n-                }\n-            };\n-\n-            parent_node = Some(current_node);\n+        // Ignore the name of the item (the last path element).\n+        if path.peek().is_none() {\n+            break;\n         }\n \n-        match parent_node {\n-            Some(node) => node,\n+        // This shouldn't need a roundtrip through InternedString.\n+        let namespace_name = path_element.as_interned_str();\n+        let name = token::intern(&namespace_name);\n+        current_key.push(name);\n+\n+        let existing_node = debug_context(cx).namespace_map.borrow()\n+                                             .get(&current_key).cloned();\n+        let current_node = match existing_node {\n+            Some(existing_node) => existing_node,\n             None => {\n-                bug!(\"debuginfo::namespace_for_item(): \\\n-                      path too short for {:?}\",\n-                     def_id);\n+                // create and insert\n+                let parent_scope = match parent_node {\n+                    Some(ref node) => node.scope,\n+                    None => ptr::null_mut()\n+                };\n+                let namespace_name = CString::new(namespace_name.as_bytes()).unwrap();\n+                let scope = unsafe {\n+                    llvm::LLVMDIBuilderCreateNameSpace(\n+                        DIB(cx),\n+                        parent_scope,\n+                        namespace_name.as_ptr(),\n+                        // cannot reconstruct file ...\n+                        ptr::null_mut(),\n+                        // ... or line information, but that's not so important.\n+                        0)\n+                };\n+\n+                let node = Rc::new(NamespaceTreeNode {\n+                    name: name,\n+                    scope: scope,\n+                    parent: parent_node.map(|parent| Rc::downgrade(&parent)),\n+                });\n+\n+                debug_context(cx).namespace_map.borrow_mut()\n+                                 .insert(current_key.clone(), node.clone());\n+\n+                node\n             }\n+        };\n+\n+        parent_node = Some(current_node);\n+    }\n+\n+    match parent_node {\n+        Some(node) => node,\n+        None => {\n+            bug!(\"debuginfo::namespace_for_item: path too short for {:?}\", def_id);\n         }\n-    })\n+    }\n }"}, {"sha": "6fdd6a2c1d111b3ceca4fc48ca9ee15d6ee292a7", "filename": "src/librustc_trans/debuginfo/type_names.rs", "status": "modified", "additions": 8, "deletions": 26, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e8a8dfb056fb3654bacd6aaa6acbc4536358df23/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a8dfb056fb3654bacd6aaa6acbc4536358df23/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs?ref=e8a8dfb056fb3654bacd6aaa6acbc4536358df23", "patch": "@@ -10,8 +10,6 @@\n \n // Type Names for Debug Info.\n \n-use super::namespace::crate_root_namespace;\n-\n use common::CrateContext;\n use rustc::hir::def_id::DefId;\n use rustc::infer;\n@@ -163,31 +161,15 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                       def_id: DefId,\n                       qualified: bool,\n                       output: &mut String) {\n-        cx.tcx().with_path(def_id, |path| {\n-            if qualified {\n-                if def_id.is_local() {\n-                    output.push_str(crate_root_namespace(cx));\n-                    output.push_str(\"::\");\n-                }\n-\n-                let mut path_element_count = 0;\n-                for path_element in path {\n-                    output.push_str(&path_element.name().as_str());\n-                    output.push_str(\"::\");\n-                    path_element_count += 1;\n-                }\n-\n-                if path_element_count == 0 {\n-                    bug!(\"debuginfo: Encountered empty item path!\");\n-                }\n-\n-                output.pop();\n-                output.pop();\n-            } else {\n-                let name = path.last().expect(\"debuginfo: Empty item path?\").name();\n-                output.push_str(&name.as_str());\n+        if qualified {\n+            output.push_str(&cx.tcx().crate_name(def_id.krate));\n+            for path_element in cx.tcx().def_path(def_id).data {\n+                output.push_str(\"::\");\n+                output.push_str(&path_element.data.as_interned_str());\n             }\n-        });\n+        } else {\n+            output.push_str(&cx.tcx().item_name(def_id).as_str());\n+        }\n     }\n \n     // Pushes the type parameters in the given `Substs` to the output string."}, {"sha": "8c65eb8dbd367f5bfe5f58c811e82552ddcf4e0b", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e8a8dfb056fb3654bacd6aaa6acbc4536358df23/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a8dfb056fb3654bacd6aaa6acbc4536358df23/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=e8a8dfb056fb3654bacd6aaa6acbc4536358df23", "patch": "@@ -11,6 +11,7 @@\n //! Support for inlining external documentation into the current AST.\n \n use std::collections::HashSet;\n+use std::iter::once;\n \n use syntax::ast;\n use syntax::attr::AttrMetaMethods;\n@@ -140,8 +141,11 @@ pub fn load_attrs(cx: &DocContext, tcx: &TyCtxt,\n /// source links back to the original item.\n pub fn record_extern_fqn(cx: &DocContext, did: DefId, kind: clean::TypeKind) {\n     if let Some(tcx) = cx.tcx_opt() {\n-        let fqn = tcx.sess.cstore.extern_item_path(did);\n-        let fqn = fqn.into_iter().map(|i| i.to_string()).collect();\n+        let crate_name = tcx.sess.cstore.crate_name(did.krate).to_string();\n+        let relative = tcx.def_path(did).data.into_iter().map(|elem| {\n+            elem.data.to_string()\n+        });\n+        let fqn = once(crate_name).chain(relative).collect();\n         cx.external_paths.borrow_mut().as_mut().unwrap().insert(did, (fqn, kind));\n     }\n }"}, {"sha": "696e0544fdc5793003c11493f059864c632f9040", "filename": "src/test/run-make/pretty-print-path-suffix/foo_method.pp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8a8dfb056fb3654bacd6aaa6acbc4536358df23/src%2Ftest%2Frun-make%2Fpretty-print-path-suffix%2Ffoo_method.pp", "raw_url": "https://github.com/rust-lang/rust/raw/e8a8dfb056fb3654bacd6aaa6acbc4536358df23/src%2Ftest%2Frun-make%2Fpretty-print-path-suffix%2Ffoo_method.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fpretty-print-path-suffix%2Ffoo_method.pp?ref=e8a8dfb056fb3654bacd6aaa6acbc4536358df23", "patch": "@@ -13,4 +13,4 @@\n \n \n fn foo_method(&self) -> &'static str { return \"i am very similar to foo.\"; }\n-/* nest::S::foo_method */\n+/* nest::{{impl}}::foo_method */"}]}