{"sha": "b312ad7d0cf0f30be2bd4658b71a3520a2e76709", "node_id": "C_kwDOAAsO6NoAKGIzMTJhZDdkMGNmMGYzMGJlMmJkNDY1OGI3MWEzNTIwYTJlNzY3MDk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-20T21:35:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-20T21:35:14Z"}, "message": "Auto merge of #8856 - xFrednet:rustup, r=Manishearth,Alexendoo\n\nRustup\n\n`@rust-lang/clippy,` `@Jarcho,` `@dswij,` `@Alexendoo.` Could someone review this? It should be pretty straight forward since it's just a sync. I think it's also fine if either one of `@Jarcho,` `@dswij,` `@Alexendoo` approves this, as these are usually not reviewed. I just want to make sure that I didn't break something obvious :upside_down_face:\n\nIt should be enough to look at the merge commit :upside_down_face:\n\nchangelog: none\nchangelog: move [`significant_drop_in_scrutinee`] to `suspicious`", "tree": {"sha": "ba84240f20302bd27d133b114f767ca5fe78f40b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba84240f20302bd27d133b114f767ca5fe78f40b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b312ad7d0cf0f30be2bd4658b71a3520a2e76709", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b312ad7d0cf0f30be2bd4658b71a3520a2e76709", "html_url": "https://github.com/rust-lang/rust/commit/b312ad7d0cf0f30be2bd4658b71a3520a2e76709", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f26f117d61cc3e85516fa24b36e91e3f5137cb0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/f26f117d61cc3e85516fa24b36e91e3f5137cb0a", "html_url": "https://github.com/rust-lang/rust/commit/f26f117d61cc3e85516fa24b36e91e3f5137cb0a"}, {"sha": "7842dbc4f5af4818c89d830607383bfe349cd7e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/7842dbc4f5af4818c89d830607383bfe349cd7e7", "html_url": "https://github.com/rust-lang/rust/commit/7842dbc4f5af4818c89d830607383bfe349cd7e7"}], "stats": {"total": 1674, "additions": 1538, "deletions": 136}, "files": [{"sha": "24204f86b5e9455a9ccf5cb0cac5201e23684232", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=b312ad7d0cf0f30be2bd4658b71a3520a2e76709", "patch": "@@ -3715,6 +3715,7 @@ Released 2018-09-13\n [`short_circuit_statement`]: https://rust-lang.github.io/rust-clippy/master/index.html#short_circuit_statement\n [`should_assert_eq`]: https://rust-lang.github.io/rust-clippy/master/index.html#should_assert_eq\n [`should_implement_trait`]: https://rust-lang.github.io/rust-clippy/master/index.html#should_implement_trait\n+[`significant_drop_in_scrutinee`]: https://rust-lang.github.io/rust-clippy/master/index.html#significant_drop_in_scrutinee\n [`similar_names`]: https://rust-lang.github.io/rust-clippy/master/index.html#similar_names\n [`single_char_add_str`]: https://rust-lang.github.io/rust-clippy/master/index.html#single_char_add_str\n [`single_char_lifetime_names`]: https://rust-lang.github.io/rust-clippy/master/index.html#single_char_lifetime_names"}, {"sha": "373e720b0d5c07024e2d253cb8191bfcb54c01eb", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=b312ad7d0cf0f30be2bd4658b71a3520a2e76709", "patch": "@@ -1,6 +1,6 @@\n [package]\n name = \"clippy\"\n-version = \"0.1.62\"\n+version = \"0.1.63\"\n description = \"A bunch of helpful lints to avoid common pitfalls in Rust\"\n repository = \"https://github.com/rust-lang/rust-clippy\"\n readme = \"README.md\""}, {"sha": "0a3f04da35705ccb479bd918d07df089099b5b9a", "filename": "clippy_lints/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/clippy_lints%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/clippy_lints%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2FCargo.toml?ref=b312ad7d0cf0f30be2bd4658b71a3520a2e76709", "patch": "@@ -1,6 +1,6 @@\n [package]\n name = \"clippy_lints\"\n-version = \"0.1.62\"\n+version = \"0.1.63\"\n description = \"A bunch of helpful lints to avoid common pitfalls in Rust\"\n repository = \"https://github.com/rust-lang/rust-clippy\"\n readme = \"README.md\""}, {"sha": "ec55009f347d3704df40e3ca6c9402dec3acd51c", "filename": "clippy_lints/src/collapsible_match.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/clippy_lints%2Fsrc%2Fcollapsible_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/clippy_lints%2Fsrc%2Fcollapsible_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcollapsible_match.rs?ref=b312ad7d0cf0f30be2bd4658b71a3520a2e76709", "patch": "@@ -5,7 +5,7 @@ use clippy_utils::{is_lang_ctor, is_unit_expr, path_to_local, peel_blocks_with_s\n use if_chain::if_chain;\n use rustc_errors::MultiSpan;\n use rustc_hir::LangItem::OptionNone;\n-use rustc_hir::{Arm, Expr, Guard, HirId, Pat, PatKind};\n+use rustc_hir::{Arm, Expr, Guard, HirId, Let, Pat, PatKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::Span;\n@@ -109,7 +109,10 @@ fn check_arm<'tcx>(\n             (Some(a), Some(b)) => SpanlessEq::new(cx).eq_expr(a, b),\n         };\n         // the binding must not be used in the if guard\n-        if outer_guard.map_or(true, |(Guard::If(e) | Guard::IfLet(_, e))| !is_local_used(cx, *e, binding_id));\n+        if outer_guard.map_or(\n+            true,\n+            |(Guard::If(e) | Guard::IfLet(Let { init: e, .. }))| !is_local_used(cx, *e, binding_id)\n+        );\n         // ...or anywhere in the inner expression\n         if match inner {\n             IfLetOrMatch::IfLet(_, _, body, els) => {"}, {"sha": "34a5f8444dea0af0d58a1d221db4a1ca3998999a", "filename": "clippy_lints/src/derivable_impls.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/clippy_lints%2Fsrc%2Fderivable_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/clippy_lints%2Fsrc%2Fderivable_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fderivable_impls.rs?ref=b312ad7d0cf0f30be2bd4658b71a3520a2e76709", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n-use clippy_utils::{is_automatically_derived, is_default_equivalent, peel_blocks};\n+use clippy_utils::{is_default_equivalent, peel_blocks};\n use rustc_hir::{\n     def::{DefKind, Res},\n     Body, Expr, ExprKind, GenericArg, Impl, ImplItemKind, Item, ItemKind, Node, PathSegment, QPath, TyKind,\n@@ -71,8 +71,7 @@ impl<'tcx> LateLintPass<'tcx> for DerivableImpls {\n                 self_ty,\n                 ..\n             }) = item.kind;\n-            if let attrs = cx.tcx.hir().attrs(item.hir_id());\n-            if !is_automatically_derived(attrs);\n+            if !cx.tcx.has_attr(item.def_id.to_def_id(), sym::automatically_derived);\n             if !item.span.from_expansion();\n             if let Some(def_id) = trait_ref.trait_def_id();\n             if cx.tcx.is_diagnostic_item(sym::Default, def_id);\n@@ -81,6 +80,7 @@ impl<'tcx> LateLintPass<'tcx> for DerivableImpls {\n             if let ImplItemKind::Fn(_, b) = &impl_item.kind;\n             if let Body { value: func_expr, .. } = cx.tcx.hir().body(*b);\n             if let Some(adt_def) = cx.tcx.type_of(item.def_id).ty_adt_def();\n+            if let attrs = cx.tcx.hir().attrs(item.hir_id());\n             if !attrs.iter().any(|attr| attr.doc_str().is_some());\n             if let child_attrs = cx.tcx.hir().attrs(impl_item_hir);\n             if !child_attrs.iter().any(|attr| attr.doc_str().is_some());"}, {"sha": "fe99f4a8d55d1e359473da38289fb397400cd490", "filename": "clippy_lints/src/derive.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/clippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/clippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fderive.rs?ref=b312ad7d0cf0f30be2bd4658b71a3520a2e76709", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_note, span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::paths;\n use clippy_utils::ty::{implements_trait, is_copy};\n-use clippy_utils::{is_automatically_derived, is_lint_allowed, match_def_path};\n+use clippy_utils::{is_lint_allowed, match_def_path};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_expr, walk_fn, walk_item, FnKind, Visitor};\n@@ -205,8 +205,7 @@ impl<'tcx> LateLintPass<'tcx> for Derive {\n         }) = item.kind\n         {\n             let ty = cx.tcx.type_of(item.def_id);\n-            let attrs = cx.tcx.hir().attrs(item.hir_id());\n-            let is_automatically_derived = is_automatically_derived(attrs);\n+            let is_automatically_derived = cx.tcx.has_attr(item.def_id.to_def_id(), sym::automatically_derived);\n \n             check_hash_peq(cx, item.span, trait_ref, ty, is_automatically_derived);\n             check_ord_partial_ord(cx, item.span, trait_ref, ty, is_automatically_derived);\n@@ -236,7 +235,7 @@ fn check_hash_peq<'tcx>(\n         then {\n             // Look for the PartialEq implementations for `ty`\n             cx.tcx.for_each_relevant_impl(peq_trait_def_id, ty, |impl_id| {\n-                let peq_is_automatically_derived = is_automatically_derived(cx.tcx.get_attrs(impl_id));\n+                let peq_is_automatically_derived = cx.tcx.has_attr(impl_id, sym::automatically_derived);\n \n                 if peq_is_automatically_derived == hash_is_automatically_derived {\n                     return;\n@@ -290,7 +289,7 @@ fn check_ord_partial_ord<'tcx>(\n         then {\n             // Look for the PartialOrd implementations for `ty`\n             cx.tcx.for_each_relevant_impl(partial_ord_trait_def_id, ty, |impl_id| {\n-                let partial_ord_is_automatically_derived = is_automatically_derived(cx.tcx.get_attrs(impl_id));\n+                let partial_ord_is_automatically_derived = cx.tcx.has_attr(impl_id, sym::automatically_derived);\n \n                 if partial_ord_is_automatically_derived == ord_is_automatically_derived {\n                     return;"}, {"sha": "c5a987842c3f186cfc4119f658a890f1d60846ce", "filename": "clippy_lints/src/entry.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/clippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/clippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fentry.rs?ref=b312ad7d0cf0f30be2bd4658b71a3520a2e76709", "patch": "@@ -11,7 +11,7 @@ use rustc_errors::Applicability;\n use rustc_hir::{\n     hir_id::HirIdSet,\n     intravisit::{walk_expr, Visitor},\n-    Block, Expr, ExprKind, Guard, HirId, Pat, Stmt, StmtKind, UnOp,\n+    Block, Expr, ExprKind, Guard, HirId, Let, Pat, Stmt, StmtKind, UnOp,\n };\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -478,7 +478,7 @@ impl<'tcx> Visitor<'tcx> for InsertSearcher<'_, 'tcx> {\n                     let mut is_map_used = self.is_map_used;\n                     for arm in arms {\n                         self.visit_pat(arm.pat);\n-                        if let Some(Guard::If(guard) | Guard::IfLet(_, guard)) = arm.guard {\n+                        if let Some(Guard::If(guard) | Guard::IfLet(&Let { init: guard, .. })) = arm.guard {\n                             self.visit_non_tail_expr(guard);\n                         }\n                         is_map_used |= self.visit_cond_arm(arm.body);"}, {"sha": "530d6d4de35f1c2bceb58e92c6b8624c9db23c75", "filename": "clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/clippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/clippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feta_reduction.rs?ref=b312ad7d0cf0f30be2bd4658b71a3520a2e76709", "patch": "@@ -150,7 +150,7 @@ impl<'tcx> LateLintPass<'tcx> for EtaReduction {\n             if check_inputs(cx, body.params, args);\n             let method_def_id = cx.typeck_results().type_dependent_def_id(body.value.hir_id).unwrap();\n             let substs = cx.typeck_results().node_substs(body.value.hir_id);\n-            let call_ty = cx.tcx.type_of(method_def_id).subst(cx.tcx, substs);\n+            let call_ty = cx.tcx.bound_type_of(method_def_id).subst(cx.tcx, substs);\n             if check_sig(cx, closure_ty, call_ty);\n             then {\n                 span_lint_and_then(cx, REDUNDANT_CLOSURE_FOR_METHOD_CALLS, expr.span, \"redundant closure\", |diag| {"}, {"sha": "6672a6cb0b58fb7be926b3d0f074021645f602e2", "filename": "clippy_lints/src/functions/must_use.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs?ref=b312ad7d0cf0f30be2bd4658b71a3520a2e76709", "patch": "@@ -13,13 +13,13 @@ use clippy_utils::attrs::is_proc_macro;\n use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_then};\n use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::is_must_use_ty;\n-use clippy_utils::{match_def_path, must_use_attr, return_ty, trait_ref_of_method};\n+use clippy_utils::{match_def_path, return_ty, trait_ref_of_method};\n \n use super::{DOUBLE_MUST_USE, MUST_USE_CANDIDATE, MUST_USE_UNIT};\n \n pub(super) fn check_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n     let attrs = cx.tcx.hir().attrs(item.hir_id());\n-    let attr = must_use_attr(attrs);\n+    let attr = cx.tcx.get_attr(item.def_id.to_def_id(), sym::must_use);\n     if let hir::ItemKind::Fn(ref sig, _generics, ref body_id) = item.kind {\n         let is_public = cx.access_levels.is_exported(item.def_id);\n         let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n@@ -44,7 +44,7 @@ pub(super) fn check_impl_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::Imp\n         let is_public = cx.access_levels.is_exported(item.def_id);\n         let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n         let attrs = cx.tcx.hir().attrs(item.hir_id());\n-        let attr = must_use_attr(attrs);\n+        let attr = cx.tcx.get_attr(item.def_id.to_def_id(), sym::must_use);\n         if let Some(attr) = attr {\n             check_needless_must_use(cx, sig.decl, item.hir_id(), item.span, fn_header_span, attr);\n         } else if is_public && !is_proc_macro(cx.sess(), attrs) && trait_ref_of_method(cx, item.def_id).is_none() {\n@@ -67,7 +67,7 @@ pub(super) fn check_trait_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::Tr\n         let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n \n         let attrs = cx.tcx.hir().attrs(item.hir_id());\n-        let attr = must_use_attr(attrs);\n+        let attr = cx.tcx.get_attr(item.def_id.to_def_id(), sym::must_use);\n         if let Some(attr) = attr {\n             check_needless_must_use(cx, sig.decl, item.hir_id(), item.span, fn_header_span, attr);\n         } else if let hir::TraitFn::Provided(eid) = *eid {"}, {"sha": "5c46d6c7df7056856ed7afcd3d37f09b70cd2808", "filename": "clippy_lints/src/future_not_send.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/clippy_lints%2Fsrc%2Ffuture_not_send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/clippy_lints%2Fsrc%2Ffuture_not_send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffuture_not_send.rs?ref=b312ad7d0cf0f30be2bd4658b71a3520a2e76709", "patch": "@@ -5,7 +5,7 @@ use rustc_hir::{Body, FnDecl, HirId};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::subst::Subst;\n-use rustc_middle::ty::{Opaque, PredicateKind::Trait};\n+use rustc_middle::ty::{EarlyBinder, Opaque, PredicateKind::Trait};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{sym, Span};\n use rustc_trait_selection::traits::error_reporting::suggestions::InferCtxtExt;\n@@ -67,7 +67,7 @@ impl<'tcx> LateLintPass<'tcx> for FutureNotSend {\n             let preds = cx.tcx.explicit_item_bounds(id);\n             let mut is_future = false;\n             for &(p, _span) in preds {\n-                let p = p.subst(cx.tcx, subst);\n+                let p = EarlyBinder(p).subst(cx.tcx, subst);\n                 if let Some(trait_pred) = p.to_opt_poly_trait_pred() {\n                     if Some(trait_pred.skip_binder().trait_ref.def_id) == cx.tcx.lang_items().future_trait() {\n                         is_future = true;"}, {"sha": "be5c478900facbb8551c7f4532c28631d25b2bc8", "filename": "clippy_lints/src/lib.register_all.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/clippy_lints%2Fsrc%2Flib.register_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/clippy_lints%2Fsrc%2Flib.register_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_all.rs?ref=b312ad7d0cf0f30be2bd4658b71a3520a2e76709", "patch": "@@ -278,6 +278,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(self_assignment::SELF_ASSIGNMENT),\n     LintId::of(self_named_constructors::SELF_NAMED_CONSTRUCTORS),\n     LintId::of(serde_api::SERDE_API_MISUSE),\n+    LintId::of(significant_drop_in_scrutinee::SIGNIFICANT_DROP_IN_SCRUTINEE),\n     LintId::of(single_component_path_imports::SINGLE_COMPONENT_PATH_IMPORTS),\n     LintId::of(size_of_in_element_count::SIZE_OF_IN_ELEMENT_COUNT),\n     LintId::of(slow_vector_initialization::SLOW_VECTOR_INITIALIZATION),"}, {"sha": "5552ea8aa80ac57655c8cbf8a02ce42d037404f6", "filename": "clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/clippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/clippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_lints.rs?ref=b312ad7d0cf0f30be2bd4658b71a3520a2e76709", "patch": "@@ -473,6 +473,7 @@ store.register_lints(&[\n     shadow::SHADOW_REUSE,\n     shadow::SHADOW_SAME,\n     shadow::SHADOW_UNRELATED,\n+    significant_drop_in_scrutinee::SIGNIFICANT_DROP_IN_SCRUTINEE,\n     single_char_lifetime_names::SINGLE_CHAR_LIFETIME_NAMES,\n     single_component_path_imports::SINGLE_COMPONENT_PATH_IMPORTS,\n     size_of_in_element_count::SIZE_OF_IN_ELEMENT_COUNT,"}, {"sha": "2de49f1624a4264e8074a1ea453f7af251cb1680", "filename": "clippy_lints/src/lib.register_suspicious.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/clippy_lints%2Fsrc%2Flib.register_suspicious.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/clippy_lints%2Fsrc%2Flib.register_suspicious.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_suspicious.rs?ref=b312ad7d0cf0f30be2bd4658b71a3520a2e76709", "patch": "@@ -27,6 +27,7 @@ store.register_group(true, \"clippy::suspicious\", Some(\"clippy_suspicious\"), vec!\n     LintId::of(mut_key::MUTABLE_KEY_TYPE),\n     LintId::of(octal_escapes::OCTAL_ESCAPES),\n     LintId::of(rc_clone_in_vec_init::RC_CLONE_IN_VEC_INIT),\n+    LintId::of(significant_drop_in_scrutinee::SIGNIFICANT_DROP_IN_SCRUTINEE),\n     LintId::of(suspicious_trait_impl::SUSPICIOUS_ARITHMETIC_IMPL),\n     LintId::of(suspicious_trait_impl::SUSPICIOUS_OP_ASSIGN_IMPL),\n ])"}, {"sha": "4ac834f72405bbbef41d2d927730e3ef1b04d0c8", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=b312ad7d0cf0f30be2bd4658b71a3520a2e76709", "patch": "@@ -367,6 +367,7 @@ mod self_named_constructors;\n mod semicolon_if_nothing_returned;\n mod serde_api;\n mod shadow;\n+mod significant_drop_in_scrutinee;\n mod single_char_lifetime_names;\n mod single_component_path_imports;\n mod size_of_in_element_count;\n@@ -886,6 +887,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(move || Box::new(manual_bits::ManualBits::new(msrv)));\n     store.register_late_pass(|| Box::new(default_union_representation::DefaultUnionRepresentation));\n     store.register_late_pass(|| Box::new(only_used_in_recursion::OnlyUsedInRecursion));\n+    store.register_late_pass(|| Box::new(significant_drop_in_scrutinee::SignificantDropInScrutinee));\n     store.register_late_pass(|| Box::new(dbg_macro::DbgMacro));\n     let cargo_ignore_publish = conf.cargo_ignore_publish;\n     store.register_late_pass(move || {"}, {"sha": "51d5b510ab93053e155d1b6ec3cbb0ade5ceb101", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=b312ad7d0cf0f30be2bd4658b71a3520a2e76709", "patch": "@@ -9,8 +9,8 @@ use rustc_hir::intravisit::{\n use rustc_hir::FnRetTy::Return;\n use rustc_hir::{\n     BareFnTy, BodyId, FnDecl, GenericArg, GenericBound, GenericParam, GenericParamKind, Generics, Impl, ImplItem,\n-    ImplItemKind, Item, ItemKind, LangItem, Lifetime, LifetimeName, ParamName, PolyTraitRef, TraitBoundModifier,\n-    TraitFn, TraitItem, TraitItemKind, Ty, TyKind, WherePredicate,\n+    ImplItemKind, Item, ItemKind, LangItem, Lifetime, LifetimeName, ParamName, PolyTraitRef, PredicateOrigin,\n+    TraitBoundModifier, TraitFn, TraitItem, TraitItemKind, Ty, TyKind, WherePredicate,\n };\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::nested_filter as middle_nested_filter;\n@@ -145,7 +145,7 @@ fn check_fn_inner<'tcx>(\n         .filter(|param| matches!(param.kind, GenericParamKind::Type { .. }));\n     for typ in types {\n         for pred in generics.bounds_for_param(cx.tcx.hir().local_def_id(typ.hir_id)) {\n-            if pred.in_where_clause {\n+            if pred.origin == PredicateOrigin::WhereClause {\n                 // has_where_lifetimes checked that this predicate contains no lifetime.\n                 continue;\n             }"}, {"sha": "80845ace3f94071404cc6b208a969552bc308e7a", "filename": "clippy_lints/src/manual_non_exhaustive.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/clippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/clippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs?ref=b312ad7d0cf0f30be2bd4658b71a3520a2e76709", "patch": "@@ -1,7 +1,6 @@\n-use clippy_utils::attrs::is_doc_hidden;\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::source::snippet_opt;\n-use clippy_utils::{is_lint_allowed, meets_msrv, msrvs};\n+use clippy_utils::{is_doc_hidden, is_lint_allowed, meets_msrv, msrvs};\n use rustc_ast::ast::{self, VisibilityKind};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::Applicability;\n@@ -161,7 +160,7 @@ impl<'tcx> LateLintPass<'tcx> for ManualNonExhaustiveEnum {\n                 let id = cx.tcx.hir().local_def_id(v.id);\n                 (matches!(v.data, hir::VariantData::Unit(_))\n                     && v.ident.as_str().starts_with('_')\n-                    && is_doc_hidden(cx.tcx.get_attrs(id.to_def_id())))\n+                    && is_doc_hidden(cx.tcx.hir().attrs(v.id)))\n                 .then(|| (id, v.span))\n             });\n             if let Some((id, span)) = iter.next()"}, {"sha": "6f8d766aef7c7806b382b51ec1d3edb9af26a9e6", "filename": "clippy_lints/src/matches/match_wild_enum.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/clippy_lints%2Fsrc%2Fmatches%2Fmatch_wild_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/clippy_lints%2Fsrc%2Fmatches%2Fmatch_wild_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmatch_wild_enum.rs?ref=b312ad7d0cf0f30be2bd4658b71a3520a2e76709", "patch": "@@ -192,6 +192,5 @@ impl<'a> CommonPrefixSearcher<'a> {\n }\n \n fn is_hidden(cx: &LateContext<'_>, variant_def: &VariantDef) -> bool {\n-    let attrs = cx.tcx.get_attrs(variant_def.def_id);\n-    clippy_utils::attrs::is_doc_hidden(attrs) || clippy_utils::attrs::is_unstable(attrs)\n+    cx.tcx.is_doc_hidden(variant_def.def_id) || cx.tcx.has_attr(variant_def.def_id, sym::unstable)\n }"}, {"sha": "9d8f8999ce409488a8c33f5c1c5a7dd0956a70a2", "filename": "clippy_lints/src/mut_reference.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/clippy_lints%2Fsrc%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/clippy_lints%2Fsrc%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_reference.rs?ref=b312ad7d0cf0f30be2bd4658b71a3520a2e76709", "patch": "@@ -48,7 +48,7 @@ impl<'tcx> LateLintPass<'tcx> for UnnecessaryMutPassed {\n             ExprKind::MethodCall(path, arguments, _) => {\n                 let def_id = cx.typeck_results().type_dependent_def_id(e.hir_id).unwrap();\n                 let substs = cx.typeck_results().node_substs(e.hir_id);\n-                let method_type = cx.tcx.type_of(def_id).subst(cx.tcx, substs);\n+                let method_type = cx.tcx.bound_type_of(def_id).subst(cx.tcx, substs);\n                 check_arguments(cx, arguments, method_type, path.ident.as_str(), \"method\");\n             },\n             _ => (),"}, {"sha": "093ec389335db80d9a75e6ca6b566aad3c02fc16", "filename": "clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/clippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/clippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnew_without_default.rs?ref=b312ad7d0cf0f30be2bd4658b71a3520a2e76709", "patch": "@@ -84,7 +84,7 @@ impl<'tcx> LateLintPass<'tcx> for NewWithoutDefault {\n                             // can't be implemented for unsafe new\n                             return;\n                         }\n-                        if clippy_utils::is_doc_hidden(cx.tcx.hir().attrs(id)) {\n+                        if cx.tcx.is_doc_hidden(impl_item.def_id) {\n                             // shouldn't be implemented when it is hidden in docs\n                             return;\n                         }"}, {"sha": "d66698f8adc6927e1546214232364e2a3c7bfc97", "filename": "clippy_lints/src/only_used_in_recursion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/clippy_lints%2Fsrc%2Fonly_used_in_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/clippy_lints%2Fsrc%2Fonly_used_in_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fonly_used_in_recursion.rs?ref=b312ad7d0cf0f30be2bd4658b71a3520a2e76709", "patch": "@@ -596,7 +596,7 @@ impl<'tcx> SideEffectVisit<'tcx> {\n                 let mut vars = std::mem::take(&mut self.ret_vars);\n                 let _ = arm.guard.as_ref().map(|guard| {\n                     self.visit_expr(match guard {\n-                        Guard::If(expr) | Guard::IfLet(_, expr) => expr,\n+                        Guard::If(expr) | Guard::IfLet(Let { init: expr, .. }) => expr,\n                     });\n                     vars.append(&mut self.ret_vars);\n                 });"}, {"sha": "09ac514d014eb1d67fc1f9a6ad9a58f5061bdaaf", "filename": "clippy_lints/src/partialeq_ne_impl.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs?ref=b312ad7d0cf0f30be2bd4658b71a3520a2e76709", "patch": "@@ -1,5 +1,4 @@\n use clippy_utils::diagnostics::span_lint_hir;\n-use clippy_utils::is_automatically_derived;\n use if_chain::if_chain;\n use rustc_hir::{Impl, Item, ItemKind};\n use rustc_lint::{LateContext, LateLintPass};\n@@ -37,8 +36,7 @@ impl<'tcx> LateLintPass<'tcx> for PartialEqNeImpl {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n         if_chain! {\n             if let ItemKind::Impl(Impl { of_trait: Some(ref trait_ref), items: impl_items, .. }) = item.kind;\n-            let attrs = cx.tcx.hir().attrs(item.hir_id());\n-            if !is_automatically_derived(attrs);\n+            if !cx.tcx.has_attr(item.def_id.to_def_id(), sym::automatically_derived);\n             if let Some(eq_trait) = cx.tcx.lang_items().eq_trait();\n             if trait_ref.path.res.def_id() == eq_trait;\n             then {"}, {"sha": "0004b8afdd37557abdfa3cc60d6971423c14304c", "filename": "clippy_lints/src/redundant_clone.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/clippy_lints%2Fsrc%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/clippy_lints%2Fsrc%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_clone.rs?ref=b312ad7d0cf0f30be2bd4658b71a3520a2e76709", "patch": "@@ -113,7 +113,7 @@ impl<'tcx> LateLintPass<'tcx> for RedundantClone {\n             }\n \n             // Give up on loops\n-            if terminator.successors().any(|s| *s == bb) {\n+            if terminator.successors().any(|s| s == bb) {\n                 continue;\n             }\n \n@@ -439,7 +439,7 @@ fn visit_clone_usage(cloned: mir::Local, clone: mir::Local, mir: &mir::Body<'_>,\n             // Short-circuit\n             if (usage.cloned_used && usage.clone_consumed_or_mutated) ||\n                 // Give up on loops\n-                tdata.terminator().successors().any(|s| *s == bb)\n+                tdata.terminator().successors().any(|s| s == bb)\n             {\n                 return CloneUsage {\n                     cloned_used: true,"}, {"sha": "9158cbcc04e1cb4586ffa3609d0d6422be15c910", "filename": "clippy_lints/src/same_name_method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/clippy_lints%2Fsrc%2Fsame_name_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/clippy_lints%2Fsrc%2Fsame_name_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsame_name_method.rs?ref=b312ad7d0cf0f30be2bd4658b71a3520a2e76709", "patch": "@@ -51,7 +51,7 @@ impl<'tcx> LateLintPass<'tcx> for SameNameMethod {\n         let mut map = FxHashMap::<Res, ExistingName>::default();\n \n         for id in cx.tcx.hir().items() {\n-            if matches!(cx.tcx.hir().def_kind(id.def_id), DefKind::Impl)\n+            if matches!(cx.tcx.def_kind(id.def_id), DefKind::Impl)\n                 && let item = cx.tcx.hir().item(id)\n                 && let ItemKind::Impl(Impl {\n                     items,"}, {"sha": "424b361a905ce479105bf2c792138106ad23d7d8", "filename": "clippy_lints/src/significant_drop_in_scrutinee.rs", "status": "added", "additions": 406, "deletions": 0, "changes": 406, "blob_url": "https://github.com/rust-lang/rust/blob/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/clippy_lints%2Fsrc%2Fsignificant_drop_in_scrutinee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/clippy_lints%2Fsrc%2Fsignificant_drop_in_scrutinee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsignificant_drop_in_scrutinee.rs?ref=b312ad7d0cf0f30be2bd4658b71a3520a2e76709", "patch": "@@ -0,0 +1,406 @@\n+use crate::FxHashSet;\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::get_attr;\n+use clippy_utils::source::{indent_of, snippet};\n+use rustc_errors::{Applicability, Diagnostic};\n+use rustc_hir::intravisit::{walk_expr, Visitor};\n+use rustc_hir::{Expr, ExprKind};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_middle::ty::subst::GenericArgKind;\n+use rustc_middle::ty::{Ty, TypeAndMut};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::Span;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Check for temporaries returned from function calls in a match scrutinee that have the\n+    /// `clippy::has_significant_drop` attribute.\n+    ///\n+    /// ### Why is this bad?\n+    /// The `clippy::has_significant_drop` attribute can be added to types whose Drop impls have\n+    /// an important side-effect, such as unlocking a mutex, making it important for users to be\n+    /// able to accurately understand their lifetimes. When a temporary is returned in a function\n+    /// call in a match scrutinee, its lifetime lasts until the end of the match block, which may\n+    /// be surprising.\n+    ///\n+    /// For `Mutex`es this can lead to a deadlock. This happens when the match scrutinee uses a\n+    /// function call that returns a `MutexGuard` and then tries to lock again in one of the match\n+    /// arms. In that case the `MutexGuard` in the scrutinee will not be dropped until the end of\n+    /// the match block and thus will not unlock.\n+    ///\n+    /// ### Example\n+    /// ```rust.ignore\n+    /// # use std::sync::Mutex;\n+    ///\n+    /// # struct State {}\n+    ///\n+    /// # impl State {\n+    /// #     fn foo(&self) -> bool {\n+    /// #         true\n+    /// #     }\n+    ///\n+    /// #     fn bar(&self) {}\n+    /// # }\n+    ///\n+    ///\n+    /// let mutex = Mutex::new(State {});\n+    ///\n+    /// match mutex.lock().unwrap().foo() {\n+    ///     true => {\n+    ///         mutex.lock().unwrap().bar(); // Deadlock!\n+    ///     }\n+    ///     false => {}\n+    /// };\n+    ///\n+    /// println!(\"All done!\");\n+    ///\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// # use std::sync::Mutex;\n+    ///\n+    /// # struct State {}\n+    ///\n+    /// # impl State {\n+    /// #     fn foo(&self) -> bool {\n+    /// #         true\n+    /// #     }\n+    ///\n+    /// #     fn bar(&self) {}\n+    /// # }\n+    ///\n+    /// let mutex = Mutex::new(State {});\n+    ///\n+    /// let is_foo = mutex.lock().unwrap().foo();\n+    /// match is_foo {\n+    ///     true => {\n+    ///         mutex.lock().unwrap().bar();\n+    ///     }\n+    ///     false => {}\n+    /// };\n+    ///\n+    /// println!(\"All done!\");\n+    /// ```\n+    #[clippy::version = \"1.60.0\"]\n+    pub SIGNIFICANT_DROP_IN_SCRUTINEE,\n+    suspicious,\n+    \"warns when a temporary of a type with a drop with a significant side-effect might have a surprising lifetime\"\n+}\n+\n+declare_lint_pass!(SignificantDropInScrutinee => [SIGNIFICANT_DROP_IN_SCRUTINEE]);\n+\n+impl<'tcx> LateLintPass<'tcx> for SignificantDropInScrutinee {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n+        if let Some(suggestions) = has_significant_drop_in_scrutinee(cx, expr) {\n+            for found in suggestions {\n+                span_lint_and_then(\n+                    cx,\n+                    SIGNIFICANT_DROP_IN_SCRUTINEE,\n+                    found.found_span,\n+                    \"temporary with significant drop in match scrutinee\",\n+                    |diag| set_diagnostic(diag, cx, expr, found),\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+fn set_diagnostic<'tcx>(diag: &mut Diagnostic, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>, found: FoundSigDrop) {\n+    if found.lint_suggestion == LintSuggestion::MoveAndClone {\n+        // If our suggestion is to move and clone, then we want to leave it to the user to\n+        // decide how to address this lint, since it may be that cloning is inappropriate.\n+        // Therefore, we won't to emit a suggestion.\n+        return;\n+    }\n+\n+    let original = snippet(cx, found.found_span, \"..\");\n+    let trailing_indent = \" \".repeat(indent_of(cx, found.found_span).unwrap_or(0));\n+\n+    let replacement = if found.lint_suggestion == LintSuggestion::MoveAndDerefToCopy {\n+        format!(\"let value = *{};\\n{}\", original, trailing_indent)\n+    } else if found.is_unit_return_val {\n+        // If the return value of the expression to be moved is unit, then we don't need to\n+        // capture the result in a temporary -- we can just replace it completely with `()`.\n+        format!(\"{};\\n{}\", original, trailing_indent)\n+    } else {\n+        format!(\"let value = {};\\n{}\", original, trailing_indent)\n+    };\n+\n+    let suggestion_message = if found.lint_suggestion == LintSuggestion::MoveOnly {\n+        \"try moving the temporary above the match\"\n+    } else {\n+        \"try moving the temporary above the match and create a copy\"\n+    };\n+\n+    let scrutinee_replacement = if found.is_unit_return_val {\n+        \"()\".to_owned()\n+    } else {\n+        \"value\".to_owned()\n+    };\n+\n+    diag.multipart_suggestion(\n+        suggestion_message,\n+        vec![\n+            (expr.span.shrink_to_lo(), replacement),\n+            (found.found_span, scrutinee_replacement),\n+        ],\n+        Applicability::MaybeIncorrect,\n+    );\n+}\n+\n+/// If the expression is an `ExprKind::Match`, check if the scrutinee has a significant drop that\n+/// may have a surprising lifetime.\n+fn has_significant_drop_in_scrutinee<'tcx, 'a>(\n+    cx: &'a LateContext<'tcx>,\n+    expr: &'tcx Expr<'tcx>,\n+) -> Option<Vec<FoundSigDrop>> {\n+    let mut helper = SigDropHelper::new(cx);\n+    match expr.kind {\n+        ExprKind::Match(match_expr, _, _) => helper.find_sig_drop(match_expr),\n+        _ => None,\n+    }\n+}\n+\n+struct SigDropHelper<'a, 'tcx> {\n+    cx: &'a LateContext<'tcx>,\n+    is_chain_end: bool,\n+    seen_types: FxHashSet<Ty<'tcx>>,\n+    has_significant_drop: bool,\n+    current_sig_drop: Option<FoundSigDrop>,\n+    sig_drop_spans: Option<Vec<FoundSigDrop>>,\n+    special_handling_for_binary_op: bool,\n+}\n+\n+#[expect(clippy::enum_variant_names)]\n+#[derive(Debug, PartialEq, Eq, Clone, Copy)]\n+enum LintSuggestion {\n+    MoveOnly,\n+    MoveAndDerefToCopy,\n+    MoveAndClone,\n+}\n+\n+#[derive(Clone, Copy)]\n+struct FoundSigDrop {\n+    found_span: Span,\n+    is_unit_return_val: bool,\n+    lint_suggestion: LintSuggestion,\n+}\n+\n+impl<'a, 'tcx> SigDropHelper<'a, 'tcx> {\n+    fn new(cx: &'a LateContext<'tcx>) -> SigDropHelper<'a, 'tcx> {\n+        SigDropHelper {\n+            cx,\n+            is_chain_end: true,\n+            seen_types: FxHashSet::default(),\n+            has_significant_drop: false,\n+            current_sig_drop: None,\n+            sig_drop_spans: None,\n+            special_handling_for_binary_op: false,\n+        }\n+    }\n+\n+    fn find_sig_drop(&mut self, match_expr: &'tcx Expr<'_>) -> Option<Vec<FoundSigDrop>> {\n+        self.visit_expr(match_expr);\n+\n+        // If sig drop spans is empty but we found a significant drop, it means that we didn't find\n+        // a type that was trivially copyable as we moved up the chain after finding a significant\n+        // drop, so move the entire scrutinee.\n+        if self.has_significant_drop && self.sig_drop_spans.is_none() {\n+            self.try_setting_current_suggestion(match_expr, true);\n+            self.move_current_suggestion();\n+        }\n+\n+        self.sig_drop_spans.take()\n+    }\n+\n+    /// This will try to set the current suggestion (so it can be moved into the suggestions vec\n+    /// later). If `allow_move_and_clone` is false, the suggestion *won't* be set -- this gives us\n+    /// an opportunity to look for another type in the chain that will be trivially copyable.\n+    /// However, if we are at the the end of the chain, we want to accept whatever is there. (The\n+    /// suggestion won't actually be output, but the diagnostic message will be output, so the user\n+    /// can determine the best way to handle the lint.)\n+    fn try_setting_current_suggestion(&mut self, expr: &'tcx Expr<'_>, allow_move_and_clone: bool) {\n+        if self.current_sig_drop.is_some() {\n+            return;\n+        }\n+        let ty = self.get_type(expr);\n+        if ty.is_ref() {\n+            // We checked that the type was ref, so builtin_deref will return Some TypeAndMut,\n+            // but let's avoid any chance of an ICE\n+            if let Some(TypeAndMut { ty, .. }) = ty.builtin_deref(true) {\n+                if ty.is_trivially_pure_clone_copy() {\n+                    self.current_sig_drop.replace(FoundSigDrop {\n+                        found_span: expr.span,\n+                        is_unit_return_val: false,\n+                        lint_suggestion: LintSuggestion::MoveAndDerefToCopy,\n+                    });\n+                } else if allow_move_and_clone {\n+                    self.current_sig_drop.replace(FoundSigDrop {\n+                        found_span: expr.span,\n+                        is_unit_return_val: false,\n+                        lint_suggestion: LintSuggestion::MoveAndClone,\n+                    });\n+                }\n+            }\n+        } else if ty.is_trivially_pure_clone_copy() {\n+            self.current_sig_drop.replace(FoundSigDrop {\n+                found_span: expr.span,\n+                is_unit_return_val: false,\n+                lint_suggestion: LintSuggestion::MoveOnly,\n+            });\n+        }\n+    }\n+\n+    fn move_current_suggestion(&mut self) {\n+        if let Some(current) = self.current_sig_drop.take() {\n+            self.sig_drop_spans.get_or_insert_with(Vec::new).push(current);\n+        }\n+    }\n+\n+    fn get_type(&self, ex: &'tcx Expr<'_>) -> Ty<'tcx> {\n+        self.cx.typeck_results().expr_ty(ex)\n+    }\n+\n+    fn has_seen_type(&mut self, ty: Ty<'tcx>) -> bool {\n+        !self.seen_types.insert(ty)\n+    }\n+\n+    fn visit_exprs_for_binary_ops(\n+        &mut self,\n+        left: &'tcx Expr<'_>,\n+        right: &'tcx Expr<'_>,\n+        is_unit_return_val: bool,\n+        span: Span,\n+    ) {\n+        self.special_handling_for_binary_op = true;\n+        self.visit_expr(left);\n+        self.visit_expr(right);\n+\n+        // If either side had a significant drop, suggest moving the entire scrutinee to avoid\n+        // unnecessary copies and to simplify cases where both sides have significant drops.\n+        if self.has_significant_drop {\n+            self.current_sig_drop.replace(FoundSigDrop {\n+                found_span: span,\n+                is_unit_return_val,\n+                lint_suggestion: LintSuggestion::MoveOnly,\n+            });\n+        }\n+\n+        self.special_handling_for_binary_op = false;\n+    }\n+\n+    fn has_sig_drop_attr(&mut self, cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n+        if let Some(adt) = ty.ty_adt_def() {\n+            if get_attr(cx.sess(), cx.tcx.get_attrs_unchecked(adt.did()), \"has_significant_drop\").count() > 0 {\n+                return true;\n+            }\n+        }\n+\n+        match ty.kind() {\n+            rustc_middle::ty::Adt(a, b) => {\n+                for f in a.all_fields() {\n+                    let ty = f.ty(cx.tcx, b);\n+                    if !self.has_seen_type(ty) && self.has_sig_drop_attr(cx, ty) {\n+                        return true;\n+                    }\n+                }\n+\n+                for generic_arg in b.iter() {\n+                    if let GenericArgKind::Type(ty) = generic_arg.unpack() {\n+                        if self.has_sig_drop_attr(cx, ty) {\n+                            return true;\n+                        }\n+                    }\n+                }\n+                false\n+            },\n+            rustc_middle::ty::Array(ty, _)\n+            | rustc_middle::ty::RawPtr(TypeAndMut { ty, .. })\n+            | rustc_middle::ty::Ref(_, ty, _)\n+            | rustc_middle::ty::Slice(ty) => self.has_sig_drop_attr(cx, *ty),\n+            _ => false,\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for SigDropHelper<'a, 'tcx> {\n+    fn visit_expr(&mut self, ex: &'tcx Expr<'_>) {\n+        if !self.is_chain_end && self.has_sig_drop_attr(self.cx, self.get_type(ex)) {\n+            self.has_significant_drop = true;\n+            return;\n+        }\n+        self.is_chain_end = false;\n+\n+        match ex.kind {\n+            ExprKind::MethodCall(_, [ref expr, ..], _) => {\n+                self.visit_expr(expr);\n+            }\n+            ExprKind::Binary(_, left, right) => {\n+                self.visit_exprs_for_binary_ops(left, right, false, ex.span);\n+            }\n+            ExprKind::Assign(left, right, _) | ExprKind::AssignOp(_, left, right) => {\n+                self.visit_exprs_for_binary_ops(left, right, true, ex.span);\n+            }\n+            ExprKind::Tup(exprs) => {\n+                for expr in exprs {\n+                    self.visit_expr(expr);\n+                    if self.has_significant_drop {\n+                        // We may have not have set current_sig_drop if all the suggestions were\n+                        // MoveAndClone, so add this tuple item's full expression in that case.\n+                        if self.current_sig_drop.is_none() {\n+                            self.try_setting_current_suggestion(expr, true);\n+                        }\n+\n+                        // Now we are guaranteed to have something, so add it to the final vec.\n+                        self.move_current_suggestion();\n+                    }\n+                    // Reset `has_significant_drop` after each tuple expression so we can look for\n+                    // additional cases.\n+                    self.has_significant_drop = false;\n+                }\n+                if self.sig_drop_spans.is_some() {\n+                    self.has_significant_drop = true;\n+                }\n+            }\n+            ExprKind::Box(..) |\n+                ExprKind::Array(..) |\n+                ExprKind::Call(..) |\n+                ExprKind::Unary(..) |\n+                ExprKind::If(..) |\n+                ExprKind::Match(..) |\n+                ExprKind::Field(..) |\n+                ExprKind::Index(..) |\n+                ExprKind::Ret(..) |\n+                ExprKind::Repeat(..) |\n+                ExprKind::Yield(..) |\n+                ExprKind::MethodCall(..) => walk_expr(self, ex),\n+            ExprKind::AddrOf(_, _, _) |\n+                ExprKind::Block(_, _) |\n+                ExprKind::Break(_, _) |\n+                ExprKind::Cast(_, _) |\n+                // Don't want to check the closure itself, only invocation, which is covered by MethodCall\n+                ExprKind::Closure(_, _, _, _, _) |\n+                ExprKind::ConstBlock(_) |\n+                ExprKind::Continue(_) |\n+                ExprKind::DropTemps(_) |\n+                ExprKind::Err |\n+                ExprKind::InlineAsm(_) |\n+                ExprKind::Let(_) |\n+                ExprKind::Lit(_) |\n+                ExprKind::Loop(_, _, _, _) |\n+                ExprKind::Path(_) |\n+                ExprKind::Struct(_, _, _) |\n+                ExprKind::Type(_, _) => {\n+                return;\n+            }\n+        }\n+\n+        // Once a significant temporary has been found, we need to go back up at least 1 level to\n+        // find the span to extract for replacement, so the temporary gets dropped. However, for\n+        // binary ops, we want to move the whole scrutinee so we avoid unnecessary copies and to\n+        // simplify cases where both sides have significant drops.\n+        if self.has_significant_drop && !self.special_handling_for_binary_op {\n+            self.try_setting_current_suggestion(ex, false);\n+        }\n+    }\n+}"}, {"sha": "6c60fb4b8e029ed97424afada4d2f8695ea756da", "filename": "clippy_lints/src/trait_bounds.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/clippy_lints%2Fsrc%2Ftrait_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/clippy_lints%2Fsrc%2Ftrait_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftrait_bounds.rs?ref=b312ad7d0cf0f30be2bd4658b71a3520a2e76709", "patch": "@@ -8,7 +8,8 @@ use rustc_data_structures::unhash::UnhashMap;\n use rustc_errors::Applicability;\n use rustc_hir::def::Res;\n use rustc_hir::{\n-    GenericBound, Generics, Item, ItemKind, Node, Path, PathSegment, QPath, TraitItem, Ty, TyKind, WherePredicate,\n+    GenericBound, Generics, Item, ItemKind, Node, Path, PathSegment, PredicateOrigin, QPath, TraitItem, Ty, TyKind,\n+    WherePredicate,\n };\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n@@ -95,6 +96,7 @@ impl<'tcx> LateLintPass<'tcx> for TraitBounds {\n         for predicate in item.generics.predicates {\n             if_chain! {\n                 if let WherePredicate::BoundPredicate(ref bound_predicate) = predicate;\n+                if bound_predicate.origin != PredicateOrigin::ImplTrait;\n                 if !bound_predicate.span.from_expansion();\n                 if let TyKind::Path(QPath::Resolved(_, Path { segments, .. })) = bound_predicate.bounded_ty.kind;\n                 if let Some(PathSegment {\n@@ -168,6 +170,7 @@ impl TraitBounds {\n         for bound in gen.predicates {\n             if_chain! {\n                 if let WherePredicate::BoundPredicate(ref p) = bound;\n+                if p.origin != PredicateOrigin::ImplTrait;\n                 if p.bounds.len() as u64 <= self.max_trait_bounds;\n                 if !p.span.from_expansion();\n                 if let Some(ref v) = map.insert(\n@@ -223,6 +226,7 @@ fn check_trait_bound_duplication(cx: &LateContext<'_>, gen: &'_ Generics<'_>) {\n     for predicate in gen.predicates {\n         if_chain! {\n             if let WherePredicate::BoundPredicate(ref bound_predicate) = predicate;\n+            if bound_predicate.origin != PredicateOrigin::ImplTrait;\n             if !bound_predicate.span.from_expansion();\n             if let TyKind::Path(QPath::Resolved(_, Path { segments, .. })) = bound_predicate.bounded_ty.kind;\n             if let Some(segment) = segments.first();"}, {"sha": "be6277332db4dbd5d7d9530388c36c62f46e4b13", "filename": "clippy_lints/src/transmute/transmute_undefined_repr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs?ref=b312ad7d0cf0f30be2bd4658b71a3520a2e76709", "patch": "@@ -307,7 +307,7 @@ fn reduce_ty<'tcx>(cx: &LateContext<'tcx>, mut ty: Ty<'tcx>) -> ReducedTy<'tcx>\n                     .non_enum_variant()\n                     .fields\n                     .iter()\n-                    .map(|f| cx.tcx.type_of(f.did).subst(cx.tcx, substs));\n+                    .map(|f| cx.tcx.bound_type_of(f.did).subst(cx.tcx, substs));\n                 let Some(sized_ty) = iter.find(|&ty| !is_zero_sized_ty(cx, ty)) else {\n                     return ReducedTy::TypeErasure;\n                 };"}, {"sha": "3f4d0fd199d0814cd712d285571c48a83d615379", "filename": "clippy_lints/src/utils/author.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=b312ad7d0cf0f30be2bd4658b71a3520a2e76709", "patch": "@@ -315,11 +315,11 @@ impl<'a, 'tcx> PrintVisitor<'a, 'tcx> {\n                 out!(\"if let Some(Guard::If({expr})) = {arm}.guard;\");\n                 self.expr(expr);\n             },\n-            Some(hir::Guard::IfLet(pat, expr)) => {\n-                bind!(self, pat, expr);\n-                out!(\"if let Some(Guard::IfLet({pat}, {expr}) = {arm}.guard;\");\n-                self.pat(pat);\n-                self.expr(expr);\n+            Some(hir::Guard::IfLet(let_expr)) => {\n+                bind!(self, let_expr);\n+                out!(\"if let Some(Guard::IfLet({let_expr}) = {arm}.guard;\");\n+                self.pat(field!(let_expr.pat));\n+                self.expr(field!(let_expr.init));\n             },\n         }\n         self.expr(field!(arm.body));"}, {"sha": "c4e0b8448ab3f48c7ba68e9062fea13bc524197b", "filename": "clippy_utils/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/clippy_utils%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/clippy_utils%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2FCargo.toml?ref=b312ad7d0cf0f30be2bd4658b71a3520a2e76709", "patch": "@@ -1,6 +1,6 @@\n [package]\n name = \"clippy_utils\"\n-version = \"0.1.62\"\n+version = \"0.1.63\"\n edition = \"2021\"\n publish = false\n "}, {"sha": "49318849d5802bf635a2038e85b9259df1daa9bc", "filename": "clippy_utils/src/attrs.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/clippy_utils%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/clippy_utils%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fattrs.rs?ref=b312ad7d0cf0f30be2bd4658b71a3520a2e76709", "patch": "@@ -1,4 +1,5 @@\n-use rustc_ast::{ast, attr};\n+use rustc_ast::ast;\n+use rustc_ast::attr;\n use rustc_errors::Applicability;\n use rustc_session::Session;\n use rustc_span::sym;\n@@ -21,6 +22,7 @@ pub const BUILTIN_ATTRIBUTES: &[(&str, DeprecationStatus)] = &[\n     (\"cyclomatic_complexity\", DeprecationStatus::Replaced(\"cognitive_complexity\")),\n     (\"dump\",                  DeprecationStatus::None),\n     (\"msrv\",                  DeprecationStatus::None),\n+    (\"has_significant_drop\",  DeprecationStatus::None),\n ];\n \n pub struct LimitStack {\n@@ -155,8 +157,3 @@ pub fn is_doc_hidden(attrs: &[ast::Attribute]) -> bool {\n         .filter_map(ast::Attribute::meta_item_list)\n         .any(|l| attr::list_contains_name(&l, sym::hidden))\n }\n-\n-/// Return true if the attributes contain `#[unstable]`\n-pub fn is_unstable(attrs: &[ast::Attribute]) -> bool {\n-    attrs.iter().any(|attr| attr.has_name(sym::unstable))\n-}"}, {"sha": "9f162a117b2d103cc12309f33029f24203ff4a3b", "filename": "clippy_utils/src/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/clippy_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/clippy_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fconsts.rs?ref=b312ad7d0cf0f30be2bd4658b71a3520a2e76709", "patch": "@@ -9,7 +9,7 @@ use rustc_hir::{BinOp, BinOpKind, Block, Expr, ExprKind, HirId, Item, ItemKind,\n use rustc_lint::LateContext;\n use rustc_middle::mir::interpret::Scalar;\n use rustc_middle::ty::subst::{Subst, SubstsRef};\n-use rustc_middle::ty::{self, FloatTy, ScalarInt, Ty, TyCtxt};\n+use rustc_middle::ty::{self, EarlyBinder, FloatTy, ScalarInt, Ty, TyCtxt};\n use rustc_middle::{bug, span_bug};\n use rustc_span::symbol::Symbol;\n use std::cmp::Ordering::{self, Equal};\n@@ -417,7 +417,7 @@ impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n                 let substs = if self.substs.is_empty() {\n                     substs\n                 } else {\n-                    substs.subst(self.lcx.tcx, self.substs)\n+                    EarlyBinder(substs).subst(self.lcx.tcx, self.substs)\n                 };\n \n                 let result = self"}, {"sha": "c440793b90e0edee2dc8b2442930b80c869ea1e3", "filename": "clippy_utils/src/hir_utils.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/clippy_utils%2Fsrc%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/clippy_utils%2Fsrc%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fhir_utils.rs?ref=b312ad7d0cf0f30be2bd4658b71a3520a2e76709", "patch": "@@ -300,7 +300,9 @@ impl HirEqInterExpr<'_, '_, '_> {\n     fn eq_guard(&mut self, left: &Guard<'_>, right: &Guard<'_>) -> bool {\n         match (left, right) {\n             (Guard::If(l), Guard::If(r)) => self.eq_expr(l, r),\n-            (Guard::IfLet(lp, le), Guard::IfLet(rp, re)) => self.eq_pat(lp, rp) && self.eq_expr(le, re),\n+            (Guard::IfLet(l), Guard::IfLet(r)) => {\n+                self.eq_pat(l.pat, r.pat) && both(&l.ty, &r.ty, |l, r| self.eq_ty(l, r)) && self.eq_expr(l.init, r.init)\n+            },\n             _ => false,\n         }\n     }\n@@ -892,7 +894,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n \n     pub fn hash_guard(&mut self, g: &Guard<'_>) {\n         match g {\n-            Guard::If(expr) | Guard::IfLet(_, expr) => {\n+            Guard::If(expr) | Guard::IfLet(Let { init: expr, .. }) => {\n                 self.hash_expr(expr);\n             },\n         }"}, {"sha": "adb37cc9d7510bd1d9a58d5fccbdbd8af75c52d2", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 28, "deletions": 50, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=b312ad7d0cf0f30be2bd4658b71a3520a2e76709", "patch": "@@ -66,21 +66,21 @@ use std::lazy::SyncOnceCell;\n use std::sync::{Mutex, MutexGuard};\n \n use if_chain::if_chain;\n-use rustc_ast::ast::{self, Attribute, LitKind};\n+use rustc_ast::ast::{self, LitKind};\n+use rustc_ast::Attribute;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::unhash::UnhashMap;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, CRATE_DEF_ID};\n use rustc_hir::hir_id::{HirIdMap, HirIdSet};\n use rustc_hir::intravisit::{walk_expr, FnKind, Visitor};\n-use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_hir::LangItem::{OptionNone, ResultErr, ResultOk};\n use rustc_hir::{\n     def, Arm, ArrayLen, BindingAnnotation, Block, BlockCheckMode, Body, Constness, Destination, Expr, ExprKind, FnDecl,\n-    ForeignItem, HirId, Impl, ImplItem, ImplItemKind, IsAsync, Item, ItemKind, LangItem, Local, MatchSource,\n-    Mutability, Node, Param, Pat, PatKind, Path, PathSegment, PrimTy, QPath, Stmt, StmtKind, TraitItem, TraitItemKind,\n-    TraitRef, TyKind, UnOp,\n+    HirId, Impl, ImplItem, ImplItemKind, IsAsync, Item, ItemKind, LangItem, Local, MatchSource, Mutability, Node,\n+    Param, Pat, PatKind, Path, PathSegment, PrimTy, QPath, Stmt, StmtKind, TraitItem, TraitItemKind, TraitRef, TyKind,\n+    UnOp,\n };\n use rustc_lint::{LateContext, Level, Lint, LintContext};\n use rustc_middle::hir::place::PlaceBase;\n@@ -1472,12 +1472,6 @@ pub fn recurse_or_patterns<'tcx, F: FnMut(&'tcx Pat<'tcx>)>(pat: &'tcx Pat<'tcx>\n     }\n }\n \n-/// Checks for the `#[automatically_derived]` attribute all `#[derive]`d\n-/// implementations have.\n-pub fn is_automatically_derived(attrs: &[ast::Attribute]) -> bool {\n-    has_attr(attrs, sym::automatically_derived)\n-}\n-\n pub fn is_self(slf: &Param<'_>) -> bool {\n     if let PatKind::Binding(.., name, _) = slf.pat.kind {\n         name.name == kw::SelfLower\n@@ -1724,11 +1718,6 @@ pub fn get_async_fn_body<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'_>) -> Option<&'t\n     None\n }\n \n-// Finds the `#[must_use]` attribute, if any\n-pub fn must_use_attr(attrs: &[Attribute]) -> Option<&Attribute> {\n-    attrs.iter().find(|a| a.has_name(sym::must_use))\n-}\n-\n // check if expr is calling method or function with #[must_use] attribute\n pub fn is_must_use_func_call(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     let did = match expr.kind {\n@@ -1745,7 +1734,7 @@ pub fn is_must_use_func_call(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n         _ => None,\n     };\n \n-    did.map_or(false, |did| must_use_attr(cx.tcx.get_attrs(did)).is_some())\n+    did.map_or(false, |did| cx.tcx.has_attr(did, sym::must_use))\n }\n \n /// Checks if an expression represents the identity function\n@@ -2079,35 +2068,6 @@ pub fn is_hir_ty_cfg_dependant(cx: &LateContext<'_>, ty: &hir::Ty<'_>) -> bool {\n     false\n }\n \n-struct TestItemNamesVisitor<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    names: Vec<Symbol>,\n-}\n-\n-impl<'hir> ItemLikeVisitor<'hir> for TestItemNamesVisitor<'hir> {\n-    fn visit_item(&mut self, item: &Item<'_>) {\n-        if let ItemKind::Const(ty, _body) = item.kind {\n-            if let TyKind::Path(QPath::Resolved(_, path)) = ty.kind {\n-                // We could also check for the type name `test::TestDescAndFn`\n-                if let Res::Def(DefKind::Struct, _) = path.res {\n-                    let has_test_marker = self\n-                        .tcx\n-                        .hir()\n-                        .attrs(item.hir_id())\n-                        .iter()\n-                        .any(|a| a.has_name(sym::rustc_test_marker));\n-                    if has_test_marker {\n-                        self.names.push(item.ident.name);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-    fn visit_trait_item(&mut self, _: &TraitItem<'_>) {}\n-    fn visit_impl_item(&mut self, _: &ImplItem<'_>) {}\n-    fn visit_foreign_item(&mut self, _: &ForeignItem<'_>) {}\n-}\n-\n static TEST_ITEM_NAMES_CACHE: SyncOnceCell<Mutex<FxHashMap<LocalDefId, Vec<Symbol>>>> = SyncOnceCell::new();\n \n fn with_test_item_names<'tcx>(tcx: TyCtxt<'tcx>, module: LocalDefId, f: impl Fn(&[Symbol]) -> bool) -> bool {\n@@ -2116,10 +2076,28 @@ fn with_test_item_names<'tcx>(tcx: TyCtxt<'tcx>, module: LocalDefId, f: impl Fn(\n     match map.entry(module) {\n         Entry::Occupied(entry) => f(entry.get()),\n         Entry::Vacant(entry) => {\n-            let mut visitor = TestItemNamesVisitor { tcx, names: Vec::new() };\n-            tcx.hir().visit_item_likes_in_module(module, &mut visitor);\n-            visitor.names.sort_unstable();\n-            f(&*entry.insert(visitor.names))\n+            let mut names = Vec::new();\n+            for id in tcx.hir().module_items(module) {\n+                if matches!(tcx.def_kind(id.def_id), DefKind::Const)\n+                    && let item = tcx.hir().item(id)\n+                    && let ItemKind::Const(ty, _body) = item.kind {\n+                    if let TyKind::Path(QPath::Resolved(_, path)) = ty.kind {\n+                        // We could also check for the type name `test::TestDescAndFn`\n+                        if let Res::Def(DefKind::Struct, _) = path.res {\n+                            let has_test_marker = tcx\n+                                .hir()\n+                                .attrs(item.hir_id())\n+                                .iter()\n+                                .any(|a| a.has_name(sym::rustc_test_marker));\n+                            if has_test_marker {\n+                                names.push(item.ident.name);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            names.sort_unstable();\n+            f(&*entry.insert(names))\n         },\n     }\n }"}, {"sha": "a6d7042fabc2606e19f3707cd2d54d4870d168df", "filename": "clippy_utils/src/qualify_min_const_fn.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/clippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/clippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fqualify_min_const_fn.rs?ref=b312ad7d0cf0f30be2bd4658b71a3520a2e76709", "patch": "@@ -14,7 +14,6 @@ use rustc_middle::ty::{self, adjustment::PointerCast, Ty, TyCtxt};\n use rustc_semver::RustcVersion;\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n-use rustc_target::spec::abi::Abi::RustIntrinsic;\n use std::borrow::Cow;\n \n type McfResult = Result<(), (Span, Cow<'static, str>)>;\n@@ -323,7 +322,7 @@ fn check_terminator<'a, 'tcx>(\n                 // within const fns. `transmute` is allowed in all other const contexts.\n                 // This won't really scale to more intrinsics or functions. Let's allow const\n                 // transmutes in const fn before we add more hacks to this.\n-                if tcx.fn_sig(fn_def_id).abi() == RustIntrinsic && tcx.item_name(fn_def_id) == sym::transmute {\n+                if tcx.is_intrinsic(fn_def_id) && tcx.item_name(fn_def_id) == sym::transmute {\n                     return Err((\n                         span,\n                         \"can only call `transmute` from const items, not `const fn`\".into(),"}, {"sha": "07d3d2807634f8a8d8a163691045b054af2c56ca", "filename": "clippy_utils/src/ty.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/clippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/clippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fty.rs?ref=b312ad7d0cf0f30be2bd4658b71a3520a2e76709", "patch": "@@ -22,7 +22,7 @@ use rustc_trait_selection::infer::InferCtxtExt;\n use rustc_trait_selection::traits::query::normalize::AtExt;\n use std::iter;\n \n-use crate::{match_def_path, must_use_attr, path_res, paths};\n+use crate::{match_def_path, path_res, paths};\n \n // Checks if the given type implements copy.\n pub fn is_copy<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n@@ -178,18 +178,18 @@ pub fn has_drop<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n // Returns whether the type has #[must_use] attribute\n pub fn is_must_use_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n     match ty.kind() {\n-        ty::Adt(adt, _) => must_use_attr(cx.tcx.get_attrs(adt.did())).is_some(),\n-        ty::Foreign(ref did) => must_use_attr(cx.tcx.get_attrs(*did)).is_some(),\n+        ty::Adt(adt, _) => cx.tcx.has_attr(adt.did(), sym::must_use),\n+        ty::Foreign(did) => cx.tcx.has_attr(*did, sym::must_use),\n         ty::Slice(ty) | ty::Array(ty, _) | ty::RawPtr(ty::TypeAndMut { ty, .. }) | ty::Ref(_, ty, _) => {\n             // for the Array case we don't need to care for the len == 0 case\n             // because we don't want to lint functions returning empty arrays\n             is_must_use_ty(cx, *ty)\n         },\n         ty::Tuple(substs) => substs.iter().any(|ty| is_must_use_ty(cx, ty)),\n-        ty::Opaque(ref def_id, _) => {\n+        ty::Opaque(def_id, _) => {\n             for (predicate, _) in cx.tcx.explicit_item_bounds(*def_id) {\n                 if let ty::PredicateKind::Trait(trait_predicate) = predicate.kind().skip_binder() {\n-                    if must_use_attr(cx.tcx.get_attrs(trait_predicate.trait_ref.def_id)).is_some() {\n+                    if cx.tcx.has_attr(trait_predicate.trait_ref.def_id, sym::must_use) {\n                         return true;\n                     }\n                 }\n@@ -199,7 +199,7 @@ pub fn is_must_use_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n         ty::Dynamic(binder, _) => {\n             for predicate in binder.iter() {\n                 if let ty::ExistentialPredicate::Trait(ref trait_ref) = predicate.skip_binder() {\n-                    if must_use_attr(cx.tcx.get_attrs(trait_ref.def_id)).is_some() {\n+                    if cx.tcx.has_attr(trait_ref.def_id, sym::must_use) {\n                         return true;\n                     }\n                 }\n@@ -520,7 +520,7 @@ pub fn expr_sig<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>) -> Option<ExprFnS\n         let ty = cx.typeck_results().expr_ty_adjusted(expr).peel_refs();\n         match *ty.kind() {\n             ty::Closure(_, subs) => Some(ExprFnSig::Closure(subs.as_closure().sig())),\n-            ty::FnDef(id, subs) => Some(ExprFnSig::Sig(cx.tcx.fn_sig(id).subst(cx.tcx, subs))),\n+            ty::FnDef(id, subs) => Some(ExprFnSig::Sig(cx.tcx.bound_fn_sig(id).subst(cx.tcx, subs))),\n             ty::FnPtr(sig) => Some(ExprFnSig::Sig(sig)),\n             ty::Dynamic(bounds, _) => {\n                 let lang_items = cx.tcx.lang_items();"}, {"sha": "997e7ba9382b2104c1f789de87dbfd5fedb67d8e", "filename": "rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/rust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/rust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-toolchain?ref=b312ad7d0cf0f30be2bd4658b71a3520a2e76709", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2022-05-05\"\n+channel = \"nightly-2022-05-19\"\n components = [\"cargo\", \"llvm-tools-preview\", \"rust-src\", \"rust-std\", \"rustc\", \"rustc-dev\", \"rustfmt\"]"}, {"sha": "d930d486fde654220d9cc9c93533fbfb01523d3f", "filename": "tests/ui/crashes/ice-6252.stderr", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/tests%2Fui%2Fcrashes%2Fice-6252.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/tests%2Fui%2Fcrashes%2Fice-6252.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fice-6252.stderr?ref=b312ad7d0cf0f30be2bd4658b71a3520a2e76709", "patch": "@@ -30,7 +30,15 @@ LL |     const VAL: T;\n LL | impl<N, M> TypeVal<usize> for Multiply<N, M> where N: TypeVal<VAL> {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `VAL` in implementation\n \n-error: aborting due to 3 previous errors\n+error: constant expression depends on a generic parameter\n+  --> $DIR/ice-6252.rs:13:9\n+   |\n+LL |     [1; <Multiply<Five, Five>>::VAL];\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this may fail depending on what value the parameter takes\n+\n+error: aborting due to 4 previous errors\n \n Some errors have detailed explanations: E0046, E0412.\n For more information about an error, try `rustc --explain E0046`."}, {"sha": "985835ffa6533ce4c6f34a3b4ac4465c4a661258", "filename": "tests/ui/expect_tool_lint_rfc_2383.rs", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/tests%2Fui%2Fexpect_tool_lint_rfc_2383.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/tests%2Fui%2Fexpect_tool_lint_rfc_2383.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexpect_tool_lint_rfc_2383.rs?ref=b312ad7d0cf0f30be2bd4658b71a3520a2e76709", "patch": "@@ -0,0 +1,142 @@\n+// check-pass\n+#![feature(lint_reasons)]\n+//! This file tests the `#[expect]` attribute implementation for tool lints. The same\n+//! file is used to test clippy and rustdoc. Any changes to this file should be synced\n+//! to the other test files as well.\n+//!\n+//! Expectations:\n+//! * rustc: only rustc lint expectations are emitted\n+//! * clippy: rustc and Clippy's expectations are emitted\n+//! * rustdoc: only rustdoc lint expectations are emitted\n+//!\n+//! This test can't cover every lint from Clippy, rustdoc and potentially other\n+//! tools that will be developed. This therefore only tests a small subset of lints\n+#![expect(rustdoc::missing_crate_level_docs)]\n+\n+mod rustc_ok {\n+    //! See <https://doc.rust-lang.org/rustc/lints/index.html>\n+\n+    #[expect(dead_code)]\n+    pub fn rustc_lints() {\n+        let x = 42.0;\n+\n+        #[expect(illegal_floating_point_literal_pattern)]\n+        match x {\n+            5.0 => {},\n+            6.0 => {},\n+            _ => {},\n+        }\n+    }\n+}\n+\n+mod rustc_warn {\n+    //! See <https://doc.rust-lang.org/rustc/lints/index.html>\n+\n+    #[expect(dead_code)]\n+    pub fn rustc_lints() {\n+        let x = 42;\n+\n+        #[expect(illegal_floating_point_literal_pattern)]\n+        match x {\n+            5 => {},\n+            6 => {},\n+            _ => {},\n+        }\n+    }\n+}\n+\n+pub mod rustdoc_ok {\n+    //! See <https://doc.rust-lang.org/rustdoc/lints.html>\n+\n+    #[expect(rustdoc::broken_intra_doc_links)]\n+    /// I want to link to [`Nonexistent`] but it doesn't exist!\n+    pub fn foo() {}\n+\n+    #[expect(rustdoc::invalid_html_tags)]\n+    /// <h1>\n+    pub fn bar() {}\n+\n+    #[expect(rustdoc::bare_urls)]\n+    /// http://example.org\n+    pub fn baz() {}\n+}\n+\n+pub mod rustdoc_warn {\n+    //! See <https://doc.rust-lang.org/rustdoc/lints.html>\n+\n+    #[expect(rustdoc::broken_intra_doc_links)]\n+    /// I want to link to [`bar`] but it doesn't exist!\n+    pub fn foo() {}\n+\n+    #[expect(rustdoc::invalid_html_tags)]\n+    /// <h1></h1>\n+    pub fn bar() {}\n+\n+    #[expect(rustdoc::bare_urls)]\n+    /// <http://example.org>\n+    pub fn baz() {}\n+}\n+\n+mod clippy_ok {\n+    //! See <https://rust-lang.github.io/rust-clippy/master/index.html>\n+\n+    #[expect(clippy::almost_swapped)]\n+    fn foo() {\n+        let mut a = 0;\n+        let mut b = 9;\n+        a = b;\n+        b = a;\n+    }\n+\n+    #[expect(clippy::bytes_nth)]\n+    fn bar() {\n+        let _ = \"Hello\".bytes().nth(3);\n+    }\n+\n+    #[expect(clippy::if_same_then_else)]\n+    fn baz() {\n+        let _ = if true { 42 } else { 42 };\n+    }\n+\n+    #[expect(clippy::logic_bug)]\n+    fn burger() {\n+        let a = false;\n+        let b = true;\n+\n+        if a && b || a {}\n+    }\n+}\n+\n+mod clippy_warn {\n+    //! See <https://rust-lang.github.io/rust-clippy/master/index.html>\n+\n+    #[expect(clippy::almost_swapped)]\n+    fn foo() {\n+        let mut a = 0;\n+        let mut b = 9;\n+        a = b;\n+    }\n+\n+    #[expect(clippy::bytes_nth)]\n+    fn bar() {\n+        let _ = \"Hello\".as_bytes().get(3);\n+    }\n+\n+    #[expect(clippy::if_same_then_else)]\n+    fn baz() {\n+        let _ = if true { 33 } else { 42 };\n+    }\n+\n+    #[expect(clippy::logic_bug)]\n+    fn burger() {\n+        let a = false;\n+        let b = true;\n+        let c = false;\n+\n+        if a && b || c {}\n+    }\n+}\n+\n+fn main() {\n+    rustc_warn::rustc_lints();\n+}"}, {"sha": "db29e85a82191abf6529511704d4fb83f6725fb6", "filename": "tests/ui/expect_tool_lint_rfc_2383.stderr", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/tests%2Fui%2Fexpect_tool_lint_rfc_2383.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/tests%2Fui%2Fexpect_tool_lint_rfc_2383.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexpect_tool_lint_rfc_2383.stderr?ref=b312ad7d0cf0f30be2bd4658b71a3520a2e76709", "patch": "@@ -0,0 +1,40 @@\n+error: this lint expectation is unfulfilled\n+  --> $DIR/expect_tool_lint_rfc_2383.rs:35:14\n+   |\n+LL |     #[expect(dead_code)]\n+   |              ^^^^^^^^^\n+   |\n+   = note: `-D unfulfilled-lint-expectations` implied by `-D warnings`\n+\n+error: this lint expectation is unfulfilled\n+  --> $DIR/expect_tool_lint_rfc_2383.rs:39:18\n+   |\n+LL |         #[expect(illegal_floating_point_literal_pattern)]\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: this lint expectation is unfulfilled\n+  --> $DIR/expect_tool_lint_rfc_2383.rs:113:14\n+   |\n+LL |     #[expect(clippy::almost_swapped)]\n+   |              ^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: this lint expectation is unfulfilled\n+  --> $DIR/expect_tool_lint_rfc_2383.rs:120:14\n+   |\n+LL |     #[expect(clippy::bytes_nth)]\n+   |              ^^^^^^^^^^^^^^^^^\n+\n+error: this lint expectation is unfulfilled\n+  --> $DIR/expect_tool_lint_rfc_2383.rs:125:14\n+   |\n+LL |     #[expect(clippy::if_same_then_else)]\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: this lint expectation is unfulfilled\n+  --> $DIR/expect_tool_lint_rfc_2383.rs:130:14\n+   |\n+LL |     #[expect(clippy::logic_bug)]\n+   |              ^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "6ae700753f06d672724d197018dd7fbecceb6ecf", "filename": "tests/ui/indexing_slicing_index.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/tests%2Fui%2Findexing_slicing_index.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/tests%2Fui%2Findexing_slicing_index.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Findexing_slicing_index.stderr?ref=b312ad7d0cf0f30be2bd4658b71a3520a2e76709", "patch": "@@ -1,4 +1,4 @@\n-error[E0080]: evaluation of `main::{constant#3}::<&i32>` failed\n+error[E0080]: evaluation of `main::{constant#3}` failed\n   --> $DIR/indexing_slicing_index.rs:31:14\n    |\n LL |     const { &ARR[idx4()] }; // Ok, let rustc handle const contexts."}, {"sha": "f83a6dd0eb288bab30a619f79f40770bb5942a3e", "filename": "tests/ui/significant_drop_in_scrutinee.rs", "status": "added", "additions": 555, "deletions": 0, "changes": 555, "blob_url": "https://github.com/rust-lang/rust/blob/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/tests%2Fui%2Fsignificant_drop_in_scrutinee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/tests%2Fui%2Fsignificant_drop_in_scrutinee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsignificant_drop_in_scrutinee.rs?ref=b312ad7d0cf0f30be2bd4658b71a3520a2e76709", "patch": "@@ -0,0 +1,555 @@\n+// FIXME: Ideally these suggestions would be fixed via rustfix. Blocked by rust-lang/rust#53934\n+// // run-rustfix\n+\n+#![warn(clippy::significant_drop_in_scrutinee)]\n+#![allow(clippy::single_match)]\n+#![allow(clippy::match_single_binding)]\n+#![allow(unused_assignments)]\n+#![allow(dead_code)]\n+\n+use std::ops::Deref;\n+use std::sync::atomic::{AtomicU64, Ordering};\n+use std::sync::{Mutex, MutexGuard};\n+\n+struct State {}\n+\n+impl State {\n+    fn foo(&self) -> bool {\n+        true\n+    }\n+\n+    fn bar(&self) {}\n+}\n+\n+fn should_not_trigger_lint_with_mutex_guard_outside_match() {\n+    let mutex = Mutex::new(State {});\n+\n+    // Should not trigger lint because the temporary should drop at the `;` on line before the match\n+    let is_foo = mutex.lock().unwrap().foo();\n+    match is_foo {\n+        true => {\n+            mutex.lock().unwrap().bar();\n+        },\n+        false => {},\n+    };\n+}\n+\n+fn should_not_trigger_lint_with_mutex_guard_when_taking_ownership_in_match() {\n+    let mutex = Mutex::new(State {});\n+\n+    // Should not trigger lint because the scrutinee is explicitly returning the MutexGuard,\n+    // so its lifetime should not be surprising.\n+    match mutex.lock() {\n+        Ok(guard) => {\n+            guard.foo();\n+            mutex.lock().unwrap().bar();\n+        },\n+        _ => {},\n+    };\n+}\n+\n+fn should_trigger_lint_with_mutex_guard_in_match_scrutinee() {\n+    let mutex = Mutex::new(State {});\n+\n+    // Should trigger lint because the lifetime of the temporary MutexGuard is surprising because it\n+    // is preserved until the end of the match, but there is no clear indication that this is the\n+    // case.\n+    match mutex.lock().unwrap().foo() {\n+        true => {\n+            mutex.lock().unwrap().bar();\n+        },\n+        false => {},\n+    };\n+}\n+\n+fn should_not_trigger_lint_for_insignificant_drop() {\n+    // Should not trigger lint because there are no temporaries whose drops have a significant\n+    // side effect.\n+    match 1u64.to_string().is_empty() {\n+        true => {\n+            println!(\"It was empty\")\n+        },\n+        false => {\n+            println!(\"It was not empty\")\n+        },\n+    }\n+}\n+\n+struct StateWithMutex {\n+    m: Mutex<u64>,\n+}\n+\n+struct MutexGuardWrapper<'a> {\n+    mg: MutexGuard<'a, u64>,\n+}\n+\n+impl<'a> MutexGuardWrapper<'a> {\n+    fn get_the_value(&self) -> u64 {\n+        *self.mg.deref()\n+    }\n+}\n+\n+struct MutexGuardWrapperWrapper<'a> {\n+    mg: MutexGuardWrapper<'a>,\n+}\n+\n+impl<'a> MutexGuardWrapperWrapper<'a> {\n+    fn get_the_value(&self) -> u64 {\n+        *self.mg.mg.deref()\n+    }\n+}\n+\n+impl StateWithMutex {\n+    fn lock_m(&self) -> MutexGuardWrapper<'_> {\n+        MutexGuardWrapper {\n+            mg: self.m.lock().unwrap(),\n+        }\n+    }\n+\n+    fn lock_m_m(&self) -> MutexGuardWrapperWrapper<'_> {\n+        MutexGuardWrapperWrapper {\n+            mg: MutexGuardWrapper {\n+                mg: self.m.lock().unwrap(),\n+            },\n+        }\n+    }\n+\n+    fn foo(&self) -> bool {\n+        true\n+    }\n+\n+    fn bar(&self) {}\n+}\n+\n+fn should_trigger_lint_with_wrapped_mutex() {\n+    let s = StateWithMutex { m: Mutex::new(1) };\n+\n+    // Should trigger lint because a temporary contains a type with a significant drop and its\n+    // lifetime is not obvious. Additionally, it is not obvious from looking at the scrutinee that\n+    // the temporary contains such a type, making it potentially even more surprising.\n+    match s.lock_m().get_the_value() {\n+        1 => {\n+            println!(\"Got 1. Is it still 1?\");\n+            println!(\"{}\", s.lock_m().get_the_value());\n+        },\n+        2 => {\n+            println!(\"Got 2. Is it still 2?\");\n+            println!(\"{}\", s.lock_m().get_the_value());\n+        },\n+        _ => {},\n+    }\n+    println!(\"All done!\");\n+}\n+\n+fn should_trigger_lint_with_double_wrapped_mutex() {\n+    let s = StateWithMutex { m: Mutex::new(1) };\n+\n+    // Should trigger lint because a temporary contains a type which further contains a type with a\n+    // significant drop and its lifetime is not obvious. Additionally, it is not obvious from\n+    // looking at the scrutinee that the temporary contains such a type, making it potentially even\n+    // more surprising.\n+    match s.lock_m_m().get_the_value() {\n+        1 => {\n+            println!(\"Got 1. Is it still 1?\");\n+            println!(\"{}\", s.lock_m().get_the_value());\n+        },\n+        2 => {\n+            println!(\"Got 2. Is it still 2?\");\n+            println!(\"{}\", s.lock_m().get_the_value());\n+        },\n+        _ => {},\n+    }\n+    println!(\"All done!\");\n+}\n+\n+struct Counter {\n+    i: AtomicU64,\n+}\n+\n+#[clippy::has_significant_drop]\n+struct CounterWrapper<'a> {\n+    counter: &'a Counter,\n+}\n+\n+impl<'a> CounterWrapper<'a> {\n+    fn new(counter: &Counter) -> CounterWrapper {\n+        counter.i.fetch_add(1, Ordering::Relaxed);\n+        CounterWrapper { counter }\n+    }\n+}\n+\n+impl<'a> Drop for CounterWrapper<'a> {\n+    fn drop(&mut self) {\n+        self.counter.i.fetch_sub(1, Ordering::Relaxed);\n+    }\n+}\n+\n+impl Counter {\n+    fn temp_increment(&self) -> Vec<CounterWrapper> {\n+        vec![CounterWrapper::new(self), CounterWrapper::new(self)]\n+    }\n+}\n+\n+fn should_trigger_lint_for_vec() {\n+    let counter = Counter { i: AtomicU64::new(0) };\n+\n+    // Should trigger lint because the temporary in the scrutinee returns a collection of types\n+    // which have significant drops. The types with significant drops are also non-obvious when\n+    // reading the expression in the scrutinee.\n+    match counter.temp_increment().len() {\n+        2 => {\n+            let current_count = counter.i.load(Ordering::Relaxed);\n+            println!(\"Current count {}\", current_count);\n+            assert_eq!(current_count, 0);\n+        },\n+        1 => {},\n+        3 => {},\n+        _ => {},\n+    };\n+}\n+\n+struct StateWithField {\n+    s: String,\n+}\n+\n+// Should trigger lint only on the type in the tuple which is created using a temporary\n+// with a significant drop. Additionally, this test ensures that the format of the tuple\n+// is preserved correctly in the suggestion.\n+fn should_trigger_lint_for_tuple_in_scrutinee() {\n+    let mutex1 = Mutex::new(StateWithField { s: \"one\".to_owned() });\n+\n+    {\n+        match (mutex1.lock().unwrap().s.len(), true) {\n+            (3, _) => {\n+                println!(\"started\");\n+                mutex1.lock().unwrap().s.len();\n+                println!(\"done\");\n+            },\n+            (_, _) => {},\n+        };\n+\n+        match (true, mutex1.lock().unwrap().s.len(), true) {\n+            (_, 3, _) => {\n+                println!(\"started\");\n+                mutex1.lock().unwrap().s.len();\n+                println!(\"done\");\n+            },\n+            (_, _, _) => {},\n+        };\n+\n+        let mutex2 = Mutex::new(StateWithField { s: \"two\".to_owned() });\n+        match (mutex1.lock().unwrap().s.len(), true, mutex2.lock().unwrap().s.len()) {\n+            (3, _, 3) => {\n+                println!(\"started\");\n+                mutex1.lock().unwrap().s.len();\n+                mutex2.lock().unwrap().s.len();\n+                println!(\"done\");\n+            },\n+            (_, _, _) => {},\n+        };\n+\n+        let mutex3 = Mutex::new(StateWithField { s: \"three\".to_owned() });\n+        match mutex3.lock().unwrap().s.as_str() {\n+            \"three\" => {\n+                println!(\"started\");\n+                mutex1.lock().unwrap().s.len();\n+                mutex2.lock().unwrap().s.len();\n+                println!(\"done\");\n+            },\n+            _ => {},\n+        };\n+\n+        match (true, mutex3.lock().unwrap().s.as_str()) {\n+            (_, \"three\") => {\n+                println!(\"started\");\n+                mutex1.lock().unwrap().s.len();\n+                mutex2.lock().unwrap().s.len();\n+                println!(\"done\");\n+            },\n+            (_, _) => {},\n+        };\n+    }\n+}\n+\n+// Should trigger lint when either side of a binary operation creates a temporary with a\n+// significant drop.\n+// To avoid potential unnecessary copies or creating references that would trigger the significant\n+// drop problem, the lint recommends moving the entire binary operation.\n+fn should_trigger_lint_for_accessing_field_in_mutex_in_one_side_of_binary_op() {\n+    let mutex = Mutex::new(StateWithField { s: \"state\".to_owned() });\n+\n+    match mutex.lock().unwrap().s.len() > 1 {\n+        true => {\n+            mutex.lock().unwrap().s.len();\n+        },\n+        false => {},\n+    };\n+\n+    match 1 < mutex.lock().unwrap().s.len() {\n+        true => {\n+            mutex.lock().unwrap().s.len();\n+        },\n+        false => {},\n+    };\n+}\n+\n+// Should trigger lint when both sides of a binary operation creates a temporary with a\n+// significant drop.\n+// To avoid potential unnecessary copies or creating references that would trigger the significant\n+// drop problem, the lint recommends moving the entire binary operation.\n+fn should_trigger_lint_for_accessing_fields_in_mutex_in_both_sides_of_binary_op() {\n+    let mutex1 = Mutex::new(StateWithField { s: \"state\".to_owned() });\n+    let mutex2 = Mutex::new(StateWithField {\n+        s: \"statewithfield\".to_owned(),\n+    });\n+\n+    match mutex1.lock().unwrap().s.len() < mutex2.lock().unwrap().s.len() {\n+        true => {\n+            println!(\n+                \"{} < {}\",\n+                mutex1.lock().unwrap().s.len(),\n+                mutex2.lock().unwrap().s.len()\n+            );\n+        },\n+        false => {},\n+    };\n+\n+    match mutex1.lock().unwrap().s.len() >= mutex2.lock().unwrap().s.len() {\n+        true => {\n+            println!(\n+                \"{} >= {}\",\n+                mutex1.lock().unwrap().s.len(),\n+                mutex2.lock().unwrap().s.len()\n+            );\n+        },\n+        false => {},\n+    };\n+}\n+\n+fn should_not_trigger_lint_for_closure_in_scrutinee() {\n+    let mutex1 = Mutex::new(StateWithField { s: \"one\".to_owned() });\n+\n+    let get_mutex_guard = || mutex1.lock().unwrap().s.len();\n+\n+    // Should not trigger lint because the temporary with a significant drop will be dropped\n+    // at the end of the closure, so the MutexGuard will be unlocked and not have a potentially\n+    // surprising lifetime.\n+    match get_mutex_guard() > 1 {\n+        true => {\n+            mutex1.lock().unwrap().s.len();\n+        },\n+        false => {},\n+    };\n+}\n+\n+fn should_trigger_lint_for_return_from_closure_in_scrutinee() {\n+    let mutex1 = Mutex::new(StateWithField { s: \"one\".to_owned() });\n+\n+    let get_mutex_guard = || mutex1.lock().unwrap();\n+\n+    // Should trigger lint because the temporary with a significant drop is returned from the\n+    // closure but not used directly in any match arms, so it has a potentially surprising lifetime.\n+    match get_mutex_guard().s.len() > 1 {\n+        true => {\n+            mutex1.lock().unwrap().s.len();\n+        },\n+        false => {},\n+    };\n+}\n+\n+fn should_trigger_lint_for_return_from_match_in_scrutinee() {\n+    let mutex1 = Mutex::new(StateWithField { s: \"one\".to_owned() });\n+    let mutex2 = Mutex::new(StateWithField { s: \"two\".to_owned() });\n+\n+    let i = 100;\n+\n+    // Should trigger lint because the nested match within the scrutinee returns a temporary with a\n+    // significant drop is but not used directly in any match arms, so it has a potentially\n+    // surprising lifetime.\n+    match match i {\n+        100 => mutex1.lock().unwrap(),\n+        _ => mutex2.lock().unwrap(),\n+    }\n+    .s\n+    .len()\n+        > 1\n+    {\n+        true => {\n+            mutex1.lock().unwrap().s.len();\n+        },\n+        false => {\n+            println!(\"nothing to do here\");\n+        },\n+    };\n+}\n+\n+fn should_trigger_lint_for_return_from_if_in_scrutinee() {\n+    let mutex1 = Mutex::new(StateWithField { s: \"one\".to_owned() });\n+    let mutex2 = Mutex::new(StateWithField { s: \"two\".to_owned() });\n+\n+    let i = 100;\n+\n+    // Should trigger lint because the nested if-expression within the scrutinee returns a temporary\n+    // with a significant drop is but not used directly in any match arms, so it has a potentially\n+    // surprising lifetime.\n+    match if i > 1 {\n+        mutex1.lock().unwrap()\n+    } else {\n+        mutex2.lock().unwrap()\n+    }\n+    .s\n+    .len()\n+        > 1\n+    {\n+        true => {\n+            mutex1.lock().unwrap().s.len();\n+        },\n+        false => {},\n+    };\n+}\n+\n+fn should_not_trigger_lint_for_if_in_scrutinee() {\n+    let mutex = Mutex::new(StateWithField { s: \"state\".to_owned() });\n+\n+    let i = 100;\n+\n+    // Should not trigger the lint because the temporary with a significant drop *is* dropped within\n+    // the body of the if-expression nested within the match scrutinee, and therefore does not have\n+    // a potentially surprising lifetime.\n+    match if i > 1 {\n+        mutex.lock().unwrap().s.len() > 1\n+    } else {\n+        false\n+    } {\n+        true => {\n+            mutex.lock().unwrap().s.len();\n+        },\n+        false => {},\n+    };\n+}\n+\n+struct StateWithBoxedMutexGuard {\n+    u: Mutex<u64>,\n+}\n+\n+impl StateWithBoxedMutexGuard {\n+    fn new() -> StateWithBoxedMutexGuard {\n+        StateWithBoxedMutexGuard { u: Mutex::new(42) }\n+    }\n+    fn lock(&self) -> Box<MutexGuard<u64>> {\n+        Box::new(self.u.lock().unwrap())\n+    }\n+}\n+\n+fn should_trigger_lint_for_boxed_mutex_guard() {\n+    let s = StateWithBoxedMutexGuard::new();\n+\n+    // Should trigger lint because a temporary Box holding a type with a significant drop in a match\n+    // scrutinee may have a potentially surprising lifetime.\n+    match s.lock().deref().deref() {\n+        0 | 1 => println!(\"Value was less than 2\"),\n+        _ => println!(\"Value is {}\", s.lock().deref()),\n+    };\n+}\n+\n+struct StateStringWithBoxedMutexGuard {\n+    s: Mutex<String>,\n+}\n+\n+impl StateStringWithBoxedMutexGuard {\n+    fn new() -> StateStringWithBoxedMutexGuard {\n+        StateStringWithBoxedMutexGuard {\n+            s: Mutex::new(\"A String\".to_owned()),\n+        }\n+    }\n+    fn lock(&self) -> Box<MutexGuard<String>> {\n+        Box::new(self.s.lock().unwrap())\n+    }\n+}\n+\n+fn should_trigger_lint_for_boxed_mutex_guard_holding_string() {\n+    let s = StateStringWithBoxedMutexGuard::new();\n+\n+    let matcher = String::from(\"A String\");\n+\n+    // Should trigger lint because a temporary Box holding a type with a significant drop in a match\n+    // scrutinee may have a potentially surprising lifetime.\n+    match s.lock().deref().deref() {\n+        matcher => println!(\"Value is {}\", s.lock().deref()),\n+        _ => println!(\"Value was not a match\"),\n+    };\n+}\n+\n+struct StateWithIntField {\n+    i: u64,\n+}\n+\n+// Should trigger lint when either side of an assign expression contains a temporary with a\n+// significant drop, because the temporary's lifetime will be extended to the end of the match.\n+// To avoid potential unnecessary copies or creating references that would trigger the significant\n+// drop problem, the lint recommends moving the entire binary operation.\n+fn should_trigger_lint_in_assign_expr() {\n+    let mutex = Mutex::new(StateWithIntField { i: 10 });\n+\n+    let mut i = 100;\n+\n+    match mutex.lock().unwrap().i = i {\n+        _ => {\n+            println!(\"{}\", mutex.lock().unwrap().i);\n+        },\n+    };\n+\n+    match i = mutex.lock().unwrap().i {\n+        _ => {\n+            println!(\"{}\", mutex.lock().unwrap().i);\n+        },\n+    };\n+\n+    match mutex.lock().unwrap().i += 1 {\n+        _ => {\n+            println!(\"{}\", mutex.lock().unwrap().i);\n+        },\n+    };\n+\n+    match i += mutex.lock().unwrap().i {\n+        _ => {\n+            println!(\"{}\", mutex.lock().unwrap().i);\n+        },\n+    };\n+}\n+\n+#[derive(Debug)]\n+enum RecursiveEnum {\n+    Foo(Option<Box<RecursiveEnum>>),\n+}\n+\n+#[derive(Debug)]\n+enum GenericRecursiveEnum<T> {\n+    Foo(T, Option<Box<GenericRecursiveEnum<T>>>),\n+}\n+\n+fn should_not_cause_stack_overflow() {\n+    // Test that when a type recursively contains itself, a stack overflow does not occur when\n+    // checking sub-types for significant drops.\n+    let f = RecursiveEnum::Foo(Some(Box::new(RecursiveEnum::Foo(None))));\n+    match f {\n+        RecursiveEnum::Foo(Some(f)) => {\n+            println!(\"{:?}\", f)\n+        },\n+        RecursiveEnum::Foo(f) => {\n+            println!(\"{:?}\", f)\n+        },\n+    }\n+\n+    let f = GenericRecursiveEnum::Foo(1u64, Some(Box::new(GenericRecursiveEnum::Foo(2u64, None))));\n+    match f {\n+        GenericRecursiveEnum::Foo(i, Some(f)) => {\n+            println!(\"{} {:?}\", i, f)\n+        },\n+        GenericRecursiveEnum::Foo(i, f) => {\n+            println!(\"{} {:?}\", i, f)\n+        },\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "af160564985051bdc8008dce745abecd7d99d497", "filename": "tests/ui/significant_drop_in_scrutinee.stderr", "status": "added", "additions": 283, "deletions": 0, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/tests%2Fui%2Fsignificant_drop_in_scrutinee.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/tests%2Fui%2Fsignificant_drop_in_scrutinee.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsignificant_drop_in_scrutinee.stderr?ref=b312ad7d0cf0f30be2bd4658b71a3520a2e76709", "patch": "@@ -0,0 +1,283 @@\n+error: temporary with significant drop in match scrutinee\n+  --> $DIR/significant_drop_in_scrutinee.rs:57:11\n+   |\n+LL |     match mutex.lock().unwrap().foo() {\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::significant-drop-in-scrutinee` implied by `-D warnings`\n+help: try moving the temporary above the match\n+   |\n+LL ~     let value = mutex.lock().unwrap().foo();\n+LL ~     match value {\n+   |\n+\n+error: temporary with significant drop in match scrutinee\n+  --> $DIR/significant_drop_in_scrutinee.rs:130:11\n+   |\n+LL |     match s.lock_m().get_the_value() {\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try moving the temporary above the match\n+   |\n+LL ~     let value = s.lock_m().get_the_value();\n+LL ~     match value {\n+   |\n+\n+error: temporary with significant drop in match scrutinee\n+  --> $DIR/significant_drop_in_scrutinee.rs:151:11\n+   |\n+LL |     match s.lock_m_m().get_the_value() {\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try moving the temporary above the match\n+   |\n+LL ~     let value = s.lock_m_m().get_the_value();\n+LL ~     match value {\n+   |\n+\n+error: temporary with significant drop in match scrutinee\n+  --> $DIR/significant_drop_in_scrutinee.rs:199:11\n+   |\n+LL |     match counter.temp_increment().len() {\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try moving the temporary above the match\n+   |\n+LL ~     let value = counter.temp_increment().len();\n+LL ~     match value {\n+   |\n+\n+error: temporary with significant drop in match scrutinee\n+  --> $DIR/significant_drop_in_scrutinee.rs:222:16\n+   |\n+LL |         match (mutex1.lock().unwrap().s.len(), true) {\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try moving the temporary above the match\n+   |\n+LL ~         let value = mutex1.lock().unwrap().s.len();\n+LL ~         match (value, true) {\n+   |\n+\n+error: temporary with significant drop in match scrutinee\n+  --> $DIR/significant_drop_in_scrutinee.rs:231:22\n+   |\n+LL |         match (true, mutex1.lock().unwrap().s.len(), true) {\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try moving the temporary above the match\n+   |\n+LL ~         let value = mutex1.lock().unwrap().s.len();\n+LL ~         match (true, value, true) {\n+   |\n+\n+error: temporary with significant drop in match scrutinee\n+  --> $DIR/significant_drop_in_scrutinee.rs:241:16\n+   |\n+LL |         match (mutex1.lock().unwrap().s.len(), true, mutex2.lock().unwrap().s.len()) {\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try moving the temporary above the match\n+   |\n+LL ~         let value = mutex1.lock().unwrap().s.len();\n+LL ~         match (value, true, mutex2.lock().unwrap().s.len()) {\n+   |\n+\n+error: temporary with significant drop in match scrutinee\n+  --> $DIR/significant_drop_in_scrutinee.rs:241:54\n+   |\n+LL |         match (mutex1.lock().unwrap().s.len(), true, mutex2.lock().unwrap().s.len()) {\n+   |                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try moving the temporary above the match\n+   |\n+LL ~         let value = mutex2.lock().unwrap().s.len();\n+LL ~         match (mutex1.lock().unwrap().s.len(), true, value) {\n+   |\n+\n+error: temporary with significant drop in match scrutinee\n+  --> $DIR/significant_drop_in_scrutinee.rs:252:15\n+   |\n+LL |         match mutex3.lock().unwrap().s.as_str() {\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: temporary with significant drop in match scrutinee\n+  --> $DIR/significant_drop_in_scrutinee.rs:262:22\n+   |\n+LL |         match (true, mutex3.lock().unwrap().s.as_str()) {\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: temporary with significant drop in match scrutinee\n+  --> $DIR/significant_drop_in_scrutinee.rs:281:11\n+   |\n+LL |     match mutex.lock().unwrap().s.len() > 1 {\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try moving the temporary above the match\n+   |\n+LL ~     let value = mutex.lock().unwrap().s.len() > 1;\n+LL ~     match value {\n+   |\n+\n+error: temporary with significant drop in match scrutinee\n+  --> $DIR/significant_drop_in_scrutinee.rs:288:11\n+   |\n+LL |     match 1 < mutex.lock().unwrap().s.len() {\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try moving the temporary above the match\n+   |\n+LL ~     let value = 1 < mutex.lock().unwrap().s.len();\n+LL ~     match value {\n+   |\n+\n+error: temporary with significant drop in match scrutinee\n+  --> $DIR/significant_drop_in_scrutinee.rs:306:11\n+   |\n+LL |     match mutex1.lock().unwrap().s.len() < mutex2.lock().unwrap().s.len() {\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try moving the temporary above the match\n+   |\n+LL ~     let value = mutex1.lock().unwrap().s.len() < mutex2.lock().unwrap().s.len();\n+LL ~     match value {\n+   |\n+\n+error: temporary with significant drop in match scrutinee\n+  --> $DIR/significant_drop_in_scrutinee.rs:317:11\n+   |\n+LL |     match mutex1.lock().unwrap().s.len() >= mutex2.lock().unwrap().s.len() {\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try moving the temporary above the match\n+   |\n+LL ~     let value = mutex1.lock().unwrap().s.len() >= mutex2.lock().unwrap().s.len();\n+LL ~     match value {\n+   |\n+\n+error: temporary with significant drop in match scrutinee\n+  --> $DIR/significant_drop_in_scrutinee.rs:352:11\n+   |\n+LL |     match get_mutex_guard().s.len() > 1 {\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try moving the temporary above the match\n+   |\n+LL ~     let value = get_mutex_guard().s.len() > 1;\n+LL ~     match value {\n+   |\n+\n+error: temporary with significant drop in match scrutinee\n+  --> $DIR/significant_drop_in_scrutinee.rs:369:11\n+   |\n+LL |       match match i {\n+   |  ___________^\n+LL | |         100 => mutex1.lock().unwrap(),\n+LL | |         _ => mutex2.lock().unwrap(),\n+LL | |     }\n+LL | |     .s\n+LL | |     .len()\n+LL | |         > 1\n+   | |___________^\n+   |\n+help: try moving the temporary above the match\n+   |\n+LL ~     let value = match i {\n+LL +         100 => mutex1.lock().unwrap(),\n+LL +         _ => mutex2.lock().unwrap(),\n+LL +     }\n+LL +     .s\n+LL +     .len()\n+ ...\n+\n+error: temporary with significant drop in match scrutinee\n+  --> $DIR/significant_drop_in_scrutinee.rs:395:11\n+   |\n+LL |       match if i > 1 {\n+   |  ___________^\n+LL | |         mutex1.lock().unwrap()\n+LL | |     } else {\n+LL | |         mutex2.lock().unwrap()\n+...  |\n+LL | |     .len()\n+LL | |         > 1\n+   | |___________^\n+   |\n+help: try moving the temporary above the match\n+   |\n+LL ~     let value = if i > 1 {\n+LL +         mutex1.lock().unwrap()\n+LL +     } else {\n+LL +         mutex2.lock().unwrap()\n+LL +     }\n+LL +     .s\n+ ...\n+\n+error: temporary with significant drop in match scrutinee\n+  --> $DIR/significant_drop_in_scrutinee.rs:449:11\n+   |\n+LL |     match s.lock().deref().deref() {\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try moving the temporary above the match and create a copy\n+   |\n+LL ~     let value = *s.lock().deref().deref();\n+LL ~     match value {\n+   |\n+\n+error: temporary with significant drop in match scrutinee\n+  --> $DIR/significant_drop_in_scrutinee.rs:477:11\n+   |\n+LL |     match s.lock().deref().deref() {\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: temporary with significant drop in match scrutinee\n+  --> $DIR/significant_drop_in_scrutinee.rs:496:11\n+   |\n+LL |     match mutex.lock().unwrap().i = i {\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try moving the temporary above the match\n+   |\n+LL ~     mutex.lock().unwrap().i = i;\n+LL ~     match () {\n+   |\n+\n+error: temporary with significant drop in match scrutinee\n+  --> $DIR/significant_drop_in_scrutinee.rs:502:11\n+   |\n+LL |     match i = mutex.lock().unwrap().i {\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try moving the temporary above the match\n+   |\n+LL ~     i = mutex.lock().unwrap().i;\n+LL ~     match () {\n+   |\n+\n+error: temporary with significant drop in match scrutinee\n+  --> $DIR/significant_drop_in_scrutinee.rs:508:11\n+   |\n+LL |     match mutex.lock().unwrap().i += 1 {\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try moving the temporary above the match\n+   |\n+LL ~     mutex.lock().unwrap().i += 1;\n+LL ~     match () {\n+   |\n+\n+error: temporary with significant drop in match scrutinee\n+  --> $DIR/significant_drop_in_scrutinee.rs:514:11\n+   |\n+LL |     match i += mutex.lock().unwrap().i {\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try moving the temporary above the match\n+   |\n+LL ~     i += mutex.lock().unwrap().i;\n+LL ~     match () {\n+   |\n+\n+error: aborting due to 23 previous errors\n+"}, {"sha": "6f8c8e47dfbf1fe56589a06f80017513e69167e8", "filename": "tests/ui/trait_duplication_in_bounds.stderr", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/tests%2Fui%2Ftrait_duplication_in_bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/tests%2Fui%2Ftrait_duplication_in_bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftrait_duplication_in_bounds.stderr?ref=b312ad7d0cf0f30be2bd4658b71a3520a2e76709", "patch": "@@ -67,13 +67,5 @@ LL |         Self: Iterator<Item = Foo>,\n    |\n    = help: consider removing this trait bound\n \n-error: this trait bound is already specified in the where clause\n-  --> $DIR/trait_duplication_in_bounds.rs:99:23\n-   |\n-LL | fn impl_trait(_: impl AsRef<str>, _: impl AsRef<str>) {}\n-   |                       ^^^^^^^^^^\n-   |\n-   = help: consider removing this trait bound\n-\n-error: aborting due to 9 previous errors\n+error: aborting due to 8 previous errors\n "}, {"sha": "148c19c7d0701dc2910de718d175a03122d26e03", "filename": "tests/ui/type_repetition_in_bounds.stderr", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/tests%2Fui%2Ftype_repetition_in_bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b312ad7d0cf0f30be2bd4658b71a3520a2e76709/tests%2Fui%2Ftype_repetition_in_bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype_repetition_in_bounds.stderr?ref=b312ad7d0cf0f30be2bd4658b71a3520a2e76709", "patch": "@@ -19,13 +19,5 @@ LL |     Self: Copy + Default + Ord,\n    |\n    = help: consider combining the bounds: `Self: Clone + Copy + Default + Ord`\n \n-error: this type has already been used as a bound predicate\n-  --> $DIR/type_repetition_in_bounds.rs:83:43\n-   |\n-LL | fn impl_trait(_: impl AsRef<str>, _: impl AsRef<str>) {}\n-   |                                           ^^^^^^^^^^\n-   |\n-   = help: consider combining the bounds: `impl AsRef<str>: AsRef<str> + AsRef<str>`\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n "}]}