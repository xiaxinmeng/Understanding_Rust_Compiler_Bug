{"sha": "bc1d205e4c653bb4879011a4975a81117dadb5c6", "node_id": "C_kwDOAAsO6NoAKGJjMWQyMDVlNGM2NTNiYjQ4NzkwMTFhNDk3NWE4MTExN2RhZGI1YzY", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-08-26T22:56:21Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-08-26T22:56:21Z"}, "message": "Rollup merge of #100724 - JeanCASPAR:migrate-ast_lowering-to-session-diagnostic, r=davidtwco\n\nMigrate ast lowering to session diagnostic\n\nI migrated the whole rustc_ast_lowering crate to session diagnostic *except* the for the use of `span_fatal` at /compiler/rustc_ast_lowering/src/expr.rs#L1268 because `#[fatal(...)]` is not yet supported (see https://github.com/rust-lang/rust/pull/100694).", "tree": {"sha": "01824efe8ee069bc228dbf13f0d4f35105208963", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/01824efe8ee069bc228dbf13f0d4f35105208963"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc1d205e4c653bb4879011a4975a81117dadb5c6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjCU+VCRBK7hj4Ov3rIwAAUlQIAEre8sAEdUEfCJlcGX2HGQqe\nLNEXtFrq4UM7qouHnI1MHLfn/iBHloDP44Boa4rBQDFsYWjz+utz0SFqr4hhlF+u\nNU3PwlijOryM0iyaZKYgmESyPRadKfmmvghjgTbXDHXgtShvOS5Fiv+oyo/2kxrf\nPGckdJ4qBVxvT9bVp5kDfg7A55OEr7pLgyuoIBdmlcl1epOdRIolNllfj3y5OmYm\nhvVbxnyfayoOwB1KDy2+59xeuSjeRolnS9Bar/9hzR4EuRZwL4cwoDu4M1UQ3wui\nM6xcgyMp5V9gNfdFt/xRAxTYDNudjgmXrHU7U96LcX1SffcgmKNQGRzvfFkkIR0=\n=FndZ\n-----END PGP SIGNATURE-----\n", "payload": "tree 01824efe8ee069bc228dbf13f0d4f35105208963\nparent c07a8b4e09f356c7468b69c50cac7fc5b5000b8a\nparent 5fef1b865f01d6d6c38288e1fcad3451e68e1765\nauthor Michael Goulet <michael@errs.io> 1661554581 -0700\ncommitter GitHub <noreply@github.com> 1661554581 -0700\n\nRollup merge of #100724 - JeanCASPAR:migrate-ast_lowering-to-session-diagnostic, r=davidtwco\n\nMigrate ast lowering to session diagnostic\n\nI migrated the whole rustc_ast_lowering crate to session diagnostic *except* the for the use of `span_fatal` at /compiler/rustc_ast_lowering/src/expr.rs#L1268 because `#[fatal(...)]` is not yet supported (see https://github.com/rust-lang/rust/pull/100694).\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc1d205e4c653bb4879011a4975a81117dadb5c6", "html_url": "https://github.com/rust-lang/rust/commit/bc1d205e4c653bb4879011a4975a81117dadb5c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc1d205e4c653bb4879011a4975a81117dadb5c6/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c07a8b4e09f356c7468b69c50cac7fc5b5000b8a", "url": "https://api.github.com/repos/rust-lang/rust/commits/c07a8b4e09f356c7468b69c50cac7fc5b5000b8a", "html_url": "https://github.com/rust-lang/rust/commit/c07a8b4e09f356c7468b69c50cac7fc5b5000b8a"}, {"sha": "5fef1b865f01d6d6c38288e1fcad3451e68e1765", "url": "https://api.github.com/repos/rust-lang/rust/commits/5fef1b865f01d6d6c38288e1fcad3451e68e1765", "html_url": "https://github.com/rust-lang/rust/commit/5fef1b865f01d6d6c38288e1fcad3451e68e1765"}], "stats": {"total": 859, "additions": 597, "deletions": 262}, "files": [{"sha": "e199e700fedf2f88e5e4f6a5f7b3af49f170da7d", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc1d205e4c653bb4879011a4975a81117dadb5c6/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/bc1d205e4c653bb4879011a4975a81117dadb5c6/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=bc1d205e4c653bb4879011a4975a81117dadb5c6", "patch": "@@ -3574,6 +3574,7 @@ dependencies = [\n  \"rustc_errors\",\n  \"rustc_hir\",\n  \"rustc_index\",\n+ \"rustc_macros\",\n  \"rustc_middle\",\n  \"rustc_query_system\",\n  \"rustc_session\","}, {"sha": "474aff2e2aac06fabc947ac8c733fa227c732e65", "filename": "compiler/rustc_ast_lowering/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc1d205e4c653bb4879011a4975a81117dadb5c6/compiler%2Frustc_ast_lowering%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bc1d205e4c653bb4879011a4975a81117dadb5c6/compiler%2Frustc_ast_lowering%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2FCargo.toml?ref=bc1d205e4c653bb4879011a4975a81117dadb5c6", "patch": "@@ -15,6 +15,7 @@ rustc_target = { path = \"../rustc_target\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n rustc_index = { path = \"../rustc_index\" }\n rustc_middle = { path = \"../rustc_middle\" }\n+rustc_macros = { path = \"../rustc_macros\" }\n rustc_query_system = { path = \"../rustc_query_system\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_errors = { path = \"../rustc_errors\" }"}, {"sha": "0dba9da63da2a03d0d18c3ccfe2697d5b672252e", "filename": "compiler/rustc_ast_lowering/src/asm.rs", "status": "modified", "additions": 74, "deletions": 105, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/bc1d205e4c653bb4879011a4975a81117dadb5c6/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc1d205e4c653bb4879011a4975a81117dadb5c6/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs?ref=bc1d205e4c653bb4879011a4975a81117dadb5c6", "patch": "@@ -1,11 +1,17 @@\n use crate::{ImplTraitContext, ImplTraitPosition, ParamMode, ResolverAstLoweringExt};\n \n+use super::errors::{\n+    AbiSpecifiedMultipleTimes, AttSyntaxOnlyX86, ClobberAbiNotSupported,\n+    InlineAsmUnsupportedTarget, InvalidAbiClobberAbi, InvalidAsmTemplateModifierConst,\n+    InvalidAsmTemplateModifierRegClass, InvalidAsmTemplateModifierRegClassSub,\n+    InvalidAsmTemplateModifierSym, InvalidRegister, InvalidRegisterClass, RegisterClassOnlyClobber,\n+    RegisterConflict,\n+};\n use super::LoweringContext;\n \n use rustc_ast::ptr::P;\n use rustc_ast::*;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::definitions::DefPathData;\n@@ -26,13 +32,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let asm_arch =\n             if self.tcx.sess.opts.actually_rustdoc { None } else { self.tcx.sess.asm_arch };\n         if asm_arch.is_none() && !self.tcx.sess.opts.actually_rustdoc {\n-            struct_span_err!(\n-                self.tcx.sess,\n-                sp,\n-                E0472,\n-                \"inline assembly is unsupported on this target\"\n-            )\n-            .emit();\n+            self.tcx.sess.emit_err(InlineAsmUnsupportedTarget { span: sp });\n         }\n         if let Some(asm_arch) = asm_arch {\n             // Inline assembly is currently only stable for these architectures.\n@@ -59,10 +59,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             && !matches!(asm_arch, Some(asm::InlineAsmArch::X86 | asm::InlineAsmArch::X86_64))\n             && !self.tcx.sess.opts.actually_rustdoc\n         {\n-            self.tcx\n-                .sess\n-                .struct_span_err(sp, \"the `att_syntax` option is only supported on x86\")\n-                .emit();\n+            self.tcx.sess.emit_err(AttSyntaxOnlyX86 { span: sp });\n         }\n         if asm.options.contains(InlineAsmOptions::MAY_UNWIND) && !self.tcx.features().asm_unwind {\n             feature_err(\n@@ -82,51 +79,37 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         // If the abi was already in the list, emit an error\n                         match clobber_abis.get(&abi) {\n                             Some((prev_name, prev_sp)) => {\n-                                let mut err = self.tcx.sess.struct_span_err(\n-                                    *abi_span,\n-                                    &format!(\"`{}` ABI specified multiple times\", prev_name),\n-                                );\n-                                err.span_label(*prev_sp, \"previously specified here\");\n-\n                                 // Multiple different abi names may actually be the same ABI\n                                 // If the specified ABIs are not the same name, alert the user that they resolve to the same ABI\n                                 let source_map = self.tcx.sess.source_map();\n-                                if source_map.span_to_snippet(*prev_sp)\n-                                    != source_map.span_to_snippet(*abi_span)\n-                                {\n-                                    err.note(\"these ABIs are equivalent on the current target\");\n-                                }\n+                                let equivalent = (source_map.span_to_snippet(*prev_sp)\n+                                    != source_map.span_to_snippet(*abi_span))\n+                                .then_some(());\n \n-                                err.emit();\n+                                self.tcx.sess.emit_err(AbiSpecifiedMultipleTimes {\n+                                    abi_span: *abi_span,\n+                                    prev_name: *prev_name,\n+                                    prev_span: *prev_sp,\n+                                    equivalent,\n+                                });\n                             }\n                             None => {\n-                                clobber_abis.insert(abi, (abi_name, *abi_span));\n+                                clobber_abis.insert(abi, (*abi_name, *abi_span));\n                             }\n                         }\n                     }\n                     Err(&[]) => {\n-                        self.tcx\n-                            .sess\n-                            .struct_span_err(\n-                                *abi_span,\n-                                \"`clobber_abi` is not supported on this target\",\n-                            )\n-                            .emit();\n+                        self.tcx.sess.emit_err(ClobberAbiNotSupported { abi_span: *abi_span });\n                     }\n                     Err(supported_abis) => {\n-                        let mut err = self\n-                            .tcx\n-                            .sess\n-                            .struct_span_err(*abi_span, \"invalid ABI for `clobber_abi`\");\n                         let mut abis = format!(\"`{}`\", supported_abis[0]);\n                         for m in &supported_abis[1..] {\n                             let _ = write!(abis, \", `{}`\", m);\n                         }\n-                        err.note(&format!(\n-                            \"the following ABIs are supported on this target: {}\",\n-                            abis\n-                        ));\n-                        err.emit();\n+                        self.tcx.sess.emit_err(InvalidAbiClobberAbi {\n+                            abi_span: *abi_span,\n+                            supported_abis: abis,\n+                        });\n                     }\n                 }\n             }\n@@ -141,24 +124,28 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             .iter()\n             .map(|(op, op_sp)| {\n                 let lower_reg = |reg| match reg {\n-                    InlineAsmRegOrRegClass::Reg(s) => {\n+                    InlineAsmRegOrRegClass::Reg(reg) => {\n                         asm::InlineAsmRegOrRegClass::Reg(if let Some(asm_arch) = asm_arch {\n-                            asm::InlineAsmReg::parse(asm_arch, s).unwrap_or_else(|e| {\n-                                let msg = format!(\"invalid register `{}`: {}\", s, e);\n-                                sess.struct_span_err(*op_sp, &msg).emit();\n+                            asm::InlineAsmReg::parse(asm_arch, reg).unwrap_or_else(|error| {\n+                                sess.emit_err(InvalidRegister { op_span: *op_sp, reg, error });\n                                 asm::InlineAsmReg::Err\n                             })\n                         } else {\n                             asm::InlineAsmReg::Err\n                         })\n                     }\n-                    InlineAsmRegOrRegClass::RegClass(s) => {\n+                    InlineAsmRegOrRegClass::RegClass(reg_class) => {\n                         asm::InlineAsmRegOrRegClass::RegClass(if let Some(asm_arch) = asm_arch {\n-                            asm::InlineAsmRegClass::parse(asm_arch, s).unwrap_or_else(|e| {\n-                                let msg = format!(\"invalid register class `{}`: {}\", s, e);\n-                                sess.struct_span_err(*op_sp, &msg).emit();\n-                                asm::InlineAsmRegClass::Err\n-                            })\n+                            asm::InlineAsmRegClass::parse(asm_arch, reg_class).unwrap_or_else(\n+                                |error| {\n+                                    sess.emit_err(InvalidRegisterClass {\n+                                        op_span: *op_sp,\n+                                        reg_class,\n+                                        error,\n+                                    });\n+                                    asm::InlineAsmRegClass::Err\n+                                },\n+                            )\n                         } else {\n                             asm::InlineAsmRegClass::Err\n                         })\n@@ -282,50 +269,39 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         }\n                         let valid_modifiers = class.valid_modifiers(asm_arch.unwrap());\n                         if !valid_modifiers.contains(&modifier) {\n-                            let mut err = sess.struct_span_err(\n-                                placeholder_span,\n-                                \"invalid asm template modifier for this register class\",\n-                            );\n-                            err.span_label(placeholder_span, \"template modifier\");\n-                            err.span_label(op_sp, \"argument\");\n-                            if !valid_modifiers.is_empty() {\n+                            let sub = if !valid_modifiers.is_empty() {\n                                 let mut mods = format!(\"`{}`\", valid_modifiers[0]);\n                                 for m in &valid_modifiers[1..] {\n                                     let _ = write!(mods, \", `{}`\", m);\n                                 }\n-                                err.note(&format!(\n-                                    \"the `{}` register class supports \\\n-                                     the following template modifiers: {}\",\n-                                    class.name(),\n-                                    mods\n-                                ));\n+                                InvalidAsmTemplateModifierRegClassSub::SupportModifier {\n+                                    class_name: class.name(),\n+                                    modifiers: mods,\n+                                }\n                             } else {\n-                                err.note(&format!(\n-                                    \"the `{}` register class does not support template modifiers\",\n-                                    class.name()\n-                                ));\n-                            }\n-                            err.emit();\n+                                InvalidAsmTemplateModifierRegClassSub::DoesNotSupportModifier {\n+                                    class_name: class.name(),\n+                                }\n+                            };\n+                            sess.emit_err(InvalidAsmTemplateModifierRegClass {\n+                                placeholder_span,\n+                                op_span: op_sp,\n+                                sub,\n+                            });\n                         }\n                     }\n                     hir::InlineAsmOperand::Const { .. } => {\n-                        let mut err = sess.struct_span_err(\n+                        sess.emit_err(InvalidAsmTemplateModifierConst {\n                             placeholder_span,\n-                            \"asm template modifiers are not allowed for `const` arguments\",\n-                        );\n-                        err.span_label(placeholder_span, \"template modifier\");\n-                        err.span_label(op_sp, \"argument\");\n-                        err.emit();\n+                            op_span: op_sp,\n+                        });\n                     }\n                     hir::InlineAsmOperand::SymFn { .. }\n                     | hir::InlineAsmOperand::SymStatic { .. } => {\n-                        let mut err = sess.struct_span_err(\n+                        sess.emit_err(InvalidAsmTemplateModifierSym {\n                             placeholder_span,\n-                            \"asm template modifiers are not allowed for `sym` arguments\",\n-                        );\n-                        err.span_label(placeholder_span, \"template modifier\");\n-                        err.span_label(op_sp, \"argument\");\n-                        err.emit();\n+                            op_span: op_sp,\n+                        });\n                     }\n                 }\n             }\n@@ -346,12 +322,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 // require that the operand name an explicit register, not a\n                 // register class.\n                 if reg_class.is_clobber_only(asm_arch.unwrap()) && !op.is_clobber() {\n-                    let msg = format!(\n-                        \"register class `{}` can only be used as a clobber, \\\n-                             not as an input or output\",\n-                        reg_class.name()\n-                    );\n-                    sess.struct_span_err(op_sp, &msg).emit();\n+                    sess.emit_err(RegisterClassOnlyClobber {\n+                        op_span: op_sp,\n+                        reg_class_name: reg_class.name(),\n+                    });\n                     continue;\n                 }\n \n@@ -391,16 +365,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                                         unreachable!();\n                                     };\n \n-                                    let msg = format!(\n-                                        \"register `{}` conflicts with register `{}`\",\n-                                        reg.name(),\n-                                        reg2.name()\n-                                    );\n-                                    let mut err = sess.struct_span_err(op_sp, &msg);\n-                                    err.span_label(op_sp, &format!(\"register `{}`\", reg.name()));\n-                                    err.span_label(op_sp2, &format!(\"register `{}`\", reg2.name()));\n-\n-                                    match (op, op2) {\n+                                    let in_out = match (op, op2) {\n                                         (\n                                             hir::InlineAsmOperand::In { .. },\n                                             hir::InlineAsmOperand::Out { late, .. },\n@@ -411,14 +376,18 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                                         ) => {\n                                             assert!(!*late);\n                                             let out_op_sp = if input { op_sp2 } else { op_sp };\n-                                            let msg = \"use `lateout` instead of \\\n-                                                       `out` to avoid conflict\";\n-                                            err.span_help(out_op_sp, msg);\n-                                        }\n-                                        _ => {}\n-                                    }\n+                                            Some(out_op_sp)\n+                                        },\n+                                        _ => None,\n+                                    };\n \n-                                    err.emit();\n+                                    sess.emit_err(RegisterConflict {\n+                                        op_span1: op_sp,\n+                                        op_span2: op_sp2,\n+                                        reg1_name: reg.name(),\n+                                        reg2_name: reg2.name(),\n+                                        in_out\n+                                    });\n                                 }\n                                 Entry::Vacant(v) => {\n                                     if r == reg {"}, {"sha": "59f1b7180e4f4c5eb02c551ebb143208c9990642", "filename": "compiler/rustc_ast_lowering/src/errors.rs", "status": "added", "additions": 329, "deletions": 0, "changes": 329, "blob_url": "https://github.com/rust-lang/rust/blob/bc1d205e4c653bb4879011a4975a81117dadb5c6/compiler%2Frustc_ast_lowering%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc1d205e4c653bb4879011a4975a81117dadb5c6/compiler%2Frustc_ast_lowering%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Ferrors.rs?ref=bc1d205e4c653bb4879011a4975a81117dadb5c6", "patch": "@@ -0,0 +1,329 @@\n+use rustc_errors::{fluent, AddSubdiagnostic, Applicability, Diagnostic, DiagnosticArgFromDisplay};\n+use rustc_macros::{SessionDiagnostic, SessionSubdiagnostic};\n+use rustc_span::{symbol::Ident, Span, Symbol};\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::generic_type_with_parentheses, code = \"E0214\")]\n+pub struct GenericTypeWithParentheses {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub sub: Option<UseAngleBrackets>,\n+}\n+\n+#[derive(Clone, Copy)]\n+pub struct UseAngleBrackets {\n+    pub open_param: Span,\n+    pub close_param: Span,\n+}\n+\n+impl AddSubdiagnostic for UseAngleBrackets {\n+    fn add_to_diagnostic(self, diag: &mut Diagnostic) {\n+        diag.multipart_suggestion(\n+            fluent::ast_lowering::use_angle_brackets,\n+            vec![(self.open_param, String::from(\"<\")), (self.close_param, String::from(\">\"))],\n+            Applicability::MaybeIncorrect,\n+        );\n+    }\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[help]\n+#[diag(ast_lowering::invalid_abi, code = \"E0703\")]\n+pub struct InvalidAbi {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub abi: Symbol,\n+    pub valid_abis: String,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::assoc_ty_parentheses)]\n+pub struct AssocTyParentheses {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub sub: AssocTyParenthesesSub,\n+}\n+\n+#[derive(Clone, Copy)]\n+pub enum AssocTyParenthesesSub {\n+    Empty { parentheses_span: Span },\n+    NotEmpty { open_param: Span, close_param: Span },\n+}\n+\n+impl AddSubdiagnostic for AssocTyParenthesesSub {\n+    fn add_to_diagnostic(self, diag: &mut Diagnostic) {\n+        match self {\n+            Self::Empty { parentheses_span } => diag.multipart_suggestion(\n+                fluent::ast_lowering::remove_parentheses,\n+                vec![(parentheses_span, String::new())],\n+                Applicability::MaybeIncorrect,\n+            ),\n+            Self::NotEmpty { open_param, close_param } => diag.multipart_suggestion(\n+                fluent::ast_lowering::use_angle_brackets,\n+                vec![(open_param, String::from(\"<\")), (close_param, String::from(\">\"))],\n+                Applicability::MaybeIncorrect,\n+            ),\n+        };\n+    }\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_lowering::misplaced_impl_trait, code = \"E0562\")]\n+pub struct MisplacedImplTrait<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub position: DiagnosticArgFromDisplay<'a>,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::rustc_box_attribute_error)]\n+pub struct RustcBoxAttributeError {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::underscore_expr_lhs_assign)]\n+pub struct UnderscoreExprLhsAssign {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::base_expression_double_dot)]\n+pub struct BaseExpressionDoubleDot {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::await_only_in_async_fn_and_blocks, code = \"E0728\")]\n+pub struct AwaitOnlyInAsyncFnAndBlocks {\n+    #[primary_span]\n+    #[label]\n+    pub dot_await_span: Span,\n+    #[label(ast_lowering::this_not_async)]\n+    pub item_span: Option<Span>,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::generator_too_many_parameters, code = \"E0628\")]\n+pub struct GeneratorTooManyParameters {\n+    #[primary_span]\n+    pub fn_decl_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::closure_cannot_be_static, code = \"E0697\")]\n+pub struct ClosureCannotBeStatic {\n+    #[primary_span]\n+    pub fn_decl_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[help]\n+#[diag(ast_lowering::async_non_move_closure_not_supported, code = \"E0708\")]\n+pub struct AsyncNonMoveClosureNotSupported {\n+    #[primary_span]\n+    pub fn_decl_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::functional_record_update_destructuring_assignment)]\n+pub struct FunctionalRecordUpdateDestructuringAssignemnt {\n+    #[primary_span]\n+    #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::async_generators_not_supported, code = \"E0727\")]\n+pub struct AsyncGeneratorsNotSupported {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::inline_asm_unsupported_target, code = \"E0472\")]\n+pub struct InlineAsmUnsupportedTarget {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::att_syntax_only_x86)]\n+pub struct AttSyntaxOnlyX86 {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::abi_specified_multiple_times)]\n+pub struct AbiSpecifiedMultipleTimes {\n+    #[primary_span]\n+    pub abi_span: Span,\n+    pub prev_name: Symbol,\n+    #[label]\n+    pub prev_span: Span,\n+    #[note]\n+    pub equivalent: Option<()>,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::clobber_abi_not_supported)]\n+pub struct ClobberAbiNotSupported {\n+    #[primary_span]\n+    pub abi_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[note]\n+#[diag(ast_lowering::invalid_abi_clobber_abi)]\n+pub struct InvalidAbiClobberAbi {\n+    #[primary_span]\n+    pub abi_span: Span,\n+    pub supported_abis: String,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::invalid_register)]\n+pub struct InvalidRegister<'a> {\n+    #[primary_span]\n+    pub op_span: Span,\n+    pub reg: Symbol,\n+    pub error: &'a str,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::invalid_register_class)]\n+pub struct InvalidRegisterClass<'a> {\n+    #[primary_span]\n+    pub op_span: Span,\n+    pub reg_class: Symbol,\n+    pub error: &'a str,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_lowering::invalid_asm_template_modifier_reg_class)]\n+pub struct InvalidAsmTemplateModifierRegClass {\n+    #[primary_span]\n+    #[label(ast_lowering::template_modifier)]\n+    pub placeholder_span: Span,\n+    #[label(ast_lowering::argument)]\n+    pub op_span: Span,\n+    #[subdiagnostic]\n+    pub sub: InvalidAsmTemplateModifierRegClassSub,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+pub enum InvalidAsmTemplateModifierRegClassSub {\n+    #[note(ast_lowering::support_modifiers)]\n+    SupportModifier { class_name: Symbol, modifiers: String },\n+    #[note(ast_lowering::does_not_support_modifiers)]\n+    DoesNotSupportModifier { class_name: Symbol },\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::invalid_asm_template_modifier_const)]\n+pub struct InvalidAsmTemplateModifierConst {\n+    #[primary_span]\n+    #[label(ast_lowering::template_modifier)]\n+    pub placeholder_span: Span,\n+    #[label(ast_lowering::argument)]\n+    pub op_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::invalid_asm_template_modifier_sym)]\n+pub struct InvalidAsmTemplateModifierSym {\n+    #[primary_span]\n+    #[label(ast_lowering::template_modifier)]\n+    pub placeholder_span: Span,\n+    #[label(ast_lowering::argument)]\n+    pub op_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::register_class_only_clobber)]\n+pub struct RegisterClassOnlyClobber {\n+    #[primary_span]\n+    pub op_span: Span,\n+    pub reg_class_name: Symbol,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::register_conflict)]\n+pub struct RegisterConflict<'a> {\n+    #[primary_span]\n+    #[label(ast_lowering::register1)]\n+    pub op_span1: Span,\n+    #[label(ast_lowering::register2)]\n+    pub op_span2: Span,\n+    pub reg1_name: &'a str,\n+    pub reg2_name: &'a str,\n+    #[help]\n+    pub in_out: Option<Span>,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[help]\n+#[diag(ast_lowering::sub_tuple_binding)]\n+pub struct SubTupleBinding<'a> {\n+    #[primary_span]\n+    #[label]\n+    #[suggestion_verbose(\n+        ast_lowering::sub_tuple_binding_suggestion,\n+        code = \"..\",\n+        applicability = \"maybe-incorrect\"\n+    )]\n+    pub span: Span,\n+    pub ident: Ident,\n+    pub ident_name: Symbol,\n+    pub ctx: &'a str,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::extra_double_dot)]\n+pub struct ExtraDoubleDot<'a> {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[label(ast_lowering::previously_used_here)]\n+    pub prev_span: Span,\n+    pub ctx: &'a str,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[note]\n+#[diag(ast_lowering::misplaced_double_dot)]\n+pub struct MisplacedDoubleDot {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::misplaced_relax_trait_bound)]\n+pub struct MisplacedRelaxTraitBound {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::not_supported_for_lifetime_binder_async_closure)]\n+pub struct NotSupportedForLifetimeBinderAsyncClosure {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::arbitrary_expression_in_pattern)]\n+pub struct ArbitraryExpressionInPattern {\n+    #[primary_span]\n+    pub span: Span,\n+}"}, {"sha": "61f8c0216f1cf91c2f6d7ef65e4c6667bbde5a0e", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 20, "deletions": 80, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/bc1d205e4c653bb4879011a4975a81117dadb5c6/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc1d205e4c653bb4879011a4975a81117dadb5c6/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=bc1d205e4c653bb4879011a4975a81117dadb5c6", "patch": "@@ -1,3 +1,9 @@\n+use super::errors::{\n+    AsyncGeneratorsNotSupported, AsyncNonMoveClosureNotSupported, AwaitOnlyInAsyncFnAndBlocks,\n+    BaseExpressionDoubleDot, ClosureCannotBeStatic, FunctionalRecordUpdateDestructuringAssignemnt,\n+    GeneratorTooManyParameters, NotSupportedForLifetimeBinderAsyncClosure, RustcBoxAttributeError,\n+    UnderscoreExprLhsAssign,\n+};\n use super::ResolverAstLoweringExt;\n use super::{ImplTraitContext, LoweringContext, ParamMode, ParenthesizedGenericArgs};\n use crate::{FnDeclKind, ImplTraitPosition};\n@@ -6,7 +12,6 @@ use rustc_ast::attr;\n use rustc_ast::ptr::P as AstP;\n use rustc_ast::*;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n-use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n use rustc_hir::definitions::DefPathData;\n@@ -45,13 +50,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                             let hir_id = self.lower_node_id(e.id);\n                             return hir::Expr { hir_id, kind, span: self.lower_span(e.span) };\n                         } else {\n-                            self.tcx.sess\n-                                .struct_span_err(\n-                                    e.span,\n-                                    \"#[rustc_box] requires precisely one argument \\\n-                                    and no other attributes are allowed\",\n-                                )\n-                                .emit();\n+                            self.tcx.sess.emit_err(RustcBoxAttributeError { span: e.span });\n                             hir::ExprKind::Err\n                         }\n                     } else if let Some(legacy_args) = self.resolver.legacy_const_generic_args(f) {\n@@ -211,13 +210,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     self.lower_expr_range(e.span, e1.as_deref(), e2.as_deref(), lims)\n                 }\n                 ExprKind::Underscore => {\n-                    self.tcx\n-                        .sess.struct_span_err(\n-                            e.span,\n-                            \"in expressions, `_` can only be used on the left-hand side of an assignment\",\n-                        )\n-                        .span_label(e.span, \"`_` not allowed here\")\n-                        .emit();\n+                    self.tcx.sess.emit_err(UnderscoreExprLhsAssign { span: e.span });\n                     hir::ExprKind::Err\n                 }\n                 ExprKind::Path(ref qself, ref path) => {\n@@ -249,11 +242,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     let rest = match &se.rest {\n                         StructRest::Base(e) => Some(self.lower_expr(e)),\n                         StructRest::Rest(sp) => {\n-                            self.tcx\n-                                .sess\n-                                .struct_span_err(*sp, \"base expression required after `..`\")\n-                                .span_label(*sp, \"add a base expression here\")\n-                                .emit();\n+                            self.tcx.sess.emit_err(BaseExpressionDoubleDot { span: *sp });\n                             Some(&*self.arena.alloc(self.expr_err(*sp)))\n                         }\n                         StructRest::None => None,\n@@ -662,17 +651,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         match self.generator_kind {\n             Some(hir::GeneratorKind::Async(_)) => {}\n             Some(hir::GeneratorKind::Gen) | None => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n+                self.tcx.sess.emit_err(AwaitOnlyInAsyncFnAndBlocks {\n                     dot_await_span,\n-                    E0728,\n-                    \"`await` is only allowed inside `async` functions and blocks\"\n-                );\n-                err.span_label(dot_await_span, \"only allowed inside `async` functions and blocks\");\n-                if let Some(item_sp) = self.current_item {\n-                    err.span_label(item_sp, \"this is not `async`\");\n-                }\n-                err.emit();\n+                    item_span: self.current_item,\n+                });\n             }\n         }\n         let span = self.mark_span_with_reason(DesugaringKind::Await, dot_await_span, None);\n@@ -892,13 +874,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         match generator_kind {\n             Some(hir::GeneratorKind::Gen) => {\n                 if decl.inputs.len() > 1 {\n-                    struct_span_err!(\n-                        self.tcx.sess,\n-                        fn_decl_span,\n-                        E0628,\n-                        \"too many parameters for a generator (expected 0 or 1 parameters)\"\n-                    )\n-                    .emit();\n+                    self.tcx.sess.emit_err(GeneratorTooManyParameters { fn_decl_span });\n                 }\n                 Some(movability)\n             }\n@@ -907,13 +883,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             }\n             None => {\n                 if movability == Movability::Static {\n-                    struct_span_err!(\n-                        self.tcx.sess,\n-                        fn_decl_span,\n-                        E0697,\n-                        \"closures cannot be static\"\n-                    )\n-                    .emit();\n+                    self.tcx.sess.emit_err(ClosureCannotBeStatic { fn_decl_span });\n                 }\n                 None\n             }\n@@ -946,10 +916,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         fn_decl_span: Span,\n     ) -> hir::ExprKind<'hir> {\n         if let &ClosureBinder::For { span, .. } = binder {\n-            self.tcx.sess.span_err(\n-                span,\n-                \"`for<...>` binders on `async` closures are not currently supported\",\n-            );\n+            self.tcx.sess.emit_err(NotSupportedForLifetimeBinderAsyncClosure { span });\n         }\n \n         let (binder_clause, generic_params) = self.lower_closure_binder(binder);\n@@ -960,17 +927,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let body = self.with_new_scopes(|this| {\n             // FIXME(cramertj): allow `async` non-`move` closures with arguments.\n             if capture_clause == CaptureBy::Ref && !decl.inputs.is_empty() {\n-                struct_span_err!(\n-                    this.tcx.sess,\n-                    fn_decl_span,\n-                    E0708,\n-                    \"`async` non-`move` closures with parameters are not currently supported\",\n-                )\n-                .help(\n-                    \"consider using `let` statements to manually capture \\\n-                    variables by reference before entering an `async move` closure\",\n-                )\n-                .emit();\n+                this.tcx.sess.emit_err(AsyncNonMoveClosureNotSupported { fn_decl_span });\n             }\n \n             // Transform `async |x: u8| -> X { ... }` into\n@@ -1210,20 +1167,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 );\n                 let fields_omitted = match &se.rest {\n                     StructRest::Base(e) => {\n-                        self.tcx\n-                            .sess\n-                            .struct_span_err(\n-                                e.span,\n-                                \"functional record updates are not allowed in destructuring \\\n-                                    assignments\",\n-                            )\n-                            .span_suggestion(\n-                                e.span,\n-                                \"consider removing the trailing pattern\",\n-                                \"\",\n-                                rustc_errors::Applicability::MachineApplicable,\n-                            )\n-                            .emit();\n+                        self.tcx.sess.emit_err(FunctionalRecordUpdateDestructuringAssignemnt {\n+                            span: e.span,\n+                        });\n                         true\n                     }\n                     StructRest::Rest(_) => true,\n@@ -1420,13 +1366,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         match self.generator_kind {\n             Some(hir::GeneratorKind::Gen) => {}\n             Some(hir::GeneratorKind::Async(_)) => {\n-                struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0727,\n-                    \"`async` generators are not yet supported\"\n-                )\n-                .emit();\n+                self.tcx.sess.emit_err(AsyncGeneratorsNotSupported { span });\n             }\n             None => self.generator_kind = Some(hir::GeneratorKind::Gen),\n         }"}, {"sha": "fd338ffc0c5e8b64c9ca0469cc25cb766070e671", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bc1d205e4c653bb4879011a4975a81117dadb5c6/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc1d205e4c653bb4879011a4975a81117dadb5c6/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=bc1d205e4c653bb4879011a4975a81117dadb5c6", "patch": "@@ -1,3 +1,4 @@\n+use super::errors::{InvalidAbi, MisplacedRelaxTraitBound};\n use super::ResolverAstLoweringExt;\n use super::{AstOwner, ImplTraitContext, ImplTraitPosition};\n use super::{FnDeclKind, LoweringContext, ParamMode};\n@@ -7,7 +8,6 @@ use rustc_ast::visit::AssocCtxt;\n use rustc_ast::*;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sorted_map::SortedMap;\n-use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{LocalDefId, CRATE_DEF_ID};\n@@ -1260,10 +1260,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     fn error_on_invalid_abi(&self, abi: StrLit) {\n-        struct_span_err!(self.tcx.sess, abi.span, E0703, \"invalid ABI: found `{}`\", abi.symbol)\n-            .span_label(abi.span, \"invalid ABI\")\n-            .help(&format!(\"valid ABIs: {}\", abi::all_names().join(\", \")))\n-            .emit();\n+        self.tcx.sess.emit_err(InvalidAbi {\n+            span: abi.span,\n+            abi: abi.symbol,\n+            valid_abis: abi::all_names().join(\", \"),\n+        });\n     }\n \n     fn lower_asyncness(&mut self, a: Async) -> hir::IsAsync {\n@@ -1338,11 +1339,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 }\n                 let is_param = *is_param.get_or_insert_with(compute_is_param);\n                 if !is_param {\n-                    self.diagnostic().span_err(\n-                        bound.span(),\n-                        \"`?Trait` bounds are only permitted at the \\\n-                        point where a type parameter is declared\",\n-                    );\n+                    self.tcx.sess.emit_err(MisplacedRelaxTraitBound { span: bound.span() });\n                 }\n             }\n         }"}, {"sha": "becb67d116546993df6ab13ea21db8e870529b79", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 13, "deletions": 26, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/bc1d205e4c653bb4879011a4975a81117dadb5c6/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc1d205e4c653bb4879011a4975a81117dadb5c6/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=bc1d205e4c653bb4879011a4975a81117dadb5c6", "patch": "@@ -39,6 +39,8 @@\n #[macro_use]\n extern crate tracing;\n \n+use crate::errors::{AssocTyParentheses, AssocTyParenthesesSub, MisplacedImplTrait};\n+\n use rustc_ast::ptr::P;\n use rustc_ast::visit;\n use rustc_ast::{self as ast, *};\n@@ -49,7 +51,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sorted_map::SortedMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::Lrc;\n-use rustc_errors::{struct_span_err, Applicability, Handler, StashKey};\n+use rustc_errors::{DiagnosticArgFromDisplay, Handler, StashKey};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, LifetimeRes, Namespace, PartialRes, PerNS, Res};\n use rustc_hir::def_id::{LocalDefId, CRATE_DEF_ID};\n@@ -75,6 +77,7 @@ macro_rules! arena_vec {\n \n mod asm;\n mod block;\n+mod errors;\n mod expr;\n mod index;\n mod item;\n@@ -1070,19 +1073,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     }\n \n     fn emit_bad_parenthesized_trait_in_assoc_ty(&self, data: &ParenthesizedArgs) {\n-        let mut err = self.tcx.sess.struct_span_err(\n-            data.span,\n-            \"parenthesized generic arguments cannot be used in associated type constraints\",\n-        );\n         // Suggest removing empty parentheses: \"Trait()\" -> \"Trait\"\n-        if data.inputs.is_empty() {\n+        let sub = if data.inputs.is_empty() {\n             let parentheses_span =\n                 data.inputs_span.shrink_to_lo().to(data.inputs_span.shrink_to_hi());\n-            err.multipart_suggestion(\n-                \"remove these parentheses\",\n-                vec![(parentheses_span, String::new())],\n-                Applicability::MaybeIncorrect,\n-            );\n+            AssocTyParenthesesSub::Empty { parentheses_span }\n         }\n         // Suggest replacing parentheses with angle brackets `Trait(params...)` to `Trait<params...>`\n         else {\n@@ -1096,13 +1091,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             // End of last argument to end of parameters\n             let close_param =\n                 data.inputs.last().unwrap().span.shrink_to_hi().to(data.inputs_span.shrink_to_hi());\n-            err.multipart_suggestion(\n-                &format!(\"use angle brackets instead\",),\n-                vec![(open_param, String::from(\"<\")), (close_param, String::from(\">\"))],\n-                Applicability::MaybeIncorrect,\n-            );\n-        }\n-        err.emit();\n+            AssocTyParenthesesSub::NotEmpty { open_param, close_param }\n+        };\n+        self.tcx.sess.emit_err(AssocTyParentheses { span: data.span, sub });\n     }\n \n     #[instrument(level = \"debug\", skip(self))]\n@@ -1341,14 +1332,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         path\n                     }\n                     ImplTraitContext::Disallowed(position) => {\n-                        let mut err = struct_span_err!(\n-                            self.tcx.sess,\n-                            t.span,\n-                            E0562,\n-                            \"`impl Trait` only allowed in function and inherent method return types, not in {}\",\n-                            position\n-                        );\n-                        err.emit();\n+                        self.tcx.sess.emit_err(MisplacedImplTrait {\n+                            span: t.span,\n+                            position: DiagnosticArgFromDisplay(&position),\n+                        });\n                         hir::TyKind::Err\n                     }\n                 }"}, {"sha": "1efa19a3a828655d22f7721cb4357d3cb5a308ff", "filename": "compiler/rustc_ast_lowering/src/pat.rs", "status": "modified", "additions": 12, "deletions": 26, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/bc1d205e4c653bb4879011a4975a81117dadb5c6/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc1d205e4c653bb4879011a4975a81117dadb5c6/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs?ref=bc1d205e4c653bb4879011a4975a81117dadb5c6", "patch": "@@ -1,11 +1,13 @@\n+use super::errors::{\n+    ArbitraryExpressionInPattern, ExtraDoubleDot, MisplacedDoubleDot, SubTupleBinding,\n+};\n use super::ResolverAstLoweringExt;\n use super::{ImplTraitContext, LoweringContext, ParamMode};\n use crate::ImplTraitPosition;\n \n use rustc_ast::ptr::P;\n use rustc_ast::*;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n-use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n use rustc_span::symbol::Ident;\n@@ -134,20 +136,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 // This is not allowed as a sub-tuple pattern\n                 PatKind::Ident(ref _bm, ident, Some(ref sub)) if sub.is_rest() => {\n                     let sp = pat.span;\n-                    self.diagnostic()\n-                        .struct_span_err(\n-                            sp,\n-                            &format!(\"`{} @` is not allowed in a {}\", ident.name, ctx),\n-                        )\n-                        .span_label(sp, \"this is only allowed in slice patterns\")\n-                        .help(\"remove this and bind each tuple field independently\")\n-                        .span_suggestion_verbose(\n-                            sp,\n-                            &format!(\"if you don't need to use the contents of {}, discard the tuple's remaining fields\", ident),\n-                            \"..\",\n-                            Applicability::MaybeIncorrect,\n-                        )\n-                        .emit();\n+                    self.tcx.sess.emit_err(SubTupleBinding {\n+                        span: sp,\n+                        ident_name: ident.name,\n+                        ident,\n+                        ctx,\n+                    });\n                 }\n                 _ => {}\n             }\n@@ -296,19 +290,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n     /// Emit a friendly error for extra `..` patterns in a tuple/tuple struct/slice pattern.\n     pub(crate) fn ban_extra_rest_pat(&self, sp: Span, prev_sp: Span, ctx: &str) {\n-        self.diagnostic()\n-            .struct_span_err(sp, &format!(\"`..` can only be used once per {} pattern\", ctx))\n-            .span_label(sp, &format!(\"can only be used once per {} pattern\", ctx))\n-            .span_label(prev_sp, \"previously used here\")\n-            .emit();\n+        self.tcx.sess.emit_err(ExtraDoubleDot { span: sp, prev_span: prev_sp, ctx });\n     }\n \n     /// Used to ban the `..` pattern in places it shouldn't be semantically.\n     fn ban_illegal_rest_pat(&self, sp: Span) -> hir::PatKind<'hir> {\n-        self.diagnostic()\n-            .struct_span_err(sp, \"`..` patterns are not allowed here\")\n-            .note(\"only allowed in tuple, tuple struct, and slice patterns\")\n-            .emit();\n+        self.tcx.sess.emit_err(MisplacedDoubleDot { span: sp });\n \n         // We're not in a list context so `..` can be reasonably treated\n         // as `_` because it should always be valid and roughly matches the\n@@ -345,8 +332,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             ExprKind::Path(..) if allow_paths => {}\n             ExprKind::Unary(UnOp::Neg, ref inner) if matches!(inner.kind, ExprKind::Lit(_)) => {}\n             _ => {\n-                self.diagnostic()\n-                    .span_err(expr.span, \"arbitrary expressions aren't allowed in patterns\");\n+                self.tcx.sess.emit_err(ArbitraryExpressionInPattern { span: expr.span });\n                 return self.arena.alloc(self.expr_err(expr.span));\n             }\n         }"}, {"sha": "5874d08a94fe06bac55a516e8abef538f386aa58", "filename": "compiler/rustc_ast_lowering/src/path.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/bc1d205e4c653bb4879011a4975a81117dadb5c6/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc1d205e4c653bb4879011a4975a81117dadb5c6/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs?ref=bc1d205e4c653bb4879011a4975a81117dadb5c6", "patch": "@@ -1,11 +1,11 @@\n use crate::ImplTraitPosition;\n \n+use super::errors::{GenericTypeWithParentheses, UseAngleBrackets};\n use super::ResolverAstLoweringExt;\n use super::{GenericArgsCtor, LifetimeRes, ParenthesizedGenericArgs};\n use super::{ImplTraitContext, LoweringContext, ParamMode};\n \n use rustc_ast::{self as ast, *};\n-use rustc_errors::{struct_span_err, Applicability};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, PartialRes, Res};\n use rustc_hir::GenericArg;\n@@ -185,18 +185,15 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     ) -> hir::PathSegment<'hir> {\n         debug!(\"path_span: {:?}, lower_path_segment(segment: {:?})\", path_span, segment,);\n         let (mut generic_args, infer_args) = if let Some(ref generic_args) = segment.args {\n-            let msg = \"parenthesized type parameters may only be used with a `Fn` trait\";\n             match **generic_args {\n                 GenericArgs::AngleBracketed(ref data) => {\n                     self.lower_angle_bracketed_parameter_data(data, param_mode, itctx)\n                 }\n                 GenericArgs::Parenthesized(ref data) => match parenthesized_generic_args {\n                     ParenthesizedGenericArgs::Ok => self.lower_parenthesized_parameter_data(data),\n                     ParenthesizedGenericArgs::Err => {\n-                        let mut err = struct_span_err!(self.tcx.sess, data.span, E0214, \"{}\", msg);\n-                        err.span_label(data.span, \"only `Fn` traits may use parentheses\");\n                         // Suggest replacing parentheses with angle brackets `Trait(params...)` to `Trait<params...>`\n-                        if !data.inputs.is_empty() {\n+                        let sub = if !data.inputs.is_empty() {\n                             // Start of the span to the 1st character of 1st argument\n                             let open_param = data.inputs_span.shrink_to_lo().to(data\n                                 .inputs\n@@ -212,16 +209,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                                 .span\n                                 .shrink_to_hi()\n                                 .to(data.inputs_span.shrink_to_hi());\n-                            err.multipart_suggestion(\n-                                &format!(\"use angle brackets instead\",),\n-                                vec![\n-                                    (open_param, String::from(\"<\")),\n-                                    (close_param, String::from(\">\")),\n-                                ],\n-                                Applicability::MaybeIncorrect,\n-                            );\n-                        }\n-                        err.emit();\n+\n+                            Some(UseAngleBrackets { open_param, close_param })\n+                        } else {\n+                            None\n+                        };\n+                        self.tcx.sess.emit_err(GenericTypeWithParentheses { span: data.span, sub });\n                         (\n                             self.lower_angle_bracketed_parameter_data(\n                                 &data.as_angle_bracketed_args(),"}, {"sha": "dcb1e2b08306fe65b23864db9ab851ba9ee1bb65", "filename": "compiler/rustc_error_messages/locales/en-US/ast_lowering.ftl", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/bc1d205e4c653bb4879011a4975a81117dadb5c6/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fast_lowering.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/bc1d205e4c653bb4879011a4975a81117dadb5c6/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fast_lowering.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fast_lowering.ftl?ref=bc1d205e4c653bb4879011a4975a81117dadb5c6", "patch": "@@ -0,0 +1,131 @@\n+ast_lowering_generic_type_with_parentheses =\n+    parenthesized type parameters may only be used with a `Fn` trait\n+    .label = only `Fn` traits may use parentheses\n+\n+ast_lowering_use_angle_brackets = use angle brackets instead\n+\n+ast_lowering_invalid_abi =\n+    invalid ABI: found `{$abi}`\n+    .label = invalid ABI\n+    .help = valid ABIs: {$valid_abis}\n+\n+ast_lowering_assoc_ty_parentheses =\n+    parenthesized generic arguments cannot be used in associated type constraints\n+\n+ast_lowering_remove_parentheses = remove these parentheses\n+\n+ast_lowering_misplaced_impl_trait =\n+    `impl Trait` only allowed in function and inherent method return types, not in {$position}\n+\n+ast_lowering_rustc_box_attribute_error =\n+    #[rustc_box] requires precisely one argument and no other attributes are allowed\n+\n+ast_lowering_underscore_expr_lhs_assign =\n+    in expressions, `_` can only be used on the left-hand side of an assignment\n+    .label = `_` not allowed here\n+\n+ast_lowering_base_expression_double_dot =\n+    base expression required after `..`\n+    .label = add a base expression here\n+\n+ast_lowering_await_only_in_async_fn_and_blocks =\n+    `await` is only allowed inside `async` functions and blocks\n+    .label = only allowed inside `async` functions and blocks\n+\n+ast_lowering_this_not_async = this is not `async`\n+\n+ast_lowering_generator_too_many_parameters =\n+    too many parameters for a generator (expected 0 or 1 parameters)\n+\n+ast_lowering_closure_cannot_be_static = closures cannot be static\n+\n+ast_lowering_async_non_move_closure_not_supported =\n+    `async` non-`move` closures with parameters are not currently supported\n+    .help = consider using `let` statements to manually capture variables by reference before entering an `async move` closure\n+\n+ast_lowering_functional_record_update_destructuring_assignment =\n+    functional record updates are not allowed in destructuring assignments\n+    .suggestion = consider removing the trailing pattern\n+\n+ast_lowering_async_generators_not_supported =\n+    `async` generators are not yet supported\n+\n+ast_lowering_inline_asm_unsupported_target =\n+    inline assembly is unsupported on this target\n+\n+ast_lowering_att_syntax_only_x86 =\n+    the `att_syntax` option is only supported on x86\n+\n+ast_lowering_abi_specified_multiple_times =\n+    `{$prev_name}` ABI specified multiple times\n+    .label = previously specified here\n+    .note = these ABIs are equivalent on the current target\n+\n+ast_lowering_clobber_abi_not_supported =\n+    `clobber_abi` is not supported on this target\n+\n+ast_lowering_invalid_abi_clobber_abi =\n+    invalid ABI for `clobber_abi`\n+    .note = the following ABIs are supported on this target: {$supported_abis}\n+\n+ast_lowering_invalid_register =\n+    invalid register `{$reg}`: {$error}\n+\n+ast_lowering_invalid_register_class =\n+    invalid register class `{$reg_class}`: {$error}\n+\n+ast_lowering_invalid_asm_template_modifier_reg_class =\n+    invalid asm template modifier for this register class\n+\n+ast_lowering_argument = argument\n+\n+ast_lowering_template_modifier = template modifier\n+\n+ast_lowering_support_modifiers =\n+    the `{$class_name}` register class supports the following template modifiers: {$modifiers}\n+\n+ast_lowering_does_not_support_modifiers =\n+    the `{$class_name}` register class does not support template modifiers\n+\n+ast_lowering_invalid_asm_template_modifier_const =\n+    asm template modifiers are not allowed for `const` arguments\n+\n+ast_lowering_invalid_asm_template_modifier_sym =\n+    asm template modifiers are not allowed for `sym` arguments\n+\n+ast_lowering_register_class_only_clobber =\n+    register class `{$reg_class_name}` can only be used as a clobber, not as an input or output\n+\n+ast_lowering_register_conflict =\n+    register `{$reg1_name}` conflicts with register `{$reg2_name}`\n+    .help = use `lateout` instead of `out` to avoid conflict\n+\n+ast_lowering_register1 = register `{$reg1_name}`\n+\n+ast_lowering_register2 = register `{$reg2_name}`\n+\n+ast_lowering_sub_tuple_binding =\n+    `{$ident_name} @` is not allowed in a {$ctx}\n+    .label = this is only allowed in slice patterns\n+    .help = remove this and bind each tuple field independently\n+\n+ast_lowering_sub_tuple_binding_suggestion = if you don't need to use the contents of {$ident}, discard the tuple's remaining fields\n+\n+ast_lowering_extra_double_dot =\n+    `..` can only be used once per {$ctx} pattern\n+    .label = can only be used once per {$ctx} pattern\n+\n+ast_lowering_previously_used_here = previously used here\n+\n+ast_lowering_misplaced_double_dot =\n+    `..` patterns are not allowed here\n+    .note = only allowed in tuple, tuple struct, and slice patterns\n+\n+ast_lowering_misplaced_relax_trait_bound =\n+    `?Trait` bounds are only permitted at the point where a type parameter is declared\n+\n+ast_lowering_not_supported_for_lifetime_binder_async_closure =\n+    `for<...>` binders on `async` closures are not currently supported\n+\n+ast_lowering_arbitrary_expression_in_pattern =\n+    arbitrary expressions aren't allowed in patterns"}, {"sha": "75dbbb2d557a759a2e43b0f048dafc0902ece269", "filename": "compiler/rustc_error_messages/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc1d205e4c653bb4879011a4975a81117dadb5c6/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc1d205e4c653bb4879011a4975a81117dadb5c6/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs?ref=bc1d205e4c653bb4879011a4975a81117dadb5c6", "patch": "@@ -32,6 +32,7 @@ pub use unic_langid::{langid, LanguageIdentifier};\n \n // Generates `DEFAULT_LOCALE_RESOURCES` static and `fluent_generated` module.\n fluent_messages! {\n+    ast_lowering => \"../locales/en-US/ast_lowering.ftl\",\n     ast_passes => \"../locales/en-US/ast_passes.ftl\",\n     borrowck => \"../locales/en-US/borrowck.ftl\",\n     builtin_macros => \"../locales/en-US/builtin_macros.ftl\","}]}