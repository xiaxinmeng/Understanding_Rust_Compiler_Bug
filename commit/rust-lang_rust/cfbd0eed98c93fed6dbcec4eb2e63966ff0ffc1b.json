{"sha": "cfbd0eed98c93fed6dbcec4eb2e63966ff0ffc1b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmYmQwZWVkOThjOTNmZWQ2ZGJjZWM0ZWIyZTYzOTY2ZmYwZmZjMWI=", "commit": {"author": {"name": "Jack Huey", "email": "jack.huey@umassmed.edu", "date": "2021-03-12T17:38:42Z"}, "committer": {"name": "Jack Huey", "email": "jack.huey@umassmed.edu", "date": "2021-03-24T20:45:41Z"}, "message": "Review comments", "tree": {"sha": "b0414158dc43d04d48580ef39bf3a14aafdf0a86", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b0414158dc43d04d48580ef39bf3a14aafdf0a86"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cfbd0eed98c93fed6dbcec4eb2e63966ff0ffc1b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cfbd0eed98c93fed6dbcec4eb2e63966ff0ffc1b", "html_url": "https://github.com/rust-lang/rust/commit/cfbd0eed98c93fed6dbcec4eb2e63966ff0ffc1b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cfbd0eed98c93fed6dbcec4eb2e63966ff0ffc1b/comments", "author": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "19ecfcd0e2ae01c79159888a45042a5d6f4ed487", "url": "https://api.github.com/repos/rust-lang/rust/commits/19ecfcd0e2ae01c79159888a45042a5d6f4ed487", "html_url": "https://github.com/rust-lang/rust/commit/19ecfcd0e2ae01c79159888a45042a5d6f4ed487"}], "stats": {"total": 71, "additions": 51, "deletions": 20}, "files": [{"sha": "9014d798a64416743566ed27845c54a2adae9d54", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cfbd0eed98c93fed6dbcec4eb2e63966ff0ffc1b/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfbd0eed98c93fed6dbcec4eb2e63966ff0ffc1b/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=cfbd0eed98c93fed6dbcec4eb2e63966ff0ffc1b", "patch": "@@ -1252,12 +1252,18 @@ rustc_queries! {\n         desc { \"looking up link arguments for a crate\" }\n     }\n \n-    /// Lifetime resolution. See `middle::resolve_lifetimes`.\n-    query resolve_lifetimes_definition(_: LocalDefId) -> ResolveLifetimes {\n+    /// Does lifetime resolution, but does not descend into trait items. This\n+    /// should only be used for resolving lifetimes of on trait definitions,\n+    /// and is used to avoid cycles. Importantly, `resolve_lifetimes` still visits\n+    /// the same lifetimes and is responsible for diagnostics.\n+    /// See `rustc_resolve::late::lifetimes for details.\n+    query resolve_lifetimes_trait_definition(_: LocalDefId) -> ResolveLifetimes {\n         storage(ArenaCacheSelector<'tcx>)\n-        desc { \"resolving lifetimes in a definition\" }\n+        desc { \"resolving lifetimes for a trait definition\" }\n     }\n-    /// Lifetime resolution. See `middle::resolve_lifetimes`.\n+    /// Does lifetime resolution on items. Importantly, we can't resolve\n+    /// lifetimes directly on things like trait methods, because of trait params.\n+    /// See `rustc_resolve::late::lifetimes for details.\n     query resolve_lifetimes(_: LocalDefId) -> ResolveLifetimes {\n         storage(ArenaCacheSelector<'tcx>)\n         desc { \"resolving lifetimes\" }\n@@ -1270,6 +1276,10 @@ rustc_queries! {\n         Option<(LocalDefId, &'tcx FxHashSet<ItemLocalId>)> {\n         desc { \"testing if a region is late bound\" }\n     }\n+    /// For a given item (like a struct), gets the default lifetimes to be used\n+    /// for each paramter if a trait object were to be passed for that parameter.\n+    /// For example, for `struct Foo<'a, T, U>`, this would be `['static, 'static]`.\n+    /// For `struct Foo<'a, T: 'a, U>`, this would instead be `['a, 'static]`.\n     query object_lifetime_defaults_map(_: LocalDefId)\n         -> Option<Vec<ObjectLifetimeDefault>> {\n         desc { \"looking up lifetime defaults for a region on an item\" }"}, {"sha": "a47a574218f284866083c9a4b429070df7f3237c", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 37, "deletions": 16, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/cfbd0eed98c93fed6dbcec4eb2e63966ff0ffc1b/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfbd0eed98c93fed6dbcec4eb2e63966ff0ffc1b/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=cfbd0eed98c93fed6dbcec4eb2e63966ff0ffc1b", "patch": "@@ -174,7 +174,10 @@ crate struct LifetimeContext<'a, 'tcx> {\n \n     is_in_const_generic: bool,\n \n-    definition_only: bool,\n+    /// Indicates that we only care about the definition of a trait. This should\n+    /// be false if the `Item` we are resolving lifetimes for is not a trait or\n+    /// we eventually need lifetimes resolve for trait items.\n+    trait_definition_only: bool,\n \n     /// List of labels in the function/method currently under analysis.\n     labels_in_fn: Vec<Ident>,\n@@ -319,7 +322,7 @@ const ROOT_SCOPE: ScopeRef<'static> = &Scope::Root;\n \n pub fn provide(providers: &mut ty::query::Providers) {\n     *providers = ty::query::Providers {\n-        resolve_lifetimes_definition,\n+        resolve_lifetimes_trait_definition,\n         resolve_lifetimes,\n \n         named_region_map: |tcx, id| resolve_lifetimes_for(tcx, id).defs.get(&id),\n@@ -339,14 +342,16 @@ pub fn provide(providers: &mut ty::query::Providers) {\n /// Like `resolve_lifetimes`, but does not resolve lifetimes for trait items.\n /// Also does not generate any diagnostics.\n #[tracing::instrument(level = \"debug\", skip(tcx))]\n-fn resolve_lifetimes_definition(tcx: TyCtxt<'_>, local_def_id: LocalDefId) -> ResolveLifetimes {\n+fn resolve_lifetimes_trait_definition(\n+    tcx: TyCtxt<'_>,\n+    local_def_id: LocalDefId,\n+) -> ResolveLifetimes {\n     do_resolve(tcx, local_def_id, true)\n }\n \n-/// Computes the `ResolveLifetimes` map that contains data for the\n-/// entire crate. You should not read the result of this query\n-/// directly, but rather use `named_region_map`, `is_late_bound_map`,\n-/// etc.\n+/// Computes the `ResolveLifetimes` map that contains data for an entire `Item`.\n+/// You should not read the result of this query directly, but rather use\n+/// `named_region_map`, `is_late_bound_map`, etc.\n #[tracing::instrument(level = \"debug\", skip(tcx))]\n fn resolve_lifetimes(tcx: TyCtxt<'_>, local_def_id: LocalDefId) -> ResolveLifetimes {\n     do_resolve(tcx, local_def_id, false)\n@@ -355,7 +360,7 @@ fn resolve_lifetimes(tcx: TyCtxt<'_>, local_def_id: LocalDefId) -> ResolveLifeti\n fn do_resolve(\n     tcx: TyCtxt<'_>,\n     local_def_id: LocalDefId,\n-    definition_only: bool,\n+    trait_definition_only: bool,\n ) -> ResolveLifetimes {\n     let item = tcx.hir().expect_item(tcx.hir().local_def_id_to_hir_id(local_def_id));\n     let mut named_region_map =\n@@ -367,7 +372,7 @@ fn do_resolve(\n         trait_ref_hack: false,\n         is_in_fn_syntax: false,\n         is_in_const_generic: false,\n-        definition_only,\n+        trait_definition_only,\n         labels_in_fn: vec![],\n         xcrate_object_lifetime_defaults: Default::default(),\n         lifetime_uses: &mut Default::default(),\n@@ -390,19 +395,30 @@ fn do_resolve(\n     rl\n }\n \n+/// Given `any` owner (structs, traits, trait methods, etc.), does lifetime resolution.\n+/// There are two important things this does.\n+/// First, we have to resolve lifetimes for\n+/// the entire *`Item`* that contains this owner, because that's the largest \"scope\"\n+/// where we can have relevant lifetimes.\n+/// Second, if we are asking for lifetimes in a trait *definition*, we use `resolve_lifetimes_trait_definition`\n+/// instead of `resolve_lifetimes`, which does not descend into the trait items and does not emit diagnostics.\n+/// This allows us to avoid cycles. Importantly, if we ask for lifetimes for lifetimes that have an owner\n+/// other than the trait itself (like the trait methods or associated types), then we just use the regular\n+/// `resolve_lifetimes`.\n fn resolve_lifetimes_for<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> &'tcx ResolveLifetimes {\n     let item_id = item_for(tcx, def_id);\n     if item_id == def_id {\n         let item = tcx.hir().item(hir::ItemId { def_id: item_id });\n         match item.kind {\n-            hir::ItemKind::Trait(..) => tcx.resolve_lifetimes_definition(item_id),\n+            hir::ItemKind::Trait(..) => tcx.resolve_lifetimes_trait_definition(item_id),\n             _ => tcx.resolve_lifetimes(item_id),\n         }\n     } else {\n         tcx.resolve_lifetimes(item_id)\n     }\n }\n \n+/// Finds the `Item` that contains the given `LocalDefId`\n fn item_for(tcx: TyCtxt<'_>, local_def_id: LocalDefId) -> LocalDefId {\n     let hir_id = tcx.hir().local_def_id_to_hir_id(local_def_id);\n     match tcx.hir().find(hir_id) {\n@@ -470,7 +486,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     fn visit_nested_item(&mut self, _: hir::ItemId) {}\n \n     fn visit_trait_item_ref(&mut self, ii: &'tcx hir::TraitItemRef) {\n-        if !self.definition_only {\n+        if !self.trait_definition_only {\n             intravisit::walk_trait_item_ref(self, ii)\n         }\n     }\n@@ -513,6 +529,11 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 // Opaque types are visited when we visit the\n                 // `TyKind::OpaqueDef`, so that they have the lifetimes from\n                 // their parent opaque_ty in scope.\n+                //\n+                // The core idea here is that since OpaqueTys are generated with the impl Trait as\n+                // their owner, we can keep going until we find the Item that owns that. We then\n+                // conservatively add all resolved lifetimes. Otherwise we run into problems in\n+                // cases like `type Foo<'a> = impl Bar<As = impl Baz + 'a>`.\n                 for (_hir_id, node) in\n                     self.tcx.hir().parent_iter(self.tcx.hir().local_def_id_to_hir_id(item.def_id))\n                 {\n@@ -760,7 +781,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                                 };\n \n                                 if !parent_is_item {\n-                                    if !self.definition_only {\n+                                    if !self.trait_definition_only {\n                                         struct_span_err!(\n                                             self.tcx.sess,\n                                             lifetime.span,\n@@ -1007,7 +1028,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     }\n \n     fn visit_generics(&mut self, generics: &'tcx hir::Generics<'tcx>) {\n-        if !self.definition_only {\n+        if !self.trait_definition_only {\n             check_mixed_explicit_and_in_band_defs(self.tcx, &generics.params);\n         }\n         for param in generics.params {\n@@ -1501,7 +1522,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             trait_ref_hack: self.trait_ref_hack,\n             is_in_fn_syntax: self.is_in_fn_syntax,\n             is_in_const_generic: self.is_in_const_generic,\n-            definition_only: self.definition_only,\n+            trait_definition_only: self.trait_definition_only,\n             labels_in_fn,\n             xcrate_object_lifetime_defaults,\n             lifetime_uses,\n@@ -1511,7 +1532,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         {\n             let _enter = span.enter();\n             f(self.scope, &mut this);\n-            if !self.definition_only {\n+            if !self.trait_definition_only {\n                 this.check_uses_for_lifetimes_defined_by_scope();\n             }\n         }\n@@ -1973,7 +1994,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n \n             // Check for fn-syntax conflicts with in-band lifetime definitions\n-            if !self.definition_only && self.is_in_fn_syntax {\n+            if !self.trait_definition_only && self.is_in_fn_syntax {\n                 match def {\n                     Region::EarlyBound(_, _, LifetimeDefOrigin::InBand)\n                     | Region::LateBound(_, _, LifetimeDefOrigin::InBand) => {"}]}