{"sha": "7e9b92cb43a489b34e2bcb8d21f36198e02eedbc", "node_id": "C_kwDOAAsO6NoAKDdlOWI5MmNiNDNhNDg5YjM0ZTJiY2I4ZDIxZjM2MTk4ZTAyZWVkYmM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-03T17:55:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-03T17:55:02Z"}, "message": "Auto merge of #85993 - bjorn3:serde_json, r=wesleywiser\n\nRemove all json handling from rustc_serialize\n\nJson is now handled using serde_json. Where appropriate I have replaced json usage with binary serialization (rmeta files) or manual string formatting (emcc linker arg generation).\n\nThis allowed for removing and simplifying a lot of code, which hopefully results in faster serialization/deserialization and faster compiles of rustc itself.\n\nWhere sensible we now use serde. Metadata and incr cache serialization keeps using a heavily modified (compared to crates.io) rustc-serialize version that in the future could probably be extended with zero-copy deserialization or other perf tricks that serde can't support due to supporting more than one serialization format.\n\nNote that I had to remove `-Zast-json` and `-Zast-json-noexpand` as the relevant AST types don't implement `serde::Serialize`.\n\nFixes #40177\n\nSee also https://github.com/rust-lang/compiler-team/issues/418", "tree": {"sha": "e2731c205d38c4d2c11fdb1789add435a21bab23", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e2731c205d38c4d2c11fdb1789add435a21bab23"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc", "html_url": "https://github.com/rust-lang/rust/commit/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a74608543d499bcc7dd505e195e8bfab9447315", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a74608543d499bcc7dd505e195e8bfab9447315", "html_url": "https://github.com/rust-lang/rust/commit/9a74608543d499bcc7dd505e195e8bfab9447315"}, {"sha": "5cc3593c17360edd92977301ca66551a45119619", "url": "https://api.github.com/repos/rust-lang/rust/commits/5cc3593c17360edd92977301ca66551a45119619", "html_url": "https://github.com/rust-lang/rust/commit/5cc3593c17360edd92977301ca66551a45119619"}], "stats": {"total": 4838, "additions": 603, "deletions": 4235}, "files": [{"sha": "dd1869fb01f099b2e2545633edc2d347b074c2ea", "filename": "Cargo.lock", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=7e9b92cb43a489b34e2bcb8d21f36198e02eedbc", "patch": "@@ -3686,6 +3686,7 @@ dependencies = [\n  \"rustc_span\",\n  \"rustc_symbol_mangling\",\n  \"rustc_target\",\n+ \"serde_json\",\n  \"smallvec\",\n  \"snap\",\n  \"tempfile\",\n@@ -3774,6 +3775,7 @@ dependencies = [\n  \"rustc_span\",\n  \"rustc_target\",\n  \"rustc_typeck\",\n+ \"serde_json\",\n  \"tracing\",\n  \"winapi\",\n ]\n@@ -3809,6 +3811,8 @@ dependencies = [\n  \"rustc_macros\",\n  \"rustc_serialize\",\n  \"rustc_span\",\n+ \"serde\",\n+ \"serde_json\",\n  \"termcolor\",\n  \"termize\",\n  \"tracing\",\n@@ -4024,6 +4028,7 @@ dependencies = [\n  \"rustc_serialize\",\n  \"rustc_span\",\n  \"rustc_target\",\n+ \"serde\",\n ]\n \n [[package]]\n@@ -4445,6 +4450,7 @@ dependencies = [\n  \"rustc_macros\",\n  \"rustc_serialize\",\n  \"rustc_span\",\n+ \"serde_json\",\n  \"tracing\",\n ]\n "}, {"sha": "b64f7b8ad1b113a213b1ecc90903c8d9d35e69fe", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=7e9b92cb43a489b34e2bcb8d21f36198e02eedbc", "patch": "@@ -41,9 +41,6 @@ use std::convert::TryFrom;\n use std::fmt;\n use std::mem;\n \n-#[cfg(test)]\n-mod tests;\n-\n /// A \"Label\" is an identifier of some point in sources,\n /// e.g. in the following code:\n ///\n@@ -2476,8 +2473,8 @@ rustc_index::newtype_index! {\n }\n \n impl<S: Encoder> rustc_serialize::Encodable<S> for AttrId {\n-    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_unit()\n+    fn encode(&self, _s: &mut S) -> Result<(), S::Error> {\n+        Ok(())\n     }\n }\n "}, {"sha": "8ba55bf037b12bd15f1fdd1aeaeba8225442e215", "filename": "compiler/rustc_ast/src/ast/tests.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9a74608543d499bcc7dd505e195e8bfab9447315/compiler%2Frustc_ast%2Fsrc%2Fast%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a74608543d499bcc7dd505e195e8bfab9447315/compiler%2Frustc_ast%2Fsrc%2Fast%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast%2Ftests.rs?ref=9a74608543d499bcc7dd505e195e8bfab9447315", "patch": "@@ -1,11 +0,0 @@\n-use super::*;\n-\n-// Are ASTs encodable?\n-#[test]\n-fn check_asts_encodable() {\n-    fn assert_encodable<\n-        T: for<'a> rustc_serialize::Encodable<rustc_serialize::json::Encoder<'a>>,\n-    >() {\n-    }\n-    assert_encodable::<Crate>();\n-}"}, {"sha": "fd8c4f78b2fc20fe98ed487de57b8c09025a99c4", "filename": "compiler/rustc_codegen_ssa/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_codegen_ssa%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_codegen_ssa%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2FCargo.toml?ref=7e9b92cb43a489b34e2bcb8d21f36198e02eedbc", "patch": "@@ -16,6 +16,7 @@ jobserver = \"0.1.22\"\n tempfile = \"3.2\"\n thorin-dwp = \"0.2\"\n pathdiff = \"0.2.0\"\n+serde_json = \"1.0.59\"\n snap = \"1\"\n smallvec = { version = \"1.6.1\", features = [\"union\", \"may_dangle\"] }\n regex = \"1.4\""}, {"sha": "a24e4347839c7ac1ff42f85950d2516cf92256fc", "filename": "compiler/rustc_codegen_ssa/src/back/linker.rs", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs?ref=7e9b92cb43a489b34e2bcb8d21f36198e02eedbc", "patch": "@@ -14,7 +14,6 @@ use rustc_hir::def_id::{CrateNum, LOCAL_CRATE};\n use rustc_middle::middle::dependency_format::Linkage;\n use rustc_middle::middle::exported_symbols::{ExportedSymbol, SymbolExportInfo, SymbolExportKind};\n use rustc_middle::ty::TyCtxt;\n-use rustc_serialize::{json, Encoder};\n use rustc_session::config::{self, CrateType, DebugInfo, LinkerPluginLto, Lto, OptLevel, Strip};\n use rustc_session::Session;\n use rustc_span::symbol::Symbol;\n@@ -1152,21 +1151,12 @@ impl<'a> Linker for EmLinker<'a> {\n         self.cmd.arg(\"-s\");\n \n         let mut arg = OsString::from(\"EXPORTED_FUNCTIONS=\");\n-        let mut encoded = String::new();\n-\n-        {\n-            let mut encoder = json::Encoder::new(&mut encoded);\n-            let res = encoder.emit_seq(symbols.len(), |encoder| {\n-                for (i, sym) in symbols.iter().enumerate() {\n-                    encoder.emit_seq_elt(i, |encoder| encoder.emit_str(&(\"_\".to_owned() + sym)))?;\n-                }\n-                Ok(())\n-            });\n-            if let Err(e) = res {\n-                self.sess.fatal(&format!(\"failed to encode exported symbols: {}\", e));\n-            }\n-        }\n+        let encoded = serde_json::to_string(\n+            &symbols.iter().map(|sym| \"_\".to_owned() + sym).collect::<Vec<_>>(),\n+        )\n+        .unwrap();\n         debug!(\"{}\", encoded);\n+\n         arg.push(encoded);\n \n         self.cmd.arg(arg);"}, {"sha": "a2cbd9abc9047e525ed4933226cd7ca4b203998d", "filename": "compiler/rustc_driver/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2FCargo.toml?ref=7e9b92cb43a489b34e2bcb8d21f36198e02eedbc", "patch": "@@ -9,6 +9,7 @@ crate-type = [\"dylib\"]\n [dependencies]\n libc = \"0.2\"\n tracing = { version = \"0.1.28\" }\n+serde_json = \"1.0.59\"\n rustc_log = { path = \"../rustc_log\" }\n rustc_middle = { path = \"../rustc_middle\" }\n rustc_ast_pretty = { path = \"../rustc_ast_pretty\" }"}, {"sha": "179a184536efa5c0904666fae87a4cc8b280c620", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=7e9b92cb43a489b34e2bcb8d21f36198e02eedbc", "patch": "@@ -30,7 +30,6 @@ use rustc_log::stdout_isatty;\n use rustc_metadata::locator;\n use rustc_save_analysis as save;\n use rustc_save_analysis::DumpHandler;\n-use rustc_serialize::json::ToJson;\n use rustc_session::config::{nightly_options, CG_OPTIONS, DB_OPTIONS};\n use rustc_session::config::{ErrorOutputType, Input, OutputType, PrintRequest, TrimmedDefPaths};\n use rustc_session::cstore::MetadataLoader;\n@@ -40,6 +39,7 @@ use rustc_session::{config, DiagnosticOutput, Session};\n use rustc_session::{early_error, early_error_no_abort, early_warn};\n use rustc_span::source_map::{FileLoader, FileName};\n use rustc_span::symbol::sym;\n+use rustc_target::json::ToJson;\n \n use std::borrow::Cow;\n use std::cmp::max;\n@@ -343,10 +343,7 @@ fn run_compiler(\n                 return early_exit();\n             }\n \n-            if sess.opts.debugging_opts.parse_only\n-                || sess.opts.debugging_opts.show_span.is_some()\n-                || sess.opts.debugging_opts.ast_json_noexpand\n-            {\n+            if sess.opts.debugging_opts.parse_only || sess.opts.debugging_opts.show_span.is_some() {\n                 return early_exit();\n             }\n \n@@ -375,7 +372,7 @@ fn run_compiler(\n \n             queries.global_ctxt()?;\n \n-            if sess.opts.debugging_opts.no_analysis || sess.opts.debugging_opts.ast_json {\n+            if sess.opts.debugging_opts.no_analysis {\n                 return early_exit();\n             }\n \n@@ -665,7 +662,9 @@ fn print_crate_info(\n             }\n             Sysroot => println!(\"{}\", sess.sysroot.display()),\n             TargetLibdir => println!(\"{}\", sess.target_tlib_path.dir.display()),\n-            TargetSpec => println!(\"{}\", sess.target.to_json().pretty()),\n+            TargetSpec => {\n+                println!(\"{}\", serde_json::to_string_pretty(&sess.target.to_json()).unwrap());\n+            }\n             FileNames | CrateName => {\n                 let input = input.unwrap_or_else(|| {\n                     early_error(ErrorOutputType::default(), \"no input file provided\")"}, {"sha": "89557626057133ccbd2d623bcf7e46105d21521e", "filename": "compiler/rustc_errors/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_errors%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_errors%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2FCargo.toml?ref=7e9b92cb43a489b34e2bcb8d21f36198e02eedbc", "patch": "@@ -19,6 +19,8 @@ atty = \"0.2\"\n termcolor = \"1.0\"\n annotate-snippets = \"0.8.0\"\n termize = \"0.1.1\"\n+serde = { version = \"1.0.125\", features = [\"derive\"] }\n+serde_json = \"1.0.59\"\n \n [target.'cfg(windows)'.dependencies]\n winapi = { version = \"0.3\", features = [\"handleapi\", \"synchapi\", \"winbase\"] }"}, {"sha": "fff35ac6ac894be46a2ae26678a410b188661aab", "filename": "compiler/rustc_errors/src/json.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_errors%2Fsrc%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_errors%2Fsrc%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fjson.rs?ref=7e9b92cb43a489b34e2bcb8d21f36198e02eedbc", "patch": "@@ -28,7 +28,7 @@ use std::path::Path;\n use std::sync::{Arc, Mutex};\n use std::vec;\n \n-use rustc_serialize::json::{as_json, as_pretty_json};\n+use serde::Serialize;\n \n #[cfg(test)]\n mod tests;\n@@ -126,9 +126,9 @@ impl Emitter for JsonEmitter {\n     fn emit_diagnostic(&mut self, diag: &crate::Diagnostic) {\n         let data = Diagnostic::from_errors_diagnostic(diag, self);\n         let result = if self.pretty {\n-            writeln!(&mut self.dst, \"{}\", as_pretty_json(&data))\n+            writeln!(&mut self.dst, \"{}\", serde_json::to_string_pretty(&data).unwrap())\n         } else {\n-            writeln!(&mut self.dst, \"{}\", as_json(&data))\n+            writeln!(&mut self.dst, \"{}\", serde_json::to_string(&data).unwrap())\n         }\n         .and_then(|_| self.dst.flush());\n         if let Err(e) = result {\n@@ -139,9 +139,9 @@ impl Emitter for JsonEmitter {\n     fn emit_artifact_notification(&mut self, path: &Path, artifact_type: &str) {\n         let data = ArtifactNotification { artifact: path, emit: artifact_type };\n         let result = if self.pretty {\n-            writeln!(&mut self.dst, \"{}\", as_pretty_json(&data))\n+            writeln!(&mut self.dst, \"{}\", serde_json::to_string_pretty(&data).unwrap())\n         } else {\n-            writeln!(&mut self.dst, \"{}\", as_json(&data))\n+            writeln!(&mut self.dst, \"{}\", serde_json::to_string(&data).unwrap())\n         }\n         .and_then(|_| self.dst.flush());\n         if let Err(e) = result {\n@@ -161,9 +161,9 @@ impl Emitter for JsonEmitter {\n             .collect();\n         let report = FutureIncompatReport { future_incompat_report: data };\n         let result = if self.pretty {\n-            writeln!(&mut self.dst, \"{}\", as_pretty_json(&report))\n+            writeln!(&mut self.dst, \"{}\", serde_json::to_string_pretty(&report).unwrap())\n         } else {\n-            writeln!(&mut self.dst, \"{}\", as_json(&report))\n+            writeln!(&mut self.dst, \"{}\", serde_json::to_string(&report).unwrap())\n         }\n         .and_then(|_| self.dst.flush());\n         if let Err(e) = result {\n@@ -175,9 +175,9 @@ impl Emitter for JsonEmitter {\n         let lint_level = lint_level.as_str();\n         let data = UnusedExterns { lint_level, unused_extern_names: unused_externs };\n         let result = if self.pretty {\n-            writeln!(&mut self.dst, \"{}\", as_pretty_json(&data))\n+            writeln!(&mut self.dst, \"{}\", serde_json::to_string_pretty(&data).unwrap())\n         } else {\n-            writeln!(&mut self.dst, \"{}\", as_json(&data))\n+            writeln!(&mut self.dst, \"{}\", serde_json::to_string(&data).unwrap())\n         }\n         .and_then(|_| self.dst.flush());\n         if let Err(e) = result {\n@@ -204,7 +204,7 @@ impl Emitter for JsonEmitter {\n \n // The following data types are provided just for serialisation.\n \n-#[derive(Encodable)]\n+#[derive(Serialize)]\n struct Diagnostic {\n     /// The primary error message.\n     message: String,\n@@ -218,7 +218,7 @@ struct Diagnostic {\n     rendered: Option<String>,\n }\n \n-#[derive(Encodable)]\n+#[derive(Serialize)]\n struct DiagnosticSpan {\n     file_name: String,\n     byte_start: u32,\n@@ -245,7 +245,7 @@ struct DiagnosticSpan {\n     expansion: Option<Box<DiagnosticSpanMacroExpansion>>,\n }\n \n-#[derive(Encodable)]\n+#[derive(Serialize)]\n struct DiagnosticSpanLine {\n     text: String,\n \n@@ -255,7 +255,7 @@ struct DiagnosticSpanLine {\n     highlight_end: usize,\n }\n \n-#[derive(Encodable)]\n+#[derive(Serialize)]\n struct DiagnosticSpanMacroExpansion {\n     /// span where macro was applied to generate this code; note that\n     /// this may itself derive from a macro (if\n@@ -269,28 +269,28 @@ struct DiagnosticSpanMacroExpansion {\n     def_site_span: DiagnosticSpan,\n }\n \n-#[derive(Encodable)]\n+#[derive(Serialize)]\n struct DiagnosticCode {\n     /// The code itself.\n     code: String,\n     /// An explanation for the code.\n     explanation: Option<&'static str>,\n }\n \n-#[derive(Encodable)]\n+#[derive(Serialize)]\n struct ArtifactNotification<'a> {\n     /// The path of the artifact.\n     artifact: &'a Path,\n     /// What kind of artifact we're emitting.\n     emit: &'a str,\n }\n \n-#[derive(Encodable)]\n+#[derive(Serialize)]\n struct FutureBreakageItem {\n     diagnostic: Diagnostic,\n }\n \n-#[derive(Encodable)]\n+#[derive(Serialize)]\n struct FutureIncompatReport {\n     future_incompat_report: Vec<FutureBreakageItem>,\n }\n@@ -299,7 +299,7 @@ struct FutureIncompatReport {\n // doctest component (as well as cargo).\n // We could unify this struct the one in rustdoc but they have different\n // ownership semantics, so doing so would create wasteful allocations.\n-#[derive(Encodable)]\n+#[derive(Serialize)]\n struct UnusedExterns<'a, 'b, 'c> {\n     /// The severity level of the unused dependencies lint\n     lint_level: &'a str,"}, {"sha": "d940d14e1db91f26b8e803a48cdb10b9c4874b6f", "filename": "compiler/rustc_errors/src/json/tests.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_errors%2Fsrc%2Fjson%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_errors%2Fsrc%2Fjson%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fjson%2Ftests.rs?ref=7e9b92cb43a489b34e2bcb8d21f36198e02eedbc", "patch": "@@ -5,12 +5,18 @@ use rustc_span::source_map::{FilePathMapping, SourceMap};\n \n use crate::emitter::{ColorConfig, HumanReadableErrorType};\n use crate::Handler;\n-use rustc_serialize::json;\n use rustc_span::{BytePos, Span};\n \n use std::str;\n \n-#[derive(Debug, PartialEq, Eq)]\n+use serde::Deserialize;\n+\n+#[derive(Deserialize, Debug, PartialEq, Eq)]\n+struct TestData {\n+    spans: Vec<SpanTestData>,\n+}\n+\n+#[derive(Deserialize, Debug, PartialEq, Eq)]\n struct SpanTestData {\n     pub byte_start: u32,\n     pub byte_end: u32,\n@@ -61,19 +67,11 @@ fn test_positions(code: &str, span: (u32, u32), expected_output: SpanTestData) {\n \n         let bytes = output.lock().unwrap();\n         let actual_output = str::from_utf8(&bytes).unwrap();\n-        let actual_output = json::from_str(&actual_output).unwrap();\n-        let spans = actual_output[\"spans\"].as_array().unwrap();\n+        let actual_output: TestData = serde_json::from_str(actual_output).unwrap();\n+        let spans = actual_output.spans;\n         assert_eq!(spans.len(), 1);\n-        let obj = &spans[0];\n-        let actual_output = SpanTestData {\n-            byte_start: obj[\"byte_start\"].as_u64().unwrap() as u32,\n-            byte_end: obj[\"byte_end\"].as_u64().unwrap() as u32,\n-            line_start: obj[\"line_start\"].as_u64().unwrap() as u32,\n-            line_end: obj[\"line_end\"].as_u64().unwrap() as u32,\n-            column_start: obj[\"column_start\"].as_u64().unwrap() as u32,\n-            column_end: obj[\"column_end\"].as_u64().unwrap() as u32,\n-        };\n-        assert_eq!(expected_output, actual_output);\n+\n+        assert_eq!(expected_output, spans[0])\n     })\n }\n "}, {"sha": "3c867e308c40e8666b7451a70a4cd8024f0f13fd", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=7e9b92cb43a489b34e2bcb8d21f36198e02eedbc", "patch": "@@ -27,7 +27,6 @@ use rustc_passes::{self, hir_stats, layout_test};\n use rustc_plugin_impl as plugin;\n use rustc_query_impl::{OnDiskCache, Queries as TcxQueries};\n use rustc_resolve::{Resolver, ResolverArenas};\n-use rustc_serialize::json;\n use rustc_session::config::{CrateType, Input, OutputFilenames, OutputType};\n use rustc_session::cstore::{MetadataLoader, MetadataLoaderDyn};\n use rustc_session::output::{filename_for_input, filename_for_metadata};\n@@ -59,10 +58,6 @@ pub fn parse<'a>(sess: &'a Session, input: &Input) -> PResult<'a, ast::Crate> {\n         }\n     })?;\n \n-    if sess.opts.debugging_opts.ast_json_noexpand {\n-        println!(\"{}\", json::as_json(&krate));\n-    }\n-\n     if sess.opts.debugging_opts.input_stats {\n         eprintln!(\"Lines of code:             {}\", sess.source_map().count_lines());\n         eprintln!(\"Pre-expansion node count:  {}\", count_nodes(&krate));\n@@ -423,10 +418,6 @@ pub fn configure_and_expand(\n         hir_stats::print_ast_stats(&krate, \"POST EXPANSION AST STATS\");\n     }\n \n-    if sess.opts.debugging_opts.ast_json {\n-        println!(\"{}\", json::as_json(&krate));\n-    }\n-\n     resolver.resolve_crate(&krate);\n \n     // Needs to go *after* expansion to be able to check the results of macro expansion."}, {"sha": "a178cca6d108953633b02707ad48e4fd32e45f8c", "filename": "compiler/rustc_interface/src/tests.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ftests.rs?ref=7e9b92cb43a489b34e2bcb8d21f36198e02eedbc", "patch": "@@ -644,8 +644,6 @@ fn test_debugging_options_tracking_hash() {\n     // Make sure that changing an [UNTRACKED] option leaves the hash unchanged.\n     // This list is in alphabetical order.\n     untracked!(assert_incr_state, Some(String::from(\"loaded\")));\n-    untracked!(ast_json, true);\n-    untracked!(ast_json_noexpand, true);\n     untracked!(borrowck, String::from(\"other\"));\n     untracked!(deduplicate_diagnostics, false);\n     untracked!(dep_tasks, true);"}, {"sha": "2bf34d82f395c0c91772d319b781e97ef6c661aa", "filename": "compiler/rustc_lint_defs/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_lint_defs%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_lint_defs%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2FCargo.toml?ref=7e9b92cb43a489b34e2bcb8d21f36198e02eedbc", "patch": "@@ -4,6 +4,7 @@ version = \"0.0.0\"\n edition = \"2021\"\n \n [dependencies]\n+serde = { version = \"1.0.125\", features = [\"derive\"] }\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n rustc_error_messages = { path = \"../rustc_error_messages\" }"}, {"sha": "913dc58a1025953f7c2ba130c0066ac3723d743a", "filename": "compiler/rustc_lint_defs/src/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs?ref=7e9b92cb43a489b34e2bcb8d21f36198e02eedbc", "patch": "@@ -14,6 +14,8 @@ use rustc_span::edition::Edition;\n use rustc_span::{sym, symbol::Ident, Span, Symbol};\n use rustc_target::spec::abi::Abi;\n \n+use serde::{Deserialize, Serialize};\n+\n pub mod builtin;\n \n #[macro_export]\n@@ -34,7 +36,7 @@ macro_rules! pluralize {\n /// All suggestions are marked with an `Applicability`. Tools use the applicability of a suggestion\n /// to determine whether it should be automatically applied or if the user should be consulted\n /// before applying the suggestion.\n-#[derive(Copy, Clone, Debug, PartialEq, Hash, Encodable, Decodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Hash, Encodable, Decodable, Serialize, Deserialize)]\n pub enum Applicability {\n     /// The suggestion is definitely what the user intended, or maintains the exact meaning of the code.\n     /// This suggestion should be automatically applied."}, {"sha": "e99fa6c113b0d260a996ad58a42fc67cd82340a4", "filename": "compiler/rustc_macros/src/serialize.rs", "status": "modified", "additions": 9, "deletions": 35, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_macros%2Fsrc%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_macros%2Fsrc%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fserialize.rs?ref=7e9b92cb43a489b34e2bcb8d21f36198e02eedbc", "patch": "@@ -140,99 +140,73 @@ fn encodable_body(\n \n     let encode_body = match s.variants() {\n         [_] => {\n-            let mut field_idx = 0usize;\n             let encode_inner = s.each_variant(|vi| {\n                 vi.bindings()\n                     .iter()\n                     .map(|binding| {\n                         let bind_ident = &binding.binding;\n-                        let field_name = binding\n-                            .ast()\n-                            .ident\n-                            .as_ref()\n-                            .map_or_else(|| field_idx.to_string(), |i| i.to_string());\n-                        let first = field_idx == 0;\n                         let result = quote! {\n-                            match ::rustc_serialize::Encoder::emit_struct_field(\n+                            match ::rustc_serialize::Encodable::<#encoder_ty>::encode(\n+                                #bind_ident,\n                                 __encoder,\n-                                #field_name,\n-                                #first,\n-                                |__encoder|\n-                                ::rustc_serialize::Encodable::<#encoder_ty>::encode(#bind_ident, __encoder),\n                             ) {\n                                 ::std::result::Result::Ok(()) => (),\n                                 ::std::result::Result::Err(__err)\n                                     => return ::std::result::Result::Err(__err),\n                             }\n                         };\n-                        field_idx += 1;\n                         result\n                     })\n                     .collect::<TokenStream>()\n             });\n-            let no_fields = field_idx == 0;\n             quote! {\n-                ::rustc_serialize::Encoder::emit_struct(__encoder, #no_fields, |__encoder| {\n-                    ::std::result::Result::Ok(match *self { #encode_inner })\n-                })\n+                ::std::result::Result::Ok(match *self { #encode_inner })\n             }\n         }\n         _ => {\n             let mut variant_idx = 0usize;\n             let encode_inner = s.each_variant(|vi| {\n-                let variant_name = vi.ast().ident.to_string();\n-                let mut field_idx = 0usize;\n-\n                 let encode_fields: TokenStream = vi\n                     .bindings()\n                     .iter()\n                     .map(|binding| {\n                         let bind_ident = &binding.binding;\n-                        let first = field_idx == 0;\n                         let result = quote! {\n-                            match ::rustc_serialize::Encoder::emit_enum_variant_arg(\n+                            match ::rustc_serialize::Encodable::<#encoder_ty>::encode(\n+                                #bind_ident,\n                                 __encoder,\n-                                #first,\n-                                |__encoder|\n-                                ::rustc_serialize::Encodable::<#encoder_ty>::encode(#bind_ident, __encoder),\n                             ) {\n                                 ::std::result::Result::Ok(()) => (),\n                                 ::std::result::Result::Err(__err)\n                                     => return ::std::result::Result::Err(__err),\n                             }\n                         };\n-                        field_idx += 1;\n                         result\n                     })\n                     .collect();\n \n-                let result = if field_idx != 0 {\n+                let result = if !vi.bindings().is_empty() {\n                     quote! {\n                         ::rustc_serialize::Encoder::emit_enum_variant(\n                             __encoder,\n-                            #variant_name,\n                             #variant_idx,\n-                            #field_idx,\n                             |__encoder| { ::std::result::Result::Ok({ #encode_fields }) }\n                         )\n                     }\n                 } else {\n                     quote! {\n                         ::rustc_serialize::Encoder::emit_fieldless_enum_variant::<#variant_idx>(\n                             __encoder,\n-                            #variant_name,\n                         )\n                     }\n                 };\n                 variant_idx += 1;\n                 result\n             });\n             quote! {\n-                ::rustc_serialize::Encoder::emit_enum(__encoder, |__encoder| {\n-                    match *self {\n-                        #encode_inner\n-                    }\n-                })\n+                match *self {\n+                    #encode_inner\n+                }\n             }\n         }\n     };"}, {"sha": "1425c5467af873902896ad16a26f64234b3407f1", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=7e9b92cb43a489b34e2bcb8d21f36198e02eedbc", "patch": "@@ -95,11 +95,6 @@ macro_rules! encoder_methods {\n impl<'a, 'tcx> Encoder for EncodeContext<'a, 'tcx> {\n     type Error = <opaque::Encoder as Encoder>::Error;\n \n-    #[inline]\n-    fn emit_unit(&mut self) -> Result<(), Self::Error> {\n-        Ok(())\n-    }\n-\n     encoder_methods! {\n         emit_usize(usize);\n         emit_u128(u128);"}, {"sha": "146ae45e46898ffaae61e9fffd9f37ebe759d50c", "filename": "compiler/rustc_middle/src/mir/interpret/value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs?ref=7e9b92cb43a489b34e2bcb8d21f36198e02eedbc", "patch": "@@ -315,7 +315,7 @@ impl<Tag> Scalar<Tag> {\n                 ScalarSizeMismatch { target_size: target_size.bytes(), data_size: size.bytes() }\n             })?),\n             Scalar::Ptr(ptr, sz) => {\n-                if target_size.bytes() != sz.into() {\n+                if target_size.bytes() != u64::from(sz) {\n                     return Err(ScalarSizeMismatch {\n                         target_size: target_size.bytes(),\n                         data_size: sz.into(),"}, {"sha": "0b9ddaf64d4e26faeb9031f953061672bb9baa18", "filename": "compiler/rustc_middle/src/mir/predecessors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpredecessors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpredecessors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpredecessors.rs?ref=7e9b92cb43a489b34e2bcb8d21f36198e02eedbc", "patch": "@@ -56,8 +56,8 @@ impl PredecessorCache {\n \n impl<S: serialize::Encoder> serialize::Encodable<S> for PredecessorCache {\n     #[inline]\n-    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_unit()\n+    fn encode(&self, _s: &mut S) -> Result<(), S::Error> {\n+        Ok(())\n     }\n }\n "}, {"sha": "fbb26800e29c9fba22507c53ea3a4833ac413776", "filename": "compiler/rustc_middle/src/mir/switch_sources.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fswitch_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fswitch_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fswitch_sources.rs?ref=7e9b92cb43a489b34e2bcb8d21f36198e02eedbc", "patch": "@@ -56,8 +56,8 @@ impl SwitchSourceCache {\n \n impl<S: serialize::Encoder> serialize::Encodable<S> for SwitchSourceCache {\n     #[inline]\n-    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_unit()\n+    fn encode(&self, _s: &mut S) -> Result<(), S::Error> {\n+        Ok(())\n     }\n }\n "}, {"sha": "5e8226d356f56c8172936cd8aadd3266dcafd769", "filename": "compiler/rustc_middle/src/mir/traversal.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftraversal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftraversal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftraversal.rs?ref=7e9b92cb43a489b34e2bcb8d21f36198e02eedbc", "patch": "@@ -367,8 +367,8 @@ impl PostorderCache {\n \n impl<S: serialize::Encoder> serialize::Encodable<S> for PostorderCache {\n     #[inline]\n-    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_unit()\n+    fn encode(&self, _s: &mut S) -> Result<(), S::Error> {\n+        Ok(())\n     }\n }\n "}, {"sha": "e93bf1a475225adb2a8a15ef312f3b52214003cc", "filename": "compiler/rustc_query_impl/src/on_disk_cache.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs?ref=7e9b92cb43a489b34e2bcb8d21f36198e02eedbc", "patch": "@@ -993,11 +993,6 @@ where\n {\n     type Error = E::Error;\n \n-    #[inline]\n-    fn emit_unit(&mut self) -> Result<(), Self::Error> {\n-        Ok(())\n-    }\n-\n     encoder_methods! {\n         emit_usize(usize);\n         emit_u128(u128);"}, {"sha": "c4541bbcac921e9ec34083e6fc1355b9e6c4ca13", "filename": "compiler/rustc_serialize/src/collection_impls.rs", "status": "modified", "additions": 43, "deletions": 51, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_serialize%2Fsrc%2Fcollection_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_serialize%2Fsrc%2Fcollection_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fcollection_impls.rs?ref=7e9b92cb43a489b34e2bcb8d21f36198e02eedbc", "patch": "@@ -25,12 +25,11 @@ impl<D: Decoder, A: Array<Item: Decodable<D>>> Decodable<D> for SmallVec<A> {\n \n impl<S: Encoder, T: Encodable<S>> Encodable<S> for LinkedList<T> {\n     fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_seq(self.len(), |s| {\n-            for (i, e) in self.iter().enumerate() {\n-                s.emit_seq_elt(i, |s| e.encode(s))?;\n-            }\n-            Ok(())\n-        })\n+        s.emit_usize(self.len())?;\n+        for e in self.iter() {\n+            e.encode(s)?;\n+        }\n+        Ok(())\n     }\n }\n \n@@ -43,12 +42,11 @@ impl<D: Decoder, T: Decodable<D>> Decodable<D> for LinkedList<T> {\n \n impl<S: Encoder, T: Encodable<S>> Encodable<S> for VecDeque<T> {\n     fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_seq(self.len(), |s| {\n-            for (i, e) in self.iter().enumerate() {\n-                s.emit_seq_elt(i, |s| e.encode(s))?;\n-            }\n-            Ok(())\n-        })\n+        s.emit_usize(self.len())?;\n+        for e in self.iter() {\n+            e.encode(s)?;\n+        }\n+        Ok(())\n     }\n }\n \n@@ -65,13 +63,12 @@ where\n     V: Encodable<S>,\n {\n     fn encode(&self, e: &mut S) -> Result<(), S::Error> {\n-        e.emit_map(self.len(), |e| {\n-            for (i, (key, val)) in self.iter().enumerate() {\n-                e.emit_map_elt_key(i, |e| key.encode(e))?;\n-                e.emit_map_elt_val(|e| val.encode(e))?;\n-            }\n-            Ok(())\n-        })\n+        e.emit_usize(self.len())?;\n+        for (key, val) in self.iter() {\n+            key.encode(e)?;\n+            val.encode(e)?;\n+        }\n+        Ok(())\n     }\n }\n \n@@ -97,12 +94,11 @@ where\n     T: Encodable<S> + PartialEq + Ord,\n {\n     fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_seq(self.len(), |s| {\n-            for (i, e) in self.iter().enumerate() {\n-                s.emit_seq_elt(i, |s| e.encode(s))?;\n-            }\n-            Ok(())\n-        })\n+        s.emit_usize(self.len())?;\n+        for e in self.iter() {\n+            e.encode(s)?;\n+        }\n+        Ok(())\n     }\n }\n \n@@ -127,13 +123,12 @@ where\n     S: BuildHasher,\n {\n     fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n-        e.emit_map(self.len(), |e| {\n-            for (i, (key, val)) in self.iter().enumerate() {\n-                e.emit_map_elt_key(i, |e| key.encode(e))?;\n-                e.emit_map_elt_val(|e| val.encode(e))?;\n-            }\n-            Ok(())\n-        })\n+        e.emit_usize(self.len())?;\n+        for (key, val) in self.iter() {\n+            key.encode(e)?;\n+            val.encode(e)?;\n+        }\n+        Ok(())\n     }\n }\n \n@@ -162,12 +157,11 @@ where\n     S: BuildHasher,\n {\n     fn encode(&self, s: &mut E) -> Result<(), E::Error> {\n-        s.emit_seq(self.len(), |s| {\n-            for (i, e) in self.iter().enumerate() {\n-                s.emit_seq_elt(i, |s| e.encode(s))?;\n-            }\n-            Ok(())\n-        })\n+        s.emit_usize(self.len())?;\n+        for e in self.iter() {\n+            e.encode(s)?;\n+        }\n+        Ok(())\n     }\n }\n \n@@ -194,13 +188,12 @@ where\n     S: BuildHasher,\n {\n     fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n-        e.emit_map(self.len(), |e| {\n-            for (i, (key, val)) in self.iter().enumerate() {\n-                e.emit_map_elt_key(i, |e| key.encode(e))?;\n-                e.emit_map_elt_val(|e| val.encode(e))?;\n-            }\n-            Ok(())\n-        })\n+        e.emit_usize(self.len())?;\n+        for (key, val) in self.iter() {\n+            key.encode(e)?;\n+            val.encode(e)?;\n+        }\n+        Ok(())\n     }\n }\n \n@@ -229,12 +222,11 @@ where\n     S: BuildHasher,\n {\n     fn encode(&self, s: &mut E) -> Result<(), E::Error> {\n-        s.emit_seq(self.len(), |s| {\n-            for (i, e) in self.iter().enumerate() {\n-                s.emit_seq_elt(i, |s| e.encode(s))?;\n-            }\n-            Ok(())\n-        })\n+        s.emit_usize(self.len())?;\n+        for e in self.iter() {\n+            e.encode(s)?;\n+        }\n+        Ok(())\n     }\n }\n "}, {"sha": "c915dd5bbf65c261dc7878409f94252e7e9b6482", "filename": "compiler/rustc_serialize/src/json.rs", "status": "removed", "additions": 0, "deletions": 2368, "changes": 2368, "blob_url": "https://github.com/rust-lang/rust/blob/9a74608543d499bcc7dd505e195e8bfab9447315/compiler%2Frustc_serialize%2Fsrc%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a74608543d499bcc7dd505e195e8bfab9447315/compiler%2Frustc_serialize%2Fsrc%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fjson.rs?ref=9a74608543d499bcc7dd505e195e8bfab9447315", "patch": "@@ -1,2368 +0,0 @@\n-// Rust JSON serialization library.\n-// Copyright (c) 2011 Google Inc.\n-\n-#![forbid(non_camel_case_types)]\n-#![allow(missing_docs)]\n-\n-//! JSON parsing and serialization\n-//!\n-//! # What is JSON?\n-//!\n-//! JSON (JavaScript Object Notation) is a way to write data in Javascript.\n-//! Like XML, it allows to encode structured data in a text format that can be easily read by humans\n-//! Its simple syntax and native compatibility with JavaScript have made it a widely used format.\n-//!\n-//! Data types that can be encoded are JavaScript types (see the `Json` enum for more details):\n-//!\n-//! * `Boolean`: equivalent to rust's `bool`\n-//! * `Number`: equivalent to rust's `f64`\n-//! * `String`: equivalent to rust's `String`\n-//! * `Array`: equivalent to rust's `Vec<T>`, but also allowing objects of different types in the\n-//!   same array\n-//! * `Object`: equivalent to rust's `BTreeMap<String, json::Json>`\n-//! * `Null`\n-//!\n-//! An object is a series of string keys mapping to values, in `\"key\": value` format.\n-//! Arrays are enclosed in square brackets ([ ... ]) and objects in curly brackets ({ ... }).\n-//! A simple JSON document encoding a person, their age, address and phone numbers could look like\n-//!\n-//! ```json\n-//! {\n-//!     \"FirstName\": \"John\",\n-//!     \"LastName\": \"Doe\",\n-//!     \"Age\": 43,\n-//!     \"Address\": {\n-//!         \"Street\": \"Downing Street 10\",\n-//!         \"City\": \"London\",\n-//!         \"Country\": \"Great Britain\"\n-//!     },\n-//!     \"PhoneNumbers\": [\n-//!         \"+44 1234567\",\n-//!         \"+44 2345678\"\n-//!     ]\n-//! }\n-//! ```\n-//!\n-//! # Rust Type-based Encoding and Decoding\n-//!\n-//! To be able to encode a piece of data, it must implement the\n-//! `serialize::Encodable` trait.  The `rustc_macros` crate provides an\n-//! annotation to automatically generate the code for this trait: `#[derive(Encodable)]`.\n-//!\n-//! The JSON API provides an enum `json::Json` and a trait `ToJson` to encode objects.\n-//! The `ToJson` trait provides a `to_json` method to convert an object into a `json::Json` value.\n-//! A `json::Json` value can be encoded as a string or buffer using the functions described above.\n-//! You can also use the `json::Encoder` object, which implements the `Encoder` trait.\n-//!\n-//! When using `ToJson` the `Encodable` trait implementation is not mandatory.\n-//!\n-//! # Examples of use\n-//!\n-//! ## Using Autoserialization\n-//!\n-//! Create a struct called `TestStruct` and serialize and deserialize it to and from JSON using the\n-//! serialization API, using the derived serialization code.\n-//!\n-//! ```rust\n-//! # #![feature(rustc_private)]\n-//! use rustc_macros::{Encodable};\n-//! use rustc_serialize::json;\n-//!\n-//! // Automatically generate `Encodable` trait implementations\n-//! #[derive(Encodable)]\n-//! pub struct TestStruct  {\n-//!     data_int: u8,\n-//!     data_str: String,\n-//!     data_vector: Vec<u8>,\n-//! }\n-//!\n-//! let object = TestStruct {\n-//!     data_int: 1,\n-//!     data_str: \"homura\".to_string(),\n-//!     data_vector: vec![2,3,4,5],\n-//! };\n-//!\n-//! // Serialize using `json::encode`\n-//! let encoded = json::encode(&object).unwrap();\n-//! ```\n-//!\n-//! ## Using the `ToJson` trait\n-//!\n-//! The examples above use the `ToJson` trait to generate the JSON string, which is required\n-//! for custom mappings.\n-//!\n-//! ### Simple example of `ToJson` usage\n-//!\n-//! ```rust\n-//! # #![feature(rustc_private)]\n-//! use rustc_macros::Encodable;\n-//! use rustc_serialize::json::{self, ToJson, Json};\n-//!\n-//! // A custom data structure\n-//! struct ComplexNum {\n-//!     a: f64,\n-//!     b: f64,\n-//! }\n-//!\n-//! // JSON value representation\n-//! impl ToJson for ComplexNum {\n-//!     fn to_json(&self) -> Json {\n-//!         Json::String(format!(\"{}+{}i\", self.a, self.b))\n-//!     }\n-//! }\n-//!\n-//! // Only generate `Encodable` trait implementation\n-//! #[derive(Encodable)]\n-//! pub struct ComplexNumRecord {\n-//!     uid: u8,\n-//!     dsc: String,\n-//!     val: Json,\n-//! }\n-//!\n-//! let num = ComplexNum { a: 0.0001, b: 12.539 };\n-//! let data: String = json::encode(&ComplexNumRecord{\n-//!     uid: 1,\n-//!     dsc: \"test\".to_string(),\n-//!     val: num.to_json(),\n-//! }).unwrap();\n-//! println!(\"data: {}\", data);\n-//! // data: {\"uid\":1,\"dsc\":\"test\",\"val\":\"0.0001+12.539i\"};\n-//! ```\n-//!\n-//! ### Verbose example of `ToJson` usage\n-//!\n-//! ```rust\n-//! # #![feature(rustc_private)]\n-//! use std::collections::BTreeMap;\n-//! use rustc_serialize::json::{Json, ToJson};\n-//!\n-//! pub struct TestStruct {\n-//!     data_int: u8,\n-//!     data_str: String,\n-//!     data_vector: Vec<u8>,\n-//! }\n-//!\n-//! // Specify encoding method manually\n-//! impl ToJson for TestStruct {\n-//!     fn to_json(&self) -> Json {\n-//!         let mut d = BTreeMap::new();\n-//!         // All standard types implement `to_json()`, so use it\n-//!         d.insert(\"data_int\".to_string(), self.data_int.to_json());\n-//!         d.insert(\"data_str\".to_string(), self.data_str.to_json());\n-//!         d.insert(\"data_vector\".to_string(), self.data_vector.to_json());\n-//!         Json::Object(d)\n-//!     }\n-//! }\n-//!\n-//! // Serialize using `ToJson`\n-//! let input_data = TestStruct {\n-//!     data_int: 1,\n-//!     data_str: \"madoka\".to_string(),\n-//!     data_vector: vec![2,3,4,5],\n-//! };\n-//! let json_obj: Json = input_data.to_json();\n-//! let json_str: String = json_obj.to_string();\n-//! ```\n-\n-use self::ErrorCode::*;\n-use self::InternalStackElement::*;\n-use self::JsonEvent::*;\n-use self::ParserError::*;\n-use self::ParserState::*;\n-\n-use std::borrow::Cow;\n-use std::collections::{BTreeMap, HashMap};\n-use std::mem::swap;\n-use std::num::FpCategory as Fp;\n-use std::ops::Index;\n-use std::str::FromStr;\n-use std::string;\n-use std::{char, fmt, str};\n-\n-use crate::Encodable;\n-\n-/// Represents a json value\n-#[derive(Clone, PartialEq, PartialOrd, Debug)]\n-pub enum Json {\n-    I64(i64),\n-    U64(u64),\n-    F64(f64),\n-    String(string::String),\n-    Boolean(bool),\n-    Array(self::Array),\n-    Object(self::Object),\n-    Null,\n-}\n-\n-pub type Array = Vec<Json>;\n-pub type Object = BTreeMap<string::String, Json>;\n-\n-pub struct PrettyJson<'a> {\n-    inner: &'a Json,\n-}\n-\n-pub struct AsJson<'a, T> {\n-    inner: &'a T,\n-}\n-pub struct AsPrettyJson<'a, T> {\n-    inner: &'a T,\n-    indent: Option<usize>,\n-}\n-\n-/// The errors that can arise while parsing a JSON stream.\n-#[derive(Clone, Copy, PartialEq, Debug)]\n-pub enum ErrorCode {\n-    InvalidSyntax,\n-    InvalidNumber,\n-    EOFWhileParsingObject,\n-    EOFWhileParsingArray,\n-    EOFWhileParsingValue,\n-    EOFWhileParsingString,\n-    KeyMustBeAString,\n-    ExpectedColon,\n-    TrailingCharacters,\n-    TrailingComma,\n-    InvalidEscape,\n-    InvalidUnicodeCodePoint,\n-    LoneLeadingSurrogateInHexEscape,\n-    UnexpectedEndOfHexEscape,\n-    UnrecognizedHex,\n-    NotFourDigit,\n-    NotUtf8,\n-}\n-\n-#[derive(Clone, PartialEq, Debug)]\n-pub enum ParserError {\n-    /// msg, line, col\n-    SyntaxError(ErrorCode, usize, usize),\n-}\n-\n-// Builder and Parser have the same errors.\n-pub type BuilderError = ParserError;\n-\n-#[derive(Copy, Clone, Debug)]\n-pub enum EncoderError {\n-    FmtError(fmt::Error),\n-    BadHashmapKey,\n-}\n-\n-/// Returns a readable error string for a given error code.\n-pub fn error_str(error: ErrorCode) -> &'static str {\n-    match error {\n-        InvalidSyntax => \"invalid syntax\",\n-        InvalidNumber => \"invalid number\",\n-        EOFWhileParsingObject => \"EOF While parsing object\",\n-        EOFWhileParsingArray => \"EOF While parsing array\",\n-        EOFWhileParsingValue => \"EOF While parsing value\",\n-        EOFWhileParsingString => \"EOF While parsing string\",\n-        KeyMustBeAString => \"key must be a string\",\n-        ExpectedColon => \"expected `:`\",\n-        TrailingCharacters => \"trailing characters\",\n-        TrailingComma => \"trailing comma\",\n-        InvalidEscape => \"invalid escape\",\n-        UnrecognizedHex => \"invalid \\\\u{ esc}ape (unrecognized hex)\",\n-        NotFourDigit => \"invalid \\\\u{ esc}ape (not four digits)\",\n-        NotUtf8 => \"contents not utf-8\",\n-        InvalidUnicodeCodePoint => \"invalid Unicode code point\",\n-        LoneLeadingSurrogateInHexEscape => \"lone leading surrogate in hex escape\",\n-        UnexpectedEndOfHexEscape => \"unexpected end of hex escape\",\n-    }\n-}\n-\n-/// Shortcut function to encode a `T` into a JSON `String`\n-pub fn encode<T: for<'r> crate::Encodable<Encoder<'r>>>(\n-    object: &T,\n-) -> Result<string::String, EncoderError> {\n-    let mut s = String::new();\n-    {\n-        let mut encoder = Encoder::new(&mut s);\n-        object.encode(&mut encoder)?;\n-    }\n-    Ok(s)\n-}\n-\n-impl fmt::Display for ErrorCode {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        error_str(*self).fmt(f)\n-    }\n-}\n-\n-impl fmt::Display for ParserError {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        // FIXME this should be a nicer error\n-        fmt::Debug::fmt(self, f)\n-    }\n-}\n-\n-impl fmt::Display for EncoderError {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        // FIXME this should be a nicer error\n-        fmt::Debug::fmt(self, f)\n-    }\n-}\n-\n-impl std::error::Error for EncoderError {}\n-\n-impl From<fmt::Error> for EncoderError {\n-    /// Converts a [`fmt::Error`] into `EncoderError`\n-    ///\n-    /// This conversion does not allocate memory.\n-    fn from(err: fmt::Error) -> EncoderError {\n-        EncoderError::FmtError(err)\n-    }\n-}\n-\n-pub type EncodeResult = Result<(), EncoderError>;\n-\n-fn escape_str(wr: &mut dyn fmt::Write, v: &str) -> EncodeResult {\n-    wr.write_str(\"\\\"\")?;\n-\n-    let mut start = 0;\n-\n-    for (i, byte) in v.bytes().enumerate() {\n-        let escaped = match byte {\n-            b'\"' => \"\\\\\\\"\",\n-            b'\\\\' => \"\\\\\\\\\",\n-            b'\\x00' => \"\\\\u0000\",\n-            b'\\x01' => \"\\\\u0001\",\n-            b'\\x02' => \"\\\\u0002\",\n-            b'\\x03' => \"\\\\u0003\",\n-            b'\\x04' => \"\\\\u0004\",\n-            b'\\x05' => \"\\\\u0005\",\n-            b'\\x06' => \"\\\\u0006\",\n-            b'\\x07' => \"\\\\u0007\",\n-            b'\\x08' => \"\\\\b\",\n-            b'\\t' => \"\\\\t\",\n-            b'\\n' => \"\\\\n\",\n-            b'\\x0b' => \"\\\\u000b\",\n-            b'\\x0c' => \"\\\\f\",\n-            b'\\r' => \"\\\\r\",\n-            b'\\x0e' => \"\\\\u000e\",\n-            b'\\x0f' => \"\\\\u000f\",\n-            b'\\x10' => \"\\\\u0010\",\n-            b'\\x11' => \"\\\\u0011\",\n-            b'\\x12' => \"\\\\u0012\",\n-            b'\\x13' => \"\\\\u0013\",\n-            b'\\x14' => \"\\\\u0014\",\n-            b'\\x15' => \"\\\\u0015\",\n-            b'\\x16' => \"\\\\u0016\",\n-            b'\\x17' => \"\\\\u0017\",\n-            b'\\x18' => \"\\\\u0018\",\n-            b'\\x19' => \"\\\\u0019\",\n-            b'\\x1a' => \"\\\\u001a\",\n-            b'\\x1b' => \"\\\\u001b\",\n-            b'\\x1c' => \"\\\\u001c\",\n-            b'\\x1d' => \"\\\\u001d\",\n-            b'\\x1e' => \"\\\\u001e\",\n-            b'\\x1f' => \"\\\\u001f\",\n-            b'\\x7f' => \"\\\\u007f\",\n-            _ => {\n-                continue;\n-            }\n-        };\n-\n-        if start < i {\n-            wr.write_str(&v[start..i])?;\n-        }\n-\n-        wr.write_str(escaped)?;\n-\n-        start = i + 1;\n-    }\n-\n-    if start != v.len() {\n-        wr.write_str(&v[start..])?;\n-    }\n-\n-    wr.write_str(\"\\\"\")?;\n-    Ok(())\n-}\n-\n-fn escape_char(writer: &mut dyn fmt::Write, v: char) -> EncodeResult {\n-    escape_str(writer, v.encode_utf8(&mut [0; 4]))\n-}\n-\n-fn spaces(wr: &mut dyn fmt::Write, mut n: usize) -> EncodeResult {\n-    const BUF: &str = \"                \";\n-\n-    while n >= BUF.len() {\n-        wr.write_str(BUF)?;\n-        n -= BUF.len();\n-    }\n-\n-    if n > 0 {\n-        wr.write_str(&BUF[..n])?;\n-    }\n-    Ok(())\n-}\n-\n-fn fmt_number_or_null(v: f64) -> string::String {\n-    match v.classify() {\n-        Fp::Nan | Fp::Infinite => string::String::from(\"null\"),\n-        _ if v.fract() != 0f64 => v.to_string(),\n-        _ => v.to_string() + \".0\",\n-    }\n-}\n-\n-/// A structure for implementing serialization to JSON.\n-pub struct Encoder<'a> {\n-    writer: &'a mut (dyn fmt::Write + 'a),\n-    is_emitting_map_key: bool,\n-}\n-\n-impl<'a> Encoder<'a> {\n-    /// Creates a new JSON encoder whose output will be written to the writer\n-    /// specified.\n-    pub fn new(writer: &'a mut dyn fmt::Write) -> Encoder<'a> {\n-        Encoder { writer, is_emitting_map_key: false }\n-    }\n-}\n-\n-macro_rules! emit_enquoted_if_mapkey {\n-    ($enc:ident,$e:expr) => {{\n-        if $enc.is_emitting_map_key {\n-            write!($enc.writer, \"\\\"{}\\\"\", $e)?;\n-        } else {\n-            write!($enc.writer, \"{}\", $e)?;\n-        }\n-        Ok(())\n-    }};\n-}\n-\n-impl<'a> crate::Encoder for Encoder<'a> {\n-    type Error = EncoderError;\n-\n-    fn emit_unit(&mut self) -> EncodeResult {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        write!(self.writer, \"null\")?;\n-        Ok(())\n-    }\n-\n-    fn emit_usize(&mut self, v: usize) -> EncodeResult {\n-        emit_enquoted_if_mapkey!(self, v)\n-    }\n-    fn emit_u128(&mut self, v: u128) -> EncodeResult {\n-        emit_enquoted_if_mapkey!(self, v)\n-    }\n-    fn emit_u64(&mut self, v: u64) -> EncodeResult {\n-        emit_enquoted_if_mapkey!(self, v)\n-    }\n-    fn emit_u32(&mut self, v: u32) -> EncodeResult {\n-        emit_enquoted_if_mapkey!(self, v)\n-    }\n-    fn emit_u16(&mut self, v: u16) -> EncodeResult {\n-        emit_enquoted_if_mapkey!(self, v)\n-    }\n-    fn emit_u8(&mut self, v: u8) -> EncodeResult {\n-        emit_enquoted_if_mapkey!(self, v)\n-    }\n-\n-    fn emit_isize(&mut self, v: isize) -> EncodeResult {\n-        emit_enquoted_if_mapkey!(self, v)\n-    }\n-    fn emit_i128(&mut self, v: i128) -> EncodeResult {\n-        emit_enquoted_if_mapkey!(self, v)\n-    }\n-    fn emit_i64(&mut self, v: i64) -> EncodeResult {\n-        emit_enquoted_if_mapkey!(self, v)\n-    }\n-    fn emit_i32(&mut self, v: i32) -> EncodeResult {\n-        emit_enquoted_if_mapkey!(self, v)\n-    }\n-    fn emit_i16(&mut self, v: i16) -> EncodeResult {\n-        emit_enquoted_if_mapkey!(self, v)\n-    }\n-    fn emit_i8(&mut self, v: i8) -> EncodeResult {\n-        emit_enquoted_if_mapkey!(self, v)\n-    }\n-\n-    fn emit_bool(&mut self, v: bool) -> EncodeResult {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        if v {\n-            write!(self.writer, \"true\")?;\n-        } else {\n-            write!(self.writer, \"false\")?;\n-        }\n-        Ok(())\n-    }\n-\n-    fn emit_f64(&mut self, v: f64) -> EncodeResult {\n-        emit_enquoted_if_mapkey!(self, fmt_number_or_null(v))\n-    }\n-    fn emit_f32(&mut self, v: f32) -> EncodeResult {\n-        self.emit_f64(f64::from(v))\n-    }\n-\n-    fn emit_char(&mut self, v: char) -> EncodeResult {\n-        escape_char(self.writer, v)\n-    }\n-    fn emit_str(&mut self, v: &str) -> EncodeResult {\n-        escape_str(self.writer, v)\n-    }\n-    fn emit_raw_bytes(&mut self, s: &[u8]) -> Result<(), Self::Error> {\n-        for &c in s.iter() {\n-            self.emit_u8(c)?;\n-        }\n-        Ok(())\n-    }\n-\n-    fn emit_enum<F>(&mut self, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n-    {\n-        f(self)\n-    }\n-\n-    fn emit_enum_variant<F>(&mut self, name: &str, _id: usize, cnt: usize, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n-    {\n-        // enums are encoded as strings or objects\n-        // Bunny => \"Bunny\"\n-        // Kangaroo(34,\"William\") => {\"variant\": \"Kangaroo\", \"fields\": [34,\"William\"]}\n-        if cnt == 0 {\n-            escape_str(self.writer, name)\n-        } else {\n-            if self.is_emitting_map_key {\n-                return Err(EncoderError::BadHashmapKey);\n-            }\n-            write!(self.writer, \"{{\\\"variant\\\":\")?;\n-            escape_str(self.writer, name)?;\n-            write!(self.writer, \",\\\"fields\\\":[\")?;\n-            f(self)?;\n-            write!(self.writer, \"]}}\")?;\n-            Ok(())\n-        }\n-    }\n-\n-    fn emit_fieldless_enum_variant<const ID: usize>(\n-        &mut self,\n-        name: &str,\n-    ) -> Result<(), Self::Error> {\n-        escape_str(self.writer, name)\n-    }\n-\n-    fn emit_enum_variant_arg<F>(&mut self, first: bool, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n-    {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        if !first {\n-            write!(self.writer, \",\")?;\n-        }\n-        f(self)\n-    }\n-\n-    fn emit_struct<F>(&mut self, _: bool, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n-    {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        write!(self.writer, \"{{\")?;\n-        f(self)?;\n-        write!(self.writer, \"}}\")?;\n-        Ok(())\n-    }\n-\n-    fn emit_struct_field<F>(&mut self, name: &str, first: bool, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n-    {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        if !first {\n-            write!(self.writer, \",\")?;\n-        }\n-        escape_str(self.writer, name)?;\n-        write!(self.writer, \":\")?;\n-        f(self)\n-    }\n-\n-    fn emit_tuple<F>(&mut self, len: usize, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n-    {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        self.emit_seq(len, f)\n-    }\n-    fn emit_tuple_arg<F>(&mut self, idx: usize, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n-    {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        self.emit_seq_elt(idx, f)\n-    }\n-\n-    fn emit_option<F>(&mut self, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n-    {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        f(self)\n-    }\n-    fn emit_option_none(&mut self) -> EncodeResult {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        self.emit_unit()\n-    }\n-    fn emit_option_some<F>(&mut self, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n-    {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        f(self)\n-    }\n-\n-    fn emit_seq<F>(&mut self, _len: usize, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n-    {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        write!(self.writer, \"[\")?;\n-        f(self)?;\n-        write!(self.writer, \"]\")?;\n-        Ok(())\n-    }\n-\n-    fn emit_seq_elt<F>(&mut self, idx: usize, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n-    {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        if idx != 0 {\n-            write!(self.writer, \",\")?;\n-        }\n-        f(self)\n-    }\n-\n-    fn emit_map<F>(&mut self, _len: usize, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n-    {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        write!(self.writer, \"{{\")?;\n-        f(self)?;\n-        write!(self.writer, \"}}\")?;\n-        Ok(())\n-    }\n-\n-    fn emit_map_elt_key<F>(&mut self, idx: usize, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n-    {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        if idx != 0 {\n-            write!(self.writer, \",\")?\n-        }\n-        self.is_emitting_map_key = true;\n-        f(self)?;\n-        self.is_emitting_map_key = false;\n-        Ok(())\n-    }\n-\n-    fn emit_map_elt_val<F>(&mut self, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n-    {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        write!(self.writer, \":\")?;\n-        f(self)\n-    }\n-}\n-\n-/// Another encoder for JSON, but prints out human-readable JSON instead of\n-/// compact data\n-pub struct PrettyEncoder<'a> {\n-    writer: &'a mut (dyn fmt::Write + 'a),\n-    curr_indent: usize,\n-    indent: usize,\n-    is_emitting_map_key: bool,\n-}\n-\n-impl<'a> PrettyEncoder<'a> {\n-    /// Creates a new encoder whose output will be written to the specified writer\n-    pub fn new(writer: &'a mut dyn fmt::Write) -> PrettyEncoder<'a> {\n-        PrettyEncoder { writer, curr_indent: 0, indent: 2, is_emitting_map_key: false }\n-    }\n-\n-    /// Sets the number of spaces to indent for each level.\n-    /// This is safe to set during encoding.\n-    pub fn set_indent(&mut self, indent: usize) {\n-        // self.indent very well could be 0 so we need to use checked division.\n-        let level = self.curr_indent.checked_div(self.indent).unwrap_or(0);\n-        self.indent = indent;\n-        self.curr_indent = level * self.indent;\n-    }\n-}\n-\n-impl<'a> crate::Encoder for PrettyEncoder<'a> {\n-    type Error = EncoderError;\n-\n-    fn emit_unit(&mut self) -> EncodeResult {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        write!(self.writer, \"null\")?;\n-        Ok(())\n-    }\n-\n-    fn emit_usize(&mut self, v: usize) -> EncodeResult {\n-        emit_enquoted_if_mapkey!(self, v)\n-    }\n-    fn emit_u128(&mut self, v: u128) -> EncodeResult {\n-        emit_enquoted_if_mapkey!(self, v)\n-    }\n-    fn emit_u64(&mut self, v: u64) -> EncodeResult {\n-        emit_enquoted_if_mapkey!(self, v)\n-    }\n-    fn emit_u32(&mut self, v: u32) -> EncodeResult {\n-        emit_enquoted_if_mapkey!(self, v)\n-    }\n-    fn emit_u16(&mut self, v: u16) -> EncodeResult {\n-        emit_enquoted_if_mapkey!(self, v)\n-    }\n-    fn emit_u8(&mut self, v: u8) -> EncodeResult {\n-        emit_enquoted_if_mapkey!(self, v)\n-    }\n-\n-    fn emit_isize(&mut self, v: isize) -> EncodeResult {\n-        emit_enquoted_if_mapkey!(self, v)\n-    }\n-    fn emit_i128(&mut self, v: i128) -> EncodeResult {\n-        emit_enquoted_if_mapkey!(self, v)\n-    }\n-    fn emit_i64(&mut self, v: i64) -> EncodeResult {\n-        emit_enquoted_if_mapkey!(self, v)\n-    }\n-    fn emit_i32(&mut self, v: i32) -> EncodeResult {\n-        emit_enquoted_if_mapkey!(self, v)\n-    }\n-    fn emit_i16(&mut self, v: i16) -> EncodeResult {\n-        emit_enquoted_if_mapkey!(self, v)\n-    }\n-    fn emit_i8(&mut self, v: i8) -> EncodeResult {\n-        emit_enquoted_if_mapkey!(self, v)\n-    }\n-\n-    fn emit_bool(&mut self, v: bool) -> EncodeResult {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        if v {\n-            write!(self.writer, \"true\")?;\n-        } else {\n-            write!(self.writer, \"false\")?;\n-        }\n-        Ok(())\n-    }\n-\n-    fn emit_f64(&mut self, v: f64) -> EncodeResult {\n-        emit_enquoted_if_mapkey!(self, fmt_number_or_null(v))\n-    }\n-    fn emit_f32(&mut self, v: f32) -> EncodeResult {\n-        self.emit_f64(f64::from(v))\n-    }\n-\n-    fn emit_char(&mut self, v: char) -> EncodeResult {\n-        escape_char(self.writer, v)\n-    }\n-    fn emit_str(&mut self, v: &str) -> EncodeResult {\n-        escape_str(self.writer, v)\n-    }\n-    fn emit_raw_bytes(&mut self, s: &[u8]) -> Result<(), Self::Error> {\n-        for &c in s.iter() {\n-            self.emit_u8(c)?;\n-        }\n-        Ok(())\n-    }\n-\n-    fn emit_enum<F>(&mut self, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n-    {\n-        f(self)\n-    }\n-\n-    fn emit_enum_variant<F>(&mut self, name: &str, _id: usize, cnt: usize, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n-    {\n-        if cnt == 0 {\n-            escape_str(self.writer, name)\n-        } else {\n-            if self.is_emitting_map_key {\n-                return Err(EncoderError::BadHashmapKey);\n-            }\n-            writeln!(self.writer, \"{{\")?;\n-            self.curr_indent += self.indent;\n-            spaces(self.writer, self.curr_indent)?;\n-            write!(self.writer, \"\\\"variant\\\": \")?;\n-            escape_str(self.writer, name)?;\n-            writeln!(self.writer, \",\")?;\n-            spaces(self.writer, self.curr_indent)?;\n-            writeln!(self.writer, \"\\\"fields\\\": [\")?;\n-            self.curr_indent += self.indent;\n-            f(self)?;\n-            self.curr_indent -= self.indent;\n-            writeln!(self.writer)?;\n-            spaces(self.writer, self.curr_indent)?;\n-            self.curr_indent -= self.indent;\n-            writeln!(self.writer, \"]\")?;\n-            spaces(self.writer, self.curr_indent)?;\n-            write!(self.writer, \"}}\")?;\n-            Ok(())\n-        }\n-    }\n-\n-    fn emit_fieldless_enum_variant<const ID: usize>(\n-        &mut self,\n-        name: &str,\n-    ) -> Result<(), Self::Error> {\n-        escape_str(self.writer, name)\n-    }\n-\n-    fn emit_enum_variant_arg<F>(&mut self, first: bool, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n-    {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        if !first {\n-            writeln!(self.writer, \",\")?;\n-        }\n-        spaces(self.writer, self.curr_indent)?;\n-        f(self)\n-    }\n-\n-    fn emit_struct<F>(&mut self, no_fields: bool, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n-    {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        if no_fields {\n-            write!(self.writer, \"{{}}\")?;\n-        } else {\n-            write!(self.writer, \"{{\")?;\n-            self.curr_indent += self.indent;\n-            f(self)?;\n-            self.curr_indent -= self.indent;\n-            writeln!(self.writer)?;\n-            spaces(self.writer, self.curr_indent)?;\n-            write!(self.writer, \"}}\")?;\n-        }\n-        Ok(())\n-    }\n-\n-    fn emit_struct_field<F>(&mut self, name: &str, first: bool, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n-    {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        if first {\n-            writeln!(self.writer)?;\n-        } else {\n-            writeln!(self.writer, \",\")?;\n-        }\n-        spaces(self.writer, self.curr_indent)?;\n-        escape_str(self.writer, name)?;\n-        write!(self.writer, \": \")?;\n-        f(self)\n-    }\n-\n-    fn emit_tuple<F>(&mut self, len: usize, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n-    {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        self.emit_seq(len, f)\n-    }\n-    fn emit_tuple_arg<F>(&mut self, idx: usize, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n-    {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        self.emit_seq_elt(idx, f)\n-    }\n-\n-    fn emit_option<F>(&mut self, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n-    {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        f(self)\n-    }\n-    fn emit_option_none(&mut self) -> EncodeResult {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        self.emit_unit()\n-    }\n-    fn emit_option_some<F>(&mut self, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n-    {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        f(self)\n-    }\n-\n-    fn emit_seq<F>(&mut self, len: usize, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n-    {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        if len == 0 {\n-            write!(self.writer, \"[]\")?;\n-        } else {\n-            write!(self.writer, \"[\")?;\n-            self.curr_indent += self.indent;\n-            f(self)?;\n-            self.curr_indent -= self.indent;\n-            writeln!(self.writer)?;\n-            spaces(self.writer, self.curr_indent)?;\n-            write!(self.writer, \"]\")?;\n-        }\n-        Ok(())\n-    }\n-\n-    fn emit_seq_elt<F>(&mut self, idx: usize, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n-    {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        if idx == 0 {\n-            writeln!(self.writer)?;\n-        } else {\n-            writeln!(self.writer, \",\")?;\n-        }\n-        spaces(self.writer, self.curr_indent)?;\n-        f(self)\n-    }\n-\n-    fn emit_map<F>(&mut self, len: usize, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n-    {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        if len == 0 {\n-            write!(self.writer, \"{{}}\")?;\n-        } else {\n-            write!(self.writer, \"{{\")?;\n-            self.curr_indent += self.indent;\n-            f(self)?;\n-            self.curr_indent -= self.indent;\n-            writeln!(self.writer)?;\n-            spaces(self.writer, self.curr_indent)?;\n-            write!(self.writer, \"}}\")?;\n-        }\n-        Ok(())\n-    }\n-\n-    fn emit_map_elt_key<F>(&mut self, idx: usize, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n-    {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        if idx == 0 {\n-            writeln!(self.writer)?;\n-        } else {\n-            writeln!(self.writer, \",\")?;\n-        }\n-        spaces(self.writer, self.curr_indent)?;\n-        self.is_emitting_map_key = true;\n-        f(self)?;\n-        self.is_emitting_map_key = false;\n-        Ok(())\n-    }\n-\n-    fn emit_map_elt_val<F>(&mut self, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n-    {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        write!(self.writer, \": \")?;\n-        f(self)\n-    }\n-}\n-\n-impl<E: crate::Encoder> Encodable<E> for Json {\n-    fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n-        match *self {\n-            Json::I64(v) => v.encode(e),\n-            Json::U64(v) => v.encode(e),\n-            Json::F64(v) => v.encode(e),\n-            Json::String(ref v) => v.encode(e),\n-            Json::Boolean(v) => v.encode(e),\n-            Json::Array(ref v) => v.encode(e),\n-            Json::Object(ref v) => v.encode(e),\n-            Json::Null => e.emit_unit(),\n-        }\n-    }\n-}\n-\n-/// Creates an `AsJson` wrapper which can be used to print a value as JSON\n-/// on-the-fly via `write!`\n-pub fn as_json<T>(t: &T) -> AsJson<'_, T> {\n-    AsJson { inner: t }\n-}\n-\n-/// Creates an `AsPrettyJson` wrapper which can be used to print a value as JSON\n-/// on-the-fly via `write!`\n-pub fn as_pretty_json<T>(t: &T) -> AsPrettyJson<'_, T> {\n-    AsPrettyJson { inner: t, indent: None }\n-}\n-\n-impl Json {\n-    /// Borrow this json object as a pretty object to generate a pretty\n-    /// representation for it via `Display`.\n-    pub fn pretty(&self) -> PrettyJson<'_> {\n-        PrettyJson { inner: self }\n-    }\n-\n-    /// If the Json value is an Object, returns the value associated with the provided key.\n-    /// Otherwise, returns None.\n-    pub fn find(&self, key: &str) -> Option<&Json> {\n-        match *self {\n-            Json::Object(ref map) => map.get(key),\n-            _ => None,\n-        }\n-    }\n-\n-    /// If the Json value is an Object, deletes the value associated with the\n-    /// provided key from the Object and returns it. Otherwise, returns None.\n-    pub fn remove_key(&mut self, key: &str) -> Option<Json> {\n-        match *self {\n-            Json::Object(ref mut map) => map.remove(key),\n-            _ => None,\n-        }\n-    }\n-\n-    /// Attempts to get a nested Json Object for each key in `keys`.\n-    /// If any key is found not to exist, `find_path` will return `None`.\n-    /// Otherwise, it will return the Json value associated with the final key.\n-    pub fn find_path<'a>(&'a self, keys: &[&str]) -> Option<&'a Json> {\n-        let mut target = self;\n-        for key in keys {\n-            target = target.find(*key)?;\n-        }\n-        Some(target)\n-    }\n-\n-    /// If the Json value is an Object, performs a depth-first search until\n-    /// a value associated with the provided key is found. If no value is found\n-    /// or the Json value is not an Object, returns `None`.\n-    pub fn search(&self, key: &str) -> Option<&Json> {\n-        match *self {\n-            Json::Object(ref map) => match map.get(key) {\n-                Some(json_value) => Some(json_value),\n-                None => {\n-                    for v in map.values() {\n-                        match v.search(key) {\n-                            x if x.is_some() => return x,\n-                            _ => (),\n-                        }\n-                    }\n-                    None\n-                }\n-            },\n-            _ => None,\n-        }\n-    }\n-\n-    /// Returns `true` if the Json value is an `Object`.\n-    pub fn is_object(&self) -> bool {\n-        self.as_object().is_some()\n-    }\n-\n-    /// If the Json value is an `Object`, returns the associated `BTreeMap`;\n-    /// returns `None` otherwise.\n-    pub fn as_object(&self) -> Option<&Object> {\n-        match *self {\n-            Json::Object(ref map) => Some(map),\n-            _ => None,\n-        }\n-    }\n-\n-    /// Returns `true` if the Json value is an `Array`.\n-    pub fn is_array(&self) -> bool {\n-        self.as_array().is_some()\n-    }\n-\n-    /// If the Json value is an `Array`, returns the associated vector;\n-    /// returns `None` otherwise.\n-    pub fn as_array(&self) -> Option<&Array> {\n-        match *self {\n-            Json::Array(ref array) => Some(&*array),\n-            _ => None,\n-        }\n-    }\n-\n-    /// Returns `true` if the Json value is a `String`.\n-    pub fn is_string(&self) -> bool {\n-        self.as_string().is_some()\n-    }\n-\n-    /// If the Json value is a `String`, returns the associated `str`;\n-    /// returns `None` otherwise.\n-    pub fn as_string(&self) -> Option<&str> {\n-        match *self {\n-            Json::String(ref s) => Some(&s[..]),\n-            _ => None,\n-        }\n-    }\n-\n-    /// Returns `true` if the Json value is a `Number`.\n-    pub fn is_number(&self) -> bool {\n-        matches!(*self, Json::I64(_) | Json::U64(_) | Json::F64(_))\n-    }\n-\n-    /// Returns `true` if the Json value is an `i64`.\n-    pub fn is_i64(&self) -> bool {\n-        matches!(*self, Json::I64(_))\n-    }\n-\n-    /// Returns `true` if the Json value is a `u64`.\n-    pub fn is_u64(&self) -> bool {\n-        matches!(*self, Json::U64(_))\n-    }\n-\n-    /// Returns `true` if the Json value is a `f64`.\n-    pub fn is_f64(&self) -> bool {\n-        matches!(*self, Json::F64(_))\n-    }\n-\n-    /// If the Json value is a number, returns or cast it to an `i64`;\n-    /// returns `None` otherwise.\n-    pub fn as_i64(&self) -> Option<i64> {\n-        match *self {\n-            Json::I64(n) => Some(n),\n-            Json::U64(n) => Some(n as i64),\n-            _ => None,\n-        }\n-    }\n-\n-    /// If the Json value is a number, returns or cast it to a `u64`;\n-    /// returns `None` otherwise.\n-    pub fn as_u64(&self) -> Option<u64> {\n-        match *self {\n-            Json::I64(n) => Some(n as u64),\n-            Json::U64(n) => Some(n),\n-            _ => None,\n-        }\n-    }\n-\n-    /// If the Json value is a number, returns or cast it to a `f64`;\n-    /// returns `None` otherwise.\n-    pub fn as_f64(&self) -> Option<f64> {\n-        match *self {\n-            Json::I64(n) => Some(n as f64),\n-            Json::U64(n) => Some(n as f64),\n-            Json::F64(n) => Some(n),\n-            _ => None,\n-        }\n-    }\n-\n-    /// Returns `true` if the Json value is a `Boolean`.\n-    pub fn is_boolean(&self) -> bool {\n-        self.as_boolean().is_some()\n-    }\n-\n-    /// If the Json value is a `Boolean`, returns the associated `bool`;\n-    /// returns `None` otherwise.\n-    pub fn as_boolean(&self) -> Option<bool> {\n-        match *self {\n-            Json::Boolean(b) => Some(b),\n-            _ => None,\n-        }\n-    }\n-\n-    /// Returns `true` if the Json value is a `Null`.\n-    pub fn is_null(&self) -> bool {\n-        self.as_null().is_some()\n-    }\n-\n-    /// If the Json value is a `Null`, returns `()`;\n-    /// returns `None` otherwise.\n-    pub fn as_null(&self) -> Option<()> {\n-        match *self {\n-            Json::Null => Some(()),\n-            _ => None,\n-        }\n-    }\n-}\n-\n-impl<'a> Index<&'a str> for Json {\n-    type Output = Json;\n-\n-    fn index(&self, idx: &'a str) -> &Json {\n-        self.find(idx).unwrap()\n-    }\n-}\n-\n-impl Index<usize> for Json {\n-    type Output = Json;\n-\n-    fn index(&self, idx: usize) -> &Json {\n-        match *self {\n-            Json::Array(ref v) => &v[idx],\n-            _ => panic!(\"can only index Json with usize if it is an array\"),\n-        }\n-    }\n-}\n-\n-/// The output of the streaming parser.\n-#[derive(PartialEq, Clone, Debug)]\n-pub enum JsonEvent {\n-    ObjectStart,\n-    ObjectEnd,\n-    ArrayStart,\n-    ArrayEnd,\n-    BooleanValue(bool),\n-    I64Value(i64),\n-    U64Value(u64),\n-    F64Value(f64),\n-    StringValue(string::String),\n-    NullValue,\n-    Error(ParserError),\n-}\n-\n-#[derive(PartialEq, Debug)]\n-enum ParserState {\n-    // Parse a value in an array, true means first element.\n-    ParseArray(bool),\n-    // Parse ',' or ']' after an element in an array.\n-    ParseArrayComma,\n-    // Parse a key:value in an object, true means first element.\n-    ParseObject(bool),\n-    // Parse ',' or ']' after an element in an object.\n-    ParseObjectComma,\n-    // Initial state.\n-    ParseStart,\n-    // Expecting the stream to end.\n-    ParseBeforeFinish,\n-    // Parsing can't continue.\n-    ParseFinished,\n-}\n-\n-/// A Stack represents the current position of the parser in the logical\n-/// structure of the JSON stream.\n-///\n-/// An example is `foo.bar[3].x`.\n-#[derive(Default)]\n-pub struct Stack {\n-    stack: Vec<InternalStackElement>,\n-    str_buffer: Vec<u8>,\n-}\n-\n-/// StackElements compose a Stack.\n-///\n-/// As an example, `StackElement::Key(\"foo\")`, `StackElement::Key(\"bar\")`,\n-/// `StackElement::Index(3)`, and `StackElement::Key(\"x\")` are the\n-/// StackElements composing the stack that represents `foo.bar[3].x`.\n-#[derive(PartialEq, Clone, Debug)]\n-pub enum StackElement<'l> {\n-    Index(u32),\n-    Key(&'l str),\n-}\n-\n-// Internally, Key elements are stored as indices in a buffer to avoid\n-// allocating a string for every member of an object.\n-#[derive(PartialEq, Clone, Debug)]\n-enum InternalStackElement {\n-    InternalIndex(u32),\n-    InternalKey(u16, u16), // start, size\n-}\n-\n-impl Stack {\n-    pub fn new() -> Stack {\n-        Self::default()\n-    }\n-\n-    /// Returns The number of elements in the Stack.\n-    pub fn len(&self) -> usize {\n-        self.stack.len()\n-    }\n-\n-    /// Returns `true` if the stack is empty.\n-    pub fn is_empty(&self) -> bool {\n-        self.stack.is_empty()\n-    }\n-\n-    /// Provides access to the StackElement at a given index.\n-    /// lower indices are at the bottom of the stack while higher indices are\n-    /// at the top.\n-    pub fn get(&self, idx: usize) -> StackElement<'_> {\n-        match self.stack[idx] {\n-            InternalIndex(i) => StackElement::Index(i),\n-            InternalKey(start, size) => StackElement::Key(\n-                str::from_utf8(&self.str_buffer[start as usize..start as usize + size as usize])\n-                    .unwrap(),\n-            ),\n-        }\n-    }\n-\n-    /// Compares this stack with an array of StackElement<'_>s.\n-    pub fn is_equal_to(&self, rhs: &[StackElement<'_>]) -> bool {\n-        if self.stack.len() != rhs.len() {\n-            return false;\n-        }\n-        for (i, r) in rhs.iter().enumerate() {\n-            if self.get(i) != *r {\n-                return false;\n-            }\n-        }\n-        true\n-    }\n-\n-    /// Returns `true` if the bottom-most elements of this stack are the same as\n-    /// the ones passed as parameter.\n-    pub fn starts_with(&self, rhs: &[StackElement<'_>]) -> bool {\n-        if self.stack.len() < rhs.len() {\n-            return false;\n-        }\n-        for (i, r) in rhs.iter().enumerate() {\n-            if self.get(i) != *r {\n-                return false;\n-            }\n-        }\n-        true\n-    }\n-\n-    /// Returns `true` if the top-most elements of this stack are the same as\n-    /// the ones passed as parameter.\n-    pub fn ends_with(&self, rhs: &[StackElement<'_>]) -> bool {\n-        if self.stack.len() < rhs.len() {\n-            return false;\n-        }\n-        let offset = self.stack.len() - rhs.len();\n-        for (i, r) in rhs.iter().enumerate() {\n-            if self.get(i + offset) != *r {\n-                return false;\n-            }\n-        }\n-        true\n-    }\n-\n-    /// Returns the top-most element (if any).\n-    pub fn top(&self) -> Option<StackElement<'_>> {\n-        match self.stack.last() {\n-            None => None,\n-            Some(&InternalIndex(i)) => Some(StackElement::Index(i)),\n-            Some(&InternalKey(start, size)) => Some(StackElement::Key(\n-                str::from_utf8(&self.str_buffer[start as usize..(start + size) as usize]).unwrap(),\n-            )),\n-        }\n-    }\n-\n-    // Used by Parser to insert StackElement::Key elements at the top of the stack.\n-    fn push_key(&mut self, key: string::String) {\n-        self.stack.push(InternalKey(self.str_buffer.len() as u16, key.len() as u16));\n-        self.str_buffer.extend(key.as_bytes());\n-    }\n-\n-    // Used by Parser to insert StackElement::Index elements at the top of the stack.\n-    fn push_index(&mut self, index: u32) {\n-        self.stack.push(InternalIndex(index));\n-    }\n-\n-    // Used by Parser to remove the top-most element of the stack.\n-    fn pop(&mut self) {\n-        assert!(!self.is_empty());\n-        match *self.stack.last().unwrap() {\n-            InternalKey(_, sz) => {\n-                let new_size = self.str_buffer.len() - sz as usize;\n-                self.str_buffer.truncate(new_size);\n-            }\n-            InternalIndex(_) => {}\n-        }\n-        self.stack.pop();\n-    }\n-\n-    // Used by Parser to test whether the top-most element is an index.\n-    fn last_is_index(&self) -> bool {\n-        matches!(self.stack.last(), Some(InternalIndex(_)))\n-    }\n-\n-    // Used by Parser to increment the index of the top-most element.\n-    fn bump_index(&mut self) {\n-        let len = self.stack.len();\n-        let idx = match *self.stack.last().unwrap() {\n-            InternalIndex(i) => i + 1,\n-            _ => {\n-                panic!();\n-            }\n-        };\n-        self.stack[len - 1] = InternalIndex(idx);\n-    }\n-}\n-\n-/// A streaming JSON parser implemented as an iterator of JsonEvent, consuming\n-/// an iterator of char.\n-pub struct Parser<T> {\n-    rdr: T,\n-    ch: Option<char>,\n-    line: usize,\n-    col: usize,\n-    // We maintain a stack representing where we are in the logical structure\n-    // of the JSON stream.\n-    stack: Stack,\n-    // A state machine is kept to make it possible to interrupt and resume parsing.\n-    state: ParserState,\n-}\n-\n-impl<T: Iterator<Item = char>> Iterator for Parser<T> {\n-    type Item = JsonEvent;\n-\n-    fn next(&mut self) -> Option<JsonEvent> {\n-        if self.state == ParseFinished {\n-            return None;\n-        }\n-\n-        if self.state == ParseBeforeFinish {\n-            self.parse_whitespace();\n-            // Make sure there is no trailing characters.\n-            if self.eof() {\n-                self.state = ParseFinished;\n-                return None;\n-            } else {\n-                return Some(self.error_event(TrailingCharacters));\n-            }\n-        }\n-\n-        Some(self.parse())\n-    }\n-}\n-\n-impl<T: Iterator<Item = char>> Parser<T> {\n-    /// Creates the JSON parser.\n-    pub fn new(rdr: T) -> Parser<T> {\n-        let mut p = Parser {\n-            rdr,\n-            ch: Some('\\x00'),\n-            line: 1,\n-            col: 0,\n-            stack: Stack::new(),\n-            state: ParseStart,\n-        };\n-        p.bump();\n-        p\n-    }\n-\n-    /// Provides access to the current position in the logical structure of the\n-    /// JSON stream.\n-    pub fn stack(&self) -> &Stack {\n-        &self.stack\n-    }\n-\n-    fn eof(&self) -> bool {\n-        self.ch.is_none()\n-    }\n-    fn ch_or_null(&self) -> char {\n-        self.ch.unwrap_or('\\x00')\n-    }\n-    fn bump(&mut self) {\n-        self.ch = self.rdr.next();\n-\n-        if self.ch_is('\\n') {\n-            self.line += 1;\n-            self.col = 1;\n-        } else {\n-            self.col += 1;\n-        }\n-    }\n-\n-    fn next_char(&mut self) -> Option<char> {\n-        self.bump();\n-        self.ch\n-    }\n-    fn ch_is(&self, c: char) -> bool {\n-        self.ch == Some(c)\n-    }\n-\n-    fn error<U>(&self, reason: ErrorCode) -> Result<U, ParserError> {\n-        Err(SyntaxError(reason, self.line, self.col))\n-    }\n-\n-    fn parse_whitespace(&mut self) {\n-        while self.ch_is(' ') || self.ch_is('\\n') || self.ch_is('\\t') || self.ch_is('\\r') {\n-            self.bump();\n-        }\n-    }\n-\n-    fn parse_number(&mut self) -> JsonEvent {\n-        let neg = if self.ch_is('-') {\n-            self.bump();\n-            true\n-        } else {\n-            false\n-        };\n-\n-        let res = match self.parse_u64() {\n-            Ok(res) => res,\n-            Err(e) => {\n-                return Error(e);\n-            }\n-        };\n-\n-        if self.ch_is('.') || self.ch_is('e') || self.ch_is('E') {\n-            let mut res = res as f64;\n-\n-            if self.ch_is('.') {\n-                res = match self.parse_decimal(res) {\n-                    Ok(res) => res,\n-                    Err(e) => {\n-                        return Error(e);\n-                    }\n-                };\n-            }\n-\n-            if self.ch_is('e') || self.ch_is('E') {\n-                res = match self.parse_exponent(res) {\n-                    Ok(res) => res,\n-                    Err(e) => {\n-                        return Error(e);\n-                    }\n-                };\n-            }\n-\n-            if neg {\n-                res *= -1.0;\n-            }\n-\n-            F64Value(res)\n-        } else if neg {\n-            let res = (res as i64).wrapping_neg();\n-\n-            // Make sure we didn't underflow.\n-            if res > 0 {\n-                Error(SyntaxError(InvalidNumber, self.line, self.col))\n-            } else {\n-                I64Value(res)\n-            }\n-        } else {\n-            U64Value(res)\n-        }\n-    }\n-\n-    fn parse_u64(&mut self) -> Result<u64, ParserError> {\n-        let mut accum = 0u64;\n-        let last_accum = 0; // necessary to detect overflow.\n-\n-        match self.ch_or_null() {\n-            '0' => {\n-                self.bump();\n-\n-                // A leading '0' must be the only digit before the decimal point.\n-                if let '0'..='9' = self.ch_or_null() {\n-                    return self.error(InvalidNumber);\n-                }\n-            }\n-            '1'..='9' => {\n-                while !self.eof() {\n-                    match self.ch_or_null() {\n-                        c @ '0'..='9' => {\n-                            accum = accum.wrapping_mul(10);\n-                            accum = accum.wrapping_add((c as u64) - ('0' as u64));\n-\n-                            // Detect overflow by comparing to the last value.\n-                            if accum <= last_accum {\n-                                return self.error(InvalidNumber);\n-                            }\n-\n-                            self.bump();\n-                        }\n-                        _ => break,\n-                    }\n-                }\n-            }\n-            _ => return self.error(InvalidNumber),\n-        }\n-\n-        Ok(accum)\n-    }\n-\n-    fn parse_decimal(&mut self, mut res: f64) -> Result<f64, ParserError> {\n-        self.bump();\n-\n-        // Make sure a digit follows the decimal place.\n-        match self.ch_or_null() {\n-            '0'..='9' => (),\n-            _ => return self.error(InvalidNumber),\n-        }\n-\n-        let mut dec = 1.0;\n-        while !self.eof() {\n-            match self.ch_or_null() {\n-                c @ '0'..='9' => {\n-                    dec /= 10.0;\n-                    res += (((c as isize) - ('0' as isize)) as f64) * dec;\n-                    self.bump();\n-                }\n-                _ => break,\n-            }\n-        }\n-\n-        Ok(res)\n-    }\n-\n-    fn parse_exponent(&mut self, mut res: f64) -> Result<f64, ParserError> {\n-        self.bump();\n-\n-        let mut exp = 0;\n-        let mut neg_exp = false;\n-\n-        if self.ch_is('+') {\n-            self.bump();\n-        } else if self.ch_is('-') {\n-            self.bump();\n-            neg_exp = true;\n-        }\n-\n-        // Make sure a digit follows the exponent place.\n-        match self.ch_or_null() {\n-            '0'..='9' => (),\n-            _ => return self.error(InvalidNumber),\n-        }\n-        while !self.eof() {\n-            match self.ch_or_null() {\n-                c @ '0'..='9' => {\n-                    exp *= 10;\n-                    exp += (c as usize) - ('0' as usize);\n-\n-                    self.bump();\n-                }\n-                _ => break,\n-            }\n-        }\n-\n-        let exp = 10_f64.powi(exp as i32);\n-        if neg_exp {\n-            res /= exp;\n-        } else {\n-            res *= exp;\n-        }\n-\n-        Ok(res)\n-    }\n-\n-    fn decode_hex_escape(&mut self) -> Result<u16, ParserError> {\n-        let mut i = 0;\n-        let mut n = 0;\n-        while i < 4 && !self.eof() {\n-            self.bump();\n-            n = match self.ch_or_null() {\n-                c @ '0'..='9' => n * 16 + ((c as u16) - ('0' as u16)),\n-                'a' | 'A' => n * 16 + 10,\n-                'b' | 'B' => n * 16 + 11,\n-                'c' | 'C' => n * 16 + 12,\n-                'd' | 'D' => n * 16 + 13,\n-                'e' | 'E' => n * 16 + 14,\n-                'f' | 'F' => n * 16 + 15,\n-                _ => return self.error(InvalidEscape),\n-            };\n-\n-            i += 1;\n-        }\n-\n-        // Error out if we didn't parse 4 digits.\n-        if i != 4 {\n-            return self.error(InvalidEscape);\n-        }\n-\n-        Ok(n)\n-    }\n-\n-    fn parse_str(&mut self) -> Result<string::String, ParserError> {\n-        let mut escape = false;\n-        let mut res = string::String::new();\n-\n-        loop {\n-            self.bump();\n-            if self.eof() {\n-                return self.error(EOFWhileParsingString);\n-            }\n-\n-            if escape {\n-                match self.ch_or_null() {\n-                    '\"' => res.push('\"'),\n-                    '\\\\' => res.push('\\\\'),\n-                    '/' => res.push('/'),\n-                    'b' => res.push('\\x08'),\n-                    'f' => res.push('\\x0c'),\n-                    'n' => res.push('\\n'),\n-                    'r' => res.push('\\r'),\n-                    't' => res.push('\\t'),\n-                    'u' => match self.decode_hex_escape()? {\n-                        0xDC00..=0xDFFF => return self.error(LoneLeadingSurrogateInHexEscape),\n-\n-                        // Non-BMP characters are encoded as a sequence of\n-                        // two hex escapes, representing UTF-16 surrogates.\n-                        n1 @ 0xD800..=0xDBFF => {\n-                            match (self.next_char(), self.next_char()) {\n-                                (Some('\\\\'), Some('u')) => (),\n-                                _ => return self.error(UnexpectedEndOfHexEscape),\n-                            }\n-\n-                            let n2 = self.decode_hex_escape()?;\n-                            if !(0xDC00..=0xDFFF).contains(&n2) {\n-                                return self.error(LoneLeadingSurrogateInHexEscape);\n-                            }\n-                            let c =\n-                                (u32::from(n1 - 0xD800) << 10 | u32::from(n2 - 0xDC00)) + 0x1_0000;\n-                            res.push(char::from_u32(c).unwrap());\n-                        }\n-\n-                        n => match char::from_u32(u32::from(n)) {\n-                            Some(c) => res.push(c),\n-                            None => return self.error(InvalidUnicodeCodePoint),\n-                        },\n-                    },\n-                    _ => return self.error(InvalidEscape),\n-                }\n-                escape = false;\n-            } else if self.ch_is('\\\\') {\n-                escape = true;\n-            } else {\n-                match self.ch {\n-                    Some('\"') => {\n-                        self.bump();\n-                        return Ok(res);\n-                    }\n-                    Some(c) => res.push(c),\n-                    None => unreachable!(),\n-                }\n-            }\n-        }\n-    }\n-\n-    // Invoked at each iteration, consumes the stream until it has enough\n-    // information to return a JsonEvent.\n-    // Manages an internal state so that parsing can be interrupted and resumed.\n-    // Also keeps track of the position in the logical structure of the json\n-    // stream isize the form of a stack that can be queried by the user using the\n-    // stack() method.\n-    fn parse(&mut self) -> JsonEvent {\n-        loop {\n-            // The only paths where the loop can spin a new iteration\n-            // are in the cases ParseArrayComma and ParseObjectComma if ','\n-            // is parsed. In these cases the state is set to (respectively)\n-            // ParseArray(false) and ParseObject(false), which always return,\n-            // so there is no risk of getting stuck in an infinite loop.\n-            // All other paths return before the end of the loop's iteration.\n-            self.parse_whitespace();\n-\n-            match self.state {\n-                ParseStart => {\n-                    return self.parse_start();\n-                }\n-                ParseArray(first) => {\n-                    return self.parse_array(first);\n-                }\n-                ParseArrayComma => {\n-                    if let Some(evt) = self.parse_array_comma_or_end() {\n-                        return evt;\n-                    }\n-                }\n-                ParseObject(first) => {\n-                    return self.parse_object(first);\n-                }\n-                ParseObjectComma => {\n-                    self.stack.pop();\n-                    if self.ch_is(',') {\n-                        self.state = ParseObject(false);\n-                        self.bump();\n-                    } else {\n-                        return self.parse_object_end();\n-                    }\n-                }\n-                _ => {\n-                    return self.error_event(InvalidSyntax);\n-                }\n-            }\n-        }\n-    }\n-\n-    fn parse_start(&mut self) -> JsonEvent {\n-        let val = self.parse_value();\n-        self.state = match val {\n-            Error(_) => ParseFinished,\n-            ArrayStart => ParseArray(true),\n-            ObjectStart => ParseObject(true),\n-            _ => ParseBeforeFinish,\n-        };\n-        val\n-    }\n-\n-    fn parse_array(&mut self, first: bool) -> JsonEvent {\n-        if self.ch_is(']') {\n-            if !first {\n-                self.error_event(InvalidSyntax)\n-            } else {\n-                self.state = if self.stack.is_empty() {\n-                    ParseBeforeFinish\n-                } else if self.stack.last_is_index() {\n-                    ParseArrayComma\n-                } else {\n-                    ParseObjectComma\n-                };\n-                self.bump();\n-                ArrayEnd\n-            }\n-        } else {\n-            if first {\n-                self.stack.push_index(0);\n-            }\n-            let val = self.parse_value();\n-            self.state = match val {\n-                Error(_) => ParseFinished,\n-                ArrayStart => ParseArray(true),\n-                ObjectStart => ParseObject(true),\n-                _ => ParseArrayComma,\n-            };\n-            val\n-        }\n-    }\n-\n-    fn parse_array_comma_or_end(&mut self) -> Option<JsonEvent> {\n-        if self.ch_is(',') {\n-            self.stack.bump_index();\n-            self.state = ParseArray(false);\n-            self.bump();\n-            None\n-        } else if self.ch_is(']') {\n-            self.stack.pop();\n-            self.state = if self.stack.is_empty() {\n-                ParseBeforeFinish\n-            } else if self.stack.last_is_index() {\n-                ParseArrayComma\n-            } else {\n-                ParseObjectComma\n-            };\n-            self.bump();\n-            Some(ArrayEnd)\n-        } else if self.eof() {\n-            Some(self.error_event(EOFWhileParsingArray))\n-        } else {\n-            Some(self.error_event(InvalidSyntax))\n-        }\n-    }\n-\n-    fn parse_object(&mut self, first: bool) -> JsonEvent {\n-        if self.ch_is('}') {\n-            if !first {\n-                if self.stack.is_empty() {\n-                    return self.error_event(TrailingComma);\n-                } else {\n-                    self.stack.pop();\n-                }\n-            }\n-            self.state = if self.stack.is_empty() {\n-                ParseBeforeFinish\n-            } else if self.stack.last_is_index() {\n-                ParseArrayComma\n-            } else {\n-                ParseObjectComma\n-            };\n-            self.bump();\n-            return ObjectEnd;\n-        }\n-        if self.eof() {\n-            return self.error_event(EOFWhileParsingObject);\n-        }\n-        if !self.ch_is('\"') {\n-            return self.error_event(KeyMustBeAString);\n-        }\n-        let s = match self.parse_str() {\n-            Ok(s) => s,\n-            Err(e) => {\n-                self.state = ParseFinished;\n-                return Error(e);\n-            }\n-        };\n-        self.parse_whitespace();\n-        if self.eof() {\n-            return self.error_event(EOFWhileParsingObject);\n-        } else if self.ch_or_null() != ':' {\n-            return self.error_event(ExpectedColon);\n-        }\n-        self.stack.push_key(s);\n-        self.bump();\n-        self.parse_whitespace();\n-\n-        let val = self.parse_value();\n-\n-        self.state = match val {\n-            Error(_) => ParseFinished,\n-            ArrayStart => ParseArray(true),\n-            ObjectStart => ParseObject(true),\n-            _ => ParseObjectComma,\n-        };\n-        val\n-    }\n-\n-    fn parse_object_end(&mut self) -> JsonEvent {\n-        if self.ch_is('}') {\n-            self.state = if self.stack.is_empty() {\n-                ParseBeforeFinish\n-            } else if self.stack.last_is_index() {\n-                ParseArrayComma\n-            } else {\n-                ParseObjectComma\n-            };\n-            self.bump();\n-            ObjectEnd\n-        } else if self.eof() {\n-            self.error_event(EOFWhileParsingObject)\n-        } else {\n-            self.error_event(InvalidSyntax)\n-        }\n-    }\n-\n-    fn parse_value(&mut self) -> JsonEvent {\n-        if self.eof() {\n-            return self.error_event(EOFWhileParsingValue);\n-        }\n-        match self.ch_or_null() {\n-            'n' => self.parse_ident(\"ull\", NullValue),\n-            't' => self.parse_ident(\"rue\", BooleanValue(true)),\n-            'f' => self.parse_ident(\"alse\", BooleanValue(false)),\n-            '0'..='9' | '-' => self.parse_number(),\n-            '\"' => match self.parse_str() {\n-                Ok(s) => StringValue(s),\n-                Err(e) => Error(e),\n-            },\n-            '[' => {\n-                self.bump();\n-                ArrayStart\n-            }\n-            '{' => {\n-                self.bump();\n-                ObjectStart\n-            }\n-            _ => self.error_event(InvalidSyntax),\n-        }\n-    }\n-\n-    fn parse_ident(&mut self, ident: &str, value: JsonEvent) -> JsonEvent {\n-        if ident.chars().all(|c| Some(c) == self.next_char()) {\n-            self.bump();\n-            value\n-        } else {\n-            Error(SyntaxError(InvalidSyntax, self.line, self.col))\n-        }\n-    }\n-\n-    fn error_event(&mut self, reason: ErrorCode) -> JsonEvent {\n-        self.state = ParseFinished;\n-        Error(SyntaxError(reason, self.line, self.col))\n-    }\n-}\n-\n-/// A Builder consumes a json::Parser to create a generic Json structure.\n-pub struct Builder<T> {\n-    parser: Parser<T>,\n-    token: Option<JsonEvent>,\n-}\n-\n-impl<T: Iterator<Item = char>> Builder<T> {\n-    /// Creates a JSON Builder.\n-    pub fn new(src: T) -> Builder<T> {\n-        Builder { parser: Parser::new(src), token: None }\n-    }\n-\n-    // Decode a Json value from a Parser.\n-    pub fn build(&mut self) -> Result<Json, BuilderError> {\n-        self.bump();\n-        let result = self.build_value();\n-        self.bump();\n-        match self.token {\n-            None => {}\n-            Some(Error(ref e)) => {\n-                return Err(e.clone());\n-            }\n-            ref tok => {\n-                panic!(\"unexpected token {:?}\", tok.clone());\n-            }\n-        }\n-        result\n-    }\n-\n-    fn bump(&mut self) {\n-        self.token = self.parser.next();\n-    }\n-\n-    fn build_value(&mut self) -> Result<Json, BuilderError> {\n-        match self.token {\n-            Some(NullValue) => Ok(Json::Null),\n-            Some(I64Value(n)) => Ok(Json::I64(n)),\n-            Some(U64Value(n)) => Ok(Json::U64(n)),\n-            Some(F64Value(n)) => Ok(Json::F64(n)),\n-            Some(BooleanValue(b)) => Ok(Json::Boolean(b)),\n-            Some(StringValue(ref mut s)) => {\n-                let mut temp = string::String::new();\n-                swap(s, &mut temp);\n-                Ok(Json::String(temp))\n-            }\n-            Some(Error(ref e)) => Err(e.clone()),\n-            Some(ArrayStart) => self.build_array(),\n-            Some(ObjectStart) => self.build_object(),\n-            Some(ObjectEnd) => self.parser.error(InvalidSyntax),\n-            Some(ArrayEnd) => self.parser.error(InvalidSyntax),\n-            None => self.parser.error(EOFWhileParsingValue),\n-        }\n-    }\n-\n-    fn build_array(&mut self) -> Result<Json, BuilderError> {\n-        self.bump();\n-        let mut values = Vec::new();\n-\n-        loop {\n-            if self.token == Some(ArrayEnd) {\n-                return Ok(Json::Array(values.into_iter().collect()));\n-            }\n-            match self.build_value() {\n-                Ok(v) => values.push(v),\n-                Err(e) => return Err(e),\n-            }\n-            self.bump();\n-        }\n-    }\n-\n-    fn build_object(&mut self) -> Result<Json, BuilderError> {\n-        self.bump();\n-\n-        let mut values = BTreeMap::new();\n-\n-        loop {\n-            match self.token {\n-                Some(ObjectEnd) => {\n-                    return Ok(Json::Object(values));\n-                }\n-                Some(Error(ref e)) => {\n-                    return Err(e.clone());\n-                }\n-                None => {\n-                    break;\n-                }\n-                _ => {}\n-            }\n-            let key = match self.parser.stack().top() {\n-                Some(StackElement::Key(k)) => k.to_owned(),\n-                _ => {\n-                    panic!(\"invalid state\");\n-                }\n-            };\n-            match self.build_value() {\n-                Ok(value) => {\n-                    values.insert(key, value);\n-                }\n-                Err(e) => {\n-                    return Err(e);\n-                }\n-            }\n-            self.bump();\n-        }\n-        self.parser.error(EOFWhileParsingObject)\n-    }\n-}\n-\n-/// Decodes a json value from a string\n-pub fn from_str(s: &str) -> Result<Json, BuilderError> {\n-    let mut builder = Builder::new(s.chars());\n-    builder.build()\n-}\n-\n-/// A trait for converting values to JSON\n-pub trait ToJson {\n-    /// Converts the value of `self` to an instance of JSON\n-    fn to_json(&self) -> Json;\n-}\n-\n-macro_rules! to_json_impl_i64 {\n-    ($($t:ty), +) => (\n-        $(impl ToJson for $t {\n-            fn to_json(&self) -> Json {\n-                Json::I64(*self as i64)\n-            }\n-        })+\n-    )\n-}\n-\n-to_json_impl_i64! { isize, i8, i16, i32, i64 }\n-\n-macro_rules! to_json_impl_u64 {\n-    ($($t:ty), +) => (\n-        $(impl ToJson for $t {\n-            fn to_json(&self) -> Json {\n-                Json::U64(*self as u64)\n-            }\n-        })+\n-    )\n-}\n-\n-to_json_impl_u64! { usize, u8, u16, u32, u64 }\n-\n-impl ToJson for Json {\n-    fn to_json(&self) -> Json {\n-        self.clone()\n-    }\n-}\n-\n-impl ToJson for f32 {\n-    fn to_json(&self) -> Json {\n-        f64::from(*self).to_json()\n-    }\n-}\n-\n-impl ToJson for f64 {\n-    fn to_json(&self) -> Json {\n-        match self.classify() {\n-            Fp::Nan | Fp::Infinite => Json::Null,\n-            _ => Json::F64(*self),\n-        }\n-    }\n-}\n-\n-impl ToJson for () {\n-    fn to_json(&self) -> Json {\n-        Json::Null\n-    }\n-}\n-\n-impl ToJson for bool {\n-    fn to_json(&self) -> Json {\n-        Json::Boolean(*self)\n-    }\n-}\n-\n-impl ToJson for str {\n-    fn to_json(&self) -> Json {\n-        Json::String(self.to_string())\n-    }\n-}\n-\n-impl ToJson for string::String {\n-    fn to_json(&self) -> Json {\n-        Json::String((*self).clone())\n-    }\n-}\n-\n-impl<'a> ToJson for Cow<'a, str> {\n-    fn to_json(&self) -> Json {\n-        Json::String(self.to_string())\n-    }\n-}\n-\n-macro_rules! tuple_impl {\n-    // use variables to indicate the arity of the tuple\n-    ($($tyvar:ident),* ) => {\n-        // the trailing commas are for the 1 tuple\n-        impl<\n-            $( $tyvar : ToJson ),*\n-            > ToJson for ( $( $tyvar ),* , ) {\n-\n-            #[inline]\n-            #[allow(non_snake_case)]\n-            fn to_json(&self) -> Json {\n-                match *self {\n-                    ($(ref $tyvar),*,) => Json::Array(vec![$($tyvar.to_json()),*])\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-tuple_impl! {A}\n-tuple_impl! {A, B}\n-tuple_impl! {A, B, C}\n-tuple_impl! {A, B, C, D}\n-tuple_impl! {A, B, C, D, E}\n-tuple_impl! {A, B, C, D, E, F}\n-tuple_impl! {A, B, C, D, E, F, G}\n-tuple_impl! {A, B, C, D, E, F, G, H}\n-tuple_impl! {A, B, C, D, E, F, G, H, I}\n-tuple_impl! {A, B, C, D, E, F, G, H, I, J}\n-tuple_impl! {A, B, C, D, E, F, G, H, I, J, K}\n-tuple_impl! {A, B, C, D, E, F, G, H, I, J, K, L}\n-\n-impl<A: ToJson> ToJson for [A] {\n-    fn to_json(&self) -> Json {\n-        Json::Array(self.iter().map(|elt| elt.to_json()).collect())\n-    }\n-}\n-\n-impl<A: ToJson> ToJson for Vec<A> {\n-    fn to_json(&self) -> Json {\n-        Json::Array(self.iter().map(|elt| elt.to_json()).collect())\n-    }\n-}\n-\n-impl<'a, A: ToJson> ToJson for Cow<'a, [A]>\n-where\n-    [A]: ToOwned,\n-{\n-    fn to_json(&self) -> Json {\n-        Json::Array(self.iter().map(|elt| elt.to_json()).collect())\n-    }\n-}\n-\n-impl<T: ToString, A: ToJson> ToJson for BTreeMap<T, A> {\n-    fn to_json(&self) -> Json {\n-        let mut d = BTreeMap::new();\n-        for (key, value) in self {\n-            d.insert(key.to_string(), value.to_json());\n-        }\n-        Json::Object(d)\n-    }\n-}\n-\n-impl<A: ToJson> ToJson for HashMap<string::String, A> {\n-    fn to_json(&self) -> Json {\n-        let mut d = BTreeMap::new();\n-        for (key, value) in self {\n-            d.insert((*key).clone(), value.to_json());\n-        }\n-        Json::Object(d)\n-    }\n-}\n-\n-impl<A: ToJson> ToJson for Option<A> {\n-    fn to_json(&self) -> Json {\n-        match *self {\n-            None => Json::Null,\n-            Some(ref value) => value.to_json(),\n-        }\n-    }\n-}\n-\n-struct FormatShim<'a, 'b> {\n-    inner: &'a mut fmt::Formatter<'b>,\n-}\n-\n-impl<'a, 'b> fmt::Write for FormatShim<'a, 'b> {\n-    fn write_str(&mut self, s: &str) -> fmt::Result {\n-        match self.inner.write_str(s) {\n-            Ok(_) => Ok(()),\n-            Err(_) => Err(fmt::Error),\n-        }\n-    }\n-}\n-\n-impl fmt::Display for Json {\n-    /// Encodes a json value into a string\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let mut shim = FormatShim { inner: f };\n-        let mut encoder = Encoder::new(&mut shim);\n-        match self.encode(&mut encoder) {\n-            Ok(_) => Ok(()),\n-            Err(_) => Err(fmt::Error),\n-        }\n-    }\n-}\n-\n-impl<'a> fmt::Display for PrettyJson<'a> {\n-    /// Encodes a json value into a string\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let mut shim = FormatShim { inner: f };\n-        let mut encoder = PrettyEncoder::new(&mut shim);\n-        match self.inner.encode(&mut encoder) {\n-            Ok(_) => Ok(()),\n-            Err(_) => Err(fmt::Error),\n-        }\n-    }\n-}\n-\n-impl<'a, T: for<'r> Encodable<Encoder<'r>>> fmt::Display for AsJson<'a, T> {\n-    /// Encodes a json value into a string\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let mut shim = FormatShim { inner: f };\n-        let mut encoder = Encoder::new(&mut shim);\n-        match self.inner.encode(&mut encoder) {\n-            Ok(_) => Ok(()),\n-            Err(_) => Err(fmt::Error),\n-        }\n-    }\n-}\n-\n-impl<'a, T> AsPrettyJson<'a, T> {\n-    /// Sets the indentation level for the emitted JSON\n-    pub fn indent(mut self, indent: usize) -> AsPrettyJson<'a, T> {\n-        self.indent = Some(indent);\n-        self\n-    }\n-}\n-\n-impl<'a, T: for<'x> Encodable<PrettyEncoder<'x>>> fmt::Display for AsPrettyJson<'a, T> {\n-    /// Encodes a json value into a string\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let mut shim = FormatShim { inner: f };\n-        let mut encoder = PrettyEncoder::new(&mut shim);\n-        if let Some(n) = self.indent {\n-            encoder.set_indent(n);\n-        }\n-        match self.inner.encode(&mut encoder) {\n-            Ok(_) => Ok(()),\n-            Err(_) => Err(fmt::Error),\n-        }\n-    }\n-}\n-\n-impl FromStr for Json {\n-    type Err = BuilderError;\n-    fn from_str(s: &str) -> Result<Json, BuilderError> {\n-        from_str(s)\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests;"}, {"sha": "01678fbf0b79e9fcde6751ce0d7accd474b60fc5", "filename": "compiler/rustc_serialize/src/json/tests.rs", "status": "removed", "additions": 0, "deletions": 147, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/9a74608543d499bcc7dd505e195e8bfab9447315/compiler%2Frustc_serialize%2Fsrc%2Fjson%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a74608543d499bcc7dd505e195e8bfab9447315/compiler%2Frustc_serialize%2Fsrc%2Fjson%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fjson%2Ftests.rs?ref=9a74608543d499bcc7dd505e195e8bfab9447315", "patch": "@@ -1,147 +0,0 @@\n-// Benchmarks and tests that require private items\n-\n-extern crate test;\n-use super::{from_str, Parser, Stack, StackElement};\n-use std::string;\n-use test::Bencher;\n-\n-#[test]\n-fn test_stack() {\n-    let mut stack = Stack::new();\n-\n-    assert!(stack.is_empty());\n-    assert!(stack.is_empty());\n-    assert!(!stack.last_is_index());\n-\n-    stack.push_index(0);\n-    stack.bump_index();\n-\n-    assert!(stack.len() == 1);\n-    assert!(stack.is_equal_to(&[StackElement::Index(1)]));\n-    assert!(stack.starts_with(&[StackElement::Index(1)]));\n-    assert!(stack.ends_with(&[StackElement::Index(1)]));\n-    assert!(stack.last_is_index());\n-    assert!(stack.get(0) == StackElement::Index(1));\n-\n-    stack.push_key(\"foo\".to_string());\n-\n-    assert!(stack.len() == 2);\n-    assert!(stack.is_equal_to(&[StackElement::Index(1), StackElement::Key(\"foo\")]));\n-    assert!(stack.starts_with(&[StackElement::Index(1), StackElement::Key(\"foo\")]));\n-    assert!(stack.starts_with(&[StackElement::Index(1)]));\n-    assert!(stack.ends_with(&[StackElement::Index(1), StackElement::Key(\"foo\")]));\n-    assert!(stack.ends_with(&[StackElement::Key(\"foo\")]));\n-    assert!(!stack.last_is_index());\n-    assert!(stack.get(0) == StackElement::Index(1));\n-    assert!(stack.get(1) == StackElement::Key(\"foo\"));\n-\n-    stack.push_key(\"bar\".to_string());\n-\n-    assert!(stack.len() == 3);\n-    assert!(stack.is_equal_to(&[\n-        StackElement::Index(1),\n-        StackElement::Key(\"foo\"),\n-        StackElement::Key(\"bar\")\n-    ]));\n-    assert!(stack.starts_with(&[StackElement::Index(1)]));\n-    assert!(stack.starts_with(&[StackElement::Index(1), StackElement::Key(\"foo\")]));\n-    assert!(stack.starts_with(&[\n-        StackElement::Index(1),\n-        StackElement::Key(\"foo\"),\n-        StackElement::Key(\"bar\")\n-    ]));\n-    assert!(stack.ends_with(&[StackElement::Key(\"bar\")]));\n-    assert!(stack.ends_with(&[StackElement::Key(\"foo\"), StackElement::Key(\"bar\")]));\n-    assert!(stack.ends_with(&[\n-        StackElement::Index(1),\n-        StackElement::Key(\"foo\"),\n-        StackElement::Key(\"bar\")\n-    ]));\n-    assert!(!stack.last_is_index());\n-    assert!(stack.get(0) == StackElement::Index(1));\n-    assert!(stack.get(1) == StackElement::Key(\"foo\"));\n-    assert!(stack.get(2) == StackElement::Key(\"bar\"));\n-\n-    stack.pop();\n-\n-    assert!(stack.len() == 2);\n-    assert!(stack.is_equal_to(&[StackElement::Index(1), StackElement::Key(\"foo\")]));\n-    assert!(stack.starts_with(&[StackElement::Index(1), StackElement::Key(\"foo\")]));\n-    assert!(stack.starts_with(&[StackElement::Index(1)]));\n-    assert!(stack.ends_with(&[StackElement::Index(1), StackElement::Key(\"foo\")]));\n-    assert!(stack.ends_with(&[StackElement::Key(\"foo\")]));\n-    assert!(!stack.last_is_index());\n-    assert!(stack.get(0) == StackElement::Index(1));\n-    assert!(stack.get(1) == StackElement::Key(\"foo\"));\n-}\n-\n-#[bench]\n-fn bench_streaming_small(b: &mut Bencher) {\n-    b.iter(|| {\n-        let mut parser = Parser::new(\n-            r#\"{\n-                \"a\": 1.0,\n-                \"b\": [\n-                    true,\n-                    \"foo\\nbar\",\n-                    { \"c\": {\"d\": null} }\n-                ]\n-            }\"#\n-            .chars(),\n-        );\n-        loop {\n-            match parser.next() {\n-                None => return,\n-                _ => {}\n-            }\n-        }\n-    });\n-}\n-#[bench]\n-fn bench_small(b: &mut Bencher) {\n-    b.iter(|| {\n-        let _ = from_str(\n-            r#\"{\n-            \"a\": 1.0,\n-            \"b\": [\n-                true,\n-                \"foo\\nbar\",\n-                { \"c\": {\"d\": null} }\n-            ]\n-        }\"#,\n-        );\n-    });\n-}\n-\n-fn big_json() -> string::String {\n-    let mut src = \"[\\n\".to_string();\n-    for _ in 0..500 {\n-        src.push_str(\n-            r#\"{ \"a\": true, \"b\": null, \"c\":3.1415, \"d\": \"Hello world\", \"e\": \\\n-                        [1,2,3]},\"#,\n-        );\n-    }\n-    src.push_str(\"{}]\");\n-    return src;\n-}\n-\n-#[bench]\n-fn bench_streaming_large(b: &mut Bencher) {\n-    let src = big_json();\n-    b.iter(|| {\n-        let mut parser = Parser::new(src.chars());\n-        loop {\n-            match parser.next() {\n-                None => return,\n-                _ => {}\n-            }\n-        }\n-    });\n-}\n-#[bench]\n-fn bench_large(b: &mut Bencher) {\n-    let src = big_json();\n-    b.iter(|| {\n-        let _ = from_str(&src);\n-    });\n-}"}, {"sha": "b3a0bcf0e1134f0b9e6a4e227a9c9821f2b31ef1", "filename": "compiler/rustc_serialize/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_serialize%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_serialize%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Flib.rs?ref=7e9b92cb43a489b34e2bcb8d21f36198e02eedbc", "patch": "@@ -25,7 +25,5 @@ pub use self::serialize::{Decodable, Decoder, Encodable, Encoder};\n mod collection_impls;\n mod serialize;\n \n-pub mod json;\n-\n pub mod leb128;\n pub mod opaque;"}, {"sha": "3bcb7cc3650549a2ff87fb90300d4a8123692325", "filename": "compiler/rustc_serialize/src/opaque.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs?ref=7e9b92cb43a489b34e2bcb8d21f36198e02eedbc", "patch": "@@ -64,11 +64,6 @@ const STR_SENTINEL: u8 = 0xC1;\n impl serialize::Encoder for Encoder {\n     type Error = !;\n \n-    #[inline]\n-    fn emit_unit(&mut self) -> EncodeResult {\n-        Ok(())\n-    }\n-\n     #[inline]\n     fn emit_usize(&mut self, v: usize) -> EncodeResult {\n         write_leb128!(self, v, usize, write_usize_leb128)\n@@ -419,11 +414,6 @@ macro_rules! file_encoder_write_leb128 {\n impl serialize::Encoder for FileEncoder {\n     type Error = io::Error;\n \n-    #[inline]\n-    fn emit_unit(&mut self) -> FileEncodeResult {\n-        Ok(())\n-    }\n-\n     #[inline]\n     fn emit_usize(&mut self, v: usize) -> FileEncodeResult {\n         file_encoder_write_leb128!(self, v, usize, write_usize_leb128)"}, {"sha": "817a0c9dcb17b0196d81f0574f7b62b667d28db3", "filename": "compiler/rustc_serialize/src/serialize.rs", "status": "modified", "additions": 22, "deletions": 161, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs?ref=7e9b92cb43a489b34e2bcb8d21f36198e02eedbc", "patch": "@@ -15,7 +15,6 @@ pub trait Encoder {\n     type Error;\n \n     // Primitive types:\n-    fn emit_unit(&mut self) -> Result<(), Self::Error>;\n     fn emit_usize(&mut self, v: usize) -> Result<(), Self::Error>;\n     fn emit_u128(&mut self, v: u128) -> Result<(), Self::Error>;\n     fn emit_u64(&mut self, v: u64) -> Result<(), Self::Error>;\n@@ -35,22 +34,8 @@ pub trait Encoder {\n     fn emit_str(&mut self, v: &str) -> Result<(), Self::Error>;\n     fn emit_raw_bytes(&mut self, s: &[u8]) -> Result<(), Self::Error>;\n \n-    // Compound types:\n-    #[inline]\n-    fn emit_enum<F>(&mut self, f: F) -> Result<(), Self::Error>\n-    where\n-        F: FnOnce(&mut Self) -> Result<(), Self::Error>,\n-    {\n-        f(self)\n-    }\n-\n-    fn emit_enum_variant<F>(\n-        &mut self,\n-        _v_name: &str,\n-        v_id: usize,\n-        _len: usize,\n-        f: F,\n-    ) -> Result<(), Self::Error>\n+    // Convenience for the derive macro:\n+    fn emit_enum_variant<F>(&mut self, v_id: usize, f: F) -> Result<(), Self::Error>\n     where\n         F: FnOnce(&mut Self) -> Result<(), Self::Error>,\n     {\n@@ -65,112 +50,9 @@ pub trait Encoder {\n     // optimization that would otherwise be necessary here, likely due to the\n     // multiple levels of inlining and const-prop that are needed.\n     #[inline]\n-    fn emit_fieldless_enum_variant<const ID: usize>(\n-        &mut self,\n-        _v_name: &str,\n-    ) -> Result<(), Self::Error> {\n+    fn emit_fieldless_enum_variant<const ID: usize>(&mut self) -> Result<(), Self::Error> {\n         self.emit_usize(ID)\n     }\n-\n-    #[inline]\n-    fn emit_enum_variant_arg<F>(&mut self, _first: bool, f: F) -> Result<(), Self::Error>\n-    where\n-        F: FnOnce(&mut Self) -> Result<(), Self::Error>,\n-    {\n-        f(self)\n-    }\n-\n-    #[inline]\n-    fn emit_struct<F>(&mut self, _no_fields: bool, f: F) -> Result<(), Self::Error>\n-    where\n-        F: FnOnce(&mut Self) -> Result<(), Self::Error>,\n-    {\n-        f(self)\n-    }\n-\n-    #[inline]\n-    fn emit_struct_field<F>(&mut self, _f_name: &str, _first: bool, f: F) -> Result<(), Self::Error>\n-    where\n-        F: FnOnce(&mut Self) -> Result<(), Self::Error>,\n-    {\n-        f(self)\n-    }\n-\n-    #[inline]\n-    fn emit_tuple<F>(&mut self, _len: usize, f: F) -> Result<(), Self::Error>\n-    where\n-        F: FnOnce(&mut Self) -> Result<(), Self::Error>,\n-    {\n-        f(self)\n-    }\n-\n-    #[inline]\n-    fn emit_tuple_arg<F>(&mut self, _idx: usize, f: F) -> Result<(), Self::Error>\n-    where\n-        F: FnOnce(&mut Self) -> Result<(), Self::Error>,\n-    {\n-        f(self)\n-    }\n-\n-    // Specialized types:\n-    fn emit_option<F>(&mut self, f: F) -> Result<(), Self::Error>\n-    where\n-        F: FnOnce(&mut Self) -> Result<(), Self::Error>,\n-    {\n-        self.emit_enum(f)\n-    }\n-\n-    #[inline]\n-    fn emit_option_none(&mut self) -> Result<(), Self::Error> {\n-        self.emit_enum_variant(\"None\", 0, 0, |_| Ok(()))\n-    }\n-\n-    fn emit_option_some<F>(&mut self, f: F) -> Result<(), Self::Error>\n-    where\n-        F: FnOnce(&mut Self) -> Result<(), Self::Error>,\n-    {\n-        self.emit_enum_variant(\"Some\", 1, 1, f)\n-    }\n-\n-    fn emit_seq<F>(&mut self, len: usize, f: F) -> Result<(), Self::Error>\n-    where\n-        F: FnOnce(&mut Self) -> Result<(), Self::Error>,\n-    {\n-        self.emit_usize(len)?;\n-        f(self)\n-    }\n-\n-    #[inline]\n-    fn emit_seq_elt<F>(&mut self, _idx: usize, f: F) -> Result<(), Self::Error>\n-    where\n-        F: FnOnce(&mut Self) -> Result<(), Self::Error>,\n-    {\n-        f(self)\n-    }\n-\n-    fn emit_map<F>(&mut self, len: usize, f: F) -> Result<(), Self::Error>\n-    where\n-        F: FnOnce(&mut Self) -> Result<(), Self::Error>,\n-    {\n-        self.emit_usize(len)?;\n-        f(self)\n-    }\n-\n-    #[inline]\n-    fn emit_map_elt_key<F>(&mut self, _idx: usize, f: F) -> Result<(), Self::Error>\n-    where\n-        F: FnOnce(&mut Self) -> Result<(), Self::Error>,\n-    {\n-        f(self)\n-    }\n-\n-    #[inline]\n-    fn emit_map_elt_val<F>(&mut self, f: F) -> Result<(), Self::Error>\n-    where\n-        F: FnOnce(&mut Self) -> Result<(), Self::Error>,\n-    {\n-        f(self)\n-    }\n }\n \n // Note: all the methods in this trait are infallible, which may be surprising.\n@@ -320,8 +202,8 @@ impl<D: Decoder> Decodable<D> for String {\n }\n \n impl<S: Encoder> Encodable<S> for () {\n-    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_unit()\n+    fn encode(&self, _s: &mut S) -> Result<(), S::Error> {\n+        Ok(())\n     }\n }\n \n@@ -330,8 +212,8 @@ impl<D: Decoder> Decodable<D> for () {\n }\n \n impl<S: Encoder, T> Encodable<S> for PhantomData<T> {\n-    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_unit()\n+    fn encode(&self, _s: &mut S) -> Result<(), S::Error> {\n+        Ok(())\n     }\n }\n \n@@ -362,12 +244,11 @@ impl<D: Decoder, T: Decodable<D>> Decodable<D> for Rc<T> {\n \n impl<S: Encoder, T: Encodable<S>> Encodable<S> for [T] {\n     default fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_seq(self.len(), |s| {\n-            for (i, e) in self.iter().enumerate() {\n-                s.emit_seq_elt(i, |s| e.encode(s))?\n-            }\n-            Ok(())\n-        })\n+        s.emit_usize(self.len())?;\n+        for e in self.iter() {\n+            e.encode(s)?\n+        }\n+        Ok(())\n     }\n }\n \n@@ -450,10 +331,10 @@ impl<'a, D: Decoder> Decodable<D> for Cow<'a, str> {\n \n impl<S: Encoder, T: Encodable<S>> Encodable<S> for Option<T> {\n     fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_option(|s| match *self {\n-            None => s.emit_option_none(),\n-            Some(ref v) => s.emit_option_some(|s| v.encode(s)),\n-        })\n+        match *self {\n+            None => s.emit_enum_variant(0, |_| Ok(())),\n+            Some(ref v) => s.emit_enum_variant(1, |s| v.encode(s)),\n+        }\n     }\n }\n \n@@ -469,14 +350,10 @@ impl<D: Decoder, T: Decodable<D>> Decodable<D> for Option<T> {\n \n impl<S: Encoder, T1: Encodable<S>, T2: Encodable<S>> Encodable<S> for Result<T1, T2> {\n     fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_enum(|s| match *self {\n-            Ok(ref v) => {\n-                s.emit_enum_variant(\"Ok\", 0, 1, |s| s.emit_enum_variant_arg(true, |s| v.encode(s)))\n-            }\n-            Err(ref v) => {\n-                s.emit_enum_variant(\"Err\", 1, 1, |s| s.emit_enum_variant_arg(true, |s| v.encode(s)))\n-            }\n-        })\n+        match *self {\n+            Ok(ref v) => s.emit_enum_variant(0, |s| v.encode(s)),\n+            Err(ref v) => s.emit_enum_variant(1, |s| v.encode(s)),\n+        }\n     }\n }\n \n@@ -494,18 +371,6 @@ macro_rules! peel {\n     ($name:ident, $($other:ident,)*) => (tuple! { $($other,)* })\n }\n \n-/// Evaluates to the number of tokens passed to it.\n-///\n-/// Logarithmic counting: every one or two recursive expansions, the number of\n-/// tokens to count is divided by two, instead of being reduced by one.\n-/// Therefore, the recursion depth is the binary logarithm of the number of\n-/// tokens to count, and the expanded tree is likewise very small.\n-macro_rules! count {\n-    ($one:tt)              => (1usize);\n-    ($($pairs:tt $_p:tt)*) => (count!($($pairs)*) << 1usize);\n-    ($odd:tt $($rest:tt)*) => (count!($($rest)*) | 1usize);\n-}\n-\n macro_rules! tuple {\n     () => ();\n     ( $($name:ident,)+ ) => (\n@@ -518,12 +383,8 @@ macro_rules! tuple {\n             #[allow(non_snake_case)]\n             fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n                 let ($(ref $name,)+) = *self;\n-                let len: usize = count!($($name)+);\n-                s.emit_tuple(len, |s| {\n-                    let mut i = 0;\n-                    $(s.emit_tuple_arg({ i+=1; i-1 }, |s| $name.encode(s))?;)+\n-                    Ok(())\n-                })\n+                $($name.encode(s)?;)+\n+                Ok(())\n             }\n         }\n         peel! { $($name,)+ }"}, {"sha": "944fe460632199db4a9cd1108a08a5a89e2e9118", "filename": "compiler/rustc_serialize/tests/json.rs", "status": "removed", "additions": 0, "deletions": 978, "changes": 978, "blob_url": "https://github.com/rust-lang/rust/blob/9a74608543d499bcc7dd505e195e8bfab9447315/compiler%2Frustc_serialize%2Ftests%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a74608543d499bcc7dd505e195e8bfab9447315/compiler%2Frustc_serialize%2Ftests%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Ftests%2Fjson.rs?ref=9a74608543d499bcc7dd505e195e8bfab9447315", "patch": "@@ -1,978 +0,0 @@\n-#![allow(rustc::internal)]\n-\n-use json::ErrorCode::*;\n-use json::Json::*;\n-use json::JsonEvent::*;\n-use json::ParserError::*;\n-use json::{from_str, Encoder, EncoderError, Json, JsonEvent, Parser, StackElement};\n-use rustc_macros::Encodable;\n-use rustc_serialize::json;\n-use rustc_serialize::Encodable;\n-\n-use std::collections::BTreeMap;\n-use std::io::prelude::*;\n-use std::string;\n-use Animal::*;\n-\n-#[derive(Eq, PartialEq, Debug)]\n-struct OptionData {\n-    opt: Option<usize>,\n-}\n-\n-#[derive(PartialEq, Encodable, Debug)]\n-enum Animal {\n-    Dog,\n-    Frog(string::String, isize),\n-}\n-\n-#[derive(PartialEq, Encodable, Debug)]\n-struct Inner {\n-    a: (),\n-    b: usize,\n-    c: Vec<string::String>,\n-}\n-\n-#[derive(PartialEq, Encodable, Debug)]\n-struct Outer {\n-    inner: Vec<Inner>,\n-}\n-\n-fn mk_object(items: &[(string::String, Json)]) -> Json {\n-    let mut d = BTreeMap::new();\n-\n-    for item in items {\n-        match *item {\n-            (ref key, ref value) => {\n-                d.insert((*key).clone(), (*value).clone());\n-            }\n-        }\n-    }\n-\n-    Object(d)\n-}\n-\n-#[test]\n-fn test_from_str_trait() {\n-    let s = \"null\";\n-    assert!(s.parse::<Json>().unwrap() == s.parse().unwrap());\n-}\n-\n-#[test]\n-fn test_write_null() {\n-    assert_eq!(Null.to_string(), \"null\");\n-    assert_eq!(Null.pretty().to_string(), \"null\");\n-}\n-\n-#[test]\n-fn test_write_i64() {\n-    assert_eq!(U64(0).to_string(), \"0\");\n-    assert_eq!(U64(0).pretty().to_string(), \"0\");\n-\n-    assert_eq!(U64(1234).to_string(), \"1234\");\n-    assert_eq!(U64(1234).pretty().to_string(), \"1234\");\n-\n-    assert_eq!(I64(-5678).to_string(), \"-5678\");\n-    assert_eq!(I64(-5678).pretty().to_string(), \"-5678\");\n-\n-    assert_eq!(U64(7650007200025252000).to_string(), \"7650007200025252000\");\n-    assert_eq!(U64(7650007200025252000).pretty().to_string(), \"7650007200025252000\");\n-}\n-\n-#[test]\n-fn test_write_f64() {\n-    assert_eq!(F64(3.0).to_string(), \"3.0\");\n-    assert_eq!(F64(3.0).pretty().to_string(), \"3.0\");\n-\n-    assert_eq!(F64(3.1).to_string(), \"3.1\");\n-    assert_eq!(F64(3.1).pretty().to_string(), \"3.1\");\n-\n-    assert_eq!(F64(-1.5).to_string(), \"-1.5\");\n-    assert_eq!(F64(-1.5).pretty().to_string(), \"-1.5\");\n-\n-    assert_eq!(F64(0.5).to_string(), \"0.5\");\n-    assert_eq!(F64(0.5).pretty().to_string(), \"0.5\");\n-\n-    assert_eq!(F64(f64::NAN).to_string(), \"null\");\n-    assert_eq!(F64(f64::NAN).pretty().to_string(), \"null\");\n-\n-    assert_eq!(F64(f64::INFINITY).to_string(), \"null\");\n-    assert_eq!(F64(f64::INFINITY).pretty().to_string(), \"null\");\n-\n-    assert_eq!(F64(f64::NEG_INFINITY).to_string(), \"null\");\n-    assert_eq!(F64(f64::NEG_INFINITY).pretty().to_string(), \"null\");\n-}\n-\n-#[test]\n-fn test_write_str() {\n-    assert_eq!(String(\"\".to_string()).to_string(), \"\\\"\\\"\");\n-    assert_eq!(String(\"\".to_string()).pretty().to_string(), \"\\\"\\\"\");\n-\n-    assert_eq!(String(\"homura\".to_string()).to_string(), \"\\\"homura\\\"\");\n-    assert_eq!(String(\"madoka\".to_string()).pretty().to_string(), \"\\\"madoka\\\"\");\n-}\n-\n-#[test]\n-fn test_write_bool() {\n-    assert_eq!(Boolean(true).to_string(), \"true\");\n-    assert_eq!(Boolean(true).pretty().to_string(), \"true\");\n-\n-    assert_eq!(Boolean(false).to_string(), \"false\");\n-    assert_eq!(Boolean(false).pretty().to_string(), \"false\");\n-}\n-\n-#[test]\n-fn test_write_array() {\n-    assert_eq!(Array(vec![]).to_string(), \"[]\");\n-    assert_eq!(Array(vec![]).pretty().to_string(), \"[]\");\n-\n-    assert_eq!(Array(vec![Boolean(true)]).to_string(), \"[true]\");\n-    assert_eq!(\n-        Array(vec![Boolean(true)]).pretty().to_string(),\n-        \"\\\n-        [\\n  \\\n-            true\\n\\\n-        ]\"\n-    );\n-\n-    let long_test_array =\n-        Array(vec![Boolean(false), Null, Array(vec![String(\"foo\\nbar\".to_string()), F64(3.5)])]);\n-\n-    assert_eq!(long_test_array.to_string(), \"[false,null,[\\\"foo\\\\nbar\\\",3.5]]\");\n-    assert_eq!(\n-        long_test_array.pretty().to_string(),\n-        \"\\\n-        [\\n  \\\n-            false,\\n  \\\n-            null,\\n  \\\n-            [\\n    \\\n-                \\\"foo\\\\nbar\\\",\\n    \\\n-                3.5\\n  \\\n-            ]\\n\\\n-        ]\"\n-    );\n-}\n-\n-#[test]\n-fn test_write_object() {\n-    assert_eq!(mk_object(&[]).to_string(), \"{}\");\n-    assert_eq!(mk_object(&[]).pretty().to_string(), \"{}\");\n-\n-    assert_eq!(mk_object(&[(\"a\".to_string(), Boolean(true))]).to_string(), \"{\\\"a\\\":true}\");\n-    assert_eq!(\n-        mk_object(&[(\"a\".to_string(), Boolean(true))]).pretty().to_string(),\n-        \"\\\n-        {\\n  \\\n-            \\\"a\\\": true\\n\\\n-        }\"\n-    );\n-\n-    let complex_obj = mk_object(&[(\n-        \"b\".to_string(),\n-        Array(vec![\n-            mk_object(&[(\"c\".to_string(), String(\"\\x0c\\r\".to_string()))]),\n-            mk_object(&[(\"d\".to_string(), String(\"\".to_string()))]),\n-        ]),\n-    )]);\n-\n-    assert_eq!(\n-        complex_obj.to_string(),\n-        \"{\\\n-            \\\"b\\\":[\\\n-                {\\\"c\\\":\\\"\\\\f\\\\r\\\"},\\\n-                {\\\"d\\\":\\\"\\\"}\\\n-            ]\\\n-        }\"\n-    );\n-    assert_eq!(\n-        complex_obj.pretty().to_string(),\n-        \"\\\n-        {\\n  \\\n-            \\\"b\\\": [\\n    \\\n-                {\\n      \\\n-                    \\\"c\\\": \\\"\\\\f\\\\r\\\"\\n    \\\n-                },\\n    \\\n-                {\\n      \\\n-                    \\\"d\\\": \\\"\\\"\\n    \\\n-                }\\n  \\\n-            ]\\n\\\n-        }\"\n-    );\n-\n-    let a = mk_object(&[\n-        (\"a\".to_string(), Boolean(true)),\n-        (\n-            \"b\".to_string(),\n-            Array(vec![\n-                mk_object(&[(\"c\".to_string(), String(\"\\x0c\\r\".to_string()))]),\n-                mk_object(&[(\"d\".to_string(), String(\"\".to_string()))]),\n-            ]),\n-        ),\n-    ]);\n-\n-    // We can't compare the strings directly because the object fields be\n-    // printed in a different order.\n-    assert_eq!(a.clone(), a.to_string().parse().unwrap());\n-    assert_eq!(a.clone(), a.pretty().to_string().parse().unwrap());\n-}\n-\n-#[test]\n-fn test_write_enum() {\n-    let animal = Dog;\n-    assert_eq!(json::as_json(&animal).to_string(), \"\\\"Dog\\\"\");\n-    assert_eq!(json::as_pretty_json(&animal).to_string(), \"\\\"Dog\\\"\");\n-\n-    let animal = Frog(\"Henry\".to_string(), 349);\n-    assert_eq!(\n-        json::as_json(&animal).to_string(),\n-        \"{\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\",349]}\"\n-    );\n-    assert_eq!(\n-        json::as_pretty_json(&animal).to_string(),\n-        \"{\\n  \\\n-           \\\"variant\\\": \\\"Frog\\\",\\n  \\\n-           \\\"fields\\\": [\\n    \\\n-             \\\"Henry\\\",\\n    \\\n-             349\\n  \\\n-           ]\\n\\\n-         }\"\n-    );\n-}\n-\n-macro_rules! check_encoder_for_simple {\n-    ($value:expr, $expected:expr) => {{\n-        let s = json::as_json(&$value).to_string();\n-        assert_eq!(s, $expected);\n-\n-        let s = json::as_pretty_json(&$value).to_string();\n-        assert_eq!(s, $expected);\n-    }};\n-}\n-\n-#[test]\n-fn test_write_some() {\n-    check_encoder_for_simple!(Some(\"jodhpurs\".to_string()), \"\\\"jodhpurs\\\"\");\n-}\n-\n-#[test]\n-fn test_write_none() {\n-    check_encoder_for_simple!(None::<string::String>, \"null\");\n-}\n-\n-#[test]\n-fn test_write_char() {\n-    check_encoder_for_simple!('a', \"\\\"a\\\"\");\n-    check_encoder_for_simple!('\\t', \"\\\"\\\\t\\\"\");\n-    check_encoder_for_simple!('\\u{0000}', \"\\\"\\\\u0000\\\"\");\n-    check_encoder_for_simple!('\\u{001b}', \"\\\"\\\\u001b\\\"\");\n-    check_encoder_for_simple!('\\u{007f}', \"\\\"\\\\u007f\\\"\");\n-    check_encoder_for_simple!('\\u{00a0}', \"\\\"\\u{00a0}\\\"\");\n-    check_encoder_for_simple!('\\u{abcd}', \"\\\"\\u{abcd}\\\"\");\n-    check_encoder_for_simple!('\\u{10ffff}', \"\\\"\\u{10ffff}\\\"\");\n-}\n-\n-#[test]\n-fn test_trailing_characters() {\n-    assert_eq!(from_str(\"nulla\"), Err(SyntaxError(TrailingCharacters, 1, 5)));\n-    assert_eq!(from_str(\"truea\"), Err(SyntaxError(TrailingCharacters, 1, 5)));\n-    assert_eq!(from_str(\"falsea\"), Err(SyntaxError(TrailingCharacters, 1, 6)));\n-    assert_eq!(from_str(\"1a\"), Err(SyntaxError(TrailingCharacters, 1, 2)));\n-    assert_eq!(from_str(\"[]a\"), Err(SyntaxError(TrailingCharacters, 1, 3)));\n-    assert_eq!(from_str(\"{}a\"), Err(SyntaxError(TrailingCharacters, 1, 3)));\n-}\n-\n-#[test]\n-fn test_read_identifiers() {\n-    assert_eq!(from_str(\"n\"), Err(SyntaxError(InvalidSyntax, 1, 2)));\n-    assert_eq!(from_str(\"nul\"), Err(SyntaxError(InvalidSyntax, 1, 4)));\n-    assert_eq!(from_str(\"t\"), Err(SyntaxError(InvalidSyntax, 1, 2)));\n-    assert_eq!(from_str(\"truz\"), Err(SyntaxError(InvalidSyntax, 1, 4)));\n-    assert_eq!(from_str(\"f\"), Err(SyntaxError(InvalidSyntax, 1, 2)));\n-    assert_eq!(from_str(\"faz\"), Err(SyntaxError(InvalidSyntax, 1, 3)));\n-\n-    assert_eq!(from_str(\"null\"), Ok(Null));\n-    assert_eq!(from_str(\"true\"), Ok(Boolean(true)));\n-    assert_eq!(from_str(\"false\"), Ok(Boolean(false)));\n-    assert_eq!(from_str(\" null \"), Ok(Null));\n-    assert_eq!(from_str(\" true \"), Ok(Boolean(true)));\n-    assert_eq!(from_str(\" false \"), Ok(Boolean(false)));\n-}\n-\n-#[test]\n-fn test_read_number() {\n-    assert_eq!(from_str(\"+\"), Err(SyntaxError(InvalidSyntax, 1, 1)));\n-    assert_eq!(from_str(\".\"), Err(SyntaxError(InvalidSyntax, 1, 1)));\n-    assert_eq!(from_str(\"NaN\"), Err(SyntaxError(InvalidSyntax, 1, 1)));\n-    assert_eq!(from_str(\"-\"), Err(SyntaxError(InvalidNumber, 1, 2)));\n-    assert_eq!(from_str(\"00\"), Err(SyntaxError(InvalidNumber, 1, 2)));\n-    assert_eq!(from_str(\"1.\"), Err(SyntaxError(InvalidNumber, 1, 3)));\n-    assert_eq!(from_str(\"1e\"), Err(SyntaxError(InvalidNumber, 1, 3)));\n-    assert_eq!(from_str(\"1e+\"), Err(SyntaxError(InvalidNumber, 1, 4)));\n-\n-    assert_eq!(from_str(\"18446744073709551616\"), Err(SyntaxError(InvalidNumber, 1, 20)));\n-    assert_eq!(from_str(\"-9223372036854775809\"), Err(SyntaxError(InvalidNumber, 1, 21)));\n-\n-    assert_eq!(from_str(\"3\"), Ok(U64(3)));\n-    assert_eq!(from_str(\"3.1\"), Ok(F64(3.1)));\n-    assert_eq!(from_str(\"-1.2\"), Ok(F64(-1.2)));\n-    assert_eq!(from_str(\"0.4\"), Ok(F64(0.4)));\n-    assert_eq!(from_str(\"0.4e5\"), Ok(F64(0.4e5)));\n-    assert_eq!(from_str(\"0.4e+15\"), Ok(F64(0.4e15)));\n-    assert_eq!(from_str(\"0.4e-01\"), Ok(F64(0.4e-01)));\n-    assert_eq!(from_str(\" 3 \"), Ok(U64(3)));\n-\n-    assert_eq!(from_str(\"-9223372036854775808\"), Ok(I64(i64::MIN)));\n-    assert_eq!(from_str(\"9223372036854775807\"), Ok(U64(i64::MAX as u64)));\n-    assert_eq!(from_str(\"18446744073709551615\"), Ok(U64(u64::MAX)));\n-}\n-\n-#[test]\n-fn test_read_str() {\n-    assert_eq!(from_str(\"\\\"\"), Err(SyntaxError(EOFWhileParsingString, 1, 2)));\n-    assert_eq!(from_str(\"\\\"lol\"), Err(SyntaxError(EOFWhileParsingString, 1, 5)));\n-\n-    assert_eq!(from_str(\"\\\"\\\"\"), Ok(String(\"\".to_string())));\n-    assert_eq!(from_str(\"\\\"foo\\\"\"), Ok(String(\"foo\".to_string())));\n-    assert_eq!(from_str(\"\\\"\\\\\\\"\\\"\"), Ok(String(\"\\\"\".to_string())));\n-    assert_eq!(from_str(\"\\\"\\\\b\\\"\"), Ok(String(\"\\x08\".to_string())));\n-    assert_eq!(from_str(\"\\\"\\\\n\\\"\"), Ok(String(\"\\n\".to_string())));\n-    assert_eq!(from_str(\"\\\"\\\\r\\\"\"), Ok(String(\"\\r\".to_string())));\n-    assert_eq!(from_str(\"\\\"\\\\t\\\"\"), Ok(String(\"\\t\".to_string())));\n-    assert_eq!(from_str(\" \\\"foo\\\" \"), Ok(String(\"foo\".to_string())));\n-    assert_eq!(from_str(\"\\\"\\\\u12ab\\\"\"), Ok(String(\"\\u{12ab}\".to_string())));\n-    assert_eq!(from_str(\"\\\"\\\\uAB12\\\"\"), Ok(String(\"\\u{AB12}\".to_string())));\n-}\n-\n-#[test]\n-fn test_read_array() {\n-    assert_eq!(from_str(\"[\"), Err(SyntaxError(EOFWhileParsingValue, 1, 2)));\n-    assert_eq!(from_str(\"[1\"), Err(SyntaxError(EOFWhileParsingArray, 1, 3)));\n-    assert_eq!(from_str(\"[1,\"), Err(SyntaxError(EOFWhileParsingValue, 1, 4)));\n-    assert_eq!(from_str(\"[1,]\"), Err(SyntaxError(InvalidSyntax, 1, 4)));\n-    assert_eq!(from_str(\"[6 7]\"), Err(SyntaxError(InvalidSyntax, 1, 4)));\n-\n-    assert_eq!(from_str(\"[]\"), Ok(Array(vec![])));\n-    assert_eq!(from_str(\"[ ]\"), Ok(Array(vec![])));\n-    assert_eq!(from_str(\"[true]\"), Ok(Array(vec![Boolean(true)])));\n-    assert_eq!(from_str(\"[ false ]\"), Ok(Array(vec![Boolean(false)])));\n-    assert_eq!(from_str(\"[null]\"), Ok(Array(vec![Null])));\n-    assert_eq!(from_str(\"[3, 1]\"), Ok(Array(vec![U64(3), U64(1)])));\n-    assert_eq!(from_str(\"\\n[3, 2]\\n\"), Ok(Array(vec![U64(3), U64(2)])));\n-    assert_eq!(from_str(\"[2, [4, 1]]\"), Ok(Array(vec![U64(2), Array(vec![U64(4), U64(1)])])));\n-}\n-\n-#[test]\n-fn test_read_object() {\n-    assert_eq!(from_str(\"{\"), Err(SyntaxError(EOFWhileParsingObject, 1, 2)));\n-    assert_eq!(from_str(\"{ \"), Err(SyntaxError(EOFWhileParsingObject, 1, 3)));\n-    assert_eq!(from_str(\"{1\"), Err(SyntaxError(KeyMustBeAString, 1, 2)));\n-    assert_eq!(from_str(\"{ \\\"a\\\"\"), Err(SyntaxError(EOFWhileParsingObject, 1, 6)));\n-    assert_eq!(from_str(\"{\\\"a\\\"\"), Err(SyntaxError(EOFWhileParsingObject, 1, 5)));\n-    assert_eq!(from_str(\"{\\\"a\\\" \"), Err(SyntaxError(EOFWhileParsingObject, 1, 6)));\n-\n-    assert_eq!(from_str(\"{\\\"a\\\" 1\"), Err(SyntaxError(ExpectedColon, 1, 6)));\n-    assert_eq!(from_str(\"{\\\"a\\\":\"), Err(SyntaxError(EOFWhileParsingValue, 1, 6)));\n-    assert_eq!(from_str(\"{\\\"a\\\":1\"), Err(SyntaxError(EOFWhileParsingObject, 1, 7)));\n-    assert_eq!(from_str(\"{\\\"a\\\":1 1\"), Err(SyntaxError(InvalidSyntax, 1, 8)));\n-    assert_eq!(from_str(\"{\\\"a\\\":1,\"), Err(SyntaxError(EOFWhileParsingObject, 1, 8)));\n-\n-    assert_eq!(from_str(\"{}\").unwrap(), mk_object(&[]));\n-    assert_eq!(from_str(\"{\\\"a\\\": 3}\").unwrap(), mk_object(&[(\"a\".to_string(), U64(3))]));\n-\n-    assert_eq!(\n-        from_str(\"{ \\\"a\\\": null, \\\"b\\\" : true }\").unwrap(),\n-        mk_object(&[(\"a\".to_string(), Null), (\"b\".to_string(), Boolean(true))])\n-    );\n-    assert_eq!(\n-        from_str(\"\\n{ \\\"a\\\": null, \\\"b\\\" : true }\\n\").unwrap(),\n-        mk_object(&[(\"a\".to_string(), Null), (\"b\".to_string(), Boolean(true))])\n-    );\n-    assert_eq!(\n-        from_str(\"{\\\"a\\\" : 1.0 ,\\\"b\\\": [ true ]}\").unwrap(),\n-        mk_object(&[(\"a\".to_string(), F64(1.0)), (\"b\".to_string(), Array(vec![Boolean(true)]))])\n-    );\n-    assert_eq!(\n-        from_str(\n-            \"{\\\n-                        \\\"a\\\": 1.0, \\\n-                        \\\"b\\\": [\\\n-                            true,\\\n-                            \\\"foo\\\\nbar\\\", \\\n-                            { \\\"c\\\": {\\\"d\\\": null} } \\\n-                        ]\\\n-                    }\"\n-        )\n-        .unwrap(),\n-        mk_object(&[\n-            (\"a\".to_string(), F64(1.0)),\n-            (\n-                \"b\".to_string(),\n-                Array(vec![\n-                    Boolean(true),\n-                    String(\"foo\\nbar\".to_string()),\n-                    mk_object(&[(\"c\".to_string(), mk_object(&[(\"d\".to_string(), Null)]))])\n-                ])\n-            )\n-        ])\n-    );\n-}\n-\n-#[test]\n-fn test_multiline_errors() {\n-    assert_eq!(from_str(\"{\\n  \\\"foo\\\":\\n \\\"bar\\\"\"), Err(SyntaxError(EOFWhileParsingObject, 3, 8)));\n-}\n-\n-#[test]\n-fn test_find() {\n-    let json_value = from_str(\"{\\\"dog\\\" : \\\"cat\\\"}\").unwrap();\n-    let found_str = json_value.find(\"dog\");\n-    assert!(found_str.unwrap().as_string().unwrap() == \"cat\");\n-}\n-\n-#[test]\n-fn test_find_path() {\n-    let json_value = from_str(\"{\\\"dog\\\":{\\\"cat\\\": {\\\"mouse\\\" : \\\"cheese\\\"}}}\").unwrap();\n-    let found_str = json_value.find_path(&[\"dog\", \"cat\", \"mouse\"]);\n-    assert!(found_str.unwrap().as_string().unwrap() == \"cheese\");\n-}\n-\n-#[test]\n-fn test_search() {\n-    let json_value = from_str(\"{\\\"dog\\\":{\\\"cat\\\": {\\\"mouse\\\" : \\\"cheese\\\"}}}\").unwrap();\n-    let found_str = json_value.search(\"mouse\").and_then(|j| j.as_string());\n-    assert!(found_str.unwrap() == \"cheese\");\n-}\n-\n-#[test]\n-fn test_index() {\n-    let json_value = from_str(\"{\\\"animals\\\":[\\\"dog\\\",\\\"cat\\\",\\\"mouse\\\"]}\").unwrap();\n-    let ref array = json_value[\"animals\"];\n-    assert_eq!(array[0].as_string().unwrap(), \"dog\");\n-    assert_eq!(array[1].as_string().unwrap(), \"cat\");\n-    assert_eq!(array[2].as_string().unwrap(), \"mouse\");\n-}\n-\n-#[test]\n-fn test_is_object() {\n-    let json_value = from_str(\"{}\").unwrap();\n-    assert!(json_value.is_object());\n-}\n-\n-#[test]\n-fn test_as_object() {\n-    let json_value = from_str(\"{}\").unwrap();\n-    let json_object = json_value.as_object();\n-    assert!(json_object.is_some());\n-}\n-\n-#[test]\n-fn test_is_array() {\n-    let json_value = from_str(\"[1, 2, 3]\").unwrap();\n-    assert!(json_value.is_array());\n-}\n-\n-#[test]\n-fn test_as_array() {\n-    let json_value = from_str(\"[1, 2, 3]\").unwrap();\n-    let json_array = json_value.as_array();\n-    let expected_length = 3;\n-    assert!(json_array.is_some() && json_array.unwrap().len() == expected_length);\n-}\n-\n-#[test]\n-fn test_is_string() {\n-    let json_value = from_str(\"\\\"dog\\\"\").unwrap();\n-    assert!(json_value.is_string());\n-}\n-\n-#[test]\n-fn test_as_string() {\n-    let json_value = from_str(\"\\\"dog\\\"\").unwrap();\n-    let json_str = json_value.as_string();\n-    let expected_str = \"dog\";\n-    assert_eq!(json_str, Some(expected_str));\n-}\n-\n-#[test]\n-fn test_is_number() {\n-    let json_value = from_str(\"12\").unwrap();\n-    assert!(json_value.is_number());\n-}\n-\n-#[test]\n-fn test_is_i64() {\n-    let json_value = from_str(\"-12\").unwrap();\n-    assert!(json_value.is_i64());\n-\n-    let json_value = from_str(\"12\").unwrap();\n-    assert!(!json_value.is_i64());\n-\n-    let json_value = from_str(\"12.0\").unwrap();\n-    assert!(!json_value.is_i64());\n-}\n-\n-#[test]\n-fn test_is_u64() {\n-    let json_value = from_str(\"12\").unwrap();\n-    assert!(json_value.is_u64());\n-\n-    let json_value = from_str(\"-12\").unwrap();\n-    assert!(!json_value.is_u64());\n-\n-    let json_value = from_str(\"12.0\").unwrap();\n-    assert!(!json_value.is_u64());\n-}\n-\n-#[test]\n-fn test_is_f64() {\n-    let json_value = from_str(\"12\").unwrap();\n-    assert!(!json_value.is_f64());\n-\n-    let json_value = from_str(\"-12\").unwrap();\n-    assert!(!json_value.is_f64());\n-\n-    let json_value = from_str(\"12.0\").unwrap();\n-    assert!(json_value.is_f64());\n-\n-    let json_value = from_str(\"-12.0\").unwrap();\n-    assert!(json_value.is_f64());\n-}\n-\n-#[test]\n-fn test_as_i64() {\n-    let json_value = from_str(\"-12\").unwrap();\n-    let json_num = json_value.as_i64();\n-    assert_eq!(json_num, Some(-12));\n-}\n-\n-#[test]\n-fn test_as_u64() {\n-    let json_value = from_str(\"12\").unwrap();\n-    let json_num = json_value.as_u64();\n-    assert_eq!(json_num, Some(12));\n-}\n-\n-#[test]\n-fn test_as_f64() {\n-    let json_value = from_str(\"12.0\").unwrap();\n-    let json_num = json_value.as_f64();\n-    assert_eq!(json_num, Some(12f64));\n-}\n-\n-#[test]\n-fn test_is_boolean() {\n-    let json_value = from_str(\"false\").unwrap();\n-    assert!(json_value.is_boolean());\n-}\n-\n-#[test]\n-fn test_as_boolean() {\n-    let json_value = from_str(\"false\").unwrap();\n-    let json_bool = json_value.as_boolean();\n-    let expected_bool = false;\n-    assert!(json_bool.is_some() && json_bool.unwrap() == expected_bool);\n-}\n-\n-#[test]\n-fn test_is_null() {\n-    let json_value = from_str(\"null\").unwrap();\n-    assert!(json_value.is_null());\n-}\n-\n-#[test]\n-fn test_as_null() {\n-    let json_value = from_str(\"null\").unwrap();\n-    let json_null = json_value.as_null();\n-    let expected_null = ();\n-    assert!(json_null.is_some() && json_null.unwrap() == expected_null);\n-}\n-\n-#[test]\n-fn test_encode_hashmap_with_numeric_key() {\n-    use std::collections::HashMap;\n-    use std::str::from_utf8;\n-    let mut hm: HashMap<usize, bool> = HashMap::new();\n-    hm.insert(1, true);\n-    let mut mem_buf = Vec::new();\n-    write!(&mut mem_buf, \"{}\", json::as_pretty_json(&hm)).unwrap();\n-    let json_str = from_utf8(&mem_buf[..]).unwrap();\n-    match from_str(json_str) {\n-        Err(_) => panic!(\"Unable to parse json_str: {:?}\", json_str),\n-        _ => {} // it parsed and we are good to go\n-    }\n-}\n-\n-#[test]\n-fn test_prettyencode_hashmap_with_numeric_key() {\n-    use std::collections::HashMap;\n-    use std::str::from_utf8;\n-    let mut hm: HashMap<usize, bool> = HashMap::new();\n-    hm.insert(1, true);\n-    let mut mem_buf = Vec::new();\n-    write!(&mut mem_buf, \"{}\", json::as_pretty_json(&hm)).unwrap();\n-    let json_str = from_utf8(&mem_buf[..]).unwrap();\n-    match from_str(json_str) {\n-        Err(_) => panic!(\"Unable to parse json_str: {:?}\", json_str),\n-        _ => {} // it parsed and we are good to go\n-    }\n-}\n-\n-#[test]\n-fn test_prettyencoder_indent_level_param() {\n-    use std::collections::BTreeMap;\n-    use std::str::from_utf8;\n-\n-    let mut tree = BTreeMap::new();\n-\n-    tree.insert(\"hello\".to_string(), String(\"guten tag\".to_string()));\n-    tree.insert(\"goodbye\".to_string(), String(\"sayonara\".to_string()));\n-\n-    let json = Array(\n-        // The following layout below should look a lot like\n-        // the pretty-printed JSON (indent * x)\n-        vec![\n-            // 0x\n-            String(\"greetings\".to_string()), // 1x\n-            Object(tree),                    // 1x + 2x + 2x + 1x\n-        ], // 0x\n-           // End JSON array (7 lines)\n-    );\n-\n-    // Helper function for counting indents\n-    fn indents(source: &str) -> usize {\n-        let trimmed = source.trim_start_matches(' ');\n-        source.len() - trimmed.len()\n-    }\n-\n-    // Test up to 4 spaces of indents (more?)\n-    for i in 0..4 {\n-        let mut writer = Vec::new();\n-        write!(&mut writer, \"{}\", json::as_pretty_json(&json).indent(i)).unwrap();\n-\n-        let printed = from_utf8(&writer[..]).unwrap();\n-\n-        // Check for indents at each line\n-        let lines: Vec<&str> = printed.lines().collect();\n-        assert_eq!(lines.len(), 7); // JSON should be 7 lines\n-\n-        assert_eq!(indents(lines[0]), 0 * i); // [\n-        assert_eq!(indents(lines[1]), 1 * i); //   \"greetings\",\n-        assert_eq!(indents(lines[2]), 1 * i); //   {\n-        assert_eq!(indents(lines[3]), 2 * i); //     \"hello\": \"guten tag\",\n-        assert_eq!(indents(lines[4]), 2 * i); //     \"goodbye\": \"sayonara\"\n-        assert_eq!(indents(lines[5]), 1 * i); //   },\n-        assert_eq!(indents(lines[6]), 0 * i); // ]\n-\n-        // Finally, test that the pretty-printed JSON is valid\n-        from_str(printed).ok().expect(\"Pretty-printed JSON is invalid!\");\n-    }\n-}\n-\n-#[test]\n-fn test_hashmap_with_enum_key() {\n-    use std::collections::HashMap;\n-    #[derive(Encodable, Eq, Hash, PartialEq, Debug)]\n-    enum Enum {\n-        Foo,\n-        #[allow(dead_code)]\n-        Bar,\n-    }\n-    let mut map = HashMap::new();\n-    map.insert(Enum::Foo, 0);\n-    let result = json::encode(&map).unwrap();\n-    assert_eq!(&result[..], r#\"{\"Foo\":0}\"#);\n-}\n-\n-fn assert_stream_equal(src: &str, expected: Vec<(JsonEvent, Vec<StackElement<'_>>)>) {\n-    let mut parser = Parser::new(src.chars());\n-    let mut i = 0;\n-    loop {\n-        let evt = match parser.next() {\n-            Some(e) => e,\n-            None => {\n-                break;\n-            }\n-        };\n-        let (ref expected_evt, ref expected_stack) = expected[i];\n-        if !parser.stack().is_equal_to(expected_stack) {\n-            panic!(\"Parser stack is not equal to {:?}\", expected_stack);\n-        }\n-        assert_eq!(&evt, expected_evt);\n-        i += 1;\n-    }\n-}\n-#[test]\n-fn test_streaming_parser() {\n-    assert_stream_equal(\n-        r#\"{ \"foo\":\"bar\", \"array\" : [0, 1, 2, 3, 4, 5], \"idents\":[null,true,false]}\"#,\n-        vec![\n-            (ObjectStart, vec![]),\n-            (StringValue(\"bar\".to_string()), vec![StackElement::Key(\"foo\")]),\n-            (ArrayStart, vec![StackElement::Key(\"array\")]),\n-            (U64Value(0), vec![StackElement::Key(\"array\"), StackElement::Index(0)]),\n-            (U64Value(1), vec![StackElement::Key(\"array\"), StackElement::Index(1)]),\n-            (U64Value(2), vec![StackElement::Key(\"array\"), StackElement::Index(2)]),\n-            (U64Value(3), vec![StackElement::Key(\"array\"), StackElement::Index(3)]),\n-            (U64Value(4), vec![StackElement::Key(\"array\"), StackElement::Index(4)]),\n-            (U64Value(5), vec![StackElement::Key(\"array\"), StackElement::Index(5)]),\n-            (ArrayEnd, vec![StackElement::Key(\"array\")]),\n-            (ArrayStart, vec![StackElement::Key(\"idents\")]),\n-            (NullValue, vec![StackElement::Key(\"idents\"), StackElement::Index(0)]),\n-            (BooleanValue(true), vec![StackElement::Key(\"idents\"), StackElement::Index(1)]),\n-            (BooleanValue(false), vec![StackElement::Key(\"idents\"), StackElement::Index(2)]),\n-            (ArrayEnd, vec![StackElement::Key(\"idents\")]),\n-            (ObjectEnd, vec![]),\n-        ],\n-    );\n-}\n-fn last_event(src: &str) -> JsonEvent {\n-    let mut parser = Parser::new(src.chars());\n-    let mut evt = NullValue;\n-    loop {\n-        evt = match parser.next() {\n-            Some(e) => e,\n-            None => return evt,\n-        }\n-    }\n-}\n-\n-#[test]\n-fn test_read_object_streaming() {\n-    assert_eq!(last_event(\"{ \"), Error(SyntaxError(EOFWhileParsingObject, 1, 3)));\n-    assert_eq!(last_event(\"{1\"), Error(SyntaxError(KeyMustBeAString, 1, 2)));\n-    assert_eq!(last_event(\"{ \\\"a\\\"\"), Error(SyntaxError(EOFWhileParsingObject, 1, 6)));\n-    assert_eq!(last_event(\"{\\\"a\\\"\"), Error(SyntaxError(EOFWhileParsingObject, 1, 5)));\n-    assert_eq!(last_event(\"{\\\"a\\\" \"), Error(SyntaxError(EOFWhileParsingObject, 1, 6)));\n-\n-    assert_eq!(last_event(\"{\\\"a\\\" 1\"), Error(SyntaxError(ExpectedColon, 1, 6)));\n-    assert_eq!(last_event(\"{\\\"a\\\":\"), Error(SyntaxError(EOFWhileParsingValue, 1, 6)));\n-    assert_eq!(last_event(\"{\\\"a\\\":1\"), Error(SyntaxError(EOFWhileParsingObject, 1, 7)));\n-    assert_eq!(last_event(\"{\\\"a\\\":1 1\"), Error(SyntaxError(InvalidSyntax, 1, 8)));\n-    assert_eq!(last_event(\"{\\\"a\\\":1,\"), Error(SyntaxError(EOFWhileParsingObject, 1, 8)));\n-    assert_eq!(last_event(\"{\\\"a\\\":1,}\"), Error(SyntaxError(TrailingComma, 1, 8)));\n-\n-    assert_stream_equal(\"{}\", vec![(ObjectStart, vec![]), (ObjectEnd, vec![])]);\n-    assert_stream_equal(\n-        \"{\\\"a\\\": 3}\",\n-        vec![\n-            (ObjectStart, vec![]),\n-            (U64Value(3), vec![StackElement::Key(\"a\")]),\n-            (ObjectEnd, vec![]),\n-        ],\n-    );\n-    assert_stream_equal(\n-        \"{ \\\"a\\\": null, \\\"b\\\" : true }\",\n-        vec![\n-            (ObjectStart, vec![]),\n-            (NullValue, vec![StackElement::Key(\"a\")]),\n-            (BooleanValue(true), vec![StackElement::Key(\"b\")]),\n-            (ObjectEnd, vec![]),\n-        ],\n-    );\n-    assert_stream_equal(\n-        \"{\\\"a\\\" : 1.0 ,\\\"b\\\": [ true ]}\",\n-        vec![\n-            (ObjectStart, vec![]),\n-            (F64Value(1.0), vec![StackElement::Key(\"a\")]),\n-            (ArrayStart, vec![StackElement::Key(\"b\")]),\n-            (BooleanValue(true), vec![StackElement::Key(\"b\"), StackElement::Index(0)]),\n-            (ArrayEnd, vec![StackElement::Key(\"b\")]),\n-            (ObjectEnd, vec![]),\n-        ],\n-    );\n-    assert_stream_equal(\n-        r#\"{\n-            \"a\": 1.0,\n-            \"b\": [\n-                true,\n-                \"foo\\nbar\",\n-                { \"c\": {\"d\": null} }\n-            ]\n-        }\"#,\n-        vec![\n-            (ObjectStart, vec![]),\n-            (F64Value(1.0), vec![StackElement::Key(\"a\")]),\n-            (ArrayStart, vec![StackElement::Key(\"b\")]),\n-            (BooleanValue(true), vec![StackElement::Key(\"b\"), StackElement::Index(0)]),\n-            (\n-                StringValue(\"foo\\nbar\".to_string()),\n-                vec![StackElement::Key(\"b\"), StackElement::Index(1)],\n-            ),\n-            (ObjectStart, vec![StackElement::Key(\"b\"), StackElement::Index(2)]),\n-            (\n-                ObjectStart,\n-                vec![StackElement::Key(\"b\"), StackElement::Index(2), StackElement::Key(\"c\")],\n-            ),\n-            (\n-                NullValue,\n-                vec![\n-                    StackElement::Key(\"b\"),\n-                    StackElement::Index(2),\n-                    StackElement::Key(\"c\"),\n-                    StackElement::Key(\"d\"),\n-                ],\n-            ),\n-            (\n-                ObjectEnd,\n-                vec![StackElement::Key(\"b\"), StackElement::Index(2), StackElement::Key(\"c\")],\n-            ),\n-            (ObjectEnd, vec![StackElement::Key(\"b\"), StackElement::Index(2)]),\n-            (ArrayEnd, vec![StackElement::Key(\"b\")]),\n-            (ObjectEnd, vec![]),\n-        ],\n-    );\n-}\n-#[test]\n-fn test_read_array_streaming() {\n-    assert_stream_equal(\"[]\", vec![(ArrayStart, vec![]), (ArrayEnd, vec![])]);\n-    assert_stream_equal(\"[ ]\", vec![(ArrayStart, vec![]), (ArrayEnd, vec![])]);\n-    assert_stream_equal(\n-        \"[true]\",\n-        vec![\n-            (ArrayStart, vec![]),\n-            (BooleanValue(true), vec![StackElement::Index(0)]),\n-            (ArrayEnd, vec![]),\n-        ],\n-    );\n-    assert_stream_equal(\n-        \"[ false ]\",\n-        vec![\n-            (ArrayStart, vec![]),\n-            (BooleanValue(false), vec![StackElement::Index(0)]),\n-            (ArrayEnd, vec![]),\n-        ],\n-    );\n-    assert_stream_equal(\n-        \"[null]\",\n-        vec![(ArrayStart, vec![]), (NullValue, vec![StackElement::Index(0)]), (ArrayEnd, vec![])],\n-    );\n-    assert_stream_equal(\n-        \"[3, 1]\",\n-        vec![\n-            (ArrayStart, vec![]),\n-            (U64Value(3), vec![StackElement::Index(0)]),\n-            (U64Value(1), vec![StackElement::Index(1)]),\n-            (ArrayEnd, vec![]),\n-        ],\n-    );\n-    assert_stream_equal(\n-        \"\\n[3, 2]\\n\",\n-        vec![\n-            (ArrayStart, vec![]),\n-            (U64Value(3), vec![StackElement::Index(0)]),\n-            (U64Value(2), vec![StackElement::Index(1)]),\n-            (ArrayEnd, vec![]),\n-        ],\n-    );\n-    assert_stream_equal(\n-        \"[2, [4, 1]]\",\n-        vec![\n-            (ArrayStart, vec![]),\n-            (U64Value(2), vec![StackElement::Index(0)]),\n-            (ArrayStart, vec![StackElement::Index(1)]),\n-            (U64Value(4), vec![StackElement::Index(1), StackElement::Index(0)]),\n-            (U64Value(1), vec![StackElement::Index(1), StackElement::Index(1)]),\n-            (ArrayEnd, vec![StackElement::Index(1)]),\n-            (ArrayEnd, vec![]),\n-        ],\n-    );\n-\n-    assert_eq!(last_event(\"[\"), Error(SyntaxError(EOFWhileParsingValue, 1, 2)));\n-\n-    assert_eq!(from_str(\"[\"), Err(SyntaxError(EOFWhileParsingValue, 1, 2)));\n-    assert_eq!(from_str(\"[1\"), Err(SyntaxError(EOFWhileParsingArray, 1, 3)));\n-    assert_eq!(from_str(\"[1,\"), Err(SyntaxError(EOFWhileParsingValue, 1, 4)));\n-    assert_eq!(from_str(\"[1,]\"), Err(SyntaxError(InvalidSyntax, 1, 4)));\n-    assert_eq!(from_str(\"[6 7]\"), Err(SyntaxError(InvalidSyntax, 1, 4)));\n-}\n-#[test]\n-fn test_trailing_characters_streaming() {\n-    assert_eq!(last_event(\"nulla\"), Error(SyntaxError(TrailingCharacters, 1, 5)));\n-    assert_eq!(last_event(\"truea\"), Error(SyntaxError(TrailingCharacters, 1, 5)));\n-    assert_eq!(last_event(\"falsea\"), Error(SyntaxError(TrailingCharacters, 1, 6)));\n-    assert_eq!(last_event(\"1a\"), Error(SyntaxError(TrailingCharacters, 1, 2)));\n-    assert_eq!(last_event(\"[]a\"), Error(SyntaxError(TrailingCharacters, 1, 3)));\n-    assert_eq!(last_event(\"{}a\"), Error(SyntaxError(TrailingCharacters, 1, 3)));\n-}\n-#[test]\n-fn test_read_identifiers_streaming() {\n-    assert_eq!(Parser::new(\"null\".chars()).next(), Some(NullValue));\n-    assert_eq!(Parser::new(\"true\".chars()).next(), Some(BooleanValue(true)));\n-    assert_eq!(Parser::new(\"false\".chars()).next(), Some(BooleanValue(false)));\n-\n-    assert_eq!(last_event(\"n\"), Error(SyntaxError(InvalidSyntax, 1, 2)));\n-    assert_eq!(last_event(\"nul\"), Error(SyntaxError(InvalidSyntax, 1, 4)));\n-    assert_eq!(last_event(\"t\"), Error(SyntaxError(InvalidSyntax, 1, 2)));\n-    assert_eq!(last_event(\"truz\"), Error(SyntaxError(InvalidSyntax, 1, 4)));\n-    assert_eq!(last_event(\"f\"), Error(SyntaxError(InvalidSyntax, 1, 2)));\n-    assert_eq!(last_event(\"faz\"), Error(SyntaxError(InvalidSyntax, 1, 3)));\n-}\n-\n-#[test]\n-fn test_to_json() {\n-    use json::ToJson;\n-    use std::collections::{BTreeMap, HashMap};\n-\n-    let array2 = Array(vec![U64(1), U64(2)]);\n-    let array3 = Array(vec![U64(1), U64(2), U64(3)]);\n-    let object = {\n-        let mut tree_map = BTreeMap::new();\n-        tree_map.insert(\"a\".to_string(), U64(1));\n-        tree_map.insert(\"b\".to_string(), U64(2));\n-        Object(tree_map)\n-    };\n-\n-    assert_eq!(array2.to_json(), array2);\n-    assert_eq!(object.to_json(), object);\n-    assert_eq!(3_isize.to_json(), I64(3));\n-    assert_eq!(4_i8.to_json(), I64(4));\n-    assert_eq!(5_i16.to_json(), I64(5));\n-    assert_eq!(6_i32.to_json(), I64(6));\n-    assert_eq!(7_i64.to_json(), I64(7));\n-    assert_eq!(8_usize.to_json(), U64(8));\n-    assert_eq!(9_u8.to_json(), U64(9));\n-    assert_eq!(10_u16.to_json(), U64(10));\n-    assert_eq!(11_u32.to_json(), U64(11));\n-    assert_eq!(12_u64.to_json(), U64(12));\n-    assert_eq!(13.0_f32.to_json(), F64(13.0_f64));\n-    assert_eq!(14.0_f64.to_json(), F64(14.0_f64));\n-    assert_eq!(().to_json(), Null);\n-    assert_eq!(f32::INFINITY.to_json(), Null);\n-    assert_eq!(f64::NAN.to_json(), Null);\n-    assert_eq!(true.to_json(), Boolean(true));\n-    assert_eq!(false.to_json(), Boolean(false));\n-    assert_eq!(\"abc\".to_json(), String(\"abc\".to_string()));\n-    assert_eq!(\"abc\".to_string().to_json(), String(\"abc\".to_string()));\n-    assert_eq!((1_usize, 2_usize).to_json(), array2);\n-    assert_eq!((1_usize, 2_usize, 3_usize).to_json(), array3);\n-    assert_eq!([1_usize, 2_usize].to_json(), array2);\n-    assert_eq!((&[1_usize, 2_usize, 3_usize]).to_json(), array3);\n-    assert_eq!((vec![1_usize, 2_usize]).to_json(), array2);\n-    assert_eq!(vec![1_usize, 2_usize, 3_usize].to_json(), array3);\n-    let mut tree_map = BTreeMap::new();\n-    tree_map.insert(\"a\".to_string(), 1 as usize);\n-    tree_map.insert(\"b\".to_string(), 2);\n-    assert_eq!(tree_map.to_json(), object);\n-    let mut hash_map = HashMap::new();\n-    hash_map.insert(\"a\".to_string(), 1 as usize);\n-    hash_map.insert(\"b\".to_string(), 2);\n-    assert_eq!(hash_map.to_json(), object);\n-    assert_eq!(Some(15).to_json(), I64(15));\n-    assert_eq!(Some(15 as usize).to_json(), U64(15));\n-    assert_eq!(None::<isize>.to_json(), Null);\n-}\n-\n-#[test]\n-fn test_encode_hashmap_with_arbitrary_key() {\n-    use std::collections::HashMap;\n-    #[derive(PartialEq, Eq, Hash, Encodable)]\n-    struct ArbitraryType(usize);\n-    let mut hm: HashMap<ArbitraryType, bool> = HashMap::new();\n-    hm.insert(ArbitraryType(1), true);\n-    let mut mem_buf = string::String::new();\n-    let mut encoder = Encoder::new(&mut mem_buf);\n-    let result = hm.encode(&mut encoder);\n-    match result.unwrap_err() {\n-        EncoderError::BadHashmapKey => (),\n-        _ => panic!(\"expected bad hash map key\"),\n-    }\n-}"}, {"sha": "ae32fd2dee9220e0e6c0615432d8cd152f3604b9", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=7e9b92cb43a489b34e2bcb8d21f36198e02eedbc", "patch": "@@ -1207,10 +1207,6 @@ options! {\n     assert_incr_state: Option<String> = (None, parse_opt_string, [UNTRACKED],\n         \"assert that the incremental cache is in given state: \\\n          either `loaded` or `not-loaded`.\"),\n-    ast_json: bool = (false, parse_bool, [UNTRACKED],\n-        \"print the AST as JSON and halt (default: no)\"),\n-    ast_json_noexpand: bool = (false, parse_bool, [UNTRACKED],\n-        \"print the pre-expansion AST as JSON and halt (default: no)\"),\n     binary_dep_depinfo: bool = (false, parse_bool, [TRACKED],\n         \"include artifacts (sysroot, crate dependencies) used during compilation in dep-info \\\n         (default: no)\"),"}, {"sha": "2bd0880a7c4254fa036f728a39260aae8049e718", "filename": "compiler/rustc_span/src/def_id.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs?ref=7e9b92cb43a489b34e2bcb8d21f36198e02eedbc", "patch": "@@ -307,11 +307,8 @@ impl DefId {\n \n impl<E: Encoder> Encodable<E> for DefId {\n     default fn encode(&self, s: &mut E) -> Result<(), E::Error> {\n-        s.emit_struct(false, |s| {\n-            s.emit_struct_field(\"krate\", true, |s| self.krate.encode(s))?;\n-\n-            s.emit_struct_field(\"index\", false, |s| self.index.encode(s))\n-        })\n+        self.krate.encode(s)?;\n+        self.index.encode(s)\n     }\n }\n "}, {"sha": "01fe9aea89bc2084ff274a7d359c13bd042fa586", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 80, "deletions": 85, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=7e9b92cb43a489b34e2bcb8d21f36198e02eedbc", "patch": "@@ -196,24 +196,23 @@ impl Hash for RealFileName {\n // an added assert statement\n impl<S: Encoder> Encodable<S> for RealFileName {\n     fn encode(&self, encoder: &mut S) -> Result<(), S::Error> {\n-        encoder.emit_enum(|encoder| match *self {\n-            RealFileName::LocalPath(ref local_path) => {\n-                encoder.emit_enum_variant(\"LocalPath\", 0, 1, |encoder| {\n-                    encoder.emit_enum_variant_arg(true, |encoder| local_path.encode(encoder))?;\n-                    Ok(())\n+        match *self {\n+            RealFileName::LocalPath(ref local_path) => encoder.emit_enum_variant(0, |encoder| {\n+                Ok({\n+                    local_path.encode(encoder)?;\n                 })\n-            }\n+            }),\n \n             RealFileName::Remapped { ref local_path, ref virtual_name } => encoder\n-                .emit_enum_variant(\"Remapped\", 1, 2, |encoder| {\n+                .emit_enum_variant(1, |encoder| {\n                     // For privacy and build reproducibility, we must not embed host-dependant path in artifacts\n                     // if they have been remapped by --remap-path-prefix\n                     assert!(local_path.is_none());\n-                    encoder.emit_enum_variant_arg(true, |encoder| local_path.encode(encoder))?;\n-                    encoder.emit_enum_variant_arg(false, |encoder| virtual_name.encode(encoder))?;\n+                    local_path.encode(encoder)?;\n+                    virtual_name.encode(encoder)?;\n                     Ok(())\n                 }),\n-        })\n+        }\n     }\n }\n \n@@ -950,10 +949,8 @@ impl Default for Span {\n impl<E: Encoder> Encodable<E> for Span {\n     default fn encode(&self, s: &mut E) -> Result<(), E::Error> {\n         let span = self.data();\n-        s.emit_struct(false, |s| {\n-            s.emit_struct_field(\"lo\", true, |s| span.lo.encode(s))?;\n-            s.emit_struct_field(\"hi\", false, |s| span.hi.encode(s))\n-        })\n+        span.lo.encode(s)?;\n+        span.hi.encode(s)\n     }\n }\n impl<D: Decoder> Decodable<D> for Span {\n@@ -1302,79 +1299,77 @@ pub struct SourceFile {\n \n impl<S: Encoder> Encodable<S> for SourceFile {\n     fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_struct(false, |s| {\n-            s.emit_struct_field(\"name\", true, |s| self.name.encode(s))?;\n-            s.emit_struct_field(\"src_hash\", false, |s| self.src_hash.encode(s))?;\n-            s.emit_struct_field(\"start_pos\", false, |s| self.start_pos.encode(s))?;\n-            s.emit_struct_field(\"end_pos\", false, |s| self.end_pos.encode(s))?;\n-            s.emit_struct_field(\"lines\", false, |s| {\n-                // We are always in `Lines` form by the time we reach here.\n-                assert!(self.lines.borrow().is_lines());\n-                self.lines(|lines| {\n-                    // Store the length.\n-                    s.emit_u32(lines.len() as u32)?;\n-\n-                    // Compute and store the difference list.\n-                    if lines.len() != 0 {\n-                        let max_line_length = if lines.len() == 1 {\n-                            0\n-                        } else {\n-                            lines\n-                                .array_windows()\n-                                .map(|&[fst, snd]| snd - fst)\n-                                .map(|bp| bp.to_usize())\n-                                .max()\n-                                .unwrap()\n-                        };\n-\n-                        let bytes_per_diff: usize = match max_line_length {\n-                            0..=0xFF => 1,\n-                            0x100..=0xFFFF => 2,\n-                            _ => 4,\n-                        };\n-\n-                        // Encode the number of bytes used per diff.\n-                        s.emit_u8(bytes_per_diff as u8)?;\n-\n-                        // Encode the first element.\n-                        lines[0].encode(s)?;\n-\n-                        // Encode the difference list.\n-                        let diff_iter = lines.array_windows().map(|&[fst, snd]| snd - fst);\n-                        let num_diffs = lines.len() - 1;\n-                        let mut raw_diffs;\n-                        match bytes_per_diff {\n-                            1 => {\n-                                raw_diffs = Vec::with_capacity(num_diffs);\n-                                for diff in diff_iter {\n-                                    raw_diffs.push(diff.0 as u8);\n-                                }\n-                            }\n-                            2 => {\n-                                raw_diffs = Vec::with_capacity(bytes_per_diff * num_diffs);\n-                                for diff in diff_iter {\n-                                    raw_diffs.extend_from_slice(&(diff.0 as u16).to_le_bytes());\n-                                }\n-                            }\n-                            4 => {\n-                                raw_diffs = Vec::with_capacity(bytes_per_diff * num_diffs);\n-                                for diff in diff_iter {\n-                                    raw_diffs.extend_from_slice(&(diff.0 as u32).to_le_bytes());\n-                                }\n-                            }\n-                            _ => unreachable!(),\n+        self.name.encode(s)?;\n+        self.src_hash.encode(s)?;\n+        self.start_pos.encode(s)?;\n+        self.end_pos.encode(s)?;\n+\n+        // We are always in `Lines` form by the time we reach here.\n+        assert!(self.lines.borrow().is_lines());\n+        self.lines(|lines| {\n+            // Store the length.\n+            s.emit_u32(lines.len() as u32)?;\n+\n+            // Compute and store the difference list.\n+            if lines.len() != 0 {\n+                let max_line_length = if lines.len() == 1 {\n+                    0\n+                } else {\n+                    lines\n+                        .array_windows()\n+                        .map(|&[fst, snd]| snd - fst)\n+                        .map(|bp| bp.to_usize())\n+                        .max()\n+                        .unwrap()\n+                };\n+\n+                let bytes_per_diff: usize = match max_line_length {\n+                    0..=0xFF => 1,\n+                    0x100..=0xFFFF => 2,\n+                    _ => 4,\n+                };\n+\n+                // Encode the number of bytes used per diff.\n+                s.emit_u8(bytes_per_diff as u8)?;\n+\n+                // Encode the first element.\n+                lines[0].encode(s)?;\n+\n+                // Encode the difference list.\n+                let diff_iter = lines.array_windows().map(|&[fst, snd]| snd - fst);\n+                let num_diffs = lines.len() - 1;\n+                let mut raw_diffs;\n+                match bytes_per_diff {\n+                    1 => {\n+                        raw_diffs = Vec::with_capacity(num_diffs);\n+                        for diff in diff_iter {\n+                            raw_diffs.push(diff.0 as u8);\n                         }\n-                        s.emit_raw_bytes(&raw_diffs)?;\n                     }\n-                    Ok(())\n-                })\n-            })?;\n-            s.emit_struct_field(\"multibyte_chars\", false, |s| self.multibyte_chars.encode(s))?;\n-            s.emit_struct_field(\"non_narrow_chars\", false, |s| self.non_narrow_chars.encode(s))?;\n-            s.emit_struct_field(\"name_hash\", false, |s| self.name_hash.encode(s))?;\n-            s.emit_struct_field(\"normalized_pos\", false, |s| self.normalized_pos.encode(s))?;\n-            s.emit_struct_field(\"cnum\", false, |s| self.cnum.encode(s))\n-        })\n+                    2 => {\n+                        raw_diffs = Vec::with_capacity(bytes_per_diff * num_diffs);\n+                        for diff in diff_iter {\n+                            raw_diffs.extend_from_slice(&(diff.0 as u16).to_le_bytes());\n+                        }\n+                    }\n+                    4 => {\n+                        raw_diffs = Vec::with_capacity(bytes_per_diff * num_diffs);\n+                        for diff in diff_iter {\n+                            raw_diffs.extend_from_slice(&(diff.0 as u32).to_le_bytes());\n+                        }\n+                    }\n+                    _ => unreachable!(),\n+                }\n+                s.emit_raw_bytes(&raw_diffs)?;\n+            }\n+            Ok(())\n+        })?;\n+\n+        self.multibyte_chars.encode(s)?;\n+        self.non_narrow_chars.encode(s)?;\n+        self.name_hash.encode(s)?;\n+        self.normalized_pos.encode(s)?;\n+        self.cnum.encode(s)\n     }\n }\n "}, {"sha": "162376af45f15bc8c0353dc02053c78cfd443f68", "filename": "compiler/rustc_target/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_target%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_target%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2FCargo.toml?ref=7e9b92cb43a489b34e2bcb8d21f36198e02eedbc", "patch": "@@ -6,6 +6,7 @@ edition = \"2021\"\n [dependencies]\n bitflags = \"1.2.1\"\n tracing = \"0.1\"\n+serde_json = \"1.0.59\"\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n rustc_macros = { path = \"../rustc_macros\" }\n rustc_serialize = { path = \"../rustc_serialize\" }"}, {"sha": "0850e6834590300d8f4a7d19d98644e08af83c3e", "filename": "compiler/rustc_target/src/abi/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs?ref=7e9b92cb43a489b34e2bcb8d21f36198e02eedbc", "patch": "@@ -1,6 +1,7 @@\n pub use Integer::*;\n pub use Primitive::*;\n \n+use crate::json::{Json, ToJson};\n use crate::spec::Target;\n \n use std::convert::{TryFrom, TryInto};\n@@ -13,7 +14,6 @@ use std::str::FromStr;\n use rustc_data_structures::intern::Interned;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_macros::HashStable_Generic;\n-use rustc_serialize::json::{Json, ToJson};\n \n pub mod call;\n \n@@ -166,7 +166,8 @@ impl TargetDataLayout {\n             ));\n         }\n \n-        if dl.pointer_size.bits() != target.pointer_width.into() {\n+        let target_pointer_width: u64 = target.pointer_width.into();\n+        if dl.pointer_size.bits() != target_pointer_width {\n             return Err(format!(\n                 \"inconsistent target specification: \\\"data-layout\\\" claims \\\n                  pointers are {}-bit, while \\\"target-pointer-width\\\" is `{}`\",\n@@ -574,7 +575,7 @@ impl Align {\n }\n \n /// A pair of alignments, ABI-mandated and preferred.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, Encodable, Decodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n #[derive(HashStable_Generic)]\n pub struct AbiAndPrefAlign {\n     pub abi: Align,"}, {"sha": "b5d926352122898d2e19a64dfc03715af116437d", "filename": "compiler/rustc_target/src/json.rs", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_target%2Fsrc%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_target%2Fsrc%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fjson.rs?ref=7e9b92cb43a489b34e2bcb8d21f36198e02eedbc", "patch": "@@ -0,0 +1,91 @@\n+use std::borrow::Cow;\n+use std::collections::BTreeMap;\n+\n+pub use serde_json::Value as Json;\n+use serde_json::{Map, Number};\n+\n+pub trait ToJson {\n+    fn to_json(&self) -> Json;\n+}\n+\n+impl ToJson for Json {\n+    fn to_json(&self) -> Json {\n+        self.clone()\n+    }\n+}\n+\n+macro_rules! to_json_impl_num {\n+    ($($t:ty), +) => (\n+        $(impl ToJson for $t {\n+            fn to_json(&self) -> Json {\n+                Json::Number(Number::from(*self))\n+            }\n+        })+\n+    )\n+}\n+\n+to_json_impl_num! { isize, i8, i16, i32, i64, usize, u8, u16, u32, u64 }\n+\n+impl ToJson for bool {\n+    fn to_json(&self) -> Json {\n+        Json::Bool(*self)\n+    }\n+}\n+\n+impl ToJson for str {\n+    fn to_json(&self) -> Json {\n+        Json::String(self.to_owned())\n+    }\n+}\n+\n+impl ToJson for String {\n+    fn to_json(&self) -> Json {\n+        Json::String(self.to_owned())\n+    }\n+}\n+\n+impl<'a> ToJson for Cow<'a, str> {\n+    fn to_json(&self) -> Json {\n+        Json::String(self.to_string())\n+    }\n+}\n+\n+impl<A: ToJson> ToJson for [A] {\n+    fn to_json(&self) -> Json {\n+        Json::Array(self.iter().map(|elt| elt.to_json()).collect())\n+    }\n+}\n+\n+impl<A: ToJson> ToJson for Vec<A> {\n+    fn to_json(&self) -> Json {\n+        Json::Array(self.iter().map(|elt| elt.to_json()).collect())\n+    }\n+}\n+\n+impl<'a, A: ToJson> ToJson for Cow<'a, [A]>\n+where\n+    [A]: ToOwned,\n+{\n+    fn to_json(&self) -> Json {\n+        Json::Array(self.iter().map(|elt| elt.to_json()).collect())\n+    }\n+}\n+\n+impl<T: ToString, A: ToJson> ToJson for BTreeMap<T, A> {\n+    fn to_json(&self) -> Json {\n+        let mut d = Map::new();\n+        for (key, value) in self {\n+            d.insert(key.to_string(), value.to_json());\n+        }\n+        Json::Object(d)\n+    }\n+}\n+\n+impl<A: ToJson> ToJson for Option<A> {\n+    fn to_json(&self) -> Json {\n+        match *self {\n+            None => Json::Null,\n+            Some(ref value) => value.to_json(),\n+        }\n+    }\n+}"}, {"sha": "e9627e33ff17079a159f34f37e18cc90d215ea57", "filename": "compiler/rustc_target/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_target%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_target%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Flib.rs?ref=7e9b92cb43a489b34e2bcb8d21f36198e02eedbc", "patch": "@@ -28,6 +28,7 @@ extern crate tracing;\n \n pub mod abi;\n pub mod asm;\n+pub mod json;\n pub mod spec;\n \n #[cfg(test)]"}, {"sha": "52ac3622eca8d867136b99f025eeb44e332c7265", "filename": "compiler/rustc_target/src/spec/crt_objects.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_target%2Fsrc%2Fspec%2Fcrt_objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_target%2Fsrc%2Fspec%2Fcrt_objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fcrt_objects.rs?ref=7e9b92cb43a489b34e2bcb8d21f36198e02eedbc", "patch": "@@ -40,8 +40,8 @@\n //! but not gcc's. As a result rustc cannot link with C++ static libraries (#36710)\n //! when linking in self-contained mode.\n \n+use crate::json::{Json, ToJson};\n use crate::spec::LinkOutputKind;\n-use rustc_serialize::json::{Json, ToJson};\n use std::borrow::Cow;\n use std::collections::BTreeMap;\n use std::str::FromStr;"}, {"sha": "00c4cf6a9bc49d23183e784a201624664b8a8507", "filename": "compiler/rustc_target/src/spec/mod.rs", "status": "modified", "additions": 61, "deletions": 56, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs?ref=7e9b92cb43a489b34e2bcb8d21f36198e02eedbc", "patch": "@@ -35,11 +35,12 @@\n //! to the list specified by the target, rather than replace.\n \n use crate::abi::Endian;\n+use crate::json::{Json, ToJson};\n use crate::spec::abi::{lookup as lookup_abi, Abi};\n use crate::spec::crt_objects::{CrtObjects, CrtObjectsFallback};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-use rustc_serialize::json::{Json, ToJson};\n use rustc_span::symbol::{sym, Symbol};\n+use serde_json::Value;\n use std::borrow::Cow;\n use std::collections::BTreeMap;\n use std::convert::TryFrom;\n@@ -211,7 +212,7 @@ impl ToJson for PanicStrategy {\n     }\n }\n \n-#[derive(Clone, Copy, Debug, PartialEq, Hash, Encodable, Decodable)]\n+#[derive(Clone, Copy, Debug, PartialEq, Hash)]\n pub enum RelroLevel {\n     Full,\n     Partial,\n@@ -255,7 +256,7 @@ impl ToJson for RelroLevel {\n     }\n }\n \n-#[derive(Clone, Copy, Debug, PartialEq, Hash, Encodable, Decodable)]\n+#[derive(Clone, Copy, Debug, PartialEq, Hash)]\n pub enum MergeFunctions {\n     Disabled,\n     Trampolines,\n@@ -548,7 +549,7 @@ impl StackProbeType {\n         let object = json.as_object().ok_or_else(|| \"expected a JSON object\")?;\n         let kind = object\n             .get(\"kind\")\n-            .and_then(|o| o.as_string())\n+            .and_then(|o| o.as_str())\n             .ok_or_else(|| \"expected `kind` to be a string\")?;\n         match kind {\n             \"none\" => Ok(StackProbeType::None),\n@@ -592,11 +593,11 @@ impl ToJson for StackProbeType {\n             StackProbeType::Call => {\n                 [(String::from(\"kind\"), \"call\".to_json())].into_iter().collect()\n             }\n-            StackProbeType::InlineOrCall { min_llvm_version_for_inline } => [\n+            StackProbeType::InlineOrCall { min_llvm_version_for_inline: (maj, min, patch) } => [\n                 (String::from(\"kind\"), \"inline-or-call\".to_json()),\n                 (\n                     String::from(\"min-llvm-version-for-inline\"),\n-                    min_llvm_version_for_inline.to_json(),\n+                    Json::Array(vec![maj.to_json(), min.to_json(), patch.to_json()]),\n                 ),\n             ]\n             .into_iter()\n@@ -1682,17 +1683,22 @@ impl Target {\n     }\n \n     /// Loads a target descriptor from a JSON object.\n-    pub fn from_json(mut obj: Json) -> Result<(Target, TargetWarnings), String> {\n+    pub fn from_json(obj: Json) -> Result<(Target, TargetWarnings), String> {\n         // While ugly, this code must remain this way to retain\n         // compatibility with existing JSON fields and the internal\n         // expected naming of the Target and TargetOptions structs.\n         // To ensure compatibility is retained, the built-in targets\n         // are round-tripped through this code to catch cases where\n         // the JSON parser is not updated to match the structs.\n \n+        let mut obj = match obj {\n+            Value::Object(obj) => obj,\n+            _ => return Err(\"Expected JSON object for target\")?,\n+        };\n+\n         let mut get_req_field = |name: &str| {\n-            obj.remove_key(name)\n-                .and_then(|j| Json::as_string(&j).map(str::to_string))\n+            obj.remove(name)\n+                .and_then(|j| j.as_str().map(str::to_string))\n                 .ok_or_else(|| format!(\"Field {} in target specification is required\", name))\n         };\n \n@@ -1711,31 +1717,31 @@ impl Target {\n         macro_rules! key {\n             ($key_name:ident) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                if let Some(s) = obj.remove_key(&name).and_then(|j| Json::as_string(&j).map(str::to_string).map(Cow::from)) {\n+                if let Some(s) = obj.remove(&name).and_then(|s| s.as_str().map(str::to_string).map(Cow::from)) {\n                     base.$key_name = s;\n                 }\n             } );\n             ($key_name:ident = $json_name:expr) => ( {\n                 let name = $json_name;\n-                if let Some(s) = obj.remove_key(&name).and_then(|j| Json::as_string(&j).map(str::to_string).map(Cow::from)) {\n+                if let Some(s) = obj.remove(name).and_then(|s| s.as_str().map(str::to_string).map(Cow::from)) {\n                     base.$key_name = s;\n                 }\n             } );\n             ($key_name:ident, bool) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                if let Some(s) = obj.remove_key(&name).and_then(|j| Json::as_boolean(&j)) {\n+                if let Some(s) = obj.remove(&name).and_then(|b| b.as_bool()) {\n                     base.$key_name = s;\n                 }\n             } );\n             ($key_name:ident, u64) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                if let Some(s) = obj.remove_key(&name).and_then(|j| Json::as_u64(&j)) {\n+                if let Some(s) = obj.remove(&name).and_then(|j| Json::as_u64(&j)) {\n                     base.$key_name = s;\n                 }\n             } );\n             ($key_name:ident, Option<u32>) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                if let Some(s) = obj.remove_key(&name).and_then(|j| Json::as_u64(&j)) {\n+                if let Some(s) = obj.remove(&name).and_then(|b| b.as_u64()) {\n                     if s < 1 || s > 5 {\n                         return Err(\"Not a valid DWARF version number\".into());\n                     }\n@@ -1744,13 +1750,13 @@ impl Target {\n             } );\n             ($key_name:ident, Option<u64>) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                if let Some(s) = obj.remove_key(&name).and_then(|j| Json::as_u64(&j)) {\n+                if let Some(s) = obj.remove(&name).and_then(|b| b.as_u64()) {\n                     base.$key_name = Some(s);\n                 }\n             } );\n             ($key_name:ident, MergeFunctions) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                obj.remove_key(&name[..]).and_then(|o| o.as_string().and_then(|s| {\n+                obj.remove(&name).and_then(|o| o.as_str().and_then(|s| {\n                     match s.parse::<MergeFunctions>() {\n                         Ok(mergefunc) => base.$key_name = mergefunc,\n                         _ => return Some(Err(format!(\"'{}' is not a valid value for \\\n@@ -1763,7 +1769,7 @@ impl Target {\n             } );\n             ($key_name:ident, RelocModel) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                obj.remove_key(&name[..]).and_then(|o| o.as_string().and_then(|s| {\n+                obj.remove(&name).and_then(|o| o.as_str().and_then(|s| {\n                     match s.parse::<RelocModel>() {\n                         Ok(relocation_model) => base.$key_name = relocation_model,\n                         _ => return Some(Err(format!(\"'{}' is not a valid relocation model. \\\n@@ -1775,7 +1781,7 @@ impl Target {\n             } );\n             ($key_name:ident, CodeModel) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                obj.remove_key(&name[..]).and_then(|o| o.as_string().and_then(|s| {\n+                obj.remove(&name).and_then(|o| o.as_str().and_then(|s| {\n                     match s.parse::<CodeModel>() {\n                         Ok(code_model) => base.$key_name = Some(code_model),\n                         _ => return Some(Err(format!(\"'{}' is not a valid code model. \\\n@@ -1787,7 +1793,7 @@ impl Target {\n             } );\n             ($key_name:ident, TlsModel) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                obj.remove_key(&name[..]).and_then(|o| o.as_string().and_then(|s| {\n+                obj.remove(&name).and_then(|o| o.as_str().and_then(|s| {\n                     match s.parse::<TlsModel>() {\n                         Ok(tls_model) => base.$key_name = tls_model,\n                         _ => return Some(Err(format!(\"'{}' is not a valid TLS model. \\\n@@ -1799,7 +1805,7 @@ impl Target {\n             } );\n             ($key_name:ident, PanicStrategy) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                obj.remove_key(&name[..]).and_then(|o| o.as_string().and_then(|s| {\n+                obj.remove(&name).and_then(|o| o.as_str().and_then(|s| {\n                     match s {\n                         \"unwind\" => base.$key_name = PanicStrategy::Unwind,\n                         \"abort\" => base.$key_name = PanicStrategy::Abort,\n@@ -1812,7 +1818,7 @@ impl Target {\n             } );\n             ($key_name:ident, RelroLevel) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                obj.remove_key(&name[..]).and_then(|o| o.as_string().and_then(|s| {\n+                obj.remove(&name).and_then(|o| o.as_str().and_then(|s| {\n                     match s.parse::<RelroLevel>() {\n                         Ok(level) => base.$key_name = level,\n                         _ => return Some(Err(format!(\"'{}' is not a valid value for \\\n@@ -1824,7 +1830,7 @@ impl Target {\n             } );\n             ($key_name:ident, SplitDebuginfo) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                obj.remove_key(&name[..]).and_then(|o| o.as_string().and_then(|s| {\n+                obj.remove(&name).and_then(|o| o.as_str().and_then(|s| {\n                     match s.parse::<SplitDebuginfo>() {\n                         Ok(level) => base.$key_name = level,\n                         _ => return Some(Err(format!(\"'{}' is not a valid value for \\\n@@ -1836,10 +1842,10 @@ impl Target {\n             } );\n             ($key_name:ident, list) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                if let Some(j) = obj.remove_key(&name){\n-                    if let Some(v) = Json::as_array(&j) {\n+                if let Some(j) = obj.remove(&name) {\n+                    if let Some(v) = j.as_array() {\n                         base.$key_name = v.iter()\n-                            .map(|a| a.as_string().unwrap().to_string().into())\n+                            .map(|a| a.as_str().unwrap().to_string().into())\n                             .collect();\n                     } else {\n                         incorrect_type.push(name)\n@@ -1848,10 +1854,10 @@ impl Target {\n             } );\n             ($key_name:ident, opt_list) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                if let Some(j) = obj.remove_key(&name) {\n-                    if let Some(v) = Json::as_array(&j) {\n+                if let Some(j) = obj.remove(&name) {\n+                    if let Some(v) = j.as_array() {\n                         base.$key_name = Some(v.iter()\n-                            .map(|a| a.as_string().unwrap().to_string().into())\n+                            .map(|a| a.as_str().unwrap().to_string().into())\n                             .collect());\n                     } else {\n                         incorrect_type.push(name)\n@@ -1860,15 +1866,15 @@ impl Target {\n             } );\n             ($key_name:ident, optional) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                if let Some(o) = obj.remove_key(&name[..]) {\n+                if let Some(o) = obj.remove(&name) {\n                     base.$key_name = o\n-                        .as_string()\n+                        .as_str()\n                         .map(|s| s.to_string().into());\n                 }\n             } );\n             ($key_name:ident, LldFlavor) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                obj.remove_key(&name[..]).and_then(|o| o.as_string().and_then(|s| {\n+                obj.remove(&name).and_then(|o| o.as_str().and_then(|s| {\n                     if let Some(flavor) = LldFlavor::from_str(&s) {\n                         base.$key_name = flavor;\n                     } else {\n@@ -1882,7 +1888,7 @@ impl Target {\n             } );\n             ($key_name:ident, LinkerFlavor) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                obj.remove_key(&name[..]).and_then(|o| o.as_string().and_then(|s| {\n+                obj.remove(&name).and_then(|o| o.as_str().and_then(|s| {\n                     match LinkerFlavor::from_str(s) {\n                         Some(linker_flavor) => base.$key_name = linker_flavor,\n                         _ => return Some(Err(format!(\"'{}' is not a valid value for linker-flavor. \\\n@@ -1893,7 +1899,7 @@ impl Target {\n             } );\n             ($key_name:ident, StackProbeType) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                obj.remove_key(&name[..]).and_then(|o| match StackProbeType::from_json(&o) {\n+                obj.remove(&name).and_then(|o| match StackProbeType::from_json(&o) {\n                     Ok(v) => {\n                         base.$key_name = v;\n                         Some(Ok(()))\n@@ -1905,10 +1911,10 @@ impl Target {\n             } );\n             ($key_name:ident, SanitizerSet) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                if let Some(o) = obj.remove_key(&name[..]) {\n+                if let Some(o) = obj.remove(&name) {\n                     if let Some(a) = o.as_array() {\n                         for s in a {\n-                            base.$key_name |= match s.as_string() {\n+                            base.$key_name |= match s.as_str() {\n                                 Some(\"address\") => SanitizerSet::ADDRESS,\n                                 Some(\"cfi\") => SanitizerSet::CFI,\n                                 Some(\"leak\") => SanitizerSet::LEAK,\n@@ -1929,7 +1935,7 @@ impl Target {\n \n             ($key_name:ident, crt_objects_fallback) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                obj.remove_key(&name[..]).and_then(|o| o.as_string().and_then(|s| {\n+                obj.remove(&name).and_then(|o| o.as_str().and_then(|s| {\n                     match s.parse::<CrtObjectsFallback>() {\n                         Ok(fallback) => base.$key_name = Some(fallback),\n                         _ => return Some(Err(format!(\"'{}' is not a valid CRT objects fallback. \\\n@@ -1940,7 +1946,7 @@ impl Target {\n             } );\n             ($key_name:ident, link_objects) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                if let Some(val) = obj.remove_key(&name[..]) {\n+                if let Some(val) = obj.remove(&name) {\n                     let obj = val.as_object().ok_or_else(|| format!(\"{}: expected a \\\n                         JSON object with fields per CRT object kind.\", name))?;\n                     let mut args = CrtObjects::new();\n@@ -1955,7 +1961,7 @@ impl Target {\n                             format!(\"{}.{}: expected a JSON array\", name, k)\n                         )?.iter().enumerate()\n                             .map(|(i,s)| {\n-                                let s = s.as_string().ok_or_else(||\n+                                let s = s.as_str().ok_or_else(||\n                                     format!(\"{}.{}[{}]: expected a JSON string\", name, k, i))?;\n                                 Ok(s.to_string().into())\n                             })\n@@ -1968,7 +1974,7 @@ impl Target {\n             } );\n             ($key_name:ident, link_args) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                if let Some(val) = obj.remove_key(&name[..]) {\n+                if let Some(val) = obj.remove(&name) {\n                     let obj = val.as_object().ok_or_else(|| format!(\"{}: expected a \\\n                         JSON object with fields per linker-flavor.\", name))?;\n                     let mut args = LinkArgs::new();\n@@ -1982,7 +1988,7 @@ impl Target {\n                             format!(\"{}.{}: expected a JSON array\", name, k)\n                         )?.iter().enumerate()\n                             .map(|(i,s)| {\n-                                let s = s.as_string().ok_or_else(||\n+                                let s = s.as_str().ok_or_else(||\n                                     format!(\"{}.{}[{}]: expected a JSON string\", name, k, i))?;\n                                 Ok(s.to_string().into())\n                             })\n@@ -1995,10 +2001,10 @@ impl Target {\n             } );\n             ($key_name:ident, env) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                if let Some(o) = obj.remove_key(&name[..]) {\n+                if let Some(o) = obj.remove(&name) {\n                     if let Some(a) = o.as_array() {\n                         for o in a {\n-                            if let Some(s) = o.as_string() {\n+                            if let Some(s) = o.as_str() {\n                                 let p = s.split('=').collect::<Vec<_>>();\n                                 if p.len() == 2 {\n                                     let k = p[0].to_string();\n@@ -2014,7 +2020,7 @@ impl Target {\n             } );\n             ($key_name:ident, Option<Abi>) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                obj.remove_key(&name[..]).and_then(|o| o.as_string().and_then(|s| {\n+                obj.remove(&name).and_then(|o| o.as_str().and_then(|s| {\n                     match lookup_abi(s) {\n                         Some(abi) => base.$key_name = Some(abi),\n                         _ => return Some(Err(format!(\"'{}' is not a valid value for abi\", s))),\n@@ -2023,28 +2029,28 @@ impl Target {\n                 })).unwrap_or(Ok(()))\n             } );\n             ($key_name:ident, TargetFamilies) => ( {\n-                if let Some(value) = obj.remove_key(\"target-family\") {\n-                    if let Some(v) = Json::as_array(&value) {\n+                if let Some(value) = obj.remove(\"target-family\") {\n+                    if let Some(v) = value.as_array() {\n                         base.$key_name = v.iter()\n-                            .map(|a| a.as_string().unwrap().to_string().into())\n+                            .map(|a| a.as_str().unwrap().to_string().into())\n                             .collect();\n-                    } else if let Some(v) = Json::as_string(&value) {\n+                    } else if let Some(v) = value.as_str() {\n                         base.$key_name = vec![v.to_string().into()].into();\n                     }\n                 }\n             } );\n         }\n \n-        if let Some(j) = obj.remove_key(\"target-endian\") {\n-            if let Some(s) = Json::as_string(&j) {\n+        if let Some(j) = obj.remove(\"target-endian\") {\n+            if let Some(s) = j.as_str() {\n                 base.endian = s.parse()?;\n             } else {\n                 incorrect_type.push(\"target-endian\".into())\n             }\n         }\n \n-        if let Some(fp) = obj.remove_key(\"frame-pointer\") {\n-            if let Some(s) = Json::as_string(&fp) {\n+        if let Some(fp) = obj.remove(\"frame-pointer\") {\n+            if let Some(s) = fp.as_str() {\n                 base.frame_pointer = s\n                     .parse()\n                     .map_err(|()| format!(\"'{}' is not a valid value for frame-pointer\", s))?;\n@@ -2156,8 +2162,8 @@ impl Target {\n             // This can cause unfortunate ICEs later down the line.\n             return Err(\"may not set is_builtin for targets not built-in\".into());\n         }\n-        // Each field should have been read using `Json::remove_key` so any keys remaining are unused.\n-        let remaining_keys = obj.as_object().ok_or(\"Expected JSON object for target\")?.keys();\n+        // Each field should have been read using `Json::remove` so any keys remaining are unused.\n+        let remaining_keys = obj.keys();\n         Ok((\n             base,\n             TargetWarnings { unused_fields: remaining_keys.cloned().collect(), incorrect_type },\n@@ -2189,13 +2195,12 @@ impl Target {\n         target_triple: &TargetTriple,\n         sysroot: &Path,\n     ) -> Result<(Target, TargetWarnings), String> {\n-        use rustc_serialize::json;\n         use std::env;\n         use std::fs;\n \n         fn load_file(path: &Path) -> Result<(Target, TargetWarnings), String> {\n             let contents = fs::read_to_string(path).map_err(|e| e.to_string())?;\n-            let obj = json::from_str(&contents).map_err(|e| e.to_string())?;\n+            let obj = serde_json::from_str(&contents).map_err(|e| e.to_string())?;\n             Target::from_json(obj)\n         }\n \n@@ -2248,7 +2253,7 @@ impl Target {\n \n impl ToJson for Target {\n     fn to_json(&self) -> Json {\n-        let mut d = BTreeMap::new();\n+        let mut d = serde_json::Map::new();\n         let default: TargetOptions = Default::default();\n \n         macro_rules! target_val {"}, {"sha": "76375170db63da637c0a41b8533aedc82d8b3703", "filename": "compiler/rustc_target/src/tests.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_target%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_target%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Ftests.rs?ref=7e9b92cb43a489b34e2bcb8d21f36198e02eedbc", "patch": "@@ -1,10 +1,8 @@\n use crate::spec::Target;\n-use rustc_serialize::json::Json;\n-use std::str::FromStr;\n \n #[test]\n fn report_unused_fields() {\n-    let json = Json::from_str(\n+    let json = serde_json::from_str(\n         r#\"\n     {\n         \"arch\": \"powerpc64\",\n@@ -23,7 +21,7 @@ fn report_unused_fields() {\n \n #[test]\n fn report_incorrect_json_type() {\n-    let json = Json::from_str(\n+    let json = serde_json::from_str(\n         r#\"\n     {\n         \"arch\": \"powerpc64\",\n@@ -42,7 +40,7 @@ fn report_incorrect_json_type() {\n \n #[test]\n fn no_warnings_for_valid_target() {\n-    let json = Json::from_str(\n+    let json = serde_json::from_str(\n         r#\"\n     {\n         \"arch\": \"powerpc64\","}, {"sha": "22b5b475b2cacf9ee53e2906dceaef6f886edd9e", "filename": "compiler/rustc_type_ir/src/sty.rs", "status": "modified", "additions": 110, "deletions": 112, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs?ref=7e9b92cb43a489b34e2bcb8d21f36198e02eedbc", "patch": "@@ -716,118 +716,116 @@ where\n     I::AllocId: Encodable<E>,\n {\n     fn encode(&self, e: &mut E) -> Result<(), <E as rustc_serialize::Encoder>::Error> {\n-        rustc_serialize::Encoder::emit_enum(e, |e| {\n-            let disc = discriminant(self);\n-            match self {\n-                Bool => e.emit_enum_variant(\"Bool\", disc, 0, |_| Ok(())),\n-                Char => e.emit_enum_variant(\"Char\", disc, 0, |_| Ok(())),\n-                Int(i) => e.emit_enum_variant(\"Int\", disc, 1, |e| {\n-                    e.emit_enum_variant_arg(true, |e| i.encode(e))?;\n-                    Ok(())\n-                }),\n-                Uint(u) => e.emit_enum_variant(\"Uint\", disc, 1, |e| {\n-                    e.emit_enum_variant_arg(true, |e| u.encode(e))?;\n-                    Ok(())\n-                }),\n-                Float(f) => e.emit_enum_variant(\"Float\", disc, 1, |e| {\n-                    e.emit_enum_variant_arg(true, |e| f.encode(e))?;\n-                    Ok(())\n-                }),\n-                Adt(adt, substs) => e.emit_enum_variant(\"Adt\", disc, 2, |e| {\n-                    e.emit_enum_variant_arg(true, |e| adt.encode(e))?;\n-                    e.emit_enum_variant_arg(false, |e| substs.encode(e))?;\n-                    Ok(())\n-                }),\n-                Foreign(def_id) => e.emit_enum_variant(\"Foreign\", disc, 1, |e| {\n-                    e.emit_enum_variant_arg(true, |e| def_id.encode(e))?;\n-                    Ok(())\n-                }),\n-                Str => e.emit_enum_variant(\"Str\", disc, 0, |_| Ok(())),\n-                Array(t, c) => e.emit_enum_variant(\"Array\", disc, 2, |e| {\n-                    e.emit_enum_variant_arg(true, |e| t.encode(e))?;\n-                    e.emit_enum_variant_arg(false, |e| c.encode(e))?;\n-                    Ok(())\n-                }),\n-                Slice(t) => e.emit_enum_variant(\"Slice\", disc, 1, |e| {\n-                    e.emit_enum_variant_arg(true, |e| t.encode(e))?;\n-                    Ok(())\n-                }),\n-                RawPtr(tam) => e.emit_enum_variant(\"RawPtr\", disc, 1, |e| {\n-                    e.emit_enum_variant_arg(true, |e| tam.encode(e))?;\n-                    Ok(())\n-                }),\n-                Ref(r, t, m) => e.emit_enum_variant(\"Ref\", disc, 3, |e| {\n-                    e.emit_enum_variant_arg(true, |e| r.encode(e))?;\n-                    e.emit_enum_variant_arg(false, |e| t.encode(e))?;\n-                    e.emit_enum_variant_arg(false, |e| m.encode(e))?;\n-                    Ok(())\n-                }),\n-                FnDef(def_id, substs) => e.emit_enum_variant(\"FnDef\", disc, 2, |e| {\n-                    e.emit_enum_variant_arg(true, |e| def_id.encode(e))?;\n-                    e.emit_enum_variant_arg(false, |e| substs.encode(e))?;\n-                    Ok(())\n-                }),\n-                FnPtr(polyfnsig) => e.emit_enum_variant(\"FnPtr\", disc, 1, |e| {\n-                    e.emit_enum_variant_arg(true, |e| polyfnsig.encode(e))?;\n-                    Ok(())\n-                }),\n-                Dynamic(l, r) => e.emit_enum_variant(\"Dynamic\", disc, 2, |e| {\n-                    e.emit_enum_variant_arg(true, |e| l.encode(e))?;\n-                    e.emit_enum_variant_arg(false, |e| r.encode(e))?;\n-                    Ok(())\n-                }),\n-                Closure(def_id, substs) => e.emit_enum_variant(\"Closure\", disc, 2, |e| {\n-                    e.emit_enum_variant_arg(true, |e| def_id.encode(e))?;\n-                    e.emit_enum_variant_arg(false, |e| substs.encode(e))?;\n-                    Ok(())\n-                }),\n-                Generator(def_id, substs, m) => e.emit_enum_variant(\"Generator\", disc, 3, |e| {\n-                    e.emit_enum_variant_arg(true, |e| def_id.encode(e))?;\n-                    e.emit_enum_variant_arg(false, |e| substs.encode(e))?;\n-                    e.emit_enum_variant_arg(false, |e| m.encode(e))?;\n-                    Ok(())\n-                }),\n-                GeneratorWitness(b) => e.emit_enum_variant(\"GeneratorWitness\", disc, 1, |e| {\n-                    e.emit_enum_variant_arg(true, |e| b.encode(e))?;\n-                    Ok(())\n-                }),\n-                Never => e.emit_enum_variant(\"Never\", disc, 0, |_| Ok(())),\n-                Tuple(substs) => e.emit_enum_variant(\"Tuple\", disc, 1, |e| {\n-                    e.emit_enum_variant_arg(true, |e| substs.encode(e))?;\n-                    Ok(())\n-                }),\n-                Projection(p) => e.emit_enum_variant(\"Projection\", disc, 1, |e| {\n-                    e.emit_enum_variant_arg(true, |e| p.encode(e))?;\n-                    Ok(())\n-                }),\n-                Opaque(def_id, substs) => e.emit_enum_variant(\"Opaque\", disc, 2, |e| {\n-                    e.emit_enum_variant_arg(true, |e| def_id.encode(e))?;\n-                    e.emit_enum_variant_arg(false, |e| substs.encode(e))?;\n-                    Ok(())\n-                }),\n-                Param(p) => e.emit_enum_variant(\"Param\", disc, 1, |e| {\n-                    e.emit_enum_variant_arg(true, |e| p.encode(e))?;\n-                    Ok(())\n-                }),\n-                Bound(d, b) => e.emit_enum_variant(\"Bound\", disc, 2, |e| {\n-                    e.emit_enum_variant_arg(true, |e| d.encode(e))?;\n-                    e.emit_enum_variant_arg(false, |e| b.encode(e))?;\n-                    Ok(())\n-                }),\n-                Placeholder(p) => e.emit_enum_variant(\"Placeholder\", disc, 1, |e| {\n-                    e.emit_enum_variant_arg(true, |e| p.encode(e))?;\n-                    Ok(())\n-                }),\n-                Infer(i) => e.emit_enum_variant(\"Infer\", disc, 1, |e| {\n-                    e.emit_enum_variant_arg(true, |e| i.encode(e))?;\n-                    Ok(())\n-                }),\n-                Error(d) => e.emit_enum_variant(\"Error\", disc, 1, |e| {\n-                    e.emit_enum_variant_arg(true, |e| d.encode(e))?;\n-                    Ok(())\n-                }),\n-            }\n-        })\n+        let disc = discriminant(self);\n+        match self {\n+            Bool => e.emit_enum_variant(disc, |_| Ok(())),\n+            Char => e.emit_enum_variant(disc, |_| Ok(())),\n+            Int(i) => e.emit_enum_variant(disc, |e| {\n+                i.encode(e)?;\n+                Ok(())\n+            }),\n+            Uint(u) => e.emit_enum_variant(disc, |e| {\n+                u.encode(e)?;\n+                Ok(())\n+            }),\n+            Float(f) => e.emit_enum_variant(disc, |e| {\n+                f.encode(e)?;\n+                Ok(())\n+            }),\n+            Adt(adt, substs) => e.emit_enum_variant(disc, |e| {\n+                adt.encode(e)?;\n+                substs.encode(e)?;\n+                Ok(())\n+            }),\n+            Foreign(def_id) => e.emit_enum_variant(disc, |e| {\n+                def_id.encode(e)?;\n+                Ok(())\n+            }),\n+            Str => e.emit_enum_variant(disc, |_| Ok(())),\n+            Array(t, c) => e.emit_enum_variant(disc, |e| {\n+                t.encode(e)?;\n+                c.encode(e)?;\n+                Ok(())\n+            }),\n+            Slice(t) => e.emit_enum_variant(disc, |e| {\n+                t.encode(e)?;\n+                Ok(())\n+            }),\n+            RawPtr(tam) => e.emit_enum_variant(disc, |e| {\n+                tam.encode(e)?;\n+                Ok(())\n+            }),\n+            Ref(r, t, m) => e.emit_enum_variant(disc, |e| {\n+                r.encode(e)?;\n+                t.encode(e)?;\n+                m.encode(e)?;\n+                Ok(())\n+            }),\n+            FnDef(def_id, substs) => e.emit_enum_variant(disc, |e| {\n+                def_id.encode(e)?;\n+                substs.encode(e)?;\n+                Ok(())\n+            }),\n+            FnPtr(polyfnsig) => e.emit_enum_variant(disc, |e| {\n+                polyfnsig.encode(e)?;\n+                Ok(())\n+            }),\n+            Dynamic(l, r) => e.emit_enum_variant(disc, |e| {\n+                l.encode(e)?;\n+                r.encode(e)?;\n+                Ok(())\n+            }),\n+            Closure(def_id, substs) => e.emit_enum_variant(disc, |e| {\n+                def_id.encode(e)?;\n+                substs.encode(e)?;\n+                Ok(())\n+            }),\n+            Generator(def_id, substs, m) => e.emit_enum_variant(disc, |e| {\n+                def_id.encode(e)?;\n+                substs.encode(e)?;\n+                m.encode(e)?;\n+                Ok(())\n+            }),\n+            GeneratorWitness(b) => e.emit_enum_variant(disc, |e| {\n+                b.encode(e)?;\n+                Ok(())\n+            }),\n+            Never => e.emit_enum_variant(disc, |_| Ok(())),\n+            Tuple(substs) => e.emit_enum_variant(disc, |e| {\n+                substs.encode(e)?;\n+                Ok(())\n+            }),\n+            Projection(p) => e.emit_enum_variant(disc, |e| {\n+                p.encode(e)?;\n+                Ok(())\n+            }),\n+            Opaque(def_id, substs) => e.emit_enum_variant(disc, |e| {\n+                def_id.encode(e)?;\n+                substs.encode(e)?;\n+                Ok(())\n+            }),\n+            Param(p) => e.emit_enum_variant(disc, |e| {\n+                p.encode(e)?;\n+                Ok(())\n+            }),\n+            Bound(d, b) => e.emit_enum_variant(disc, |e| {\n+                d.encode(e)?;\n+                b.encode(e)?;\n+                Ok(())\n+            }),\n+            Placeholder(p) => e.emit_enum_variant(disc, |e| {\n+                p.encode(e)?;\n+                Ok(())\n+            }),\n+            Infer(i) => e.emit_enum_variant(disc, |e| {\n+                i.encode(e)?;\n+                Ok(())\n+            }),\n+            Error(d) => e.emit_enum_variant(disc, |e| {\n+                d.encode(e)?;\n+                Ok(())\n+            }),\n+        }\n     }\n }\n "}, {"sha": "230194c53779342a6dc11b7954ef839d4e1192b7", "filename": "src/test/ui-fulldeps/extern-mod-syntax.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/src%2Ftest%2Fui-fulldeps%2Fextern-mod-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/src%2Ftest%2Fui-fulldeps%2Fextern-mod-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fextern-mod-syntax.rs?ref=7e9b92cb43a489b34e2bcb8d21f36198e02eedbc", "patch": "@@ -3,8 +3,8 @@\n #![allow(unused_imports)]\n #![feature(rustc_private)]\n \n-extern crate rustc_serialize;\n-use rustc_serialize::json::Object;\n+extern crate libc;\n+use libc::c_void;\n \n pub fn main() {\n     println!(\"Hello world!\");"}, {"sha": "9641470a68ba209700a2e26dccded8e03cbf172e", "filename": "src/test/ui-fulldeps/issue-11881.rs", "status": "modified", "additions": 52, "deletions": 14, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/src%2Ftest%2Fui-fulldeps%2Fissue-11881.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/src%2Ftest%2Fui-fulldeps%2Fissue-11881.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fissue-11881.rs?ref=7e9b92cb43a489b34e2bcb8d21f36198e02eedbc", "patch": "@@ -3,42 +3,80 @@\n #![allow(unused_must_use)]\n #![allow(dead_code)]\n #![allow(unused_imports)]\n-#![feature(rustc_private)]\n-\n-extern crate rustc_macros;\n-extern crate rustc_serialize;\n \n use std::fmt;\n use std::io::prelude::*;\n use std::io::Cursor;\n use std::slice;\n+use std::marker::PhantomData;\n+\n+trait Encoder {\n+    type Error;\n+}\n+\n+trait Encodable<S: Encoder> {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error>;\n+}\n+\n+struct JsonEncoder<'a>(PhantomData<&'a mut ()>);\n+\n+impl Encoder for JsonEncoder<'_> {\n+    type Error = ();\n+}\n+\n+struct AsJson<'a, T> {\n+    inner: &'a T,\n+}\n+\n+impl<'a, T: for<'r> Encodable<JsonEncoder<'r>>> fmt::Display for AsJson<'a, T> {\n+    /// Encodes a json value into a string\n+    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        Ok(())\n+    }\n+}\n+\n+fn as_json<T>(t: &T) -> AsJson<'_, T> {\n+    AsJson { inner: t }\n+}\n+\n+struct OpaqueEncoder(Vec<u8>);\n+\n+impl Encoder for OpaqueEncoder {\n+    type Error = ();\n+}\n \n-use rustc_macros::Encodable;\n-use rustc_serialize::json;\n-use rustc_serialize::opaque;\n-use rustc_serialize::{Encodable, Encoder};\n \n-#[derive(Encodable)]\n struct Foo {\n     baz: bool,\n }\n \n-#[derive(Encodable)]\n+impl<S: Encoder> Encodable<S> for Foo {\n+    fn encode(&self, _s: &mut S) -> Result<(), S::Error> {\n+        Ok(())\n+    }\n+}\n+\n struct Bar {\n     froboz: usize,\n }\n \n+impl<S: Encoder> Encodable<S> for Bar {\n+    fn encode(&self, _s: &mut S) -> Result<(), S::Error> {\n+        Ok(())\n+    }\n+}\n+\n enum WireProtocol {\n     JSON,\n     Opaque,\n     // ...\n }\n \n-fn encode_json<T: for<'a> Encodable<json::Encoder<'a>>>(val: &T, wr: &mut Cursor<Vec<u8>>) {\n-    write!(wr, \"{}\", json::as_json(val));\n+fn encode_json<T: for<'a> Encodable<JsonEncoder<'a>>>(val: &T, wr: &mut Cursor<Vec<u8>>) {\n+    write!(wr, \"{}\", as_json(val));\n }\n-fn encode_opaque<T: Encodable<opaque::Encoder>>(val: &T, wr: Vec<u8>) {\n-    let mut encoder = opaque::Encoder::new(wr);\n+fn encode_opaque<T: Encodable<OpaqueEncoder>>(val: &T, wr: Vec<u8>) {\n+    let mut encoder = OpaqueEncoder(wr);\n     val.encode(&mut encoder);\n }\n "}, {"sha": "d8b3914d0d4f777e9e1855dab37d6dfa21855ad0", "filename": "src/test/ui-fulldeps/issue-15924.rs", "status": "modified", "additions": 35, "deletions": 8, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/src%2Ftest%2Fui-fulldeps%2Fissue-15924.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/src%2Ftest%2Fui-fulldeps%2Fissue-15924.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fissue-15924.rs?ref=7e9b92cb43a489b34e2bcb8d21f36198e02eedbc", "patch": "@@ -3,21 +3,48 @@\n #![allow(unused_imports)]\n #![allow(unused_must_use)]\n // pretty-expanded FIXME #23616\n-#![feature(rustc_private)]\n \n-extern crate rustc_serialize;\n-\n-use rustc_serialize::json;\n-use rustc_serialize::{Encodable, Encoder};\n use std::fmt;\n+use std::marker::PhantomData;\n+\n+trait Encoder {\n+    type Error;\n+}\n+\n+trait Encodable<S: Encoder> {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error>;\n+}\n+\n+impl<S: Encoder> Encodable<S> for i32 {\n+    fn encode(&self, _s: &mut S) -> Result<(), S::Error> {\n+        Ok(())\n+    }\n+}\n+\n+struct JsonEncoder<'a>(PhantomData<&'a mut ()>);\n+\n+impl Encoder for JsonEncoder<'_> {\n+    type Error = ();\n+}\n+\n+fn encode_json<T: for<'r> Encodable<JsonEncoder<'r>>>(\n+    object: &T,\n+) -> Result<String, ()> {\n+    let s = String::new();\n+    {\n+        let mut encoder = JsonEncoder(PhantomData);\n+        object.encode(&mut encoder)?;\n+    }\n+    Ok(s)\n+}\n \n-struct Foo<T: for<'a> Encodable<json::Encoder<'a>>> {\n+struct Foo<T: for<'a> Encodable<JsonEncoder<'a>>> {\n     v: T,\n }\n \n-impl<T: for<'a> Encodable<json::Encoder<'a>>> Drop for Foo<T> {\n+impl<T: for<'a> Encodable<JsonEncoder<'a>>> Drop for Foo<T> {\n     fn drop(&mut self) {\n-        json::encode(&self.v);\n+        encode_json(&self.v);\n     }\n }\n "}, {"sha": "571028c5e400571391530091cf97a4cf87de91ee", "filename": "src/test/ui-fulldeps/issue-2804.rs", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/src%2Ftest%2Fui-fulldeps%2Fissue-2804.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/src%2Ftest%2Fui-fulldeps%2Fissue-2804.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fissue-2804.rs?ref=7e9b92cb43a489b34e2bcb8d21f36198e02eedbc", "patch": "@@ -2,27 +2,38 @@\n \n #![allow(non_camel_case_types)]\n #![allow(dead_code)]\n-#![feature(rustc_private)]\n \n-extern crate rustc_serialize;\n-\n-use std::collections::HashMap;\n-use rustc_serialize::json::{self, Json};\n+use std::collections::{BTreeMap, HashMap};\n use std::option;\n \n+#[derive(Clone, Debug)]\n+enum Json {\n+    I64(i64),\n+    U64(u64),\n+    F64(f64),\n+    String(String),\n+    Boolean(bool),\n+    Array(Array),\n+    Object(Object),\n+    Null,\n+}\n+\n+type Array = Vec<Json>;\n+type Object = BTreeMap<String, Json>;\n+\n enum object {\n     bool_value(bool),\n     int_value(i64),\n }\n \n-fn lookup(table: json::Object, key: String, default: String) -> String\n+fn lookup(table: Object, key: String, default: String) -> String\n {\n     match table.get(&key) {\n         option::Option::Some(&Json::String(ref s)) => {\n             s.to_string()\n         }\n         option::Option::Some(value) => {\n-            println!(\"{} was expected to be a string but is a {}\", key, value);\n+            println!(\"{} was expected to be a string but is a {:?}\", key, value);\n             default\n         }\n         option::Option::None => {\n@@ -31,7 +42,7 @@ fn lookup(table: json::Object, key: String, default: String) -> String\n     }\n }\n \n-fn add_interface(_store: isize, managed_ip: String, data: json::Json) -> (String, object)\n+fn add_interface(_store: isize, managed_ip: String, data: Json) -> (String, object)\n {\n     match &data {\n         &Json::Object(ref interface) => {\n@@ -43,13 +54,13 @@ fn add_interface(_store: isize, managed_ip: String, data: json::Json) -> (String\n             (label, object::bool_value(false))\n         }\n         _ => {\n-            println!(\"Expected dict for {} interfaces, found {}\", managed_ip, data);\n+            println!(\"Expected dict for {} interfaces, found {:?}\", managed_ip, data);\n             (\"gnos:missing-interface\".to_string(), object::bool_value(true))\n         }\n     }\n }\n \n-fn add_interfaces(store: isize, managed_ip: String, device: HashMap<String, json::Json>)\n+fn add_interfaces(store: isize, managed_ip: String, device: HashMap<String, Json>)\n -> Vec<(String, object)> {\n     match device[\"interfaces\"] {\n         Json::Array(ref interfaces) =>\n@@ -60,7 +71,7 @@ fn add_interfaces(store: isize, managed_ip: String, device: HashMap<String, json\n         }\n         _ =>\n         {\n-            println!(\"Expected list for {} interfaces, found {}\", managed_ip,\n+            println!(\"Expected list for {} interfaces, found {:?}\", managed_ip,\n                      device[\"interfaces\"]);\n             Vec::new()\n         }"}, {"sha": "ce93e4b5d4b2dc9526f36e0d9d2875d6c54d5087", "filename": "src/test/ui/ast-json/ast-json-ice.rs", "status": "removed", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftest%2Fui%2Fast-json%2Fast-json-ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftest%2Fui%2Fast-json%2Fast-json-ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fast-json%2Fast-json-ice.rs?ref=9a74608543d499bcc7dd505e195e8bfab9447315", "patch": "@@ -1,56 +0,0 @@\n-// Test that AST json serialization doesn't ICE (#63728).\n-\n-// revisions: expand noexpand\n-\n-//[expand] compile-flags: -Zast-json\n-//[noexpand] compile-flags: -Zast-json-noexpand\n-\n-// check-pass\n-// dont-check-compiler-stdout - don't check for any AST change.\n-\n-enum V {\n-    A(i32),\n-    B { f: [i64; 3 + 4] }\n-}\n-\n-trait X {\n-    type Output;\n-    fn read(&self) -> Self::Output;\n-    fn write(&mut self, _: Self::Output);\n-}\n-\n-macro_rules! call_println {\n-    ($y:ident) => { println!(\"{}\", $y) }\n-}\n-\n-fn main() {\n-    let x: (i32) = 35;\n-    let y = x as i64<> + 5;\n-\n-    call_println!(y);\n-\n-    struct A;\n-}\n-\n-// Regressions tests for issues #78398 and #78510 (captured tokens in associated and foreign items)\n-\n-struct S;\n-\n-macro_rules! mac_extern {\n-    ($i:item) => {\n-        extern \"C\" { $i }\n-    }\n-}\n-macro_rules! mac_assoc {\n-    ($i:item) => {\n-        impl S { $i }\n-        trait Bar { $i }\n-    }\n-}\n-\n-mac_extern! {\n-    fn foo();\n-}\n-mac_assoc! {\n-    fn foo() {}\n-}"}, {"sha": "cba539f0065393ccc2ee66d3ae637e56b585cc2a", "filename": "src/test/ui/ast-json/ast-json-noexpand-output.rs", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftest%2Fui%2Fast-json%2Fast-json-noexpand-output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftest%2Fui%2Fast-json%2Fast-json-noexpand-output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fast-json%2Fast-json-noexpand-output.rs?ref=9a74608543d499bcc7dd505e195e8bfab9447315", "patch": "@@ -1,10 +0,0 @@\n-// Check that AST json printing works.\n-#![crate_type = \"lib\"]\n-\n-// check-pass\n-// compile-flags: -Zast-json-noexpand\n-// normalize-stdout-test \":\\d+\" -> \":0\"\n-\n-// Only include a single item to reduce how often the test output needs\n-// updating.\n-extern crate core;"}, {"sha": "6f6e9b38e94245869caa66026c3552fb2ae9a2b2", "filename": "src/test/ui/ast-json/ast-json-noexpand-output.stdout", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftest%2Fui%2Fast-json%2Fast-json-noexpand-output.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftest%2Fui%2Fast-json%2Fast-json-noexpand-output.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fast-json%2Fast-json-noexpand-output.stdout?ref=9a74608543d499bcc7dd505e195e8bfab9447315", "patch": "@@ -1 +0,0 @@\n-{\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"crate_type\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}],\"tokens\":null},\"args\":{\"variant\":\"Eq\",\"fields\":[{\"lo\":0,\"hi\":0},{\"variant\":\"Ast\",\"fields\":[{\"id\":0,\"kind\":{\"variant\":\"Lit\",\"fields\":[{\"token\":{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null},\"kind\":{\"variant\":\"Str\",\"fields\":[\"lib\",\"Cooked\"]},\"span\":{\"lo\":0,\"hi\":0}}]},\"span\":{\"lo\":0,\"hi\":0},\"attrs\":{\"0\":null},\"tokens\":{\"0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Literal\",\"fields\":[{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null}]},\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"]]}}]}]},\"tokens\":null},{\"0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Pound\",\"span\":{\"lo\":0,\"hi\":0}}]},\"Joint\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Not\",\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"],[{\"variant\":\"Delimited\",\"fields\":[{\"open\":{\"lo\":0,\"hi\":0},\"close\":{\"lo\":0,\"hi\":0}},\"Bracket\",{\"0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Ident\",\"fields\":[\"crate_type\",false]},\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Eq\",\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Literal\",\"fields\":[{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null}]},\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"]]}]},\"Alone\"]]}]},\"id\":null,\"style\":\"Inner\",\"span\":{\"lo\":0,\"hi\":0}}],\"items\":[{\"attrs\":[],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"kind\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0},\"tokens\":null},\"ident\":{\"name\":\"core\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"ExternCrate\",\"fields\":[null]},\"tokens\":null}],\"spans\":{\"inner_span\":{\"lo\":0,\"hi\":0},\"inject_use_span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"is_placeholder\":false}"}, {"sha": "2e009149ed68d3c38edbe621a0a81f3a3c5ce3c3", "filename": "src/test/ui/ast-json/ast-json-output.rs", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftest%2Fui%2Fast-json%2Fast-json-output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftest%2Fui%2Fast-json%2Fast-json-output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fast-json%2Fast-json-output.rs?ref=9a74608543d499bcc7dd505e195e8bfab9447315", "patch": "@@ -1,10 +0,0 @@\n-// Check that AST json printing works.\n-#![crate_type = \"lib\"]\n-\n-// check-pass\n-// compile-flags: -Zast-json\n-// normalize-stdout-test \":\\d+\" -> \":0\"\n-\n-// Only include a single item to reduce how often the test output needs\n-// updating.\n-extern crate core;"}, {"sha": "5637ce596b3144f9126130135f57ef1e9ba82f8c", "filename": "src/test/ui/ast-json/ast-json-output.stdout", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftest%2Fui%2Fast-json%2Fast-json-output.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftest%2Fui%2Fast-json%2Fast-json-output.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fast-json%2Fast-json-output.stdout?ref=9a74608543d499bcc7dd505e195e8bfab9447315", "patch": "@@ -1 +0,0 @@\n-{\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"crate_type\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}],\"tokens\":null},\"args\":{\"variant\":\"Eq\",\"fields\":[{\"lo\":0,\"hi\":0},{\"variant\":\"Ast\",\"fields\":[{\"id\":0,\"kind\":{\"variant\":\"Lit\",\"fields\":[{\"token\":{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null},\"kind\":{\"variant\":\"Str\",\"fields\":[\"lib\",\"Cooked\"]},\"span\":{\"lo\":0,\"hi\":0}}]},\"span\":{\"lo\":0,\"hi\":0},\"attrs\":{\"0\":null},\"tokens\":{\"0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Literal\",\"fields\":[{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null}]},\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"]]}}]}]},\"tokens\":null},{\"0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Pound\",\"span\":{\"lo\":0,\"hi\":0}}]},\"Joint\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Not\",\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"],[{\"variant\":\"Delimited\",\"fields\":[{\"open\":{\"lo\":0,\"hi\":0},\"close\":{\"lo\":0,\"hi\":0}},\"Bracket\",{\"0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Ident\",\"fields\":[\"crate_type\",false]},\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Eq\",\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Literal\",\"fields\":[{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null}]},\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"]]}]},\"Alone\"]]}]},\"id\":null,\"style\":\"Inner\",\"span\":{\"lo\":0,\"hi\":0}}],\"items\":[{\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"prelude_import\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}],\"tokens\":null},\"args\":\"Empty\",\"tokens\":null},null]},\"id\":null,\"style\":\"Outer\",\"span\":{\"lo\":0,\"hi\":0}}],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"kind\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0},\"tokens\":null},\"ident\":{\"name\":\"\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"Use\",\"fields\":[{\"prefix\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"{{root}}\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null},{\"ident\":{\"name\":\"std\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null},{\"ident\":{\"name\":\"prelude\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null},{\"ident\":{\"name\":\"rust_2015\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}],\"tokens\":null},\"kind\":\"Glob\",\"span\":{\"lo\":0,\"hi\":0}}]},\"tokens\":null},{\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"macro_use\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}],\"tokens\":null},\"args\":\"Empty\",\"tokens\":null},null]},\"id\":null,\"style\":\"Outer\",\"span\":{\"lo\":0,\"hi\":0}}],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"kind\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0},\"tokens\":null},\"ident\":{\"name\":\"std\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"ExternCrate\",\"fields\":[null]},\"tokens\":null},{\"attrs\":[],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"kind\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0},\"tokens\":null},\"ident\":{\"name\":\"core\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"ExternCrate\",\"fields\":[null]},\"tokens\":null}],\"spans\":{\"inner_span\":{\"lo\":0,\"hi\":0},\"inject_use_span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"is_placeholder\":false}"}]}