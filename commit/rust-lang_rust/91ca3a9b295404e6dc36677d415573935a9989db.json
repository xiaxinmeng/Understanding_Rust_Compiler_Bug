{"sha": "91ca3a9b295404e6dc36677d415573935a9989db", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxY2EzYTliMjk1NDA0ZTZkYzM2Njc3ZDQxNTU3MzkzNWE5OTg5ZGI=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-04-28T01:50:35Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-14T21:52:05Z"}, "message": "core::rt: Reording code", "tree": {"sha": "b917f022e20d4f7d09930fde9bd94a064add4647", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b917f022e20d4f7d09930fde9bd94a064add4647"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/91ca3a9b295404e6dc36677d415573935a9989db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/91ca3a9b295404e6dc36677d415573935a9989db", "html_url": "https://github.com/rust-lang/rust/commit/91ca3a9b295404e6dc36677d415573935a9989db", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/91ca3a9b295404e6dc36677d415573935a9989db/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6ab02c03da1e610f9c2f4c9a185a74f37f6195f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ab02c03da1e610f9c2f4c9a185a74f37f6195f2", "html_url": "https://github.com/rust-lang/rust/commit/6ab02c03da1e610f9c2f4c9a185a74f37f6195f2"}], "stats": {"total": 229, "additions": 115, "deletions": 114}, "files": [{"sha": "79afaf69ad35a3354de92fb0c66154b77dd836ba", "filename": "src/libcore/rt/uv/mod.rs", "status": "modified", "additions": 115, "deletions": 114, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/91ca3a9b295404e6dc36677d415573935a9989db/src%2Flibcore%2Frt%2Fuv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ca3a9b295404e6dc36677d415573935a9989db/src%2Flibcore%2Frt%2Fuv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Fmod.rs?ref=91ca3a9b295404e6dc36677d415573935a9989db", "patch": "@@ -178,111 +178,6 @@ impl NativeHandle<*uvll::uv_idle_t> for IdleWatcher {\n     }\n }\n \n-// XXX: Need to define the error constants like EOF so they can be\n-// compared to the UvError type\n-\n-pub struct UvError(uvll::uv_err_t);\n-\n-pub impl UvError {\n-\n-    fn name(&self) -> ~str {\n-        unsafe {\n-            let inner = match self { &UvError(ref a) => a };\n-            let name_str = uvll::err_name(inner);\n-            assert!(name_str.is_not_null());\n-            from_c_str(name_str)\n-        }\n-    }\n-\n-    fn desc(&self) -> ~str {\n-        unsafe {\n-            let inner = match self { &UvError(ref a) => a };\n-            let desc_str = uvll::strerror(inner);\n-            assert!(desc_str.is_not_null());\n-            from_c_str(desc_str)\n-        }\n-    }\n-}\n-\n-impl ToStr for UvError {\n-    fn to_str(&self) -> ~str {\n-        fmt!(\"%s: %s\", self.name(), self.desc())\n-    }\n-}\n-\n-#[test]\n-fn error_smoke_test() {\n-    let err = uvll::uv_err_t { code: 1, sys_errno_: 1 };\n-    let err: UvError = UvError(err);\n-    assert!(err.to_str() == ~\"EOF: end of file\");\n-}\n-\n-pub fn last_uv_error<H, W: Watcher + NativeHandle<*H>>(watcher: &W) -> UvError {\n-    unsafe {\n-        let loop_ = watcher.event_loop();\n-        UvError(uvll::last_error(loop_.native_handle()))\n-    }\n-}\n-\n-pub fn uv_error_to_io_error(uverr: UvError) -> IoError {\n-\n-    // XXX: Could go in str::raw\n-    unsafe fn c_str_to_static_slice(s: *libc::c_char) -> &'static str {\n-        let s = s as *u8;\n-        let mut curr = s, len = 0u;\n-        while *curr != 0u8 {\n-            len += 1u;\n-            curr = ptr::offset(s, len);\n-        }\n-\n-        str::raw::buf_as_slice(s, len, |d| cast::transmute(d))\n-    }\n-\n-\n-    unsafe {\n-        // Importing error constants\n-        use rt::uv::uvll::*;\n-        use rt::io::*;\n-\n-        // uv error descriptions are static\n-        let c_desc = uvll::strerror(&*uverr);\n-        let desc = c_str_to_static_slice(c_desc);\n-\n-        let kind = match uverr.code {\n-            UNKNOWN => OtherIoError,\n-            OK => OtherIoError,\n-            EOF => EndOfFile,\n-            EACCES => PermissionDenied,\n-            ECONNREFUSED => ConnectionRefused,\n-            e => {\n-                abort!(\"unknown uv error code: %u\", e as uint);\n-            }\n-        };\n-\n-        IoError {\n-            kind: kind,\n-            desc: desc,\n-            detail: None\n-        }\n-    }\n-}\n-\n-/// Given a uv handle, convert a callback status to a UvError\n-// XXX: Follow the pattern below by parameterizing over T: Watcher, not T\n-pub fn status_to_maybe_uv_error<T>(handle: *T, status: c_int) -> Option<UvError> {\n-    if status != -1 {\n-        None\n-    } else {\n-        unsafe {\n-            rtdebug!(\"handle: %x\", handle as uint);\n-            let loop_ = uvll::get_loop_for_uv_handle(handle);\n-            rtdebug!(\"loop: %x\", loop_ as uint);\n-            let err = uvll::last_error(loop_);\n-            Some(UvError(err))\n-        }\n-    }\n-}\n-\n /// Callbacks used by StreamWatchers, set as custom data on the foreign handle\n struct WatcherData {\n     read_cb: Option<ReadCallback>,\n@@ -383,21 +278,109 @@ impl<H, W: Watcher + NativeHandle<*H>> WatcherInterop for W {\n     }\n }\n \n+// XXX: Need to define the error constants like EOF so they can be\n+// compared to the UvError type\n+\n+pub struct UvError(uvll::uv_err_t);\n+\n+pub impl UvError {\n+\n+    fn name(&self) -> ~str {\n+        unsafe {\n+            let inner = match self { &UvError(ref a) => a };\n+            let name_str = uvll::err_name(inner);\n+            assert!(name_str.is_not_null());\n+            from_c_str(name_str)\n+        }\n+    }\n+\n+    fn desc(&self) -> ~str {\n+        unsafe {\n+            let inner = match self { &UvError(ref a) => a };\n+            let desc_str = uvll::strerror(inner);\n+            assert!(desc_str.is_not_null());\n+            from_c_str(desc_str)\n+        }\n+    }\n+}\n+\n+impl ToStr for UvError {\n+    fn to_str(&self) -> ~str {\n+        fmt!(\"%s: %s\", self.name(), self.desc())\n+    }\n+}\n+\n #[test]\n-fn test_slice_to_uv_buf() {\n-    let slice = [0, .. 20];\n-    let buf = slice_to_uv_buf(slice);\n+fn error_smoke_test() {\n+    let err = uvll::uv_err_t { code: 1, sys_errno_: 1 };\n+    let err: UvError = UvError(err);\n+    assert!(err.to_str() == ~\"EOF: end of file\");\n+}\n+\n+pub fn last_uv_error<H, W: Watcher + NativeHandle<*H>>(watcher: &W) -> UvError {\n+    unsafe {\n+        let loop_ = watcher.event_loop();\n+        UvError(uvll::last_error(loop_.native_handle()))\n+    }\n+}\n+\n+pub fn uv_error_to_io_error(uverr: UvError) -> IoError {\n+\n+    // XXX: Could go in str::raw\n+    unsafe fn c_str_to_static_slice(s: *libc::c_char) -> &'static str {\n+        let s = s as *u8;\n+        let mut curr = s, len = 0u;\n+        while *curr != 0u8 {\n+            len += 1u;\n+            curr = ptr::offset(s, len);\n+        }\n+\n+        str::raw::buf_as_slice(s, len, |d| cast::transmute(d))\n+    }\n \n-    assert!(buf.len == 20);\n \n     unsafe {\n-        let base = transmute::<*u8, *mut u8>(buf.base);\n-        (*base) = 1;\n-        (*ptr::mut_offset(base, 1)) = 2;\n+        // Importing error constants\n+        use rt::uv::uvll::*;\n+        use rt::io::*;\n+\n+        // uv error descriptions are static\n+        let c_desc = uvll::strerror(&*uverr);\n+        let desc = c_str_to_static_slice(c_desc);\n+\n+        let kind = match uverr.code {\n+            UNKNOWN => OtherIoError,\n+            OK => OtherIoError,\n+            EOF => EndOfFile,\n+            EACCES => PermissionDenied,\n+            ECONNREFUSED => ConnectionRefused,\n+            e => {\n+                abort!(\"unknown uv error code: %u\", e as uint);\n+            }\n+        };\n+\n+        IoError {\n+            kind: kind,\n+            desc: desc,\n+            detail: None\n+        }\n     }\n+}\n \n-    assert!(slice[0] == 1);\n-    assert!(slice[1] == 2);\n+/// Given a uv handle, convert a callback status to a UvError\n+// XXX: Follow the pattern below by parameterizing over T: Watcher, not T\n+pub fn status_to_maybe_uv_error<T>(handle: *T, status: c_int) -> Option<UvError> {\n+    if status != -1 {\n+        None\n+    } else {\n+        unsafe {\n+            rtdebug!(\"handle: %x\", handle as uint);\n+            let loop_ = uvll::get_loop_for_uv_handle(handle);\n+            rtdebug!(\"loop: %x\", loop_ as uint);\n+            let err = uvll::last_error(loop_);\n+            Some(UvError(err))\n+        }\n+    }\n }\n \n /// The uv buffer type\n@@ -437,6 +420,24 @@ pub fn vec_from_uv_buf(buf: Buf) -> Option<~[u8]> {\n     }\n }\n \n+#[test]\n+fn test_slice_to_uv_buf() {\n+    let slice = [0, .. 20];\n+    let buf = slice_to_uv_buf(slice);\n+\n+    assert!(buf.len == 20);\n+\n+    unsafe {\n+        let base = transmute::<*u8, *mut u8>(buf.base);\n+        (*base) = 1;\n+        (*ptr::mut_offset(base, 1)) = 2;\n+    }\n+\n+    assert!(slice[0] == 1);\n+    assert!(slice[1] == 2);\n+}\n+\n+\n #[test]\n fn loop_smoke_test() {\n     do run_in_bare_thread {"}]}