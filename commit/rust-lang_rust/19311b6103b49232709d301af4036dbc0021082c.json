{"sha": "19311b6103b49232709d301af4036dbc0021082c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5MzExYjYxMDNiNDkyMzI3MDlkMzAxYWY0MDM2ZGJjMDAyMTA4MmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-14T03:21:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-14T03:21:07Z"}, "message": "auto merge of #13316 : eddyb/rust/ast-ptr, r=brson\n\nReplaces Gc<T> in the AST with a custom owned smart pointer, P<T>. Fixes #7929.\r\n\r\n## Benefits\r\n* **Identity** (affinity?): sharing AST nodes is bad for the various analysis passes (e.g. one could bypass borrowck with a shared `ExprAddrOf` node taking a mutable borrow), the only reason we haven't hit any serious issues with it is because of inefficient folding passes which will always deduplicate any such shared nodes. Even if we were to switch to an arena, this would still hold, i.e. we wouldn't just use `&'a T` in the AST, but rather an wrapper (`P<'a, T>`?).\r\n\r\n* **Immutability**: `P<T>` disallows mutating its inner `T` (unless that contains an `Unsafe` interior, which won't happen in the AST), unlike `~T`.\r\n\r\n* **Efficiency**: folding can reuse allocation space for `P<T>` and `Vec<T>`, the latter even when the input and output types differ (as it would be the case with arenas or an AST with type parameters to toggle macro support). Also, various algorithms have been changed from copying `Gc<T>` to using `&T` and iterators.\r\n\r\n* **Maintainability**: there is another reason I didn't just replace `Gc<T>` with `~T`: `P<T>` provides a fixed interface (`Deref`, `and_then` and `map`) which can remain fully functional even if the implementation changes (using a special thread-local heap, for example). Moreover, switching to, e.g. `P<'a, T>` (for a contextual arena) is easy and mostly automated.", "tree": {"sha": "ae5c946b1c5198c5fb4f878d79a21b872b41f945", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ae5c946b1c5198c5fb4f878d79a21b872b41f945"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/19311b6103b49232709d301af4036dbc0021082c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/19311b6103b49232709d301af4036dbc0021082c", "html_url": "https://github.com/rust-lang/rust/commit/19311b6103b49232709d301af4036dbc0021082c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/19311b6103b49232709d301af4036dbc0021082c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "931b11549f3aab00aaaaff39cce33c0f7219b3b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/931b11549f3aab00aaaaff39cce33c0f7219b3b6", "html_url": "https://github.com/rust-lang/rust/commit/931b11549f3aab00aaaaff39cce33c0f7219b3b6"}, {"sha": "8577343f9eb1024bf77f59e281ba9f4cd1ee0aaa", "url": "https://api.github.com/repos/rust-lang/rust/commits/8577343f9eb1024bf77f59e281ba9f4cd1ee0aaa", "html_url": "https://github.com/rust-lang/rust/commit/8577343f9eb1024bf77f59e281ba9f4cd1ee0aaa"}], "stats": {"total": 9949, "additions": 4912, "deletions": 5037}, "files": [{"sha": "c0fd04401bcdaad97984405cdf1ce214ffa81dfb", "filename": "mk/crates.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -70,7 +70,7 @@ DEPS_graphviz := std\n DEPS_green := std native:context_switch\n DEPS_rustuv := std native:uv native:uv_support\n DEPS_native := std\n-DEPS_syntax := std term serialize log fmt_macros debug\n+DEPS_syntax := std term serialize log fmt_macros debug arena\n DEPS_rustc := syntax flate arena serialize getopts rbml \\\n               time log graphviz debug rustc_llvm rustc_back\n DEPS_rustc_llvm := native:rustllvm libc std"}, {"sha": "3aa4005879232cfe9f97ebb7dca909d01cc9706c", "filename": "src/libfourcc/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibfourcc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibfourcc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfourcc%2Flib.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -63,10 +63,9 @@ use syntax::ext::base::{ExtCtxt, MacExpr};\n use syntax::ext::build::AstBuilder;\n use syntax::parse::token;\n use syntax::parse::token::InternedString;\n+use syntax::ptr::P;\n use rustc::plugin::Registry;\n \n-use std::gc::Gc;\n-\n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_macro(\"fourcc\", expand_syntax_ext);\n@@ -135,7 +134,7 @@ struct Ident {\n }\n \n fn parse_tts(cx: &ExtCtxt,\n-             tts: &[ast::TokenTree]) -> (Gc<ast::Expr>, Option<Ident>) {\n+             tts: &[ast::TokenTree]) -> (P<ast::Expr>, Option<Ident>) {\n     let p = &mut cx.new_parser_from_tts(tts);\n     let ex = p.parse_expr();\n     let id = if p.token == token::EOF {\n@@ -156,7 +155,7 @@ fn parse_tts(cx: &ExtCtxt,\n fn target_endian_little(cx: &ExtCtxt, sp: Span) -> bool {\n     let meta = cx.meta_name_value(sp, InternedString::new(\"target_endian\"),\n         ast::LitStr(InternedString::new(\"little\"), ast::CookedStr));\n-    contains(cx.cfg().as_slice(), meta)\n+    contains(cx.cfg().as_slice(), &*meta)\n }\n \n // FIXME (10872): This is required to prevent an LLVM assert on Windows"}, {"sha": "ae7a3e66dfdf816288bd719118ee9a4666858624", "filename": "src/libhexfloat/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibhexfloat%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibhexfloat%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibhexfloat%2Flib.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -57,10 +57,9 @@ use syntax::ext::base;\n use syntax::ext::base::{ExtCtxt, MacExpr};\n use syntax::ext::build::AstBuilder;\n use syntax::parse::token;\n+use syntax::ptr::P;\n use rustc::plugin::Registry;\n \n-use std::gc::Gc;\n-\n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_macro(\"hexfloat\", expand_syntax_ext);\n@@ -122,7 +121,7 @@ pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n \n     let s = match expr.node {\n         // expression is a literal\n-        ast::ExprLit(lit) => match lit.node {\n+        ast::ExprLit(ref lit) => match lit.node {\n             // string literal\n             ast::LitStr(ref s, _) => {\n                 s.clone()\n@@ -167,7 +166,7 @@ struct Ident {\n }\n \n fn parse_tts(cx: &ExtCtxt,\n-             tts: &[ast::TokenTree]) -> (Gc<ast::Expr>, Option<Ident>) {\n+             tts: &[ast::TokenTree]) -> (P<ast::Expr>, Option<Ident>) {\n     let p = &mut cx.new_parser_from_tts(tts);\n     let ex = p.parse_expr();\n     let id = if p.token == token::EOF {"}, {"sha": "cd00e459a79988c66ff946c038c059c517772cb7", "filename": "src/libregex_macros/lib.rs", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibregex_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibregex_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex_macros%2Flib.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -26,7 +26,6 @@ extern crate syntax;\n extern crate rustc;\n \n use std::rc::Rc;\n-use std::gc::{Gc, GC};\n \n use syntax::ast;\n use syntax::codemap;\n@@ -35,6 +34,7 @@ use syntax::ext::base::{ExtCtxt, MacResult, MacExpr, DummyResult};\n use syntax::parse::token;\n use syntax::print::pprust;\n use syntax::fold::Folder;\n+use syntax::ptr::P;\n \n use rustc::plugin::Registry;\n \n@@ -111,7 +111,7 @@ struct NfaGen<'a> {\n }\n \n impl<'a> NfaGen<'a> {\n-    fn code(&mut self) -> Gc<ast::Expr> {\n+    fn code(&mut self) -> P<ast::Expr> {\n         // Most or all of the following things are used in the quasiquoted\n         // expression returned.\n         let num_cap_locs = 2 * self.prog.num_captures();\n@@ -332,7 +332,7 @@ fn exec<'t>(which: ::regex::native::MatchKind, input: &'t str,\n \n     // Generates code for the `add` method, which is responsible for adding\n     // zero-width states to the next queue of states to visit.\n-    fn add_insts(&self) -> Gc<ast::Expr> {\n+    fn add_insts(&self) -> P<ast::Expr> {\n         let arms = self.prog.insts.iter().enumerate().map(|(pc, inst)| {\n             let nextpc = pc + 1;\n             let body = match *inst {\n@@ -433,7 +433,7 @@ fn exec<'t>(which: ::regex::native::MatchKind, input: &'t str,\n \n     // Generates the code for the `step` method, which processes all states\n     // in the current queue that consume a single character.\n-    fn step_insts(&self) -> Gc<ast::Expr> {\n+    fn step_insts(&self) -> P<ast::Expr> {\n         let arms = self.prog.insts.iter().enumerate().map(|(pc, inst)| {\n             let nextpc = pc + 1;\n             let body = match *inst {\n@@ -524,17 +524,15 @@ fn exec<'t>(which: ::regex::native::MatchKind, input: &'t str,\n     // Translates a character class into a match expression.\n     // This avoids a binary search (and is hopefully replaced by a jump\n     // table).\n-    fn match_class(&self, casei: bool, ranges: &[(char, char)]) -> Gc<ast::Expr> {\n-        let expr_true = quote_expr!(self.cx, true);\n-\n+    fn match_class(&self, casei: bool, ranges: &[(char, char)]) -> P<ast::Expr> {\n         let mut arms = ranges.iter().map(|&(mut start, mut end)| {\n             if casei {\n                 start = start.to_uppercase();\n                 end = end.to_uppercase();\n             }\n             let pat = self.cx.pat(self.sp, ast::PatRange(quote_expr!(self.cx, $start),\n                                                          quote_expr!(self.cx, $end)));\n-            self.cx.arm(self.sp, vec!(pat), expr_true)\n+            self.cx.arm(self.sp, vec!(pat), quote_expr!(self.cx, true))\n         }).collect::<Vec<ast::Arm>>();\n \n         arms.push(self.wild_arm_expr(quote_expr!(self.cx, false)));\n@@ -546,7 +544,7 @@ fn exec<'t>(which: ::regex::native::MatchKind, input: &'t str,\n     // Generates code for checking a literal prefix of the search string.\n     // The code is only generated if the regex *has* a literal prefix.\n     // Otherwise, a no-op is returned.\n-    fn check_prefix(&self) -> Gc<ast::Expr> {\n+    fn check_prefix(&self) -> P<ast::Expr> {\n         if self.prog.prefix.len() == 0 {\n             self.empty_block()\n         } else {\n@@ -570,32 +568,32 @@ fn exec<'t>(which: ::regex::native::MatchKind, input: &'t str,\n     // A wild-card arm is automatically added that executes a no-op. It will\n     // never be used, but is added to satisfy the compiler complaining about\n     // non-exhaustive patterns.\n-    fn match_insts(&self, mut arms: Vec<ast::Arm>) -> Gc<ast::Expr> {\n+    fn match_insts(&self, mut arms: Vec<ast::Arm>) -> P<ast::Expr> {\n         arms.push(self.wild_arm_expr(self.empty_block()));\n         self.cx.expr_match(self.sp, quote_expr!(self.cx, pc), arms)\n     }\n \n-    fn empty_block(&self) -> Gc<ast::Expr> {\n+    fn empty_block(&self) -> P<ast::Expr> {\n         quote_expr!(self.cx, {})\n     }\n \n     // Creates a match arm for the instruction at `pc` with the expression\n     // `body`.\n-    fn arm_inst(&self, pc: uint, body: Gc<ast::Expr>) -> ast::Arm {\n+    fn arm_inst(&self, pc: uint, body: P<ast::Expr>) -> ast::Arm {\n         let pc_pat = self.cx.pat_lit(self.sp, quote_expr!(self.cx, $pc));\n \n         self.cx.arm(self.sp, vec!(pc_pat), body)\n     }\n \n     // Creates a wild-card match arm with the expression `body`.\n-    fn wild_arm_expr(&self, body: Gc<ast::Expr>) -> ast::Arm {\n+    fn wild_arm_expr(&self, body: P<ast::Expr>) -> ast::Arm {\n         ast::Arm {\n             attrs: vec!(),\n-            pats: vec!(box(GC) ast::Pat{\n+            pats: vec!(P(ast::Pat{\n                 id: ast::DUMMY_NODE_ID,\n                 span: self.sp,\n                 node: ast::PatWild(ast::PatWildSingle),\n-            }),\n+            })),\n             guard: None,\n             body: body,\n         }\n@@ -605,8 +603,8 @@ fn exec<'t>(which: ::regex::native::MatchKind, input: &'t str,\n     // Converts `xs` to a `[x1, x2, .., xN]` expression by calling `to_expr`\n     // on each element in `xs`.\n     fn vec_expr<T, It: Iterator<T>>(&self, xs: It,\n-                                    to_expr: |&ExtCtxt, T| -> Gc<ast::Expr>)\n-                  -> Gc<ast::Expr> {\n+                                    to_expr: |&ExtCtxt, T| -> P<ast::Expr>)\n+                  -> P<ast::Expr> {\n         let exprs = xs.map(|x| to_expr(self.cx, x)).collect();\n         self.cx.expr_vec(self.sp, exprs)\n     }\n@@ -618,13 +616,13 @@ fn parse(cx: &mut ExtCtxt, tts: &[ast::TokenTree]) -> Option<String> {\n     let mut parser = cx.new_parser_from_tts(tts);\n     let entry = cx.expander().fold_expr(parser.parse_expr());\n     let regex = match entry.node {\n-        ast::ExprLit(lit) => {\n+        ast::ExprLit(ref lit) => {\n             match lit.node {\n                 ast::LitStr(ref s, _) => s.to_string(),\n                 _ => {\n                     cx.span_err(entry.span, format!(\n                         \"expected string literal but got `{}`\",\n-                        pprust::lit_to_string(&*lit)).as_slice());\n+                        pprust::lit_to_string(&**lit)).as_slice());\n                     return None\n                 }\n             }"}, {"sha": "b80d53922f8a501ba485c4015c985850f4947843", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 57, "deletions": 37, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -35,6 +35,7 @@ use std::io::fs;\n use std::os;\n use arena::TypedArena;\n use syntax::ast;\n+use syntax::ast_map;\n use syntax::attr;\n use syntax::attr::{AttrMetaMethods};\n use syntax::diagnostics;\n@@ -65,7 +66,7 @@ pub fn compile_input(sess: Session,\n     // large chunks of memory alive and we want to free them as soon as\n     // possible to keep the peak memory usage low\n     let (outputs, trans, sess) = {\n-        let (outputs, expanded_crate, ast_map, id) = {\n+        let (outputs, expanded_crate, id) = {\n             let krate = phase_1_parse_input(&sess, cfg, input);\n             if stop_after_phase_1(&sess) { return; }\n             let outputs = build_output_filenames(input,\n@@ -75,25 +76,28 @@ pub fn compile_input(sess: Session,\n                                                  &sess);\n             let id = link::find_crate_name(Some(&sess), krate.attrs.as_slice(),\n                                            input);\n-            let (expanded_crate, ast_map)\n+            let expanded_crate\n                 = match phase_2_configure_and_expand(&sess, krate, id.as_slice(),\n                                                      addl_plugins) {\n                     None => return,\n-                    Some(p) => p,\n+                    Some(k) => k\n                 };\n \n-            (outputs, expanded_crate, ast_map, id)\n+            (outputs, expanded_crate, id)\n         };\n+\n+        let mut forest = ast_map::Forest::new(expanded_crate);\n+        let ast_map = assign_node_ids_and_map(&sess, &mut forest);\n+\n         write_out_deps(&sess, input, &outputs, id.as_slice());\n \n         if stop_after_phase_2(&sess) { return; }\n \n         let type_arena = TypedArena::new();\n-        let analysis = phase_3_run_analysis_passes(sess, &expanded_crate,\n-                                                   ast_map, &type_arena, id);\n-        phase_save_analysis(&analysis.ty_cx.sess, &expanded_crate, &analysis, outdir);\n+        let analysis = phase_3_run_analysis_passes(sess, ast_map, &type_arena, id);\n+        phase_save_analysis(&analysis.ty_cx.sess, analysis.ty_cx.map.krate(), &analysis, outdir);\n         if stop_after_phase_3(&analysis.ty_cx.sess) { return; }\n-        let (tcx, trans) = phase_4_translate_to_llvm(expanded_crate, analysis);\n+        let (tcx, trans) = phase_4_translate_to_llvm(analysis);\n \n         // Discard interned strings as they are no longer required.\n         token::get_ident_interner().clear();\n@@ -182,7 +186,7 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n                                     mut krate: ast::Crate,\n                                     crate_name: &str,\n                                     addl_plugins: Option<Plugins>)\n-                                    -> Option<(ast::Crate, syntax::ast_map::Map)> {\n+                                    -> Option<ast::Crate> {\n     let time_passes = sess.time_passes();\n \n     *sess.crate_types.borrow_mut() =\n@@ -294,20 +298,37 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n     krate = time(time_passes, \"prelude injection\", krate, |krate|\n                  front::std_inject::maybe_inject_prelude(sess, krate));\n \n-    let (krate, map) = time(time_passes, \"assigning node ids and indexing ast\", krate, |krate|\n-         front::assign_node_ids_and_map::assign_node_ids_and_map(sess, krate));\n+    time(time_passes, \"checking that all macro invocations are gone\", &krate, |krate|\n+         syntax::ext::expand::check_for_macros(&sess.parse_sess, krate));\n+\n+    Some(krate)\n+}\n+\n+pub fn assign_node_ids_and_map<'ast>(sess: &Session,\n+                                     forest: &'ast mut ast_map::Forest)\n+                                     -> ast_map::Map<'ast> {\n+    struct NodeIdAssigner<'a> {\n+        sess: &'a Session\n+    }\n+\n+    impl<'a> ast_map::FoldOps for NodeIdAssigner<'a> {\n+        fn new_id(&self, old_id: ast::NodeId) -> ast::NodeId {\n+            assert_eq!(old_id, ast::DUMMY_NODE_ID);\n+            self.sess.next_node_id()\n+        }\n+    }\n+\n+    let map = time(sess.time_passes(), \"assigning node ids and indexing ast\", forest, |forest|\n+                   ast_map::map_crate(forest, NodeIdAssigner { sess: sess }));\n \n     if sess.opts.debugging_opts & config::AST_JSON != 0 {\n         let mut stdout = io::BufferedWriter::new(io::stdout());\n         let mut json = json::PrettyEncoder::new(&mut stdout);\n         // unwrapping so IoError isn't ignored\n-        krate.encode(&mut json).unwrap();\n+        map.krate().encode(&mut json).unwrap();\n     }\n \n-    time(time_passes, \"checking that all macro invocations are gone\", &krate, |krate|\n-         syntax::ext::expand::check_for_macros(&sess.parse_sess, krate));\n-\n-    Some((krate, map))\n+    map\n }\n \n pub struct CrateAnalysis<'tcx> {\n@@ -324,11 +345,11 @@ pub struct CrateAnalysis<'tcx> {\n /// miscellaneous analysis passes on the crate. Return various\n /// structures carrying the results of the analysis.\n pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n-                                         krate: &ast::Crate,\n-                                         ast_map: syntax::ast_map::Map,\n+                                         ast_map: ast_map::Map<'tcx>,\n                                          type_arena: &'tcx TypedArena<ty::t_box_>,\n                                          name: String) -> CrateAnalysis<'tcx> {\n     let time_passes = sess.time_passes();\n+    let krate = ast_map.krate();\n \n     time(time_passes, \"external crate/lib resolution\", (), |_|\n          creader::read_crates(&sess, krate));\n@@ -353,7 +374,7 @@ pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n                                 |_| middle::resolve_lifetime::krate(&sess, krate));\n \n     time(time_passes, \"looking for entry point\", (),\n-         |_| middle::entry::find_entry_point(&sess, krate, &ast_map));\n+         |_| middle::entry::find_entry_point(&sess, &ast_map));\n \n     sess.plugin_registrar_fn.set(\n         time(time_passes, \"looking for plugin registrar\", (), |_|\n@@ -385,43 +406,43 @@ pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n                             stability_index);\n \n     // passes are timed inside typeck\n-    typeck::check_crate(&ty_cx, trait_map, krate);\n+    typeck::check_crate(&ty_cx, trait_map);\n \n     time(time_passes, \"check static items\", (), |_|\n-         middle::check_static::check_crate(&ty_cx, krate));\n+         middle::check_static::check_crate(&ty_cx));\n \n     // These next two const passes can probably be merged\n     time(time_passes, \"const marking\", (), |_|\n-         middle::const_eval::process_crate(krate, &ty_cx));\n+         middle::const_eval::process_crate(&ty_cx));\n \n     time(time_passes, \"const checking\", (), |_|\n-         middle::check_const::check_crate(krate, &ty_cx));\n+         middle::check_const::check_crate(&ty_cx));\n \n     let maps = (external_exports, last_private_map);\n     let (exported_items, public_items) =\n             time(time_passes, \"privacy checking\", maps, |(a, b)|\n-                 middle::privacy::check_crate(&ty_cx, &exp_map2, a, b, krate));\n+                 middle::privacy::check_crate(&ty_cx, &exp_map2, a, b));\n \n     time(time_passes, \"intrinsic checking\", (), |_|\n-         middle::intrinsicck::check_crate(&ty_cx, krate));\n+         middle::intrinsicck::check_crate(&ty_cx));\n \n     time(time_passes, \"effect checking\", (), |_|\n-         middle::effect::check_crate(&ty_cx, krate));\n+         middle::effect::check_crate(&ty_cx));\n \n     time(time_passes, \"match checking\", (), |_|\n-         middle::check_match::check_crate(&ty_cx, krate));\n+         middle::check_match::check_crate(&ty_cx));\n \n     time(time_passes, \"liveness checking\", (), |_|\n-         middle::liveness::check_crate(&ty_cx, krate));\n+         middle::liveness::check_crate(&ty_cx));\n \n     time(time_passes, \"borrow checking\", (), |_|\n-         middle::borrowck::check_crate(&ty_cx, krate));\n+         middle::borrowck::check_crate(&ty_cx));\n \n     time(time_passes, \"rvalue checking\", (), |_|\n          middle::check_rvalues::check_crate(&ty_cx, krate));\n \n     time(time_passes, \"kind checking\", (), |_|\n-         kind::check_crate(&ty_cx, krate));\n+         kind::check_crate(&ty_cx));\n \n     let reachable_map =\n         time(time_passes, \"reachability checking\", (), |_|\n@@ -430,12 +451,11 @@ pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n     time(time_passes, \"death checking\", (), |_| {\n         middle::dead::check_crate(&ty_cx,\n                                   &exported_items,\n-                                  &reachable_map,\n-                                  krate)\n+                                  &reachable_map)\n     });\n \n     time(time_passes, \"lint checking\", (), |_|\n-         lint::check_crate(&ty_cx, krate, &exported_items));\n+         lint::check_crate(&ty_cx, &exported_items));\n \n     CrateAnalysis {\n         exp_map2: exp_map2,\n@@ -475,16 +495,16 @@ pub struct CrateTranslation {\n \n /// Run the translation phase to LLVM, after which the AST and analysis can\n /// be discarded.\n-pub fn phase_4_translate_to_llvm(krate: ast::Crate,\n-                                 analysis: CrateAnalysis) -> (ty::ctxt, CrateTranslation) {\n+pub fn phase_4_translate_to_llvm<'tcx>(analysis: CrateAnalysis<'tcx>)\n+                                       -> (ty::ctxt<'tcx>, CrateTranslation) {\n     let time_passes = analysis.ty_cx.sess.time_passes();\n \n     time(time_passes, \"resolving dependency formats\", (), |_|\n          dependency_format::calculate(&analysis.ty_cx));\n \n     // Option dance to work around the lack of stack once closures.\n-    time(time_passes, \"translation\", (krate, analysis), |(krate, analysis)|\n-         trans::base::trans_crate(krate, analysis))\n+    time(time_passes, \"translation\", analysis, |analysis|\n+         trans::base::trans_crate(analysis))\n }\n \n /// Run LLVM itself, producing a bitcode file, assembly file or object file"}, {"sha": "7c27f23d4857a2456e0b0231a0dc0057280d105c", "filename": "src/librustc/driver/pretty.rs", "status": "modified", "additions": 55, "deletions": 77, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fdriver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fdriver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fpretty.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -91,13 +91,13 @@ pub fn parse_pretty(sess: &Session, name: &str) -> (PpMode, Option<UserIdentifie\n \n impl PpSourceMode {\n     /// Constructs a `PrinterSupport` object and passes it to `f`.\n-    fn call_with_pp_support<A,B>(&self,\n-                                 sess: Session,\n-                                 krate: &ast::Crate,\n-                                 ast_map: Option<ast_map::Map>,\n-                                 id: String,\n-                                 payload: B,\n-                                 f: |&PrinterSupport, B| -> A) -> A {\n+    fn call_with_pp_support<'tcx, A, B>(&self,\n+                                        sess: Session,\n+                                        ast_map: Option<ast_map::Map<'tcx>>,\n+                                        type_arena: &'tcx TypedArena<ty::t_box_>,\n+                                        id: String,\n+                                        payload: B,\n+                                        f: |&PrinterSupport, B| -> A) -> A {\n         match *self {\n             PpmNormal | PpmExpanded => {\n                 let annotation = NoAnn { sess: sess, ast_map: ast_map };\n@@ -114,79 +114,60 @@ impl PpSourceMode {\n             }\n             PpmTyped => {\n                 let ast_map = ast_map.expect(\"--pretty=typed missing ast_map\");\n-                let type_arena = TypedArena::new();\n-                let analysis = driver::phase_3_run_analysis_passes(sess, krate, ast_map,\n-                                                                   &type_arena, id);\n+                let analysis = driver::phase_3_run_analysis_passes(sess, ast_map,\n+                                                                   type_arena, id);\n                 let annotation = TypedAnnotation { analysis: analysis };\n                 f(&annotation, payload)\n             }\n         }\n     }\n }\n \n-trait SessionCarrier {\n+trait PrinterSupport<'ast>: pprust::PpAnn {\n     /// Provides a uniform interface for re-extracting a reference to a\n     /// `Session` from a value that now owns it.\n     fn sess<'a>(&'a self) -> &'a Session;\n-}\n \n-trait AstMapCarrier {\n     /// Provides a uniform interface for re-extracting a reference to an\n     /// `ast_map::Map` from a value that now owns it.\n-    fn ast_map<'a>(&'a self) -> Option<&'a ast_map::Map>;\n-}\n+    fn ast_map<'a>(&'a self) -> Option<&'a ast_map::Map<'ast>>;\n \n-trait PrinterSupport : SessionCarrier + AstMapCarrier {\n     /// Produces the pretty-print annotation object.\n     ///\n-    /// Usually implemented via `self as &pprust::PpAnn`.\n-    ///\n     /// (Rust does not yet support upcasting from a trait object to\n     /// an object for one of its super-traits.)\n-    fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn;\n+    fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn { self as &pprust::PpAnn }\n }\n \n-struct NoAnn {\n+struct NoAnn<'ast> {\n     sess: Session,\n-    ast_map: Option<ast_map::Map>,\n-}\n-\n-impl PrinterSupport for NoAnn {\n-    fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn { self as &pprust::PpAnn }\n+    ast_map: Option<ast_map::Map<'ast>>\n }\n \n-impl SessionCarrier for NoAnn {\n+impl<'ast> PrinterSupport<'ast> for NoAnn<'ast> {\n     fn sess<'a>(&'a self) -> &'a Session { &self.sess }\n-}\n \n-impl AstMapCarrier for NoAnn {\n-    fn ast_map<'a>(&'a self) -> Option<&'a ast_map::Map> {\n+    fn ast_map<'a>(&'a self) -> Option<&'a ast_map::Map<'ast>> {\n         self.ast_map.as_ref()\n     }\n }\n \n-impl pprust::PpAnn for NoAnn {}\n+impl<'ast> pprust::PpAnn for NoAnn<'ast> {}\n \n-struct IdentifiedAnnotation {\n+struct IdentifiedAnnotation<'ast> {\n     sess: Session,\n-    ast_map: Option<ast_map::Map>,\n-}\n-\n-impl PrinterSupport for IdentifiedAnnotation {\n-    fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn { self as &pprust::PpAnn }\n+    ast_map: Option<ast_map::Map<'ast>>,\n }\n \n-impl SessionCarrier for IdentifiedAnnotation {\n+impl<'ast> PrinterSupport<'ast> for IdentifiedAnnotation<'ast> {\n     fn sess<'a>(&'a self) -> &'a Session { &self.sess }\n-}\n \n-impl AstMapCarrier for IdentifiedAnnotation {\n-    fn ast_map<'a>(&'a self) -> Option<&'a ast_map::Map> {\n+    fn ast_map<'a>(&'a self) -> Option<&'a ast_map::Map<'ast>> {\n         self.ast_map.as_ref()\n     }\n }\n \n-impl pprust::PpAnn for IdentifiedAnnotation {\n+impl<'ast> pprust::PpAnn for IdentifiedAnnotation<'ast> {\n     fn pre(&self,\n            s: &mut pprust::State,\n            node: pprust::AnnNode) -> io::IoResult<()> {\n@@ -222,26 +203,20 @@ impl pprust::PpAnn for IdentifiedAnnotation {\n     }\n }\n \n-struct HygieneAnnotation {\n+struct HygieneAnnotation<'ast> {\n     sess: Session,\n-    ast_map: Option<ast_map::Map>,\n-}\n-\n-impl PrinterSupport for HygieneAnnotation {\n-    fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn { self as &pprust::PpAnn }\n+    ast_map: Option<ast_map::Map<'ast>>,\n }\n \n-impl SessionCarrier for HygieneAnnotation {\n+impl<'ast> PrinterSupport<'ast> for HygieneAnnotation<'ast> {\n     fn sess<'a>(&'a self) -> &'a Session { &self.sess }\n-}\n \n-impl AstMapCarrier for HygieneAnnotation {\n-    fn ast_map<'a>(&'a self) -> Option<&'a ast_map::Map> {\n+    fn ast_map<'a>(&'a self) -> Option<&'a ast_map::Map<'ast>> {\n         self.ast_map.as_ref()\n     }\n }\n \n-impl pprust::PpAnn for HygieneAnnotation {\n+impl<'ast> pprust::PpAnn for HygieneAnnotation<'ast> {\n     fn post(&self,\n             s: &mut pprust::State,\n             node: pprust::AnnNode) -> io::IoResult<()> {\n@@ -266,16 +241,10 @@ struct TypedAnnotation<'tcx> {\n     analysis: CrateAnalysis<'tcx>,\n }\n \n-impl<'tcx> PrinterSupport for TypedAnnotation<'tcx> {\n-    fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn { self as &pprust::PpAnn }\n-}\n-\n-impl<'tcx> SessionCarrier for TypedAnnotation<'tcx> {\n+impl<'tcx> PrinterSupport<'tcx> for TypedAnnotation<'tcx> {\n     fn sess<'a>(&'a self) -> &'a Session { &self.analysis.ty_cx.sess }\n-}\n \n-impl<'tcx> AstMapCarrier for TypedAnnotation<'tcx> {\n-    fn ast_map<'a>(&'a self) -> Option<&'a ast_map::Map> {\n+    fn ast_map<'a>(&'a self) -> Option<&'a ast_map::Map<'tcx>> {\n         Some(&self.analysis.ty_cx.map)\n     }\n }\n@@ -347,12 +316,12 @@ impl FromStr for UserIdentifiedItem {\n     }\n }\n \n-enum NodesMatchingUII<'a> {\n+enum NodesMatchingUII<'a, 'ast: 'a> {\n     NodesMatchingDirect(option::Item<ast::NodeId>),\n-    NodesMatchingSuffix(ast_map::NodesMatchingSuffix<'a, String>),\n+    NodesMatchingSuffix(ast_map::NodesMatchingSuffix<'a, 'ast, String>),\n }\n \n-impl<'a> Iterator<ast::NodeId> for NodesMatchingUII<'a> {\n+impl<'a, 'ast> Iterator<ast::NodeId> for NodesMatchingUII<'a, 'ast> {\n     fn next(&mut self) -> Option<ast::NodeId> {\n         match self {\n             &NodesMatchingDirect(ref mut iter) => iter.next(),\n@@ -369,7 +338,8 @@ impl UserIdentifiedItem {\n         }\n     }\n \n-    fn all_matching_node_ids<'a>(&'a self, map: &'a ast_map::Map) -> NodesMatchingUII<'a> {\n+    fn all_matching_node_ids<'a, 'ast>(&'a self, map: &'a ast_map::Map<'ast>)\n+                                       -> NodesMatchingUII<'a, 'ast> {\n         match *self {\n             ItemViaNode(node_id) =>\n                 NodesMatchingDirect(Some(node_id).move_iter()),\n@@ -443,15 +413,24 @@ pub fn pretty_print_input(sess: Session,\n     let id = link::find_crate_name(Some(&sess), krate.attrs.as_slice(), input);\n \n     let is_expanded = needs_expansion(&ppm);\n-    let (krate, ast_map) = if needs_ast_map(&ppm, &opt_uii) {\n-        let k = driver::phase_2_configure_and_expand(&sess, krate, id.as_slice(), None);\n-        let (krate, ast_map) = match k {\n+    let compute_ast_map = needs_ast_map(&ppm, &opt_uii);\n+    let krate = if compute_ast_map {\n+        match driver::phase_2_configure_and_expand(&sess, krate, id.as_slice(), None) {\n             None => return,\n-            Some(p) => p,\n-        };\n-        (krate, Some(ast_map))\n+            Some(k) => k\n+        }\n+    } else {\n+        krate\n+    };\n+\n+    let mut forest = ast_map::Forest::new(krate);\n+    let type_arena = TypedArena::new();\n+\n+    let (krate, ast_map) = if compute_ast_map {\n+        let map = driver::assign_node_ids_and_map(&sess, &mut forest);\n+        (map.krate(), Some(map))\n     } else {\n-        (krate, None)\n+        (forest.krate(), None)\n     };\n \n     let src_name = driver::source_name(input);\n@@ -476,12 +455,12 @@ pub fn pretty_print_input(sess: Session,\n     match (ppm, opt_uii) {\n         (PpmSource(s), None) =>\n             s.call_with_pp_support(\n-                sess, &krate, ast_map, id, out, |annotation, out| {\n+                sess, ast_map, &type_arena, id, out, |annotation, out| {\n                     debug!(\"pretty printing source code {}\", s);\n                     let sess = annotation.sess();\n                     pprust::print_crate(sess.codemap(),\n                                         sess.diagnostic(),\n-                                        &krate,\n+                                        krate,\n                                         src_name.to_string(),\n                                         &mut rdr,\n                                         out,\n@@ -491,7 +470,7 @@ pub fn pretty_print_input(sess: Session,\n \n         (PpmSource(s), Some(uii)) =>\n             s.call_with_pp_support(\n-                sess, &krate, ast_map, id, (out,uii), |annotation, (out,uii)| {\n+                sess, ast_map, &type_arena, id, (out,uii), |annotation, (out,uii)| {\n                     debug!(\"pretty printing source code {}\", s);\n                     let sess = annotation.sess();\n                     let ast_map = annotation.ast_map()\n@@ -533,9 +512,8 @@ pub fn pretty_print_input(sess: Session,\n             match code {\n                 Some(code) => {\n                     let variants = gather_flowgraph_variants(&sess);\n-                    let type_arena = TypedArena::new();\n-                    let analysis = driver::phase_3_run_analysis_passes(sess, &krate,\n-                                                                       ast_map, &type_arena, id);\n+                    let analysis = driver::phase_3_run_analysis_passes(sess, ast_map,\n+                                                                       &type_arena, id);\n                     print_flowgraph(variants, analysis, code, out)\n                 }\n                 None => {"}, {"sha": "6f020184b336d8a3d92a4f7a81d260b4d5aad3d5", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -263,7 +263,6 @@ pub fn build_session_(sopts: config::Options,\n }\n \n // Seems out of place, but it uses session, so I'm putting it here\n-pub fn expect<T:Clone>(sess: &Session, opt: Option<T>, msg: || -> String)\n-              -> T {\n+pub fn expect<T>(sess: &Session, opt: Option<T>, msg: || -> String) -> T {\n     diagnostic::expect(sess.diagnostic(), opt, msg)\n }"}, {"sha": "f7c919131a80939eb1a1e8bb78184b6d18c2f98e", "filename": "src/librustc/front/assign_node_ids_and_map.rs", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/931b11549f3aab00aaaaff39cce33c0f7219b3b6/src%2Flibrustc%2Ffront%2Fassign_node_ids_and_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/931b11549f3aab00aaaaff39cce33c0f7219b3b6/src%2Flibrustc%2Ffront%2Fassign_node_ids_and_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fassign_node_ids_and_map.rs?ref=931b11549f3aab00aaaaff39cce33c0f7219b3b6", "patch": "@@ -1,29 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use driver::session::Session;\n-\n-use syntax::ast;\n-use syntax::ast_map;\n-\n-struct NodeIdAssigner<'a> {\n-    sess: &'a Session\n-}\n-\n-impl<'a> ast_map::FoldOps for NodeIdAssigner<'a> {\n-    fn new_id(&self, old_id: ast::NodeId) -> ast::NodeId {\n-        assert_eq!(old_id, ast::DUMMY_NODE_ID);\n-        self.sess.next_node_id()\n-    }\n-}\n-\n-pub fn assign_node_ids_and_map(sess: &Session, krate: ast::Crate) -> (ast::Crate, ast_map::Map) {\n-    ast_map::map_crate(krate, NodeIdAssigner { sess: sess })\n-}"}, {"sha": "f028f5c97b7ef9216278c2595aa7e4aa4a3ac0c5", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 127, "deletions": 129, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -10,9 +10,8 @@\n \n use syntax::fold::Folder;\n use syntax::{ast, fold, attr};\n-use syntax::codemap;\n-\n-use std::gc::{Gc, GC};\n+use syntax::codemap::Spanned;\n+use syntax::ptr::P;\n \n /// A folder that strips out items that do not belong in the current\n /// configuration.\n@@ -28,22 +27,22 @@ pub fn strip_unconfigured_items(krate: ast::Crate) -> ast::Crate {\n }\n \n impl<'a> fold::Folder for Context<'a> {\n-    fn fold_mod(&mut self, module: &ast::Mod) -> ast::Mod {\n+    fn fold_mod(&mut self, module: ast::Mod) -> ast::Mod {\n         fold_mod(self, module)\n     }\n-    fn fold_block(&mut self, block: ast::P<ast::Block>) -> ast::P<ast::Block> {\n+    fn fold_block(&mut self, block: P<ast::Block>) -> P<ast::Block> {\n         fold_block(self, block)\n     }\n-    fn fold_foreign_mod(&mut self, foreign_mod: &ast::ForeignMod) -> ast::ForeignMod {\n+    fn fold_foreign_mod(&mut self, foreign_mod: ast::ForeignMod) -> ast::ForeignMod {\n         fold_foreign_mod(self, foreign_mod)\n     }\n-    fn fold_item_underscore(&mut self, item: &ast::Item_) -> ast::Item_ {\n+    fn fold_item_underscore(&mut self, item: ast::Item_) -> ast::Item_ {\n         fold_item_underscore(self, item)\n     }\n-    fn fold_expr(&mut self, expr: Gc<ast::Expr>) -> Gc<ast::Expr> {\n+    fn fold_expr(&mut self, expr: P<ast::Expr>) -> P<ast::Expr> {\n         fold_expr(self, expr)\n     }\n-    fn fold_mac(&mut self, mac: &ast::Mac) -> ast::Mac {\n+    fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac {\n         fold::noop_fold_mac(mac, self)\n     }\n }\n@@ -57,169 +56,168 @@ pub fn strip_items(krate: ast::Crate,\n     ctxt.fold_crate(krate)\n }\n \n-fn filter_view_item<'r>(cx: &mut Context, view_item: &'r ast::ViewItem)\n-                        -> Option<&'r ast::ViewItem> {\n-    if view_item_in_cfg(cx, view_item) {\n+fn filter_view_item(cx: &mut Context, view_item: ast::ViewItem) -> Option<ast::ViewItem> {\n+    if view_item_in_cfg(cx, &view_item) {\n         Some(view_item)\n     } else {\n         None\n     }\n }\n \n-fn fold_mod(cx: &mut Context, m: &ast::Mod) -> ast::Mod {\n-    let filtered_items: Vec<&Gc<ast::Item>> = m.items.iter()\n-            .filter(|a| item_in_cfg(cx, &***a))\n-            .collect();\n-    let flattened_items = filtered_items.move_iter()\n-            .flat_map(|&x| cx.fold_item(x).move_iter())\n-            .collect();\n-    let filtered_view_items = m.view_items.iter().filter_map(|a| {\n-        filter_view_item(cx, a).map(|x| cx.fold_view_item(x))\n-    }).collect();\n+fn fold_mod(cx: &mut Context, ast::Mod {inner, view_items, items}: ast::Mod) -> ast::Mod {\n     ast::Mod {\n-        inner: m.inner,\n-        view_items: filtered_view_items,\n-        items: flattened_items\n+        inner: inner,\n+        view_items: view_items.move_iter().filter_map(|a| {\n+            filter_view_item(cx, a).map(|x| cx.fold_view_item(x))\n+        }).collect(),\n+        items: items.move_iter().filter_map(|a| {\n+            if item_in_cfg(cx, &*a) {\n+                Some(cx.fold_item(a))\n+            } else {\n+                None\n+            }\n+        }).flat_map(|x| x.move_iter()).collect()\n     }\n }\n \n-fn filter_foreign_item(cx: &mut Context, item: Gc<ast::ForeignItem>)\n-                       -> Option<Gc<ast::ForeignItem>> {\n+fn filter_foreign_item(cx: &mut Context, item: P<ast::ForeignItem>)\n+                       -> Option<P<ast::ForeignItem>> {\n     if foreign_item_in_cfg(cx, &*item) {\n         Some(item)\n     } else {\n         None\n     }\n }\n \n-fn fold_foreign_mod(cx: &mut Context, nm: &ast::ForeignMod) -> ast::ForeignMod {\n-    let filtered_items = nm.items\n-                           .iter()\n-                           .filter_map(|a| filter_foreign_item(cx, *a))\n-                           .collect();\n-    let filtered_view_items = nm.view_items.iter().filter_map(|a| {\n-        filter_view_item(cx, a).map(|x| cx.fold_view_item(x))\n-    }).collect();\n+fn fold_foreign_mod(cx: &mut Context, ast::ForeignMod {abi, view_items, items}: ast::ForeignMod)\n+                    -> ast::ForeignMod {\n     ast::ForeignMod {\n-        abi: nm.abi,\n-        view_items: filtered_view_items,\n-        items: filtered_items\n+        abi: abi,\n+        view_items: view_items.move_iter().filter_map(|a| {\n+            filter_view_item(cx, a).map(|x| cx.fold_view_item(x))\n+        }).collect(),\n+        items: items.move_iter()\n+                    .filter_map(|a| filter_foreign_item(cx, a))\n+                    .collect()\n     }\n }\n \n-fn fold_item_underscore(cx: &mut Context, item: &ast::Item_) -> ast::Item_ {\n-    let item = match *item {\n-        ast::ItemImpl(ref a, ref b, c, ref impl_items) => {\n-            let impl_items = impl_items.iter()\n-                                       .filter(|ii| {\n-                                           impl_item_in_cfg(cx, &**ii)\n-                                       })\n-                                       .map(|x| *x)\n+fn fold_item_underscore(cx: &mut Context, item: ast::Item_) -> ast::Item_ {\n+    let item = match item {\n+        ast::ItemImpl(a, b, c, impl_items) => {\n+            let impl_items = impl_items.move_iter()\n+                                       .filter(|ii| impl_item_in_cfg(cx, ii))\n                                        .collect();\n-            ast::ItemImpl((*a).clone(), (*b).clone(), c, impl_items)\n+            ast::ItemImpl(a, b, c, impl_items)\n         }\n-        ast::ItemTrait(ref a, ref b, ref c, ref methods) => {\n-            let methods = methods.iter()\n-                                 .filter(|m| trait_method_in_cfg(cx, *m) )\n-                                 .map(|x| (*x).clone())\n+        ast::ItemTrait(a, b, c, methods) => {\n+            let methods = methods.move_iter()\n+                                 .filter(|m| trait_method_in_cfg(cx, m))\n                                  .collect();\n-            ast::ItemTrait((*a).clone(), (*b).clone(), (*c).clone(), methods)\n+            ast::ItemTrait(a, b, c, methods)\n         }\n-        ast::ItemStruct(ref def, ref generics) => {\n-            ast::ItemStruct(fold_struct(cx, &**def), generics.clone())\n+        ast::ItemStruct(def, generics) => {\n+            ast::ItemStruct(fold_struct(cx, def), generics)\n         }\n-        ast::ItemEnum(ref def, ref generics) => {\n-            let mut variants = def.variants.iter().map(|c| c.clone()).\n-            filter_map(|v| {\n+        ast::ItemEnum(def, generics) => {\n+            let mut variants = def.variants.move_iter().filter_map(|v| {\n                 if !(cx.in_cfg)(v.node.attrs.as_slice()) {\n                     None\n                 } else {\n-                    Some(match v.node.kind {\n-                                ast::TupleVariantKind(..) => v,\n-                                ast::StructVariantKind(ref def) => {\n-                                    let def = fold_struct(cx, &**def);\n-                                    box(GC) codemap::Spanned {\n-                                        node: ast::Variant_ {\n-                                            kind: ast::StructVariantKind(def.clone()),\n-                                            ..v.node.clone()\n-                                        },\n-                                        ..*v\n+                    Some(v.map(|Spanned {node: ast::Variant_ {id, name, attrs, kind,\n+                                                              disr_expr, vis}, span}| {\n+                        Spanned {\n+                            node: ast::Variant_ {\n+                                id: id,\n+                                name: name,\n+                                attrs: attrs,\n+                                kind: match kind {\n+                                    ast::TupleVariantKind(..) => kind,\n+                                    ast::StructVariantKind(def) => {\n+                                        ast::StructVariantKind(fold_struct(cx, def))\n                                     }\n-                                }\n-                            })\n-                    }\n-                });\n+                                },\n+                                disr_expr: disr_expr,\n+                                vis: vis\n+                            },\n+                            span: span\n+                        }\n+                    }))\n+                }\n+            });\n             ast::ItemEnum(ast::EnumDef {\n                 variants: variants.collect(),\n-            }, generics.clone())\n+            }, generics)\n         }\n-        ref item => item.clone(),\n+        item => item,\n     };\n \n-    fold::noop_fold_item_underscore(&item, cx)\n+    fold::noop_fold_item_underscore(item, cx)\n }\n \n-fn fold_struct(cx: &mut Context, def: &ast::StructDef) -> Gc<ast::StructDef> {\n-    let mut fields = def.fields.iter().map(|c| c.clone()).filter(|m| {\n-        (cx.in_cfg)(m.node.attrs.as_slice())\n-    });\n-    box(GC) ast::StructDef {\n-        fields: fields.collect(),\n-        ctor_id: def.ctor_id,\n-        super_struct: def.super_struct.clone(),\n-        is_virtual: def.is_virtual,\n-    }\n+fn fold_struct(cx: &mut Context, def: P<ast::StructDef>) -> P<ast::StructDef> {\n+    def.map(|ast::StructDef {fields, ctor_id, super_struct, is_virtual}| {\n+        ast::StructDef {\n+            fields: fields.move_iter().filter(|m| {\n+                (cx.in_cfg)(m.node.attrs.as_slice())\n+            }).collect(),\n+            ctor_id: ctor_id,\n+            super_struct: super_struct,\n+            is_virtual: is_virtual,\n+        }\n+    })\n }\n \n-fn retain_stmt(cx: &mut Context, stmt: Gc<ast::Stmt>) -> bool {\n+fn retain_stmt(cx: &mut Context, stmt: &ast::Stmt) -> bool {\n     match stmt.node {\n-      ast::StmtDecl(decl, _) => {\n-        match decl.node {\n-          ast::DeclItem(ref item) => {\n-            item_in_cfg(cx, &**item)\n-          }\n-          _ => true\n+        ast::StmtDecl(ref decl, _) => {\n+            match decl.node {\n+                ast::DeclItem(ref item) => {\n+                    item_in_cfg(cx, &**item)\n+                }\n+                _ => true\n+            }\n         }\n-      }\n-      _ => true\n+        _ => true\n     }\n }\n \n-fn fold_block(cx: &mut Context, b: ast::P<ast::Block>) -> ast::P<ast::Block> {\n-    let resulting_stmts: Vec<&Gc<ast::Stmt>> =\n-        b.stmts.iter().filter(|&a| retain_stmt(cx, *a)).collect();\n-    let resulting_stmts = resulting_stmts.move_iter()\n-        .flat_map(|stmt| cx.fold_stmt(&**stmt).move_iter())\n-        .collect();\n-    let filtered_view_items = b.view_items.iter().filter_map(|a| {\n-        filter_view_item(cx, a).map(|x| cx.fold_view_item(x))\n-    }).collect();\n-    ast::P(ast::Block {\n-        view_items: filtered_view_items,\n-        stmts: resulting_stmts,\n-        expr: b.expr.map(|x| cx.fold_expr(x)),\n-        id: b.id,\n-        rules: b.rules,\n-        span: b.span,\n+fn fold_block(cx: &mut Context, b: P<ast::Block>) -> P<ast::Block> {\n+    b.map(|ast::Block {id, view_items, stmts, expr, rules, span}| {\n+        let resulting_stmts: Vec<P<ast::Stmt>> =\n+            stmts.move_iter().filter(|a| retain_stmt(cx, &**a)).collect();\n+        let resulting_stmts = resulting_stmts.move_iter()\n+            .flat_map(|stmt| cx.fold_stmt(stmt).move_iter())\n+            .collect();\n+        let filtered_view_items = view_items.move_iter().filter_map(|a| {\n+            filter_view_item(cx, a).map(|x| cx.fold_view_item(x))\n+        }).collect();\n+        ast::Block {\n+            id: id,\n+            view_items: filtered_view_items,\n+            stmts: resulting_stmts,\n+            expr: expr.map(|x| cx.fold_expr(x)),\n+            rules: rules,\n+            span: span,\n+        }\n     })\n }\n \n-fn fold_expr(cx: &mut Context, expr: Gc<ast::Expr>) -> Gc<ast::Expr> {\n-    let expr = match expr.node {\n-        ast::ExprMatch(ref m, ref arms) => {\n-            let arms = arms.iter()\n-                .filter(|a| (cx.in_cfg)(a.attrs.as_slice()))\n-                .map(|a| a.clone())\n-                .collect();\n-            box(GC) ast::Expr {\n-                id: expr.id,\n-                span: expr.span.clone(),\n-                node: ast::ExprMatch(m.clone(), arms),\n-            }\n-        }\n-        _ => expr.clone()\n-    };\n-    fold::noop_fold_expr(expr, cx)\n+fn fold_expr(cx: &mut Context, expr: P<ast::Expr>) -> P<ast::Expr> {\n+    expr.map(|ast::Expr {id, span, node}| {\n+        fold::noop_fold_expr(ast::Expr {\n+            id: id,\n+            node: match node {\n+                ast::ExprMatch(m, arms) => {\n+                    ast::ExprMatch(m, arms.move_iter()\n+                                        .filter(|a| (cx.in_cfg)(a.attrs.as_slice()))\n+                                        .collect())\n+                }\n+                _ => node\n+            },\n+            span: span\n+        }, cx)\n+    })\n }\n \n fn item_in_cfg(cx: &mut Context, item: &ast::Item) -> bool {\n@@ -237,19 +235,19 @@ fn view_item_in_cfg(cx: &mut Context, item: &ast::ViewItem) -> bool {\n fn trait_method_in_cfg(cx: &mut Context, meth: &ast::TraitItem) -> bool {\n     match *meth {\n         ast::RequiredMethod(ref meth) => (cx.in_cfg)(meth.attrs.as_slice()),\n-        ast::ProvidedMethod(meth) => (cx.in_cfg)(meth.attrs.as_slice())\n+        ast::ProvidedMethod(ref meth) => (cx.in_cfg)(meth.attrs.as_slice())\n     }\n }\n \n fn impl_item_in_cfg(cx: &mut Context, impl_item: &ast::ImplItem) -> bool {\n     match *impl_item {\n-        ast::MethodImplItem(meth) => (cx.in_cfg)(meth.attrs.as_slice()),\n+        ast::MethodImplItem(ref meth) => (cx.in_cfg)(meth.attrs.as_slice()),\n     }\n }\n \n // Determine if an item should be translated in the current crate\n // configuration based on the item's attributes\n-fn in_cfg(cfg: &[Gc<ast::MetaItem>], attrs: &[ast::Attribute]) -> bool {\n-    attr::test_cfg(cfg, attrs.iter().map(|x| *x))\n+fn in_cfg(cfg: &[P<ast::MetaItem>], attrs: &[ast::Attribute]) -> bool {\n+    attr::test_cfg(cfg, attrs.iter())\n }\n "}, {"sha": "13a40aba93078321db65640e5d255ffc975e672a", "filename": "src/librustc/front/feature_gate.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ffeature_gate.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -33,6 +33,7 @@ use syntax::parse::token;\n use driver::session::Session;\n \n use std::cell::Cell;\n+use std::slice;\n \n /// This is a list of all known features since the beginning of time. This list\n /// can never shrink, it may only be expanded (in order to prevent old programs\n@@ -220,7 +221,7 @@ impl<'a, 'v> Visitor<'v> for Context<'a> {\n                 }\n             }\n \n-            ast::ItemStruct(struct_definition, _) => {\n+            ast::ItemStruct(ref struct_definition, _) => {\n                 if attr::contains_name(i.attrs.as_slice(), \"simd\") {\n                     self.gate_feature(\"simd\", i.span,\n                                       \"SIMD types are experimental and possibly buggy\");\n@@ -310,7 +311,7 @@ impl<'a, 'v> Visitor<'v> for Context<'a> {\n \n     fn visit_ty(&mut self, t: &ast::Ty) {\n         match t.node {\n-            ast::TyClosure(closure) if closure.onceness == ast::Once => {\n+            ast::TyClosure(ref closure) if closure.onceness == ast::Once => {\n                 self.gate_feature(\"once_fns\", t.span,\n                                   \"once functions are \\\n                                    experimental and likely to be removed\");\n@@ -352,7 +353,7 @@ impl<'a, 'v> Visitor<'v> for Context<'a> {\n     fn visit_generics(&mut self, generics: &ast::Generics) {\n         for type_parameter in generics.ty_params.iter() {\n             match type_parameter.default {\n-                Some(ty) => {\n+                Some(ref ty) => {\n                     self.gate_feature(\"default_type_params\", ty.span,\n                                       \"default type parameters are \\\n                                        experimental and possibly buggy\");\n@@ -364,7 +365,7 @@ impl<'a, 'v> Visitor<'v> for Context<'a> {\n     }\n \n     fn visit_attribute(&mut self, attr: &ast::Attribute) {\n-        if attr::contains_name([*attr], \"lang\") {\n+        if attr::contains_name(slice::ref_slice(attr), \"lang\") {\n             self.gate_feature(\"lang_items\",\n                               attr.span,\n                               \"language items are subject to change\");\n@@ -420,7 +421,7 @@ pub fn check_crate(sess: &Session, krate: &ast::Crate) {\n                                           expected #![feature(...)]\");\n             }\n             Some(list) => {\n-                for &mi in list.iter() {\n+                for mi in list.iter() {\n                     let name = match mi.node {\n                         ast::MetaWord(ref word) => (*word).clone(),\n                         _ => {"}, {"sha": "748641ba70c2bc2eee1698260f0ff0a7d19e6eed", "filename": "src/librustc/front/std_inject.rs", "status": "modified", "additions": 24, "deletions": 28, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fstd_inject.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -21,10 +21,10 @@ use syntax::owned_slice::OwnedSlice;\n use syntax::parse::token::InternedString;\n use syntax::parse::token::special_idents;\n use syntax::parse::token;\n+use syntax::ptr::P;\n use syntax::util::small_vector::SmallVector;\n \n use std::mem;\n-use std::gc::{Gc, GC};\n \n pub fn maybe_inject_crates_ref(sess: &Session, krate: ast::Crate)\n                                -> ast::Crate {\n@@ -149,7 +149,6 @@ impl<'a> fold::Folder for PreludeInjector<'a> {\n         if !no_prelude(krate.attrs.as_slice()) {\n             // only add `use std::prelude::*;` if there wasn't a\n             // `#![no_implicit_prelude]` at the crate level.\n-\n             // fold_mod() will insert glob path.\n             let globs_attr = attr::mk_attr_inner(attr::mk_attr_id(),\n                                                  attr::mk_list_item(\n@@ -161,23 +160,23 @@ impl<'a> fold::Folder for PreludeInjector<'a> {\n             attr::mark_used(&globs_attr);\n             krate.attrs.push(globs_attr);\n \n-            krate.module = self.fold_mod(&krate.module);\n+            krate.module = self.fold_mod(krate.module);\n         }\n         krate\n     }\n \n-    fn fold_item(&mut self, item: Gc<ast::Item>) -> SmallVector<Gc<ast::Item>> {\n+    fn fold_item(&mut self, item: P<ast::Item>) -> SmallVector<P<ast::Item>> {\n         if !no_prelude(item.attrs.as_slice()) {\n             // only recur if there wasn't `#![no_implicit_prelude]`\n             // on this item, i.e. this means that the prelude is not\n             // implicitly imported though the whole subtree\n-            fold::noop_fold_item(&*item, self)\n+            fold::noop_fold_item(item, self)\n         } else {\n             SmallVector::one(item)\n         }\n     }\n \n-    fn fold_mod(&mut self, module: &ast::Mod) -> ast::Mod {\n+    fn fold_mod(&mut self, ast::Mod {inner, view_items, items}: ast::Mod) -> ast::Mod {\n         let prelude_path = ast::Path {\n             span: DUMMY_SP,\n             global: false,\n@@ -194,44 +193,41 @@ impl<'a> fold::Folder for PreludeInjector<'a> {\n                 }),\n         };\n \n-        let vp = box(GC) codemap::dummy_spanned(ast::ViewPathGlob(prelude_path,\n-                                                                  ast::DUMMY_NODE_ID));\n-        let vi2 = ast::ViewItem {\n+        let (crates, uses) = view_items.partitioned(|x| {\n+            match x.node {\n+                ast::ViewItemExternCrate(..) => true,\n+                _ => false,\n+            }\n+        });\n+\n+        // add prelude after any `extern crate` but before any `use`\n+        let mut view_items = crates;\n+        let vp = P(codemap::dummy_spanned(ast::ViewPathGlob(prelude_path, ast::DUMMY_NODE_ID)));\n+        view_items.push(ast::ViewItem {\n             node: ast::ViewItemUse(vp),\n-            attrs: vec!(ast::Attribute {\n+            attrs: vec![ast::Attribute {\n                 span: DUMMY_SP,\n                 node: ast::Attribute_ {\n                     id: attr::mk_attr_id(),\n                     style: ast::AttrOuter,\n-                    value: box(GC) ast::MetaItem {\n+                    value: P(ast::MetaItem {\n                         span: DUMMY_SP,\n                         node: ast::MetaWord(token::get_name(\n                                 special_idents::prelude_import.name)),\n-                    },\n+                    }),\n                     is_sugared_doc: false,\n                 },\n-            }),\n+            }],\n             vis: ast::Inherited,\n             span: DUMMY_SP,\n-        };\n-\n-        let (crates, uses) = module.view_items.partitioned(|x| {\n-            match x.node {\n-                ast::ViewItemExternCrate(..) => true,\n-                _ => false,\n-            }\n         });\n-\n-        // add vi2 after any `extern crate` but before any `use`\n-        let mut view_items = crates;\n-        view_items.push(vi2);\n         view_items.push_all_move(uses);\n \n-        let new_module = ast::Mod {\n+        fold::noop_fold_mod(ast::Mod {\n+            inner: inner,\n             view_items: view_items,\n-            ..(*module).clone()\n-        };\n-        fold::noop_fold_mod(&new_module, self)\n+            items: items\n+        }, self)\n     }\n }\n "}, {"sha": "a8c9c500095884f333c1075049129ab555e6b377", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 53, "deletions": 50, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -16,10 +16,10 @@\n use driver::session::Session;\n use front::config;\n \n-use std::gc::{Gc, GC};\n use std::slice;\n use std::mem;\n use std::vec;\n+use syntax::{ast, ast_util};\n use syntax::ast_util::*;\n use syntax::attr::AttrMetaMethods;\n use syntax::attr;\n@@ -28,13 +28,13 @@ use syntax::codemap;\n use syntax::ext::base::ExtCtxt;\n use syntax::ext::build::AstBuilder;\n use syntax::ext::expand::ExpansionConfig;\n-use syntax::fold::Folder;\n+use syntax::fold::{Folder, MoveMap};\n use syntax::fold;\n use syntax::owned_slice::OwnedSlice;\n use syntax::parse::token::InternedString;\n use syntax::parse::token;\n use syntax::print::pprust;\n-use syntax::{ast, ast_util};\n+use syntax::ptr::P;\n use syntax::util::small_vector::SmallVector;\n \n struct Test {\n@@ -105,12 +105,12 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n         folded\n     }\n \n-    fn fold_item(&mut self, i: Gc<ast::Item>) -> SmallVector<Gc<ast::Item>> {\n+    fn fold_item(&mut self, i: P<ast::Item>) -> SmallVector<P<ast::Item>> {\n         self.cx.path.push(i.ident);\n         debug!(\"current path: {}\",\n                ast_util::path_name_i(self.cx.path.as_slice()));\n \n-        if is_test_fn(&self.cx, i) || is_bench_fn(&self.cx, i) {\n+        if is_test_fn(&self.cx, &*i) || is_bench_fn(&self.cx, &*i) {\n             match i.node {\n                 ast::ItemFn(_, ast::UnsafeFn, _, _, _) => {\n                     let sess = self.cx.sess;\n@@ -123,9 +123,9 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n                     let test = Test {\n                         span: i.span,\n                         path: self.cx.path.clone(),\n-                        bench: is_bench_fn(&self.cx, i),\n-                        ignore: is_ignored(&self.cx, i),\n-                        should_fail: should_fail(i)\n+                        bench: is_bench_fn(&self.cx, &*i),\n+                        ignore: is_ignored(&self.cx, &*i),\n+                        should_fail: should_fail(&*i)\n                     };\n                     self.cx.testfns.push(test);\n                     self.tests.push(i.ident);\n@@ -138,14 +138,14 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n         // We don't want to recurse into anything other than mods, since\n         // mods or tests inside of functions will break things\n         let res = match i.node {\n-            ast::ItemMod(..) => fold::noop_fold_item(&*i, self),\n+            ast::ItemMod(..) => fold::noop_fold_item(i, self),\n             _ => SmallVector::one(i),\n         };\n         self.cx.path.pop();\n         res\n     }\n \n-    fn fold_mod(&mut self, m: &ast::Mod) -> ast::Mod {\n+    fn fold_mod(&mut self, m: ast::Mod) -> ast::Mod {\n         let tests = mem::replace(&mut self.tests, Vec::new());\n         let tested_submods = mem::replace(&mut self.tested_submods, Vec::new());\n         let mut mod_folded = fold::noop_fold_mod(m, self);\n@@ -155,22 +155,25 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n         // Remove any #[main] from the AST so it doesn't clash with\n         // the one we're going to add. Only if compiling an executable.\n \n-        fn nomain(item: Gc<ast::Item>) -> Gc<ast::Item> {\n-            box(GC) ast::Item {\n-                attrs: item.attrs.iter().filter_map(|attr| {\n-                    if !attr.check_name(\"main\") {\n-                        Some(*attr)\n-                    } else {\n-                        None\n-                    }\n-                }).collect(),\n-                .. (*item).clone()\n-            }\n-        }\n+        mod_folded.items = mem::replace(&mut mod_folded.items, vec![]).move_map(|item| {\n+            item.map(|ast::Item {id, ident, attrs, node, vis, span}| {\n+                ast::Item {\n+                    id: id,\n+                    ident: ident,\n+                    attrs: attrs.move_iter().filter_map(|attr| {\n+                        if !attr.check_name(\"main\") {\n+                            Some(attr)\n+                        } else {\n+                            None\n+                        }\n+                    }).collect(),\n+                    node: node,\n+                    vis: vis,\n+                    span: span\n+                }\n+            })\n+        });\n \n-        for i in mod_folded.items.mut_iter() {\n-            *i = nomain(*i);\n-        }\n         if !tests.is_empty() || !tested_submods.is_empty() {\n             let (it, sym) = mk_reexport_mod(&mut self.cx, tests, tested_submods);\n             mod_folded.items.push(it);\n@@ -188,7 +191,7 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n }\n \n fn mk_reexport_mod(cx: &mut TestCtxt, tests: Vec<ast::Ident>,\n-                   tested_submods: Vec<(ast::Ident, ast::Ident)>) -> (Gc<ast::Item>, ast::Ident) {\n+                   tested_submods: Vec<(ast::Ident, ast::Ident)>) -> (P<ast::Item>, ast::Ident) {\n     let mut view_items = Vec::new();\n     let super_ = token::str_to_ident(\"super\");\n \n@@ -208,14 +211,14 @@ fn mk_reexport_mod(cx: &mut TestCtxt, tests: Vec<ast::Ident>,\n     };\n \n     let sym = token::gensym_ident(\"__test_reexports\");\n-    let it = box(GC) ast::Item {\n+    let it = P(ast::Item {\n         ident: sym.clone(),\n         attrs: Vec::new(),\n         id: ast::DUMMY_NODE_ID,\n         node: ast::ItemMod(reexport_mod),\n         vis: ast::Public,\n         span: DUMMY_SP,\n-    };\n+    });\n \n     (it, sym)\n }\n@@ -266,10 +269,10 @@ fn strip_test_functions(krate: ast::Crate) -> ast::Crate {\n     })\n }\n \n-fn is_test_fn(cx: &TestCtxt, i: Gc<ast::Item>) -> bool {\n+fn is_test_fn(cx: &TestCtxt, i: &ast::Item) -> bool {\n     let has_test_attr = attr::contains_name(i.attrs.as_slice(), \"test\");\n \n-    fn has_test_signature(i: Gc<ast::Item>) -> bool {\n+    fn has_test_signature(i: &ast::Item) -> bool {\n         match &i.node {\n           &ast::ItemFn(ref decl, _, _, ref generics, _) => {\n             let no_output = match decl.output.node {\n@@ -295,10 +298,10 @@ fn is_test_fn(cx: &TestCtxt, i: Gc<ast::Item>) -> bool {\n     return has_test_attr && has_test_signature(i);\n }\n \n-fn is_bench_fn(cx: &TestCtxt, i: Gc<ast::Item>) -> bool {\n+fn is_bench_fn(cx: &TestCtxt, i: &ast::Item) -> bool {\n     let has_bench_attr = attr::contains_name(i.attrs.as_slice(), \"bench\");\n \n-    fn has_test_signature(i: Gc<ast::Item>) -> bool {\n+    fn has_test_signature(i: &ast::Item) -> bool {\n         match i.node {\n             ast::ItemFn(ref decl, _, _, ref generics, _) => {\n                 let input_cnt = decl.inputs.len();\n@@ -325,19 +328,19 @@ fn is_bench_fn(cx: &TestCtxt, i: Gc<ast::Item>) -> bool {\n     return has_bench_attr && has_test_signature(i);\n }\n \n-fn is_ignored(cx: &TestCtxt, i: Gc<ast::Item>) -> bool {\n+fn is_ignored(cx: &TestCtxt, i: &ast::Item) -> bool {\n     i.attrs.iter().any(|attr| {\n         // check ignore(cfg(foo, bar))\n         attr.check_name(\"ignore\") && match attr.meta_item_list() {\n             Some(ref cfgs) => {\n-                attr::test_cfg(cx.config.as_slice(), cfgs.iter().map(|x| *x))\n+                attr::test_cfg(cx.config.as_slice(), cfgs.iter())\n             }\n             None => true\n         }\n     })\n }\n \n-fn should_fail(i: Gc<ast::Item>) -> bool {\n+fn should_fail(i: &ast::Item) -> bool {\n     attr::contains_name(i.attrs.as_slice(), \"should_fail\")\n }\n \n@@ -362,9 +365,9 @@ fn mk_std(cx: &TestCtxt) -> ast::ViewItem {\n     let id_test = token::str_to_ident(\"test\");\n     let (vi, vis) = if cx.is_test_crate {\n         (ast::ViewItemUse(\n-            box(GC) nospan(ast::ViewPathSimple(id_test,\n-                                        path_node(vec!(id_test)),\n-                                        ast::DUMMY_NODE_ID))),\n+            P(nospan(ast::ViewPathSimple(id_test,\n+                                         path_node(vec!(id_test)),\n+                                         ast::DUMMY_NODE_ID)))),\n          ast::Public)\n     } else {\n         (ast::ViewItemExternCrate(id_test, None, ast::DUMMY_NODE_ID),\n@@ -378,7 +381,7 @@ fn mk_std(cx: &TestCtxt) -> ast::ViewItem {\n     }\n }\n \n-fn mk_test_module(cx: &mut TestCtxt) -> (Gc<ast::Item>, Option<ast::ViewItem>) {\n+fn mk_test_module(cx: &mut TestCtxt) -> (P<ast::Item>, Option<ast::ViewItem>) {\n     // Link to test crate\n     let view_items = vec!(mk_std(cx));\n \n@@ -421,7 +424,7 @@ fn mk_test_module(cx: &mut TestCtxt) -> (Gc<ast::Item>, Option<ast::ViewItem>) {\n                                        ast::DUMMY_NODE_ID));\n \n         ast::ViewItem {\n-            node: ast::ViewItemUse(box(GC) use_path),\n+            node: ast::ViewItemUse(P(use_path)),\n             attrs: vec![],\n             vis: ast::Inherited,\n             span: DUMMY_SP\n@@ -430,7 +433,7 @@ fn mk_test_module(cx: &mut TestCtxt) -> (Gc<ast::Item>, Option<ast::ViewItem>) {\n \n     debug!(\"Synthetic test module:\\n{}\\n\", pprust::item_to_string(&item));\n \n-    (box(GC) item, reexport)\n+    (P(item), reexport)\n }\n \n fn nospan<T>(t: T) -> codemap::Spanned<T> {\n@@ -449,7 +452,7 @@ fn path_node(ids: Vec<ast::Ident> ) -> ast::Path {\n     }\n }\n \n-fn mk_tests(cx: &TestCtxt) -> Gc<ast::Item> {\n+fn mk_tests(cx: &TestCtxt) -> P<ast::Item> {\n     // The vector of test_descs for this crate\n     let test_descs = mk_test_descs(cx);\n \n@@ -483,24 +486,24 @@ fn is_test_crate(krate: &ast::Crate) -> bool {\n     }\n }\n \n-fn mk_test_descs(cx: &TestCtxt) -> Gc<ast::Expr> {\n+fn mk_test_descs(cx: &TestCtxt) -> P<ast::Expr> {\n     debug!(\"building test vector from {} tests\", cx.testfns.len());\n \n-    box(GC) ast::Expr {\n+    P(ast::Expr {\n         id: ast::DUMMY_NODE_ID,\n         node: ast::ExprAddrOf(ast::MutImmutable,\n-            box(GC) ast::Expr {\n+            P(ast::Expr {\n                 id: ast::DUMMY_NODE_ID,\n                 node: ast::ExprVec(cx.testfns.iter().map(|test| {\n                     mk_test_desc_and_fn_rec(cx, test)\n-            }).collect()),\n-            span: DUMMY_SP,\n-        }),\n+                }).collect()),\n+                span: DUMMY_SP,\n+            })),\n         span: DUMMY_SP,\n-    }\n+    })\n }\n \n-fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> Gc<ast::Expr> {\n+fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> P<ast::Expr> {\n     // FIXME #15962: should be using quote_expr, but that stringifies\n     // __test_reexports, causing it to be reinterned, losing the\n     // gensym information."}, {"sha": "fd643a70c7b95b71ffe371504f7f5f9c10af5373", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -119,7 +119,6 @@ pub mod front {\n     pub mod config;\n     pub mod test;\n     pub mod std_inject;\n-    pub mod assign_node_ids_and_map;\n     pub mod feature_gate;\n     pub mod show_span;\n }"}, {"sha": "58c05bee443737b51279bd4ac69426b1df5faca9", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 41, "deletions": 40, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -36,15 +36,16 @@ use lint::{Context, LintPass, LintArray};\n \n use std::cmp;\n use std::collections::HashMap;\n+use std::slice;\n use std::{i8, i16, i32, i64, u8, u16, u32, u64, f32, f64};\n-use std::gc::Gc;\n use syntax::abi;\n use syntax::ast_map;\n use syntax::attr::AttrMetaMethods;\n use syntax::attr;\n use syntax::codemap::Span;\n use syntax::parse::token;\n use syntax::{ast, ast_util, visit};\n+use syntax::ptr::P;\n use syntax::visit::Visitor;\n \n declare_lint!(WHILE_TRUE, Warn,\n@@ -59,9 +60,9 @@ impl LintPass for WhileTrue {\n \n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n         match e.node {\n-            ast::ExprWhile(cond, _, _) => {\n+            ast::ExprWhile(ref cond, _, _) => {\n                 match cond.node {\n-                    ast::ExprLit(lit) => {\n+                    ast::ExprLit(ref lit) => {\n                         match lit.node {\n                             ast::LitBool(true) => {\n                                 cx.span_lint(WHILE_TRUE, e.span,\n@@ -91,9 +92,9 @@ impl LintPass for UnusedCasts {\n \n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n         match e.node {\n-            ast::ExprCast(expr, ty) => {\n-                let t_t = ast_ty_to_ty(cx, &infer::new_infer_ctxt(cx.tcx), &*ty);\n-                if ty::get(ty::expr_ty(cx.tcx, &*expr)).sty == ty::get(t_t).sty {\n+            ast::ExprCast(ref expr, ref ty) => {\n+                let t_t = ast_ty_to_ty(cx, &infer::new_infer_ctxt(cx.tcx), &**ty);\n+                if ty::get(ty::expr_ty(cx.tcx, &**expr)).sty == ty::get(t_t).sty {\n                     cx.span_lint(UNNECESSARY_TYPECAST, ty.span, \"unnecessary type cast\");\n                 }\n             }\n@@ -131,9 +132,9 @@ impl LintPass for TypeLimits {\n \n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n         match e.node {\n-            ast::ExprUnary(ast::UnNeg, expr) => {\n+            ast::ExprUnary(ast::UnNeg, ref expr) => {\n                 match expr.node  {\n-                    ast::ExprLit(lit) => {\n+                    ast::ExprLit(ref lit) => {\n                         match lit.node {\n                             ast::LitInt(_, ast::UnsignedIntLit(_)) => {\n                                 cx.span_lint(UNSIGNED_NEGATE, e.span,\n@@ -144,7 +145,7 @@ impl LintPass for TypeLimits {\n                         }\n                     },\n                     _ => {\n-                        let t = ty::expr_ty(cx.tcx, &*expr);\n+                        let t = ty::expr_ty(cx.tcx, &**expr);\n                         match ty::get(t).sty {\n                             ty::ty_uint(_) => {\n                                 cx.span_lint(UNSIGNED_NEGATE, e.span,\n@@ -160,16 +161,16 @@ impl LintPass for TypeLimits {\n                     self.negated_expr_id = expr.id;\n                 }\n             },\n-            ast::ExprParen(expr) if self.negated_expr_id == e.id => {\n+            ast::ExprParen(ref expr) if self.negated_expr_id == e.id => {\n                 self.negated_expr_id = expr.id;\n             },\n-            ast::ExprBinary(binop, l, r) => {\n-                if is_comparison(binop) && !check_limits(cx.tcx, binop, &*l, &*r) {\n+            ast::ExprBinary(binop, ref l, ref r) => {\n+                if is_comparison(binop) && !check_limits(cx.tcx, binop, &**l, &**r) {\n                     cx.span_lint(TYPE_LIMITS, e.span,\n                                  \"comparison is useless due to type limits\");\n                 }\n             },\n-            ast::ExprLit(lit) => {\n+            ast::ExprLit(ref lit) => {\n                 match ty::get(ty::expr_ty(cx.tcx, e)).sty {\n                     ty::ty_int(t) => {\n                         match lit.node {\n@@ -292,7 +293,7 @@ impl LintPass for TypeLimits {\n                 ty::ty_int(int_ty) => {\n                     let (min, max) = int_ty_range(int_ty);\n                     let lit_val: i64 = match lit.node {\n-                        ast::ExprLit(li) => match li.node {\n+                        ast::ExprLit(ref li) => match li.node {\n                             ast::LitInt(v, ast::SignedIntLit(_, ast::Plus)) |\n                             ast::LitInt(v, ast::UnsuffixedIntLit(ast::Plus)) => v as i64,\n                             ast::LitInt(v, ast::SignedIntLit(_, ast::Minus)) |\n@@ -306,7 +307,7 @@ impl LintPass for TypeLimits {\n                 ty::ty_uint(uint_ty) => {\n                     let (min, max): (u64, u64) = uint_ty_range(uint_ty);\n                     let lit_val: u64 = match lit.node {\n-                        ast::ExprLit(li) => match li.node {\n+                        ast::ExprLit(ref li) => match li.node {\n                             ast::LitInt(v, _) => v,\n                             _ => return true\n                         },\n@@ -400,8 +401,8 @@ impl LintPass for CTypes {\n             ast::ItemForeignMod(ref nmod) if nmod.abi != abi::RustIntrinsic => {\n                 for ni in nmod.items.iter() {\n                     match ni.node {\n-                        ast::ForeignItemFn(decl, _) => check_foreign_fn(cx, &*decl),\n-                        ast::ForeignItemStatic(t, _) => check_ty(cx, &*t)\n+                        ast::ForeignItemFn(ref decl, _) => check_foreign_fn(cx, &**decl),\n+                        ast::ForeignItemStatic(ref t, _) => check_ty(cx, &**t)\n                     }\n                 }\n             }\n@@ -477,7 +478,7 @@ impl LintPass for HeapMemory {\n \n         // If it's a struct, we also have to check the fields' types\n         match it.node {\n-            ast::ItemStruct(struct_def, _) => {\n+            ast::ItemStruct(ref struct_def, _) => {\n                 for struct_field in struct_def.fields.iter() {\n                     self.check_heap_type(cx, struct_field.span,\n                                          ty::node_id_to_type(cx.tcx, struct_field.node.id));\n@@ -658,7 +659,7 @@ impl LintPass for PathStatement {\n \n     fn check_stmt(&mut self, cx: &Context, s: &ast::Stmt) {\n         match s.node {\n-            ast::StmtSemi(expr, _) => {\n+            ast::StmtSemi(ref expr, _) => {\n                 match expr.node {\n                     ast::ExprPath(_) => cx.span_lint(PATH_STATEMENT, s.span,\n                                                      \"path statement with no effect\"),\n@@ -685,10 +686,10 @@ impl LintPass for UnusedResult {\n \n     fn check_stmt(&mut self, cx: &Context, s: &ast::Stmt) {\n         let expr = match s.node {\n-            ast::StmtSemi(expr, _) => expr,\n+            ast::StmtSemi(ref expr, _) => &**expr,\n             _ => return\n         };\n-        let t = ty::expr_ty(cx.tcx, &*expr);\n+        let t = ty::expr_ty(cx.tcx, expr);\n         match ty::get(t).sty {\n             ty::ty_nil | ty::ty_bot | ty::ty_bool => return,\n             _ => {}\n@@ -698,7 +699,7 @@ impl LintPass for UnusedResult {\n             _ => {}\n         }\n \n-        let t = ty::expr_ty(cx.tcx, &*expr);\n+        let t = ty::expr_ty(cx.tcx, expr);\n         let mut warned = false;\n         match ty::get(t).sty {\n             ty::ty_struct(did, _) |\n@@ -1080,29 +1081,29 @@ impl LintPass for UnnecessaryParens {\n \n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n         let (value, msg, struct_lit_needs_parens) = match e.node {\n-            ast::ExprIf(cond, _, _) => (cond, \"`if` condition\", true),\n-            ast::ExprWhile(cond, _, _) => (cond, \"`while` condition\", true),\n-            ast::ExprMatch(head, _) => (head, \"`match` head expression\", true),\n-            ast::ExprRet(Some(value)) => (value, \"`return` value\", false),\n-            ast::ExprAssign(_, value) => (value, \"assigned value\", false),\n-            ast::ExprAssignOp(_, _, value) => (value, \"assigned value\", false),\n+            ast::ExprIf(ref cond, _, _) => (cond, \"`if` condition\", true),\n+            ast::ExprWhile(ref cond, _, _) => (cond, \"`while` condition\", true),\n+            ast::ExprMatch(ref head, _) => (head, \"`match` head expression\", true),\n+            ast::ExprRet(Some(ref value)) => (value, \"`return` value\", false),\n+            ast::ExprAssign(_, ref value) => (value, \"assigned value\", false),\n+            ast::ExprAssignOp(_, _, ref value) => (value, \"assigned value\", false),\n             _ => return\n         };\n-        self.check_unnecessary_parens_core(cx, &*value, msg, struct_lit_needs_parens);\n+        self.check_unnecessary_parens_core(cx, &**value, msg, struct_lit_needs_parens);\n     }\n \n     fn check_stmt(&mut self, cx: &Context, s: &ast::Stmt) {\n         let (value, msg) = match s.node {\n-            ast::StmtDecl(decl, _) => match decl.node {\n-                ast::DeclLocal(local) => match local.init {\n-                    Some(value) => (value, \"assigned value\"),\n+            ast::StmtDecl(ref decl, _) => match decl.node {\n+                ast::DeclLocal(ref local) => match local.init {\n+                    Some(ref value) => (value, \"assigned value\"),\n                     None => return\n                 },\n                 _ => return\n             },\n             _ => return\n         };\n-        self.check_unnecessary_parens_core(cx, &*value, msg, false);\n+        self.check_unnecessary_parens_core(cx, &**value, msg, false);\n     }\n }\n \n@@ -1157,12 +1158,12 @@ declare_lint!(pub UNUSED_MUT, Warn,\n pub struct UnusedMut;\n \n impl UnusedMut {\n-    fn check_unused_mut_pat(&self, cx: &Context, pats: &[Gc<ast::Pat>]) {\n+    fn check_unused_mut_pat(&self, cx: &Context, pats: &[P<ast::Pat>]) {\n         // collect all mutable pattern and group their NodeIDs by their Identifier to\n         // avoid false warnings in match arms with multiple patterns\n         let mut mutables = HashMap::new();\n-        for &p in pats.iter() {\n-            pat_util::pat_bindings(&cx.tcx.def_map, &*p, |mode, id, _, path1| {\n+        for p in pats.iter() {\n+            pat_util::pat_bindings(&cx.tcx.def_map, &**p, |mode, id, _, path1| {\n                 let ident = path1.node;\n                 match mode {\n                     ast::BindByValue(ast::MutMutable) => {\n@@ -1205,10 +1206,10 @@ impl LintPass for UnusedMut {\n \n     fn check_stmt(&mut self, cx: &Context, s: &ast::Stmt) {\n         match s.node {\n-            ast::StmtDecl(d, _) => {\n+            ast::StmtDecl(ref d, _) => {\n                 match d.node {\n-                    ast::DeclLocal(l) => {\n-                        self.check_unused_mut_pat(cx, &[l.pat]);\n+                    ast::DeclLocal(ref l) => {\n+                        self.check_unused_mut_pat(cx, slice::ref_slice(&l.pat));\n                     },\n                     _ => {}\n                 }\n@@ -1221,7 +1222,7 @@ impl LintPass for UnusedMut {\n                 _: visit::FnKind, decl: &ast::FnDecl,\n                 _: &ast::Block, _: Span, _: ast::NodeId) {\n         for a in decl.inputs.iter() {\n-            self.check_unused_mut_pat(cx, &[a.pat]);\n+            self.check_unused_mut_pat(cx, slice::ref_slice(&a.pat));\n         }\n     }\n }"}, {"sha": "4dd944415127e022d0cd4dc6b3a4767dfda31829", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -278,7 +278,7 @@ pub fn gather_attrs(attrs: &[ast::Attribute])\n \n         attr::mark_used(attr);\n \n-        let meta = attr.node.value;\n+        let meta = &attr.node.value;\n         let metas = match meta.node {\n             ast::MetaList(_, ref metas) => metas,\n             _ => {\n@@ -709,8 +709,8 @@ impl LintPass for GatherNodeLevels {\n ///\n /// Consumes the `lint_store` field of the `Session`.\n pub fn check_crate(tcx: &ty::ctxt,\n-                   krate: &ast::Crate,\n                    exported_items: &ExportedItems) {\n+    let krate = tcx.map.krate();\n     let mut cx = Context::new(tcx, krate, exported_items);\n \n     // Visit the whole crate."}, {"sha": "c27f1d9ed1f53387a66bd13a194081b0ee44141b", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -97,18 +97,18 @@ pub fn get_item_path(tcx: &ty::ctxt, def: ast::DefId) -> Vec<ast_map::PathElem>\n         path.as_slice())\n }\n \n-pub enum found_ast {\n-    found(ast::InlinedItem),\n-    found_parent(ast::DefId, ast::InlinedItem),\n+pub enum found_ast<'ast> {\n+    found(&'ast ast::InlinedItem),\n+    found_parent(ast::DefId, &'ast ast::InlinedItem),\n     not_found,\n }\n \n // Finds the AST for this item in the crate metadata, if any.  If the item was\n // not marked for inlining, then the AST will not be present and hence none\n // will be returned.\n-pub fn maybe_get_item_ast(tcx: &ty::ctxt, def: ast::DefId,\n-                          decode_inlined_item: decoder::DecodeInlinedItem)\n-                       -> found_ast {\n+pub fn maybe_get_item_ast<'tcx>(tcx: &ty::ctxt<'tcx>, def: ast::DefId,\n+                                decode_inlined_item: decoder::DecodeInlinedItem)\n+                                -> found_ast<'tcx> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::maybe_get_item_ast(&*cdata, tcx, def.node, decode_inlined_item)"}, {"sha": "bcf9a4f678d0a36c321ec02e2c1ad84d2c59722b", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -30,7 +30,6 @@ use middle::ty;\n use middle::typeck;\n use middle::astencode::vtable_decoder_helpers;\n \n-use std::gc::Gc;\n use std::hash::Hash;\n use std::hash;\n use std::io::extensions::u64_from_be_bytes;\n@@ -48,6 +47,7 @@ use syntax::parse::token;\n use syntax::print::pprust;\n use syntax::ast;\n use syntax::codemap;\n+use syntax::ptr::P;\n \n pub type Cmd<'a> = &'a crate_metadata;\n \n@@ -612,27 +612,28 @@ pub fn get_item_path(cdata: Cmd, id: ast::NodeId) -> Vec<ast_map::PathElem> {\n     item_path(lookup_item(id, cdata.data()))\n }\n \n-pub type DecodeInlinedItem<'a> = |cdata: Cmd,\n-                                  tcx: &ty::ctxt,\n-                                  path: Vec<ast_map::PathElem>,\n-                                  par_doc: rbml::Doc|: 'a\n-                                  -> Result<ast::InlinedItem, Vec<ast_map::PathElem> >;\n+pub type DecodeInlinedItem<'a> = <'tcx> |cdata: Cmd,\n+                                         tcx: &ty::ctxt<'tcx>,\n+                                         path: Vec<ast_map::PathElem>,\n+                                         par_doc: rbml::Doc|: 'a\n+                                         -> Result<&'tcx ast::InlinedItem,\n+                                                   Vec<ast_map::PathElem>>;\n \n-pub fn maybe_get_item_ast(cdata: Cmd, tcx: &ty::ctxt, id: ast::NodeId,\n-                          decode_inlined_item: DecodeInlinedItem)\n-                          -> csearch::found_ast {\n+pub fn maybe_get_item_ast<'tcx>(cdata: Cmd, tcx: &ty::ctxt<'tcx>, id: ast::NodeId,\n+                                decode_inlined_item: DecodeInlinedItem)\n+                                -> csearch::found_ast<'tcx> {\n     debug!(\"Looking up item: {}\", id);\n     let item_doc = lookup_item(id, cdata.data());\n     let path = Vec::from_slice(item_path(item_doc).init());\n     match decode_inlined_item(cdata, tcx, path, item_doc) {\n-        Ok(ref ii) => csearch::found(*ii),\n+        Ok(ii) => csearch::found(ii),\n         Err(path) => {\n             match item_parent_item(item_doc) {\n                 Some(did) => {\n                     let did = translate_def_id(cdata, did);\n                     let parent_item = lookup_item(did.node, cdata.data());\n                     match decode_inlined_item(cdata, tcx, path, parent_item) {\n-                        Ok(ref ii) => csearch::found_parent(did, *ii),\n+                        Ok(ii) => csearch::found_parent(did, ii),\n                         Err(_) => csearch::not_found\n                     }\n                 }\n@@ -1003,8 +1004,8 @@ pub fn get_struct_fields(intr: Rc<IdentInterner>, cdata: Cmd, id: ast::NodeId)\n     result\n }\n \n-fn get_meta_items(md: rbml::Doc) -> Vec<Gc<ast::MetaItem>> {\n-    let mut items: Vec<Gc<ast::MetaItem>> = Vec::new();\n+fn get_meta_items(md: rbml::Doc) -> Vec<P<ast::MetaItem>> {\n+    let mut items: Vec<P<ast::MetaItem>> = Vec::new();\n     reader::tagged_docs(md, tag_meta_item_word, |meta_item_doc| {\n         let nd = reader::get_doc(meta_item_doc, tag_meta_item_name);\n         let n = token::intern_and_get_ident(nd.as_str_slice());\n@@ -1043,7 +1044,7 @@ fn get_attributes(md: rbml::Doc) -> Vec<ast::Attribute> {\n             // Currently it's only possible to have a single meta item on\n             // an attribute\n             assert_eq!(meta_items.len(), 1u);\n-            let meta_item = *meta_items.get(0);\n+            let meta_item = meta_items.move_iter().nth(0).unwrap();\n             attrs.push(\n                 codemap::Spanned {\n                     node: ast::Attribute_ {"}, {"sha": "376cccc3f10fc2c9646800136d725b0cee3f6cab", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 38, "deletions": 72, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -29,7 +29,6 @@ use util::nodemap::{NodeMap, NodeSet};\n \n use serialize::Encodable;\n use std::cell::RefCell;\n-use std::gc::Gc;\n use std::hash::Hash;\n use std::hash;\n use std::mem;\n@@ -46,6 +45,7 @@ use syntax::attr::AttrMetaMethods;\n use syntax::diagnostic::SpanHandler;\n use syntax::parse::token::special_idents;\n use syntax::parse::token;\n+use syntax::ptr::P;\n use syntax::visit::Visitor;\n use syntax::visit;\n use syntax;\n@@ -55,16 +55,11 @@ use rbml::io::SeekableMemWriter;\n /// A borrowed version of `ast::InlinedItem`.\n pub enum InlinedItemRef<'a> {\n     IIItemRef(&'a ast::Item),\n-    IITraitItemRef(ast::DefId, InlinedTraitItemRef<'a>),\n+    IITraitItemRef(ast::DefId, &'a ast::TraitItem),\n+    IIImplItemRef(ast::DefId, &'a ast::ImplItem),\n     IIForeignRef(&'a ast::ForeignItem)\n }\n \n-/// A borrowed version of `ast::InlinedTraitItem`.\n-pub enum InlinedTraitItemRef<'a> {\n-    ProvidedInlinedTraitItemRef(&'a Method),\n-    RequiredInlinedTraitItemRef(&'a Method),\n-}\n-\n pub type Encoder<'a> = writer::Encoder<'a, SeekableMemWriter>;\n \n pub type EncodeInlinedItem<'a> = |ecx: &EncodeContext,\n@@ -507,7 +502,7 @@ fn encode_reexported_static_methods(ecx: &EncodeContext,\n /// * For enums, iterates through the node IDs of the variants.\n ///\n /// * For newtype structs, iterates through the node ID of the constructor.\n-fn each_auxiliary_node_id(item: Gc<Item>, callback: |NodeId| -> bool) -> bool {\n+fn each_auxiliary_node_id(item: &Item, callback: |NodeId| -> bool) -> bool {\n     let mut continue_ = true;\n     match item.node {\n         ItemEnum(ref enum_def, _) => {\n@@ -518,7 +513,7 @@ fn each_auxiliary_node_id(item: Gc<Item>, callback: |NodeId| -> bool) -> bool {\n                 }\n             }\n         }\n-        ItemStruct(struct_def, _) => {\n+        ItemStruct(ref struct_def, _) => {\n             // If this is a newtype struct, return the constructor.\n             match struct_def.ctor_id {\n                 Some(ctor_id) if struct_def.fields.len() > 0 &&\n@@ -587,7 +582,7 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n         rbml_w.wr_str(def_to_string(local_def(item.id)).as_slice());\n         rbml_w.end_tag();\n \n-        each_auxiliary_node_id(*item, |auxiliary_node_id| {\n+        each_auxiliary_node_id(&**item, |auxiliary_node_id| {\n             rbml_w.start_tag(tag_mod_child);\n             rbml_w.wr_str(def_to_string(local_def(\n                         auxiliary_node_id)).as_slice());\n@@ -858,7 +853,7 @@ fn encode_info_for_method(ecx: &EncodeContext,\n                           impl_path: PathElems,\n                           is_default_impl: bool,\n                           parent_id: NodeId,\n-                          ast_method_opt: Option<Gc<Method>>) {\n+                          ast_item_opt: Option<&ImplItem>) {\n \n     debug!(\"encode_info_for_method: {:?} {}\", m.def_id,\n            token::get_ident(m.ident));\n@@ -877,26 +872,20 @@ fn encode_info_for_method(ecx: &EncodeContext,\n \n     let elem = ast_map::PathName(m.ident.name);\n     encode_path(rbml_w, impl_path.chain(Some(elem).move_iter()));\n-    match ast_method_opt {\n-        Some(ast_method) => {\n-            encode_attributes(rbml_w, ast_method.attrs.as_slice())\n-        }\n-        None => ()\n-    }\n-\n-    for &ast_method in ast_method_opt.iter() {\n-        let any_types = !pty.generics.types.is_empty();\n-        if any_types || is_default_impl || should_inline(ast_method.attrs.as_slice()) {\n-            encode_inlined_item(ecx,\n-                                rbml_w,\n-                                IITraitItemRef(local_def(parent_id),\n-                                               RequiredInlinedTraitItemRef(\n-                                                   &*ast_method)));\n-        }\n-        if !any_types {\n-            encode_symbol(ecx, rbml_w, m.def_id.node);\n+    match ast_item_opt {\n+        Some(&ast::MethodImplItem(ref ast_method)) => {\n+            encode_attributes(rbml_w, ast_method.attrs.as_slice());\n+            let any_types = !pty.generics.types.is_empty();\n+            if any_types || is_default_impl || should_inline(ast_method.attrs.as_slice()) {\n+                encode_inlined_item(ecx, rbml_w, IIImplItemRef(local_def(parent_id),\n+                                                               ast_item_opt.unwrap()));\n+            }\n+            if !any_types {\n+                encode_symbol(ecx, rbml_w, m.def_id.node);\n+            }\n+            encode_method_argument_names(rbml_w, ast_method.pe_fn_decl());\n         }\n-        encode_method_argument_names(rbml_w, &*ast_method.pe_fn_decl());\n+        None => {}\n     }\n \n     rbml_w.end_tag();\n@@ -1127,7 +1116,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                                  (*enum_definition).variants.as_slice(),\n                                  index);\n       }\n-      ItemStruct(struct_def, _) => {\n+      ItemStruct(ref struct_def, _) => {\n         let fields = ty::lookup_struct_fields(tcx, def_id);\n \n         /* First, encode the fields\n@@ -1178,7 +1167,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             None => {}\n         }\n       }\n-      ItemImpl(_, ref opt_trait, ty, ref ast_items) => {\n+      ItemImpl(_, ref opt_trait, ref ty, ref ast_items) => {\n         // We need to encode information about the default methods we\n         // have inherited, so we drive this based on the impl structure.\n         let impl_items = tcx.impl_items.borrow();\n@@ -1228,7 +1217,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         let num_implemented_methods = ast_items.len();\n         for (i, &trait_item_def_id) in items.iter().enumerate() {\n             let ast_item = if i < num_implemented_methods {\n-                Some(*ast_items.get(i))\n+                Some(ast_items.get(i))\n             } else {\n                 None\n             };\n@@ -1238,29 +1227,10 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                 pos: rbml_w.writer.tell().unwrap(),\n             });\n \n-            let trait_item_type =\n+            let ty::MethodTraitItem(method_type) =\n                 ty::impl_or_trait_item(tcx, trait_item_def_id.def_id());\n-            match (trait_item_type, ast_item) {\n-                (ty::MethodTraitItem(method_type),\n-                 Some(ast::MethodImplItem(ast_method))) => {\n-                    encode_info_for_method(ecx,\n-                                           rbml_w,\n-                                           &*method_type,\n-                                           path.clone(),\n-                                           false,\n-                                           item.id,\n-                                           Some(ast_method))\n-                }\n-                (ty::MethodTraitItem(method_type), None) => {\n-                    encode_info_for_method(ecx,\n-                                           rbml_w,\n-                                           &*method_type,\n-                                           path.clone(),\n-                                           false,\n-                                           item.id,\n-                                           None)\n-                }\n-            }\n+            encode_info_for_method(ecx, rbml_w, &*method_type, path.clone(),\n+                                   false, item.id, ast_item)\n         }\n       }\n       ItemTrait(_, _, _, ref ms) => {\n@@ -1345,15 +1315,16 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                         }\n                     }\n \n-                    match ms.get(i) {\n-                        &RequiredMethod(ref tm) => {\n+                    let trait_item = ms.get(i);\n+                    match *trait_item {\n+                        RequiredMethod(ref tm) => {\n                             encode_attributes(rbml_w, tm.attrs.as_slice());\n                             encode_item_sort(rbml_w, 'r');\n                             encode_parent_sort(rbml_w, 't');\n                             encode_method_argument_names(rbml_w, &*tm.decl);\n                         }\n \n-                        &ProvidedMethod(m) => {\n+                        ProvidedMethod(ref m) => {\n                             encode_attributes(rbml_w, m.attrs.as_slice());\n                             // If this is a static method, we've already\n                             // encoded this.\n@@ -1366,14 +1337,9 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                             }\n                             encode_item_sort(rbml_w, 'p');\n                             encode_parent_sort(rbml_w, 't');\n-                            encode_inlined_item(\n-                                ecx,\n-                                rbml_w,\n-                                IITraitItemRef(\n-                                    def_id,\n-                                    ProvidedInlinedTraitItemRef(&*m)));\n-                            encode_method_argument_names(rbml_w,\n-                                                         &*m.pe_fn_decl());\n+                            encode_inlined_item(ecx, rbml_w,\n+                                                IITraitItemRef(def_id, trait_item));\n+                            encode_method_argument_names(rbml_w, &*m.pe_fn_decl());\n                         }\n                     }\n                 }\n@@ -1571,7 +1537,7 @@ fn write_i64(writer: &mut SeekableMemWriter, &n: &i64) {\n     wr.write_be_u32(n as u32);\n }\n \n-fn encode_meta_item(rbml_w: &mut Encoder, mi: Gc<MetaItem>) {\n+fn encode_meta_item(rbml_w: &mut Encoder, mi: &MetaItem) {\n     match mi.node {\n       MetaWord(ref name) => {\n         rbml_w.start_tag(tag_meta_item_word);\n@@ -1601,7 +1567,7 @@ fn encode_meta_item(rbml_w: &mut Encoder, mi: Gc<MetaItem>) {\n         rbml_w.writer.write(name.get().as_bytes());\n         rbml_w.end_tag();\n         for inner_item in items.iter() {\n-            encode_meta_item(rbml_w, *inner_item);\n+            encode_meta_item(rbml_w, &**inner_item);\n         }\n         rbml_w.end_tag();\n       }\n@@ -1613,7 +1579,7 @@ fn encode_attributes(rbml_w: &mut Encoder, attrs: &[Attribute]) {\n     for attr in attrs.iter() {\n         rbml_w.start_tag(tag_attribute);\n         rbml_w.wr_tagged_u8(tag_attribute_is_sugared_doc, attr.node.is_sugared_doc as u8);\n-        encode_meta_item(rbml_w, attr.node.value);\n+        encode_meta_item(rbml_w, &*attr.node.value);\n         rbml_w.end_tag();\n     }\n     rbml_w.end_tag();\n@@ -1852,12 +1818,12 @@ fn encode_misc_info(ecx: &EncodeContext,\n                     rbml_w: &mut Encoder) {\n     rbml_w.start_tag(tag_misc_info);\n     rbml_w.start_tag(tag_misc_info_crate_items);\n-    for &item in krate.module.items.iter() {\n+    for item in krate.module.items.iter() {\n         rbml_w.start_tag(tag_mod_child);\n         rbml_w.wr_str(def_to_string(local_def(item.id)).as_slice());\n         rbml_w.end_tag();\n \n-        each_auxiliary_node_id(item, |auxiliary_node_id| {\n+        each_auxiliary_node_id(&**item, |auxiliary_node_id| {\n             rbml_w.start_tag(tag_mod_child);\n             rbml_w.wr_str(def_to_string(local_def(\n                         auxiliary_node_id)).as_slice());"}, {"sha": "2dab3c2b1da02b488313106eefa0936a2d6bb6aa", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 263, "deletions": 287, "changes": 550, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -36,6 +36,7 @@ use syntax::ast_util::PostExpansionMethod;\n use syntax::codemap::Span;\n use syntax::fold::Folder;\n use syntax::parse::token;\n+use syntax::ptr::P;\n use syntax;\n \n use libc;\n@@ -52,25 +53,20 @@ use serialize::{EncoderHelpers};\n \n #[cfg(test)] use syntax::parse;\n #[cfg(test)] use syntax::print::pprust;\n-#[cfg(test)] use std::gc::Gc;\n \n-struct DecodeContext<'a, 'tcx: 'a> {\n-    cdata: &'a cstore::crate_metadata,\n+struct DecodeContext<'a, 'b, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n-}\n-\n-struct ExtendedDecodeContext<'a, 'tcx: 'a> {\n-    dcx: &'a DecodeContext<'a, 'tcx>,\n+    cdata: &'b cstore::crate_metadata,\n     from_id_range: ast_util::IdRange,\n     to_id_range: ast_util::IdRange\n }\n \n trait tr {\n-    fn tr(&self, xcx: &ExtendedDecodeContext) -> Self;\n+    fn tr(&self, dcx: &DecodeContext) -> Self;\n }\n \n trait tr_intern {\n-    fn tr_intern(&self, xcx: &ExtendedDecodeContext) -> ast::DefId;\n+    fn tr_intern(&self, dcx: &DecodeContext) -> ast::DefId;\n }\n \n pub type Encoder<'a> = writer::Encoder<'a, SeekableMemWriter>;\n@@ -84,19 +80,21 @@ pub fn encode_inlined_item(ecx: &e::EncodeContext,\n     let id = match ii {\n         e::IIItemRef(i) => i.id,\n         e::IIForeignRef(i) => i.id,\n-        e::IITraitItemRef(_, e::ProvidedInlinedTraitItemRef(m)) => m.id,\n-        e::IITraitItemRef(_, e::RequiredInlinedTraitItemRef(m)) => m.id,\n+        e::IITraitItemRef(_, &ast::ProvidedMethod(ref m)) => m.id,\n+        e::IITraitItemRef(_, &ast::RequiredMethod(ref m)) => m.id,\n+        e::IIImplItemRef(_, &ast::MethodImplItem(ref m)) => m.id\n     };\n     debug!(\"> Encoding inlined item: {} ({})\",\n            ecx.tcx.map.path_to_string(id),\n            rbml_w.writer.tell());\n \n+    // Folding could be avoided with a smarter encoder.\n     let ii = simplify_ast(ii);\n     let id_range = ast_util::compute_id_range_for_inlined_item(&ii);\n \n     rbml_w.start_tag(c::tag_ast as uint);\n     id_range.encode(rbml_w);\n-    encode_ast(rbml_w, ii);\n+    encode_ast(rbml_w, &ii);\n     encode_side_tables_for_ii(ecx, rbml_w, &ii);\n     rbml_w.end_tag();\n \n@@ -105,15 +103,28 @@ pub fn encode_inlined_item(ecx: &e::EncodeContext,\n            rbml_w.writer.tell());\n }\n \n-pub fn decode_inlined_item(cdata: &cstore::crate_metadata,\n-                           tcx: &ty::ctxt,\n-                           path: Vec<ast_map::PathElem>,\n-                           par_doc: rbml::Doc)\n-                           -> Result<ast::InlinedItem, Vec<ast_map::PathElem>> {\n-    let dcx = &DecodeContext {\n-        cdata: cdata,\n-        tcx: tcx,\n-    };\n+impl<'a, 'b, 'c, 'tcx> ast_map::FoldOps for &'a DecodeContext<'b, 'c, 'tcx> {\n+    fn new_id(&self, id: ast::NodeId) -> ast::NodeId {\n+        if id == ast::DUMMY_NODE_ID {\n+            // Used by ast_map to map the NodeInlinedParent.\n+            self.tcx.sess.next_node_id()\n+        } else {\n+            self.tr_id(id)\n+        }\n+    }\n+    fn new_def_id(&self, def_id: ast::DefId) -> ast::DefId {\n+        self.tr_def_id(def_id)\n+    }\n+    fn new_span(&self, span: Span) -> Span {\n+        self.tr_span(span)\n+    }\n+}\n+\n+pub fn decode_inlined_item<'tcx>(cdata: &cstore::crate_metadata,\n+                                 tcx: &ty::ctxt<'tcx>,\n+                                 path: Vec<ast_map::PathElem>,\n+                                 par_doc: rbml::Doc)\n+                                 -> Result<&'tcx ast::InlinedItem, Vec<ast_map::PathElem>> {\n     match par_doc.opt_child(c::tag_ast) {\n       None => Err(path),\n       Some(ast_doc) => {\n@@ -127,34 +138,41 @@ pub fn decode_inlined_item(cdata: &cstore::crate_metadata,\n         });\n         let mut ast_dsr = reader::Decoder::new(ast_doc);\n         let from_id_range = Decodable::decode(&mut ast_dsr).unwrap();\n-        let to_id_range = reserve_id_range(&dcx.tcx.sess, from_id_range);\n-        let xcx = &ExtendedDecodeContext {\n-            dcx: dcx,\n+        let to_id_range = reserve_id_range(&tcx.sess, from_id_range);\n+        let dcx = &DecodeContext {\n+            cdata: cdata,\n+            tcx: tcx,\n             from_id_range: from_id_range,\n             to_id_range: to_id_range\n         };\n         let raw_ii = decode_ast(ast_doc);\n-        let ii = renumber_and_map_ast(xcx, &dcx.tcx.map, path, raw_ii);\n-        let ident = match ii {\n-            ast::IIItem(i) => i.ident,\n-            ast::IIForeign(i) => i.ident,\n-            ast::IITraitItem(_, iti) => {\n-                match iti {\n-                    ast::ProvidedInlinedTraitItem(m) => m.pe_ident(),\n-                    ast::RequiredInlinedTraitItem(m) => m.pe_ident(),\n+        let ii = ast_map::map_decoded_item(&dcx.tcx.map, path, raw_ii, dcx);\n+\n+        let ident = match *ii {\n+            ast::IIItem(ref i) => i.ident,\n+            ast::IIForeign(ref i) => i.ident,\n+            ast::IITraitItem(_, ref ti) => {\n+                match *ti {\n+                    ast::ProvidedMethod(ref m) => m.pe_ident(),\n+                    ast::RequiredMethod(ref ty_m) => ty_m.ident\n+                }\n+            },\n+            ast::IIImplItem(_, ref m) => {\n+                match *m {\n+                    ast::MethodImplItem(ref m) => m.pe_ident()\n                 }\n             }\n         };\n         debug!(\"Fn named: {}\", token::get_ident(ident));\n         debug!(\"< Decoded inlined fn: {}::{}\",\n                path_as_str.unwrap(),\n                token::get_ident(ident));\n-        region::resolve_inlined_item(&tcx.sess, &tcx.region_maps, &ii);\n-        decode_side_tables(xcx, ast_doc);\n-        match ii {\n-          ast::IIItem(i) => {\n+        region::resolve_inlined_item(&tcx.sess, &tcx.region_maps, ii);\n+        decode_side_tables(dcx, ast_doc);\n+        match *ii {\n+          ast::IIItem(ref i) => {\n             debug!(\">>> DECODED ITEM >>>\\n{}\\n<<< DECODED ITEM <<<\",\n-                   syntax::print::pprust::item_to_string(&*i));\n+                   syntax::print::pprust::item_to_string(&**i));\n           }\n           _ => { }\n         }\n@@ -176,7 +194,7 @@ fn reserve_id_range(sess: &Session,\n     ast_util::IdRange { min: to_id_min, max: to_id_max }\n }\n \n-impl<'a, 'tcx> ExtendedDecodeContext<'a, 'tcx> {\n+impl<'a, 'b, 'tcx> DecodeContext<'a, 'b, 'tcx> {\n     pub fn tr_id(&self, id: ast::NodeId) -> ast::NodeId {\n         /*!\n          * Translates an internal id, meaning a node id that is known\n@@ -214,7 +232,7 @@ impl<'a, 'tcx> ExtendedDecodeContext<'a, 'tcx> {\n          * `tr_intern_def_id()` below.\n          */\n \n-        decoder::translate_def_id(self.dcx.cdata, did)\n+        decoder::translate_def_id(self.cdata, did)\n     }\n     pub fn tr_intern_def_id(&self, did: ast::DefId) -> ast::DefId {\n         /*!\n@@ -233,26 +251,26 @@ impl<'a, 'tcx> ExtendedDecodeContext<'a, 'tcx> {\n }\n \n impl tr_intern for ast::DefId {\n-    fn tr_intern(&self, xcx: &ExtendedDecodeContext) -> ast::DefId {\n-        xcx.tr_intern_def_id(*self)\n+    fn tr_intern(&self, dcx: &DecodeContext) -> ast::DefId {\n+        dcx.tr_intern_def_id(*self)\n     }\n }\n \n impl tr for ast::DefId {\n-    fn tr(&self, xcx: &ExtendedDecodeContext) -> ast::DefId {\n-        xcx.tr_def_id(*self)\n+    fn tr(&self, dcx: &DecodeContext) -> ast::DefId {\n+        dcx.tr_def_id(*self)\n     }\n }\n \n impl tr for Option<ast::DefId> {\n-    fn tr(&self, xcx: &ExtendedDecodeContext) -> Option<ast::DefId> {\n-        self.map(|d| xcx.tr_def_id(d))\n+    fn tr(&self, dcx: &DecodeContext) -> Option<ast::DefId> {\n+        self.map(|d| dcx.tr_def_id(d))\n     }\n }\n \n impl tr for Span {\n-    fn tr(&self, xcx: &ExtendedDecodeContext) -> Span {\n-        xcx.tr_span(*self)\n+    fn tr(&self, dcx: &DecodeContext) -> Span {\n+        dcx.tr_span(*self)\n     }\n }\n \n@@ -267,18 +285,18 @@ impl<S:serialize::Encoder<E>, E> def_id_encoder_helpers for S {\n }\n \n trait def_id_decoder_helpers {\n-    fn read_def_id(&mut self, xcx: &ExtendedDecodeContext) -> ast::DefId;\n-    fn read_def_id_noxcx(&mut self,\n+    fn read_def_id(&mut self, dcx: &DecodeContext) -> ast::DefId;\n+    fn read_def_id_nodcx(&mut self,\n                          cdata: &cstore::crate_metadata) -> ast::DefId;\n }\n \n impl<D:serialize::Decoder<E>, E> def_id_decoder_helpers for D {\n-    fn read_def_id(&mut self, xcx: &ExtendedDecodeContext) -> ast::DefId {\n+    fn read_def_id(&mut self, dcx: &DecodeContext) -> ast::DefId {\n         let did: ast::DefId = Decodable::decode(self).ok().unwrap();\n-        did.tr(xcx)\n+        did.tr(dcx)\n     }\n \n-    fn read_def_id_noxcx(&mut self,\n+    fn read_def_id_nodcx(&mut self,\n                          cdata: &cstore::crate_metadata) -> ast::DefId {\n         let did: ast::DefId = Decodable::decode(self).ok().unwrap();\n         decoder::translate_def_id(cdata, did)\n@@ -300,7 +318,7 @@ impl<D:serialize::Decoder<E>, E> def_id_decoder_helpers for D {\n // We also have to adjust the spans: for now we just insert a dummy span,\n // but eventually we should add entries to the local codemap as required.\n \n-fn encode_ast(rbml_w: &mut Encoder, item: ast::InlinedItem) {\n+fn encode_ast(rbml_w: &mut Encoder, item: &ast::InlinedItem) {\n     rbml_w.start_tag(c::tag_tree as uint);\n     item.encode(rbml_w);\n     rbml_w.end_tag();\n@@ -309,29 +327,36 @@ fn encode_ast(rbml_w: &mut Encoder, item: ast::InlinedItem) {\n struct NestedItemsDropper;\n \n impl Folder for NestedItemsDropper {\n-    fn fold_block(&mut self, blk: ast::P<ast::Block>) -> ast::P<ast::Block> {\n-        let stmts_sans_items = blk.stmts.iter().filter_map(|stmt| {\n-            match stmt.node {\n-                ast::StmtExpr(_, _) | ast::StmtSemi(_, _) => Some(*stmt),\n-                ast::StmtDecl(decl, _) => {\n-                    match decl.node {\n-                        ast::DeclLocal(_) => Some(*stmt),\n-                        ast::DeclItem(_) => None,\n+    fn fold_block(&mut self, blk: P<ast::Block>) -> P<ast::Block> {\n+        blk.and_then(|ast::Block {id, stmts, expr, rules, span, ..}| {\n+            let stmts_sans_items = stmts.move_iter().filter_map(|stmt| {\n+                let use_stmt = match stmt.node {\n+                    ast::StmtExpr(_, _) | ast::StmtSemi(_, _) => true,\n+                    ast::StmtDecl(ref decl, _) => {\n+                        match decl.node {\n+                            ast::DeclLocal(_) => true,\n+                            ast::DeclItem(_) => false,\n+                        }\n                     }\n+                    ast::StmtMac(..) => fail!(\"unexpanded macro in astencode\")\n+                };\n+                if use_stmt {\n+                    Some(stmt)\n+                } else {\n+                    None\n                 }\n-                ast::StmtMac(..) => fail!(\"unexpanded macro in astencode\")\n-            }\n-        }).collect();\n-        let blk_sans_items = ast::P(ast::Block {\n-            view_items: Vec::new(), // I don't know if we need the view_items\n-                                    // here, but it doesn't break tests!\n-            stmts: stmts_sans_items,\n-            expr: blk.expr,\n-            id: blk.id,\n-            rules: blk.rules,\n-            span: blk.span,\n-        });\n-        fold::noop_fold_block(blk_sans_items, self)\n+            }).collect();\n+            let blk_sans_items = P(ast::Block {\n+                view_items: Vec::new(), // I don't know if we need the view_items\n+                                        // here, but it doesn't break tests!\n+                stmts: stmts_sans_items,\n+                expr: expr,\n+                id: id,\n+                rules: rules,\n+                span: span,\n+            });\n+            fold::noop_fold_block(blk_sans_items, self)\n+        })\n     }\n }\n \n@@ -351,27 +376,35 @@ fn simplify_ast(ii: e::InlinedItemRef) -> ast::InlinedItem {\n     match ii {\n         // HACK we're not dropping items.\n         e::IIItemRef(i) => {\n-            ast::IIItem(fold::noop_fold_item(i, &mut fld)\n+            ast::IIItem(fold::noop_fold_item(P(i.clone()), &mut fld)\n                             .expect_one(\"expected one item\"))\n         }\n-        e::IITraitItemRef(d, iti) => {\n-            ast::IITraitItem(d, match iti {\n-                e::ProvidedInlinedTraitItemRef(m) => {\n-                    ast::ProvidedInlinedTraitItem(\n-                        fold::noop_fold_method(m, &mut fld)\n+        e::IITraitItemRef(d, ti) => {\n+            ast::IITraitItem(d, match *ti {\n+                ast::ProvidedMethod(ref m) => {\n+                    ast::ProvidedMethod(\n+                        fold::noop_fold_method(m.clone(), &mut fld)\n                             .expect_one(\"noop_fold_method must produce \\\n                                          exactly one method\"))\n                 }\n-                e::RequiredInlinedTraitItemRef(m) => {\n-                    ast::RequiredInlinedTraitItem(\n-                        fold::noop_fold_method(m, &mut fld)\n+                ast::RequiredMethod(ref ty_m) => {\n+                    ast::RequiredMethod(\n+                        fold::noop_fold_type_method(ty_m.clone(), &mut fld))\n+                }\n+            })\n+        }\n+        e::IIImplItemRef(d, m) => {\n+            ast::IIImplItem(d, match *m {\n+                ast::MethodImplItem(ref m) => {\n+                    ast::MethodImplItem(\n+                        fold::noop_fold_method(m.clone(), &mut fld)\n                             .expect_one(\"noop_fold_method must produce \\\n                                          exactly one method\"))\n                 }\n             })\n         }\n         e::IIForeignRef(i) => {\n-            ast::IIForeign(fold::noop_fold_foreign_item(i, &mut fld))\n+            ast::IIForeign(fold::noop_fold_foreign_item(P(i.clone()), &mut fld))\n         }\n     }\n }\n@@ -382,114 +415,61 @@ fn decode_ast(par_doc: rbml::Doc) -> ast::InlinedItem {\n     Decodable::decode(&mut d).unwrap()\n }\n \n-struct AstRenumberer<'a, 'tcx: 'a> {\n-    xcx: &'a ExtendedDecodeContext<'a, 'tcx>,\n-}\n-\n-impl<'a, 'tcx> ast_map::FoldOps for AstRenumberer<'a, 'tcx> {\n-    fn new_id(&self, id: ast::NodeId) -> ast::NodeId {\n-        if id == ast::DUMMY_NODE_ID {\n-            // Used by ast_map to map the NodeInlinedParent.\n-            self.xcx.dcx.tcx.sess.next_node_id()\n-        } else {\n-            self.xcx.tr_id(id)\n-        }\n-    }\n-    fn new_span(&self, span: Span) -> Span {\n-        self.xcx.tr_span(span)\n-    }\n-}\n-\n-fn renumber_and_map_ast(xcx: &ExtendedDecodeContext,\n-                        map: &ast_map::Map,\n-                        path: Vec<ast_map::PathElem> ,\n-                        ii: ast::InlinedItem) -> ast::InlinedItem {\n-    ast_map::map_decoded_item(map,\n-                              path.move_iter().collect(),\n-                              AstRenumberer { xcx: xcx },\n-                              |fld| {\n-        match ii {\n-            ast::IIItem(i) => {\n-                ast::IIItem(fld.fold_item(i).expect_one(\"expected one item\"))\n-            }\n-            ast::IITraitItem(d, iti) => {\n-                match iti {\n-                    ast::ProvidedInlinedTraitItem(m) => {\n-                        ast::IITraitItem(\n-                            xcx.tr_def_id(d),\n-                            ast::ProvidedInlinedTraitItem(\n-                                fld.fold_method(m)\n-                                   .expect_one(\"expected one method\")))\n-                    }\n-                    ast::RequiredInlinedTraitItem(m) => {\n-                        ast::IITraitItem(\n-                            xcx.tr_def_id(d),\n-                            ast::RequiredInlinedTraitItem(\n-                                fld.fold_method(m)\n-                                   .expect_one(\"expected one method\")))\n-                    }\n-                }\n-            }\n-            ast::IIForeign(i) => ast::IIForeign(fld.fold_foreign_item(i))\n-        }\n-    })\n-}\n-\n // ______________________________________________________________________\n // Encoding and decoding of ast::def\n \n-fn decode_def(xcx: &ExtendedDecodeContext, doc: rbml::Doc) -> def::Def {\n+fn decode_def(dcx: &DecodeContext, doc: rbml::Doc) -> def::Def {\n     let mut dsr = reader::Decoder::new(doc);\n     let def: def::Def = Decodable::decode(&mut dsr).unwrap();\n-    def.tr(xcx)\n+    def.tr(dcx)\n }\n \n impl tr for def::Def {\n-    fn tr(&self, xcx: &ExtendedDecodeContext) -> def::Def {\n+    fn tr(&self, dcx: &DecodeContext) -> def::Def {\n         match *self {\n-          def::DefFn(did, p) => def::DefFn(did.tr(xcx), p),\n+          def::DefFn(did, p) => def::DefFn(did.tr(dcx), p),\n           def::DefStaticMethod(did, wrapped_did2, p) => {\n-            def::DefStaticMethod(did.tr(xcx),\n+            def::DefStaticMethod(did.tr(dcx),\n                                    match wrapped_did2 {\n                                     def::FromTrait(did2) => {\n-                                        def::FromTrait(did2.tr(xcx))\n+                                        def::FromTrait(did2.tr(dcx))\n                                     }\n                                     def::FromImpl(did2) => {\n-                                        def::FromImpl(did2.tr(xcx))\n+                                        def::FromImpl(did2.tr(dcx))\n                                     }\n                                    },\n                                    p)\n           }\n           def::DefMethod(did0, did1) => {\n-            def::DefMethod(did0.tr(xcx), did1.map(|did1| did1.tr(xcx)))\n+            def::DefMethod(did0.tr(dcx), did1.map(|did1| did1.tr(dcx)))\n           }\n-          def::DefSelfTy(nid) => { def::DefSelfTy(xcx.tr_id(nid)) }\n-          def::DefMod(did) => { def::DefMod(did.tr(xcx)) }\n-          def::DefForeignMod(did) => { def::DefForeignMod(did.tr(xcx)) }\n-          def::DefStatic(did, m) => { def::DefStatic(did.tr(xcx), m) }\n-          def::DefArg(nid, b) => { def::DefArg(xcx.tr_id(nid), b) }\n-          def::DefLocal(nid, b) => { def::DefLocal(xcx.tr_id(nid), b) }\n+          def::DefSelfTy(nid) => { def::DefSelfTy(dcx.tr_id(nid)) }\n+          def::DefMod(did) => { def::DefMod(did.tr(dcx)) }\n+          def::DefForeignMod(did) => { def::DefForeignMod(did.tr(dcx)) }\n+          def::DefStatic(did, m) => { def::DefStatic(did.tr(dcx), m) }\n+          def::DefArg(nid, b) => { def::DefArg(dcx.tr_id(nid), b) }\n+          def::DefLocal(nid, b) => { def::DefLocal(dcx.tr_id(nid), b) }\n           def::DefVariant(e_did, v_did, is_s) => {\n-            def::DefVariant(e_did.tr(xcx), v_did.tr(xcx), is_s)\n+            def::DefVariant(e_did.tr(dcx), v_did.tr(dcx), is_s)\n           },\n-          def::DefTrait(did) => def::DefTrait(did.tr(xcx)),\n-          def::DefTy(did) => def::DefTy(did.tr(xcx)),\n+          def::DefTrait(did) => def::DefTrait(did.tr(dcx)),\n+          def::DefTy(did) => def::DefTy(did.tr(dcx)),\n           def::DefPrimTy(p) => def::DefPrimTy(p),\n-          def::DefTyParam(s, did, v) => def::DefTyParam(s, did.tr(xcx), v),\n-          def::DefBinding(nid, bm) => def::DefBinding(xcx.tr_id(nid), bm),\n-          def::DefUse(did) => def::DefUse(did.tr(xcx)),\n+          def::DefTyParam(s, did, v) => def::DefTyParam(s, did.tr(dcx), v),\n+          def::DefBinding(nid, bm) => def::DefBinding(dcx.tr_id(nid), bm),\n+          def::DefUse(did) => def::DefUse(did.tr(dcx)),\n           def::DefUpvar(nid1, def, nid2, nid3) => {\n-            def::DefUpvar(xcx.tr_id(nid1),\n-                           box(GC) (*def).tr(xcx),\n-                           xcx.tr_id(nid2),\n-                           xcx.tr_id(nid3))\n+            def::DefUpvar(dcx.tr_id(nid1),\n+                           box(GC) (*def).tr(dcx),\n+                           dcx.tr_id(nid2),\n+                           dcx.tr_id(nid3))\n           }\n-          def::DefStruct(did) => def::DefStruct(did.tr(xcx)),\n-          def::DefRegion(nid) => def::DefRegion(xcx.tr_id(nid)),\n+          def::DefStruct(did) => def::DefStruct(did.tr(dcx)),\n+          def::DefRegion(nid) => def::DefRegion(dcx.tr_id(nid)),\n           def::DefTyParamBinder(nid) => {\n-            def::DefTyParamBinder(xcx.tr_id(nid))\n+            def::DefTyParamBinder(dcx.tr_id(nid))\n           }\n-          def::DefLabel(nid) => def::DefLabel(xcx.tr_id(nid))\n+          def::DefLabel(nid) => def::DefLabel(dcx.tr_id(nid))\n         }\n     }\n }\n@@ -498,44 +478,44 @@ impl tr for def::Def {\n // Encoding and decoding of ancillary information\n \n impl tr for ty::Region {\n-    fn tr(&self, xcx: &ExtendedDecodeContext) -> ty::Region {\n+    fn tr(&self, dcx: &DecodeContext) -> ty::Region {\n         match *self {\n             ty::ReLateBound(id, br) => {\n-                ty::ReLateBound(xcx.tr_id(id), br.tr(xcx))\n+                ty::ReLateBound(dcx.tr_id(id), br.tr(dcx))\n             }\n             ty::ReEarlyBound(id, space, index, ident) => {\n-                ty::ReEarlyBound(xcx.tr_id(id), space, index, ident)\n+                ty::ReEarlyBound(dcx.tr_id(id), space, index, ident)\n             }\n             ty::ReScope(id) => {\n-                ty::ReScope(xcx.tr_id(id))\n+                ty::ReScope(dcx.tr_id(id))\n             }\n             ty::ReEmpty | ty::ReStatic | ty::ReInfer(..) => {\n                 *self\n             }\n             ty::ReFree(ref fr) => {\n-                ty::ReFree(ty::FreeRegion {scope_id: xcx.tr_id(fr.scope_id),\n-                                            bound_region: fr.bound_region.tr(xcx)})\n+                ty::ReFree(ty::FreeRegion {scope_id: dcx.tr_id(fr.scope_id),\n+                                            bound_region: fr.bound_region.tr(dcx)})\n             }\n         }\n     }\n }\n \n impl tr for ty::BoundRegion {\n-    fn tr(&self, xcx: &ExtendedDecodeContext) -> ty::BoundRegion {\n+    fn tr(&self, dcx: &DecodeContext) -> ty::BoundRegion {\n         match *self {\n             ty::BrAnon(_) |\n             ty::BrFresh(_) => *self,\n-            ty::BrNamed(id, ident) => ty::BrNamed(xcx.tr_def_id(id),\n+            ty::BrNamed(id, ident) => ty::BrNamed(dcx.tr_def_id(id),\n                                                     ident),\n         }\n     }\n }\n \n impl tr for ty::TraitStore {\n-    fn tr(&self, xcx: &ExtendedDecodeContext) -> ty::TraitStore {\n+    fn tr(&self, dcx: &DecodeContext) -> ty::TraitStore {\n         match *self {\n             ty::RegionTraitStore(r, m) => {\n-                ty::RegionTraitStore(r.tr(xcx), m)\n+                ty::RegionTraitStore(r.tr(dcx), m)\n             }\n             ty::UniqTraitStore => ty::UniqTraitStore\n         }\n@@ -554,16 +534,16 @@ fn encode_capture_mode(rbml_w: &mut Encoder, cm: CaptureMode) {\n }\n \n trait rbml_decoder_helper {\n-    fn read_freevar_entry(&mut self, xcx: &ExtendedDecodeContext)\n+    fn read_freevar_entry(&mut self, dcx: &DecodeContext)\n                           -> freevar_entry;\n     fn read_capture_mode(&mut self) -> CaptureMode;\n }\n \n impl<'a> rbml_decoder_helper for reader::Decoder<'a> {\n-    fn read_freevar_entry(&mut self, xcx: &ExtendedDecodeContext)\n+    fn read_freevar_entry(&mut self, dcx: &DecodeContext)\n                           -> freevar_entry {\n         let fv: freevar_entry = Decodable::decode(self).unwrap();\n-        fv.tr(xcx)\n+        fv.tr(dcx)\n     }\n \n     fn read_capture_mode(&mut self) -> CaptureMode {\n@@ -573,19 +553,19 @@ impl<'a> rbml_decoder_helper for reader::Decoder<'a> {\n }\n \n impl tr for freevar_entry {\n-    fn tr(&self, xcx: &ExtendedDecodeContext) -> freevar_entry {\n+    fn tr(&self, dcx: &DecodeContext) -> freevar_entry {\n         freevar_entry {\n-            def: self.def.tr(xcx),\n-            span: self.span.tr(xcx),\n+            def: self.def.tr(dcx),\n+            span: self.span.tr(dcx),\n         }\n     }\n }\n \n impl tr for ty::UpvarBorrow {\n-    fn tr(&self, xcx: &ExtendedDecodeContext) -> ty::UpvarBorrow {\n+    fn tr(&self, dcx: &DecodeContext) -> ty::UpvarBorrow {\n         ty::UpvarBorrow {\n             kind: self.kind,\n-            region: self.region.tr(xcx)\n+            region: self.region.tr(dcx)\n         }\n     }\n }\n@@ -594,7 +574,7 @@ impl tr for ty::UpvarBorrow {\n // Encoding and decoding of MethodCallee\n \n trait read_method_callee_helper {\n-    fn read_method_callee(&mut self, xcx: &ExtendedDecodeContext)\n+    fn read_method_callee(&mut self, dcx: &DecodeContext)\n         -> (typeck::ExprAdjustment, MethodCallee);\n }\n \n@@ -621,7 +601,7 @@ fn encode_method_callee(ecx: &e::EncodeContext,\n }\n \n impl<'a> read_method_callee_helper for reader::Decoder<'a> {\n-    fn read_method_callee(&mut self, xcx: &ExtendedDecodeContext)\n+    fn read_method_callee(&mut self, dcx: &DecodeContext)\n         -> (typeck::ExprAdjustment, MethodCallee) {\n \n         self.read_struct(\"MethodCallee\", 4, |this| {\n@@ -632,38 +612,38 @@ impl<'a> read_method_callee_helper for reader::Decoder<'a> {\n                 origin: this.read_struct_field(\"origin\", 1, |this| {\n                     let method_origin: MethodOrigin =\n                         Decodable::decode(this).unwrap();\n-                    Ok(method_origin.tr(xcx))\n+                    Ok(method_origin.tr(dcx))\n                 }).unwrap(),\n                 ty: this.read_struct_field(\"ty\", 2, |this| {\n-                    Ok(this.read_ty(xcx))\n+                    Ok(this.read_ty(dcx))\n                 }).unwrap(),\n                 substs: this.read_struct_field(\"substs\", 3, |this| {\n-                    Ok(this.read_substs(xcx))\n+                    Ok(this.read_substs(dcx))\n                 }).unwrap()\n             }))\n         }).unwrap()\n     }\n }\n \n impl tr for MethodOrigin {\n-    fn tr(&self, xcx: &ExtendedDecodeContext) -> MethodOrigin {\n+    fn tr(&self, dcx: &DecodeContext) -> MethodOrigin {\n         match *self {\n-            typeck::MethodStatic(did) => typeck::MethodStatic(did.tr(xcx)),\n+            typeck::MethodStatic(did) => typeck::MethodStatic(did.tr(dcx)),\n             typeck::MethodStaticUnboxedClosure(did) => {\n-                typeck::MethodStaticUnboxedClosure(did.tr(xcx))\n+                typeck::MethodStaticUnboxedClosure(did.tr(dcx))\n             }\n             typeck::MethodParam(ref mp) => {\n                 typeck::MethodParam(\n                     typeck::MethodParam {\n-                        trait_id: mp.trait_id.tr(xcx),\n+                        trait_id: mp.trait_id.tr(dcx),\n                         .. *mp\n                     }\n                 )\n             }\n             typeck::MethodObject(ref mo) => {\n                 typeck::MethodObject(\n                     typeck::MethodObject {\n-                        trait_id: mo.trait_id.tr(xcx),\n+                        trait_id: mo.trait_id.tr(dcx),\n                         .. *mo\n                     }\n                 )\n@@ -862,10 +842,10 @@ impl<'a> vtable_decoder_helpers for reader::Decoder<'a> {\n                   0 => {\n                     typeck::vtable_static(\n                         this.read_enum_variant_arg(0u, |this| {\n-                            Ok(this.read_def_id_noxcx(cdata))\n+                            Ok(this.read_def_id_nodcx(cdata))\n                         }).unwrap(),\n                         this.read_enum_variant_arg(1u, |this| {\n-                            Ok(this.read_substs_noxcx(tcx, cdata))\n+                            Ok(this.read_substs_nodcx(tcx, cdata))\n                         }).unwrap(),\n                         this.read_enum_variant_arg(2u, |this| {\n                             Ok(this.read_vtable_res(tcx, cdata))\n@@ -885,7 +865,7 @@ impl<'a> vtable_decoder_helpers for reader::Decoder<'a> {\n                   2 => {\n                     typeck::vtable_unboxed_closure(\n                         this.read_enum_variant_arg(0u, |this| {\n-                            Ok(this.read_def_id_noxcx(cdata))\n+                            Ok(this.read_def_id_nodcx(cdata))\n                         }).unwrap()\n                     )\n                   }\n@@ -1398,40 +1378,40 @@ impl<'a> doc_decoder_helpers for rbml::Doc<'a> {\n }\n \n trait rbml_decoder_decoder_helpers {\n-    fn read_ty(&mut self, xcx: &ExtendedDecodeContext) -> ty::t;\n-    fn read_tys(&mut self, xcx: &ExtendedDecodeContext) -> Vec<ty::t>;\n-    fn read_type_param_def(&mut self, xcx: &ExtendedDecodeContext)\n+    fn read_ty(&mut self, dcx: &DecodeContext) -> ty::t;\n+    fn read_tys(&mut self, dcx: &DecodeContext) -> Vec<ty::t>;\n+    fn read_type_param_def(&mut self, dcx: &DecodeContext)\n                            -> ty::TypeParameterDef;\n-    fn read_polytype(&mut self, xcx: &ExtendedDecodeContext)\n+    fn read_polytype(&mut self, dcx: &DecodeContext)\n                      -> ty::Polytype;\n-    fn read_existential_bounds(&mut self, xcx: &ExtendedDecodeContext) -> ty::ExistentialBounds;\n-    fn read_substs(&mut self, xcx: &ExtendedDecodeContext) -> subst::Substs;\n-    fn read_auto_adjustment(&mut self, xcx: &ExtendedDecodeContext) -> ty::AutoAdjustment;\n-    fn read_unboxed_closure(&mut self, xcx: &ExtendedDecodeContext)\n+    fn read_existential_bounds(&mut self, dcx: &DecodeContext) -> ty::ExistentialBounds;\n+    fn read_substs(&mut self, dcx: &DecodeContext) -> subst::Substs;\n+    fn read_auto_adjustment(&mut self, dcx: &DecodeContext) -> ty::AutoAdjustment;\n+    fn read_unboxed_closure(&mut self, dcx: &DecodeContext)\n                             -> ty::UnboxedClosure;\n-    fn read_auto_deref_ref(&mut self, xcx: &ExtendedDecodeContext) -> ty::AutoDerefRef;\n-    fn read_autoref(&mut self, xcx: &ExtendedDecodeContext) -> ty::AutoRef;\n-    fn read_unsize_kind(&mut self, xcx: &ExtendedDecodeContext) -> ty::UnsizeKind;\n+    fn read_auto_deref_ref(&mut self, dcx: &DecodeContext) -> ty::AutoDerefRef;\n+    fn read_autoref(&mut self, dcx: &DecodeContext) -> ty::AutoRef;\n+    fn read_unsize_kind(&mut self, dcx: &DecodeContext) -> ty::UnsizeKind;\n     fn convert_def_id(&mut self,\n-                      xcx: &ExtendedDecodeContext,\n+                      dcx: &DecodeContext,\n                       source: DefIdSource,\n                       did: ast::DefId)\n                       -> ast::DefId;\n \n     // Versions of the type reading functions that don't need the full\n-    // ExtendedDecodeContext.\n-    fn read_ty_noxcx(&mut self,\n+    // DecodeContext.\n+    fn read_ty_nodcx(&mut self,\n                      tcx: &ty::ctxt, cdata: &cstore::crate_metadata) -> ty::t;\n-    fn read_tys_noxcx(&mut self,\n+    fn read_tys_nodcx(&mut self,\n                       tcx: &ty::ctxt,\n                       cdata: &cstore::crate_metadata) -> Vec<ty::t>;\n-    fn read_substs_noxcx(&mut self, tcx: &ty::ctxt,\n+    fn read_substs_nodcx(&mut self, tcx: &ty::ctxt,\n                          cdata: &cstore::crate_metadata)\n                          -> subst::Substs;\n }\n \n impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n-    fn read_ty_noxcx(&mut self,\n+    fn read_ty_nodcx(&mut self,\n                      tcx: &ty::ctxt, cdata: &cstore::crate_metadata) -> ty::t {\n         self.read_opaque(|_, doc| {\n             Ok(tydecode::parse_ty_data(\n@@ -1443,16 +1423,16 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n-    fn read_tys_noxcx(&mut self,\n+    fn read_tys_nodcx(&mut self,\n                       tcx: &ty::ctxt,\n                       cdata: &cstore::crate_metadata) -> Vec<ty::t> {\n-        self.read_to_vec(|this| Ok(this.read_ty_noxcx(tcx, cdata)) )\n+        self.read_to_vec(|this| Ok(this.read_ty_nodcx(tcx, cdata)) )\n             .unwrap()\n             .move_iter()\n             .collect()\n     }\n \n-    fn read_substs_noxcx(&mut self,\n+    fn read_substs_nodcx(&mut self,\n                          tcx: &ty::ctxt,\n                          cdata: &cstore::crate_metadata)\n                          -> subst::Substs\n@@ -1467,7 +1447,7 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n-    fn read_ty(&mut self, xcx: &ExtendedDecodeContext) -> ty::t {\n+    fn read_ty(&mut self, dcx: &DecodeContext) -> ty::t {\n         // Note: regions types embed local node ids.  In principle, we\n         // should translate these node ids into the new decode\n         // context.  However, we do not bother, because region types\n@@ -1478,10 +1458,10 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n \n             let ty = tydecode::parse_ty_data(\n                 doc.data,\n-                xcx.dcx.cdata.cnum,\n+                dcx.cdata.cnum,\n                 doc.start,\n-                xcx.dcx.tcx,\n-                |s, a| this.convert_def_id(xcx, s, a));\n+                dcx.tcx,\n+                |s, a| this.convert_def_id(dcx, s, a));\n \n             Ok(ty)\n         }).unwrap();\n@@ -1495,23 +1475,23 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n         }\n     }\n \n-    fn read_tys(&mut self, xcx: &ExtendedDecodeContext) -> Vec<ty::t> {\n-        self.read_to_vec(|this| Ok(this.read_ty(xcx))).unwrap().move_iter().collect()\n+    fn read_tys(&mut self, dcx: &DecodeContext) -> Vec<ty::t> {\n+        self.read_to_vec(|this| Ok(this.read_ty(dcx))).unwrap().move_iter().collect()\n     }\n \n-    fn read_type_param_def(&mut self, xcx: &ExtendedDecodeContext)\n+    fn read_type_param_def(&mut self, dcx: &DecodeContext)\n                            -> ty::TypeParameterDef {\n         self.read_opaque(|this, doc| {\n             Ok(tydecode::parse_type_param_def_data(\n                 doc.data,\n                 doc.start,\n-                xcx.dcx.cdata.cnum,\n-                xcx.dcx.tcx,\n-                |s, a| this.convert_def_id(xcx, s, a)))\n+                dcx.cdata.cnum,\n+                dcx.tcx,\n+                |s, a| this.convert_def_id(dcx, s, a)))\n         }).unwrap()\n     }\n \n-    fn read_polytype(&mut self, xcx: &ExtendedDecodeContext)\n+    fn read_polytype(&mut self, dcx: &DecodeContext)\n                                    -> ty::Polytype {\n         self.read_struct(\"Polytype\", 2, |this| {\n             Ok(ty::Polytype {\n@@ -1521,7 +1501,7 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n                             types:\n                             this.read_struct_field(\"types\", 0, |this| {\n                                 Ok(this.read_vec_per_param_space(\n-                                    |this| this.read_type_param_def(xcx)))\n+                                    |this| this.read_type_param_def(dcx)))\n                             }).unwrap(),\n \n                             regions:\n@@ -1533,34 +1513,34 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n                     })\n                 }).unwrap(),\n                 ty: this.read_struct_field(\"ty\", 1, |this| {\n-                    Ok(this.read_ty(xcx))\n+                    Ok(this.read_ty(dcx))\n                 }).unwrap()\n             })\n         }).unwrap()\n     }\n \n-    fn read_existential_bounds(&mut self, xcx: &ExtendedDecodeContext) -> ty::ExistentialBounds\n+    fn read_existential_bounds(&mut self, dcx: &DecodeContext) -> ty::ExistentialBounds\n     {\n         self.read_opaque(|this, doc| {\n             Ok(tydecode::parse_existential_bounds_data(doc.data,\n-                                                       xcx.dcx.cdata.cnum,\n+                                                       dcx.cdata.cnum,\n                                                        doc.start,\n-                                                       xcx.dcx.tcx,\n-                                                       |s, a| this.convert_def_id(xcx, s, a)))\n+                                                       dcx.tcx,\n+                                                       |s, a| this.convert_def_id(dcx, s, a)))\n         }).unwrap()\n     }\n \n-    fn read_substs(&mut self, xcx: &ExtendedDecodeContext) -> subst::Substs {\n+    fn read_substs(&mut self, dcx: &DecodeContext) -> subst::Substs {\n         self.read_opaque(|this, doc| {\n             Ok(tydecode::parse_substs_data(doc.data,\n-                                        xcx.dcx.cdata.cnum,\n+                                        dcx.cdata.cnum,\n                                         doc.start,\n-                                        xcx.dcx.tcx,\n-                                        |s, a| this.convert_def_id(xcx, s, a)))\n+                                        dcx.tcx,\n+                                        |s, a| this.convert_def_id(dcx, s, a)))\n         }).unwrap()\n     }\n \n-    fn read_auto_adjustment(&mut self, xcx: &ExtendedDecodeContext) -> ty::AutoAdjustment {\n+    fn read_auto_adjustment(&mut self, dcx: &DecodeContext) -> ty::AutoAdjustment {\n         self.read_enum(\"AutoAdjustment\", |this| {\n             let variants = [\"AutoAddEnv\", \"AutoDerefRef\"];\n             this.read_enum_variant(variants, |this, i| {\n@@ -1569,12 +1549,12 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n                         let store: ty::TraitStore =\n                             this.read_enum_variant_arg(0, |this| Decodable::decode(this)).unwrap();\n \n-                        ty::AutoAddEnv(store.tr(xcx))\n+                        ty::AutoAddEnv(store.tr(dcx))\n                     }\n                     1 => {\n                         let auto_deref_ref: ty::AutoDerefRef =\n                             this.read_enum_variant_arg(0,\n-                                |this| Ok(this.read_auto_deref_ref(xcx))).unwrap();\n+                                |this| Ok(this.read_auto_deref_ref(dcx))).unwrap();\n \n                         ty::AutoDerefRef(auto_deref_ref)\n                     }\n@@ -1584,7 +1564,7 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n-    fn read_auto_deref_ref(&mut self, xcx: &ExtendedDecodeContext) -> ty::AutoDerefRef {\n+    fn read_auto_deref_ref(&mut self, dcx: &DecodeContext) -> ty::AutoDerefRef {\n         self.read_struct(\"AutoDerefRef\", 2, |this| {\n             Ok(ty::AutoDerefRef {\n                 autoderefs: this.read_struct_field(\"autoderefs\", 0, |this| {\n@@ -1593,7 +1573,7 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n                 autoref: this.read_struct_field(\"autoref\", 1, |this| {\n                     this.read_option(|this, b| {\n                         if b {\n-                            Ok(Some(this.read_autoref(xcx)))\n+                            Ok(Some(this.read_autoref(dcx)))\n                         } else {\n                             Ok(None)\n                         }\n@@ -1603,7 +1583,7 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n-    fn read_autoref(&mut self, xcx: &ExtendedDecodeContext) -> ty::AutoRef {\n+    fn read_autoref(&mut self, dcx: &DecodeContext) -> ty::AutoRef {\n         self.read_enum(\"AutoRef\", |this| {\n             let variants = [\"AutoPtr\",\n                             \"AutoUnsize\",\n@@ -1619,25 +1599,25 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n                         let a: Option<Box<ty::AutoRef>> =\n                             this.read_enum_variant_arg(2, |this| this.read_option(|this, b| {\n                                 if b {\n-                                    Ok(Some(box this.read_autoref(xcx)))\n+                                    Ok(Some(box this.read_autoref(dcx)))\n                                 } else {\n                                     Ok(None)\n                                 }\n                             })).unwrap();\n \n-                        ty::AutoPtr(r.tr(xcx), m, a)\n+                        ty::AutoPtr(r.tr(dcx), m, a)\n                     }\n                     1 => {\n                         let uk: ty::UnsizeKind =\n                             this.read_enum_variant_arg(0,\n-                                |this| Ok(this.read_unsize_kind(xcx))).unwrap();\n+                                |this| Ok(this.read_unsize_kind(dcx))).unwrap();\n \n                         ty::AutoUnsize(uk)\n                     }\n                     2 => {\n                         let uk: ty::UnsizeKind =\n                             this.read_enum_variant_arg(0,\n-                                |this| Ok(this.read_unsize_kind(xcx))).unwrap();\n+                                |this| Ok(this.read_unsize_kind(dcx))).unwrap();\n \n                         ty::AutoUnsizeUniq(uk)\n                     }\n@@ -1647,7 +1627,7 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n                         let a: Option<Box<ty::AutoRef>> =\n                             this.read_enum_variant_arg(1, |this| this.read_option(|this, b| {\n                                 if b {\n-                                    Ok(Some(box this.read_autoref(xcx)))\n+                                    Ok(Some(box this.read_autoref(dcx)))\n                                 } else {\n                                     Ok(None)\n                                 }\n@@ -1661,7 +1641,7 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n-    fn read_unsize_kind(&mut self, xcx: &ExtendedDecodeContext) -> ty::UnsizeKind {\n+    fn read_unsize_kind(&mut self, dcx: &DecodeContext) -> ty::UnsizeKind {\n         self.read_enum(\"UnsizeKind\", |this| {\n             let variants = [\"UnsizeLength\", \"UnsizeStruct\", \"UnsizeVtable\"];\n             this.read_enum_variant(variants, |this, i| {\n@@ -1675,7 +1655,7 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n                     1 => {\n                         let uk: ty::UnsizeKind =\n                             this.read_enum_variant_arg(0,\n-                                |this| Ok(this.read_unsize_kind(xcx))).unwrap();\n+                                |this| Ok(this.read_unsize_kind(dcx))).unwrap();\n                         let idx: uint =\n                             this.read_enum_variant_arg(1, |this| Decodable::decode(this)).unwrap();\n \n@@ -1684,29 +1664,29 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n                     2 => {\n                         let b =\n                             this.read_enum_variant_arg(\n-                                0, |this| Ok(this.read_existential_bounds(xcx))).unwrap();\n+                                0, |this| Ok(this.read_existential_bounds(dcx))).unwrap();\n                         let def_id: ast::DefId =\n                             this.read_enum_variant_arg(1, |this| Decodable::decode(this)).unwrap();\n                         let substs = this.read_enum_variant_arg(2,\n-                            |this| Ok(this.read_substs(xcx))).unwrap();\n+                            |this| Ok(this.read_substs(dcx))).unwrap();\n \n-                        ty::UnsizeVtable(b, def_id.tr(xcx), substs)\n+                        ty::UnsizeVtable(b, def_id.tr(dcx), substs)\n                     }\n                     _ => fail!(\"bad enum variant for ty::UnsizeKind\")\n                 })\n             })\n         }).unwrap()\n     }\n \n-    fn read_unboxed_closure(&mut self, xcx: &ExtendedDecodeContext)\n+    fn read_unboxed_closure(&mut self, dcx: &DecodeContext)\n                             -> ty::UnboxedClosure {\n         let closure_type = self.read_opaque(|this, doc| {\n             Ok(tydecode::parse_ty_closure_data(\n                 doc.data,\n-                xcx.dcx.cdata.cnum,\n+                dcx.cdata.cnum,\n                 doc.start,\n-                xcx.dcx.tcx,\n-                |s, a| this.convert_def_id(xcx, s, a)))\n+                dcx.tcx,\n+                |s, a| this.convert_def_id(dcx, s, a)))\n         }).unwrap();\n         let variants = [\n             \"FnUnboxedClosureKind\",\n@@ -1728,7 +1708,7 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n     }\n \n     fn convert_def_id(&mut self,\n-                      xcx: &ExtendedDecodeContext,\n+                      dcx: &DecodeContext,\n                       source: tydecode::DefIdSource,\n                       did: ast::DefId)\n                       -> ast::DefId {\n@@ -1761,29 +1741,28 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n          */\n \n         let r = match source {\n-            NominalType | TypeWithId | RegionParameter => xcx.tr_def_id(did),\n-            TypeParameter => xcx.tr_intern_def_id(did)\n+            NominalType | TypeWithId | RegionParameter => dcx.tr_def_id(did),\n+            TypeParameter => dcx.tr_intern_def_id(did)\n         };\n         debug!(\"convert_def_id(source={:?}, did={:?})={:?}\", source, did, r);\n         return r;\n     }\n }\n \n-fn decode_side_tables(xcx: &ExtendedDecodeContext,\n+fn decode_side_tables(dcx: &DecodeContext,\n                       ast_doc: rbml::Doc) {\n-    let dcx = xcx.dcx;\n     let tbl_doc = ast_doc.get(c::tag_table as uint);\n     reader::docs(tbl_doc, |tag, entry_doc| {\n         let id0 = entry_doc.get(c::tag_table_id as uint).as_int();\n-        let id = xcx.tr_id(id0 as ast::NodeId);\n+        let id = dcx.tr_id(id0 as ast::NodeId);\n \n         debug!(\">> Side table document with tag 0x{:x} \\\n                 found for id {} (orig {})\",\n                tag, id, id0);\n \n         match c::astencode_tag::from_uint(tag) {\n             None => {\n-                xcx.dcx.tcx.sess.bug(\n+                dcx.tcx.sess.bug(\n                     format!(\"unknown tag found in side tables: {:x}\",\n                             tag).as_slice());\n             }\n@@ -1794,36 +1773,36 @@ fn decode_side_tables(xcx: &ExtendedDecodeContext,\n \n                 match value {\n                     c::tag_table_def => {\n-                        let def = decode_def(xcx, val_doc);\n+                        let def = decode_def(dcx, val_doc);\n                         dcx.tcx.def_map.borrow_mut().insert(id, def);\n                     }\n                     c::tag_table_node_type => {\n-                        let ty = val_dsr.read_ty(xcx);\n+                        let ty = val_dsr.read_ty(dcx);\n                         debug!(\"inserting ty for node {:?}: {}\",\n                                id, ty_to_string(dcx.tcx, ty));\n                         dcx.tcx.node_types.borrow_mut().insert(id as uint, ty);\n                     }\n                     c::tag_table_item_subst => {\n                         let item_substs = ty::ItemSubsts {\n-                            substs: val_dsr.read_substs(xcx)\n+                            substs: val_dsr.read_substs(dcx)\n                         };\n                         dcx.tcx.item_substs.borrow_mut().insert(\n                             id, item_substs);\n                     }\n                     c::tag_table_freevars => {\n                         let fv_info = val_dsr.read_to_vec(|val_dsr| {\n-                            Ok(val_dsr.read_freevar_entry(xcx))\n+                            Ok(val_dsr.read_freevar_entry(dcx))\n                         }).unwrap().move_iter().collect();\n                         dcx.tcx.freevars.borrow_mut().insert(id, fv_info);\n                     }\n                     c::tag_table_upvar_borrow_map => {\n                         let var_id: ast::NodeId = Decodable::decode(val_dsr).unwrap();\n                         let upvar_id = ty::UpvarId {\n-                            var_id: xcx.tr_id(var_id),\n+                            var_id: dcx.tr_id(var_id),\n                             closure_expr_id: id\n                         };\n                         let ub: ty::UpvarBorrow = Decodable::decode(val_dsr).unwrap();\n-                        dcx.tcx.upvar_borrow_map.borrow_mut().insert(upvar_id, ub.tr(xcx));\n+                        dcx.tcx.upvar_borrow_map.borrow_mut().insert(upvar_id, ub.tr(dcx));\n                     }\n                     c::tag_table_capture_modes => {\n                         let capture_mode = val_dsr.read_capture_mode();\n@@ -1833,16 +1812,16 @@ fn decode_side_tables(xcx: &ExtendedDecodeContext,\n                            .insert(id, capture_mode);\n                     }\n                     c::tag_table_tcache => {\n-                        let pty = val_dsr.read_polytype(xcx);\n+                        let pty = val_dsr.read_polytype(dcx);\n                         let lid = ast::DefId { krate: ast::LOCAL_CRATE, node: id };\n                         dcx.tcx.tcache.borrow_mut().insert(lid, pty);\n                     }\n                     c::tag_table_param_defs => {\n-                        let bounds = val_dsr.read_type_param_def(xcx);\n+                        let bounds = val_dsr.read_type_param_def(dcx);\n                         dcx.tcx.ty_param_defs.borrow_mut().insert(id, bounds);\n                     }\n                     c::tag_table_method_map => {\n-                        let (adjustment, method) = val_dsr.read_method_callee(xcx);\n+                        let (adjustment, method) = val_dsr.read_method_callee(dcx);\n                         let method_call = MethodCall {\n                             expr_id: id,\n                             adjustment: adjustment\n@@ -1851,29 +1830,29 @@ fn decode_side_tables(xcx: &ExtendedDecodeContext,\n                     }\n                     c::tag_table_vtable_map => {\n                         let (adjustment, vtable_res) =\n-                            val_dsr.read_vtable_res_with_key(xcx.dcx.tcx,\n-                                                             xcx.dcx.cdata);\n+                            val_dsr.read_vtable_res_with_key(dcx.tcx,\n+                                                             dcx.cdata);\n                         let vtable_key = MethodCall {\n                             expr_id: id,\n                             adjustment: adjustment\n                         };\n                         dcx.tcx.vtable_map.borrow_mut().insert(vtable_key, vtable_res);\n                     }\n                     c::tag_table_adjustments => {\n-                        let adj: ty::AutoAdjustment = val_dsr.read_auto_adjustment(xcx);\n+                        let adj: ty::AutoAdjustment = val_dsr.read_auto_adjustment(dcx);\n                         dcx.tcx.adjustments.borrow_mut().insert(id, adj);\n                     }\n                     c::tag_table_unboxed_closures => {\n                         let unboxed_closure =\n-                            val_dsr.read_unboxed_closure(xcx);\n+                            val_dsr.read_unboxed_closure(dcx);\n                         dcx.tcx\n                            .unboxed_closures\n                            .borrow_mut()\n                            .insert(ast_util::local_def(id),\n                                    unboxed_closure);\n                     }\n                     _ => {\n-                        xcx.dcx.tcx.sess.bug(\n+                        dcx.tcx.sess.bug(\n                             format!(\"unknown tag found in side tables: {:x}\",\n                                     tag).as_slice());\n                     }\n@@ -1890,17 +1869,17 @@ fn decode_side_tables(xcx: &ExtendedDecodeContext,\n // Testing of astencode_gen\n \n #[cfg(test)]\n-fn encode_item_ast(rbml_w: &mut Encoder, item: Gc<ast::Item>) {\n+fn encode_item_ast(rbml_w: &mut Encoder, item: &ast::Item) {\n     rbml_w.start_tag(c::tag_tree as uint);\n     (*item).encode(rbml_w);\n     rbml_w.end_tag();\n }\n \n #[cfg(test)]\n-fn decode_item_ast(par_doc: rbml::Doc) -> Gc<ast::Item> {\n+fn decode_item_ast(par_doc: rbml::Doc) -> ast::Item {\n     let chi_doc = par_doc.get(c::tag_tree as uint);\n     let mut d = reader::Decoder::new(chi_doc);\n-    box(GC) Decodable::decode(&mut d).unwrap()\n+    Decodable::decode(&mut d).unwrap()\n }\n \n #[cfg(test)]\n@@ -1935,17 +1914,14 @@ fn mk_ctxt() -> parse::ParseSess {\n }\n \n #[cfg(test)]\n-fn roundtrip(in_item: Option<Gc<ast::Item>>) {\n+fn roundtrip(in_item: Option<P<ast::Item>>) {\n     let in_item = in_item.unwrap();\n     let mut wr = SeekableMemWriter::new();\n-    {\n-        let mut rbml_w = writer::Encoder::new(&mut wr);\n-        encode_item_ast(&mut rbml_w, in_item);\n-    }\n+    encode_item_ast(&mut writer::Encoder::new(&mut wr), &*in_item);\n     let rbml_doc = rbml::Doc::new(wr.get_ref());\n     let out_item = decode_item_ast(rbml_doc);\n \n-    assert!(in_item == out_item);\n+    assert!(*in_item == out_item);\n }\n \n #[test]"}, {"sha": "c789db5be0c012d3fdc9b884fc682d9311316077", "filename": "src/librustc/middle/borrowck/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgraphviz.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -44,7 +44,7 @@ impl Variant {\n }\n \n pub struct DataflowLabeller<'a, 'tcx: 'a> {\n-    pub inner: cfg_dot::LabelledCFG<'a>,\n+    pub inner: cfg_dot::LabelledCFG<'a, 'tcx>,\n     pub variants: Vec<Variant>,\n     pub borrowck_ctxt: &'a BorrowckCtxt<'a, 'tcx>,\n     pub analysis_data: &'a borrowck::AnalysisData<'a, 'tcx>,"}, {"sha": "0d584a7664f67e81e2002bbcedf016b27710dcf2", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 28, "deletions": 31, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -22,9 +22,7 @@ use middle::mem_categorization as mc;\n use middle::ty;\n use util::ppaux::{note_and_explain_region, Repr, UserString};\n \n-use std::cell::{Cell};\n use std::rc::Rc;\n-use std::gc::{Gc, GC};\n use std::string::String;\n use syntax::ast;\n use syntax::ast_map;\n@@ -71,34 +69,33 @@ impl<'a, 'tcx, 'v> Visitor<'v> for BorrowckCtxt<'a, 'tcx> {\n     }\n }\n \n-pub fn check_crate(tcx: &ty::ctxt,\n-                   krate: &ast::Crate) {\n+pub fn check_crate(tcx: &ty::ctxt) {\n     let mut bccx = BorrowckCtxt {\n         tcx: tcx,\n-        stats: box(GC) BorrowStats {\n-            loaned_paths_same: Cell::new(0),\n-            loaned_paths_imm: Cell::new(0),\n-            stable_paths: Cell::new(0),\n-            guaranteed_paths: Cell::new(0),\n+        stats: BorrowStats {\n+            loaned_paths_same: 0,\n+            loaned_paths_imm: 0,\n+            stable_paths: 0,\n+            guaranteed_paths: 0\n         }\n     };\n \n-    visit::walk_crate(&mut bccx, krate);\n+    visit::walk_crate(&mut bccx, tcx.map.krate());\n \n     if tcx.sess.borrowck_stats() {\n         println!(\"--- borrowck stats ---\");\n         println!(\"paths requiring guarantees: {}\",\n-                 bccx.stats.guaranteed_paths.get());\n+                 bccx.stats.guaranteed_paths);\n         println!(\"paths requiring loans     : {}\",\n-                 make_stat(&bccx, bccx.stats.loaned_paths_same.get()));\n+                 make_stat(&bccx, bccx.stats.loaned_paths_same));\n         println!(\"paths requiring imm loans : {}\",\n-                 make_stat(&bccx, bccx.stats.loaned_paths_imm.get()));\n+                 make_stat(&bccx, bccx.stats.loaned_paths_imm));\n         println!(\"stable paths              : {}\",\n-                 make_stat(&bccx, bccx.stats.stable_paths.get()));\n+                 make_stat(&bccx, bccx.stats.stable_paths));\n     }\n \n     fn make_stat(bccx: &BorrowckCtxt, stat: uint) -> String {\n-        let total = bccx.stats.guaranteed_paths.get() as f64;\n+        let total = bccx.stats.guaranteed_paths as f64;\n         let perc = if total == 0.0 { 0.0 } else { stat as f64 * 100.0 / total };\n         format!(\"{} ({:.0f}%)\", stat, perc)\n     }\n@@ -110,8 +107,8 @@ fn borrowck_item(this: &mut BorrowckCtxt, item: &ast::Item) {\n     // loan step is intended for things that have a data\n     // flow dependent conditions.\n     match item.node {\n-        ast::ItemStatic(_, _, ex) => {\n-            gather_loans::gather_loans_in_static_initializer(this, &*ex);\n+        ast::ItemStatic(_, _, ref ex) => {\n+            gather_loans::gather_loans_in_static_initializer(this, &**ex);\n         }\n         _ => {\n             visit::walk_item(this, item);\n@@ -206,11 +203,11 @@ pub fn build_borrowck_dataflow_data_for_fn<'a, 'tcx>(\n \n     let mut bccx = BorrowckCtxt {\n         tcx: tcx,\n-        stats: box(GC) BorrowStats {\n-            loaned_paths_same: Cell::new(0),\n-            loaned_paths_imm: Cell::new(0),\n-            stable_paths: Cell::new(0),\n-            guaranteed_paths: Cell::new(0),\n+        stats: BorrowStats {\n+            loaned_paths_same: 0,\n+            loaned_paths_imm: 0,\n+            stable_paths: 0,\n+            guaranteed_paths: 0\n         }\n     };\n \n@@ -234,14 +231,14 @@ pub struct BorrowckCtxt<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n \n     // Statistics:\n-    stats: Gc<BorrowStats>,\n+    stats: BorrowStats\n }\n \n-pub struct BorrowStats {\n-    loaned_paths_same: Cell<uint>,\n-    loaned_paths_imm: Cell<uint>,\n-    stable_paths: Cell<uint>,\n-    guaranteed_paths: Cell<uint>,\n+struct BorrowStats {\n+    loaned_paths_same: uint,\n+    loaned_paths_imm: uint,\n+    stable_paths: uint,\n+    guaranteed_paths: uint\n }\n \n pub type BckResult<T> = Result<T, BckError>;\n@@ -290,9 +287,9 @@ pub fn closure_to_block(closure_id: ast::NodeId,\n                     tcx: &ty::ctxt) -> ast::NodeId {\n     match tcx.map.get(closure_id) {\n         ast_map::NodeExpr(expr) => match expr.node {\n-            ast::ExprProc(_, block) |\n-            ast::ExprFnBlock(_, _, block) |\n-            ast::ExprUnboxedFn(_, _, _, block) => { block.id }\n+            ast::ExprProc(_, ref block) |\n+            ast::ExprFnBlock(_, _, ref block) |\n+            ast::ExprUnboxedFn(_, _, _, ref block) => { block.id }\n             _ => fail!(\"encountered non-closure id: {}\", closure_id)\n         },\n         _ => fail!(\"encountered non-expr id: {}\", closure_id)"}, {"sha": "05cc61a754749b1d4af538ca5b78fe73d11c0a7d", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 78, "deletions": 87, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -15,10 +15,9 @@ use middle::typeck;\n use middle::ty;\n use syntax::ast;\n use syntax::ast_util;\n+use syntax::ptr::P;\n use util::nodemap::NodeMap;\n \n-use std::gc::Gc;\n-\n struct CFGBuilder<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n     exit_map: NodeMap<CFGIndex>,\n@@ -69,23 +68,23 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n     fn block(&mut self, blk: &ast::Block, pred: CFGIndex) -> CFGIndex {\n         let mut stmts_exit = pred;\n         for stmt in blk.stmts.iter() {\n-            stmts_exit = self.stmt(stmt.clone(), stmts_exit);\n+            stmts_exit = self.stmt(&**stmt, stmts_exit);\n         }\n \n-        let expr_exit = self.opt_expr(blk.expr.clone(), stmts_exit);\n+        let expr_exit = self.opt_expr(&blk.expr, stmts_exit);\n \n         self.add_node(blk.id, [expr_exit])\n     }\n \n-    fn stmt(&mut self, stmt: Gc<ast::Stmt>, pred: CFGIndex) -> CFGIndex {\n+    fn stmt(&mut self, stmt: &ast::Stmt, pred: CFGIndex) -> CFGIndex {\n         match stmt.node {\n             ast::StmtDecl(ref decl, id) => {\n                 let exit = self.decl(&**decl, pred);\n                 self.add_node(id, [exit])\n             }\n \n             ast::StmtExpr(ref expr, id) | ast::StmtSemi(ref expr, id) => {\n-                let exit = self.expr(expr.clone(), pred);\n+                let exit = self.expr(&**expr, pred);\n                 self.add_node(id, [exit])\n             }\n \n@@ -98,7 +97,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n     fn decl(&mut self, decl: &ast::Decl, pred: CFGIndex) -> CFGIndex {\n         match decl.node {\n             ast::DeclLocal(ref local) => {\n-                let init_exit = self.opt_expr(local.init.clone(), pred);\n+                let init_exit = self.opt_expr(&local.init, pred);\n                 self.pat(&*local.pat, init_exit)\n             }\n \n@@ -127,24 +126,20 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n \n             ast::PatEnum(_, Some(ref subpats)) |\n             ast::PatTup(ref subpats) => {\n-                let pats_exit =\n-                    self.pats_all(subpats.iter().map(|p| p.clone()), pred);\n+                let pats_exit = self.pats_all(subpats.iter(), pred);\n                 self.add_node(pat.id, [pats_exit])\n             }\n \n             ast::PatStruct(_, ref subpats, _) => {\n                 let pats_exit =\n-                    self.pats_all(subpats.iter().map(|f| f.pat.clone()), pred);\n+                    self.pats_all(subpats.iter().map(|f| &f.pat), pred);\n                 self.add_node(pat.id, [pats_exit])\n             }\n \n             ast::PatVec(ref pre, ref vec, ref post) => {\n-                let pre_exit =\n-                    self.pats_all(pre.iter().map(|p| *p), pred);\n-                let vec_exit =\n-                    self.pats_all(vec.iter().map(|p| *p), pre_exit);\n-                let post_exit =\n-                    self.pats_all(post.iter().map(|p| *p), vec_exit);\n+                let pre_exit = self.pats_all(pre.iter(), pred);\n+                let vec_exit = self.pats_all(vec.iter(), pre_exit);\n+                let post_exit = self.pats_all(post.iter(), vec_exit);\n                 self.add_node(pat.id, [post_exit])\n             }\n \n@@ -154,32 +149,32 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         }\n     }\n \n-    fn pats_all<I: Iterator<Gc<ast::Pat>>>(&mut self,\n-                                        pats: I,\n-                                        pred: CFGIndex) -> CFGIndex {\n+    fn pats_all<'a, I: Iterator<&'a P<ast::Pat>>>(&mut self,\n+                                          pats: I,\n+                                          pred: CFGIndex) -> CFGIndex {\n         //! Handles case where all of the patterns must match.\n         let mut pats = pats;\n-        pats.fold(pred, |pred, pat| self.pat(&*pat, pred))\n+        pats.fold(pred, |pred, pat| self.pat(&**pat, pred))\n     }\n \n     fn pats_any(&mut self,\n-                pats: &[Gc<ast::Pat>],\n+                pats: &[P<ast::Pat>],\n                 pred: CFGIndex) -> CFGIndex {\n         //! Handles case where just one of the patterns must match.\n \n         if pats.len() == 1 {\n             self.pat(&*pats[0], pred)\n         } else {\n             let collect = self.add_dummy_node([]);\n-            for &pat in pats.iter() {\n-                let pat_exit = self.pat(&*pat, pred);\n+            for pat in pats.iter() {\n+                let pat_exit = self.pat(&**pat, pred);\n                 self.add_contained_edge(pat_exit, collect);\n             }\n             collect\n         }\n     }\n \n-    fn expr(&mut self, expr: Gc<ast::Expr>, pred: CFGIndex) -> CFGIndex {\n+    fn expr(&mut self, expr: &ast::Expr, pred: CFGIndex) -> CFGIndex {\n         match expr.node {\n             ast::ExprBlock(ref blk) => {\n                 let blk_exit = self.block(&**blk, pred);\n@@ -201,7 +196,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 //    v 3   v 4\n                 //   [..expr..]\n                 //\n-                let cond_exit = self.expr(cond.clone(), pred);           // 1\n+                let cond_exit = self.expr(&**cond, pred);                // 1\n                 let then_exit = self.block(&**then, cond_exit);          // 2\n                 self.add_node(expr.id, [cond_exit, then_exit])           // 3,4\n             }\n@@ -221,9 +216,9 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 //    v 4   v 5\n                 //   [..expr..]\n                 //\n-                let cond_exit = self.expr(cond.clone(), pred);           // 1\n+                let cond_exit = self.expr(&**cond, pred);                // 1\n                 let then_exit = self.block(&**then, cond_exit);          // 2\n-                let else_exit = self.expr(otherwise.clone(), cond_exit); // 3\n+                let else_exit = self.expr(&**otherwise, cond_exit);      // 3\n                 self.add_node(expr.id, [then_exit, else_exit])           // 4, 5\n             }\n \n@@ -247,7 +242,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n \n                 // Is the condition considered part of the loop?\n                 let loopback = self.add_dummy_node([pred]);              // 1\n-                let cond_exit = self.expr(cond.clone(), loopback);       // 2\n+                let cond_exit = self.expr(&**cond, loopback);            // 2\n                 let expr_exit = self.add_node(expr.id, [cond_exit]);     // 3\n                 self.loop_scopes.push(LoopScope {\n                     loop_id: expr.id,\n@@ -283,7 +278,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 // Note that `break` and `continue` statements\n                 // may cause additional edges.\n \n-                let head = self.expr(head.clone(), pred);       // 1\n+                let head = self.expr(&**head, pred);            // 1\n                 let loopback = self.add_dummy_node([head]);     // 2\n                 let cond = self.add_dummy_node([loopback]);     // 3\n                 let expr_exit = self.add_node(expr.id, [cond]); // 4\n@@ -353,18 +348,17 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 //     v 6   v    v\n                 //  [.....expr.....]\n                 //\n-                let discr_exit = self.expr(discr.clone(), pred);         // 1\n+                let discr_exit = self.expr(&**discr, pred);              // 1\n \n                 let expr_exit = self.add_node(expr.id, []);\n                 let mut cond_exit = discr_exit;\n                 for arm in arms.iter() {\n                     cond_exit = self.add_dummy_node([cond_exit]);        // 2\n                     let pats_exit = self.pats_any(arm.pats.as_slice(),\n                                                   cond_exit);            // 3\n-                    let guard_exit = self.opt_expr(arm.guard,\n+                    let guard_exit = self.opt_expr(&arm.guard,\n                                                    pats_exit);           // 4\n-                    let body_exit = self.expr(arm.body.clone(),\n-                                              guard_exit);               // 5\n+                    let body_exit = self.expr(&*arm.body, guard_exit);   // 5\n                     self.add_contained_edge(body_exit, expr_exit);       // 6\n                 }\n                 expr_exit\n@@ -385,13 +379,13 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 //    v 3  v 4\n                 //   [..exit..]\n                 //\n-                let l_exit = self.expr(l.clone(), pred);                  // 1\n-                let r_exit = self.expr(r.clone(), l_exit);               // 2\n+                let l_exit = self.expr(&**l, pred);                      // 1\n+                let r_exit = self.expr(&**r, l_exit);                    // 2\n                 self.add_node(expr.id, [l_exit, r_exit])                 // 3,4\n             }\n \n             ast::ExprRet(ref v) => {\n-                let v_exit = self.opt_expr(v.clone(), pred);\n+                let v_exit = self.opt_expr(v, pred);\n                 let b = self.add_node(expr.id, [v_exit]);\n                 self.add_returning_edge(expr, b);\n                 self.add_node(ast::DUMMY_NODE_ID, [])\n@@ -414,76 +408,74 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             }\n \n             ast::ExprVec(ref elems) => {\n-                self.straightline(expr, pred, elems.as_slice())\n+                self.straightline(expr, pred, elems.iter().map(|e| &**e))\n             }\n \n             ast::ExprCall(ref func, ref args) => {\n-                self.call(expr, pred, func.clone(), args.as_slice())\n+                self.call(expr, pred, &**func, args.iter().map(|e| &**e))\n             }\n \n             ast::ExprMethodCall(_, _, ref args) => {\n-                self.call(expr, pred, *args.get(0), args.slice_from(1))\n+                self.call(expr, pred, &**args.get(0), args.slice_from(1).iter().map(|e| &**e))\n             }\n \n             ast::ExprIndex(ref l, ref r) |\n-            ast::ExprBinary(_, ref l, ref r) if self.is_method_call(&*expr) => {\n-                self.call(expr, pred, l.clone(), [r.clone()])\n+            ast::ExprBinary(_, ref l, ref r) if self.is_method_call(expr) => {\n+                self.call(expr, pred, &**l, Some(&**r).move_iter())\n             }\n \n-            ast::ExprUnary(_, ref e) if self.is_method_call(&*expr) => {\n-                self.call(expr, pred, e.clone(), [])\n+            ast::ExprUnary(_, ref e) if self.is_method_call(expr) => {\n+                self.call(expr, pred, &**e, None::<ast::Expr>.iter())\n             }\n \n             ast::ExprTup(ref exprs) => {\n-                self.straightline(expr, pred, exprs.as_slice())\n+                self.straightline(expr, pred, exprs.iter().map(|e| &**e))\n             }\n \n-            ast::ExprStruct(_, ref fields, base) => {\n+            ast::ExprStruct(_, ref fields, ref base) => {\n                 let base_exit = self.opt_expr(base, pred);\n-                let field_exprs: Vec<Gc<ast::Expr>> =\n-                    fields.iter().map(|f| f.expr).collect();\n-                self.straightline(expr, base_exit, field_exprs.as_slice())\n+                self.straightline(expr, base_exit, fields.iter().map(|f| &*f.expr))\n             }\n \n-            ast::ExprRepeat(elem, count) => {\n-                self.straightline(expr, pred, [elem, count])\n+            ast::ExprRepeat(ref elem, ref count) => {\n+                self.straightline(expr, pred, [elem, count].iter().map(|&e| &**e))\n             }\n \n-            ast::ExprAssign(l, r) |\n-            ast::ExprAssignOp(_, l, r) => {\n-                self.straightline(expr, pred, [r, l])\n+            ast::ExprAssign(ref l, ref r) |\n+            ast::ExprAssignOp(_, ref l, ref r) => {\n+                self.straightline(expr, pred, [r, l].iter().map(|&e| &**e))\n             }\n \n-            ast::ExprIndex(l, r) |\n-            ast::ExprBinary(_, l, r) => { // NB: && and || handled earlier\n-                self.straightline(expr, pred, [l, r])\n+            ast::ExprIndex(ref l, ref r) |\n+            ast::ExprBinary(_, ref l, ref r) => { // NB: && and || handled earlier\n+                self.straightline(expr, pred, [l, r].iter().map(|&e| &**e))\n             }\n \n-            ast::ExprBox(p, e) => {\n-                self.straightline(expr, pred, [p, e])\n+            ast::ExprBox(ref p, ref e) => {\n+                self.straightline(expr, pred, [p, e].iter().map(|&e| &**e))\n             }\n \n-            ast::ExprAddrOf(_, e) |\n-            ast::ExprCast(e, _) |\n-            ast::ExprUnary(_, e) |\n-            ast::ExprParen(e) |\n-            ast::ExprField(e, _, _) |\n-            ast::ExprTupField(e, _, _) => {\n-                self.straightline(expr, pred, [e])\n+            ast::ExprAddrOf(_, ref e) |\n+            ast::ExprCast(ref e, _) |\n+            ast::ExprUnary(_, ref e) |\n+            ast::ExprParen(ref e) |\n+            ast::ExprField(ref e, _, _) |\n+            ast::ExprTupField(ref e, _, _) => {\n+                self.straightline(expr, pred, Some(&**e).move_iter())\n             }\n \n             ast::ExprInlineAsm(ref inline_asm) => {\n                 let inputs = inline_asm.inputs.iter();\n                 let outputs = inline_asm.outputs.iter();\n                 let post_inputs = self.exprs(inputs.map(|a| {\n                     debug!(\"cfg::construct InlineAsm id:{} input:{:?}\", expr.id, a);\n-                    let &(_, expr) = a;\n-                    expr\n+                    let &(_, ref expr) = a;\n+                    &**expr\n                 }), pred);\n                 let post_outputs = self.exprs(outputs.map(|a| {\n                     debug!(\"cfg::construct InlineAsm id:{} output:{:?}\", expr.id, a);\n-                    let &(_, expr, _) = a;\n-                    expr\n+                    let &(_, ref expr, _) = a;\n+                    &**expr\n                 }), post_inputs);\n                 self.add_node(expr.id, [post_outputs])\n             }\n@@ -494,16 +486,16 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             ast::ExprUnboxedFn(..) |\n             ast::ExprLit(..) |\n             ast::ExprPath(..) => {\n-                self.straightline(expr, pred, [])\n+                self.straightline(expr, pred, None::<ast::Expr>.iter())\n             }\n         }\n     }\n \n-    fn call(&mut self,\n-            call_expr: Gc<ast::Expr>,\n+    fn call<'a, I: Iterator<&'a ast::Expr>>(&mut self,\n+            call_expr: &ast::Expr,\n             pred: CFGIndex,\n-            func_or_rcvr: Gc<ast::Expr>,\n-            args: &[Gc<ast::Expr>]) -> CFGIndex {\n+            func_or_rcvr: &ast::Expr,\n+            args: I) -> CFGIndex {\n         let func_or_rcvr_exit = self.expr(func_or_rcvr, pred);\n         let ret = self.straightline(call_expr, func_or_rcvr_exit, args);\n \n@@ -516,28 +508,27 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         }\n     }\n \n-    fn exprs<I:Iterator<Gc<ast::Expr>>>(&mut self,\n-                                        mut exprs: I,\n-                                        pred: CFGIndex) -> CFGIndex {\n+    fn exprs<'a, I: Iterator<&'a ast::Expr>>(&mut self,\n+                                             mut exprs: I,\n+                                             pred: CFGIndex) -> CFGIndex {\n         //! Constructs graph for `exprs` evaluated in order\n         exprs.fold(pred, |p, e| self.expr(e, p))\n     }\n \n     fn opt_expr(&mut self,\n-                opt_expr: Option<Gc<ast::Expr>>,\n+                opt_expr: &Option<P<ast::Expr>>,\n                 pred: CFGIndex) -> CFGIndex {\n         //! Constructs graph for `opt_expr` evaluated, if Some\n-\n-        opt_expr.iter().fold(pred, |p, &e| self.expr(e, p))\n+        opt_expr.iter().fold(pred, |p, e| self.expr(&**e, p))\n     }\n \n-    fn straightline(&mut self,\n-                    expr: Gc<ast::Expr>,\n+    fn straightline<'a, I: Iterator<&'a ast::Expr>>(&mut self,\n+                    expr: &ast::Expr,\n                     pred: CFGIndex,\n-                    subexprs: &[Gc<ast::Expr>]) -> CFGIndex {\n+                    subexprs: I) -> CFGIndex {\n         //! Handles case of an expression that evaluates `subexprs` in order\n \n-        let subexprs_exit = self.exprs(subexprs.iter().map(|&e|e), pred);\n+        let subexprs_exit = self.exprs(subexprs, pred);\n         self.add_node(expr.id, [subexprs_exit])\n     }\n \n@@ -566,7 +557,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n     }\n \n     fn add_exiting_edge(&mut self,\n-                        from_expr: Gc<ast::Expr>,\n+                        from_expr: &ast::Expr,\n                         from_index: CFGIndex,\n                         to_loop: LoopScope,\n                         to_index: CFGIndex) {\n@@ -581,7 +572,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n     }\n \n     fn add_returning_edge(&mut self,\n-                          _from_expr: Gc<ast::Expr>,\n+                          _from_expr: &ast::Expr,\n                           from_index: CFGIndex) {\n         let mut data = CFGEdgeData {\n             exiting_scopes: vec!(),\n@@ -593,7 +584,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n     }\n \n     fn find_scope(&self,\n-                  expr: Gc<ast::Expr>,\n+                  expr: &ast::Expr,\n                   label: Option<ast::Ident>) -> LoopScope {\n         match label {\n             None => {"}, {"sha": "84b96edc12652cc32efa890aa97fdea6a18557a1", "filename": "src/librustc/middle/cfg/graphviz.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -22,8 +22,8 @@ use middle::cfg;\n pub type Node<'a> = (cfg::CFGIndex, &'a cfg::CFGNode);\n pub type Edge<'a> = &'a cfg::CFGEdge;\n \n-pub struct LabelledCFG<'a>{\n-    pub ast_map: &'a ast_map::Map,\n+pub struct LabelledCFG<'a, 'ast: 'a> {\n+    pub ast_map: &'a ast_map::Map<'ast>,\n     pub cfg: &'a cfg::CFG,\n     pub name: String,\n }\n@@ -49,7 +49,7 @@ fn replace_newline_with_backslash_l(s: String) -> String {\n     }\n }\n \n-impl<'a> dot::Labeller<'a, Node<'a>, Edge<'a>> for LabelledCFG<'a> {\n+impl<'a, 'ast> dot::Labeller<'a, Node<'a>, Edge<'a>> for LabelledCFG<'a, 'ast> {\n     fn graph_id(&'a self) -> dot::Id<'a> { dot::Id::new(self.name.as_slice()) }\n \n     fn node_id(&'a self, &(i,_): &Node<'a>) -> dot::Id<'a> {\n@@ -110,7 +110,7 @@ impl<'a> dot::GraphWalk<'a, Node<'a>, Edge<'a>> for &'a cfg::CFG {\n     }\n }\n \n-impl<'a> dot::GraphWalk<'a, Node<'a>, Edge<'a>> for LabelledCFG<'a>\n+impl<'a, 'ast> dot::GraphWalk<'a, Node<'a>, Edge<'a>> for LabelledCFG<'a, 'ast>\n {\n     fn nodes(&self) -> dot::Nodes<'a, Node<'a>> { self.cfg.nodes() }\n     fn edges(&self) -> dot::Edges<'a, Edge<'a>> { self.cfg.edges() }"}, {"sha": "303961105b526784a2efdf3a7766d558643d95f7", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -53,15 +53,16 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n     }\n }\n \n-pub fn check_crate(krate: &Crate, tcx: &ty::ctxt) {\n-    visit::walk_crate(&mut CheckCrateVisitor { tcx: tcx, in_const: false }, krate);\n+pub fn check_crate(tcx: &ty::ctxt) {\n+    visit::walk_crate(&mut CheckCrateVisitor { tcx: tcx, in_const: false },\n+                      tcx.map.krate());\n     tcx.sess.abort_if_errors();\n }\n \n fn check_item(v: &mut CheckCrateVisitor, it: &Item) {\n     match it.node {\n-        ItemStatic(_, _, ex) => {\n-            v.inside_const(|v| v.visit_expr(&*ex));\n+        ItemStatic(_, _, ref ex) => {\n+            v.inside_const(|v| v.visit_expr(&**ex));\n             check_item_recursion(&v.tcx.sess, &v.tcx.map, &v.tcx.def_map, it);\n         }\n         ItemEnum(ref enum_definition, _) => {\n@@ -78,9 +79,9 @@ fn check_item(v: &mut CheckCrateVisitor, it: &Item) {\n fn check_pat(v: &mut CheckCrateVisitor, p: &Pat) {\n     fn is_str(e: &Expr) -> bool {\n         match e.node {\n-            ExprBox(_, expr) => {\n+            ExprBox(_, ref expr) => {\n                 match expr.node {\n-                    ExprLit(lit) => ast_util::lit_is_str(lit),\n+                    ExprLit(ref lit) => ast_util::lit_is_str(&**lit),\n                     _ => false,\n                 }\n             }\n@@ -106,7 +107,7 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &Expr) {\n             span_err!(v.tcx.sess, e.span, E0010, \"cannot do allocations in constant expressions\");\n             return;\n           }\n-          ExprLit(lit) if ast_util::lit_is_str(lit) => {}\n+          ExprLit(ref lit) if ast_util::lit_is_str(&**lit) => {}\n           ExprBinary(..) | ExprUnary(..) => {\n             let method_call = typeck::MethodCall::expr(e.id);\n             if v.tcx.method_map.borrow().contains_key(&method_call) {\n@@ -149,7 +150,7 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &Expr) {\n               }\n             }\n           }\n-          ExprCall(callee, _) => {\n+          ExprCall(ref callee, _) => {\n             match v.tcx.def_map.borrow().find(&callee.id) {\n                 Some(&DefStruct(..)) => {}    // OK.\n                 Some(&DefVariant(..)) => {}    // OK.\n@@ -194,7 +195,7 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &Expr) {\n           ExprTup(..) |\n           ExprRepeat(..) |\n           ExprStruct(..) => { }\n-          ExprAddrOf(_, inner) => {\n+          ExprAddrOf(_, ref inner) => {\n                 match inner.node {\n                     // Mutable slices are allowed.\n                     ExprVec(_) => {}\n@@ -214,12 +215,13 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &Expr) {\n     visit::walk_expr(v, e);\n }\n \n-struct CheckItemRecursionVisitor<'a> {\n+struct CheckItemRecursionVisitor<'a, 'ast: 'a> {\n     root_it: &'a Item,\n     sess: &'a Session,\n-    ast_map: &'a ast_map::Map,\n+    ast_map: &'a ast_map::Map<'ast>,\n     def_map: &'a resolve::DefMap,\n-    idstack: Vec<NodeId> }\n+    idstack: Vec<NodeId>\n+}\n \n // Make sure a const item doesn't recursively refer to itself\n // FIXME: Should use the dependency graph when it's available (#1356)\n@@ -238,7 +240,7 @@ pub fn check_item_recursion<'a>(sess: &'a Session,\n     visitor.visit_item(it);\n }\n \n-impl<'a, 'v> Visitor<'v> for CheckItemRecursionVisitor<'a> {\n+impl<'a, 'ast, 'v> Visitor<'v> for CheckItemRecursionVisitor<'a, 'ast> {\n     fn visit_item(&mut self, it: &Item) {\n         if self.idstack.iter().any(|x| x == &(it.id)) {\n             self.sess.span_fatal(self.root_it.span, \"recursive constant\");"}, {"sha": "eb308f903d3dd79546d4667ca3582e20340d7ae4", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 171, "deletions": 166, "changes": 337, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -19,19 +19,26 @@ use middle::pat_util::*;\n use middle::ty::*;\n use middle::ty;\n use std::fmt;\n-use std::gc::{Gc, GC};\n use std::iter::AdditiveIterator;\n use std::iter::range_inclusive;\n+use std::slice;\n use syntax::ast::*;\n use syntax::ast_util::walk_pat;\n use syntax::codemap::{Span, Spanned, DUMMY_SP};\n use syntax::fold::{Folder, noop_fold_pat};\n use syntax::print::pprust::pat_to_string;\n use syntax::parse::token;\n+use syntax::ptr::P;\n use syntax::visit::{mod, Visitor, FnKind};\n use util::ppaux::ty_to_string;\n \n-struct Matrix(Vec<Vec<Gc<Pat>>>);\n+static DUMMY_WILD_PAT: Pat = Pat {\n+    id: DUMMY_NODE_ID,\n+    node: PatWild(PatWildSingle),\n+    span: DUMMY_SP\n+};\n+\n+struct Matrix<'a>(Vec<Vec<&'a Pat>>);\n \n /// Pretty-printer for matrices of patterns, example:\n /// ++++++++++++++++++++++++++\n@@ -45,7 +52,7 @@ struct Matrix(Vec<Vec<Gc<Pat>>>);\n /// ++++++++++++++++++++++++++\n /// + _     + [_, _, ..tail] +\n /// ++++++++++++++++++++++++++\n-impl fmt::Show for Matrix {\n+impl<'a> fmt::Show for Matrix<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, \"\\n\"));\n \n@@ -80,8 +87,8 @@ impl fmt::Show for Matrix {\n     }\n }\n \n-impl FromIterator<Vec<Gc<Pat>>> for Matrix {\n-    fn from_iter<T: Iterator<Vec<Gc<Pat>>>>(mut iterator: T) -> Matrix {\n+impl<'a> FromIterator<Vec<&'a Pat>> for Matrix<'a> {\n+    fn from_iter<T: Iterator<Vec<&'a Pat>>>(mut iterator: T) -> Matrix<'a> {\n         Matrix(iterator.collect())\n     }\n }\n@@ -110,7 +117,7 @@ pub enum Constructor {\n #[deriving(Clone, PartialEq)]\n enum Usefulness {\n     Useful,\n-    UsefulWithWitness(Vec<Gc<Pat>>),\n+    UsefulWithWitness(Vec<P<Pat>>),\n     NotUseful\n }\n \n@@ -132,16 +139,15 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MatchCheckCtxt<'a, 'tcx> {\n     }\n }\n \n-pub fn check_crate(tcx: &ty::ctxt, krate: &Crate) {\n-    let mut cx = MatchCheckCtxt { tcx: tcx };\n-    visit::walk_crate(&mut cx, krate);\n+pub fn check_crate(tcx: &ty::ctxt) {\n+    visit::walk_crate(&mut MatchCheckCtxt { tcx: tcx }, tcx.map.krate());\n     tcx.sess.abort_if_errors();\n }\n \n fn check_expr(cx: &mut MatchCheckCtxt, ex: &Expr) {\n     visit::walk_expr(cx, ex);\n     match ex.node {\n-        ExprMatch(scrut, ref arms) => {\n+        ExprMatch(ref scrut, ref arms) => {\n             // First, check legality of move bindings.\n             for arm in arms.iter() {\n                 check_legality_of_move_bindings(cx,\n@@ -156,28 +162,26 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &Expr) {\n             // assigning or borrowing anything mutably.\n             for arm in arms.iter() {\n                 match arm.guard {\n-                    Some(guard) => check_for_mutation_in_guard(cx, &*guard),\n+                    Some(ref guard) => check_for_mutation_in_guard(cx, &**guard),\n                     None => {}\n                 }\n             }\n \n             let mut static_inliner = StaticInliner::new(cx.tcx);\n-            let inlined_arms = arms\n-                .iter()\n-                .map(|arm| Arm {\n-                    pats: arm.pats.iter().map(|pat| {\n-                        static_inliner.fold_pat(*pat)\n-                    }).collect(),\n-                    ..arm.clone()\n-                })\n-                .collect::<Vec<Arm>>();\n+            let inlined_arms = arms.iter().map(|arm| {\n+                (arm.pats.iter().map(|pat| {\n+                    static_inliner.fold_pat((*pat).clone())\n+                }).collect(), arm.guard.as_ref().map(|e| &**e))\n+            }).collect::<Vec<(Vec<P<Pat>>, Option<&Expr>)>>();\n \n             if static_inliner.failed {\n                 return;\n             }\n \n             // Third, check if there are any references to NaN that we should warn about.\n-            check_for_static_nan(cx, inlined_arms.as_slice());\n+            for &(ref pats, _) in inlined_arms.iter() {\n+                check_for_static_nan(cx, pats.as_slice());\n+            }\n \n             // Fourth, check for unreachable arms.\n             check_arms(cx, inlined_arms.as_slice());\n@@ -198,28 +202,25 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &Expr) {\n             }\n \n             let matrix: Matrix = inlined_arms\n-                .move_iter()\n-                .filter(|arm| arm.guard.is_none())\n-                .flat_map(|arm| arm.pats.move_iter())\n-                .map(|pat| vec![pat])\n+                .iter()\n+                .filter(|&&(_, guard)| guard.is_none())\n+                .flat_map(|arm| arm.ref0().iter())\n+                .map(|pat| vec![&**pat])\n                 .collect();\n             check_exhaustive(cx, ex.span, &matrix);\n         },\n         ExprForLoop(ref pat, _, _, _) => {\n             let mut static_inliner = StaticInliner::new(cx.tcx);\n-            match is_refutable(cx, static_inliner.fold_pat(*pat)) {\n-                Some(uncovered_pat) => {\n-                    cx.tcx.sess.span_err(\n-                        pat.span,\n-                        format!(\"refutable pattern in `for` loop binding: \\\n-                                 `{}` not covered\",\n-                                pat_to_string(&*uncovered_pat)).as_slice());\n-                },\n-                None => {}\n-            }\n+            is_refutable(cx, &*static_inliner.fold_pat((*pat).clone()), |uncovered_pat| {\n+                cx.tcx.sess.span_err(\n+                    pat.span,\n+                    format!(\"refutable pattern in `for` loop binding: \\\n+                            `{}` not covered\",\n+                            pat_to_string(uncovered_pat)).as_slice());\n+            });\n \n             // Check legality of move bindings.\n-            check_legality_of_move_bindings(cx, false, [ *pat ]);\n+            check_legality_of_move_bindings(cx, false, slice::ref_slice(pat));\n             check_legality_of_bindings_in_at_patterns(cx, &**pat);\n         }\n         _ => ()\n@@ -234,36 +235,34 @@ fn is_expr_const_nan(tcx: &ty::ctxt, expr: &Expr) -> bool {\n }\n \n // Check that we do not match against a static NaN (#6804)\n-fn check_for_static_nan(cx: &MatchCheckCtxt, arms: &[Arm]) {\n-    for arm in arms.iter() {\n-        for &pat in arm.pats.iter() {\n-            walk_pat(&*pat, |p| {\n-                match p.node {\n-                    PatLit(expr) if is_expr_const_nan(cx.tcx, &*expr) => {\n-                        span_warn!(cx.tcx.sess, p.span, E0003,\n-                            \"unmatchable NaN in pattern, \\\n-                             use the is_nan method in a guard instead\");\n-                    }\n-                    _ => ()\n+fn check_for_static_nan(cx: &MatchCheckCtxt, pats: &[P<Pat>]) {\n+    for pat in pats.iter() {\n+        walk_pat(&**pat, |p| {\n+            match p.node {\n+                PatLit(ref expr) if is_expr_const_nan(cx.tcx, &**expr) => {\n+                    span_warn!(cx.tcx.sess, p.span, E0003,\n+                        \"unmatchable NaN in pattern, \\\n+                            use the is_nan method in a guard instead\");\n                 }\n-                true\n-            });\n-        }\n+                _ => ()\n+            }\n+            true\n+        });\n     }\n }\n \n // Check for unreachable patterns\n-fn check_arms(cx: &MatchCheckCtxt, arms: &[Arm]) {\n-    let mut seen = Matrix(vec!());\n-    for arm in arms.iter() {\n-        for &pat in arm.pats.iter() {\n-            let v = vec![pat];\n+fn check_arms(cx: &MatchCheckCtxt, arms: &[(Vec<P<Pat>>, Option<&Expr>)]) {\n+    let mut seen = Matrix(vec![]);\n+    for &(ref pats, guard) in arms.iter() {\n+        for pat in pats.iter() {\n+            let v = vec![&**pat];\n             match is_useful(cx, &seen, v.as_slice(), LeaveOutWitness) {\n                 NotUseful => span_err!(cx.tcx.sess, pat.span, E0001, \"unreachable pattern\"),\n                 Useful => (),\n                 UsefulWithWitness(_) => unreachable!()\n             }\n-            if arm.guard.is_none() {\n+            if guard.is_none() {\n                 let Matrix(mut rows) = seen;\n                 rows.push(v);\n                 seen = Matrix(rows);\n@@ -272,17 +271,24 @@ fn check_arms(cx: &MatchCheckCtxt, arms: &[Arm]) {\n     }\n }\n \n+fn raw_pat<'a>(p: &'a Pat) -> &'a Pat {\n+    match p.node {\n+        PatIdent(_, _, Some(ref s)) => raw_pat(&**s),\n+        _ => p\n+    }\n+}\n+\n fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, matrix: &Matrix) {\n-    match is_useful(cx, matrix, [wild()], ConstructWitness) {\n+    match is_useful(cx, matrix, &[&DUMMY_WILD_PAT], ConstructWitness) {\n         UsefulWithWitness(pats) => {\n             let witness = match pats.as_slice() {\n-                [witness] => witness,\n-                [] => wild(),\n+                [ref witness] => &**witness,\n+                [] => &DUMMY_WILD_PAT,\n                 _ => unreachable!()\n             };\n             span_err!(cx.tcx.sess, sp, E0004,\n                 \"non-exhaustive patterns: `{}` not covered\",\n-                pat_to_string(&*witness)\n+                pat_to_string(witness)\n             );\n         }\n         NotUseful => {\n@@ -292,17 +298,17 @@ fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, matrix: &Matrix) {\n     }\n }\n \n-fn const_val_to_expr(value: &const_val) -> Gc<Expr> {\n+fn const_val_to_expr(value: &const_val) -> P<Expr> {\n     let node = match value {\n         &const_bool(b) => LitBool(b),\n         &const_nil => LitNil,\n         _ => unreachable!()\n     };\n-    box (GC) Expr {\n+    P(Expr {\n         id: 0,\n-        node: ExprLit(box(GC) Spanned { node: node, span: DUMMY_SP }),\n+        node: ExprLit(P(Spanned { node: node, span: DUMMY_SP })),\n         span: DUMMY_SP\n-    }\n+    })\n }\n \n pub struct StaticInliner<'a, 'tcx: 'a> {\n@@ -320,16 +326,18 @@ impl<'a, 'tcx> StaticInliner<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> Folder for StaticInliner<'a, 'tcx> {\n-    fn fold_pat(&mut self, pat: Gc<Pat>) -> Gc<Pat> {\n+    fn fold_pat(&mut self, pat: P<Pat>) -> P<Pat> {\n         match pat.node {\n             PatIdent(..) | PatEnum(..) => {\n                 let def = self.tcx.def_map.borrow().find_copy(&pat.id);\n                 match def {\n                     Some(DefStatic(did, _)) => match lookup_const_by_id(self.tcx, did) {\n-                        Some(const_expr) => box (GC) Pat {\n-                            span: pat.span,\n-                            ..(*const_expr_to_pat(self.tcx, const_expr)).clone()\n-                        },\n+                        Some(const_expr) => {\n+                            const_expr_to_pat(self.tcx, const_expr).map(|mut new_pat| {\n+                                new_pat.span = pat.span;\n+                                new_pat\n+                            })\n+                        }\n                         None => {\n                             self.failed = true;\n                             span_err!(self.tcx.sess, pat.span, E0158,\n@@ -359,9 +367,11 @@ impl<'a, 'tcx> Folder for StaticInliner<'a, 'tcx> {\n /// left_ty: struct X { a: (bool, &'static str), b: uint}\n /// pats: [(false, \"foo\"), 42]  => X { a: (false, \"foo\"), b: 42 }\n fn construct_witness(cx: &MatchCheckCtxt, ctor: &Constructor,\n-                     pats: Vec<Gc<Pat>>, left_ty: ty::t) -> Gc<Pat> {\n+                     pats: Vec<&Pat>, left_ty: ty::t) -> P<Pat> {\n+    let pats_len = pats.len();\n+    let mut pats = pats.move_iter().map(|p| P((*p).clone()));\n     let pat = match ty::get(left_ty).sty {\n-        ty::ty_tup(_) => PatTup(pats),\n+        ty::ty_tup(_) => PatTup(pats.collect()),\n \n         ty::ty_enum(cid, _) | ty::ty_struct(cid, _)  => {\n             let (vid, is_structure) = match ctor {\n@@ -374,52 +384,52 @@ fn construct_witness(cx: &MatchCheckCtxt, ctor: &Constructor,\n             if is_structure {\n                 let fields = ty::lookup_struct_fields(cx.tcx, vid);\n                 let field_pats: Vec<FieldPat> = fields.move_iter()\n-                    .zip(pats.iter())\n-                    .filter(|&(_, pat)| pat.node != PatWild(PatWildSingle))\n+                    .zip(pats)\n+                    .filter(|&(_, ref pat)| pat.node != PatWild(PatWildSingle))\n                     .map(|(field, pat)| FieldPat {\n                         ident: Ident::new(field.name),\n-                        pat: pat.clone()\n+                        pat: pat\n                     }).collect();\n-                let has_more_fields = field_pats.len() < pats.len();\n+                let has_more_fields = field_pats.len() < pats_len;\n                 PatStruct(def_to_path(cx.tcx, vid), field_pats, has_more_fields)\n             } else {\n-                PatEnum(def_to_path(cx.tcx, vid), Some(pats))\n+                PatEnum(def_to_path(cx.tcx, vid), Some(pats.collect()))\n             }\n         }\n \n         ty::ty_rptr(_, ty::mt { ty: ty, .. }) => {\n             match ty::get(ty).sty {\n                ty::ty_vec(_, Some(n)) => match ctor {\n                     &Single => {\n-                        assert_eq!(pats.len(), n);\n-                        PatVec(pats, None, vec!())\n+                        assert_eq!(pats_len, n);\n+                        PatVec(pats.collect(), None, vec!())\n                     },\n                     _ => unreachable!()\n                 },\n                 ty::ty_vec(_, None) => match ctor {\n                     &Slice(n) => {\n-                        assert_eq!(pats.len(), n);\n-                        PatVec(pats, None, vec!())\n+                        assert_eq!(pats_len, n);\n+                        PatVec(pats.collect(), None, vec!())\n                     },\n                     _ => unreachable!()\n                 },\n                 ty::ty_str => PatWild(PatWildSingle),\n \n                 _ => {\n-                    assert_eq!(pats.len(), 1);\n-                    PatRegion(pats.get(0).clone())\n+                    assert_eq!(pats_len, 1);\n+                    PatRegion(pats.nth(0).unwrap())\n                 }\n             }\n         }\n \n         ty::ty_box(_) => {\n-            assert_eq!(pats.len(), 1);\n-            PatBox(pats.get(0).clone())\n+            assert_eq!(pats_len, 1);\n+            PatBox(pats.nth(0).unwrap())\n         }\n \n         ty::ty_vec(_, Some(len)) => {\n-            assert_eq!(pats.len(), len);\n-            PatVec(pats, None, vec!())\n+            assert_eq!(pats_len, len);\n+            PatVec(pats.collect(), None, vec![])\n         }\n \n         _ => {\n@@ -430,11 +440,11 @@ fn construct_witness(cx: &MatchCheckCtxt, ctor: &Constructor,\n         }\n     };\n \n-    box (GC) Pat {\n+    P(Pat {\n         id: 0,\n         node: pat,\n         span: DUMMY_SP\n-    }\n+    })\n }\n \n fn missing_constructor(cx: &MatchCheckCtxt, &Matrix(ref rows): &Matrix,\n@@ -492,7 +502,7 @@ fn all_constructors(cx: &MatchCheckCtxt, left_ty: ty::t,\n // So it assumes that v is non-empty.\n fn is_useful(cx: &MatchCheckCtxt,\n              matrix: &Matrix,\n-             v: &[Gc<Pat>],\n+             v: &[&Pat],\n              witness: WitnessPreference)\n              -> Usefulness {\n     let &Matrix(ref rows) = matrix;\n@@ -506,12 +516,12 @@ fn is_useful(cx: &MatchCheckCtxt,\n     if rows.get(0).len() == 0u {\n         return NotUseful;\n     }\n-    let real_pat = match rows.iter().find(|r| r.get(0).id != 0) {\n+    let real_pat = match rows.iter().find(|r| r.get(0).id != DUMMY_NODE_ID) {\n         Some(r) => raw_pat(*r.get(0)),\n         None if v.len() == 0 => return NotUseful,\n         None => v[0]\n     };\n-    let left_ty = if real_pat.id == 0 {\n+    let left_ty = if real_pat.id == DUMMY_NODE_ID {\n         ty::mk_nil()\n     } else {\n         ty::pat_ty(cx.tcx, &*real_pat)\n@@ -530,14 +540,13 @@ fn is_useful(cx: &MatchCheckCtxt,\n                     match is_useful_specialized(cx, matrix, v, c.clone(), left_ty, witness) {\n                         UsefulWithWitness(pats) => UsefulWithWitness({\n                             let arity = constructor_arity(cx, &c, left_ty);\n-                            let subpats = {\n+                            let mut result = {\n                                 let pat_slice = pats.as_slice();\n-                                Vec::from_fn(arity, |i| {\n-                                    pat_slice.get(i).map(|p| p.clone())\n-                                        .unwrap_or_else(|| wild())\n-                                })\n+                                let subpats = Vec::from_fn(arity, |i| {\n+                                    pat_slice.get(i).map_or(&DUMMY_WILD_PAT, |p| &**p)\n+                                });\n+                                vec![construct_witness(cx, &c, subpats, left_ty)]\n                             };\n-                            let mut result = vec!(construct_witness(cx, &c, subpats, left_ty));\n                             result.extend(pats.move_iter().skip(arity));\n                             result\n                         }),\n@@ -547,13 +556,21 @@ fn is_useful(cx: &MatchCheckCtxt,\n             },\n \n             Some(constructor) => {\n-                let matrix = rows.iter().filter_map(|r| default(cx, r.as_slice())).collect();\n+                let matrix = rows.iter().filter_map(|r| {\n+                    if pat_is_binding_or_wild(&cx.tcx.def_map, raw_pat(r[0])) {\n+                        Some(Vec::from_slice(r.tail()))\n+                    } else {\n+                        None\n+                    }\n+                }).collect();\n                 match is_useful(cx, &matrix, v.tail(), witness) {\n                     UsefulWithWitness(pats) => {\n                         let arity = constructor_arity(cx, &constructor, left_ty);\n-                        let wild_pats = Vec::from_elem(arity, wild());\n+                        let wild_pats = Vec::from_elem(arity, &DUMMY_WILD_PAT);\n                         let enum_pat = construct_witness(cx, &constructor, wild_pats, left_ty);\n-                        UsefulWithWitness(vec!(enum_pat).append(pats.as_slice()))\n+                        let mut new_pats = vec![enum_pat];\n+                        new_pats.extend(pats.move_iter());\n+                        UsefulWithWitness(new_pats)\n                     },\n                     result => result\n                 }\n@@ -566,8 +583,9 @@ fn is_useful(cx: &MatchCheckCtxt,\n     }\n }\n \n-fn is_useful_specialized(cx: &MatchCheckCtxt, &Matrix(ref m): &Matrix, v: &[Gc<Pat>],\n-                         ctor: Constructor, lty: ty::t, witness: WitnessPreference) -> Usefulness {\n+fn is_useful_specialized(cx: &MatchCheckCtxt, &Matrix(ref m): &Matrix,\n+                         v: &[&Pat], ctor: Constructor, lty: ty::t,\n+                         witness: WitnessPreference) -> Usefulness {\n     let arity = constructor_arity(cx, &ctor, lty);\n     let matrix = Matrix(m.iter().filter_map(|r| {\n         specialize(cx, r.as_slice(), &ctor, 0u, arity)\n@@ -587,7 +605,7 @@ fn is_useful_specialized(cx: &MatchCheckCtxt, &Matrix(ref m): &Matrix, v: &[Gc<P\n ///\n /// On the other hand, a wild pattern and an identifier pattern cannot be\n /// specialized in any way.\n-fn pat_constructors(cx: &MatchCheckCtxt, p: Gc<Pat>,\n+fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n                     left_ty: ty::t, max_slice_length: uint) -> Vec<Constructor> {\n     let pat = raw_pat(p);\n     match pat.node {\n@@ -613,10 +631,10 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: Gc<Pat>,\n                 Some(&DefVariant(_, id, _)) => vec!(Variant(id)),\n                 _ => vec!(Single)\n             },\n-        PatLit(expr) =>\n-            vec!(ConstantValue(eval_const_expr(cx.tcx, &*expr))),\n-        PatRange(lo, hi) =>\n-            vec!(ConstantRange(eval_const_expr(cx.tcx, &*lo), eval_const_expr(cx.tcx, &*hi))),\n+        PatLit(ref expr) =>\n+            vec!(ConstantValue(eval_const_expr(cx.tcx, &**expr))),\n+        PatRange(ref lo, ref hi) =>\n+            vec!(ConstantRange(eval_const_expr(cx.tcx, &**lo), eval_const_expr(cx.tcx, &**hi))),\n         PatVec(ref before, ref slice, ref after) =>\n             match ty::get(left_ty).sty {\n                 ty::ty_vec(_, Some(_)) => vec!(Single),\n@@ -691,14 +709,15 @@ fn range_covered_by_constructor(ctor: &Constructor,\n /// different patterns.\n /// Structure patterns with a partial wild pattern (Foo { a: 42, .. }) have their missing\n /// fields filled with wild patterns.\n-pub fn specialize(cx: &MatchCheckCtxt, r: &[Gc<Pat>],\n-                  constructor: &Constructor, col: uint, arity: uint) -> Option<Vec<Gc<Pat>>> {\n+pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n+                      constructor: &Constructor, col: uint, arity: uint) -> Option<Vec<&'a Pat>> {\n     let &Pat {\n         id: pat_id, node: ref node, span: pat_span\n-    } = &(*raw_pat(r[col]));\n-    let head: Option<Vec<Gc<Pat>>> = match node {\n+    } = raw_pat(r[col]);\n+    let head: Option<Vec<&Pat>> = match node {\n+\n         &PatWild(_) =>\n-            Some(Vec::from_elem(arity, wild())),\n+            Some(Vec::from_elem(arity, &DUMMY_WILD_PAT)),\n \n         &PatIdent(_, _, _) => {\n             let opt_def = cx.tcx.def_map.borrow().find_copy(&pat_id);\n@@ -710,7 +729,7 @@ pub fn specialize(cx: &MatchCheckCtxt, r: &[Gc<Pat>],\n                 } else {\n                     None\n                 },\n-                _ => Some(Vec::from_elem(arity, wild()))\n+                _ => Some(Vec::from_elem(arity, &DUMMY_WILD_PAT))\n             }\n         }\n \n@@ -722,8 +741,8 @@ pub fn specialize(cx: &MatchCheckCtxt, r: &[Gc<Pat>],\n                 DefVariant(_, id, _) if *constructor != Variant(id) => None,\n                 DefVariant(..) | DefFn(..) | DefStruct(..) => {\n                     Some(match args {\n-                        &Some(ref args) => args.clone(),\n-                        &None => Vec::from_elem(arity, wild())\n+                        &Some(ref args) => args.iter().map(|p| &**p).collect(),\n+                        &None => Vec::from_elem(arity, &DUMMY_WILD_PAT)\n                     })\n                 }\n                 _ => None\n@@ -757,24 +776,24 @@ pub fn specialize(cx: &MatchCheckCtxt, r: &[Gc<Pat>],\n                 let struct_fields = ty::lookup_struct_fields(cx.tcx, variant_id);\n                 let args = struct_fields.iter().map(|sf| {\n                     match pattern_fields.iter().find(|f| f.ident.name == sf.name) {\n-                        Some(f) => f.pat,\n-                        _ => wild()\n+                        Some(ref f) => &*f.pat,\n+                        _ => &DUMMY_WILD_PAT\n                     }\n                 }).collect();\n                 args\n             })\n         }\n \n         &PatTup(ref args) =>\n-            Some(args.clone()),\n+            Some(args.iter().map(|p| &**p).collect()),\n \n         &PatBox(ref inner) | &PatRegion(ref inner) =>\n-            Some(vec!(inner.clone())),\n+            Some(vec![&**inner]),\n \n         &PatLit(ref expr) => {\n             let expr_value = eval_const_expr(cx.tcx, &**expr);\n             match range_covered_by_constructor(constructor, &expr_value, &expr_value) {\n-                Some(true) => Some(vec!()),\n+                Some(true) => Some(vec![]),\n                 Some(false) => None,\n                 None => {\n                     cx.tcx.sess.span_err(pat_span, \"mismatched types between arms\");\n@@ -787,7 +806,7 @@ pub fn specialize(cx: &MatchCheckCtxt, r: &[Gc<Pat>],\n             let from_value = eval_const_expr(cx.tcx, &**from);\n             let to_value = eval_const_expr(cx.tcx, &**to);\n             match range_covered_by_constructor(constructor, &from_value, &to_value) {\n-                Some(true) => Some(vec!()),\n+                Some(true) => Some(vec![]),\n                 Some(false) => None,\n                 None => {\n                     cx.tcx.sess.span_err(pat_span, \"mismatched types between arms\");\n@@ -800,28 +819,28 @@ pub fn specialize(cx: &MatchCheckCtxt, r: &[Gc<Pat>],\n             match *constructor {\n                 // Fixed-length vectors.\n                 Single => {\n-                    let mut pats = before.clone();\n-                    pats.grow_fn(arity - before.len() - after.len(), |_| wild());\n-                    pats.push_all(after.as_slice());\n+                    let mut pats: Vec<&Pat> = before.iter().map(|p| &**p).collect();\n+                    pats.grow_fn(arity - before.len() - after.len(), |_| &DUMMY_WILD_PAT);\n+                    pats.extend(after.iter().map(|p| &**p));\n                     Some(pats)\n                 },\n                 Slice(length) if before.len() + after.len() <= length && slice.is_some() => {\n-                    let mut pats = before.clone();\n-                    pats.grow_fn(arity - before.len() - after.len(), |_| wild());\n-                    pats.push_all(after.as_slice());\n+                    let mut pats: Vec<&Pat> = before.iter().map(|p| &**p).collect();\n+                    pats.grow_fn(arity - before.len() - after.len(), |_| &DUMMY_WILD_PAT);\n+                    pats.extend(after.iter().map(|p| &**p));\n                     Some(pats)\n                 },\n                 Slice(length) if before.len() + after.len() == length => {\n-                    let mut pats = before.clone();\n-                    pats.push_all(after.as_slice());\n+                    let mut pats: Vec<&Pat> = before.iter().map(|p| &**p).collect();\n+                    pats.extend(after.iter().map(|p| &**p));\n                     Some(pats)\n                 },\n                 SliceWithSubslice(prefix, suffix)\n                     if before.len() == prefix\n                         && after.len() == suffix\n                         && slice.is_some() => {\n-                    let mut pats = before.clone();\n-                    pats.push_all(after.as_slice());\n+                    let mut pats: Vec<&Pat> = before.iter().map(|p| &**p).collect();\n+                    pats.extend(after.iter().map(|p| &**p));\n                     Some(pats)\n                 }\n                 _ => None\n@@ -836,14 +855,6 @@ pub fn specialize(cx: &MatchCheckCtxt, r: &[Gc<Pat>],\n     head.map(|head| head.append(r.slice_to(col)).append(r.slice_from(col + 1)))\n }\n \n-fn default(cx: &MatchCheckCtxt, r: &[Gc<Pat>]) -> Option<Vec<Gc<Pat>>> {\n-    if pat_is_binding_or_wild(&cx.tcx.def_map, &*raw_pat(r[0])) {\n-        Some(Vec::from_slice(r.tail()))\n-    } else {\n-        None\n-    }\n-}\n-\n fn check_local(cx: &mut MatchCheckCtxt, loc: &Local) {\n     visit::walk_local(cx, loc);\n \n@@ -853,18 +864,15 @@ fn check_local(cx: &mut MatchCheckCtxt, loc: &Local) {\n     };\n \n     let mut static_inliner = StaticInliner::new(cx.tcx);\n-    match is_refutable(cx, static_inliner.fold_pat(loc.pat)) {\n-        Some(pat) => {\n-            span_err!(cx.tcx.sess, loc.pat.span, E0005,\n-                \"refutable pattern in {} binding: `{}` not covered\",\n-                name, pat_to_string(&*pat)\n-            );\n-        },\n-        None => ()\n-    }\n+    is_refutable(cx, &*static_inliner.fold_pat(loc.pat.clone()), |pat| {\n+        span_err!(cx.tcx.sess, loc.pat.span, E0005,\n+            \"refutable pattern in {} binding: `{}` not covered\",\n+            name, pat_to_string(pat)\n+        );\n+    });\n \n     // Check legality of move bindings and `@` patterns.\n-    check_legality_of_move_bindings(cx, false, [ loc.pat ]);\n+    check_legality_of_move_bindings(cx, false, slice::ref_slice(&loc.pat));\n     check_legality_of_bindings_in_at_patterns(cx, &*loc.pat);\n }\n \n@@ -875,26 +883,23 @@ fn check_fn(cx: &mut MatchCheckCtxt,\n             sp: Span) {\n     visit::walk_fn(cx, kind, decl, body, sp);\n     for input in decl.inputs.iter() {\n-        match is_refutable(cx, input.pat) {\n-            Some(pat) => {\n-                span_err!(cx.tcx.sess, input.pat.span, E0006,\n-                    \"refutable pattern in function argument: `{}` not covered\",\n-                    pat_to_string(&*pat)\n-                );\n-            },\n-            None => ()\n-        }\n-        check_legality_of_move_bindings(cx, false, [input.pat]);\n+        is_refutable(cx, &*input.pat, |pat| {\n+            span_err!(cx.tcx.sess, input.pat.span, E0006,\n+                \"refutable pattern in function argument: `{}` not covered\",\n+                pat_to_string(pat)\n+            );\n+        });\n+        check_legality_of_move_bindings(cx, false, slice::ref_slice(&input.pat));\n         check_legality_of_bindings_in_at_patterns(cx, &*input.pat);\n     }\n }\n \n-fn is_refutable(cx: &MatchCheckCtxt, pat: Gc<Pat>) -> Option<Gc<Pat>> {\n+fn is_refutable<A>(cx: &MatchCheckCtxt, pat: &Pat, refutable: |&Pat| -> A) -> Option<A> {\n     let pats = Matrix(vec!(vec!(pat)));\n-    match is_useful(cx, &pats, [wild()], ConstructWitness) {\n+    match is_useful(cx, &pats, [&DUMMY_WILD_PAT], ConstructWitness) {\n         UsefulWithWitness(pats) => {\n             assert_eq!(pats.len(), 1);\n-            Some(pats.get(0).clone())\n+            Some(refutable(&*pats[0]))\n         },\n         NotUseful => None,\n         Useful => unreachable!()\n@@ -904,7 +909,7 @@ fn is_refutable(cx: &MatchCheckCtxt, pat: Gc<Pat>) -> Option<Gc<Pat>> {\n // Legality of move bindings checking\n fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n                                    has_guard: bool,\n-                                   pats: &[Gc<Pat>]) {\n+                                   pats: &[P<Pat>]) {\n     let tcx = cx.tcx;\n     let def_map = &tcx.def_map;\n     let mut by_ref_span = None;\n@@ -920,7 +925,7 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n         })\n     }\n \n-    let check_move: |&Pat, Option<Gc<Pat>>| = |p, sub| {\n+    let check_move: |&Pat, Option<&Pat>| = |p, sub| {\n         // check legality of moving out of the enum\n \n         // x @ Foo(..) is legal, but x @ Foo(y) isn't.\n@@ -939,10 +944,10 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n         walk_pat(&**pat, |p| {\n             if pat_is_binding(def_map, &*p) {\n                 match p.node {\n-                    PatIdent(BindByValue(_), _, sub) => {\n+                    PatIdent(BindByValue(_), _, ref sub) => {\n                         let pat_ty = ty::node_id_to_type(tcx, p.id);\n                         if ty::type_moves_by_default(tcx, pat_ty) {\n-                            check_move(p, sub);\n+                            check_move(p, sub.as_ref().map(|p| &**p));\n                         }\n                     }\n                     PatIdent(BindByRef(_), _, _) => {"}, {"sha": "7a11090a8eecbfa7a6a13a1d8086e1eb036f7551", "filename": "src/librustc/middle/check_static.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -56,8 +56,9 @@ struct CheckStaticVisitor<'a, 'tcx: 'a> {\n     in_const: bool\n }\n \n-pub fn check_crate(tcx: &ty::ctxt, krate: &ast::Crate) {\n-    visit::walk_crate(&mut CheckStaticVisitor { tcx: tcx, in_const: false }, krate)\n+pub fn check_crate(tcx: &ty::ctxt) {\n+    visit::walk_crate(&mut CheckStaticVisitor { tcx: tcx, in_const: false },\n+                      tcx.map.krate())\n }\n \n impl<'a, 'tcx> CheckStaticVisitor<'a, 'tcx> {"}, {"sha": "8c7c8eda2d27893c4a1cf47524e252c9f986118e", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 64, "deletions": 59, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -22,12 +22,12 @@ use util::nodemap::{DefIdMap};\n \n use syntax::ast::*;\n use syntax::parse::token::InternedString;\n+use syntax::ptr::P;\n use syntax::visit::Visitor;\n use syntax::visit;\n use syntax::{ast, ast_map, ast_util};\n \n use std::rc::Rc;\n-use std::gc::{Gc, GC};\n \n //\n // This pass classifies expressions by their constant-ness.\n@@ -83,7 +83,7 @@ pub fn join_all<It: Iterator<constness>>(mut cs: It) -> constness {\n     cs.fold(integral_const, |a, b| join(a, b))\n }\n \n-pub fn lookup_const(tcx: &ty::ctxt, e: &Expr) -> Option<Gc<Expr>> {\n+fn lookup_const<'a>(tcx: &'a ty::ctxt, e: &Expr) -> Option<&'a Expr> {\n     let opt_def = tcx.def_map.borrow().find_copy(&e.id);\n     match opt_def {\n         Some(def::DefStatic(def_id, false)) => {\n@@ -96,83 +96,90 @@ pub fn lookup_const(tcx: &ty::ctxt, e: &Expr) -> Option<Gc<Expr>> {\n     }\n }\n \n-pub fn lookup_variant_by_id(tcx: &ty::ctxt,\n+fn lookup_variant_by_id<'a>(tcx: &'a ty::ctxt,\n                             enum_def: ast::DefId,\n                             variant_def: ast::DefId)\n-                       -> Option<Gc<Expr>> {\n-    fn variant_expr(variants: &[ast::P<ast::Variant>],\n-                    id: ast::NodeId) -> Option<Gc<Expr>> {\n+                            -> Option<&'a Expr> {\n+    fn variant_expr<'a>(variants: &'a [P<ast::Variant>], id: ast::NodeId)\n+                        -> Option<&'a Expr> {\n         for variant in variants.iter() {\n             if variant.node.id == id {\n-                return variant.node.disr_expr;\n+                return variant.node.disr_expr.as_ref().map(|e| &**e);\n             }\n         }\n         None\n     }\n \n     if ast_util::is_local(enum_def) {\n-        {\n-            match tcx.map.find(enum_def.node) {\n-                None => None,\n-                Some(ast_map::NodeItem(it)) => match it.node {\n-                    ItemEnum(ast::EnumDef { variants: ref variants }, _) => {\n-                        variant_expr(variants.as_slice(), variant_def.node)\n-                    }\n-                    _ => None\n-                },\n-                Some(_) => None\n-            }\n+        match tcx.map.find(enum_def.node) {\n+            None => None,\n+            Some(ast_map::NodeItem(it)) => match it.node {\n+                ItemEnum(ast::EnumDef { variants: ref variants }, _) => {\n+                    variant_expr(variants.as_slice(), variant_def.node)\n+                }\n+                _ => None\n+            },\n+            Some(_) => None\n         }\n     } else {\n         match tcx.extern_const_variants.borrow().find(&variant_def) {\n-            Some(&e) => return e,\n+            Some(&ast::DUMMY_NODE_ID) => return None,\n+            Some(&expr_id) => {\n+                return Some(tcx.map.expect_expr(expr_id));\n+            }\n             None => {}\n         }\n-        let e = match csearch::maybe_get_item_ast(tcx, enum_def,\n+        let expr_id = match csearch::maybe_get_item_ast(tcx, enum_def,\n             |a, b, c, d| astencode::decode_inlined_item(a, b, c, d)) {\n-            csearch::found(ast::IIItem(item)) => match item.node {\n+            csearch::found(&ast::IIItem(ref item)) => match item.node {\n                 ItemEnum(ast::EnumDef { variants: ref variants }, _) => {\n-                    variant_expr(variants.as_slice(), variant_def.node)\n+                    // NOTE this doesn't do the right thing, it compares inlined\n+                    // NodeId's to the original variant_def's NodeId, but they\n+                    // come from different crates, so they will likely never match.\n+                    variant_expr(variants.as_slice(), variant_def.node).map(|e| e.id)\n                 }\n                 _ => None\n             },\n             _ => None\n         };\n-        tcx.extern_const_variants.borrow_mut().insert(variant_def, e);\n-        return e;\n+        tcx.extern_const_variants.borrow_mut().insert(variant_def,\n+                                                      expr_id.unwrap_or(ast::DUMMY_NODE_ID));\n+        expr_id.map(|id| tcx.map.expect_expr(id))\n     }\n }\n \n-pub fn lookup_const_by_id(tcx: &ty::ctxt, def_id: ast::DefId)\n-                          -> Option<Gc<Expr>> {\n+pub fn lookup_const_by_id<'a>(tcx: &'a ty::ctxt, def_id: ast::DefId)\n+                          -> Option<&'a Expr> {\n     if ast_util::is_local(def_id) {\n-        {\n-            match tcx.map.find(def_id.node) {\n-                None => None,\n-                Some(ast_map::NodeItem(it)) => match it.node {\n-                    ItemStatic(_, ast::MutImmutable, const_expr) => {\n-                        Some(const_expr)\n-                    }\n-                    _ => None\n-                },\n-                Some(_) => None\n-            }\n+        match tcx.map.find(def_id.node) {\n+            None => None,\n+            Some(ast_map::NodeItem(it)) => match it.node {\n+                ItemStatic(_, ast::MutImmutable, ref const_expr) => {\n+                    Some(&**const_expr)\n+                }\n+                _ => None\n+            },\n+            Some(_) => None\n         }\n     } else {\n         match tcx.extern_const_statics.borrow().find(&def_id) {\n-            Some(&e) => return e,\n+            Some(&ast::DUMMY_NODE_ID) => return None,\n+            Some(&expr_id) => {\n+                return Some(tcx.map.expect_expr(expr_id));\n+            }\n             None => {}\n         }\n-        let e = match csearch::maybe_get_item_ast(tcx, def_id,\n+        let expr_id = match csearch::maybe_get_item_ast(tcx, def_id,\n             |a, b, c, d| astencode::decode_inlined_item(a, b, c, d)) {\n-            csearch::found(ast::IIItem(item)) => match item.node {\n-                ItemStatic(_, ast::MutImmutable, const_expr) => Some(const_expr),\n+            csearch::found(&ast::IIItem(ref item)) => match item.node {\n+                ItemStatic(_, ast::MutImmutable, ref const_expr) => Some(const_expr.id),\n                 _ => None\n             },\n             _ => None\n         };\n-        tcx.extern_const_statics.borrow_mut().insert(def_id, e);\n-        return e;\n+        tcx.extern_const_statics.borrow_mut().insert(def_id,\n+                                                     expr_id.unwrap_or(ast::DUMMY_NODE_ID));\n+        expr_id.map(|id| tcx.map.expect_expr(id))\n     }\n }\n \n@@ -271,8 +278,8 @@ impl<'a, 'tcx> ConstEvalVisitor<'a, 'tcx> {\n impl<'a, 'tcx, 'v> Visitor<'v> for ConstEvalVisitor<'a, 'tcx> {\n     fn visit_ty(&mut self, t: &Ty) {\n         match t.node {\n-            TyFixedLengthVec(_, expr) => {\n-                check::check_const_in_type(self.tcx, &*expr, ty::mk_uint());\n+            TyFixedLengthVec(_, ref expr) => {\n+                check::check_const_in_type(self.tcx, &**expr, ty::mk_uint());\n             }\n             _ => {}\n         }\n@@ -285,13 +292,11 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ConstEvalVisitor<'a, 'tcx> {\n     }\n }\n \n-pub fn process_crate(krate: &ast::Crate,\n-                     tcx: &ty::ctxt) {\n-    let mut v = ConstEvalVisitor {\n+pub fn process_crate(tcx: &ty::ctxt) {\n+    visit::walk_crate(&mut ConstEvalVisitor {\n         tcx: tcx,\n         ccache: DefIdMap::new(),\n-    };\n-    visit::walk_crate(&mut v, krate);\n+    }, tcx.map.krate());\n     tcx.sess.abort_if_errors();\n }\n \n@@ -309,33 +314,33 @@ pub enum const_val {\n     const_nil\n }\n \n-pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: Gc<Expr>) -> Gc<Pat> {\n+pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr) -> P<Pat> {\n     let pat = match expr.node {\n         ExprTup(ref exprs) =>\n-            PatTup(exprs.iter().map(|&expr| const_expr_to_pat(tcx, expr)).collect()),\n+            PatTup(exprs.iter().map(|expr| const_expr_to_pat(tcx, &**expr)).collect()),\n \n-        ExprCall(callee, ref args) => {\n+        ExprCall(ref callee, ref args) => {\n             let def = tcx.def_map.borrow().get_copy(&callee.id);\n             tcx.def_map.borrow_mut().find_or_insert(expr.id, def);\n             let path = match def {\n                 def::DefStruct(def_id) => def_to_path(tcx, def_id),\n                 def::DefVariant(_, variant_did, _) => def_to_path(tcx, variant_did),\n                 _ => unreachable!()\n             };\n-            let pats = args.iter().map(|&expr| const_expr_to_pat(tcx, expr)).collect();\n+            let pats = args.iter().map(|expr| const_expr_to_pat(tcx, &**expr)).collect();\n             PatEnum(path, Some(pats))\n         }\n \n         ExprStruct(ref path, ref fields, None) => {\n             let field_pats = fields.iter().map(|field| FieldPat {\n                 ident: field.ident.node,\n-                pat: const_expr_to_pat(tcx, field.expr)\n+                pat: const_expr_to_pat(tcx, &*field.expr)\n             }).collect();\n             PatStruct(path.clone(), field_pats, false)\n         }\n \n         ExprVec(ref exprs) => {\n-            let pats = exprs.iter().map(|&expr| const_expr_to_pat(tcx, expr)).collect();\n+            let pats = exprs.iter().map(|expr| const_expr_to_pat(tcx, &**expr)).collect();\n             PatVec(pats, None, vec![])\n         }\n \n@@ -347,17 +352,17 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: Gc<Expr>) -> Gc<Pat> {\n                 Some(def::DefVariant(..)) =>\n                     PatEnum(path.clone(), None),\n                 _ => {\n-                    match lookup_const(tcx, &*expr) {\n+                    match lookup_const(tcx, expr) {\n                         Some(actual) => return const_expr_to_pat(tcx, actual),\n                         _ => unreachable!()\n                     }\n                 }\n             }\n         }\n \n-        _ => PatLit(expr)\n+        _ => PatLit(P(expr.clone()))\n     };\n-    box (GC) Pat { id: expr.id, node: pat, span: expr.span }\n+    P(Pat { id: expr.id, node: pat, span: expr.span })\n }\n \n pub fn eval_const_expr(tcx: &ty::ctxt, e: &Expr) -> const_val {"}, {"sha": "46e3585912a7f6eab3e65d8b6e4e4d22b381663f", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -219,12 +219,12 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n                 }\n             }\n             ast_map::NodeTraitItem(trait_method) => {\n-                visit::walk_trait_item(self, &*trait_method);\n+                visit::walk_trait_item(self, trait_method);\n             }\n             ast_map::NodeImplItem(impl_item) => {\n                 match *impl_item {\n-                    ast::MethodImplItem(method) => {\n-                        visit::walk_block(self, &*method.pe_body());\n+                    ast::MethodImplItem(ref method) => {\n+                        visit::walk_block(self, method.pe_body());\n                     }\n                 }\n             }\n@@ -338,7 +338,7 @@ impl<'v> Visitor<'v> for LifeSeeder {\n             ast::ItemImpl(_, Some(ref _trait_ref), _, ref impl_items) => {\n                 for impl_item in impl_items.iter() {\n                     match *impl_item {\n-                        ast::MethodImplItem(method) => {\n+                        ast::MethodImplItem(ref method) => {\n                             self.worklist.push(method.id);\n                         }\n                     }\n@@ -422,7 +422,7 @@ fn should_warn(item: &ast::Item) -> bool {\n \n fn get_struct_ctor_id(item: &ast::Item) -> Option<ast::NodeId> {\n     match item.node {\n-        ast::ItemStruct(struct_def, _) => struct_def.ctor_id,\n+        ast::ItemStruct(ref struct_def, _) => struct_def.ctor_id,\n         _ => None\n     }\n }\n@@ -551,8 +551,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n \n pub fn check_crate(tcx: &ty::ctxt,\n                    exported_items: &privacy::ExportedItems,\n-                   reachable_symbols: &NodeSet,\n-                   krate: &ast::Crate) {\n+                   reachable_symbols: &NodeSet) {\n+    let krate = tcx.map.krate();\n     let live_symbols = find_live(tcx, exported_items,\n                                  reachable_symbols, krate);\n     let mut visitor = DeadVisitor { tcx: tcx, live_symbols: live_symbols };"}, {"sha": "b492203b3521e99e13718763f88b85ca5212b138", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -64,7 +64,7 @@ impl<'a, 'tcx> EffectCheckVisitor<'a, 'tcx> {\n \n     fn check_str_index(&mut self, e: &ast::Expr) {\n         let base_type = match e.node {\n-            ast::ExprIndex(base, _) => ty::node_id_to_type(self.tcx, base.id),\n+            ast::ExprIndex(ref base, _) => ty::node_id_to_type(self.tcx, base.id),\n             _ => return\n         };\n         debug!(\"effect: checking index with base type {}\",\n@@ -153,15 +153,15 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n                                         \"invocation of unsafe method\")\n                 }\n             }\n-            ast::ExprCall(base, _) => {\n+            ast::ExprCall(ref base, _) => {\n                 let base_type = ty::node_id_to_type(self.tcx, base.id);\n                 debug!(\"effect: call case, base type is {}\",\n                        ppaux::ty_to_string(self.tcx, base_type));\n                 if type_is_unsafe_function(base_type) {\n                     self.require_unsafe(expr.span, \"call to unsafe function\")\n                 }\n             }\n-            ast::ExprUnary(ast::UnDeref, base) => {\n+            ast::ExprUnary(ast::UnDeref, ref base) => {\n                 let base_type = ty::node_id_to_type(self.tcx, base.id);\n                 debug!(\"effect: unary case, base type is {}\",\n                         ppaux::ty_to_string(self.tcx, base_type));\n@@ -197,11 +197,11 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n     }\n }\n \n-pub fn check_crate(tcx: &ty::ctxt, krate: &ast::Crate) {\n+pub fn check_crate(tcx: &ty::ctxt) {\n     let mut visitor = EffectCheckVisitor {\n         tcx: tcx,\n         unsafe_context: SafeContext,\n     };\n \n-    visit::walk_crate(&mut visitor, krate);\n+    visit::walk_crate(&mut visitor, tcx.map.krate());\n }"}, {"sha": "01854564c05723ca52d9f0986785b569d1fbf35f", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -11,18 +11,18 @@\n \n use driver::config;\n use driver::session::Session;\n-use syntax::ast::{Crate, Name, NodeId, Item, ItemFn};\n+use syntax::ast::{Name, NodeId, Item, ItemFn};\n use syntax::ast_map;\n use syntax::attr;\n use syntax::codemap::Span;\n use syntax::parse::token;\n use syntax::visit;\n use syntax::visit::Visitor;\n \n-struct EntryContext<'a> {\n+struct EntryContext<'a, 'ast: 'a> {\n     session: &'a Session,\n \n-    ast_map: &'a ast_map::Map,\n+    ast_map: &'a ast_map::Map<'ast>,\n \n     // The interned Name for \"main\".\n     main_name: Name,\n@@ -41,13 +41,13 @@ struct EntryContext<'a> {\n     non_main_fns: Vec<(NodeId, Span)> ,\n }\n \n-impl<'a, 'v> Visitor<'v> for EntryContext<'a> {\n+impl<'a, 'ast, 'v> Visitor<'v> for EntryContext<'a, 'ast> {\n     fn visit_item(&mut self, item: &Item) {\n         find_item(item, self);\n     }\n }\n \n-pub fn find_entry_point(session: &Session, krate: &Crate, ast_map: &ast_map::Map) {\n+pub fn find_entry_point(session: &Session, ast_map: &ast_map::Map) {\n     let any_exe = session.crate_types.borrow().iter().any(|ty| {\n         *ty == config::CrateTypeExecutable\n     });\n@@ -57,7 +57,7 @@ pub fn find_entry_point(session: &Session, krate: &Crate, ast_map: &ast_map::Map\n     }\n \n     // If the user wants no main function at all, then stop here.\n-    if attr::contains_name(krate.attrs.as_slice(), \"no_main\") {\n+    if attr::contains_name(ast_map.krate().attrs.as_slice(), \"no_main\") {\n         session.entry_type.set(Some(config::EntryNone));\n         return\n     }\n@@ -72,7 +72,7 @@ pub fn find_entry_point(session: &Session, krate: &Crate, ast_map: &ast_map::Map\n         non_main_fns: Vec::new(),\n     };\n \n-    visit::walk_crate(&mut ctxt, krate);\n+    visit::walk_crate(&mut ctxt, ast_map.krate());\n \n     configure_main(&mut ctxt);\n }"}, {"sha": "1e79ea68eebacf19d6814a92bd2ee51f690c9da0", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -24,8 +24,8 @@ use middle::typeck::{MethodStatic, MethodStaticUnboxedClosure};\n use middle::typeck;\n use util::ppaux::Repr;\n \n-use std::gc::Gc;\n use syntax::ast;\n+use syntax::ptr::P;\n use syntax::codemap::Span;\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -242,7 +242,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n                 ty::ReScope(body.id), // Args live only as long as the fn body.\n                 arg_ty);\n \n-            self.walk_pat(arg_cmt, arg.pat.clone());\n+            self.walk_pat(arg_cmt, &*arg.pat);\n         }\n     }\n \n@@ -258,7 +258,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n         self.delegate.consume(consume_id, consume_span, cmt, mode);\n     }\n \n-    fn consume_exprs(&mut self, exprs: &Vec<Gc<ast::Expr>>) {\n+    fn consume_exprs(&mut self, exprs: &Vec<P<ast::Expr>>) {\n         for expr in exprs.iter() {\n             self.consume_expr(&**expr);\n         }\n@@ -315,7 +315,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n             ast::ExprPath(..) => { }\n \n             ast::ExprUnary(ast::UnDeref, ref base) => {      // *base\n-                if !self.walk_overloaded_operator(expr, &**base, []) {\n+                if !self.walk_overloaded_operator(expr, &**base, None) {\n                     self.select_from_expr(&**base);\n                 }\n             }\n@@ -328,8 +328,8 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n                 self.select_from_expr(&**base);\n             }\n \n-            ast::ExprIndex(ref lhs, ref rhs) => {           // lhs[rhs]\n-                if !self.walk_overloaded_operator(expr, &**lhs, [rhs.clone()]) {\n+            ast::ExprIndex(ref lhs, ref rhs) => {       // lhs[rhs]\n+                if !self.walk_overloaded_operator(expr, &**lhs, Some(&**rhs)) {\n                     self.select_from_expr(&**lhs);\n                     self.consume_expr(&**rhs);\n                 }\n@@ -345,7 +345,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n             }\n \n             ast::ExprStruct(_, ref fields, ref opt_with) => {\n-                self.walk_struct_expr(expr, fields, opt_with.clone());\n+                self.walk_struct_expr(expr, fields, opt_with);\n             }\n \n             ast::ExprTup(ref exprs) => {\n@@ -423,19 +423,19 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n                                                  pat.span,\n                                                  ty::ReScope(blk.id),\n                                                  pattern_type);\n-                self.walk_pat(pat_cmt, pat.clone());\n+                self.walk_pat(pat_cmt, &**pat);\n \n                 self.walk_block(&**blk);\n             }\n \n             ast::ExprUnary(_, ref lhs) => {\n-                if !self.walk_overloaded_operator(expr, &**lhs, []) {\n+                if !self.walk_overloaded_operator(expr, &**lhs, None) {\n                     self.consume_expr(&**lhs);\n                 }\n             }\n \n             ast::ExprBinary(_, ref lhs, ref rhs) => {\n-                if !self.walk_overloaded_operator(expr, &**lhs, [rhs.clone()]) {\n+                if !self.walk_overloaded_operator(expr, &**lhs, Some(&**rhs)) {\n                     self.consume_expr(&**lhs);\n                     self.consume_expr(&**rhs);\n                 }\n@@ -554,7 +554,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n             ast::StmtDecl(ref decl, _) => {\n                 match decl.node {\n                     ast::DeclLocal(ref local) => {\n-                        self.walk_local(local.clone());\n+                        self.walk_local(&**local);\n                     }\n \n                     ast::DeclItem(_) => {\n@@ -575,7 +575,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n         }\n     }\n \n-    fn walk_local(&mut self, local: Gc<ast::Local>) {\n+    fn walk_local(&mut self, local: &ast::Local) {\n         match local.init {\n             None => {\n                 let delegate = &mut self.delegate;\n@@ -592,7 +592,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n                 // `walk_pat`:\n                 self.walk_expr(&**expr);\n                 let init_cmt = return_if_err!(self.mc.cat_expr(&**expr));\n-                self.walk_pat(init_cmt, local.pat);\n+                self.walk_pat(init_cmt, &*local.pat);\n             }\n         }\n     }\n@@ -617,14 +617,14 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n     fn walk_struct_expr(&mut self,\n                         _expr: &ast::Expr,\n                         fields: &Vec<ast::Field>,\n-                        opt_with: Option<Gc<ast::Expr>>) {\n+                        opt_with: &Option<P<ast::Expr>>) {\n         // Consume the expressions supplying values for each field.\n         for field in fields.iter() {\n             self.consume_expr(&*field.expr);\n         }\n \n-        let with_expr = match opt_with {\n-            Some(ref w) => { w.clone() }\n+        let with_expr = match *opt_with {\n+            Some(ref w) => &**w,\n             None => { return; }\n         };\n \n@@ -773,7 +773,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n     fn walk_overloaded_operator(&mut self,\n                                 expr: &ast::Expr,\n                                 receiver: &ast::Expr,\n-                                args: &[Gc<ast::Expr>])\n+                                rhs: Option<&ast::Expr>)\n                                 -> bool\n     {\n         if !self.typer.is_method_call(expr.id) {\n@@ -789,15 +789,15 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n         let r = ty::ReScope(expr.id);\n         let bk = ty::ImmBorrow;\n \n-        for arg in args.iter() {\n-            self.borrow_expr(&**arg, r, bk, OverloadedOperator);\n+        for &arg in rhs.iter() {\n+            self.borrow_expr(arg, r, bk, OverloadedOperator);\n         }\n         return true;\n     }\n \n     fn walk_arm(&mut self, discr_cmt: mc::cmt, arm: &ast::Arm) {\n-        for &pat in arm.pats.iter() {\n-            self.walk_pat(discr_cmt.clone(), pat);\n+        for pat in arm.pats.iter() {\n+            self.walk_pat(discr_cmt.clone(), &**pat);\n         }\n \n         for guard in arm.guard.iter() {\n@@ -807,7 +807,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n         self.consume_expr(&*arm.body);\n     }\n \n-    fn walk_pat(&mut self, cmt_discr: mc::cmt, pat: Gc<ast::Pat>) {\n+    fn walk_pat(&mut self, cmt_discr: mc::cmt, pat: &ast::Pat) {\n         debug!(\"walk_pat cmt_discr={} pat={}\", cmt_discr.repr(self.tcx()),\n                pat.repr(self.tcx()));\n         let mc = &self.mc;\n@@ -859,14 +859,14 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n                 }\n             } else {\n                 match pat.node {\n-                    ast::PatVec(_, Some(slice_pat), _) => {\n+                    ast::PatVec(_, Some(ref slice_pat), _) => {\n                         // The `slice_pat` here creates a slice into\n                         // the original vector.  This is effectively a\n                         // borrow of the elements of the vector being\n                         // matched.\n \n                         let (slice_cmt, slice_mutbl, slice_r) = {\n-                            match mc.cat_slice_pattern(cmt_pat, &*slice_pat) {\n+                            match mc.cat_slice_pattern(cmt_pat, &**slice_pat) {\n                                 Ok(v) => v,\n                                 Err(()) => {\n                                     tcx.sess.span_bug(slice_pat.span,"}, {"sha": "9d0d21d6d2af6e40f23d804832834b62908ffa03", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -148,11 +148,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for IntrinsicCheckingVisitor<'a, 'tcx> {\n     }\n }\n \n-pub fn check_crate(tcx: &ctxt, krate: &ast::Crate) {\n-    let mut visitor = IntrinsicCheckingVisitor {\n-        tcx: tcx,\n-    };\n-\n-    visit::walk_crate(&mut visitor, krate);\n+pub fn check_crate(tcx: &ctxt) {\n+    visit::walk_crate(&mut IntrinsicCheckingVisitor { tcx: tcx },\n+                      tcx.map.krate());\n }\n "}, {"sha": "33f7680d873c376a47bcc8d220e31071864dd21b", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -83,14 +83,13 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n     }\n }\n \n-pub fn check_crate(tcx: &ty::ctxt,\n-                   krate: &Crate) {\n+pub fn check_crate(tcx: &ty::ctxt) {\n     let mut ctx = Context {\n         tcx: tcx,\n         struct_and_enum_bounds_checked: HashSet::new(),\n         parameter_environments: Vec::new(),\n     };\n-    visit::walk_crate(&mut ctx, krate);\n+    visit::walk_crate(&mut ctx, tcx.map.krate());\n     tcx.sess.abort_if_errors();\n }\n "}, {"sha": "aecfa36c108e096d98cd9f06554e78a43f0a6aaa", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 45, "deletions": 40, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -111,7 +111,6 @@ use lint;\n use util::nodemap::NodeMap;\n \n use std::fmt;\n-use std::gc::Gc;\n use std::io;\n use std::mem::transmute;\n use std::rc::Rc;\n@@ -122,16 +121,16 @@ use syntax::codemap::{BytePos, original_sp, Span};\n use syntax::parse::token::special_idents;\n use syntax::parse::token;\n use syntax::print::pprust::{expr_to_string, block_to_string};\n+use syntax::ptr::P;\n use syntax::{visit, ast_util};\n use syntax::visit::{Visitor, FnKind};\n \n /// For use with `propagate_through_loop`.\n-#[deriving(PartialEq, Eq)]\n-enum LoopKind {\n+enum LoopKind<'a> {\n     /// An endless `loop` loop.\n     LoopLoop,\n     /// A `while` loop, with the given expression as condition.\n-    WhileLoop(Gc<Expr>),\n+    WhileLoop(&'a Expr),\n     /// A `for` loop.\n     ForLoop,\n }\n@@ -189,9 +188,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for IrMaps<'a, 'tcx> {\n     fn visit_arm(&mut self, a: &Arm) { visit_arm(self, a); }\n }\n \n-pub fn check_crate(tcx: &ty::ctxt,\n-                   krate: &Crate) {\n-    visit::walk_crate(&mut IrMaps::new(tcx), krate);\n+pub fn check_crate(tcx: &ty::ctxt) {\n+    visit::walk_crate(&mut IrMaps::new(tcx), tcx.map.krate());\n     tcx.sess.abort_if_errors();\n }\n \n@@ -617,25 +615,25 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     }\n \n     fn arm_pats_bindings(&mut self,\n-                         pats: &[Gc<Pat>],\n+                         pat: Option<&Pat>,\n                          f: |&mut Liveness<'a, 'tcx>, LiveNode, Variable, Span, NodeId|) {\n-        // only consider the first pattern; any later patterns must have\n-        // the same bindings, and we also consider the first pattern to be\n-        // the \"authoritative\" set of ids\n-        if !pats.is_empty() {\n-            self.pat_bindings(&*pats[0], f)\n+        match pat {\n+            Some(pat) => {\n+                self.pat_bindings(pat, f);\n+            }\n+            None => {}\n         }\n     }\n \n-    fn define_bindings_in_pat(&mut self, pat: Gc<Pat>, succ: LiveNode)\n+    fn define_bindings_in_pat(&mut self, pat: &Pat, succ: LiveNode)\n                               -> LiveNode {\n-        self.define_bindings_in_arm_pats([pat], succ)\n+        self.define_bindings_in_arm_pats(Some(pat), succ)\n     }\n \n-    fn define_bindings_in_arm_pats(&mut self, pats: &[Gc<Pat>], succ: LiveNode)\n+    fn define_bindings_in_arm_pats(&mut self, pat: Option<&Pat>, succ: LiveNode)\n                                    -> LiveNode {\n         let mut succ = succ;\n-        self.arm_pats_bindings(pats, |this, ln, var, _sp, _id| {\n+        self.arm_pats_bindings(pat, |this, ln, var, _sp, _id| {\n             this.init_from_succ(ln, succ);\n             this.define(ln, var);\n             succ = ln;\n@@ -882,7 +880,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     fn propagate_through_block(&mut self, blk: &Block, succ: LiveNode)\n                                -> LiveNode {\n-        let succ = self.propagate_through_opt_expr(blk.expr, succ);\n+        let succ = self.propagate_through_opt_expr(blk.expr.as_ref().map(|e| &**e), succ);\n         blk.stmts.iter().rev().fold(succ, |succ, stmt| {\n             self.propagate_through_stmt(&**stmt, succ)\n         })\n@@ -931,19 +929,19 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         // initialization, which is mildly more complex than checking\n         // once at the func header but otherwise equivalent.\n \n-        let succ = self.propagate_through_opt_expr(local.init, succ);\n-        self.define_bindings_in_pat(local.pat, succ)\n+        let succ = self.propagate_through_opt_expr(local.init.as_ref().map(|e| &**e), succ);\n+        self.define_bindings_in_pat(&*local.pat, succ)\n     }\n \n-    fn propagate_through_exprs(&mut self, exprs: &[Gc<Expr>], succ: LiveNode)\n+    fn propagate_through_exprs(&mut self, exprs: &[P<Expr>], succ: LiveNode)\n                                -> LiveNode {\n         exprs.iter().rev().fold(succ, |succ, expr| {\n             self.propagate_through_expr(&**expr, succ)\n         })\n     }\n \n     fn propagate_through_opt_expr(&mut self,\n-                                  opt_expr: Option<Gc<Expr>>,\n+                                  opt_expr: Option<&Expr>,\n                                   succ: LiveNode)\n                                   -> LiveNode {\n         opt_expr.iter().fold(succ, |succ, expr| {\n@@ -1014,7 +1012,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             //    v     v\n             //   (  succ  )\n             //\n-            let else_ln = self.propagate_through_opt_expr(els.clone(), succ);\n+            let else_ln = self.propagate_through_opt_expr(els.as_ref().map(|e| &**e), succ);\n             let then_ln = self.propagate_through_block(&**then, succ);\n             let ln = self.live_node(expr.id, expr.span);\n             self.init_from_succ(ln, else_ln);\n@@ -1023,10 +1021,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n           }\n \n           ExprWhile(ref cond, ref blk, _) => {\n-            self.propagate_through_loop(expr,\n-                                        WhileLoop(cond.clone()),\n-                                        &**blk,\n-                                        succ)\n+            self.propagate_through_loop(expr, WhileLoop(&**cond), &**blk, succ)\n           }\n \n           ExprForLoop(_, ref head, ref blk, _) => {\n@@ -1062,20 +1057,23 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 let body_succ =\n                     self.propagate_through_expr(&*arm.body, succ);\n                 let guard_succ =\n-                    self.propagate_through_opt_expr(arm.guard, body_succ);\n+                    self.propagate_through_opt_expr(arm.guard.as_ref().map(|e| &**e), body_succ);\n+                // only consider the first pattern; any later patterns must have\n+                // the same bindings, and we also consider the first pattern to be\n+                // the \"authoritative\" set of ids\n                 let arm_succ =\n-                    self.define_bindings_in_arm_pats(arm.pats.as_slice(),\n+                    self.define_bindings_in_arm_pats(arm.pats.as_slice().head().map(|p| &**p),\n                                                      guard_succ);\n                 self.merge_from_succ(ln, arm_succ, first_merge);\n                 first_merge = false;\n             };\n             self.propagate_through_expr(&**e, ln)\n           }\n \n-          ExprRet(o_e) => {\n+          ExprRet(ref o_e) => {\n             // ignore succ and subst exit_ln:\n             let exit_ln = self.s.exit_ln;\n-            self.propagate_through_opt_expr(o_e, exit_ln)\n+            self.propagate_through_opt_expr(o_e.as_ref().map(|e| &**e), exit_ln)\n           }\n \n           ExprBreak(opt_label) => {\n@@ -1134,7 +1132,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n           }\n \n           ExprStruct(_, ref fields, ref with_expr) => {\n-            let succ = self.propagate_through_opt_expr(with_expr.clone(), succ);\n+            let succ = self.propagate_through_opt_expr(with_expr.as_ref().map(|e| &**e), succ);\n             fields.iter().rev().fold(succ, |succ, field| {\n                 self.propagate_through_expr(&*field.expr, succ)\n             })\n@@ -1182,7 +1180,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n           ExprIndex(ref l, ref r) |\n           ExprBinary(_, ref l, ref r) |\n           ExprBox(ref l, ref r) => {\n-            self.propagate_through_exprs([l.clone(), r.clone()], succ)\n+            let r_succ = self.propagate_through_expr(&**r, succ);\n+            self.propagate_through_expr(&**l, r_succ)\n           }\n \n           ExprAddrOf(_, ref e) |\n@@ -1342,12 +1341,15 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         let mut first_merge = true;\n         let ln = self.live_node(expr.id, expr.span);\n         self.init_empty(ln, succ);\n-        if kind != LoopLoop {\n-            // If this is not a `loop` loop, then it's possible we bypass\n-            // the body altogether. Otherwise, the only way is via a `break`\n-            // in the loop body.\n-            self.merge_from_succ(ln, succ, first_merge);\n-            first_merge = false;\n+        match kind {\n+            LoopLoop => {}\n+            _ => {\n+                // If this is not a `loop` loop, then it's possible we bypass\n+                // the body altogether. Otherwise, the only way is via a `break`\n+                // in the loop body.\n+                self.merge_from_succ(ln, succ, first_merge);\n+                first_merge = false;\n+            }\n         }\n         debug!(\"propagate_through_loop: using id for loop body {} {}\",\n                expr.id, block_to_string(body));\n@@ -1413,7 +1415,10 @@ fn check_local(this: &mut Liveness, local: &Local) {\n }\n \n fn check_arm(this: &mut Liveness, arm: &Arm) {\n-    this.arm_pats_bindings(arm.pats.as_slice(), |this, ln, var, sp, id| {\n+    // only consider the first pattern; any later patterns must have\n+    // the same bindings, and we also consider the first pattern to be\n+    // the \"authoritative\" set of ids\n+    this.arm_pats_bindings(arm.pats.as_slice().head().map(|p| &**p), |this, ln, var, sp, id| {\n         this.warn_about_unused(sp, id, ln, var);\n     });\n     visit::walk_arm(this, arm);"}, {"sha": "3e42ee9187c4258227906d706f1b56362ecbb049", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -490,7 +490,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n           }\n \n           ast::ExprPath(_) => {\n-            let def = self.tcx().def_map.borrow().get_copy(&expr.id);\n+            let def = *self.tcx().def_map.borrow().get(&expr.id);\n             self.cat_def(expr.id, expr.span, expr_ty, def)\n           }\n \n@@ -1154,7 +1154,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             if_ok!(self.cat_pattern(subcmt, &**subpat, op));\n           }\n \n-          ast::PatVec(ref before, slice, ref after) => {\n+          ast::PatVec(ref before, ref slice, ref after) => {\n               let elt_cmt = self.cat_index(pat, self.deref_vec(pat, cmt));\n               for before_pat in before.iter() {\n                   if_ok!(self.cat_pattern(elt_cmt.clone(), &**before_pat,"}, {"sha": "ac1a62b185231468524e7a6f4f2a72c7ce33e258", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -13,7 +13,6 @@ use middle::resolve;\n use middle::ty;\n \n use std::collections::HashMap;\n-use std::gc::{Gc, GC};\n use syntax::ast::*;\n use syntax::ast_util::{walk_pat};\n use syntax::codemap::{Span, DUMMY_SP};\n@@ -115,17 +114,6 @@ pub fn simple_identifier<'a>(pat: &'a Pat) -> Option<&'a Ident> {\n     }\n }\n \n-pub fn wild() -> Gc<Pat> {\n-    box (GC) Pat { id: 0, node: PatWild(PatWildSingle), span: DUMMY_SP }\n-}\n-\n-pub fn raw_pat(p: Gc<Pat>) -> Gc<Pat> {\n-    match p.node {\n-        PatIdent(_, _, Some(s)) => { raw_pat(s) }\n-        _ => { p }\n-    }\n-}\n-\n pub fn def_to_path(tcx: &ty::ctxt, id: DefId) -> Path {\n     ty::with_path(tcx, id, |mut path| Path {\n         global: false,"}, {"sha": "feacbf84f6739cd79a1c0a1a2e1e04d9969f9e36", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -12,7 +12,6 @@\n //! outside their scopes. This pass will also generate a set of exported items\n //! which are available for use externally when compiled as a library.\n \n-use std::gc::Gc;\n use std::mem::replace;\n \n use metadata::csearch;\n@@ -263,7 +262,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n                 if public_ty || public_trait {\n                     for impl_item in impl_items.iter() {\n                         match *impl_item {\n-                            ast::MethodImplItem(method) => {\n+                            ast::MethodImplItem(ref method) => {\n                                 let meth_public =\n                                     match method.pe_explicit_self().node {\n                                         ast::SelfStatic => public_ty,\n@@ -457,11 +456,10 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                 // invocation.\n                 // FIXME(#10573) is this the right behavior? Why not consider\n                 //               where the method was defined?\n-                Some(ast_map::NodeImplItem(ref ii)) => {\n-                    match **ii {\n-                        ast::MethodImplItem(m) => {\n-                            let imp = self.tcx\n-                                          .map\n+                Some(ast_map::NodeImplItem(ii)) => {\n+                    match *ii {\n+                        ast::MethodImplItem(ref m) => {\n+                            let imp = self.tcx.map\n                                           .get_parent_did(closest_private_id);\n                             match ty::impl_trait_ref(self.tcx, imp) {\n                                 Some(..) => return Allowable,\n@@ -1108,7 +1106,7 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n                                  impls\");\n                 for impl_item in impl_items.iter() {\n                     match *impl_item {\n-                        ast::MethodImplItem(m) => {\n+                        ast::MethodImplItem(ref m) => {\n                             check_inherited(m.span, m.pe_vis(), \"\");\n                         }\n                     }\n@@ -1169,7 +1167,7 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n                 tcx.sess.span_err(sp, \"visibility has no effect inside functions\");\n             }\n         }\n-        let check_struct = |def: &Gc<ast::StructDef>| {\n+        let check_struct = |def: &ast::StructDef| {\n             for f in def.fields.iter() {\n                match f.node.kind {\n                     ast::NamedField(_, p) => check_inherited(tcx, f.span, p),\n@@ -1182,7 +1180,7 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n             ast::ItemImpl(_, _, _, ref impl_items) => {\n                 for impl_item in impl_items.iter() {\n                     match *impl_item {\n-                        ast::MethodImplItem(m) => {\n+                        ast::MethodImplItem(ref m) => {\n                             check_inherited(tcx, m.span, m.pe_vis());\n                         }\n                     }\n@@ -1198,13 +1196,13 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n                     check_inherited(tcx, v.span, v.node.vis);\n \n                     match v.node.kind {\n-                        ast::StructVariantKind(ref s) => check_struct(s),\n+                        ast::StructVariantKind(ref s) => check_struct(&**s),\n                         ast::TupleVariantKind(..) => {}\n                     }\n                 }\n             }\n \n-            ast::ItemStruct(ref def, _) => check_struct(def),\n+            ast::ItemStruct(ref def, _) => check_struct(&**def),\n \n             ast::ItemTrait(_, _, _, ref methods) => {\n                 for m in methods.iter() {\n@@ -1305,7 +1303,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n             // (i.e. we could just return here to not check them at\n             // all, or some worse estimation of whether an impl is\n             // publicly visible.\n-            ast::ItemImpl(ref g, ref trait_ref, self_, ref impl_items) => {\n+            ast::ItemImpl(ref g, ref trait_ref, ref self_, ref impl_items) => {\n                 // `impl [... for] Private` is never visible.\n                 let self_contains_private;\n                 // impl [... for] Public<...>, but not `impl [... for]\n@@ -1320,7 +1318,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                         at_outer_type: true,\n                         outer_type_is_public_path: false,\n                     };\n-                    visitor.visit_ty(&*self_);\n+                    visitor.visit_ty(&**self_);\n                     self_contains_private = visitor.contains_private;\n                     self_is_public_path = visitor.outer_type_is_public_path;\n                 }\n@@ -1349,7 +1347,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                     impl_items.iter()\n                               .any(|impl_item| {\n                                   match *impl_item {\n-                                      ast::MethodImplItem(m) => {\n+                                      ast::MethodImplItem(ref m) => {\n                                           self.exported_items.contains(&m.id)\n                                       }\n                                   }\n@@ -1365,8 +1363,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                         None => {\n                             for impl_item in impl_items.iter() {\n                                 match *impl_item {\n-                                    ast::MethodImplItem(method) => {\n-                                        visit::walk_method_helper(self, &*method)\n+                                    ast::MethodImplItem(ref method) => {\n+                                        visit::walk_method_helper(self, &**method)\n                                     }\n                                 }\n                             }\n@@ -1393,13 +1391,13 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                     let mut found_pub_static = false;\n                     for impl_item in impl_items.iter() {\n                         match *impl_item {\n-                            ast::MethodImplItem(method) => {\n+                            ast::MethodImplItem(ref method) => {\n                                 if method.pe_explicit_self().node ==\n                                         ast::SelfStatic &&\n                                         self.exported_items\n                                             .contains(&method.id) {\n                                     found_pub_static = true;\n-                                    visit::walk_method_helper(self, &*method);\n+                                    visit::walk_method_helper(self, &**method);\n                                 }\n                             }\n                         }\n@@ -1487,8 +1485,10 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n pub fn check_crate(tcx: &ty::ctxt,\n                    exp_map2: &resolve::ExportMap2,\n                    external_exports: resolve::ExternalExports,\n-                   last_private_map: resolve::LastPrivateMap,\n-                   krate: &ast::Crate) -> (ExportedItems, PublicItems) {\n+                   last_private_map: resolve::LastPrivateMap)\n+                   -> (ExportedItems, PublicItems) {\n+    let krate = tcx.map.krate();\n+\n     // Figure out who everyone's parent is\n     let mut visitor = ParentVisitor {\n         parents: NodeMap::new(),"}, {"sha": "630b65f527878e0796ee1ca13e8efae120798f6d", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -201,7 +201,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             }\n             Some(ast_map::NodeImplItem(impl_item)) => {\n                 match *impl_item {\n-                    ast::MethodImplItem(method) => {\n+                    ast::MethodImplItem(ref method) => {\n                         if generics_require_inlining(method.pe_generics()) ||\n                                 attributes_specify_inlining(\n                                     method.attrs.as_slice()) {\n@@ -333,10 +333,10 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             }\n             ast_map::NodeImplItem(impl_item) => {\n                 match *impl_item {\n-                    ast::MethodImplItem(method) => {\n+                    ast::MethodImplItem(ref method) => {\n                         let did = self.tcx.map.get_parent_did(search_item);\n-                        if method_might_be_inlined(self.tcx, &*method, did) {\n-                            visit::walk_block(self, &*method.pe_body())\n+                        if method_might_be_inlined(self.tcx, &**method, did) {\n+                            visit::walk_block(self, method.pe_body())\n                         }\n                     }\n                 }"}, {"sha": "4f81aac5eb049e6f1289231bc0d8a5b0951ded69", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -29,12 +29,12 @@ use util::common::can_reach;\n \n use std::cell::RefCell;\n use std::collections::{HashMap, HashSet};\n-use std::gc::Gc;\n use syntax::codemap::Span;\n use syntax::{ast, visit};\n-use syntax::visit::{Visitor, FnKind};\n use syntax::ast::{Block, Item, FnDecl, NodeId, Arm, Pat, Stmt, Expr, Local};\n use syntax::ast_util::{stmt_id};\n+use syntax::ptr::P;\n+use syntax::visit::{Visitor, FnKind};\n \n /**\n The region maps encode information about region relationships.\n@@ -422,7 +422,7 @@ fn resolve_arm(visitor: &mut RegionResolutionVisitor, arm: &ast::Arm) {\n     visitor.region_maps.mark_as_terminating_scope(arm.body.id);\n \n     match arm.guard {\n-        Some(expr) => {\n+        Some(ref expr) => {\n             visitor.region_maps.mark_as_terminating_scope(expr.id);\n         }\n         None => { }\n@@ -471,28 +471,28 @@ fn resolve_expr(visitor: &mut RegionResolutionVisitor, expr: &ast::Expr) {\n         // scopes, meaning that temporaries cannot outlive them.\n         // This ensures fixed size stacks.\n \n-        ast::ExprBinary(ast::BiAnd, _, r) |\n-        ast::ExprBinary(ast::BiOr, _, r) => {\n+        ast::ExprBinary(ast::BiAnd, _, ref r) |\n+        ast::ExprBinary(ast::BiOr, _, ref r) => {\n             // For shortcircuiting operators, mark the RHS as a terminating\n             // scope since it only executes conditionally.\n             visitor.region_maps.mark_as_terminating_scope(r.id);\n         }\n \n-        ast::ExprIf(_, then, Some(otherwise)) => {\n+        ast::ExprIf(_, ref then, Some(ref otherwise)) => {\n             visitor.region_maps.mark_as_terminating_scope(then.id);\n             visitor.region_maps.mark_as_terminating_scope(otherwise.id);\n         }\n \n-        ast::ExprIf(expr, then, None) => {\n+        ast::ExprIf(ref expr, ref then, None) => {\n             visitor.region_maps.mark_as_terminating_scope(expr.id);\n             visitor.region_maps.mark_as_terminating_scope(then.id);\n         }\n \n-        ast::ExprLoop(body, _) => {\n+        ast::ExprLoop(ref body, _) => {\n             visitor.region_maps.mark_as_terminating_scope(body.id);\n         }\n \n-        ast::ExprWhile(expr, body, _) => {\n+        ast::ExprWhile(ref expr, ref body, _) => {\n             visitor.region_maps.mark_as_terminating_scope(expr.id);\n             visitor.region_maps.mark_as_terminating_scope(body.id);\n         }\n@@ -776,7 +776,7 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor, local: &ast::Local) {\n                 ast::ExprTupField(ref subexpr, _, _) |\n                 ast::ExprIndex(ref subexpr, _) |\n                 ast::ExprParen(ref subexpr) => {\n-                    let subexpr: &'a Gc<Expr> = subexpr; // FIXME(#11586)\n+                    let subexpr: &'a P<Expr> = subexpr; // FIXME(#11586)\n                     expr = &**subexpr;\n                 }\n                 _ => {"}, {"sha": "64ae2776ccc34de641f9a87b18769c858311b37b", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 47, "deletions": 42, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -30,7 +30,7 @@ use syntax::ast::{Ident, ImplItem, Item, ItemEnum, ItemFn, ItemForeignMod};\n use syntax::ast::{ItemImpl, ItemMac, ItemMod, ItemStatic, ItemStruct};\n use syntax::ast::{ItemTrait, ItemTy, LOCAL_CRATE, Local, Method};\n use syntax::ast::{MethodImplItem, Mod, Name, NamedField, NodeId};\n-use syntax::ast::{P, Pat, PatEnum, PatIdent, PatLit};\n+use syntax::ast::{Pat, PatEnum, PatIdent, PatLit};\n use syntax::ast::{PatRange, PatStruct, Path, PathListIdent, PathListMod};\n use syntax::ast::{PrimTy, Public, SelfExplicit, SelfStatic};\n use syntax::ast::{RegionTyParamBound, StmtDecl, StructField};\n@@ -43,15 +43,15 @@ use syntax::ast::{UnboxedFnTyParamBound, UnnamedField, UnsafeFn, Variant};\n use syntax::ast::{ViewItem, ViewItemExternCrate, ViewItemUse, ViewPathGlob};\n use syntax::ast::{ViewPathList, ViewPathSimple, Visibility};\n use syntax::ast;\n-use syntax::ast_util::{PostExpansionMethod, local_def};\n-use syntax::ast_util::{trait_item_to_ty_method, walk_pat};\n+use syntax::ast_util::{PostExpansionMethod, local_def, walk_pat};\n use syntax::attr::AttrMetaMethods;\n use syntax::ext::mtwt;\n use syntax::parse::token::special_names;\n use syntax::parse::token::special_idents;\n use syntax::parse::token;\n use syntax::codemap::{Span, DUMMY_SP, Pos};\n use syntax::owned_slice::OwnedSlice;\n+use syntax::ptr::P;\n use syntax::visit;\n use syntax::visit::Visitor;\n \n@@ -1164,7 +1164,7 @@ impl<'a> Resolver<'a> {\n         // Check each statement.\n         for statement in block.stmts.iter() {\n             match statement.node {\n-                StmtDecl(declaration, _) => {\n+                StmtDecl(ref declaration, _) => {\n                     match declaration.node {\n                         DeclItem(_) => {\n                             return true;\n@@ -1277,7 +1277,7 @@ impl<'a> Resolver<'a> {\n             }\n \n             // These items live in both the type and value namespaces.\n-            ItemStruct(struct_def, _) => {\n+            ItemStruct(ref struct_def, _) => {\n                 // Adding to both Type and Value namespaces or just Type?\n                 let (forbid, ctor_id) = match struct_def.ctor_id {\n                     Some(ctor_id)   => (ForbidDuplicateTypesAndValues, Some(ctor_id)),\n@@ -1309,7 +1309,7 @@ impl<'a> Resolver<'a> {\n                 parent\n             }\n \n-            ItemImpl(_, None, ty, ref impl_items) => {\n+            ItemImpl(_, None, ref ty, ref impl_items) => {\n                 // If this implements an anonymous trait, then add all the\n                 // methods within to a new module, if the type was defined\n                 // within this module.\n@@ -1364,7 +1364,7 @@ impl<'a> Resolver<'a> {\n                         // For each implementation item...\n                         for impl_item in impl_items.iter() {\n                             match *impl_item {\n-                                MethodImplItem(method) => {\n+                                MethodImplItem(ref method) => {\n                                     // Add the method to the module.\n                                     let ident = method.pe_ident();\n                                     let method_name_bindings =\n@@ -1430,37 +1430,42 @@ impl<'a> Resolver<'a> {\n \n                 // Add the names of all the methods to the trait info.\n                 for method in methods.iter() {\n-                    let ty_m = trait_item_to_ty_method(method);\n-\n-                    let ident = ty_m.ident;\n+                    let (m_id, m_ident, m_fn_style, m_self, m_span) = match *method {\n+                        ast::RequiredMethod(ref m) => {\n+                            (m.id, m.ident, m.fn_style, &m.explicit_self, m.span)\n+                        }\n+                        ast::ProvidedMethod(ref m) => {\n+                            (m.id, m.pe_ident(), m.pe_fn_style(), m.pe_explicit_self(), m.span)\n+                        }\n+                    };\n \n                     // Add it as a name in the trait module.\n-                    let (def, static_flag) = match ty_m.explicit_self.node {\n+                    let (def, static_flag) = match m_self.node {\n                         SelfStatic => {\n                             // Static methods become `def_static_method`s.\n-                            (DefStaticMethod(local_def(ty_m.id),\n+                            (DefStaticMethod(local_def(m_id),\n                                               FromTrait(local_def(item.id)),\n-                                              ty_m.fn_style),\n+                                              m_fn_style),\n                              StaticMethodTraitItemKind)\n                         }\n                         _ => {\n                             // Non-static methods become `def_method`s.\n-                            (DefMethod(local_def(ty_m.id),\n+                            (DefMethod(local_def(m_id),\n                                        Some(local_def(item.id))),\n                              NonstaticMethodTraitItemKind)\n                         }\n                     };\n \n                     let method_name_bindings =\n-                        self.add_child(ident,\n+                        self.add_child(m_ident,\n                                        module_parent.clone(),\n                                        ForbidDuplicateValues,\n-                                       ty_m.span);\n-                    method_name_bindings.define_value(def, ty_m.span, true);\n+                                       m_span);\n+                    method_name_bindings.define_value(def, m_span, true);\n \n                     self.trait_item_map\n                         .borrow_mut()\n-                        .insert((ident.name, def_id), static_flag);\n+                        .insert((m_ident.name, def_id), static_flag);\n                 }\n \n                 name_bindings.define_type(DefTrait(def_id), sp, is_public);\n@@ -4068,7 +4073,7 @@ impl<'a> Resolver<'a> {\n             ItemStruct(ref struct_def, ref generics) => {\n                 self.resolve_struct(item.id,\n                                     generics,\n-                                    struct_def.super_struct,\n+                                    &struct_def.super_struct,\n                                     struct_def.fields.as_slice());\n             }\n \n@@ -4100,15 +4105,15 @@ impl<'a> Resolver<'a> {\n                 });\n             }\n \n-            ItemFn(fn_decl, _, _, ref generics, block) => {\n+            ItemFn(ref fn_decl, _, _, ref generics, ref block) => {\n                 self.resolve_function(ItemRibKind,\n-                                      Some(fn_decl),\n+                                      Some(&**fn_decl),\n                                       HasTypeParameters\n                                         (generics,\n                                          FnSpace,\n                                          item.id,\n                                          ItemRibKind),\n-                                      block);\n+                                      &**block);\n             }\n \n             ItemStatic(..) => {\n@@ -4179,9 +4184,9 @@ impl<'a> Resolver<'a> {\n \n     fn resolve_function(&mut self,\n                         rib_kind: RibKind,\n-                        optional_declaration: Option<P<FnDecl>>,\n+                        optional_declaration: Option<&FnDecl>,\n                         type_parameters: TypeParameters,\n-                        block: P<Block>) {\n+                        block: &Block) {\n         // Create a value rib for the function.\n         let function_value_rib = Rib::new(rib_kind);\n         self.value_ribs.borrow_mut().push(function_value_rib);\n@@ -4357,7 +4362,7 @@ impl<'a> Resolver<'a> {\n     fn resolve_struct(&mut self,\n                       id: NodeId,\n                       generics: &Generics,\n-                      super_struct: Option<P<Ty>>,\n+                      super_struct: &Option<P<Ty>>,\n                       fields: &[StructField]) {\n         // If applicable, create a rib for the type parameters.\n         self.with_type_parameter_rib(HasTypeParameters(generics,\n@@ -4370,8 +4375,8 @@ impl<'a> Resolver<'a> {\n             this.resolve_where_clause(&generics.where_clause);\n \n             // Resolve the super struct.\n-            match super_struct {\n-                Some(t) => match t.node {\n+            match *super_struct {\n+                Some(ref t) => match t.node {\n                     TyPath(ref path, None, path_id) => {\n                         match this.resolve_path(id, path, TypeNS, true) {\n                             Some((DefTy(def_id), lp)) if this.structs.contains_key(&def_id) => {\n@@ -4489,7 +4494,7 @@ impl<'a> Resolver<'a> {\n                 this.with_current_self_type(self_type, |this| {\n                     for impl_item in impl_items.iter() {\n                         match *impl_item {\n-                            MethodImplItem(method) => {\n+                            MethodImplItem(ref method) => {\n                                 // If this is a trait impl, ensure the method\n                                 // exists in trait\n                                 this.check_trait_item(method.pe_ident(),\n@@ -4500,7 +4505,7 @@ impl<'a> Resolver<'a> {\n                                 this.resolve_method(\n                                     MethodRibKind(id,\n                                                   ProvidedMethod(method.id)),\n-                                    &*method);\n+                                    &**method);\n                             }\n                         }\n                     }\n@@ -4738,7 +4743,7 @@ impl<'a> Resolver<'a> {\n                 });\n             }\n \n-            TyClosure(c) | TyProc(c) => {\n+            TyClosure(ref c) | TyProc(ref c) => {\n                 self.resolve_type_parameter_bounds(ty.id, &c.bounds,\n                                                    TraitBoundingTypeParameter);\n                 visit::walk_ty(self, ty);\n@@ -4775,7 +4780,7 @@ impl<'a> Resolver<'a> {\n                     let renamed = mtwt::resolve(ident);\n \n                     match self.resolve_bare_identifier_pattern(ident, pattern.span) {\n-                        FoundStructOrEnumVariant(def, lp)\n+                        FoundStructOrEnumVariant(ref def, lp)\n                                 if mode == RefutableMode => {\n                             debug!(\"(resolving pattern) resolving `{}` to \\\n                                     struct or enum variant\",\n@@ -4785,7 +4790,7 @@ impl<'a> Resolver<'a> {\n                                 pattern,\n                                 binding_mode,\n                                 \"an enum variant\");\n-                            self.record_def(pattern.id, (def, lp));\n+                            self.record_def(pattern.id, (def.clone(), lp));\n                         }\n                         FoundStructOrEnumVariant(..) => {\n                             self.resolve_error(\n@@ -4795,7 +4800,7 @@ impl<'a> Resolver<'a> {\n                                          scope\",\n                                         token::get_name(renamed)).as_slice());\n                         }\n-                        FoundConst(def, lp) if mode == RefutableMode => {\n+                        FoundConst(ref def, lp) if mode == RefutableMode => {\n                             debug!(\"(resolving pattern) resolving `{}` to \\\n                                     constant\",\n                                    token::get_name(renamed));\n@@ -4804,7 +4809,7 @@ impl<'a> Resolver<'a> {\n                                 pattern,\n                                 binding_mode,\n                                 \"a constant\");\n-                            self.record_def(pattern.id, (def, lp));\n+                            self.record_def(pattern.id, (def.clone(), lp));\n                         }\n                         FoundConst(..) => {\n                             self.resolve_error(pattern.span,\n@@ -5024,7 +5029,7 @@ impl<'a> Resolver<'a> {\n         if path.segments.len() > 1 {\n             let def = self.resolve_module_relative_path(path, namespace);\n             match (def, unqualified_def) {\n-                (Some((d, _)), Some((ud, _))) if d == ud => {\n+                (Some((ref d, _)), Some((ref ud, _))) if *d == *ud => {\n                     self.session\n                         .add_lint(lint::builtin::UNNECESSARY_QUALIFICATION,\n                                   id,\n@@ -5386,8 +5391,8 @@ impl<'a> Resolver<'a> {\n                                                     -> Option<(Path, NodeId, FallbackChecks)> {\n             match t.node {\n                 TyPath(ref path, _, node_id) => Some((path.clone(), node_id, allow)),\n-                TyPtr(mut_ty) => extract_path_and_node_id(&*mut_ty.ty, OnlyTraitAndStatics),\n-                TyRptr(_, mut_ty) => extract_path_and_node_id(&*mut_ty.ty, allow),\n+                TyPtr(ref mut_ty) => extract_path_and_node_id(&*mut_ty.ty, OnlyTraitAndStatics),\n+                TyRptr(_, ref mut_ty) => extract_path_and_node_id(&*mut_ty.ty, allow),\n                 // This doesn't handle the remaining `Ty` variants as they are not\n                 // that commonly the self_type, it might be interesting to provide\n                 // support for those in future.\n@@ -5647,12 +5652,12 @@ impl<'a> Resolver<'a> {\n                 visit::walk_expr(self, expr);\n             }\n \n-            ExprFnBlock(_, fn_decl, block) |\n-            ExprProc(fn_decl, block) |\n-            ExprUnboxedFn(_, _, fn_decl, block) => {\n+            ExprFnBlock(_, ref fn_decl, ref block) |\n+            ExprProc(ref fn_decl, ref block) |\n+            ExprUnboxedFn(_, _, ref fn_decl, ref block) => {\n                 self.resolve_function(FunctionRibKind(expr.id, block.id),\n-                                      Some(fn_decl), NoTypeParameters,\n-                                      block);\n+                                      Some(&**fn_decl), NoTypeParameters,\n+                                      &**block);\n             }\n \n             ExprStruct(ref path, _, _) => {"}, {"sha": "04e04efd93c261fe19ca612f0ccbd59a670fc77e", "filename": "src/librustc/middle/save/mod.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -35,7 +35,6 @@ use middle::ty;\n use middle::typeck;\n \n use std::cell::Cell;\n-use std::gc::Gc;\n use std::io;\n use std::io::File;\n use std::io::fs;\n@@ -54,6 +53,7 @@ use syntax::owned_slice::OwnedSlice;\n use syntax::visit;\n use syntax::visit::Visitor;\n use syntax::print::pprust::{path_to_string,ty_to_string};\n+use syntax::ptr::P;\n \n use middle::save::span_utils::SpanUtils;\n use middle::save::recorder::Recorder;\n@@ -289,9 +289,9 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                 NodeItem(item) => {\n                     scope_id = item.id;\n                     match item.node {\n-                        ast::ItemImpl(_, _, ty, _) => {\n+                        ast::ItemImpl(_, _, ref ty, _) => {\n                             let mut result = String::from_str(\"<\");\n-                            result.push_str(ty_to_string(&*ty).as_slice());\n+                            result.push_str(ty_to_string(&**ty).as_slice());\n \n                             match ty::trait_of_item(&self.analysis.ty_cx,\n                                                     ast_util::local_def(method.id)) {\n@@ -466,9 +466,9 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n \n     fn process_fn(&mut self,\n                   item: &ast::Item,\n-                  decl: ast::P<ast::FnDecl>,\n+                  decl: &ast::FnDecl,\n                   ty_params: &ast::Generics,\n-                  body: ast::P<ast::Block>) {\n+                  body: &ast::Block) {\n         let qualname = self.analysis.ty_cx.map.path_to_string(item.id);\n \n         let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Fn);\n@@ -494,7 +494,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n \n     fn process_static(&mut self,\n                       item: &ast::Item,\n-                      typ: ast::P<ast::Ty>,\n+                      typ: &ast::Ty,\n                       mt: ast::Mutability,\n                       expr: &ast::Expr)\n     {\n@@ -611,7 +611,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                     item: &ast::Item,\n                     type_parameters: &ast::Generics,\n                     trait_ref: &Option<ast::TraitRef>,\n-                    typ: ast::P<ast::Ty>,\n+                    typ: &ast::Ty,\n                     impl_items: &Vec<ast::ImplItem>) {\n         match typ.node {\n             ast::TyPath(ref path, _, id) => {\n@@ -643,8 +643,8 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         self.process_generic_params(type_parameters, item.span, \"\", item.id);\n         for impl_item in impl_items.iter() {\n             match *impl_item {\n-                ast::MethodImplItem(method) => {\n-                    visit::walk_method_helper(self, &*method)\n+                ast::MethodImplItem(ref method) => {\n+                    visit::walk_method_helper(self, &**method)\n                 }\n             }\n         }\n@@ -833,7 +833,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                           ex: &ast::Expr,\n                           path: &ast::Path,\n                           fields: &Vec<ast::Field>,\n-                          base: &Option<Gc<ast::Expr>>) {\n+                          base: &Option<P<ast::Expr>>) {\n         if generated_code(path.span) {\n             return\n         }\n@@ -883,7 +883,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n \n     fn process_method_call(&mut self,\n                            ex: &ast::Expr,\n-                           args: &Vec<Gc<ast::Expr>>) {\n+                           args: &Vec<P<ast::Expr>>) {\n         let method_map = self.analysis.ty_cx.method_map.borrow();\n         let method_callee = method_map.get(&typeck::MethodCall::expr(ex.id));\n         let (def_id, decl_id) = match method_callee.origin {\n@@ -1010,7 +1010,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                 self.collected_paths.push((p.id, path, immut, recorder::VarRef));\n                 match *optional_subpattern {\n                     None => {}\n-                    Some(subpattern) => self.visit_pat(&*subpattern),\n+                    Some(ref subpattern) => self.visit_pat(&**subpattern)\n                 }\n             }\n             _ => visit::walk_pat(self, p)\n@@ -1025,36 +1025,36 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n         }\n \n         match item.node {\n-            ast::ItemFn(decl, _, _, ref ty_params, body) =>\n-                self.process_fn(item, decl, ty_params, body),\n-            ast::ItemStatic(typ, mt, expr) =>\n-                self.process_static(item, typ, mt, &*expr),\n-            ast::ItemStruct(def, ref ty_params) => self.process_struct(item, &*def, ty_params),\n+            ast::ItemFn(ref decl, _, _, ref ty_params, ref body) =>\n+                self.process_fn(item, &**decl, ty_params, &**body),\n+            ast::ItemStatic(ref typ, mt, ref expr) =>\n+                self.process_static(item, &**typ, mt, &**expr),\n+            ast::ItemStruct(ref def, ref ty_params) => self.process_struct(item, &**def, ty_params),\n             ast::ItemEnum(ref def, ref ty_params) => self.process_enum(item, def, ty_params),\n             ast::ItemImpl(ref ty_params,\n                           ref trait_ref,\n-                          typ,\n+                          ref typ,\n                           ref impl_items) => {\n                 self.process_impl(item,\n                                   ty_params,\n                                   trait_ref,\n-                                  typ,\n+                                  &**typ,\n                                   impl_items)\n             }\n             ast::ItemTrait(ref generics, _, ref trait_refs, ref methods) =>\n                 self.process_trait(item, generics, trait_refs, methods),\n             ast::ItemMod(ref m) => self.process_mod(item, m),\n-            ast::ItemTy(ty, ref ty_params) => {\n+            ast::ItemTy(ref ty, ref ty_params) => {\n                 let qualname = self.analysis.ty_cx.map.path_to_string(item.id);\n-                let value = ty_to_string(&*ty);\n+                let value = ty_to_string(&**ty);\n                 let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Type);\n                 self.fmt.typedef_str(item.span,\n                                      sub_span,\n                                      item.id,\n                                      qualname.as_slice(),\n                                      value.as_slice());\n \n-                self.visit_ty(&*ty);\n+                self.visit_ty(&**ty);\n                 self.process_generic_params(ty_params, item.span, qualname.as_slice(), item.id);\n             },\n             ast::ItemMac(_) => (),\n@@ -1073,8 +1073,8 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                 }\n             }\n             match param.default {\n-                Some(ty) => self.visit_ty(&*ty),\n-                None => (),\n+                Some(ref ty) => self.visit_ty(&**ty),\n+                None => {}\n             }\n         }\n     }\n@@ -1139,7 +1139,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                                             qualname,\n                                             method_type.id);\n             }\n-            ast::ProvidedMethod(method) => self.process_method(&*method),\n+            ast::ProvidedMethod(ref method) => self.process_method(&**method)\n         }\n     }\n \n@@ -1269,7 +1269,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n         }\n \n         match ex.node {\n-            ast::ExprCall(_f, ref _args) => {\n+            ast::ExprCall(ref _f, ref _args) => {\n                 // Don't need to do anything for function calls,\n                 // because just walking the callee path does what we want.\n                 visit::walk_expr(self, ex);\n@@ -1278,14 +1278,14 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n             ast::ExprStruct(ref path, ref fields, ref base) =>\n                 self.process_struct_lit(ex, path, fields, base),\n             ast::ExprMethodCall(_, _, ref args) => self.process_method_call(ex, args),\n-            ast::ExprField(sub_ex, ident, _) => {\n+            ast::ExprField(ref sub_ex, ident, _) => {\n                 if generated_code(sub_ex.span) {\n                     return\n                 }\n \n-                self.visit_expr(&*sub_ex);\n+                self.visit_expr(&**sub_ex);\n \n-                let t = ty::expr_ty_adjusted(&self.analysis.ty_cx, &*sub_ex);\n+                let t = ty::expr_ty_adjusted(&self.analysis.ty_cx, &**sub_ex);\n                 let t_box = ty::get(t);\n                 match t_box.sty {\n                     ty::ty_struct(def_id, _) => {\n@@ -1306,14 +1306,14 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                                             \"Expected struct type, but not ty_struct\"),\n                 }\n             },\n-            ast::ExprTupField(sub_ex, idx, _) => {\n+            ast::ExprTupField(ref sub_ex, idx, _) => {\n                 if generated_code(sub_ex.span) {\n                     return\n                 }\n \n-                self.visit_expr(&*sub_ex);\n+                self.visit_expr(&**sub_ex);\n \n-                let t = ty::expr_ty_adjusted(&self.analysis.ty_cx, &*sub_ex);\n+                let t = ty::expr_ty_adjusted(&self.analysis.ty_cx, &**sub_ex);\n                 let t_box = ty::get(t);\n                 match t_box.sty {\n                     ty::ty_struct(def_id, _) => {\n@@ -1334,7 +1334,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                                             \"Expected struct type, but not ty_struct\"),\n                 }\n             },\n-            ast::ExprFnBlock(_, decl, body) => {\n+            ast::ExprFnBlock(_, ref decl, ref body) => {\n                 if generated_code(body.span) {\n                     return\n                 }\n@@ -1349,7 +1349,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                 self.visit_ty(&*decl.output);\n \n                 // walk the body\n-                self.nest(ex.id, |v| v.visit_block(&*body));\n+                self.nest(ex.id, |v| v.visit_block(&**body));\n             },\n             _ => {\n                 visit::walk_expr(self, ex)"}, {"sha": "755ff991fb60a11e33c14029819bcf437822fd83", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 156, "deletions": 153, "changes": 309, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -218,55 +218,65 @@ use util::ppaux::{Repr, vec_map_to_string};\n \n use std;\n use std::collections::HashMap;\n-use std::gc::{Gc};\n use std::rc::Rc;\n use syntax::ast;\n-use syntax::ast::Ident;\n+use syntax::ast::{DUMMY_NODE_ID, Ident};\n use syntax::codemap::Span;\n use syntax::fold::Folder;\n+use syntax::ptr::P;\n \n-struct ConstantExpr<'a, 'tcx: 'a>(&'a ty::ctxt<'tcx>, Gc<ast::Expr>);\n+struct ConstantExpr<'a>(&'a ast::Expr);\n \n-impl<'a, 'tcx> Eq for ConstantExpr<'a, 'tcx> {\n-    fn assert_receiver_is_total_eq(&self) {}\n-}\n-\n-impl<'a, 'tcx> PartialEq for ConstantExpr<'a, 'tcx> {\n-    fn eq(&self, other: &ConstantExpr<'a, 'tcx>) -> bool {\n-        let &ConstantExpr(tcx, expr) = self;\n-        let &ConstantExpr(_, other_expr) = other;\n-        match const_eval::compare_lit_exprs(tcx, &*expr, &*other_expr) {\n+impl<'a> ConstantExpr<'a> {\n+    fn eq(self, other: ConstantExpr<'a>, tcx: &ty::ctxt) -> bool {\n+        let ConstantExpr(expr) = self;\n+        let ConstantExpr(other_expr) = other;\n+        match const_eval::compare_lit_exprs(tcx, expr, other_expr) {\n             Some(val1) => val1 == 0,\n             None => fail!(\"compare_list_exprs: type mismatch\"),\n         }\n     }\n }\n \n // An option identifying a branch (either a literal, an enum variant or a range)\n-#[deriving(Eq, PartialEq)]\n-enum Opt<'blk, 'tcx: 'blk> {\n-    ConstantValue(ConstantExpr<'blk, 'tcx>),\n-    ConstantRange(ConstantExpr<'blk, 'tcx>, ConstantExpr<'blk, 'tcx>),\n+enum Opt<'a> {\n+    ConstantValue(ConstantExpr<'a>),\n+    ConstantRange(ConstantExpr<'a>, ConstantExpr<'a>),\n     Variant(ty::Disr, Rc<adt::Repr>, ast::DefId),\n     SliceLengthEqual(uint),\n     SliceLengthGreaterOrEqual(/* prefix length */ uint, /* suffix length */ uint),\n }\n \n-impl<'blk, 'tcx> Opt<'blk, 'tcx> {\n-    fn trans(&self, mut bcx: Block<'blk, 'tcx>) -> OptResult<'blk, 'tcx> {\n+impl<'a> Opt<'a> {\n+    fn eq(&self, other: &Opt<'a>, tcx: &ty::ctxt) -> bool {\n+        match (self, other) {\n+            (&ConstantValue(a), &ConstantValue(b)) => a.eq(b, tcx),\n+            (&ConstantRange(a1, a2), &ConstantRange(b1, b2)) => {\n+                a1.eq(b1, tcx) && a2.eq(b2, tcx)\n+            }\n+            (&Variant(a_disr, ref a_repr, a_def), &Variant(b_disr, ref b_repr, b_def)) => {\n+                a_disr == b_disr && *a_repr == *b_repr && a_def == b_def\n+            }\n+            (&SliceLengthEqual(a), &SliceLengthEqual(b)) => a == b,\n+            (&SliceLengthGreaterOrEqual(a1, a2), &SliceLengthGreaterOrEqual(b1, b2)) => {\n+                a1 == b1 && a2 == b2\n+            }\n+            _ => false\n+        }\n+    }\n+\n+    fn trans<'blk, 'tcx>(&self, mut bcx: Block<'blk, 'tcx>) -> OptResult<'blk, 'tcx> {\n         let _icx = push_ctxt(\"match::trans_opt\");\n         let ccx = bcx.ccx();\n         match *self {\n-            ConstantValue(ConstantExpr(_, lit_expr)) => {\n+            ConstantValue(ConstantExpr(lit_expr)) => {\n                 let lit_ty = ty::node_id_to_type(bcx.tcx(), lit_expr.id);\n                 let (llval, _, _) = consts::const_expr(ccx, &*lit_expr, true);\n                 let lit_datum = immediate_rvalue(llval, lit_ty);\n                 let lit_datum = unpack_datum!(bcx, lit_datum.to_appropriate_datum(bcx));\n                 SingleResult(Result::new(bcx, lit_datum.val))\n             }\n-            ConstantRange(\n-                ConstantExpr(_, ref l1),\n-                ConstantExpr(_, ref l2)) => {\n+            ConstantRange(ConstantExpr(ref l1), ConstantExpr(ref l2)) => {\n                 let (l1, _, _) = consts::const_expr(ccx, &**l1, true);\n                 let (l2, _, _) = consts::const_expr(ccx, &**l2, true);\n                 RangeResult(Result::new(bcx, l1), Result::new(bcx, l2))\n@@ -325,9 +335,9 @@ pub struct BindingInfo {\n \n type BindingsMap = HashMap<Ident, BindingInfo>;\n \n-struct ArmData<'a, 'blk, 'tcx: 'blk> {\n+struct ArmData<'p, 'blk, 'tcx: 'blk> {\n     bodycx: Block<'blk, 'tcx>,\n-    arm: &'a ast::Arm,\n+    arm: &'p ast::Arm,\n     bindings_map: BindingsMap\n }\n \n@@ -337,13 +347,13 @@ struct ArmData<'a, 'blk, 'tcx: 'blk> {\n  * As we proceed `bound_ptrs` are filled with pointers to values to be bound,\n  * these pointers are stored in llmatch variables just before executing `data` arm.\n  */\n-struct Match<'a, 'blk: 'a, 'tcx: 'blk> {\n-    pats: Vec<Gc<ast::Pat>>,\n-    data: &'a ArmData<'a, 'blk, 'tcx>,\n+struct Match<'a, 'p: 'a, 'blk: 'a, 'tcx: 'blk> {\n+    pats: Vec<&'p ast::Pat>,\n+    data: &'a ArmData<'p, 'blk, 'tcx>,\n     bound_ptrs: Vec<(Ident, ValueRef)>\n }\n \n-impl<'a, 'blk, 'tcx> Repr for Match<'a, 'blk, 'tcx> {\n+impl<'a, 'p, 'blk, 'tcx> Repr for Match<'a, 'p, 'blk, 'tcx> {\n     fn repr(&self, tcx: &ty::ctxt) -> String {\n         if tcx.sess.verbose() {\n             // for many programs, this just take too long to serialize\n@@ -364,11 +374,11 @@ fn has_nested_bindings(m: &[Match], col: uint) -> bool {\n     return false;\n }\n \n-fn expand_nested_bindings<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                          m: &'a [Match<'a, 'blk, 'tcx>],\n-                                          col: uint,\n-                                          val: ValueRef)\n-                                          -> Vec<Match<'a, 'blk, 'tcx>> {\n+fn expand_nested_bindings<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                              m: &[Match<'a, 'p, 'blk, 'tcx>],\n+                                              col: uint,\n+                                              val: ValueRef)\n+                                              -> Vec<Match<'a, 'p, 'blk, 'tcx>> {\n     debug!(\"expand_nested_bindings(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -381,9 +391,9 @@ fn expand_nested_bindings<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         let mut pat = *br.pats.get(col);\n         loop {\n             pat = match pat.node {\n-                ast::PatIdent(_, ref path, Some(inner)) => {\n+                ast::PatIdent(_, ref path, Some(ref inner)) => {\n                     bound_ptrs.push((path.node, val));\n-                    inner.clone()\n+                    &**inner\n                 },\n                 _ => break\n             }\n@@ -399,15 +409,15 @@ fn expand_nested_bindings<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }).collect()\n }\n \n-type EnterPatterns<'a> = |&[Gc<ast::Pat>]|: 'a -> Option<Vec<Gc<ast::Pat>>>;\n+type EnterPatterns<'a> = <'p> |&[&'p ast::Pat]|: 'a -> Option<Vec<&'p ast::Pat>>;\n \n-fn enter_match<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                               dm: &DefMap,\n-                               m: &'a [Match<'a, 'blk, 'tcx>],\n-                               col: uint,\n-                               val: ValueRef,\n-                               e: EnterPatterns)\n-                               -> Vec<Match<'a, 'blk, 'tcx>> {\n+fn enter_match<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                   dm: &DefMap,\n+                                   m: &[Match<'a, 'p, 'blk, 'tcx>],\n+                                   col: uint,\n+                                   val: ValueRef,\n+                                   e: EnterPatterns)\n+                                   -> Vec<Match<'a, 'p, 'blk, 'tcx>> {\n     debug!(\"enter_match(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -425,7 +435,7 @@ fn enter_match<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                         bound_ptrs.push((path.node, val));\n                     }\n                 }\n-                ast::PatVec(ref before, Some(slice), ref after) => {\n+                ast::PatVec(ref before, Some(ref slice), ref after) => {\n                     match slice.node {\n                         ast::PatIdent(_, ref path, None) => {\n                             let subslice_val = bind_subslice_pat(\n@@ -438,7 +448,6 @@ fn enter_match<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 }\n                 _ => {}\n             }\n-\n             Match {\n                 pats: pats,\n                 data: br.data,\n@@ -448,12 +457,12 @@ fn enter_match<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }).collect()\n }\n \n-fn enter_default<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                 dm: &DefMap,\n-                                 m: &'a [Match<'a, 'blk, 'tcx>],\n-                                 col: uint,\n-                                 val: ValueRef)\n-                                 -> Vec<Match<'a, 'blk, 'tcx>> {\n+fn enter_default<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                     dm: &DefMap,\n+                                     m: &[Match<'a, 'p, 'blk, 'tcx>],\n+                                     col: uint,\n+                                     val: ValueRef)\n+                                     -> Vec<Match<'a, 'p, 'blk, 'tcx>> {\n     debug!(\"enter_default(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -499,16 +508,16 @@ fn enter_default<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n /// takes the complete row of patterns rather than just the first one.\n /// Also, most of the enter_() family functions have been unified with\n /// the check_match specialization step.\n-fn enter_opt<'a, 'blk, 'tcx>(\n+fn enter_opt<'a, 'p, 'blk, 'tcx>(\n              bcx: Block<'blk, 'tcx>,\n              _: ast::NodeId,\n              dm: &DefMap,\n-             m: &'a [Match<'a, 'blk, 'tcx>],\n+             m: &[Match<'a, 'p, 'blk, 'tcx>],\n              opt: &Opt,\n              col: uint,\n              variant_size: uint,\n              val: ValueRef)\n-             -> Vec<Match<'a, 'blk, 'tcx>> {\n+             -> Vec<Match<'a, 'p, 'blk, 'tcx>> {\n     debug!(\"enter_opt(bcx={}, m={}, opt={:?}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -518,10 +527,10 @@ fn enter_opt<'a, 'blk, 'tcx>(\n     let _indenter = indenter();\n \n     let ctor = match opt {\n-        &ConstantValue(ConstantExpr(_, expr)) => check_match::ConstantValue(\n+        &ConstantValue(ConstantExpr(expr)) => check_match::ConstantValue(\n             const_eval::eval_const_expr(bcx.tcx(), &*expr)\n         ),\n-        &ConstantRange(ConstantExpr(_, lo), ConstantExpr(_, hi)) => check_match::ConstantRange(\n+        &ConstantRange(ConstantExpr(lo), ConstantExpr(hi)) => check_match::ConstantRange(\n             const_eval::eval_const_expr(bcx.tcx(), &*lo),\n             const_eval::eval_const_expr(bcx.tcx(), &*hi)\n         ),\n@@ -542,51 +551,41 @@ fn enter_opt<'a, 'blk, 'tcx>(\n // Returns the options in one column of matches. An option is something that\n // needs to be conditionally matched at runtime; for example, the discriminant\n // on a set of enum variants or a literal.\n-fn get_branches<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                            m: &[Match], col: uint)\n-                            -> Vec<Opt<'blk, 'tcx>> {\n-    let ccx = bcx.ccx();\n-\n-    fn add_to_set<'blk, 'tcx>(set: &mut Vec<Opt<'blk, 'tcx>>, opt: Opt<'blk, 'tcx>) {\n-        if !set.contains(&opt) {\n-            set.push(opt);\n-        }\n-    }\n+fn get_branches<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                    m: &[Match<'a, 'p, 'blk, 'tcx>], col: uint)\n+                                    -> Vec<Opt<'p>> {\n+    let tcx = bcx.tcx();\n \n-    let mut found = Vec::new();\n+    let mut found: Vec<Opt> = vec![];\n     for (i, br) in m.iter().enumerate() {\n         let cur = *br.pats.get(col);\n-        match cur.node {\n-            ast::PatLit(l) => {\n-                add_to_set(&mut found, ConstantValue(ConstantExpr(ccx.tcx(), l)));\n-            }\n+        let opt = match cur.node {\n+            ast::PatLit(ref l) => ConstantValue(ConstantExpr(&**l)),\n             ast::PatIdent(..) | ast::PatEnum(..) | ast::PatStruct(..) => {\n                 // This is either an enum variant or a variable binding.\n-                let opt_def = ccx.tcx().def_map.borrow().find_copy(&cur.id);\n+                let opt_def = tcx.def_map.borrow().find_copy(&cur.id);\n                 match opt_def {\n                     Some(def::DefVariant(enum_id, var_id, _)) => {\n-                        let variant = ty::enum_variant_with_id(ccx.tcx(), enum_id, var_id);\n-                        add_to_set(&mut found, Variant(\n-                            variant.disr_val,\n-                            adt::represent_node(bcx, cur.id), var_id\n-                        ));\n+                        let variant = ty::enum_variant_with_id(tcx, enum_id, var_id);\n+                        Variant(variant.disr_val, adt::represent_node(bcx, cur.id), var_id)\n                     }\n-                    _ => {}\n+                    _ => continue\n                 }\n             }\n-            ast::PatRange(l1, l2) => {\n-                add_to_set(&mut found, ConstantRange(\n-                    ConstantExpr(ccx.tcx(), l1),\n-                    ConstantExpr(ccx.tcx(), l2)\n-                ));\n+            ast::PatRange(ref l1, ref l2) => {\n+                ConstantRange(ConstantExpr(&**l1), ConstantExpr(&**l2))\n             }\n             ast::PatVec(ref before, None, ref after) => {\n-                add_to_set(&mut found, SliceLengthEqual(before.len() + after.len()));\n+                SliceLengthEqual(before.len() + after.len())\n             }\n             ast::PatVec(ref before, Some(_), ref after) => {\n-                add_to_set(&mut found, SliceLengthGreaterOrEqual(before.len(), after.len()));\n+                SliceLengthGreaterOrEqual(before.len(), after.len())\n             }\n-            _ => {}\n+            _ => continue\n+        };\n+\n+        if !found.iter().any(|x| x.eq(&opt, tcx)) {\n+            found.push(opt);\n         }\n     }\n     found\n@@ -870,14 +869,14 @@ fn insert_lllocals<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     bcx\n }\n \n-fn compile_guard<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                 guard_expr: &ast::Expr,\n-                                 data: &ArmData,\n-                                 m: &'a [Match<'a, 'blk, 'tcx>],\n-                                 vals: &[ValueRef],\n-                                 chk: &FailureHandler,\n-                                 has_genuine_default: bool)\n-                                 -> Block<'blk, 'tcx> {\n+fn compile_guard<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                     guard_expr: &ast::Expr,\n+                                     data: &ArmData,\n+                                     m: &[Match<'a, 'p, 'blk, 'tcx>],\n+                                     vals: &[ValueRef],\n+                                     chk: &FailureHandler,\n+                                     has_genuine_default: bool)\n+                                     -> Block<'blk, 'tcx> {\n     debug!(\"compile_guard(bcx={}, guard_expr={}, m={}, vals={})\",\n            bcx.to_str(),\n            bcx.expr_to_string(guard_expr),\n@@ -918,11 +917,11 @@ fn compile_guard<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     })\n }\n \n-fn compile_submatch<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                    m: &'a [Match<'a, 'blk, 'tcx>],\n-                                    vals: &[ValueRef],\n-                                    chk: &FailureHandler,\n-                                    has_genuine_default: bool) {\n+fn compile_submatch<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                        m: &[Match<'a, 'p, 'blk, 'tcx>],\n+                                        vals: &[ValueRef],\n+                                        chk: &FailureHandler,\n+                                        has_genuine_default: bool) {\n     debug!(\"compile_submatch(bcx={}, m={}, vals={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -978,13 +977,13 @@ fn compile_submatch<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n }\n \n-fn compile_submatch_continue<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n-                                             m: &'a [Match<'a, 'blk, 'tcx>],\n-                                             vals: &[ValueRef],\n-                                             chk: &FailureHandler,\n-                                             col: uint,\n-                                             val: ValueRef,\n-                                             has_genuine_default: bool) {\n+fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n+                                                 m: &[Match<'a, 'p, 'blk, 'tcx>],\n+                                                 vals: &[ValueRef],\n+                                                 chk: &FailureHandler,\n+                                                 col: uint,\n+                                                 val: ValueRef,\n+                                                 has_genuine_default: bool) {\n     let fcx = bcx.fcx;\n     let tcx = bcx.tcx();\n     let dm = &tcx.def_map;\n@@ -994,9 +993,11 @@ fn compile_submatch_continue<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n     // Find a real id (we're adding placeholder wildcard patterns, but\n     // each column is guaranteed to have at least one real pattern)\n-    let pat_id = m.iter().map(|br| br.pats.get(col).id).find(|&id| id != 0).unwrap_or(0);\n+    let pat_id = m.iter().map(|br| br.pats.get(col).id)\n+                         .find(|&id| id != DUMMY_NODE_ID)\n+                         .unwrap_or(DUMMY_NODE_ID);\n \n-    let left_ty = if pat_id == 0 {\n+    let left_ty = if pat_id == DUMMY_NODE_ID {\n         ty::mk_nil()\n     } else {\n         node_id_type(bcx, pat_id)\n@@ -1264,7 +1265,7 @@ impl euv::Delegate for ReassignmentChecker {\n     }\n }\n \n-fn create_bindings_map(bcx: Block, pat: Gc<ast::Pat>,\n+fn create_bindings_map(bcx: Block, pat: &ast::Pat,\n                       discr: &ast::Expr, body: &ast::Expr) -> BindingsMap {\n     // Create the bindings map, which is a mapping from each binding name\n     // to an alloca() that will be the value for that local variable.\n@@ -1345,14 +1346,17 @@ fn trans_match_inner<'blk, 'tcx>(scope_cx: Block<'blk, 'tcx>,\n     let arm_datas: Vec<ArmData> = arms.iter().map(|arm| ArmData {\n         bodycx: fcx.new_id_block(\"case_body\", arm.body.id),\n         arm: arm,\n-        bindings_map: create_bindings_map(bcx, *arm.pats.get(0), discr_expr, &*arm.body)\n+        bindings_map: create_bindings_map(bcx, &**arm.pats.get(0), discr_expr, &*arm.body)\n     }).collect();\n \n     let mut static_inliner = StaticInliner::new(scope_cx.tcx());\n+    let arm_pats: Vec<Vec<P<ast::Pat>>> = arm_datas.iter().map(|arm_data| {\n+        arm_data.arm.pats.iter().map(|p| static_inliner.fold_pat((*p).clone())).collect()\n+    }).collect();\n     let mut matches = Vec::new();\n-    for arm_data in arm_datas.iter() {\n-        matches.extend(arm_data.arm.pats.iter().map(|&p| Match {\n-            pats: vec![static_inliner.fold_pat(p)],\n+    for (arm_data, pats) in arm_datas.iter().zip(arm_pats.iter()) {\n+        matches.extend(pats.iter().map(|p| Match {\n+            pats: vec![&**p],\n             data: arm_data,\n             bound_ptrs: Vec::new(),\n         }));\n@@ -1404,11 +1408,25 @@ pub fn store_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let _icx = push_ctxt(\"match::store_local\");\n     let mut bcx = bcx;\n     let tcx = bcx.tcx();\n-    let pat = local.pat;\n-    let opt_init_expr = local.init;\n+    let pat = &*local.pat;\n+\n+    fn create_dummy_locals<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n+                                       pat: &ast::Pat)\n+                                       -> Block<'blk, 'tcx> {\n+        // create dummy memory for the variables if we have no\n+        // value to store into them immediately\n+        let tcx = bcx.tcx();\n+        pat_bindings(&tcx.def_map, pat, |_, p_id, _, path1| {\n+            let scope = cleanup::var_scope(tcx, p_id);\n+            bcx = mk_binding_alloca(\n+                bcx, p_id, &path1.node, BindLocal, scope, (),\n+                |(), bcx, llval, ty| { zero_mem(bcx, llval, ty); bcx });\n+        });\n+        bcx\n+    }\n \n-    return match opt_init_expr {\n-        Some(init_expr) => {\n+    match local.init {\n+        Some(ref init_expr) => {\n             // Optimize the \"let x = expr\" case. This just writes\n             // the result of evaluating `expr` directly into the alloca\n             // for `x`. Often the general path results in similar or the\n@@ -1424,7 +1442,7 @@ pub fn store_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     let var_scope = cleanup::var_scope(tcx, local.id);\n                     return mk_binding_alloca(\n                         bcx, pat.id, ident, BindLocal, var_scope, (),\n-                        |(), bcx, v, _| expr::trans_into(bcx, &*init_expr,\n+                        |(), bcx, v, _| expr::trans_into(bcx, &**init_expr,\n                                                          expr::SaveIn(v)));\n                 }\n \n@@ -1433,8 +1451,8 @@ pub fn store_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n             // General path.\n             let init_datum =\n-                unpack_datum!(bcx, expr::trans_to_lvalue(bcx, &*init_expr, \"let\"));\n-            if ty::type_is_bot(expr_ty(bcx, &*init_expr)) {\n+                unpack_datum!(bcx, expr::trans_to_lvalue(bcx, &**init_expr, \"let\"));\n+            if ty::type_is_bot(expr_ty(bcx, &**init_expr)) {\n                 create_dummy_locals(bcx, pat)\n             } else {\n                 if bcx.sess().asm_comments() {\n@@ -1447,26 +1465,11 @@ pub fn store_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         None => {\n             create_dummy_locals(bcx, pat)\n         }\n-    };\n-\n-    fn create_dummy_locals<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n-                                       pat: Gc<ast::Pat>)\n-                                       -> Block<'blk, 'tcx> {\n-        // create dummy memory for the variables if we have no\n-        // value to store into them immediately\n-        let tcx = bcx.tcx();\n-        pat_bindings(&tcx.def_map, &*pat, |_, p_id, _, path1| {\n-                let scope = cleanup::var_scope(tcx, p_id);\n-                bcx = mk_binding_alloca(\n-                    bcx, p_id, &path1.node, BindLocal, scope, (),\n-                    |(), bcx, llval, ty| { zero_mem(bcx, llval, ty); bcx });\n-            });\n-        bcx\n     }\n }\n \n pub fn store_arg<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n-                             pat: Gc<ast::Pat>,\n+                             pat: &ast::Pat,\n                              arg: Datum<Rvalue>,\n                              arg_scope: cleanup::ScopeId)\n                              -> Block<'blk, 'tcx> {\n@@ -1520,7 +1523,7 @@ pub fn store_arg<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n /// Generates code for the pattern binding in a `for` loop like\n /// `for <pat> in <expr> { ... }`.\n pub fn store_for_loop_binding<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                          pat: Gc<ast::Pat>,\n+                                          pat: &ast::Pat,\n                                           llvalue: ValueRef,\n                                           body_scope: cleanup::ScopeId)\n                                           -> Block<'blk, 'tcx> {\n@@ -1573,7 +1576,7 @@ fn mk_binding_alloca<'blk, 'tcx, A>(bcx: Block<'blk, 'tcx>,\n }\n \n fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                    pat: Gc<ast::Pat>,\n+                                    pat: &ast::Pat,\n                                     val: ValueRef,\n                                     binding_mode: IrrefutablePatternBindingMode,\n                                     cleanup_scope: cleanup::ScopeId)\n@@ -1611,7 +1614,7 @@ fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let tcx = bcx.tcx();\n     let ccx = bcx.ccx();\n     match pat.node {\n-        ast::PatIdent(pat_binding_mode, ref path1, inner) => {\n+        ast::PatIdent(pat_binding_mode, ref path1, ref inner) => {\n             if pat_is_binding(&tcx.def_map, &*pat) {\n                 // Allocate the stack slot where the value of this\n                 // binding will live and place it into the appropriate\n@@ -1637,8 +1640,8 @@ fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     });\n             }\n \n-            for &inner_pat in inner.iter() {\n-                bcx = bind_irrefutable_pat(bcx, inner_pat, val,\n+            for inner_pat in inner.iter() {\n+                bcx = bind_irrefutable_pat(bcx, &**inner_pat, val,\n                                            binding_mode, cleanup_scope);\n             }\n         }\n@@ -1655,9 +1658,9 @@ fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                                     vinfo.disr_val,\n                                                     val);\n                     for sub_pat in sub_pats.iter() {\n-                        for (i, argval) in args.vals.iter().enumerate() {\n-                            bcx = bind_irrefutable_pat(bcx, *sub_pat.get(i),\n-                                                       *argval, binding_mode,\n+                        for (i, &argval) in args.vals.iter().enumerate() {\n+                            bcx = bind_irrefutable_pat(bcx, &**sub_pat.get(i),\n+                                                       argval, binding_mode,\n                                                        cleanup_scope);\n                         }\n                     }\n@@ -1674,7 +1677,7 @@ fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                             for (i, elem) in elems.iter().enumerate() {\n                                 let fldptr = adt::trans_field_ptr(bcx, &*repr,\n                                                                   val, 0, i);\n-                                bcx = bind_irrefutable_pat(bcx, *elem,\n+                                bcx = bind_irrefutable_pat(bcx, &**elem,\n                                                            fldptr, binding_mode,\n                                                            cleanup_scope);\n                             }\n@@ -1695,7 +1698,7 @@ fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     let ix = ty::field_idx_strict(tcx, f.ident.name, field_tys);\n                     let fldptr = adt::trans_field_ptr(bcx, &*pat_repr, val,\n                                                       discr, ix);\n-                    bcx = bind_irrefutable_pat(bcx, f.pat, fldptr,\n+                    bcx = bind_irrefutable_pat(bcx, &*f.pat, fldptr,\n                                                binding_mode, cleanup_scope);\n                 }\n             })\n@@ -1704,17 +1707,17 @@ fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let repr = adt::represent_node(bcx, pat.id);\n             for (i, elem) in elems.iter().enumerate() {\n                 let fldptr = adt::trans_field_ptr(bcx, &*repr, val, 0, i);\n-                bcx = bind_irrefutable_pat(bcx, *elem, fldptr,\n+                bcx = bind_irrefutable_pat(bcx, &**elem, fldptr,\n                                            binding_mode, cleanup_scope);\n             }\n         }\n-        ast::PatBox(inner) => {\n+        ast::PatBox(ref inner) => {\n             let llbox = Load(bcx, val);\n-            bcx = bind_irrefutable_pat(bcx, inner, llbox, binding_mode, cleanup_scope);\n+            bcx = bind_irrefutable_pat(bcx, &**inner, llbox, binding_mode, cleanup_scope);\n         }\n-        ast::PatRegion(inner) => {\n+        ast::PatRegion(ref inner) => {\n             let loaded_val = Load(bcx, val);\n-            bcx = bind_irrefutable_pat(bcx, inner, loaded_val, binding_mode, cleanup_scope);\n+            bcx = bind_irrefutable_pat(bcx, &**inner, loaded_val, binding_mode, cleanup_scope);\n         }\n         ast::PatVec(ref before, ref slice, ref after) => {\n             let pat_ty = node_id_type(bcx, pat.id);\n@@ -1733,8 +1736,8 @@ fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 .chain(slice.iter())\n                 .chain(after.iter())\n                 .zip(extracted.vals.move_iter())\n-                .fold(bcx, |bcx, (&inner, elem)|\n-                    bind_irrefutable_pat(bcx, inner, elem, binding_mode, cleanup_scope)\n+                .fold(bcx, |bcx, (inner, elem)|\n+                    bind_irrefutable_pat(bcx, &**inner, elem, binding_mode, cleanup_scope)\n                 );\n         }\n         ast::PatMac(..) => {"}, {"sha": "c474aab9b2647a03ab3bfd09cb4e28e8cd275e6f", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -67,10 +67,10 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n         let in_datum = unpack_datum!(bcx, expr::trans(bcx, &**input));\n         unpack_result!(bcx, {\n             callee::trans_arg_datum(bcx,\n-                                   expr_ty(bcx, &**input),\n-                                   in_datum,\n-                                   cleanup::CustomScope(temp_scope),\n-                                   callee::DontAutorefArg)\n+                                    expr_ty(bcx, &**input),\n+                                    in_datum,\n+                                    cleanup::CustomScope(temp_scope),\n+                                    callee::DontAutorefArg)\n         })\n     }).collect::<Vec<_>>().append(ext_inputs.as_slice());\n "}, {"sha": "e86df8651187062424549effdec85d27e1f9b621", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -1356,7 +1356,7 @@ fn has_nested_returns(tcx: &ty::ctxt, id: ast::NodeId) -> bool {\n     match tcx.map.find(id) {\n         Some(ast_map::NodeItem(i)) => {\n             match i.node {\n-                ast::ItemFn(_, _, _, _, blk) => {\n+                ast::ItemFn(_, _, _, _, ref blk) => {\n                     let mut explicit = CheckForNestedReturnsVisitor::explicit();\n                     let mut implicit = CheckForNestedReturnsVisitor::implicit();\n                     visit::walk_item(&mut explicit, &*i);\n@@ -1368,12 +1368,12 @@ fn has_nested_returns(tcx: &ty::ctxt, id: ast::NodeId) -> bool {\n         }\n         Some(ast_map::NodeTraitItem(trait_method)) => {\n             match *trait_method {\n-                ast::ProvidedMethod(m) => {\n+                ast::ProvidedMethod(ref m) => {\n                     match m.node {\n-                        ast::MethDecl(_, _, _, _, _, _, blk, _) => {\n+                        ast::MethDecl(_, _, _, _, _, _, ref blk, _) => {\n                             let mut explicit = CheckForNestedReturnsVisitor::explicit();\n                             let mut implicit = CheckForNestedReturnsVisitor::implicit();\n-                            visit::walk_method_helper(&mut explicit, &*m);\n+                            visit::walk_method_helper(&mut explicit, &**m);\n                             visit::walk_expr_opt(&mut implicit, &blk.expr);\n                             explicit.found || implicit.found\n                         }\n@@ -1386,11 +1386,11 @@ fn has_nested_returns(tcx: &ty::ctxt, id: ast::NodeId) -> bool {\n                 }\n             }\n         }\n-        Some(ast_map::NodeImplItem(ref ii)) => {\n-            match **ii {\n+        Some(ast_map::NodeImplItem(ii)) => {\n+            match *ii {\n                 ast::MethodImplItem(ref m) => {\n                     match m.node {\n-                        ast::MethDecl(_, _, _, _, _, _, blk, _) => {\n+                        ast::MethDecl(_, _, _, _, _, _, ref blk, _) => {\n                             let mut explicit = CheckForNestedReturnsVisitor::explicit();\n                             let mut implicit = CheckForNestedReturnsVisitor::implicit();\n                             visit::walk_method_helper(&mut explicit, &**m);\n@@ -1404,12 +1404,12 @@ fn has_nested_returns(tcx: &ty::ctxt, id: ast::NodeId) -> bool {\n         }\n         Some(ast_map::NodeExpr(e)) => {\n             match e.node {\n-                ast::ExprFnBlock(_, _, blk) |\n-                ast::ExprProc(_, blk) |\n-                ast::ExprUnboxedFn(_, _, _, blk) => {\n+                ast::ExprFnBlock(_, _, ref blk) |\n+                ast::ExprProc(_, ref blk) |\n+                ast::ExprUnboxedFn(_, _, _, ref blk) => {\n                     let mut explicit = CheckForNestedReturnsVisitor::explicit();\n                     let mut implicit = CheckForNestedReturnsVisitor::implicit();\n-                    visit::walk_expr(&mut explicit, &*e);\n+                    visit::walk_expr(&mut explicit, e);\n                     visit::walk_expr_opt(&mut implicit, &blk.expr);\n                     explicit.found || implicit.found\n                 }\n@@ -1649,7 +1649,7 @@ fn copy_args_to_allocas<'blk, 'tcx>(fcx: &FunctionContext<'blk, 'tcx>,\n         // This alloca should be optimized away by LLVM's mem-to-reg pass in\n         // the event it's not truly needed.\n \n-        bcx = _match::store_arg(bcx, args[i].pat, arg_datum, arg_scope_id);\n+        bcx = _match::store_arg(bcx, &*args[i].pat, arg_datum, arg_scope_id);\n \n         if fcx.ccx.sess().opts.debuginfo == FullDebugInfo {\n             debuginfo::create_argument_metadata(bcx, &args[i]);\n@@ -1701,7 +1701,7 @@ fn copy_unboxed_closure_args_to_allocas<'blk, 'tcx>(\n                           tuple_element_datum.to_rvalue_datum(bcx,\n                                                               \"arg\"));\n         bcx = _match::store_arg(bcx,\n-                                args[j].pat,\n+                                &*args[j].pat,\n                                 tuple_element_datum,\n                                 arg_scope_id);\n \n@@ -2008,7 +2008,7 @@ pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     if !type_is_zero_size(ccx, result_ty) {\n         match args {\n             callee::ArgExprs(exprs) => {\n-                let fields = exprs.iter().map(|x| *x).enumerate().collect::<Vec<_>>();\n+                let fields = exprs.iter().map(|x| &**x).enumerate().collect::<Vec<_>>();\n                 bcx = expr::trans_adt(bcx, result_ty, disr, fields.as_slice(),\n                                       None, expr::SaveIn(llresult));\n             }\n@@ -2792,15 +2792,15 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                     ccx.sess().bug(\"unexpected variant: required trait method in \\\n                                    get_item_val()\");\n                 }\n-                ast::ProvidedMethod(m) => {\n-                    register_method(ccx, id, &*m)\n+                ast::ProvidedMethod(ref m) => {\n+                    register_method(ccx, id, &**m)\n                 }\n             }\n         }\n \n         ast_map::NodeImplItem(ii) => {\n             match *ii {\n-                ast::MethodImplItem(m) => register_method(ccx, id, &*m),\n+                ast::MethodImplItem(ref m) => register_method(ccx, id, &**m),\n             }\n         }\n \n@@ -3042,9 +3042,10 @@ fn internalize_symbols(cx: &SharedCrateContext, reachable: &HashSet<String>) {\n     }\n }\n \n-pub fn trans_crate(krate: ast::Crate,\n-                   analysis: CrateAnalysis) -> (ty::ctxt, CrateTranslation) {\n+pub fn trans_crate<'tcx>(analysis: CrateAnalysis<'tcx>)\n+                         -> (ty::ctxt<'tcx>, CrateTranslation) {\n     let CrateAnalysis { ty_cx: tcx, exp_map2, reachable, name, .. } = analysis;\n+    let krate = tcx.map.krate();\n \n     // Before we touch LLVM, make sure that multithreading is enabled.\n     unsafe {\n@@ -3064,7 +3065,7 @@ pub fn trans_crate(krate: ast::Crate,\n         }\n     }\n \n-    let link_meta = link::build_link_meta(&tcx.sess, &krate, name);\n+    let link_meta = link::build_link_meta(&tcx.sess, krate, name);\n \n     let codegen_units = tcx.sess.opts.cg.codegen_units;\n     let shared_ccx = SharedCrateContext::new(link_meta.crate_name.as_slice(),\n@@ -3096,7 +3097,7 @@ pub fn trans_crate(krate: ast::Crate,\n     }\n \n     // Translate the metadata.\n-    let metadata = write_metadata(&shared_ccx, &krate);\n+    let metadata = write_metadata(&shared_ccx, krate);\n \n     if shared_ccx.sess().trans_stats() {\n         let stats = shared_ccx.stats();"}, {"sha": "878d95773ada5c512c16f15532f89aa5e8a6ce83", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -53,10 +53,10 @@ use middle::typeck::MethodCall;\n use util::ppaux::Repr;\n use util::ppaux::ty_to_string;\n \n-use std::gc::Gc;\n use syntax::abi as synabi;\n use syntax::ast;\n use syntax::ast_map;\n+use syntax::ptr::P;\n \n pub struct MethodData {\n     pub llfn: ValueRef,\n@@ -902,7 +902,7 @@ pub fn trans_call_inner<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n pub enum CallArgs<'a> {\n     // Supply value of arguments as a list of expressions that must be\n     // translated. This is used in the common case of `foo(bar, qux)`.\n-    ArgExprs(&'a [Gc<ast::Expr>]),\n+    ArgExprs(&'a [P<ast::Expr>]),\n \n     // Supply value of arguments as a list of LLVM value refs; frequently\n     // used with lang items and so forth, when the argument is an internal\n@@ -916,12 +916,12 @@ pub enum CallArgs<'a> {\n \n     // Supply value of arguments as a list of expressions that must be\n     // translated, for overloaded call operators.\n-    ArgOverloadedCall(&'a [Gc<ast::Expr>]),\n+    ArgOverloadedCall(Vec<&'a ast::Expr>),\n }\n \n fn trans_args_under_call_abi<'blk, 'tcx>(\n                              mut bcx: Block<'blk, 'tcx>,\n-                             arg_exprs: &[Gc<ast::Expr>],\n+                             arg_exprs: &[P<ast::Expr>],\n                              fn_ty: ty::t,\n                              llargs: &mut Vec<ValueRef>,\n                              arg_cleanup_scope: cleanup::ScopeId,\n@@ -941,13 +941,13 @@ fn trans_args_under_call_abi<'blk, 'tcx>(\n     }\n \n     // Now untuple the rest of the arguments.\n-    let tuple_expr = arg_exprs[1];\n+    let tuple_expr = &arg_exprs[1];\n     let tuple_type = node_id_type(bcx, tuple_expr.id);\n \n     match ty::get(tuple_type).sty {\n         ty::ty_tup(ref field_types) => {\n             let tuple_datum = unpack_datum!(bcx,\n-                                            expr::trans(bcx, &*tuple_expr));\n+                                            expr::trans(bcx, &**tuple_expr));\n             let tuple_lvalue_datum =\n                 unpack_datum!(bcx,\n                               tuple_datum.to_lvalue_datum(bcx,\n@@ -982,7 +982,7 @@ fn trans_args_under_call_abi<'blk, 'tcx>(\n \n fn trans_overloaded_call_args<'blk, 'tcx>(\n                               mut bcx: Block<'blk, 'tcx>,\n-                              arg_exprs: &[Gc<ast::Expr>],\n+                              arg_exprs: Vec<&ast::Expr>,\n                               fn_ty: ty::t,\n                               llargs: &mut Vec<ValueRef>,\n                               arg_cleanup_scope: cleanup::ScopeId,\n@@ -991,7 +991,7 @@ fn trans_overloaded_call_args<'blk, 'tcx>(\n     // Translate the `self` argument first.\n     let arg_tys = ty::ty_fn_args(fn_ty);\n     if !ignore_self {\n-        let arg_datum = unpack_datum!(bcx, expr::trans(bcx, &*arg_exprs[0]));\n+        let arg_datum = unpack_datum!(bcx, expr::trans(bcx, arg_exprs[0]));\n         llargs.push(unpack_result!(bcx, {\n             trans_arg_datum(bcx,\n                             *arg_tys.get(0),\n@@ -1007,7 +1007,7 @@ fn trans_overloaded_call_args<'blk, 'tcx>(\n         ty::ty_tup(ref field_types) => {\n             for (i, &field_type) in field_types.iter().enumerate() {\n                 let arg_datum =\n-                    unpack_datum!(bcx, expr::trans(bcx, &*arg_exprs[i + 1]));\n+                    unpack_datum!(bcx, expr::trans(bcx, arg_exprs[i + 1]));\n                 llargs.push(unpack_result!(bcx, {\n                     trans_arg_datum(bcx,\n                                     field_type,"}, {"sha": "bbb9ba4bbb685c13740c8e7bbc9f2592d55d72f5", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -472,7 +472,7 @@ impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n \n     pub fn def(&self, nid: ast::NodeId) -> def::Def {\n         match self.tcx().def_map.borrow().find(&nid) {\n-            Some(&v) => v,\n+            Some(v) => v.clone(),\n             None => {\n                 self.tcx().sess.bug(format!(\n                     \"no def associated with node id {:?}\", nid).as_slice());"}, {"sha": "576031500b9588c609725fe0d81fc696e74cfa86", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -33,12 +33,12 @@ use middle::ty;\n use util::ppaux::{Repr, ty_to_string};\n \n use std::c_str::ToCStr;\n-use std::gc::Gc;\n use std::vec;\n use libc::c_uint;\n use syntax::{ast, ast_util};\n+use syntax::ptr::P;\n \n-pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: ast::Lit)\n+pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: &ast::Lit)\n     -> ValueRef {\n     let _icx = push_ctxt(\"trans_lit\");\n     debug!(\"const_lit: {}\", lit);\n@@ -102,7 +102,7 @@ fn first_two<R, S, T>((a, b, _): (R, S, T)) -> (R, S) {\n }\n \n fn const_vec(cx: &CrateContext, e: &ast::Expr,\n-             es: &[Gc<ast::Expr>], is_local: bool) -> (ValueRef, Type, bool) {\n+             es: &[P<ast::Expr>], is_local: bool) -> (ValueRef, Type, bool) {\n     let vec_ty = ty::expr_ty(cx.tcx(), e);\n     let unit_ty = ty::sequence_element_type(cx.tcx(), vec_ty);\n     let llunitty = type_of::type_of(cx, unit_ty);\n@@ -321,7 +321,7 @@ pub fn const_expr(cx: &CrateContext, e: &ast::Expr, is_local: bool) -> (ValueRef\n // if it's assigned to a static.\n fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n                          is_local: bool) -> (ValueRef, bool) {\n-    let map_list = |exprs: &[Gc<ast::Expr>]| {\n+    let map_list = |exprs: &[P<ast::Expr>]| {\n         exprs.iter().map(|e| first_two(const_expr(cx, &**e, is_local)))\n              .fold((Vec::new(), true),\n                    |(l, all_inlineable), (val, inlineable)| {\n@@ -332,7 +332,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n         let _icx = push_ctxt(\"const_expr\");\n         return match e.node {\n           ast::ExprLit(ref lit) => {\n-              (consts::const_lit(cx, e, (**lit).clone()), true)\n+              (consts::const_lit(cx, e, &**lit), true)\n           }\n           ast::ExprBinary(b, ref e1, ref e2) => {\n             let (te1, _, _) = const_expr(cx, &**e1, is_local);\n@@ -653,7 +653,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n                 }\n             }\n           }\n-          ast::ExprCall(callee, ref args) => {\n+          ast::ExprCall(ref callee, ref args) => {\n               let opt_def = cx.tcx().def_map.borrow().find_copy(&callee.id);\n               match opt_def {\n                   Some(def::DefStruct(_)) => {"}, {"sha": "fb12520741bcf5656d884b60d295839d8b89c850", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -39,8 +39,6 @@ use syntax::parse::token::InternedString;\n use syntax::parse::token;\n use syntax::visit::Visitor;\n \n-use std::gc::Gc;\n-\n pub fn trans_stmt<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                               s: &ast::Stmt)\n                               -> Block<'blk, 'tcx> {\n@@ -61,7 +59,7 @@ pub fn trans_stmt<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n         ast::StmtExpr(ref e, _) | ast::StmtSemi(ref e, _) => {\n             bcx = trans_stmt_semi(bcx, &**e);\n         }\n-        ast::StmtDecl(d, _) => {\n+        ast::StmtDecl(ref d, _) => {\n             match d.node {\n                 ast::DeclLocal(ref local) => {\n                     bcx = init_local(bcx, &**local);\n@@ -132,8 +130,8 @@ pub fn trans_block<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n pub fn trans_if<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                             if_id: ast::NodeId,\n                             cond: &ast::Expr,\n-                            thn: ast::P<ast::Block>,\n-                            els: Option<Gc<ast::Expr>>,\n+                            thn: &ast::Block,\n+                            els: Option<&ast::Expr>,\n                             dest: expr::Dest)\n                             -> Block<'blk, 'tcx> {\n     debug!(\"trans_if(bcx={}, if_id={}, cond={}, thn={:?}, dest={})\",\n@@ -251,7 +249,7 @@ pub fn trans_while<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n /// Translates a `for` loop.\n pub fn trans_for<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                              loop_info: NodeInfo,\n-                             pat: Gc<ast::Pat>,\n+                             pat: &ast::Pat,\n                              head: &ast::Expr,\n                              body: &ast::Block)\n                              -> Block<'blk, 'tcx> {\n@@ -453,7 +451,7 @@ pub fn trans_cont<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n }\n \n pub fn trans_ret<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                             e: Option<Gc<ast::Expr>>)\n+                             e: Option<&ast::Expr>)\n                              -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_ret\");\n     let fcx = bcx.fcx;"}, {"sha": "21ba2189414c21aad65d5ed131e0361e0af73ff9", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 35, "deletions": 37, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -207,7 +207,6 @@ use std::c_str::{CString, ToCStr};\n use std::cell::{Cell, RefCell};\n use std::collections::HashMap;\n use std::collections::HashSet;\n-use std::gc::Gc;\n use std::ptr;\n use std::rc::{Rc, Weak};\n use syntax::util::interner::Interner;\n@@ -1129,8 +1128,8 @@ pub fn create_function_debug_context(cx: &CrateContext,\n             }\n \n             match item.node {\n-                ast::ItemFn(fn_decl, _, _, ref generics, top_level_block) => {\n-                    (item.ident, fn_decl, generics, top_level_block, item.span, true)\n+                ast::ItemFn(ref fn_decl, _, _, ref generics, ref top_level_block) => {\n+                    (item.ident, &**fn_decl, generics, &**top_level_block, item.span, true)\n                 }\n                 _ => {\n                     cx.sess().span_bug(item.span,\n@@ -1158,16 +1157,16 @@ pub fn create_function_debug_context(cx: &CrateContext,\n         }\n         ast_map::NodeExpr(ref expr) => {\n             match expr.node {\n-                ast::ExprFnBlock(_, fn_decl, top_level_block) |\n-                ast::ExprProc(fn_decl, top_level_block) |\n-                ast::ExprUnboxedFn(_, _, fn_decl, top_level_block) => {\n+                ast::ExprFnBlock(_, ref fn_decl, ref top_level_block) |\n+                ast::ExprProc(ref fn_decl, ref top_level_block) |\n+                ast::ExprUnboxedFn(_, _, ref fn_decl, ref top_level_block) => {\n                     let name = format!(\"fn{}\", token::gensym(\"fn\"));\n                     let name = token::str_to_ident(name.as_slice());\n-                    (name, fn_decl,\n+                    (name, &**fn_decl,\n                         // This is not quite right. It should actually inherit\n                         // the generics of the enclosing function.\n                         &empty_generics,\n-                        top_level_block,\n+                        &**top_level_block,\n                         expr.span,\n                         // Don't try to lookup the item path:\n                         false)\n@@ -1287,9 +1286,8 @@ pub fn create_function_debug_context(cx: &CrateContext,\n         source_locations_enabled: Cell::new(false),\n     };\n \n-    let arg_pats = fn_decl.inputs.iter().map(|arg_ref| arg_ref.pat).collect::<Vec<_>>();\n     populate_scope_map(cx,\n-                       arg_pats.as_slice(),\n+                       fn_decl.inputs.as_slice(),\n                        &*top_level_block,\n                        fn_metadata,\n                        &mut *fn_debug_context.scope_map.borrow_mut());\n@@ -3169,7 +3167,7 @@ fn get_namespace_and_span_for_item(cx: &CrateContext, def_id: ast::DefId)\n // introducing *artificial* lexical scope descriptors where necessary. These\n // artificial scopes allow GDB to correctly handle name shadowing.\n fn populate_scope_map(cx: &CrateContext,\n-                      arg_pats: &[Gc<ast::Pat>],\n+                      args: &[ast::Arg],\n                       fn_entry_block: &ast::Block,\n                       fn_metadata: DISubprogram,\n                       scope_map: &mut HashMap<ast::NodeId, DIScope>) {\n@@ -3185,8 +3183,8 @@ fn populate_scope_map(cx: &CrateContext,\n \n     // Push argument identifiers onto the stack so arguments integrate nicely\n     // with variable shadowing.\n-    for &arg_pat in arg_pats.iter() {\n-        pat_util::pat_bindings(def_map, &*arg_pat, |_, _, _, path1| {\n+    for arg in args.iter() {\n+        pat_util::pat_bindings(def_map, &*arg.pat, |_, _, _, path1| {\n             scope_stack.push(ScopeStackEntry { scope_metadata: fn_metadata,\n                                                ident: Some(path1.node) });\n         })\n@@ -3272,10 +3270,10 @@ fn populate_scope_map(cx: &CrateContext,\n                  scope_stack: &mut Vec<ScopeStackEntry> ,\n                  scope_map: &mut HashMap<ast::NodeId, DIScope>) {\n         match *decl {\n-            codemap::Spanned { node: ast::DeclLocal(local), .. } => {\n+            codemap::Spanned { node: ast::DeclLocal(ref local), .. } => {\n                 scope_map.insert(local.id, scope_stack.last().unwrap().scope_metadata);\n \n-                walk_pattern(cx, local.pat, scope_stack, scope_map);\n+                walk_pattern(cx, &*local.pat, scope_stack, scope_map);\n \n                 for exp in local.init.iter() {\n                     walk_expr(cx, &**exp, scope_stack, scope_map);\n@@ -3286,7 +3284,7 @@ fn populate_scope_map(cx: &CrateContext,\n     }\n \n     fn walk_pattern(cx: &CrateContext,\n-                    pat: Gc<ast::Pat>,\n+                    pat: &ast::Pat,\n                     scope_stack: &mut Vec<ScopeStackEntry> ,\n                     scope_map: &mut HashMap<ast::NodeId, DIScope>) {\n \n@@ -3367,8 +3365,8 @@ fn populate_scope_map(cx: &CrateContext,\n \n                 scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n \n-                for &sub_pat in sub_pat_opt.iter() {\n-                    walk_pattern(cx, sub_pat, scope_stack, scope_map);\n+                for sub_pat in sub_pat_opt.iter() {\n+                    walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n                 }\n             }\n \n@@ -3379,32 +3377,32 @@ fn populate_scope_map(cx: &CrateContext,\n             ast::PatEnum(_, ref sub_pats_opt) => {\n                 scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n \n-                for ref sub_pats in sub_pats_opt.iter() {\n-                    for &p in sub_pats.iter() {\n-                        walk_pattern(cx, p, scope_stack, scope_map);\n+                for sub_pats in sub_pats_opt.iter() {\n+                    for p in sub_pats.iter() {\n+                        walk_pattern(cx, &**p, scope_stack, scope_map);\n                     }\n                 }\n             }\n \n             ast::PatStruct(_, ref field_pats, _) => {\n                 scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n \n-                for &ast::FieldPat { pat: sub_pat, .. } in field_pats.iter() {\n-                    walk_pattern(cx, sub_pat, scope_stack, scope_map);\n+                for &ast::FieldPat { pat: ref sub_pat, .. } in field_pats.iter() {\n+                    walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n                 }\n             }\n \n             ast::PatTup(ref sub_pats) => {\n                 scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n \n                 for sub_pat in sub_pats.iter() {\n-                    walk_pattern(cx, sub_pat.clone(), scope_stack, scope_map);\n+                    walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n                 }\n             }\n \n             ast::PatBox(ref sub_pat) | ast::PatRegion(ref sub_pat) => {\n                 scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n-                walk_pattern(cx, sub_pat.clone(), scope_stack, scope_map);\n+                walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n             }\n \n             ast::PatLit(ref exp) => {\n@@ -3421,16 +3419,16 @@ fn populate_scope_map(cx: &CrateContext,\n             ast::PatVec(ref front_sub_pats, ref middle_sub_pats, ref back_sub_pats) => {\n                 scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n \n-                for &sub_pat in front_sub_pats.iter() {\n-                    walk_pattern(cx, sub_pat, scope_stack, scope_map);\n+                for sub_pat in front_sub_pats.iter() {\n+                    walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n                 }\n \n-                for &sub_pat in middle_sub_pats.iter() {\n-                    walk_pattern(cx, sub_pat, scope_stack, scope_map);\n+                for sub_pat in middle_sub_pats.iter() {\n+                    walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n                 }\n \n-                for &sub_pat in back_sub_pats.iter() {\n-                    walk_pattern(cx, sub_pat, scope_stack, scope_map);\n+                for sub_pat in back_sub_pats.iter() {\n+                    walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n                 }\n             }\n \n@@ -3466,8 +3464,8 @@ fn populate_scope_map(cx: &CrateContext,\n                 walk_expr(cx, &**sub_expr, scope_stack, scope_map);\n             }\n \n-            ast::ExprRet(exp_opt) => match exp_opt {\n-                Some(sub_exp) => walk_expr(cx, &*sub_exp, scope_stack, scope_map),\n+            ast::ExprRet(ref exp_opt) => match *exp_opt {\n+                Some(ref sub_exp) => walk_expr(cx, &**sub_exp, scope_stack, scope_map),\n                 None => ()\n             },\n \n@@ -3538,7 +3536,7 @@ fn populate_scope_map(cx: &CrateContext,\n                                                 .unwrap()\n                                                 .scope_metadata);\n                     walk_pattern(cx,\n-                                 *pattern,\n+                                 &**pattern,\n                                  scope_stack,\n                                  scope_map);\n                     walk_block(cx, &**body, scope_stack, scope_map);\n@@ -3570,7 +3568,7 @@ fn populate_scope_map(cx: &CrateContext,\n                                scope_map,\n                                |cx, scope_stack, scope_map| {\n                     for &ast::Arg { pat: ref pattern, .. } in decl.inputs.iter() {\n-                        walk_pattern(cx, pattern.clone(), scope_stack, scope_map);\n+                        walk_pattern(cx, &**pattern, scope_stack, scope_map);\n                     }\n \n                     walk_block(cx, &**block, scope_stack, scope_map);\n@@ -3607,8 +3605,8 @@ fn populate_scope_map(cx: &CrateContext,\n                                    scope_stack,\n                                    scope_map,\n                                    |cx, scope_stack, scope_map| {\n-                        for &pat in arm_ref.pats.iter() {\n-                            walk_pattern(cx, pat, scope_stack, scope_map);\n+                        for pat in arm_ref.pats.iter() {\n+                            walk_pattern(cx, &**pat, scope_stack, scope_map);\n                         }\n \n                         for guard_exp in arm_ref.guard.iter() {"}, {"sha": "8a6f3dd6ffab61898273b6cfb32da8b65a62c69d", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 34, "deletions": 35, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -77,8 +77,7 @@ use middle::trans::type_::Type;\n use syntax::ast;\n use syntax::codemap;\n use syntax::print::pprust::{expr_to_string};\n-\n-use std::gc::Gc;\n+use syntax::ptr::P;\n \n // Destinations\n \n@@ -597,7 +596,7 @@ fn trans_datum_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             }\n \n         }\n-        ast::ExprLit(ref lit) => trans_immediate_lit(bcx, expr, (**lit).clone()),\n+        ast::ExprLit(ref lit) => trans_immediate_lit(bcx, expr, &**lit),\n         ast::ExprBinary(op, ref lhs, ref rhs) => {\n             trans_binary(bcx, expr, op, &**lhs, &**rhs)\n         }\n@@ -882,16 +881,16 @@ fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         ast::ExprAgain(label_opt) => {\n             controlflow::trans_cont(bcx, expr.id, label_opt)\n         }\n-        ast::ExprRet(ex) => {\n-            controlflow::trans_ret(bcx, ex)\n+        ast::ExprRet(ref ex) => {\n+            controlflow::trans_ret(bcx, ex.as_ref().map(|e| &**e))\n         }\n         ast::ExprWhile(ref cond, ref body, _) => {\n             controlflow::trans_while(bcx, expr.id, &**cond, &**body)\n         }\n         ast::ExprForLoop(ref pat, ref head, ref body, _) => {\n             controlflow::trans_for(bcx,\n                                    expr_info(expr),\n-                                   *pat,\n+                                   &**pat,\n                                    &**head,\n                                    &**body)\n         }\n@@ -928,7 +927,7 @@ fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             }\n         }\n         ast::ExprAssignOp(op, ref dst, ref src) => {\n-            trans_assign_op(bcx, expr, op, &**dst, src.clone())\n+            trans_assign_op(bcx, expr, op, &**dst, &**src)\n         }\n         ast::ExprInlineAsm(ref a) => {\n             asm::trans_inline_asm(bcx, a)\n@@ -958,29 +957,29 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         ast::ExprPath(_) => {\n             trans_def_dps_unadjusted(bcx, expr, bcx.def(expr.id), dest)\n         }\n-        ast::ExprIf(ref cond, ref thn, els) => {\n-            controlflow::trans_if(bcx, expr.id, &**cond, thn.clone(), els, dest)\n+        ast::ExprIf(ref cond, ref thn, ref els) => {\n+            controlflow::trans_if(bcx, expr.id, &**cond, &**thn, els.as_ref().map(|e| &**e), dest)\n         }\n         ast::ExprMatch(ref discr, ref arms) => {\n             _match::trans_match(bcx, expr, &**discr, arms.as_slice(), dest)\n         }\n         ast::ExprBlock(ref blk) => {\n             controlflow::trans_block(bcx, &**blk, dest)\n         }\n-        ast::ExprStruct(_, ref fields, base) => {\n+        ast::ExprStruct(_, ref fields, ref base) => {\n             trans_struct(bcx,\n                          fields.as_slice(),\n-                         base,\n+                         base.as_ref().map(|e| &**e),\n                          expr.span,\n                          expr.id,\n                          dest)\n         }\n         ast::ExprTup(ref args) => {\n-            let numbered_fields: Vec<(uint, Gc<ast::Expr>)> =\n-                args.iter().enumerate().map(|(i, arg)| (i, *arg)).collect();\n+            let numbered_fields: Vec<(uint, &ast::Expr)> =\n+                args.iter().enumerate().map(|(i, arg)| (i, &**arg)).collect();\n             trans_adt(bcx, expr_ty(bcx, expr), 0, numbered_fields.as_slice(), None, dest)\n         }\n-        ast::ExprLit(lit) => {\n+        ast::ExprLit(ref lit) => {\n             match lit.node {\n                 ast::LitStr(ref s, _) => {\n                     tvec::trans_lit_str(bcx, expr, (*s).clone(), dest)\n@@ -1005,14 +1004,14 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                    expr_to_string(expr), expr_ty.repr(tcx));\n             closure::trans_expr_fn(bcx, store, &**decl, &**body, expr.id, dest)\n         }\n-        ast::ExprUnboxedFn(_, _, decl, body) => {\n-            closure::trans_unboxed_closure(bcx, &*decl, &*body, expr.id, dest)\n+        ast::ExprUnboxedFn(_, _, ref decl, ref body) => {\n+            closure::trans_unboxed_closure(bcx, &**decl, &**body, expr.id, dest)\n         }\n         ast::ExprCall(ref f, ref args) => {\n             if bcx.tcx().is_method_call(expr.id) {\n                 trans_overloaded_call(bcx,\n                                       expr,\n-                                      *f,\n+                                      &**f,\n                                       args.as_slice(),\n                                       Some(dest))\n             } else {\n@@ -1061,7 +1060,7 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             }\n         }\n         ast::ExprAssignOp(op, ref dst, ref src) => {\n-            trans_assign_op(bcx, expr, op, &**dst, src.clone())\n+            trans_assign_op(bcx, expr, op, &**dst, &**src)\n         }\n         _ => {\n             bcx.tcx().sess.span_bug(\n@@ -1263,7 +1262,7 @@ pub fn with_field_tys<R>(tcx: &ty::ctxt,\n \n fn trans_struct<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                             fields: &[ast::Field],\n-                            base: Option<Gc<ast::Expr>>,\n+                       base: Option<&ast::Expr>,\n                             expr_span: codemap::Span,\n                             id: ast::NodeId,\n                             dest: Dest) -> Block<'blk, 'tcx> {\n@@ -1281,7 +1280,7 @@ fn trans_struct<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             match opt_pos {\n                 Some(i) => {\n                     *need_base.get_mut(i) = false;\n-                    (i, field.expr)\n+                    (i, &*field.expr)\n                 }\n                 None => {\n                     tcx.sess.span_bug(field.span,\n@@ -1320,11 +1319,12 @@ fn trans_struct<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n  * Note that `fields` may be empty; the base expression must always be\n  * evaluated for side-effects.\n  */\n-pub struct StructBaseInfo {\n+pub struct StructBaseInfo<'a> {\n     /// The base expression; will be evaluated after all explicit fields.\n-    expr: Gc<ast::Expr>,\n+    expr: &'a ast::Expr,\n     /// The indices of fields to copy paired with their types.\n-    fields: Vec<(uint, ty::t)> }\n+    fields: Vec<(uint, ty::t)>\n+}\n \n /**\n  * Constructs an ADT instance:\n@@ -1339,7 +1339,7 @@ pub struct StructBaseInfo {\n pub fn trans_adt<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                              ty: ty::t,\n                              discr: ty::Disr,\n-                             fields: &[(uint, Gc<ast::Expr>)],\n+                             fields: &[(uint, &ast::Expr)],\n                              optbase: Option<StructBaseInfo>,\n                              dest: Dest) -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_adt\");\n@@ -1407,7 +1407,7 @@ pub fn trans_adt<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n fn trans_immediate_lit<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                    expr: &ast::Expr,\n-                                   lit: ast::Lit)\n+                                   lit: &ast::Lit)\n                                    -> DatumBlock<'blk, 'tcx, Expr> {\n     // must not be a string constant, that is a RvalueDpsExpr\n     let _icx = push_ctxt(\"trans_immediate_lit\");\n@@ -1750,20 +1750,20 @@ fn trans_overloaded_op<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                              dest)\n }\n \n-fn trans_overloaded_call<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n-                                     expr: &ast::Expr,\n-                                     callee: Gc<ast::Expr>,\n-                                     args: &[Gc<ast::Expr>],\n-                                     dest: Option<Dest>)\n-                                     -> Block<'blk, 'tcx> {\n+fn trans_overloaded_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n+                                         expr: &ast::Expr,\n+                                         callee: &'a ast::Expr,\n+                                         args: &'a [P<ast::Expr>],\n+                                         dest: Option<Dest>)\n+                                         -> Block<'blk, 'tcx> {\n     let method_call = MethodCall::expr(expr.id);\n     let method_type = bcx.tcx()\n                          .method_map\n                          .borrow()\n                          .get(&method_call)\n                          .ty;\n     let mut all_args = vec!(callee);\n-    all_args.push_all(args);\n+    all_args.extend(args.iter().map(|e| &**e));\n     unpack_result!(bcx,\n                    callee::trans_call_inner(bcx,\n                                             Some(expr_info(expr)),\n@@ -1776,8 +1776,7 @@ fn trans_overloaded_call<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                                     None,\n                                                     arg_cleanup_scope)\n                                             },\n-                                            callee::ArgOverloadedCall(\n-                                                all_args.as_slice()),\n+                                            callee::ArgOverloadedCall(all_args),\n                                             dest));\n     bcx\n }\n@@ -1957,7 +1956,7 @@ fn trans_assign_op<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                expr: &ast::Expr,\n                                op: ast::BinOp,\n                                dst: &ast::Expr,\n-                               src: Gc<ast::Expr>)\n+                               src: &ast::Expr)\n                                -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_assign_op\");\n     let mut bcx = bcx;"}, {"sha": "e1e728fbea018bd0dcf4fe6c9cacb26a78109a25", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -47,12 +47,12 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n             ccx.external().borrow_mut().insert(fn_id, None);\n             return None;\n         }\n-        csearch::found(ast::IIItem(item)) => {\n+        csearch::found(&ast::IIItem(ref item)) => {\n             ccx.external().borrow_mut().insert(fn_id, Some(item.id));\n             ccx.external_srcs().borrow_mut().insert(item.id, fn_id);\n \n             ccx.stats().n_inlines.set(ccx.stats().n_inlines.get() + 1);\n-            trans_item(ccx, &*item);\n+            trans_item(ccx, &**item);\n \n             let linkage = match item.node {\n                 ast::ItemFn(_, _, _, ref generics, _) => {\n@@ -104,12 +104,12 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n \n             local_def(item.id)\n         }\n-        csearch::found(ast::IIForeign(item)) => {\n+        csearch::found(&ast::IIForeign(ref item)) => {\n             ccx.external().borrow_mut().insert(fn_id, Some(item.id));\n             ccx.external_srcs().borrow_mut().insert(item.id, fn_id);\n             local_def(item.id)\n         }\n-        csearch::found_parent(parent_id, ast::IIItem(item)) => {\n+        csearch::found_parent(parent_id, &ast::IIItem(ref item)) => {\n             ccx.external().borrow_mut().insert(parent_id, Some(item.id));\n             ccx.external_srcs().borrow_mut().insert(item.id, parent_id);\n \n@@ -135,32 +135,37 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n             _ => ccx.sess().bug(\"maybe_instantiate_inline: item has a \\\n                                  non-enum, non-struct parent\")\n           }\n-          trans_item(ccx, &*item);\n+          trans_item(ccx, &**item);\n           local_def(my_id)\n         }\n         csearch::found_parent(_, _) => {\n             ccx.sess().bug(\"maybe_get_item_ast returned a found_parent \\\n              with a non-item parent\");\n         }\n-        csearch::found(ast::IITraitItem(impl_did, impl_item)) => {\n-            match impl_item {\n-                ast::ProvidedInlinedTraitItem(mth) |\n-                ast::RequiredInlinedTraitItem(mth) => {\n+        csearch::found(&ast::IITraitItem(_, ref trait_item)) => {\n+            match *trait_item {\n+                ast::RequiredMethod(_) => ccx.sess().bug(\"found RequiredMethod IITraitItem\"),\n+                ast::ProvidedMethod(ref mth) => {\n                     ccx.external().borrow_mut().insert(fn_id, Some(mth.id));\n                     ccx.external_srcs().borrow_mut().insert(mth.id, fn_id);\n \n                     ccx.stats().n_inlines.set(ccx.stats().n_inlines.get() + 1);\n-                }\n-            }\n \n-            match impl_item {\n-                ast::ProvidedInlinedTraitItem(mth) => {\n                     // If this is a default method, we can't look up the\n                     // impl type. But we aren't going to translate anyways, so\n                     // don't.\n                     local_def(mth.id)\n                 }\n-                ast::RequiredInlinedTraitItem(mth) => {\n+            }\n+        }\n+        csearch::found(&ast::IIImplItem(impl_did, ref impl_item)) => {\n+            match *impl_item {\n+                ast::MethodImplItem(ref mth) => {\n+                    ccx.external().borrow_mut().insert(fn_id, Some(mth.id));\n+                    ccx.external_srcs().borrow_mut().insert(mth.id, fn_id);\n+\n+                    ccx.stats().n_inlines.set(ccx.stats().n_inlines.get() + 1);\n+\n                     let impl_tpt = ty::lookup_item_type(ccx.tcx(), impl_did);\n                     let unparameterized = impl_tpt.generics.types.is_empty() &&\n                             mth.pe_generics().ty_params.is_empty();"}, {"sha": "4202c2deff6fc8442c8067d6e05a758308a8d302", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -66,23 +66,23 @@ pub fn trans_impl(ccx: &CrateContext,\n         let mut v = TransItemVisitor{ ccx: ccx };\n         for impl_item in impl_items.iter() {\n             match *impl_item {\n-                ast::MethodImplItem(method) => {\n-                    visit::walk_method_helper(&mut v, &*method);\n+                ast::MethodImplItem(ref method) => {\n+                    visit::walk_method_helper(&mut v, &**method);\n                 }\n             }\n         }\n         return;\n     }\n     for impl_item in impl_items.iter() {\n         match *impl_item {\n-            ast::MethodImplItem(method) => {\n+            ast::MethodImplItem(ref method) => {\n                 if method.pe_generics().ty_params.len() == 0u {\n                     let trans_everywhere = attr::requests_inline(method.attrs.as_slice());\n                     for (ref ccx, is_origin) in ccx.maybe_iter(trans_everywhere) {\n                         let llfn = get_item_val(ccx, method.id);\n                         trans_fn(ccx,\n-                                 &*method.pe_fn_decl(),\n-                                 &*method.pe_body(),\n+                                 method.pe_fn_decl(),\n+                                 method.pe_body(),\n                                  llfn,\n                                  &param_substs::empty(),\n                                  method.id,\n@@ -96,7 +96,7 @@ pub fn trans_impl(ccx: &CrateContext,\n                 let mut v = TransItemVisitor {\n                     ccx: ccx,\n                 };\n-                visit::walk_method_helper(&mut v, &*method);\n+                visit::walk_method_helper(&mut v, &**method);\n             }\n         }\n     }"}, {"sha": "57004922ef7d163b16d963b2b1695eb7175b712f", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -221,13 +221,13 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n         }\n         ast_map::NodeImplItem(ii) => {\n             match *ii {\n-                ast::MethodImplItem(mth) => {\n+                ast::MethodImplItem(ref mth) => {\n                     let d = mk_lldecl(abi::Rust);\n                     let needs_body = setup_lldecl(d, mth.attrs.as_slice());\n                     if needs_body {\n                         trans_fn(ccx,\n-                                 &*mth.pe_fn_decl(),\n-                                 &*mth.pe_body(),\n+                                 mth.pe_fn_decl(),\n+                                 mth.pe_body(),\n                                  d,\n                                  &psubsts,\n                                  mth.id,\n@@ -239,11 +239,11 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n         }\n         ast_map::NodeTraitItem(method) => {\n             match *method {\n-                ast::ProvidedMethod(mth) => {\n+                ast::ProvidedMethod(ref mth) => {\n                     let d = mk_lldecl(abi::Rust);\n                     let needs_body = setup_lldecl(d, mth.attrs.as_slice());\n                     if needs_body {\n-                        trans_fn(ccx, &*mth.pe_fn_decl(), &*mth.pe_body(), d,\n+                        trans_fn(ccx, mth.pe_fn_decl(), mth.pe_body(), d,\n                                  &psubsts, mth.id, []);\n                     }\n                     d"}, {"sha": "f5c3ed388b7f9af7c80d2ffb88ca272de3ada0a3", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -156,7 +156,7 @@ pub fn trans_slice_vec<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     // Handle the \"...\" case (returns a slice since strings are always unsized):\n     match content_expr.node {\n-        ast::ExprLit(lit) => {\n+        ast::ExprLit(ref lit) => {\n             match lit.node {\n                 ast::LitStr(ref s, _) => {\n                     let scratch = rvalue_scratch_datum(bcx, vec_ty, \"\");\n@@ -255,7 +255,7 @@ pub fn write_content<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n            bcx.expr_to_string(vstore_expr));\n \n     match content_expr.node {\n-        ast::ExprLit(lit) => {\n+        ast::ExprLit(ref lit) => {\n             match lit.node {\n                 ast::LitStr(ref s, _) => {\n                     match dest {\n@@ -363,7 +363,7 @@ pub fn elements_required(bcx: Block, content_expr: &ast::Expr) -> uint {\n     //! Figure out the number of elements we need to store this content\n \n     match content_expr.node {\n-        ast::ExprLit(lit) => {\n+        ast::ExprLit(ref lit) => {\n             match lit.node {\n                 ast::LitStr(ref s, _) => s.get().len(),\n                 _ => {"}, {"sha": "bf35e25635aa2f94f19e262383b3ca1c2059bd23", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -44,7 +44,6 @@ use std::cmp;\n use std::fmt::Show;\n use std::fmt;\n use std::hash::{Hash, sip, Writer};\n-use std::gc::Gc;\n use std::iter::AdditiveIterator;\n use std::mem;\n use std::ops;\n@@ -459,7 +458,7 @@ pub struct ctxt<'tcx> {\n     pub trait_refs: RefCell<NodeMap<Rc<TraitRef>>>,\n     pub trait_defs: RefCell<DefIdMap<Rc<TraitDef>>>,\n \n-    pub map: ast_map::Map,\n+    pub map: ast_map::Map<'tcx>,\n     pub intrinsic_defs: RefCell<DefIdMap<t>>,\n     pub freevars: RefCell<freevars::freevar_map>,\n     pub tcache: type_cache,\n@@ -533,8 +532,8 @@ pub struct ctxt<'tcx> {\n \n     /// These two caches are used by const_eval when decoding external statics\n     /// and variants that are found.\n-    pub extern_const_statics: RefCell<DefIdMap<Option<Gc<ast::Expr>>>>,\n-    pub extern_const_variants: RefCell<DefIdMap<Option<Gc<ast::Expr>>>>,\n+    pub extern_const_statics: RefCell<DefIdMap<ast::NodeId>>,\n+    pub extern_const_variants: RefCell<DefIdMap<ast::NodeId>>,\n \n     pub method_map: typeck::MethodMap,\n     pub vtable_map: typeck::vtable_map,\n@@ -1382,7 +1381,7 @@ pub fn mk_ctxt<'tcx>(s: Session,\n                      type_arena: &'tcx TypedArena<t_box_>,\n                      dm: resolve::DefMap,\n                      named_region_map: resolve_lifetime::NamedRegionMap,\n-                     map: ast_map::Map,\n+                     map: ast_map::Map<'tcx>,\n                      freevars: freevars::freevar_map,\n                      capture_modes: freevars::CaptureModeMap,\n                      region_maps: middle::region::RegionMaps,\n@@ -3619,7 +3618,7 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n             RvalueDpsExpr\n         }\n \n-        ast::ExprLit(lit) if lit_is_str(lit) => {\n+        ast::ExprLit(ref lit) if lit_is_str(&**lit) => {\n             RvalueDpsExpr\n         }\n \n@@ -3668,7 +3667,7 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n             RvalueDatumExpr\n         }\n \n-        ast::ExprBox(place, _) => {\n+        ast::ExprBox(ref place, _) => {\n             // Special case `Box<T>`/`Gc<T>` for now:\n             let definition = match tcx.def_map.borrow().find(&place.id) {\n                 Some(&def) => def,\n@@ -3959,16 +3958,15 @@ pub fn provided_trait_methods(cx: &ctxt, id: ast::DefId) -> Vec<Rc<Method>> {\n             Some(ast_map::NodeItem(item)) => {\n                 match item.node {\n                     ItemTrait(_, _, _, ref ms) => {\n-                        let (_, p) = ast_util::split_trait_methods(ms.as_slice());\n-                        p.iter()\n-                         .map(|m| {\n-                            match impl_or_trait_item(\n-                                    cx,\n-                                    ast_util::local_def(m.id)) {\n-                                MethodTraitItem(m) => m,\n+                        ms.iter().filter_map(|m| match *m {\n+                            ast::RequiredMethod(_) => None,\n+                            ast::ProvidedMethod(ref m) => {\n+                                match impl_or_trait_item(cx,\n+                                        ast_util::local_def(m.id)) {\n+                                    MethodTraitItem(m) => Some(m),\n+                                }\n                             }\n-                         })\n-                         .collect()\n+                         }).collect()\n                     }\n                     _ => {\n                         cx.sess.bug(format!(\"provided_trait_methods: `{}` is \\\n@@ -4289,11 +4287,11 @@ pub fn enum_variants(cx: &ctxt, id: ast::DefId) -> Rc<Vec<Rc<VariantInfo>>> {\n           expr, since check_enum_variants also updates the enum_var_cache\n          */\n         match cx.map.get(id.node) {\n-            ast_map::NodeItem(item) => {\n+            ast_map::NodeItem(ref item) => {\n                 match item.node {\n                     ast::ItemEnum(ref enum_definition, _) => {\n                         let mut last_discriminant: Option<Disr> = None;\n-                        Rc::new(enum_definition.variants.iter().map(|&variant| {\n+                        Rc::new(enum_definition.variants.iter().map(|variant| {\n \n                             let mut discriminant = match last_discriminant {\n                                 Some(val) => val + 1,\n@@ -4324,7 +4322,7 @@ pub fn enum_variants(cx: &ctxt, id: ast::DefId) -> Rc<Vec<Rc<VariantInfo>>> {\n                             };\n \n                             last_discriminant = Some(discriminant);\n-                            Rc::new(VariantInfo::from_ast_variant(cx, &*variant,\n+                            Rc::new(VariantInfo::from_ast_variant(cx, &**variant,\n                                                                   discriminant))\n                         }).collect())\n                     }"}, {"sha": "f2fe7fe6282215b87cdee1e20256bbfccefc0926", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 28, "deletions": 34, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -451,13 +451,10 @@ pub fn ast_ty_to_builtin_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                     for inner_ast_type in path.segments\n                                               .iter()\n                                               .flat_map(|s| s.types.iter()) {\n-                        let mt = ast::MutTy {\n-                            ty: *inner_ast_type,\n-                            mutbl: ast::MutImmutable,\n-                        };\n                         return Some(mk_pointer(this,\n                                                rscope,\n-                                               &mt,\n+                                               ast::MutImmutable,\n+                                               &**inner_ast_type,\n                                                Uniq,\n                                                |typ| ty::mk_uniq(this.tcx(), typ)));\n                     }\n@@ -478,13 +475,10 @@ pub fn ast_ty_to_builtin_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                     for inner_ast_type in path.segments\n                                               .iter()\n                                               .flat_map(|s| s.types.iter()) {\n-                        let mt = ast::MutTy {\n-                            ty: *inner_ast_type,\n-                            mutbl: ast::MutImmutable,\n-                        };\n                         return Some(mk_pointer(this,\n                                                rscope,\n-                                               &mt,\n+                                               ast::MutImmutable,\n+                                               &**inner_ast_type,\n                                                Box,\n                                                |typ| {\n                             match ty::get(typ).sty {\n@@ -578,14 +572,15 @@ pub fn trait_ref_for_unboxed_function<'tcx, AC: AstConv<'tcx>,\n fn mk_pointer<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n         this: &AC,\n         rscope: &RS,\n-        a_seq_ty: &ast::MutTy,\n+        a_seq_mutbl: ast::Mutability,\n+        a_seq_ty: &ast::Ty,\n         ptr_ty: PointerTy,\n         constr: |ty::t| -> ty::t)\n         -> ty::t {\n     let tcx = this.tcx();\n     debug!(\"mk_pointer(ptr_ty={})\", ptr_ty);\n \n-    match a_seq_ty.ty.node {\n+    match a_seq_ty.node {\n         ast::TyVec(ref ty) => {\n             let ty = ast_ty_to_ty(this, rscope, &**ty);\n             return constr(ty::mk_vec(tcx, ty, None));\n@@ -610,11 +605,11 @@ fn mk_pointer<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                 RPtr(r) => {\n                     return ty::mk_rptr(this.tcx(),\n                                        r,\n-                                       ty::mt {mutbl: a_seq_ty.mutbl, ty: tr});\n+                                       ty::mt {mutbl: a_seq_mutbl, ty: tr});\n                 }\n                 _ => {\n                     tcx.sess.span_err(\n-                        a_seq_ty.ty.span,\n+                        a_seq_ty.span,\n                         \"~trait or &trait are the only supported \\\n                          forms of casting-to-trait\");\n                     return ty::mk_err();\n@@ -671,7 +666,7 @@ fn mk_pointer<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                             return ty::mk_uniq(tcx, tr);\n                         }\n                         RPtr(r) => {\n-                            return ty::mk_rptr(tcx, r, ty::mt{mutbl: a_seq_ty.mutbl, ty: tr});\n+                            return ty::mk_rptr(tcx, r, ty::mt{mutbl: a_seq_mutbl, ty: tr});\n                         }\n                         _ => {\n                             tcx.sess.span_err(\n@@ -688,7 +683,7 @@ fn mk_pointer<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n         _ => {}\n     }\n \n-    constr(ast_ty_to_ty(this, rscope, &*a_seq_ty.ty))\n+    constr(ast_ty_to_ty(this, rscope, a_seq_ty))\n }\n \n // Parses the programmer's textual representation of a type into our\n@@ -716,17 +711,16 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n         match ast_ty.node {\n             ast::TyNil => ty::mk_nil(),\n             ast::TyBot => ty::mk_bot(),\n-            ast::TyBox(ty) => {\n-                let mt = ast::MutTy { ty: ty, mutbl: ast::MutImmutable };\n-                mk_pointer(this, rscope, &mt, Box, |ty| ty::mk_box(tcx, ty))\n+            ast::TyBox(ref ty) => {\n+                mk_pointer(this, rscope, ast::MutImmutable, &**ty, Box,\n+                           |ty| ty::mk_box(tcx, ty))\n             }\n-            ast::TyUniq(ty) => {\n-                let mt = ast::MutTy { ty: ty, mutbl: ast::MutImmutable };\n-                mk_pointer(this, rscope, &mt, Uniq,\n+            ast::TyUniq(ref ty) => {\n+                mk_pointer(this, rscope, ast::MutImmutable, &**ty, Uniq,\n                            |ty| ty::mk_uniq(tcx, ty))\n             }\n-            ast::TyVec(ty) => {\n-                ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, &*ty), None)\n+            ast::TyVec(ref ty) => {\n+                ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, &**ty), None)\n             }\n             ast::TyPtr(ref mt) => {\n                 ty::mk_ptr(tcx, ty::mt {\n@@ -737,7 +731,7 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n             ast::TyRptr(ref region, ref mt) => {\n                 let r = opt_ast_region_to_region(this, rscope, ast_ty.span, region);\n                 debug!(\"ty_rptr r={}\", r.repr(this.tcx()));\n-                mk_pointer(this, rscope, mt, RPtr(r),\n+                mk_pointer(this, rscope, mt.mutbl, &*mt.ty, RPtr(r),\n                            |ty| ty::mk_rptr(tcx, r, ty::mt {ty: ty, mutbl: mt.mutbl}))\n             }\n             ast::TyTup(ref fields) => {\n@@ -870,15 +864,15 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                     }\n                 }\n             }\n-            ast::TyFixedLengthVec(ty, e) => {\n-                match const_eval::eval_const_expr_partial(tcx, &*e) {\n+            ast::TyFixedLengthVec(ref ty, ref e) => {\n+                match const_eval::eval_const_expr_partial(tcx, &**e) {\n                     Ok(ref r) => {\n                         match *r {\n                             const_eval::const_int(i) =>\n-                                ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, &*ty),\n+                                ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, &**ty),\n                                            Some(i as uint)),\n                             const_eval::const_uint(i) =>\n-                                ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, &*ty),\n+                                ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, &**ty),\n                                            Some(i as uint)),\n                             _ => {\n                                 tcx.sess.span_fatal(\n@@ -895,7 +889,7 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                     }\n                 }\n             }\n-            ast::TyTypeof(_e) => {\n+            ast::TyTypeof(ref _e) => {\n                 tcx.sess.span_bug(ast_ty.span, \"typeof is reserved but unimplemented\");\n             }\n             ast::TyInfer => {\n@@ -925,15 +919,15 @@ pub fn ty_of_arg<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(this: &AC, rscope: &R\n \n struct SelfInfo<'a> {\n     untransformed_self_ty: ty::t,\n-    explicit_self: ast::ExplicitSelf,\n+    explicit_self: &'a ast::ExplicitSelf,\n }\n \n pub fn ty_of_method<'tcx, AC: AstConv<'tcx>>(\n                     this: &AC,\n                     id: ast::NodeId,\n                     fn_style: ast::FnStyle,\n                     untransformed_self_ty: ty::t,\n-                    explicit_self: ast::ExplicitSelf,\n+                    explicit_self: &ast::ExplicitSelf,\n                     decl: &ast::FnDecl,\n                     abi: abi::Abi)\n                     -> (ty::BareFnTy, ty::ExplicitSelfCategory) {\n@@ -1087,8 +1081,8 @@ fn determine_explicit_self_category<'tcx, AC: AstConv<'tcx>,\n                                          lifetime);\n             ty::ByReferenceExplicitSelfCategory(region, mutability)\n         }\n-        ast::SelfExplicit(ast_type, _) => {\n-            let explicit_type = ast_ty_to_ty(this, rscope, &*ast_type);\n+        ast::SelfExplicit(ref ast_type, _) => {\n+            let explicit_type = ast_ty_to_ty(this, rscope, &**ast_type);\n \n             {\n                 let inference_context = infer::new_infer_ctxt(this.tcx());"}, {"sha": "1602dfeaa280afbcd7317ff7e52ffffb6bfe74b6", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -24,12 +24,12 @@ use middle::typeck::require_same_types;\n use util::ppaux;\n \n use std::collections::{HashMap, HashSet};\n-use std::gc::Gc;\n use syntax::ast;\n use syntax::ast_util;\n use syntax::parse::token;\n use syntax::codemap::Span;\n use syntax::print::pprust;\n+use syntax::ptr::P;\n \n pub fn check_match(fcx: &FnCtxt,\n                    expr: &ast::Expr,\n@@ -66,17 +66,17 @@ pub fn check_match(fcx: &FnCtxt,\n         let mut guard_err = false;\n         let mut guard_bot = false;\n         match arm.guard {\n-          Some(ref e) => {\n-              check_expr_has_type(fcx, &**e, ty::mk_bool());\n-              let e_ty = fcx.expr_ty(&**e);\n-              if ty::type_is_error(e_ty) {\n-                  guard_err = true;\n-              }\n-              else if ty::type_is_bot(e_ty) {\n-                  guard_bot = true;\n-              }\n-          },\n-          None => ()\n+            Some(ref e) => {\n+                check_expr_has_type(fcx, &**e, ty::mk_bool());\n+                let e_ty = fcx.expr_ty(&**e);\n+                if ty::type_is_error(e_ty) {\n+                    guard_err = true;\n+                }\n+                else if ty::type_is_bot(e_ty) {\n+                    guard_bot = true;\n+                }\n+            },\n+            None => ()\n         }\n         check_expr(fcx, &*arm.body);\n         let bty = fcx.node_ty(arm.body.id);\n@@ -113,7 +113,7 @@ pub struct pat_ctxt<'a, 'tcx: 'a> {\n }\n \n pub fn check_pat_variant(pcx: &pat_ctxt, pat: &ast::Pat, path: &ast::Path,\n-                         subpats: &Option<Vec<Gc<ast::Pat>>>, expected: ty::t) {\n+                         subpats: &Option<Vec<P<ast::Pat>>>, expected: ty::t) {\n \n     // Typecheck the path.\n     let fcx = pcx.fcx;\n@@ -457,7 +457,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n         demand::suptype(fcx, pat.span, expected, const_pty.ty);\n         fcx.write_ty(pat.id, const_pty.ty);\n       }\n-      ast::PatIdent(bm, ref path1, sub) if pat_is_binding(&tcx.def_map, pat) => {\n+      ast::PatIdent(bm, ref path1, ref sub) if pat_is_binding(&tcx.def_map, pat) => {\n         let typ = fcx.local_ty(pat.span, pat.id);\n \n         match bm {\n@@ -491,9 +491,9 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n                ppaux::ty_to_string(tcx, expected),\n                pat.id);\n \n-        match sub {\n-          Some(ref p) => check_pat(pcx, &**p, expected),\n-          _ => ()\n+        match *sub {\n+            Some(ref p) => check_pat(pcx, &**p, expected),\n+            _ => ()\n         }\n       }\n       // it's not a binding, it's an enum in disguise:\n@@ -624,14 +624,14 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n       ast::PatRegion(ref inner) => {\n           check_pointer_pat(pcx, Borrowed, &**inner, pat.id, pat.span, expected);\n       }\n-      ast::PatVec(ref before, slice, ref after) => {\n+      ast::PatVec(ref before, ref slice, ref after) => {\n         let default_region_var =\n             fcx.infcx().next_region_var(\n                 infer::PatternRegion(pat.span));\n \n         let check_err = |found: String| {\n-            for &elt in before.iter() {\n-                check_pat(pcx, &*elt, ty::mk_err());\n+            for elt in before.iter() {\n+                check_pat(pcx, &**elt, ty::mk_err());\n             }\n             for elt in slice.iter() {\n                 check_pat(pcx, &**elt, ty::mk_err());\n@@ -690,7 +690,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n         };\n \n         let min_len = before.len() + after.len();\n-        fixed.and_then(|count| match slice {\n+        fixed.and_then(|count| match *slice {\n             Some(_) if count < min_len =>\n                 Some(format!(\"a fixed vector pattern of size at least {}\", min_len)),\n \n@@ -703,7 +703,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n         for elt in before.iter() {\n             check_pat(pcx, &**elt, elt_type);\n         }\n-        match slice {\n+        match *slice {\n             Some(ref slice_pat) => {\n                 let slice_ty = ty::mk_slice(tcx,\n                                             region_var,"}, {"sha": "8ac9f072a0b32bb78a9a92cb1cee3798aa00a4db", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 114, "deletions": 109, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -124,7 +124,7 @@ use std::cell::{Cell, RefCell};\n use std::collections::HashMap;\n use std::mem::replace;\n use std::rc::Rc;\n-use std::gc::Gc;\n+use std::slice;\n use syntax::abi;\n use syntax::ast::{ProvidedMethod, RequiredMethod};\n use syntax::ast;\n@@ -137,6 +137,7 @@ use syntax::codemap;\n use syntax::owned_slice::OwnedSlice;\n use syntax::parse::token;\n use syntax::print::pprust;\n+use syntax::ptr::P;\n use syntax::visit;\n use syntax::visit::Visitor;\n use syntax;\n@@ -401,7 +402,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckItemSizedTypesVisitor<'a, 'tcx> {\n     }\n }\n \n-pub fn check_item_types(ccx: &CrateCtxt, krate: &ast::Crate) {\n+pub fn check_item_types(ccx: &CrateCtxt) {\n+    let krate = ccx.tcx.map.krate();\n+\n     let mut visit = CheckTypeWellFormedVisitor { ccx: ccx };\n     visit::walk_crate(&mut visit, krate);\n \n@@ -624,7 +627,7 @@ fn span_for_field(tcx: &ty::ctxt, field: &ty::field_ty, struct_id: ast::DefId) -\n     };\n \n     match item.node {\n-        ast::ItemStruct(struct_def, _) => {\n+        ast::ItemStruct(ref struct_def, _) => {\n             match struct_def.fields.iter().find(|f| match f.node.kind {\n                 ast::NamedField(ident, _) => ident.name == field.name,\n                 _ => false,\n@@ -818,8 +821,8 @@ pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n         let impl_pty = ty::lookup_item_type(ccx.tcx, ast_util::local_def(it.id));\n         for impl_item in impl_items.iter() {\n             match *impl_item {\n-                ast::MethodImplItem(m) => {\n-                    check_method_body(ccx, &impl_pty.generics, &*m);\n+                ast::MethodImplItem(ref m) => {\n+                    check_method_body(ccx, &impl_pty.generics, &**m);\n                 }\n             }\n         }\n@@ -841,14 +844,14 @@ pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n       }\n       ast::ItemTrait(_, _, _, ref trait_methods) => {\n         let trait_def = ty::lookup_trait_def(ccx.tcx, local_def(it.id));\n-        for trait_method in (*trait_methods).iter() {\n+        for trait_method in trait_methods.iter() {\n             match *trait_method {\n                 RequiredMethod(..) => {\n                     // Nothing to do, since required methods don't have\n                     // bodies to check.\n                 }\n-                ProvidedMethod(m) => {\n-                    check_method_body(ccx, &trait_def.generics, &*m);\n+                ProvidedMethod(ref m) => {\n+                    check_method_body(ccx, &trait_def.generics, &**m);\n                 }\n             }\n         }\n@@ -930,7 +933,7 @@ fn check_impl_items_against_trait(ccx: &CrateCtxt,\n     // and compatible with trait signature\n     for impl_item in impl_items.iter() {\n         match *impl_item {\n-            ast::MethodImplItem(impl_method) => {\n+            ast::MethodImplItem(ref impl_method) => {\n                 let impl_method_def_id = local_def(impl_method.id);\n                 let impl_item_ty = ty::impl_or_trait_item(ccx.tcx,\n                                                           impl_method_def_id);\n@@ -983,7 +986,7 @@ fn check_impl_items_against_trait(ccx: &CrateCtxt,\n                 let is_implemented =\n                     impl_items.iter().any(|ii| {\n                         match *ii {\n-                            ast::MethodImplItem(m) => {\n+                            ast::MethodImplItem(ref m) => {\n                                 m.pe_ident().name == trait_method.ident.name\n                             }\n                         }\n@@ -1968,9 +1971,9 @@ pub fn autoderef<T>(fcx: &FnCtxt, sp: Span, base_ty: ty::t,\n /// Attempts to resolve a call expression as an overloaded call.\n fn try_overloaded_call(fcx: &FnCtxt,\n                        call_expression: &ast::Expr,\n-                       callee: Gc<ast::Expr>,\n+                       callee: &ast::Expr,\n                        callee_type: ty::t,\n-                       args: &[Gc<ast::Expr>])\n+                       args: &[P<ast::Expr>])\n                        -> bool {\n     // Bail out if the callee is a bare function or a closure. We check those\n     // manually.\n@@ -2072,9 +2075,9 @@ fn try_overloaded_deref(fcx: &FnCtxt,\n fn try_overloaded_index(fcx: &FnCtxt,\n                         method_call: Option<MethodCall>,\n                         expr: &ast::Expr,\n-                        base_expr: Gc<ast::Expr>,\n+                        base_expr: &ast::Expr,\n                         base_ty: ty::t,\n-                        index_expr: Gc<ast::Expr>,\n+                        index_expr: &P<ast::Expr>,\n                         lvalue_pref: LvaluePreference)\n                         -> Option<ty::mt> {\n     // Try `IndexMut` first, if preferred.\n@@ -2119,7 +2122,7 @@ fn try_overloaded_index(fcx: &FnCtxt,\n                                 expr.span,\n                                 method_type,\n                                 expr,\n-                                [base_expr, index_expr],\n+                                slice::ref_slice(index_expr),\n                                 DoDerefArgs,\n                                 DontTupleArguments);\n \n@@ -2145,7 +2148,7 @@ fn try_overloaded_index(fcx: &FnCtxt,\n /// The return type of this function represents the concrete element type\n /// `A` in the type `Iterator<A>` that the method returns.\n fn lookup_method_for_for_loop(fcx: &FnCtxt,\n-                              iterator_expr: Gc<ast::Expr>,\n+                              iterator_expr: &ast::Expr,\n                               loop_id: ast::NodeId)\n                               -> ty::t {\n     let trait_did = match fcx.tcx().lang_items.require(IteratorItem) {\n@@ -2188,8 +2191,8 @@ fn lookup_method_for_for_loop(fcx: &FnCtxt,\n     let return_type = check_method_argument_types(fcx,\n                                                   iterator_expr.span,\n                                                   method_type,\n-                                                  &*iterator_expr,\n-                                                  [iterator_expr],\n+                                                  iterator_expr,\n+                                                  &[],\n                                                   DontDerefArgs,\n                                                   DontTupleArguments);\n \n@@ -2224,23 +2227,17 @@ fn check_method_argument_types(fcx: &FnCtxt,\n                                sp: Span,\n                                method_fn_ty: ty::t,\n                                callee_expr: &ast::Expr,\n-                               args: &[Gc<ast::Expr>],\n+                               args_no_rcvr: &[P<ast::Expr>],\n                                deref_args: DerefArgs,\n                                tuple_arguments: TupleArgumentsFlag)\n                                -> ty::t {\n-    // HACK(eddyb) ignore provided self (it has special typeck rules).\n-    let args = if tuple_arguments == DontTupleArguments {\n-        args.slice_from(1)\n-    } else {\n-        args\n-    };\n     if ty::type_is_error(method_fn_ty) {\n-        let err_inputs = err_args(args.len());\n+       let err_inputs = err_args(args_no_rcvr.len());\n         check_argument_types(fcx,\n                              sp,\n                              err_inputs.as_slice(),\n                              callee_expr,\n-                             args,\n+                             args_no_rcvr,\n                              deref_args,\n                              false,\n                              tuple_arguments);\n@@ -2253,7 +2250,7 @@ fn check_method_argument_types(fcx: &FnCtxt,\n                                      sp,\n                                      fty.sig.inputs.slice_from(1),\n                                      callee_expr,\n-                                     args,\n+                                     args_no_rcvr,\n                                      deref_args,\n                                      fty.sig.variadic,\n                                      tuple_arguments);\n@@ -2271,7 +2268,7 @@ fn check_argument_types(fcx: &FnCtxt,\n                         sp: Span,\n                         fn_inputs: &[ty::t],\n                         callee_expr: &ast::Expr,\n-                        args: &[Gc<ast::Expr>],\n+                        args: &[P<ast::Expr>],\n                         deref_args: DerefArgs,\n                         variadic: bool,\n                         tuple_arguments: TupleArgumentsFlag) {\n@@ -2665,7 +2662,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n     fn check_call(fcx: &FnCtxt,\n                   call_expr: &ast::Expr,\n                   f: &ast::Expr,\n-                  args: &[Gc<ast::Expr>]) {\n+                  args: &[P<ast::Expr>]) {\n         // Store the type of `f` as the type of the callee\n         let fn_ty = fcx.expr_ty(f);\n \n@@ -2716,9 +2713,9 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n     fn check_method_call(fcx: &FnCtxt,\n                          expr: &ast::Expr,\n                          method_name: ast::SpannedIdent,\n-                         args: &[Gc<ast::Expr>],\n-                         tps: &[ast::P<ast::Ty>]) {\n-        let rcvr = args[0].clone();\n+                         args: &[P<ast::Expr>],\n+                         tps: &[P<ast::Ty>]) {\n+        let rcvr = &*args[0];\n         // We can't know if we need &mut self before we look up the method,\n         // so treat the receiver as mutable just in case - only explicit\n         // overloaded dereferences care about the distinction.\n@@ -2779,7 +2776,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                                                  method_name.span,\n                                                  fn_ty,\n                                                  expr,\n-                                                 args,\n+                                                 args.slice_from(1),\n                                                  DontDerefArgs,\n                                                  DontTupleArguments);\n \n@@ -2791,7 +2788,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n     fn check_then_else(fcx: &FnCtxt,\n                        cond_expr: &ast::Expr,\n                        then_blk: &ast::Block,\n-                       opt_else_expr: Option<Gc<ast::Expr>>,\n+                       opt_else_expr: Option<&ast::Expr>,\n                        id: ast::NodeId,\n                        sp: Span,\n                        expected: Expectation) {\n@@ -2852,22 +2849,31 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         fcx.write_ty(id, if_ty);\n     }\n \n-    fn lookup_op_method(fcx: &FnCtxt,\n-                        op_ex: &ast::Expr,\n-                        self_t: ty::t,\n-                        opname: ast::Name,\n-                        trait_did: Option<ast::DefId>,\n-                        args: &[Gc<ast::Expr>],\n-                        autoderef_receiver: AutoderefReceiverFlag,\n-                        unbound_method: ||) -> ty::t {\n+    fn lookup_op_method<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n+                                  op_ex: &ast::Expr,\n+                                  lhs_ty: ty::t,\n+                                  opname: ast::Name,\n+                                  trait_did: Option<ast::DefId>,\n+                                  lhs: &'a ast::Expr,\n+                                  rhs: Option<&P<ast::Expr>>,\n+                                  autoderef_receiver: AutoderefReceiverFlag,\n+                                  unbound_method: ||) -> ty::t {\n         let method = match trait_did {\n             Some(trait_did) => {\n-                method::lookup_in_trait(fcx, op_ex.span, Some(&*args[0]), opname,\n-                                        trait_did, self_t, [], autoderef_receiver,\n+                method::lookup_in_trait(fcx, op_ex.span, Some(lhs), opname,\n+                                        trait_did, lhs_ty, &[], autoderef_receiver,\n                                         IgnoreStaticMethods)\n             }\n             None => None\n         };\n+        let args = match rhs {\n+            Some(rhs) => slice::ref_slice(rhs),\n+            None => {\n+                // Work around the lack of coercion.\n+                let empty: &[_] = &[];\n+                empty\n+            }\n+        };\n         match method {\n             Some(method) => {\n                 let method_ty = method.ty;\n@@ -2903,8 +2909,8 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n     fn check_binop(fcx: &FnCtxt,\n                    expr: &ast::Expr,\n                    op: ast::BinOp,\n-                   lhs: Gc<ast::Expr>,\n-                   rhs: Gc<ast::Expr>,\n+                   lhs: &ast::Expr,\n+                   rhs: &P<ast::Expr>,\n                    is_binop_assignment: IsBinopAssignment) {\n         let tcx = fcx.ccx.tcx;\n \n@@ -2920,15 +2926,15 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n \n         if ty::type_is_integral(lhs_t) && ast_util::is_shift_binop(op) {\n             // Shift is a special case: rhs must be uint, no matter what lhs is\n-            check_expr_has_type(fcx, &*rhs, ty::mk_uint());\n+            check_expr_has_type(fcx, &**rhs, ty::mk_uint());\n             fcx.write_ty(expr.id, lhs_t);\n             return;\n         }\n \n         if ty::is_binopable(tcx, lhs_t, op) {\n             let tvar = fcx.infcx().next_ty_var();\n             demand::suptype(fcx, expr.span, tvar, lhs_t);\n-            check_expr_has_type(fcx, &*rhs, tvar);\n+            check_expr_has_type(fcx, &**rhs, tvar);\n \n             let result_t = match op {\n                 ast::BiEq | ast::BiNe | ast::BiLt | ast::BiLe | ast::BiGe |\n@@ -2993,7 +2999,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                                    },\n                                    lhs_t,\n                                    None);\n-            check_expr(fcx, &*rhs);\n+            check_expr(fcx, &**rhs);\n             ty::mk_err()\n         };\n \n@@ -3005,10 +3011,10 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n \n     fn check_user_binop(fcx: &FnCtxt,\n                         ex: &ast::Expr,\n-                        lhs_expr: Gc<ast::Expr>,\n+                        lhs_expr: &ast::Expr,\n                         lhs_resolved_t: ty::t,\n                         op: ast::BinOp,\n-                        rhs: Gc<ast::Expr>) -> ty::t {\n+                        rhs: &P<ast::Expr>) -> ty::t {\n         let tcx = fcx.ccx.tcx;\n         let lang = &tcx.lang_items;\n         let (name, trait_did) = match op {\n@@ -3029,12 +3035,12 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             ast::BiEq => (\"eq\", lang.eq_trait()),\n             ast::BiNe => (\"ne\", lang.eq_trait()),\n             ast::BiAnd | ast::BiOr => {\n-                check_expr(fcx, &*rhs);\n+                check_expr(fcx, &**rhs);\n                 return ty::mk_err();\n             }\n         };\n         lookup_op_method(fcx, ex, lhs_resolved_t, token::intern(name),\n-                         trait_did, [lhs_expr, rhs], DontAutoderefReceiver, || {\n+                         trait_did, lhs_expr, Some(rhs), DontAutoderefReceiver, || {\n             fcx.type_error_message(ex.span, |actual| {\n                 format!(\"binary operation `{}` cannot be applied to type `{}`\",\n                         ast_util::binop_to_string(op),\n@@ -3048,10 +3054,10 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                        mname: &str,\n                        trait_did: Option<ast::DefId>,\n                        ex: &ast::Expr,\n-                       rhs_expr: Gc<ast::Expr>,\n+                       rhs_expr: &ast::Expr,\n                        rhs_t: ty::t) -> ty::t {\n        lookup_op_method(fcx, ex, rhs_t, token::intern(mname),\n-                        trait_did, [rhs_expr], DontAutoderefReceiver, || {\n+                        trait_did, rhs_expr, None, DontAutoderefReceiver, || {\n             fcx.type_error_message(ex.span, |actual| {\n                 format!(\"cannot apply unary operator `{}` to type `{}`\",\n                         op_str, actual)\n@@ -3063,7 +3069,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                              expr: &ast::Expr,\n                              kind: ast::UnboxedClosureKind,\n                              decl: &ast::FnDecl,\n-                             body: ast::P<ast::Block>) {\n+                             body: &ast::Block) {\n         let mut fn_ty = astconv::ty_of_closure(\n             fcx,\n             expr.id,\n@@ -3131,7 +3137,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                      expr: &ast::Expr,\n                      store: ty::TraitStore,\n                      decl: &ast::FnDecl,\n-                     body: ast::P<ast::Block>,\n+                     body: &ast::Block,\n                      expected: Expectation) {\n         let tcx = fcx.ccx.tcx;\n \n@@ -3228,7 +3234,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                    lvalue_pref: LvaluePreference,\n                    base: &ast::Expr,\n                    field: &ast::SpannedIdent,\n-                   tys: &[ast::P<ast::Ty>]) {\n+                   tys: &[P<ast::Ty>]) {\n         let tcx = fcx.ccx.tcx;\n         check_expr_with_lvalue_pref(fcx, base, lvalue_pref);\n         let expr_t = structurally_resolved_type(fcx, expr.span,\n@@ -3302,7 +3308,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                        lvalue_pref: LvaluePreference,\n                        base: &ast::Expr,\n                        idx: codemap::Spanned<uint>,\n-                       _tys: &[ast::P<ast::Ty>]) {\n+                       _tys: &[P<ast::Ty>]) {\n         let tcx = fcx.ccx.tcx;\n         check_expr_with_lvalue_pref(fcx, base, lvalue_pref);\n         let expr_t = structurally_resolved_type(fcx, expr.span,\n@@ -3453,7 +3459,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                                 span: codemap::Span,\n                                 class_id: ast::DefId,\n                                 fields: &[ast::Field],\n-                                base_expr: Option<Gc<ast::Expr>>) {\n+                                base_expr: Option<&ast::Expr>) {\n         let tcx = fcx.ccx.tcx;\n \n         // Look up the number of type parameters and the raw type, and\n@@ -3527,14 +3533,14 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n     fn check_struct_fields_on_error(fcx: &FnCtxt,\n                                     id: ast::NodeId,\n                                     fields: &[ast::Field],\n-                                    base_expr: Option<Gc<ast::Expr>>) {\n+                                    base_expr: &Option<P<ast::Expr>>) {\n         // Make sure to still write the types\n         // otherwise we might ICE\n         fcx.write_error(id);\n         for field in fields.iter() {\n             check_expr(fcx, &*field.expr);\n         }\n-        match base_expr {\n+        match *base_expr {\n             Some(ref base) => check_expr(fcx, &**base),\n             None => {}\n         }\n@@ -3578,12 +3584,12 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n           }\n       }\n \n-      ast::ExprLit(lit) => {\n-        let typ = check_lit(fcx, &*lit, expected);\n+      ast::ExprLit(ref lit) => {\n+        let typ = check_lit(fcx, &**lit, expected);\n         fcx.write_ty(id, typ);\n       }\n       ast::ExprBinary(op, ref lhs, ref rhs) => {\n-        check_binop(fcx, expr, op, lhs.clone(), rhs.clone(), SimpleBinop);\n+        check_binop(fcx, expr, op, &**lhs, rhs, SimpleBinop);\n \n         let lhs_ty = fcx.expr_ty(&**lhs);\n         let rhs_ty = fcx.expr_ty(&**rhs);\n@@ -3597,7 +3603,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         }\n       }\n       ast::ExprAssignOp(op, ref lhs, ref rhs) => {\n-        check_binop(fcx, expr, op, lhs.clone(), rhs.clone(), BinopAssignment);\n+        check_binop(fcx, expr, op, &**lhs, rhs, BinopAssignment);\n \n         let lhs_t = fcx.expr_ty(&**lhs);\n         let result_t = fcx.expr_ty(expr);\n@@ -3691,7 +3697,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                          ty::get(oprnd_t).sty == ty::ty_bool) {\n                         oprnd_t = check_user_unop(fcx, \"!\", \"not\",\n                                                   tcx.lang_items.not_trait(),\n-                                                  expr, oprnd.clone(), oprnd_t);\n+                                                  expr, &**oprnd, oprnd_t);\n                     }\n                 }\n                 ast::UnNeg => {\n@@ -3701,7 +3707,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                          ty::type_is_fp(oprnd_t)) {\n                         oprnd_t = check_user_unop(fcx, \"-\", \"neg\",\n                                                   tcx.lang_items.neg_trait(),\n-                                                  expr, oprnd.clone(), oprnd_t);\n+                                                  expr, &**oprnd, oprnd_t);\n                     }\n                 }\n             }\n@@ -3802,12 +3808,12 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         }\n         fcx.write_bot(id);\n       }\n-      ast::ExprParen(a) => {\n+      ast::ExprParen(ref a) => {\n         check_expr_with_expectation_and_lvalue_pref(fcx,\n-                                                    &*a,\n+                                                    &**a,\n                                                     expected,\n                                                     lvalue_pref);\n-        fcx.write_ty(id, fcx.expr_ty(&*a));\n+        fcx.write_ty(id, fcx.expr_ty(&**a));\n       }\n       ast::ExprAssign(ref lhs, ref rhs) => {\n         check_expr_with_lvalue_pref(fcx, &**lhs, PreferMutLvalue);\n@@ -3831,7 +3837,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         }\n       }\n       ast::ExprIf(ref cond, ref then_blk, ref opt_else_expr) => {\n-        check_then_else(fcx, &**cond, &**then_blk, opt_else_expr.clone(),\n+        check_then_else(fcx, &**cond, &**then_blk, opt_else_expr.as_ref().map(|e| &**e),\n                         id, expr.span, expected);\n       }\n       ast::ExprWhile(ref cond, ref body, _) => {\n@@ -3851,7 +3857,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n       }\n       ast::ExprForLoop(ref pat, ref head, ref block, _) => {\n         check_expr(fcx, &**head);\n-        let typ = lookup_method_for_for_loop(fcx, *head, expr.id);\n+        let typ = lookup_method_for_for_loop(fcx, &**head, expr.id);\n         vtable::early_resolve_expr(expr, fcx, true);\n \n         let pcx = pat_ctxt {\n@@ -3865,10 +3871,9 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n       }\n       ast::ExprLoop(ref body, _) => {\n         check_block_no_value(fcx, &**body);\n-        if !may_break(tcx, expr.id, body.clone()) {\n+        if !may_break(tcx, expr.id, &**body) {\n             fcx.write_bot(id);\n-        }\n-        else {\n+        } else {\n             fcx.write_nil(id);\n         }\n       }\n@@ -3884,22 +3889,22 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                       expr,\n                       ty::RegionTraitStore(region, ast::MutMutable),\n                       &**decl,\n-                      body.clone(),\n+                      &**body,\n                       expected);\n       }\n       ast::ExprUnboxedFn(_, kind, ref decl, ref body) => {\n         check_unboxed_closure(fcx,\n                               expr,\n                               kind,\n                               &**decl,\n-                              *body);\n+                              &**body);\n       }\n       ast::ExprProc(ref decl, ref body) => {\n         check_expr_fn(fcx,\n                       expr,\n                       ty::UniqTraitStore,\n                       &**decl,\n-                      body.clone(),\n+                      &**body,\n                       expected);\n       }\n       ast::ExprBlock(ref b) => {\n@@ -3912,7 +3917,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n           check_expr(fcx, &**f);\n           let f_ty = fcx.expr_ty(&**f);\n \n-          if !try_overloaded_call(fcx, expr, f.clone(), f_ty, args.as_slice()) {\n+          if !try_overloaded_call(fcx, expr, &**f, f_ty, args.as_slice()) {\n               check_call(fcx, expr, &**f, args.as_slice());\n               let (args_bot, args_err) = args.iter().fold((false, false),\n                  |(rest_bot, rest_err), a| {\n@@ -4050,7 +4055,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             fcx.write_ty(id, typ);\n         }\n       }\n-      ast::ExprStruct(ref path, ref fields, base_expr) => {\n+      ast::ExprStruct(ref path, ref fields, ref base_expr) => {\n         // Resolve the path.\n         let def = tcx.def_map.borrow().find(&id).map(|i| *i);\n         let struct_id = match def {\n@@ -4079,7 +4084,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                                                  expr.span,\n                                                  struct_did,\n                                                  fields.as_slice(),\n-                                                 base_expr);\n+                                                 base_expr.as_ref().map(|e| &**e));\n                     }\n                     _ => {\n                         span_err!(tcx.sess, path.span, E0071,\n@@ -4168,9 +4173,9 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                       match try_overloaded_index(fcx,\n                                                  Some(method_call),\n                                                  expr,\n-                                                 *base,\n+                                                 &**base,\n                                                  base_t,\n-                                                 *idx,\n+                                                 idx,\n                                                  lvalue_pref) {\n                           Some(mt) => fcx.write_ty(id, mt.ty),\n                           None => {\n@@ -4331,7 +4336,7 @@ pub fn check_stmt(fcx: &FnCtxt, stmt: &ast::Stmt)  {\n     let mut saw_bot = false;\n     let mut saw_err = false;\n     match stmt.node {\n-      ast::StmtDecl(decl, id) => {\n+      ast::StmtDecl(ref decl, id) => {\n         node_id = id;\n         match decl.node {\n           ast::DeclLocal(ref l) => {\n@@ -4404,7 +4409,7 @@ fn check_block_with_expected(fcx: &FnCtxt,\n         let s_id = ast_util::stmt_id(&**s);\n         let s_ty = fcx.node_ty(s_id);\n         if last_was_bot && !warned && match s.node {\n-            ast::StmtDecl(decl, _) => {\n+            ast::StmtDecl(ref decl, _) => {\n                 match decl.node {\n                     ast::DeclLocal(_) => true,\n                     _ => false,\n@@ -4431,14 +4436,12 @@ fn check_block_with_expected(fcx: &FnCtxt,\n     match blk.expr {\n         None => if any_err {\n             fcx.write_error(blk.id);\n-        }\n-        else if any_bot {\n+        } else if any_bot {\n             fcx.write_bot(blk.id);\n-        }\n-        else  {\n+        } else {\n             fcx.write_nil(blk.id);\n         },\n-        Some(e) => {\n+        Some(ref e) => {\n             if any_bot && !warned {\n                 fcx.ccx\n                     .tcx\n@@ -4450,12 +4453,12 @@ fn check_block_with_expected(fcx: &FnCtxt,\n             }\n             let ety = match expected {\n                 ExpectHasType(ety) => {\n-                    check_expr_coercable_to_type(fcx, &*e, ety);\n+                    check_expr_coercable_to_type(fcx, &**e, ety);\n                     ety\n                 }\n                 _ => {\n-                    check_expr_with_expectation(fcx, &*e, expected);\n-                    fcx.expr_ty(&*e)\n+                    check_expr_with_expectation(fcx, &**e, expected);\n+                    fcx.expr_ty(&**e)\n                 }\n             };\n \n@@ -4603,8 +4606,8 @@ pub fn check_simd(tcx: &ty::ctxt, sp: Span, id: ast::NodeId) {\n \n \n pub fn check_enum_variants_sized(ccx: &CrateCtxt,\n-                                 vs: &[ast::P<ast::Variant>]) {\n-    for &v in vs.iter() {\n+                                 vs: &[P<ast::Variant>]) {\n+    for v in vs.iter() {\n         match v.node.kind {\n             ast::TupleVariantKind(ref args) if args.len() > 0 => {\n                 let ctor_ty = ty::node_id_to_type(ccx.tcx, v.node.id);\n@@ -4626,15 +4629,17 @@ pub fn check_enum_variants_sized(ccx: &CrateCtxt,\n                     }\n                 }\n             },\n-            ast::StructVariantKind(struct_def) => check_fields_sized(ccx.tcx, &*struct_def),\n+            ast::StructVariantKind(ref struct_def) => {\n+                check_fields_sized(ccx.tcx, &**struct_def)\n+            }\n             _ => {}\n         }\n     }\n }\n \n pub fn check_enum_variants(ccx: &CrateCtxt,\n                            sp: Span,\n-                           vs: &[ast::P<ast::Variant>],\n+                           vs: &[P<ast::Variant>],\n                            id: ast::NodeId) {\n \n     fn disr_in_range(ccx: &CrateCtxt,\n@@ -4665,7 +4670,7 @@ pub fn check_enum_variants(ccx: &CrateCtxt,\n     }\n \n     fn do_check(ccx: &CrateCtxt,\n-                vs: &[ast::P<ast::Variant>],\n+                vs: &[P<ast::Variant>],\n                 id: ast::NodeId,\n                 hint: attr::ReprAttr)\n                 -> Vec<Rc<ty::VariantInfo>> {\n@@ -4675,7 +4680,7 @@ pub fn check_enum_variants(ccx: &CrateCtxt,\n         let mut disr_vals: Vec<ty::Disr> = Vec::new();\n         let mut prev_disr_val: Option<ty::Disr> = None;\n \n-        for &v in vs.iter() {\n+        for v in vs.iter() {\n \n             // If the discriminant value is specified explicitly in the enum check whether the\n             // initialization expression is valid, otherwise use the last value plus one.\n@@ -4685,8 +4690,8 @@ pub fn check_enum_variants(ccx: &CrateCtxt,\n             };\n \n             match v.node.disr_expr {\n-                Some(e) => {\n-                    debug!(\"disr expr, checking {}\", pprust::expr_to_string(&*e));\n+                Some(ref e) => {\n+                    debug!(\"disr expr, checking {}\", pprust::expr_to_string(&**e));\n \n                     let inh = static_inherited_fields(ccx);\n                     let fcx = blank_fn_ctxt(ccx, &inh, rty, e.id);\n@@ -4699,12 +4704,12 @@ pub fn check_enum_variants(ccx: &CrateCtxt,\n                             ty::mk_mach_uint(ity)\n                         },\n                     };\n-                    check_const_with_ty(&fcx, e.span, &*e, declty);\n+                    check_const_with_ty(&fcx, e.span, &**e, declty);\n                     // check_expr (from check_const pass) doesn't guarantee\n                     // that the expression is in a form that eval_const_expr can\n                     // handle, so we may still get an internal compiler error\n \n-                    match const_eval::eval_const_expr_partial(ccx.tcx, &*e) {\n+                    match const_eval::eval_const_expr_partial(ccx.tcx, &**e) {\n                         Ok(const_eval::const_int(val)) => current_disr_val = val as Disr,\n                         Ok(const_eval::const_uint(val)) => current_disr_val = val as Disr,\n                         Ok(_) => {\n@@ -4742,7 +4747,7 @@ pub fn check_enum_variants(ccx: &CrateCtxt,\n             }\n             disr_vals.push(current_disr_val);\n \n-            let variant_info = Rc::new(VariantInfo::from_ast_variant(ccx.tcx, &*v,\n+            let variant_info = Rc::new(VariantInfo::from_ast_variant(ccx.tcx, &**v,\n                                                                      current_disr_val));\n             prev_disr_val = Some(current_disr_val);\n \n@@ -5051,8 +5056,8 @@ pub fn instantiate_path(fcx: &FnCtxt,\n         {\n             let type_count = type_defs.len(space);\n             assert_eq!(substs.types.len(space), 0);\n-            for (i, &typ) in segment.types.iter().enumerate() {\n-                let t = fcx.to_ty(&*typ);\n+            for (i, typ) in segment.types.iter().enumerate() {\n+                let t = fcx.to_ty(&**typ);\n                 if i < type_count {\n                     substs.types.push(space, t);\n                 } else if i == type_count {\n@@ -5256,7 +5261,7 @@ pub fn type_is_c_like_enum(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n }\n \n // Returns true if b contains a break that can exit from b\n-pub fn may_break(cx: &ty::ctxt, id: ast::NodeId, b: ast::P<ast::Block>) -> bool {\n+pub fn may_break(cx: &ty::ctxt, id: ast::NodeId, b: &ast::Block) -> bool {\n     // First: is there an unlabeled break immediately\n     // inside the loop?\n     (loop_query(&*b, |e| {"}, {"sha": "95b7e03e6d9aa99464724be57ab48f9f0863d4c6", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 23, "deletions": 27, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -141,7 +141,6 @@ use syntax::visit;\n use syntax::visit::Visitor;\n \n use std::cell::RefCell;\n-use std::gc::Gc;\n \n ///////////////////////////////////////////////////////////////////////////\n // PUBLIC ENTRY POINTS\n@@ -614,23 +613,20 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n     match expr.node {\n         ast::ExprCall(ref callee, ref args) => {\n             if has_method_map {\n-                constrain_call(rcx, expr, Some(*callee),\n-                               args.as_slice(), false);\n+                constrain_call(rcx, expr, Some(&**callee),\n+                               args.iter().map(|e| &**e), false);\n             } else {\n                 constrain_callee(rcx, callee.id, expr, &**callee);\n-                constrain_call(rcx,\n-                               expr,\n-                               None,\n-                               args.as_slice(),\n-                               false);\n+                constrain_call(rcx, expr, None,\n+                               args.iter().map(|e| &**e), false);\n             }\n \n             visit::walk_expr(rcx, expr);\n         }\n \n         ast::ExprMethodCall(_, _, ref args) => {\n-            constrain_call(rcx, expr, Some(*args.get(0)),\n-                           args.slice_from(1), false);\n+            constrain_call(rcx, expr, Some(&**args.get(0)),\n+                           args.slice_from(1).iter().map(|e| &**e), false);\n \n             visit::walk_expr(rcx, expr);\n         }\n@@ -642,8 +638,8 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n \n         ast::ExprAssignOp(_, ref lhs, ref rhs) => {\n             if has_method_map {\n-                constrain_call(rcx, expr, Some(lhs.clone()),\n-                               [rhs.clone()], true);\n+                constrain_call(rcx, expr, Some(&**lhs),\n+                               Some(&**rhs).move_iter(), true);\n             }\n \n             adjust_borrow_kind_for_assignment_lhs(rcx, &**lhs);\n@@ -657,15 +653,16 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n             // overloaded op.  Note that we (sadly) currently use an\n             // implicit \"by ref\" sort of passing style here.  This\n             // should be converted to an adjustment!\n-            constrain_call(rcx, expr, Some(lhs.clone()),\n-                           [rhs.clone()], true);\n+            constrain_call(rcx, expr, Some(&**lhs),\n+                           Some(&**rhs).move_iter(), true);\n \n             visit::walk_expr(rcx, expr);\n         }\n \n         ast::ExprUnary(_, ref lhs) if has_method_map => {\n             // As above.\n-            constrain_call(rcx, expr, Some(lhs.clone()), [], true);\n+            constrain_call(rcx, expr, Some(&**lhs),\n+                           None::<ast::Expr>.iter(), true);\n \n             visit::walk_expr(rcx, expr);\n         }\n@@ -683,7 +680,8 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n             let method_call = MethodCall::expr(expr.id);\n             let base_ty = match rcx.fcx.inh.method_map.borrow().find(&method_call) {\n                 Some(method) => {\n-                    constrain_call(rcx, expr, Some(base.clone()), [], true);\n+                    constrain_call(rcx, expr, Some(&**base),\n+                                   None::<ast::Expr>.iter(), true);\n                     ty::ty_fn_ret(method.ty)\n                 }\n                 None => rcx.resolve_node_type(base.id)\n@@ -1080,11 +1078,11 @@ fn constrain_callee(rcx: &mut Rcx,\n     }\n }\n \n-fn constrain_call(rcx: &mut Rcx,\n-                  call_expr: &ast::Expr,\n-                  receiver: Option<Gc<ast::Expr>>,\n-                  arg_exprs: &[Gc<ast::Expr>],\n-                  implicitly_ref_args: bool) {\n+fn constrain_call<'a, I: Iterator<&'a ast::Expr>>(rcx: &mut Rcx,\n+                                                  call_expr: &ast::Expr,\n+                                                  receiver: Option<&ast::Expr>,\n+                                                  mut arg_exprs: I,\n+                                                  implicitly_ref_args: bool) {\n     //! Invoked on every call site (i.e., normal calls, method calls,\n     //! and overloaded operators). Constrains the regions which appear\n     //! in the type of the function. Also constrains the regions that\n@@ -1093,11 +1091,9 @@ fn constrain_call(rcx: &mut Rcx,\n     let tcx = rcx.fcx.tcx();\n     debug!(\"constrain_call(call_expr={}, \\\n             receiver={}, \\\n-            arg_exprs={}, \\\n             implicitly_ref_args={:?})\",\n             call_expr.repr(tcx),\n             receiver.repr(tcx),\n-            arg_exprs.repr(tcx),\n             implicitly_ref_args);\n \n     // `callee_region` is the scope representing the time in which the\n@@ -1109,7 +1105,7 @@ fn constrain_call(rcx: &mut Rcx,\n \n     debug!(\"callee_region={}\", callee_region.repr(tcx));\n \n-    for arg_expr in arg_exprs.iter() {\n+    for arg_expr in arg_exprs {\n         debug!(\"Argument: {}\", arg_expr.repr(tcx));\n \n         // ensure that any regions appearing in the argument type are\n@@ -1123,7 +1119,7 @@ fn constrain_call(rcx: &mut Rcx,\n         // result. modes are going away and the \"DerefArgs\" code\n         // should be ported to use adjustments\n         if implicitly_ref_args {\n-            link_by_ref(rcx, &**arg_expr, callee_scope);\n+            link_by_ref(rcx, arg_expr, callee_scope);\n         }\n     }\n \n@@ -1292,10 +1288,10 @@ fn link_local(rcx: &Rcx, local: &ast::Local) {\n     debug!(\"regionck::for_local()\");\n     let init_expr = match local.init {\n         None => { return; }\n-        Some(ref expr) => expr,\n+        Some(ref expr) => &**expr,\n     };\n     let mc = mc::MemCategorizationContext::new(rcx);\n-    let discr_cmt = ignore_err!(mc.cat_expr(&**init_expr));\n+    let discr_cmt = ignore_err!(mc.cat_expr(init_expr));\n     link_pattern(rcx, mc, discr_cmt, &*local.pat);\n }\n "}, {"sha": "8de17627e28253be2921a28607c2b3fbeb40cfbc", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -597,7 +597,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                         ast_items.iter()\n                                  .map(|ast_item| {\n                             match *ast_item {\n-                                ast::MethodImplItem(ast_method) => {\n+                                ast::MethodImplItem(ref ast_method) => {\n                                     MethodTraitItemId(\n                                         local_def(ast_method.id))\n                                 }\n@@ -820,9 +820,9 @@ fn subst_receiver_types_in_method_ty(tcx: &ty::ctxt,\n     )\n }\n \n-pub fn check_coherence(crate_context: &CrateCtxt, krate: &Crate) {\n+pub fn check_coherence(crate_context: &CrateCtxt) {\n     CoherenceChecker {\n         crate_context: crate_context,\n         inference_context: new_infer_ctxt(crate_context.tcx),\n-    }.check(krate);\n+    }.check(crate_context.tcx.map.krate());\n }"}, {"sha": "581bd8acbc97ea7053908fbc0e6c415dd5be9f38", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -53,22 +53,22 @@ use util::ppaux::{Repr,UserString};\n \n use std::collections::{HashMap, HashSet};\n use std::rc::Rc;\n-use std::gc::Gc;\n \n use syntax::abi;\n use syntax::ast;\n use syntax::ast_map;\n-use syntax::ast_util::{local_def, split_trait_methods, PostExpansionMethod};\n+use syntax::ast_util::{local_def, PostExpansionMethod};\n use syntax::codemap::Span;\n use syntax::parse::token::{special_idents};\n use syntax::parse::token;\n use syntax::print::pprust::{path_to_string};\n+use syntax::ptr::P;\n use syntax::visit;\n \n ///////////////////////////////////////////////////////////////////////////\n // Main entry point\n \n-pub fn collect_item_types(ccx: &CrateCtxt, krate: &ast::Crate) {\n+pub fn collect_item_types(ccx: &CrateCtxt) {\n     fn collect_intrinsic_type(ccx: &CrateCtxt,\n                               lang_item: ast::DefId) {\n         let ty::Polytype { ty: ty, .. } =\n@@ -84,10 +84,10 @@ pub fn collect_item_types(ccx: &CrateCtxt, krate: &ast::Crate) {\n     }\n \n     let mut visitor = CollectTraitDefVisitor{ ccx: ccx };\n-    visit::walk_crate(&mut visitor, krate);\n+    visit::walk_crate(&mut visitor, ccx.tcx.map.krate());\n \n     let mut visitor = CollectItemTypesVisitor{ ccx: ccx };\n-    visit::walk_crate(&mut visitor, krate);\n+    visit::walk_crate(&mut visitor, ccx.tcx.map.krate());\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -179,7 +179,7 @@ impl<'a, 'tcx> AstConv<'tcx> for CrateCtxt<'a, 'tcx> {\n \n pub fn get_enum_variant_types(ccx: &CrateCtxt,\n                               enum_ty: ty::t,\n-                              variants: &[ast::P<ast::Variant>],\n+                              variants: &[P<ast::Variant>],\n                               generics: &ast::Generics) {\n     let tcx = ccx.tcx;\n \n@@ -199,13 +199,13 @@ pub fn get_enum_variant_types(ccx: &CrateCtxt,\n                 enum_ty\n             }\n \n-            ast::StructVariantKind(struct_def) => {\n+            ast::StructVariantKind(ref struct_def) => {\n                 let pty = Polytype {\n                     generics: ty_generics_for_type(ccx, generics),\n                     ty: enum_ty\n                 };\n \n-                convert_struct(ccx, &*struct_def, pty, variant.node.id);\n+                convert_struct(ccx, &**struct_def, pty, variant.node.id);\n \n                 let input_tys: Vec<_> = struct_def.fields.iter().map(\n                     |f| ty::node_id_to_type(ccx.tcx, f.node.id)).collect();\n@@ -332,7 +332,7 @@ fn collect_trait_methods(ccx: &CrateCtxt,\n                                   *m_id,\n                                   *m_fn_style,\n                                   trait_self_ty,\n-                                  *m_explicit_self,\n+                                  m_explicit_self,\n                                   m_decl,\n                                   m_abi);\n         let ty_generics =\n@@ -386,28 +386,27 @@ pub fn convert_field(ccx: &CrateCtxt,\n     }\n }\n \n-fn convert_methods(ccx: &CrateCtxt,\n-                   container: ImplOrTraitItemContainer,\n-                   ms: &[Gc<ast::Method>],\n-                   untransformed_rcvr_ty: ty::t,\n-                   rcvr_ty_generics: &ty::Generics,\n-                   rcvr_visibility: ast::Visibility)\n-{\n+fn convert_methods<'a, I: Iterator<&'a ast::Method>>(ccx: &CrateCtxt,\n+        container: ImplOrTraitItemContainer,\n+        mut ms: I,\n+        untransformed_rcvr_ty: ty::t,\n+        rcvr_ty_generics: &ty::Generics,\n+        rcvr_visibility: ast::Visibility) {\n     debug!(\"convert_methods(untransformed_rcvr_ty={}, \\\n             rcvr_ty_generics={})\",\n            untransformed_rcvr_ty.repr(ccx.tcx),\n            rcvr_ty_generics.repr(ccx.tcx));\n \n     let tcx = ccx.tcx;\n     let mut seen_methods = HashSet::new();\n-    for m in ms.iter() {\n+    for m in ms {\n         if !seen_methods.insert(m.pe_ident().repr(ccx.tcx)) {\n             tcx.sess.span_err(m.span, \"duplicate method in trait impl\");\n         }\n \n         let mty = Rc::new(ty_of_method(ccx,\n                                        container,\n-                                       &**m,\n+                                       m,\n                                        untransformed_rcvr_ty,\n                                        rcvr_ty_generics,\n                                        rcvr_visibility));\n@@ -459,7 +458,7 @@ fn convert_methods(ccx: &CrateCtxt,\n                                   m.id,\n                                   m.pe_fn_style(),\n                                   untransformed_rcvr_ty,\n-                                  *m.pe_explicit_self(),\n+                                  m.pe_explicit_self(),\n                                   &*m.pe_fn_decl(),\n                                   real_abi);\n \n@@ -524,10 +523,10 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n         },\n         ast::ItemImpl(ref generics,\n                       ref opt_trait_ref,\n-                      selfty,\n+                      ref selfty,\n                       ref impl_items) => {\n             let ty_generics = ty_generics_for_type(ccx, generics);\n-            let selfty = ccx.to_ty(&ExplicitRscope, &*selfty);\n+            let selfty = ccx.to_ty(&ExplicitRscope, &**selfty);\n             write_ty_to_tcx(tcx, it.id, selfty);\n \n             tcx.tcache.borrow_mut().insert(local_def(it.id),\n@@ -554,14 +553,14 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n                                                &BindingRscope::new(method.id),\n                                                selfty,\n                                                method.pe_explicit_self());\n-                        methods.push(*method);\n+                        methods.push(&**method);\n                     }\n                 }\n             }\n \n             convert_methods(ccx,\n                             ImplContainer(local_def(it.id)),\n-                            methods.as_slice(),\n+                            methods.move_iter(),\n                             selfty,\n                             &ty_generics,\n                             parent_visibility);\n@@ -600,12 +599,13 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n             }\n \n             // Run convert_methods on the provided methods.\n-            let (_, provided_methods) =\n-                split_trait_methods(trait_methods.as_slice());\n             let untransformed_rcvr_ty = ty::mk_self_type(tcx, local_def(it.id));\n             convert_methods(ccx,\n                             TraitContainer(local_def(it.id)),\n-                            provided_methods.as_slice(),\n+                            trait_methods.iter().filter_map(|m| match *m {\n+                                ast::RequiredMethod(_) => None,\n+                                ast::ProvidedMethod(ref m) => Some(&**m)\n+                            }),\n                             untransformed_rcvr_ty,\n                             &trait_def.generics,\n                             it.vis);\n@@ -615,7 +615,7 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n             // static trait methods. This is somewhat unfortunate.\n             collect_trait_methods(ccx, it.id, &*trait_def);\n         },\n-        ast::ItemStruct(struct_def, _) => {\n+        ast::ItemStruct(ref struct_def, _) => {\n             // Write the class type.\n             let pty = ty_of_item(ccx, it);\n             write_ty_to_tcx(tcx, it.id, pty.ty);\n@@ -624,14 +624,14 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n \n             // Write the super-struct type, if it exists.\n             match struct_def.super_struct {\n-                Some(ty) => {\n-                    let supserty = ccx.to_ty(&ExplicitRscope, &*ty);\n+                Some(ref ty) => {\n+                    let supserty = ccx.to_ty(&ExplicitRscope, &**ty);\n                     write_ty_to_tcx(tcx, it.id, supserty);\n                 },\n                 _ => {},\n             }\n \n-            convert_struct(ccx, &*struct_def, pty, it.id);\n+            convert_struct(ccx, &**struct_def, pty, it.id);\n         },\n         ast::ItemTy(_, ref generics) => {\n             ensure_no_ty_param_bounds(ccx, it.span, generics, \"type\");\n@@ -683,7 +683,7 @@ pub fn convert_struct(ccx: &CrateCtxt,\n     tcx.struct_fields.borrow_mut().insert(local_def(id), Rc::new(field_tys));\n \n     let super_struct = match struct_def.super_struct {\n-        Some(t) => match t.node {\n+        Some(ref t) => match t.node {\n             ast::TyPath(_, _, path_id) => {\n                 let def_map = tcx.def_map.borrow();\n                 match def_map.find(&path_id) {\n@@ -692,7 +692,7 @@ pub fn convert_struct(ccx: &CrateCtxt,\n                         // Check super-struct is virtual.\n                         match tcx.map.find(def_id.node) {\n                             Some(ast_map::NodeItem(i)) => match i.node {\n-                                ast::ItemStruct(struct_def, _) => {\n+                                ast::ItemStruct(ref struct_def, _) => {\n                                     if !struct_def.is_virtual {\n                                         span_err!(tcx.sess, t.span, E0126,\n                                                   \"struct inheritance is only \\\n@@ -908,21 +908,21 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::Item)\n         _ => {}\n     }\n     match it.node {\n-        ast::ItemStatic(t, _, _) => {\n-            let typ = ccx.to_ty(&ExplicitRscope, &*t);\n+        ast::ItemStatic(ref t, _, _) => {\n+            let typ = ccx.to_ty(&ExplicitRscope, &**t);\n             let pty = no_params(typ);\n \n             tcx.tcache.borrow_mut().insert(local_def(it.id), pty.clone());\n             return pty;\n         }\n-        ast::ItemFn(decl, fn_style, abi, ref generics, _) => {\n+        ast::ItemFn(ref decl, fn_style, abi, ref generics, _) => {\n             let ty_generics = ty_generics_for_fn_or_method(ccx, generics,\n                                                            ty::Generics::empty());\n             let tofd = astconv::ty_of_bare_fn(ccx,\n                                               it.id,\n                                               fn_style,\n                                               abi,\n-                                              &*decl);\n+                                              &**decl);\n             let pty = Polytype {\n                 generics: ty_generics,\n                 ty: ty::mk_bare_fn(ccx.tcx, tofd)\n@@ -935,14 +935,14 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::Item)\n             ccx.tcx.tcache.borrow_mut().insert(local_def(it.id), pty.clone());\n             return pty;\n         }\n-        ast::ItemTy(t, ref generics) => {\n+        ast::ItemTy(ref t, ref generics) => {\n             match tcx.tcache.borrow_mut().find(&local_def(it.id)) {\n                 Some(pty) => return pty.clone(),\n                 None => { }\n             }\n \n             let pty = {\n-                let ty = ccx.to_ty(&ExplicitRscope, &*t);\n+                let ty = ccx.to_ty(&ExplicitRscope, &**t);\n                 Polytype {\n                     generics: ty_generics_for_type(ccx, generics),\n                     ty: ty\n@@ -990,17 +990,17 @@ pub fn ty_of_foreign_item(ccx: &CrateCtxt,\n                           abi: abi::Abi) -> ty::Polytype\n {\n     match it.node {\n-        ast::ForeignItemFn(fn_decl, ref generics) => {\n+        ast::ForeignItemFn(ref fn_decl, ref generics) => {\n             ty_of_foreign_fn_decl(ccx,\n-                                  &*fn_decl,\n+                                  &**fn_decl,\n                                   local_def(it.id),\n                                   generics,\n                                   abi)\n         }\n-        ast::ForeignItemStatic(t, _) => {\n+        ast::ForeignItemStatic(ref t, _) => {\n             ty::Polytype {\n                 generics: ty::Generics::empty(),\n-                ty: ast_ty_to_ty(ccx, &ExplicitRscope, &*t)\n+                ty: ast_ty_to_ty(ccx, &ExplicitRscope, &**t)\n             }\n         }\n     }\n@@ -1163,8 +1163,8 @@ fn ty_generics(ccx: &CrateCtxt,\n                                     &param.unbound,\n                                     param.span,\n                                     where_clause);\n-        let default = param.default.map(|path| {\n-            let ty = ast_ty_to_ty(ccx, &ExplicitRscope, &*path);\n+            let default = param.default.as_ref().map(|path| {\n+            let ty = ast_ty_to_ty(ccx, &ExplicitRscope, &**path);\n             let cur_idx = index;\n \n             ty::walk_ty(ty, |t| {"}, {"sha": "b5b4cc80faac1b9d302ef7980c5d616178d1f05a", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 101, "deletions": 109, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -60,7 +60,6 @@ time of error detection.\n */\n \n use std::collections::HashSet;\n-use std::gc::GC;\n use middle::def;\n use middle::subst;\n use middle::ty;\n@@ -84,12 +83,12 @@ use std::rc::Rc;\n use std::string::String;\n use syntax::ast;\n use syntax::ast_map;\n-use syntax::ast_util;\n use syntax::ast_util::{name_to_dummy_lifetime, PostExpansionMethod};\n use syntax::owned_slice::OwnedSlice;\n use syntax::codemap;\n use syntax::parse::token;\n use syntax::print::pprust;\n+use syntax::ptr::P;\n use util::ppaux::bound_region_to_string;\n use util::ppaux::note_and_explain_region;\n \n@@ -161,7 +160,7 @@ trait ErrorReportingHelpers {\n                                 decl: &ast::FnDecl,\n                                 fn_style: ast::FnStyle,\n                                 ident: ast::Ident,\n-                                opt_explicit_self: Option<ast::ExplicitSelf_>,\n+                                opt_explicit_self: Option<&ast::ExplicitSelf_>,\n                                 generics: &ast::Generics,\n                                 span: codemap::Span);\n }\n@@ -855,8 +854,8 @@ impl<'a, 'tcx> ErrorReporting for InferCtxt<'a, 'tcx> {\n             Some(ref node) => match *node {\n                 ast_map::NodeItem(ref item) => {\n                     match item.node {\n-                        ast::ItemFn(fn_decl, ref pur, _, ref gen, _) => {\n-                            Some((fn_decl, gen, *pur, item.ident, None, item.span))\n+                        ast::ItemFn(ref fn_decl, pur, _, ref gen, _) => {\n+                            Some((&**fn_decl, gen, pur, item.ident, None, item.span))\n                         },\n                         _ => None\n                     }\n@@ -868,7 +867,7 @@ impl<'a, 'tcx> ErrorReporting for InferCtxt<'a, 'tcx> {\n                                   m.pe_generics(),\n                                   m.pe_fn_style(),\n                                   m.pe_ident(),\n-                                  Some(m.pe_explicit_self().node),\n+                                  Some(&m.pe_explicit_self().node),\n                                   m.span))\n                         }\n                     }\n@@ -885,7 +884,7 @@ impl<'a, 'tcx> ErrorReporting for InferCtxt<'a, 'tcx> {\n                                        generics, same_regions, &life_giver);\n         let (fn_decl, expl_self, generics) = rebuilder.rebuild();\n         self.give_expl_lifetime_param(&fn_decl, fn_style, ident,\n-                                      expl_self, &generics, span);\n+                                      expl_self.as_ref(), &generics, span);\n     }\n }\n \n@@ -902,8 +901,8 @@ struct RebuildPathInfo<'a> {\n \n struct Rebuilder<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n-    fn_decl: ast::P<ast::FnDecl>,\n-    expl_self_opt: Option<ast::ExplicitSelf_>,\n+    fn_decl: &'a ast::FnDecl,\n+    expl_self_opt: Option<&'a ast::ExplicitSelf_>,\n     generics: &'a ast::Generics,\n     same_regions: &'a [SameRegions],\n     life_giver: &'a LifeGiver,\n@@ -918,8 +917,8 @@ enum FreshOrKept {\n \n impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n     fn new(tcx: &'a ty::ctxt<'tcx>,\n-           fn_decl: ast::P<ast::FnDecl>,\n-           expl_self_opt: Option<ast::ExplicitSelf_>,\n+           fn_decl: &'a ast::FnDecl,\n+           expl_self_opt: Option<&'a ast::ExplicitSelf_>,\n            generics: &'a ast::Generics,\n            same_regions: &'a [SameRegions],\n            life_giver: &'a LifeGiver)\n@@ -938,9 +937,9 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n \n     fn rebuild(&self)\n                -> (ast::FnDecl, Option<ast::ExplicitSelf_>, ast::Generics) {\n-        let mut expl_self_opt = self.expl_self_opt;\n+        let mut expl_self_opt = self.expl_self_opt.map(|x| x.clone());\n         let mut inputs = self.fn_decl.inputs.clone();\n-        let mut output = self.fn_decl.output;\n+        let mut output = self.fn_decl.output.clone();\n         let mut ty_params = self.generics.ty_params.clone();\n         let where_clause = self.generics.where_clause.clone();\n         let mut kept_lifetimes = HashSet::new();\n@@ -958,7 +957,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                                                    &anon_nums, &region_names);\n             inputs = self.rebuild_args_ty(inputs.as_slice(), lifetime,\n                                           &anon_nums, &region_names);\n-            output = self.rebuild_arg_ty_or_output(output, lifetime,\n+            output = self.rebuild_arg_ty_or_output(&*output, lifetime,\n                                                    &anon_nums, &region_names);\n             ty_params = self.rebuild_ty_params(ty_params, lifetime,\n                                                &region_names);\n@@ -1068,7 +1067,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                 id: ty_param.id,\n                 bounds: bounds,\n                 unbound: ty_param.unbound.clone(),\n-                default: ty_param.default,\n+                default: ty_param.default.clone(),\n                 span: ty_param.span,\n             }\n         })\n@@ -1087,8 +1086,8 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                     // be passing down a map.\n                     ast::RegionTyParamBound(lt)\n                 }\n-                &ast::UnboxedFnTyParamBound(unboxed_function_type) => {\n-                    ast::UnboxedFnTyParamBound(unboxed_function_type)\n+                &ast::UnboxedFnTyParamBound(ref unboxed_function_type) => {\n+                    ast::UnboxedFnTyParamBound((*unboxed_function_type).clone())\n                 }\n                 &ast::TraitTyParamBound(ref tr) => {\n                     let last_seg = tr.path.segments.last().unwrap();\n@@ -1122,7 +1121,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                          region_names: &HashSet<ast::Name>)\n                          -> Option<ast::ExplicitSelf_> {\n         match expl_self_opt {\n-            Some(expl_self) => match expl_self {\n+            Some(ref expl_self) => match *expl_self {\n                 ast::SelfRegion(lt_opt, muta, id) => match lt_opt {\n                     Some(lt) => if region_names.contains(&lt.name) {\n                         return Some(ast::SelfRegion(Some(lifetime), muta, id));\n@@ -1177,11 +1176,11 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                        -> Vec<ast::Arg> {\n         let mut new_inputs = Vec::new();\n         for arg in inputs.iter() {\n-            let new_ty = self.rebuild_arg_ty_or_output(arg.ty, lifetime,\n+            let new_ty = self.rebuild_arg_ty_or_output(&*arg.ty, lifetime,\n                                                        anon_nums, region_names);\n             let possibly_new_arg = ast::Arg {\n                 ty: new_ty,\n-                pat: arg.pat,\n+                pat: arg.pat.clone(),\n                 id: arg.id\n             };\n             new_inputs.push(possibly_new_arg);\n@@ -1190,36 +1189,40 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n     }\n \n     fn rebuild_arg_ty_or_output(&self,\n-                                ty: ast::P<ast::Ty>,\n+                                ty: &ast::Ty,\n                                 lifetime: ast::Lifetime,\n                                 anon_nums: &HashSet<uint>,\n                                 region_names: &HashSet<ast::Name>)\n-                                -> ast::P<ast::Ty> {\n-        let mut new_ty = ty;\n+                                -> P<ast::Ty> {\n+        let mut new_ty = P(ty.clone());\n         let mut ty_queue = vec!(ty);\n-        let mut cur_ty;\n         while !ty_queue.is_empty() {\n-            cur_ty = ty_queue.shift().unwrap();\n+            let cur_ty = ty_queue.shift().unwrap();\n             match cur_ty.node {\n-                ast::TyRptr(lt_opt, mut_ty) => {\n-                    match lt_opt {\n-                        Some(lt) => if region_names.contains(&lt.name) {\n-                            new_ty = self.rebuild_ty(new_ty, cur_ty,\n-                                                     lifetime, None);\n-                        },\n+                ast::TyRptr(lt_opt, ref mut_ty) => {\n+                    let rebuild = match lt_opt {\n+                        Some(lt) => region_names.contains(&lt.name),\n                         None => {\n                             let anon = self.cur_anon.get();\n-                            if anon_nums.contains(&anon) {\n-                                new_ty = self.rebuild_ty(new_ty, cur_ty,\n-                                                         lifetime, None);\n+                            let rebuild = anon_nums.contains(&anon);\n+                            if rebuild {\n                                 self.track_anon(anon);\n                             }\n                             self.inc_and_offset_cur_anon(1);\n+                            rebuild\n                         }\n+                    };\n+                    if rebuild {\n+                        let to = ast::Ty {\n+                            id: cur_ty.id,\n+                            node: ast::TyRptr(Some(lifetime), mut_ty.clone()),\n+                            span: cur_ty.span\n+                        };\n+                        new_ty = self.rebuild_ty(new_ty, P(to));\n                     }\n-                    ty_queue.push(mut_ty.ty);\n+                    ty_queue.push(&*mut_ty.ty);\n                 }\n-                ast::TyPath(ref path, _, id) => {\n+                ast::TyPath(ref path, ref bounds, id) => {\n                     let a_def = match self.tcx.def_map.borrow().find(&id) {\n                         None => {\n                             self.tcx\n@@ -1232,10 +1235,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                     };\n                     match a_def {\n                         def::DefTy(did) | def::DefStruct(did) => {\n-                            let ty::Polytype {\n-                                generics: generics,\n-                                ty: _\n-                            } = ty::lookup_item_type(self.tcx, did);\n+                            let generics = ty::lookup_item_type(self.tcx, did).generics;\n \n                             let expected =\n                                 generics.regions.len(subst::TypeSpace);\n@@ -1266,85 +1266,77 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                                 anon_nums: anon_nums,\n                                 region_names: region_names\n                             };\n-                            new_ty = self.rebuild_ty(new_ty, cur_ty,\n-                                                     lifetime,\n-                                                     Some(rebuild_info));\n+                            let new_path = self.rebuild_path(rebuild_info, lifetime);\n+                            let to = ast::Ty {\n+                                id: cur_ty.id,\n+                                node: ast::TyPath(new_path, bounds.clone(), id),\n+                                span: cur_ty.span\n+                            };\n+                            new_ty = self.rebuild_ty(new_ty, P(to));\n                         }\n                         _ => ()\n                     }\n \n                 }\n-                _ => ty_queue.push_all_move(ast_util::get_inner_tys(cur_ty))\n+\n+                ast::TyPtr(ref mut_ty) => {\n+                    ty_queue.push(&*mut_ty.ty);\n+                }\n+                ast::TyBox(ref ty) |\n+                ast::TyVec(ref ty) |\n+                ast::TyUniq(ref ty) |\n+                ast::TyFixedLengthVec(ref ty, _) => {\n+                    ty_queue.push(&**ty);\n+                }\n+                ast::TyTup(ref tys) => ty_queue.extend(tys.iter().map(|ty| &**ty)),\n+                _ => {}\n             }\n         }\n         new_ty\n     }\n \n     fn rebuild_ty(&self,\n-                  from: ast::P<ast::Ty>,\n-                  to: ast::P<ast::Ty>,\n-                  lifetime: ast::Lifetime,\n-                  rebuild_path_info: Option<RebuildPathInfo>)\n-                  -> ast::P<ast::Ty> {\n-\n-        fn build_to(from: ast::P<ast::Ty>,\n-                    to: ast::P<ast::Ty>)\n-                    -> ast::P<ast::Ty> {\n-            if from.id == to.id {\n-                return to;\n-            }\n-            let new_node = match from.node {\n-                ast::TyRptr(ref lifetime, ref mut_ty) => {\n-                    let new_mut_ty = ast::MutTy {\n-                        ty: build_to(mut_ty.ty, to),\n-                        mutbl: mut_ty.mutbl\n-                    };\n-                    ast::TyRptr(*lifetime, new_mut_ty)\n-                }\n-                ast::TyPtr(ref mut_ty) => {\n-                    let new_mut_ty = ast::MutTy {\n-                        ty: build_to(mut_ty.ty, to),\n-                        mutbl: mut_ty.mutbl\n-                    };\n-                    ast::TyPtr(new_mut_ty)\n-                }\n-                ast::TyBox(ref ty) => ast::TyBox(build_to(*ty, to)),\n-                ast::TyVec(ref ty) => ast::TyVec(build_to(*ty, to)),\n-                ast::TyUniq(ref ty) => ast::TyUniq(build_to(*ty, to)),\n-                ast::TyFixedLengthVec(ref ty, ref e) => {\n-                    ast::TyFixedLengthVec(build_to(*ty, to), *e)\n-                }\n-                ast::TyTup(ref tys) => {\n-                    let mut new_tys = Vec::new();\n-                    for ty in tys.iter() {\n-                        new_tys.push(build_to(*ty, to));\n+                  from: P<ast::Ty>,\n+                  to: P<ast::Ty>)\n+                  -> P<ast::Ty> {\n+\n+        fn build_to(from: P<ast::Ty>,\n+                    to: &mut Option<P<ast::Ty>>)\n+                    -> P<ast::Ty> {\n+            if Some(from.id) == to.as_ref().map(|ty| ty.id) {\n+                return to.take().expect(\"`to` type found more than once during rebuild\");\n+            }\n+            from.map(|ast::Ty {id, node, span}| {\n+                let new_node = match node {\n+                    ast::TyRptr(lifetime, mut_ty) => {\n+                        ast::TyRptr(lifetime, ast::MutTy {\n+                            mutbl: mut_ty.mutbl,\n+                            ty: build_to(mut_ty.ty, to),\n+                        })\n                     }\n-                    ast::TyTup(new_tys)\n-                }\n-                ast::TyParen(ref typ) => ast::TyParen(build_to(*typ, to)),\n-                ref other => other.clone()\n-            };\n-            box(GC) ast::Ty { id: from.id, node: new_node, span: from.span }\n+                    ast::TyPtr(mut_ty) => {\n+                        ast::TyPtr(ast::MutTy {\n+                            mutbl: mut_ty.mutbl,\n+                            ty: build_to(mut_ty.ty, to),\n+                        })\n+                    }\n+                    ast::TyBox(ty) => ast::TyBox(build_to(ty, to)),\n+                    ast::TyVec(ty) => ast::TyVec(build_to(ty, to)),\n+                    ast::TyUniq(ty) => ast::TyUniq(build_to(ty, to)),\n+                    ast::TyFixedLengthVec(ty, e) => {\n+                        ast::TyFixedLengthVec(build_to(ty, to), e)\n+                    }\n+                    ast::TyTup(tys) => {\n+                        ast::TyTup(tys.move_iter().map(|ty| build_to(ty, to)).collect())\n+                    }\n+                    ast::TyParen(typ) => ast::TyParen(build_to(typ, to)),\n+                    other => other\n+                };\n+                ast::Ty { id: id, node: new_node, span: span }\n+            })\n         }\n \n-        let new_ty_node = match to.node {\n-            ast::TyRptr(_, mut_ty) => ast::TyRptr(Some(lifetime), mut_ty),\n-            ast::TyPath(_, ref bounds, id) => {\n-                let rebuild_info = match rebuild_path_info {\n-                    Some(ri) => ri,\n-                    None => fail!(\"expect index_opt in rebuild_ty/ast::TyPath\")\n-                };\n-                let new_path = self.rebuild_path(rebuild_info, lifetime);\n-                ast::TyPath(new_path, bounds.clone(), id)\n-            }\n-            _ => fail!(\"expect ast::TyRptr or ast::TyPath\")\n-        };\n-        let new_ty = box(GC) ast::Ty {\n-            id: to.id,\n-            node: new_ty_node,\n-            span: to.span\n-        };\n-        build_to(from, new_ty)\n+        build_to(from, &mut Some(to))\n     }\n \n     fn rebuild_path(&self,\n@@ -1384,8 +1376,8 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                 }\n             }\n         }\n-        let new_types = last_seg.types.map(|&t| {\n-            self.rebuild_arg_ty_or_output(t, lifetime, anon_nums, region_names)\n+        let new_types = last_seg.types.map(|t| {\n+            self.rebuild_arg_ty_or_output(&**t, lifetime, anon_nums, region_names)\n         });\n         let new_seg = ast::PathSegment {\n             identifier: last_seg.identifier,\n@@ -1408,7 +1400,7 @@ impl<'a, 'tcx> ErrorReportingHelpers for InferCtxt<'a, 'tcx> {\n                                 decl: &ast::FnDecl,\n                                 fn_style: ast::FnStyle,\n                                 ident: ast::Ident,\n-                                opt_explicit_self: Option<ast::ExplicitSelf_>,\n+                                opt_explicit_self: Option<&ast::ExplicitSelf_>,\n                                 generics: &ast::Generics,\n                                 span: codemap::Span) {\n         let suggested_fn = pprust::fun_to_string(decl, fn_style, ident,\n@@ -1686,7 +1678,7 @@ fn lifetimes_in_scope(tcx: &ty::ctxt,\n             },\n             ast_map::NodeImplItem(ii) => {\n                 match *ii {\n-                    ast::MethodImplItem(m) => {\n+                    ast::MethodImplItem(ref m) => {\n                         taken.push_all(m.pe_generics().lifetimes.as_slice());\n                         Some(m.id)\n                     }"}, {"sha": "c0236cefca3f9ec88beca937cf724d2dccb64317", "filename": "src/librustc/middle/typeck/infer/test.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -36,13 +36,12 @@ use middle::typeck::infer::glb::Glb;\n use syntax::codemap;\n use syntax::codemap::{Span, CodeMap, DUMMY_SP};\n use syntax::diagnostic::{Level, RenderSpan, Bug, Fatal, Error, Warning, Note};\n-use syntax::ast;\n+use syntax::{ast, ast_map};\n use util::ppaux::{ty_to_string, UserString};\n \n use arena::TypedArena;\n \n struct Env<'a, 'tcx: 'a> {\n-    krate: ast::Crate,\n     infcx: &'a infer::InferCtxt<'a, 'tcx>,\n }\n \n@@ -117,19 +116,22 @@ fn test_env(_test_name: &str,\n     let krate_config = Vec::new();\n     let input = driver::StrInput(source_string.to_string());\n     let krate = driver::phase_1_parse_input(&sess, krate_config, &input);\n-    let (krate, ast_map) =\n-        driver::phase_2_configure_and_expand(&sess, krate, \"test\", None)\n-            .expect(\"phase 2 aborted\");\n+    let krate = driver::phase_2_configure_and_expand(&sess, krate, \"test\", None)\n+                    .expect(\"phase 2 aborted\");\n+\n+    let mut forest = ast_map::Forest::new(krate);\n+    let ast_map = driver::assign_node_ids_and_map(&sess, &mut forest);\n+    let krate = ast_map.krate();\n \n     // run just enough stuff to build a tcx:\n-    let lang_items = lang_items::collect_language_items(&krate, &sess);\n+    let lang_items = lang_items::collect_language_items(krate, &sess);\n     let resolve::CrateMap { def_map: def_map, .. } =\n-        resolve::resolve_crate(&sess, &lang_items, &krate);\n+        resolve::resolve_crate(&sess, &lang_items, krate);\n     let (freevars_map, captures_map) = freevars::annotate_freevars(&def_map,\n-                                                                   &krate);\n-    let named_region_map = resolve_lifetime::krate(&sess, &krate);\n-    let region_map = region::resolve_crate(&sess, &krate);\n-    let stability_index = stability::Index::build(&krate);\n+                                                                   krate);\n+    let named_region_map = resolve_lifetime::krate(&sess, krate);\n+    let region_map = region::resolve_crate(&sess, krate);\n+    let stability_index = stability::Index::build(krate);\n     let type_arena = TypedArena::new();\n     let tcx = ty::mk_ctxt(sess,\n                           &type_arena,\n@@ -142,11 +144,7 @@ fn test_env(_test_name: &str,\n                           lang_items,\n                           stability_index);\n     let infcx = infer::new_infer_ctxt(&tcx);\n-    let env = Env {\n-        krate: krate,\n-        infcx: &infcx\n-    };\n-    body(env);\n+    body(Env { infcx: &infcx });\n     infcx.resolve_regions_and_report_errors();\n     assert_eq!(tcx.sess.err_count(), expected_err_count);\n }\n@@ -171,7 +169,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n     }\n \n     pub fn lookup_item(&self, names: &[String]) -> ast::NodeId {\n-        return match search_mod(self, &self.krate.module, 0, names) {\n+        return match search_mod(self, &self.infcx.tcx.map.krate().module, 0, names) {\n             Some(id) => id,\n             None => {\n                 fail!(\"no item found: `{}`\", names.connect(\"::\"));"}, {"sha": "e59f1aa3ce4c13780918b407310b73bc9ba0f4e8", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -308,7 +308,7 @@ pub fn write_substs_to_tcx(tcx: &ty::ctxt,\n }\n pub fn lookup_def_tcx(tcx:&ty::ctxt, sp: Span, id: ast::NodeId) -> def::Def {\n     match tcx.def_map.borrow().find(&id) {\n-        Some(&x) => x,\n+        Some(x) => x.clone(),\n         _ => {\n             tcx.sess.span_fatal(sp, \"internal error looking up a definition\")\n         }\n@@ -474,30 +474,28 @@ fn check_for_entry_fn(ccx: &CrateCtxt) {\n     }\n }\n \n-pub fn check_crate(tcx: &ty::ctxt,\n-                   trait_map: resolve::TraitMap,\n-                   krate: &ast::Crate) {\n+pub fn check_crate(tcx: &ty::ctxt, trait_map: resolve::TraitMap) {\n     let time_passes = tcx.sess.time_passes();\n     let ccx = CrateCtxt {\n         trait_map: trait_map,\n         tcx: tcx\n     };\n \n     time(time_passes, \"type collecting\", (), |_|\n-        collect::collect_item_types(&ccx, krate));\n+        collect::collect_item_types(&ccx));\n \n     // this ensures that later parts of type checking can assume that items\n     // have valid types and not error\n     tcx.sess.abort_if_errors();\n \n     time(time_passes, \"variance inference\", (), |_|\n-         variance::infer_variance(tcx, krate));\n+         variance::infer_variance(tcx));\n \n     time(time_passes, \"coherence checking\", (), |_|\n-        coherence::check_coherence(&ccx, krate));\n+        coherence::check_coherence(&ccx));\n \n     time(time_passes, \"type checking\", (), |_|\n-        check::check_item_types(&ccx, krate));\n+        check::check_item_types(&ccx));\n \n     check_for_entry_fn(&ccx);\n     tcx.sess.abort_if_errors();"}, {"sha": "547fbce573bccf67636e81ba01f513f2a14e2e9f", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -208,8 +208,8 @@ use syntax::visit;\n use syntax::visit::Visitor;\n use util::ppaux::Repr;\n \n-pub fn infer_variance(tcx: &ty::ctxt,\n-                      krate: &ast::Crate) {\n+pub fn infer_variance(tcx: &ty::ctxt) {\n+    let krate = tcx.map.krate();\n     let mut arena = arena::Arena::new();\n     let terms_cx = determine_parameters_to_be_inferred(tcx, &mut arena, krate);\n     let constraints_cx = add_constraints_from_crate(terms_cx, krate);"}, {"sha": "c39f011189a605392e235ab77a1c694c93516445", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -99,7 +99,7 @@ impl<'a, 'v> Visitor<'v> for BlockQueryVisitor<'a> {\n \n // Takes a predicate p, returns true iff p is true for any subexpressions\n // of b -- skipping any inner loops (loop, while, loop_body)\n-pub fn block_query(b: ast::P<ast::Block>, p: |&ast::Expr| -> bool) -> bool {\n+pub fn block_query(b: &ast::Block, p: |&ast::Expr| -> bool) -> bool {\n     let mut v = BlockQueryVisitor {\n         p: p,\n         flag: false,"}, {"sha": "ba1f7ca2cb2314dc7dc1749ff4a0a1ef174f3dd2", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -27,7 +27,6 @@ use middle::typeck;\n use middle::typeck::check::regionmanip;\n use middle::typeck::infer;\n \n-use std::gc::Gc;\n use std::rc::Rc;\n use syntax::abi;\n use syntax::ast_map;\n@@ -546,9 +545,9 @@ impl<T:Repr> Repr for Rc<T> {\n     }\n }\n \n-impl<T:Repr + 'static> Repr for Gc<T> {\n+impl<'a, T:Repr> Repr for &'a T {\n     fn repr(&self, tcx: &ctxt) -> String {\n-        (&**self).repr(tcx)\n+        (*self).repr(tcx)\n     }\n }\n \n@@ -822,21 +821,19 @@ impl Repr for ast::DefId {\n         // a path for a def-id, so I'll just make a best effort for now\n         // and otherwise fallback to just printing the crate/node pair\n         if self.krate == ast::LOCAL_CRATE {\n-            {\n-                match tcx.map.find(self.node) {\n-                    Some(ast_map::NodeItem(..)) |\n-                    Some(ast_map::NodeForeignItem(..)) |\n-                    Some(ast_map::NodeImplItem(..)) |\n-                    Some(ast_map::NodeTraitItem(..)) |\n-                    Some(ast_map::NodeVariant(..)) |\n-                    Some(ast_map::NodeStructCtor(..)) => {\n-                        return format!(\n+            match tcx.map.find(self.node) {\n+                Some(ast_map::NodeItem(..)) |\n+                Some(ast_map::NodeForeignItem(..)) |\n+                Some(ast_map::NodeImplItem(..)) |\n+                Some(ast_map::NodeTraitItem(..)) |\n+                Some(ast_map::NodeVariant(..)) |\n+                Some(ast_map::NodeStructCtor(..)) => {\n+                    return format!(\n                                 \"{:?}:{}\",\n                                 *self,\n                                 ty::item_path_str(tcx, *self))\n-                    }\n-                    _ => {}\n                 }\n+                _ => {}\n             }\n         }\n         return format!(\"{:?}\", *self)"}, {"sha": "415141c0b94004b918e9fd091484c027b383a40e", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -264,7 +264,7 @@ mod svh_visitor {\n             ExprTup(..)              => SawExprTup,\n             ExprBinary(op, _, _)     => SawExprBinary(op),\n             ExprUnary(op, _)         => SawExprUnary(op),\n-            ExprLit(lit)             => SawExprLit(lit.node.clone()),\n+            ExprLit(ref lit)         => SawExprLit(lit.node.clone()),\n             ExprCast(..)             => SawExprCast,\n             ExprIf(..)               => SawExprIf,\n             ExprWhile(..)            => SawExprWhile,"}, {"sha": "e6fcbbe9b6ff35c800852f974919fe67c6485621", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -20,6 +20,7 @@ use syntax::attr::{AttributeMethods, AttrMetaMethods};\n use syntax::codemap::Pos;\n use syntax::parse::token::InternedString;\n use syntax::parse::token;\n+use syntax::ptr::P;\n \n use rustc::back::link;\n use rustc::driver::driver;\n@@ -34,7 +35,6 @@ use rustc::middle::stability;\n \n use std::rc::Rc;\n use std::u32;\n-use std::gc::{Gc, GC};\n \n use core::DocContext;\n use doctree;\n@@ -67,7 +67,7 @@ impl<T: Clean<U>, U> Clean<VecPerParamSpace<U>> for VecPerParamSpace<T> {\n     }\n }\n \n-impl<T: 'static + Clean<U>, U> Clean<U> for Gc<T> {\n+impl<T: Clean<U>, U> Clean<U> for P<T> {\n     fn clean(&self, cx: &DocContext) -> U {\n         (**self).clean(cx)\n     }\n@@ -408,7 +408,7 @@ impl Clean<Attribute> for ast::MetaItem {\n \n impl Clean<Attribute> for ast::Attribute {\n     fn clean(&self, cx: &DocContext) -> Attribute {\n-        self.desugar_doc().node.value.clean(cx)\n+        self.with_desugared_doc(|a| a.node.value.clean(cx))\n     }\n }\n \n@@ -430,12 +430,12 @@ impl attr::AttrMetaMethods for Attribute {\n             _ => None,\n         }\n     }\n-    fn meta_item_list<'a>(&'a self) -> Option<&'a [Gc<ast::MetaItem>]> { None }\n+    fn meta_item_list<'a>(&'a self) -> Option<&'a [P<ast::MetaItem>]> { None }\n }\n impl<'a> attr::AttrMetaMethods for &'a Attribute {\n     fn name(&self) -> InternedString { (**self).name() }\n     fn value_str(&self) -> Option<InternedString> { (**self).value_str() }\n-    fn meta_item_list<'a>(&'a self) -> Option<&'a [Gc<ast::MetaItem>]> { None }\n+    fn meta_item_list<'a>(&'a self) -> Option<&'a [P<ast::MetaItem>]> { None }\n }\n \n #[deriving(Clone, Encodable, Decodable, PartialEq)]\n@@ -758,10 +758,10 @@ impl Clean<SelfTy> for ast::ExplicitSelf_ {\n         match *self {\n             ast::SelfStatic => SelfStatic,\n             ast::SelfValue(_) => SelfValue,\n-            ast::SelfRegion(lt, mt, _) => {\n+            ast::SelfRegion(ref lt, ref mt, _) => {\n                 SelfBorrowed(lt.clean(cx), mt.clean(cx))\n             }\n-            ast::SelfExplicit(typ, _) => SelfExplicit(typ.clean(cx)),\n+            ast::SelfExplicit(ref typ, _) => SelfExplicit(typ.clean(cx)),\n         }\n     }\n }\n@@ -1189,11 +1189,11 @@ impl Clean<Type> for ast::Ty {\n             TyRptr(ref l, ref m) =>\n                 BorrowedRef {lifetime: l.clean(cx), mutability: m.mutbl.clean(cx),\n                              type_: box m.ty.clean(cx)},\n-            TyBox(ty) => Managed(box ty.clean(cx)),\n-            TyUniq(ty) => Unique(box ty.clean(cx)),\n-            TyVec(ty) => Vector(box ty.clean(cx)),\n-            TyFixedLengthVec(ty, ref e) => FixedVector(box ty.clean(cx),\n-                                                       e.span.to_src(cx)),\n+            TyBox(ref ty) => Managed(box ty.clean(cx)),\n+            TyUniq(ref ty) => Unique(box ty.clean(cx)),\n+            TyVec(ref ty) => Vector(box ty.clean(cx)),\n+            TyFixedLengthVec(ref ty, ref e) => FixedVector(box ty.clean(cx),\n+                                                           e.span.to_src(cx)),\n             TyTup(ref tys) => Tuple(tys.clean(cx)),\n             TyPath(ref p, ref tpbs, id) => {\n                 resolve_type(cx, p.clean(cx), tpbs.clean(cx), id)\n@@ -1799,7 +1799,7 @@ impl Clean<Vec<Item>> for ast::ViewItem {\n                                                          remaining,\n                                                          b.clone());\n                             let path = syntax::codemap::dummy_spanned(path);\n-                            ret.push(convert(&ast::ViewItemUse(box(GC) path)));\n+                            ret.push(convert(&ast::ViewItemUse(P(path))));\n                         }\n                     }\n                     ast::ViewPathSimple(ident, _, id) => {\n@@ -1985,8 +1985,8 @@ fn name_from_pat(p: &ast::Pat) -> String {\n         },\n         PatTup(ref elts) => format!(\"({})\", elts.iter().map(|p| name_from_pat(&**p))\n                                             .collect::<Vec<String>>().connect(\", \")),\n-        PatBox(p) => name_from_pat(&*p),\n-        PatRegion(p) => name_from_pat(&*p),\n+        PatBox(ref p) => name_from_pat(&**p),\n+        PatRegion(ref p) => name_from_pat(&**p),\n         PatLit(..) => {\n             warn!(\"tried to get argument name from PatLit, \\\n                   which is silly in function arguments\");"}, {"sha": "ddb4b994ca38e157e4d326433f13b1909f64de43", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 42, "deletions": 53, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -8,18 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc;\n-use rustc::{driver, middle};\n+use rustc::driver::{config, driver, session};\n use rustc::middle::{privacy, ty};\n use rustc::lint;\n use rustc::back::link;\n \n-use syntax::ast;\n+use syntax::{ast, ast_map, codemap, diagnostic};\n use syntax::parse::token;\n-use syntax;\n+use syntax::ptr::P;\n \n use std::cell::RefCell;\n-use std::gc::GC;\n use std::os;\n use std::collections::{HashMap, HashSet};\n use arena::TypedArena;\n@@ -30,15 +28,15 @@ use clean::Clean;\n \n /// Are we generating documentation (`Typed`) or tests (`NotTyped`)?\n pub enum MaybeTyped<'tcx> {\n-    Typed(middle::ty::ctxt<'tcx>),\n-    NotTyped(driver::session::Session)\n+    Typed(ty::ctxt<'tcx>),\n+    NotTyped(session::Session)\n }\n \n pub type ExternalPaths = RefCell<Option<HashMap<ast::DefId,\n                                                 (Vec<String>, clean::TypeKind)>>>;\n \n pub struct DocContext<'tcx> {\n-    pub krate: ast::Crate,\n+    pub krate: &'tcx ast::Crate,\n     pub maybe_typed: MaybeTyped<'tcx>,\n     pub src: Path,\n     pub external_paths: ExternalPaths,\n@@ -49,7 +47,7 @@ pub struct DocContext<'tcx> {\n }\n \n impl<'tcx> DocContext<'tcx> {\n-    pub fn sess<'a>(&'a self) -> &'a driver::session::Session {\n+    pub fn sess<'a>(&'a self) -> &'a session::Session {\n         match self.maybe_typed {\n             Typed(ref tcx) => &tcx.sess,\n             NotTyped(ref sess) => sess\n@@ -80,91 +78,82 @@ pub struct CrateAnalysis {\n \n pub type Externs = HashMap<String, Vec<String>>;\n \n-/// Parses, resolves, and typechecks the given crate\n-fn get_ast_and_resolve<'tcx>(cpath: &Path, libs: Vec<Path>, cfgs: Vec<String>,\n-                             externs: Externs, triple: Option<String>,\n-                             type_arena: &'tcx TypedArena<ty::t_box_>)\n-                             -> (DocContext<'tcx>, CrateAnalysis) {\n-    use syntax::codemap::dummy_spanned;\n-    use rustc::driver::driver::{FileInput,\n-                                phase_1_parse_input,\n-                                phase_2_configure_and_expand,\n-                                phase_3_run_analysis_passes};\n-    use rustc::driver::config::build_configuration;\n+pub fn run_core(libs: Vec<Path>, cfgs: Vec<String>, externs: Externs,\n+                cpath: &Path, triple: Option<String>)\n+                -> (clean::Crate, CrateAnalysis) {\n \n-    let input = FileInput(cpath.clone());\n+    // Parse, resolve, and typecheck the given crate.\n+\n+    let input = driver::FileInput(cpath.clone());\n \n     let warning_lint = lint::builtin::WARNINGS.name_lower();\n \n-    let sessopts = driver::config::Options {\n+    let sessopts = config::Options {\n         maybe_sysroot: Some(os::self_exe_path().unwrap().dir_path()),\n         addl_lib_search_paths: RefCell::new(libs),\n-        crate_types: vec!(driver::config::CrateTypeRlib),\n+        crate_types: vec!(config::CrateTypeRlib),\n         lint_opts: vec!((warning_lint, lint::Allow)),\n         externs: externs,\n-        target_triple: triple.unwrap_or(driver::driver::host_triple().to_string()),\n-        ..rustc::driver::config::basic_options().clone()\n+        target_triple: triple.unwrap_or(driver::host_triple().to_string()),\n+        ..config::basic_options().clone()\n     };\n \n \n-    let codemap = syntax::codemap::CodeMap::new();\n-    let diagnostic_handler = syntax::diagnostic::default_handler(syntax::diagnostic::Auto, None);\n+    let codemap = codemap::CodeMap::new();\n+    let diagnostic_handler = diagnostic::default_handler(diagnostic::Auto, None);\n     let span_diagnostic_handler =\n-        syntax::diagnostic::mk_span_handler(diagnostic_handler, codemap);\n+        diagnostic::mk_span_handler(diagnostic_handler, codemap);\n \n-    let sess = driver::session::build_session_(sessopts,\n-                                               Some(cpath.clone()),\n-                                               span_diagnostic_handler);\n+    let sess = session::build_session_(sessopts,\n+                                       Some(cpath.clone()),\n+                                       span_diagnostic_handler);\n \n-    let mut cfg = build_configuration(&sess);\n+    let mut cfg = config::build_configuration(&sess);\n     for cfg_ in cfgs.move_iter() {\n         let cfg_ = token::intern_and_get_ident(cfg_.as_slice());\n-        cfg.push(box(GC) dummy_spanned(ast::MetaWord(cfg_)));\n+        cfg.push(P(codemap::dummy_spanned(ast::MetaWord(cfg_))));\n     }\n \n-    let krate = phase_1_parse_input(&sess, cfg, &input);\n+    let krate = driver::phase_1_parse_input(&sess, cfg, &input);\n \n     let name = link::find_crate_name(Some(&sess), krate.attrs.as_slice(),\n                                      &input);\n \n-    let (krate, ast_map)\n-        = phase_2_configure_and_expand(&sess, krate, name.as_slice(), None)\n-            .expect(\"phase_2_configure_and_expand aborted in rustdoc!\");\n+    let krate = driver::phase_2_configure_and_expand(&sess, krate, name.as_slice(), None)\n+                    .expect(\"phase_2_configure_and_expand aborted in rustdoc!\");\n+\n+    let mut forest = ast_map::Forest::new(krate);\n+    let ast_map = driver::assign_node_ids_and_map(&sess, &mut forest);\n \n-    let driver::driver::CrateAnalysis {\n+    let type_arena = TypedArena::new();\n+    let driver::CrateAnalysis {\n         exported_items, public_items, ty_cx, ..\n-    } = phase_3_run_analysis_passes(sess, &krate, ast_map, type_arena, name);\n+    } = driver::phase_3_run_analysis_passes(sess, ast_map, &type_arena, name);\n \n-    debug!(\"crate: {:?}\", krate);\n-    (DocContext {\n-        krate: krate,\n+    let ctxt = DocContext {\n+        krate: ty_cx.map.krate(),\n         maybe_typed: Typed(ty_cx),\n         src: cpath.clone(),\n         external_traits: RefCell::new(Some(HashMap::new())),\n         external_typarams: RefCell::new(Some(HashMap::new())),\n         external_paths: RefCell::new(Some(HashMap::new())),\n         inlined: RefCell::new(Some(HashSet::new())),\n         populated_crate_impls: RefCell::new(HashSet::new()),\n-    }, CrateAnalysis {\n+    };\n+    debug!(\"crate: {:?}\", ctxt.krate);\n+\n+    let analysis = CrateAnalysis {\n         exported_items: exported_items,\n         public_items: public_items,\n         external_paths: RefCell::new(None),\n         external_traits: RefCell::new(None),\n         external_typarams: RefCell::new(None),\n         inlined: RefCell::new(None),\n-    })\n-}\n-\n-pub fn run_core(libs: Vec<Path>, cfgs: Vec<String>, externs: Externs,\n-                path: &Path, triple: Option<String>)\n-                -> (clean::Crate, CrateAnalysis) {\n-    let type_arena = TypedArena::new();\n-    let (ctxt, analysis) = get_ast_and_resolve(path, libs, cfgs, externs,\n-                                               triple, &type_arena);\n+    };\n \n     let krate = {\n         let mut v = RustdocVisitor::new(&ctxt, Some(&analysis));\n-        v.visit(&ctxt.krate);\n+        v.visit(ctxt.krate);\n         v.clean(&ctxt)\n     };\n "}, {"sha": "72964609049bf5fa61a2aff488e5fb7c46009e5e", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -16,8 +16,7 @@ use syntax::codemap::Span;\n use syntax::ast;\n use syntax::attr;\n use syntax::ast::{Ident, NodeId};\n-\n-use std::gc::Gc;\n+use syntax::ptr::P;\n \n pub struct Module {\n     pub name: Option<Ident>,\n@@ -130,7 +129,7 @@ pub struct Function {\n }\n \n pub struct Typedef {\n-    pub ty: ast::P<ast::Ty>,\n+    pub ty: P<ast::Ty>,\n     pub gen: ast::Generics,\n     pub name: Ident,\n     pub id: ast::NodeId,\n@@ -141,9 +140,9 @@ pub struct Typedef {\n }\n \n pub struct Static {\n-    pub type_: ast::P<ast::Ty>,\n+    pub type_: P<ast::Ty>,\n     pub mutability: ast::Mutability,\n-    pub expr: Gc<ast::Expr>,\n+    pub expr: P<ast::Expr>,\n     pub name: Ident,\n     pub attrs: Vec<ast::Attribute>,\n     pub vis: ast::Visibility,\n@@ -167,7 +166,7 @@ pub struct Trait {\n pub struct Impl {\n     pub generics: ast::Generics,\n     pub trait_: Option<ast::TraitRef>,\n-    pub for_: ast::P<ast::Ty>,\n+    pub for_: P<ast::Ty>,\n     pub items: Vec<ast::ImplItem>,\n     pub attrs: Vec<ast::Attribute>,\n     pub whence: Span,"}, {"sha": "b7c602d9d730f7bf14ecd8d338489b61f9f6e77c", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -11,7 +11,6 @@\n use std::cell::RefCell;\n use std::char;\n use std::dynamic_lib::DynamicLibrary;\n-use std::gc::GC;\n use std::io::{Command, TempDir};\n use std::io;\n use std::os;\n@@ -28,6 +27,7 @@ use syntax::ast;\n use syntax::codemap::{CodeMap, dummy_spanned};\n use syntax::diagnostic;\n use syntax::parse::token;\n+use syntax::ptr::P;\n \n use core;\n use clean;\n@@ -67,15 +67,15 @@ pub fn run(input: &str,\n     let mut cfg = config::build_configuration(&sess);\n     cfg.extend(cfgs.move_iter().map(|cfg_| {\n         let cfg_ = token::intern_and_get_ident(cfg_.as_slice());\n-        box(GC) dummy_spanned(ast::MetaWord(cfg_))\n+        P(dummy_spanned(ast::MetaWord(cfg_)))\n     }));\n     let krate = driver::phase_1_parse_input(&sess, cfg, &input);\n-    let (krate, _) = driver::phase_2_configure_and_expand(&sess, krate,\n-                                                          \"rustdoc-test\", None)\n+    let krate = driver::phase_2_configure_and_expand(&sess, krate,\n+                                                     \"rustdoc-test\", None)\n         .expect(\"phase_2_configure_and_expand aborted in rustdoc!\");\n \n     let ctx = core::DocContext {\n-        krate: krate,\n+        krate: &krate,\n         maybe_typed: core::NotTyped(sess),\n         src: input_path,\n         external_paths: RefCell::new(Some(HashMap::new())),\n@@ -86,7 +86,7 @@ pub fn run(input: &str,\n     };\n \n     let mut v = RustdocVisitor::new(&ctx, None);\n-    v.visit(&ctx.krate);\n+    v.visit(ctx.krate);\n     let mut krate = v.clean(&ctx);\n     match crate_name {\n         Some(name) => krate.name = name,"}, {"sha": "a9e0c9cb260f65f21ad9e276034bc69e456e1ea3", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 59, "deletions": 74, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -18,11 +18,10 @@ use syntax::ast_map;\n use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n use syntax::codemap::Span;\n+use syntax::ptr::P;\n \n use rustc::middle::stability;\n \n-use std::gc::{Gc, GC};\n-\n use core;\n use doctree::*;\n \n@@ -57,13 +56,10 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     }\n \n     pub fn visit(&mut self, krate: &ast::Crate) {\n-        self.attrs = krate.attrs.iter().map(|x| (*x).clone()).collect();\n+        self.attrs = krate.attrs.clone();\n \n         self.module = self.visit_mod_contents(krate.span,\n-                                              krate.attrs\n-                                                   .iter()\n-                                                   .map(|x| *x)\n-                                                   .collect(),\n+                                              krate.attrs.clone(),\n                                               ast::Public,\n                                               ast::CRATE_NODE_ID,\n                                               &krate.module,\n@@ -74,61 +70,60 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         self.module.is_crate = true;\n     }\n \n-    pub fn visit_struct_def(&mut self, item: &ast::Item, sd: Gc<ast::StructDef>,\n+    pub fn visit_struct_def(&mut self, item: &ast::Item,\n+                            name: ast::Ident, sd: &ast::StructDef,\n                             generics: &ast::Generics) -> Struct {\n         debug!(\"Visiting struct\");\n         let struct_type = struct_type_from_def(&*sd);\n         Struct {\n             id: item.id,\n             struct_type: struct_type,\n-            name: item.ident,\n+            name: name,\n             vis: item.vis,\n             stab: self.stability(item.id),\n-            attrs: item.attrs.iter().map(|x| *x).collect(),\n+            attrs: item.attrs.clone(),\n             generics: generics.clone(),\n-            fields: sd.fields.iter().map(|x| (*x).clone()).collect(),\n+            fields: sd.fields.clone(),\n             whence: item.span\n         }\n     }\n \n-    pub fn visit_enum_def(&mut self, it: &ast::Item, def: &ast::EnumDef,\n+    pub fn visit_enum_def(&mut self, it: &ast::Item,\n+                          name: ast::Ident, def: &ast::EnumDef,\n                           params: &ast::Generics) -> Enum {\n         debug!(\"Visiting enum\");\n-        let mut vars: Vec<Variant> = Vec::new();\n-        for x in def.variants.iter() {\n-            vars.push(Variant {\n-                name: x.node.name,\n-                attrs: x.node.attrs.iter().map(|x| *x).collect(),\n-                vis: x.node.vis,\n-                stab: self.stability(x.node.id),\n-                id: x.node.id,\n-                kind: x.node.kind.clone(),\n-                whence: x.span,\n-            });\n-        }\n         Enum {\n-            name: it.ident,\n-            variants: vars,\n+            name: name,\n+            variants: def.variants.iter().map(|v| Variant {\n+                name: v.node.name,\n+                attrs: v.node.attrs.clone(),\n+                vis: v.node.vis,\n+                stab: self.stability(v.node.id),\n+                id: v.node.id,\n+                kind: v.node.kind.clone(),\n+                whence: v.span,\n+            }).collect(),\n             vis: it.vis,\n             stab: self.stability(it.id),\n             generics: params.clone(),\n-            attrs: it.attrs.iter().map(|x| *x).collect(),\n+            attrs: it.attrs.clone(),\n             id: it.id,\n             whence: it.span,\n         }\n     }\n \n-    pub fn visit_fn(&mut self, item: &ast::Item, fd: &ast::FnDecl,\n+    pub fn visit_fn(&mut self, item: &ast::Item,\n+                    name: ast::Ident, fd: &ast::FnDecl,\n                     fn_style: &ast::FnStyle, _abi: &abi::Abi,\n                     gen: &ast::Generics) -> Function {\n         debug!(\"Visiting fn\");\n         Function {\n             id: item.id,\n             vis: item.vis,\n             stab: self.stability(item.id),\n-            attrs: item.attrs.iter().map(|x| *x).collect(),\n+            attrs: item.attrs.clone(),\n             decl: fd.clone(),\n-            name: item.ident,\n+            name: name,\n             whence: item.span,\n             generics: gen.clone(),\n             fn_style: *fn_style,\n@@ -150,7 +145,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         om.stab = self.stability(id);\n         om.id = id;\n         for i in m.items.iter() {\n-            self.visit_item(&**i, &mut om);\n+            self.visit_item(&**i, None, &mut om);\n         }\n         om\n     }\n@@ -169,7 +164,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         });\n         let item = match item.node {\n             ast::ViewItemUse(ref vpath) => {\n-                match self.visit_view_path(*vpath, om, please_inline) {\n+                match self.visit_view_path(&**vpath, om, please_inline) {\n                     None => return,\n                     Some(path) => {\n                         ast::ViewItem {\n@@ -184,9 +179,9 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         om.view_items.push(item);\n     }\n \n-    fn visit_view_path(&mut self, path: Gc<ast::ViewPath>,\n+    fn visit_view_path(&mut self, path: &ast::ViewPath,\n                        om: &mut Module,\n-                       please_inline: bool) -> Option<Gc<ast::ViewPath>> {\n+                       please_inline: bool) -> Option<P<ast::ViewPath>> {\n         match path.node {\n             ast::ViewPathSimple(dst, _, id) => {\n                 if self.resolve_id(id, Some(dst), false, om, please_inline) {\n@@ -203,10 +198,10 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 }\n \n                 if mine.len() == 0 { return None }\n-                return Some(box(GC) ::syntax::codemap::Spanned {\n+                return Some(P(::syntax::codemap::Spanned {\n                     node: ast::ViewPathList(p.clone(), mine, b.clone()),\n                     span: path.span,\n-                })\n+                }))\n             }\n \n             // these are feature gated anyway\n@@ -216,7 +211,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 }\n             }\n         }\n-        return Some(path);\n+        Some(P(path.clone()))\n     }\n \n     fn resolve_id(&mut self, id: ast::NodeId, renamed: Option<ast::Ident>,\n@@ -236,77 +231,67 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n \n         match tcx.map.get(def.node) {\n             ast_map::NodeItem(it) => {\n-                let it = match renamed {\n-                    Some(ident) => {\n-                        box(GC) ast::Item {\n-                            ident: ident,\n-                            ..(*it).clone()\n-                        }\n-                    }\n-                    None => it,\n-                };\n                 if glob {\n                     match it.node {\n                         ast::ItemMod(ref m) => {\n                             for vi in m.view_items.iter() {\n                                 self.visit_view_item(vi, om);\n                             }\n                             for i in m.items.iter() {\n-                                self.visit_item(&**i, om);\n+                                self.visit_item(&**i, None, om);\n                             }\n                         }\n                         _ => { fail!(\"glob not mapped to a module\"); }\n                     }\n                 } else {\n-                    self.visit_item(&*it, om);\n+                    self.visit_item(it, renamed, om);\n                 }\n                 true\n             }\n             _ => false,\n         }\n     }\n \n-    pub fn visit_item(&mut self, item: &ast::Item, om: &mut Module) {\n+    pub fn visit_item(&mut self, item: &ast::Item,\n+                      renamed: Option<ast::Ident>, om: &mut Module) {\n         debug!(\"Visiting item {:?}\", item);\n+        let name = renamed.unwrap_or(item.ident);\n         match item.node {\n             ast::ItemMod(ref m) => {\n                 om.mods.push(self.visit_mod_contents(item.span,\n-                                                     item.attrs\n-                                                         .iter()\n-                                                         .map(|x| *x)\n-                                                         .collect(),\n+                                                     item.attrs.clone(),\n                                                      item.vis,\n                                                      item.id,\n                                                      m,\n-                                                     Some(item.ident)));\n+                                                     Some(name)));\n             },\n             ast::ItemEnum(ref ed, ref gen) =>\n-                om.enums.push(self.visit_enum_def(item, ed, gen)),\n-            ast::ItemStruct(sd, ref gen) =>\n-                om.structs.push(self.visit_struct_def(item, sd, gen)),\n+                om.enums.push(self.visit_enum_def(item, name, ed, gen)),\n+            ast::ItemStruct(ref sd, ref gen) =>\n+                om.structs.push(self.visit_struct_def(item, name, &**sd, gen)),\n             ast::ItemFn(ref fd, ref pur, ref abi, ref gen, _) =>\n-                om.fns.push(self.visit_fn(item, &**fd, pur, abi, gen)),\n-            ast::ItemTy(ty, ref gen) => {\n+                om.fns.push(self.visit_fn(item, name, &**fd, pur, abi, gen)),\n+            ast::ItemTy(ref ty, ref gen) => {\n                 let t = Typedef {\n-                    ty: ty,\n+                    ty: ty.clone(),\n                     gen: gen.clone(),\n-                    name: item.ident,\n+                    name: name,\n                     id: item.id,\n-                    attrs: item.attrs.iter().map(|x| *x).collect(),\n+                    attrs: item.attrs.clone(),\n                     whence: item.span,\n                     vis: item.vis,\n                     stab: self.stability(item.id),\n                 };\n                 om.typedefs.push(t);\n             },\n-            ast::ItemStatic(ty, ref mut_, ref exp) => {\n+            ast::ItemStatic(ref ty, ref mut_, ref exp) => {\n                 let s = Static {\n-                    type_: ty,\n+                    type_: ty.clone(),\n                     mutability: mut_.clone(),\n                     expr: exp.clone(),\n                     id: item.id,\n-                    name: item.ident,\n-                    attrs: item.attrs.iter().map(|x| *x).collect(),\n+                    name: name,\n+                    attrs: item.attrs.clone(),\n                     whence: item.span,\n                     vis: item.vis,\n                     stab: self.stability(item.id),\n@@ -315,25 +300,25 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             },\n             ast::ItemTrait(ref gen, _, ref b, ref items) => {\n                 let t = Trait {\n-                    name: item.ident,\n-                    items: items.iter().map(|x| (*x).clone()).collect(),\n+                    name: name,\n+                    items: items.clone(),\n                     generics: gen.clone(),\n                     bounds: b.iter().map(|x| (*x).clone()).collect(),\n                     id: item.id,\n-                    attrs: item.attrs.iter().map(|x| *x).collect(),\n+                    attrs: item.attrs.clone(),\n                     whence: item.span,\n                     vis: item.vis,\n                     stab: self.stability(item.id),\n                 };\n                 om.traits.push(t);\n             },\n-            ast::ItemImpl(ref gen, ref tr, ty, ref items) => {\n+            ast::ItemImpl(ref gen, ref tr, ref ty, ref items) => {\n                 let i = Impl {\n                     generics: gen.clone(),\n                     trait_: tr.clone(),\n-                    for_: ty,\n-                    items: items.iter().map(|x| *x).collect(),\n-                    attrs: item.attrs.iter().map(|x| *x).collect(),\n+                    for_: ty.clone(),\n+                    items: items.clone(),\n+                    attrs: item.attrs.clone(),\n                     id: item.id,\n                     whence: item.span,\n                     vis: item.vis,\n@@ -354,7 +339,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     fn visit_macro(&self, item: &ast::Item) -> Macro {\n         Macro {\n             id: item.id,\n-            attrs: item.attrs.iter().map(|x| *x).collect(),\n+            attrs: item.attrs.clone(),\n             name: item.ident,\n             whence: item.span,\n             stab: self.stability(item.id),"}, {"sha": "5546f868ba08d4ccb3f1fbedc7bf1aa8c299199e", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 76, "deletions": 92, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -16,25 +16,14 @@ use ast_util;\n use owned_slice::OwnedSlice;\n use parse::token::{InternedString, str_to_ident};\n use parse::token;\n+use ptr::P;\n \n use std::fmt;\n use std::num::Zero;\n use std::fmt::Show;\n-use std::option::Option;\n use std::rc::Rc;\n-use std::gc::{Gc, GC};\n use serialize::{Encodable, Decodable, Encoder, Decoder};\n \n-/// A pointer abstraction.\n-// FIXME(eddyb) #10676 use Rc<T> in the future.\n-pub type P<T> = Gc<T>;\n-\n-#[allow(non_snake_case)]\n-/// Construct a P<T> from a T value.\n-pub fn P<T: 'static>(value: T) -> P<T> {\n-    box(GC) value\n-}\n-\n // FIXME #6993: in librustc, uses of \"ident\" should be replaced\n // by just \"Name\".\n \n@@ -277,23 +266,23 @@ pub struct WherePredicate {\n \n /// The set of MetaItems that define the compilation environment of the crate,\n /// used to drive conditional compilation\n-pub type CrateConfig = Vec<Gc<MetaItem>>;\n+pub type CrateConfig = Vec<P<MetaItem>> ;\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct Crate {\n     pub module: Mod,\n     pub attrs: Vec<Attribute>,\n     pub config: CrateConfig,\n     pub span: Span,\n-    pub exported_macros: Vec<Gc<Item>>\n+    pub exported_macros: Vec<P<Item>>\n }\n \n pub type MetaItem = Spanned<MetaItem_>;\n \n #[deriving(Clone, Eq, Encodable, Decodable, Hash, Show)]\n pub enum MetaItem_ {\n     MetaWord(InternedString),\n-    MetaList(InternedString, Vec<Gc<MetaItem>>),\n+    MetaList(InternedString, Vec<P<MetaItem>>),\n     MetaNameValue(InternedString, Lit),\n }\n \n@@ -325,8 +314,8 @@ impl PartialEq for MetaItem_ {\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct Block {\n     pub view_items: Vec<ViewItem>,\n-    pub stmts: Vec<Gc<Stmt>>,\n-    pub expr: Option<Gc<Expr>>,\n+    pub stmts: Vec<P<Stmt>>,\n+    pub expr: Option<P<Expr>>,\n     pub id: NodeId,\n     pub rules: BlockCheckMode,\n     pub span: Span,\n@@ -342,7 +331,7 @@ pub struct Pat {\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct FieldPat {\n     pub ident: Ident,\n-    pub pat: Gc<Pat>,\n+    pub pat: P<Pat>,\n }\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n@@ -372,20 +361,20 @@ pub enum Pat_ {\n     /// which it is. The resolver determines this, and\n     /// records this pattern's NodeId in an auxiliary\n     /// set (of \"PatIdents that refer to nullary enums\")\n-    PatIdent(BindingMode, SpannedIdent, Option<Gc<Pat>>),\n+    PatIdent(BindingMode, SpannedIdent, Option<P<Pat>>),\n \n     /// \"None\" means a * pattern where we don't bind the fields to names.\n-    PatEnum(Path, Option<Vec<Gc<Pat>>>),\n+    PatEnum(Path, Option<Vec<P<Pat>>>),\n \n     PatStruct(Path, Vec<FieldPat>, bool),\n-    PatTup(Vec<Gc<Pat>>),\n-    PatBox(Gc<Pat>),\n-    PatRegion(Gc<Pat>), // reference pattern\n-    PatLit(Gc<Expr>),\n-    PatRange(Gc<Expr>, Gc<Expr>),\n+    PatTup(Vec<P<Pat>>),\n+    PatBox(P<Pat>),\n+    PatRegion(P<Pat>), // reference pattern\n+    PatLit(P<Expr>),\n+    PatRange(P<Expr>, P<Expr>),\n     /// [a, b, ..i, y, z] is represented as:\n     ///     PatVec(~[a, b], Some(i), ~[y, z])\n-    PatVec(Vec<Gc<Pat>>, Option<Gc<Pat>>, Vec<Gc<Pat>>),\n+    PatVec(Vec<P<Pat>>, Option<P<Pat>>, Vec<P<Pat>>),\n     PatMac(Mac),\n }\n \n@@ -431,13 +420,13 @@ pub type Stmt = Spanned<Stmt_>;\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum Stmt_ {\n     /// Could be an item or a local (let) binding:\n-    StmtDecl(Gc<Decl>, NodeId),\n+    StmtDecl(P<Decl>, NodeId),\n \n     /// Expr without trailing semi-colon (must have unit type):\n-    StmtExpr(Gc<Expr>, NodeId),\n+    StmtExpr(P<Expr>, NodeId),\n \n     /// Expr with trailing semi-colon (may have any type):\n-    StmtSemi(Gc<Expr>, NodeId),\n+    StmtSemi(P<Expr>, NodeId),\n \n     /// bool: is there a trailing sem-colon?\n     StmtMac(Mac, bool),\n@@ -457,8 +446,8 @@ pub enum LocalSource {\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct Local {\n     pub ty: P<Ty>,\n-    pub pat: Gc<Pat>,\n-    pub init: Option<Gc<Expr>>,\n+    pub pat: P<Pat>,\n+    pub init: Option<P<Expr>>,\n     pub id: NodeId,\n     pub span: Span,\n     pub source: LocalSource,\n@@ -469,24 +458,24 @@ pub type Decl = Spanned<Decl_>;\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum Decl_ {\n     /// A local (let) binding:\n-    DeclLocal(Gc<Local>),\n+    DeclLocal(P<Local>),\n     /// An item binding:\n-    DeclItem(Gc<Item>),\n+    DeclItem(P<Item>),\n }\n \n /// represents one arm of a 'match'\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct Arm {\n     pub attrs: Vec<Attribute>,\n-    pub pats: Vec<Gc<Pat>>,\n-    pub guard: Option<Gc<Expr>>,\n-    pub body: Gc<Expr>,\n+    pub pats: Vec<P<Pat>>,\n+    pub guard: Option<P<Expr>>,\n+    pub body: P<Expr>,\n }\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct Field {\n     pub ident: SpannedIdent,\n-    pub expr: Gc<Expr>,\n+    pub expr: P<Expr>,\n     pub span: Span,\n }\n \n@@ -514,56 +503,56 @@ pub struct Expr {\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum Expr_ {\n     /// First expr is the place; second expr is the value.\n-    ExprBox(Gc<Expr>, Gc<Expr>),\n-    ExprVec(Vec<Gc<Expr>>),\n-    ExprCall(Gc<Expr>, Vec<Gc<Expr>>),\n-    ExprMethodCall(SpannedIdent, Vec<P<Ty>>, Vec<Gc<Expr>>),\n-    ExprTup(Vec<Gc<Expr>>),\n-    ExprBinary(BinOp, Gc<Expr>, Gc<Expr>),\n-    ExprUnary(UnOp, Gc<Expr>),\n-    ExprLit(Gc<Lit>),\n-    ExprCast(Gc<Expr>, P<Ty>),\n-    ExprIf(Gc<Expr>, P<Block>, Option<Gc<Expr>>),\n+    ExprBox(P<Expr>, P<Expr>),\n+    ExprVec(Vec<P<Expr>>),\n+    ExprCall(P<Expr>, Vec<P<Expr>>),\n+    ExprMethodCall(SpannedIdent, Vec<P<Ty>>, Vec<P<Expr>>),\n+    ExprTup(Vec<P<Expr>>),\n+    ExprBinary(BinOp, P<Expr>, P<Expr>),\n+    ExprUnary(UnOp, P<Expr>),\n+    ExprLit(P<Lit>),\n+    ExprCast(P<Expr>, P<Ty>),\n+    ExprIf(P<Expr>, P<Block>, Option<P<Expr>>),\n     // FIXME #6993: change to Option<Name> ... or not, if these are hygienic.\n-    ExprWhile(Gc<Expr>, P<Block>, Option<Ident>),\n+    ExprWhile(P<Expr>, P<Block>, Option<Ident>),\n     // FIXME #6993: change to Option<Name> ... or not, if these are hygienic.\n-    ExprForLoop(Gc<Pat>, Gc<Expr>, P<Block>, Option<Ident>),\n+    ExprForLoop(P<Pat>, P<Expr>, P<Block>, Option<Ident>),\n     // Conditionless loop (can be exited with break, cont, or ret)\n     // FIXME #6993: change to Option<Name> ... or not, if these are hygienic.\n     ExprLoop(P<Block>, Option<Ident>),\n-    ExprMatch(Gc<Expr>, Vec<Arm>),\n+    ExprMatch(P<Expr>, Vec<Arm>),\n     ExprFnBlock(CaptureClause, P<FnDecl>, P<Block>),\n     ExprProc(P<FnDecl>, P<Block>),\n     ExprUnboxedFn(CaptureClause, UnboxedClosureKind, P<FnDecl>, P<Block>),\n     ExprBlock(P<Block>),\n \n-    ExprAssign(Gc<Expr>, Gc<Expr>),\n-    ExprAssignOp(BinOp, Gc<Expr>, Gc<Expr>),\n-    ExprField(Gc<Expr>, SpannedIdent, Vec<P<Ty>>),\n-    ExprTupField(Gc<Expr>, Spanned<uint>, Vec<P<Ty>>),\n-    ExprIndex(Gc<Expr>, Gc<Expr>),\n+    ExprAssign(P<Expr>, P<Expr>),\n+    ExprAssignOp(BinOp, P<Expr>, P<Expr>),\n+    ExprField(P<Expr>, SpannedIdent, Vec<P<Ty>>),\n+    ExprTupField(P<Expr>, Spanned<uint>, Vec<P<Ty>>),\n+    ExprIndex(P<Expr>, P<Expr>),\n \n     /// Variable reference, possibly containing `::` and/or\n     /// type parameters, e.g. foo::bar::<baz>\n     ExprPath(Path),\n \n-    ExprAddrOf(Mutability, Gc<Expr>),\n+    ExprAddrOf(Mutability, P<Expr>),\n     ExprBreak(Option<Ident>),\n     ExprAgain(Option<Ident>),\n-    ExprRet(Option<Gc<Expr>>),\n+    ExprRet(Option<P<Expr>>),\n \n     ExprInlineAsm(InlineAsm),\n \n     ExprMac(Mac),\n \n     /// A struct literal expression.\n-    ExprStruct(Path, Vec<Field> , Option<Gc<Expr>> /* base */),\n+    ExprStruct(Path, Vec<Field>, Option<P<Expr>> /* base */),\n \n     /// A vector literal constructed from one repeated element.\n-    ExprRepeat(Gc<Expr> /* element */, Gc<Expr> /* count */),\n+    ExprRepeat(P<Expr> /* element */, P<Expr> /* count */),\n \n     /// No-op: used solely so we can pretty-print faithfully\n-    ExprParen(Gc<Expr>)\n+    ExprParen(P<Expr>)\n }\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n@@ -776,12 +765,12 @@ pub struct TypeMethod {\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum TraitItem {\n     RequiredMethod(TypeMethod),\n-    ProvidedMethod(Gc<Method>),\n+    ProvidedMethod(P<Method>),\n }\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum ImplItem {\n-    MethodImplItem(Gc<Method>),\n+    MethodImplItem(P<Method>),\n }\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n@@ -889,7 +878,7 @@ impl fmt::Show for Onceness {\n }\n \n /// Represents the type of a closure\n-#[deriving(PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct ClosureTy {\n     pub lifetimes: Vec<LifetimeDef>,\n     pub fn_style: FnStyle,\n@@ -898,7 +887,7 @@ pub struct ClosureTy {\n     pub bounds: TyParamBounds,\n }\n \n-#[deriving(PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct BareFnTy {\n     pub fn_style: FnStyle,\n     pub abi: Abi,\n@@ -919,18 +908,18 @@ pub enum Ty_ {\n     TyBox(P<Ty>),\n     TyUniq(P<Ty>),\n     TyVec(P<Ty>),\n-    TyFixedLengthVec(P<Ty>, Gc<Expr>),\n+    TyFixedLengthVec(P<Ty>, P<Expr>),\n     TyPtr(MutTy),\n     TyRptr(Option<Lifetime>, MutTy),\n-    TyClosure(Gc<ClosureTy>),\n-    TyProc(Gc<ClosureTy>),\n-    TyBareFn(Gc<BareFnTy>),\n-    TyUnboxedFn(Gc<UnboxedFnTy>),\n+    TyClosure(P<ClosureTy>),\n+    TyProc(P<ClosureTy>),\n+    TyBareFn(P<BareFnTy>),\n+    TyUnboxedFn(P<UnboxedFnTy>),\n     TyTup(Vec<P<Ty>> ),\n     TyPath(Path, Option<TyParamBounds>, NodeId), // for #7264; see above\n     /// No-op; kept solely so that we can pretty-print faithfully\n     TyParen(P<Ty>),\n-    TyTypeof(Gc<Expr>),\n+    TyTypeof(P<Expr>),\n     /// TyInfer means the type should be inferred instead of it having been\n     /// specified. This can appear anywhere in a type.\n     TyInfer,\n@@ -946,8 +935,8 @@ pub enum AsmDialect {\n pub struct InlineAsm {\n     pub asm: InternedString,\n     pub asm_str_style: StrStyle,\n-    pub outputs: Vec<(InternedString, Gc<Expr>, bool)>,\n-    pub inputs: Vec<(InternedString, Gc<Expr>)>,\n+    pub outputs: Vec<(InternedString, P<Expr>, bool)>,\n+    pub inputs: Vec<(InternedString, P<Expr>)>,\n     pub clobbers: InternedString,\n     pub volatile: bool,\n     pub alignstack: bool,\n@@ -958,7 +947,7 @@ pub struct InlineAsm {\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct Arg {\n     pub ty: P<Ty>,\n-    pub pat: Gc<Pat>,\n+    pub pat: P<Pat>,\n     pub id: NodeId,\n }\n \n@@ -972,11 +961,11 @@ impl Arg {\n                 node: TyInfer,\n                 span: DUMMY_SP,\n             }),\n-            pat: box(GC) Pat {\n+            pat: P(Pat {\n                 id: DUMMY_NODE_ID,\n                 node: PatIdent(BindByValue(mutability), path, None),\n                 span: span\n-            },\n+            }),\n             id: DUMMY_NODE_ID\n         }\n     }\n@@ -1062,14 +1051,14 @@ pub struct Mod {\n     /// to the last token in the external file.\n     pub inner: Span,\n     pub view_items: Vec<ViewItem>,\n-    pub items: Vec<Gc<Item>>,\n+    pub items: Vec<P<Item>>,\n }\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct ForeignMod {\n     pub abi: Abi,\n     pub view_items: Vec<ViewItem>,\n-    pub items: Vec<Gc<ForeignItem>>,\n+    pub items: Vec<P<ForeignItem>>,\n }\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n@@ -1081,7 +1070,7 @@ pub struct VariantArg {\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum VariantKind {\n     TupleVariantKind(Vec<VariantArg>),\n-    StructVariantKind(Gc<StructDef>),\n+    StructVariantKind(P<StructDef>),\n }\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n@@ -1095,7 +1084,7 @@ pub struct Variant_ {\n     pub attrs: Vec<Attribute>,\n     pub kind: VariantKind,\n     pub id: NodeId,\n-    pub disr_expr: Option<Gc<Expr>>,\n+    pub disr_expr: Option<P<Expr>>,\n     pub vis: Visibility,\n }\n \n@@ -1151,7 +1140,7 @@ pub enum ViewItem_ {\n     /// (containing arbitrary characters) from which to fetch the crate sources\n     /// For example, extern crate whatever = \"github.com/rust-lang/rust\"\n     ViewItemExternCrate(Ident, Option<(InternedString,StrStyle)>, NodeId),\n-    ViewItemUse(Gc<ViewPath>),\n+    ViewItemUse(P<ViewPath>),\n }\n \n /// Meta-data associated with an item\n@@ -1174,7 +1163,7 @@ pub struct AttrId(pub uint);\n pub struct Attribute_ {\n     pub id: AttrId,\n     pub style: AttrStyle,\n-    pub value: Gc<MetaItem>,\n+    pub value: P<MetaItem>,\n     pub is_sugared_doc: bool,\n }\n \n@@ -1269,13 +1258,13 @@ pub struct Item {\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum Item_ {\n-    ItemStatic(P<Ty>, Mutability, Gc<Expr>),\n+    ItemStatic(P<Ty>, Mutability, P<Expr>),\n     ItemFn(P<FnDecl>, FnStyle, Abi, Generics, P<Block>),\n     ItemMod(Mod),\n     ItemForeignMod(ForeignMod),\n     ItemTy(P<Ty>, Generics),\n     ItemEnum(EnumDef, Generics),\n-    ItemStruct(Gc<StructDef>, Generics),\n+    ItemStruct(P<StructDef>, Generics),\n     /// Represents a Trait Declaration\n     ItemTrait(Generics,\n               Option<TyParamBound>, // (optional) default bound not required for Self.\n@@ -1318,15 +1307,10 @@ pub enum UnboxedClosureKind {\n /// that we trans.\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum InlinedItem {\n-    IIItem(Gc<Item>),\n-    IITraitItem(DefId /* impl id */, InlinedTraitItem),\n-    IIForeign(Gc<ForeignItem>),\n-}\n-\n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n-pub enum InlinedTraitItem {\n-    ProvidedInlinedTraitItem(Gc<Method>),\n-    RequiredInlinedTraitItem(Gc<Method>),\n+    IIItem(P<Item>),\n+    IITraitItem(DefId /* impl id */, TraitItem),\n+    IIImplItem(DefId /* impl id */, ImplItem),\n+    IIForeign(P<ForeignItem>),\n }\n \n #[cfg(test)]"}, {"sha": "1400e494917f1ad13612d9a1fe0de6993b387720", "filename": "src/libsyntax/ast_map/blocks.rs", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fast_map%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fast_map%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fblocks.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -22,7 +22,7 @@\n //! for the `Code` associated with a particular NodeId.\n \n use abi;\n-use ast::{P, Block, FnDecl, NodeId};\n+use ast::{Block, FnDecl, NodeId};\n use ast;\n use ast_map::{Node};\n use ast_map;\n@@ -39,16 +39,16 @@ use visit;\n ///   - The default implementation for a trait method.\n ///\n /// To construct one, use the `Code::from_node` function.\n-pub struct FnLikeNode { node: ast_map::Node }\n+pub struct FnLikeNode<'a> { node: ast_map::Node<'a> }\n \n /// MaybeFnLike wraps a method that indicates if an object\n /// corresponds to some FnLikeNode.\n pub trait MaybeFnLike { fn is_fn_like(&self) -> bool; }\n \n /// Components shared by fn-like things (fn items, methods, closures).\n pub struct FnParts<'a> {\n-    pub decl: P<FnDecl>,\n-    pub body: P<Block>,\n+    pub decl: &'a FnDecl,\n+    pub body: &'a Block,\n     pub kind: visit::FnKind<'a>,\n     pub span: Span,\n     pub id:   NodeId,\n@@ -78,12 +78,12 @@ impl MaybeFnLike for ast::Expr {\n /// Carries either an FnLikeNode or a Block, as these are the two\n /// constructs that correspond to \"code\" (as in, something from which\n /// we can construct a control-flow graph).\n-pub enum Code {\n-    FnLikeCode(FnLikeNode),\n-    BlockCode(P<Block>),\n+pub enum Code<'a> {\n+    FnLikeCode(FnLikeNode<'a>),\n+    BlockCode(&'a Block),\n }\n \n-impl Code {\n+impl<'a> Code<'a> {\n     pub fn id(&self) -> ast::NodeId {\n         match *self {\n             FnLikeCode(node) => node.id(),\n@@ -115,32 +115,32 @@ impl Code {\n /// use when implementing FnLikeNode operations.\n struct ItemFnParts<'a> {\n     ident:    ast::Ident,\n-    decl:     P<ast::FnDecl>,\n+    decl:     &'a ast::FnDecl,\n     style:    ast::FnStyle,\n     abi:      abi::Abi,\n     generics: &'a ast::Generics,\n-    body:     P<Block>,\n+    body:     &'a Block,\n     id:       ast::NodeId,\n     span:     Span\n }\n \n /// These are all the components one can extract from a closure expr\n /// for use when implementing FnLikeNode operations.\n-struct ClosureParts {\n-    decl: P<FnDecl>,\n-    body: P<Block>,\n+struct ClosureParts<'a> {\n+    decl: &'a FnDecl,\n+    body: &'a Block,\n     id: NodeId,\n     span: Span\n }\n \n-impl ClosureParts {\n-    fn new(d: P<FnDecl>, b: P<Block>, id: NodeId, s: Span) -> ClosureParts {\n+impl<'a> ClosureParts<'a> {\n+    fn new(d: &'a FnDecl, b: &'a Block, id: NodeId, s: Span) -> ClosureParts<'a> {\n         ClosureParts { decl: d, body: b, id: id, span: s }\n     }\n }\n \n-impl FnLikeNode {\n-    pub fn to_fn_parts<'a>(&'a self) -> FnParts<'a> {\n+impl<'a> FnLikeNode<'a> {\n+    pub fn to_fn_parts(self) -> FnParts<'a> {\n         FnParts {\n             decl: self.decl(),\n             body: self.body(),\n@@ -150,31 +150,31 @@ impl FnLikeNode {\n         }\n     }\n \n-    pub fn body<'a>(&'a self) -> P<Block> {\n-        self.handle(|i: ItemFnParts|     i.body,\n-                    |m: &'a ast::Method| m.pe_body(),\n-                    |c: ClosureParts|    c.body)\n+    pub fn body(self) -> &'a Block {\n+        self.handle(|i: ItemFnParts<'a>|  &*i.body,\n+                    |m: &'a ast::Method|  m.pe_body(),\n+                    |c: ClosureParts<'a>| c.body)\n     }\n \n-    pub fn decl<'a>(&'a self) -> P<FnDecl> {\n-        self.handle(|i: ItemFnParts|     i.decl,\n-                    |m: &'a ast::Method| m.pe_fn_decl(),\n-                    |c: ClosureParts|    c.decl)\n+    pub fn decl(self) -> &'a FnDecl {\n+        self.handle(|i: ItemFnParts<'a>|  &*i.decl,\n+                    |m: &'a ast::Method|  m.pe_fn_decl(),\n+                    |c: ClosureParts<'a>| c.decl)\n     }\n \n-    pub fn span<'a>(&'a self) -> Span {\n+    pub fn span(self) -> Span {\n         self.handle(|i: ItemFnParts|     i.span,\n                     |m: &'a ast::Method| m.span,\n                     |c: ClosureParts|    c.span)\n     }\n \n-    pub fn id<'a>(&'a self) -> NodeId {\n+    pub fn id(self) -> NodeId {\n         self.handle(|i: ItemFnParts|     i.id,\n                     |m: &'a ast::Method| m.id,\n                     |c: ClosureParts|    c.id)\n     }\n \n-    pub fn kind<'a>(&'a self) -> visit::FnKind<'a> {\n+    pub fn kind(self) -> visit::FnKind<'a> {\n         let item = |p: ItemFnParts<'a>| -> visit::FnKind<'a> {\n             visit::FkItemFn(p.ident, p.generics, p.style, p.abi)\n         };\n@@ -187,33 +187,33 @@ impl FnLikeNode {\n         self.handle(item, method, closure)\n     }\n \n-    fn handle<'a, A>(&'a self,\n-                     item_fn: |ItemFnParts<'a>| -> A,\n-                     method: |&'a ast::Method| -> A,\n-                     closure: |ClosureParts| -> A) -> A {\n+    fn handle<A>(self,\n+                 item_fn: |ItemFnParts<'a>| -> A,\n+                 method: |&'a ast::Method| -> A,\n+                 closure: |ClosureParts<'a>| -> A) -> A {\n         match self.node {\n-            ast_map::NodeItem(ref i) => match i.node {\n-                ast::ItemFn(decl, style, abi, ref generics, block) =>\n+            ast_map::NodeItem(i) => match i.node {\n+                ast::ItemFn(ref decl, style, abi, ref generics, ref block) =>\n                     item_fn(ItemFnParts{\n-                        ident: i.ident, decl: decl, style: style, body: block,\n+                        ident: i.ident, decl: &**decl, style: style, body: &**block,\n                         generics: generics, abi: abi, id: i.id, span: i.span\n                     }),\n                 _ => fail!(\"item FnLikeNode that is not fn-like\"),\n             },\n-            ast_map::NodeTraitItem(ref t) => match **t {\n+            ast_map::NodeTraitItem(t) => match *t {\n                 ast::ProvidedMethod(ref m) => method(&**m),\n                 _ => fail!(\"trait method FnLikeNode that is not fn-like\"),\n             },\n-            ast_map::NodeImplItem(ref ii) => {\n-                match **ii {\n+            ast_map::NodeImplItem(ii) => {\n+                match *ii {\n                     ast::MethodImplItem(ref m) => method(&**m),\n                 }\n             }\n-            ast_map::NodeExpr(ref e) => match e.node {\n+            ast_map::NodeExpr(e) => match e.node {\n                 ast::ExprFnBlock(_, ref decl, ref block) =>\n-                    closure(ClosureParts::new(*decl, *block, e.id, e.span)),\n+                    closure(ClosureParts::new(&**decl, &**block, e.id, e.span)),\n                 ast::ExprProc(ref decl, ref block) =>\n-                    closure(ClosureParts::new(*decl, *block, e.id, e.span)),\n+                    closure(ClosureParts::new(&**decl, &**block, e.id, e.span)),\n                 _ => fail!(\"expr FnLikeNode that is not fn-like\"),\n             },\n             _ => fail!(\"other FnLikeNode that is not fn-like\"),"}, {"sha": "20594a428481ec0a21d7f3bb29f69835ab1d4685", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 343, "deletions": 251, "changes": 594, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -11,18 +11,19 @@\n use abi;\n use ast::*;\n use ast_util;\n-use codemap::{Span, Spanned};\n+use ast_util::PostExpansionMethod;\n+use codemap::{DUMMY_SP, Span, Spanned};\n use fold::Folder;\n-use fold;\n use parse::token;\n use print::pprust;\n-use util::small_vector::SmallVector;\n+use visit::{mod, Visitor};\n \n+use arena::TypedArena;\n use std::cell::RefCell;\n use std::fmt;\n-use std::gc::{Gc, GC};\n use std::io::IoResult;\n use std::iter;\n+use std::mem;\n use std::slice;\n \n pub mod blocks;\n@@ -95,62 +96,85 @@ pub fn path_to_string<PI: Iterator<PathElem>>(mut path: PI) -> String {\n     }).to_string()\n }\n \n-#[deriving(Clone)]\n-pub enum Node {\n-    NodeItem(Gc<Item>),\n-    NodeForeignItem(Gc<ForeignItem>),\n-    NodeTraitItem(Gc<TraitItem>),\n-    NodeImplItem(Gc<ImplItem>),\n-    NodeVariant(P<Variant>),\n-    NodeExpr(Gc<Expr>),\n-    NodeStmt(Gc<Stmt>),\n-    NodeArg(Gc<Pat>),\n-    NodeLocal(Gc<Pat>),\n-    NodePat(Gc<Pat>),\n-    NodeBlock(P<Block>),\n+pub enum Node<'ast> {\n+    NodeItem(&'ast Item),\n+    NodeForeignItem(&'ast ForeignItem),\n+    NodeTraitItem(&'ast TraitItem),\n+    NodeImplItem(&'ast ImplItem),\n+    NodeVariant(&'ast Variant),\n+    NodeExpr(&'ast Expr),\n+    NodeStmt(&'ast Stmt),\n+    NodeArg(&'ast Pat),\n+    NodeLocal(&'ast Pat),\n+    NodePat(&'ast Pat),\n+    NodeBlock(&'ast Block),\n \n     /// NodeStructCtor represents a tuple struct.\n-    NodeStructCtor(Gc<StructDef>),\n+    NodeStructCtor(&'ast StructDef),\n \n-    NodeLifetime(Gc<Lifetime>),\n+    NodeLifetime(&'ast Lifetime),\n }\n \n /// Represents an entry and its parent Node ID\n /// The odd layout is to bring down the total size.\n-#[deriving(Clone)]\n-enum MapEntry {\n+#[deriving(Show)]\n+enum MapEntry<'ast> {\n     /// Placeholder for holes in the map.\n     NotPresent,\n \n     /// All the node types, with a parent ID.\n-    EntryItem(NodeId, Gc<Item>),\n-    EntryForeignItem(NodeId, Gc<ForeignItem>),\n-    EntryTraitItem(NodeId, Gc<TraitItem>),\n-    EntryImplItem(NodeId, Gc<ImplItem>),\n-    EntryVariant(NodeId, P<Variant>),\n-    EntryExpr(NodeId, Gc<Expr>),\n-    EntryStmt(NodeId, Gc<Stmt>),\n-    EntryArg(NodeId, Gc<Pat>),\n-    EntryLocal(NodeId, Gc<Pat>),\n-    EntryPat(NodeId, Gc<Pat>),\n-    EntryBlock(NodeId, P<Block>),\n-    EntryStructCtor(NodeId, Gc<StructDef>),\n-    EntryLifetime(NodeId, Gc<Lifetime>),\n+    EntryItem(NodeId, &'ast Item),\n+    EntryForeignItem(NodeId, &'ast ForeignItem),\n+    EntryTraitItem(NodeId, &'ast TraitItem),\n+    EntryImplItem(NodeId, &'ast ImplItem),\n+    EntryVariant(NodeId, &'ast Variant),\n+    EntryExpr(NodeId, &'ast Expr),\n+    EntryStmt(NodeId, &'ast Stmt),\n+    EntryArg(NodeId, &'ast Pat),\n+    EntryLocal(NodeId, &'ast Pat),\n+    EntryPat(NodeId, &'ast Pat),\n+    EntryBlock(NodeId, &'ast Block),\n+    EntryStructCtor(NodeId, &'ast StructDef),\n+    EntryLifetime(NodeId, &'ast Lifetime),\n \n     /// Roots for node trees.\n     RootCrate,\n-    RootInlinedParent(P<InlinedParent>)\n+    RootInlinedParent(&'ast InlinedParent)\n+}\n+\n+impl<'ast> Clone for MapEntry<'ast> {\n+    fn clone(&self) -> MapEntry<'ast> {\n+        *self\n+    }\n }\n \n+#[deriving(Show)]\n struct InlinedParent {\n-    path: Vec<PathElem> ,\n-    /// RequiredMethod by NodeTraitItem and NodeImplItem.\n-    def_id: DefId\n+    path: Vec<PathElem>,\n+    ii: InlinedItem\n }\n \n-impl MapEntry {\n-    fn parent(&self) -> Option<NodeId> {\n-        Some(match *self {\n+impl<'ast> MapEntry<'ast> {\n+    fn from_node(p: NodeId, node: Node<'ast>) -> MapEntry<'ast> {\n+        match node {\n+            NodeItem(n) => EntryItem(p, n),\n+            NodeForeignItem(n) => EntryForeignItem(p, n),\n+            NodeTraitItem(n) => EntryTraitItem(p, n),\n+            NodeImplItem(n) => EntryImplItem(p, n),\n+            NodeVariant(n) => EntryVariant(p, n),\n+            NodeExpr(n) => EntryExpr(p, n),\n+            NodeStmt(n) => EntryStmt(p, n),\n+            NodeArg(n) => EntryArg(p, n),\n+            NodeLocal(n) => EntryLocal(p, n),\n+            NodePat(n) => EntryPat(p, n),\n+            NodeBlock(n) => EntryBlock(p, n),\n+            NodeStructCtor(n) => EntryStructCtor(p, n),\n+            NodeLifetime(n) => EntryLifetime(p, n)\n+        }\n+    }\n+\n+    fn parent(self) -> Option<NodeId> {\n+        Some(match self {\n             EntryItem(id, _) => id,\n             EntryForeignItem(id, _) => id,\n             EntryTraitItem(id, _) => id,\n@@ -168,29 +192,51 @@ impl MapEntry {\n         })\n     }\n \n-    fn to_node(&self) -> Option<Node> {\n-        Some(match *self {\n-            EntryItem(_, p) => NodeItem(p),\n-            EntryForeignItem(_, p) => NodeForeignItem(p),\n-            EntryTraitItem(_, p) => NodeTraitItem(p),\n-            EntryImplItem(_, p) => NodeImplItem(p),\n-            EntryVariant(_, p) => NodeVariant(p),\n-            EntryExpr(_, p) => NodeExpr(p),\n-            EntryStmt(_, p) => NodeStmt(p),\n-            EntryArg(_, p) => NodeArg(p),\n-            EntryLocal(_, p) => NodeLocal(p),\n-            EntryPat(_, p) => NodePat(p),\n-            EntryBlock(_, p) => NodeBlock(p),\n-            EntryStructCtor(_, p) => NodeStructCtor(p),\n-            EntryLifetime(_, p) => NodeLifetime(p),\n+    fn to_node(self) -> Option<Node<'ast>> {\n+        Some(match self {\n+            EntryItem(_, n) => NodeItem(n),\n+            EntryForeignItem(_, n) => NodeForeignItem(n),\n+            EntryTraitItem(_, n) => NodeTraitItem(n),\n+            EntryImplItem(_, n) => NodeImplItem(n),\n+            EntryVariant(_, n) => NodeVariant(n),\n+            EntryExpr(_, n) => NodeExpr(n),\n+            EntryStmt(_, n) => NodeStmt(n),\n+            EntryArg(_, n) => NodeArg(n),\n+            EntryLocal(_, n) => NodeLocal(n),\n+            EntryPat(_, n) => NodePat(n),\n+            EntryBlock(_, n) => NodeBlock(n),\n+            EntryStructCtor(_, n) => NodeStructCtor(n),\n+            EntryLifetime(_, n) => NodeLifetime(n),\n             _ => return None\n         })\n     }\n }\n \n+/// Stores a crate and any number of inlined items from other crates.\n+pub struct Forest {\n+    krate: Crate,\n+    inlined_items: TypedArena<InlinedParent>\n+}\n+\n+impl Forest {\n+    pub fn new(krate: Crate) -> Forest {\n+        Forest {\n+            krate: krate,\n+            inlined_items: TypedArena::new()\n+        }\n+    }\n+\n+    pub fn krate<'ast>(&'ast self) -> &'ast Crate {\n+        &self.krate\n+    }\n+}\n+\n /// Represents a mapping from Node IDs to AST elements and their parent\n /// Node IDs\n-pub struct Map {\n+pub struct Map<'ast> {\n+    /// The backing storage for all the AST nodes.\n+    forest: &'ast Forest,\n+\n     /// NodeIds are sequential integers from 0, so we can be\n     /// super-compact by storing them in a vector. Not everything with\n     /// a NodeId is in the map, but empirically the occupancy is about\n@@ -200,26 +246,25 @@ pub struct Map {\n     ///\n     /// Also, indexing is pretty quick when you've got a vector and\n     /// plain old integers.\n-    map: RefCell<Vec<MapEntry> >\n+    map: RefCell<Vec<MapEntry<'ast>>>\n }\n \n-impl Map {\n+impl<'ast> Map<'ast> {\n     fn entry_count(&self) -> uint {\n         self.map.borrow().len()\n     }\n \n-    fn find_entry(&self, id: NodeId) -> Option<MapEntry> {\n-        let map = self.map.borrow();\n-        if map.len() > id as uint {\n-            Some(*map.get(id as uint))\n-        } else {\n-            None\n-        }\n+    fn find_entry(&self, id: NodeId) -> Option<MapEntry<'ast>> {\n+        self.map.borrow().as_slice().get(id as uint).map(|e| *e)\n+    }\n+\n+    pub fn krate(&self) -> &'ast Crate {\n+        &self.forest.krate\n     }\n \n     /// Retrieve the Node corresponding to `id`, failing if it cannot\n     /// be found.\n-    pub fn get(&self, id: NodeId) -> Node {\n+    pub fn get(&self, id: NodeId) -> Node<'ast> {\n         match self.find(id) {\n             Some(node) => node,\n             None => fail!(\"couldn't find node id {} in the AST map\", id)\n@@ -228,7 +273,7 @@ impl Map {\n \n     /// Retrieve the Node corresponding to `id`, returning None if\n     /// cannot be found.\n-    pub fn find(&self, id: NodeId) -> Option<Node> {\n+    pub fn find(&self, id: NodeId) -> Option<Node<'ast>> {\n         self.find_entry(id).and_then(|x| x.to_node())\n     }\n \n@@ -241,18 +286,21 @@ impl Map {\n     pub fn get_parent_did(&self, id: NodeId) -> DefId {\n         let parent = self.get_parent(id);\n         match self.find_entry(parent) {\n-            Some(RootInlinedParent(data)) => data.def_id,\n+            Some(RootInlinedParent(&InlinedParent {ii: IITraitItem(did, _), ..})) => did,\n+            Some(RootInlinedParent(&InlinedParent {ii: IIImplItem(did, _), ..})) => did,\n             _ => ast_util::local_def(parent)\n         }\n     }\n \n     pub fn get_foreign_abi(&self, id: NodeId) -> abi::Abi {\n         let parent = self.get_parent(id);\n         let abi = match self.find_entry(parent) {\n-            Some(EntryItem(_, i)) => match i.node {\n-                ItemForeignMod(ref nm) => Some(nm.abi),\n-                _ => None\n-            },\n+            Some(EntryItem(_, i)) => {\n+                match i.node {\n+                    ItemForeignMod(ref nm) => Some(nm.abi),\n+                    _ => None\n+                }\n+            }\n             /// Wrong but OK, because the only inlined foreign items are intrinsics.\n             Some(RootInlinedParent(_)) => Some(abi::RustIntrinsic),\n             _ => None\n@@ -272,45 +320,52 @@ impl Map {\n         }\n     }\n \n-    pub fn expect_item(&self, id: NodeId) -> Gc<Item> {\n+    pub fn expect_item(&self, id: NodeId) -> &'ast Item {\n         match self.find(id) {\n             Some(NodeItem(item)) => item,\n             _ => fail!(\"expected item, found {}\", self.node_to_string(id))\n         }\n     }\n \n-    pub fn expect_struct(&self, id: NodeId) -> Gc<StructDef> {\n+    pub fn expect_struct(&self, id: NodeId) -> &'ast StructDef {\n         match self.find(id) {\n             Some(NodeItem(i)) => {\n                 match i.node {\n-                    ItemStruct(struct_def, _) => struct_def,\n+                    ItemStruct(ref struct_def, _) => &**struct_def,\n                     _ => fail!(\"struct ID bound to non-struct\")\n                 }\n             }\n-            Some(NodeVariant(ref variant)) => {\n-                match (*variant).node.kind {\n-                    StructVariantKind(struct_def) => struct_def,\n+            Some(NodeVariant(variant)) => {\n+                match variant.node.kind {\n+                    StructVariantKind(ref struct_def) => &**struct_def,\n                     _ => fail!(\"struct ID bound to enum variant that isn't struct-like\"),\n                 }\n             }\n             _ => fail!(format!(\"expected struct, found {}\", self.node_to_string(id))),\n         }\n     }\n \n-    pub fn expect_variant(&self, id: NodeId) -> P<Variant> {\n+    pub fn expect_variant(&self, id: NodeId) -> &'ast Variant {\n         match self.find(id) {\n             Some(NodeVariant(variant)) => variant,\n             _ => fail!(format!(\"expected variant, found {}\", self.node_to_string(id))),\n         }\n     }\n \n-    pub fn expect_foreign_item(&self, id: NodeId) -> Gc<ForeignItem> {\n+    pub fn expect_foreign_item(&self, id: NodeId) -> &'ast ForeignItem {\n         match self.find(id) {\n             Some(NodeForeignItem(item)) => item,\n             _ => fail!(\"expected foreign item, found {}\", self.node_to_string(id))\n         }\n     }\n \n+    pub fn expect_expr(&self, id: NodeId) -> &'ast Expr {\n+        match self.find(id) {\n+            Some(NodeExpr(expr)) => expr,\n+            _ => fail!(\"expected expr, found {}\", self.node_to_string(id))\n+        }\n+    }\n+\n     /// returns the name associated with the given NodeId's AST\n     pub fn get_path_elem(&self, id: NodeId) -> PathElem {\n         let node = self.get(id);\n@@ -340,7 +395,7 @@ impl Map {\n             },\n             NodeTraitItem(tm) => match *tm {\n                 RequiredMethod(ref m) => PathName(m.ident.name),\n-                ProvidedMethod(m) => match m.node {\n+                ProvidedMethod(ref m) => match m.node {\n                     MethDecl(ident, _, _, _, _, _, _, _) => {\n                         PathName(ident.name)\n                     }\n@@ -399,10 +454,9 @@ impl Map {\n     /// Given a node ID and a closure, apply the closure to the array\n     /// of attributes associated with the AST corresponding to the Node ID\n     pub fn with_attrs<T>(&self, id: NodeId, f: |Option<&[Attribute]>| -> T) -> T {\n-        let node = self.get(id);\n-        let attrs = match node {\n-            NodeItem(ref i) => Some(i.attrs.as_slice()),\n-            NodeForeignItem(ref fi) => Some(fi.attrs.as_slice()),\n+        let attrs = match self.get(id) {\n+            NodeItem(i) => Some(i.attrs.as_slice()),\n+            NodeForeignItem(fi) => Some(fi.attrs.as_slice()),\n             NodeTraitItem(ref tm) => match **tm {\n                 RequiredMethod(ref type_m) => Some(type_m.attrs.as_slice()),\n                 ProvidedMethod(ref m) => Some(m.attrs.as_slice())\n@@ -432,7 +486,7 @@ impl Map {\n     /// such as `foo::bar::quux`, `bar::quux`, `other::bar::quux`, and\n     /// any other such items it can find in the map.\n     pub fn nodes_matching_suffix<'a, S:Str>(&'a self, parts: &'a [S])\n-                                 -> NodesMatchingSuffix<'a,S> {\n+                                 -> NodesMatchingSuffix<'a, 'ast, S> {\n         NodesMatchingSuffix {\n             map: self,\n             item_name: parts.last().unwrap(),\n@@ -478,14 +532,14 @@ impl Map {\n     }\n }\n \n-pub struct NodesMatchingSuffix<'a, S:'a> {\n-    map: &'a Map,\n+pub struct NodesMatchingSuffix<'a, 'ast:'a, S:'a> {\n+    map: &'a Map<'ast>,\n     item_name: &'a S,\n     in_which: &'a [S],\n     idx: NodeId,\n }\n \n-impl<'a,S:Str> NodesMatchingSuffix<'a,S> {\n+impl<'a, 'ast, S:Str> NodesMatchingSuffix<'a, 'ast, S> {\n     /// Returns true only if some suffix of the module path for parent\n     /// matches `self.in_which`.\n     ///\n@@ -542,7 +596,7 @@ impl<'a,S:Str> NodesMatchingSuffix<'a,S> {\n     }\n }\n \n-impl<'a,S:Str> Iterator<NodeId> for NodesMatchingSuffix<'a,S> {\n+impl<'a, 'ast, S:Str> Iterator<NodeId> for NodesMatchingSuffix<'a, 'ast, S> {\n     fn next(&mut self) -> Option<NodeId> {\n         loop {\n             let idx = self.idx;\n@@ -551,11 +605,11 @@ impl<'a,S:Str> Iterator<NodeId> for NodesMatchingSuffix<'a,S> {\n             }\n             self.idx += 1;\n             let (p, name) = match self.map.find_entry(idx) {\n-                Some(EntryItem(p, n))        => (p, n.name()),\n-                Some(EntryForeignItem(p, n)) => (p, n.name()),\n-                Some(EntryTraitItem(p, n))   => (p, n.name()),\n-                Some(EntryImplItem(p, n))    => (p, n.name()),\n-                Some(EntryVariant(p, n))     => (p, n.name()),\n+                Some(EntryItem(p, n))       => (p, n.name()),\n+                Some(EntryForeignItem(p, n))=> (p, n.name()),\n+                Some(EntryTraitItem(p, n))  => (p, n.name()),\n+                Some(EntryImplItem(p, n))   => (p, n.name()),\n+                Some(EntryVariant(p, n))    => (p, n.name()),\n                 _ => continue,\n             };\n             if self.matches_names(p, name) {\n@@ -578,7 +632,7 @@ impl Named for TraitItem {\n     fn name(&self) -> Name {\n         match *self {\n             RequiredMethod(ref tm) => tm.ident.name,\n-            ProvidedMethod(m) => m.name(),\n+            ProvidedMethod(ref m) => m.name(),\n         }\n     }\n }\n@@ -602,257 +656,292 @@ pub trait FoldOps {\n     fn new_id(&self, id: NodeId) -> NodeId {\n         id\n     }\n+    fn new_def_id(&self, def_id: DefId) -> DefId {\n+        def_id\n+    }\n     fn new_span(&self, span: Span) -> Span {\n         span\n     }\n }\n \n-/// A Folder that walks over an AST and constructs a Node ID Map. Its\n-/// fold_ops argument has the opportunity to replace Node IDs and spans.\n-pub struct Ctx<'a, F> {\n-    map: &'a Map,\n-    /// The node in which we are currently mapping (an item or a method).\n-    /// When equal to DUMMY_NODE_ID, the next mapped node becomes the parent.\n-    parent: NodeId,\n+/// A Folder that updates IDs and Span's according to fold_ops.\n+struct IdAndSpanUpdater<F> {\n     fold_ops: F\n }\n \n-impl<'a, F> Ctx<'a, F> {\n-    fn insert(&self, id: NodeId, entry: MapEntry) {\n-        (*self.map.map.borrow_mut()).grow_set(id as uint, &NotPresent, entry);\n-    }\n-}\n-\n-impl<'a, F: FoldOps> Folder for Ctx<'a, F> {\n+impl<F: FoldOps> Folder for IdAndSpanUpdater<F> {\n     fn new_id(&mut self, id: NodeId) -> NodeId {\n-        let id = self.fold_ops.new_id(id);\n-        if self.parent == DUMMY_NODE_ID {\n-            self.parent = id;\n-        }\n-        id\n+        self.fold_ops.new_id(id)\n     }\n \n     fn new_span(&mut self, span: Span) -> Span {\n         self.fold_ops.new_span(span)\n     }\n+}\n \n-    fn fold_item(&mut self, i: Gc<Item>) -> SmallVector<Gc<Item>> {\n-        let parent = self.parent;\n-        self.parent = DUMMY_NODE_ID;\n+/// A Visitor that walks over an AST and collects Node's into an AST Map.\n+struct NodeCollector<'ast> {\n+    map: Vec<MapEntry<'ast>>,\n+    /// The node in which we are currently mapping (an item or a method).\n+    parent: NodeId\n+}\n \n-        let i = fold::noop_fold_item(&*i, self).expect_one(\"expected one item\");\n-        assert_eq!(self.parent, i.id);\n+impl<'ast> NodeCollector<'ast> {\n+    fn insert_entry(&mut self, id: NodeId, entry: MapEntry<'ast>) {\n+        self.map.grow_set(id as uint, &NotPresent, entry);\n+        debug!(\"ast_map: {} => {}\", id, entry);\n+    }\n+\n+    fn insert(&mut self, id: NodeId, node: Node<'ast>) {\n+        let entry = MapEntry::from_node(self.parent, node);\n+        self.insert_entry(id, entry);\n+    }\n+\n+    fn visit_fn_decl(&mut self, decl: &'ast FnDecl) {\n+        for a in decl.inputs.iter() {\n+            self.insert(a.id, NodeArg(&*a.pat));\n+        }\n+    }\n+}\n \n+impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n+    fn visit_item(&mut self, i: &'ast Item) {\n+        self.insert(i.id, NodeItem(i));\n+        let parent = self.parent;\n+        self.parent = i.id;\n         match i.node {\n             ItemImpl(_, _, _, ref impl_items) => {\n                 for impl_item in impl_items.iter() {\n-                    match *impl_item {\n-                        MethodImplItem(m) => {\n-                            self.insert(m.id,\n-                                        EntryImplItem(self.parent,\n-                                                      box(GC) *impl_item));\n-                        }\n-                    }\n+                    let id = match *impl_item {\n+                        MethodImplItem(ref m) => m.id\n+                    };\n+                    self.insert(id, NodeImplItem(impl_item));\n                 }\n             }\n             ItemEnum(ref enum_definition, _) => {\n-                for &v in enum_definition.variants.iter() {\n-                    self.insert(v.node.id, EntryVariant(self.parent, v));\n+                for v in enum_definition.variants.iter() {\n+                    self.insert(v.node.id, NodeVariant(&**v));\n                 }\n             }\n             ItemForeignMod(ref nm) => {\n                 for nitem in nm.items.iter() {\n-                    self.insert(nitem.id, EntryForeignItem(self.parent,\n-                                                           nitem.clone()));\n+                    self.insert(nitem.id, NodeForeignItem(&**nitem));\n                 }\n             }\n             ItemStruct(ref struct_def, _) => {\n                 // If this is a tuple-like struct, register the constructor.\n                 match struct_def.ctor_id {\n                     Some(ctor_id) => {\n-                        self.insert(ctor_id, EntryStructCtor(self.parent,\n-                                                             struct_def.clone()));\n+                        self.insert(ctor_id, NodeStructCtor(&**struct_def));\n                     }\n                     None => {}\n                 }\n             }\n             ItemTrait(_, _, _, ref methods) => {\n                 for tm in methods.iter() {\n-                    match *tm {\n-                        RequiredMethod(ref m) => {\n-                            self.insert(m.id, EntryTraitItem(self.parent,\n-                                                               box(GC) (*tm).clone()));\n-                        }\n-                        ProvidedMethod(m) => {\n-                            self.insert(m.id, EntryTraitItem(self.parent,\n-                                                               box(GC) ProvidedMethod(m)));\n-                        }\n-                    }\n+                    let id = match *tm {\n+                        RequiredMethod(ref m) => m.id,\n+                        ProvidedMethod(ref m) => m.id\n+                    };\n+                    self.insert(id, NodeTraitItem(tm));\n                 }\n             }\n             _ => {}\n         }\n-\n+        visit::walk_item(self, i);\n         self.parent = parent;\n-        self.insert(i.id, EntryItem(self.parent, i));\n-\n-        SmallVector::one(i)\n     }\n \n-    fn fold_pat(&mut self, pat: Gc<Pat>) -> Gc<Pat> {\n-        let pat = fold::noop_fold_pat(pat, self);\n-        match pat.node {\n-            PatIdent(..) => {\n-                // Note: this is at least *potentially* a pattern...\n-                self.insert(pat.id, EntryLocal(self.parent, pat));\n-            }\n-            _ => {\n-                self.insert(pat.id, EntryPat(self.parent, pat));\n-            }\n-        }\n-\n-        pat\n+    fn visit_pat(&mut self, pat: &'ast Pat) {\n+        self.insert(pat.id, match pat.node {\n+            // Note: this is at least *potentially* a pattern...\n+            PatIdent(..) => NodeLocal(pat),\n+            _ => NodePat(pat)\n+        });\n+        visit::walk_pat(self, pat);\n     }\n \n-    fn fold_expr(&mut self, expr: Gc<Expr>) -> Gc<Expr> {\n-        let expr = fold::noop_fold_expr(expr, self);\n-\n-        self.insert(expr.id, EntryExpr(self.parent, expr));\n-\n-        expr\n+    fn visit_expr(&mut self, expr: &'ast Expr) {\n+        self.insert(expr.id, NodeExpr(expr));\n+        visit::walk_expr(self, expr);\n     }\n \n-    fn fold_stmt(&mut self, stmt: &Stmt) -> SmallVector<Gc<Stmt>> {\n-        let stmt = fold::noop_fold_stmt(stmt, self).expect_one(\"expected one statement\");\n-        self.insert(ast_util::stmt_id(&*stmt), EntryStmt(self.parent, stmt));\n-        SmallVector::one(stmt)\n+    fn visit_stmt(&mut self, stmt: &'ast Stmt) {\n+        self.insert(ast_util::stmt_id(stmt), NodeStmt(stmt));\n+        visit::walk_stmt(self, stmt);\n     }\n \n-    fn fold_type_method(&mut self, m: &TypeMethod) -> TypeMethod {\n+    fn visit_ty_method(&mut self, m: &'ast TypeMethod) {\n         let parent = self.parent;\n-        self.parent = DUMMY_NODE_ID;\n-        let m = fold::noop_fold_type_method(m, self);\n-        assert_eq!(self.parent, m.id);\n+        self.parent = m.id;\n+        self.visit_fn_decl(&*m.decl);\n+        visit::walk_ty_method(self, m);\n         self.parent = parent;\n-        m\n     }\n \n-    fn fold_method(&mut self, m: Gc<Method>) -> SmallVector<Gc<Method>> {\n-        let parent = self.parent;\n-        self.parent = DUMMY_NODE_ID;\n-        let m = fold::noop_fold_method(&*m, self).expect_one(\n-            \"noop_fold_method must produce exactly one method\");\n-        assert_eq!(self.parent, m.id);\n-        self.parent = parent;\n-        SmallVector::one(m)\n+    fn visit_fn(&mut self, fk: visit::FnKind<'ast>, fd: &'ast FnDecl,\n+                b: &'ast Block, s: Span, id: NodeId) {\n+        match fk {\n+            visit::FkMethod(..) => {\n+                let parent = self.parent;\n+                self.parent = id;\n+                self.visit_fn_decl(fd);\n+                visit::walk_fn(self, fk, fd, b, s);\n+                self.parent = parent;\n+            }\n+            _ => {\n+                self.visit_fn_decl(fd);\n+                visit::walk_fn(self, fk, fd, b, s);\n+            }\n+        }\n     }\n \n-    fn fold_fn_decl(&mut self, decl: &FnDecl) -> P<FnDecl> {\n-        let decl = fold::noop_fold_fn_decl(decl, self);\n-        for a in decl.inputs.iter() {\n-            self.insert(a.id, EntryArg(self.parent, a.pat));\n+    fn visit_ty(&mut self, ty: &'ast Ty) {\n+        match ty.node {\n+            TyClosure(ref fd) | TyProc(ref fd) => {\n+                self.visit_fn_decl(&*fd.decl);\n+            }\n+            TyBareFn(ref fd) => {\n+                self.visit_fn_decl(&*fd.decl);\n+            }\n+            TyUnboxedFn(ref fd) => {\n+                self.visit_fn_decl(&*fd.decl);\n+            }\n+            _ => {}\n         }\n-        decl\n+        visit::walk_ty(self, ty);\n     }\n \n-    fn fold_block(&mut self, block: P<Block>) -> P<Block> {\n-        let block = fold::noop_fold_block(block, self);\n-        self.insert(block.id, EntryBlock(self.parent, block));\n-        block\n+    fn visit_block(&mut self, block: &'ast Block) {\n+        self.insert(block.id, NodeBlock(block));\n+        visit::walk_block(self, block);\n     }\n \n-    fn fold_lifetime(&mut self, lifetime: &Lifetime) -> Lifetime {\n-        let lifetime = fold::noop_fold_lifetime(lifetime, self);\n-        self.insert(lifetime.id, EntryLifetime(self.parent, box(GC) lifetime));\n-        lifetime\n+    fn visit_lifetime_ref(&mut self, lifetime: &'ast Lifetime) {\n+        self.insert(lifetime.id, NodeLifetime(lifetime));\n     }\n \n-    fn fold_mac(&mut self, mac: &Mac) -> Mac {\n-        fold::noop_fold_mac(mac, self)\n+    fn visit_lifetime_decl(&mut self, def: &'ast LifetimeDef) {\n+        self.visit_lifetime_ref(&def.lifetime);\n     }\n }\n \n-pub fn map_crate<F: FoldOps>(krate: Crate, fold_ops: F) -> (Crate, Map) {\n-    let map = Map { map: RefCell::new(Vec::new()) };\n-    let krate = {\n-        let mut cx = Ctx {\n-            map: &map,\n-            parent: CRATE_NODE_ID,\n-            fold_ops: fold_ops\n-        };\n-        cx.insert(CRATE_NODE_ID, RootCrate);\n-        cx.fold_crate(krate)\n+pub fn map_crate<'ast, F: FoldOps>(forest: &'ast mut Forest, fold_ops: F) -> Map<'ast> {\n+    // Replace the crate with an empty one to take it out.\n+    let krate = mem::replace(&mut forest.krate, Crate {\n+        module: Mod {\n+            inner: DUMMY_SP,\n+            view_items: vec![],\n+            items: vec![],\n+        },\n+        attrs: vec![],\n+        config: vec![],\n+        exported_macros: vec![],\n+        span: DUMMY_SP\n+    });\n+    forest.krate = IdAndSpanUpdater { fold_ops: fold_ops }.fold_crate(krate);\n+\n+    let mut collector = NodeCollector {\n+        map: vec![],\n+        parent: CRATE_NODE_ID\n     };\n+    collector.insert_entry(CRATE_NODE_ID, RootCrate);\n+    visit::walk_crate(&mut collector, &forest.krate);\n+    let map = collector.map;\n \n     if log_enabled!(::log::DEBUG) {\n-        let map = map.map.borrow();\n         // This only makes sense for ordered stores; note the\n         // enumerate to count the number of entries.\n-        let (entries_less_1, _) = (*map).iter().filter(|&x| {\n+        let (entries_less_1, _) = map.iter().filter(|&x| {\n             match *x {\n                 NotPresent => false,\n                 _ => true\n             }\n         }).enumerate().last().expect(\"AST map was empty after folding?\");\n \n         let entries = entries_less_1 + 1;\n-        let vector_length = (*map).len();\n+        let vector_length = map.len();\n         debug!(\"The AST map has {} entries with a maximum of {}: occupancy {:.1}%\",\n               entries, vector_length, (entries as f64 / vector_length as f64) * 100.);\n     }\n \n-    (krate, map)\n+    Map {\n+        forest: forest,\n+        map: RefCell::new(map)\n+    }\n }\n \n /// Used for items loaded from external crate that are being inlined into this\n /// crate.  The `path` should be the path to the item but should not include\n /// the item itself.\n-pub fn map_decoded_item<F: FoldOps>(map: &Map,\n-                                    path: Vec<PathElem> ,\n-                                    fold_ops: F,\n-                                    fold: |&mut Ctx<F>| -> InlinedItem)\n-                                    -> InlinedItem {\n-    let mut cx = Ctx {\n-        map: map,\n-        parent: DUMMY_NODE_ID,\n-        fold_ops: fold_ops\n+pub fn map_decoded_item<'ast, F: FoldOps>(map: &Map<'ast>,\n+                                          path: Vec<PathElem>,\n+                                          ii: InlinedItem,\n+                                          fold_ops: F)\n+                                          -> &'ast InlinedItem {\n+    let mut fld = IdAndSpanUpdater { fold_ops: fold_ops };\n+    let ii = match ii {\n+        IIItem(i) => IIItem(fld.fold_item(i).expect_one(\"expected one item\")),\n+        IITraitItem(d, ti) => match ti {\n+            ProvidedMethod(m) => {\n+                IITraitItem(fld.fold_ops.new_def_id(d),\n+                            ProvidedMethod(fld.fold_method(m)\n+                                              .expect_one(\"expected one method\")))\n+            }\n+            RequiredMethod(ty_m) => {\n+                IITraitItem(fld.fold_ops.new_def_id(d),\n+                            RequiredMethod(fld.fold_type_method(ty_m)))\n+            }\n+        },\n+        IIImplItem(d, m) => match m {\n+            MethodImplItem(m) => {\n+                IIImplItem(fld.fold_ops.new_def_id(d),\n+                           MethodImplItem(fld.fold_method(m)\n+                                             .expect_one(\"expected one method\")))\n+            }\n+        },\n+        IIForeign(i) => IIForeign(fld.fold_foreign_item(i))\n     };\n \n-    // Generate a NodeId for the RootInlinedParent inserted below.\n-    cx.new_id(DUMMY_NODE_ID);\n+    let ii_parent = map.forest.inlined_items.alloc(InlinedParent {\n+        path: path,\n+        ii: ii\n+    });\n+\n+    let mut collector = NodeCollector {\n+        map: mem::replace(&mut *map.map.borrow_mut(), vec![]),\n+        parent: fld.new_id(DUMMY_NODE_ID)\n+    };\n+    let ii_parent_id = collector.parent;\n+    collector.insert_entry(ii_parent_id, RootInlinedParent(ii_parent));\n+    visit::walk_inlined_item(&mut collector, &ii_parent.ii);\n \n     // Methods get added to the AST map when their impl is visited.  Since we\n     // don't decode and instantiate the impl, but just the method, we have to\n     // add it to the table now. Likewise with foreign items.\n-    let mut def_id = DefId { krate: LOCAL_CRATE, node: DUMMY_NODE_ID };\n-    let ii = fold(&mut cx);\n-    match ii {\n+    match ii_parent.ii {\n         IIItem(_) => {}\n-        IITraitItem(impl_did, inlined_trait_item) => {\n-            let (trait_item_id, entry) = match inlined_trait_item {\n-                ProvidedInlinedTraitItem(m) => {\n-                    (m.id,\n-                     EntryTraitItem(cx.parent, box(GC) ProvidedMethod(m)))\n-                }\n-                RequiredInlinedTraitItem(m) => {\n-                    (m.id,\n-                     EntryImplItem(cx.parent, box(GC) MethodImplItem(m)))\n-                }\n+        IITraitItem(_, ref trait_item) => {\n+            let trait_item_id = match *trait_item {\n+                ProvidedMethod(ref m) => m.id,\n+                RequiredMethod(ref m) => m.id\n             };\n-            cx.insert(trait_item_id, entry);\n-            def_id = impl_did;\n+\n+            collector.insert(trait_item_id, NodeTraitItem(trait_item));\n         }\n-        IIForeign(i) => {\n-            cx.insert(i.id, EntryForeignItem(cx.parent, i));\n+        IIImplItem(_, ref impl_item) => {\n+            let impl_item_id = match *impl_item {\n+                MethodImplItem(ref m) => m.id\n+            };\n+\n+            collector.insert(impl_item_id, NodeImplItem(impl_item));\n+        }\n+        IIForeign(ref i) => {\n+            collector.insert(i.id, NodeForeignItem(&**i));\n         }\n     }\n-\n-    cx.insert(cx.parent, RootInlinedParent(P(InlinedParent {\n-        path: path,\n-        def_id: def_id\n-    })));\n-\n-    ii\n+    *map.map.borrow_mut() = collector.map;\n+    &ii_parent.ii\n }\n \n pub trait NodePrinter {\n@@ -920,10 +1009,13 @@ fn node_id_to_string(map: &Map, id: NodeId) -> String {\n                 }\n             }\n         }\n-        Some(NodeTraitItem(ref tm)) => {\n-            let m = ast_util::trait_item_to_ty_method(&**tm);\n+        Some(NodeTraitItem(ref ti)) => {\n+            let ident = match **ti {\n+                ProvidedMethod(ref m) => m.pe_ident(),\n+                RequiredMethod(ref m) => m.ident\n+            };\n             format!(\"method {} in {} (id={})\",\n-                    token::get_ident(m.ident),\n+                    token::get_ident(ident),\n                     map.path_to_string(id), id)\n         }\n         Some(NodeVariant(ref variant)) => {"}, {"sha": "becfe715f29e2cd844014e8c86945a09b19eace6", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 23, "deletions": 101, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -19,12 +19,12 @@ use codemap::Span;\n use owned_slice::OwnedSlice;\n use parse::token;\n use print::pprust;\n+use ptr::P;\n use visit::Visitor;\n use visit;\n \n use std::cell::Cell;\n use std::cmp;\n-use std::gc::{Gc, GC};\n use std::u32;\n \n pub fn path_name_i(idents: &[Ident]) -> String {\n@@ -98,7 +98,7 @@ pub fn unop_to_string(op: UnOp) -> &'static str {\n     }\n }\n \n-pub fn is_path(e: Gc<Expr>) -> bool {\n+pub fn is_path(e: P<Expr>) -> bool {\n     return match e.node { ExprPath(_) => true, _ => false };\n }\n \n@@ -166,21 +166,6 @@ pub fn float_ty_to_string(t: FloatTy) -> String {\n     }\n }\n \n-pub fn is_call_expr(e: Gc<Expr>) -> bool {\n-    match e.node { ExprCall(..) => true, _ => false }\n-}\n-\n-pub fn block_from_expr(e: Gc<Expr>) -> P<Block> {\n-    P(Block {\n-        view_items: Vec::new(),\n-        stmts: Vec::new(),\n-        expr: Some(e),\n-        id: e.id,\n-        rules: DefaultBlock,\n-        span: e.span\n-    })\n-}\n-\n // convert a span and an identifier to the corresponding\n // 1-segment path\n pub fn ident_to_path(s: Span, identifier: Ident) -> Path {\n@@ -197,10 +182,12 @@ pub fn ident_to_path(s: Span, identifier: Ident) -> Path {\n     }\n }\n \n-pub fn ident_to_pat(id: NodeId, s: Span, i: Ident) -> Gc<Pat> {\n-    box(GC) ast::Pat { id: id,\n-                node: PatIdent(BindByValue(MutImmutable), codemap::Spanned{span:s, node:i}, None),\n-                span: s }\n+pub fn ident_to_pat(id: NodeId, s: Span, i: Ident) -> P<Pat> {\n+    P(Pat {\n+        id: id,\n+        node: PatIdent(BindByValue(MutImmutable), codemap::Spanned{span:s, node:i}, None),\n+        span: s\n+    })\n }\n \n pub fn name_to_dummy_lifetime(name: Name) -> Lifetime {\n@@ -226,57 +213,6 @@ pub fn impl_pretty_name(trait_ref: &Option<TraitRef>, ty: &Ty) -> Ident {\n     token::gensym_ident(pretty.as_slice())\n }\n \n-pub fn trait_method_to_ty_method(method: &Method) -> TypeMethod {\n-    match method.node {\n-        MethDecl(ident,\n-                 ref generics,\n-                 abi,\n-                 explicit_self,\n-                 fn_style,\n-                 decl,\n-                 _,\n-                 vis) => {\n-            TypeMethod {\n-                ident: ident,\n-                attrs: method.attrs.clone(),\n-                fn_style: fn_style,\n-                decl: decl,\n-                generics: generics.clone(),\n-                explicit_self: explicit_self,\n-                id: method.id,\n-                span: method.span,\n-                vis: vis,\n-                abi: abi,\n-            }\n-        },\n-        MethMac(_) => fail!(\"expected non-macro method declaration\")\n-    }\n-}\n-\n-/// extract a TypeMethod from a TraitItem. if the TraitItem is\n-/// a default, pull out the useful fields to make a TypeMethod\n-//\n-// NB: to be used only after expansion is complete, and macros are gone.\n-pub fn trait_item_to_ty_method(method: &TraitItem) -> TypeMethod {\n-    match *method {\n-        RequiredMethod(ref m) => (*m).clone(),\n-        ProvidedMethod(ref m) => trait_method_to_ty_method(&**m),\n-    }\n-}\n-\n-pub fn split_trait_methods(trait_methods: &[TraitItem])\n-    -> (Vec<TypeMethod> , Vec<Gc<Method>> ) {\n-    let mut reqd = Vec::new();\n-    let mut provd = Vec::new();\n-    for trt_method in trait_methods.iter() {\n-        match *trt_method {\n-            RequiredMethod(ref tm) => reqd.push((*tm).clone()),\n-            ProvidedMethod(m) => provd.push(m)\n-        }\n-    };\n-    (reqd, provd)\n-}\n-\n pub fn struct_field_visibility(field: ast::StructField) -> Visibility {\n     match field.node.kind {\n         ast::NamedField(_, v) | ast::UnnamedField(v) => v\n@@ -538,6 +474,14 @@ impl<'a, 'v, O: IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O> {\n         }\n         visit::walk_trait_item(self, tm);\n     }\n+\n+    fn visit_lifetime_ref(&mut self, lifetime: &'v Lifetime) {\n+        self.operation.visit_id(lifetime.id);\n+    }\n+\n+    fn visit_lifetime_decl(&mut self, def: &'v LifetimeDef) {\n+        self.visit_lifetime_ref(&def.lifetime);\n+    }\n }\n \n pub fn visit_ids_for_inlined_item<O: IdVisitingOperation>(item: &InlinedItem,\n@@ -595,13 +539,6 @@ pub fn compute_id_range_for_fn_body(fk: visit::FnKind,\n     visitor.result.get()\n }\n \n-pub fn is_item_impl(item: Gc<ast::Item>) -> bool {\n-    match item.node {\n-        ItemImpl(..) => true,\n-        _            => false\n-    }\n-}\n-\n pub fn walk_pat(pat: &Pat, it: |&Pat| -> bool) -> bool {\n     if !it(pat) {\n         return false;\n@@ -670,7 +607,7 @@ pub fn struct_def_is_tuple_like(struct_def: &ast::StructDef) -> bool {\n \n /// Returns true if the given pattern consists solely of an identifier\n /// and false otherwise.\n-pub fn pat_is_ident(pat: Gc<ast::Pat>) -> bool {\n+pub fn pat_is_ident(pat: P<ast::Pat>) -> bool {\n     match pat.node {\n         ast::PatIdent(..) => true,\n         _ => false,\n@@ -705,28 +642,13 @@ pub fn segments_name_eq(a : &[ast::PathSegment], b : &[ast::PathSegment]) -> boo\n }\n \n /// Returns true if this literal is a string and false otherwise.\n-pub fn lit_is_str(lit: Gc<Lit>) -> bool {\n+pub fn lit_is_str(lit: &Lit) -> bool {\n     match lit.node {\n         LitStr(..) => true,\n         _ => false,\n     }\n }\n \n-pub fn get_inner_tys(ty: P<Ty>) -> Vec<P<Ty>> {\n-    match ty.node {\n-        ast::TyRptr(_, mut_ty) | ast::TyPtr(mut_ty) => {\n-            vec!(mut_ty.ty)\n-        }\n-        ast::TyBox(ty)\n-        | ast::TyVec(ty)\n-        | ast::TyUniq(ty)\n-        | ast::TyFixedLengthVec(ty, _) => vec!(ty),\n-        ast::TyTup(ref tys) => tys.clone(),\n-        ast::TyParen(ty) => get_inner_tys(ty),\n-        _ => Vec::new()\n-    }\n-}\n-\n /// Returns true if the static with the given mutability and attributes\n /// has a significant address and false otherwise.\n pub fn static_has_significant_address(mutbl: ast::Mutability,\n@@ -749,13 +671,13 @@ pub trait PostExpansionMethod {\n     fn pe_abi(&self) -> Abi;\n     fn pe_explicit_self<'a>(&'a self) -> &'a ast::ExplicitSelf;\n     fn pe_fn_style(&self) -> ast::FnStyle;\n-    fn pe_fn_decl(&self) -> P<ast::FnDecl>;\n-    fn pe_body(&self) -> P<ast::Block>;\n+    fn pe_fn_decl<'a>(&'a self) -> &'a ast::FnDecl;\n+    fn pe_body<'a>(&'a self) -> &'a ast::Block;\n     fn pe_vis(&self) -> ast::Visibility;\n }\n \n macro_rules! mf_method{\n-    ($meth_name:ident, $field_ty:ty, $field_pat:pat, $result:ident) => {\n+    ($meth_name:ident, $field_ty:ty, $field_pat:pat, $result:expr) => {\n         fn $meth_name<'a>(&'a self) -> $field_ty {\n             match self.node {\n                 $field_pat => $result,\n@@ -776,8 +698,8 @@ impl PostExpansionMethod for Method {\n     mf_method!(pe_explicit_self,&'a ast::ExplicitSelf,\n                MethDecl(_,_,_,ref explicit_self,_,_,_,_),explicit_self)\n     mf_method!(pe_fn_style,ast::FnStyle,MethDecl(_,_,_,_,fn_style,_,_,_),fn_style)\n-    mf_method!(pe_fn_decl,P<ast::FnDecl>,MethDecl(_,_,_,_,_,decl,_,_),decl)\n-    mf_method!(pe_body,P<ast::Block>,MethDecl(_,_,_,_,_,_,body,_),body)\n+    mf_method!(pe_fn_decl,&'a ast::FnDecl,MethDecl(_,_,_,_,_,ref decl,_,_),&**decl)\n+    mf_method!(pe_body,&'a ast::Block,MethDecl(_,_,_,_,_,_,ref body,_),&**body)\n     mf_method!(pe_vis,ast::Visibility,MethDecl(_,_,_,_,_,_,_,vis),vis)\n }\n "}, {"sha": "80e4d148bdec8c16171114d7deee05090411e708", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 45, "deletions": 50, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -18,10 +18,10 @@ use diagnostic::SpanHandler;\n use parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n use parse::token::InternedString;\n use parse::token;\n+use ptr::P;\n \n use std::collections::HashSet;\n use std::collections::BitvSet;\n-use std::gc::{Gc, GC};\n \n local_data_key!(used_attrs: BitvSet)\n \n@@ -50,7 +50,7 @@ pub trait AttrMetaMethods {\n     /// containing a string, otherwise None.\n     fn value_str(&self) -> Option<InternedString>;\n     /// Gets a list of inner meta items from a list MetaItem type.\n-    fn meta_item_list<'a>(&'a self) -> Option<&'a [Gc<MetaItem>]>;\n+    fn meta_item_list<'a>(&'a self) -> Option<&'a [P<MetaItem>]>;\n }\n \n impl AttrMetaMethods for Attribute {\n@@ -65,7 +65,7 @@ impl AttrMetaMethods for Attribute {\n     fn value_str(&self) -> Option<InternedString> {\n         self.meta().value_str()\n     }\n-    fn meta_item_list<'a>(&'a self) -> Option<&'a [Gc<MetaItem>]> {\n+    fn meta_item_list<'a>(&'a self) -> Option<&'a [P<MetaItem>]> {\n         self.node.value.meta_item_list()\n     }\n }\n@@ -91,7 +91,7 @@ impl AttrMetaMethods for MetaItem {\n         }\n     }\n \n-    fn meta_item_list<'a>(&'a self) -> Option<&'a [Gc<MetaItem>]> {\n+    fn meta_item_list<'a>(&'a self) -> Option<&'a [P<MetaItem>]> {\n         match self.node {\n             MetaList(_, ref l) => Some(l.as_slice()),\n             _ => None\n@@ -100,67 +100,66 @@ impl AttrMetaMethods for MetaItem {\n }\n \n // Annoying, but required to get test_cfg to work\n-impl AttrMetaMethods for Gc<MetaItem> {\n+impl AttrMetaMethods for P<MetaItem> {\n     fn name(&self) -> InternedString { (**self).name() }\n     fn value_str(&self) -> Option<InternedString> { (**self).value_str() }\n-    fn meta_item_list<'a>(&'a self) -> Option<&'a [Gc<MetaItem>]> {\n+    fn meta_item_list<'a>(&'a self) -> Option<&'a [P<MetaItem>]> {\n         (**self).meta_item_list()\n     }\n }\n \n \n pub trait AttributeMethods {\n-    fn meta(&self) -> Gc<MetaItem>;\n-    fn desugar_doc(&self) -> Attribute;\n+    fn meta<'a>(&'a self) -> &'a MetaItem;\n+    fn with_desugared_doc<T>(&self, f: |&Attribute| -> T) -> T;\n }\n \n impl AttributeMethods for Attribute {\n     /// Extract the MetaItem from inside this Attribute.\n-    fn meta(&self) -> Gc<MetaItem> {\n-        self.node.value\n+    fn meta<'a>(&'a self) -> &'a MetaItem {\n+        &*self.node.value\n     }\n \n     /// Convert self to a normal #[doc=\"foo\"] comment, if it is a\n     /// comment like `///` or `/** */`. (Returns self unchanged for\n     /// non-sugared doc attributes.)\n-    fn desugar_doc(&self) -> Attribute {\n+    fn with_desugared_doc<T>(&self, f: |&Attribute| -> T) -> T {\n         if self.node.is_sugared_doc {\n             let comment = self.value_str().unwrap();\n             let meta = mk_name_value_item_str(\n                 InternedString::new(\"doc\"),\n                 token::intern_and_get_ident(strip_doc_comment_decoration(\n                         comment.get()).as_slice()));\n             if self.node.style == ast::AttrOuter {\n-                mk_attr_outer(self.node.id, meta)\n+                f(&mk_attr_outer(self.node.id, meta))\n             } else {\n-                mk_attr_inner(self.node.id, meta)\n+                f(&mk_attr_inner(self.node.id, meta))\n             }\n         } else {\n-            *self\n+            f(self)\n         }\n     }\n }\n \n /* Constructors */\n \n pub fn mk_name_value_item_str(name: InternedString, value: InternedString)\n-                              -> Gc<MetaItem> {\n+                              -> P<MetaItem> {\n     let value_lit = dummy_spanned(ast::LitStr(value, ast::CookedStr));\n     mk_name_value_item(name, value_lit)\n }\n \n pub fn mk_name_value_item(name: InternedString, value: ast::Lit)\n-                          -> Gc<MetaItem> {\n-    box(GC) dummy_spanned(MetaNameValue(name, value))\n+                          -> P<MetaItem> {\n+    P(dummy_spanned(MetaNameValue(name, value)))\n }\n \n-pub fn mk_list_item(name: InternedString,\n-                    items: Vec<Gc<MetaItem>>) -> Gc<MetaItem> {\n-    box(GC) dummy_spanned(MetaList(name, items))\n+pub fn mk_list_item(name: InternedString, items: Vec<P<MetaItem>>) -> P<MetaItem> {\n+    P(dummy_spanned(MetaList(name, items)))\n }\n \n-pub fn mk_word_item(name: InternedString) -> Gc<MetaItem> {\n-    box(GC) dummy_spanned(MetaWord(name))\n+pub fn mk_word_item(name: InternedString) -> P<MetaItem> {\n+    P(dummy_spanned(MetaWord(name)))\n }\n \n local_data_key!(next_attr_id: uint)\n@@ -172,7 +171,7 @@ pub fn mk_attr_id() -> AttrId {\n }\n \n /// Returns an inner attribute with the given value.\n-pub fn mk_attr_inner(id: AttrId, item: Gc<MetaItem>) -> Attribute {\n+pub fn mk_attr_inner(id: AttrId, item: P<MetaItem>) -> Attribute {\n     dummy_spanned(Attribute_ {\n         id: id,\n         style: ast::AttrInner,\n@@ -182,7 +181,7 @@ pub fn mk_attr_inner(id: AttrId, item: Gc<MetaItem>) -> Attribute {\n }\n \n /// Returns an outer attribute with the given value.\n-pub fn mk_attr_outer(id: AttrId, item: Gc<MetaItem>) -> Attribute {\n+pub fn mk_attr_outer(id: AttrId, item: P<MetaItem>) -> Attribute {\n     dummy_spanned(Attribute_ {\n         id: id,\n         style: ast::AttrOuter,\n@@ -199,8 +198,8 @@ pub fn mk_sugared_doc_attr(id: AttrId, text: InternedString, lo: BytePos,\n     let attr = Attribute_ {\n         id: id,\n         style: style,\n-        value: box(GC) spanned(lo, hi, MetaNameValue(InternedString::new(\"doc\"),\n-                                              lit)),\n+        value: P(spanned(lo, hi, MetaNameValue(InternedString::new(\"doc\"),\n+                                               lit))),\n         is_sugared_doc: true\n     };\n     spanned(lo, hi, attr)\n@@ -210,8 +209,7 @@ pub fn mk_sugared_doc_attr(id: AttrId, text: InternedString, lo: BytePos,\n /// Check if `needle` occurs in `haystack` by a structural\n /// comparison. This is slightly subtle, and relies on ignoring the\n /// span included in the `==` comparison a plain MetaItem.\n-pub fn contains(haystack: &[Gc<ast::MetaItem>],\n-                needle: Gc<ast::MetaItem>) -> bool {\n+pub fn contains(haystack: &[P<MetaItem>], needle: &MetaItem) -> bool {\n     debug!(\"attr::contains (name={})\", needle.name());\n     haystack.iter().any(|item| {\n         debug!(\"  testing: {}\", item.name());\n@@ -234,7 +232,7 @@ pub fn first_attr_value_str_by_name(attrs: &[Attribute], name: &str)\n         .and_then(|at| at.value_str())\n }\n \n-pub fn last_meta_item_value_str_by_name(items: &[Gc<MetaItem>], name: &str)\n+pub fn last_meta_item_value_str_by_name(items: &[P<MetaItem>], name: &str)\n                                      -> Option<InternedString> {\n     items.iter()\n          .rev()\n@@ -244,28 +242,25 @@ pub fn last_meta_item_value_str_by_name(items: &[Gc<MetaItem>], name: &str)\n \n /* Higher-level applications */\n \n-pub fn sort_meta_items(items: &[Gc<MetaItem>]) -> Vec<Gc<MetaItem>> {\n+pub fn sort_meta_items(items: Vec<P<MetaItem>>) -> Vec<P<MetaItem>> {\n     // This is sort of stupid here, but we need to sort by\n     // human-readable strings.\n-    let mut v = items.iter()\n-        .map(|&mi| (mi.name(), mi))\n-        .collect::<Vec<(InternedString, Gc<MetaItem>)> >();\n+    let mut v = items.move_iter()\n+        .map(|mi| (mi.name(), mi))\n+        .collect::<Vec<(InternedString, P<MetaItem>)>>();\n \n     v.sort_by(|&(ref a, _), &(ref b, _)| a.cmp(b));\n \n     // There doesn't seem to be a more optimal way to do this\n-    v.move_iter().map(|(_, m)| {\n-        match m.node {\n-            MetaList(ref n, ref mis) => {\n-                box(GC) Spanned {\n-                    node: MetaList((*n).clone(),\n-                                   sort_meta_items(mis.as_slice())),\n-                    .. /*bad*/ (*m).clone()\n-                }\n-            }\n-            _ => m\n+    v.move_iter().map(|(_, m)| m.map(|Spanned {node, span}| {\n+        Spanned {\n+            node: match node {\n+                MetaList(n, mis) => MetaList(n, sort_meta_items(mis)),\n+                _ => node\n+            },\n+            span: span\n         }\n-    }).collect()\n+    })).collect()\n }\n \n pub fn find_crate_name(attrs: &[Attribute]) -> Option<InternedString> {\n@@ -318,8 +313,8 @@ pub fn requests_inline(attrs: &[Attribute]) -> bool {\n /// test_cfg(`[foo=\"a\", bar]`, `[cfg(not(bar))]`) == false\n /// test_cfg(`[foo=\"a\", bar]`, `[cfg(bar, foo=\"a\")]`) == true\n /// test_cfg(`[foo=\"a\", bar]`, `[cfg(bar, foo=\"b\")]`) == false\n-pub fn test_cfg<AM: AttrMetaMethods, It: Iterator<AM>>\n-    (cfg: &[Gc<MetaItem>], mut metas: It) -> bool {\n+pub fn test_cfg<'a, AM: AttrMetaMethods, It: Iterator<&'a AM>>\n+    (cfg: &[P<MetaItem>], mut metas: It) -> bool {\n     // having no #[cfg(...)] attributes counts as matching.\n     let mut no_cfgs = true;\n \n@@ -344,10 +339,10 @@ pub fn test_cfg<AM: AttrMetaMethods, It: Iterator<AM>>\n                                 // not match.\n                                 !not_cfgs.iter().all(|mi| {\n                                     debug!(\"cfg(not({}[...]))\", mi.name());\n-                                    contains(cfg, *mi)\n+                                    contains(cfg, &**mi)\n                                 })\n                             }\n-                            _ => contains(cfg, *cfg_mi)\n+                            _ => contains(cfg, &**cfg_mi)\n                         }\n                     })\n                 }\n@@ -397,7 +392,7 @@ pub fn find_stability_generic<'a,\n         };\n \n         return Some((Stability {\n-                level: level,\n+            level: level,\n                 text: attr.value_str()\n             }, attr));\n     }\n@@ -412,7 +407,7 @@ pub fn find_stability(attrs: &[Attribute]) -> Option<Stability> {\n     })\n }\n \n-pub fn require_unique_names(diagnostic: &SpanHandler, metas: &[Gc<MetaItem>]) {\n+pub fn require_unique_names(diagnostic: &SpanHandler, metas: &[P<MetaItem>]) {\n     let mut set = HashSet::new();\n     for meta in metas.iter() {\n         let name = meta.name();"}, {"sha": "faa3946b74d0f75dd6652103d25a2f9a092a78fc", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -543,10 +543,9 @@ fn print_macro_backtrace(w: &mut EmitterWriter,\n     Ok(())\n }\n \n-pub fn expect<T:Clone>(diag: &SpanHandler, opt: Option<T>, msg: || -> String)\n-              -> T {\n+pub fn expect<T>(diag: &SpanHandler, opt: Option<T>, msg: || -> String) -> T {\n     match opt {\n-       Some(ref t) => (*t).clone(),\n-       None => diag.handler().bug(msg().as_slice()),\n+        Some(t) => t,\n+        None => diag.handler().bug(msg().as_slice()),\n     }\n }"}, {"sha": "132b59c89b203069bc25a182715cf3e4615c0810", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -10,13 +10,13 @@\n \n use std::cell::RefCell;\n use std::collections::HashMap;\n-use std::gc::Gc;\n use ast;\n use ast::{Ident, Name, TokenTree};\n use codemap::Span;\n use ext::base::{ExtCtxt, MacExpr, MacItem, MacResult};\n use ext::build::AstBuilder;\n use parse::token;\n+use ptr::P;\n \n local_data_key!(registered_diagnostics: RefCell<HashMap<Name, Option<Name>>>)\n local_data_key!(used_diagnostics: RefCell<HashMap<Name, Span>>)\n@@ -116,7 +116,7 @@ pub fn expand_build_diagnostic_array<'cx>(ecx: &'cx mut ExtCtxt,\n \n     let (count, expr) = with_used_diagnostics(|diagnostics_in_use| {\n         with_registered_diagnostics(|diagnostics| {\n-            let descriptions: Vec<Gc<ast::Expr>> = diagnostics\n+            let descriptions: Vec<P<ast::Expr>> = diagnostics\n                 .iter().filter_map(|(code, description)| {\n                 if !diagnostics_in_use.contains_key(code) {\n                     ecx.span_warn(span, format!("}, {"sha": "4b8c3376cad2ec91282016d333eca2f3992d0046", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -18,8 +18,7 @@ use ext::base;\n use ext::base::*;\n use parse::token::InternedString;\n use parse::token;\n-\n-use std::gc::GC;\n+use ptr::P;\n \n enum State {\n     Asm,\n@@ -199,7 +198,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n         }\n     }\n \n-    MacExpr::new(box(GC) ast::Expr {\n+    MacExpr::new(P(ast::Expr {\n         id: ast::DUMMY_NODE_ID,\n         node: ast::ExprInlineAsm(ast::InlineAsm {\n             asm: token::intern_and_get_ident(asm.get()),\n@@ -212,5 +211,5 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n             dialect: dialect\n         }),\n         span: sp\n-    })\n+    }))\n }"}, {"sha": "6e25b6b73ade6fa83fdfdca16bebe5ae7e0ae0cb", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 62, "deletions": 61, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -18,6 +18,7 @@ use parse;\n use parse::parser;\n use parse::token;\n use parse::token::{InternedString, intern, str_to_ident};\n+use ptr::P;\n use util::small_vector::SmallVector;\n use ext::mtwt;\n use fold::Folder;\n@@ -43,18 +44,18 @@ pub trait ItemDecorator {\n     fn expand(&self,\n               ecx: &mut ExtCtxt,\n               sp: Span,\n-              meta_item: Gc<ast::MetaItem>,\n-              item: Gc<ast::Item>,\n-              push: |Gc<ast::Item>|);\n+              meta_item: &ast::MetaItem,\n+              item: &ast::Item,\n+              push: |P<ast::Item>|);\n }\n \n-impl ItemDecorator for fn(&mut ExtCtxt, Span, Gc<ast::MetaItem>, Gc<ast::Item>, |Gc<ast::Item>|) {\n+impl ItemDecorator for fn(&mut ExtCtxt, Span, &ast::MetaItem, &ast::Item, |P<ast::Item>|) {\n     fn expand(&self,\n               ecx: &mut ExtCtxt,\n               sp: Span,\n-              meta_item: Gc<ast::MetaItem>,\n-              item: Gc<ast::Item>,\n-              push: |Gc<ast::Item>|) {\n+              meta_item: &ast::MetaItem,\n+              item: &ast::Item,\n+              push: |P<ast::Item>|) {\n         (*self)(ecx, sp, meta_item, item, push)\n     }\n }\n@@ -63,18 +64,18 @@ pub trait ItemModifier {\n     fn expand(&self,\n               ecx: &mut ExtCtxt,\n               span: Span,\n-              meta_item: Gc<ast::MetaItem>,\n-              item: Gc<ast::Item>)\n-              -> Gc<ast::Item>;\n+              meta_item: &ast::MetaItem,\n+              item: P<ast::Item>)\n+              -> P<ast::Item>;\n }\n \n-impl ItemModifier for fn(&mut ExtCtxt, Span, Gc<ast::MetaItem>, Gc<ast::Item>) -> Gc<ast::Item> {\n+impl ItemModifier for fn(&mut ExtCtxt, Span, &ast::MetaItem, P<ast::Item>) -> P<ast::Item> {\n     fn expand(&self,\n               ecx: &mut ExtCtxt,\n               span: Span,\n-              meta_item: Gc<ast::MetaItem>,\n-              item: Gc<ast::Item>)\n-              -> Gc<ast::Item> {\n+              meta_item: &ast::MetaItem,\n+              item: P<ast::Item>)\n+              -> P<ast::Item> {\n         (*self)(ecx, span, meta_item, item)\n     }\n }\n@@ -128,99 +129,99 @@ impl IdentMacroExpander for IdentMacroExpanderFn {\n /// methods are spliced into the AST at the callsite of the macro (or\n /// just into the compiler's internal macro table, for `make_def`).\n pub trait MacResult {\n-    /// Define a new macro.\n+    /// Attempt to define a new macro.\n     // this should go away; the idea that a macro might expand into\n     // either a macro definition or an expression, depending on what\n     // the context wants, is kind of silly.\n-    fn make_def(&self) -> Option<MacroDef> {\n+    fn make_def(&mut self) -> Option<MacroDef> {\n         None\n     }\n     /// Create an expression.\n-    fn make_expr(&self) -> Option<Gc<ast::Expr>> {\n+    fn make_expr(self: Box<Self>) -> Option<P<ast::Expr>> {\n         None\n     }\n     /// Create zero or more items.\n-    fn make_items(&self) -> Option<SmallVector<Gc<ast::Item>>> {\n+    fn make_items(self: Box<Self>) -> Option<SmallVector<P<ast::Item>>> {\n         None\n     }\n \n     /// Create zero or more methods.\n-    fn make_methods(&self) -> Option<SmallVector<Gc<ast::Method>>> {\n+    fn make_methods(self: Box<Self>) -> Option<SmallVector<P<ast::Method>>> {\n         None\n     }\n \n     /// Create a pattern.\n-    fn make_pat(&self) -> Option<Gc<ast::Pat>> {\n+    fn make_pat(self: Box<Self>) -> Option<P<ast::Pat>> {\n         None\n     }\n \n     /// Create a statement.\n     ///\n     /// By default this attempts to create an expression statement,\n     /// returning None if that fails.\n-    fn make_stmt(&self) -> Option<Gc<ast::Stmt>> {\n+    fn make_stmt(self: Box<Self>) -> Option<P<ast::Stmt>> {\n         self.make_expr()\n-            .map(|e| box(GC) codemap::respan(e.span, ast::StmtExpr(e, ast::DUMMY_NODE_ID)))\n+            .map(|e| P(codemap::respan(e.span, ast::StmtExpr(e, ast::DUMMY_NODE_ID))))\n     }\n }\n \n /// A convenience type for macros that return a single expression.\n pub struct MacExpr {\n-    e: Gc<ast::Expr>,\n+    e: P<ast::Expr>\n }\n impl MacExpr {\n-    pub fn new(e: Gc<ast::Expr>) -> Box<MacResult+'static> {\n+    pub fn new(e: P<ast::Expr>) -> Box<MacResult+'static> {\n         box MacExpr { e: e } as Box<MacResult+'static>\n     }\n }\n impl MacResult for MacExpr {\n-    fn make_expr(&self) -> Option<Gc<ast::Expr>> {\n+    fn make_expr(self: Box<MacExpr>) -> Option<P<ast::Expr>> {\n         Some(self.e)\n     }\n-    fn make_pat(&self) -> Option<Gc<ast::Pat>> {\n+    fn make_pat(self: Box<MacExpr>) -> Option<P<ast::Pat>> {\n         match self.e.node {\n-            ast::ExprLit(_) => Some(box(GC) ast::Pat {\n+            ast::ExprLit(_) => Some(P(ast::Pat {\n                 id: ast::DUMMY_NODE_ID,\n-                node: ast::PatLit(self.e),\n-                span: self.e.span\n-            }),\n+                span: self.e.span,\n+                node: ast::PatLit(self.e)\n+            })),\n             _ => None\n         }\n     }\n }\n /// A convenience type for macros that return a single pattern.\n pub struct MacPat {\n-    p: Gc<ast::Pat>,\n+    p: P<ast::Pat>\n }\n impl MacPat {\n-    pub fn new(p: Gc<ast::Pat>) -> Box<MacResult+'static> {\n+    pub fn new(p: P<ast::Pat>) -> Box<MacResult+'static> {\n         box MacPat { p: p } as Box<MacResult+'static>\n     }\n }\n impl MacResult for MacPat {\n-    fn make_pat(&self) -> Option<Gc<ast::Pat>> {\n+    fn make_pat(self: Box<MacPat>) -> Option<P<ast::Pat>> {\n         Some(self.p)\n     }\n }\n /// A convenience type for macros that return a single item.\n pub struct MacItem {\n-    i: Gc<ast::Item>\n+    i: P<ast::Item>\n }\n impl MacItem {\n-    pub fn new(i: Gc<ast::Item>) -> Box<MacResult+'static> {\n+    pub fn new(i: P<ast::Item>) -> Box<MacResult+'static> {\n         box MacItem { i: i } as Box<MacResult+'static>\n     }\n }\n impl MacResult for MacItem {\n-    fn make_items(&self) -> Option<SmallVector<Gc<ast::Item>>> {\n+    fn make_items(self: Box<MacItem>) -> Option<SmallVector<P<ast::Item>>> {\n         Some(SmallVector::one(self.i))\n     }\n-    fn make_stmt(&self) -> Option<Gc<ast::Stmt>> {\n-        Some(box(GC) codemap::respan(\n+    fn make_stmt(self: Box<MacItem>) -> Option<P<ast::Stmt>> {\n+        Some(P(codemap::respan(\n             self.i.span,\n             ast::StmtDecl(\n-                box(GC) codemap::respan(self.i.span, ast::DeclItem(self.i)),\n-                ast::DUMMY_NODE_ID)))\n+                P(codemap::respan(self.i.span, ast::DeclItem(self.i))),\n+                ast::DUMMY_NODE_ID))))\n     }\n }\n \n@@ -250,17 +251,17 @@ impl DummyResult {\n     }\n \n     /// A plain dummy expression.\n-    pub fn raw_expr(sp: Span) -> Gc<ast::Expr> {\n-        box(GC) ast::Expr {\n+    pub fn raw_expr(sp: Span) -> P<ast::Expr> {\n+        P(ast::Expr {\n             id: ast::DUMMY_NODE_ID,\n-            node: ast::ExprLit(box(GC) codemap::respan(sp, ast::LitNil)),\n+            node: ast::ExprLit(P(codemap::respan(sp, ast::LitNil))),\n             span: sp,\n-        }\n+        })\n     }\n \n     /// A plain dummy pattern.\n-    pub fn raw_pat(sp: Span) -> Gc<ast::Pat> {\n-        box(GC) ast::Pat {\n+    pub fn raw_pat(sp: Span) -> ast::Pat {\n+        ast::Pat {\n             id: ast::DUMMY_NODE_ID,\n             node: ast::PatWild(ast::PatWildSingle),\n             span: sp,\n@@ -270,31 +271,31 @@ impl DummyResult {\n }\n \n impl MacResult for DummyResult {\n-    fn make_expr(&self) -> Option<Gc<ast::Expr>> {\n+    fn make_expr(self: Box<DummyResult>) -> Option<P<ast::Expr>> {\n         Some(DummyResult::raw_expr(self.span))\n     }\n-    fn make_pat(&self) -> Option<Gc<ast::Pat>> {\n-        Some(DummyResult::raw_pat(self.span))\n+    fn make_pat(self: Box<DummyResult>) -> Option<P<ast::Pat>> {\n+        Some(P(DummyResult::raw_pat(self.span)))\n     }\n-    fn make_items(&self) -> Option<SmallVector<Gc<ast::Item>>> {\n+    fn make_items(self: Box<DummyResult>) -> Option<SmallVector<P<ast::Item>>> {\n         // this code needs a comment... why not always just return the Some() ?\n         if self.expr_only {\n             None\n         } else {\n             Some(SmallVector::zero())\n         }\n     }\n-    fn make_methods(&self) -> Option<SmallVector<Gc<ast::Method>>> {\n+    fn make_methods(self: Box<DummyResult>) -> Option<SmallVector<P<ast::Method>>> {\n         if self.expr_only {\n             None\n         } else {\n             Some(SmallVector::zero())\n         }\n     }\n-    fn make_stmt(&self) -> Option<Gc<ast::Stmt>> {\n-        Some(box(GC) codemap::respan(self.span,\n-                              ast::StmtExpr(DummyResult::raw_expr(self.span),\n-                                            ast::DUMMY_NODE_ID)))\n+    fn make_stmt(self: Box<DummyResult>) -> Option<P<ast::Stmt>> {\n+        Some(P(codemap::respan(self.span,\n+                               ast::StmtExpr(DummyResult::raw_expr(self.span),\n+                                             ast::DUMMY_NODE_ID))))\n     }\n }\n \n@@ -461,7 +462,7 @@ pub struct ExtCtxt<'a> {\n \n     pub mod_path: Vec<ast::Ident> ,\n     pub trace_mac: bool,\n-    pub exported_macros: Vec<Gc<ast::Item>>,\n+    pub exported_macros: Vec<P<ast::Item>>,\n \n     pub syntax_env: SyntaxEnv,\n }\n@@ -482,7 +483,7 @@ impl<'a> ExtCtxt<'a> {\n     }\n \n     #[deprecated = \"Replaced with `expander().fold_expr()`\"]\n-    pub fn expand_expr(&mut self, e: Gc<ast::Expr>) -> Gc<ast::Expr> {\n+    pub fn expand_expr(&mut self, e: P<ast::Expr>) -> P<ast::Expr> {\n         self.expander().fold_expr(e)\n     }\n \n@@ -595,12 +596,12 @@ impl<'a> ExtCtxt<'a> {\n /// Extract a string literal from the macro expanded version of `expr`,\n /// emitting `err_msg` if `expr` is not a string literal. This does not stop\n /// compilation on error, merely emits a non-fatal error and returns None.\n-pub fn expr_to_string(cx: &mut ExtCtxt, expr: Gc<ast::Expr>, err_msg: &str)\n-                   -> Option<(InternedString, ast::StrStyle)> {\n+pub fn expr_to_string(cx: &mut ExtCtxt, expr: P<ast::Expr>, err_msg: &str)\n+                      -> Option<(InternedString, ast::StrStyle)> {\n     // we want to be able to handle e.g. concat(\"foo\", \"bar\")\n     let expr = cx.expander().fold_expr(expr);\n     match expr.node {\n-        ast::ExprLit(l) => match l.node {\n+        ast::ExprLit(ref l) => match l.node {\n             ast::LitStr(ref s, style) => return Some(((*s).clone(), style)),\n             _ => cx.span_err(l.span, err_msg)\n         },\n@@ -651,7 +652,7 @@ pub fn get_single_str_from_tts(cx: &ExtCtxt,\n /// parsing error, emit a non-fatal error and return None.\n pub fn get_exprs_from_tts(cx: &mut ExtCtxt,\n                           sp: Span,\n-                          tts: &[ast::TokenTree]) -> Option<Vec<Gc<ast::Expr>>> {\n+                          tts: &[ast::TokenTree]) -> Option<Vec<P<ast::Expr>>> {\n     let mut p = cx.new_parser_from_tts(tts);\n     let mut es = Vec::new();\n     while p.token != token::EOF {"}, {"sha": "eda373c4fb806339c6d1f937c7728c82a26cf0bf", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 236, "deletions": 291, "changes": 527, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -9,19 +9,18 @@\n // except according to those terms.\n \n use abi;\n-use ast::{P, Ident, Generics, NodeId, Expr};\n+use ast::{Ident, Generics, Expr};\n use ast;\n use ast_util;\n use attr;\n use codemap::{Span, respan, Spanned, DUMMY_SP, Pos};\n use ext::base::ExtCtxt;\n-use fold::Folder;\n use owned_slice::OwnedSlice;\n use parse::token::special_idents;\n use parse::token::InternedString;\n use parse::token;\n+use ptr::P;\n \n-use std::gc::{Gc, GC};\n \n // Transitional reexports so qquote can find the paths it is looking for\n mod syntax {\n@@ -64,7 +63,6 @@ pub trait AstBuilder {\n     fn ty_vars(&self, ty_params: &OwnedSlice<ast::TyParam>) -> Vec<P<ast::Ty>> ;\n     fn ty_vars_global(&self, ty_params: &OwnedSlice<ast::TyParam>) -> Vec<P<ast::Ty>> ;\n     fn ty_field_imm(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> ast::TypeField;\n-    fn strip_bounds(&self, bounds: &Generics) -> Generics;\n \n     fn typaram(&self,\n                span: Span,\n@@ -83,140 +81,130 @@ pub trait AstBuilder {\n                     -> ast::LifetimeDef;\n \n     // statements\n-    fn stmt_expr(&self, expr: Gc<ast::Expr>) -> Gc<ast::Stmt>;\n-    fn stmt_let(&self, sp: Span, mutbl: bool, ident: ast::Ident,\n-                ex: Gc<ast::Expr>) -> Gc<ast::Stmt>;\n+    fn stmt_expr(&self, expr: P<ast::Expr>) -> P<ast::Stmt>;\n+    fn stmt_let(&self, sp: Span, mutbl: bool, ident: ast::Ident, ex: P<ast::Expr>) -> P<ast::Stmt>;\n     fn stmt_let_typed(&self,\n                       sp: Span,\n                       mutbl: bool,\n                       ident: ast::Ident,\n                       typ: P<ast::Ty>,\n-                      ex: Gc<ast::Expr>)\n-                      -> Gc<ast::Stmt>;\n-    fn stmt_item(&self, sp: Span, item: Gc<ast::Item>) -> Gc<ast::Stmt>;\n+                      ex: P<ast::Expr>)\n+                      -> P<ast::Stmt>;\n+    fn stmt_item(&self, sp: Span, item: P<ast::Item>) -> P<ast::Stmt>;\n \n     // blocks\n-    fn block(&self, span: Span, stmts: Vec<Gc<ast::Stmt>>,\n-             expr: Option<Gc<ast::Expr>>) -> P<ast::Block>;\n-    fn block_expr(&self, expr: Gc<ast::Expr>) -> P<ast::Block>;\n+    fn block(&self, span: Span, stmts: Vec<P<ast::Stmt>>,\n+             expr: Option<P<ast::Expr>>) -> P<ast::Block>;\n+    fn block_expr(&self, expr: P<ast::Expr>) -> P<ast::Block>;\n     fn block_all(&self, span: Span,\n-                 view_items: Vec<ast::ViewItem> ,\n-                 stmts: Vec<Gc<ast::Stmt>> ,\n-                 expr: Option<Gc<ast::Expr>>) -> P<ast::Block>;\n+                 view_items: Vec<ast::ViewItem>,\n+                 stmts: Vec<P<ast::Stmt>>,\n+                 expr: Option<P<ast::Expr>>) -> P<ast::Block>;\n \n     // expressions\n-    fn expr(&self, span: Span, node: ast::Expr_) -> Gc<ast::Expr>;\n-    fn expr_path(&self, path: ast::Path) -> Gc<ast::Expr>;\n-    fn expr_ident(&self, span: Span, id: ast::Ident) -> Gc<ast::Expr>;\n+    fn expr(&self, span: Span, node: ast::Expr_) -> P<ast::Expr>;\n+    fn expr_path(&self, path: ast::Path) -> P<ast::Expr>;\n+    fn expr_ident(&self, span: Span, id: ast::Ident) -> P<ast::Expr>;\n \n-    fn expr_self(&self, span: Span) -> Gc<ast::Expr>;\n+    fn expr_self(&self, span: Span) -> P<ast::Expr>;\n     fn expr_binary(&self, sp: Span, op: ast::BinOp,\n-                   lhs: Gc<ast::Expr>, rhs: Gc<ast::Expr>) -> Gc<ast::Expr>;\n-    fn expr_deref(&self, sp: Span, e: Gc<ast::Expr>) -> Gc<ast::Expr>;\n-    fn expr_unary(&self, sp: Span, op: ast::UnOp, e: Gc<ast::Expr>) -> Gc<ast::Expr>;\n-\n-    fn expr_managed(&self, sp: Span, e: Gc<ast::Expr>) -> Gc<ast::Expr>;\n-    fn expr_addr_of(&self, sp: Span, e: Gc<ast::Expr>) -> Gc<ast::Expr>;\n-    fn expr_mut_addr_of(&self, sp: Span, e: Gc<ast::Expr>) -> Gc<ast::Expr>;\n-    fn expr_field_access(&self, span: Span, expr: Gc<ast::Expr>,\n-                         ident: ast::Ident) -> Gc<ast::Expr>;\n-    fn expr_tup_field_access(&self, sp: Span, expr: Gc<ast::Expr>,\n-                             idx: uint) -> Gc<ast::Expr>;\n-    fn expr_call(&self, span: Span, expr: Gc<ast::Expr>,\n-                 args: Vec<Gc<ast::Expr>>) -> Gc<ast::Expr>;\n-    fn expr_call_ident(&self, span: Span, id: ast::Ident,\n-                       args: Vec<Gc<ast::Expr>>) -> Gc<ast::Expr>;\n-    fn expr_call_global(&self, sp: Span, fn_path: Vec<ast::Ident> ,\n-                        args: Vec<Gc<ast::Expr>>) -> Gc<ast::Expr>;\n+                   lhs: P<ast::Expr>, rhs: P<ast::Expr>) -> P<ast::Expr>;\n+    fn expr_deref(&self, sp: Span, e: P<ast::Expr>) -> P<ast::Expr>;\n+    fn expr_unary(&self, sp: Span, op: ast::UnOp, e: P<ast::Expr>) -> P<ast::Expr>;\n+\n+    fn expr_managed(&self, sp: Span, e: P<ast::Expr>) -> P<ast::Expr>;\n+    fn expr_addr_of(&self, sp: Span, e: P<ast::Expr>) -> P<ast::Expr>;\n+    fn expr_mut_addr_of(&self, sp: Span, e: P<ast::Expr>) -> P<ast::Expr>;\n+    fn expr_field_access(&self, span: Span, expr: P<ast::Expr>, ident: ast::Ident) -> P<ast::Expr>;\n+    fn expr_tup_field_access(&self, sp: Span, expr: P<ast::Expr>,\n+                             idx: uint) -> P<ast::Expr>;\n+    fn expr_call(&self, span: Span, expr: P<ast::Expr>, args: Vec<P<ast::Expr>>) -> P<ast::Expr>;\n+    fn expr_call_ident(&self, span: Span, id: ast::Ident, args: Vec<P<ast::Expr>>) -> P<ast::Expr>;\n+    fn expr_call_global(&self, sp: Span, fn_path: Vec<ast::Ident>,\n+                        args: Vec<P<ast::Expr>> ) -> P<ast::Expr>;\n     fn expr_method_call(&self, span: Span,\n-                        expr: Gc<ast::Expr>, ident: ast::Ident,\n-                        args: Vec<Gc<ast::Expr>> ) -> Gc<ast::Expr>;\n-    fn expr_block(&self, b: P<ast::Block>) -> Gc<ast::Expr>;\n-    fn expr_cast(&self, sp: Span, expr: Gc<ast::Expr>,\n-                 ty: P<ast::Ty>) -> Gc<ast::Expr>;\n-\n-    fn field_imm(&self, span: Span, name: Ident, e: Gc<ast::Expr>) -> ast::Field;\n-    fn expr_struct(&self, span: Span, path: ast::Path,\n-                   fields: Vec<ast::Field> ) -> Gc<ast::Expr>;\n+                        expr: P<ast::Expr>, ident: ast::Ident,\n+                        args: Vec<P<ast::Expr>> ) -> P<ast::Expr>;\n+    fn expr_block(&self, b: P<ast::Block>) -> P<ast::Expr>;\n+    fn expr_cast(&self, sp: Span, expr: P<ast::Expr>, ty: P<ast::Ty>) -> P<ast::Expr>;\n+\n+    fn field_imm(&self, span: Span, name: Ident, e: P<ast::Expr>) -> ast::Field;\n+    fn expr_struct(&self, span: Span, path: ast::Path, fields: Vec<ast::Field>) -> P<ast::Expr>;\n     fn expr_struct_ident(&self, span: Span, id: ast::Ident,\n-                         fields: Vec<ast::Field> ) -> Gc<ast::Expr>;\n+                         fields: Vec<ast::Field>) -> P<ast::Expr>;\n \n-    fn expr_lit(&self, sp: Span, lit: ast::Lit_) -> Gc<ast::Expr>;\n+    fn expr_lit(&self, sp: Span, lit: ast::Lit_) -> P<ast::Expr>;\n \n-    fn expr_uint(&self, span: Span, i: uint) -> Gc<ast::Expr>;\n-    fn expr_int(&self, sp: Span, i: int) -> Gc<ast::Expr>;\n-    fn expr_u8(&self, sp: Span, u: u8) -> Gc<ast::Expr>;\n-    fn expr_bool(&self, sp: Span, value: bool) -> Gc<ast::Expr>;\n+    fn expr_uint(&self, span: Span, i: uint) -> P<ast::Expr>;\n+    fn expr_int(&self, sp: Span, i: int) -> P<ast::Expr>;\n+    fn expr_u8(&self, sp: Span, u: u8) -> P<ast::Expr>;\n+    fn expr_bool(&self, sp: Span, value: bool) -> P<ast::Expr>;\n \n-    fn expr_vec(&self, sp: Span, exprs: Vec<Gc<ast::Expr>> ) -> Gc<ast::Expr>;\n-    fn expr_vec_ng(&self, sp: Span) -> Gc<ast::Expr>;\n-    fn expr_vec_slice(&self, sp: Span, exprs: Vec<Gc<ast::Expr>> ) -> Gc<ast::Expr>;\n-    fn expr_str(&self, sp: Span, s: InternedString) -> Gc<ast::Expr>;\n+    fn expr_vec(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr>;\n+    fn expr_vec_ng(&self, sp: Span) -> P<ast::Expr>;\n+    fn expr_vec_slice(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr>;\n+    fn expr_str(&self, sp: Span, s: InternedString) -> P<ast::Expr>;\n \n-    fn expr_some(&self, sp: Span, expr: Gc<ast::Expr>) -> Gc<ast::Expr>;\n-    fn expr_none(&self, sp: Span) -> Gc<ast::Expr>;\n+    fn expr_some(&self, sp: Span, expr: P<ast::Expr>) -> P<ast::Expr>;\n+    fn expr_none(&self, sp: Span) -> P<ast::Expr>;\n \n-    fn expr_tuple(&self, sp: Span, exprs: Vec<Gc<ast::Expr>>) -> Gc<ast::Expr>;\n+    fn expr_tuple(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr>;\n \n-    fn expr_fail(&self, span: Span, msg: InternedString) -> Gc<ast::Expr>;\n-    fn expr_unreachable(&self, span: Span) -> Gc<ast::Expr>;\n+    fn expr_fail(&self, span: Span, msg: InternedString) -> P<ast::Expr>;\n+    fn expr_unreachable(&self, span: Span) -> P<ast::Expr>;\n \n-    fn expr_ok(&self, span: Span, expr: Gc<ast::Expr>) -> Gc<ast::Expr>;\n-    fn expr_err(&self, span: Span, expr: Gc<ast::Expr>) -> Gc<ast::Expr>;\n-    fn expr_try(&self, span: Span, head: Gc<ast::Expr>) -> Gc<ast::Expr>;\n+    fn expr_ok(&self, span: Span, expr: P<ast::Expr>) -> P<ast::Expr>;\n+    fn expr_err(&self, span: Span, expr: P<ast::Expr>) -> P<ast::Expr>;\n+    fn expr_try(&self, span: Span, head: P<ast::Expr>) -> P<ast::Expr>;\n \n-    fn pat(&self, span: Span, pat: ast::Pat_) -> Gc<ast::Pat>;\n-    fn pat_wild(&self, span: Span) -> Gc<ast::Pat>;\n-    fn pat_lit(&self, span: Span, expr: Gc<ast::Expr>) -> Gc<ast::Pat>;\n-    fn pat_ident(&self, span: Span, ident: ast::Ident) -> Gc<ast::Pat>;\n+    fn pat(&self, span: Span, pat: ast::Pat_) -> P<ast::Pat>;\n+    fn pat_wild(&self, span: Span) -> P<ast::Pat>;\n+    fn pat_lit(&self, span: Span, expr: P<ast::Expr>) -> P<ast::Pat>;\n+    fn pat_ident(&self, span: Span, ident: ast::Ident) -> P<ast::Pat>;\n \n     fn pat_ident_binding_mode(&self,\n                               span: Span,\n                               ident: ast::Ident,\n-                              bm: ast::BindingMode) -> Gc<ast::Pat>;\n-    fn pat_enum(&self, span: Span, path: ast::Path,\n-                subpats: Vec<Gc<ast::Pat>>) -> Gc<ast::Pat>;\n+                              bm: ast::BindingMode) -> P<ast::Pat>;\n+    fn pat_enum(&self, span: Span, path: ast::Path, subpats: Vec<P<ast::Pat>> ) -> P<ast::Pat>;\n     fn pat_struct(&self, span: Span,\n-                  path: ast::Path, field_pats: Vec<ast::FieldPat> ) -> Gc<ast::Pat>;\n-    fn pat_tuple(&self, span: Span, pats: Vec<Gc<ast::Pat>>) -> Gc<ast::Pat>;\n+                  path: ast::Path, field_pats: Vec<ast::FieldPat> ) -> P<ast::Pat>;\n+    fn pat_tuple(&self, span: Span, pats: Vec<P<ast::Pat>>) -> P<ast::Pat>;\n \n-    fn pat_some(&self, span: Span, pat: Gc<ast::Pat>) -> Gc<ast::Pat>;\n-    fn pat_none(&self, span: Span) -> Gc<ast::Pat>;\n+    fn pat_some(&self, span: Span, pat: P<ast::Pat>) -> P<ast::Pat>;\n+    fn pat_none(&self, span: Span) -> P<ast::Pat>;\n \n-    fn pat_ok(&self, span: Span, pat: Gc<ast::Pat>) -> Gc<ast::Pat>;\n-    fn pat_err(&self, span: Span, pat: Gc<ast::Pat>) -> Gc<ast::Pat>;\n+    fn pat_ok(&self, span: Span, pat: P<ast::Pat>) -> P<ast::Pat>;\n+    fn pat_err(&self, span: Span, pat: P<ast::Pat>) -> P<ast::Pat>;\n \n-    fn arm(&self, span: Span, pats: Vec<Gc<ast::Pat>> , expr: Gc<ast::Expr>) -> ast::Arm;\n+    fn arm(&self, span: Span, pats: Vec<P<ast::Pat>>, expr: P<ast::Expr>) -> ast::Arm;\n     fn arm_unreachable(&self, span: Span) -> ast::Arm;\n \n-    fn expr_match(&self, span: Span, arg: Gc<ast::Expr>, arms: Vec<ast::Arm> ) -> Gc<ast::Expr>;\n+    fn expr_match(&self, span: Span, arg: P<ast::Expr>, arms: Vec<ast::Arm> ) -> P<ast::Expr>;\n     fn expr_if(&self, span: Span,\n-               cond: Gc<ast::Expr>, then: Gc<ast::Expr>,\n-               els: Option<Gc<ast::Expr>>) -> Gc<ast::Expr>;\n-    fn expr_loop(&self, span: Span, block: P<ast::Block>) -> Gc<ast::Expr>;\n+               cond: P<ast::Expr>, then: P<ast::Expr>, els: Option<P<ast::Expr>>) -> P<ast::Expr>;\n+    fn expr_loop(&self, span: Span, block: P<ast::Block>) -> P<ast::Expr>;\n \n     fn lambda_fn_decl(&self, span: Span,\n-                      fn_decl: P<ast::FnDecl>, blk: P<ast::Block>) -> Gc<ast::Expr>;\n+                      fn_decl: P<ast::FnDecl>, blk: P<ast::Block>) -> P<ast::Expr>;\n \n-    fn lambda(&self, span: Span, ids: Vec<ast::Ident> , blk: P<ast::Block>) -> Gc<ast::Expr>;\n-    fn lambda0(&self, span: Span, blk: P<ast::Block>) -> Gc<ast::Expr>;\n-    fn lambda1(&self, span: Span, blk: P<ast::Block>, ident: ast::Ident) -> Gc<ast::Expr>;\n+    fn lambda(&self, span: Span, ids: Vec<ast::Ident> , blk: P<ast::Block>) -> P<ast::Expr>;\n+    fn lambda0(&self, span: Span, blk: P<ast::Block>) -> P<ast::Expr>;\n+    fn lambda1(&self, span: Span, blk: P<ast::Block>, ident: ast::Ident) -> P<ast::Expr>;\n \n-    fn lambda_expr(&self, span: Span, ids: Vec<ast::Ident> , blk: Gc<ast::Expr>) -> Gc<ast::Expr>;\n-    fn lambda_expr_0(&self, span: Span, expr: Gc<ast::Expr>) -> Gc<ast::Expr>;\n-    fn lambda_expr_1(&self, span: Span, expr: Gc<ast::Expr>, ident: ast::Ident) -> Gc<ast::Expr>;\n+    fn lambda_expr(&self, span: Span, ids: Vec<ast::Ident> , blk: P<ast::Expr>) -> P<ast::Expr>;\n+    fn lambda_expr_0(&self, span: Span, expr: P<ast::Expr>) -> P<ast::Expr>;\n+    fn lambda_expr_1(&self, span: Span, expr: P<ast::Expr>, ident: ast::Ident) -> P<ast::Expr>;\n \n     fn lambda_stmts(&self, span: Span, ids: Vec<ast::Ident>,\n-                    blk: Vec<Gc<ast::Stmt>>) -> Gc<ast::Expr>;\n-    fn lambda_stmts_0(&self, span: Span,\n-                      stmts: Vec<Gc<ast::Stmt>>) -> Gc<ast::Expr>;\n-    fn lambda_stmts_1(&self, span: Span,\n-                      stmts: Vec<Gc<ast::Stmt>>, ident: ast::Ident) -> Gc<ast::Expr>;\n+                    blk: Vec<P<ast::Stmt>>) -> P<ast::Expr>;\n+    fn lambda_stmts_0(&self, span: Span, stmts: Vec<P<ast::Stmt>>) -> P<ast::Expr>;\n+    fn lambda_stmts_1(&self, span: Span, stmts: Vec<P<ast::Stmt>>,\n+                      ident: ast::Ident) -> P<ast::Expr>;\n \n     // items\n     fn item(&self, span: Span,\n-            name: Ident, attrs: Vec<ast::Attribute>,\n-            node: ast::Item_) -> Gc<ast::Item>;\n+            name: Ident, attrs: Vec<ast::Attribute> , node: ast::Item_) -> P<ast::Item>;\n \n     fn arg(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> ast::Arg;\n     // FIXME unused self\n@@ -228,67 +216,64 @@ pub trait AstBuilder {\n                     inputs: Vec<ast::Arg> ,\n                     output: P<ast::Ty>,\n                     generics: Generics,\n-                    body: P<ast::Block>) -> Gc<ast::Item>;\n+                    body: P<ast::Block>) -> P<ast::Item>;\n     fn item_fn(&self,\n                span: Span,\n                name: Ident,\n                inputs: Vec<ast::Arg> ,\n                output: P<ast::Ty>,\n-               body: P<ast::Block>) -> Gc<ast::Item>;\n+               body: P<ast::Block>) -> P<ast::Item>;\n \n     fn variant(&self, span: Span, name: Ident, tys: Vec<P<ast::Ty>> ) -> ast::Variant;\n     fn item_enum_poly(&self,\n                       span: Span,\n                       name: Ident,\n                       enum_definition: ast::EnumDef,\n-                      generics: Generics) -> Gc<ast::Item>;\n-    fn item_enum(&self, span: Span, name: Ident,\n-                 enum_def: ast::EnumDef) -> Gc<ast::Item>;\n+                      generics: Generics) -> P<ast::Item>;\n+    fn item_enum(&self, span: Span, name: Ident, enum_def: ast::EnumDef) -> P<ast::Item>;\n \n     fn item_struct_poly(&self,\n                         span: Span,\n                         name: Ident,\n                         struct_def: ast::StructDef,\n-                        generics: Generics) -> Gc<ast::Item>;\n-    fn item_struct(&self, span: Span, name: Ident,\n-                   struct_def: ast::StructDef) -> Gc<ast::Item>;\n+                        generics: Generics) -> P<ast::Item>;\n+    fn item_struct(&self, span: Span, name: Ident, struct_def: ast::StructDef) -> P<ast::Item>;\n \n     fn item_mod(&self, span: Span, inner_span: Span,\n                 name: Ident, attrs: Vec<ast::Attribute>,\n-                vi: Vec<ast::ViewItem>,\n-                items: Vec<Gc<ast::Item>>) -> Gc<ast::Item>;\n+                vi: Vec<ast::ViewItem> , items: Vec<P<ast::Item>> ) -> P<ast::Item>;\n \n     fn item_static(&self,\n                    span: Span,\n                    name: Ident,\n                    ty: P<ast::Ty>,\n                    mutbl: ast::Mutability,\n-                   expr: Gc<ast::Expr>)\n-                   -> Gc<ast::Item>;\n+                   expr: P<ast::Expr>)\n+                   -> P<ast::Item>;\n \n     fn item_ty_poly(&self,\n                     span: Span,\n                     name: Ident,\n                     ty: P<ast::Ty>,\n-                    generics: Generics) -> Gc<ast::Item>;\n-    fn item_ty(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> Gc<ast::Item>;\n+                    generics: Generics) -> P<ast::Item>;\n+    fn item_ty(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> P<ast::Item>;\n \n-    fn attribute(&self, sp: Span, mi: Gc<ast::MetaItem>) -> ast::Attribute;\n+    fn attribute(&self, sp: Span, mi: P<ast::MetaItem>) -> ast::Attribute;\n \n-    fn meta_word(&self, sp: Span, w: InternedString) -> Gc<ast::MetaItem>;\n+    fn meta_word(&self, sp: Span, w: InternedString) -> P<ast::MetaItem>;\n     fn meta_list(&self,\n                  sp: Span,\n                  name: InternedString,\n-                 mis: Vec<Gc<ast::MetaItem>>)\n-                 -> Gc<ast::MetaItem>;\n+                 mis: Vec<P<ast::MetaItem>> )\n+                 -> P<ast::MetaItem>;\n     fn meta_name_value(&self,\n                        sp: Span,\n                        name: InternedString,\n                        value: ast::Lit_)\n-                       -> Gc<ast::MetaItem>;\n+                       -> P<ast::MetaItem>;\n \n     fn view_use(&self, sp: Span,\n-                vis: ast::Visibility, vp: Gc<ast::ViewPath>) -> ast::ViewItem;\n+                vis: ast::Visibility, vp: P<ast::ViewPath>) -> ast::ViewItem;\n     fn view_use_simple(&self, sp: Span, vis: ast::Visibility, path: ast::Path) -> ast::ViewItem;\n     fn view_use_simple_(&self, sp: Span, vis: ast::Visibility,\n                         ident: ast::Ident, path: ast::Path) -> ast::ViewItem;\n@@ -447,16 +432,6 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                 self.path_global(DUMMY_SP, vec!(p.ident)), None)).collect()\n     }\n \n-    fn strip_bounds(&self, generics: &Generics) -> Generics {\n-        let new_params = generics.ty_params.map(|ty_param| {\n-            ast::TyParam { bounds: OwnedSlice::empty(), unbound: None, ..*ty_param }\n-        });\n-        Generics {\n-            ty_params: new_params,\n-            .. (*generics).clone()\n-        }\n-    }\n-\n     fn trait_ref(&self, path: ast::Path) -> ast::TraitRef {\n         ast::TraitRef {\n             path: path,\n@@ -483,74 +458,71 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         }\n     }\n \n-    fn stmt_expr(&self, expr: Gc<ast::Expr>) -> Gc<ast::Stmt> {\n-        box(GC) respan(expr.span, ast::StmtSemi(expr, ast::DUMMY_NODE_ID))\n+    fn stmt_expr(&self, expr: P<ast::Expr>) -> P<ast::Stmt> {\n+        P(respan(expr.span, ast::StmtSemi(expr, ast::DUMMY_NODE_ID)))\n     }\n \n     fn stmt_let(&self, sp: Span, mutbl: bool, ident: ast::Ident,\n-                ex: Gc<ast::Expr>) -> Gc<ast::Stmt> {\n+                ex: P<ast::Expr>) -> P<ast::Stmt> {\n         let pat = if mutbl {\n             self.pat_ident_binding_mode(sp, ident, ast::BindByValue(ast::MutMutable))\n         } else {\n             self.pat_ident(sp, ident)\n         };\n-        let local = box(GC) ast::Local {\n+        let local = P(ast::Local {\n             ty: self.ty_infer(sp),\n             pat: pat,\n             init: Some(ex),\n             id: ast::DUMMY_NODE_ID,\n             span: sp,\n             source: ast::LocalLet,\n-        };\n+        });\n         let decl = respan(sp, ast::DeclLocal(local));\n-        box(GC) respan(sp, ast::StmtDecl(box(GC) decl, ast::DUMMY_NODE_ID))\n+        P(respan(sp, ast::StmtDecl(P(decl), ast::DUMMY_NODE_ID)))\n     }\n \n     fn stmt_let_typed(&self,\n                       sp: Span,\n                       mutbl: bool,\n                       ident: ast::Ident,\n                       typ: P<ast::Ty>,\n-                      ex: Gc<ast::Expr>)\n-                      -> Gc<ast::Stmt> {\n+                      ex: P<ast::Expr>)\n+                      -> P<ast::Stmt> {\n         let pat = if mutbl {\n             self.pat_ident_binding_mode(sp, ident, ast::BindByValue(ast::MutMutable))\n         } else {\n             self.pat_ident(sp, ident)\n         };\n-        let local = box(GC) ast::Local {\n+        let local = P(ast::Local {\n             ty: typ,\n             pat: pat,\n             init: Some(ex),\n             id: ast::DUMMY_NODE_ID,\n             span: sp,\n             source: ast::LocalLet,\n-        };\n+        });\n         let decl = respan(sp, ast::DeclLocal(local));\n-        box(GC) respan(sp, ast::StmtDecl(box(GC) decl, ast::DUMMY_NODE_ID))\n+        P(respan(sp, ast::StmtDecl(P(decl), ast::DUMMY_NODE_ID)))\n     }\n \n-    fn block(&self,\n-             span: Span,\n-             stmts: Vec<Gc<ast::Stmt>>,\n-             expr: Option<Gc<Expr>>)\n-             -> P<ast::Block> {\n+    fn block(&self, span: Span, stmts: Vec<P<ast::Stmt>>,\n+             expr: Option<P<Expr>>) -> P<ast::Block> {\n         self.block_all(span, Vec::new(), stmts, expr)\n     }\n \n-    fn stmt_item(&self, sp: Span, item: Gc<ast::Item>) -> Gc<ast::Stmt> {\n+    fn stmt_item(&self, sp: Span, item: P<ast::Item>) -> P<ast::Stmt> {\n         let decl = respan(sp, ast::DeclItem(item));\n-        box(GC) respan(sp, ast::StmtDecl(box(GC) decl, ast::DUMMY_NODE_ID))\n+        P(respan(sp, ast::StmtDecl(P(decl), ast::DUMMY_NODE_ID)))\n     }\n \n-    fn block_expr(&self, expr: Gc<ast::Expr>) -> P<ast::Block> {\n+    fn block_expr(&self, expr: P<ast::Expr>) -> P<ast::Block> {\n         self.block_all(expr.span, Vec::new(), Vec::new(), Some(expr))\n     }\n     fn block_all(&self,\n                  span: Span,\n-                 view_items: Vec<ast::ViewItem> ,\n-                 stmts: Vec<Gc<ast::Stmt>>,\n-                 expr: Option<Gc<ast::Expr>>) -> P<ast::Block> {\n+                 view_items: Vec<ast::ViewItem>,\n+                 stmts: Vec<P<ast::Stmt>>,\n+                 expr: Option<P<ast::Expr>>) -> P<ast::Block> {\n             P(ast::Block {\n                view_items: view_items,\n                stmts: stmts,\n@@ -561,42 +533,42 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             })\n     }\n \n-    fn expr(&self, span: Span, node: ast::Expr_) -> Gc<ast::Expr> {\n-        box(GC) ast::Expr {\n+    fn expr(&self, span: Span, node: ast::Expr_) -> P<ast::Expr> {\n+        P(ast::Expr {\n             id: ast::DUMMY_NODE_ID,\n             node: node,\n             span: span,\n-        }\n+        })\n     }\n \n-    fn expr_path(&self, path: ast::Path) -> Gc<ast::Expr> {\n+    fn expr_path(&self, path: ast::Path) -> P<ast::Expr> {\n         self.expr(path.span, ast::ExprPath(path))\n     }\n \n-    fn expr_ident(&self, span: Span, id: ast::Ident) -> Gc<ast::Expr> {\n+    fn expr_ident(&self, span: Span, id: ast::Ident) -> P<ast::Expr> {\n         self.expr_path(self.path_ident(span, id))\n     }\n-    fn expr_self(&self, span: Span) -> Gc<ast::Expr> {\n+    fn expr_self(&self, span: Span) -> P<ast::Expr> {\n         self.expr_ident(span, special_idents::self_)\n     }\n \n     fn expr_binary(&self, sp: Span, op: ast::BinOp,\n-                   lhs: Gc<ast::Expr>, rhs: Gc<ast::Expr>) -> Gc<ast::Expr> {\n+                   lhs: P<ast::Expr>, rhs: P<ast::Expr>) -> P<ast::Expr> {\n         self.expr(sp, ast::ExprBinary(op, lhs, rhs))\n     }\n \n-    fn expr_deref(&self, sp: Span, e: Gc<ast::Expr>) -> Gc<ast::Expr> {\n+    fn expr_deref(&self, sp: Span, e: P<ast::Expr>) -> P<ast::Expr> {\n         self.expr_unary(sp, ast::UnDeref, e)\n     }\n-    fn expr_unary(&self, sp: Span, op: ast::UnOp, e: Gc<ast::Expr>) -> Gc<ast::Expr> {\n+    fn expr_unary(&self, sp: Span, op: ast::UnOp, e: P<ast::Expr>) -> P<ast::Expr> {\n         self.expr(sp, ast::ExprUnary(op, e))\n     }\n \n-    fn expr_managed(&self, sp: Span, e: Gc<ast::Expr>) -> Gc<ast::Expr> {\n+    fn expr_managed(&self, sp: Span, e: P<ast::Expr>) -> P<ast::Expr> {\n         self.expr_unary(sp, ast::UnBox, e)\n     }\n \n-    fn expr_field_access(&self, sp: Span, expr: Gc<ast::Expr>, ident: ast::Ident) -> Gc<ast::Expr> {\n+    fn expr_field_access(&self, sp: Span, expr: P<ast::Expr>, ident: ast::Ident) -> P<ast::Expr> {\n         let field_name = token::get_ident(ident);\n         let field_span = Span {\n             lo: sp.lo - Pos::from_uint(field_name.get().len()),\n@@ -607,7 +579,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         let id = Spanned { node: ident, span: field_span };\n         self.expr(sp, ast::ExprField(expr, id, Vec::new()))\n     }\n-    fn expr_tup_field_access(&self, sp: Span, expr: Gc<ast::Expr>, idx: uint) -> Gc<ast::Expr> {\n+    fn expr_tup_field_access(&self, sp: Span, expr: P<ast::Expr>, idx: uint) -> P<ast::Expr> {\n         let field_span = Span {\n             lo: sp.lo - Pos::from_uint(idx.to_string().len()),\n             hi: sp.hi,\n@@ -617,108 +589,107 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         let id = Spanned { node: idx, span: field_span };\n         self.expr(sp, ast::ExprTupField(expr, id, Vec::new()))\n     }\n-    fn expr_addr_of(&self, sp: Span, e: Gc<ast::Expr>) -> Gc<ast::Expr> {\n+    fn expr_addr_of(&self, sp: Span, e: P<ast::Expr>) -> P<ast::Expr> {\n         self.expr(sp, ast::ExprAddrOf(ast::MutImmutable, e))\n     }\n-    fn expr_mut_addr_of(&self, sp: Span, e: Gc<ast::Expr>) -> Gc<ast::Expr> {\n+    fn expr_mut_addr_of(&self, sp: Span, e: P<ast::Expr>) -> P<ast::Expr> {\n         self.expr(sp, ast::ExprAddrOf(ast::MutMutable, e))\n     }\n \n-    fn expr_call(&self, span: Span, expr: Gc<ast::Expr>,\n-                 args: Vec<Gc<ast::Expr>>) -> Gc<ast::Expr> {\n+    fn expr_call(&self, span: Span, expr: P<ast::Expr>, args: Vec<P<ast::Expr>>) -> P<ast::Expr> {\n         self.expr(span, ast::ExprCall(expr, args))\n     }\n     fn expr_call_ident(&self, span: Span, id: ast::Ident,\n-                       args: Vec<Gc<ast::Expr>>) -> Gc<ast::Expr> {\n+                       args: Vec<P<ast::Expr>>) -> P<ast::Expr> {\n         self.expr(span, ast::ExprCall(self.expr_ident(span, id), args))\n     }\n     fn expr_call_global(&self, sp: Span, fn_path: Vec<ast::Ident> ,\n-                      args: Vec<Gc<ast::Expr>> ) -> Gc<ast::Expr> {\n+                      args: Vec<P<ast::Expr>> ) -> P<ast::Expr> {\n         let pathexpr = self.expr_path(self.path_global(sp, fn_path));\n         self.expr_call(sp, pathexpr, args)\n     }\n     fn expr_method_call(&self, span: Span,\n-                        expr: Gc<ast::Expr>,\n+                        expr: P<ast::Expr>,\n                         ident: ast::Ident,\n-                        mut args: Vec<Gc<ast::Expr>> ) -> Gc<ast::Expr> {\n+                        mut args: Vec<P<ast::Expr>> ) -> P<ast::Expr> {\n         let id = Spanned { node: ident, span: span };\n         args.unshift(expr);\n         self.expr(span, ast::ExprMethodCall(id, Vec::new(), args))\n     }\n-    fn expr_block(&self, b: P<ast::Block>) -> Gc<ast::Expr> {\n+    fn expr_block(&self, b: P<ast::Block>) -> P<ast::Expr> {\n         self.expr(b.span, ast::ExprBlock(b))\n     }\n-    fn field_imm(&self, span: Span, name: Ident, e: Gc<ast::Expr>) -> ast::Field {\n+    fn field_imm(&self, span: Span, name: Ident, e: P<ast::Expr>) -> ast::Field {\n         ast::Field { ident: respan(span, name), expr: e, span: span }\n     }\n-    fn expr_struct(&self, span: Span, path: ast::Path, fields: Vec<ast::Field> ) -> Gc<ast::Expr> {\n+    fn expr_struct(&self, span: Span, path: ast::Path, fields: Vec<ast::Field>) -> P<ast::Expr> {\n         self.expr(span, ast::ExprStruct(path, fields, None))\n     }\n     fn expr_struct_ident(&self, span: Span,\n-                         id: ast::Ident, fields: Vec<ast::Field> ) -> Gc<ast::Expr> {\n+                         id: ast::Ident, fields: Vec<ast::Field>) -> P<ast::Expr> {\n         self.expr_struct(span, self.path_ident(span, id), fields)\n     }\n \n-    fn expr_lit(&self, sp: Span, lit: ast::Lit_) -> Gc<ast::Expr> {\n-        self.expr(sp, ast::ExprLit(box(GC) respan(sp, lit)))\n+    fn expr_lit(&self, sp: Span, lit: ast::Lit_) -> P<ast::Expr> {\n+        self.expr(sp, ast::ExprLit(P(respan(sp, lit))))\n     }\n-    fn expr_uint(&self, span: Span, i: uint) -> Gc<ast::Expr> {\n+    fn expr_uint(&self, span: Span, i: uint) -> P<ast::Expr> {\n         self.expr_lit(span, ast::LitInt(i as u64, ast::UnsignedIntLit(ast::TyU)))\n     }\n-    fn expr_int(&self, sp: Span, i: int) -> Gc<ast::Expr> {\n+    fn expr_int(&self, sp: Span, i: int) -> P<ast::Expr> {\n         self.expr_lit(sp, ast::LitInt(i as u64, ast::SignedIntLit(ast::TyI, ast::Sign::new(i))))\n     }\n-    fn expr_u8(&self, sp: Span, u: u8) -> Gc<ast::Expr> {\n+    fn expr_u8(&self, sp: Span, u: u8) -> P<ast::Expr> {\n         self.expr_lit(sp, ast::LitInt(u as u64, ast::UnsignedIntLit(ast::TyU8)))\n     }\n-    fn expr_bool(&self, sp: Span, value: bool) -> Gc<ast::Expr> {\n+    fn expr_bool(&self, sp: Span, value: bool) -> P<ast::Expr> {\n         self.expr_lit(sp, ast::LitBool(value))\n     }\n \n-    fn expr_vec(&self, sp: Span, exprs: Vec<Gc<ast::Expr>> ) -> Gc<ast::Expr> {\n+    fn expr_vec(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr> {\n         self.expr(sp, ast::ExprVec(exprs))\n     }\n-    fn expr_vec_ng(&self, sp: Span) -> Gc<ast::Expr> {\n+    fn expr_vec_ng(&self, sp: Span) -> P<ast::Expr> {\n         self.expr_call_global(sp,\n                               vec!(self.ident_of(\"std\"),\n                                    self.ident_of(\"vec\"),\n                                    self.ident_of(\"Vec\"),\n                                    self.ident_of(\"new\")),\n                               Vec::new())\n     }\n-    fn expr_vec_slice(&self, sp: Span, exprs: Vec<Gc<ast::Expr>> ) -> Gc<ast::Expr> {\n+    fn expr_vec_slice(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr> {\n         self.expr_addr_of(sp, self.expr_vec(sp, exprs))\n     }\n-    fn expr_str(&self, sp: Span, s: InternedString) -> Gc<ast::Expr> {\n+    fn expr_str(&self, sp: Span, s: InternedString) -> P<ast::Expr> {\n         self.expr_lit(sp, ast::LitStr(s, ast::CookedStr))\n     }\n \n-    fn expr_cast(&self, sp: Span, expr: Gc<ast::Expr>, ty: P<ast::Ty>) -> Gc<ast::Expr> {\n+    fn expr_cast(&self, sp: Span, expr: P<ast::Expr>, ty: P<ast::Ty>) -> P<ast::Expr> {\n         self.expr(sp, ast::ExprCast(expr, ty))\n     }\n \n \n-    fn expr_some(&self, sp: Span, expr: Gc<ast::Expr>) -> Gc<ast::Expr> {\n+    fn expr_some(&self, sp: Span, expr: P<ast::Expr>) -> P<ast::Expr> {\n         let some = vec!(\n             self.ident_of(\"std\"),\n             self.ident_of(\"option\"),\n             self.ident_of(\"Some\"));\n         self.expr_call_global(sp, some, vec!(expr))\n     }\n \n-    fn expr_none(&self, sp: Span) -> Gc<ast::Expr> {\n+    fn expr_none(&self, sp: Span) -> P<ast::Expr> {\n         let none = self.path_global(sp, vec!(\n             self.ident_of(\"std\"),\n             self.ident_of(\"option\"),\n             self.ident_of(\"None\")));\n         self.expr_path(none)\n     }\n \n-    fn expr_tuple(&self, sp: Span, exprs: Vec<Gc<ast::Expr>>) -> Gc<ast::Expr> {\n+    fn expr_tuple(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr> {\n         self.expr(sp, ast::ExprTup(exprs))\n     }\n \n-    fn expr_fail(&self, span: Span, msg: InternedString) -> Gc<ast::Expr> {\n+    fn expr_fail(&self, span: Span, msg: InternedString) -> P<ast::Expr> {\n         let loc = self.codemap().lookup_char_pos(span.lo);\n         let expr_file = self.expr_str(span,\n                                       token::intern_and_get_ident(loc.file\n@@ -738,29 +709,29 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                 expr_file_line_ptr))\n     }\n \n-    fn expr_unreachable(&self, span: Span) -> Gc<ast::Expr> {\n+    fn expr_unreachable(&self, span: Span) -> P<ast::Expr> {\n         self.expr_fail(span,\n                        InternedString::new(\n                            \"internal error: entered unreachable code\"))\n     }\n \n-    fn expr_ok(&self, sp: Span, expr: Gc<ast::Expr>) -> Gc<ast::Expr> {\n+    fn expr_ok(&self, sp: Span, expr: P<ast::Expr>) -> P<ast::Expr> {\n         let ok = vec!(\n             self.ident_of(\"std\"),\n             self.ident_of(\"result\"),\n             self.ident_of(\"Ok\"));\n         self.expr_call_global(sp, ok, vec!(expr))\n     }\n \n-    fn expr_err(&self, sp: Span, expr: Gc<ast::Expr>) -> Gc<ast::Expr> {\n+    fn expr_err(&self, sp: Span, expr: P<ast::Expr>) -> P<ast::Expr> {\n         let err = vec!(\n             self.ident_of(\"std\"),\n             self.ident_of(\"result\"),\n             self.ident_of(\"Err\"));\n         self.expr_call_global(sp, err, vec!(expr))\n     }\n \n-    fn expr_try(&self, sp: Span, head: Gc<ast::Expr>) -> Gc<ast::Expr> {\n+    fn expr_try(&self, sp: Span, head: P<ast::Expr>) -> P<ast::Expr> {\n         let ok = self.ident_of(\"Ok\");\n         let ok_path = self.path_ident(sp, ok);\n         let err = self.ident_of(\"Err\");\n@@ -771,11 +742,11 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         let binding_expr = self.expr_ident(sp, binding_variable);\n \n         // Ok(__try_var) pattern\n-        let ok_pat = self.pat_enum(sp, ok_path, vec!(binding_pat));\n+        let ok_pat = self.pat_enum(sp, ok_path, vec!(binding_pat.clone()));\n \n         // Err(__try_var)  (pattern and expression resp.)\n         let err_pat = self.pat_enum(sp, err_path, vec!(binding_pat));\n-        let err_inner_expr = self.expr_call_ident(sp, err, vec!(binding_expr));\n+        let err_inner_expr = self.expr_call_ident(sp, err, vec!(binding_expr.clone()));\n         // return Err(__try_var)\n         let err_expr = self.expr(sp, ast::ExprRet(Some(err_inner_expr)));\n \n@@ -789,41 +760,41 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n \n-    fn pat(&self, span: Span, pat: ast::Pat_) -> Gc<ast::Pat> {\n-        box(GC) ast::Pat { id: ast::DUMMY_NODE_ID, node: pat, span: span }\n+    fn pat(&self, span: Span, pat: ast::Pat_) -> P<ast::Pat> {\n+        P(ast::Pat { id: ast::DUMMY_NODE_ID, node: pat, span: span })\n     }\n-    fn pat_wild(&self, span: Span) -> Gc<ast::Pat> {\n+    fn pat_wild(&self, span: Span) -> P<ast::Pat> {\n         self.pat(span, ast::PatWild(ast::PatWildSingle))\n     }\n-    fn pat_lit(&self, span: Span, expr: Gc<ast::Expr>) -> Gc<ast::Pat> {\n+    fn pat_lit(&self, span: Span, expr: P<ast::Expr>) -> P<ast::Pat> {\n         self.pat(span, ast::PatLit(expr))\n     }\n-    fn pat_ident(&self, span: Span, ident: ast::Ident) -> Gc<ast::Pat> {\n+    fn pat_ident(&self, span: Span, ident: ast::Ident) -> P<ast::Pat> {\n         self.pat_ident_binding_mode(span, ident, ast::BindByValue(ast::MutImmutable))\n     }\n \n     fn pat_ident_binding_mode(&self,\n                               span: Span,\n                               ident: ast::Ident,\n-                              bm: ast::BindingMode) -> Gc<ast::Pat> {\n+                              bm: ast::BindingMode) -> P<ast::Pat> {\n         let pat = ast::PatIdent(bm, Spanned{span: span, node: ident}, None);\n         self.pat(span, pat)\n     }\n-    fn pat_enum(&self, span: Span, path: ast::Path, subpats: Vec<Gc<ast::Pat>> ) -> Gc<ast::Pat> {\n+    fn pat_enum(&self, span: Span, path: ast::Path, subpats: Vec<P<ast::Pat>>) -> P<ast::Pat> {\n         let pat = ast::PatEnum(path, Some(subpats));\n         self.pat(span, pat)\n     }\n     fn pat_struct(&self, span: Span,\n-                  path: ast::Path, field_pats: Vec<ast::FieldPat> ) -> Gc<ast::Pat> {\n+                  path: ast::Path, field_pats: Vec<ast::FieldPat>) -> P<ast::Pat> {\n         let pat = ast::PatStruct(path, field_pats, false);\n         self.pat(span, pat)\n     }\n-    fn pat_tuple(&self, span: Span, pats: Vec<Gc<ast::Pat>>) -> Gc<ast::Pat> {\n+    fn pat_tuple(&self, span: Span, pats: Vec<P<ast::Pat>>) -> P<ast::Pat> {\n         let pat = ast::PatTup(pats);\n         self.pat(span, pat)\n     }\n \n-    fn pat_some(&self, span: Span, pat: Gc<ast::Pat>) -> Gc<ast::Pat> {\n+    fn pat_some(&self, span: Span, pat: P<ast::Pat>) -> P<ast::Pat> {\n         let some = vec!(\n             self.ident_of(\"std\"),\n             self.ident_of(\"option\"),\n@@ -832,7 +803,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.pat_enum(span, path, vec!(pat))\n     }\n \n-    fn pat_none(&self, span: Span) -> Gc<ast::Pat> {\n+    fn pat_none(&self, span: Span) -> P<ast::Pat> {\n         let some = vec!(\n             self.ident_of(\"std\"),\n             self.ident_of(\"option\"),\n@@ -841,7 +812,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.pat_enum(span, path, vec!())\n     }\n \n-    fn pat_ok(&self, span: Span, pat: Gc<ast::Pat>) -> Gc<ast::Pat> {\n+    fn pat_ok(&self, span: Span, pat: P<ast::Pat>) -> P<ast::Pat> {\n         let some = vec!(\n             self.ident_of(\"std\"),\n             self.ident_of(\"result\"),\n@@ -850,7 +821,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.pat_enum(span, path, vec!(pat))\n     }\n \n-    fn pat_err(&self, span: Span, pat: Gc<ast::Pat>) -> Gc<ast::Pat> {\n+    fn pat_err(&self, span: Span, pat: P<ast::Pat>) -> P<ast::Pat> {\n         let some = vec!(\n             self.ident_of(\"std\"),\n             self.ident_of(\"result\"),\n@@ -859,7 +830,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.pat_enum(span, path, vec!(pat))\n     }\n \n-    fn arm(&self, _span: Span, pats: Vec<Gc<ast::Pat>> , expr: Gc<ast::Expr>) -> ast::Arm {\n+    fn arm(&self, _span: Span, pats: Vec<P<ast::Pat>>, expr: P<ast::Expr>) -> ast::Arm {\n         ast::Arm {\n             attrs: vec!(),\n             pats: pats,\n@@ -872,64 +843,62 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.arm(span, vec!(self.pat_wild(span)), self.expr_unreachable(span))\n     }\n \n-    fn expr_match(&self, span: Span, arg: Gc<ast::Expr>,\n-                  arms: Vec<ast::Arm>) -> Gc<Expr> {\n+    fn expr_match(&self, span: Span, arg: P<ast::Expr>, arms: Vec<ast::Arm>) -> P<Expr> {\n         self.expr(span, ast::ExprMatch(arg, arms))\n     }\n \n-    fn expr_if(&self, span: Span,\n-               cond: Gc<ast::Expr>, then: Gc<ast::Expr>,\n-               els: Option<Gc<ast::Expr>>) -> Gc<ast::Expr> {\n+    fn expr_if(&self, span: Span, cond: P<ast::Expr>,\n+               then: P<ast::Expr>, els: Option<P<ast::Expr>>) -> P<ast::Expr> {\n         let els = els.map(|x| self.expr_block(self.block_expr(x)));\n         self.expr(span, ast::ExprIf(cond, self.block_expr(then), els))\n     }\n \n-    fn expr_loop(&self, span: Span, block: P<ast::Block>) -> Gc<ast::Expr> {\n+    fn expr_loop(&self, span: Span, block: P<ast::Block>) -> P<ast::Expr> {\n         self.expr(span, ast::ExprLoop(block, None))\n     }\n \n     fn lambda_fn_decl(&self, span: Span,\n-                      fn_decl: P<ast::FnDecl>, blk: P<ast::Block>) -> Gc<ast::Expr> {\n+                      fn_decl: P<ast::FnDecl>, blk: P<ast::Block>) -> P<ast::Expr> {\n         self.expr(span, ast::ExprFnBlock(ast::CaptureByRef, fn_decl, blk))\n     }\n-    fn lambda(&self, span: Span, ids: Vec<ast::Ident> , blk: P<ast::Block>) -> Gc<ast::Expr> {\n+    fn lambda(&self, span: Span, ids: Vec<ast::Ident>, blk: P<ast::Block>) -> P<ast::Expr> {\n         let fn_decl = self.fn_decl(\n             ids.iter().map(|id| self.arg(span, *id, self.ty_infer(span))).collect(),\n             self.ty_infer(span));\n \n         self.expr(span, ast::ExprFnBlock(ast::CaptureByRef, fn_decl, blk))\n     }\n-    fn lambda0(&self, span: Span, blk: P<ast::Block>) -> Gc<ast::Expr> {\n+    fn lambda0(&self, span: Span, blk: P<ast::Block>) -> P<ast::Expr> {\n         self.lambda(span, Vec::new(), blk)\n     }\n \n-    fn lambda1(&self, span: Span, blk: P<ast::Block>, ident: ast::Ident) -> Gc<ast::Expr> {\n+    fn lambda1(&self, span: Span, blk: P<ast::Block>, ident: ast::Ident) -> P<ast::Expr> {\n         self.lambda(span, vec!(ident), blk)\n     }\n \n-    fn lambda_expr(&self, span: Span, ids: Vec<ast::Ident> , expr: Gc<ast::Expr>) -> Gc<ast::Expr> {\n+    fn lambda_expr(&self, span: Span, ids: Vec<ast::Ident>,\n+                   expr: P<ast::Expr>) -> P<ast::Expr> {\n         self.lambda(span, ids, self.block_expr(expr))\n     }\n-    fn lambda_expr_0(&self, span: Span, expr: Gc<ast::Expr>) -> Gc<ast::Expr> {\n+    fn lambda_expr_0(&self, span: Span, expr: P<ast::Expr>) -> P<ast::Expr> {\n         self.lambda0(span, self.block_expr(expr))\n     }\n-    fn lambda_expr_1(&self, span: Span, expr: Gc<ast::Expr>, ident: ast::Ident) -> Gc<ast::Expr> {\n+    fn lambda_expr_1(&self, span: Span, expr: P<ast::Expr>, ident: ast::Ident) -> P<ast::Expr> {\n         self.lambda1(span, self.block_expr(expr), ident)\n     }\n \n     fn lambda_stmts(&self,\n                     span: Span,\n                     ids: Vec<ast::Ident>,\n-                    stmts: Vec<Gc<ast::Stmt>>)\n-                    -> Gc<ast::Expr> {\n+                    stmts: Vec<P<ast::Stmt>>)\n+                    -> P<ast::Expr> {\n         self.lambda(span, ids, self.block(span, stmts, None))\n     }\n-    fn lambda_stmts_0(&self, span: Span,\n-                      stmts: Vec<Gc<ast::Stmt>>) -> Gc<ast::Expr> {\n+    fn lambda_stmts_0(&self, span: Span, stmts: Vec<P<ast::Stmt>>) -> P<ast::Expr> {\n         self.lambda0(span, self.block(span, stmts, None))\n     }\n-    fn lambda_stmts_1(&self, span: Span, stmts: Vec<Gc<ast::Stmt>>,\n-                      ident: ast::Ident) -> Gc<ast::Expr> {\n+    fn lambda_stmts_1(&self, span: Span, stmts: Vec<P<ast::Stmt>>,\n+                      ident: ast::Ident) -> P<ast::Expr> {\n         self.lambda1(span, self.block(span, stmts, None), ident)\n     }\n \n@@ -952,17 +921,18 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         })\n     }\n \n-    fn item(&self, span: Span,\n-            name: Ident, attrs: Vec<ast::Attribute>,\n-            node: ast::Item_) -> Gc<ast::Item> {\n+    fn item(&self, span: Span, name: Ident,\n+            attrs: Vec<ast::Attribute>, node: ast::Item_) -> P<ast::Item> {\n         // FIXME: Would be nice if our generated code didn't violate\n         // Rust coding conventions\n-        box(GC) ast::Item { ident: name,\n-                    attrs: attrs,\n-                    id: ast::DUMMY_NODE_ID,\n-                    node: node,\n-                    vis: ast::Inherited,\n-                    span: span }\n+        P(ast::Item {\n+            ident: name,\n+            attrs: attrs,\n+            id: ast::DUMMY_NODE_ID,\n+            node: node,\n+            vis: ast::Inherited,\n+            span: span\n+        })\n     }\n \n     fn item_fn_poly(&self,\n@@ -971,7 +941,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                     inputs: Vec<ast::Arg> ,\n                     output: P<ast::Ty>,\n                     generics: Generics,\n-                    body: P<ast::Block>) -> Gc<ast::Item> {\n+                    body: P<ast::Block>) -> P<ast::Item> {\n         self.item(span,\n                   name,\n                   Vec::new(),\n@@ -988,7 +958,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                inputs: Vec<ast::Arg> ,\n                output: P<ast::Ty>,\n                body: P<ast::Block>\n-              ) -> Gc<ast::Item> {\n+              ) -> P<ast::Item> {\n         self.item_fn_poly(\n             span,\n             name,\n@@ -1016,18 +986,18 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n \n     fn item_enum_poly(&self, span: Span, name: Ident,\n                       enum_definition: ast::EnumDef,\n-                      generics: Generics) -> Gc<ast::Item> {\n+                      generics: Generics) -> P<ast::Item> {\n         self.item(span, name, Vec::new(), ast::ItemEnum(enum_definition, generics))\n     }\n \n     fn item_enum(&self, span: Span, name: Ident,\n-                 enum_definition: ast::EnumDef) -> Gc<ast::Item> {\n+                 enum_definition: ast::EnumDef) -> P<ast::Item> {\n         self.item_enum_poly(span, name, enum_definition,\n                             ast_util::empty_generics())\n     }\n \n     fn item_struct(&self, span: Span, name: Ident,\n-                   struct_def: ast::StructDef) -> Gc<ast::Item> {\n+                   struct_def: ast::StructDef) -> P<ast::Item> {\n         self.item_struct_poly(\n             span,\n             name,\n@@ -1037,14 +1007,14 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn item_struct_poly(&self, span: Span, name: Ident,\n-        struct_def: ast::StructDef, generics: Generics) -> Gc<ast::Item> {\n-        self.item(span, name, Vec::new(), ast::ItemStruct(box(GC) struct_def, generics))\n+        struct_def: ast::StructDef, generics: Generics) -> P<ast::Item> {\n+        self.item(span, name, Vec::new(), ast::ItemStruct(P(struct_def), generics))\n     }\n \n     fn item_mod(&self, span: Span, inner_span: Span, name: Ident,\n                 attrs: Vec<ast::Attribute> ,\n                 vi: Vec<ast::ViewItem> ,\n-                items: Vec<Gc<ast::Item>>) -> Gc<ast::Item> {\n+                items: Vec<P<ast::Item>> ) -> P<ast::Item> {\n         self.item(\n             span,\n             name,\n@@ -1062,21 +1032,21 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                    name: Ident,\n                    ty: P<ast::Ty>,\n                    mutbl: ast::Mutability,\n-                   expr: Gc<ast::Expr>)\n-                   -> Gc<ast::Item> {\n+                   expr: P<ast::Expr>)\n+                   -> P<ast::Item> {\n         self.item(span, name, Vec::new(), ast::ItemStatic(ty, mutbl, expr))\n     }\n \n     fn item_ty_poly(&self, span: Span, name: Ident, ty: P<ast::Ty>,\n-                    generics: Generics) -> Gc<ast::Item> {\n+                    generics: Generics) -> P<ast::Item> {\n         self.item(span, name, Vec::new(), ast::ItemTy(ty, generics))\n     }\n \n-    fn item_ty(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> Gc<ast::Item> {\n+    fn item_ty(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> P<ast::Item> {\n         self.item_ty_poly(span, name, ty, ast_util::empty_generics())\n     }\n \n-    fn attribute(&self, sp: Span, mi: Gc<ast::MetaItem>) -> ast::Attribute {\n+    fn attribute(&self, sp: Span, mi: P<ast::MetaItem>) -> ast::Attribute {\n         respan(sp, ast::Attribute_ {\n             id: attr::mk_attr_id(),\n             style: ast::AttrOuter,\n@@ -1085,26 +1055,26 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         })\n     }\n \n-    fn meta_word(&self, sp: Span, w: InternedString) -> Gc<ast::MetaItem> {\n-        box(GC) respan(sp, ast::MetaWord(w))\n+    fn meta_word(&self, sp: Span, w: InternedString) -> P<ast::MetaItem> {\n+        P(respan(sp, ast::MetaWord(w)))\n     }\n     fn meta_list(&self,\n                  sp: Span,\n                  name: InternedString,\n-                 mis: Vec<Gc<ast::MetaItem>> )\n-                 -> Gc<ast::MetaItem> {\n-        box(GC) respan(sp, ast::MetaList(name, mis))\n+                 mis: Vec<P<ast::MetaItem>> )\n+                 -> P<ast::MetaItem> {\n+        P(respan(sp, ast::MetaList(name, mis)))\n     }\n     fn meta_name_value(&self,\n                        sp: Span,\n                        name: InternedString,\n                        value: ast::Lit_)\n-                       -> Gc<ast::MetaItem> {\n-        box(GC) respan(sp, ast::MetaNameValue(name, respan(sp, value)))\n+                       -> P<ast::MetaItem> {\n+        P(respan(sp, ast::MetaNameValue(name, respan(sp, value))))\n     }\n \n     fn view_use(&self, sp: Span,\n-                vis: ast::Visibility, vp: Gc<ast::ViewPath>) -> ast::ViewItem {\n+                vis: ast::Visibility, vp: P<ast::ViewPath>) -> ast::ViewItem {\n         ast::ViewItem {\n             node: ast::ViewItemUse(vp),\n             attrs: Vec::new(),\n@@ -1121,10 +1091,10 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn view_use_simple_(&self, sp: Span, vis: ast::Visibility,\n                         ident: ast::Ident, path: ast::Path) -> ast::ViewItem {\n         self.view_use(sp, vis,\n-                      box(GC) respan(sp,\n-                           ast::ViewPathSimple(ident,\n-                                               path,\n-                                               ast::DUMMY_NODE_ID)))\n+                      P(respan(sp,\n+                               ast::ViewPathSimple(ident,\n+                                                   path,\n+                                                   ast::DUMMY_NODE_ID))))\n     }\n \n     fn view_use_list(&self, sp: Span, vis: ast::Visibility,\n@@ -1134,41 +1104,16 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         }).collect();\n \n         self.view_use(sp, vis,\n-                      box(GC) respan(sp,\n-                           ast::ViewPathList(self.path(sp, path),\n-                                             imports,\n-                                             ast::DUMMY_NODE_ID)))\n+                      P(respan(sp,\n+                               ast::ViewPathList(self.path(sp, path),\n+                                                 imports,\n+                                                 ast::DUMMY_NODE_ID))))\n     }\n \n     fn view_use_glob(&self, sp: Span,\n                      vis: ast::Visibility, path: Vec<ast::Ident> ) -> ast::ViewItem {\n         self.view_use(sp, vis,\n-                      box(GC) respan(sp,\n-                           ast::ViewPathGlob(self.path(sp, path), ast::DUMMY_NODE_ID)))\n-    }\n-}\n-\n-struct Duplicator<'a>;\n-\n-impl<'a> Folder for Duplicator<'a> {\n-    fn new_id(&mut self, _: NodeId) -> NodeId {\n-        ast::DUMMY_NODE_ID\n-    }\n-}\n-\n-pub trait Duplicate {\n-    //\n-    // Duplication functions\n-    //\n-    // These functions just duplicate AST nodes.\n-    //\n-\n-    fn duplicate(&self, cx: &ExtCtxt) -> Self;\n-}\n-\n-impl Duplicate for Gc<ast::Expr> {\n-    fn duplicate(&self, _: &ExtCtxt) -> Gc<ast::Expr> {\n-        let mut folder = Duplicator;\n-        folder.fold_expr(*self)\n+                      P(respan(sp,\n+                               ast::ViewPathGlob(self.path(sp, path), ast::DUMMY_NODE_ID))))\n     }\n }"}, {"sha": "3e0f340ad7ff6138e475aca1a534c95b074de9a7", "filename": "src/libsyntax/ext/bytes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fext%2Fbytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fext%2Fbytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbytes.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -40,7 +40,7 @@ pub fn expand_syntax_ext<'cx>(cx: &'cx mut ExtCtxt,\n     for expr in exprs.iter() {\n         match expr.node {\n             // expression is a literal\n-            ast::ExprLit(lit) => match lit.node {\n+            ast::ExprLit(ref lit) => match lit.node {\n                 // string literal, push each byte to vector expression\n                 ast::LitStr(ref s, _) => {\n                     for byte in s.get().bytes() {"}, {"sha": "79cb47fee7b45a4ef01c4c8da7261a064cfea505", "filename": "src/libsyntax/ext/cfg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fext%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fext%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fcfg.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -40,10 +40,10 @@ pub fn expand_cfg<'cx>(cx: &mut ExtCtxt,\n     }\n \n     // test_cfg searches for meta items looking like `cfg(foo, ...)`\n-    let in_cfg = &[cx.meta_list(sp, InternedString::new(\"cfg\"), cfgs)];\n+    let in_cfg = Some(cx.meta_list(sp, InternedString::new(\"cfg\"), cfgs));\n \n     let matches_cfg = attr::test_cfg(cx.cfg().as_slice(),\n-                                     in_cfg.iter().map(|&x| x));\n+                                     in_cfg.iter());\n     let e = cx.expr_bool(sp, matches_cfg);\n     MacExpr::new(e)\n }"}, {"sha": "455148bfedd50f9087b2b29dbde8a0aa6e84d914", "filename": "src/libsyntax/ext/concat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fext%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fext%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -27,7 +27,7 @@ pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n     let mut accumulator = String::new();\n     for e in es.move_iter() {\n         match e.node {\n-            ast::ExprLit(lit) => {\n+            ast::ExprLit(ref lit) => {\n                 match lit.node {\n                     ast::LitStr(ref s, _) |\n                     ast::LitFloat(ref s, _) |"}, {"sha": "145412caa0bfe44bbac17fa10e7ac0a512181cd4", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -15,8 +15,7 @@ use ext::base;\n use owned_slice::OwnedSlice;\n use parse::token;\n use parse::token::{str_to_ident};\n-\n-use std::gc::GC;\n+use ptr::P;\n \n pub fn expand_syntax_ext<'cx>(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                               -> Box<base::MacResult+'cx> {\n@@ -44,7 +43,7 @@ pub fn expand_syntax_ext<'cx>(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree]\n     }\n     let res = str_to_ident(res_str.as_slice());\n \n-    let e = box(GC) ast::Expr {\n+    let e = P(ast::Expr {\n         id: ast::DUMMY_NODE_ID,\n         node: ast::ExprPath(\n             ast::Path {\n@@ -60,6 +59,6 @@ pub fn expand_syntax_ext<'cx>(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree]\n             }\n         ),\n         span: sp,\n-    };\n+    });\n     MacExpr::new(e)\n }"}, {"sha": "0595b0bc7f4409e417fcfc95fbb460c159b15ce5", "filename": "src/libsyntax/ext/deriving/bounds.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -13,14 +13,13 @@ use codemap::Span;\n use ext::base::ExtCtxt;\n use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n-\n-use std::gc::Gc;\n+use ptr::P;\n \n pub fn expand_deriving_bound(cx: &mut ExtCtxt,\n                              span: Span,\n-                             mitem: Gc<MetaItem>,\n-                             item: Gc<Item>,\n-                             push: |Gc<Item>|) {\n+                             mitem: &MetaItem,\n+                             item: &Item,\n+                             push: |P<Item>|) {\n \n     let name = match mitem.node {\n         MetaWord(ref tname) => {"}, {"sha": "64607ffd5d4c931ca3e5b4a253be9622bf8ce3ca", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -15,14 +15,13 @@ use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n-\n-use std::gc::Gc;\n+use ptr::P;\n \n pub fn expand_deriving_clone(cx: &mut ExtCtxt,\n                              span: Span,\n-                             mitem: Gc<MetaItem>,\n-                             item: Gc<Item>,\n-                             push: |Gc<Item>|) {\n+                             mitem: &MetaItem,\n+                             item: &Item,\n+                             push: |P<Item>|) {\n     let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n     let attrs = vec!(cx.attribute(span, inline));\n     let trait_def = TraitDef {\n@@ -52,12 +51,12 @@ pub fn expand_deriving_clone(cx: &mut ExtCtxt,\n fn cs_clone(\n     name: &str,\n     cx: &mut ExtCtxt, trait_span: Span,\n-    substr: &Substructure) -> Gc<Expr> {\n+    substr: &Substructure) -> P<Expr> {\n     let clone_ident = substr.method_ident;\n     let ctor_ident;\n     let all_fields;\n     let subcall = |field: &FieldInfo|\n-        cx.expr_method_call(field.span, field.self_, clone_ident, Vec::new());\n+        cx.expr_method_call(field.span, field.self_.clone(), clone_ident, Vec::new());\n \n     match *substr.fields {\n         Struct(ref af) => {"}, {"sha": "a27016fde61562c42063c3119cc7defdf4b68670", "filename": "src/libsyntax/ext/deriving/cmp/eq.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -15,21 +15,20 @@ use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n-\n-use std::gc::Gc;\n+use ptr::P;\n \n pub fn expand_deriving_eq(cx: &mut ExtCtxt,\n                           span: Span,\n-                          mitem: Gc<MetaItem>,\n-                          item: Gc<Item>,\n-                          push: |Gc<Item>|) {\n+                          mitem: &MetaItem,\n+                          item: &Item,\n+                          push: |P<Item>|) {\n     // structures are equal if all fields are equal, and non equal, if\n     // any fields are not equal or if the enum variants are different\n-    fn cs_eq(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> Gc<Expr> {\n+    fn cs_eq(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<Expr> {\n         cs_and(|cx, span, _, _| cx.expr_bool(span, false),\n                                  cx, span, substr)\n     }\n-    fn cs_ne(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> Gc<Expr> {\n+    fn cs_ne(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<Expr> {\n         cs_or(|cx, span, _, _| cx.expr_bool(span, true),\n               cx, span, substr)\n     }"}, {"sha": "7cb61d295c0d45d5aaf61f2da46054605a40f526", "filename": "src/libsyntax/ext/deriving/cmp/ord.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -16,14 +16,13 @@ use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n-\n-use std::gc::Gc;\n+use ptr::P;\n \n pub fn expand_deriving_ord(cx: &mut ExtCtxt,\n                            span: Span,\n-                           mitem: Gc<MetaItem>,\n-                           item: Gc<Item>,\n-                           push: |Gc<Item>|) {\n+                           mitem: &MetaItem,\n+                           item: &Item,\n+                           push: |P<Item>|) {\n     macro_rules! md (\n         ($name:expr, $op:expr, $equal:expr) => { {\n             let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n@@ -87,7 +86,7 @@ pub enum OrderingOp {\n pub fn some_ordering_collapsed(cx: &mut ExtCtxt,\n                                span: Span,\n                                op: OrderingOp,\n-                               self_arg_tags: &[ast::Ident]) -> Gc<ast::Expr> {\n+                               self_arg_tags: &[ast::Ident]) -> P<ast::Expr> {\n     let lft = cx.expr_ident(span, self_arg_tags[0]);\n     let rgt = cx.expr_addr_of(span, cx.expr_ident(span, self_arg_tags[1]));\n     let op_str = match op {\n@@ -99,7 +98,7 @@ pub fn some_ordering_collapsed(cx: &mut ExtCtxt,\n }\n \n pub fn cs_partial_cmp(cx: &mut ExtCtxt, span: Span,\n-              substr: &Substructure) -> Gc<Expr> {\n+              substr: &Substructure) -> P<Expr> {\n     let test_id = cx.ident_of(\"__test\");\n     let ordering = cx.path_global(span,\n                                   vec!(cx.ident_of(\"std\"),\n@@ -159,8 +158,8 @@ pub fn cs_partial_cmp(cx: &mut ExtCtxt, span: Span,\n }\n \n /// Strict inequality.\n-fn cs_op(less: bool, equal: bool, cx: &mut ExtCtxt, span: Span,\n-         substr: &Substructure) -> Gc<Expr> {\n+fn cs_op(less: bool, equal: bool, cx: &mut ExtCtxt,\n+         span: Span, substr: &Substructure) -> P<Expr> {\n     let op = if less {ast::BiLt} else {ast::BiGt};\n     cs_fold(\n         false, // need foldr,\n@@ -183,14 +182,14 @@ fn cs_op(less: bool, equal: bool, cx: &mut ExtCtxt, span: Span,\n             layers of pointers, if the type includes pointers.\n             */\n             let other_f = match other_fs {\n-                [o_f] => o_f,\n+                [ref o_f] => o_f,\n                 _ => cx.span_bug(span, \"not exactly 2 arguments in `deriving(Ord)`\")\n             };\n \n-            let cmp = cx.expr_binary(span, op, self_f, other_f);\n+            let cmp = cx.expr_binary(span, op, self_f.clone(), other_f.clone());\n \n             let not_cmp = cx.expr_unary(span, ast::UnNot,\n-                                        cx.expr_binary(span, op, other_f, self_f));\n+                                        cx.expr_binary(span, op, other_f.clone(), self_f));\n \n             let and = cx.expr_binary(span, ast::BiAnd, not_cmp, subexpr);\n             cx.expr_binary(span, ast::BiOr, cmp, and)"}, {"sha": "98c8885f7fa01566740d8e89f37ced2b01bce141", "filename": "src/libsyntax/ext/deriving/cmp/totaleq.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -15,16 +15,14 @@ use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n-\n-use std::gc::Gc;\n+use ptr::P;\n \n pub fn expand_deriving_totaleq(cx: &mut ExtCtxt,\n                                span: Span,\n-                               mitem: Gc<MetaItem>,\n-                               item: Gc<Item>,\n-                               push: |Gc<Item>|) {\n-    fn cs_total_eq_assert(cx: &mut ExtCtxt, span: Span,\n-                          substr: &Substructure) -> Gc<Expr> {\n+                               mitem: &MetaItem,\n+                               item: &Item,\n+                               push: |P<Item>|) {\n+    fn cs_total_eq_assert(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<Expr> {\n         cs_same_method(|cx, span, exprs| {\n             // create `a.<method>(); b.<method>(); c.<method>(); ...`\n             // (where method is `assert_receiver_is_total_eq`)"}, {"sha": "9ef463f9c630e0d86712425f55d78ffdbf50aba9", "filename": "src/libsyntax/ext/deriving/cmp/totalord.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -16,14 +16,13 @@ use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n-\n-use std::gc::Gc;\n+use ptr::P;\n \n pub fn expand_deriving_totalord(cx: &mut ExtCtxt,\n                                 span: Span,\n-                                mitem: Gc<MetaItem>,\n-                                item: Gc<Item>,\n-                                push: |Gc<Item>|) {\n+                                mitem: &MetaItem,\n+                                item: &Item,\n+                                push: |P<Item>|) {\n     let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n     let attrs = vec!(cx.attribute(span, inline));\n     let trait_def = TraitDef {\n@@ -53,14 +52,14 @@ pub fn expand_deriving_totalord(cx: &mut ExtCtxt,\n \n pub fn ordering_collapsed(cx: &mut ExtCtxt,\n                           span: Span,\n-                          self_arg_tags: &[ast::Ident]) -> Gc<ast::Expr> {\n+                          self_arg_tags: &[ast::Ident]) -> P<ast::Expr> {\n     let lft = cx.expr_ident(span, self_arg_tags[0]);\n     let rgt = cx.expr_addr_of(span, cx.expr_ident(span, self_arg_tags[1]));\n     cx.expr_method_call(span, lft, cx.ident_of(\"cmp\"), vec![rgt])\n }\n \n pub fn cs_cmp(cx: &mut ExtCtxt, span: Span,\n-              substr: &Substructure) -> Gc<Expr> {\n+              substr: &Substructure) -> P<Expr> {\n     let test_id = cx.ident_of(\"__test\");\n     let equals_path = cx.path_global(span,\n                                      vec!(cx.ident_of(\"std\"),"}, {"sha": "fd24f5e35a4463616fd882d531fe034f13543629", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -21,14 +21,13 @@ use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n use parse::token;\n-\n-use std::gc::Gc;\n+use ptr::P;\n \n pub fn expand_deriving_decodable(cx: &mut ExtCtxt,\n                                  span: Span,\n-                                 mitem: Gc<MetaItem>,\n-                                 item: Gc<Item>,\n-                                 push: |Gc<Item>|) {\n+                                 mitem: &MetaItem,\n+                                 item: &Item,\n+                                 push: |P<Item>|) {\n     let trait_def = TraitDef {\n         span: span,\n         attributes: Vec::new(),\n@@ -64,15 +63,15 @@ pub fn expand_deriving_decodable(cx: &mut ExtCtxt,\n }\n \n fn decodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n-                          substr: &Substructure) -> Gc<Expr> {\n-    let decoder = substr.nonself_args[0];\n+                          substr: &Substructure) -> P<Expr> {\n+    let decoder = substr.nonself_args[0].clone();\n     let recurse = vec!(cx.ident_of(\"serialize\"),\n                     cx.ident_of(\"Decodable\"),\n                     cx.ident_of(\"decode\"));\n     // throw an underscore in front to suppress unused variable warnings\n     let blkarg = cx.ident_of(\"_d\");\n     let blkdecoder = cx.expr_ident(trait_span, blkarg);\n-    let calldecode = cx.expr_call_global(trait_span, recurse, vec!(blkdecoder));\n+    let calldecode = cx.expr_call_global(trait_span, recurse, vec!(blkdecoder.clone()));\n     let lambdadecode = cx.lambda_expr_1(trait_span, calldecode, blkarg);\n \n     return match *substr.fields {\n@@ -89,10 +88,10 @@ fn decodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n                                               summary,\n                                               |cx, span, name, field| {\n                 cx.expr_try(span,\n-                    cx.expr_method_call(span, blkdecoder, read_struct_field,\n+                    cx.expr_method_call(span, blkdecoder.clone(), read_struct_field,\n                                         vec!(cx.expr_str(span, name),\n                                           cx.expr_uint(span, field),\n-                                          lambdadecode)))\n+                                          lambdadecode.clone())))\n             });\n             let result = cx.expr_ok(trait_span, result);\n             cx.expr_method_call(trait_span,\n@@ -121,8 +120,8 @@ fn decodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n                                                    |cx, span, _, field| {\n                     let idx = cx.expr_uint(span, field);\n                     cx.expr_try(span,\n-                        cx.expr_method_call(span, blkdecoder, rvariant_arg,\n-                                            vec!(idx, lambdadecode)))\n+                        cx.expr_method_call(span, blkdecoder.clone(), rvariant_arg,\n+                                            vec!(idx, lambdadecode.clone())))\n                 });\n \n                 arms.push(cx.arm(v_span,\n@@ -159,8 +158,8 @@ fn decode_static_fields(cx: &mut ExtCtxt,\n                         trait_span: Span,\n                         outer_pat_ident: Ident,\n                         fields: &StaticFields,\n-                        getarg: |&mut ExtCtxt, Span, InternedString, uint| -> Gc<Expr>)\n-                        -> Gc<Expr> {\n+                        getarg: |&mut ExtCtxt, Span, InternedString, uint| -> P<Expr>)\n+                        -> P<Expr> {\n     match *fields {\n         Unnamed(ref fields) => {\n             if fields.is_empty() {"}, {"sha": "f4a66414d89bd664db5044a970dd6bab47125382", "filename": "src/libsyntax/ext/deriving/default.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -15,14 +15,13 @@ use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n-\n-use std::gc::Gc;\n+use ptr::P;\n \n pub fn expand_deriving_default(cx: &mut ExtCtxt,\n                             span: Span,\n-                            mitem: Gc<MetaItem>,\n-                            item: Gc<Item>,\n-                            push: |Gc<Item>|) {\n+                            mitem: &MetaItem,\n+                            item: &Item,\n+                            push: |P<Item>|) {\n     let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n     let attrs = vec!(cx.attribute(span, inline));\n     let trait_def = TraitDef {\n@@ -47,8 +46,7 @@ pub fn expand_deriving_default(cx: &mut ExtCtxt,\n     trait_def.expand(cx, mitem, item, push)\n }\n \n-fn default_substructure(cx: &mut ExtCtxt, trait_span: Span,\n-                        substr: &Substructure) -> Gc<Expr> {\n+fn default_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure) -> P<Expr> {\n     let default_ident = vec!(\n         cx.ident_of(\"std\"),\n         cx.ident_of(\"default\"),"}, {"sha": "103253560df65c3aa8d490fb9a89246b9a13c036", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -86,14 +86,13 @@ use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n use parse::token;\n-\n-use std::gc::Gc;\n+use ptr::P;\n \n pub fn expand_deriving_encodable(cx: &mut ExtCtxt,\n                                  span: Span,\n-                                 mitem: Gc<MetaItem>,\n-                                 item: Gc<Item>,\n-                                 push: |Gc<Item>|) {\n+                                 mitem: &MetaItem,\n+                                 item: &Item,\n+                                 push: |P<Item>|) {\n     let trait_def = TraitDef {\n         span: span,\n         attributes: Vec::new(),\n@@ -131,8 +130,8 @@ pub fn expand_deriving_encodable(cx: &mut ExtCtxt,\n }\n \n fn encodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n-                          substr: &Substructure) -> Gc<Expr> {\n-    let encoder = substr.nonself_args[0];\n+                          substr: &Substructure) -> P<Expr> {\n+    let encoder = substr.nonself_args[0].clone();\n     // throw an underscore in front to suppress unused variable warnings\n     let blkarg = cx.ident_of(\"_e\");\n     let blkencoder = cx.expr_ident(trait_span, blkarg);\n@@ -145,7 +144,7 @@ fn encodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n             let last = fields.len() - 1;\n             for (i, &FieldInfo {\n                     name,\n-                    self_,\n+                    ref self_,\n                     span,\n                     ..\n                 }) in fields.iter().enumerate() {\n@@ -156,9 +155,10 @@ fn encodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n                                                             i).as_slice())\n                     }\n                 };\n-                let enc = cx.expr_method_call(span, self_, encode, vec!(blkencoder));\n+                let enc = cx.expr_method_call(span, self_.clone(),\n+                                              encode, vec!(blkencoder.clone()));\n                 let lambda = cx.lambda_expr_1(span, enc, blkarg);\n-                let call = cx.expr_method_call(span, blkencoder,\n+                let call = cx.expr_method_call(span, blkencoder.clone(),\n                                                emit_struct_field,\n                                                vec!(cx.expr_str(span, name),\n                                                  cx.expr_uint(span, i),\n@@ -202,10 +202,11 @@ fn encodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n             let emit_variant_arg = cx.ident_of(\"emit_enum_variant_arg\");\n             let mut stmts = Vec::new();\n             let last = fields.len() - 1;\n-            for (i, &FieldInfo { self_, span, .. }) in fields.iter().enumerate() {\n-                let enc = cx.expr_method_call(span, self_, encode, vec!(blkencoder));\n+            for (i, &FieldInfo { ref self_, span, .. }) in fields.iter().enumerate() {\n+                let enc = cx.expr_method_call(span, self_.clone(),\n+                                              encode, vec!(blkencoder.clone()));\n                 let lambda = cx.lambda_expr_1(span, enc, blkarg);\n-                let call = cx.expr_method_call(span, blkencoder,\n+                let call = cx.expr_method_call(span, blkencoder.clone(),\n                                                emit_variant_arg,\n                                                vec!(cx.expr_uint(span, i),\n                                                  lambda));"}, {"sha": "53af5a86ed2c6989335777f62b40465b8480b4dd", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 131, "deletions": 133, "changes": 264, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -181,22 +181,25 @@\n //! ~~~\n \n use std::cell::RefCell;\n-use std::gc::{Gc, GC};\n+use std::gc::GC;\n+use std::vec;\n \n use abi::Abi;\n use abi;\n use ast;\n-use ast::{P, EnumDef, Expr, Ident, Generics, StructDef};\n+use ast::{EnumDef, Expr, Ident, Generics, StructDef};\n use ast_util;\n use attr;\n use attr::AttrMetaMethods;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use codemap;\n use codemap::Span;\n+use fold::MoveMap;\n use owned_slice::OwnedSlice;\n use parse::token::InternedString;\n use parse::token::special_idents;\n+use ptr::P;\n \n use self::ty::{LifetimeBounds, Path, Ptr, PtrTy, Self, Ty};\n \n@@ -251,9 +254,9 @@ pub struct Substructure<'a> {\n     /// ident of the method\n     pub method_ident: Ident,\n     /// dereferenced access to any Self or Ptr(Self, _) arguments\n-    pub self_args: &'a [Gc<Expr>],\n+    pub self_args: &'a [P<Expr>],\n     /// verbatim access to any other arguments\n-    pub nonself_args: &'a [Gc<Expr>],\n+    pub nonself_args: &'a [P<Expr>],\n     pub fields: &'a SubstructureFields<'a>\n }\n \n@@ -265,10 +268,10 @@ pub struct FieldInfo {\n     pub name: Option<Ident>,\n     /// The expression corresponding to this field of `self`\n     /// (specifically, a reference to it).\n-    pub self_: Gc<Expr>,\n+    pub self_: P<Expr>,\n     /// The expressions corresponding to references to this field in\n     /// the other Self arguments.\n-    pub other: Vec<Gc<Expr>>,\n+    pub other: Vec<P<Expr>>,\n }\n \n /// Fields for a static method\n@@ -298,7 +301,7 @@ pub enum SubstructureFields<'a> {\n     Idents bound to the variant index values for each of the actual\n     input Self arguments.\n     */\n-    EnumNonMatchingCollapsed(Vec<Ident>, &'a [Gc<ast::Variant>], &'a [Ident]),\n+    EnumNonMatchingCollapsed(Vec<Ident>, &'a [P<ast::Variant>], &'a [Ident]),\n \n     /// A static method where Self is a struct.\n     StaticStruct(&'a ast::StructDef, StaticFields),\n@@ -313,7 +316,7 @@ Combine the values of all the fields together. The last argument is\n all the fields of all the structures, see above for details.\n */\n pub type CombineSubstructureFunc<'a> =\n-    |&mut ExtCtxt, Span, &Substructure|: 'a -> Gc<Expr>;\n+    |&mut ExtCtxt, Span, &Substructure|: 'a -> P<Expr>;\n \n /**\n Deal with non-matching enum variants.  The tuple is a list of\n@@ -324,10 +327,10 @@ last argument is all the non-Self args of the method being derived.\n */\n pub type EnumNonMatchCollapsedFunc<'a> =\n     |&mut ExtCtxt,\n-           Span,\n-           (&[Ident], &[Ident]),\n-           &[Gc<Expr>]|: 'a\n-           -> Gc<Expr>;\n+     Span,\n+     (&[Ident], &[Ident]),\n+     &[P<Expr>]|: 'a\n+     -> P<Expr>;\n \n pub fn combine_substructure<'a>(f: CombineSubstructureFunc<'a>)\n     -> RefCell<CombineSubstructureFunc<'a>> {\n@@ -338,9 +341,9 @@ pub fn combine_substructure<'a>(f: CombineSubstructureFunc<'a>)\n impl<'a> TraitDef<'a> {\n     pub fn expand(&self,\n                   cx: &mut ExtCtxt,\n-                  _mitem: Gc<ast::MetaItem>,\n-                  item: Gc<ast::Item>,\n-                  push: |Gc<ast::Item>|) {\n+                  _mitem: &ast::MetaItem,\n+                  item: &ast::Item,\n+                  push: |P<ast::Item>|) {\n         let newitem = match item.node {\n             ast::ItemStruct(ref struct_def, ref generics) => {\n                 self.expand_struct_def(cx,\n@@ -365,10 +368,10 @@ impl<'a> TraitDef<'a> {\n                 _ => false,\n             }\n         }).map(|a| a.clone()));\n-        push(box(GC) ast::Item {\n+        push(P(ast::Item {\n             attrs: attrs,\n             ..(*newitem).clone()\n-        })\n+        }))\n     }\n \n     /**\n@@ -387,7 +390,7 @@ impl<'a> TraitDef<'a> {\n                            cx: &mut ExtCtxt,\n                            type_ident: Ident,\n                            generics: &Generics,\n-                           methods: Vec<Gc<ast::Method>> ) -> Gc<ast::Item> {\n+                           methods: Vec<P<ast::Method>>) -> P<ast::Item> {\n         let trait_path = self.path.to_path(cx, self.span, type_ident, generics);\n \n         let Generics { mut lifetimes, ty_params, where_clause: _ } =\n@@ -475,7 +478,7 @@ impl<'a> TraitDef<'a> {\n                          cx: &mut ExtCtxt,\n                          struct_def: &StructDef,\n                          type_ident: Ident,\n-                         generics: &Generics) -> Gc<ast::Item> {\n+                         generics: &Generics) -> P<ast::Item> {\n         let methods = self.methods.iter().map(|method_def| {\n             let (explicit_self, self_args, nonself_args, tys) =\n                 method_def.split_self_nonself_args(\n@@ -515,7 +518,7 @@ impl<'a> TraitDef<'a> {\n                        cx: &mut ExtCtxt,\n                        enum_def: &EnumDef,\n                        type_ident: Ident,\n-                       generics: &Generics) -> Gc<ast::Item> {\n+                       generics: &Generics) -> P<ast::Item> {\n         let methods = self.methods.iter().map(|method_def| {\n             let (explicit_self, self_args, nonself_args, tys) =\n                 method_def.split_self_nonself_args(cx, self,\n@@ -534,7 +537,7 @@ impl<'a> TraitDef<'a> {\n                                                    self,\n                                                    enum_def,\n                                                    type_ident,\n-                                                   self_args.as_slice(),\n+                                                   self_args,\n                                                    nonself_args.as_slice())\n             };\n \n@@ -553,7 +556,7 @@ impl<'a> TraitDef<'a> {\n }\n \n fn variant_to_pat(cx: &mut ExtCtxt, sp: Span, variant: &ast::Variant)\n-                  -> Gc<ast::Pat> {\n+                  -> P<ast::Pat> {\n     let ident = cx.path_ident(sp, variant.node.name);\n     cx.pat(sp, match variant.node.kind {\n         ast::TupleVariantKind(..) => ast::PatEnum(ident, None),\n@@ -566,10 +569,10 @@ impl<'a> MethodDef<'a> {\n                                 cx: &mut ExtCtxt,\n                                 trait_: &TraitDef,\n                                 type_ident: Ident,\n-                                self_args: &[Gc<Expr>],\n-                                nonself_args: &[Gc<Expr>],\n+                                self_args: &[P<Expr>],\n+                                nonself_args: &[P<Expr>],\n                                 fields: &SubstructureFields)\n-        -> Gc<Expr> {\n+        -> P<Expr> {\n         let substructure = Substructure {\n             type_ident: type_ident,\n             method_ident: cx.ident_of(self.name),\n@@ -600,8 +603,7 @@ impl<'a> MethodDef<'a> {\n                                trait_: &TraitDef,\n                                type_ident: Ident,\n                                generics: &Generics)\n-        -> (ast::ExplicitSelf, Vec<Gc<Expr>>, Vec<Gc<Expr>>,\n-            Vec<(Ident, P<ast::Ty>)>) {\n+        -> (ast::ExplicitSelf, Vec<P<Expr>>, Vec<P<Expr>>, Vec<(Ident, P<ast::Ty>)>) {\n \n         let mut self_args = Vec::new();\n         let mut nonself_args = Vec::new();\n@@ -654,8 +656,7 @@ impl<'a> MethodDef<'a> {\n                      abi: Abi,\n                      explicit_self: ast::ExplicitSelf,\n                      arg_types: Vec<(Ident, P<ast::Ty>)> ,\n-                     body: Gc<Expr>)\n-                     -> Gc<ast::Method> {\n+                     body: P<Expr>) -> P<ast::Method> {\n         // create the generics that aren't for Self\n         let fn_generics = self.generics.to_generics(cx, trait_.span, type_ident, generics);\n \n@@ -678,7 +679,7 @@ impl<'a> MethodDef<'a> {\n         let body_block = cx.block_expr(body);\n \n         // Create the method.\n-        box(GC) ast::Method {\n+        P(ast::Method {\n             attrs: self.attributes.clone(),\n             id: ast::DUMMY_NODE_ID,\n             span: trait_.span,\n@@ -690,7 +691,7 @@ impl<'a> MethodDef<'a> {\n                                 fn_decl,\n                                 body_block,\n                                 ast::Inherited)\n-        }\n+        })\n     }\n \n     /**\n@@ -719,9 +720,9 @@ impl<'a> MethodDef<'a> {\n                                  trait_: &TraitDef,\n                                  struct_def: &StructDef,\n                                  type_ident: Ident,\n-                                 self_args: &[Gc<Expr>],\n-                                 nonself_args: &[Gc<Expr>])\n-        -> Gc<Expr> {\n+                                 self_args: &[P<Expr>],\n+                                 nonself_args: &[P<Expr>])\n+        -> P<Expr> {\n \n         let mut raw_fields = Vec::new(); // ~[[fields of self],\n                                  // [fields of next Self arg], [etc]]\n@@ -740,20 +741,20 @@ impl<'a> MethodDef<'a> {\n \n         // transpose raw_fields\n         let fields = if raw_fields.len() > 0 {\n-            raw_fields.get(0)\n-                      .iter()\n-                      .enumerate()\n-                      .map(|(i, &(span, opt_id, field))| {\n-                let other_fields = raw_fields.tail().iter().map(|l| {\n-                    match l.get(i) {\n-                        &(_, _, ex) => ex\n-                    }\n-                }).collect();\n+            let mut raw_fields = raw_fields.move_iter().map(|v| v.move_iter());\n+            let first_field = raw_fields.next().unwrap();\n+            let mut other_fields: Vec<vec::MoveItems<(Span, Option<Ident>, P<Expr>)>>\n+                = raw_fields.collect();\n+            first_field.map(|(span, opt_id, field)| {\n                 FieldInfo {\n                     span: span,\n                     name: opt_id,\n                     self_: field,\n-                    other: other_fields\n+                    other: other_fields.mut_iter().map(|l| {\n+                        match l.next().unwrap() {\n+                            (_, _, ex) => ex\n+                        }\n+                    }).collect()\n                 }\n             }).collect()\n         } else {\n@@ -774,9 +775,9 @@ impl<'a> MethodDef<'a> {\n         // make a series of nested matches, to destructure the\n         // structs. This is actually right-to-left, but it shouldn't\n         // matter.\n-        for (&arg_expr, &pat) in self_args.iter().zip(patterns.iter()) {\n-            body = cx.expr_match(trait_.span, arg_expr,\n-                                     vec!( cx.arm(trait_.span, vec!(pat), body) ))\n+        for (arg_expr, pat) in self_args.iter().zip(patterns.iter()) {\n+            body = cx.expr_match(trait_.span, arg_expr.clone(),\n+                                     vec!( cx.arm(trait_.span, vec!(pat.clone()), body) ))\n         }\n         body\n     }\n@@ -786,9 +787,9 @@ impl<'a> MethodDef<'a> {\n                                         trait_: &TraitDef,\n                                         struct_def: &StructDef,\n                                         type_ident: Ident,\n-                                        self_args: &[Gc<Expr>],\n-                                        nonself_args: &[Gc<Expr>])\n-        -> Gc<Expr> {\n+                                        self_args: &[P<Expr>],\n+                                        nonself_args: &[P<Expr>])\n+        -> P<Expr> {\n         let summary = trait_.summarise_struct(cx, struct_def);\n \n         self.call_substructure_method(cx,\n@@ -834,9 +835,9 @@ impl<'a> MethodDef<'a> {\n                                trait_: &TraitDef,\n                                enum_def: &EnumDef,\n                                type_ident: Ident,\n-                               self_args: &[Gc<Expr>],\n-                               nonself_args: &[Gc<Expr>])\n-                               -> Gc<Expr> {\n+                               self_args: Vec<P<Expr>>,\n+                               nonself_args: &[P<Expr>])\n+                               -> P<Expr> {\n         self.build_enum_match_tuple(\n             cx, trait_, enum_def, type_ident, self_args, nonself_args)\n     }\n@@ -875,8 +876,8 @@ impl<'a> MethodDef<'a> {\n         trait_: &TraitDef,\n         enum_def: &EnumDef,\n         type_ident: Ident,\n-        self_args: &[Gc<Expr>],\n-        nonself_args: &[Gc<Expr>]) -> Gc<Expr> {\n+        self_args: Vec<P<Expr>>,\n+        nonself_args: &[P<Expr>]) -> P<Expr> {\n \n         let sp = trait_.span;\n         let variants = &enum_def.variants;\n@@ -898,7 +899,7 @@ impl<'a> MethodDef<'a> {\n         // The `vi_idents` will be bound, solely in the catch-all, to\n         // a series of let statements mapping each self_arg to a uint\n         // corresponding to its variant index.\n-        let vi_idents : Vec<ast::Ident> = self_arg_names.iter()\n+        let vi_idents: Vec<ast::Ident> = self_arg_names.iter()\n             .map(|name| { let vi_suffix = format!(\"{:s}_vi\", name.as_slice());\n                           cx.ident_of(vi_suffix.as_slice()) })\n             .collect::<Vec<ast::Ident>>();\n@@ -914,24 +915,29 @@ impl<'a> MethodDef<'a> {\n         // (Variant2, Variant2, ...) => Body2\n         // ...\n         // where each tuple has length = self_args.len()\n-        let mut match_arms : Vec<ast::Arm> = variants.iter().enumerate()\n-            .map(|(index, &variant)| {\n-\n-                // These self_pats have form Variant1, Variant2, ...\n-                let self_pats : Vec<(Gc<ast::Pat>,\n-                                     Vec<(Span, Option<Ident>, Gc<Expr>)>)>;\n-                self_pats = self_arg_names.iter()\n-                    .map(|self_arg_name|\n-                         trait_.create_enum_variant_pattern(\n-                             cx, &*variant, self_arg_name.as_slice(),\n-                             ast::MutImmutable))\n-                    .collect();\n+        let mut match_arms: Vec<ast::Arm> = variants.iter().enumerate()\n+            .map(|(index, variant)| {\n+                let mk_self_pat = |cx: &mut ExtCtxt, self_arg_name: &str| {\n+                    let (p, idents) = trait_.create_enum_variant_pattern(cx, &**variant,\n+                                                                         self_arg_name,\n+                                                                         ast::MutImmutable);\n+                    (cx.pat(sp, ast::PatRegion(p)), idents)\n+                };\n \n                 // A single arm has form (&VariantK, &VariantK, ...) => BodyK\n                 // (see \"Final wrinkle\" note below for why.)\n-                let subpats = self_pats.iter()\n-                    .map(|&(p, ref _idents)| cx.pat(sp, ast::PatRegion(p)))\n-                    .collect::<Vec<Gc<ast::Pat>>>();\n+                let mut subpats = Vec::with_capacity(self_arg_names.len());\n+                let mut self_pats_idents = Vec::with_capacity(self_arg_names.len() - 1);\n+                let first_self_pat_idents = {\n+                    let (p, idents) = mk_self_pat(cx, self_arg_names[0].as_slice());\n+                    subpats.push(p);\n+                    idents\n+                };\n+                for self_arg_name in self_arg_names.tail().iter() {\n+                    let (p, idents) = mk_self_pat(cx, self_arg_name.as_slice());\n+                    subpats.push(p);\n+                    self_pats_idents.push(idents);\n+                }\n \n                 // Here is the pat = `(&VariantK, &VariantK, ...)`\n                 let single_pat = cx.pat(sp, ast::PatTup(subpats));\n@@ -941,39 +947,33 @@ impl<'a> MethodDef<'a> {\n                 // we are in.\n \n                 // All of the Self args have the same variant in these\n-                // cases.  So we transpose the info in self_pats to\n-                // gather the getter expressions together, in the form\n-                // that EnumMatching expects.\n+                // cases.  So we transpose the info in self_pats_idents\n+                // to gather the getter expressions together, in the\n+                // form that EnumMatching expects.\n \n                 // The transposition is driven by walking across the\n                 // arg fields of the variant for the first self pat.\n-                let &(_, ref self_arg_fields) = self_pats.get(0);\n-\n-                let field_tuples : Vec<FieldInfo>;\n-\n-                field_tuples = self_arg_fields.iter().enumerate()\n+                let field_tuples = first_self_pat_idents.move_iter().enumerate()\n                     // For each arg field of self, pull out its getter expr ...\n-                    .map(|(field_index, &(sp, opt_ident, self_getter_expr))| {\n+                    .map(|(field_index, (sp, opt_ident, self_getter_expr))| {\n                         // ... but FieldInfo also wants getter expr\n                         // for matching other arguments of Self type;\n-                        // so walk across the *other* self_pats and\n-                        // pull out getter for same field in each of\n-                        // them (using `field_index` tracked above).\n+                        // so walk across the *other* self_pats_idents\n+                        // and pull out getter for same field in each\n+                        // of them (using `field_index` tracked above).\n                         // That is the heart of the transposition.\n-                        let others = self_pats.tail().iter()\n-                            .map(|&(_pat, ref fields)| {\n+                        let others = self_pats_idents.iter().map(|fields| {\n+                            let &(_, _opt_ident, ref other_getter_expr) =\n+                                fields.get(field_index);\n \n-                                let &(_, _opt_ident, other_getter_expr) =\n-                                    fields.get(field_index);\n+                            // All Self args have same variant, so\n+                            // opt_idents are the same.  (Assert\n+                            // here to make it self-evident that\n+                            // it is okay to ignore `_opt_ident`.)\n+                            assert!(opt_ident == _opt_ident);\n \n-                                // All Self args have same variant, so\n-                                // opt_idents are the same.  (Assert\n-                                // here to make it self-evident that\n-                                // it is okay to ignore `_opt_ident`.)\n-                                assert!(opt_ident == _opt_ident);\n-\n-                                other_getter_expr\n-                            }).collect::<Vec<Gc<Expr>>>();\n+                            other_getter_expr.clone()\n+                        }).collect::<Vec<P<Expr>>>();\n \n                         FieldInfo { span: sp,\n                                     name: opt_ident,\n@@ -987,10 +987,10 @@ impl<'a> MethodDef<'a> {\n                 // Self arg, assuming all are instances of VariantK.\n                 // Build up code associated with such a case.\n                 let substructure = EnumMatching(index,\n-                                                &*variant,\n+                                                &**variant,\n                                                 field_tuples);\n                 let arm_expr = self.call_substructure_method(\n-                    cx, trait_, type_ident, self_args, nonself_args,\n+                    cx, trait_, type_ident, self_args.as_slice(), nonself_args,\n                     &substructure);\n \n                 cx.arm(sp, vec![single_pat], arm_expr)\n@@ -1012,9 +1012,9 @@ impl<'a> MethodDef<'a> {\n         //   unreachable-pattern error.\n         //\n         if variants.len() > 1 && self_args.len() > 1 {\n-            let arms : Vec<ast::Arm> = variants.iter().enumerate()\n-                .map(|(index, &variant)| {\n-                    let pat = variant_to_pat(cx, sp, &*variant);\n+            let arms: Vec<ast::Arm> = variants.iter().enumerate()\n+                .map(|(index, variant)| {\n+                    let pat = variant_to_pat(cx, sp, &**variant);\n                     let lit = ast::LitInt(index as u64, ast::UnsignedIntLit(ast::TyU));\n                     cx.arm(sp, vec![pat], cx.expr_lit(sp, lit))\n                 }).collect();\n@@ -1035,15 +1035,15 @@ impl<'a> MethodDef<'a> {\n             //     A => 0u, B(..) => 1u, C(..) => 2u\n             // };\n             // ```\n-            let mut index_let_stmts : Vec<Gc<ast::Stmt>> = Vec::new();\n-            for (&ident, &self_arg) in vi_idents.iter().zip(self_args.iter()) {\n-                let variant_idx = cx.expr_match(sp, self_arg, arms.clone());\n+            let mut index_let_stmts: Vec<P<ast::Stmt>> = Vec::new();\n+            for (&ident, self_arg) in vi_idents.iter().zip(self_args.iter()) {\n+                let variant_idx = cx.expr_match(sp, self_arg.clone(), arms.clone());\n                 let let_stmt = cx.stmt_let(sp, false, ident, variant_idx);\n                 index_let_stmts.push(let_stmt);\n             }\n \n             let arm_expr = self.call_substructure_method(\n-                cx, trait_, type_ident, self_args, nonself_args,\n+                cx, trait_, type_ident, self_args.as_slice(), nonself_args,\n                 &catch_all_substructure);\n \n             // Builds the expression:\n@@ -1124,9 +1124,7 @@ impl<'a> MethodDef<'a> {\n         // them when they are fed as r-values into a tuple\n         // expression; here add a layer of borrowing, turning\n         // `(*self, *__arg_0, ...)` into `(&*self, &*__arg_0, ...)`.\n-        let borrowed_self_args = self_args.iter()\n-            .map(|&self_arg| cx.expr_addr_of(sp, self_arg))\n-            .collect::<Vec<Gc<ast::Expr>>>();\n+        let borrowed_self_args = self_args.move_map(|self_arg| cx.expr_addr_of(sp, self_arg));\n         let match_arg = cx.expr(sp, ast::ExprTup(borrowed_self_args));\n         cx.expr_match(sp, match_arg, match_arms)\n     }\n@@ -1136,9 +1134,9 @@ impl<'a> MethodDef<'a> {\n                                       trait_: &TraitDef,\n                                       enum_def: &EnumDef,\n                                       type_ident: Ident,\n-                                      self_args: &[Gc<Expr>],\n-                                      nonself_args: &[Gc<Expr>])\n-        -> Gc<Expr> {\n+                                      self_args: &[P<Expr>],\n+                                      nonself_args: &[P<Expr>])\n+        -> P<Expr> {\n         let summary = enum_def.variants.iter().map(|v| {\n             let ident = v.node.name;\n             let summary = match v.node.kind {\n@@ -1210,11 +1208,11 @@ impl<'a> TraitDef<'a> {\n                           cx: &mut ExtCtxt,\n                           field_paths: Vec<ast::SpannedIdent> ,\n                           mutbl: ast::Mutability)\n-                          -> Vec<Gc<ast::Pat>> {\n+                          -> Vec<P<ast::Pat>> {\n         field_paths.iter().map(|path| {\n             cx.pat(path.span,\n                         ast::PatIdent(ast::BindByRef(mutbl), (*path).clone(), None))\n-            }).collect()\n+        }).collect()\n     }\n \n     fn create_struct_pattern(&self,\n@@ -1223,7 +1221,7 @@ impl<'a> TraitDef<'a> {\n                              struct_def: &StructDef,\n                              prefix: &str,\n                              mutbl: ast::Mutability)\n-                             -> (Gc<ast::Pat>, Vec<(Span, Option<Ident>, Gc<Expr>)>) {\n+                             -> (P<ast::Pat>, Vec<(Span, Option<Ident>, P<Expr>)>) {\n         if struct_def.fields.is_empty() {\n             return (\n                 cx.pat_ident_binding_mode(\n@@ -1266,7 +1264,7 @@ impl<'a> TraitDef<'a> {\n         // struct_type is definitely not Unknown, since struct_def.fields\n         // must be nonempty to reach here\n         let pattern = if struct_type == Record {\n-            let field_pats = subpats.iter().zip(ident_expr.iter()).map(|(&pat, &(_, id, _))| {\n+            let field_pats = subpats.move_iter().zip(ident_expr.iter()).map(|(pat, &(_, id, _))| {\n                 // id is guaranteed to be Some\n                 ast::FieldPat { ident: id.unwrap(), pat: pat }\n             }).collect();\n@@ -1283,7 +1281,7 @@ impl<'a> TraitDef<'a> {\n                                    variant: &ast::Variant,\n                                    prefix: &str,\n                                    mutbl: ast::Mutability)\n-        -> (Gc<ast::Pat>, Vec<(Span, Option<Ident>, Gc<Expr>)> ) {\n+        -> (P<ast::Pat>, Vec<(Span, Option<Ident>, P<Expr>)>) {\n         let variant_ident = variant.node.name;\n         match variant.node.kind {\n             ast::TupleVariantKind(ref variant_args) => {\n@@ -1327,29 +1325,29 @@ Fold the fields. `use_foldl` controls whether this is done\n left-to-right (`true`) or right-to-left (`false`).\n */\n pub fn cs_fold(use_foldl: bool,\n-               f: |&mut ExtCtxt, Span, Gc<Expr>, Gc<Expr>, &[Gc<Expr>]| -> Gc<Expr>,\n-               base: Gc<Expr>,\n+               f: |&mut ExtCtxt, Span, P<Expr>, P<Expr>, &[P<Expr>]| -> P<Expr>,\n+               base: P<Expr>,\n                enum_nonmatch_f: EnumNonMatchCollapsedFunc,\n                cx: &mut ExtCtxt,\n                trait_span: Span,\n                substructure: &Substructure)\n-               -> Gc<Expr> {\n+               -> P<Expr> {\n     match *substructure.fields {\n         EnumMatching(_, _, ref all_fields) | Struct(ref all_fields) => {\n             if use_foldl {\n                 all_fields.iter().fold(base, |old, field| {\n                     f(cx,\n                       field.span,\n                       old,\n-                      field.self_,\n+                      field.self_.clone(),\n                       field.other.as_slice())\n                 })\n             } else {\n                 all_fields.iter().rev().fold(base, |old, field| {\n                     f(cx,\n                       field.span,\n                       old,\n-                      field.self_,\n+                      field.self_.clone(),\n                       field.other.as_slice())\n                 })\n             }\n@@ -1374,21 +1372,21 @@ f(cx, span, ~[self_1.method(__arg_1_1, __arg_2_1),\n ~~~\n */\n #[inline]\n-pub fn cs_same_method(f: |&mut ExtCtxt, Span, Vec<Gc<Expr>>| -> Gc<Expr>,\n+pub fn cs_same_method(f: |&mut ExtCtxt, Span, Vec<P<Expr>>| -> P<Expr>,\n                       enum_nonmatch_f: EnumNonMatchCollapsedFunc,\n                       cx: &mut ExtCtxt,\n                       trait_span: Span,\n                       substructure: &Substructure)\n-                      -> Gc<Expr> {\n+                      -> P<Expr> {\n     match *substructure.fields {\n         EnumMatching(_, _, ref all_fields) | Struct(ref all_fields) => {\n             // call self_n.method(other_1_n, other_2_n, ...)\n             let called = all_fields.iter().map(|field| {\n                 cx.expr_method_call(field.span,\n-                                    field.self_,\n+                                    field.self_.clone(),\n                                     substructure.method_ident,\n                                     field.other.iter()\n-                                               .map(|e| cx.expr_addr_of(field.span, *e))\n+                                               .map(|e| cx.expr_addr_of(field.span, e.clone()))\n                                                .collect())\n             }).collect();\n \n@@ -1410,21 +1408,21 @@ fields. `use_foldl` controls whether this is done left-to-right\n */\n #[inline]\n pub fn cs_same_method_fold(use_foldl: bool,\n-                           f: |&mut ExtCtxt, Span, Gc<Expr>, Gc<Expr>| -> Gc<Expr>,\n-                           base: Gc<Expr>,\n+                           f: |&mut ExtCtxt, Span, P<Expr>, P<Expr>| -> P<Expr>,\n+                           base: P<Expr>,\n                            enum_nonmatch_f: EnumNonMatchCollapsedFunc,\n                            cx: &mut ExtCtxt,\n                            trait_span: Span,\n                            substructure: &Substructure)\n-                           -> Gc<Expr> {\n+                           -> P<Expr> {\n     cs_same_method(\n         |cx, span, vals| {\n             if use_foldl {\n-                vals.iter().fold(base, |old, &new| {\n+                vals.move_iter().fold(base.clone(), |old, new| {\n                     f(cx, span, old, new)\n                 })\n             } else {\n-                vals.iter().rev().fold(base, |old, &new| {\n+                vals.move_iter().rev().fold(base.clone(), |old, new| {\n                     f(cx, span, old, new)\n                 })\n             }\n@@ -1438,10 +1436,10 @@ Use a given binop to combine the result of calling the derived method\n on all the fields.\n */\n #[inline]\n-pub fn cs_binop(binop: ast::BinOp, base: Gc<Expr>,\n+pub fn cs_binop(binop: ast::BinOp, base: P<Expr>,\n                 enum_nonmatch_f: EnumNonMatchCollapsedFunc,\n                 cx: &mut ExtCtxt, trait_span: Span,\n-                substructure: &Substructure) -> Gc<Expr> {\n+                substructure: &Substructure) -> P<Expr> {\n     cs_same_method_fold(\n         true, // foldl is good enough\n         |cx, span, old, new| {\n@@ -1459,7 +1457,7 @@ pub fn cs_binop(binop: ast::BinOp, base: Gc<Expr>,\n #[inline]\n pub fn cs_or(enum_nonmatch_f: EnumNonMatchCollapsedFunc,\n              cx: &mut ExtCtxt, span: Span,\n-             substructure: &Substructure) -> Gc<Expr> {\n+             substructure: &Substructure) -> P<Expr> {\n     cs_binop(ast::BiOr, cx.expr_bool(span, false),\n              enum_nonmatch_f,\n              cx, span, substructure)\n@@ -1469,7 +1467,7 @@ pub fn cs_or(enum_nonmatch_f: EnumNonMatchCollapsedFunc,\n #[inline]\n pub fn cs_and(enum_nonmatch_f: EnumNonMatchCollapsedFunc,\n               cx: &mut ExtCtxt, span: Span,\n-              substructure: &Substructure) -> Gc<Expr> {\n+              substructure: &Substructure) -> P<Expr> {\n     cs_binop(ast::BiAnd, cx.expr_bool(span, true),\n              enum_nonmatch_f,\n              cx, span, substructure)"}, {"sha": "a90618a30b6ebf3c7cd287018c971c24d20ef9e9", "filename": "src/libsyntax/ext/deriving/generic/ty.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -14,14 +14,13 @@ explicit `Self` type to use when specifying impls to be derived.\n */\n \n use ast;\n-use ast::{P,Expr,Generics,Ident};\n+use ast::{Expr,Generics,Ident};\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use codemap::{Span,respan};\n use owned_slice::OwnedSlice;\n use parse::token::special_idents;\n-\n-use std::gc::Gc;\n+use ptr::P;\n \n /// The types of pointers\n #[deriving(Clone)]\n@@ -260,7 +259,7 @@ impl<'a> LifetimeBounds<'a> {\n }\n \n pub fn get_explicit_self(cx: &ExtCtxt, span: Span, self_ptr: &Option<PtrTy>)\n-    -> (Gc<Expr>, ast::ExplicitSelf) {\n+    -> (P<Expr>, ast::ExplicitSelf) {\n     // this constructs a fresh `self` path, which will match the fresh `self` binding\n     // created below.\n     let self_path = cx.expr_self(span);"}, {"sha": "b7f11c2582548114d5dc091ebc5100947001aef8", "filename": "src/libsyntax/ext/deriving/hash.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -15,14 +15,13 @@ use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n-\n-use std::gc::Gc;\n+use ptr::P;\n \n pub fn expand_deriving_hash(cx: &mut ExtCtxt,\n                             span: Span,\n-                            mitem: Gc<MetaItem>,\n-                            item: Gc<Item>,\n-                            push: |Gc<Item>|) {\n+                            mitem: &MetaItem,\n+                            item: &Item,\n+                            push: |P<Item>|) {\n \n     let (path, generics, args) = if cx.ecfg.deriving_hash_type_parameter {\n         (Path::new_(vec!(\"std\", \"hash\", \"Hash\"), None,\n@@ -64,15 +63,14 @@ pub fn expand_deriving_hash(cx: &mut ExtCtxt,\n     hash_trait_def.expand(cx, mitem, item, push);\n }\n \n-fn hash_substructure(cx: &mut ExtCtxt, trait_span: Span,\n-                     substr: &Substructure) -> Gc<Expr> {\n+fn hash_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure) -> P<Expr> {\n     let state_expr = match substr.nonself_args {\n-        [state_expr] => state_expr,\n+        [ref state_expr] => state_expr,\n         _ => cx.span_bug(trait_span, \"incorrect number of arguments in `deriving(Hash)`\")\n     };\n     let hash_ident = substr.method_ident;\n     let call_hash = |span, thing_expr| {\n-        let expr = cx.expr_method_call(span, thing_expr, hash_ident, vec!(state_expr));\n+        let expr = cx.expr_method_call(span, thing_expr, hash_ident, vec!(state_expr.clone()));\n         cx.stmt_expr(expr)\n     };\n     let mut stmts = Vec::new();\n@@ -83,7 +81,7 @@ fn hash_substructure(cx: &mut ExtCtxt, trait_span: Span,\n             // Determine the discriminant. We will feed this value to the byte\n             // iteration function.\n             let discriminant = match variant.node.disr_expr {\n-                Some(d) => d,\n+                Some(ref d) => d.clone(),\n                 None => cx.expr_uint(trait_span, index)\n             };\n \n@@ -94,8 +92,8 @@ fn hash_substructure(cx: &mut ExtCtxt, trait_span: Span,\n         _ => cx.span_bug(trait_span, \"impossible substructure in `deriving(Hash)`\")\n     };\n \n-    for &FieldInfo { self_, span, .. } in fields.iter() {\n-        stmts.push(call_hash(span, self_));\n+    for &FieldInfo { ref self_, span, .. } in fields.iter() {\n+        stmts.push(call_hash(span, self_.clone()));\n     }\n \n     if stmts.len() == 0 {"}, {"sha": "b8cebd8ea201c74708090bd056e22f4225071738", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -21,8 +21,7 @@ library.\n use ast::{Item, MetaItem, MetaList, MetaNameValue, MetaWord};\n use ext::base::ExtCtxt;\n use codemap::Span;\n-\n-use std::gc::Gc;\n+use ptr::P;\n \n pub mod bounds;\n pub mod clone;\n@@ -49,9 +48,9 @@ pub mod generic;\n \n pub fn expand_meta_deriving(cx: &mut ExtCtxt,\n                             _span: Span,\n-                            mitem: Gc<MetaItem>,\n-                            item: Gc<Item>,\n-                            push: |Gc<Item>|) {\n+                            mitem: &MetaItem,\n+                            item: &Item,\n+                            push: |P<Item>|) {\n     match mitem.node {\n         MetaNameValue(_, ref l) => {\n             cx.span_err(l.span, \"unexpected value in `deriving`\");\n@@ -63,13 +62,13 @@ pub fn expand_meta_deriving(cx: &mut ExtCtxt,\n             cx.span_warn(mitem.span, \"empty trait list in `deriving`\");\n         }\n         MetaList(_, ref titems) => {\n-            for &titem in titems.iter().rev() {\n+            for titem in titems.iter().rev() {\n                 match titem.node {\n                     MetaNameValue(ref tname, _) |\n                     MetaList(ref tname, _) |\n                     MetaWord(ref tname) => {\n                         macro_rules! expand(($func:path) => ($func(cx, titem.span,\n-                                                                   titem, item,\n+                                                                   &**titem, item,\n                                                                    |i| push(i))));\n                         match tname.get() {\n                             \"Clone\" => expand!(clone::expand_deriving_clone),"}, {"sha": "044a2812c000397f66c80a23a75fcd767f721852", "filename": "src/libsyntax/ext/deriving/primitive.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -16,14 +16,13 @@ use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n-\n-use std::gc::Gc;\n+use ptr::P;\n \n pub fn expand_deriving_from_primitive(cx: &mut ExtCtxt,\n                                       span: Span,\n-                                      mitem: Gc<MetaItem>,\n-                                      item: Gc<Item>,\n-                                      push: |Gc<Item>|) {\n+                                      mitem: &MetaItem,\n+                                      item: &Item,\n+                                      push: |P<Item>|) {\n     let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n     let attrs = vec!(cx.attribute(span, inline));\n     let trait_def = TraitDef {\n@@ -70,10 +69,9 @@ pub fn expand_deriving_from_primitive(cx: &mut ExtCtxt,\n     trait_def.expand(cx, mitem, item, push)\n }\n \n-fn cs_from(name: &str, cx: &mut ExtCtxt, trait_span: Span,\n-           substr: &Substructure) -> Gc<Expr> {\n+fn cs_from(name: &str, cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure) -> P<Expr> {\n     let n = match substr.nonself_args {\n-        [n] => n,\n+        [ref n] => n,\n         _ => cx.span_bug(trait_span, \"incorrect number of arguments in `deriving(FromPrimitive)`\")\n     };\n \n@@ -106,8 +104,8 @@ fn cs_from(name: &str, cx: &mut ExtCtxt, trait_span: Span,\n                         // expr for `$n == $variant as $name`\n                         let variant = cx.expr_ident(span, variant.node.name);\n                         let ty = cx.ty_ident(span, cx.ident_of(name));\n-                        let cast = cx.expr_cast(span, variant, ty);\n-                        let guard = cx.expr_binary(span, ast::BiEq, n, cast);\n+                        let cast = cx.expr_cast(span, variant.clone(), ty);\n+                        let guard = cx.expr_binary(span, ast::BiEq, n.clone(), cast);\n \n                         // expr for `Some($variant)`\n                         let body = cx.expr_some(span, variant);\n@@ -141,7 +139,7 @@ fn cs_from(name: &str, cx: &mut ExtCtxt, trait_span: Span,\n             };\n             arms.push(arm);\n \n-            cx.expr_match(trait_span, n, arms)\n+            cx.expr_match(trait_span, n.clone(), arms)\n         }\n         _ => cx.span_bug(trait_span, \"expected StaticEnum in deriving(FromPrimitive)\")\n     }"}, {"sha": "584645bb306394116f6563322dbfdcb6034db4aa", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -15,14 +15,13 @@ use ext::base::ExtCtxt;\n use ext::build::{AstBuilder};\n use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n-\n-use std::gc::Gc;\n+use ptr::P;\n \n pub fn expand_deriving_rand(cx: &mut ExtCtxt,\n                             span: Span,\n-                            mitem: Gc<MetaItem>,\n-                            item: Gc<Item>,\n-                            push: |Gc<Item>|) {\n+                            mitem: &MetaItem,\n+                            item: &Item,\n+                            push: |P<Item>|) {\n     let trait_def = TraitDef {\n         span: span,\n         attributes: Vec::new(),\n@@ -54,10 +53,9 @@ pub fn expand_deriving_rand(cx: &mut ExtCtxt,\n     trait_def.expand(cx, mitem, item, push)\n }\n \n-fn rand_substructure(cx: &mut ExtCtxt, trait_span: Span,\n-                     substr: &Substructure) -> Gc<Expr> {\n+fn rand_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure) -> P<Expr> {\n     let rng = match substr.nonself_args {\n-        [rng] => vec!( rng ),\n+        [ref rng] => rng,\n         _ => cx.bug(\"Incorrect number of arguments to `rand` in `deriving(Rand)`\")\n     };\n     let rand_ident = vec!(\n@@ -69,7 +67,7 @@ fn rand_substructure(cx: &mut ExtCtxt, trait_span: Span,\n     let rand_call = |cx: &mut ExtCtxt, span| {\n         cx.expr_call_global(span,\n                             rand_ident.clone(),\n-                            vec!( *rng.get(0) ))\n+                            vec!(rng.clone()))\n     };\n \n     return match *substr.fields {\n@@ -95,7 +93,7 @@ fn rand_substructure(cx: &mut ExtCtxt, trait_span: Span,\n             // ::rand::Rand::rand(rng)\n             let rv_call = cx.expr_call(trait_span,\n                                        rand_name,\n-                                       vec!( *rng.get(0) ));\n+                                       vec!(rng.clone()));\n \n             // need to specify the uint-ness of the random number\n             let uint_ty = cx.ty_ident(trait_span, cx.ident_of(\"uint\"));\n@@ -136,8 +134,8 @@ fn rand_substructure(cx: &mut ExtCtxt, trait_span: Span,\n                   trait_span: Span,\n                   ctor_ident: Ident,\n                   summary: &StaticFields,\n-                  rand_call: |&mut ExtCtxt, Span| -> Gc<Expr>)\n-                  -> Gc<Expr> {\n+                  rand_call: |&mut ExtCtxt, Span| -> P<Expr>)\n+                  -> P<Expr> {\n         match *summary {\n             Unnamed(ref fields) => {\n                 if fields.is_empty() {"}, {"sha": "16ce264fe712d46d94003823e3b688177e59bef3", "filename": "src/libsyntax/ext/deriving/show.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -9,24 +9,23 @@\n // except according to those terms.\n \n use ast;\n-use ast::{MetaItem, Item, Expr};\n+use ast::{MetaItem, Item, Expr,};\n use codemap::Span;\n use ext::format;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n use parse::token;\n+use ptr::P;\n \n use std::collections::HashMap;\n-use std::string::String;\n-use std::gc::Gc;\n \n pub fn expand_deriving_show(cx: &mut ExtCtxt,\n                             span: Span,\n-                            mitem: Gc<MetaItem>,\n-                            item: Gc<Item>,\n-                            push: |Gc<Item>|) {\n+                            mitem: &MetaItem,\n+                            item: &Item,\n+                            push: |P<Item>|) {\n     // &mut ::std::fmt::Formatter\n     let fmtr = Ptr(box Literal(Path::new(vec!(\"std\", \"fmt\", \"Formatter\"))),\n                    Borrowed(None, ast::MutMutable));\n@@ -57,7 +56,7 @@ pub fn expand_deriving_show(cx: &mut ExtCtxt,\n /// We construct a format string and then defer to std::fmt, since that\n /// knows what's up with formatting and so on.\n fn show_substructure(cx: &mut ExtCtxt, span: Span,\n-                     substr: &Substructure) -> Gc<Expr> {\n+                     substr: &Substructure) -> P<Expr> {\n     // build `<name>`, `<name>({}, {}, ...)` or `<name> { <field>: {},\n     // <field>: {}, ... }` based on the \"shape\".\n     //\n@@ -91,7 +90,7 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span,\n \n                     format_string.push_str(\"{}\");\n \n-                    exprs.push(field.self_);\n+                    exprs.push(field.self_.clone());\n                 }\n \n                 format_string.push_str(\")\");\n@@ -108,7 +107,7 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span,\n                     format_string.push_str(name.get());\n                     format_string.push_str(\": {}\");\n \n-                    exprs.push(field.self_);\n+                    exprs.push(field.self_.clone());\n                 }\n \n                 format_string.push_str(\" }}\");\n@@ -123,7 +122,7 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span,\n     // format_arg_method!(fmt, write_fmt, \"<format_string>\", exprs...)\n     //\n     // but doing it directly via ext::format.\n-    let formatter = substr.nonself_args[0];\n+    let formatter = substr.nonself_args[0].clone();\n \n     let meth = cx.ident_of(\"write_fmt\");\n     let s = token::intern_and_get_ident(format_string.as_slice());"}, {"sha": "7f265b529ffea6f53b224272af94b5a11a287939", "filename": "src/libsyntax/ext/deriving/zero.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -15,14 +15,13 @@ use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n-\n-use std::gc::Gc;\n+use ptr::P;\n \n pub fn expand_deriving_zero(cx: &mut ExtCtxt,\n                             span: Span,\n-                            mitem: Gc<MetaItem>,\n-                            item: Gc<Item>,\n-                            push: |Gc<Item>|) {\n+                            mitem: &MetaItem,\n+                            item: &Item,\n+                            push: |P<Item>|) {\n     let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n     let attrs = vec!(cx.attribute(span, inline));\n     let trait_def = TraitDef {\n@@ -63,8 +62,7 @@ pub fn expand_deriving_zero(cx: &mut ExtCtxt,\n     trait_def.expand(cx, mitem, item, push)\n }\n \n-fn zero_substructure(cx: &mut ExtCtxt, trait_span: Span,\n-                     substr: &Substructure) -> Gc<Expr> {\n+fn zero_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure) -> P<Expr> {\n     let zero_ident = vec!(\n         cx.ident_of(\"std\"),\n         cx.ident_of(\"num\"),"}, {"sha": "69574ee6696781e4ffbdfecd7d6d8a4bef572f5d", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -61,38 +61,42 @@ pub fn expand_option_env<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenT\n \n pub fn expand_env<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                        -> Box<base::MacResult+'cx> {\n-    let exprs = match get_exprs_from_tts(cx, sp, tts) {\n+    let mut exprs = match get_exprs_from_tts(cx, sp, tts) {\n         Some(ref exprs) if exprs.len() == 0 => {\n             cx.span_err(sp, \"env! takes 1 or 2 arguments\");\n             return DummyResult::expr(sp);\n         }\n         None => return DummyResult::expr(sp),\n-        Some(exprs) => exprs\n+        Some(exprs) => exprs.move_iter()\n     };\n \n     let var = match expr_to_string(cx,\n-                                *exprs.get(0),\n+                                exprs.next().unwrap(),\n                                 \"expected string literal\") {\n         None => return DummyResult::expr(sp),\n         Some((v, _style)) => v\n     };\n-    let msg = match exprs.len() {\n-        1 => {\n+    let msg = match exprs.next() {\n+        None => {\n             token::intern_and_get_ident(format!(\"environment variable `{}` \\\n                                                  not defined\",\n                                                 var).as_slice())\n         }\n-        2 => {\n-            match expr_to_string(cx, *exprs.get(1), \"expected string literal\") {\n+        Some(second) => {\n+            match expr_to_string(cx, second, \"expected string literal\") {\n                 None => return DummyResult::expr(sp),\n                 Some((s, _style)) => s\n             }\n         }\n-        _ => {\n+    };\n+\n+    match exprs.next() {\n+        None => {}\n+        Some(_) => {\n             cx.span_err(sp, \"env! takes 1 or 2 arguments\");\n             return DummyResult::expr(sp);\n         }\n-    };\n+    }\n \n     let e = match os::getenv(var.get()) {\n         None => {"}, {"sha": "310f7c4f3036fa5a2c92576dc830c623adee649b", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 290, "deletions": 289, "changes": 579, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{P, Block, Crate, DeclLocal, ExprMac, PatMac};\n+use ast::{Block, Crate, DeclLocal, ExprMac, PatMac};\n use ast::{Local, Ident, MacInvocTT};\n use ast::{ItemMac, Mrk, Stmt, StmtDecl, StmtMac, StmtExpr, StmtSemi};\n use ast::TokenTree;\n@@ -25,103 +25,106 @@ use fold::*;\n use parse;\n use parse::token::{fresh_mark, fresh_name, intern};\n use parse::token;\n+use ptr::P;\n+use util::small_vector::SmallVector;\n use visit;\n use visit::Visitor;\n-use util::small_vector::SmallVector;\n \n-use std::gc::{Gc, GC};\n+use std::gc::Gc;\n \n enum Either<L,R> {\n     Left(L),\n     Right(R)\n }\n \n-fn expand_expr(e: Gc<ast::Expr>, fld: &mut MacroExpander) -> Gc<ast::Expr> {\n-    match e.node {\n+pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n+    e.and_then(|ast::Expr {id, node, span}| match node {\n         // expr_mac should really be expr_ext or something; it's the\n         // entry-point for all syntax extensions.\n-        ExprMac(ref mac) => {\n-            let expanded_expr = match expand_mac_invoc(mac,&e.span,\n-                                                       |r|{r.make_expr()},\n-                                                       |expr,fm|{mark_expr(expr,fm)},\n-                                                       fld) {\n+        ExprMac(mac) => {\n+            let expanded_expr = match expand_mac_invoc(mac, span,\n+                                                       |r| r.make_expr(),\n+                                                       mark_expr, fld) {\n                 Some(expr) => expr,\n                 None => {\n-                    return DummyResult::raw_expr(e.span);\n+                    return DummyResult::raw_expr(span);\n                 }\n             };\n \n             // Keep going, outside-in.\n             //\n-            // FIXME(pcwalton): Is it necessary to clone the\n-            // node here?\n-            let fully_expanded =\n-                fld.fold_expr(expanded_expr).node.clone();\n+            let fully_expanded = fld.fold_expr(expanded_expr);\n             fld.cx.bt_pop();\n \n-            box(GC) ast::Expr {\n+            fully_expanded.map(|e| ast::Expr {\n                 id: ast::DUMMY_NODE_ID,\n-                node: fully_expanded,\n-                span: e.span,\n-            }\n+                node: e.node,\n+                span: span,\n+            })\n         }\n \n         ast::ExprWhile(cond, body, opt_ident) => {\n             let cond = fld.fold_expr(cond);\n             let (body, opt_ident) = expand_loop_block(body, opt_ident, fld);\n-            fld.cx.expr(e.span, ast::ExprWhile(cond, body, opt_ident))\n+            fld.cx.expr(span, ast::ExprWhile(cond, body, opt_ident))\n         }\n \n         ast::ExprLoop(loop_block, opt_ident) => {\n             let (loop_block, opt_ident) = expand_loop_block(loop_block, opt_ident, fld);\n-            fld.cx.expr(e.span, ast::ExprLoop(loop_block, opt_ident))\n+            fld.cx.expr(span, ast::ExprLoop(loop_block, opt_ident))\n         }\n \n         ast::ExprForLoop(pat, head, body, opt_ident) => {\n             let pat = fld.fold_pat(pat);\n             let head = fld.fold_expr(head);\n             let (body, opt_ident) = expand_loop_block(body, opt_ident, fld);\n-            fld.cx.expr(e.span, ast::ExprForLoop(pat, head, body, opt_ident))\n+            fld.cx.expr(span, ast::ExprForLoop(pat, head, body, opt_ident))\n         }\n \n         ast::ExprFnBlock(capture_clause, fn_decl, block) => {\n             let (rewritten_fn_decl, rewritten_block)\n-                = expand_and_rename_fn_decl_and_block(&*fn_decl, block, fld);\n+                = expand_and_rename_fn_decl_and_block(fn_decl, block, fld);\n             let new_node = ast::ExprFnBlock(capture_clause,\n                                             rewritten_fn_decl,\n                                             rewritten_block);\n-            box(GC) ast::Expr{id:e.id, node: new_node, span: fld.new_span(e.span)}\n+            P(ast::Expr{id:id, node: new_node, span: fld.new_span(span)})\n         }\n \n         ast::ExprProc(fn_decl, block) => {\n             let (rewritten_fn_decl, rewritten_block)\n-                = expand_and_rename_fn_decl_and_block(&*fn_decl, block, fld);\n+                = expand_and_rename_fn_decl_and_block(fn_decl, block, fld);\n             let new_node = ast::ExprProc(rewritten_fn_decl, rewritten_block);\n-            box(GC) ast::Expr{id:e.id, node: new_node, span: fld.new_span(e.span)}\n+            P(ast::Expr{id:id, node: new_node, span: fld.new_span(span)})\n         }\n \n-        _ => noop_fold_expr(e, fld)\n-    }\n+        _ => {\n+            P(noop_fold_expr(ast::Expr {\n+                id: id,\n+                node: node,\n+                span: span\n+            }, fld))\n+        }\n+    })\n }\n \n /// Expand a (not-ident-style) macro invocation. Returns the result\n /// of expansion and the mark which must be applied to the result.\n /// Our current interface doesn't allow us to apply the mark to the\n /// result until after calling make_expr, make_items, etc.\n-fn expand_mac_invoc<T>(mac: &ast::Mac, span: &codemap::Span,\n+fn expand_mac_invoc<T>(mac: ast::Mac, span: codemap::Span,\n                        parse_thunk: |Box<MacResult>|->Option<T>,\n                        mark_thunk: |T,Mrk|->T,\n                        fld: &mut MacroExpander)\n                        -> Option<T>\n {\n-    match (*mac).node {\n+    match mac.node {\n         // it would almost certainly be cleaner to pass the whole\n         // macro invocation in, rather than pulling it apart and\n         // marking the tts and the ctxt separately. This also goes\n         // for the other three macro invocation chunks of code\n         // in this file.\n         // Token-tree macros:\n-        MacInvocTT(ref pth, ref tts, _) => {\n+        MacInvocTT(pth, tts, _) => {\n             if pth.segments.len() > 1u {\n                 fld.cx.span_err(pth.span,\n                                 \"expected macro name without module \\\n@@ -144,7 +147,7 @@ fn expand_mac_invoc<T>(mac: &ast::Mac, span: &codemap::Span,\n                 Some(rc) => match *rc {\n                     NormalTT(ref expandfun, exp_span) => {\n                         fld.cx.bt_push(ExpnInfo {\n-                                call_site: *span,\n+                                call_site: span,\n                                 callee: NameAndSpan {\n                                     name: extnamestr.get().to_string(),\n                                     format: MacroBang,\n@@ -218,7 +221,7 @@ fn expand_loop_block(loop_block: P<Block>,\n             // in a block enclosed by loop head.\n             fld.cx.syntax_env.push_frame();\n             fld.cx.syntax_env.info().pending_renames.push(rename);\n-            let expanded_block = expand_block_elts(&*loop_block, fld);\n+            let expanded_block = expand_block_elts(loop_block, fld);\n             fld.cx.syntax_env.pop_frame();\n \n             (expanded_block, Some(renamed_ident))\n@@ -240,8 +243,8 @@ macro_rules! with_exts_frame (\n )\n \n // When we enter a module, record it, for the sake of `module!`\n-fn expand_item(it: Gc<ast::Item>, fld: &mut MacroExpander)\n-                   -> SmallVector<Gc<ast::Item>> {\n+pub fn expand_item(it: P<ast::Item>, fld: &mut MacroExpander)\n+                   -> SmallVector<P<ast::Item>> {\n     let it = expand_item_modifiers(it, fld);\n \n     let mut decorator_items = SmallVector::zero();\n@@ -265,8 +268,9 @@ fn expand_item(it: Gc<ast::Item>, fld: &mut MacroExpander)\n \n                     // we'd ideally decorator_items.push_all(expand_item(item, fld)),\n                     // but that double-mut-borrows fld\n-                    let mut items: SmallVector<Gc<ast::Item>> = SmallVector::zero();\n-                    dec.expand(fld.cx, attr.span, attr.node.value, it, |item| items.push(item));\n+                    let mut items: SmallVector<P<ast::Item>> = SmallVector::zero();\n+                    dec.expand(fld.cx, attr.span, &*attr.node.value, &*it,\n+                               |item| items.push(item));\n                     decorator_items.extend(items.move_iter()\n                         .flat_map(|item| expand_item(item, fld).move_iter()));\n \n@@ -285,26 +289,25 @@ fn expand_item(it: Gc<ast::Item>, fld: &mut MacroExpander)\n             let macro_escape = contains_macro_escape(new_attrs.as_slice());\n             let result = with_exts_frame!(fld.cx.syntax_env,\n                                           macro_escape,\n-                                          noop_fold_item(&*it, fld));\n+                                          noop_fold_item(it, fld));\n             fld.cx.mod_pop();\n             result\n         },\n         _ => {\n-            let it = box(GC) ast::Item {\n+            let it = P(ast::Item {\n                 attrs: new_attrs,\n                 ..(*it).clone()\n-\n-            };\n-            noop_fold_item(&*it, fld)\n+            });\n+            noop_fold_item(it, fld)\n         }\n     };\n \n     new_items.push_all(decorator_items);\n     new_items\n }\n \n-fn expand_item_modifiers(mut it: Gc<ast::Item>, fld: &mut MacroExpander)\n-                         -> Gc<ast::Item> {\n+fn expand_item_modifiers(mut it: P<ast::Item>, fld: &mut MacroExpander)\n+                         -> P<ast::Item> {\n     // partition the attributes into ItemModifiers and others\n     let (modifiers, other_attrs) = it.attrs.partitioned(|attr| {\n         match fld.cx.syntax_env.find(&intern(attr.name().get())) {\n@@ -313,10 +316,10 @@ fn expand_item_modifiers(mut it: Gc<ast::Item>, fld: &mut MacroExpander)\n         }\n     });\n     // update the attrs, leave everything else alone. Is this mutation really a good idea?\n-    it = box(GC) ast::Item {\n+    it = P(ast::Item {\n         attrs: other_attrs,\n         ..(*it).clone()\n-    };\n+    });\n \n     if modifiers.is_empty() {\n         return it;\n@@ -337,7 +340,7 @@ fn expand_item_modifiers(mut it: Gc<ast::Item>, fld: &mut MacroExpander)\n                             span: None,\n                         }\n                     });\n-                    it = mac.expand(fld.cx, attr.span, attr.node.value, it);\n+                    it = mac.expand(fld.cx, attr.span, &*attr.node.value, it);\n                     fld.cx.bt_pop();\n                 }\n                 _ => unreachable!()\n@@ -351,15 +354,15 @@ fn expand_item_modifiers(mut it: Gc<ast::Item>, fld: &mut MacroExpander)\n }\n \n /// Expand item_underscore\n-fn expand_item_underscore(item: &ast::Item_, fld: &mut MacroExpander) -> ast::Item_ {\n-    match *item {\n-        ast::ItemFn(decl, fn_style, abi, ref generics, body) => {\n+fn expand_item_underscore(item: ast::Item_, fld: &mut MacroExpander) -> ast::Item_ {\n+    match item {\n+        ast::ItemFn(decl, fn_style, abi, generics, body) => {\n             let (rewritten_fn_decl, rewritten_body)\n-                = expand_and_rename_fn_decl_and_block(&*decl, body, fld);\n+                = expand_and_rename_fn_decl_and_block(decl, body, fld);\n             let expanded_generics = fold::noop_fold_generics(generics,fld);\n             ast::ItemFn(rewritten_fn_decl, fn_style, abi, expanded_generics, rewritten_body)\n         }\n-        _ => noop_fold_item_underscore(&*item, fld)\n+        _ => noop_fold_item_underscore(item, fld)\n     }\n }\n \n@@ -370,26 +373,24 @@ fn contains_macro_escape(attrs: &[ast::Attribute]) -> bool {\n \n // Support for item-position macro invocations, exactly the same\n // logic as for expression-position macro invocations.\n-fn expand_item_mac(it: Gc<ast::Item>, fld: &mut MacroExpander)\n-                   -> SmallVector<Gc<ast::Item>>\n-{\n-    let (pth, tts) = match it.node {\n+pub fn expand_item_mac(it: P<ast::Item>, fld: &mut MacroExpander)\n+                       -> SmallVector<P<ast::Item>> {\n+    let (extname, path_span, tts) = match it.node {\n         ItemMac(codemap::Spanned {\n             node: MacInvocTT(ref pth, ref tts, _),\n             ..\n         }) => {\n-            (pth, (*tts).clone())\n+            (pth.segments.get(0).identifier, pth.span, (*tts).clone())\n         }\n         _ => fld.cx.span_bug(it.span, \"invalid item macro invocation\")\n     };\n \n-    let extname = pth.segments.get(0).identifier;\n     let extnamestr = token::get_ident(extname);\n     let fm = fresh_mark();\n     let def_or_items = {\n-        let expanded = match fld.cx.syntax_env.find(&extname.name) {\n+        let mut expanded = match fld.cx.syntax_env.find(&extname.name) {\n             None => {\n-                fld.cx.span_err(pth.span,\n+                fld.cx.span_err(path_span,\n                                 format!(\"macro undefined: '{}!'\",\n                                         extnamestr).as_slice());\n                 // let compilation continue\n@@ -400,7 +401,7 @@ fn expand_item_mac(it: Gc<ast::Item>, fld: &mut MacroExpander)\n                 NormalTT(ref expander, span) => {\n                     if it.ident.name != parse::token::special_idents::invalid.name {\n                         fld.cx\n-                            .span_err(pth.span,\n+                            .span_err(path_span,\n                                       format!(\"macro {}! expects no ident argument, \\\n                                         given '{}'\",\n                                       extnamestr,\n@@ -421,7 +422,7 @@ fn expand_item_mac(it: Gc<ast::Item>, fld: &mut MacroExpander)\n                 }\n                 IdentTT(ref expander, span) => {\n                     if it.ident.name == parse::token::special_idents::invalid.name {\n-                        fld.cx.span_err(pth.span,\n+                        fld.cx.span_err(path_span,\n                                         format!(\"macro {}! expects an ident argument\",\n                                                 extnamestr.get()).as_slice());\n                         return SmallVector::zero();\n@@ -440,7 +441,7 @@ fn expand_item_mac(it: Gc<ast::Item>, fld: &mut MacroExpander)\n                 }\n                 LetSyntaxTT(ref expander, span) => {\n                     if it.ident.name == parse::token::special_idents::invalid.name {\n-                        fld.cx.span_err(pth.span,\n+                        fld.cx.span_err(path_span,\n                                         format!(\"macro {}! expects an ident argument\",\n                                                 extnamestr.get()).as_slice());\n                         return SmallVector::zero();\n@@ -490,79 +491,64 @@ fn expand_item_mac(it: Gc<ast::Item>, fld: &mut MacroExpander)\n                 .collect()\n         }\n         Right(None) => {\n-            fld.cx.span_err(pth.span,\n+            fld.cx.span_err(path_span,\n                             format!(\"non-item macro in item position: {}\",\n                                     extnamestr.get()).as_slice());\n             return SmallVector::zero();\n         }\n     };\n \n     fld.cx.bt_pop();\n-    return items;\n+    items\n }\n \n /// Expand a stmt\n //\n // I don't understand why this returns a vector... it looks like we're\n // half done adding machinery to allow macros to expand into multiple statements.\n-fn expand_stmt(s: &Stmt, fld: &mut MacroExpander) -> SmallVector<Gc<Stmt>> {\n+fn expand_stmt(s: Stmt, fld: &mut MacroExpander) -> SmallVector<P<Stmt>> {\n     let (mac, semi) = match s.node {\n-        StmtMac(ref mac, semi) => (mac, semi),\n+        StmtMac(mac, semi) => (mac, semi),\n         _ => return expand_non_macro_stmt(s, fld)\n     };\n-    let expanded_stmt = match expand_mac_invoc(mac,&s.span,\n-                                                |r|{r.make_stmt()},\n-                                                |sts,mrk| {\n-                                                    mark_stmt(&*sts,mrk)\n-                                                },\n-                                                fld) {\n+    let expanded_stmt = match expand_mac_invoc(mac, s.span,\n+                                                |r| r.make_stmt(),\n+                                                mark_stmt, fld) {\n         Some(stmt) => stmt,\n         None => {\n             return SmallVector::zero();\n         }\n     };\n \n     // Keep going, outside-in.\n-    let fully_expanded = fld.fold_stmt(&*expanded_stmt);\n+    let fully_expanded = fld.fold_stmt(expanded_stmt);\n     fld.cx.bt_pop();\n-    let fully_expanded: SmallVector<Gc<Stmt>> = fully_expanded.move_iter()\n-            .map(|s| box(GC) Spanned { span: s.span, node: s.node.clone() })\n-            .collect();\n-\n-    fully_expanded.move_iter().map(|s| {\n-        match s.node {\n-            StmtExpr(e, stmt_id) if semi => {\n-                box(GC) Spanned {\n-                    span: s.span,\n-                    node: StmtSemi(e, stmt_id)\n-                }\n+\n+    if semi {\n+        fully_expanded.move_iter().map(|s| s.map(|Spanned {node, span}| {\n+            Spanned {\n+                node: match node {\n+                    StmtExpr(e, stmt_id) => StmtSemi(e, stmt_id),\n+                    _ => node /* might already have a semi */\n+                },\n+                span: span\n             }\n-            _ => s /* might already have a semi */\n-        }\n-    }).collect()\n+        })).collect()\n+    } else {\n+        fully_expanded\n+    }\n }\n \n // expand a non-macro stmt. this is essentially the fallthrough for\n // expand_stmt, above.\n-fn expand_non_macro_stmt(s: &Stmt, fld: &mut MacroExpander)\n-                         -> SmallVector<Gc<Stmt>> {\n+fn expand_non_macro_stmt(Spanned {node, span: stmt_span}: Stmt, fld: &mut MacroExpander)\n+                         -> SmallVector<P<Stmt>> {\n     // is it a let?\n-    match s.node {\n-        StmtDecl(decl, node_id) => {\n-            match *decl {\n-                Spanned {\n-                    node: DeclLocal(ref local),\n-                    span: stmt_span\n-                } => {\n-                    // take it apart:\n-                    let Local {\n-                        ty: ty,\n-                        pat: pat,\n-                        init: init,\n-                        id: id,\n-                        span: span,\n-                        source: source,\n-                    } = **local;\n+    match node {\n+        StmtDecl(decl, node_id) => decl.and_then(|Spanned {node: decl, span}| match decl {\n+            DeclLocal(local) => {\n+                // take it apart:\n+                let rewritten_local = local.map(|Local {id, pat, ty, init, source, span}| {\n                     // expand the ty since TyFixedLengthVec contains an Expr\n                     // and thus may have a macro use\n                     let expanded_ty = fld.fold_ty(ty);\n@@ -585,57 +571,66 @@ fn expand_non_macro_stmt(s: &Stmt, fld: &mut MacroExpander)\n                     };\n                     // add them to the existing pending renames:\n                     fld.cx.syntax_env.info().pending_renames.push_all_move(new_pending_renames);\n-                    // also, don't forget to expand the init:\n-                    let new_init_opt = init.map(|e| fld.fold_expr(e));\n-                    let rewritten_local =\n-                        box(GC) Local {\n-                            ty: expanded_ty,\n-                            pat: rewritten_pat,\n-                            init: new_init_opt,\n-                            id: id,\n-                            span: span,\n-                            source: source\n-                        };\n-                    SmallVector::one(box(GC) Spanned {\n-                        node: StmtDecl(box(GC) Spanned {\n-                                node: DeclLocal(rewritten_local),\n-                                span: stmt_span\n-                            },\n-                            node_id),\n+                    Local {\n+                        id: id,\n+                        ty: expanded_ty,\n+                        pat: rewritten_pat,\n+                        // also, don't forget to expand the init:\n+                        init: init.map(|e| fld.fold_expr(e)),\n+                        source: source,\n                         span: span\n-                    })\n-                }\n-                _ => noop_fold_stmt(s, fld),\n+                    }\n+                });\n+                SmallVector::one(P(Spanned {\n+                    node: StmtDecl(P(Spanned {\n+                            node: DeclLocal(rewritten_local),\n+                            span: span\n+                        }),\n+                        node_id),\n+                    span: stmt_span\n+                }))\n             }\n-        },\n-        _ => noop_fold_stmt(s, fld),\n+            _ => {\n+                noop_fold_stmt(Spanned {\n+                    node: StmtDecl(P(Spanned {\n+                            node: decl,\n+                            span: span\n+                        }),\n+                        node_id),\n+                    span: stmt_span\n+                }, fld)\n+            }\n+        }),\n+        _ => {\n+            noop_fold_stmt(Spanned {\n+                node: node,\n+                span: stmt_span\n+            }, fld)\n+        }\n     }\n }\n \n // expand the arm of a 'match', renaming for macro hygiene\n-fn expand_arm(arm: &ast::Arm, fld: &mut MacroExpander) -> ast::Arm {\n+fn expand_arm(arm: ast::Arm, fld: &mut MacroExpander) -> ast::Arm {\n     // expand pats... they might contain macro uses:\n-    let expanded_pats : Vec<Gc<ast::Pat>> = arm.pats.iter().map(|pat| fld.fold_pat(*pat)).collect();\n+    let expanded_pats = arm.pats.move_map(|pat| fld.fold_pat(pat));\n     if expanded_pats.len() == 0 {\n         fail!(\"encountered match arm with 0 patterns\");\n     }\n     // all of the pats must have the same set of bindings, so use the\n     // first one to extract them and generate new names:\n-    let first_pat = expanded_pats.get(0);\n-    let idents = pattern_bindings(&**first_pat);\n-    let new_renames =\n-        idents.iter().map(|id| (*id,fresh_name(id))).collect();\n+    let idents = pattern_bindings(&**expanded_pats.get(0));\n+    let new_renames = idents.move_iter().map(|id| (id, fresh_name(&id))).collect();\n     // apply the renaming, but only to the PatIdents:\n     let mut rename_pats_fld = PatIdentRenamer{renames:&new_renames};\n-    let rewritten_pats =\n-        expanded_pats.iter().map(|pat| rename_pats_fld.fold_pat(*pat)).collect();\n+    let rewritten_pats = expanded_pats.move_map(|pat| rename_pats_fld.fold_pat(pat));\n     // apply renaming and then expansion to the guard and the body:\n     let mut rename_fld = IdentRenamer{renames:&new_renames};\n     let rewritten_guard =\n         arm.guard.map(|g| fld.fold_expr(rename_fld.fold_expr(g)));\n     let rewritten_body = fld.fold_expr(rename_fld.fold_expr(arm.body));\n     ast::Arm {\n-        attrs: arm.attrs.iter().map(|x| fld.fold_attribute(*x)).collect(),\n+        attrs: arm.attrs.move_map(|x| fld.fold_attribute(x)),\n         pats: rewritten_pats,\n         guard: rewritten_guard,\n         body: rewritten_body,\n@@ -683,121 +678,126 @@ fn fn_decl_arg_bindings(fn_decl: &ast::FnDecl) -> Vec<ast::Ident> {\n }\n \n // expand a block. pushes a new exts_frame, then calls expand_block_elts\n-fn expand_block(blk: &Block, fld: &mut MacroExpander) -> P<Block> {\n+pub fn expand_block(blk: P<Block>, fld: &mut MacroExpander) -> P<Block> {\n     // see note below about treatment of exts table\n     with_exts_frame!(fld.cx.syntax_env,false,\n                      expand_block_elts(blk, fld))\n }\n \n // expand the elements of a block.\n-fn expand_block_elts(b: &Block, fld: &mut MacroExpander) -> P<Block> {\n-    let new_view_items = b.view_items.iter().map(|x| fld.fold_view_item(x)).collect();\n-    let new_stmts =\n-        b.stmts.iter().flat_map(|x| {\n+pub fn expand_block_elts(b: P<Block>, fld: &mut MacroExpander) -> P<Block> {\n+    b.map(|Block {id, view_items, stmts, expr, rules, span}| {\n+        let new_view_items = view_items.move_iter().map(|x| fld.fold_view_item(x)).collect();\n+        let new_stmts = stmts.move_iter().flat_map(|x| {\n             // perform all pending renames\n             let renamed_stmt = {\n                 let pending_renames = &mut fld.cx.syntax_env.info().pending_renames;\n                 let mut rename_fld = IdentRenamer{renames:pending_renames};\n-                rename_fld.fold_stmt(&**x).expect_one(\"rename_fold didn't return one value\")\n+                rename_fld.fold_stmt(x).expect_one(\"rename_fold didn't return one value\")\n             };\n             // expand macros in the statement\n-            fld.fold_stmt(&*renamed_stmt).move_iter()\n+            fld.fold_stmt(renamed_stmt).move_iter()\n         }).collect();\n-    let new_expr = b.expr.map(|x| {\n-        let expr = {\n-            let pending_renames = &mut fld.cx.syntax_env.info().pending_renames;\n-            let mut rename_fld = IdentRenamer{renames:pending_renames};\n-            rename_fld.fold_expr(x)\n-        };\n-        fld.fold_expr(expr)\n-    });\n-    P(Block {\n-        view_items: new_view_items,\n-        stmts: new_stmts,\n-        expr: new_expr,\n-        id: fld.new_id(b.id),\n-        rules: b.rules,\n-        span: b.span,\n+        let new_expr = expr.map(|x| {\n+            let expr = {\n+                let pending_renames = &mut fld.cx.syntax_env.info().pending_renames;\n+                let mut rename_fld = IdentRenamer{renames:pending_renames};\n+                rename_fld.fold_expr(x)\n+            };\n+            fld.fold_expr(expr)\n+        });\n+        Block {\n+            id: fld.new_id(id),\n+            view_items: new_view_items,\n+            stmts: new_stmts,\n+            expr: new_expr,\n+            rules: rules,\n+            span: span\n+        }\n     })\n }\n \n-fn expand_pat(p: Gc<ast::Pat>, fld: &mut MacroExpander) -> Gc<ast::Pat> {\n-    let (pth, tts) = match p.node {\n-        PatMac(ref mac) => {\n-            match mac.node {\n-                MacInvocTT(ref pth, ref tts, _) => {\n-                    (pth, (*tts).clone())\n-                }\n-            }\n-        }\n-        _ => return noop_fold_pat(p, fld),\n-    };\n-    if pth.segments.len() > 1u {\n-        fld.cx.span_err(pth.span, \"expected macro name without module separators\");\n-        return DummyResult::raw_pat(p.span);\n+fn expand_pat(p: P<ast::Pat>, fld: &mut MacroExpander) -> P<ast::Pat> {\n+    match p.node {\n+        PatMac(_) => {}\n+        _ => return noop_fold_pat(p, fld)\n     }\n-    let extname = pth.segments.get(0).identifier;\n-    let extnamestr = token::get_ident(extname);\n-    let marked_after = match fld.cx.syntax_env.find(&extname.name) {\n-        None => {\n-            fld.cx.span_err(pth.span,\n-                            format!(\"macro undefined: '{}!'\",\n-                                    extnamestr).as_slice());\n-            // let compilation continue\n-            return DummyResult::raw_pat(p.span);\n+    p.map(|ast::Pat {node, span, ..}| {\n+        let (pth, tts) = match node {\n+            PatMac(mac) => match mac.node {\n+                MacInvocTT(pth, tts, _) => {\n+                    (pth, tts)\n+                }\n+            },\n+            _ => unreachable!()\n+        };\n+        if pth.segments.len() > 1u {\n+            fld.cx.span_err(pth.span, \"expected macro name without module separators\");\n+            return DummyResult::raw_pat(span);\n         }\n+        let extname = pth.segments.get(0).identifier;\n+        let extnamestr = token::get_ident(extname);\n+        let marked_after = match fld.cx.syntax_env.find(&extname.name) {\n+            None => {\n+                fld.cx.span_err(pth.span,\n+                                format!(\"macro undefined: '{}!'\",\n+                                        extnamestr).as_slice());\n+                // let compilation continue\n+                return DummyResult::raw_pat(span);\n+            }\n \n-        Some(rc) => match *rc {\n-            NormalTT(ref expander, span) => {\n-                fld.cx.bt_push(ExpnInfo {\n-                    call_site: p.span,\n-                    callee: NameAndSpan {\n-                        name: extnamestr.get().to_string(),\n-                        format: MacroBang,\n-                        span: span\n-                    }\n-                });\n+            Some(rc) => match *rc {\n+                NormalTT(ref expander, tt_span) => {\n+                    fld.cx.bt_push(ExpnInfo {\n+                        call_site: span,\n+                        callee: NameAndSpan {\n+                            name: extnamestr.get().to_string(),\n+                            format: MacroBang,\n+                            span: tt_span\n+                        }\n+                    });\n \n-                let fm = fresh_mark();\n-                let marked_before = mark_tts(tts.as_slice(), fm);\n-                let mac_span = original_span(fld.cx);\n-                let expanded = match expander.expand(fld.cx,\n-                                    mac_span.call_site,\n-                                    marked_before.as_slice()).make_pat() {\n-                    Some(e) => e,\n-                    None => {\n-                        fld.cx.span_err(\n-                            pth.span,\n-                            format!(\n-                                \"non-pattern macro in pattern position: {}\",\n-                                extnamestr.get()\n-                            ).as_slice()\n-                        );\n-                        return DummyResult::raw_pat(p.span);\n-                    }\n-                };\n+                    let fm = fresh_mark();\n+                    let marked_before = mark_tts(tts.as_slice(), fm);\n+                    let mac_span = original_span(fld.cx);\n+                    let expanded = match expander.expand(fld.cx,\n+                                        mac_span.call_site,\n+                                        marked_before.as_slice()).make_pat() {\n+                        Some(e) => e,\n+                        None => {\n+                            fld.cx.span_err(\n+                                pth.span,\n+                                format!(\n+                                    \"non-pattern macro in pattern position: {}\",\n+                                    extnamestr.get()\n+                                ).as_slice()\n+                            );\n+                            return DummyResult::raw_pat(span);\n+                        }\n+                    };\n \n-                // mark after:\n-                mark_pat(expanded,fm)\n-            }\n-            _ => {\n-                fld.cx.span_err(p.span,\n-                                format!(\"{}! is not legal in pattern position\",\n-                                        extnamestr.get()).as_slice());\n-                return DummyResult::raw_pat(p.span);\n+                    // mark after:\n+                    mark_pat(expanded,fm)\n+                }\n+                _ => {\n+                    fld.cx.span_err(span,\n+                                    format!(\"{}! is not legal in pattern position\",\n+                                            extnamestr.get()).as_slice());\n+                    return DummyResult::raw_pat(span);\n+                }\n             }\n-        }\n-    };\n+        };\n \n-    let fully_expanded =\n-        fld.fold_pat(marked_after).node.clone();\n-    fld.cx.bt_pop();\n+        let fully_expanded =\n+            fld.fold_pat(marked_after).node.clone();\n+        fld.cx.bt_pop();\n \n-    box(GC) ast::Pat {\n-        id: ast::DUMMY_NODE_ID,\n-        node: fully_expanded,\n-        span: p.span,\n-    }\n+        ast::Pat {\n+            id: ast::DUMMY_NODE_ID,\n+            node: fully_expanded,\n+            span: span\n+        }\n+    })\n }\n \n /// A tree-folder that applies every rename in its (mutable) list\n@@ -814,7 +814,7 @@ impl<'a> Folder for IdentRenamer<'a> {\n             ctxt: mtwt::apply_renames(self.renames, id.ctxt),\n         }\n     }\n-    fn fold_mac(&mut self, macro: &ast::Mac) -> ast::Mac {\n+    fn fold_mac(&mut self, macro: ast::Mac) -> ast::Mac {\n         fold::noop_fold_mac(macro, self)\n     }\n }\n@@ -828,45 +828,50 @@ pub struct PatIdentRenamer<'a> {\n }\n \n impl<'a> Folder for PatIdentRenamer<'a> {\n-    fn fold_pat(&mut self, pat: Gc<ast::Pat>) -> Gc<ast::Pat> {\n+    fn fold_pat(&mut self, pat: P<ast::Pat>) -> P<ast::Pat> {\n         match pat.node {\n-            ast::PatIdent(binding_mode, Spanned{span: ref sp, node: id}, ref sub) => {\n-                let new_ident = Ident{name: id.name,\n-                                      ctxt: mtwt::apply_renames(self.renames, id.ctxt)};\n+            ast::PatIdent(..) => {},\n+            _ => return noop_fold_pat(pat, self)\n+        }\n+\n+        pat.map(|ast::Pat {id, node, span}| match node {\n+            ast::PatIdent(binding_mode, Spanned{span: sp, node: ident}, sub) => {\n+                let new_ident = Ident{name: ident.name,\n+                                      ctxt: mtwt::apply_renames(self.renames, ident.ctxt)};\n                 let new_node =\n                     ast::PatIdent(binding_mode,\n-                                  Spanned{span: self.new_span(*sp), node: new_ident},\n+                                  Spanned{span: self.new_span(sp), node: new_ident},\n                                   sub.map(|p| self.fold_pat(p)));\n-                box(GC) ast::Pat {\n-                    id: pat.id,\n-                    span: self.new_span(pat.span),\n+                ast::Pat {\n+                    id: id,\n                     node: new_node,\n+                    span: self.new_span(span)\n                 }\n             },\n-            _ => noop_fold_pat(pat, self)\n-        }\n+            _ => unreachable!()\n+        })\n     }\n-    fn fold_mac(&mut self, macro: &ast::Mac) -> ast::Mac {\n+    fn fold_mac(&mut self, macro: ast::Mac) -> ast::Mac {\n         fold::noop_fold_mac(macro, self)\n     }\n }\n \n // expand a method\n-fn expand_method(m: &ast::Method, fld: &mut MacroExpander) -> SmallVector<Gc<ast::Method>> {\n-    let id = fld.new_id(m.id);\n-    match m.node {\n+fn expand_method(m: P<ast::Method>, fld: &mut MacroExpander) -> SmallVector<P<ast::Method>> {\n+    m.and_then(|m| match m.node {\n         ast::MethDecl(ident,\n-                      ref generics,\n+                      generics,\n                       abi,\n-                      ref explicit_self,\n+                      explicit_self,\n                       fn_style,\n                       decl,\n                       body,\n                       vis) => {\n+            let id = fld.new_id(m.id);\n             let (rewritten_fn_decl, rewritten_body)\n-                = expand_and_rename_fn_decl_and_block(&*decl,body,fld);\n-            SmallVector::one(box(GC) ast::Method {\n-                    attrs: m.attrs.iter().map(|a| fld.fold_attribute(*a)).collect(),\n+                = expand_and_rename_fn_decl_and_block(decl,body,fld);\n+            SmallVector::one(P(ast::Method {\n+                    attrs: m.attrs.move_map(|a| fld.fold_attribute(a)),\n                     id: id,\n                     span: fld.new_span(m.span),\n                     node: ast::MethDecl(fld.fold_ident(ident),\n@@ -877,15 +882,13 @@ fn expand_method(m: &ast::Method, fld: &mut MacroExpander) -> SmallVector<Gc<ast\n                                         rewritten_fn_decl,\n                                         rewritten_body,\n                                         vis)\n-                })\n+                }))\n         },\n-        ast::MethMac(ref mac) => {\n+        ast::MethMac(mac) => {\n             let maybe_new_methods =\n-                expand_mac_invoc(mac, &m.span,\n-                                 |r|{r.make_methods()},\n-                                 |meths,mark|{\n-                    meths.move_iter().map(|m|{mark_method(m,mark)})\n-                        .collect()},\n+                expand_mac_invoc(mac, m.span,\n+                                 |r| r.make_methods(),\n+                                 |meths, mark| meths.move_map(|m| mark_method(m, mark)),\n                                  fld);\n \n             let new_methods = match maybe_new_methods {\n@@ -896,22 +899,22 @@ fn expand_method(m: &ast::Method, fld: &mut MacroExpander) -> SmallVector<Gc<ast\n             // expand again if necessary\n             new_methods.move_iter().flat_map(|m| fld.fold_method(m).move_iter()).collect()\n         }\n-    }\n+    })\n }\n \n /// Given a fn_decl and a block and a MacroExpander, expand the fn_decl, then use the\n /// PatIdents in its arguments to perform renaming in the FnDecl and\n /// the block, returning both the new FnDecl and the new Block.\n-fn expand_and_rename_fn_decl_and_block(fn_decl: &ast::FnDecl, block: Gc<ast::Block>,\n+fn expand_and_rename_fn_decl_and_block(fn_decl: P<ast::FnDecl>, block: P<ast::Block>,\n                                        fld: &mut MacroExpander)\n-    -> (Gc<ast::FnDecl>, Gc<ast::Block>) {\n+    -> (P<ast::FnDecl>, P<ast::Block>) {\n     let expanded_decl = fld.fold_fn_decl(fn_decl);\n     let idents = fn_decl_arg_bindings(&*expanded_decl);\n     let renames =\n         idents.iter().map(|id : &ast::Ident| (*id,fresh_name(id))).collect();\n     // first, a renamer for the PatIdents, for the fn_decl:\n     let mut rename_pat_fld = PatIdentRenamer{renames: &renames};\n-    let rewritten_fn_decl = rename_pat_fld.fold_fn_decl(&*expanded_decl);\n+    let rewritten_fn_decl = rename_pat_fld.fold_fn_decl(expanded_decl);\n     // now, a renamer for *all* idents, for the body:\n     let mut rename_fld = IdentRenamer{renames: &renames};\n     let rewritten_body = fld.fold_block(rename_fld.fold_block(block));\n@@ -924,36 +927,36 @@ pub struct MacroExpander<'a, 'b:'a> {\n }\n \n impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n-    fn fold_expr(&mut self, expr: Gc<ast::Expr>) -> Gc<ast::Expr> {\n+    fn fold_expr(&mut self, expr: P<ast::Expr>) -> P<ast::Expr> {\n         expand_expr(expr, self)\n     }\n \n-    fn fold_pat(&mut self, pat: Gc<ast::Pat>) -> Gc<ast::Pat> {\n+    fn fold_pat(&mut self, pat: P<ast::Pat>) -> P<ast::Pat> {\n         expand_pat(pat, self)\n     }\n \n-    fn fold_item(&mut self, item: Gc<ast::Item>) -> SmallVector<Gc<ast::Item>> {\n+    fn fold_item(&mut self, item: P<ast::Item>) -> SmallVector<P<ast::Item>> {\n         expand_item(item, self)\n     }\n \n-    fn fold_item_underscore(&mut self, item: &ast::Item_) -> ast::Item_ {\n+    fn fold_item_underscore(&mut self, item: ast::Item_) -> ast::Item_ {\n         expand_item_underscore(item, self)\n     }\n \n-    fn fold_stmt(&mut self, stmt: &ast::Stmt) -> SmallVector<Gc<ast::Stmt>> {\n-        expand_stmt(stmt, self)\n+    fn fold_stmt(&mut self, stmt: P<ast::Stmt>) -> SmallVector<P<ast::Stmt>> {\n+        stmt.and_then(|stmt| expand_stmt(stmt, self))\n     }\n \n     fn fold_block(&mut self, block: P<Block>) -> P<Block> {\n-        expand_block(&*block, self)\n+        expand_block(block, self)\n     }\n \n-    fn fold_arm(&mut self, arm: &ast::Arm) -> ast::Arm {\n+    fn fold_arm(&mut self, arm: ast::Arm) -> ast::Arm {\n         expand_arm(arm, self)\n     }\n \n-    fn fold_method(&mut self, method: Gc<ast::Method>) -> SmallVector<Gc<ast::Method>> {\n-        expand_method(&*method, self)\n+    fn fold_method(&mut self, method: P<ast::Method>) -> SmallVector<P<ast::Method>> {\n+        expand_method(method, self)\n     }\n \n     fn new_span(&mut self, span: Span) -> Span {\n@@ -1033,17 +1036,16 @@ impl Folder for Marker {\n             ctxt: mtwt::apply_mark(self.mark, id.ctxt)\n         }\n     }\n-    fn fold_mac(&mut self, m: &ast::Mac) -> ast::Mac {\n-        let macro = match m.node {\n-            MacInvocTT(ref path, ref tts, ctxt) => {\n-                MacInvocTT(self.fold_path(path),\n-                           self.fold_tts(tts.as_slice()),\n-                           mtwt::apply_mark(self.mark, ctxt))\n-            }\n-        };\n+    fn fold_mac(&mut self, Spanned {node, span}: ast::Mac) -> ast::Mac {\n         Spanned {\n-            node: macro,\n-            span: m.span,\n+            node: match node {\n+                MacInvocTT(path, tts, ctxt) => {\n+                    MacInvocTT(self.fold_path(path),\n+                               self.fold_tts(tts.as_slice()),\n+                               mtwt::apply_mark(self.mark, ctxt))\n+                }\n+            },\n+            span: span,\n         }\n     }\n }\n@@ -1054,29 +1056,29 @@ fn mark_tts(tts: &[TokenTree], m: Mrk) -> Vec<TokenTree> {\n }\n \n // apply a given mark to the given expr. Used following the expansion of a macro.\n-fn mark_expr(expr: Gc<ast::Expr>, m: Mrk) -> Gc<ast::Expr> {\n+fn mark_expr(expr: P<ast::Expr>, m: Mrk) -> P<ast::Expr> {\n     Marker{mark:m}.fold_expr(expr)\n }\n \n // apply a given mark to the given pattern. Used following the expansion of a macro.\n-fn mark_pat(pat: Gc<ast::Pat>, m: Mrk) -> Gc<ast::Pat> {\n+fn mark_pat(pat: P<ast::Pat>, m: Mrk) -> P<ast::Pat> {\n     Marker{mark:m}.fold_pat(pat)\n }\n \n // apply a given mark to the given stmt. Used following the expansion of a macro.\n-fn mark_stmt(expr: &ast::Stmt, m: Mrk) -> Gc<ast::Stmt> {\n+fn mark_stmt(expr: P<ast::Stmt>, m: Mrk) -> P<ast::Stmt> {\n     Marker{mark:m}.fold_stmt(expr)\n         .expect_one(\"marking a stmt didn't return exactly one stmt\")\n }\n \n // apply a given mark to the given item. Used following the expansion of a macro.\n-fn mark_item(expr: Gc<ast::Item>, m: Mrk) -> Gc<ast::Item> {\n+fn mark_item(expr: P<ast::Item>, m: Mrk) -> P<ast::Item> {\n     Marker{mark:m}.fold_item(expr)\n         .expect_one(\"marking an item didn't return exactly one item\")\n }\n \n // apply a given mark to the given item. Used following the expansion of a macro.\n-fn mark_method(expr: Gc<ast::Method>, m: Mrk) -> Gc<ast::Method> {\n+fn mark_method(expr: P<ast::Method>, m: Mrk) -> P<ast::Method> {\n     Marker{mark:m}.fold_method(expr)\n         .expect_one(\"marking an item didn't return exactly one method\")\n }\n@@ -1128,13 +1130,12 @@ mod test {\n     use fold::Folder;\n     use parse;\n     use parse::token;\n+    use ptr::P;\n     use util::parser_testing::{string_to_parser};\n     use util::parser_testing::{string_to_pat, string_to_crate, strs_to_idents};\n     use visit;\n     use visit::Visitor;\n \n-    use std::gc::GC;\n-\n     // a visitor that extracts the paths\n     // from a given thingy and puts them in a mutable\n     // array (passed in to the traversal)\n@@ -1239,7 +1240,7 @@ mod test {\n         let attr1 = make_dummy_attr (\"foo\");\n         let attr2 = make_dummy_attr (\"bar\");\n         let escape_attr = make_dummy_attr (\"macro_escape\");\n-        let attrs1 = vec!(attr1, escape_attr, attr2);\n+        let attrs1 = vec!(attr1.clone(), escape_attr, attr2.clone());\n         assert_eq!(contains_macro_escape(attrs1.as_slice()),true);\n         let attrs2 = vec!(attr1,attr2);\n         assert_eq!(contains_macro_escape(attrs2.as_slice()),false);\n@@ -1252,10 +1253,10 @@ mod test {\n             node: Attribute_ {\n                 id: attr::mk_attr_id(),\n                 style: AttrOuter,\n-                value: box(GC) Spanned {\n+                value: P(Spanned {\n                     node: MetaWord(token::intern_and_get_ident(s)),\n                     span: codemap::DUMMY_SP,\n-                },\n+                }),\n                 is_sugared_doc: false,\n             }\n         }"}, {"sha": "271a5137bbf36e159455e445d62b606082bd0bc6", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 116, "deletions": 116, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -9,17 +9,16 @@\n // except according to those terms.\n \n use ast;\n-use ast::P;\n use codemap::{Span, respan};\n use ext::base::*;\n use ext::base;\n use ext::build::AstBuilder;\n use fmt_macros as parse;\n use parse::token::InternedString;\n use parse::token;\n+use ptr::P;\n \n use std::collections::HashMap;\n-use std::gc::{Gc, GC};\n \n #[deriving(PartialEq)]\n enum ArgumentType {\n@@ -39,37 +38,37 @@ struct Context<'a, 'b:'a> {\n \n     /// Parsed argument expressions and the types that we've found so far for\n     /// them.\n-    args: Vec<Gc<ast::Expr>>,\n+    args: Vec<P<ast::Expr>>,\n     arg_types: Vec<Option<ArgumentType>>,\n     /// Parsed named expressions and the types that we've found for them so far.\n     /// Note that we keep a side-array of the ordering of the named arguments\n     /// found to be sure that we can translate them in the same order that they\n     /// were declared in.\n-    names: HashMap<String, Gc<ast::Expr>>,\n+    names: HashMap<String, P<ast::Expr>>,\n     name_types: HashMap<String, ArgumentType>,\n     name_ordering: Vec<String>,\n \n     /// The latest consecutive literal strings, or empty if there weren't any.\n     literal: String,\n \n     /// Collection of the compiled `rt::Argument` structures\n-    pieces: Vec<Gc<ast::Expr>>,\n+    pieces: Vec<P<ast::Expr>>,\n     /// Collection of string literals\n-    str_pieces: Vec<Gc<ast::Expr>>,\n+    str_pieces: Vec<P<ast::Expr>>,\n     /// Stays `true` if all formatting parameters are default (as in \"{}{}\").\n     all_pieces_simple: bool,\n \n     name_positions: HashMap<String, uint>,\n-    method_statics: Vec<Gc<ast::Item>>,\n+    method_statics: Vec<P<ast::Item>>,\n \n     /// Updated as arguments are consumed or methods are entered\n     nest_level: uint,\n     next_arg: uint,\n }\n \n pub enum Invocation {\n-    Call(Gc<ast::Expr>),\n-    MethodCall(Gc<ast::Expr>, ast::Ident),\n+    Call(P<ast::Expr>),\n+    MethodCall(P<ast::Expr>, ast::Ident),\n }\n \n /// Parses the arguments from the given list of tokens, returning None\n@@ -82,10 +81,10 @@ pub enum Invocation {\n ///           named arguments))\n fn parse_args(ecx: &mut ExtCtxt, sp: Span, allow_method: bool,\n               tts: &[ast::TokenTree])\n-    -> (Invocation, Option<(Gc<ast::Expr>, Vec<Gc<ast::Expr>>, Vec<String>,\n-                            HashMap<String, Gc<ast::Expr>>)>) {\n+    -> (Invocation, Option<(P<ast::Expr>, Vec<P<ast::Expr>>, Vec<String>,\n+                            HashMap<String, P<ast::Expr>>)>) {\n     let mut args = Vec::new();\n-    let mut names = HashMap::<String, Gc<ast::Expr>>::new();\n+    let mut names = HashMap::<String, P<ast::Expr>>::new();\n     let mut order = Vec::new();\n \n     let mut p = ecx.new_parser_from_tts(tts);\n@@ -323,44 +322,44 @@ impl<'a, 'b> Context<'a, 'b> {\n \n     /// These attributes are applied to all statics that this syntax extension\n     /// will generate.\n-    fn static_attrs(&self) -> Vec<ast::Attribute> {\n+    fn static_attrs(ecx: &ExtCtxt, fmtsp: Span) -> Vec<ast::Attribute> {\n         // Flag statics as `inline` so LLVM can merge duplicate globals as much\n         // as possible (which we're generating a whole lot of).\n-        let unnamed = self.ecx.meta_word(self.fmtsp, InternedString::new(\"inline\"));\n-        let unnamed = self.ecx.attribute(self.fmtsp, unnamed);\n+        let unnamed = ecx.meta_word(fmtsp, InternedString::new(\"inline\"));\n+        let unnamed = ecx.attribute(fmtsp, unnamed);\n \n         // Do not warn format string as dead code\n-        let dead_code = self.ecx.meta_word(self.fmtsp,\n-                                           InternedString::new(\"dead_code\"));\n-        let allow_dead_code = self.ecx.meta_list(self.fmtsp,\n-                                                 InternedString::new(\"allow\"),\n-                                                 vec!(dead_code));\n-        let allow_dead_code = self.ecx.attribute(self.fmtsp, allow_dead_code);\n-        return vec!(unnamed, allow_dead_code);\n+        let dead_code = ecx.meta_word(fmtsp, InternedString::new(\"dead_code\"));\n+        let allow_dead_code = ecx.meta_list(fmtsp,\n+                                            InternedString::new(\"allow\"),\n+                                            vec![dead_code]);\n+        let allow_dead_code = ecx.attribute(fmtsp, allow_dead_code);\n+        vec![unnamed, allow_dead_code]\n     }\n \n-    fn rtpath(&self, s: &str) -> Vec<ast::Ident> {\n-        vec!(self.ecx.ident_of(\"std\"), self.ecx.ident_of(\"fmt\"),\n-          self.ecx.ident_of(\"rt\"), self.ecx.ident_of(s))\n+    fn rtpath(ecx: &ExtCtxt, s: &str) -> Vec<ast::Ident> {\n+        vec![ecx.ident_of(\"std\"), ecx.ident_of(\"fmt\"), ecx.ident_of(\"rt\"), ecx.ident_of(s)]\n     }\n \n-    fn trans_count(&self, c: parse::Count) -> Gc<ast::Expr> {\n+    fn trans_count(&self, c: parse::Count) -> P<ast::Expr> {\n         let sp = self.fmtsp;\n         match c {\n             parse::CountIs(i) => {\n-                self.ecx.expr_call_global(sp, self.rtpath(\"CountIs\"),\n+                self.ecx.expr_call_global(sp, Context::rtpath(self.ecx, \"CountIs\"),\n                                           vec!(self.ecx.expr_uint(sp, i)))\n             }\n             parse::CountIsParam(i) => {\n-                self.ecx.expr_call_global(sp, self.rtpath(\"CountIsParam\"),\n+                self.ecx.expr_call_global(sp, Context::rtpath(self.ecx, \"CountIsParam\"),\n                                           vec!(self.ecx.expr_uint(sp, i)))\n             }\n             parse::CountImplied => {\n-                let path = self.ecx.path_global(sp, self.rtpath(\"CountImplied\"));\n+                let path = self.ecx.path_global(sp, Context::rtpath(self.ecx,\n+                                                                    \"CountImplied\"));\n                 self.ecx.expr_path(path)\n             }\n             parse::CountIsNextParam => {\n-                let path = self.ecx.path_global(sp, self.rtpath(\"CountIsNextParam\"));\n+                let path = self.ecx.path_global(sp, Context::rtpath(self.ecx,\n+                                                                    \"CountIsNextParam\"));\n                 self.ecx.expr_path(path)\n             }\n             parse::CountIsName(n) => {\n@@ -369,14 +368,14 @@ impl<'a, 'b> Context<'a, 'b> {\n                     None => 0, // error already emitted elsewhere\n                 };\n                 let i = i + self.args.len();\n-                self.ecx.expr_call_global(sp, self.rtpath(\"CountIsParam\"),\n+                self.ecx.expr_call_global(sp, Context::rtpath(self.ecx, \"CountIsParam\"),\n                                           vec!(self.ecx.expr_uint(sp, i)))\n             }\n         }\n     }\n \n     /// Translate the accumulated string literals to a literal expression\n-    fn trans_literal_string(&mut self) -> Gc<ast::Expr> {\n+    fn trans_literal_string(&mut self) -> P<ast::Expr> {\n         let sp = self.fmtsp;\n         let s = token::intern_and_get_ident(self.literal.as_slice());\n         self.literal.clear();\n@@ -385,7 +384,7 @@ impl<'a, 'b> Context<'a, 'b> {\n \n     /// Translate a `parse::Piece` to a static `rt::Argument` or append\n     /// to the `literal` string.\n-    fn trans_piece(&mut self, piece: &parse::Piece) -> Option<Gc<ast::Expr>> {\n+    fn trans_piece(&mut self, piece: &parse::Piece) -> Option<P<ast::Expr>> {\n         let sp = self.fmtsp;\n         match *piece {\n             parse::String(s) => {\n@@ -397,12 +396,12 @@ impl<'a, 'b> Context<'a, 'b> {\n                 let pos = match arg.position {\n                     // These two have a direct mapping\n                     parse::ArgumentNext => {\n-                        let path = self.ecx.path_global(sp,\n-                                                        self.rtpath(\"ArgumentNext\"));\n+                        let path = self.ecx.path_global(sp, Context::rtpath(self.ecx,\n+                                                                            \"ArgumentNext\"));\n                         self.ecx.expr_path(path)\n                     }\n                     parse::ArgumentIs(i) => {\n-                        self.ecx.expr_call_global(sp, self.rtpath(\"ArgumentIs\"),\n+                        self.ecx.expr_call_global(sp, Context::rtpath(self.ecx, \"ArgumentIs\"),\n                                                   vec!(self.ecx.expr_uint(sp, i)))\n                     }\n                     // Named arguments are converted to positional arguments at\n@@ -413,7 +412,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                             None => 0, // error already emitted elsewhere\n                         };\n                         let i = i + self.args.len();\n-                        self.ecx.expr_call_global(sp, self.rtpath(\"ArgumentIs\"),\n+                        self.ecx.expr_call_global(sp, Context::rtpath(self.ecx, \"ArgumentIs\"),\n                                                   vec!(self.ecx.expr_uint(sp, i)))\n                     }\n                 };\n@@ -440,72 +439,71 @@ impl<'a, 'b> Context<'a, 'b> {\n                 let fill = self.ecx.expr_lit(sp, ast::LitChar(fill));\n                 let align = match arg.format.align {\n                     parse::AlignLeft => {\n-                        self.ecx.path_global(sp, self.rtpath(\"AlignLeft\"))\n+                        self.ecx.path_global(sp, Context::rtpath(self.ecx, \"AlignLeft\"))\n                     }\n                     parse::AlignRight => {\n-                        self.ecx.path_global(sp, self.rtpath(\"AlignRight\"))\n+                        self.ecx.path_global(sp, Context::rtpath(self.ecx, \"AlignRight\"))\n                     }\n                     parse::AlignCenter => {\n-                        self.ecx.path_global(sp, self.rtpath(\"AlignCenter\"))\n+                        self.ecx.path_global(sp, Context::rtpath(self.ecx, \"AlignCenter\"))\n                     }\n                     parse::AlignUnknown => {\n-                        self.ecx.path_global(sp, self.rtpath(\"AlignUnknown\"))\n+                        self.ecx.path_global(sp, Context::rtpath(self.ecx, \"AlignUnknown\"))\n                     }\n                 };\n                 let align = self.ecx.expr_path(align);\n                 let flags = self.ecx.expr_uint(sp, arg.format.flags);\n                 let prec = self.trans_count(arg.format.precision);\n                 let width = self.trans_count(arg.format.width);\n-                let path = self.ecx.path_global(sp, self.rtpath(\"FormatSpec\"));\n+                let path = self.ecx.path_global(sp, Context::rtpath(self.ecx, \"FormatSpec\"));\n                 let fmt = self.ecx.expr_struct(sp, path, vec!(\n                     self.ecx.field_imm(sp, self.ecx.ident_of(\"fill\"), fill),\n                     self.ecx.field_imm(sp, self.ecx.ident_of(\"align\"), align),\n                     self.ecx.field_imm(sp, self.ecx.ident_of(\"flags\"), flags),\n                     self.ecx.field_imm(sp, self.ecx.ident_of(\"precision\"), prec),\n                     self.ecx.field_imm(sp, self.ecx.ident_of(\"width\"), width)));\n \n-                let path = self.ecx.path_global(sp, self.rtpath(\"Argument\"));\n+                let path = self.ecx.path_global(sp, Context::rtpath(self.ecx, \"Argument\"));\n                 Some(self.ecx.expr_struct(sp, path, vec!(\n                     self.ecx.field_imm(sp, self.ecx.ident_of(\"position\"), pos),\n                     self.ecx.field_imm(sp, self.ecx.ident_of(\"format\"), fmt))))\n             }\n         }\n     }\n \n-    fn item_static_array(&self,\n+    fn item_static_array(ecx: &mut ExtCtxt,\n                          name: ast::Ident,\n-                         piece_ty: Gc<ast::Ty>,\n-                         pieces: Vec<Gc<ast::Expr>>)\n-        -> ast::Stmt\n-    {\n-        let pieces_len = self.ecx.expr_uint(self.fmtsp, pieces.len());\n-        let fmt = self.ecx.expr_vec(self.fmtsp, pieces);\n+                         piece_ty: P<ast::Ty>,\n+                         pieces: Vec<P<ast::Expr>>)\n+                         -> P<ast::Stmt> {\n+        let fmtsp = piece_ty.span;\n+        let pieces_len = ecx.expr_uint(fmtsp, pieces.len());\n+        let fmt = ecx.expr_vec(fmtsp, pieces);\n         let ty = ast::TyFixedLengthVec(\n             piece_ty,\n             pieces_len\n         );\n-        let ty = self.ecx.ty(self.fmtsp, ty);\n+        let ty = ecx.ty(fmtsp, ty);\n         let st = ast::ItemStatic(ty, ast::MutImmutable, fmt);\n-        let item = self.ecx.item(self.fmtsp, name,\n-                                 self.static_attrs(), st);\n-        let decl = respan(self.fmtsp, ast::DeclItem(item));\n-        respan(self.fmtsp, ast::StmtDecl(box(GC) decl, ast::DUMMY_NODE_ID))\n+        let item = ecx.item(fmtsp, name, Context::static_attrs(ecx, fmtsp), st);\n+        let decl = respan(fmtsp, ast::DeclItem(item));\n+        P(respan(fmtsp, ast::StmtDecl(P(decl), ast::DUMMY_NODE_ID)))\n     }\n \n     /// Actually builds the expression which the iformat! block will be expanded\n     /// to\n-    fn to_expr(&self, invocation: Invocation) -> Gc<ast::Expr> {\n+    fn to_expr(mut self, invocation: Invocation) -> P<ast::Expr> {\n         let mut lets = Vec::new();\n         let mut locals = Vec::new();\n         let mut names = Vec::from_fn(self.name_positions.len(), |_| None);\n         let mut pats = Vec::new();\n         let mut heads = Vec::new();\n \n         // First, declare all of our methods that are statics\n-        for &method in self.method_statics.iter() {\n+        for method in self.method_statics.move_iter() {\n             let decl = respan(self.fmtsp, ast::DeclItem(method));\n-            lets.push(box(GC) respan(self.fmtsp,\n-                              ast::StmtDecl(box(GC) decl, ast::DUMMY_NODE_ID)));\n+            lets.push(P(respan(self.fmtsp,\n+                               ast::StmtDecl(P(decl), ast::DUMMY_NODE_ID))));\n         }\n \n         // Next, build up the static array which will become our precompiled\n@@ -517,23 +515,25 @@ impl<'a, 'b> Context<'a, 'b> {\n                 self.ecx.ty_ident(self.fmtsp, self.ecx.ident_of(\"str\")),\n                 Some(static_lifetime),\n                 ast::MutImmutable);\n-        lets.push(box(GC) self.item_static_array(static_str_name,\n-                                                 piece_ty,\n-                                                 self.str_pieces.clone()));\n+        lets.push(Context::item_static_array(self.ecx,\n+                                             static_str_name,\n+                                             piece_ty,\n+                                             self.str_pieces));\n \n         // Then, build up the static array which will store our precompiled\n         // nonstandard placeholders, if there are any.\n         let static_args_name = self.ecx.ident_of(\"__STATIC_FMTARGS\");\n         if !self.all_pieces_simple {\n             let piece_ty = self.ecx.ty_path(self.ecx.path_all(\n                     self.fmtsp,\n-                    true, self.rtpath(\"Argument\"),\n+                    true, Context::rtpath(self.ecx, \"Argument\"),\n                     vec![static_lifetime],\n                     vec![]\n                 ), None);\n-            lets.push(box(GC) self.item_static_array(static_args_name,\n-                                                     piece_ty,\n-                                                     self.pieces.clone()));\n+            lets.push(Context::item_static_array(self.ecx,\n+                                                 static_args_name,\n+                                                 piece_ty,\n+                                                 self.pieces));\n         }\n \n         // Right now there is a bug such that for the expression:\n@@ -543,31 +543,35 @@ impl<'a, 'b> Context<'a, 'b> {\n         // format! string are shoved into locals. Furthermore, we shove the address\n         // of each variable because we don't want to move out of the arguments\n         // passed to this function.\n-        for (i, &e) in self.args.iter().enumerate() {\n-            if self.arg_types.get(i).is_none() {\n-                continue // error already generated\n-            }\n+        for (i, e) in self.args.move_iter().enumerate() {\n+            let arg_ty = match self.arg_types.get(i).as_ref() {\n+                Some(ty) => ty,\n+                None => continue // error already generated\n+            };\n \n             let name = self.ecx.ident_of(format!(\"__arg{}\", i).as_slice());\n             pats.push(self.ecx.pat_ident(e.span, name));\n+            locals.push(Context::format_arg(self.ecx, e.span, arg_ty,\n+                                            self.ecx.expr_ident(e.span, name)));\n             heads.push(self.ecx.expr_addr_of(e.span, e));\n-            locals.push(self.format_arg(e.span, Exact(i),\n-                                        self.ecx.expr_ident(e.span, name)));\n         }\n         for name in self.name_ordering.iter() {\n-            let e = match self.names.find(name) {\n-                Some(&e) if self.name_types.contains_key(name) => e,\n-                Some(..) | None => continue\n+            let e = match self.names.pop(name) {\n+                Some(e) => e,\n+                None => continue\n+            };\n+            let arg_ty = match self.name_types.find(name) {\n+                Some(ty) => ty,\n+                None => continue\n             };\n \n             let lname = self.ecx.ident_of(format!(\"__arg{}\",\n                                                   *name).as_slice());\n             pats.push(self.ecx.pat_ident(e.span, lname));\n-            heads.push(self.ecx.expr_addr_of(e.span, e));\n             *names.get_mut(*self.name_positions.get(name)) =\n-                Some(self.format_arg(e.span,\n-                                     Named((*name).clone()),\n-                                     self.ecx.expr_ident(e.span, lname)));\n+                Some(Context::format_arg(self.ecx, e.span, arg_ty,\n+                                         self.ecx.expr_ident(e.span, lname)));\n+            heads.push(self.ecx.expr_addr_of(e.span, e));\n         }\n \n         // Now create a vector containing all the arguments\n@@ -611,12 +615,14 @@ impl<'a, 'b> Context<'a, 'b> {\n         let res = self.ecx.expr_ident(self.fmtsp, resname);\n         let result = match invocation {\n             Call(e) => {\n-                self.ecx.expr_call(e.span, e,\n-                                   vec!(self.ecx.expr_addr_of(e.span, res)))\n+                let span = e.span;\n+                self.ecx.expr_call(span, e,\n+                                   vec!(self.ecx.expr_addr_of(span, res)))\n             }\n             MethodCall(e, m) => {\n-                self.ecx.expr_method_call(e.span, e, m,\n-                                          vec!(self.ecx.expr_addr_of(e.span, res)))\n+                let span = e.span;\n+                self.ecx.expr_method_call(span, e, m,\n+                                          vec!(self.ecx.expr_addr_of(span, res)))\n             }\n         };\n         let body = self.ecx.expr_block(self.ecx.block(self.fmtsp, lets,\n@@ -655,13 +661,9 @@ impl<'a, 'b> Context<'a, 'b> {\n         self.ecx.expr_match(self.fmtsp, head, vec!(arm))\n     }\n \n-    fn format_arg(&self, sp: Span, argno: Position, arg: Gc<ast::Expr>)\n-                  -> Gc<ast::Expr> {\n-        let ty = match argno {\n-            Exact(ref i) => self.arg_types.get(*i).get_ref(),\n-            Named(ref s) => self.name_types.get(s)\n-        };\n-\n+    fn format_arg(ecx: &ExtCtxt, sp: Span,\n+                  ty: &ArgumentType, arg: P<ast::Expr>)\n+                  -> P<ast::Expr> {\n         let (krate, fmt_fn) = match *ty {\n             Known(ref tyname) => {\n                 match tyname.as_slice() {\n@@ -681,36 +683,35 @@ impl<'a, 'b> Context<'a, 'b> {\n                     \"x\" => (\"std\", \"secret_lower_hex\"),\n                     \"X\" => (\"std\", \"secret_upper_hex\"),\n                     _ => {\n-                        self.ecx\n-                            .span_err(sp,\n-                                      format!(\"unknown format trait `{}`\",\n-                                              *tyname).as_slice());\n+                        ecx.span_err(sp,\n+                                     format!(\"unknown format trait `{}`\",\n+                                             *tyname).as_slice());\n                         (\"std\", \"dummy\")\n                     }\n                 }\n             }\n             String => {\n-                return self.ecx.expr_call_global(sp, vec!(\n-                        self.ecx.ident_of(\"std\"),\n-                        self.ecx.ident_of(\"fmt\"),\n-                        self.ecx.ident_of(\"argumentstr\")), vec!(arg))\n+                return ecx.expr_call_global(sp, vec![\n+                        ecx.ident_of(\"std\"),\n+                        ecx.ident_of(\"fmt\"),\n+                        ecx.ident_of(\"argumentstr\")], vec![arg])\n             }\n             Unsigned => {\n-                return self.ecx.expr_call_global(sp, vec!(\n-                        self.ecx.ident_of(\"std\"),\n-                        self.ecx.ident_of(\"fmt\"),\n-                        self.ecx.ident_of(\"argumentuint\")), vec!(arg))\n+                return ecx.expr_call_global(sp, vec![\n+                        ecx.ident_of(\"std\"),\n+                        ecx.ident_of(\"fmt\"),\n+                        ecx.ident_of(\"argumentuint\")], vec![arg])\n             }\n         };\n \n-        let format_fn = self.ecx.path_global(sp, vec!(\n-                self.ecx.ident_of(krate),\n-                self.ecx.ident_of(\"fmt\"),\n-                self.ecx.ident_of(fmt_fn)));\n-        self.ecx.expr_call_global(sp, vec!(\n-                self.ecx.ident_of(\"std\"),\n-                self.ecx.ident_of(\"fmt\"),\n-                self.ecx.ident_of(\"argument\")), vec!(self.ecx.expr_path(format_fn), arg))\n+        let format_fn = ecx.path_global(sp, vec![\n+                ecx.ident_of(krate),\n+                ecx.ident_of(\"fmt\"),\n+                ecx.ident_of(fmt_fn)]);\n+        ecx.expr_call_global(sp, vec![\n+                ecx.ident_of(\"std\"),\n+                ecx.ident_of(\"fmt\"),\n+                ecx.ident_of(\"argument\")], vec![ecx.expr_path(format_fn), arg])\n     }\n }\n \n@@ -744,12 +745,11 @@ pub fn expand_format_args_method<'cx>(ecx: &'cx mut ExtCtxt, sp: Span,\n /// expression.\n pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n                                     invocation: Invocation,\n-                                    efmt: Gc<ast::Expr>,\n-                                    args: Vec<Gc<ast::Expr>>,\n+                                    efmt: P<ast::Expr>,\n+                                    args: Vec<P<ast::Expr>>,\n                                     name_ordering: Vec<String>,\n-                                    names: HashMap<String, Gc<ast::Expr>>)\n-    -> Gc<ast::Expr>\n-{\n+                                    names: HashMap<String, P<ast::Expr>>)\n+                                    -> P<ast::Expr> {\n     let arg_types = Vec::from_fn(args.len(), |_| None);\n     let mut cx = Context {\n         ecx: ecx,\n@@ -796,7 +796,7 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n     }\n     match parser.errors.shift() {\n         Some(error) => {\n-            cx.ecx.span_err(efmt.span,\n+            cx.ecx.span_err(cx.fmtsp,\n                             format!(\"invalid format string: {}\",\n                                     error).as_slice());\n             return DummyResult::raw_expr(sp);"}, {"sha": "6f13a2e6a51fc8a57c9fd70b6732bd2facbbb59a", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 37, "deletions": 39, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -15,8 +15,7 @@ use ext::base;\n use ext::build::AstBuilder;\n use parse::token::*;\n use parse::token;\n-\n-use std::gc::Gc;\n+use ptr::P;\n \n /**\n *\n@@ -36,14 +35,13 @@ pub mod rt {\n     use parse::token;\n     use parse;\n     use print::pprust;\n+    use ptr::P;\n \n     use ast::{TokenTree, Generics, Expr};\n \n     pub use parse::new_parser_from_tts;\n     pub use codemap::{BytePos, Span, dummy_spanned};\n \n-    use std::gc::Gc;\n-\n     pub trait ToTokens {\n         fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree> ;\n     }\n@@ -107,13 +105,13 @@ pub mod rt {\n     }\n \n     macro_rules! impl_to_source(\n-        (Gc<$t:ty>, $pp:ident) => (\n-            impl ToSource for Gc<$t> {\n+        (P<$t:ty>, $pp:ident) => (\n+            impl ToSource for P<$t> {\n                 fn to_source(&self) -> String {\n                     pprust::$pp(&**self)\n                 }\n             }\n-            impl ToSourceWithHygiene for Gc<$t> {\n+            impl ToSourceWithHygiene for P<$t> {\n                 fn to_source_with_hygiene(&self) -> String {\n                     pprust::with_hygiene::$pp(&**self)\n                 }\n@@ -182,18 +180,18 @@ pub mod rt {\n     impl_to_source!(ast::Block, block_to_string)\n     impl_to_source!(ast::Arg, arg_to_string)\n     impl_to_source!(Generics, generics_to_string)\n-    impl_to_source!(Gc<ast::Item>, item_to_string)\n-    impl_to_source!(Gc<ast::Method>, method_to_string)\n-    impl_to_source!(Gc<ast::Stmt>, stmt_to_string)\n-    impl_to_source!(Gc<ast::Expr>, expr_to_string)\n-    impl_to_source!(Gc<ast::Pat>, pat_to_string)\n+    impl_to_source!(P<ast::Item>, item_to_string)\n+    impl_to_source!(P<ast::Method>, method_to_string)\n+    impl_to_source!(P<ast::Stmt>, stmt_to_string)\n+    impl_to_source!(P<ast::Expr>, expr_to_string)\n+    impl_to_source!(P<ast::Pat>, pat_to_string)\n     impl_to_source!(ast::Arm, arm_to_string)\n     impl_to_source_slice!(ast::Ty, \", \")\n-    impl_to_source_slice!(Gc<ast::Item>, \"\\n\\n\")\n+    impl_to_source_slice!(P<ast::Item>, \"\\n\\n\")\n \n     impl ToSource for ast::Attribute_ {\n         fn to_source(&self) -> String {\n-            pprust::attribute_to_string(&dummy_spanned(*self))\n+            pprust::attribute_to_string(&dummy_spanned(self.clone()))\n         }\n     }\n     impl ToSourceWithHygiene for ast::Attribute_ {\n@@ -315,16 +313,16 @@ pub mod rt {\n     )\n \n     impl_to_tokens!(ast::Ident)\n-    impl_to_tokens!(Gc<ast::Item>)\n-    impl_to_tokens!(Gc<ast::Pat>)\n+    impl_to_tokens!(P<ast::Item>)\n+    impl_to_tokens!(P<ast::Pat>)\n     impl_to_tokens!(ast::Arm)\n-    impl_to_tokens!(Gc<ast::Method>)\n-    impl_to_tokens_lifetime!(&'a [Gc<ast::Item>])\n+    impl_to_tokens!(P<ast::Method>)\n+    impl_to_tokens_lifetime!(&'a [P<ast::Item>])\n     impl_to_tokens!(ast::Ty)\n     impl_to_tokens_lifetime!(&'a [ast::Ty])\n     impl_to_tokens!(Generics)\n-    impl_to_tokens!(Gc<ast::Stmt>)\n-    impl_to_tokens!(Gc<ast::Expr>)\n+    impl_to_tokens!(P<ast::Stmt>)\n+    impl_to_tokens!(P<ast::Expr>)\n     impl_to_tokens!(ast::Block)\n     impl_to_tokens!(ast::Arg)\n     impl_to_tokens!(ast::Attribute_)\n@@ -344,9 +342,9 @@ pub mod rt {\n     impl_to_tokens!(u64)\n \n     pub trait ExtParseUtils {\n-        fn parse_item(&self, s: String) -> Gc<ast::Item>;\n-        fn parse_expr(&self, s: String) -> Gc<ast::Expr>;\n-        fn parse_stmt(&self, s: String) -> Gc<ast::Stmt>;\n+        fn parse_item(&self, s: String) -> P<ast::Item>;\n+        fn parse_expr(&self, s: String) -> P<ast::Expr>;\n+        fn parse_stmt(&self, s: String) -> P<ast::Stmt>;\n         fn parse_tts(&self, s: String) -> Vec<ast::TokenTree>;\n     }\n \n@@ -358,7 +356,7 @@ pub mod rt {\n \n     impl<'a> ExtParseUtils for ExtCtxt<'a> {\n \n-        fn parse_item(&self, s: String) -> Gc<ast::Item> {\n+        fn parse_item(&self, s: String) -> P<ast::Item> {\n             let res = parse::parse_item_from_source_str(\n                 \"<quote expansion>\".to_string(),\n                 s,\n@@ -373,15 +371,15 @@ pub mod rt {\n             }\n         }\n \n-        fn parse_stmt(&self, s: String) -> Gc<ast::Stmt> {\n+        fn parse_stmt(&self, s: String) -> P<ast::Stmt> {\n             parse::parse_stmt_from_source_str(\"<quote expansion>\".to_string(),\n                                               s,\n                                               self.cfg(),\n                                               Vec::new(),\n                                               self.parse_sess())\n         }\n \n-        fn parse_expr(&self, s: String) -> Gc<ast::Expr> {\n+        fn parse_expr(&self, s: String) -> P<ast::Expr> {\n             parse::parse_expr_from_source_str(\"<quote expansion>\".to_string(),\n                                               s,\n                                               self.cfg(),\n@@ -491,7 +489,7 @@ fn id_ext(str: &str) -> ast::Ident {\n }\n \n // Lift an ident to the expr that evaluates to that ident.\n-fn mk_ident(cx: &ExtCtxt, sp: Span, ident: ast::Ident) -> Gc<ast::Expr> {\n+fn mk_ident(cx: &ExtCtxt, sp: Span, ident: ast::Ident) -> P<ast::Expr> {\n     let e_str = cx.expr_str(sp, token::get_ident(ident));\n     cx.expr_method_call(sp,\n                         cx.expr_ident(sp, id_ext(\"ext_cx\")),\n@@ -500,25 +498,25 @@ fn mk_ident(cx: &ExtCtxt, sp: Span, ident: ast::Ident) -> Gc<ast::Expr> {\n }\n \n // Lift a name to the expr that evaluates to that name\n-fn mk_name(cx: &ExtCtxt, sp: Span, ident: ast::Ident) -> Gc<ast::Expr> {\n+fn mk_name(cx: &ExtCtxt, sp: Span, ident: ast::Ident) -> P<ast::Expr> {\n     let e_str = cx.expr_str(sp, token::get_ident(ident));\n     cx.expr_method_call(sp,\n                         cx.expr_ident(sp, id_ext(\"ext_cx\")),\n                         id_ext(\"name_of\"),\n                         vec!(e_str))\n }\n \n-fn mk_ast_path(cx: &ExtCtxt, sp: Span, name: &str) -> Gc<ast::Expr> {\n+fn mk_ast_path(cx: &ExtCtxt, sp: Span, name: &str) -> P<ast::Expr> {\n     let idents = vec!(id_ext(\"syntax\"), id_ext(\"ast\"), id_ext(name));\n     cx.expr_path(cx.path_global(sp, idents))\n }\n \n-fn mk_token_path(cx: &ExtCtxt, sp: Span, name: &str) -> Gc<ast::Expr> {\n+fn mk_token_path(cx: &ExtCtxt, sp: Span, name: &str) -> P<ast::Expr> {\n     let idents = vec!(id_ext(\"syntax\"), id_ext(\"parse\"), id_ext(\"token\"), id_ext(name));\n     cx.expr_path(cx.path_global(sp, idents))\n }\n \n-fn mk_binop(cx: &ExtCtxt, sp: Span, bop: token::BinOp) -> Gc<ast::Expr> {\n+fn mk_binop(cx: &ExtCtxt, sp: Span, bop: token::BinOp) -> P<ast::Expr> {\n     let name = match bop {\n         PLUS => \"PLUS\",\n         MINUS => \"MINUS\",\n@@ -534,7 +532,7 @@ fn mk_binop(cx: &ExtCtxt, sp: Span, bop: token::BinOp) -> Gc<ast::Expr> {\n     mk_token_path(cx, sp, name)\n }\n \n-fn mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> Gc<ast::Expr> {\n+fn mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> P<ast::Expr> {\n \n     match *tok {\n         BINOP(binop) => {\n@@ -640,7 +638,7 @@ fn mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> Gc<ast::Expr> {\n }\n \n \n-fn mk_tt(cx: &ExtCtxt, sp: Span, tt: &ast::TokenTree) -> Vec<Gc<ast::Stmt>> {\n+fn mk_tt(cx: &ExtCtxt, sp: Span, tt: &ast::TokenTree) -> Vec<P<ast::Stmt>> {\n     match *tt {\n         ast::TTTok(sp, ref tok) => {\n             let e_sp = cx.expr_ident(sp, id_ext(\"_sp\"));\n@@ -680,7 +678,7 @@ fn mk_tt(cx: &ExtCtxt, sp: Span, tt: &ast::TokenTree) -> Vec<Gc<ast::Stmt>> {\n }\n \n fn mk_tts(cx: &ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n-    -> Vec<Gc<ast::Stmt>> {\n+    -> Vec<P<ast::Stmt>> {\n     let mut ss = Vec::new();\n     for tt in tts.iter() {\n         ss.push_all_move(mk_tt(cx, sp, tt));\n@@ -689,7 +687,7 @@ fn mk_tts(cx: &ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n }\n \n fn expand_tts(cx: &ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n-              -> (Gc<ast::Expr>, Gc<ast::Expr>) {\n+              -> (P<ast::Expr>, P<ast::Expr>) {\n     // NB: It appears that the main parser loses its mind if we consider\n     // $foo as a TTNonterminal during the main parse, so we have to re-parse\n     // under quote_depth > 0. This is silly and should go away; the _guess_ is\n@@ -757,8 +755,8 @@ fn expand_tts(cx: &ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n \n fn expand_wrapper(cx: &ExtCtxt,\n                   sp: Span,\n-                  cx_expr: Gc<ast::Expr>,\n-                  expr: Gc<ast::Expr>) -> Gc<ast::Expr> {\n+                  cx_expr: P<ast::Expr>,\n+                  expr: P<ast::Expr>) -> P<ast::Expr> {\n     let uses = [\n         &[\"syntax\", \"ext\", \"quote\", \"rt\"],\n     ].iter().map(|path| {\n@@ -776,8 +774,8 @@ fn expand_wrapper(cx: &ExtCtxt,\n fn expand_parse_call(cx: &ExtCtxt,\n                      sp: Span,\n                      parse_method: &str,\n-                     arg_exprs: Vec<Gc<ast::Expr>>,\n-                     tts: &[ast::TokenTree]) -> Gc<ast::Expr> {\n+                     arg_exprs: Vec<P<ast::Expr>> ,\n+                     tts: &[ast::TokenTree]) -> P<ast::Expr> {\n     let (cx_expr, tts_expr) = expand_tts(cx, sp, tts);\n \n     let cfg_call = || cx.expr_method_call("}, {"sha": "3006bcaf6f8764d9b50bfce703b35423b59c2383", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -87,9 +87,9 @@ use parse::attr::ParserAttr;\n use parse::parser::{LifetimeAndTypesWithoutColons, Parser};\n use parse::token::{Token, EOF, Nonterminal};\n use parse::token;\n+use ptr::P;\n \n use std::rc::Rc;\n-use std::gc::GC;\n use std::collections::HashMap;\n \n /* to avoid costly uniqueness checks, we require that `MatchSeq` always has a\n@@ -451,7 +451,7 @@ pub fn parse_nt(p: &mut Parser, name: &str) -> Nonterminal {\n       \"meta\" => token::NtMeta(p.parse_meta_item()),\n       \"tt\" => {\n         p.quote_depth += 1u; //but in theory, non-quoted tts might be useful\n-        let res = token::NtTT(box(GC) p.parse_token_tree());\n+        let res = token::NtTT(P(p.parse_token_tree()));\n         p.quote_depth -= 1u;\n         res\n       }"}, {"sha": "6c7bbb2384c12630f87ee5f5d892e017ec71a6dc", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -8,8 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{Ident, Matcher_, Matcher, MatchTok, MatchNonterminal, MatchSeq};\n-use ast::{TTDelim};\n+use ast::{Ident, Matcher_, Matcher, MatchTok, MatchNonterminal, MatchSeq, TTDelim};\n use ast;\n use codemap::{Span, Spanned, DUMMY_SP};\n use ext::base::{ExtCtxt, MacResult, MacroDef};\n@@ -24,11 +23,12 @@ use parse::token::{special_idents, gensym_ident};\n use parse::token::{FAT_ARROW, SEMI, NtMatchers, NtTT, EOF};\n use parse::token;\n use print;\n+use ptr::P;\n+\n use util::small_vector::SmallVector;\n \n use std::cell::RefCell;\n use std::rc::Rc;\n-use std::gc::Gc;\n \n struct ParserAnyMacro<'a> {\n     parser: RefCell<Parser<'a>>,\n@@ -58,17 +58,17 @@ impl<'a> ParserAnyMacro<'a> {\n }\n \n impl<'a> MacResult for ParserAnyMacro<'a> {\n-    fn make_expr(&self) -> Option<Gc<ast::Expr>> {\n+    fn make_expr(self: Box<ParserAnyMacro<'a>>) -> Option<P<ast::Expr>> {\n         let ret = self.parser.borrow_mut().parse_expr();\n         self.ensure_complete_parse(true);\n         Some(ret)\n     }\n-    fn make_pat(&self) -> Option<Gc<ast::Pat>> {\n+    fn make_pat(self: Box<ParserAnyMacro<'a>>) -> Option<P<ast::Pat>> {\n         let ret = self.parser.borrow_mut().parse_pat();\n         self.ensure_complete_parse(false);\n         Some(ret)\n     }\n-    fn make_items(&self) -> Option<SmallVector<Gc<ast::Item>>> {\n+    fn make_items(self: Box<ParserAnyMacro<'a>>) -> Option<SmallVector<P<ast::Item>>> {\n         let mut ret = SmallVector::zero();\n         loop {\n             let mut parser = self.parser.borrow_mut();\n@@ -84,7 +84,7 @@ impl<'a> MacResult for ParserAnyMacro<'a> {\n         Some(ret)\n     }\n \n-    fn make_methods(&self) -> Option<SmallVector<Gc<ast::Method>>> {\n+    fn make_methods(self: Box<ParserAnyMacro<'a>>) -> Option<SmallVector<P<ast::Method>>> {\n         let mut ret = SmallVector::zero();\n         loop {\n             let mut parser = self.parser.borrow_mut();\n@@ -97,7 +97,7 @@ impl<'a> MacResult for ParserAnyMacro<'a> {\n         Some(ret)\n     }\n \n-    fn make_stmt(&self) -> Option<Gc<ast::Stmt>> {\n+    fn make_stmt(self: Box<ParserAnyMacro<'a>>) -> Option<P<ast::Stmt>> {\n         let attrs = self.parser.borrow_mut().parse_outer_attributes();\n         let ret = self.parser.borrow_mut().parse_stmt(attrs);\n         self.ensure_complete_parse(true);\n@@ -127,11 +127,11 @@ impl TTMacroExpander for MacroRulesMacroExpander {\n }\n \n struct MacroRulesDefiner {\n-    def: RefCell<Option<MacroDef>>\n+    def: Option<MacroDef>\n }\n impl MacResult for MacroRulesDefiner {\n-    fn make_def(&self) -> Option<MacroDef> {\n-        Some(self.def.borrow_mut().take().expect(\"MacroRulesDefiner expanded twice\"))\n+    fn make_def(&mut self) -> Option<MacroDef> {\n+        Some(self.def.take().expect(\"empty MacroRulesDefiner\"))\n     }\n }\n \n@@ -170,8 +170,8 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n               Success(named_matches) => {\n                 let rhs = match *rhses[i] {\n                     // okay, what's your transcriber?\n-                    MatchedNonterminal(NtTT(tt)) => {\n-                        match *tt {\n+                    MatchedNonterminal(NtTT(ref tt)) => {\n+                        match **tt {\n                             // cut off delimiters; don't parse 'em\n                             TTDelim(ref tts) => {\n                                 (*tts).slice(1u,(*tts).len()-1u)\n@@ -269,9 +269,9 @@ pub fn add_new_extension<'cx>(cx: &'cx mut ExtCtxt,\n     };\n \n     box MacroRulesDefiner {\n-        def: RefCell::new(Some(MacroDef {\n+        def: Some(MacroDef {\n             name: token::get_ident(name).to_string(),\n             ext: NormalTT(exp, Some(sp))\n-        }))\n+        })\n     } as Box<MacResult+'cx>\n }"}, {"sha": "e63954c36806e502c4f8424222c8741af48ab7dc", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 688, "deletions": 723, "changes": 1411, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -23,11 +23,35 @@ use ast;\n use ast_util;\n use codemap::{respan, Span, Spanned};\n use parse::token;\n+use ptr::P;\n use owned_slice::OwnedSlice;\n use util::small_vector::SmallVector;\n \n use std::rc::Rc;\n-use std::gc::{Gc, GC};\n+\n+// This could have a better place to live.\n+pub trait MoveMap<T> {\n+    fn move_map(self, f: |T| -> T) -> Self;\n+}\n+\n+impl<T> MoveMap<T> for Vec<T> {\n+    fn move_map(mut self, f: |T| -> T) -> Vec<T> {\n+        use std::{mem, ptr};\n+        for p in self.mut_iter() {\n+            unsafe {\n+                // FIXME(#5016) this shouldn't need to zero to be safe.\n+                mem::move_val_init(p, f(ptr::read_and_zero(p)));\n+            }\n+        }\n+        self\n+    }\n+}\n+\n+impl<T> MoveMap<T> for OwnedSlice<T> {\n+    fn move_map(self, f: |T| -> T) -> OwnedSlice<T> {\n+        OwnedSlice::from_vec(self.into_vec().move_map(f))\n+    }\n+}\n \n pub trait Folder {\n     // Any additions to this trait should happen in form\n@@ -42,91 +66,91 @@ pub trait Folder {\n         noop_fold_crate(c, self)\n     }\n \n-    fn fold_meta_items(&mut self, meta_items: &[Gc<MetaItem>]) -> Vec<Gc<MetaItem>> {\n+    fn fold_meta_items(&mut self, meta_items: Vec<P<MetaItem>>) -> Vec<P<MetaItem>> {\n         noop_fold_meta_items(meta_items, self)\n     }\n \n-    fn fold_meta_item(&mut self, meta_item: &MetaItem) -> MetaItem {\n+    fn fold_meta_item(&mut self, meta_item: P<MetaItem>) -> P<MetaItem> {\n         noop_fold_meta_item(meta_item, self)\n     }\n \n-    fn fold_view_path(&mut self, view_path: Gc<ViewPath>) -> Gc<ViewPath> {\n+    fn fold_view_path(&mut self, view_path: P<ViewPath>) -> P<ViewPath> {\n         noop_fold_view_path(view_path, self)\n     }\n \n-    fn fold_view_item(&mut self, vi: &ViewItem) -> ViewItem {\n+    fn fold_view_item(&mut self, vi: ViewItem) -> ViewItem {\n         noop_fold_view_item(vi, self)\n     }\n \n-    fn fold_foreign_item(&mut self, ni: Gc<ForeignItem>) -> Gc<ForeignItem> {\n-        noop_fold_foreign_item(&*ni, self)\n+    fn fold_foreign_item(&mut self, ni: P<ForeignItem>) -> P<ForeignItem> {\n+        noop_fold_foreign_item(ni, self)\n     }\n \n-    fn fold_item(&mut self, i: Gc<Item>) -> SmallVector<Gc<Item>> {\n-        noop_fold_item(&*i, self)\n+    fn fold_item(&mut self, i: P<Item>) -> SmallVector<P<Item>> {\n+        noop_fold_item(i, self)\n     }\n \n-    fn fold_item_simple(&mut self, i: &Item) -> Item {\n+    fn fold_item_simple(&mut self, i: Item) -> Item {\n         noop_fold_item_simple(i, self)\n     }\n \n-    fn fold_struct_field(&mut self, sf: &StructField) -> StructField {\n+    fn fold_struct_field(&mut self, sf: StructField) -> StructField {\n         noop_fold_struct_field(sf, self)\n     }\n \n-    fn fold_item_underscore(&mut self, i: &Item_) -> Item_ {\n+    fn fold_item_underscore(&mut self, i: Item_) -> Item_ {\n         noop_fold_item_underscore(i, self)\n     }\n \n-    fn fold_fn_decl(&mut self, d: &FnDecl) -> P<FnDecl> {\n+    fn fold_fn_decl(&mut self, d: P<FnDecl>) -> P<FnDecl> {\n         noop_fold_fn_decl(d, self)\n     }\n \n-    fn fold_type_method(&mut self, m: &TypeMethod) -> TypeMethod {\n+    fn fold_type_method(&mut self, m: TypeMethod) -> TypeMethod {\n         noop_fold_type_method(m, self)\n     }\n \n-    fn fold_method(&mut self, m: Gc<Method>) -> SmallVector<Gc<Method>>  {\n-        noop_fold_method(&*m, self)\n+    fn fold_method(&mut self, m: P<Method>) -> SmallVector<P<Method>> {\n+        noop_fold_method(m, self)\n     }\n \n     fn fold_block(&mut self, b: P<Block>) -> P<Block> {\n         noop_fold_block(b, self)\n     }\n \n-    fn fold_stmt(&mut self, s: &Stmt) -> SmallVector<Gc<Stmt>> {\n-        noop_fold_stmt(s, self)\n+    fn fold_stmt(&mut self, s: P<Stmt>) -> SmallVector<P<Stmt>> {\n+        s.and_then(|s| noop_fold_stmt(s, self))\n     }\n \n-    fn fold_arm(&mut self, a: &Arm) -> Arm {\n+    fn fold_arm(&mut self, a: Arm) -> Arm {\n         noop_fold_arm(a, self)\n     }\n \n-    fn fold_pat(&mut self, p: Gc<Pat>) -> Gc<Pat> {\n+    fn fold_pat(&mut self, p: P<Pat>) -> P<Pat> {\n         noop_fold_pat(p, self)\n     }\n \n-    fn fold_decl(&mut self, d: Gc<Decl>) -> SmallVector<Gc<Decl>> {\n+    fn fold_decl(&mut self, d: P<Decl>) -> SmallVector<P<Decl>> {\n         noop_fold_decl(d, self)\n     }\n \n-    fn fold_expr(&mut self, e: Gc<Expr>) -> Gc<Expr> {\n-        noop_fold_expr(e, self)\n+    fn fold_expr(&mut self, e: P<Expr>) -> P<Expr> {\n+        e.map(|e| noop_fold_expr(e, self))\n     }\n \n     fn fold_ty(&mut self, t: P<Ty>) -> P<Ty> {\n         noop_fold_ty(t, self)\n     }\n \n-    fn fold_mod(&mut self, m: &Mod) -> Mod {\n+    fn fold_mod(&mut self, m: Mod) -> Mod {\n         noop_fold_mod(m, self)\n     }\n \n-    fn fold_foreign_mod(&mut self, nm: &ForeignMod) -> ForeignMod {\n+    fn fold_foreign_mod(&mut self, nm: ForeignMod) -> ForeignMod {\n         noop_fold_foreign_mod(nm, self)\n     }\n \n-    fn fold_variant(&mut self, v: &Variant) -> P<Variant> {\n+    fn fold_variant(&mut self, v: P<Variant>) -> P<Variant> {\n         noop_fold_variant(v, self)\n     }\n \n@@ -138,15 +162,15 @@ pub trait Folder {\n         noop_fold_uint(i, self)\n     }\n \n-    fn fold_path(&mut self, p: &Path) -> Path {\n+    fn fold_path(&mut self, p: Path) -> Path {\n         noop_fold_path(p, self)\n     }\n \n-    fn fold_local(&mut self, l: Gc<Local>) -> Gc<Local> {\n+    fn fold_local(&mut self, l: P<Local>) -> P<Local> {\n         noop_fold_local(l, self)\n     }\n \n-    fn fold_mac(&mut self, _macro: &Mac) -> Mac {\n+    fn fold_mac(&mut self, _macro: Mac) -> Mac {\n         fail!(\"fold_mac disabled by default\");\n         // NB: see note about macros above.\n         // if you really want a folder that\n@@ -155,55 +179,55 @@ pub trait Folder {\n         // fold::noop_fold_mac(_macro, self)\n     }\n \n-    fn fold_explicit_self(&mut self, es: &ExplicitSelf) -> ExplicitSelf {\n+    fn fold_explicit_self(&mut self, es: ExplicitSelf) -> ExplicitSelf {\n         noop_fold_explicit_self(es, self)\n     }\n \n-    fn fold_explicit_self_underscore(&mut self, es: &ExplicitSelf_) -> ExplicitSelf_ {\n+    fn fold_explicit_self_underscore(&mut self, es: ExplicitSelf_) -> ExplicitSelf_ {\n         noop_fold_explicit_self_underscore(es, self)\n     }\n \n-    fn fold_lifetime(&mut self, l: &Lifetime) -> Lifetime {\n+    fn fold_lifetime(&mut self, l: Lifetime) -> Lifetime {\n         noop_fold_lifetime(l, self)\n     }\n \n-    fn fold_lifetime_def(&mut self, l: &LifetimeDef) -> LifetimeDef {\n+    fn fold_lifetime_def(&mut self, l: LifetimeDef) -> LifetimeDef {\n         noop_fold_lifetime_def(l, self)\n     }\n \n     fn fold_attribute(&mut self, at: Attribute) -> Attribute {\n         noop_fold_attribute(at, self)\n     }\n \n-    fn fold_arg(&mut self, a: &Arg) -> Arg {\n+    fn fold_arg(&mut self, a: Arg) -> Arg {\n         noop_fold_arg(a, self)\n     }\n \n-    fn fold_generics(&mut self, generics: &Generics) -> Generics {\n+    fn fold_generics(&mut self, generics: Generics) -> Generics {\n         noop_fold_generics(generics, self)\n     }\n \n-    fn fold_trait_ref(&mut self, p: &TraitRef) -> TraitRef {\n+    fn fold_trait_ref(&mut self, p: TraitRef) -> TraitRef {\n         noop_fold_trait_ref(p, self)\n     }\n \n-    fn fold_struct_def(&mut self, struct_def: Gc<StructDef>) -> Gc<StructDef> {\n+    fn fold_struct_def(&mut self, struct_def: P<StructDef>) -> P<StructDef> {\n         noop_fold_struct_def(struct_def, self)\n     }\n \n-    fn fold_lifetimes(&mut self, lts: &[Lifetime]) -> Vec<Lifetime> {\n+    fn fold_lifetimes(&mut self, lts: Vec<Lifetime>) -> Vec<Lifetime> {\n         noop_fold_lifetimes(lts, self)\n     }\n \n-    fn fold_lifetime_defs(&mut self, lts: &[LifetimeDef]) -> Vec<LifetimeDef> {\n+    fn fold_lifetime_defs(&mut self, lts: Vec<LifetimeDef>) -> Vec<LifetimeDef> {\n         noop_fold_lifetime_defs(lts, self)\n     }\n \n-    fn fold_ty_param(&mut self, tp: &TyParam) -> TyParam {\n+    fn fold_ty_param(&mut self, tp: TyParam) -> TyParam {\n         noop_fold_ty_param(tp, self)\n     }\n \n-    fn fold_ty_params(&mut self, tps: &[TyParam]) -> OwnedSlice<TyParam> {\n+    fn fold_ty_params(&mut self, tps: OwnedSlice<TyParam>) -> OwnedSlice<TyParam> {\n         noop_fold_ty_params(tps, self)\n     }\n \n@@ -215,61 +239,54 @@ pub trait Folder {\n         noop_fold_tts(tts, self)\n     }\n \n-    fn fold_token(&mut self, t: &token::Token) -> token::Token {\n+    fn fold_token(&mut self, t: token::Token) -> token::Token {\n         noop_fold_token(t, self)\n     }\n \n-    fn fold_interpolated(&mut self, nt : &token::Nonterminal) -> token::Nonterminal {\n+    fn fold_interpolated(&mut self, nt: token::Nonterminal) -> token::Nonterminal {\n         noop_fold_interpolated(nt, self)\n     }\n \n-    fn fold_opt_lifetime(&mut self, o_lt: &Option<Lifetime>) -> Option<Lifetime> {\n+    fn fold_opt_lifetime(&mut self, o_lt: Option<Lifetime>) -> Option<Lifetime> {\n         noop_fold_opt_lifetime(o_lt, self)\n     }\n \n-    fn fold_variant_arg(&mut self, va: &VariantArg) -> VariantArg {\n+    fn fold_variant_arg(&mut self, va: VariantArg) -> VariantArg {\n         noop_fold_variant_arg(va, self)\n     }\n \n-    fn fold_opt_bounds(&mut self, b: &Option<OwnedSlice<TyParamBound>>)\n+    fn fold_opt_bounds(&mut self, b: Option<OwnedSlice<TyParamBound>>)\n                        -> Option<OwnedSlice<TyParamBound>> {\n         noop_fold_opt_bounds(b, self)\n     }\n \n-    fn fold_bounds(&mut self, b: &OwnedSlice<TyParamBound>)\n+    fn fold_bounds(&mut self, b: OwnedSlice<TyParamBound>)\n                        -> OwnedSlice<TyParamBound> {\n         noop_fold_bounds(b, self)\n     }\n \n-    fn fold_ty_param_bound(&mut self, tpb: &TyParamBound) -> TyParamBound {\n+    fn fold_ty_param_bound(&mut self, tpb: TyParamBound) -> TyParamBound {\n         noop_fold_ty_param_bound(tpb, self)\n     }\n \n-    fn fold_mt(&mut self, mt: &MutTy) -> MutTy {\n+    fn fold_mt(&mut self, mt: MutTy) -> MutTy {\n         noop_fold_mt(mt, self)\n     }\n \n     fn fold_field(&mut self, field: Field) -> Field {\n         noop_fold_field(field, self)\n     }\n \n-    fn fold_where_clause(&mut self, where_clause: &WhereClause)\n+    fn fold_where_clause(&mut self, where_clause: WhereClause)\n                          -> WhereClause {\n         noop_fold_where_clause(where_clause, self)\n     }\n \n-    fn fold_where_predicate(&mut self, where_predicate: &WherePredicate)\n+    fn fold_where_predicate(&mut self, where_predicate: WherePredicate)\n                             -> WherePredicate {\n         noop_fold_where_predicate(where_predicate, self)\n     }\n \n-// Helper methods:\n-\n-    fn map_exprs(&self, f: |Gc<Expr>| -> Gc<Expr>,\n-                 es: &[Gc<Expr>]) -> Vec<Gc<Expr>> {\n-        es.iter().map(|x| f(*x)).collect()\n-    }\n-\n     fn new_id(&mut self, i: NodeId) -> NodeId {\n         i\n     }\n@@ -279,190 +296,161 @@ pub trait Folder {\n     }\n }\n \n-pub fn noop_fold_meta_items<T: Folder>(meta_items: &[Gc<MetaItem>], fld: &mut T)\n-                                       -> Vec<Gc<MetaItem>> {\n-    meta_items.iter().map(|x| box (GC) fld.fold_meta_item(&**x)).collect()\n+pub fn noop_fold_meta_items<T: Folder>(meta_items: Vec<P<MetaItem>>, fld: &mut T)\n+                                       -> Vec<P<MetaItem>> {\n+    meta_items.move_map(|x| fld.fold_meta_item(x))\n }\n \n-pub fn noop_fold_view_path<T: Folder>(view_path: Gc<ViewPath>, fld: &mut T) -> Gc<ViewPath> {\n-    let inner_view_path = match view_path.node {\n-        ViewPathSimple(ref ident, ref path, node_id) => {\n-            let id = fld.new_id(node_id);\n-            ViewPathSimple(ident.clone(),\n-                        fld.fold_path(path),\n-                        id)\n-        }\n-        ViewPathGlob(ref path, node_id) => {\n-            let id = fld.new_id(node_id);\n-            ViewPathGlob(fld.fold_path(path), id)\n-        }\n-        ViewPathList(ref path, ref path_list_idents, node_id) => {\n-            let id = fld.new_id(node_id);\n-            ViewPathList(fld.fold_path(path),\n-                        path_list_idents.iter().map(|path_list_ident| {\n-                            Spanned {\n-                                node: match path_list_ident.node {\n-                                    PathListIdent { id, name } =>\n-                                        PathListIdent {\n-                                            id: fld.new_id(id),\n-                                            name: name.clone()\n-                                        },\n-                                    PathListMod { id } =>\n-                                        PathListMod { id: fld.new_id(id) }\n-                                },\n-                                span: fld.new_span(path_list_ident.span)\n-                            }\n-                        }).collect(),\n-                        id)\n-        }\n-    };\n-    box(GC) Spanned {\n-        node: inner_view_path,\n-        span: fld.new_span(view_path.span),\n-    }\n+pub fn noop_fold_view_path<T: Folder>(view_path: P<ViewPath>, fld: &mut T) -> P<ViewPath> {\n+    view_path.map(|Spanned {node, span}| Spanned {\n+        node: match node {\n+            ViewPathSimple(ident, path, node_id) => {\n+                let id = fld.new_id(node_id);\n+                ViewPathSimple(ident, fld.fold_path(path), id)\n+            }\n+            ViewPathGlob(path, node_id) => {\n+                let id = fld.new_id(node_id);\n+                ViewPathGlob(fld.fold_path(path), id)\n+            }\n+            ViewPathList(path, path_list_idents, node_id) => {\n+                let id = fld.new_id(node_id);\n+                ViewPathList(fld.fold_path(path),\n+                             path_list_idents.move_map(|path_list_ident| {\n+                                Spanned {\n+                                    node: match path_list_ident.node {\n+                                        PathListIdent { id, name } =>\n+                                            PathListIdent {\n+                                                id: fld.new_id(id),\n+                                                name: name\n+                                            },\n+                                        PathListMod { id } =>\n+                                            PathListMod { id: fld.new_id(id) }\n+                                    },\n+                                    span: fld.new_span(path_list_ident.span)\n+                                }\n+                             }),\n+                             id)\n+            }\n+        },\n+        span: fld.new_span(span)\n+    })\n }\n \n-pub fn noop_fold_arm<T: Folder>(a: &Arm, fld: &mut T) -> Arm {\n+pub fn noop_fold_arm<T: Folder>(Arm {attrs, pats, guard, body}: Arm, fld: &mut T) -> Arm {\n     Arm {\n-        attrs: a.attrs.iter().map(|x| fld.fold_attribute(*x)).collect(),\n-        pats: a.pats.iter().map(|x| fld.fold_pat(*x)).collect(),\n-        guard: a.guard.map(|x| fld.fold_expr(x)),\n-        body: fld.fold_expr(a.body),\n+        attrs: attrs.move_map(|x| fld.fold_attribute(x)),\n+        pats: pats.move_map(|x| fld.fold_pat(x)),\n+        guard: guard.map(|x| fld.fold_expr(x)),\n+        body: fld.fold_expr(body),\n     }\n }\n \n-pub fn noop_fold_decl<T: Folder>(d: Gc<Decl>, fld: &mut T) -> SmallVector<Gc<Decl>> {\n-    let node = match d.node {\n-        DeclLocal(ref l) => SmallVector::one(DeclLocal(fld.fold_local(*l))),\n-        DeclItem(it) => {\n-            fld.fold_item(it).move_iter().map(|i| DeclItem(i)).collect()\n-        }\n-    };\n-\n-    node.move_iter().map(|node| {\n-        box(GC) Spanned {\n-            node: node,\n-            span: fld.new_span(d.span),\n-        }\n-    }).collect()\n+pub fn noop_fold_decl<T: Folder>(d: P<Decl>, fld: &mut T) -> SmallVector<P<Decl>> {\n+    d.and_then(|Spanned {node, span}| match node {\n+        DeclLocal(l) => SmallVector::one(P(Spanned {\n+            node: DeclLocal(fld.fold_local(l)),\n+            span: fld.new_span(span)\n+        })),\n+        DeclItem(it) => fld.fold_item(it).move_iter().map(|i| P(Spanned {\n+            node: DeclItem(i),\n+            span: fld.new_span(span)\n+        })).collect()\n+    })\n }\n \n pub fn noop_fold_ty<T: Folder>(t: P<Ty>, fld: &mut T) -> P<Ty> {\n-    let id = fld.new_id(t.id);\n-    let node = match t.node {\n-        TyNil | TyBot | TyInfer => t.node.clone(),\n-        TyBox(ty) => TyBox(fld.fold_ty(ty)),\n-        TyUniq(ty) => TyUniq(fld.fold_ty(ty)),\n-        TyVec(ty) => TyVec(fld.fold_ty(ty)),\n-        TyPtr(ref mt) => TyPtr(fld.fold_mt(mt)),\n-        TyRptr(ref region, ref mt) => {\n-            TyRptr(fld.fold_opt_lifetime(region), fld.fold_mt(mt))\n-        }\n-        TyClosure(ref f) => {\n-            TyClosure(box(GC) ClosureTy {\n-                fn_style: f.fn_style,\n-                onceness: f.onceness,\n-                bounds: fld.fold_bounds(&f.bounds),\n-                decl: fld.fold_fn_decl(&*f.decl),\n-                lifetimes: fld.fold_lifetime_defs(f.lifetimes.as_slice()),\n-            })\n-        }\n-        TyProc(ref f) => {\n-            TyProc(box(GC) ClosureTy {\n-                fn_style: f.fn_style,\n-                onceness: f.onceness,\n-                bounds: fld.fold_bounds(&f.bounds),\n-                decl: fld.fold_fn_decl(&*f.decl),\n-                lifetimes: fld.fold_lifetime_defs(f.lifetimes.as_slice()),\n-            })\n-        }\n-        TyBareFn(ref f) => {\n-            TyBareFn(box(GC) BareFnTy {\n-                lifetimes: fld.fold_lifetime_defs(f.lifetimes.as_slice()),\n-                fn_style: f.fn_style,\n-                abi: f.abi,\n-                decl: fld.fold_fn_decl(&*f.decl)\n-            })\n-        }\n-        TyUnboxedFn(ref f) => {\n-            TyUnboxedFn(box(GC) UnboxedFnTy {\n-                decl: fld.fold_fn_decl(&*f.decl),\n-                kind: f.kind,\n-            })\n-        }\n-        TyTup(ref tys) => TyTup(tys.iter().map(|&ty| fld.fold_ty(ty)).collect()),\n-        TyParen(ref ty) => TyParen(fld.fold_ty(*ty)),\n-        TyPath(ref path, ref bounds, id) => {\n-            let id = fld.new_id(id);\n-            TyPath(fld.fold_path(path),\n-                    fld.fold_opt_bounds(bounds),\n-                    id)\n-        }\n-        TyFixedLengthVec(ty, e) => {\n-            TyFixedLengthVec(fld.fold_ty(ty), fld.fold_expr(e))\n-        }\n-        TyTypeof(expr) => TyTypeof(fld.fold_expr(expr)),\n-    };\n-    P(Ty {\n-        id: id,\n-        span: fld.new_span(t.span),\n-        node: node,\n+    t.map(|Ty {id, node, span}| Ty {\n+        id: fld.new_id(id),\n+        node: match node {\n+            TyNil | TyBot | TyInfer => node,\n+            TyBox(ty) => TyBox(fld.fold_ty(ty)),\n+            TyUniq(ty) => TyUniq(fld.fold_ty(ty)),\n+            TyVec(ty) => TyVec(fld.fold_ty(ty)),\n+            TyPtr(mt) => TyPtr(fld.fold_mt(mt)),\n+            TyRptr(region, mt) => {\n+                TyRptr(fld.fold_opt_lifetime(region), fld.fold_mt(mt))\n+            }\n+            TyClosure(f) => {\n+                TyClosure(f.map(|ClosureTy {fn_style, onceness, bounds, decl, lifetimes}| {\n+                    ClosureTy {\n+                        fn_style: fn_style,\n+                        onceness: onceness,\n+                        bounds: fld.fold_bounds(bounds),\n+                        decl: fld.fold_fn_decl(decl),\n+                        lifetimes: fld.fold_lifetime_defs(lifetimes)\n+                    }\n+                }))\n+            }\n+            TyProc(f) => {\n+                TyProc(f.map(|ClosureTy {fn_style, onceness, bounds, decl, lifetimes}| {\n+                    ClosureTy {\n+                        fn_style: fn_style,\n+                        onceness: onceness,\n+                        bounds: fld.fold_bounds(bounds),\n+                        decl: fld.fold_fn_decl(decl),\n+                        lifetimes: fld.fold_lifetime_defs(lifetimes)\n+                    }\n+                }))\n+            }\n+            TyBareFn(f) => {\n+                TyBareFn(f.map(|BareFnTy {lifetimes, fn_style, abi, decl}| BareFnTy {\n+                    lifetimes: fld.fold_lifetime_defs(lifetimes),\n+                    fn_style: fn_style,\n+                    abi: abi,\n+                    decl: fld.fold_fn_decl(decl)\n+                }))\n+            }\n+            TyUnboxedFn(f) => {\n+                TyUnboxedFn(f.map(|UnboxedFnTy {decl, kind}| UnboxedFnTy {\n+                    decl: fld.fold_fn_decl(decl),\n+                    kind: kind,\n+                }))\n+            }\n+            TyTup(tys) => TyTup(tys.move_map(|ty| fld.fold_ty(ty))),\n+            TyParen(ty) => TyParen(fld.fold_ty(ty)),\n+            TyPath(path, bounds, id) => {\n+                let id = fld.new_id(id);\n+                TyPath(fld.fold_path(path),\n+                        fld.fold_opt_bounds(bounds),\n+                        id)\n+            }\n+            TyFixedLengthVec(ty, e) => {\n+                TyFixedLengthVec(fld.fold_ty(ty), fld.fold_expr(e))\n+            }\n+            TyTypeof(expr) => TyTypeof(fld.fold_expr(expr))\n+        },\n+        span: fld.new_span(span)\n     })\n }\n \n-pub fn noop_fold_foreign_mod<T: Folder>(nm: &ForeignMod, fld: &mut T) -> ForeignMod {\n-    ast::ForeignMod {\n-        abi: nm.abi,\n-        view_items: nm.view_items\n-                        .iter()\n-                        .map(|x| fld.fold_view_item(x))\n-                        .collect(),\n-        items: nm.items\n-                    .iter()\n-                    .map(|x| fld.fold_foreign_item(*x))\n-                    .collect(),\n+pub fn noop_fold_foreign_mod<T: Folder>(ForeignMod {abi, view_items, items}: ForeignMod,\n+                                        fld: &mut T) -> ForeignMod {\n+    ForeignMod {\n+        abi: abi,\n+        view_items: view_items.move_map(|x| fld.fold_view_item(x)),\n+        items: items.move_map(|x| fld.fold_foreign_item(x)),\n     }\n }\n \n-pub fn noop_fold_variant<T: Folder>(v: &Variant, fld: &mut T) -> P<Variant> {\n-    let id = fld.new_id(v.node.id);\n-    let kind;\n-    match v.node.kind {\n-        TupleVariantKind(ref variant_args) => {\n-            kind = TupleVariantKind(variant_args.iter().map(|x|\n-                fld.fold_variant_arg(x)).collect())\n-        }\n-        StructVariantKind(ref struct_def) => {\n-            kind = StructVariantKind(box(GC) ast::StructDef {\n-                fields: struct_def.fields.iter()\n-                    .map(|f| fld.fold_struct_field(f)).collect(),\n-                ctor_id: struct_def.ctor_id.map(|c| fld.new_id(c)),\n-                super_struct: match struct_def.super_struct {\n-                    Some(t) => Some(fld.fold_ty(t)),\n-                    None => None\n-                },\n-                is_virtual: struct_def.is_virtual,\n-            })\n-        }\n-    }\n-\n-    let attrs = v.node.attrs.iter().map(|x| fld.fold_attribute(*x)).collect();\n-\n-    let de = match v.node.disr_expr {\n-        Some(e) => Some(fld.fold_expr(e)),\n-        None => None\n-    };\n-    let node = ast::Variant_ {\n-        name: v.node.name,\n-        attrs: attrs,\n-        kind: kind,\n-        id: id,\n-        disr_expr: de,\n-        vis: v.node.vis,\n-    };\n-    P(Spanned {\n-        node: node,\n-        span: fld.new_span(v.span),\n+pub fn noop_fold_variant<T: Folder>(v: P<Variant>, fld: &mut T) -> P<Variant> {\n+    v.map(|Spanned {node: Variant_ {id, name, attrs, kind, disr_expr, vis}, span}| Spanned {\n+        node: Variant_ {\n+            id: fld.new_id(id),\n+            name: name,\n+            attrs: attrs.move_map(|x| fld.fold_attribute(x)),\n+            kind: match kind {\n+                TupleVariantKind(variant_args) => {\n+                    TupleVariantKind(variant_args.move_map(|x|\n+                        fld.fold_variant_arg(x)))\n+                }\n+                StructVariantKind(struct_def) => {\n+                    StructVariantKind(fld.fold_struct_def(struct_def))\n+                }\n+            },\n+            disr_expr: disr_expr.map(|e| fld.fold_expr(e)),\n+            vis: vis,\n+        },\n+        span: fld.new_span(span),\n     })\n }\n \n@@ -474,109 +462,105 @@ pub fn noop_fold_uint<T: Folder>(i: uint, _: &mut T) -> uint {\n     i\n }\n \n-pub fn noop_fold_path<T: Folder>(p: &Path, fld: &mut T) -> Path {\n-    ast::Path {\n-        span: fld.new_span(p.span),\n-        global: p.global,\n-        segments: p.segments.iter().map(|segment| ast::PathSegment {\n-            identifier: fld.fold_ident(segment.identifier),\n-            lifetimes: segment.lifetimes.iter().map(|l| fld.fold_lifetime(l)).collect(),\n-            types: segment.types.iter().map(|&typ| fld.fold_ty(typ)).collect(),\n-        }).collect()\n+pub fn noop_fold_path<T: Folder>(Path {global, segments, span}: Path, fld: &mut T) -> Path {\n+    Path {\n+        global: global,\n+        segments: segments.move_map(|PathSegment {identifier, lifetimes, types}| PathSegment {\n+            identifier: fld.fold_ident(identifier),\n+            lifetimes: fld.fold_lifetimes(lifetimes),\n+            types: types.move_map(|typ| fld.fold_ty(typ)),\n+        }),\n+        span: fld.new_span(span)\n     }\n }\n \n-pub fn noop_fold_local<T: Folder>(l: Gc<Local>, fld: &mut T) -> Gc<Local> {\n-    let id = fld.new_id(l.id); // Needs to be first, for ast_map.\n-    box(GC) Local {\n-        id: id,\n-        ty: fld.fold_ty(l.ty),\n-        pat: fld.fold_pat(l.pat),\n-        init: l.init.map(|e| fld.fold_expr(e)),\n-        span: fld.new_span(l.span),\n-        source: l.source,\n-    }\n+pub fn noop_fold_local<T: Folder>(l: P<Local>, fld: &mut T) -> P<Local> {\n+    l.map(|Local {id, pat, ty, init, source, span}| Local {\n+        id: fld.new_id(id),\n+        ty: fld.fold_ty(ty),\n+        pat: fld.fold_pat(pat),\n+        init: init.map(|e| fld.fold_expr(e)),\n+        source: source,\n+        span: fld.new_span(span)\n+    })\n }\n \n pub fn noop_fold_attribute<T: Folder>(at: Attribute, fld: &mut T) -> Attribute {\n+    let Spanned {node: Attribute_ {id, style, value, is_sugared_doc}, span} = at;\n     Spanned {\n-        span: fld.new_span(at.span),\n-        node: ast::Attribute_ {\n-            id: at.node.id,\n-            style: at.node.style,\n-            value: box (GC) fld.fold_meta_item(&*at.node.value),\n-            is_sugared_doc: at.node.is_sugared_doc\n-        }\n+        node: Attribute_ {\n+            id: id,\n+            style: style,\n+            value: fld.fold_meta_item(value),\n+            is_sugared_doc: is_sugared_doc\n+        },\n+        span: fld.new_span(span)\n     }\n }\n \n-pub fn noop_fold_explicit_self_underscore<T: Folder>(es: &ExplicitSelf_, fld: &mut T)\n+pub fn noop_fold_explicit_self_underscore<T: Folder>(es: ExplicitSelf_, fld: &mut T)\n                                                      -> ExplicitSelf_ {\n-    match *es {\n-        SelfStatic | SelfValue(_) => *es,\n-        SelfRegion(ref lifetime, m, id) => {\n-            SelfRegion(fld.fold_opt_lifetime(lifetime), m, id)\n+    match es {\n+        SelfStatic | SelfValue(_) => es,\n+        SelfRegion(lifetime, m, ident) => {\n+            SelfRegion(fld.fold_opt_lifetime(lifetime), m, ident)\n+        }\n+        SelfExplicit(typ, ident) => {\n+            SelfExplicit(fld.fold_ty(typ), ident)\n         }\n-        SelfExplicit(ref typ, id) => SelfExplicit(fld.fold_ty(*typ), id),\n     }\n }\n \n-pub fn noop_fold_explicit_self<T: Folder>(es: &ExplicitSelf, fld: &mut T) -> ExplicitSelf {\n+pub fn noop_fold_explicit_self<T: Folder>(Spanned {span, node}: ExplicitSelf, fld: &mut T)\n+                                          -> ExplicitSelf {\n     Spanned {\n-        span: fld.new_span(es.span),\n-        node: fld.fold_explicit_self_underscore(&es.node)\n+        node: fld.fold_explicit_self_underscore(node),\n+        span: fld.new_span(span)\n     }\n }\n \n \n-pub fn noop_fold_mac<T: Folder>(macro: &Mac, fld: &mut T) -> Mac {\n+pub fn noop_fold_mac<T: Folder>(Spanned {node, span}: Mac, fld: &mut T) -> Mac {\n     Spanned {\n-        node: match macro.node {\n-            MacInvocTT(ref p, ref tts, ctxt) => {\n-                MacInvocTT(fld.fold_path(p),\n-                           fld.fold_tts(tts.as_slice()),\n-                           ctxt)\n+        node: match node {\n+            MacInvocTT(p, tts, ctxt) => {\n+                MacInvocTT(fld.fold_path(p), fld.fold_tts(tts.as_slice()), ctxt)\n             }\n         },\n-        span: fld.new_span(macro.span)\n+        span: fld.new_span(span)\n     }\n }\n \n-pub fn noop_fold_meta_item<T: Folder>(mi: &MetaItem, fld: &mut T) -> MetaItem {\n-    Spanned {\n-        node:\n-            match mi.node {\n-                MetaWord(ref id) => MetaWord((*id).clone()),\n-                MetaList(ref id, ref mis) => {\n-                    MetaList((*id).clone(),\n-                             mis.iter()\n-                                .map(|e| box (GC) fld.fold_meta_item(&**e)).collect())\n-                }\n-                MetaNameValue(ref id, ref s) => {\n-                    MetaNameValue((*id).clone(), (*s).clone())\n-                }\n-            },\n-        span: fld.new_span(mi.span) }\n+pub fn noop_fold_meta_item<T: Folder>(mi: P<MetaItem>, fld: &mut T) -> P<MetaItem> {\n+    mi.map(|Spanned {node, span}| Spanned {\n+        node: match node {\n+            MetaWord(id) => MetaWord(id),\n+            MetaList(id, mis) => {\n+                MetaList(id, mis.move_map(|e| fld.fold_meta_item(e)))\n+            }\n+            MetaNameValue(id, s) => MetaNameValue(id, s)\n+        },\n+        span: fld.new_span(span)\n+    })\n }\n \n-pub fn noop_fold_arg<T: Folder>(a: &Arg, fld: &mut T) -> Arg {\n-    let id = fld.new_id(a.id); // Needs to be first, for ast_map.\n+pub fn noop_fold_arg<T: Folder>(Arg {id, pat, ty}: Arg, fld: &mut T) -> Arg {\n     Arg {\n-        id: id,\n-        ty: fld.fold_ty(a.ty),\n-        pat: fld.fold_pat(a.pat),\n+        id: fld.new_id(id),\n+        pat: fld.fold_pat(pat),\n+        ty: fld.fold_ty(ty)\n     }\n }\n \n pub fn noop_fold_tt<T: Folder>(tt: &TokenTree, fld: &mut T) -> TokenTree {\n     match *tt {\n         TTTok(span, ref tok) =>\n-            TTTok(span, fld.fold_token(tok)),\n+            TTTok(span, fld.fold_token(tok.clone())),\n         TTDelim(ref tts) => TTDelim(Rc::new(fld.fold_tts(tts.as_slice()))),\n         TTSeq(span, ref pattern, ref sep, is_optional) =>\n             TTSeq(span,\n                   Rc::new(fld.fold_tts(pattern.as_slice())),\n-                  sep.as_ref().map(|tok| fld.fold_token(tok)),\n+                  sep.clone().map(|tok| fld.fold_token(tok)),\n                   is_optional),\n         TTNonterminal(sp,ref ident) =>\n             TTNonterminal(sp,fld.fold_ident(*ident))\n@@ -588,14 +572,14 @@ pub fn noop_fold_tts<T: Folder>(tts: &[TokenTree], fld: &mut T) -> Vec<TokenTree\n }\n \n // apply ident folder if it's an ident, apply other folds to interpolated nodes\n-pub fn noop_fold_token<T: Folder>(t: &token::Token, fld: &mut T) -> token::Token {\n-    match *t {\n+pub fn noop_fold_token<T: Folder>(t: token::Token, fld: &mut T) -> token::Token {\n+    match t {\n         token::IDENT(id, followed_by_colons) => {\n             token::IDENT(fld.fold_ident(id), followed_by_colons)\n         }\n         token::LIFETIME(id) => token::LIFETIME(fld.fold_ident(id)),\n-        token::INTERPOLATED(ref nt) => token::INTERPOLATED(fld.fold_interpolated(nt)),\n-        _ => (*t).clone()\n+        token::INTERPOLATED(nt) => token::INTERPOLATED(fld.fold_interpolated(nt)),\n+        _ => t\n     }\n }\n \n@@ -619,9 +603,9 @@ pub fn noop_fold_token<T: Folder>(t: &token::Token, fld: &mut T) -> token::Token\n // BTW, design choice: I considered just changing the type of, e.g., NtItem to contain\n // multiple items, but decided against it when I looked at parse_item_or_view_item and\n // tried to figure out what I would do with multiple items there....\n-pub fn noop_fold_interpolated<T: Folder>(nt : &token::Nonterminal, fld: &mut T)\n+pub fn noop_fold_interpolated<T: Folder>(nt: token::Nonterminal, fld: &mut T)\n                                          -> token::Nonterminal {\n-    match *nt {\n+    match nt {\n         token::NtItem(item) =>\n             token::NtItem(fld.fold_item(item)\n                           // this is probably okay, because the only folds likely\n@@ -630,411 +614,381 @@ pub fn noop_fold_interpolated<T: Folder>(nt : &token::Nonterminal, fld: &mut T)\n                           .expect_one(\"expected fold to produce exactly one item\")),\n         token::NtBlock(block) => token::NtBlock(fld.fold_block(block)),\n         token::NtStmt(stmt) =>\n-            token::NtStmt(fld.fold_stmt(&*stmt)\n+            token::NtStmt(fld.fold_stmt(stmt)\n                           // this is probably okay, because the only folds likely\n                           // to peek inside interpolated nodes will be renamings/markings,\n                           // which map single items to single items\n                           .expect_one(\"expected fold to produce exactly one statement\")),\n         token::NtPat(pat) => token::NtPat(fld.fold_pat(pat)),\n         token::NtExpr(expr) => token::NtExpr(fld.fold_expr(expr)),\n         token::NtTy(ty) => token::NtTy(fld.fold_ty(ty)),\n-        token::NtIdent(ref id, is_mod_name) =>\n-            token::NtIdent(box fld.fold_ident(**id),is_mod_name),\n-        token::NtMeta(meta_item) => token::NtMeta(box (GC) fld.fold_meta_item(&*meta_item)),\n-        token::NtPath(ref path) => token::NtPath(box fld.fold_path(&**path)),\n-        token::NtTT(tt) => token::NtTT(box (GC) fld.fold_tt(&*tt)),\n+        token::NtIdent(box id, is_mod_name) =>\n+            token::NtIdent(box fld.fold_ident(id), is_mod_name),\n+        token::NtMeta(meta_item) => token::NtMeta(fld.fold_meta_item(meta_item)),\n+        token::NtPath(box path) => token::NtPath(box fld.fold_path(path)),\n+        token::NtTT(tt) => token::NtTT(P(fld.fold_tt(&*tt))),\n         // it looks to me like we can leave out the matchers: token::NtMatchers(matchers)\n-        _ => (*nt).clone()\n+        _ => nt\n     }\n }\n \n-pub fn noop_fold_fn_decl<T: Folder>(decl: &FnDecl, fld: &mut T) -> P<FnDecl> {\n-    P(FnDecl {\n-        inputs: decl.inputs.iter().map(|x| fld.fold_arg(x)).collect(), // bad copy\n-        output: fld.fold_ty(decl.output),\n-        cf: decl.cf,\n-        variadic: decl.variadic\n+pub fn noop_fold_fn_decl<T: Folder>(decl: P<FnDecl>, fld: &mut T) -> P<FnDecl> {\n+    decl.map(|FnDecl {inputs, output, cf, variadic}| FnDecl {\n+        inputs: inputs.move_map(|x| fld.fold_arg(x)),\n+        output: fld.fold_ty(output),\n+        cf: cf,\n+        variadic: variadic\n     })\n }\n \n-pub fn noop_fold_ty_param_bound<T: Folder>(tpb: &TyParamBound, fld: &mut T)\n+pub fn noop_fold_ty_param_bound<T: Folder>(tpb: TyParamBound, fld: &mut T)\n                                            -> TyParamBound {\n-    match *tpb {\n-        TraitTyParamBound(ref ty) => TraitTyParamBound(fld.fold_trait_ref(ty)),\n-        RegionTyParamBound(ref lifetime) => RegionTyParamBound(fld.fold_lifetime(lifetime)),\n-        UnboxedFnTyParamBound(ref unboxed_function_type) => {\n+    match tpb {\n+        TraitTyParamBound(ty) => TraitTyParamBound(fld.fold_trait_ref(ty)),\n+        RegionTyParamBound(lifetime) => RegionTyParamBound(fld.fold_lifetime(lifetime)),\n+        UnboxedFnTyParamBound(UnboxedFnTy {decl, kind}) => {\n             UnboxedFnTyParamBound(UnboxedFnTy {\n-                decl: fld.fold_fn_decl(&*unboxed_function_type.decl),\n-                kind: unboxed_function_type.kind,\n+                decl: fld.fold_fn_decl(decl),\n+                kind: kind,\n             })\n         }\n     }\n }\n \n-pub fn noop_fold_ty_param<T: Folder>(tp: &TyParam, fld: &mut T) -> TyParam {\n-    let id = fld.new_id(tp.id);\n+pub fn noop_fold_ty_param<T: Folder>(tp: TyParam, fld: &mut T) -> TyParam {\n+    let TyParam {id, ident, bounds, unbound, default, span} = tp;\n     TyParam {\n-        ident: tp.ident,\n-        id: id,\n-        bounds: fld.fold_bounds(&tp.bounds),\n-        unbound: tp.unbound.as_ref().map(|x| fld.fold_ty_param_bound(x)),\n-        default: tp.default.map(|x| fld.fold_ty(x)),\n-        span: tp.span\n+        id: fld.new_id(id),\n+        ident: ident,\n+        bounds: fld.fold_bounds(bounds),\n+        unbound: unbound.map(|x| fld.fold_ty_param_bound(x)),\n+        default: default.map(|x| fld.fold_ty(x)),\n+        span: span\n     }\n }\n \n-pub fn noop_fold_ty_params<T: Folder>(tps: &[TyParam], fld: &mut T)\n+pub fn noop_fold_ty_params<T: Folder>(tps: OwnedSlice<TyParam>, fld: &mut T)\n                                       -> OwnedSlice<TyParam> {\n-    tps.iter().map(|tp| fld.fold_ty_param(tp)).collect()\n+    tps.move_map(|tp| fld.fold_ty_param(tp))\n }\n \n-pub fn noop_fold_lifetime<T: Folder>(l: &Lifetime, fld: &mut T) -> Lifetime {\n-    let id = fld.new_id(l.id);\n+pub fn noop_fold_lifetime<T: Folder>(l: Lifetime, fld: &mut T) -> Lifetime {\n     Lifetime {\n-        id: id,\n-        span: fld.new_span(l.span),\n-        name: l.name\n+        id: fld.new_id(l.id),\n+        name: l.name,\n+        span: fld.new_span(l.span)\n     }\n }\n \n-pub fn noop_fold_lifetime_def<T: Folder>(l: &LifetimeDef, fld: &mut T)\n-                                         -> LifetimeDef\n-{\n+pub fn noop_fold_lifetime_def<T: Folder>(l: LifetimeDef, fld: &mut T)\n+                                         -> LifetimeDef {\n     LifetimeDef {\n-        lifetime: fld.fold_lifetime(&l.lifetime),\n-        bounds: fld.fold_lifetimes(l.bounds.as_slice()),\n+        lifetime: fld.fold_lifetime(l.lifetime),\n+        bounds: fld.fold_lifetimes(l.bounds),\n     }\n }\n \n-pub fn noop_fold_lifetimes<T: Folder>(lts: &[Lifetime], fld: &mut T) -> Vec<Lifetime> {\n-    lts.iter().map(|l| fld.fold_lifetime(l)).collect()\n+pub fn noop_fold_lifetimes<T: Folder>(lts: Vec<Lifetime>, fld: &mut T) -> Vec<Lifetime> {\n+    lts.move_map(|l| fld.fold_lifetime(l))\n }\n \n-pub fn noop_fold_lifetime_defs<T: Folder>(lts: &[LifetimeDef], fld: &mut T) -> Vec<LifetimeDef> {\n-    lts.iter().map(|l| fld.fold_lifetime_def(l)).collect()\n+pub fn noop_fold_lifetime_defs<T: Folder>(lts: Vec<LifetimeDef>, fld: &mut T)\n+                                          -> Vec<LifetimeDef> {\n+    lts.move_map(|l| fld.fold_lifetime_def(l))\n }\n \n-pub fn noop_fold_opt_lifetime<T: Folder>(o_lt: &Option<Lifetime>, fld: &mut T)\n-                                      -> Option<Lifetime> {\n-    o_lt.as_ref().map(|lt| fld.fold_lifetime(lt))\n+pub fn noop_fold_opt_lifetime<T: Folder>(o_lt: Option<Lifetime>, fld: &mut T)\n+                                         -> Option<Lifetime> {\n+    o_lt.map(|lt| fld.fold_lifetime(lt))\n }\n \n-pub fn noop_fold_generics<T: Folder>(generics: &Generics, fld: &mut T) -> Generics {\n+pub fn noop_fold_generics<T: Folder>(Generics {ty_params, lifetimes, where_clause}: Generics,\n+                                     fld: &mut T) -> Generics {\n     Generics {\n-        ty_params: fld.fold_ty_params(generics.ty_params.as_slice()),\n-        lifetimes: fld.fold_lifetime_defs(generics.lifetimes.as_slice()),\n-        where_clause: fld.fold_where_clause(&generics.where_clause),\n+        ty_params: fld.fold_ty_params(ty_params),\n+        lifetimes: fld.fold_lifetime_defs(lifetimes),\n+        where_clause: fld.fold_where_clause(where_clause),\n     }\n }\n \n pub fn noop_fold_where_clause<T: Folder>(\n-                              where_clause: &WhereClause,\n+                              WhereClause {id, predicates}: WhereClause,\n                               fld: &mut T)\n                               -> WhereClause {\n     WhereClause {\n-        id: fld.new_id(where_clause.id),\n-        predicates: where_clause.predicates.iter().map(|predicate| {\n+        id: fld.new_id(id),\n+        predicates: predicates.move_map(|predicate| {\n             fld.fold_where_predicate(predicate)\n-        }).collect(),\n+        })\n     }\n }\n \n pub fn noop_fold_where_predicate<T: Folder>(\n-                                 predicate: &WherePredicate,\n+                                 WherePredicate {id, ident, bounds, span}: WherePredicate,\n                                  fld: &mut T)\n                                  -> WherePredicate {\n     WherePredicate {\n-        id: fld.new_id(predicate.id),\n-        span: fld.new_span(predicate.span),\n-        ident: fld.fold_ident(predicate.ident),\n-        bounds: predicate.bounds.map(|x| {\n-            fld.fold_ty_param_bound(x)\n-        }),\n+        id: fld.new_id(id),\n+        ident: fld.fold_ident(ident),\n+        bounds: bounds.move_map(|x| fld.fold_ty_param_bound(x)),\n+        span: fld.new_span(span)\n     }\n }\n \n-pub fn noop_fold_struct_def<T: Folder>(struct_def: Gc<StructDef>,\n-                              fld: &mut T) -> Gc<StructDef> {\n-    box(GC) ast::StructDef {\n-        fields: struct_def.fields.iter().map(|f| fld.fold_struct_field(f)).collect(),\n-        ctor_id: struct_def.ctor_id.map(|cid| fld.new_id(cid)),\n-        super_struct: match struct_def.super_struct {\n-            Some(t) => Some(fld.fold_ty(t)),\n-            None => None\n-        },\n-        is_virtual: struct_def.is_virtual,\n-    }\n+pub fn noop_fold_struct_def<T: Folder>(struct_def: P<StructDef>, fld: &mut T) -> P<StructDef> {\n+    struct_def.map(|StructDef {fields, ctor_id, super_struct, is_virtual}| StructDef {\n+        fields: fields.move_map(|f| fld.fold_struct_field(f)),\n+        ctor_id: ctor_id.map(|cid| fld.new_id(cid)),\n+        super_struct: super_struct.map(|t| fld.fold_ty(t)),\n+        is_virtual: is_virtual\n+    })\n }\n \n-pub fn noop_fold_trait_ref<T: Folder>(p: &TraitRef, fld: &mut T) -> TraitRef {\n-    let id = fld.new_id(p.ref_id);\n-    ast::TraitRef {\n-        path: fld.fold_path(&p.path),\n-        ref_id: id,\n+pub fn noop_fold_trait_ref<T: Folder>(TraitRef {ref_id, path}: TraitRef, fld: &mut T) -> TraitRef {\n+    TraitRef {\n+        ref_id: fld.new_id(ref_id),\n+        path: fld.fold_path(path),\n     }\n }\n \n-pub fn noop_fold_struct_field<T: Folder>(f: &StructField, fld: &mut T) -> StructField {\n-    let id = fld.new_id(f.node.id);\n+pub fn noop_fold_struct_field<T: Folder>(f: StructField, fld: &mut T) -> StructField {\n+    let StructField {node: StructField_ {id, kind, ty, attrs}, span} = f;\n     Spanned {\n-        node: ast::StructField_ {\n-            kind: f.node.kind,\n-            id: id,\n-            ty: fld.fold_ty(f.node.ty),\n-            attrs: f.node.attrs.iter().map(|a| fld.fold_attribute(*a)).collect(),\n+        node: StructField_ {\n+            id: fld.new_id(id),\n+            kind: kind,\n+            ty: fld.fold_ty(ty),\n+            attrs: attrs.move_map(|a| fld.fold_attribute(a))\n         },\n-        span: fld.new_span(f.span),\n+        span: fld.new_span(span)\n     }\n }\n \n-pub fn noop_fold_field<T: Folder>(field: Field, folder: &mut T) -> Field {\n-    ast::Field {\n-        ident: respan(field.ident.span, folder.fold_ident(field.ident.node)),\n-        expr: folder.fold_expr(field.expr),\n-        span: folder.new_span(field.span),\n+pub fn noop_fold_field<T: Folder>(Field {ident, expr, span}: Field, folder: &mut T) -> Field {\n+    Field {\n+        ident: respan(ident.span, folder.fold_ident(ident.node)),\n+        expr: folder.fold_expr(expr),\n+        span: folder.new_span(span)\n     }\n }\n \n-pub fn noop_fold_mt<T: Folder>(mt: &MutTy, folder: &mut T) -> MutTy {\n+pub fn noop_fold_mt<T: Folder>(MutTy {ty, mutbl}: MutTy, folder: &mut T) -> MutTy {\n     MutTy {\n-        ty: folder.fold_ty(mt.ty),\n-        mutbl: mt.mutbl,\n+        ty: folder.fold_ty(ty),\n+        mutbl: mutbl,\n     }\n }\n \n-pub fn noop_fold_opt_bounds<T: Folder>(b: &Option<OwnedSlice<TyParamBound>>, folder: &mut T)\n-                              -> Option<OwnedSlice<TyParamBound>> {\n-    b.as_ref().map(|bounds| folder.fold_bounds(bounds))\n+pub fn noop_fold_opt_bounds<T: Folder>(b: Option<OwnedSlice<TyParamBound>>, folder: &mut T)\n+                                       -> Option<OwnedSlice<TyParamBound>> {\n+    b.map(|bounds| folder.fold_bounds(bounds))\n }\n \n-fn noop_fold_bounds<T: Folder>(bounds: &TyParamBounds, folder: &mut T)\n+fn noop_fold_bounds<T: Folder>(bounds: TyParamBounds, folder: &mut T)\n                           -> TyParamBounds {\n-    bounds.map(|bound| folder.fold_ty_param_bound(bound))\n+    bounds.move_map(|bound| folder.fold_ty_param_bound(bound))\n }\n \n-pub fn noop_fold_variant_arg<T: Folder>(va: &VariantArg, folder: &mut T) -> VariantArg {\n-    let id = folder.new_id(va.id);\n-    ast::VariantArg {\n-        ty: folder.fold_ty(va.ty),\n-        id: id,\n+fn noop_fold_variant_arg<T: Folder>(VariantArg {id, ty}: VariantArg, folder: &mut T)\n+                                    -> VariantArg {\n+    VariantArg {\n+        id: folder.new_id(id),\n+        ty: folder.fold_ty(ty)\n     }\n }\n \n-pub fn noop_fold_view_item<T: Folder>(vi: &ViewItem, folder: &mut T)\n-                                       -> ViewItem{\n-    let inner_view_item = match vi.node {\n-        ViewItemExternCrate(ref ident, ref string, node_id) => {\n-            ViewItemExternCrate(ident.clone(),\n-                              (*string).clone(),\n-                              folder.new_id(node_id))\n-        }\n-        ViewItemUse(ref view_path) => {\n-            ViewItemUse(folder.fold_view_path(*view_path))\n-        }\n-    };\n+pub fn noop_fold_view_item<T: Folder>(ViewItem {node, attrs, vis, span}: ViewItem,\n+                                      folder: &mut T) -> ViewItem {\n     ViewItem {\n-        node: inner_view_item,\n-        attrs: vi.attrs.iter().map(|a| folder.fold_attribute(*a)).collect(),\n-        vis: vi.vis,\n-        span: folder.new_span(vi.span),\n+        node: match node {\n+            ViewItemExternCrate(ident, string, node_id) => {\n+                ViewItemExternCrate(ident, string,\n+                                    folder.new_id(node_id))\n+            }\n+            ViewItemUse(view_path) => {\n+                ViewItemUse(folder.fold_view_path(view_path))\n+            }\n+        },\n+        attrs: attrs.move_map(|a| folder.fold_attribute(a)),\n+        vis: vis,\n+        span: folder.new_span(span)\n     }\n }\n \n pub fn noop_fold_block<T: Folder>(b: P<Block>, folder: &mut T) -> P<Block> {\n-    let id = folder.new_id(b.id); // Needs to be first, for ast_map.\n-    let view_items = b.view_items.iter().map(|x| folder.fold_view_item(x)).collect();\n-    let stmts = b.stmts.iter().flat_map(|s| folder.fold_stmt(&**s).move_iter()).collect();\n-    P(Block {\n-        id: id,\n-        view_items: view_items,\n-        stmts: stmts,\n-        expr: b.expr.map(|x| folder.fold_expr(x)),\n-        rules: b.rules,\n-        span: folder.new_span(b.span),\n+    b.map(|Block {id, view_items, stmts, expr, rules, span}| Block {\n+        id: folder.new_id(id),\n+        view_items: view_items.move_map(|x| folder.fold_view_item(x)),\n+        stmts: stmts.move_iter().flat_map(|s| folder.fold_stmt(s).move_iter()).collect(),\n+        expr: expr.map(|x| folder.fold_expr(x)),\n+        rules: rules,\n+        span: folder.new_span(span),\n     })\n }\n \n-pub fn noop_fold_item_underscore<T: Folder>(i: &Item_, folder: &mut T) -> Item_ {\n-    match *i {\n+pub fn noop_fold_item_underscore<T: Folder>(i: Item_, folder: &mut T) -> Item_ {\n+    match i {\n         ItemStatic(t, m, e) => {\n             ItemStatic(folder.fold_ty(t), m, folder.fold_expr(e))\n         }\n-        ItemFn(decl, fn_style, abi, ref generics, body) => {\n+        ItemFn(decl, fn_style, abi, generics, body) => {\n             ItemFn(\n-                folder.fold_fn_decl(&*decl),\n+                folder.fold_fn_decl(decl),\n                 fn_style,\n                 abi,\n                 folder.fold_generics(generics),\n                 folder.fold_block(body)\n             )\n         }\n-        ItemMod(ref m) => ItemMod(folder.fold_mod(m)),\n-        ItemForeignMod(ref nm) => ItemForeignMod(folder.fold_foreign_mod(nm)),\n-        ItemTy(t, ref generics) => {\n+        ItemMod(m) => ItemMod(folder.fold_mod(m)),\n+        ItemForeignMod(nm) => ItemForeignMod(folder.fold_foreign_mod(nm)),\n+        ItemTy(t, generics) => {\n             ItemTy(folder.fold_ty(t), folder.fold_generics(generics))\n         }\n-        ItemEnum(ref enum_definition, ref generics) => {\n+        ItemEnum(enum_definition, generics) => {\n             ItemEnum(\n                 ast::EnumDef {\n-                    variants: enum_definition.variants.iter().map(|&x| {\n-                        folder.fold_variant(&*x)\n-                    }).collect(),\n+                    variants: enum_definition.variants.move_map(|x| folder.fold_variant(x)),\n                 },\n                 folder.fold_generics(generics))\n         }\n-        ItemStruct(ref struct_def, ref generics) => {\n-            let struct_def = folder.fold_struct_def(*struct_def);\n+        ItemStruct(struct_def, generics) => {\n+            let struct_def = folder.fold_struct_def(struct_def);\n             ItemStruct(struct_def, folder.fold_generics(generics))\n         }\n-        ItemImpl(ref generics, ref ifce, ty, ref impl_items) => {\n+        ItemImpl(generics, ifce, ty, impl_items) => {\n             ItemImpl(folder.fold_generics(generics),\n-                     ifce.as_ref().map(|p| folder.fold_trait_ref(p)),\n+                     ifce.map(|p| folder.fold_trait_ref(p)),\n                      folder.fold_ty(ty),\n-                     impl_items.iter()\n-                               .flat_map(|impl_item| {\n-                                    match *impl_item {\n-                                        MethodImplItem(x) => {\n-                                            folder.fold_method(x)\n-                                                  .move_iter()\n-                                                  .map(|x| MethodImplItem(x))\n-                                        }\n-                                    }\n-                               }).collect()\n-            )\n+                     impl_items.move_iter().flat_map(|impl_item| match impl_item {\n+                        MethodImplItem(x) => {\n+                            folder.fold_method(x).move_iter().map(|x| MethodImplItem(x))\n+                        }\n+                     }).collect())\n         }\n-        ItemTrait(ref generics, ref unbound, ref bounds, ref methods) => {\n+        ItemTrait(generics, unbound, bounds, methods) => {\n             let bounds = folder.fold_bounds(bounds);\n-            let methods = methods.iter().flat_map(|method| {\n-                let r = match *method {\n-                    RequiredMethod(ref m) => {\n-                            SmallVector::one(RequiredMethod(\n-                                    folder.fold_type_method(m))).move_iter()\n-                    }\n-                    ProvidedMethod(method) => {\n-                            // the awkward collect/iter idiom here is because\n-                            // even though an iter and a map satisfy the same trait bound,\n-                            // they're not actually the same type, so the method arms\n-                            // don't unify.\n-                            let methods : SmallVector<ast::TraitItem> =\n-                                folder.fold_method(method).move_iter()\n-                                .map(|m| ProvidedMethod(m)).collect();\n-                            methods.move_iter()\n-                        }\n-                };\n-                r\n+            let methods = methods.move_iter().flat_map(|method| match method {\n+                RequiredMethod(m) => {\n+                    SmallVector::one(RequiredMethod(folder.fold_type_method(m))).move_iter()\n+                }\n+                ProvidedMethod(method) => {\n+                    // the awkward collect/iter idiom here is because\n+                    // even though an iter and a map satisfy the same trait bound,\n+                    // they're not actually the same type, so the method arms\n+                    // don't unify.\n+                    let methods: SmallVector<ast::TraitItem> =\n+                        folder.fold_method(method).move_iter()\n+                        .map(|m| ProvidedMethod(m)).collect();\n+                    methods.move_iter()\n+                }\n             }).collect();\n             ItemTrait(folder.fold_generics(generics),\n-                      unbound.clone(),\n+                      unbound,\n                       bounds,\n                       methods)\n         }\n-        ItemMac(ref m) => ItemMac(folder.fold_mac(m)),\n+        ItemMac(m) => ItemMac(folder.fold_mac(m)),\n     }\n }\n \n-pub fn noop_fold_type_method<T: Folder>(m: &TypeMethod, fld: &mut T) -> TypeMethod {\n-    let id = fld.new_id(m.id); // Needs to be first, for ast_map.\n+pub fn noop_fold_type_method<T: Folder>(m: TypeMethod, fld: &mut T) -> TypeMethod {\n+    let TypeMethod {id, ident, attrs, fn_style, abi, decl, generics, explicit_self, vis, span} = m;\n     TypeMethod {\n-        id: id,\n-        ident: fld.fold_ident(m.ident),\n-        attrs: m.attrs.iter().map(|a| fld.fold_attribute(*a)).collect(),\n-        fn_style: m.fn_style,\n-        abi: m.abi,\n-        decl: fld.fold_fn_decl(&*m.decl),\n-        generics: fld.fold_generics(&m.generics),\n-        explicit_self: fld.fold_explicit_self(&m.explicit_self),\n-        span: fld.new_span(m.span),\n-        vis: m.vis,\n+        id: fld.new_id(id),\n+        ident: fld.fold_ident(ident),\n+        attrs: attrs.move_map(|a| fld.fold_attribute(a)),\n+        fn_style: fn_style,\n+        abi: abi,\n+        decl: fld.fold_fn_decl(decl),\n+        generics: fld.fold_generics(generics),\n+        explicit_self: fld.fold_explicit_self(explicit_self),\n+        vis: vis,\n+        span: fld.new_span(span)\n     }\n }\n \n-pub fn noop_fold_mod<T: Folder>(m: &Mod, folder: &mut T) -> Mod {\n-    ast::Mod {\n-        inner: folder.new_span(m.inner),\n-        view_items: m.view_items\n-                     .iter()\n-                     .map(|x| folder.fold_view_item(x)).collect(),\n-        items: m.items.iter().flat_map(|x| folder.fold_item(*x).move_iter()).collect(),\n+pub fn noop_fold_mod<T: Folder>(Mod {inner, view_items, items}: Mod, folder: &mut T) -> Mod {\n+    Mod {\n+        inner: folder.new_span(inner),\n+        view_items: view_items.move_map(|x| folder.fold_view_item(x)),\n+        items: items.move_iter().flat_map(|x| folder.fold_item(x).move_iter()).collect(),\n     }\n }\n \n-pub fn noop_fold_crate<T: Folder>(c: Crate, folder: &mut T) -> Crate {\n+pub fn noop_fold_crate<T: Folder>(Crate {module, attrs, config, exported_macros, span}: Crate,\n+                                  folder: &mut T) -> Crate {\n     Crate {\n-        module: folder.fold_mod(&c.module),\n-        attrs: c.attrs.iter().map(|x| folder.fold_attribute(*x)).collect(),\n-        config: c.config.iter().map(|x| box (GC) folder.fold_meta_item(&**x)).collect(),\n-        span: folder.new_span(c.span),\n-        exported_macros: c.exported_macros\n+        module: folder.fold_mod(module),\n+        attrs: attrs.move_map(|x| folder.fold_attribute(x)),\n+        config: folder.fold_meta_items(config),\n+        exported_macros: exported_macros,\n+        span: folder.new_span(span)\n     }\n }\n \n // fold one item into possibly many items\n-pub fn noop_fold_item<T: Folder>(i: &Item,\n-                                 folder: &mut T) -> SmallVector<Gc<Item>> {\n-    SmallVector::one(box(GC) folder.fold_item_simple(i))\n+pub fn noop_fold_item<T: Folder>(i: P<Item>, folder: &mut T) -> SmallVector<P<Item>> {\n+    SmallVector::one(i.map(|i| folder.fold_item_simple(i)))\n }\n \n-\n // fold one item into exactly one item\n-pub fn noop_fold_item_simple<T: Folder>(i: &Item, folder: &mut T) -> Item {\n-    let id = folder.new_id(i.id); // Needs to be first, for ast_map.\n-    let node = folder.fold_item_underscore(&i.node);\n+pub fn noop_fold_item_simple<T: Folder>(Item {id, ident, attrs, node, vis, span}: Item,\n+                                        folder: &mut T) -> Item {\n+    let id = folder.new_id(id);\n+    let node = folder.fold_item_underscore(node);\n     let ident = match node {\n         // The node may have changed, recompute the \"pretty\" impl name.\n-        ItemImpl(_, ref maybe_trait, ty, _) => {\n-            ast_util::impl_pretty_name(maybe_trait, &*ty)\n+        ItemImpl(_, ref maybe_trait, ref ty, _) => {\n+            ast_util::impl_pretty_name(maybe_trait, &**ty)\n         }\n-        _ => i.ident\n+        _ => ident\n     };\n \n     Item {\n         id: id,\n         ident: folder.fold_ident(ident),\n-        attrs: i.attrs.iter().map(|e| folder.fold_attribute(*e)).collect(),\n+        attrs: attrs.move_map(|e| folder.fold_attribute(e)),\n         node: node,\n-        vis: i.vis,\n-        span: folder.new_span(i.span)\n+        vis: vis,\n+        span: folder.new_span(span)\n     }\n }\n \n-pub fn noop_fold_foreign_item<T: Folder>(ni: &ForeignItem,\n-                                         folder: &mut T) -> Gc<ForeignItem> {\n-    let id = folder.new_id(ni.id); // Needs to be first, for ast_map.\n-    box(GC) ForeignItem {\n-        id: id,\n-        ident: folder.fold_ident(ni.ident),\n-        attrs: ni.attrs.iter().map(|x| folder.fold_attribute(*x)).collect(),\n-        node: match ni.node {\n-            ForeignItemFn(ref fdec, ref generics) => {\n-                ForeignItemFn(P(FnDecl {\n-                    inputs: fdec.inputs.iter().map(|a| folder.fold_arg(a)).collect(),\n-                    output: folder.fold_ty(fdec.output),\n-                    cf: fdec.cf,\n-                    variadic: fdec.variadic\n+pub fn noop_fold_foreign_item<T: Folder>(ni: P<ForeignItem>, folder: &mut T) -> P<ForeignItem> {\n+    ni.map(|ForeignItem {id, ident, attrs, node, span, vis}| ForeignItem {\n+        id: folder.new_id(id),\n+        ident: folder.fold_ident(ident),\n+        attrs: attrs.move_map(|x| folder.fold_attribute(x)),\n+        node: match node {\n+            ForeignItemFn(fdec, generics) => {\n+                ForeignItemFn(fdec.map(|FnDecl {inputs, output, cf, variadic}| FnDecl {\n+                    inputs: inputs.move_map(|a| folder.fold_arg(a)),\n+                    output: folder.fold_ty(output),\n+                    cf: cf,\n+                    variadic: variadic\n                 }), folder.fold_generics(generics))\n             }\n             ForeignItemStatic(t, m) => {\n                 ForeignItemStatic(folder.fold_ty(t), m)\n             }\n         },\n-        span: folder.new_span(ni.span),\n-        vis: ni.vis,\n-    }\n+        vis: vis,\n+        span: folder.new_span(span)\n+    })\n }\n \n // Default fold over a method.\n // Invariant: produces exactly one method.\n-pub fn noop_fold_method<T: Folder>(m: &Method, folder: &mut T) -> SmallVector<Gc<Method>> {\n-    let id = folder.new_id(m.id); // Needs to be first, for ast_map.\n-    SmallVector::one(box(GC) Method {\n-        attrs: m.attrs.iter().map(|a| folder.fold_attribute(*a)).collect(),\n-        id: id,\n-        span: folder.new_span(m.span),\n-        node: match m.node {\n+pub fn noop_fold_method<T: Folder>(m: P<Method>, folder: &mut T) -> SmallVector<P<Method>> {\n+    SmallVector::one(m.map(|Method {id, attrs, node, span}| Method {\n+        id: folder.new_id(id),\n+        attrs: attrs.move_map(|a| folder.fold_attribute(a)),\n+        node: match node {\n             MethDecl(ident,\n-                     ref generics,\n+                     generics,\n                      abi,\n-                     ref explicit_self,\n+                     explicit_self,\n                      fn_style,\n                      decl,\n                      body,\n@@ -1044,215 +998,226 @@ pub fn noop_fold_method<T: Folder>(m: &Method, folder: &mut T) -> SmallVector<Gc\n                          abi,\n                          folder.fold_explicit_self(explicit_self),\n                          fn_style,\n-                         folder.fold_fn_decl(&*decl),\n+                         folder.fold_fn_decl(decl),\n                          folder.fold_block(body),\n                          vis)\n             },\n-            MethMac(ref mac) => MethMac(folder.fold_mac(mac)),\n-        }\n-    })\n+            MethMac(mac) => MethMac(folder.fold_mac(mac)),\n+        },\n+        span: folder.new_span(span)\n+    }))\n }\n \n-pub fn noop_fold_pat<T: Folder>(p: Gc<Pat>, folder: &mut T) -> Gc<Pat> {\n-    let id = folder.new_id(p.id);\n-    let node = match p.node {\n-        PatWild(k) => PatWild(k),\n-        PatIdent(binding_mode, ref pth1, ref sub) => {\n-            PatIdent(binding_mode,\n-                     Spanned{span: folder.new_span(pth1.span),\n-                             node: folder.fold_ident(pth1.node)},\n-                     sub.map(|x| folder.fold_pat(x)))\n-        }\n-        PatLit(e) => PatLit(folder.fold_expr(e)),\n-        PatEnum(ref pth, ref pats) => {\n-            PatEnum(folder.fold_path(pth),\n-                    pats.as_ref().map(|pats| pats.iter().map(|x| folder.fold_pat(*x)).collect()))\n-        }\n-        PatStruct(ref pth, ref fields, etc) => {\n-            let pth_ = folder.fold_path(pth);\n-            let fs = fields.iter().map(|f| {\n-                ast::FieldPat {\n-                    ident: f.ident,\n-                    pat: folder.fold_pat(f.pat)\n-                }\n-            }).collect();\n-            PatStruct(pth_, fs, etc)\n-        }\n-        PatTup(ref elts) => PatTup(elts.iter().map(|x| folder.fold_pat(*x)).collect()),\n-        PatBox(inner) => PatBox(folder.fold_pat(inner)),\n-        PatRegion(inner) => PatRegion(folder.fold_pat(inner)),\n-        PatRange(e1, e2) => {\n-            PatRange(folder.fold_expr(e1), folder.fold_expr(e2))\n+pub fn noop_fold_pat<T: Folder>(p: P<Pat>, folder: &mut T) -> P<Pat> {\n+    p.map(|Pat {id, node, span}| Pat {\n+        id: folder.new_id(id),\n+        node: match node {\n+            PatWild(k) => PatWild(k),\n+            PatIdent(binding_mode, pth1, sub) => {\n+                PatIdent(binding_mode,\n+                        Spanned{span: folder.new_span(pth1.span),\n+                                node: folder.fold_ident(pth1.node)},\n+                        sub.map(|x| folder.fold_pat(x)))\n+            }\n+            PatLit(e) => PatLit(folder.fold_expr(e)),\n+            PatEnum(pth, pats) => {\n+                PatEnum(folder.fold_path(pth),\n+                        pats.map(|pats| pats.move_map(|x| folder.fold_pat(x))))\n+            }\n+            PatStruct(pth, fields, etc) => {\n+                let pth = folder.fold_path(pth);\n+                let fs = fields.move_map(|f| {\n+                    ast::FieldPat {\n+                        ident: f.ident,\n+                        pat: folder.fold_pat(f.pat)\n+                    }\n+                });\n+                PatStruct(pth, fs, etc)\n+            }\n+            PatTup(elts) => PatTup(elts.move_map(|x| folder.fold_pat(x))),\n+            PatBox(inner) => PatBox(folder.fold_pat(inner)),\n+            PatRegion(inner) => PatRegion(folder.fold_pat(inner)),\n+            PatRange(e1, e2) => {\n+                PatRange(folder.fold_expr(e1), folder.fold_expr(e2))\n+            },\n+            PatVec(before, slice, after) => {\n+                PatVec(before.move_map(|x| folder.fold_pat(x)),\n+                       slice.map(|x| folder.fold_pat(x)),\n+                       after.move_map(|x| folder.fold_pat(x)))\n+            }\n+            PatMac(mac) => PatMac(folder.fold_mac(mac))\n         },\n-        PatVec(ref before, ref slice, ref after) => {\n-            PatVec(before.iter().map(|x| folder.fold_pat(*x)).collect(),\n-                    slice.map(|x| folder.fold_pat(x)),\n-                    after.iter().map(|x| folder.fold_pat(*x)).collect())\n-        }\n-        PatMac(ref mac) => PatMac(folder.fold_mac(mac)),\n-    };\n-\n-    box(GC) Pat {\n-        id: id,\n-        span: folder.new_span(p.span),\n-        node: node,\n-    }\n+        span: folder.new_span(span)\n+    })\n }\n \n-pub fn noop_fold_expr<T: Folder>(e: Gc<Expr>, folder: &mut T) -> Gc<Expr> {\n-    let id = folder.new_id(e.id);\n-    let node = match e.node {\n-        ExprBox(p, e) => {\n-            ExprBox(folder.fold_expr(p), folder.fold_expr(e))\n-        }\n-        ExprVec(ref exprs) => {\n-            ExprVec(exprs.iter().map(|&x| folder.fold_expr(x)).collect())\n-        }\n-        ExprRepeat(expr, count) => {\n-            ExprRepeat(folder.fold_expr(expr), folder.fold_expr(count))\n-        }\n-        ExprTup(ref elts) => ExprTup(elts.iter().map(|x| folder.fold_expr(*x)).collect()),\n-        ExprCall(f, ref args) => {\n-            ExprCall(folder.fold_expr(f),\n-                     args.iter().map(|&x| folder.fold_expr(x)).collect())\n-        }\n-        ExprMethodCall(i, ref tps, ref args) => {\n-            ExprMethodCall(\n-                respan(i.span, folder.fold_ident(i.node)),\n-                tps.iter().map(|&x| folder.fold_ty(x)).collect(),\n-                args.iter().map(|&x| folder.fold_expr(x)).collect())\n-        }\n-        ExprBinary(binop, lhs, rhs) => {\n-            ExprBinary(binop,\n-                       folder.fold_expr(lhs),\n-                       folder.fold_expr(rhs))\n-        }\n-        ExprUnary(binop, ohs) => {\n-            ExprUnary(binop, folder.fold_expr(ohs))\n-        }\n-        ExprLit(_) => e.node.clone(),\n-        ExprCast(expr, ty) => {\n-            ExprCast(folder.fold_expr(expr), folder.fold_ty(ty))\n-        }\n-        ExprAddrOf(m, ohs) => ExprAddrOf(m, folder.fold_expr(ohs)),\n-        ExprIf(cond, tr, fl) => {\n-            ExprIf(folder.fold_expr(cond),\n-                   folder.fold_block(tr),\n-                   fl.map(|x| folder.fold_expr(x)))\n-        }\n-        ExprWhile(cond, body, opt_ident) => {\n-            ExprWhile(folder.fold_expr(cond),\n-                      folder.fold_block(body),\n-                      opt_ident.map(|i| folder.fold_ident(i)))\n-        }\n-        ExprForLoop(pat, iter, body, ref opt_ident) => {\n-            ExprForLoop(folder.fold_pat(pat),\n-                        folder.fold_expr(iter),\n-                        folder.fold_block(body),\n+pub fn noop_fold_expr<T: Folder>(Expr {id, node, span}: Expr, folder: &mut T) -> Expr {\n+    Expr {\n+        id: folder.new_id(id),\n+        node: match node {\n+            ExprBox(p, e) => {\n+                ExprBox(folder.fold_expr(p), folder.fold_expr(e))\n+            }\n+            ExprVec(exprs) => {\n+                ExprVec(exprs.move_map(|x| folder.fold_expr(x)))\n+            }\n+            ExprRepeat(expr, count) => {\n+                ExprRepeat(folder.fold_expr(expr), folder.fold_expr(count))\n+            }\n+            ExprTup(elts) => ExprTup(elts.move_map(|x| folder.fold_expr(x))),\n+            ExprCall(f, args) => {\n+                ExprCall(folder.fold_expr(f),\n+                         args.move_map(|x| folder.fold_expr(x)))\n+            }\n+            ExprMethodCall(i, tps, args) => {\n+                ExprMethodCall(\n+                    respan(i.span, folder.fold_ident(i.node)),\n+                    tps.move_map(|x| folder.fold_ty(x)),\n+                    args.move_map(|x| folder.fold_expr(x)))\n+            }\n+            ExprBinary(binop, lhs, rhs) => {\n+                ExprBinary(binop,\n+                        folder.fold_expr(lhs),\n+                        folder.fold_expr(rhs))\n+            }\n+            ExprUnary(binop, ohs) => {\n+                ExprUnary(binop, folder.fold_expr(ohs))\n+            }\n+            ExprLit(l) => ExprLit(l),\n+            ExprCast(expr, ty) => {\n+                ExprCast(folder.fold_expr(expr), folder.fold_ty(ty))\n+            }\n+            ExprAddrOf(m, ohs) => ExprAddrOf(m, folder.fold_expr(ohs)),\n+            ExprIf(cond, tr, fl) => {\n+                ExprIf(folder.fold_expr(cond),\n+                       folder.fold_block(tr),\n+                       fl.map(|x| folder.fold_expr(x)))\n+            }\n+            ExprWhile(cond, body, opt_ident) => {\n+                ExprWhile(folder.fold_expr(cond),\n+                          folder.fold_block(body),\n+                          opt_ident.map(|i| folder.fold_ident(i)))\n+            }\n+            ExprForLoop(pat, iter, body, opt_ident) => {\n+                ExprForLoop(folder.fold_pat(pat),\n+                            folder.fold_expr(iter),\n+                            folder.fold_block(body),\n+                            opt_ident.map(|i| folder.fold_ident(i)))\n+            }\n+            ExprLoop(body, opt_ident) => {\n+                ExprLoop(folder.fold_block(body),\n                         opt_ident.map(|i| folder.fold_ident(i)))\n-        }\n-        ExprLoop(body, opt_ident) => {\n-            ExprLoop(folder.fold_block(body),\n-                     opt_ident.map(|i| folder.fold_ident(i)))\n-        }\n-        ExprMatch(expr, ref arms) => {\n-            ExprMatch(folder.fold_expr(expr),\n-                      arms.iter().map(|x| folder.fold_arm(x)).collect())\n-        }\n-        ExprFnBlock(capture_clause, ref decl, ref body) => {\n-            ExprFnBlock(capture_clause,\n-                        folder.fold_fn_decl(&**decl),\n-                        folder.fold_block(body.clone()))\n-        }\n-        ExprProc(ref decl, ref body) => {\n-            ExprProc(folder.fold_fn_decl(&**decl),\n-                     folder.fold_block(body.clone()))\n-        }\n-        ExprUnboxedFn(capture_clause, kind, ref decl, ref body) => {\n-            ExprUnboxedFn(capture_clause,\n-                          kind,\n-                          folder.fold_fn_decl(&**decl),\n-                          folder.fold_block(*body))\n-        }\n-        ExprBlock(ref blk) => ExprBlock(folder.fold_block(*blk)),\n-        ExprAssign(el, er) => {\n-            ExprAssign(folder.fold_expr(el), folder.fold_expr(er))\n-        }\n-        ExprAssignOp(op, el, er) => {\n-            ExprAssignOp(op,\n-                         folder.fold_expr(el),\n-                         folder.fold_expr(er))\n-        }\n-        ExprField(el, id, ref tys) => {\n-            ExprField(folder.fold_expr(el),\n-                      respan(id.span, folder.fold_ident(id.node)),\n-                      tys.iter().map(|&x| folder.fold_ty(x)).collect())\n-        }\n-        ExprTupField(el, id, ref tys) => {\n-            ExprTupField(folder.fold_expr(el),\n-                      respan(id.span, folder.fold_uint(id.node)),\n-                      tys.iter().map(|&x| folder.fold_ty(x)).collect())\n-        }\n-        ExprIndex(el, er) => {\n-            ExprIndex(folder.fold_expr(el), folder.fold_expr(er))\n-        }\n-        ExprPath(ref pth) => ExprPath(folder.fold_path(pth)),\n-        ExprBreak(opt_ident) => ExprBreak(opt_ident.map(|x| folder.fold_ident(x))),\n-        ExprAgain(opt_ident) => ExprAgain(opt_ident.map(|x| folder.fold_ident(x))),\n-        ExprRet(ref e) => {\n-            ExprRet(e.map(|x| folder.fold_expr(x)))\n-        }\n-        ExprInlineAsm(ref a) => {\n+            }\n+            ExprMatch(expr, arms) => {\n+                ExprMatch(folder.fold_expr(expr),\n+                        arms.move_map(|x| folder.fold_arm(x)))\n+            }\n+            ExprFnBlock(capture_clause, decl, body) => {\n+                ExprFnBlock(capture_clause,\n+                            folder.fold_fn_decl(decl),\n+                            folder.fold_block(body))\n+            }\n+            ExprProc(decl, body) => {\n+                ExprProc(folder.fold_fn_decl(decl),\n+                         folder.fold_block(body))\n+            }\n+            ExprUnboxedFn(capture_clause, kind, decl, body) => {\n+                ExprUnboxedFn(capture_clause,\n+                            kind,\n+                            folder.fold_fn_decl(decl),\n+                            folder.fold_block(body))\n+            }\n+            ExprBlock(blk) => ExprBlock(folder.fold_block(blk)),\n+            ExprAssign(el, er) => {\n+                ExprAssign(folder.fold_expr(el), folder.fold_expr(er))\n+            }\n+            ExprAssignOp(op, el, er) => {\n+                ExprAssignOp(op,\n+                            folder.fold_expr(el),\n+                            folder.fold_expr(er))\n+            }\n+            ExprField(el, ident, tys) => {\n+                ExprField(folder.fold_expr(el),\n+                          respan(ident.span, folder.fold_ident(ident.node)),\n+                          tys.move_map(|x| folder.fold_ty(x)))\n+            }\n+            ExprTupField(el, ident, tys) => {\n+                ExprTupField(folder.fold_expr(el),\n+                             respan(ident.span, folder.fold_uint(ident.node)),\n+                             tys.move_map(|x| folder.fold_ty(x)))\n+            }\n+            ExprIndex(el, er) => {\n+                ExprIndex(folder.fold_expr(el), folder.fold_expr(er))\n+            }\n+            ExprPath(pth) => ExprPath(folder.fold_path(pth)),\n+            ExprBreak(opt_ident) => ExprBreak(opt_ident.map(|x| folder.fold_ident(x))),\n+            ExprAgain(opt_ident) => ExprAgain(opt_ident.map(|x| folder.fold_ident(x))),\n+            ExprRet(e) => ExprRet(e.map(|x| folder.fold_expr(x))),\n             ExprInlineAsm(InlineAsm {\n-                inputs: a.inputs.iter().map(|&(ref c, input)| {\n-                    ((*c).clone(), folder.fold_expr(input))\n-                }).collect(),\n-                outputs: a.outputs.iter().map(|&(ref c, out, is_rw)| {\n-                    ((*c).clone(), folder.fold_expr(out), is_rw)\n-                }).collect(),\n-                .. (*a).clone()\n-            })\n-        }\n-        ExprMac(ref mac) => ExprMac(folder.fold_mac(mac)),\n-        ExprStruct(ref path, ref fields, maybe_expr) => {\n-            ExprStruct(folder.fold_path(path),\n-                       fields.iter().map(|x| folder.fold_field(*x)).collect(),\n-                       maybe_expr.map(|x| folder.fold_expr(x)))\n+                inputs,\n+                outputs,\n+                asm,\n+                asm_str_style,\n+                clobbers,\n+                volatile,\n+                alignstack,\n+                dialect\n+            }) => ExprInlineAsm(InlineAsm {\n+                inputs: inputs.move_map(|(c, input)| {\n+                    (c, folder.fold_expr(input))\n+                }),\n+                outputs: outputs.move_map(|(c, out, is_rw)| {\n+                    (c, folder.fold_expr(out), is_rw)\n+                }),\n+                asm: asm,\n+                asm_str_style: asm_str_style,\n+                clobbers: clobbers,\n+                volatile: volatile,\n+                alignstack: alignstack,\n+                dialect: dialect\n+            }),\n+            ExprMac(mac) => ExprMac(folder.fold_mac(mac)),\n+            ExprStruct(path, fields, maybe_expr) => {\n+                ExprStruct(folder.fold_path(path),\n+                        fields.move_map(|x| folder.fold_field(x)),\n+                        maybe_expr.map(|x| folder.fold_expr(x)))\n+            },\n+            ExprParen(ex) => ExprParen(folder.fold_expr(ex))\n         },\n-        ExprParen(ex) => ExprParen(folder.fold_expr(ex))\n-    };\n-\n-    box(GC) Expr {\n-        id: id,\n-        node: node,\n-        span: folder.new_span(e.span),\n+        span: folder.new_span(span)\n     }\n }\n \n-pub fn noop_fold_stmt<T: Folder>(s: &Stmt,\n-                                 folder: &mut T) -> SmallVector<Gc<Stmt>> {\n-    let nodes = match s.node {\n+pub fn noop_fold_stmt<T: Folder>(Spanned {node, span}: Stmt, folder: &mut T)\n+                                 -> SmallVector<P<Stmt>> {\n+    let span = folder.new_span(span);\n+    match node {\n         StmtDecl(d, id) => {\n             let id = folder.new_id(id);\n-            folder.fold_decl(d).move_iter()\n-                    .map(|d| StmtDecl(d, id))\n-                    .collect()\n+            folder.fold_decl(d).move_iter().map(|d| P(Spanned {\n+                node: StmtDecl(d, id),\n+                span: span\n+            })).collect()\n         }\n         StmtExpr(e, id) => {\n             let id = folder.new_id(id);\n-            SmallVector::one(StmtExpr(folder.fold_expr(e), id))\n+            SmallVector::one(P(Spanned {\n+                node: StmtExpr(folder.fold_expr(e), id),\n+                span: span\n+            }))\n         }\n         StmtSemi(e, id) => {\n             let id = folder.new_id(id);\n-            SmallVector::one(StmtSemi(folder.fold_expr(e), id))\n+            SmallVector::one(P(Spanned {\n+                node: StmtSemi(folder.fold_expr(e), id),\n+                span: span\n+            }))\n         }\n-        StmtMac(ref mac, semi) => SmallVector::one(StmtMac(folder.fold_mac(mac), semi))\n-    };\n-\n-    nodes.move_iter().map(|node| box(GC) Spanned {\n-        node: node,\n-        span: folder.new_span(s.span),\n-    }).collect()\n+        StmtMac(mac, semi) => SmallVector::one(P(Spanned {\n+            node: StmtMac(folder.fold_mac(mac), semi),\n+            span: span\n+        }))\n+    }\n }\n \n #[cfg(test)]\n@@ -1278,7 +1243,7 @@ mod test {\n         fn fold_ident(&mut self, _: ast::Ident) -> ast::Ident {\n             token::str_to_ident(\"zz\")\n         }\n-        fn fold_mac(&mut self, macro: &ast::Mac) -> ast::Mac {\n+        fn fold_mac(&mut self, macro: ast::Mac) -> ast::Mac {\n             fold::noop_fold_mac(macro, self)\n         }\n     }"}, {"sha": "146b5a5b34865670df3437d7fc281a9d7bd3a80d", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -27,6 +27,7 @@\n #![feature(quote, struct_variant, unsafe_destructor, import_shadowing)]\n #![allow(deprecated)]\n \n+extern crate arena;\n extern crate fmt_macros;\n extern crate debug;\n #[phase(plugin, link)] extern crate log;\n@@ -63,6 +64,7 @@ pub mod diagnostic;\n pub mod fold;\n pub mod owned_slice;\n pub mod parse;\n+pub mod ptr;\n pub mod visit;\n \n pub mod print {"}, {"sha": "7d8a9e08ba02b9b687194017ba8702b0db20ecb8", "filename": "src/libsyntax/owned_slice.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fowned_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fowned_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fowned_slice.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -11,7 +11,7 @@\n use std::fmt;\n use std::default::Default;\n use std::hash;\n-use std::{mem, raw, ptr, slice};\n+use std::{mem, raw, ptr, slice, vec};\n use serialize::{Encodable, Decodable, Encoder, Decoder};\n \n /// A non-growable owned slice. This would preferably become `~[T]`\n@@ -105,6 +105,10 @@ impl<T> OwnedSlice<T> {\n         self.as_slice().iter()\n     }\n \n+    pub fn move_iter(self) -> vec::MoveItems<T> {\n+        self.into_vec().move_iter()\n+    }\n+\n     pub fn map<U>(&self, f: |&T| -> U) -> OwnedSlice<U> {\n         self.iter().map(f).collect()\n     }"}, {"sha": "74b93e75e64dd88bc54920fa4282f5813cb4cc62", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -15,18 +15,17 @@ use parse::common::*; //resolve bug?\n use parse::token;\n use parse::parser::Parser;\n use parse::token::INTERPOLATED;\n-\n-use std::gc::{Gc, GC};\n+use ptr::P;\n \n /// A parser that can parse attributes.\n pub trait ParserAttr {\n     fn parse_outer_attributes(&mut self) -> Vec<ast::Attribute>;\n     fn parse_attribute(&mut self, permit_inner: bool) -> ast::Attribute;\n     fn parse_inner_attrs_and_next(&mut self)\n                                   -> (Vec<ast::Attribute>, Vec<ast::Attribute>);\n-    fn parse_meta_item(&mut self) -> Gc<ast::MetaItem>;\n-    fn parse_meta_seq(&mut self) -> Vec<Gc<ast::MetaItem>>;\n-    fn parse_optional_meta(&mut self) -> Vec<Gc<ast::MetaItem>>;\n+    fn parse_meta_item(&mut self) -> P<ast::MetaItem>;\n+    fn parse_meta_seq(&mut self) -> Vec<P<ast::MetaItem>>;\n+    fn parse_optional_meta(&mut self) -> Vec<P<ast::MetaItem>>;\n }\n \n impl<'a> ParserAttr for Parser<'a> {\n@@ -160,13 +159,20 @@ impl<'a> ParserAttr for Parser<'a> {\n     /// matches meta_item = IDENT\n     /// | IDENT = lit\n     /// | IDENT meta_seq\n-    fn parse_meta_item(&mut self) -> Gc<ast::MetaItem> {\n-        match self.token {\n-            token::INTERPOLATED(token::NtMeta(e)) => {\n+    fn parse_meta_item(&mut self) -> P<ast::MetaItem> {\n+        let nt_meta = match self.token {\n+            token::INTERPOLATED(token::NtMeta(ref e)) => {\n+                Some(e.clone())\n+            }\n+            _ => None\n+        };\n+\n+        match nt_meta {\n+            Some(meta) => {\n                 self.bump();\n-                return e\n+                return meta;\n             }\n-            _ => {}\n+            None => {}\n         }\n \n         let lo = self.span.lo;\n@@ -187,29 +193,29 @@ impl<'a> ParserAttr for Parser<'a> {\n                     }\n                 }\n                 let hi = self.span.hi;\n-                box(GC) spanned(lo, hi, ast::MetaNameValue(name, lit))\n+                P(spanned(lo, hi, ast::MetaNameValue(name, lit)))\n             }\n             token::LPAREN => {\n                 let inner_items = self.parse_meta_seq();\n                 let hi = self.span.hi;\n-                box(GC) spanned(lo, hi, ast::MetaList(name, inner_items))\n+                P(spanned(lo, hi, ast::MetaList(name, inner_items)))\n             }\n             _ => {\n                 let hi = self.last_span.hi;\n-                box(GC) spanned(lo, hi, ast::MetaWord(name))\n+                P(spanned(lo, hi, ast::MetaWord(name)))\n             }\n         }\n     }\n \n     /// matches meta_seq = ( COMMASEP(meta_item) )\n-    fn parse_meta_seq(&mut self) -> Vec<Gc<ast::MetaItem>> {\n+    fn parse_meta_seq(&mut self) -> Vec<P<ast::MetaItem>> {\n         self.parse_seq(&token::LPAREN,\n                        &token::RPAREN,\n                        seq_sep_trailing_disallowed(token::COMMA),\n                        |p| p.parse_meta_item()).node\n     }\n \n-    fn parse_optional_meta(&mut self) -> Vec<Gc<ast::MetaItem>> {\n+    fn parse_optional_meta(&mut self) -> Vec<P<ast::MetaItem>> {\n         match self.token {\n             token::LPAREN => self.parse_meta_seq(),\n             _ => Vec::new()"}, {"sha": "cdd221aca7cf01b72a94b2a255379af8682f5466", "filename": "src/libsyntax/parse/classify.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fparse%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fparse%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fclassify.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -13,7 +13,6 @@\n // Predicates on exprs and stmts that the pretty-printer and parser use\n \n use ast;\n-use std::gc::Gc;\n \n /// Does this expression require a semicolon to be treated\n /// as a statement? The negation of this: 'can this expression\n@@ -22,7 +21,7 @@ use std::gc::Gc;\n ///     if true {...} else {...}\n ///      |x| 5\n /// isn't parsed as (if true {...} else {...} | x) | 5\n-pub fn expr_requires_semi_to_be_stmt(e: Gc<ast::Expr>) -> bool {\n+pub fn expr_requires_semi_to_be_stmt(e: &ast::Expr) -> bool {\n     match e.node {\n         ast::ExprIf(..)\n         | ast::ExprMatch(..)\n@@ -34,25 +33,25 @@ pub fn expr_requires_semi_to_be_stmt(e: Gc<ast::Expr>) -> bool {\n     }\n }\n \n-pub fn expr_is_simple_block(e: Gc<ast::Expr>) -> bool {\n+pub fn expr_is_simple_block(e: &ast::Expr) -> bool {\n     match e.node {\n-        ast::ExprBlock(block) => block.rules == ast::DefaultBlock,\n-      _ => false\n+        ast::ExprBlock(ref block) => block.rules == ast::DefaultBlock,\n+        _ => false\n     }\n }\n \n /// this statement requires a semicolon after it.\n /// note that in one case (stmt_semi), we've already\n /// seen the semicolon, and thus don't need another.\n-pub fn stmt_ends_with_semi(stmt: &ast::Stmt) -> bool {\n-    return match stmt.node {\n-        ast::StmtDecl(d, _) => {\n+pub fn stmt_ends_with_semi(stmt: &ast::Stmt_) -> bool {\n+    match *stmt {\n+        ast::StmtDecl(ref d, _) => {\n             match d.node {\n                 ast::DeclLocal(_) => true,\n                 ast::DeclItem(_) => false\n             }\n         }\n-        ast::StmtExpr(e, _) => { expr_requires_semi_to_be_stmt(e) }\n+        ast::StmtExpr(ref e, _) => { expr_requires_semi_to_be_stmt(&**e) }\n         ast::StmtSemi(..) => { false }\n         ast::StmtMac(..) => { false }\n     }"}, {"sha": "e5b6359000b6c1647dc69d6395e51be1f12ec8c0", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -15,9 +15,9 @@ use codemap::{Span, CodeMap, FileMap};\n use diagnostic::{SpanHandler, mk_span_handler, default_handler, Auto};\n use parse::attr::ParserAttr;\n use parse::parser::Parser;\n+use ptr::P;\n \n use std::cell::RefCell;\n-use std::gc::Gc;\n use std::io::File;\n use std::rc::Rc;\n use std::str;\n@@ -106,7 +106,7 @@ pub fn parse_expr_from_source_str(name: String,\n                                   source: String,\n                                   cfg: ast::CrateConfig,\n                                   sess: &ParseSess)\n-                                  -> Gc<ast::Expr> {\n+                                  -> P<ast::Expr> {\n     let mut p = new_parser_from_source_str(sess, cfg, name, source);\n     maybe_aborted(p.parse_expr(), p)\n }\n@@ -115,7 +115,7 @@ pub fn parse_item_from_source_str(name: String,\n                                   source: String,\n                                   cfg: ast::CrateConfig,\n                                   sess: &ParseSess)\n-                                  -> Option<Gc<ast::Item>> {\n+                                  -> Option<P<ast::Item>> {\n     let mut p = new_parser_from_source_str(sess, cfg, name, source);\n     maybe_aborted(p.parse_item_with_outer_attributes(),p)\n }\n@@ -124,7 +124,7 @@ pub fn parse_meta_from_source_str(name: String,\n                                   source: String,\n                                   cfg: ast::CrateConfig,\n                                   sess: &ParseSess)\n-                                  -> Gc<ast::MetaItem> {\n+                                  -> P<ast::MetaItem> {\n     let mut p = new_parser_from_source_str(sess, cfg, name, source);\n     maybe_aborted(p.parse_meta_item(),p)\n }\n@@ -134,7 +134,7 @@ pub fn parse_stmt_from_source_str(name: String,\n                                   cfg: ast::CrateConfig,\n                                   attrs: Vec<ast::Attribute> ,\n                                   sess: &ParseSess)\n-                                  -> Gc<ast::Stmt> {\n+                                  -> P<ast::Stmt> {\n     let mut p = new_parser_from_source_str(\n         sess,\n         cfg,\n@@ -702,7 +702,6 @@ pub fn integer_lit(s: &str, sd: &SpanHandler, sp: Span) -> ast::Lit_ {\n mod test {\n     use super::*;\n     use serialize::json;\n-    use std::gc::GC;\n     use codemap::{Span, BytePos, Spanned};\n     use owned_slice::OwnedSlice;\n     use ast;\n@@ -711,6 +710,7 @@ mod test {\n     use attr::AttrMetaMethods;\n     use parse::parser::Parser;\n     use parse::token::{str_to_ident};\n+    use ptr::P;\n     use util::parser_testing::{string_to_tts, string_to_parser};\n     use util::parser_testing::{string_to_expr, string_to_item};\n     use util::parser_testing::string_to_stmt;\n@@ -722,7 +722,7 @@ mod test {\n \n     #[test] fn path_exprs_1() {\n         assert!(string_to_expr(\"a\".to_string()) ==\n-                   box(GC) ast::Expr{\n+                   P(ast::Expr{\n                     id: ast::DUMMY_NODE_ID,\n                     node: ast::ExprPath(ast::Path {\n                         span: sp(0, 1),\n@@ -736,12 +736,12 @@ mod test {\n                         ),\n                     }),\n                     span: sp(0, 1)\n-                   })\n+                   }))\n     }\n \n     #[test] fn path_exprs_2 () {\n         assert!(string_to_expr(\"::a::b\".to_string()) ==\n-                   box(GC) ast::Expr {\n+                   P(ast::Expr {\n                     id: ast::DUMMY_NODE_ID,\n                     node: ast::ExprPath(ast::Path {\n                             span: sp(0, 6),\n@@ -760,7 +760,7 @@ mod test {\n                             )\n                         }),\n                     span: sp(0, 6)\n-                   })\n+                   }))\n     }\n \n     #[should_fail]\n@@ -953,9 +953,9 @@ mod test {\n \n     #[test] fn ret_expr() {\n         assert!(string_to_expr(\"return d\".to_string()) ==\n-                   box(GC) ast::Expr{\n+                   P(ast::Expr{\n                     id: ast::DUMMY_NODE_ID,\n-                    node:ast::ExprRet(Some(box(GC) ast::Expr{\n+                    node:ast::ExprRet(Some(P(ast::Expr{\n                         id: ast::DUMMY_NODE_ID,\n                         node:ast::ExprPath(ast::Path{\n                             span: sp(7, 8),\n@@ -969,15 +969,15 @@ mod test {\n                             ),\n                         }),\n                         span:sp(7,8)\n-                    })),\n+                    }))),\n                     span:sp(0,8)\n-                   })\n+                   }))\n     }\n \n     #[test] fn parse_stmt_1 () {\n         assert!(string_to_stmt(\"b;\".to_string()) ==\n-                   box(GC) Spanned{\n-                       node: ast::StmtExpr(box(GC) ast::Expr {\n+                   P(Spanned{\n+                       node: ast::StmtExpr(P(ast::Expr {\n                            id: ast::DUMMY_NODE_ID,\n                            node: ast::ExprPath(ast::Path {\n                                span:sp(0,1),\n@@ -990,9 +990,9 @@ mod test {\n                                 }\n                                ),\n                             }),\n-                           span: sp(0,1)},\n+                           span: sp(0,1)}),\n                                            ast::DUMMY_NODE_ID),\n-                       span: sp(0,1)})\n+                       span: sp(0,1)}))\n \n     }\n \n@@ -1004,14 +1004,14 @@ mod test {\n         let sess = new_parse_sess();\n         let mut parser = string_to_parser(&sess, \"b\".to_string());\n         assert!(parser.parse_pat()\n-                == box(GC) ast::Pat{\n+                == P(ast::Pat{\n                 id: ast::DUMMY_NODE_ID,\n                 node: ast::PatIdent(ast::BindByValue(ast::MutImmutable),\n                                     Spanned{ span:sp(0, 1),\n                                              node: str_to_ident(\"b\")\n                     },\n                                     None),\n-                span: sp(0,1)});\n+                span: sp(0,1)}));\n         parser_done(parser);\n     }\n \n@@ -1020,13 +1020,13 @@ mod test {\n         // this test depends on the intern order of \"fn\" and \"int\"\n         assert!(string_to_item(\"fn a (b : int) { b; }\".to_string()) ==\n                   Some(\n-                      box(GC) ast::Item{ident:str_to_ident(\"a\"),\n+                      P(ast::Item{ident:str_to_ident(\"a\"),\n                             attrs:Vec::new(),\n                             id: ast::DUMMY_NODE_ID,\n-                            node: ast::ItemFn(ast::P(ast::FnDecl {\n+                            node: ast::ItemFn(P(ast::FnDecl {\n                                 inputs: vec!(ast::Arg{\n-                                    ty: ast::P(ast::Ty{id: ast::DUMMY_NODE_ID,\n-                                                       node: ast::TyPath(ast::Path{\n+                                    ty: P(ast::Ty{id: ast::DUMMY_NODE_ID,\n+                                                  node: ast::TyPath(ast::Path{\n                                         span:sp(10,13),\n                                         global:false,\n                                         segments: vec!(\n@@ -1040,7 +1040,7 @@ mod test {\n                                         }, None, ast::DUMMY_NODE_ID),\n                                         span:sp(10,13)\n                                     }),\n-                                    pat: box(GC) ast::Pat {\n+                                    pat: P(ast::Pat {\n                                         id: ast::DUMMY_NODE_ID,\n                                         node: ast::PatIdent(\n                                             ast::BindByValue(ast::MutImmutable),\n@@ -1050,12 +1050,12 @@ mod test {\n                                                 None\n                                                     ),\n                                             span: sp(6,7)\n-                                        },\n+                                    }),\n                                         id: ast::DUMMY_NODE_ID\n                                     }),\n-                                output: ast::P(ast::Ty{id: ast::DUMMY_NODE_ID,\n-                                                       node: ast::TyNil,\n-                                                       span:sp(15,15)}), // not sure\n+                                output: P(ast::Ty{id: ast::DUMMY_NODE_ID,\n+                                                  node: ast::TyNil,\n+                                                  span:sp(15,15)}), // not sure\n                                 cf: ast::Return,\n                                 variadic: false\n                             }),\n@@ -1069,10 +1069,10 @@ mod test {\n                                             predicates: Vec::new(),\n                                         }\n                                     },\n-                                    ast::P(ast::Block {\n+                                    P(ast::Block {\n                                         view_items: Vec::new(),\n-                                        stmts: vec!(box(GC) Spanned{\n-                                            node: ast::StmtSemi(box(GC) ast::Expr{\n+                                        stmts: vec!(P(Spanned{\n+                                            node: ast::StmtSemi(P(ast::Expr{\n                                                 id: ast::DUMMY_NODE_ID,\n                                                 node: ast::ExprPath(\n                                                       ast::Path{\n@@ -1090,28 +1090,28 @@ mod test {\n                                                             }\n                                                         ),\n                                                       }),\n-                                                span: sp(17,18)},\n+                                                span: sp(17,18)}),\n                                                 ast::DUMMY_NODE_ID),\n-                                            span: sp(17,19)}),\n+                                            span: sp(17,19)})),\n                                         expr: None,\n                                         id: ast::DUMMY_NODE_ID,\n                                         rules: ast::DefaultBlock, // no idea\n                                         span: sp(15,21),\n                                     })),\n                             vis: ast::Inherited,\n-                            span: sp(0,21)}));\n+                            span: sp(0,21)})));\n     }\n \n \n     #[test] fn parse_exprs () {\n         // just make sure that they parse....\n         string_to_expr(\"3 + 4\".to_string());\n-        string_to_expr(\"a::z.froob(b,box(GC)(987+3))\".to_string());\n+        string_to_expr(\"a::z.froob(b,&(987+3))\".to_string());\n     }\n \n     #[test] fn attrs_fix_bug () {\n         string_to_item(\"pub fn mk_file_writer(path: &Path, flags: &[FileFlag])\n-                   -> Result<Gc<Writer>, String> {\n+                   -> Result<Box<Writer>, String> {\n     #[cfg(windows)]\n     fn wb() -> c_int {\n       (O_WRONLY | libc::consts::os::extra::O_BINARY) as c_int"}, {"sha": "d47231bc3e2de5ea25b6b1df8d908fa4382f6c35", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=19311b6103b49232709d301af4036dbc0021082c", "patch": "@@ -21,8 +21,7 @@ use ast::{Expr, ExprLit, LitNil};\n use codemap::{Span, respan};\n use parse::parser;\n use parse::token;\n-\n-use std::gc::{Gc, GC};\n+use ptr::P;\n \n /// The specific types of unsupported syntax\n #[deriving(PartialEq, Eq, Hash)]\n@@ -44,7 +43,7 @@ pub trait ParserObsoleteMethods {\n     fn obsolete(&mut self, sp: Span, kind: ObsoleteSyntax);\n     /// Reports an obsolete syntax non-fatal error, and returns\n     /// a placeholder expression\n-    fn obsolete_expr(&mut self, sp: Span, kind: ObsoleteSyntax) -> Gc<Expr>;\n+    fn obsolete_expr(&mut self, sp: Span, kind: ObsoleteSyntax) -> P<Expr>;\n     fn report(&mut self,\n               sp: Span,\n               kind: ObsoleteSyntax,\n@@ -105,9 +104,9 @@ impl<'a> ParserObsoleteMethods for parser::Parser<'a> {\n \n     /// Reports an obsolete syntax non-fatal error, and returns\n     /// a placeholder expression\n-    fn obsolete_expr(&mut self, sp: Span, kind: ObsoleteSyntax) -> Gc<Expr> {\n+    fn obsolete_expr(&mut self, sp: Span, kind: ObsoleteSyntax) -> P<Expr> {\n         self.obsolete(sp, kind);\n-        self.mk_expr(sp.lo, sp.hi, ExprLit(box(GC) respan(sp, LitNil)))\n+        self.mk_expr(sp.lo, sp.hi, ExprLit(P(respan(sp, LitNil))))\n     }\n \n     fn report(&mut self,"}, {"sha": "f41362cad418513d1fab2c1f4feb1e7214767a89", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=19311b6103b49232709d301af4036dbc0021082c"}, {"sha": "f113e0e6cff75714709fd0a05fdd38df77d49fae", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=19311b6103b49232709d301af4036dbc0021082c"}, {"sha": "d0df95d711ee407abad10bdbd5bd318eeeb13e7c", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 57, "deletions": 62, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=19311b6103b49232709d301af4036dbc0021082c"}, {"sha": "bd560abf3bda70d46bf7e30671def56a3a143fe0", "filename": "src/libsyntax/ptr.rs", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fptr.rs?ref=19311b6103b49232709d301af4036dbc0021082c"}, {"sha": "d0faa3c682064029ecec220d2858ffd5f35b0b4b", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=19311b6103b49232709d301af4036dbc0021082c"}, {"sha": "47aef987a63d04426428acede8c63fd942a562c6", "filename": "src/libsyntax/util/small_vector.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fsmall_vector.rs?ref=19311b6103b49232709d301af4036dbc0021082c"}, {"sha": "30a38e28729f0f6008e8adda4242b6ec2ac31709", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=19311b6103b49232709d301af4036dbc0021082c"}, {"sha": "dd1f9c3404f029831e90cb11c07db2e12a4238b9", "filename": "src/test/auxiliary/macro_crate_test.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs?ref=19311b6103b49232709d301af4036dbc0021082c"}, {"sha": "b7c4c14638226e23a56fc2a73987e0ce3655ff68", "filename": "src/test/run-pass-fulldeps/quote-tokens.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/19311b6103b49232709d301af4036dbc0021082c/src%2Ftest%2Frun-pass-fulldeps%2Fquote-tokens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19311b6103b49232709d301af4036dbc0021082c/src%2Ftest%2Frun-pass-fulldeps%2Fquote-tokens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fquote-tokens.rs?ref=19311b6103b49232709d301af4036dbc0021082c"}]}