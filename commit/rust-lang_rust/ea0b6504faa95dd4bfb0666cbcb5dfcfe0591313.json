{"sha": "ea0b6504faa95dd4bfb0666cbcb5dfcfe0591313", "node_id": "C_kwDOAAsO6NoAKGVhMGI2NTA0ZmFhOTVkZDRiZmIwNjY2Y2JjYjVkZmNmZTA1OTEzMTM", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-05-04T17:18:21Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-05-04T17:18:21Z"}, "message": "Rollup merge of #111009 - scottmcm:ascii-char, r=BurntSushi\n\nAdd `ascii::Char` (ACP#179)\n\nACP second: https://github.com/rust-lang/libs-team/issues/179#issuecomment-1527900570\nNew tracking issue: https://github.com/rust-lang/rust/issues/110998\n\nFor now this is an `enum` as `@kupiakos` [suggested](https://github.com/rust-lang/libs-team/issues/179#issuecomment-1527959724), with the variants under a different feature flag.\n\nThere's lots more things that could be added here, and place for further doc updates, but this seems like a plausible starting point PR.\n\nI've gone through and put an `as_ascii` next to every `is_ascii`: on `u8`, `char`, `[u8]`, and `str`.\n\nAs a demonstration, made a commit updating some formatting code to use this: https://github.com/scottmcm/rust/commit/ascii-char-in-fmt (I don't want to include that in this PR, though, because that brings in perf questions that don't exist if this is just adding new unstable APIs.)", "tree": {"sha": "fa4ad464202284442a0b227f262f6a048b006040", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa4ad464202284442a0b227f262f6a048b006040"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ea0b6504faa95dd4bfb0666cbcb5dfcfe0591313", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkU+jdCRBK7hj4Ov3rIwAAvdEIACMCGCiMGUJMVNfHd20zL/ML\nlprenLstE4YACGV9f1m94h11znYWIDHnsI9eGnyc458vWzEuhcN/8LmB/+ABQGLv\nSxb22+HJh4edsKyefI1F6yCOYvkmrqWs09TmFP/Gd6W5Qgtu7+7Gvur1L6KWM8sR\nWF+sxbugDWIL/dCGadqUeliRggV+Mi6ZxqFwqiTUFibW+fE2uCd3nO2TPzxqdjoQ\nUoliIYgxpngAxGEV5U2ekyNEsuUsAK71PJUV7kqdrHfPQIidgSC9h35zntukacKe\nYa8dlB9PjHeKYGBqlCoTBtUO6ZsQCn7JHh1Q/OJO04z7krtE1in88gl2B4E5qnA=\n=wlR8\n-----END PGP SIGNATURE-----\n", "payload": "tree fa4ad464202284442a0b227f262f6a048b006040\nparent 8d66f01ab50870c63f85c3c7395347e5b82caa88\nparent 8c781b0906209e81f3540d1495becddae9894a25\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1683220701 +0200\ncommitter GitHub <noreply@github.com> 1683220701 +0200\n\nRollup merge of #111009 - scottmcm:ascii-char, r=BurntSushi\n\nAdd `ascii::Char` (ACP#179)\n\nACP second: https://github.com/rust-lang/libs-team/issues/179#issuecomment-1527900570\nNew tracking issue: https://github.com/rust-lang/rust/issues/110998\n\nFor now this is an `enum` as `@kupiakos` [suggested](https://github.com/rust-lang/libs-team/issues/179#issuecomment-1527959724), with the variants under a different feature flag.\n\nThere's lots more things that could be added here, and place for further doc updates, but this seems like a plausible starting point PR.\n\nI've gone through and put an `as_ascii` next to every `is_ascii`: on `u8`, `char`, `[u8]`, and `str`.\n\nAs a demonstration, made a commit updating some formatting code to use this: https://github.com/scottmcm/rust/commit/ascii-char-in-fmt (I don't want to include that in this PR, though, because that brings in perf questions that don't exist if this is just adding new unstable APIs.)\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ea0b6504faa95dd4bfb0666cbcb5dfcfe0591313", "html_url": "https://github.com/rust-lang/rust/commit/ea0b6504faa95dd4bfb0666cbcb5dfcfe0591313", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ea0b6504faa95dd4bfb0666cbcb5dfcfe0591313/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8d66f01ab50870c63f85c3c7395347e5b82caa88", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d66f01ab50870c63f85c3c7395347e5b82caa88", "html_url": "https://github.com/rust-lang/rust/commit/8d66f01ab50870c63f85c3c7395347e5b82caa88"}, {"sha": "8c781b0906209e81f3540d1495becddae9894a25", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c781b0906209e81f3540d1495becddae9894a25", "html_url": "https://github.com/rust-lang/rust/commit/8c781b0906209e81f3540d1495becddae9894a25"}], "stats": {"total": 725, "additions": 724, "deletions": 1}, "files": [{"sha": "18f25aec5feee85515806213714d6389b2487b4d", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ea0b6504faa95dd4bfb0666cbcb5dfcfe0591313/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0b6504faa95dd4bfb0666cbcb5dfcfe0591313/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=ea0b6504faa95dd4bfb0666cbcb5dfcfe0591313", "patch": "@@ -101,6 +101,7 @@\n #![feature(array_into_iter_constructors)]\n #![feature(array_methods)]\n #![feature(array_windows)]\n+#![feature(ascii_char)]\n #![feature(assert_matches)]\n #![feature(async_iterator)]\n #![feature(coerce_unsized)]"}, {"sha": "b9ef76c109abf8656b9c1315f174f8640f0cdb81", "filename": "library/alloc/src/string.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ea0b6504faa95dd4bfb0666cbcb5dfcfe0591313/library%2Falloc%2Fsrc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0b6504faa95dd4bfb0666cbcb5dfcfe0591313/library%2Falloc%2Fsrc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fstring.rs?ref=ea0b6504faa95dd4bfb0666cbcb5dfcfe0591313", "patch": "@@ -2526,6 +2526,15 @@ impl<T: fmt::Display + ?Sized> ToString for T {\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n+#[unstable(feature = \"ascii_char\", issue = \"110998\")]\n+impl ToString for core::ascii::Char {\n+    #[inline]\n+    fn to_string(&self) -> String {\n+        self.as_str().to_owned()\n+    }\n+}\n+\n #[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"char_to_string_specialization\", since = \"1.46.0\")]\n impl ToString for char {"}, {"sha": "6750d7c071144f7616236bd4905dc75ce1820d12", "filename": "library/core/src/array/ascii.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ea0b6504faa95dd4bfb0666cbcb5dfcfe0591313/library%2Fcore%2Fsrc%2Farray%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0b6504faa95dd4bfb0666cbcb5dfcfe0591313/library%2Fcore%2Fsrc%2Farray%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fascii.rs?ref=ea0b6504faa95dd4bfb0666cbcb5dfcfe0591313", "patch": "@@ -0,0 +1,34 @@\n+use crate::ascii;\n+\n+#[cfg(not(test))]\n+impl<const N: usize> [u8; N] {\n+    /// Converts this array of bytes into a array of ASCII characters,\n+    /// or returns `None` if any of the characters is non-ASCII.\n+    #[unstable(feature = \"ascii_char\", issue = \"110998\")]\n+    #[must_use]\n+    #[inline]\n+    pub fn as_ascii(&self) -> Option<&[ascii::Char; N]> {\n+        if self.is_ascii() {\n+            // SAFETY: Just checked that it's ASCII\n+            Some(unsafe { self.as_ascii_unchecked() })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Converts this array of bytes into a array of ASCII characters,\n+    /// without checking whether they're valid.\n+    ///\n+    /// # Safety\n+    ///\n+    /// Every byte in the array must be in `0..=127`, or else this is UB.\n+    #[unstable(feature = \"ascii_char\", issue = \"110998\")]\n+    #[must_use]\n+    #[inline]\n+    pub const unsafe fn as_ascii_unchecked(&self) -> &[ascii::Char; N] {\n+        let byte_ptr: *const [u8; N] = self;\n+        let ascii_ptr = byte_ptr as *const [ascii::Char; N];\n+        // SAFETY: The caller promised all the bytes are ASCII\n+        unsafe { &*ascii_ptr }\n+    }\n+}"}, {"sha": "bdb4c975909e0664ec4fcc5938b56338efe80480", "filename": "library/core/src/array/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ea0b6504faa95dd4bfb0666cbcb5dfcfe0591313/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0b6504faa95dd4bfb0666cbcb5dfcfe0591313/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fmod.rs?ref=ea0b6504faa95dd4bfb0666cbcb5dfcfe0591313", "patch": "@@ -17,6 +17,7 @@ use crate::ops::{\n };\n use crate::slice::{Iter, IterMut};\n \n+mod ascii;\n mod drain;\n mod equality;\n mod iter;"}, {"sha": "7fd14a7e1eae8cd73f8d1a5942170aeb485c969d", "filename": "library/core/src/ascii.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ea0b6504faa95dd4bfb0666cbcb5dfcfe0591313/library%2Fcore%2Fsrc%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0b6504faa95dd4bfb0666cbcb5dfcfe0591313/library%2Fcore%2Fsrc%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fascii.rs?ref=ea0b6504faa95dd4bfb0666cbcb5dfcfe0591313", "patch": "@@ -14,6 +14,10 @@ use crate::fmt;\n use crate::iter::FusedIterator;\n use crate::num::NonZeroUsize;\n \n+mod ascii_char;\n+#[unstable(feature = \"ascii_char\", issue = \"110998\")]\n+pub use ascii_char::AsciiChar as Char;\n+\n /// An iterator over the escaped version of a byte.\n ///\n /// This `struct` is created by the [`escape_default`] function. See its"}, {"sha": "f093a0990d1a90ff1e93d7e74dfceb12d38ef36c", "filename": "library/core/src/ascii/ascii_char.rs", "status": "added", "additions": 565, "deletions": 0, "changes": 565, "blob_url": "https://github.com/rust-lang/rust/blob/ea0b6504faa95dd4bfb0666cbcb5dfcfe0591313/library%2Fcore%2Fsrc%2Fascii%2Fascii_char.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0b6504faa95dd4bfb0666cbcb5dfcfe0591313/library%2Fcore%2Fsrc%2Fascii%2Fascii_char.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fascii%2Fascii_char.rs?ref=ea0b6504faa95dd4bfb0666cbcb5dfcfe0591313", "patch": "@@ -0,0 +1,565 @@\n+//! This uses the name `AsciiChar`, even though it's not exposed that way right now,\n+//! because it avoids a whole bunch of \"are you sure you didn't mean `char`?\"\n+//! suggestions from rustc if you get anything slightly wrong in here, and overall\n+//! helps with clarity as we're also referring to `char` intentionally in here.\n+\n+use crate::fmt;\n+use crate::mem::transmute;\n+\n+/// One of the 128 Unicode characters from U+0000 through U+007F,\n+/// often known as the [ASCII] subset.\n+///\n+/// Officially, this is the first [block] in Unicode, _Basic Latin_.\n+/// For details, see the [*C0 Controls and Basic Latin*][chart] code chart.\n+///\n+/// This block was based on older 7-bit character code standards such as\n+/// ANSI X3.4-1977, ISO 646-1973, and [NIST FIPS 1-2].\n+///\n+/// # When to use this\n+///\n+/// The main advantage of this subset is that it's always valid UTF-8.  As such,\n+/// the `&[ascii::Char]` -> `&str` conversion function (as well as other related\n+/// ones) are O(1): *no* runtime checks are needed.\n+///\n+/// If you're consuming strings, you should usually handle Unicode and thus\n+/// accept `str`s, not limit yourself to `ascii::Char`s.\n+///\n+/// However, certain formats are intentionally designed to produce ASCII-only\n+/// output in order to be 8-bit-clean.  In those cases, it can be simpler and\n+/// faster to generate `ascii::Char`s instead of dealing with the variable width\n+/// properties of general UTF-8 encoded strings, while still allowing the result\n+/// to be used freely with other Rust things that deal in general `str`s.\n+///\n+/// For example, a UUID library might offer a way to produce the string\n+/// representation of a UUID as an `[ascii::Char; 36]` to avoid memory\n+/// allocation yet still allow it to be used as UTF-8 via `as_str` without\n+/// paying for validation (or needing `unsafe` code) the way it would if it\n+/// were provided as a `[u8; 36]`.\n+///\n+/// # Layout\n+///\n+/// This type is guaranteed to have a size and alignment of 1 byte.\n+///\n+/// # Names\n+///\n+/// The variants on this type are [Unicode names][NamesList] of the characters\n+/// in upper camel case, with a few tweaks:\n+/// - For `<control>` characters, the primary alias name is used.\n+/// - `LATIN` is dropped, as this block has no non-latin letters.\n+/// - `LETTER` is dropped, as `CAPITAL`/`SMALL` suffices in this block.\n+/// - `DIGIT`s use a single digit rather than writing out `ZERO`, `ONE`, etc.\n+///\n+/// [ASCII]: https://www.unicode.org/glossary/index.html#ASCII\n+/// [block]: https://www.unicode.org/glossary/index.html#block\n+/// [chart]: https://www.unicode.org/charts/PDF/U0000.pdf\n+/// [NIST FIPS 1-2]: https://nvlpubs.nist.gov/nistpubs/Legacy/FIPS/fipspub1-2-1977.pdf\n+/// [NamesList]: https://www.unicode.org/Public/15.0.0/ucd/NamesList.txt\n+#[derive(Debug, Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]\n+#[unstable(feature = \"ascii_char\", issue = \"110998\")]\n+#[repr(u8)]\n+pub enum AsciiChar {\n+    /// U+0000\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    Null = 0,\n+    /// U+0001\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    StartOfHeading = 1,\n+    /// U+0002\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    StartOfText = 2,\n+    /// U+0003\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    EndOfText = 3,\n+    /// U+0004\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    EndOfTransmission = 4,\n+    /// U+0005\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    Enquiry = 5,\n+    /// U+0006\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    Acknowledge = 6,\n+    /// U+0007\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    Bell = 7,\n+    /// U+0008\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    Backspace = 8,\n+    /// U+0009\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    CharacterTabulation = 9,\n+    /// U+000A\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    LineFeed = 10,\n+    /// U+000B\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    LineTabulation = 11,\n+    /// U+000C\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    FormFeed = 12,\n+    /// U+000D\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    CarriageReturn = 13,\n+    /// U+000E\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    ShiftOut = 14,\n+    /// U+000F\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    ShiftIn = 15,\n+    /// U+0010\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    DataLinkEscape = 16,\n+    /// U+0011\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    DeviceControlOne = 17,\n+    /// U+0012\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    DeviceControlTwo = 18,\n+    /// U+0013\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    DeviceControlThree = 19,\n+    /// U+0014\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    DeviceControlFour = 20,\n+    /// U+0015\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    NegativeAcknowledge = 21,\n+    /// U+0016\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    SynchronousIdle = 22,\n+    /// U+0017\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    EndOfTransmissionBlock = 23,\n+    /// U+0018\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    Cancel = 24,\n+    /// U+0019\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    EndOfMedium = 25,\n+    /// U+001A\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    Substitute = 26,\n+    /// U+001B\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    Escape = 27,\n+    /// U+001C\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    InformationSeparatorFour = 28,\n+    /// U+001D\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    InformationSeparatorThree = 29,\n+    /// U+001E\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    InformationSeparatorTwo = 30,\n+    /// U+001F\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    InformationSeparatorOne = 31,\n+    /// U+0020\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    Space = 32,\n+    /// U+0021\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    ExclamationMark = 33,\n+    /// U+0022\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    QuotationMark = 34,\n+    /// U+0023\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    NumberSign = 35,\n+    /// U+0024\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    DollarSign = 36,\n+    /// U+0025\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    PercentSign = 37,\n+    /// U+0026\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    Ampersand = 38,\n+    /// U+0027\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    Apostrophe = 39,\n+    /// U+0028\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    LeftParenthesis = 40,\n+    /// U+0029\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    RightParenthesis = 41,\n+    /// U+002A\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    Asterisk = 42,\n+    /// U+002B\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    PlusSign = 43,\n+    /// U+002C\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    Comma = 44,\n+    /// U+002D\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    HyphenMinus = 45,\n+    /// U+002E\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    FullStop = 46,\n+    /// U+002F\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    Solidus = 47,\n+    /// U+0030\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    Digit0 = 48,\n+    /// U+0031\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    Digit1 = 49,\n+    /// U+0032\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    Digit2 = 50,\n+    /// U+0033\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    Digit3 = 51,\n+    /// U+0034\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    Digit4 = 52,\n+    /// U+0035\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    Digit5 = 53,\n+    /// U+0036\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    Digit6 = 54,\n+    /// U+0037\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    Digit7 = 55,\n+    /// U+0038\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    Digit8 = 56,\n+    /// U+0039\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    Digit9 = 57,\n+    /// U+003A\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    Colon = 58,\n+    /// U+003B\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    Semicolon = 59,\n+    /// U+003C\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    LessThanSign = 60,\n+    /// U+003D\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    EqualsSign = 61,\n+    /// U+003E\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    GreaterThanSign = 62,\n+    /// U+003F\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    QuestionMark = 63,\n+    /// U+0040\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    CommercialAt = 64,\n+    /// U+0041\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    CapitalA = 65,\n+    /// U+0042\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    CapitalB = 66,\n+    /// U+0043\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    CapitalC = 67,\n+    /// U+0044\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    CapitalD = 68,\n+    /// U+0045\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    CapitalE = 69,\n+    /// U+0046\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    CapitalF = 70,\n+    /// U+0047\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    CapitalG = 71,\n+    /// U+0048\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    CapitalH = 72,\n+    /// U+0049\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    CapitalI = 73,\n+    /// U+004A\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    CapitalJ = 74,\n+    /// U+004B\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    CapitalK = 75,\n+    /// U+004C\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    CapitalL = 76,\n+    /// U+004D\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    CapitalM = 77,\n+    /// U+004E\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    CapitalN = 78,\n+    /// U+004F\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    CapitalO = 79,\n+    /// U+0050\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    CapitalP = 80,\n+    /// U+0051\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    CapitalQ = 81,\n+    /// U+0052\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    CapitalR = 82,\n+    /// U+0053\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    CapitalS = 83,\n+    /// U+0054\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    CapitalT = 84,\n+    /// U+0055\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    CapitalU = 85,\n+    /// U+0056\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    CapitalV = 86,\n+    /// U+0057\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    CapitalW = 87,\n+    /// U+0058\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    CapitalX = 88,\n+    /// U+0059\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    CapitalY = 89,\n+    /// U+005A\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    CapitalZ = 90,\n+    /// U+005B\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    LeftSquareBracket = 91,\n+    /// U+005C\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    ReverseSolidus = 92,\n+    /// U+005D\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    RightSquareBracket = 93,\n+    /// U+005E\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    CircumflexAccent = 94,\n+    /// U+005F\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    LowLine = 95,\n+    /// U+0060\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    GraveAccent = 96,\n+    /// U+0061\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    SmallA = 97,\n+    /// U+0062\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    SmallB = 98,\n+    /// U+0063\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    SmallC = 99,\n+    /// U+0064\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    SmallD = 100,\n+    /// U+0065\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    SmallE = 101,\n+    /// U+0066\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    SmallF = 102,\n+    /// U+0067\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    SmallG = 103,\n+    /// U+0068\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    SmallH = 104,\n+    /// U+0069\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    SmallI = 105,\n+    /// U+006A\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    SmallJ = 106,\n+    /// U+006B\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    SmallK = 107,\n+    /// U+006C\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    SmallL = 108,\n+    /// U+006D\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    SmallM = 109,\n+    /// U+006E\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    SmallN = 110,\n+    /// U+006F\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    SmallO = 111,\n+    /// U+0070\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    SmallP = 112,\n+    /// U+0071\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    SmallQ = 113,\n+    /// U+0072\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    SmallR = 114,\n+    /// U+0073\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    SmallS = 115,\n+    /// U+0074\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    SmallT = 116,\n+    /// U+0075\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    SmallU = 117,\n+    /// U+0076\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    SmallV = 118,\n+    /// U+0077\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    SmallW = 119,\n+    /// U+0078\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    SmallX = 120,\n+    /// U+0079\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    SmallY = 121,\n+    /// U+007A\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    SmallZ = 122,\n+    /// U+007B\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    LeftCurlyBracket = 123,\n+    /// U+007C\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    VerticalLine = 124,\n+    /// U+007D\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    RightCurlyBracket = 125,\n+    /// U+007E\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    Tilde = 126,\n+    /// U+007F\n+    #[unstable(feature = \"ascii_char_variants\", issue = \"110998\")]\n+    Delete = 127,\n+}\n+\n+impl AsciiChar {\n+    /// Creates an ascii character from the byte `b`,\n+    /// or returns `None` if it's too large.\n+    #[unstable(feature = \"ascii_char\", issue = \"110998\")]\n+    #[inline]\n+    pub const fn from_u8(b: u8) -> Option<Self> {\n+        if b <= 127 {\n+            // SAFETY: Just checked that `b` is in-range\n+            Some(unsafe { Self::from_u8_unchecked(b) })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Creates an ASCII character from the byte `b`,\n+    /// without checking whether it's valid.\n+    ///\n+    /// # Safety\n+    ///\n+    /// `b` must be in `0..=127`, or else this is UB.\n+    #[unstable(feature = \"ascii_char\", issue = \"110998\")]\n+    #[inline]\n+    pub const unsafe fn from_u8_unchecked(b: u8) -> Self {\n+        // SAFETY: Our safety precondition is that `b` is in-range.\n+        unsafe { transmute(b) }\n+    }\n+\n+    /// When passed the *number* `0`, `1`, \u2026, `9`, returns the *character*\n+    /// `'0'`, `'1'`, \u2026, `'9'` respectively.\n+    ///\n+    /// If `d >= 10`, returns `None`.\n+    #[unstable(feature = \"ascii_char\", issue = \"110998\")]\n+    #[inline]\n+    pub const fn digit(d: u8) -> Option<Self> {\n+        if d < 10 {\n+            // SAFETY: Just checked it's in-range.\n+            Some(unsafe { Self::digit_unchecked(d) })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// When passed the *number* `0`, `1`, \u2026, `9`, returns the *character*\n+    /// `'0'`, `'1'`, \u2026, `'9'` respectively, without checking that it's in-range.\n+    ///\n+    /// # Safety\n+    ///\n+    /// This is immediate UB if called with `d > 64`.\n+    ///\n+    /// If `d >= 10` and `d <= 64`, this is allowed to return any value or panic.\n+    /// Notably, it should not be expected to return hex digits, or any other\n+    /// reasonable extension of the decimal digits.\n+    ///\n+    /// (This lose safety condition is intended to simplify soundness proofs\n+    /// when writing code using this method, since the implementation doesn't\n+    /// need something really specific, not to make those other arguments do\n+    /// something useful. It might be tightened before stabilization.)\n+    #[unstable(feature = \"ascii_char\", issue = \"110998\")]\n+    #[inline]\n+    pub const unsafe fn digit_unchecked(d: u8) -> Self {\n+        debug_assert!(d < 10);\n+\n+        // SAFETY: `'0'` through `'9'` are U+00030 through U+0039,\n+        // so because `d` must be 64 or less the addition can return at most\n+        // 112 (0x70), which doesn't overflow and is within the ASCII range.\n+        unsafe {\n+            let byte = b'0'.unchecked_add(d);\n+            Self::from_u8_unchecked(byte)\n+        }\n+    }\n+\n+    /// Gets this ASCII character as a byte.\n+    #[unstable(feature = \"ascii_char\", issue = \"110998\")]\n+    #[inline]\n+    pub const fn as_u8(self) -> u8 {\n+        self as u8\n+    }\n+\n+    /// Gets this ASCII character as a `char` Unicode Scalar Value.\n+    #[unstable(feature = \"ascii_char\", issue = \"110998\")]\n+    #[inline]\n+    pub const fn as_char(self) -> char {\n+        self as u8 as char\n+    }\n+\n+    /// Views this ASCII character as a one-code-unit UTF-8 `str`.\n+    #[unstable(feature = \"ascii_char\", issue = \"110998\")]\n+    #[inline]\n+    pub const fn as_str(&self) -> &str {\n+        crate::slice::from_ref(self).as_str()\n+    }\n+}\n+\n+impl [AsciiChar] {\n+    /// Views this slice of ASCII characters as a UTF-8 `str`.\n+    #[unstable(feature = \"ascii_char\", issue = \"110998\")]\n+    #[inline]\n+    pub const fn as_str(&self) -> &str {\n+        let ascii_ptr: *const Self = self;\n+        let str_ptr = ascii_ptr as *const str;\n+        // SAFETY: Each ASCII codepoint in UTF-8 is encoded as one single-byte\n+        // code unit having the same value as the ASCII byte.\n+        unsafe { &*str_ptr }\n+    }\n+\n+    /// Views this slice of ASCII characters as a slice of `u8` bytes.\n+    #[unstable(feature = \"ascii_char\", issue = \"110998\")]\n+    #[inline]\n+    pub const fn as_bytes(&self) -> &[u8] {\n+        self.as_str().as_bytes()\n+    }\n+}\n+\n+#[unstable(feature = \"ascii_char\", issue = \"110998\")]\n+impl fmt::Display for AsciiChar {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        <str as fmt::Display>::fmt(self.as_str(), f)\n+    }\n+}"}, {"sha": "1dfa9c34db14c45ac474d99cbbd65a874ba2ec7a", "filename": "library/core/src/char/methods.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ea0b6504faa95dd4bfb0666cbcb5dfcfe0591313/library%2Fcore%2Fsrc%2Fchar%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0b6504faa95dd4bfb0666cbcb5dfcfe0591313/library%2Fcore%2Fsrc%2Fchar%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fchar%2Fmethods.rs?ref=ea0b6504faa95dd4bfb0666cbcb5dfcfe0591313", "patch": "@@ -1,5 +1,6 @@\n //! impl char {}\n \n+use crate::ascii;\n use crate::slice;\n use crate::str::from_utf8_unchecked_mut;\n use crate::unicode::printable::is_printable;\n@@ -1101,6 +1102,24 @@ impl char {\n         *self as u32 <= 0x7F\n     }\n \n+    /// Returns `Some` if the value is within the ASCII range,\n+    /// or `None` if it's not.\n+    ///\n+    /// This is preferred to [`Self::is_ascii`] when you're passing the value\n+    /// along to something else that can take [`ascii::Char`] rather than\n+    /// needing to check again for itself whether the value is in ASCII.\n+    #[must_use]\n+    #[unstable(feature = \"ascii_char\", issue = \"110998\")]\n+    #[inline]\n+    pub const fn as_ascii(&self) -> Option<ascii::Char> {\n+        if self.is_ascii() {\n+            // SAFETY: Just checked that this is ASCII.\n+            Some(unsafe { ascii::Char::from_u8_unchecked(*self as u8) })\n+        } else {\n+            None\n+        }\n+    }\n+\n     /// Makes a copy of the value in its ASCII upper case equivalent.\n     ///\n     /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',"}, {"sha": "08444421dca08c2acef25eb161a25e6436ab6d1f", "filename": "library/core/src/num/mod.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ea0b6504faa95dd4bfb0666cbcb5dfcfe0591313/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0b6504faa95dd4bfb0666cbcb5dfcfe0591313/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs?ref=ea0b6504faa95dd4bfb0666cbcb5dfcfe0591313", "patch": "@@ -472,7 +472,16 @@ impl u8 {\n     #[rustc_const_stable(feature = \"const_u8_is_ascii\", since = \"1.43.0\")]\n     #[inline]\n     pub const fn is_ascii(&self) -> bool {\n-        *self & 128 == 0\n+        *self <= 127\n+    }\n+\n+    /// If the value of this byte is within the ASCII range, returns it as an\n+    /// [ASCII character](ascii::Char).  Otherwise, returns `None`.\n+    #[must_use]\n+    #[unstable(feature = \"ascii_char\", issue = \"110998\")]\n+    #[inline]\n+    pub const fn as_ascii(&self) -> Option<ascii::Char> {\n+        ascii::Char::from_u8(*self)\n     }\n \n     /// Makes a copy of the value in its ASCII upper case equivalent."}, {"sha": "7bae6692ad4ed0f6f7a1e60bb560dd21636c0482", "filename": "library/core/src/slice/ascii.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ea0b6504faa95dd4bfb0666cbcb5dfcfe0591313/library%2Fcore%2Fsrc%2Fslice%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0b6504faa95dd4bfb0666cbcb5dfcfe0591313/library%2Fcore%2Fsrc%2Fslice%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fascii.rs?ref=ea0b6504faa95dd4bfb0666cbcb5dfcfe0591313", "patch": "@@ -16,6 +16,36 @@ impl [u8] {\n         is_ascii(self)\n     }\n \n+    /// If this slice [`is_ascii`](Self::is_ascii), returns it as a slice of\n+    /// [ASCII characters](`ascii::Char`), otherwise returns `None`.\n+    #[unstable(feature = \"ascii_char\", issue = \"110998\")]\n+    #[must_use]\n+    #[inline]\n+    pub fn as_ascii(&self) -> Option<&[ascii::Char]> {\n+        if self.is_ascii() {\n+            // SAFETY: Just checked that it's ASCII\n+            Some(unsafe { self.as_ascii_unchecked() })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Converts this slice of bytes into a slice of ASCII characters,\n+    /// without checking whether they're valid.\n+    ///\n+    /// # Safety\n+    ///\n+    /// Every byte in the slice must be in `0..=127`, or else this is UB.\n+    #[unstable(feature = \"ascii_char\", issue = \"110998\")]\n+    #[must_use]\n+    #[inline]\n+    pub const unsafe fn as_ascii_unchecked(&self) -> &[ascii::Char] {\n+        let byte_ptr: *const [u8] = self;\n+        let ascii_ptr = byte_ptr as *const [ascii::Char];\n+        // SAFETY: The caller promised all the bytes are ASCII\n+        unsafe { &*ascii_ptr }\n+    }\n+\n     /// Checks that two slices are an ASCII case-insensitive match.\n     ///\n     /// Same as `to_ascii_lowercase(a) == to_ascii_lowercase(b)`,"}, {"sha": "66fa9cf6f64c065e4b97d89ba74621913997fa1b", "filename": "library/core/src/str/mod.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ea0b6504faa95dd4bfb0666cbcb5dfcfe0591313/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0b6504faa95dd4bfb0666cbcb5dfcfe0591313/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs?ref=ea0b6504faa95dd4bfb0666cbcb5dfcfe0591313", "patch": "@@ -16,6 +16,7 @@ mod validations;\n use self::pattern::Pattern;\n use self::pattern::{DoubleEndedSearcher, ReverseSearcher, Searcher};\n \n+use crate::ascii;\n use crate::char::{self, EscapeDebugExtArgs};\n use crate::mem;\n use crate::slice::{self, SliceIndex};\n@@ -2366,6 +2367,16 @@ impl str {\n         self.as_bytes().is_ascii()\n     }\n \n+    /// If this string slice [`is_ascii`](Self::is_ascii), returns it as a slice\n+    /// of [ASCII characters](`ascii::Char`), otherwise returns `None`.\n+    #[unstable(feature = \"ascii_char\", issue = \"110998\")]\n+    #[must_use]\n+    #[inline]\n+    pub fn as_ascii(&self) -> Option<&[ascii::Char]> {\n+        // Like in `is_ascii`, we can work on the bytes directly.\n+        self.as_bytes().as_ascii()\n+    }\n+\n     /// Checks that two strings are an ASCII case-insensitive match.\n     ///\n     /// Same as `to_ascii_lowercase(a) == to_ascii_lowercase(b)`,"}, {"sha": "b18ab50de123ecd01f09d44bdf8268754c824072", "filename": "library/std/src/ascii.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ea0b6504faa95dd4bfb0666cbcb5dfcfe0591313/library%2Fstd%2Fsrc%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0b6504faa95dd4bfb0666cbcb5dfcfe0591313/library%2Fstd%2Fsrc%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fascii.rs?ref=ea0b6504faa95dd4bfb0666cbcb5dfcfe0591313", "patch": "@@ -16,6 +16,9 @@\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::ascii::{escape_default, EscapeDefault};\n \n+#[unstable(feature = \"ascii_char\", issue = \"110998\")]\n+pub use core::ascii::Char;\n+\n /// Extension methods for ASCII-subset only operations.\n ///\n /// Be aware that operations on seemingly non-ASCII characters can sometimes"}, {"sha": "4167becf5e9a96298db184c347f655563f24dbaf", "filename": "tests/codegen/ascii-char.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/ea0b6504faa95dd4bfb0666cbcb5dfcfe0591313/tests%2Fcodegen%2Fascii-char.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0b6504faa95dd4bfb0666cbcb5dfcfe0591313/tests%2Fcodegen%2Fascii-char.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fascii-char.rs?ref=ea0b6504faa95dd4bfb0666cbcb5dfcfe0591313", "patch": "@@ -0,0 +1,37 @@\n+// compile-flags: -C opt-level=1\n+// ignore-debug (the extra assertions get in the way)\n+\n+#![crate_type = \"lib\"]\n+#![feature(ascii_char)]\n+\n+use std::ascii::Char as AsciiChar;\n+\n+// CHECK-LABEL: i8 @unwrap_digit_from_remainder(i32\n+#[no_mangle]\n+pub fn unwrap_digit_from_remainder(v: u32) -> AsciiChar {\n+    // CHECK-NOT: icmp\n+    // CHECK-NOT: panic\n+\n+    // CHECK: %[[R:.+]] = urem i32 %v, 10\n+    // CHECK-NEXT: %[[T:.+]] = trunc i32 %[[R]] to i8\n+    // CHECK-NEXT: %[[D:.+]] = or i8 %[[T]], 48\n+    // CHECK-NEXT: ret i8 %[[D]]\n+\n+    // CHECK-NOT: icmp\n+    // CHECK-NOT: panic\n+    AsciiChar::digit((v % 10) as u8).unwrap()\n+}\n+\n+// CHECK-LABEL: i8 @unwrap_from_masked(i8\n+#[no_mangle]\n+pub fn unwrap_from_masked(b: u8) -> AsciiChar {\n+    // CHECK-NOT: icmp\n+    // CHECK-NOT: panic\n+\n+    // CHECK: %[[M:.+]] = and i8 %b, 127\n+    // CHECK-NEXT: ret i8 %[[M]]\n+\n+    // CHECK-NOT: icmp\n+    // CHECK-NOT: panic\n+    AsciiChar::from_u8(b & 0x7f).unwrap()\n+}"}]}