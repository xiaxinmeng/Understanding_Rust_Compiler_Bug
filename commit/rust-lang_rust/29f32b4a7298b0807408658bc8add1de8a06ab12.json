{"sha": "29f32b4a7298b0807408658bc8add1de8a06ab12", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5ZjMyYjRhNzI5OGIwODA3NDA4NjU4YmM4YWRkMWRlOGEwNmFiMTI=", "commit": {"author": {"name": "Paul Stansifer", "email": "paul.stansifer@gmail.com", "date": "2012-08-23T00:24:52Z"}, "committer": {"name": "Paul Stansifer", "email": "paul.stansifer@gmail.com", "date": "2012-08-23T18:14:14Z"}, "message": "`m1!{...}` -> `m1!(...)`", "tree": {"sha": "c989293754f94ce2c22cee3902af0c57d33e6dd0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c989293754f94ce2c22cee3902af0c57d33e6dd0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/29f32b4a7298b0807408658bc8add1de8a06ab12", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/29f32b4a7298b0807408658bc8add1de8a06ab12", "html_url": "https://github.com/rust-lang/rust/commit/29f32b4a7298b0807408658bc8add1de8a06ab12", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/29f32b4a7298b0807408658bc8add1de8a06ab12/comments", "author": {"login": "paulstansifer", "id": 1431, "node_id": "MDQ6VXNlcjE0MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/paulstansifer", "html_url": "https://github.com/paulstansifer", "followers_url": "https://api.github.com/users/paulstansifer/followers", "following_url": "https://api.github.com/users/paulstansifer/following{/other_user}", "gists_url": "https://api.github.com/users/paulstansifer/gists{/gist_id}", "starred_url": "https://api.github.com/users/paulstansifer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/paulstansifer/subscriptions", "organizations_url": "https://api.github.com/users/paulstansifer/orgs", "repos_url": "https://api.github.com/users/paulstansifer/repos", "events_url": "https://api.github.com/users/paulstansifer/events{/privacy}", "received_events_url": "https://api.github.com/users/paulstansifer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "paulstansifer", "id": 1431, "node_id": "MDQ6VXNlcjE0MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/paulstansifer", "html_url": "https://github.com/paulstansifer", "followers_url": "https://api.github.com/users/paulstansifer/followers", "following_url": "https://api.github.com/users/paulstansifer/following{/other_user}", "gists_url": "https://api.github.com/users/paulstansifer/gists{/gist_id}", "starred_url": "https://api.github.com/users/paulstansifer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/paulstansifer/subscriptions", "organizations_url": "https://api.github.com/users/paulstansifer/orgs", "repos_url": "https://api.github.com/users/paulstansifer/repos", "events_url": "https://api.github.com/users/paulstansifer/events{/privacy}", "received_events_url": "https://api.github.com/users/paulstansifer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "226fd87199fb0184fb39ffc5dff3865cfdc9f362", "url": "https://api.github.com/repos/rust-lang/rust/commits/226fd87199fb0184fb39ffc5dff3865cfdc9f362", "html_url": "https://github.com/rust-lang/rust/commit/226fd87199fb0184fb39ffc5dff3865cfdc9f362"}], "stats": {"total": 8036, "additions": 5330, "deletions": 2706}, "files": [{"sha": "2330078a7bbb12b0b77c81bccb10da7fe22cb9f6", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 74, "deletions": 74, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -371,7 +371,7 @@ fn rest(s: ~str, start: uint) -> ~str {\n fn need_dir(s: ~str) {\n     if os::path_is_dir(s) { return; }\n     if !os::make_dir(s, 493_i32 /* oct: 755 */) {\n-        fail fmt!{\"can't make_dir %s\", s};\n+        fail fmt!(\"can't make_dir %s\", s);\n     }\n }\n \n@@ -389,7 +389,7 @@ fn valid_pkg_name(s: ~str) -> bool {\n \n fn parse_source(name: ~str, j: json::json) -> source {\n     if !valid_pkg_name(name) {\n-        fail fmt!{\"'%s' is an invalid source name\", name};\n+        fail fmt!(\"'%s' is an invalid source name\", name);\n     }\n \n     match j {\n@@ -432,11 +432,11 @@ fn try_parse_sources(filename: ~str, sources: map::hashmap<~str, source>) {\n         ok(json::dict(j)) => {\n           for j.each |k, v| {\n                 sources.insert(k, parse_source(k, v));\n-                debug!{\"source: %s\", k};\n+                debug!(\"source: %s\", k);\n             }\n         }\n         ok(_) => fail ~\"malformed sources.json\",\n-        err(e) => fail fmt!{\"%s:%s\", filename, e.to_str()}\n+        err(e) => fail fmt!(\"%s:%s\", filename, e.to_str())\n     }\n }\n \n@@ -559,7 +559,7 @@ fn load_source_info(c: cargo, src: source) {\n                  ~\"(source info is not a dict)\");\n         }\n         err(e) => {\n-            warn(fmt!{\"%s:%s\", src.name, e.to_str()});\n+            warn(fmt!(\"%s:%s\", src.name, e.to_str()));\n         }\n     };\n }\n@@ -588,7 +588,7 @@ fn load_source_packages(c: cargo, src: source) {\n                  ~\"(packages is not a list)\");\n         }\n         err(e) => {\n-            warn(fmt!{\"%s:%s\", src.name, e.to_str()});\n+            warn(fmt!(\"%s:%s\", src.name, e.to_str()));\n         }\n     };\n }\n@@ -597,7 +597,7 @@ fn build_cargo_options(argv: ~[~str]) -> options {\n     let matches = match getopts::getopts(argv, opts()) {\n         result::ok(m) => m,\n         result::err(f) => {\n-            fail fmt!{\"%s\", getopts::fail_str(f)};\n+            fail fmt!(\"%s\", getopts::fail_str(f));\n         }\n     };\n \n@@ -707,11 +707,11 @@ fn run_in_buildpath(what: ~str, path: ~str, subdir: ~str, cf: ~str,\n                     extra_flags: ~[~str]) -> option<~str> {\n     let buildpath = path::connect(path, subdir);\n     need_dir(buildpath);\n-    debug!{\"%s: %s -> %s\", what, cf, buildpath};\n+    debug!(\"%s: %s -> %s\", what, cf, buildpath);\n     let p = run::program_output(rustc_sysroot(),\n                                 ~[~\"--out-dir\", buildpath, cf] + extra_flags);\n     if p.status != 0 {\n-        error(fmt!{\"rustc failed: %d\\n%s\\n%s\", p.status, p.err, p.out});\n+        error(fmt!(\"rustc failed: %d\\n%s\\n%s\", p.status, p.err, p.out));\n         return none;\n     }\n     some(buildpath)\n@@ -738,15 +738,15 @@ fn install_one_crate(c: cargo, path: ~str, cf: ~str) {\n         if (exec_suffix != ~\"\" && str::ends_with(ct, exec_suffix)) ||\n             (exec_suffix == ~\"\" && !str::starts_with(path::basename(ct),\n                                                     ~\"lib\")) {\n-            debug!{\"  bin: %s\", ct};\n+            debug!(\"  bin: %s\", ct);\n             install_to_dir(ct, c.bindir);\n             if c.opts.mode == system_mode {\n                 // FIXME (#2662): Put this file in PATH / symlink it so it can\n                 // be used as a generic executable\n                 // `cargo install -G rustray` and `rustray file.obj`\n             }\n         } else {\n-            debug!{\"  lib: %s\", ct};\n+            debug!(\"  lib: %s\", ct);\n             install_to_dir(ct, c.libdir);\n         }\n     }\n@@ -758,15 +758,15 @@ fn rustc_sysroot() -> ~str {\n         some(path) => {\n             let path = ~[path, ~\"..\", ~\"bin\", ~\"rustc\"];\n             let rustc = path::normalize(path::connect_many(path));\n-            debug!{\"  rustc: %s\", rustc};\n+            debug!(\"  rustc: %s\", rustc);\n             rustc\n         }\n         none => ~\"rustc\"\n     }\n }\n \n fn install_source(c: cargo, path: ~str) {\n-    debug!{\"source: %s\", path};\n+    debug!(\"source: %s\", path);\n     os::change_dir(path);\n \n     let mut cratefiles = ~[];\n@@ -792,7 +792,7 @@ fn install_source(c: cargo, path: ~str) {\n                     let wd_base = c.workdir + path::path_sep();\n                     let wd = match tempfile::mkdtemp(wd_base, ~\"\") {\n                         some(wd) => wd,\n-                        none => fail fmt!{\"needed temp dir: %s\", wd_base}\n+                        none => fail fmt!(\"needed temp dir: %s\", wd_base)\n                     };\n \n                     install_query(c, wd, query);\n@@ -825,7 +825,7 @@ fn install_curl(c: cargo, wd: ~str, url: ~str) {\n     let p = run::program_output(~\"curl\", ~[~\"-f\", ~\"-s\", ~\"-o\",\n                                          tarpath, url]);\n     if p.status != 0 {\n-        fail fmt!{\"fetch of %s failed: %s\", url, p.err};\n+        fail fmt!(\"fetch of %s failed: %s\", url, p.err);\n     }\n     run::run_program(~\"tar\", ~[~\"-x\", ~\"--strip-components=1\",\n                              ~\"-C\", wd, ~\"-f\", tarpath]);\n@@ -846,7 +846,7 @@ fn install_package(c: cargo, src: ~str, wd: ~str, pkg: package) {\n         _ => ~\"curl\"\n     };\n \n-    info(fmt!{\"installing %s/%s via %s...\", src, pkg.name, method});\n+    info(fmt!(\"installing %s/%s via %s...\", src, pkg.name, method));\n \n     match method {\n         ~\"git\" => install_git(c, wd, url, copy pkg.reference),\n@@ -1076,15 +1076,15 @@ fn cmd_install(c: cargo) unsafe {\n     let wd_base = c.workdir + path::path_sep();\n     let wd = match tempfile::mkdtemp(wd_base, ~\"\") {\n         some(wd) => wd,\n-        none => fail fmt!{\"needed temp dir: %s\", wd_base}\n+        none => fail fmt!(\"needed temp dir: %s\", wd_base)\n     };\n \n     if vec::len(c.opts.free) == 2u {\n         let cwd = os::getcwd();\n         let status = run::run_program(~\"cp\", ~[~\"-R\", cwd, wd]);\n \n         if status != 0 {\n-            fail fmt!{\"could not copy directory: %s\", cwd};\n+            fail fmt!(\"could not copy directory: %s\", cwd);\n         }\n \n         install_source(c, wd);\n@@ -1120,7 +1120,7 @@ fn sync_one_file(c: cargo, dir: ~str, src: source) -> bool {\n     let mut has_src_file = false;\n \n     if !os::copy_file(path::connect(url, ~\"packages.json\"), pkgfile) {\n-        error(fmt!{\"fetch for source %s (url %s) failed\", name, url});\n+        error(fmt!(\"fetch for source %s (url %s) failed\", name, url));\n         return false;\n     }\n \n@@ -1136,7 +1136,7 @@ fn sync_one_file(c: cargo, dir: ~str, src: source) -> bool {\n             let p = run::program_output(~\"curl\",\n                                         ~[~\"-f\", ~\"-s\", ~\"-o\", keyfile, u]);\n             if p.status != 0 {\n-                error(fmt!{\"fetch for source %s (key %s) failed\", name, u});\n+                error(fmt!(\"fetch for source %s (key %s) failed\", name, u));\n                 return false;\n             }\n             pgp::add(c.root, keyfile);\n@@ -1148,17 +1148,17 @@ fn sync_one_file(c: cargo, dir: ~str, src: source) -> bool {\n             let r = pgp::verify(c.root, pkgfile, sigfile, f);\n \n             if !r {\n-                error(fmt!{\"signature verification failed for source %s\",\n-                          name});\n+                error(fmt!(\"signature verification failed for source %s\",\n+                          name));\n                 return false;\n             }\n \n             if has_src_file {\n                 let e = pgp::verify(c.root, srcfile, srcsigfile, f);\n \n                 if !e {\n-                    error(fmt!{\"signature verification failed for source %s\",\n-                              name});\n+                    error(fmt!(\"signature verification failed for source %s\",\n+                              name));\n                     return false;\n                 }\n             }\n@@ -1178,7 +1178,7 @@ fn sync_one_file(c: cargo, dir: ~str, src: source) -> bool {\n     os::remove_file(pkgfile);\n     os::remove_file(sigfile);\n \n-    info(fmt!{\"synced source: %s\", name});\n+    info(fmt!(\"synced source: %s\", name));\n \n     return true;\n }\n@@ -1194,7 +1194,7 @@ fn sync_one_git(c: cargo, dir: ~str, src: source) -> bool {\n \n     fn rollback(name: ~str, dir: ~str, insecure: bool) {\n         fn msg(name: ~str, insecure: bool) {\n-            error(fmt!{\"could not rollback source: %s\", name});\n+            error(fmt!(\"could not rollback source: %s\", name));\n \n             if insecure {\n                 warn(~\"a past security check failed on source \" +\n@@ -1220,20 +1220,20 @@ fn sync_one_git(c: cargo, dir: ~str, src: source) -> bool {\n         let p = run::program_output(~\"git\", ~[~\"clone\", url, dir]);\n \n         if p.status != 0 {\n-            error(fmt!{\"fetch for source %s (url %s) failed\", name, url});\n+            error(fmt!(\"fetch for source %s (url %s) failed\", name, url));\n             return false;\n         }\n     }\n     else {\n         if !os::change_dir(dir) {\n-            error(fmt!{\"fetch for source %s (url %s) failed\", name, url});\n+            error(fmt!(\"fetch for source %s (url %s) failed\", name, url));\n             return false;\n         }\n \n         let p = run::program_output(~\"git\", ~[~\"pull\"]);\n \n         if p.status != 0 {\n-            error(fmt!{\"fetch for source %s (url %s) failed\", name, url});\n+            error(fmt!(\"fetch for source %s (url %s) failed\", name, url));\n             return false;\n         }\n     }\n@@ -1245,7 +1245,7 @@ fn sync_one_git(c: cargo, dir: ~str, src: source) -> bool {\n             let p = run::program_output(~\"curl\",\n                                         ~[~\"-f\", ~\"-s\", ~\"-o\", keyfile, u]);\n             if p.status != 0 {\n-                error(fmt!{\"fetch for source %s (key %s) failed\", name, u});\n+                error(fmt!(\"fetch for source %s (key %s) failed\", name, u));\n                 rollback(name, dir, false);\n                 return false;\n             }\n@@ -1258,8 +1258,8 @@ fn sync_one_git(c: cargo, dir: ~str, src: source) -> bool {\n             let r = pgp::verify(c.root, pkgfile, sigfile, f);\n \n             if !r {\n-                error(fmt!{\"signature verification failed for source %s\",\n-                          name});\n+                error(fmt!(\"signature verification failed for source %s\",\n+                          name));\n                 rollback(name, dir, false);\n                 return false;\n             }\n@@ -1268,8 +1268,8 @@ fn sync_one_git(c: cargo, dir: ~str, src: source) -> bool {\n                 let e = pgp::verify(c.root, srcfile, srcsigfile, f);\n \n                 if !e {\n-                    error(fmt!{\"signature verification failed for source %s\",\n-                              name});\n+                    error(fmt!(\"signature verification failed for source %s\",\n+                              name));\n                     rollback(name, dir, false);\n                     return false;\n                 }\n@@ -1280,7 +1280,7 @@ fn sync_one_git(c: cargo, dir: ~str, src: source) -> bool {\n \n     os::remove_file(keyfile);\n \n-    info(fmt!{\"synced source: %s\", name});\n+    info(fmt!(\"synced source: %s\", name));\n \n     return true;\n }\n@@ -1306,7 +1306,7 @@ fn sync_one_curl(c: cargo, dir: ~str, src: source) -> bool {\n                                 ~[~\"-f\", ~\"-s\", ~\"-o\", pkgfile, url]);\n \n     if p.status != 0 {\n-        error(fmt!{\"fetch for source %s (url %s) failed\", name, url});\n+        error(fmt!(\"fetch for source %s (url %s) failed\", name, url));\n         return false;\n     }\n     if smart {\n@@ -1325,7 +1325,7 @@ fn sync_one_curl(c: cargo, dir: ~str, src: source) -> bool {\n             let p = run::program_output(~\"curl\",\n                                         ~[~\"-f\", ~\"-s\", ~\"-o\", keyfile, u]);\n             if p.status != 0 {\n-                error(fmt!{\"fetch for source %s (key %s) failed\", name, u});\n+                error(fmt!(\"fetch for source %s (key %s) failed\", name, u));\n                 return false;\n             }\n             pgp::add(c.root, keyfile);\n@@ -1344,15 +1344,15 @@ fn sync_one_curl(c: cargo, dir: ~str, src: source) -> bool {\n             let mut p = run::program_output(~\"curl\", ~[~\"-f\", ~\"-s\", ~\"-o\",\n                         sigfile, url]);\n             if p.status != 0 {\n-                error(fmt!{\"fetch for source %s (sig %s) failed\", name, url});\n+                error(fmt!(\"fetch for source %s (sig %s) failed\", name, url));\n                 return false;\n             }\n \n             let r = pgp::verify(c.root, pkgfile, sigfile, f);\n \n             if !r {\n-                error(fmt!{\"signature verification failed for source %s\",\n-                          name});\n+                error(fmt!(\"signature verification failed for source %s\",\n+                          name));\n                 return false;\n             }\n \n@@ -1363,8 +1363,8 @@ fn sync_one_curl(c: cargo, dir: ~str, src: source) -> bool {\n                                         ~[~\"-f\", ~\"-s\", ~\"-o\",\n                                           srcsigfile, url]);\n                 if p.status != 0 {\n-                    error(fmt!{\"fetch for source %s (sig %s) failed\",\n-                          name, url});\n+                    error(fmt!(\"fetch for source %s (sig %s) failed\",\n+                          name, url));\n                     return false;\n                 }\n \n@@ -1392,7 +1392,7 @@ fn sync_one_curl(c: cargo, dir: ~str, src: source) -> bool {\n     os::remove_file(pkgfile);\n     os::remove_file(sigfile);\n \n-    info(fmt!{\"synced source: %s\", name});\n+    info(fmt!(\"synced source: %s\", name));\n \n     return true;\n }\n@@ -1401,7 +1401,7 @@ fn sync_one(c: cargo, src: source) {\n     let name = src.name;\n     let dir = path::connect(c.sourcedir, name);\n \n-    info(fmt!{\"syncing source: %s...\", name});\n+    info(fmt!(\"syncing source: %s...\", name));\n \n     need_dir(dir);\n \n@@ -1428,28 +1428,28 @@ fn cmd_init(c: cargo) {\n     let p =\n         run::program_output(~\"curl\", ~[~\"-f\", ~\"-s\", ~\"-o\", srcfile, srcurl]);\n     if p.status != 0 {\n-        error(fmt!{\"fetch of sources.json failed: %s\", p.out});\n+        error(fmt!(\"fetch of sources.json failed: %s\", p.out));\n         return;\n     }\n \n     let p =\n         run::program_output(~\"curl\", ~[~\"-f\", ~\"-s\", ~\"-o\", sigfile, sigurl]);\n     if p.status != 0 {\n-        error(fmt!{\"fetch of sources.json.sig failed: %s\", p.out});\n+        error(fmt!(\"fetch of sources.json.sig failed: %s\", p.out));\n         return;\n     }\n \n     let r = pgp::verify(c.root, srcfile, sigfile, pgp::signing_key_fp());\n     if !r {\n-        error(fmt!{\"signature verification failed for '%s'\", srcfile});\n+        error(fmt!(\"signature verification failed for '%s'\", srcfile));\n         return;\n     }\n \n     copy_warn(srcfile, destsrcfile);\n     os::remove_file(srcfile);\n     os::remove_file(sigfile);\n \n-    info(fmt!{\"initialized .cargo in %s\", c.root});\n+    info(fmt!(\"initialized .cargo in %s\", c.root));\n }\n \n fn print_pkg(s: source, p: package) {\n@@ -1490,14 +1490,14 @@ fn cmd_list(c: cargo) {\n     if vec::len(c.opts.free) >= 3u {\n         do vec::iter_between(c.opts.free, 2u, vec::len(c.opts.free)) |name| {\n             if !valid_pkg_name(name) {\n-                error(fmt!{\"'%s' is an invalid source name\", name});\n+                error(fmt!(\"'%s' is an invalid source name\", name));\n             } else {\n                 match c.sources.find(name) {\n                     some(source) => {\n                         print_source(source);\n                     }\n                     none => {\n-                        error(fmt!{\"no such source: %s\", name});\n+                        error(fmt!(\"no such source: %s\", name));\n                     }\n                 }\n             }\n@@ -1527,17 +1527,17 @@ fn cmd_search(c: cargo) {\n             n += 1;\n         }\n     });\n-    info(fmt!{\"found %d packages\", n});\n+    info(fmt!(\"found %d packages\", n));\n }\n \n fn install_to_dir(srcfile: ~str, destdir: ~str) {\n     let newfile = path::connect(destdir, path::basename(srcfile));\n \n     let status = run::run_program(~\"cp\", ~[~\"-r\", srcfile, newfile]);\n     if status == 0 {\n-        info(fmt!{\"installed: '%s'\", newfile});\n+        info(fmt!(\"installed: '%s'\", newfile));\n     } else {\n-        error(fmt!{\"could not install: '%s'\", newfile});\n+        error(fmt!(\"could not install: '%s'\", newfile));\n     }\n }\n \n@@ -1595,22 +1595,22 @@ fn dump_sources(c: cargo) {\n             writer.write_str(json::to_str(root));\n         }\n         result::err(e) => {\n-            error(fmt!{\"could not dump sources: %s\", e});\n+            error(fmt!(\"could not dump sources: %s\", e));\n         }\n     }\n }\n \n fn copy_warn(srcfile: ~str, destfile: ~str) {\n     if !os::copy_file(srcfile, destfile) {\n-        warn(fmt!{\"copying %s to %s failed\", srcfile, destfile});\n+        warn(fmt!(\"copying %s to %s failed\", srcfile, destfile));\n     }\n }\n \n fn cmd_sources(c: cargo) {\n     if vec::len(c.opts.free) < 3u {\n         for c.sources.each_value |v| {\n-            info(fmt!{\"%s (%s) via %s\",\n-                      v.name, v.url, v.method});\n+            info(fmt!(\"%s (%s) via %s\",\n+                      v.name, v.url, v.method));\n         }\n         return;\n     }\n@@ -1635,13 +1635,13 @@ fn cmd_sources(c: cargo) {\n             let url = c.opts.free[4u];\n \n             if !valid_pkg_name(name) {\n-                error(fmt!{\"'%s' is an invalid source name\", name});\n+                error(fmt!(\"'%s' is an invalid source name\", name));\n                 return;\n             }\n \n             match c.sources.find(name) {\n                 some(source) => {\n-                    error(fmt!{\"source already exists: %s\", name});\n+                    error(fmt!(\"source already exists: %s\", name));\n                 }\n                 none => {\n                     c.sources.insert(name, @{\n@@ -1652,7 +1652,7 @@ fn cmd_sources(c: cargo) {\n                         mut keyfp: none,\n                         mut packages: ~[mut]\n                     });\n-                    info(fmt!{\"added source: %s\", name});\n+                    info(fmt!(\"added source: %s\", name));\n                 }\n             }\n         }\n@@ -1665,17 +1665,17 @@ fn cmd_sources(c: cargo) {\n             let name = c.opts.free[3u];\n \n             if !valid_pkg_name(name) {\n-                error(fmt!{\"'%s' is an invalid source name\", name});\n+                error(fmt!(\"'%s' is an invalid source name\", name));\n                 return;\n             }\n \n             match c.sources.find(name) {\n                 some(source) => {\n                     c.sources.remove(name);\n-                    info(fmt!{\"removed source: %s\", name});\n+                    info(fmt!(\"removed source: %s\", name));\n                 }\n                 none => {\n-                    error(fmt!{\"no such source: %s\", name});\n+                    error(fmt!(\"no such source: %s\", name));\n                 }\n             }\n         }\n@@ -1689,7 +1689,7 @@ fn cmd_sources(c: cargo) {\n             let url = c.opts.free[4u];\n \n             if !valid_pkg_name(name) {\n-                error(fmt!{\"'%s' is an invalid source name\", name});\n+                error(fmt!(\"'%s' is an invalid source name\", name));\n                 return;\n             }\n \n@@ -1703,10 +1703,10 @@ fn cmd_sources(c: cargo) {\n \n                     c.sources.insert(name, source);\n \n-                    info(fmt!{\"changed source url: '%s' to '%s'\", old, url});\n+                    info(fmt!(\"changed source url: '%s' to '%s'\", old, url));\n                 }\n                 none => {\n-                    error(fmt!{\"no such source: %s\", name});\n+                    error(fmt!(\"no such source: %s\", name));\n                 }\n             }\n         }\n@@ -1720,7 +1720,7 @@ fn cmd_sources(c: cargo) {\n             let method = c.opts.free[4u];\n \n             if !valid_pkg_name(name) {\n-                error(fmt!{\"'%s' is an invalid source name\", name});\n+                error(fmt!(\"'%s' is an invalid source name\", name));\n                 return;\n             }\n \n@@ -1736,11 +1736,11 @@ fn cmd_sources(c: cargo) {\n \n                     c.sources.insert(name, source);\n \n-                    info(fmt!{\"changed source method: '%s' to '%s'\", old,\n-                         method});\n+                    info(fmt!(\"changed source method: '%s' to '%s'\", old,\n+                         method));\n                 }\n                 none => {\n-                    error(fmt!{\"no such source: %s\", name});\n+                    error(fmt!(\"no such source: %s\", name));\n                 }\n             }\n         }\n@@ -1754,22 +1754,22 @@ fn cmd_sources(c: cargo) {\n             let newn = c.opts.free[4u];\n \n             if !valid_pkg_name(name) {\n-                error(fmt!{\"'%s' is an invalid source name\", name});\n+                error(fmt!(\"'%s' is an invalid source name\", name));\n                 return;\n             }\n             if !valid_pkg_name(newn) {\n-                error(fmt!{\"'%s' is an invalid source name\", newn});\n+                error(fmt!(\"'%s' is an invalid source name\", newn));\n                 return;\n             }\n \n             match c.sources.find(name) {\n                 some(source) => {\n                     c.sources.remove(name);\n                     c.sources.insert(newn, source);\n-                    info(fmt!{\"renamed source: %s to %s\", name, newn});\n+                    info(fmt!(\"renamed source: %s to %s\", name, newn));\n                 }\n                 none => {\n-                    error(fmt!{\"no such source: %s\", name});\n+                    error(fmt!(\"no such source: %s\", name));\n                 }\n             }\n         }"}, {"sha": "73c824285abb395a522b435c3221fabf19f09d72", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -63,20 +63,20 @@ fn parse_config(args: ~[~str]) -> config {\n \n fn log_config(config: config) {\n     let c = config;\n-    logv(c, fmt!{\"configuration:\"});\n-    logv(c, fmt!{\"compile_lib_path: %s\", config.compile_lib_path});\n-    logv(c, fmt!{\"run_lib_path: %s\", config.run_lib_path});\n-    logv(c, fmt!{\"rustc_path: %s\", config.rustc_path});\n-    logv(c, fmt!{\"src_base: %s\", config.src_base});\n-    logv(c, fmt!{\"build_base: %s\", config.build_base});\n-    logv(c, fmt!{\"stage_id: %s\", config.stage_id});\n-    logv(c, fmt!{\"mode: %s\", mode_str(config.mode)});\n-    logv(c, fmt!{\"run_ignored: %b\", config.run_ignored});\n-    logv(c, fmt!{\"filter: %s\", opt_str(config.filter)});\n-    logv(c, fmt!{\"runtool: %s\", opt_str(config.runtool)});\n-    logv(c, fmt!{\"rustcflags: %s\", opt_str(config.rustcflags)});\n-    logv(c, fmt!{\"verbose: %b\", config.verbose});\n-    logv(c, fmt!{\"\\n\"});\n+    logv(c, fmt!(\"configuration:\"));\n+    logv(c, fmt!(\"compile_lib_path: %s\", config.compile_lib_path));\n+    logv(c, fmt!(\"run_lib_path: %s\", config.run_lib_path));\n+    logv(c, fmt!(\"rustc_path: %s\", config.rustc_path));\n+    logv(c, fmt!(\"src_base: %s\", config.src_base));\n+    logv(c, fmt!(\"build_base: %s\", config.build_base));\n+    logv(c, fmt!(\"stage_id: %s\", config.stage_id));\n+    logv(c, fmt!(\"mode: %s\", mode_str(config.mode)));\n+    logv(c, fmt!(\"run_ignored: %b\", config.run_ignored));\n+    logv(c, fmt!(\"filter: %s\", opt_str(config.filter)));\n+    logv(c, fmt!(\"runtool: %s\", opt_str(config.runtool)));\n+    logv(c, fmt!(\"rustcflags: %s\", opt_str(config.rustcflags)));\n+    logv(c, fmt!(\"verbose: %b\", config.verbose));\n+    logv(c, fmt!(\"\\n\"));\n }\n \n fn opt_str(maybestr: option<~str>) -> ~str {\n@@ -129,11 +129,11 @@ fn test_opts(config: config) -> test::test_opts {\n }\n \n fn make_tests(config: config) -> ~[test::test_desc] {\n-    debug!{\"making tests from %s\", config.src_base};\n+    debug!(\"making tests from %s\", config.src_base);\n     let mut tests = ~[];\n     for os::list_dir_path(config.src_base).each |file| {\n         let file = file;\n-        debug!{\"inspecting file %s\", file};\n+        debug!(\"inspecting file %s\", file);\n         if is_test(config, file) {\n             vec::push(tests, make_test(config, file))\n         }\n@@ -175,7 +175,7 @@ fn make_test(config: config, testfile: ~str) ->\n }\n \n fn make_test_name(config: config, testfile: ~str) -> ~str {\n-    fmt!{\"[%s] %s\", mode_str(config.mode), testfile}\n+    fmt!(\"[%s] %s\", mode_str(config.mode), testfile)\n }\n \n fn make_test_closure(config: config, testfile: ~str) -> test::test_fn {"}, {"sha": "030e1d01ab00dcdfeef3cea06a391b8157c084f6", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -45,7 +45,7 @@ fn parse_expected(line_num: uint, line: ~str) -> ~[expected_error] unsafe {\n     while idx < len && line[idx] == (' ' as u8) { idx += 1u; }\n     let msg = str::slice(line, idx, len);\n \n-    debug!{\"line=%u kind=%s msg=%s\", line_num - adjust_line, kind, msg};\n+    debug!(\"line=%u kind=%s msg=%s\", line_num - adjust_line, kind, msg);\n \n     return ~[{line: line_num - adjust_line, kind: kind, msg: msg}];\n }"}, {"sha": "efaa822d0159f05dde434eb54653abba59499832", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -109,7 +109,7 @@ fn parse_exec_env(line: ~str) -> option<(~str, ~str)> {\n         match strs.len() {\n           1u => (strs[0], ~\"\"),\n           2u => (strs[0], strs[1]),\n-          n => fail fmt!{\"Expected 1 or 2 strings, not %u\", n}\n+          n => fail fmt!(\"Expected 1 or 2 strings, not %u\", n)\n         }\n     }\n }\n@@ -138,7 +138,7 @@ fn parse_name_value_directive(line: ~str,\n         option::some(colon) => {\n             let value = str::slice(line, colon + str::len(keycolon),\n                                    str::len(line));\n-            debug!{\"%s: %s\", directive,  value};\n+            debug!(\"%s: %s\", directive,  value);\n             option::some(value)\n         }\n         option::none => option::none"}, {"sha": "6498a7d8952950a6124cd5f2822f3c8fa9480587", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -16,7 +16,7 @@ fn run(config: config, testfile: ~str) {\n         // We're going to be dumping a lot of info. Start on a new line.\n         io::stdout().write_str(~\"\\n\\n\");\n     }\n-    debug!{\"running %s\", testfile};\n+    debug!(\"running %s\", testfile);\n     let props = load_props(testfile);\n     match config.mode {\n       mode_compile_fail => run_cfail_test(config, props, testfile),\n@@ -68,8 +68,8 @@ fn check_correct_failure_status(procres: procres) {\n     const rust_err: int = 101;\n     if procres.status != rust_err {\n         fatal_procres(\n-            fmt!{\"failure produced the wrong error code: %d\",\n-                 procres.status},\n+            fmt!(\"failure produced the wrong error code: %d\",\n+                 procres.status),\n             procres);\n     }\n }\n@@ -96,11 +96,11 @@ fn run_pretty_test(config: config, props: test_props, testfile: ~str) {\n \n     let mut round = 0;\n     while round < rounds {\n-        logv(config, fmt!{\"pretty-printing round %d\", round});\n+        logv(config, fmt!(\"pretty-printing round %d\", round));\n         let procres = print_source(config, testfile, srcs[round]);\n \n         if procres.status != 0 {\n-            fatal_procres(fmt!{\"pretty-printing failed in round %d\", round},\n+            fatal_procres(fmt!(\"pretty-printing failed in round %d\", round),\n                           procres);\n         }\n \n@@ -151,7 +151,7 @@ fn run_pretty_test(config: config, props: test_props, testfile: ~str) {\n         if expected != actual {\n             error(~\"pretty-printed source does not match expected source\");\n             let msg =\n-                fmt!{\"\\n\\\n+                fmt!(\"\\n\\\n expected:\\n\\\n ------------------------------------------\\n\\\n %s\\n\\\n@@ -161,7 +161,7 @@ actual:\\n\\\n %s\\n\\\n ------------------------------------------\\n\\\n \\n\",\n-                     expected, actual};\n+                     expected, actual);\n             io::stdout().write_str(msg);\n             fail;\n         }\n@@ -201,10 +201,10 @@ fn check_error_patterns(props: test_props,\n     let mut done = false;\n     for str::split_char(procres.stderr, '\\n').each |line| {\n         if str::contains(line, next_err_pat) {\n-            debug!{\"found error pattern %s\", next_err_pat};\n+            debug!(\"found error pattern %s\", next_err_pat);\n             next_err_idx += 1u;\n             if next_err_idx == vec::len(props.error_patterns) {\n-                debug!{\"found all error patterns\"};\n+                debug!(\"found all error patterns\");\n                 done = true;\n                 break;\n             }\n@@ -217,11 +217,11 @@ fn check_error_patterns(props: test_props,\n         vec::slice(props.error_patterns, next_err_idx,\n                    vec::len(props.error_patterns));\n     if vec::len(missing_patterns) == 1u {\n-        fatal_procres(fmt!{\"error pattern '%s' not found!\",\n-                           missing_patterns[0]}, procres);\n+        fatal_procres(fmt!(\"error pattern '%s' not found!\",\n+                           missing_patterns[0]), procres);\n     } else {\n         for missing_patterns.each |pattern| {\n-            error(fmt!{\"error pattern '%s' not found!\", pattern});\n+            error(fmt!(\"error pattern '%s' not found!\", pattern));\n         }\n         fatal_procres(~\"multiple error patterns not found\", procres);\n     }\n@@ -240,7 +240,7 @@ fn check_expected_errors(expected_errors: ~[errors::expected_error],\n     }\n \n     let prefixes = vec::map(expected_errors, |ee| {\n-        fmt!{\"%s:%u:\", testfile, ee.line}\n+        fmt!(\"%s:%u:\", testfile, ee.line)\n     });\n \n     // Scan and extract our error/warning messages,\n@@ -253,8 +253,8 @@ fn check_expected_errors(expected_errors: ~[errors::expected_error],\n         let mut was_expected = false;\n         for vec::eachi(expected_errors) |i, ee| {\n             if !found_flags[i] {\n-                debug!{\"prefix=%s ee.kind=%s ee.msg=%s line=%s\",\n-                       prefixes[i], ee.kind, ee.msg, line};\n+                debug!(\"prefix=%s ee.kind=%s ee.msg=%s line=%s\",\n+                       prefixes[i], ee.kind, ee.msg, line);\n                 if (str::starts_with(line, prefixes[i]) &&\n                     str::contains(line, ee.kind) &&\n                     str::contains(line, ee.msg)) {\n@@ -272,16 +272,16 @@ fn check_expected_errors(expected_errors: ~[errors::expected_error],\n \n         if !was_expected && (str::contains(line, ~\"error\") ||\n                              str::contains(line, ~\"warning\")) {\n-            fatal_procres(fmt!{\"unexpected error pattern '%s'!\", line},\n+            fatal_procres(fmt!(\"unexpected error pattern '%s'!\", line),\n                           procres);\n         }\n     }\n \n     for uint::range(0u, vec::len(found_flags)) |i| {\n         if !found_flags[i] {\n             let ee = expected_errors[i];\n-            fatal_procres(fmt!{\"expected %s on line %u not found: %s\",\n-                               ee.kind, ee.line, ee.msg}, procres);\n+            fatal_procres(fmt!(\"expected %s on line %u not found: %s\",\n+                               ee.kind, ee.line, ee.msg), procres);\n         }\n     }\n }\n@@ -330,7 +330,7 @@ fn compose_and_run_compiler(\n                                      config.compile_lib_path, option::none);\n         if auxres.status != 0 {\n             fatal_procres(\n-                fmt!{\"auxiliary build of %s failed to compile: \", abs_ab},\n+                fmt!(\"auxiliary build of %s failed to compile: \", abs_ab),\n                 auxres);\n         }\n     }\n@@ -342,7 +342,7 @@ fn compose_and_run_compiler(\n fn ensure_dir(path: Path) {\n     if os::path_is_dir(path) { return; }\n     if !os::make_dir(path, 0x1c0i32) {\n-        fail fmt!{\"can't make dir %s\", path};\n+        fail fmt!(\"can't make dir %s\", path);\n     }\n }\n \n@@ -414,7 +414,7 @@ fn program_output(config: config, testfile: ~str, lib_path: ~str, prog: ~str,\n     let cmdline =\n         {\n             let cmdline = make_cmdline(lib_path, prog, args);\n-            logv(config, fmt!{\"executing %s\", cmdline});\n+            logv(config, fmt!(\"executing %s\", cmdline));\n             cmdline\n         };\n     let res = procsrv::run(lib_path, prog, args, env, input);\n@@ -430,19 +430,19 @@ fn program_output(config: config, testfile: ~str, lib_path: ~str, prog: ~str,\n #[cfg(target_os = \"macos\")]\n #[cfg(target_os = \"freebsd\")]\n fn make_cmdline(_libpath: ~str, prog: ~str, args: ~[~str]) -> ~str {\n-    fmt!{\"%s %s\", prog, str::connect(args, ~\" \")}\n+    fmt!(\"%s %s\", prog, str::connect(args, ~\" \"))\n }\n \n #[cfg(target_os = \"win32\")]\n fn make_cmdline(libpath: ~str, prog: ~str, args: ~[~str]) -> ~str {\n-    fmt!{\"%s %s %s\", lib_path_cmd_prefix(libpath), prog,\n-         str::connect(args, ~\" \")}\n+    fmt!(\"%s %s %s\", lib_path_cmd_prefix(libpath), prog,\n+         str::connect(args, ~\" \"))\n }\n \n // Build the LD_LIBRARY_PATH variable as it would be seen on the command line\n // for diagnostic purposes\n fn lib_path_cmd_prefix(path: ~str) -> ~str {\n-    fmt!{\"%s=\\\"%s\\\"\", util::lib_path_env_var(), util::make_new_path(path)}\n+    fmt!(\"%s=\\\"%s\\\"\", util::lib_path_env_var(), util::make_new_path(path))\n }\n \n fn dump_output(config: config, testfile: ~str, out: ~str, err: ~str) {\n@@ -475,13 +475,13 @@ fn output_testname(testfile: ~str) -> ~str {\n fn output_base_name(config: config, testfile: ~str) -> ~str {\n     let base = config.build_base;\n     let filename = output_testname(testfile);\n-    fmt!{\"%s%s.%s\", base, filename, config.stage_id}\n+    fmt!(\"%s%s.%s\", base, filename, config.stage_id)\n }\n \n fn maybe_dump_to_stdout(config: config, out: ~str, err: ~str) {\n     if config.verbose {\n-        let sep1 = fmt!{\"------%s------------------------------\", ~\"stdout\"};\n-        let sep2 = fmt!{\"------%s------------------------------\", ~\"stderr\"};\n+        let sep1 = fmt!(\"------%s------------------------------\", ~\"stdout\");\n+        let sep2 = fmt!(\"------%s------------------------------\", ~\"stderr\");\n         let sep3 = ~\"------------------------------------------\";\n         io::stdout().write_line(sep1);\n         io::stdout().write_line(out);\n@@ -491,13 +491,13 @@ fn maybe_dump_to_stdout(config: config, out: ~str, err: ~str) {\n     }\n }\n \n-fn error(err: ~str) { io::stdout().write_line(fmt!{\"\\nerror: %s\", err}); }\n+fn error(err: ~str) { io::stdout().write_line(fmt!(\"\\nerror: %s\", err)); }\n \n fn fatal(err: ~str) -> ! { error(err); fail; }\n \n fn fatal_procres(err: ~str, procres: procres) -> ! {\n     let msg =\n-        fmt!{\"\\n\\\n+        fmt!(\"\\n\\\n error: %s\\n\\\n command: %s\\n\\\n stdout:\\n\\\n@@ -509,7 +509,7 @@ stderr:\\n\\\n %s\\n\\\n ------------------------------------------\\n\\\n \\n\",\n-             err, procres.cmdline, procres.stdout, procres.stderr};\n+             err, procres.cmdline, procres.stdout, procres.stderr);\n     io::stdout().write_str(msg);\n     fail;\n }"}, {"sha": "7a1f30a33efc544d90717efa84b4631c1035b6a6", "filename": "src/compiletest/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Fcompiletest%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Fcompiletest%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Futil.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -9,7 +9,7 @@ fn make_new_path(path: ~str) -> ~str {\n     // maintain the current value while adding our own\n     match getenv(lib_path_env_var()) {\n       option::some(curr) => {\n-        fmt!{\"%s%s%s\", path, path_div(), curr}\n+        fmt!(\"%s%s%s\", path, path_div(), curr)\n       }\n       option::none => path\n     }"}, {"sha": "b1879ad75efce4e47abcf4af94f1edb5f5d5da38", "filename": "src/fuzzer/ast_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ffuzzer%2Fast_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ffuzzer%2Fast_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Fast_match.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -26,5 +26,5 @@ fn main() {\n     assert (!vec_equal(~[5, 5], ~[4, 5], builtin_equal_int));\n     assert (vec_equal(~[5, 5], ~[5, 5], builtin_equal_int));\n \n-    error!{\"Pass\"};\n+    error!(\"Pass\");\n }"}, {"sha": "d9e6c0042d4088458befd23bfb31688cff65c354", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -242,8 +242,8 @@ fn check_variants_T<T: copy>(\n   replacer: fn@(ast::crate, uint, T, test_mode) -> ast::crate,\n   cx: context\n   ) {\n-    error!{\"%s contains %u %s objects\", filename,\n-           vec::len(things), thing_label};\n+    error!(\"%s contains %u %s objects\", filename,\n+           vec::len(things), thing_label);\n \n     // Assuming we're not generating any token_trees\n     let intr = syntax::parse::token::mk_fake_ident_interner();\n@@ -274,9 +274,9 @@ fn check_variants_T<T: copy>(\n                     check_roundtrip_convergence(str3, 1u);\n                   }\n                   tm_run => {\n-                    let file_label = fmt!{\"rusttmp/%s_%s_%u_%u\",\n+                    let file_label = fmt!(\"rusttmp/%s_%s_%u_%u\",\n                                           last_part(filename),\n-                                          thing_label, i, j};\n+                                          thing_label, i, j);\n                     let safe_to_run = !(content_is_dangerous_to_run(*str3)\n                                         || has_raw_pointers(*crate2));\n                     check_whole_compiler(*str3, file_label, safe_to_run);\n@@ -386,7 +386,7 @@ fn check_compiling(filename: ~str) -> happiness {\n          stage1/bin/rustc\",\n         ~[filename]);\n \n-    //error!{\"Status: %d\", p.status};\n+    //error!(\"Status: %d\", p.status);\n     if p.status == 0 {\n         passed\n     } else if p.err != ~\"\" {\n@@ -515,9 +515,9 @@ fn check_roundtrip_convergence(code: @~str, maxIters: uint) {\n     }\n \n     if oldv == newv {\n-        error!{\"Converged after %u iterations\", i};\n+        error!(\"Converged after %u iterations\", i);\n     } else {\n-        error!{\"Did not converge after %u iterations!\", i};\n+        error!(\"Did not converge after %u iterations!\", i);\n         write_file(~\"round-trip-a.rs\", *oldv);\n         write_file(~\"round-trip-b.rs\", *newv);\n         run::run_program(~\"diff\",\n@@ -528,12 +528,12 @@ fn check_roundtrip_convergence(code: @~str, maxIters: uint) {\n }\n \n fn check_convergence(files: ~[~str]) {\n-    error!{\"pp convergence tests: %u files\", vec::len(files)};\n+    error!(\"pp convergence tests: %u files\", vec::len(files));\n     for files.each |file| {\n         if !file_might_not_converge(file) {\n             let s = @result::get(io::read_whole_file_str(file));\n             if !content_might_not_converge(*s) {\n-                error!{\"pp converge: %s\", file};\n+                error!(\"pp converge: %s\", file);\n                 // Change from 7u to 2u once\n                 // https://github.com/mozilla/rust/issues/850 is fixed\n                 check_roundtrip_convergence(s, 7u);\n@@ -545,8 +545,8 @@ fn check_convergence(files: ~[~str]) {\n fn check_variants(files: ~[~str], cx: context) {\n     for files.each |file| {\n         if cx.mode == tm_converge && file_might_not_converge(file) {\n-            error!{\"Skipping convergence test based on\\\n-                    file_might_not_converge\"};\n+            error!(\"Skipping convergence test based on\\\n+                    file_might_not_converge\");\n             again;\n         }\n \n@@ -568,7 +568,7 @@ fn check_variants(files: ~[~str], cx: context) {\n                 file,\n                 s, ~[], sess);\n         io::with_str_reader(*s, |rdr| {\n-            error!{\"%s\",\n+            error!(\"%s\",\n                    as_str(|a| pprust::print_crate(\n                        sess.cm,\n                        // Assuming no token_trees\n@@ -578,29 +578,29 @@ fn check_variants(files: ~[~str], cx: context) {\n                        file,\n                        rdr, a,\n                        pprust::no_ann(),\n-                       false) )}\n+                       false) ))\n         });\n         check_variants_of_ast(*crate, sess.cm, file, cx);\n     }\n }\n \n fn main(args: ~[~str]) {\n     if vec::len(args) != 2u {\n-        error!{\"usage: %s <testdir>\", args[0]};\n+        error!(\"usage: %s <testdir>\", args[0]);\n         return;\n     }\n     let mut files = ~[];\n     let root = args[1];\n \n     find_rust_files(files, root);\n-    error!{\"== check_convergence ==\"};\n+    error!(\"== check_convergence ==\");\n     check_convergence(files);\n-    error!{\"== check_variants: converge ==\"};\n+    error!(\"== check_variants: converge ==\");\n     check_variants(files, { mode: tm_converge });\n-    error!{\"== check_variants: run ==\"};\n+    error!(\"== check_variants: run ==\");\n     check_variants(files, { mode: tm_run });\n \n-    error!{\"Fuzzer done\"};\n+    error!(\"Fuzzer done\");\n }\n \n // Local Variables:"}, {"sha": "a381a64a63a342d995ea15c300657774795d3f17", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -21,7 +21,7 @@ combinations at the moment.\n \n Example:\n \n-debug!{\"hello, %s!\", \"world\"};\n+debug!(\"hello, %s!\", \"world\");\n \n */\n \n@@ -446,7 +446,7 @@ mod test {\n     #[test]\n     fn fmt_slice() {\n         let s = \"abc\";\n-        let _s = fmt!{\"%s\", s};\n+        let _s = fmt!(\"%s\", s);\n     }\n }\n "}, {"sha": "d7773d9349700c2896cb248c3ee8002c98df96ef", "filename": "src/libcore/future.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibcore%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibcore%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -11,7 +11,7 @@\n  * ~~~\n  * let delayed_fib = future::spawn {|| fib(5000) };\n  * make_a_sandwich();\n- * io::println(fmt!{\"fib(5000) = %?\", delayed_fib.get()})\n+ * io::println(fmt!(\"fib(5000) = %?\", delayed_fib.get()))\n  * ~~~\n  */\n \n@@ -64,9 +64,9 @@ fn from_value<A>(+val: A) -> Future<A> {\n     })\n }\n \n-macro_rules! move_it {\n+macro_rules! move_it (\n     {$x:expr} => { unsafe { let y <- *ptr::addr_of($x); y } }\n-}\n+)\n \n fn from_port<A:send>(+port: future_pipe::client::waiting<A>) -> Future<A> {\n     #[doc = \"\n@@ -82,7 +82,7 @@ fn from_port<A:send>(+port: future_pipe::client::waiting<A>) -> Future<A> {\n         port_ <-> *port;\n         let port = option::unwrap(port_);\n         match recv(port) {\n-          future_pipe::completed(data) => move_it!{data}\n+          future_pipe::completed(data) => move_it!(data)\n         }\n     }\n }"}, {"sha": "7130de88c12b0b5025b30dbe95a61d4e2be672ec", "filename": "src/libcore/hash.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibcore%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibcore%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -174,11 +174,11 @@ impl &SipState : io::Writer {\n                 t += 1;\n             }\n \n-            let m = u8to64_le!{self.tail, 0};\n+            let m = u8to64_le!(self.tail, 0);\n \n             self.v3 ^= m;\n-            compress!{self.v0, self.v1, self.v2, self.v3};\n-            compress!{self.v0, self.v1, self.v2, self.v3};\n+            compress!(self.v0, self.v1, self.v2, self.v3);\n+            compress!(self.v0, self.v1, self.v2, self.v3);\n             self.v0 ^= m;\n \n             self.ntail = 0;\n@@ -191,11 +191,11 @@ impl &SipState : io::Writer {\n \n         let mut i = needed;\n         while i < end {\n-            let mi = u8to64_le!{msg, i};\n+            let mi = u8to64_le!(msg, i);\n \n             self.v3 ^= mi;\n-            compress!{self.v0, self.v1, self.v2, self.v3};\n-            compress!{self.v0, self.v1, self.v2, self.v3};\n+            compress!(self.v0, self.v1, self.v2, self.v3);\n+            compress!(self.v0, self.v1, self.v2, self.v3);\n             self.v0 ^= mi;\n \n             i += 8;\n@@ -246,15 +246,15 @@ impl &SipState : Streaming {\n         if self.ntail > 6 { b |= self.tail[6] as u64 << 48; }\n \n         v3 ^= b;\n-        compress!{v0, v1, v2, v3};\n-        compress!{v0, v1, v2, v3};\n+        compress!(v0, v1, v2, v3);\n+        compress!(v0, v1, v2, v3);\n         v0 ^= b;\n \n         v2 ^= 0xff;\n-        compress!{v0, v1, v2, v3};\n-        compress!{v0, v1, v2, v3};\n-        compress!{v0, v1, v2, v3};\n-        compress!{v0, v1, v2, v3};\n+        compress!(v0, v1, v2, v3);\n+        compress!(v0, v1, v2, v3);\n+        compress!(v0, v1, v2, v3);\n+        compress!(v0, v1, v2, v3);\n \n         return (v0 ^ v1 ^ v2 ^ v3);\n     }\n@@ -373,18 +373,18 @@ fn test_siphash() {\n     }\n \n     while t < 64 {\n-        debug!{\"siphash test %?\", t};\n-        let vec = u8to64_le!{vecs[t], 0};\n+        debug!(\"siphash test %?\", t);\n+        let vec = u8to64_le!(vecs[t], 0);\n         let out = hash_bytes_keyed(buf, k0, k1);\n-        debug!{\"got %?, expected %?\", out, vec};\n+        debug!(\"got %?, expected %?\", out, vec);\n         assert vec == out;\n \n         stream_full.reset();\n         stream_full.input(buf);\n         let f = stream_full.result_str();\n         let i = stream_inc.result_str();\n         let v = to_hex_str(&vecs[t]);\n-        debug!{\"%d: (%s) => inc=%s full=%s\", t, v, i, f};\n+        debug!(\"%d: (%s) => inc=%s full=%s\", t, v, i, f);\n \n         assert f == i && f == v;\n "}, {"sha": "5634d5cfac5bb822968060bd0187103cc5f89641", "filename": "src/libcore/int-template.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibcore%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibcore%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint-template.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -97,8 +97,8 @@ impl T: iter::Times {\n         `for int::range(0, x) |_i| { /* anything */ }`.\"]\n     pure fn times(it: fn() -> bool) {\n         if self < 0 {\n-            fail fmt!{\"The .times method expects a nonnegative number, \\\n-                       but found %?\", self};\n+            fail fmt!(\"The .times method expects a nonnegative number, \\\n+                       but found %?\", self);\n         }\n         let mut i = self;\n         while i > 0 {\n@@ -114,8 +114,8 @@ impl T: iter::TimesIx {\n     pure fn timesi(it: fn(uint) -> bool) {\n         let slf = self as uint;\n         if slf < 0u {\n-            fail fmt!{\"The .timesi method expects a nonnegative number, \\\n-                       but found %?\", self};\n+            fail fmt!(\"The .timesi method expects a nonnegative number, \\\n+                       but found %?\", self);\n         }\n         let mut i = 0u;\n         while i < slf {"}, {"sha": "046d155a27a5d22e0f8757e25f35bc9ee694b67a", "filename": "src/libcore/io.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -292,7 +292,7 @@ impl ByteBuf: Reader {\n         return b as int;\n     }\n     // FIXME (#2738): implement this\n-    fn unread_byte(_byte: int) { error!{\"Unimplemented: unread_byte\"}; fail; }\n+    fn unread_byte(_byte: int) { error!(\"Unimplemented: unread_byte\"); fail; }\n     fn eof() -> bool { self.pos == self.len }\n     fn seek(offset: int, whence: SeekStyle) {\n         let pos = self.pos;\n@@ -358,7 +358,7 @@ impl *libc::FILE: Writer {\n             let nout = libc::fwrite(vbuf as *c_void, len as size_t,\n                                     1u as size_t, self);\n             if nout < 1 as size_t {\n-                error!{\"error writing buffer\"};\n+                error!(\"error writing buffer\");\n                 log(error, os::last_os_error());\n                 fail;\n             }\n@@ -393,7 +393,7 @@ impl fd_t: Writer {\n                 let vb = ptr::const_offset(vbuf, count) as *c_void;\n                 let nout = libc::write(self, vb, len as size_t);\n                 if nout < 0 as ssize_t {\n-                    error!{\"error writing buffer\"};\n+                    error!(\"error writing buffer\");\n                     log(error, os::last_os_error());\n                     fail;\n                 }\n@@ -402,11 +402,11 @@ impl fd_t: Writer {\n         }\n     }\n     fn seek(_offset: int, _whence: SeekStyle) {\n-        error!{\"need 64-bit foreign calls for seek, sorry\"};\n+        error!(\"need 64-bit foreign calls for seek, sorry\");\n         fail;\n     }\n     fn tell() -> uint {\n-        error!{\"need 64-bit foreign calls for tell, sorry\"};\n+        error!(\"need 64-bit foreign calls for tell, sorry\");\n         fail;\n     }\n     fn flush() -> int { 0 }\n@@ -453,7 +453,7 @@ fn mk_file_writer(path: ~str, flags: ~[FileFlag])\n                    (S_IRUSR | S_IWUSR) as c_int)\n     };\n     if fd < (0 as c_int) {\n-        result::err(fmt!{\"error opening %s: %s\", path, os::last_os_error()})\n+        result::err(fmt!(\"error opening %s: %s\", path, os::last_os_error()))\n     } else {\n         result::ok(fd_writer(fd, true))\n     }"}, {"sha": "39adaa313edf2e076054a7786ca2f27f996d62c2", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -176,7 +176,7 @@ pure fn find<A: copy,IA:BaseIter<A>>(self: IA,\n #[test]\n fn test_enumerate() {\n     enumerate([\"0\", \"1\", \"2\"]) {|i,j|\n-        assert fmt!{\"%u\",i} == j;\n+        assert fmt!(\"%u\",i) == j;\n     }\n }\n \n@@ -254,7 +254,7 @@ fn test_flat_map_with_list() {\n     let a = bind vec::iter(~[0, 1, 2, 3], _);\n     let b = bind flat_map(a, repeat, _);\n     let c = to_vec(b);\n-    debug!{\"c = %?\", c};\n+    debug!(\"c = %?\", c);\n     assert c == ~[1, 2, 2, 3, 3, 3];\n }\n \n@@ -265,7 +265,7 @@ fn test_repeat() {\n         c += ~[(i * i)];\n         i += 1u;\n     };\n-    debug!{\"c = %?\", c};\n+    debug!(\"c = %?\", c);\n     assert c == ~[0u, 1u, 4u, 9u, 16u];\n }\n "}, {"sha": "30bcd8043308af93ed0955e8e380a9f2f96382e6", "filename": "src/libcore/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -1036,7 +1036,7 @@ mod tests {\n       assert (libc::fclose(ostream) == (0u as c_int));\n       let rs = os::copy_file(in, out);\n       if (!os::path_exists(in)) {\n-        fail (fmt!{\"%s doesn't exist\", in});\n+        fail (fmt!(\"%s doesn't exist\", in));\n       }\n       assert(rs);\n       let rslt = run::run_program(~\"diff\", ~[in, out]);"}, {"sha": "048bd64f8f620a0e8a565771c7c03f06525de901", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -103,9 +103,9 @@ export rt;\n #[doc(hidden)]\n const SPIN_COUNT: uint = 0;\n \n-macro_rules! move_it {\n+macro_rules! move_it (\n     { $x:expr } => { unsafe { let y <- *ptr::addr_of($x); y } }\n-}\n+)\n \n #[doc(hidden)]\n enum state {\n@@ -335,15 +335,15 @@ struct buffer_resource<T: send> {\n     let buffer: ~buffer<T>;\n     new(+b: ~buffer<T>) {\n         //let p = ptr::addr_of(*b);\n-        //error!{\"take %?\", p};\n+        //error!(\"take %?\", p);\n         atomic_add_acq(&mut b.header.ref_count, 1);\n         self.buffer = b;\n     }\n \n     drop unsafe {\n-        let b = move_it!{self.buffer};\n+        let b = move_it!(self.buffer);\n         //let p = ptr::addr_of(*b);\n-        //error!{\"drop %?\", p};\n+        //error!(\"drop %?\", p);\n         let old_count = atomic_sub_rel(&mut b.header.ref_count, 1);\n         //let old_count = atomic_xchng_rel(b.header.ref_count, 0);\n         if old_count == 1 {\n@@ -377,7 +377,7 @@ fn send<T: send, Tbuffer: send>(+p: send_packet_buffered<T, Tbuffer>,\n         }\n         full => fail ~\"duplicate send\",\n         blocked => {\n-            debug!{\"waking up task for %?\", p_};\n+            debug!(\"waking up task for %?\", p_);\n             let old_task = swap_task(&mut p.header.blocked_task, ptr::null());\n             if !old_task.is_null() {\n                 rustrt::task_signal_event(\n@@ -461,7 +461,7 @@ fn try_recv<T: send, Tbuffer: send>(+p: recv_packet_buffered<T, Tbuffer>)\n                                        blocked);\n         match old_state {\n           empty => {\n-            debug!{\"no data available on %?, going to sleep.\", p_};\n+            debug!(\"no data available on %?, going to sleep.\", p_);\n             if count == 0 {\n                 wait_event(this);\n             }\n@@ -474,7 +474,7 @@ fn try_recv<T: send, Tbuffer: send>(+p: recv_packet_buffered<T, Tbuffer>)\n                 // sometimes blocking the thing we are waiting on.\n                 task::yield();\n             }\n-            debug!{\"woke up, p.state = %?\", copy p.header.state};\n+            debug!(\"woke up, p.state = %?\", copy p.header.state);\n           }\n           blocked => if first {\n             fail ~\"blocking on already blocked packet\"\n@@ -603,7 +603,7 @@ fn wait_many<T: selectable>(pkts: &[T]) -> uint {\n     }\n \n     while !data_avail {\n-        debug!{\"sleeping on %? packets\", pkts.len()};\n+        debug!(\"sleeping on %? packets\", pkts.len());\n         let event = wait_event(this) as *packet_header;\n         let pos = vec::position(pkts, |p| p.header() == event);\n \n@@ -612,11 +612,11 @@ fn wait_many<T: selectable>(pkts: &[T]) -> uint {\n             ready_packet = i;\n             data_avail = true;\n           }\n-          none => debug!{\"ignoring spurious event, %?\", event}\n+          none => debug!(\"ignoring spurious event, %?\", event)\n         }\n     }\n \n-    debug!{\"%?\", pkts[ready_packet]};\n+    debug!(\"%?\", pkts[ready_packet]);\n \n     for pkts.each |p| { unsafe{ (*p.header()).unblock()} }\n \n@@ -725,7 +725,7 @@ struct send_packet_buffered<T: send, Tbuffer: send> {\n     let mut p: option<*packet<T>>;\n     let mut buffer: option<buffer_resource<Tbuffer>>;\n     new(p: *packet<T>) {\n-        //debug!{\"take send %?\", p};\n+        //debug!(\"take send %?\", p);\n         self.p = some(p);\n         unsafe {\n             self.buffer = some(\n@@ -735,17 +735,17 @@ struct send_packet_buffered<T: send, Tbuffer: send> {\n     }\n     drop {\n         //if self.p != none {\n-        //    debug!{\"drop send %?\", option::get(self.p)};\n+        //    debug!(\"drop send %?\", option::get(self.p));\n         //}\n         if self.p != none {\n             let mut p = none;\n             p <-> self.p;\n             sender_terminate(option::unwrap(p))\n         }\n-        //unsafe { error!{\"send_drop: %?\",\n+        //unsafe { error!(\"send_drop: %?\",\n         //                if self.buffer == none {\n         //                    \"none\"\n-        //                } else { \"some\" }}; }\n+        //                } else { \"some\" }); }\n     }\n     fn unwrap() -> *packet<T> {\n         let mut p = none;\n@@ -766,7 +766,7 @@ struct send_packet_buffered<T: send, Tbuffer: send> {\n     }\n \n     fn reuse_buffer() -> buffer_resource<Tbuffer> {\n-        //error!{\"send reuse_buffer\"};\n+        //error!(\"send reuse_buffer\");\n         let mut tmp = none;\n         tmp <-> self.buffer;\n         option::unwrap(tmp)\n@@ -786,7 +786,7 @@ struct recv_packet_buffered<T: send, Tbuffer: send> : selectable {\n     let mut p: option<*packet<T>>;\n     let mut buffer: option<buffer_resource<Tbuffer>>;\n     new(p: *packet<T>) {\n-        //debug!{\"take recv %?\", p};\n+        //debug!(\"take recv %?\", p);\n         self.p = some(p);\n         unsafe {\n             self.buffer = some(\n@@ -796,17 +796,17 @@ struct recv_packet_buffered<T: send, Tbuffer: send> : selectable {\n     }\n     drop {\n         //if self.p != none {\n-        //    debug!{\"drop recv %?\", option::get(self.p)};\n+        //    debug!(\"drop recv %?\", option::get(self.p));\n         //}\n         if self.p != none {\n             let mut p = none;\n             p <-> self.p;\n             receiver_terminate(option::unwrap(p))\n         }\n-        //unsafe { error!{\"recv_drop: %?\",\n+        //unsafe { error!(\"recv_drop: %?\",\n         //                if self.buffer == none {\n         //                    \"none\"\n-        //                } else { \"some\" }}; }\n+        //                } else { \"some\" }); }\n     }\n     fn unwrap() -> *packet<T> {\n         let mut p = none;\n@@ -827,7 +827,7 @@ struct recv_packet_buffered<T: send, Tbuffer: send> : selectable {\n     }\n \n     fn reuse_buffer() -> buffer_resource<Tbuffer> {\n-        //error!{\"recv reuse_buffer\"};\n+        //error!(\"recv reuse_buffer\");\n         let mut tmp = none;\n         tmp <-> self.buffer;\n         option::unwrap(tmp)\n@@ -991,8 +991,8 @@ impl<T: send> port<T>: recv<T> {\n         endp <-> self.endp;\n         match move pipes::try_recv(unwrap(endp)) {\n           some(streamp::data(x, endp)) => {\n-            self.endp = some(move_it!{endp});\n-            some(move_it!{x})\n+            self.endp = some(move_it!(endp));\n+            some(move_it!(x))\n           }\n           none => none\n         }"}, {"sha": "c341d01fba89ae0a79547920eae6a4ce2d48e1f3", "filename": "src/libcore/priv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibcore%2Fpriv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibcore%2Fpriv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpriv.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -69,7 +69,7 @@ unsafe fn chan_from_global_ptr<T: send>(\n         log(debug,~\"BEFORE COMPARE AND SWAP\");\n         let swapped = compare_and_swap(\n             global, 0u, unsafe::reinterpret_cast(ch));\n-        log(debug,fmt!{\"AFTER .. swapped? %?\", swapped});\n+        log(debug,fmt!(\"AFTER .. swapped? %?\", swapped));\n \n         if swapped {\n             // Success!"}, {"sha": "41e2cfd99dde676632d2181c8938bd0854426e59", "filename": "src/libcore/rand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibcore%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibcore%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frand.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -328,7 +328,7 @@ mod tests {\n         let ra = rand::seeded_rng(seed);\n         // Regression test that isaac is actually using the above vector\n         let r = ra.next();\n-        error!{\"%?\", r};\n+        error!(\"%?\", r);\n         assert r == 890007737u32 // on x86_64\n             || r == 2935188040u32; // on x86\n     }"}, {"sha": "9b8482c5b5c234510b3dcc1e1bed3c728202c73a", "filename": "src/libcore/result.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -21,7 +21,7 @@ pure fn get<T: copy, U>(res: result<T, U>) -> T {\n     match res {\n       ok(t) => t,\n       err(the_err) => unchecked {\n-        fail fmt!{\"get called on error result: %?\", the_err}\n+        fail fmt!(\"get called on error result: %?\", the_err)\n       }\n     }\n }"}, {"sha": "977119c0a56207051677acc4acc61bf82c761fa0", "filename": "src/libcore/run.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -106,7 +106,7 @@ fn with_envp<T>(env: &option<~[(~str,~str)]>,\n \n         for vec::each(es) |e| {\n             let (k,v) = e;\n-            let t = @(fmt!{\"%s=%s\", k, v});\n+            let t = @(fmt!(\"%s=%s\", k, v));\n             vec::push(tmps, t);\n             vec::push_all(ptrs, str::as_c_str(*t, |b| ~[b]));\n         }\n@@ -131,7 +131,7 @@ fn with_envp<T>(env: &option<~[(~str,~str)]>,\n             let mut blk : ~[u8] = ~[];\n             for vec::each(es) |e| {\n                 let (k,v) = e;\n-                let t = fmt!{\"%s=%s\", k, v};\n+                let t = fmt!(\"%s=%s\", k, v);\n                 let mut v : ~[u8] = ::unsafe::reinterpret_cast(t);\n                 blk += v;\n                 ::unsafe::forget(v);\n@@ -332,7 +332,7 @@ fn program_output(prog: &str, args: &[~str]) ->\n fn writeclose(fd: c_int, s: &str) {\n     import io::WriterUtil;\n \n-    error!{\"writeclose %d, %s\", fd as int, s};\n+    error!(\"writeclose %d, %s\", fd as int, s);\n     let writer = io::fd_writer(fd, false);\n     writer.write_str(s);\n "}, {"sha": "9792b7c805bd48c012c050cf82c9d697dd7aaf46", "filename": "src/libcore/send_map.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibcore%2Fsend_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibcore%2Fsend_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsend_map.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -76,7 +76,7 @@ mod linear {\n                             len_buckets: uint) -> uint {\n             let n = (idx + 1) % len_buckets;\n             unsafe{ // argh. log not considered pure.\n-                debug!{\"next_bucket(%?, %?) = %?\", idx, len_buckets, n};\n+                debug!(\"next_bucket(%?, %?) = %?\", idx, len_buckets, n);\n             }\n             return n;\n         }\n@@ -154,15 +154,15 @@ mod linear {\n             match self.bucket_for_key_with_hash(self.buckets, hash, &k) {\n               TableFull => {fail ~\"Internal logic error\";}\n               FoundHole(idx) => {\n-                debug!{\"insert fresh (%?->%?) at idx %?, hash %?\",\n-                       k, v, idx, hash};\n+                debug!(\"insert fresh (%?->%?) at idx %?, hash %?\",\n+                       k, v, idx, hash);\n                 self.buckets[idx] = some({hash: hash, key: k, value: v});\n                 self.size += 1;\n                 return true;\n               }\n               FoundEntry(idx) => {\n-                debug!{\"insert overwrite (%?->%?) at idx %?, hash %?\",\n-                       k, v, idx, hash};\n+                debug!(\"insert overwrite (%?->%?) at idx %?, hash %?\",\n+                       k, v, idx, hash);\n                 self.buckets[idx] = some({hash: hash, key: k, value: v});\n                 return false;\n               }\n@@ -308,7 +308,7 @@ mod linear {\n         fn get(&const self, k: &K) -> V {\n             let value = self.find(k);\n             if value.is_none() {\n-                fail fmt!{\"No entry found for key: %?\", k};\n+                fail fmt!(\"No entry found for key: %?\", k);\n             }\n             option::unwrap(value)\n         }"}, {"sha": "3dad707a92bf43d7604735ccc5747ece3a0b05ef", "filename": "src/libcore/stackwalk.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibcore%2Fstackwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibcore%2Fstackwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstackwalk.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -16,7 +16,7 @@ struct Frame {\n \n fn walk_stack(visit: fn(Frame) -> bool) {\n \n-    debug!{\"beginning stack walk\"};\n+    debug!(\"beginning stack walk\");\n \n     do frame_address |frame_pointer| {\n         let mut frame_address: *Word = unsafe {\n@@ -25,14 +25,14 @@ fn walk_stack(visit: fn(Frame) -> bool) {\n         loop {\n             let fr = Frame(frame_address);\n \n-            debug!{\"frame: %x\", unsafe { reinterpret_cast(fr.fp) }};\n+            debug!(\"frame: %x\", unsafe { reinterpret_cast(fr.fp) });\n             visit(fr);\n \n             unsafe {\n                 let next_fp: **Word = reinterpret_cast(frame_address);\n                 frame_address = *next_fp;\n                 if *frame_address == 0u {\n-                    debug!{\"encountered task_start_wrapper. ending walk\"};\n+                    debug!(\"encountered task_start_wrapper. ending walk\");\n                     // This is the task_start_wrapper_frame. There is\n                     // no stack beneath it and it is a foreign frame.\n                     break;"}, {"sha": "e3d976cb0a2d011e315282b901fdcc1c713f9a06", "filename": "src/libcore/str.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -1464,7 +1464,7 @@ pure fn is_char_boundary(s: &str, index: uint) -> bool {\n  * let i = 0u;\n  * while i < str::len(s) {\n  *     let {ch, next} = str::char_range_at(s, i);\n- *     std::io::println(fmt!{\"%u: %c\",i,ch});\n+ *     std::io::println(fmt!(\"%u: %c\",i,ch));\n  *     i = next;\n  * }\n  * ~~~\n@@ -2138,7 +2138,7 @@ mod tests {\n         fn t(s: ~str, c: char, u: ~[~str]) {\n             log(debug, ~\"split_byte: \" + s);\n             let v = split_char(s, c);\n-            debug!{\"split_byte to: %?\", v};\n+            debug!(\"split_byte to: %?\", v);\n             assert vec::all2(v, u, |a,b| a == b);\n         }\n         t(~\"abc.hello.there\", '.', ~[~\"abc\", ~\"hello\", ~\"there\"]);\n@@ -2167,8 +2167,8 @@ mod tests {\n         fn t(s: ~str, c: char, n: uint, u: ~[~str]) {\n             log(debug, ~\"splitn_byte: \" + s);\n             let v = splitn_char(s, c, n);\n-            debug!{\"split_byte to: %?\", v};\n-            debug!{\"comparing vs. %?\", u};\n+            debug!(\"split_byte to: %?\", v);\n+            debug!(\"comparing vs. %?\", u);\n             assert vec::all2(v, u, |a,b| a == b);\n         }\n         t(~\"abc.hello.there\", '.', 0u, ~[~\"abc.hello.there\"]);"}, {"sha": "4752b2d3a565de5387d1aa1953c2d05d1dd94051", "filename": "src/libcore/task.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -1031,10 +1031,10 @@ fn kill_taskgroup(state: TaskGroupInner, me: *rust_task, is_main: bool) {\n \n // FIXME (#2912): Work around core-vs-coretest function duplication. Can't use\n // a proper closure because the #[test]s won't understand. Have to fake it.\n-macro_rules! taskgroup_key {\n+macro_rules! taskgroup_key (\n     // Use a \"code pointer\" value that will never be a real code pointer.\n     {} => (unsafe::transmute((-2 as uint, 0u)))\n-}\n+)\n \n fn gen_child_taskgroup(linked: bool, supervised: bool)\n         -> (TaskGroupArc, AncestorList, bool) {"}, {"sha": "2e280747d20dc25935cc1314d1cebd4ca91152a3", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -274,37 +274,37 @@ mod tests {\n         fn reccyeq(a: reccy, b: reccy) -> bool {\n             return a.x == b.x && a.y == b.y && taggyeq(a.t, b.t);\n         }\n-        debug!{\"*** test boxes\"};\n+        debug!(\"*** test boxes\");\n         test_boxes(@5, @72, @64, @175);\n-        debug!{\"*** end test boxes\"};\n-        debug!{\"test parameterized: int\"};\n+        debug!(\"*** end test boxes\");\n+        debug!(\"test parameterized: int\");\n         let eq1: eqfn<int> = inteq;\n         test_parameterized::<int>(eq1, 5, 72, 64, 175);\n-        debug!{\"*** test parameterized: @int\"};\n+        debug!(\"*** test parameterized: @int\");\n         let eq2: eqfn<@int> = intboxeq;\n         test_parameterized::<@int>(eq2, @5, @72, @64, @175);\n-        debug!{\"*** end test parameterized @int\"};\n-        debug!{\"test parameterized: taggy\"};\n+        debug!(\"*** end test parameterized @int\");\n+        debug!(\"test parameterized: taggy\");\n         let eq3: eqfn<taggy> = taggyeq;\n         test_parameterized::<taggy>(eq3, one(1), two(1, 2), three(1, 2, 3),\n                                     two(17, 42));\n \n-        debug!{\"*** test parameterized: taggypar<int>\"};\n+        debug!(\"*** test parameterized: taggypar<int>\");\n         let eq4: eqfn<taggypar<int>> = |x,y| taggypareq::<int>(x, y);\n         test_parameterized::<taggypar<int>>(eq4, onepar::<int>(1),\n                                             twopar::<int>(1, 2),\n                                             threepar::<int>(1, 2, 3),\n                                             twopar::<int>(17, 42));\n-        debug!{\"*** end test parameterized: taggypar::<int>\"};\n+        debug!(\"*** end test parameterized: taggypar::<int>\");\n \n-        debug!{\"*** test parameterized: reccy\"};\n+        debug!(\"*** test parameterized: reccy\");\n         let reccy1: reccy = {x: 1, y: 2, t: one(1)};\n         let reccy2: reccy = {x: 345, y: 2, t: two(1, 2)};\n         let reccy3: reccy = {x: 1, y: 777, t: three(1, 2, 3)};\n         let reccy4: reccy = {x: 19, y: 252, t: two(17, 42)};\n         let eq5: eqfn<reccy> = reccyeq;\n         test_parameterized::<reccy>(eq5, reccy1, reccy2, reccy3, reccy4);\n-        debug!{\"*** end test parameterized: reccy\"};\n-        debug!{\"*** done\"};\n+        debug!(\"*** end test parameterized: reccy\");\n+        debug!(\"*** done\");\n     }\n }"}, {"sha": "758dcf4eebf810a6cc0035e95ed28c474ba7ab44", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -70,7 +70,7 @@ fn vuint_at(data: &[u8], start: uint) -> {val: uint, next: uint} {\n                  (data[start + 2u] as uint) << 8u |\n                  (data[start + 3u] as uint),\n              next: start + 4u};\n-    } else { error!{\"vint too big\"}; fail; }\n+    } else { error!(\"vint too big\"); fail; }\n }\n \n fn doc(data: @~[u8]) -> doc {\n@@ -106,7 +106,7 @@ fn get_doc(d: doc, tg: uint) -> doc {\n     match maybe_get_doc(d, tg) {\n       some(d) => return d,\n       none => {\n-        error!{\"failed to find block with tag %u\", tg};\n+        error!(\"failed to find block with tag %u\", tg);\n         fail;\n       }\n     }\n@@ -186,7 +186,7 @@ fn write_sized_vuint(w: io::Writer, n: uint, size: uint) {\n                       n as u8]),\n       4u => w.write(&[0x10u8 | ((n >> 24_u) as u8), (n >> 16_u) as u8,\n                       (n >> 8_u) as u8, n as u8]),\n-      _ => fail fmt!{\"vint to write too big: %?\", n}\n+      _ => fail fmt!(\"vint to write too big: %?\", n)\n     };\n }\n \n@@ -195,7 +195,7 @@ fn write_vuint(w: io::Writer, n: uint) {\n     if n < 0x4000_u { write_sized_vuint(w, n, 2u); return; }\n     if n < 0x200000_u { write_sized_vuint(w, n, 3u); return; }\n     if n < 0x10000000_u { write_sized_vuint(w, n, 4u); return; }\n-    fail fmt!{\"vint to write too big: %?\", n};\n+    fail fmt!(\"vint to write too big: %?\", n);\n }\n \n fn writer(w: io::Writer) -> writer {\n@@ -206,7 +206,7 @@ fn writer(w: io::Writer) -> writer {\n // FIXME (#2741): Provide a function to write the standard ebml header.\n impl writer {\n     fn start_tag(tag_id: uint) {\n-        debug!{\"Start tag %u\", tag_id};\n+        debug!(\"Start tag %u\", tag_id);\n \n         // Write the enum ID:\n         write_vuint(self.writer, tag_id);\n@@ -225,7 +225,7 @@ impl writer {\n         write_sized_vuint(self.writer, size, 4u);\n         self.writer.seek(cur_pos as int, io::SeekSet);\n \n-        debug!{\"End tag (size = %u)\", size};\n+        debug!(\"End tag (size = %u)\", size);\n     }\n \n     fn wr_tag(tag_id: uint, blk: fn()) {\n@@ -289,12 +289,12 @@ impl writer {\n     }\n \n     fn wr_bytes(b: &[u8]) {\n-        debug!{\"Write %u bytes\", vec::len(b)};\n+        debug!(\"Write %u bytes\", vec::len(b));\n         self.writer.write(b);\n     }\n \n     fn wr_str(s: ~str) {\n-        debug!{\"Write str: %?\", s};\n+        debug!(\"Write str: %?\", s);\n         self.writer.write(str::bytes(s));\n     }\n }\n@@ -417,29 +417,29 @@ priv impl ebml_deserializer {\n                 self.pos = r_doc.end;\n                 let str = ebml::doc_as_str(r_doc);\n                 if lbl != str {\n-                    fail fmt!{\"Expected label %s but found %s\", lbl, str};\n+                    fail fmt!(\"Expected label %s but found %s\", lbl, str);\n                 }\n             }\n         }\n     }\n \n     fn next_doc(exp_tag: ebml_serializer_tag) -> ebml::doc {\n-        debug!{\". next_doc(exp_tag=%?)\", exp_tag};\n+        debug!(\". next_doc(exp_tag=%?)\", exp_tag);\n         if self.pos >= self.parent.end {\n             fail ~\"no more documents in current node!\";\n         }\n         let {tag: r_tag, doc: r_doc} =\n             ebml::doc_at(self.parent.data, self.pos);\n-        debug!{\"self.parent=%?-%? self.pos=%? r_tag=%? r_doc=%?-%?\",\n+        debug!(\"self.parent=%?-%? self.pos=%? r_tag=%? r_doc=%?-%?\",\n                copy self.parent.start, copy self.parent.end,\n-               copy self.pos, r_tag, r_doc.start, r_doc.end};\n+               copy self.pos, r_tag, r_doc.start, r_doc.end);\n         if r_tag != (exp_tag as uint) {\n-            fail fmt!{\"expected EMBL doc with tag %? but found tag %?\",\n-                      exp_tag, r_tag};\n+            fail fmt!(\"expected EMBL doc with tag %? but found tag %?\",\n+                      exp_tag, r_tag);\n         }\n         if r_doc.end > self.parent.end {\n-            fail fmt!{\"invalid EBML, child extends to 0x%x, parent to 0x%x\",\n-                      r_doc.end, self.parent.end};\n+            fail fmt!(\"invalid EBML, child extends to 0x%x, parent to 0x%x\",\n+                      r_doc.end, self.parent.end);\n         }\n         self.pos = r_doc.end;\n         return r_doc;\n@@ -458,7 +458,7 @@ priv impl ebml_deserializer {\n \n     fn _next_uint(exp_tag: ebml_serializer_tag) -> uint {\n         let r = ebml::doc_as_u32(self.next_doc(exp_tag));\n-        debug!{\"_next_uint exp_tag=%? result=%?\", exp_tag, r};\n+        debug!(\"_next_uint exp_tag=%? result=%?\", exp_tag, r);\n         return r as uint;\n     }\n }\n@@ -473,7 +473,7 @@ impl ebml_deserializer: serialization::deserializer {\n     fn read_uint() -> uint {\n         let v = ebml::doc_as_u64(self.next_doc(es_uint));\n         if v > (core::uint::max_value as u64) {\n-            fail fmt!{\"uint %? too large for this architecture\", v};\n+            fail fmt!(\"uint %? too large for this architecture\", v);\n         }\n         return v as uint;\n     }\n@@ -485,7 +485,7 @@ impl ebml_deserializer: serialization::deserializer {\n     fn read_int() -> int {\n         let v = ebml::doc_as_u64(self.next_doc(es_int)) as i64;\n         if v > (int::max_value as i64) || v < (int::min_value as i64) {\n-            fail fmt!{\"int %? out of range for this architecture\", v};\n+            fail fmt!(\"int %? out of range for this architecture\", v);\n         }\n         return v as int;\n     }\n@@ -500,67 +500,67 @@ impl ebml_deserializer: serialization::deserializer {\n \n     // Compound types:\n     fn read_enum<T>(name: ~str, f: fn() -> T) -> T {\n-        debug!{\"read_enum(%s)\", name};\n+        debug!(\"read_enum(%s)\", name);\n         self._check_label(name);\n         self.push_doc(self.next_doc(es_enum), f)\n     }\n \n     fn read_enum_variant<T>(f: fn(uint) -> T) -> T {\n-        debug!{\"read_enum_variant()\"};\n+        debug!(\"read_enum_variant()\");\n         let idx = self._next_uint(es_enum_vid);\n-        debug!{\"  idx=%u\", idx};\n+        debug!(\"  idx=%u\", idx);\n         do self.push_doc(self.next_doc(es_enum_body)) {\n             f(idx)\n         }\n     }\n \n     fn read_enum_variant_arg<T>(idx: uint, f: fn() -> T) -> T {\n-        debug!{\"read_enum_variant_arg(idx=%u)\", idx};\n+        debug!(\"read_enum_variant_arg(idx=%u)\", idx);\n         f()\n     }\n \n     fn read_vec<T>(f: fn(uint) -> T) -> T {\n-        debug!{\"read_vec()\"};\n+        debug!(\"read_vec()\");\n         do self.push_doc(self.next_doc(es_vec)) {\n             let len = self._next_uint(es_vec_len);\n-            debug!{\"  len=%u\", len};\n+            debug!(\"  len=%u\", len);\n             f(len)\n         }\n     }\n \n     fn read_vec_elt<T>(idx: uint, f: fn() -> T) -> T {\n-        debug!{\"read_vec_elt(idx=%u)\", idx};\n+        debug!(\"read_vec_elt(idx=%u)\", idx);\n         self.push_doc(self.next_doc(es_vec_elt), f)\n     }\n \n     fn read_box<T>(f: fn() -> T) -> T {\n-        debug!{\"read_box()\"};\n+        debug!(\"read_box()\");\n         f()\n     }\n \n     fn read_uniq<T>(f: fn() -> T) -> T {\n-        debug!{\"read_uniq()\"};\n+        debug!(\"read_uniq()\");\n         f()\n     }\n \n     fn read_rec<T>(f: fn() -> T) -> T {\n-        debug!{\"read_rec()\"};\n+        debug!(\"read_rec()\");\n         f()\n     }\n \n     fn read_rec_field<T>(f_name: ~str, f_idx: uint, f: fn() -> T) -> T {\n-        debug!{\"read_rec_field(%s, idx=%u)\", f_name, f_idx};\n+        debug!(\"read_rec_field(%s, idx=%u)\", f_name, f_idx);\n         self._check_label(f_name);\n         f()\n     }\n \n     fn read_tup<T>(sz: uint, f: fn() -> T) -> T {\n-        debug!{\"read_tup(sz=%u)\", sz};\n+        debug!(\"read_tup(sz=%u)\", sz);\n         f()\n     }\n \n     fn read_tup_elt<T>(idx: uint, f: fn() -> T) -> T {\n-        debug!{\"read_tup_elt(idx=%u)\", idx};\n+        debug!(\"read_tup_elt(idx=%u)\", idx);\n         f()\n     }\n }\n@@ -613,14 +613,14 @@ fn test_option_int() {\n     }\n \n     fn test_v(v: option<int>) {\n-        debug!{\"v == %?\", v};\n+        debug!(\"v == %?\", v);\n         let mbuf = io::mem_buffer();\n         let ebml_w = ebml::writer(io::mem_buffer_writer(mbuf));\n         serialize_0(ebml_w, v);\n         let ebml_doc = ebml::doc(@io::mem_buffer_buf(mbuf));\n         let deser = ebml_deserializer(ebml_doc);\n         let v1 = deserialize_0(deser);\n-        debug!{\"v1 == %?\", v1};\n+        debug!(\"v1 == %?\", v1);\n         assert v == v1;\n     }\n "}, {"sha": "f14d2e32263d838cb4f950878e7a9cba09561608", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -314,7 +314,7 @@ fn opt_vals(m: matches, nm: ~str) -> ~[optval] {\n     return match find_opt(m.opts, mkname(nm)) {\n       some(id) => m.vals[id],\n       none => {\n-        error!{\"No option '%s' defined\", nm};\n+        error!(\"No option '%s' defined\", nm);\n         fail\n       }\n     };"}, {"sha": "5523de29aebce761bcc083edaf7cbf57ec23876b", "filename": "src/libstd/json.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -628,7 +628,7 @@ impl json: to_str::ToStr {\n \n impl error: to_str::ToStr {\n     fn to_str() -> ~str {\n-        fmt!{\"%u:%u: %s\", self.line, self.col, *self.msg}\n+        fmt!(\"%u:%u: %s\", self.line, self.col, *self.msg)\n     }\n }\n "}, {"sha": "7ed64c947a2ae4b3d05e4101dfbd6cdad52a9fc4", "filename": "src/libstd/map.rs", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibstd%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibstd%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmap.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -137,16 +137,16 @@ mod chained {\n             loop {\n                 match copy e0.next {\n                   none => {\n-                    debug!{\"search_tbl: absent, comp %u, hash %u, idx %u\",\n-                           comp, h, idx};\n+                    debug!(\"search_tbl: absent, comp %u, hash %u, idx %u\",\n+                           comp, h, idx);\n                     return not_found;\n                   }\n                   some(e1) => {\n                     comp += 1u;\n                     if e1.hash == h && self.eqer(&e1.key, k) {\n-                        debug!{\"search_tbl: present, comp %u, \\\n+                        debug!(\"search_tbl: present, comp %u, \\\n                                 hash %u, idx %u\",\n-                               comp, h, idx};\n+                               comp, h, idx);\n                         return found_after(e0, e1);\n                     } else {\n                         e0 = e1;\n@@ -160,14 +160,14 @@ mod chained {\n             let idx = h % vec::len(self.chains);\n             match copy self.chains[idx] {\n               none => {\n-                debug!{\"search_tbl: none, comp %u, hash %u, idx %u\",\n-                       0u, h, idx};\n+                debug!(\"search_tbl: none, comp %u, hash %u, idx %u\",\n+                       0u, h, idx);\n                 return not_found;\n               }\n               some(e) => {\n                 if e.hash == h && self.eqer(&e.key, k) {\n-                    debug!{\"search_tbl: present, comp %u, hash %u, idx %u\",\n-                           1u, h, idx};\n+                    debug!(\"search_tbl: present, comp %u, hash %u, idx %u\",\n+                           1u, h, idx);\n                     return found_first(idx, e);\n                 } else {\n                     return self.search_rem(k, h, idx, e);\n@@ -277,7 +277,7 @@ mod chained {\n         fn get(+k: K) -> V {\n             let opt_v = self.find(k);\n             if opt_v.is_none() {\n-                fail fmt!{\"Key not found in table: %?\", k};\n+                fail fmt!(\"Key not found in table: %?\", k);\n             }\n             option::unwrap(opt_v)\n         }\n@@ -563,14 +563,14 @@ mod tests {\n \n     #[test]\n     fn test_simple() {\n-        debug!{\"*** starting test_simple\"};\n+        debug!(\"*** starting test_simple\");\n         pure fn eq_uint(x: &uint, y: &uint) -> bool { *x == *y }\n         pure fn uint_id(x: &uint) -> uint { *x }\n         let hasher_uint: map::hashfn<uint> = uint_id;\n         let eqer_uint: map::eqfn<uint> = eq_uint;\n         let hasher_str: map::hashfn<~str> = str::hash;\n         let eqer_str: map::eqfn<~str> = str::eq;\n-        debug!{\"uint -> uint\"};\n+        debug!(\"uint -> uint\");\n         let hm_uu: map::hashmap<uint, uint> =\n             map::hashmap::<uint, uint>(copy hasher_uint, copy eqer_uint);\n         assert (hm_uu.insert(10u, 12u));\n@@ -586,7 +586,7 @@ mod tests {\n         let ten: ~str = ~\"ten\";\n         let eleven: ~str = ~\"eleven\";\n         let twelve: ~str = ~\"twelve\";\n-        debug!{\"str -> uint\"};\n+        debug!(\"str -> uint\");\n         let hm_su: map::hashmap<~str, uint> =\n             map::hashmap::<~str, uint>(copy hasher_str, copy eqer_str);\n         assert (hm_su.insert(~\"ten\", 12u));\n@@ -600,7 +600,7 @@ mod tests {\n         assert (hm_su.get(~\"twelve\") == 14u);\n         assert (!hm_su.insert(~\"twelve\", 12u));\n         assert (hm_su.get(~\"twelve\") == 12u);\n-        debug!{\"uint -> str\"};\n+        debug!(\"uint -> str\");\n         let hm_us: map::hashmap<uint, ~str> =\n             map::hashmap::<uint, ~str>(copy hasher_uint, copy eqer_uint);\n         assert (hm_us.insert(10u, ~\"twelve\"));\n@@ -613,7 +613,7 @@ mod tests {\n         assert hm_us.get(12u) == ~\"fourteen\";\n         assert (!hm_us.insert(12u, ~\"twelve\"));\n         assert hm_us.get(12u) == ~\"twelve\";\n-        debug!{\"str -> str\"};\n+        debug!(\"str -> str\");\n         let hm_ss: map::hashmap<~str, ~str> =\n             map::hashmap::<~str, ~str>(copy hasher_str, copy eqer_str);\n         assert (hm_ss.insert(ten, ~\"twelve\"));\n@@ -626,7 +626,7 @@ mod tests {\n         assert hm_ss.get(~\"twelve\") == ~\"fourteen\";\n         assert (!hm_ss.insert(~\"twelve\", ~\"twelve\"));\n         assert hm_ss.get(~\"twelve\") == ~\"twelve\";\n-        debug!{\"*** finished test_simple\"};\n+        debug!(\"*** finished test_simple\");\n     }\n \n \n@@ -635,78 +635,78 @@ mod tests {\n     */\n     #[test]\n     fn test_growth() {\n-        debug!{\"*** starting test_growth\"};\n+        debug!(\"*** starting test_growth\");\n         let num_to_insert: uint = 64u;\n         pure fn eq_uint(x: &uint, y: &uint) -> bool { *x == *y }\n         pure fn uint_id(x: &uint) -> uint { *x }\n-        debug!{\"uint -> uint\"};\n+        debug!(\"uint -> uint\");\n         let hasher_uint: map::hashfn<uint> = uint_id;\n         let eqer_uint: map::eqfn<uint> = eq_uint;\n         let hm_uu: map::hashmap<uint, uint> =\n             map::hashmap::<uint, uint>(hasher_uint, eqer_uint);\n         let mut i: uint = 0u;\n         while i < num_to_insert {\n             assert (hm_uu.insert(i, i * i));\n-            debug!{\"inserting %u -> %u\", i, i*i};\n+            debug!(\"inserting %u -> %u\", i, i*i);\n             i += 1u;\n         }\n-        debug!{\"-----\"};\n+        debug!(\"-----\");\n         i = 0u;\n         while i < num_to_insert {\n-            debug!{\"get(%u) = %u\", i, hm_uu.get(i)};\n+            debug!(\"get(%u) = %u\", i, hm_uu.get(i));\n             assert (hm_uu.get(i) == i * i);\n             i += 1u;\n         }\n         assert (hm_uu.insert(num_to_insert, 17u));\n         assert (hm_uu.get(num_to_insert) == 17u);\n-        debug!{\"-----\"};\n+        debug!(\"-----\");\n         i = 0u;\n         while i < num_to_insert {\n-            debug!{\"get(%u) = %u\", i, hm_uu.get(i)};\n+            debug!(\"get(%u) = %u\", i, hm_uu.get(i));\n             assert (hm_uu.get(i) == i * i);\n             i += 1u;\n         }\n-        debug!{\"str -> str\"};\n+        debug!(\"str -> str\");\n         let hasher_str: map::hashfn<~str> = str::hash;\n         let eqer_str: map::eqfn<~str> = str::eq;\n         let hm_ss: map::hashmap<~str, ~str> =\n             map::hashmap::<~str, ~str>(hasher_str, eqer_str);\n         i = 0u;\n         while i < num_to_insert {\n             assert hm_ss.insert(uint::to_str(i, 2u), uint::to_str(i * i, 2u));\n-            debug!{\"inserting \\\"%s\\\" -> \\\"%s\\\"\",\n+            debug!(\"inserting \\\"%s\\\" -> \\\"%s\\\"\",\n                    uint::to_str(i, 2u),\n-                   uint::to_str(i*i, 2u)};\n+                   uint::to_str(i*i, 2u));\n             i += 1u;\n         }\n-        debug!{\"-----\"};\n+        debug!(\"-----\");\n         i = 0u;\n         while i < num_to_insert {\n-            debug!{\"get(\\\"%s\\\") = \\\"%s\\\"\",\n+            debug!(\"get(\\\"%s\\\") = \\\"%s\\\"\",\n                    uint::to_str(i, 2u),\n-                   hm_ss.get(uint::to_str(i, 2u))};\n+                   hm_ss.get(uint::to_str(i, 2u)));\n             assert hm_ss.get(uint::to_str(i, 2u)) == uint::to_str(i * i, 2u);\n             i += 1u;\n         }\n         assert (hm_ss.insert(uint::to_str(num_to_insert, 2u),\n                              uint::to_str(17u, 2u)));\n         assert hm_ss.get(uint::to_str(num_to_insert, 2u)) ==\n             uint::to_str(17u, 2u);\n-        debug!{\"-----\"};\n+        debug!(\"-----\");\n         i = 0u;\n         while i < num_to_insert {\n-            debug!{\"get(\\\"%s\\\") = \\\"%s\\\"\",\n+            debug!(\"get(\\\"%s\\\") = \\\"%s\\\"\",\n                    uint::to_str(i, 2u),\n-                   hm_ss.get(uint::to_str(i, 2u))};\n+                   hm_ss.get(uint::to_str(i, 2u)));\n             assert hm_ss.get(uint::to_str(i, 2u)) == uint::to_str(i * i, 2u);\n             i += 1u;\n         }\n-        debug!{\"*** finished test_growth\"};\n+        debug!(\"*** finished test_growth\");\n     }\n \n     #[test]\n     fn test_removal() {\n-        debug!{\"*** starting test_removal\"};\n+        debug!(\"*** starting test_removal\");\n         let num_to_insert: uint = 64u;\n         fn eq(x: &uint, y: &uint) -> bool { *x == *y }\n         fn hash(u: &uint) -> uint {\n@@ -724,57 +724,57 @@ mod tests {\n         let mut i: uint = 0u;\n         while i < num_to_insert {\n             assert (hm.insert(i, i * i));\n-            debug!{\"inserting %u -> %u\", i, i*i};\n+            debug!(\"inserting %u -> %u\", i, i*i);\n             i += 1u;\n         }\n         assert (hm.size() == num_to_insert);\n-        debug!{\"-----\"};\n-        debug!{\"removing evens\"};\n+        debug!(\"-----\");\n+        debug!(\"removing evens\");\n         i = 0u;\n         while i < num_to_insert {\n             let v = hm.remove(i);\n             assert v;\n             i += 2u;\n         }\n         assert (hm.size() == num_to_insert / 2u);\n-        debug!{\"-----\"};\n+        debug!(\"-----\");\n         i = 1u;\n         while i < num_to_insert {\n-            debug!{\"get(%u) = %u\", i, hm.get(i)};\n+            debug!(\"get(%u) = %u\", i, hm.get(i));\n             assert (hm.get(i) == i * i);\n             i += 2u;\n         }\n-        debug!{\"-----\"};\n+        debug!(\"-----\");\n         i = 1u;\n         while i < num_to_insert {\n-            debug!{\"get(%u) = %u\", i, hm.get(i)};\n+            debug!(\"get(%u) = %u\", i, hm.get(i));\n             assert (hm.get(i) == i * i);\n             i += 2u;\n         }\n-        debug!{\"-----\"};\n+        debug!(\"-----\");\n         i = 0u;\n         while i < num_to_insert {\n             assert (hm.insert(i, i * i));\n-            debug!{\"inserting %u -> %u\", i, i*i};\n+            debug!(\"inserting %u -> %u\", i, i*i);\n             i += 2u;\n         }\n         assert (hm.size() == num_to_insert);\n-        debug!{\"-----\"};\n+        debug!(\"-----\");\n         i = 0u;\n         while i < num_to_insert {\n-            debug!{\"get(%u) = %u\", i, hm.get(i)};\n+            debug!(\"get(%u) = %u\", i, hm.get(i));\n             assert (hm.get(i) == i * i);\n             i += 1u;\n         }\n-        debug!{\"-----\"};\n+        debug!(\"-----\");\n         assert (hm.size() == num_to_insert);\n         i = 0u;\n         while i < num_to_insert {\n-            debug!{\"get(%u) = %u\", i, hm.get(i)};\n+            debug!(\"get(%u) = %u\", i, hm.get(i));\n             assert (hm.get(i) == i * i);\n             i += 1u;\n         }\n-        debug!{\"*** finished test_removal\"};\n+        debug!(\"*** finished test_removal\");\n     }\n \n     #[test]"}, {"sha": "f7a7f42afcfb15e09b31e6914a1dcd4472cfb89d", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -88,7 +88,7 @@ fn get_addr(++node: ~str, iotask: iotask)\n         -> result::result<~[ip_addr], ip_get_addr_err> unsafe {\n     do core::comm::listen |output_ch| {\n         do str::as_buf(node) |node_ptr, len| {\n-            log(debug, fmt!{\"slice len %?\", len});\n+            log(debug, fmt!(\"slice len %?\", len));\n             let handle = create_uv_getaddrinfo_t();\n             let handle_ptr = ptr::addr_of(handle);\n             let handle_data: get_addr_data = {\n@@ -161,10 +161,10 @@ mod v4 {\n             }\n         });\n         if vec::len(parts) != 4u {\n-                result::err(fmt!{\"'%s' doesn't have 4 parts\", ip})\n+                result::err(fmt!(\"'%s' doesn't have 4 parts\", ip))\n                 }\n         else if vec::contains(parts, 256u) {\n-                result::err(fmt!{\"invalid octal in addr '%s'\", ip})\n+                result::err(fmt!(\"invalid octal in addr '%s'\", ip))\n                 }\n         else {\n             result::ok({a: parts[0] as u8, b: parts[1] as u8,\n@@ -185,8 +185,8 @@ mod v4 {\n \n             let new_addr = uv_ip4_addr(ip, 22);\n             let reformatted_name = uv_ip4_name(&new_addr);\n-            log(debug, fmt!{\"try_parse_addr: input ip: %s reparsed ip: %s\",\n-                            ip, reformatted_name});\n+            log(debug, fmt!(\"try_parse_addr: input ip: %s reparsed ip: %s\",\n+                            ip, reformatted_name));\n             let ref_ip_rep_result = parse_to_ipv4_rep(reformatted_name);\n             if result::is_err(ref_ip_rep_result) {\n                 let err_str = result::get_err(ref_ip_rep_result);\n@@ -230,13 +230,13 @@ mod v6 {\n             // need to figure out how to establish a parse failure..\n             let new_addr = uv_ip6_addr(ip, 22);\n             let reparsed_name = uv_ip6_name(&new_addr);\n-            log(debug, fmt!{\"v6::try_parse_addr ip: '%s' reparsed '%s'\",\n-                            ip, reparsed_name});\n+            log(debug, fmt!(\"v6::try_parse_addr ip: '%s' reparsed '%s'\",\n+                            ip, reparsed_name));\n             // '::' appears to be uv_ip6_name() returns for bogus\n             // parses..\n             if  ip != ~\"::\" && reparsed_name == ~\"::\" {\n-                result::err({err_msg:fmt!{\"failed to parse '%s'\",\n-                                           ip}})\n+                result::err({err_msg:fmt!(\"failed to parse '%s'\",\n+                                           ip)})\n             }\n             else {\n                 result::ok(ipv6(new_addr))\n@@ -257,7 +257,7 @@ extern fn get_addr_cb(handle: *uv_getaddrinfo_t, status: libc::c_int,\n     if status == 0i32 {\n         if res != (ptr::null::<addrinfo>()) {\n             let mut out_vec = ~[];\n-            log(debug, fmt!{\"initial addrinfo: %?\", res});\n+            log(debug, fmt!(\"initial addrinfo: %?\", res));\n             let mut curr_addr = res;\n             loop {\n                 let new_ip_addr = if ll::is_ipv4_addrinfo(curr_addr) {\n@@ -284,11 +284,11 @@ extern fn get_addr_cb(handle: *uv_getaddrinfo_t, status: libc::c_int,\n                 }\n                 else {\n                     curr_addr = next_addr;\n-                    log(debug, fmt!{\"next_addr addrinfo: %?\", curr_addr});\n+                    log(debug, fmt!(\"next_addr addrinfo: %?\", curr_addr));\n                 }\n             }\n-            log(debug, fmt!{\"successful process addrinfo result, len: %?\",\n-                            vec::len(out_vec)});\n+            log(debug, fmt!(\"successful process addrinfo result, len: %?\",\n+                            vec::len(out_vec)));\n             (*handle_data).output_ch.send(result::ok(out_vec));\n         }\n         else {\n@@ -320,19 +320,19 @@ mod test {\n     fn test_ip_ipv6_parse_and_format_ip() {\n         let localhost_str = ~\"::1\";\n         let format_result = format_addr(v6::parse_addr(localhost_str));\n-        log(debug, fmt!{\"results: expected: '%s' actual: '%s'\",\n-            localhost_str, format_result});\n+        log(debug, fmt!(\"results: expected: '%s' actual: '%s'\",\n+            localhost_str, format_result));\n         assert format_result == localhost_str;\n     }\n     #[test]\n     fn test_ip_ipv4_bad_parse() {\n         match v4::try_parse_addr(~\"b4df00d\") {\n           result::err(err_info) => {\n-            log(debug, fmt!{\"got error as expected %?\", err_info});\n+            log(debug, fmt!(\"got error as expected %?\", err_info));\n             assert true;\n           }\n           result::ok(addr) => {\n-            fail fmt!{\"Expected failure, but got addr %?\", addr};\n+            fail fmt!(\"Expected failure, but got addr %?\", addr);\n           }\n         }\n     }\n@@ -341,11 +341,11 @@ mod test {\n     fn test_ip_ipv6_bad_parse() {\n         match v6::try_parse_addr(~\"::,~2234k;\") {\n           result::err(err_info) => {\n-            log(debug, fmt!{\"got error as expected %?\", err_info});\n+            log(debug, fmt!(\"got error as expected %?\", err_info));\n             assert true;\n           }\n           result::ok(addr) => {\n-            fail fmt!{\"Expected failure, but got addr %?\", addr};\n+            fail fmt!(\"Expected failure, but got addr %?\", addr);\n           }\n         }\n     }\n@@ -361,15 +361,15 @@ mod test {\n         // note really sure how to realiably test/assert\n         // this.. mostly just wanting to see it work, atm.\n         let results = result::unwrap(ga_result);\n-        log(debug, fmt!{\"test_get_addr: Number of results for %s: %?\",\n-                        localhost_name, vec::len(results)});\n+        log(debug, fmt!(\"test_get_addr: Number of results for %s: %?\",\n+                        localhost_name, vec::len(results)));\n         for vec::each(results) |r| {\n             let ipv_prefix = match r {\n               ipv4(_) => ~\"IPv4\",\n               ipv6(_) => ~\"IPv6\"\n             };\n-            log(debug, fmt!{\"test_get_addr: result %s: '%s'\",\n-                            ipv_prefix, format_addr(r)});\n+            log(debug, fmt!(\"test_get_addr: result %s: '%s'\",\n+                            ipv_prefix, format_addr(r)));\n         }\n         // at least one result.. this is going to vary from system\n         // to system, based on stuff like the contents of /etc/hosts"}, {"sha": "64271eceed75f9a4621a9731e7316fefbe42b419", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 69, "deletions": 69, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -140,15 +140,15 @@ fn connect(-input_ip: ip::ip_addr, port: uint,\n         iotask: iotask\n     };\n     let socket_data_ptr = ptr::addr_of(*socket_data);\n-    log(debug, fmt!{\"tcp_connect result_ch %?\", conn_data.result_ch});\n+    log(debug, fmt!(\"tcp_connect result_ch %?\", conn_data.result_ch));\n     // get an unsafe representation of our stream_handle_ptr that\n     // we can send into the interact cb to be handled in libuv..\n-    log(debug, fmt!{\"stream_handle_ptr outside interact %?\",\n-        stream_handle_ptr});\n+    log(debug, fmt!(\"stream_handle_ptr outside interact %?\",\n+        stream_handle_ptr));\n     do iotask::interact(iotask) |loop_ptr| {\n         log(debug, ~\"in interact cb for tcp client connect..\");\n-        log(debug, fmt!{\"stream_handle_ptr in interact %?\",\n-            stream_handle_ptr});\n+        log(debug, fmt!(\"stream_handle_ptr in interact %?\",\n+            stream_handle_ptr));\n         match uv::ll::tcp_init( loop_ptr, stream_handle_ptr) {\n           0i32 => {\n             log(debug, ~\"tcp_init successful\");\n@@ -165,7 +165,7 @@ fn connect(-input_ip: ip::ip_addr, port: uint,\n                     // info.. should probably add an additional\n                     // rust type that actually is closer to\n                     // what the libuv API expects (ip str + port num)\n-                    log(debug, fmt!{\"addr: %?\", addr});\n+                    log(debug, fmt!(\"addr: %?\", addr));\n                     let in_addr = uv::ll::ip4_addr(addr_str, port as int);\n                     uv::ll::tcp_connect(\n                         connect_req_ptr,\n@@ -174,7 +174,7 @@ fn connect(-input_ip: ip::ip_addr, port: uint,\n                         tcp_connect_on_connect_cb)\n                   }\n                   ip::ipv6(addr) => {\n-                    log(debug, fmt!{\"addr: %?\", addr});\n+                    log(debug, fmt!(\"addr: %?\", addr));\n                     let in_addr = uv::ll::ip6_addr(addr_str, port as int);\n                     uv::ll::tcp_connect6(\n                         connect_req_ptr,\n@@ -333,7 +333,7 @@ fn read_start(sock: tcp_socket)\n fn read_stop(sock: tcp_socket,\n              -read_port: comm::Port<result::result<~[u8], tcp_err_data>>) ->\n     result::result<(), tcp_err_data> unsafe {\n-    log(debug, fmt!{\"taking the read_port out of commission %?\", read_port});\n+    log(debug, fmt!(\"taking the read_port out of commission %?\", read_port));\n     let socket_data = ptr::addr_of(*sock.socket_data);\n     read_stop_common_impl(socket_data)\n }\n@@ -617,13 +617,13 @@ fn listen_common(-host_ip: ip::ip_addr, port: uint, backlog: uint,\n                 let addr_str = ip::format_addr(loc_ip);\n                 let bind_result = match loc_ip {\n                   ip::ipv4(addr) => {\n-                    log(debug, fmt!{\"addr: %?\", addr});\n+                    log(debug, fmt!(\"addr: %?\", addr));\n                     let in_addr = uv::ll::ip4_addr(addr_str, port as int);\n                     uv::ll::tcp_bind(server_stream_ptr,\n                                      ptr::addr_of(in_addr))\n                   }\n                   ip::ipv6(addr) => {\n-                    log(debug, fmt!{\"addr: %?\", addr});\n+                    log(debug, fmt!(\"addr: %?\", addr));\n                     let in_addr = uv::ll::ip6_addr(addr_str, port as int);\n                     uv::ll::tcp_bind6(server_stream_ptr,\n                                      ptr::addr_of(in_addr))\n@@ -661,8 +661,8 @@ fn listen_common(-host_ip: ip::ip_addr, port: uint, backlog: uint,\n     match setup_result {\n       some(err_data) => {\n         do iotask::interact(iotask) |loop_ptr| {\n-            log(debug, fmt!{\"tcp::listen post-kill recv hl interact %?\",\n-                            loop_ptr});\n+            log(debug, fmt!(\"tcp::listen post-kill recv hl interact %?\",\n+                            loop_ptr));\n             (*server_data_ptr).active = false;\n             uv::ll::close(server_stream_ptr, tcp_lfc_close_cb);\n         };\n@@ -677,8 +677,8 @@ fn listen_common(-host_ip: ip::ip_addr, port: uint, backlog: uint,\n             result::err(address_in_use)\n           }\n           _ => {\n-            log(debug, fmt!{\"Got '%s' '%s' libuv error\",\n-                            err_data.err_name, err_data.err_msg});\n+            log(debug, fmt!(\"Got '%s' '%s' libuv error\",\n+                            err_data.err_name, err_data.err_msg));\n             result::err(\n                 generic_listen_err(err_data.err_name, err_data.err_msg))\n           }\n@@ -688,8 +688,8 @@ fn listen_common(-host_ip: ip::ip_addr, port: uint, backlog: uint,\n         on_establish_cb(kill_ch);\n         let kill_result = core::comm::recv(kill_po);\n         do iotask::interact(iotask) |loop_ptr| {\n-            log(debug, fmt!{\"tcp::listen post-kill recv hl interact %?\",\n-                            loop_ptr});\n+            log(debug, fmt!(\"tcp::listen post-kill recv hl interact %?\",\n+                            loop_ptr));\n             (*server_data_ptr).active = false;\n             uv::ll::close(server_stream_ptr, tcp_lfc_close_cb);\n         };\n@@ -765,8 +765,8 @@ impl @tcp_socket_buf: io::Reader {\n                 if err_data.err_name == ~\"EOF\" {\n                     break;\n                 } else {\n-                    debug!{\"ERROR sock_buf as io::reader.read err %? %?\",\n-                           err_data.err_name, err_data.err_msg};\n+                    debug!(\"ERROR sock_buf as io::reader.read err %? %?\",\n+                           err_data.err_name, err_data.err_msg);\n \n                     return 0;\n                 }\n@@ -798,7 +798,7 @@ impl @tcp_socket_buf: io::Reader {\n         false // noop\n     }\n     fn seek(dist: int, seek: io::SeekStyle) {\n-        log(debug, fmt!{\"tcp_socket_buf seek stub %? %?\", dist, seek});\n+        log(debug, fmt!(\"tcp_socket_buf seek stub %? %?\", dist, seek));\n         // noop\n     }\n     fn tell() -> uint {\n@@ -815,12 +815,12 @@ impl @tcp_socket_buf: io::Writer {\n                                         vec::slice(data, 0, vec::len(data)));\n         if w_result.is_err() {\n             let err_data = w_result.get_err();\n-            log(debug, fmt!{\"ERROR sock_buf as io::writer.writer err: %? %?\",\n-                             err_data.err_name, err_data.err_msg});\n+            log(debug, fmt!(\"ERROR sock_buf as io::writer.writer err: %? %?\",\n+                             err_data.err_name, err_data.err_msg));\n         }\n     }\n     fn seek(dist: int, seek: io::SeekStyle) {\n-      log(debug, fmt!{\"tcp_socket_buf seek stub %? %?\", dist, seek});\n+      log(debug, fmt!(\"tcp_socket_buf seek stub %? %?\", dist, seek));\n         // noop\n     }\n     fn tell() -> uint {\n@@ -845,14 +845,14 @@ fn tear_down_socket_data(socket_data: @tcp_socket_data) unsafe {\n     let close_data_ptr = ptr::addr_of(close_data);\n     let stream_handle_ptr = (*socket_data).stream_handle_ptr;\n     do iotask::interact((*socket_data).iotask) |loop_ptr| {\n-        log(debug, fmt!{\"interact dtor for tcp_socket stream %? loop %?\",\n-            stream_handle_ptr, loop_ptr});\n+        log(debug, fmt!(\"interact dtor for tcp_socket stream %? loop %?\",\n+            stream_handle_ptr, loop_ptr));\n         uv::ll::set_data_for_uv_handle(stream_handle_ptr,\n                                        close_data_ptr);\n         uv::ll::close(stream_handle_ptr, tcp_socket_dtor_close_cb);\n     };\n     core::comm::recv(closed_po);\n-    log(debug, fmt!{\"about to free socket_data at %?\", socket_data});\n+    log(debug, fmt!(\"about to free socket_data at %?\", socket_data));\n     rustrt::rust_uv_current_kernel_free(stream_handle_ptr\n                                        as *libc::c_void);\n     log(debug, ~\"exiting dtor for tcp_socket\");\n@@ -931,7 +931,7 @@ fn read_start_common_impl(socket_data: *tcp_socket_data)\n     let start_ch = core::comm::chan(start_po);\n     log(debug, ~\"in tcp::read_start before interact loop\");\n     do iotask::interact((*socket_data).iotask) |loop_ptr| {\n-        log(debug, fmt!{\"in tcp::read_start interact cb %?\", loop_ptr});\n+        log(debug, fmt!(\"in tcp::read_start interact cb %?\", loop_ptr));\n         match uv::ll::read_start(stream_handle_ptr as *uv::ll::uv_stream_t,\n                                on_alloc_cb,\n                                on_tcp_read_cb) {\n@@ -971,7 +971,7 @@ fn write_common_impl(socket_data_ptr: *tcp_socket_data,\n     };\n     let write_data_ptr = ptr::addr_of(write_data);\n     do iotask::interact((*socket_data_ptr).iotask) |loop_ptr| {\n-        log(debug, fmt!{\"in interact cb for tcp::write %?\", loop_ptr});\n+        log(debug, fmt!(\"in interact cb for tcp::write %?\", loop_ptr));\n         match uv::ll::write(write_req_ptr,\n                           stream_handle_ptr,\n                           write_buf_vec_ptr,\n@@ -1075,17 +1075,17 @@ impl uv::ll::uv_err_data: to_tcp_err {\n extern fn on_tcp_read_cb(stream: *uv::ll::uv_stream_t,\n                     nread: libc::ssize_t,\n                     ++buf: uv::ll::uv_buf_t) unsafe {\n-    log(debug, fmt!{\"entering on_tcp_read_cb stream: %? nread: %?\",\n-                    stream, nread});\n+    log(debug, fmt!(\"entering on_tcp_read_cb stream: %? nread: %?\",\n+                    stream, nread));\n     let loop_ptr = uv::ll::get_loop_for_uv_handle(stream);\n     let socket_data_ptr = uv::ll::get_data_for_uv_handle(stream)\n         as *tcp_socket_data;\n     match nread as int {\n       // incoming err.. probably eof\n       -1 => {\n         let err_data = uv::ll::get_last_err_data(loop_ptr).to_tcp_err();\n-        log(debug, fmt!{\"on_tcp_read_cb: incoming err.. name %? msg %?\",\n-                        err_data.err_name, err_data.err_msg});\n+        log(debug, fmt!(\"on_tcp_read_cb: incoming err.. name %? msg %?\",\n+                        err_data.err_name, err_data.err_msg));\n         let reader_ch = (*socket_data_ptr).reader_ch;\n         core::comm::send(reader_ch, result::err(err_data));\n       }\n@@ -1094,7 +1094,7 @@ extern fn on_tcp_read_cb(stream: *uv::ll::uv_stream_t,\n       // have data\n       _ => {\n         // we have data\n-        log(debug, fmt!{\"tcp on_read_cb nread: %d\", nread as int});\n+        log(debug, fmt!(\"tcp on_read_cb nread: %d\", nread as int));\n         let reader_ch = (*socket_data_ptr).reader_ch;\n         let buf_base = uv::ll::get_base_from_buf(buf);\n         let new_bytes = vec::unsafe::from_buf(buf_base, nread as uint);\n@@ -1110,10 +1110,10 @@ extern fn on_alloc_cb(handle: *libc::c_void,\n     -> uv::ll::uv_buf_t unsafe {\n     log(debug, ~\"tcp read on_alloc_cb!\");\n     let char_ptr = uv::ll::malloc_buf_base_of(suggested_size);\n-    log(debug, fmt!{\"tcp read on_alloc_cb h: %? char_ptr: %u sugsize: %u\",\n+    log(debug, fmt!(\"tcp read on_alloc_cb h: %? char_ptr: %u sugsize: %u\",\n                      handle,\n                      char_ptr as uint,\n-                     suggested_size as uint});\n+                     suggested_size as uint));\n     uv::ll::buf_init(char_ptr, suggested_size as uint)\n }\n \n@@ -1160,19 +1160,19 @@ extern fn stream_error_close_cb(handle: *uv::ll::uv_tcp_t) unsafe {\n     let data = uv::ll::get_data_for_uv_handle(handle) as\n         *connect_req_data;\n     core::comm::send((*data).closed_signal_ch, ());\n-    log(debug, fmt!{\"exiting steam_error_close_cb for %?\", handle});\n+    log(debug, fmt!(\"exiting steam_error_close_cb for %?\", handle));\n }\n \n extern fn tcp_connect_close_cb(handle: *uv::ll::uv_tcp_t) unsafe {\n-    log(debug, fmt!{\"closed client tcp handle %?\", handle});\n+    log(debug, fmt!(\"closed client tcp handle %?\", handle));\n }\n \n extern fn tcp_connect_on_connect_cb(connect_req_ptr: *uv::ll::uv_connect_t,\n                                    status: libc::c_int) unsafe {\n     let conn_data_ptr = (uv::ll::get_data_for_req(connect_req_ptr)\n                       as *connect_req_data);\n     let result_ch = (*conn_data_ptr).result_ch;\n-    log(debug, fmt!{\"tcp_connect result_ch %?\", result_ch});\n+    log(debug, fmt!(\"tcp_connect result_ch %?\", result_ch));\n     let tcp_stream_ptr =\n         uv::ll::get_stream_handle_from_connect_req(connect_req_ptr);\n     match status {\n@@ -1184,8 +1184,8 @@ extern fn tcp_connect_on_connect_cb(connect_req_ptr: *uv::ll::uv_connect_t,\n         log(debug, ~\"error in tcp_connect_on_connect_cb\");\n         let loop_ptr = uv::ll::get_loop_for_uv_handle(tcp_stream_ptr);\n         let err_data = uv::ll::get_last_err_data(loop_ptr);\n-        log(debug, fmt!{\"err_data %? %?\", err_data.err_name,\n-                        err_data.err_msg});\n+        log(debug, fmt!(\"err_data %? %?\", err_data.err_name,\n+                        err_data.err_msg));\n         core::comm::send(result_ch, conn_failure(err_data));\n         uv::ll::set_data_for_uv_handle(tcp_stream_ptr,\n                                        conn_data_ptr);\n@@ -1314,10 +1314,10 @@ mod test {\n         assert actual_resp_result.is_ok();\n         let actual_resp = actual_resp_result.get();\n         let actual_req = core::comm::recv(server_result_po);\n-        log(debug, fmt!{\"REQ: expected: '%s' actual: '%s'\",\n-                       expected_req, actual_req});\n-        log(debug, fmt!{\"RESP: expected: '%s' actual: '%s'\",\n-                       expected_resp, actual_resp});\n+        log(debug, fmt!(\"REQ: expected: '%s' actual: '%s'\",\n+                       expected_req, actual_req));\n+        log(debug, fmt!(\"RESP: expected: '%s' actual: '%s'\",\n+                       expected_resp, actual_resp));\n         assert str::contains(actual_req, expected_req);\n         assert str::contains(actual_resp, expected_resp);\n     }\n@@ -1453,27 +1453,27 @@ mod test {\n         };\n \n         let actual_req = core::comm::recv(server_result_po);\n-        log(debug, fmt!{\"REQ: expected: '%s' actual: '%s'\",\n-                       expected_req, actual_req});\n-        log(debug, fmt!{\"RESP: expected: '%s' actual: '%s'\",\n-                       expected_resp, actual_resp});\n+        log(debug, fmt!(\"REQ: expected: '%s' actual: '%s'\",\n+                       expected_req, actual_req));\n+        log(debug, fmt!(\"RESP: expected: '%s' actual: '%s'\",\n+                       expected_resp, actual_resp));\n         assert str::contains(actual_req, expected_req);\n         assert str::contains(actual_resp, expected_resp);\n     }\n \n     fn buf_write(+w: io::Writer, val: ~str) {\n-        log(debug, fmt!{\"BUF_WRITE: val len %?\", str::len(val)});\n+        log(debug, fmt!(\"BUF_WRITE: val len %?\", str::len(val)));\n         do str::byte_slice(val) |b_slice| {\n-            log(debug, fmt!{\"BUF_WRITE: b_slice len %?\",\n-                            vec::len(b_slice)});\n+            log(debug, fmt!(\"BUF_WRITE: b_slice len %?\",\n+                            vec::len(b_slice)));\n             w.write(b_slice)\n         }\n     }\n \n     fn buf_read(+r: io::Reader, len: uint) -> ~str {\n         let new_bytes = r.read_bytes(len);\n-        log(debug, fmt!{\"in buf_read.. new_bytes len: %?\",\n-                        vec::len(new_bytes)});\n+        log(debug, fmt!(\"in buf_read.. new_bytes len: %?\",\n+                        vec::len(new_bytes)));\n         str::from_bytes(new_bytes)\n     }\n \n@@ -1485,8 +1485,8 @@ mod test {\n         let listen_result = listen(server_ip_addr, server_port, 128u, iotask,\n             // on_establish_cb -- called when listener is set up\n             |kill_ch| {\n-                log(debug, fmt!{\"establish_cb %?\",\n-                    kill_ch});\n+                log(debug, fmt!(\"establish_cb %?\",\n+                    kill_ch));\n                 core::comm::send(cont_ch, ());\n             },\n             // risky to run this on the loop, but some users\n@@ -1518,8 +1518,8 @@ mod test {\n                         match received_req_bytes {\n                           result::ok(data) => {\n                             log(debug, ~\"SERVER: got REQ str::from_bytes..\");\n-                            log(debug, fmt!{\"SERVER: REQ data len: %?\",\n-                                            vec::len(data)});\n+                            log(debug, fmt!(\"SERVER: REQ data len: %?\",\n+                                            vec::len(data)));\n                             server_ch.send(\n                                 str::from_bytes(data));\n                             log(debug, ~\"SERVER: before write\");\n@@ -1528,8 +1528,8 @@ mod test {\n                             core::comm::send(kill_ch, none);\n                           }\n                           result::err(err_data) => {\n-                            log(debug, fmt!{\"SERVER: error recvd: %s %s\",\n-                                err_data.err_name, err_data.err_msg});\n+                            log(debug, fmt!(\"SERVER: error recvd: %s %s\",\n+                                err_data.err_name, err_data.err_msg));\n                             core::comm::send(kill_ch, some(err_data));\n                             server_ch.send(~\"\");\n                           }\n@@ -1546,8 +1546,8 @@ mod test {\n         if result::is_err(listen_result) {\n             match result::get_err(listen_result) {\n               generic_listen_err(name, msg) => {\n-                fail fmt!{\"SERVER: exited abnormally name %s msg %s\",\n-                                name, msg};\n+                fail fmt!(\"SERVER: exited abnormally name %s msg %s\",\n+                                name, msg);\n               }\n               access_denied => {\n                 fail ~\"SERVER: exited abnormally, got access denied..\";\n@@ -1558,7 +1558,7 @@ mod test {\n             }\n         }\n         let ret_val = server_ch.recv();\n-        log(debug, fmt!{\"SERVER: exited and got return val: '%s'\", ret_val});\n+        log(debug, fmt!(\"SERVER: exited and got return val: '%s'\", ret_val));\n         ret_val\n     }\n \n@@ -1568,12 +1568,12 @@ mod test {\n         let listen_result = listen(server_ip_addr, server_port, 128u, iotask,\n             // on_establish_cb -- called when listener is set up\n             |kill_ch| {\n-                log(debug, fmt!{\"establish_cb %?\",\n-                    kill_ch});\n+                log(debug, fmt!(\"establish_cb %?\",\n+                    kill_ch));\n             },\n             |new_conn, kill_ch| {\n-                fail fmt!{\"SERVER: shouldn't be called.. %? %?\",\n-                           new_conn, kill_ch};\n+                fail fmt!(\"SERVER: shouldn't be called.. %? %?\",\n+                           new_conn, kill_ch);\n         });\n         // err check on listen_result\n         if result::is_err(listen_result) {\n@@ -1609,8 +1609,8 @@ mod test {\n             else {\n                 client_ch.send(str::from_bytes(read_result.get()));\n                 let ret_val = client_ch.recv();\n-                log(debug, fmt!{\"CLIENT: after client_ch recv ret: '%s'\",\n-                   ret_val});\n+                log(debug, fmt!(\"CLIENT: after client_ch recv ret: '%s'\",\n+                   ret_val));\n                 ok(ret_val)\n             }\n         }\n@@ -1622,8 +1622,8 @@ mod test {\n         if result::is_err(write_result) {\n             log(debug, ~\"tcp_write_single: write failed!\");\n             let err_data = result::get_err(write_result);\n-            log(debug, fmt!{\"tcp_write_single err name: %s msg: %s\",\n-                err_data.err_name, err_data.err_msg});\n+            log(debug, fmt!(\"tcp_write_single err name: %s msg: %s\",\n+                err_data.err_name, err_data.err_msg));\n             // meh. torn on what to do here.\n             fail ~\"tcp_write_single failed\";\n         }"}, {"sha": "34ea2433bedbb64122838e919e1a9f42b3502b3e", "filename": "src/libstd/par.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibstd%2Fpar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibstd%2Fpar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpar.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -47,11 +47,11 @@ fn map_slices<A: copy send, B: copy send>(\n                         let len = end - base;\n                         let slice = (ptr::offset(p, base),\n                                      len * sys::size_of::<A>());\n-                        log(info, fmt!{\"pre-slice: %?\", (base, slice)});\n+                        log(info, fmt!(\"pre-slice: %?\", (base, slice)));\n                         let slice : &[A] =\n                             unsafe::reinterpret_cast(slice);\n-                        log(info, fmt!{\"slice: %?\",\n-                                       (base, vec::len(slice), end - base)});\n+                        log(info, fmt!(\"slice: %?\",\n+                                       (base, vec::len(slice), end - base)));\n                         assert(vec::len(slice) == end - base);\n                         f(base, slice)\n                     }\n@@ -62,7 +62,7 @@ fn map_slices<A: copy send, B: copy send>(\n         }\n         log(info, ~\"tasks spawned\");\n \n-        log(info, fmt!{\"num_tasks: %?\", (num_tasks, futures.len())});\n+        log(info, fmt!(\"num_tasks: %?\", (num_tasks, futures.len())));\n         assert(num_tasks == futures.len());\n \n         let r = do futures.map() |ys| {"}, {"sha": "4e21da29fd77bbbf90eabbdc5d9968e8e09802ca", "filename": "src/libstd/prettyprint.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibstd%2Fprettyprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibstd%2Fprettyprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprettyprint.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -8,63 +8,63 @@ impl Writer: serializer {\n     }\n \n     fn emit_uint(v: uint) {\n-        self.write_str(fmt!{\"%?u\", v});\n+        self.write_str(fmt!(\"%?u\", v));\n     }\n \n     fn emit_u64(v: u64) {\n-        self.write_str(fmt!{\"%?_u64\", v});\n+        self.write_str(fmt!(\"%?_u64\", v));\n     }\n \n     fn emit_u32(v: u32) {\n-        self.write_str(fmt!{\"%?_u32\", v});\n+        self.write_str(fmt!(\"%?_u32\", v));\n     }\n \n     fn emit_u16(v: u16) {\n-        self.write_str(fmt!{\"%?_u16\", v});\n+        self.write_str(fmt!(\"%?_u16\", v));\n     }\n \n     fn emit_u8(v: u8) {\n-        self.write_str(fmt!{\"%?_u8\", v});\n+        self.write_str(fmt!(\"%?_u8\", v));\n     }\n \n     fn emit_int(v: int) {\n-        self.write_str(fmt!{\"%?\", v});\n+        self.write_str(fmt!(\"%?\", v));\n     }\n \n     fn emit_i64(v: i64) {\n-        self.write_str(fmt!{\"%?_i64\", v});\n+        self.write_str(fmt!(\"%?_i64\", v));\n     }\n \n     fn emit_i32(v: i32) {\n-        self.write_str(fmt!{\"%?_i32\", v});\n+        self.write_str(fmt!(\"%?_i32\", v));\n     }\n \n     fn emit_i16(v: i16) {\n-        self.write_str(fmt!{\"%?_i16\", v});\n+        self.write_str(fmt!(\"%?_i16\", v));\n     }\n \n     fn emit_i8(v: i8) {\n-        self.write_str(fmt!{\"%?_i8\", v});\n+        self.write_str(fmt!(\"%?_i8\", v));\n     }\n \n     fn emit_bool(v: bool) {\n-        self.write_str(fmt!{\"%b\", v});\n+        self.write_str(fmt!(\"%b\", v));\n     }\n \n     fn emit_float(v: float) {\n-        self.write_str(fmt!{\"%?_f\", v});\n+        self.write_str(fmt!(\"%?_f\", v));\n     }\n \n     fn emit_f64(v: f64) {\n-        self.write_str(fmt!{\"%?_f64\", v});\n+        self.write_str(fmt!(\"%?_f64\", v));\n     }\n \n     fn emit_f32(v: f32) {\n-        self.write_str(fmt!{\"%?_f32\", v});\n+        self.write_str(fmt!(\"%?_f32\", v));\n     }\n \n     fn emit_str(v: &str) {\n-        self.write_str(fmt!{\"%?\", v});\n+        self.write_str(fmt!(\"%?\", v));\n     }\n \n     fn emit_enum(_name: ~str, f: fn()) {"}, {"sha": "5a7e77ead480023ce70b6ff100433c6de4bb51c0", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -27,7 +27,7 @@ fn mk<T: copy>() -> smallintmap<T> {\n  */\n #[inline(always)]\n fn insert<T: copy>(self: smallintmap<T>, key: uint, val: T) {\n-    //io::println(fmt!{\"%?\", key});\n+    //io::println(fmt!(\"%?\", key));\n     self.v.grow_set_elt(key, none, some(val));\n }\n \n@@ -50,7 +50,7 @@ pure fn find<T: copy>(self: smallintmap<T>, key: uint) -> option<T> {\n pure fn get<T: copy>(self: smallintmap<T>, key: uint) -> T {\n     match find(self, key) {\n       none => {\n-        error!{\"smallintmap::get(): key not present\"};\n+        error!(\"smallintmap::get(): key not present\");\n         fail;\n       }\n       some(v) => return v"}, {"sha": "256ee4ecd739dc718ed9e377e94540f8d4173c48", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -250,7 +250,7 @@ mod test_qsort {\n         let pairs = vec::zip(expected, immut_names);\n         for vec::each(pairs) |p| {\n             let (a, b) = p;\n-            debug!{\"%d %d\", a, b};\n+            debug!(\"%d %d\", a, b);\n             assert (a == b);\n         }\n     }"}, {"sha": "a0cc26b6658e2542214a1930d4ce5a16b88f92ce", "filename": "src/libstd/test.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -110,9 +110,9 @@ fn run_tests_console(opts: test_opts,\n           te_filtered(filtered_tests) => {\n             st.total = vec::len(filtered_tests);\n             let noun = if st.total != 1u { ~\"tests\" } else { ~\"test\" };\n-            st.out.write_line(fmt!{\"\\nrunning %u %s\", st.total, noun});\n+            st.out.write_line(fmt!(\"\\nrunning %u %s\", st.total, noun));\n           }\n-          te_wait(test) => st.out.write_str(fmt!{\"test %s ... \", test.name}),\n+          te_wait(test) => st.out.write_str(fmt!(\"test %s ... \", test.name)),\n           te_result(test, result) => {\n             match st.log_out {\n                 some(f) => write_log(f, result, test),\n@@ -145,7 +145,7 @@ fn run_tests_console(opts: test_opts,\n                                             ~[io::Create, io::Truncate]) {\n           result::ok(w) => some(w),\n           result::err(s) => {\n-              fail(fmt!{\"can't open output file: %s\", s})\n+              fail(fmt!(\"can't open output file: %s\", s))\n           }\n         },\n         none => none\n@@ -170,23 +170,23 @@ fn run_tests_console(opts: test_opts,\n         print_failures(st);\n     }\n \n-    st.out.write_str(fmt!{\"\\nresult: \"});\n+    st.out.write_str(fmt!(\"\\nresult: \"));\n     if success {\n         // There's no parallelism at this point so it's safe to use color\n         write_ok(st.out, true);\n     } else { write_failed(st.out, true); }\n-    st.out.write_str(fmt!{\". %u passed; %u failed; %u ignored\\n\\n\", st.passed,\n-                          st.failed, st.ignored});\n+    st.out.write_str(fmt!(\". %u passed; %u failed; %u ignored\\n\\n\", st.passed,\n+                          st.failed, st.ignored));\n \n     return success;\n \n     fn write_log(out: io::Writer, result: test_result, test: test_desc) {\n-        out.write_line(fmt!{\"%s %s\",\n+        out.write_line(fmt!(\"%s %s\",\n                     match result {\n                         tr_ok => ~\"ok\",\n                         tr_failed => ~\"failed\",\n                         tr_ignored => ~\"ignored\"\n-                    }, test.name});\n+                    }, test.name));\n     }\n \n     fn write_ok(out: io::Writer, use_color: bool) {\n@@ -218,7 +218,7 @@ fn print_failures(st: console_test_state) {\n     let failures = vec::map(failures, |test| test.name);\n     let failures = sort::merge_sort(str::le, failures);\n     for vec::each(failures) |name| {\n-        st.out.write_line(fmt!{\"    %s\", name});\n+        st.out.write_line(fmt!(\"    %s\", name));\n     }\n }\n \n@@ -279,7 +279,7 @@ fn run_tests(opts: test_opts, tests: ~[test_desc],\n     // It's tempting to just spawn all the tests at once, but since we have\n     // many tests that run in other processes we would be making a big mess.\n     let concurrency = get_concurrency();\n-    debug!{\"using %u test tasks\", concurrency};\n+    debug!(\"using %u test tasks\", concurrency);\n \n     let total = vec::len(filtered_tests);\n     let mut run_idx = 0u;"}, {"sha": "4f557fd95734fc45bbabdd78614e7e4ec4dd3955", "filename": "src/libstd/time.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -200,9 +200,9 @@ fn strptime(s: ~str, format: ~str) -> result<tm, ~str> {\n         if c == ch {\n             ok(next)\n         } else {\n-            err(fmt!{\"Expected %?, found %?\",\n+            err(fmt!(\"Expected %?, found %?\",\n                 str::from_char(c),\n-                str::from_char(ch)})\n+                str::from_char(ch)))\n         }\n     }\n \n@@ -511,7 +511,7 @@ fn strptime(s: ~str, format: ~str) -> result<tm, ~str> {\n           }\n           '%' => parse_char(s, pos, '%'),\n           ch => {\n-            err(fmt!{\"unknown formatting type: %?\", str::from_char(ch)})\n+            err(fmt!(\"unknown formatting type: %?\", str::from_char(ch)))\n           }\n         }\n     }\n@@ -625,70 +625,70 @@ fn strftime(format: ~str, tm: tm) -> ~str {\n             11 => ~\"Dec\",\n             _  => die()\n           },\n-          'C' => fmt!{\"%02d\", (tm.tm_year as int + 1900) / 100},\n+          'C' => fmt!(\"%02d\", (tm.tm_year as int + 1900) / 100),\n           'c' => {\n-            fmt!{\"%s %s %s %s %s\",\n+            fmt!(\"%s %s %s %s %s\",\n                 parse_type('a', tm),\n                 parse_type('b', tm),\n                 parse_type('e', tm),\n                 parse_type('T', tm),\n-                parse_type('Y', tm)}\n+                parse_type('Y', tm))\n           }\n           'D' | 'x' => {\n-            fmt!{\"%s/%s/%s\",\n+            fmt!(\"%s/%s/%s\",\n                 parse_type('m', tm),\n                 parse_type('d', tm),\n-                parse_type('y', tm)}\n+                parse_type('y', tm))\n           }\n-          'd' => fmt!{\"%02d\", tm.tm_mday as int},\n-          'e' => fmt!{\"%2d\", tm.tm_mday as int},\n+          'd' => fmt!(\"%02d\", tm.tm_mday as int),\n+          'e' => fmt!(\"%2d\", tm.tm_mday as int),\n           'F' => {\n-            fmt!{\"%s-%s-%s\",\n+            fmt!(\"%s-%s-%s\",\n                 parse_type('Y', tm),\n                 parse_type('m', tm),\n-                parse_type('d', tm)}\n+                parse_type('d', tm))\n           }\n           //'G' {}\n           //'g' {}\n-          'H' => fmt!{\"%02d\", tm.tm_hour as int},\n+          'H' => fmt!(\"%02d\", tm.tm_hour as int),\n           'I' => {\n             let mut h = tm.tm_hour as int;\n             if h == 0 { h = 12 }\n             if h > 12 { h -= 12 }\n-            fmt!{\"%02d\", h}\n+            fmt!(\"%02d\", h)\n           }\n-          'j' => fmt!{\"%03d\", tm.tm_yday as int + 1},\n-          'k' => fmt!{\"%2d\", tm.tm_hour as int},\n+          'j' => fmt!(\"%03d\", tm.tm_yday as int + 1),\n+          'k' => fmt!(\"%2d\", tm.tm_hour as int),\n           'l' => {\n             let mut h = tm.tm_hour as int;\n             if h == 0 { h = 12 }\n             if h > 12 { h -= 12 }\n-            fmt!{\"%2d\", h}\n+            fmt!(\"%2d\", h)\n           }\n-          'M' => fmt!{\"%02d\", tm.tm_min as int},\n-          'm' => fmt!{\"%02d\", tm.tm_mon as int + 1},\n+          'M' => fmt!(\"%02d\", tm.tm_min as int),\n+          'm' => fmt!(\"%02d\", tm.tm_mon as int + 1),\n           'n' => ~\"\\n\",\n           'P' => if tm.tm_hour as int < 12 { ~\"am\" } else { ~\"pm\" },\n           'p' => if tm.tm_hour as int < 12 { ~\"AM\" } else { ~\"PM\" },\n           'R' => {\n-            fmt!{\"%s:%s\",\n+            fmt!(\"%s:%s\",\n                 parse_type('H', tm),\n-                parse_type('M', tm)}\n+                parse_type('M', tm))\n           }\n           'r' => {\n-            fmt!{\"%s:%s:%s %s\",\n+            fmt!(\"%s:%s:%s %s\",\n                 parse_type('I', tm),\n                 parse_type('M', tm),\n                 parse_type('S', tm),\n-                parse_type('p', tm)}\n+                parse_type('p', tm))\n           }\n-          'S' => fmt!{\"%02d\", tm.tm_sec as int},\n-          's' => fmt!{\"%d\", tm.to_timespec().sec as int},\n+          'S' => fmt!(\"%02d\", tm.tm_sec as int),\n+          's' => fmt!(\"%d\", tm.to_timespec().sec as int),\n           'T' | 'X' => {\n-            fmt!{\"%s:%s:%s\",\n+            fmt!(\"%s:%s:%s\",\n                 parse_type('H', tm),\n                 parse_type('M', tm),\n-                parse_type('S', tm)}\n+                parse_type('S', tm))\n           }\n           't' => ~\"\\t\",\n           //'U' {}\n@@ -698,24 +698,24 @@ fn strftime(format: ~str, tm: tm) -> ~str {\n           }\n           //'V' {}\n           'v' => {\n-            fmt!{\"%s-%s-%s\",\n+            fmt!(\"%s-%s-%s\",\n                 parse_type('e', tm),\n                 parse_type('b', tm),\n-                parse_type('Y', tm)}\n+                parse_type('Y', tm))\n           }\n           //'W' {}\n           'w' => int::str(tm.tm_wday as int),\n           //'X' {}\n           //'x' {}\n           'Y' => int::str(tm.tm_year as int + 1900),\n-          'y' => fmt!{\"%02d\", (tm.tm_year as int + 1900) % 100},\n+          'y' => fmt!(\"%02d\", (tm.tm_year as int + 1900) % 100),\n           'Z' => tm.tm_zone,\n           'z' => {\n             let sign = if tm.tm_gmtoff > 0_i32 { '+' } else { '-' };\n             let mut m = i32::abs(tm.tm_gmtoff) / 60_i32;\n             let h = m / 60_i32;\n             m -= h * 60_i32;\n-            fmt!{\"%c%02d%02d\", sign, h as int, m as int}\n+            fmt!(\"%c%02d%02d\", sign, h as int, m as int)\n           }\n           //'+' {}\n           '%' => ~\"%\",\n@@ -807,7 +807,7 @@ impl tm {\n             let mut m = i32::abs(self.tm_gmtoff) / 60_i32;\n             let h = m / 60_i32;\n             m -= h * 60_i32;\n-            s + fmt!{\"%c%02d:%02d\", sign, h as int, m as int}\n+            s + fmt!(\"%c%02d:%02d\", sign, h as int, m as int)\n         }\n     }\n }\n@@ -888,7 +888,7 @@ mod tests {\n         let time = { sec: 1234567890_i64, nsec: 54321_i32 };\n         let local = at(time);\n \n-        error!{\"time_at: %?\", local};\n+        error!(\"time_at: %?\", local);\n \n         assert local.tm_sec == 30_i32;\n         assert local.tm_min == 31_i32;\n@@ -1094,7 +1094,7 @@ mod tests {\n         let utc   = at_utc(time);\n         let local = at(time);\n \n-        error!{\"test_ctime: %? %?\", utc.ctime(), local.ctime()};\n+        error!(\"test_ctime: %? %?\", utc.ctime(), local.ctime());\n \n         assert utc.ctime()   == ~\"Fri Feb 13 23:31:30 2009\";\n         assert local.ctime() == ~\"Fri Feb 13 15:31:30 2009\";"}, {"sha": "02c2294f8c4888d7e2205229bd25c7a7242c8465", "filename": "src/libstd/timer.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibstd%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibstd%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftimer.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -108,8 +108,8 @@ fn recv_timeout<T: copy send>(iotask: iotask,\n     // FIXME: This could be written clearer (#2618)\n     either::either(\n         |left_val| {\n-            log(debug, fmt!{\"recv_time .. left_val %?\",\n-                           left_val});\n+            log(debug, fmt!(\"recv_time .. left_val %?\",\n+                           left_val));\n             none\n         }, |right_val| {\n             some(*right_val)\n@@ -120,7 +120,7 @@ fn recv_timeout<T: copy send>(iotask: iotask,\n // INTERNAL API\n extern fn delayed_send_cb(handle: *uv::ll::uv_timer_t,\n                                 status: libc::c_int) unsafe {\n-    log(debug, fmt!{\"delayed_send_cb handle %? status %?\", handle, status});\n+    log(debug, fmt!(\"delayed_send_cb handle %? status %?\", handle, status));\n     let timer_done_ch =\n         *(uv::ll::get_data_for_uv_handle(handle) as *comm::Chan<()>);\n     let stop_result = uv::ll::timer_stop(handle);\n@@ -136,7 +136,7 @@ extern fn delayed_send_cb(handle: *uv::ll::uv_timer_t,\n }\n \n extern fn delayed_send_close_cb(handle: *uv::ll::uv_timer_t) unsafe {\n-    log(debug, fmt!{\"delayed_send_close_cb handle %?\", handle});\n+    log(debug, fmt!(\"delayed_send_close_cb handle %?\", handle));\n     let timer_done_ch =\n         *(uv::ll::get_data_for_uv_handle(handle) as *comm::Chan<()>);\n     comm::send(timer_done_ch, ());"}, {"sha": "1c301a78260f9ce80c5026e1045041bb5e2dfb43", "filename": "src/libstd/uv_global_loop.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibstd%2Fuv_global_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibstd%2Fuv_global_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_global_loop.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -37,10 +37,10 @@ fn get_monitor_task_gl() -> iotask unsafe {\n \n     let monitor_loop_chan_ptr = rustrt::rust_uv_get_kernel_global_chan_ptr();\n \n-    debug!{\"ENTERING global_loop::get() loop chan: %?\",\n-           monitor_loop_chan_ptr};\n+    debug!(\"ENTERING global_loop::get() loop chan: %?\",\n+           monitor_loop_chan_ptr);\n \n-    debug!{\"before priv::chan_from_global_ptr\"};\n+    debug!(\"before priv::chan_from_global_ptr\");\n     type monchan = Chan<iotask>;\n \n     let monitor_ch =\n@@ -50,31 +50,31 @@ fn get_monitor_task_gl() -> iotask unsafe {\n                                                 (task::SingleThreaded)\n                                                 .unlinked()\n                                            }) |msg_po| {\n-        debug!{\"global monitor task starting\"};\n+        debug!(\"global monitor task starting\");\n \n         // As a weak task the runtime will notify us when to exit\n         do weaken_task() |weak_exit_po| {\n-            debug!{\"global monitor task is now weak\"};\n+            debug!(\"global monitor task is now weak\");\n             let hl_loop = spawn_loop();\n             loop {\n-                debug!{\"in outer_loop...\"};\n+                debug!(\"in outer_loop...\");\n                 match select2(weak_exit_po, msg_po) {\n                   Left(weak_exit) => {\n                     // all normal tasks have ended, tell the\n                     // libuv loop to tear_down, then exit\n-                    debug!{\"weak_exit_po recv'd msg: %?\", weak_exit};\n+                    debug!(\"weak_exit_po recv'd msg: %?\", weak_exit);\n                     iotask::exit(hl_loop);\n                     break;\n                   }\n                   Right(fetch_ch) => {\n-                    debug!{\"hl_loop req recv'd: %?\", fetch_ch};\n+                    debug!(\"hl_loop req recv'd: %?\", fetch_ch);\n                     fetch_ch.send(hl_loop);\n                   }\n                 }\n             }\n-            debug!{\"global monitor task is leaving weakend state\"};\n+            debug!(\"global monitor task is leaving weakend state\");\n         };\n-        debug!{\"global monitor task exiting\"};\n+        debug!(\"global monitor task exiting\");\n     };\n \n     // once we have a chan to the monitor loop, we ask it for\n@@ -91,14 +91,14 @@ fn spawn_loop() -> iotask unsafe {\n             // The I/O loop task also needs to be weak so it doesn't keep\n             // the runtime alive\n             do weaken_task |weak_exit_po| {\n-                debug!{\"global libuv task is now weak %?\", weak_exit_po};\n+                debug!(\"global libuv task is now weak %?\", weak_exit_po);\n                 task_body();\n \n                 // We don't wait for the exit message on weak_exit_po\n                 // because the monitor task will tell the uv loop when to\n                 // exit\n \n-                debug!{\"global libuv task is leaving weakened state\"};\n+                debug!(\"global libuv task is leaving weakened state\");\n             }\n         }\n     };\n@@ -112,8 +112,8 @@ mod test {\n             timer_ptr as *libc::c_void) as *comm::Chan<bool>;\n         let exit_ch = *exit_ch_ptr;\n         core::comm::send(exit_ch, true);\n-        log(debug, fmt!{\"EXIT_CH_PTR simple_timer_close_cb exit_ch_ptr: %?\",\n-                       exit_ch_ptr});\n+        log(debug, fmt!(\"EXIT_CH_PTR simple_timer_close_cb exit_ch_ptr: %?\",\n+                       exit_ch_ptr));\n     }\n     extern fn simple_timer_cb(timer_ptr: *ll::uv_timer_t,\n                              _status: libc::c_int) unsafe {\n@@ -133,8 +133,8 @@ mod test {\n         let exit_po = core::comm::port::<bool>();\n         let exit_ch = core::comm::chan(exit_po);\n         let exit_ch_ptr = ptr::addr_of(exit_ch);\n-        log(debug, fmt!{\"EXIT_CH_PTR newly created exit_ch_ptr: %?\",\n-                       exit_ch_ptr});\n+        log(debug, fmt!(\"EXIT_CH_PTR newly created exit_ch_ptr: %?\",\n+                       exit_ch_ptr));\n         let timer_handle = ll::timer_t();\n         let timer_ptr = ptr::addr_of(timer_handle);\n         do iotask::interact(iotask) |loop_ptr| {"}, {"sha": "2643edc87bdb1326fb698d603ecf3dc4b1056024", "filename": "src/libstd/uv_iotask.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibstd%2Fuv_iotask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibstd%2Fuv_iotask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_iotask.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -30,9 +30,9 @@ fn spawn_iotask(-task: task::TaskBuilder) -> iotask {\n     do listen |iotask_ch| {\n \n         do task.sched_mode(task::SingleThreaded).spawn {\n-            debug!{\"entering libuv task\"};\n+            debug!(\"entering libuv task\");\n             run_loop(iotask_ch);\n-            debug!{\"libuv task exiting\"};\n+            debug!(\"libuv task exiting\");\n         };\n \n         iotask_ch.recv()\n@@ -137,8 +137,8 @@ fn send_msg(iotask: iotask,\n extern fn wake_up_cb(async_handle: *ll::uv_async_t,\n                     status: int) unsafe {\n \n-    log(debug, fmt!{\"wake_up_cb extern.. handle: %? status: %?\",\n-                     async_handle, status});\n+    log(debug, fmt!(\"wake_up_cb extern.. handle: %? status: %?\",\n+                     async_handle, status));\n \n     let loop_ptr = ll::get_loop_for_uv_handle(async_handle);\n     let data = ll::get_data_for_uv_handle(async_handle) as *iotask_loop_data;\n@@ -161,22 +161,22 @@ fn begin_teardown(data: *iotask_loop_data) unsafe {\n extern fn tear_down_close_cb(handle: *ll::uv_async_t) unsafe {\n     let loop_ptr = ll::get_loop_for_uv_handle(handle);\n     let loop_refs = ll::loop_refcount(loop_ptr);\n-    log(debug, fmt!{\"tear_down_close_cb called, closing handle at %? refs %?\",\n-                    handle, loop_refs});\n+    log(debug, fmt!(\"tear_down_close_cb called, closing handle at %? refs %?\",\n+                    handle, loop_refs));\n     assert loop_refs == 1i32;\n }\n \n #[cfg(test)]\n mod test {\n     extern fn async_close_cb(handle: *ll::uv_async_t) unsafe {\n-        log(debug, fmt!{\"async_close_cb handle %?\", handle});\n+        log(debug, fmt!(\"async_close_cb handle %?\", handle));\n         let exit_ch = (*(ll::get_data_for_uv_handle(handle)\n                         as *ah_data)).exit_ch;\n         core::comm::send(exit_ch, ());\n     }\n     extern fn async_handle_cb(handle: *ll::uv_async_t, status: libc::c_int)\n         unsafe {\n-        log(debug, fmt!{\"async_handle_cb handle %? status %?\",handle,status});\n+        log(debug, fmt!(\"async_handle_cb handle %? status %?\",handle,status));\n         ll::close(handle, async_close_cb);\n     }\n     type ah_data = {\n@@ -214,13 +214,13 @@ mod test {\n     }\n \n     extern fn lifetime_handle_close(handle: *libc::c_void) unsafe {\n-        log(debug, fmt!{\"lifetime_handle_close ptr %?\", handle});\n+        log(debug, fmt!(\"lifetime_handle_close ptr %?\", handle));\n     }\n \n     extern fn lifetime_async_callback(handle: *libc::c_void,\n                                      status: libc::c_int) {\n-        log(debug, fmt!{\"lifetime_handle_close ptr %? status %?\",\n-                        handle, status});\n+        log(debug, fmt!(\"lifetime_handle_close ptr %? status %?\",\n+                        handle, status));\n     }\n \n     #[test]"}, {"sha": "79a2856a1c75434394a228ba0288b36e98d2d32c", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 84, "deletions": 84, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -707,8 +707,8 @@ unsafe fn tcp_connect(connect_ptr: *uv_connect_t,\n                       addr_ptr: *sockaddr_in,\n                       ++after_connect_cb: *u8)\n -> libc::c_int {\n-    log(debug, fmt!{\"b4 foreign tcp_connect--addr port: %u cb: %u\",\n-                    (*addr_ptr).sin_port as uint, after_connect_cb as uint});\n+    log(debug, fmt!(\"b4 foreign tcp_connect--addr port: %u cb: %u\",\n+                    (*addr_ptr).sin_port as uint, after_connect_cb as uint));\n     return rustrt::rust_uv_tcp_connect(connect_ptr, tcp_handle_ptr,\n                                     after_connect_cb, addr_ptr);\n }\n@@ -788,20 +788,20 @@ unsafe fn async_send(async_handle: *uv_async_t) {\n unsafe fn buf_init(++input: *u8, len: uint) -> uv_buf_t {\n     let out_buf = { base: ptr::null(), len: 0 as libc::size_t };\n     let out_buf_ptr = ptr::addr_of(out_buf);\n-    log(debug, fmt!{\"buf_init - input %u len %u out_buf: %u\",\n+    log(debug, fmt!(\"buf_init - input %u len %u out_buf: %u\",\n                      input as uint,\n                      len as uint,\n-                     out_buf_ptr as uint});\n+                     out_buf_ptr as uint));\n     // yuck :/\n     rustrt::rust_uv_buf_init(out_buf_ptr, input, len as size_t);\n     //let result = rustrt::rust_uv_buf_init_2(input, len as size_t);\n     log(debug, ~\"after rust_uv_buf_init\");\n     let res_base = get_base_from_buf(out_buf);\n     let res_len = get_len_from_buf(out_buf);\n     //let res_base = get_base_from_buf(result);\n-    log(debug, fmt!{\"buf_init - result %u len %u\",\n+    log(debug, fmt!(\"buf_init - result %u len %u\",\n                      res_base as uint,\n-                     res_len as uint});\n+                     res_len as uint));\n     return out_buf;\n     //return result;\n }\n@@ -845,8 +845,8 @@ unsafe fn ip6_name(src: &sockaddr_in6) -> ~str {\n                        0u8,0u8,0u8,0u8,0u8,0u8];\n     do vec::as_buf(dst) |dst_buf, size| {\n         let src_unsafe_ptr = assimilate(src);\n-        log(debug, fmt!{\"val of src *sockaddr_in6: %? sockaddr_in6: %?\",\n-                        src_unsafe_ptr, src});\n+        log(debug, fmt!(\"val of src *sockaddr_in6: %? sockaddr_in6: %?\",\n+                        src_unsafe_ptr, src));\n         let result = rustrt::rust_uv_ip6_name(src_unsafe_ptr,\n                                               dst_buf, size as libc::size_t);\n         match result {\n@@ -962,8 +962,8 @@ unsafe fn get_last_err_info(uv_loop: *libc::c_void) -> ~str {\n     let err_ptr = ptr::addr_of(err);\n     let err_name = str::unsafe::from_c_str(err_name(err_ptr));\n     let err_msg = str::unsafe::from_c_str(strerror(err_ptr));\n-    return fmt!{\"LIBUV ERROR: name: %s msg: %s\",\n-                    err_name, err_msg};\n+    return fmt!(\"LIBUV ERROR: name: %s msg: %s\",\n+                    err_name, err_msg);\n }\n \n unsafe fn get_last_err_data(uv_loop: *libc::c_void) -> uv_err_data {\n@@ -1013,31 +1013,31 @@ mod test {\n     };\n \n     extern fn after_close_cb(handle: *libc::c_void) {\n-        log(debug, fmt!{\"after uv_close! handle ptr: %?\",\n-                        handle});\n+        log(debug, fmt!(\"after uv_close! handle ptr: %?\",\n+                        handle));\n     }\n \n     extern fn on_alloc_cb(handle: *libc::c_void,\n                          ++suggested_size: libc::size_t)\n         -> uv_buf_t unsafe {\n         log(debug, ~\"on_alloc_cb!\");\n         let char_ptr = malloc_buf_base_of(suggested_size);\n-        log(debug, fmt!{\"on_alloc_cb h: %? char_ptr: %u sugsize: %u\",\n+        log(debug, fmt!(\"on_alloc_cb h: %? char_ptr: %u sugsize: %u\",\n                          handle,\n                          char_ptr as uint,\n-                         suggested_size as uint});\n+                         suggested_size as uint));\n         return buf_init(char_ptr, suggested_size as uint);\n     }\n \n     extern fn on_read_cb(stream: *uv_stream_t,\n                         nread: libc::ssize_t,\n                         ++buf: uv_buf_t) unsafe {\n         let nread = nread as int;\n-        log(debug, fmt!{\"CLIENT entering on_read_cb nred: %d\",\n-                        nread});\n+        log(debug, fmt!(\"CLIENT entering on_read_cb nred: %d\",\n+                        nread));\n         if (nread > 0) {\n             // we have data\n-            log(debug, fmt!{\"CLIENT read: data! nread: %d\", nread});\n+            log(debug, fmt!(\"CLIENT read: data! nread: %d\", nread));\n             read_stop(stream);\n             let client_data =\n                 get_data_for_uv_handle(stream as *libc::c_void)\n@@ -1065,20 +1065,20 @@ mod test {\n \n     extern fn on_write_complete_cb(write_req: *uv_write_t,\n                                   status: libc::c_int) unsafe {\n-        log(debug, fmt!{\"CLIENT beginning on_write_complete_cb status: %d\",\n-                         status as int});\n+        log(debug, fmt!(\"CLIENT beginning on_write_complete_cb status: %d\",\n+                         status as int));\n         let stream = get_stream_handle_from_write_req(write_req);\n-        log(debug, fmt!{\"CLIENT on_write_complete_cb: tcp:%d write_handle:%d\",\n-            stream as int, write_req as int});\n+        log(debug, fmt!(\"CLIENT on_write_complete_cb: tcp:%d write_handle:%d\",\n+            stream as int, write_req as int));\n         let result = read_start(stream, on_alloc_cb, on_read_cb);\n-        log(debug, fmt!{\"CLIENT ending on_write_complete_cb .. status: %d\",\n-                         result as int});\n+        log(debug, fmt!(\"CLIENT ending on_write_complete_cb .. status: %d\",\n+                         result as int));\n     }\n \n     extern fn on_connect_cb(connect_req_ptr: *uv_connect_t,\n                                  status: libc::c_int) unsafe {\n-        log(debug, fmt!{\"beginning on_connect_cb .. status: %d\",\n-                         status as int});\n+        log(debug, fmt!(\"beginning on_connect_cb .. status: %d\",\n+                         status as int));\n         let stream =\n             get_stream_handle_from_connect_req(connect_req_ptr);\n         if (status == 0i32) {\n@@ -1087,14 +1087,14 @@ mod test {\n                 connect_req_ptr as *libc::c_void)\n                 as *request_wrapper;\n             let write_handle = (*client_data).write_req;\n-            log(debug, fmt!{\"on_connect_cb: tcp: %d write_hdl: %d\",\n-                            stream as int, write_handle as int});\n+            log(debug, fmt!(\"on_connect_cb: tcp: %d write_hdl: %d\",\n+                            stream as int, write_handle as int));\n             let write_result = write(write_handle,\n                               stream as *libc::c_void,\n                               (*client_data).req_buf,\n                               on_write_complete_cb);\n-            log(debug, fmt!{\"on_connect_cb: write() status: %d\",\n-                             write_result as int});\n+            log(debug, fmt!(\"on_connect_cb: write() status: %d\",\n+                             write_result as int));\n         }\n         else {\n             let test_loop = get_loop_for_uv_handle(\n@@ -1121,17 +1121,17 @@ mod test {\n         // data field in our uv_connect_t struct\n         let req_str_bytes = str::bytes(req_str);\n         let req_msg_ptr: *u8 = vec::unsafe::to_ptr(req_str_bytes);\n-        log(debug, fmt!{\"req_msg ptr: %u\", req_msg_ptr as uint});\n+        log(debug, fmt!(\"req_msg ptr: %u\", req_msg_ptr as uint));\n         let req_msg = ~[\n             buf_init(req_msg_ptr, vec::len(req_str_bytes))\n         ];\n         // this is the enclosing record, we'll pass a ptr to\n         // this to C..\n         let write_handle = write_t();\n         let write_handle_ptr = ptr::addr_of(write_handle);\n-        log(debug, fmt!{\"tcp req: tcp stream: %d write_handle: %d\",\n+        log(debug, fmt!(\"tcp req: tcp stream: %d write_handle: %d\",\n                          tcp_handle_ptr as int,\n-                         write_handle_ptr as int});\n+                         write_handle_ptr as int));\n         let client_data = { writer_handle: write_handle_ptr,\n                     req_buf: ptr::addr_of(req_msg),\n                     read_chan: client_chan };\n@@ -1145,12 +1145,12 @@ mod test {\n             let addr = ip4_addr(ip, port);\n             // FIXME ref #2064\n             let addr_ptr = ptr::addr_of(addr);\n-            log(debug, fmt!{\"after build addr in rust. port: %u\",\n-                             addr.sin_port as uint});\n+            log(debug, fmt!(\"after build addr in rust. port: %u\",\n+                             addr.sin_port as uint));\n \n             // this should set up the connection request..\n-            log(debug, fmt!{\"b4 call tcp_connect connect cb: %u \",\n-                            on_connect_cb as uint});\n+            log(debug, fmt!(\"b4 call tcp_connect connect cb: %u \",\n+                            on_connect_cb as uint));\n             let tcp_connect_result = tcp_connect(\n                 connect_req_ptr, tcp_handle_ptr,\n                 addr_ptr, on_connect_cb);\n@@ -1181,8 +1181,8 @@ mod test {\n     }\n \n     extern fn server_after_close_cb(handle: *libc::c_void) unsafe {\n-        log(debug, fmt!{\"SERVER server stream closed, should exit.. h: %?\",\n-                   handle});\n+        log(debug, fmt!(\"SERVER server stream closed, should exit.. h: %?\",\n+                   handle));\n     }\n \n     extern fn client_stream_after_close_cb(handle: *libc::c_void)\n@@ -1210,15 +1210,15 @@ mod test {\n         let nread = nread as int;\n         if (nread > 0) {\n             // we have data\n-            log(debug, fmt!{\"SERVER read: data! nread: %d\", nread});\n+            log(debug, fmt!(\"SERVER read: data! nread: %d\", nread));\n \n             // pull out the contents of the write from the client\n             let buf_base = get_base_from_buf(buf);\n             let buf_len = get_len_from_buf(buf) as uint;\n-            log(debug, fmt!{\"SERVER buf base: %u, len: %u, nread: %d\",\n+            log(debug, fmt!(\"SERVER buf base: %u, len: %u, nread: %d\",\n                             buf_base as uint,\n                             buf_len as uint,\n-                            nread});\n+                            nread));\n             let bytes = vec::unsafe::from_buf(buf_base, buf_len);\n             let request_str = str::from_bytes(bytes);\n \n@@ -1238,8 +1238,8 @@ mod test {\n                     client_stream_ptr as *libc::c_void,\n                     (*client_data).server_resp_buf,\n                     after_server_resp_write);\n-                log(debug, fmt!{\"SERVER: resp write result: %d\",\n-                            write_result as int});\n+                log(debug, fmt!(\"SERVER: resp write result: %d\",\n+                            write_result as int));\n                 if (write_result != 0i32) {\n                     log(debug, ~\"bad result for server resp write()\");\n                     log(debug, get_last_err_info(\n@@ -1273,8 +1273,8 @@ mod test {\n                                server_stream_ptr as *libc::c_void);\n         if status != 0i32 {\n             let err_msg = get_last_err_info(test_loop);\n-            log(debug, fmt!{\"server_connect_cb: non-zero status: %?\",\n-                         err_msg});\n+            log(debug, fmt!(\"server_connect_cb: non-zero status: %?\",\n+                         err_msg));\n             return;\n         }\n         let server_data = get_data_for_uv_handle(\n@@ -1301,20 +1301,20 @@ mod test {\n                     log(debug, ~\"successful server read start\");\n                 }\n                 else {\n-                    log(debug, fmt!{\"server_connection_cb: bad read:%d\",\n-                                    read_result as int});\n+                    log(debug, fmt!(\"server_connection_cb: bad read:%d\",\n+                                    read_result as int));\n                     assert false;\n                 }\n             }\n             else {\n-                log(debug, fmt!{\"server_connection_cb: bad accept: %d\",\n-                            accept_result as int});\n+                log(debug, fmt!(\"server_connection_cb: bad accept: %d\",\n+                            accept_result as int));\n                 assert false;\n             }\n         }\n         else {\n-            log(debug, fmt!{\"server_connection_cb: bad client init: %d\",\n-                        client_init_result as int});\n+            log(debug, fmt!(\"server_connection_cb: bad client init: %d\",\n+                        client_init_result as int));\n             assert false;\n         }\n     }\n@@ -1333,8 +1333,8 @@ mod test {\n     };\n \n     extern fn async_close_cb(handle: *libc::c_void) {\n-        log(debug, fmt!{\"SERVER: closing async cb... h: %?\",\n-                   handle});\n+        log(debug, fmt!(\"SERVER: closing async cb... h: %?\",\n+                   handle));\n     }\n \n     extern fn continue_async_cb(async_handle: *uv_async_t,\n@@ -1369,7 +1369,7 @@ mod test {\n \n         let resp_str_bytes = str::bytes(server_resp_msg);\n         let resp_msg_ptr: *u8 = vec::unsafe::to_ptr(resp_str_bytes);\n-        log(debug, fmt!{\"resp_msg ptr: %u\", resp_msg_ptr as uint});\n+        log(debug, fmt!(\"resp_msg ptr: %u\", resp_msg_ptr as uint));\n         let resp_msg = ~[\n             buf_init(resp_msg_ptr, vec::len(resp_str_bytes))\n         ];\n@@ -1428,26 +1428,26 @@ mod test {\n                         log(debug, ~\"server uv::run() has returned\");\n                     }\n                     else {\n-                        log(debug, fmt!{\"uv_async_init failure: %d\",\n-                                async_result as int});\n+                        log(debug, fmt!(\"uv_async_init failure: %d\",\n+                                async_result as int));\n                         assert false;\n                     }\n                 }\n                 else {\n-                    log(debug, fmt!{\"non-zero result on uv_listen: %d\",\n-                                listen_result as int});\n+                    log(debug, fmt!(\"non-zero result on uv_listen: %d\",\n+                                listen_result as int));\n                     assert false;\n                 }\n             }\n             else {\n-                log(debug, fmt!{\"non-zero result on uv_tcp_bind: %d\",\n-                            bind_result as int});\n+                log(debug, fmt!(\"non-zero result on uv_tcp_bind: %d\",\n+                            bind_result as int));\n                 assert false;\n             }\n         }\n         else {\n-            log(debug, fmt!{\"non-zero result on uv_tcp_init: %d\",\n-                        tcp_init_result as int});\n+            log(debug, fmt!(\"non-zero result on uv_tcp_init: %d\",\n+                        tcp_init_result as int));\n             assert false;\n         }\n         loop_delete(test_loop);\n@@ -1524,8 +1524,8 @@ mod test {\n     fn test_uv_ll_struct_size_uv_tcp_t() {\n         let foreign_handle_size = rustrt::rust_uv_helper_uv_tcp_t_size();\n         let rust_handle_size = sys::size_of::<uv_tcp_t>();\n-        let output = fmt!{\"uv_tcp_t -- foreign: %u rust: %u\",\n-                          foreign_handle_size as uint, rust_handle_size};\n+        let output = fmt!(\"uv_tcp_t -- foreign: %u rust: %u\",\n+                          foreign_handle_size as uint, rust_handle_size);\n         log(debug, output);\n         assert foreign_handle_size as uint == rust_handle_size;\n     }\n@@ -1535,8 +1535,8 @@ mod test {\n         let foreign_handle_size =\n             rustrt::rust_uv_helper_uv_connect_t_size();\n         let rust_handle_size = sys::size_of::<uv_connect_t>();\n-        let output = fmt!{\"uv_connect_t -- foreign: %u rust: %u\",\n-                          foreign_handle_size as uint, rust_handle_size};\n+        let output = fmt!(\"uv_connect_t -- foreign: %u rust: %u\",\n+                          foreign_handle_size as uint, rust_handle_size);\n         log(debug, output);\n         assert foreign_handle_size as uint == rust_handle_size;\n     }\n@@ -1546,8 +1546,8 @@ mod test {\n         let foreign_handle_size =\n             rustrt::rust_uv_helper_uv_buf_t_size();\n         let rust_handle_size = sys::size_of::<uv_buf_t>();\n-        let output = fmt!{\"uv_buf_t -- foreign: %u rust: %u\",\n-                          foreign_handle_size as uint, rust_handle_size};\n+        let output = fmt!(\"uv_buf_t -- foreign: %u rust: %u\",\n+                          foreign_handle_size as uint, rust_handle_size);\n         log(debug, output);\n         assert foreign_handle_size as uint == rust_handle_size;\n     }\n@@ -1557,8 +1557,8 @@ mod test {\n         let foreign_handle_size =\n             rustrt::rust_uv_helper_uv_write_t_size();\n         let rust_handle_size = sys::size_of::<uv_write_t>();\n-        let output = fmt!{\"uv_write_t -- foreign: %u rust: %u\",\n-                          foreign_handle_size as uint, rust_handle_size};\n+        let output = fmt!(\"uv_write_t -- foreign: %u rust: %u\",\n+                          foreign_handle_size as uint, rust_handle_size);\n         log(debug, output);\n         assert foreign_handle_size as uint == rust_handle_size;\n     }\n@@ -1569,8 +1569,8 @@ mod test {\n         let foreign_handle_size =\n             rustrt::rust_uv_helper_sockaddr_in_size();\n         let rust_handle_size = sys::size_of::<sockaddr_in>();\n-        let output = fmt!{\"sockaddr_in -- foreign: %u rust: %u\",\n-                          foreign_handle_size as uint, rust_handle_size};\n+        let output = fmt!(\"sockaddr_in -- foreign: %u rust: %u\",\n+                          foreign_handle_size as uint, rust_handle_size);\n         log(debug, output);\n         assert foreign_handle_size as uint == rust_handle_size;\n     }\n@@ -1580,8 +1580,8 @@ mod test {\n         let foreign_handle_size =\n             rustrt::rust_uv_helper_sockaddr_in6_size();\n         let rust_handle_size = sys::size_of::<sockaddr_in6>();\n-        let output = fmt!{\"sockaddr_in6 -- foreign: %u rust: %u\",\n-                          foreign_handle_size as uint, rust_handle_size};\n+        let output = fmt!(\"sockaddr_in6 -- foreign: %u rust: %u\",\n+                          foreign_handle_size as uint, rust_handle_size);\n         log(debug, output);\n         // FIXME #1645 .. rust appears to pad structs to the nearest byte..?\n         // .. can't get the uv::ll::sockaddr_in6 to == 28 :/\n@@ -1595,8 +1595,8 @@ mod test {\n         let foreign_handle_size =\n             rustrt::rust_uv_helper_addr_in_size();\n         let rust_handle_size = sys::size_of::<addr_in>();\n-        let output = fmt!{\"addr_in -- foreign: %u rust: %u\",\n-                          foreign_handle_size as uint, rust_handle_size};\n+        let output = fmt!(\"addr_in -- foreign: %u rust: %u\",\n+                          foreign_handle_size as uint, rust_handle_size);\n         log(debug, output);\n         // FIXME #1645 .. see note above about struct padding\n         assert (4u+foreign_handle_size as uint) == rust_handle_size;\n@@ -1608,8 +1608,8 @@ mod test {\n         let foreign_handle_size =\n             rustrt::rust_uv_helper_uv_async_t_size();\n         let rust_handle_size = sys::size_of::<uv_async_t>();\n-        let output = fmt!{\"uv_async_t -- foreign: %u rust: %u\",\n-                          foreign_handle_size as uint, rust_handle_size};\n+        let output = fmt!(\"uv_async_t -- foreign: %u rust: %u\",\n+                          foreign_handle_size as uint, rust_handle_size);\n         log(debug, output);\n         assert foreign_handle_size as uint == rust_handle_size;\n     }\n@@ -1620,8 +1620,8 @@ mod test {\n         let foreign_handle_size =\n             rustrt::rust_uv_helper_uv_timer_t_size();\n         let rust_handle_size = sys::size_of::<uv_timer_t>();\n-        let output = fmt!{\"uv_timer_t -- foreign: %u rust: %u\",\n-                          foreign_handle_size as uint, rust_handle_size};\n+        let output = fmt!(\"uv_timer_t -- foreign: %u rust: %u\",\n+                          foreign_handle_size as uint, rust_handle_size);\n         log(debug, output);\n         assert foreign_handle_size as uint == rust_handle_size;\n     }\n@@ -1633,8 +1633,8 @@ mod test {\n         let foreign_handle_size =\n             rustrt::rust_uv_helper_uv_getaddrinfo_t_size();\n         let rust_handle_size = sys::size_of::<uv_getaddrinfo_t>();\n-        let output = fmt!{\"uv_getaddrinfo_t -- foreign: %u rust: %u\",\n-                          foreign_handle_size as uint, rust_handle_size};\n+        let output = fmt!(\"uv_getaddrinfo_t -- foreign: %u rust: %u\",\n+                          foreign_handle_size as uint, rust_handle_size);\n         log(debug, output);\n         assert foreign_handle_size as uint == rust_handle_size;\n     }\n@@ -1646,8 +1646,8 @@ mod test {\n         let foreign_handle_size =\n             rustrt::rust_uv_helper_addrinfo_size();\n         let rust_handle_size = sys::size_of::<addrinfo>();\n-        let output = fmt!{\"addrinfo -- foreign: %u rust: %u\",\n-                          foreign_handle_size as uint, rust_handle_size};\n+        let output = fmt!(\"addrinfo -- foreign: %u rust: %u\",\n+                          foreign_handle_size as uint, rust_handle_size);\n         log(debug, output);\n         assert foreign_handle_size as uint == rust_handle_size;\n     }"}, {"sha": "fbcfb3139d18c4642ca1883cd965eff37e622f06", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -25,7 +25,7 @@ fn path_ident_to_str(p: path, i: ident, itr: ident_interner) -> ~str {\n         //FIXME /* FIXME (#2543) */ copy *i\n         *itr.get(i)\n     } else {\n-        fmt!{\"%s::%s\", path_to_str(p, itr), *itr.get(i)}\n+        fmt!(\"%s::%s\", path_to_str(p, itr), *itr.get(i))\n     }\n }\n \n@@ -296,7 +296,7 @@ fn map_stmt(stmt: @stmt, cx: ctx, v: vt) {\n fn node_id_to_str(map: map, id: node_id, itr: ident_interner) -> ~str {\n     match map.find(id) {\n       none => {\n-        fmt!{\"unknown node (id=%d)\", id}\n+        fmt!(\"unknown node (id=%d)\", id)\n       }\n       some(node_item(item, path)) => {\n         let path_str = path_ident_to_str(*path, item.ident, itr);\n@@ -315,48 +315,48 @@ fn node_id_to_str(map: map, id: node_id, itr: ident_interner) -> ~str {\n         fmt!(\"%s %s (id=%?)\", item_str, path_str, id)\n       }\n       some(node_foreign_item(item, abi, path)) => {\n-        fmt!{\"foreign item %s with abi %? (id=%?)\",\n-             path_ident_to_str(*path, item.ident, itr), abi, id}\n+        fmt!(\"foreign item %s with abi %? (id=%?)\",\n+             path_ident_to_str(*path, item.ident, itr), abi, id)\n       }\n       some(node_method(m, impl_did, path)) => {\n-        fmt!{\"method %s in %s (id=%?)\",\n-             *itr.get(m.ident), path_to_str(*path, itr), id}\n+        fmt!(\"method %s in %s (id=%?)\",\n+             *itr.get(m.ident), path_to_str(*path, itr), id)\n       }\n       some(node_trait_method(tm, impl_did, path)) => {\n         let m = ast_util::trait_method_to_ty_method(*tm);\n-        fmt!{\"method %s in %s (id=%?)\",\n-             *itr.get(m.ident), path_to_str(*path, itr), id}\n+        fmt!(\"method %s in %s (id=%?)\",\n+             *itr.get(m.ident), path_to_str(*path, itr), id)\n       }\n       some(node_variant(variant, def_id, path)) => {\n-        fmt!{\"variant %s in %s (id=%?)\",\n-             *itr.get(variant.node.name), path_to_str(*path, itr), id}\n+        fmt!(\"variant %s in %s (id=%?)\",\n+             *itr.get(variant.node.name), path_to_str(*path, itr), id)\n       }\n       some(node_expr(expr)) => {\n-        fmt!{\"expr %s (id=%?)\", pprust::expr_to_str(expr, itr), id}\n+        fmt!(\"expr %s (id=%?)\", pprust::expr_to_str(expr, itr), id)\n       }\n       some(node_stmt(stmt)) => {\n-        fmt!{\"stmt %s (id=%?)\",\n-             pprust::stmt_to_str(*stmt, itr), id}\n+        fmt!(\"stmt %s (id=%?)\",\n+             pprust::stmt_to_str(*stmt, itr), id)\n       }\n       // FIXMEs are as per #2410\n       some(node_export(_, path)) => {\n-        fmt!{\"export %s (id=%?)\", // add more info here\n-             path_to_str(*path, itr), id}\n+        fmt!(\"export %s (id=%?)\", // add more info here\n+             path_to_str(*path, itr), id)\n       }\n       some(node_arg(_, _)) => { // add more info here\n-        fmt!{\"arg (id=%?)\", id}\n+        fmt!(\"arg (id=%?)\", id)\n       }\n       some(node_local(_)) => { // add more info here\n-        fmt!{\"local (id=%?)\", id}\n+        fmt!(\"local (id=%?)\", id)\n       }\n       some(node_ctor(*)) => { // add more info here\n-        fmt!{\"node_ctor (id=%?)\", id}\n+        fmt!(\"node_ctor (id=%?)\", id)\n       }\n       some(node_dtor(*)) => { // add more info here\n-        fmt!{\"node_dtor (id=%?)\", id}\n+        fmt!(\"node_dtor (id=%?)\", id)\n       }\n       some(node_block(_)) => {\n-        fmt!{\"block\"}\n+        fmt!(\"block\")\n       }\n     }\n }"}, {"sha": "c1838c7780237f2305933bf920b70fe17f5b5ed9", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -368,7 +368,7 @@ fn require_unique_names(diagnostic: span_handler,\n         // FIXME: How do I silence the warnings? --pcw (#2619)\n         if map.contains_key(name) {\n             diagnostic.span_fatal(meta.span,\n-                                  fmt!{\"duplicate meta item `%s`\", name});\n+                                  fmt!(\"duplicate meta item `%s`\", name));\n         }\n         map.insert(name, ());\n     }"}, {"sha": "bbaaf2deb350a0b08deff5824e45418a76b2b594", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -73,7 +73,7 @@ fn new_filemap(+filename: filename, src: @~str,\n fn mk_substr_filename(cm: codemap, sp: span) -> ~str\n {\n     let pos = lookup_char_pos(cm, sp.lo);\n-    return fmt!{\"<%s:%u:%u>\", pos.file.name, pos.line, pos.col};\n+    return fmt!(\"<%s:%u:%u>\", pos.file.name, pos.line, pos.col);\n }\n \n fn next_line(file: filemap, chpos: uint, byte_pos: uint) {\n@@ -93,7 +93,7 @@ fn lookup_line(map: codemap, pos: uint, lookup: lookup_fn)\n         if lookup(map.files[m].start_pos) > pos { b = m; } else { a = m; }\n     }\n     if (a >= len) {\n-        fail fmt!{\"position %u does not resolve to a source location\", pos}\n+        fail fmt!(\"position %u does not resolve to a source location\", pos)\n     }\n     let f = map.files[a];\n     a = 0u;\n@@ -166,15 +166,15 @@ type span = {lo: uint, hi: uint, expn_info: expn_info};\n fn span_to_str_no_adj(sp: span, cm: codemap) -> ~str {\n     let lo = lookup_char_pos(cm, sp.lo);\n     let hi = lookup_char_pos(cm, sp.hi);\n-    return fmt!{\"%s:%u:%u: %u:%u\", lo.file.name,\n-             lo.line, lo.col, hi.line, hi.col}\n+    return fmt!(\"%s:%u:%u: %u:%u\", lo.file.name,\n+             lo.line, lo.col, hi.line, hi.col)\n }\n \n fn span_to_str(sp: span, cm: codemap) -> ~str {\n     let lo = lookup_char_pos_adj(cm, sp.lo);\n     let hi = lookup_char_pos_adj(cm, sp.hi);\n-    return fmt!{\"%s:%u:%u: %u:%u\", lo.filename,\n-             lo.line, lo.col, hi.line, hi.col}\n+    return fmt!(\"%s:%u:%u: %u:%u\", lo.filename,\n+             lo.line, lo.col, hi.line, hi.col)\n }\n \n type file_lines = {file: filemap, lines: ~[uint]};"}, {"sha": "0c622cf7a7c0dea12181230d86909921bf7b5783", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -91,8 +91,8 @@ impl handler_t: handler {\n           0u => return,\n           1u => s = ~\"aborting due to previous error\",\n           _  => {\n-            s = fmt!{\"aborting due to %u previous errors\",\n-                     self.err_count};\n+            s = fmt!(\"aborting due to %u previous errors\",\n+                     self.err_count);\n           }\n         }\n         self.fatal(s);\n@@ -113,7 +113,7 @@ impl handler_t: handler {\n }\n \n fn ice_msg(msg: ~str) -> ~str {\n-    fmt!{\"internal compiler error: %s\", msg}\n+    fmt!(\"internal compiler error: %s\", msg)\n }\n \n fn mk_span_handler(handler: handler, cm: codemap::codemap) -> span_handler {\n@@ -168,16 +168,16 @@ fn print_diagnostic(topic: ~str, lvl: level, msg: ~str) {\n     let use_color = term::color_supported() &&\n         io::stderr().get_type() == io::Screen;\n     if str::is_not_empty(topic) {\n-        io::stderr().write_str(fmt!{\"%s \", topic});\n+        io::stderr().write_str(fmt!(\"%s \", topic));\n     }\n     if use_color {\n         term::fg(io::stderr(), diagnosticcolor(lvl));\n     }\n-    io::stderr().write_str(fmt!{\"%s:\", diagnosticstr(lvl)});\n+    io::stderr().write_str(fmt!(\"%s:\", diagnosticstr(lvl)));\n     if use_color {\n         term::reset(io::stderr());\n     }\n-    io::stderr().write_str(fmt!{\" %s\\n\", msg});\n+    io::stderr().write_str(fmt!(\" %s\\n\", msg));\n }\n \n fn emit(cmsp: option<(codemap::codemap, span)>,\n@@ -212,13 +212,13 @@ fn highlight_lines(cm: codemap::codemap, sp: span,\n     }\n     // Print the offending lines\n     for display_lines.each |line| {\n-        io::stderr().write_str(fmt!{\"%s:%u \", fm.name, line + 1u});\n+        io::stderr().write_str(fmt!(\"%s:%u \", fm.name, line + 1u));\n         let s = codemap::get_line(fm, line as int) + ~\"\\n\";\n         io::stderr().write_str(s);\n     }\n     if elided {\n         let last_line = display_lines[vec::len(display_lines) - 1u];\n-        let s = fmt!{\"%s:%u \", fm.name, last_line + 1u};\n+        let s = fmt!(\"%s:%u \", fm.name, last_line + 1u);\n         let mut indent = str::len(s);\n         let mut out = ~\"\";\n         while indent > 0u { out += ~\" \"; indent -= 1u; }\n@@ -257,7 +257,7 @@ fn print_macro_backtrace(cm: codemap::codemap, sp: span) {\n         let ss = option::map_default(ei.callie.span, @~\"\",\n                                      |span| @codemap::span_to_str(span, cm));\n         print_diagnostic(*ss, note,\n-                         fmt!{\"in expansion of #%s\", ei.callie.name});\n+                         fmt!(\"in expansion of #%s\", ei.callie.name));\n         let ss = codemap::span_to_str(ei.call_site, cm);\n         print_diagnostic(ss, note, ~\"expansion site\");\n         print_macro_backtrace(cm, ei.call_site);"}, {"sha": "d094bfe6f01913eb8dae6ddd7f70d1df04136c65", "filename": "src/libsyntax/ext/auto_serialize.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_serialize.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -356,7 +356,7 @@ fn ser_variant(cx: ext_ctxt,\n                argfn: fn(-@ast::expr, uint, ast::blk) -> @ast::expr)\n     -> ast::arm {\n     let vnames = do vec::from_fn(vec::len(tys)) |i| {\n-        cx.parse_sess().interner.intern(@fmt!{\"__v%u\", i})\n+        cx.parse_sess().interner.intern(@fmt!(\"__v%u\", i))\n     };\n     let pats = do vec::from_fn(vec::len(tys)) |i| {\n         cx.binder_pat(tys[i].span, vnames[i])\n@@ -406,7 +406,7 @@ fn ser_ty(cx: ext_ctxt, tps: ser_tps_map,\n \n       ast::ty_bot => {\n         cx.span_err(\n-            ty.span, fmt!{\"Cannot serialize bottom type\"});\n+            ty.span, fmt!(\"Cannot serialize bottom type\"));\n         ~[]\n       }\n \n@@ -553,7 +553,7 @@ fn mk_ser_fn(cx: ext_ctxt, span: span, name: ast::ident,\n              ident: cx.ident_of(~\"__s\" + cx.str_of(tp.ident)),\n              id: cx.next_id()});\n \n-    debug!{\"tp_inputs = %?\", tp_inputs};\n+    debug!(\"tp_inputs = %?\", tp_inputs);\n \n \n     let ser_inputs: ~[ast::arg] =\n@@ -574,7 +574,7 @@ fn mk_ser_fn(cx: ext_ctxt, span: span, name: ast::ident,\n             tp.ident,\n             fn@(v: @ast::expr) -> ~[@ast::stmt] {\n                 let f = cx.var_ref(span, arg_ident);\n-                debug!{\"serializing type arg %s\", cx.str_of(arg_ident)};\n+                debug!(\"serializing type arg %s\", cx.str_of(arg_ident));\n                 ~[#ast[stmt]{$(f)($(v));}]\n             });\n     }\n@@ -765,7 +765,7 @@ fn mk_deser_fn(cx: ext_ctxt, span: span,\n              ident: cx.ident_of(~\"__d\" + cx.str_of(tp.ident)),\n              id: cx.next_id()});\n \n-    debug!{\"tp_inputs = %?\", tp_inputs};\n+    debug!(\"tp_inputs = %?\", tp_inputs);\n \n     let deser_inputs: ~[ast::arg] =\n         vec::append(~[{mode: ast::expl(ast::by_ref),"}, {"sha": "b16a8f11427ae1da76663ceb172bd1033630c1b7", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -267,21 +267,21 @@ fn get_mac_args(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n               match max {\n                 some(max) if ! (min <= elts_len && elts_len <= max) => {\n                   cx.span_fatal(sp,\n-                                fmt!{\"#%s takes between %u and %u arguments.\",\n-                                     name, min, max});\n+                                fmt!(\"#%s takes between %u and %u arguments.\",\n+                                     name, min, max));\n                 }\n                 none if ! (min <= elts_len) => {\n-                  cx.span_fatal(sp, fmt!{\"#%s needs at least %u arguments.\",\n-                                         name, min});\n+                  cx.span_fatal(sp, fmt!(\"#%s needs at least %u arguments.\",\n+                                         name, min));\n                 }\n                 _ => return elts /* we are good */\n               }\n           }\n         _ => {\n-            cx.span_fatal(sp, fmt!{\"#%s: malformed invocation\", name})\n+            cx.span_fatal(sp, fmt!(\"#%s: malformed invocation\", name))\n         }\n       },\n-      none => cx.span_fatal(sp, fmt!{\"#%s: missing arguments\", name})\n+      none => cx.span_fatal(sp, fmt!(\"#%s: missing arguments\", name))\n     }\n }\n "}, {"sha": "0b6c2ea5a9912af6ae2c7cb157a99588470e358e", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -31,12 +31,12 @@ fn expand_expr(exts: hashmap<~str, syntax_extension>, cx: ext_ctxt,\n                 match exts.find(*extname) {\n                   none => {\n                     cx.span_fatal(pth.span,\n-                                  fmt!{\"macro undefined: '%s'\", *extname})\n+                                  fmt!(\"macro undefined: '%s'\", *extname))\n                   }\n                   some(item_decorator(_)) => {\n                     cx.span_fatal(\n                         pth.span,\n-                        fmt!{\"%s can only be used as a decorator\", *extname});\n+                        fmt!(\"%s can only be used as a decorator\", *extname));\n                   }\n                   some(normal({expander: exp, span: exp_sp})) => {\n                     let expanded = exp(cx, mac.span, args, body);\n@@ -56,8 +56,8 @@ fn expand_expr(exts: hashmap<~str, syntax_extension>, cx: ext_ctxt,\n                   }\n                   some(expr_tt(_)) => {\n                     cx.span_fatal(pth.span,\n-                                  fmt!{\"this tt-style macro should be \\\n-                                        invoked '%s!{...}'\", *extname})\n+                                  fmt!(\"this tt-style macro should be \\\n+                                        invoked '%s!(...)'\", *extname))\n                   }\n                   some(item_tt(*)) => {\n                     cx.span_fatal(pth.span,\n@@ -76,14 +76,14 @@ fn expand_expr(exts: hashmap<~str, syntax_extension>, cx: ext_ctxt,\n                 match exts.find(*extname) {\n                   none => {\n                     cx.span_fatal(pth.span,\n-                                  fmt!{\"macro undefined: '%s'\", *extname})\n+                                  fmt!(\"macro undefined: '%s'\", *extname))\n                   }\n                   some(expr_tt({expander: exp, span: exp_sp})) => {\n                     let expanded = match exp(cx, mac.span, tts) {\n                       mr_expr(e) => e,\n                       _ => cx.span_fatal(\n-                          pth.span, fmt!{\"non-expr macro in expr pos: %s\",\n-                                         *extname})\n+                          pth.span, fmt!(\"non-expr macro in expr pos: %s\",\n+                                         *extname))\n                     };\n \n                     cx.bt_push(expanded_from({call_site: s,\n@@ -110,8 +110,8 @@ fn expand_expr(exts: hashmap<~str, syntax_extension>, cx: ext_ctxt,\n                   }\n                   _ => {\n                     cx.span_fatal(pth.span,\n-                                  fmt!{\"'%s' is not a tt-style macro\",\n-                                       *extname})\n+                                  fmt!(\"'%s' is not a tt-style macro\",\n+                                       *extname))\n                   }\n \n                 }\n@@ -202,7 +202,7 @@ fn expand_item_mac(exts: hashmap<~str, syntax_extension>,\n         match exts.find(*extname) {\n           none => {\n             cx.span_fatal(pth.span,\n-                          fmt!{\"macro undefined: '%s'\", *extname})\n+                          fmt!(\"macro undefined: '%s'\", *extname))\n           }\n           some(item_tt(expand)) => {\n             let expanded = expand.expander(cx, it.span, it.ident, tts);\n@@ -223,7 +223,7 @@ fn expand_item_mac(exts: hashmap<~str, syntax_extension>,\n             return maybe_it\n           }\n           _ => cx.span_fatal(it.span,\n-                            fmt!{\"%s is not a legal here\", *extname})\n+                            fmt!(\"%s is not a legal here\", *extname))\n         }\n       }\n       _ => cx.span_bug(it.span, ~\"invalid item macro invocation\")"}, {"sha": "6e459a551fe2c7ec5ebffc92b9886ea4ed91dad6", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -18,7 +18,7 @@ fn expand_syntax_ext(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n         expr_to_str(cx, args[0],\n                     ~\"first argument to #fmt must be a string literal.\");\n     let fmtspan = args[0].span;\n-    debug!{\"Format string:\"};\n+    debug!(\"Format string:\");\n     log(debug, fmt);\n     fn parse_fmt_err_(cx: ext_ctxt, sp: span, msg: ~str) -> ! {\n         cx.span_fatal(sp, msg);\n@@ -193,49 +193,49 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n     fn log_conv(c: conv) {\n         match c.param {\n           some(p) => { log(debug, ~\"param: \" + int::to_str(p, 10u)); }\n-          _ => debug!{\"param: none\"}\n+          _ => debug!(\"param: none\")\n         }\n         for c.flags.each |f| {\n             match f {\n-              flag_left_justify => debug!{\"flag: left justify\"},\n-              flag_left_zero_pad => debug!{\"flag: left zero pad\"},\n-              flag_space_for_sign => debug!{\"flag: left space pad\"},\n-              flag_sign_always => debug!{\"flag: sign always\"},\n-              flag_alternate => debug!{\"flag: alternate\"}\n+              flag_left_justify => debug!(\"flag: left justify\"),\n+              flag_left_zero_pad => debug!(\"flag: left zero pad\"),\n+              flag_space_for_sign => debug!(\"flag: left space pad\"),\n+              flag_sign_always => debug!(\"flag: sign always\"),\n+              flag_alternate => debug!(\"flag: alternate\")\n             }\n         }\n         match c.width {\n           count_is(i) => log(\n               debug, ~\"width: count is \" + int::to_str(i, 10u)),\n           count_is_param(i) => log(\n               debug, ~\"width: count is param \" + int::to_str(i, 10u)),\n-          count_is_next_param => debug!{\"width: count is next param\"},\n-          count_implied => debug!{\"width: count is implied\"}\n+          count_is_next_param => debug!(\"width: count is next param\"),\n+          count_implied => debug!(\"width: count is implied\")\n         }\n         match c.precision {\n           count_is(i) => log(\n               debug, ~\"prec: count is \" + int::to_str(i, 10u)),\n           count_is_param(i) => log(\n               debug, ~\"prec: count is param \" + int::to_str(i, 10u)),\n-          count_is_next_param => debug!{\"prec: count is next param\"},\n-          count_implied => debug!{\"prec: count is implied\"}\n+          count_is_next_param => debug!(\"prec: count is next param\"),\n+          count_implied => debug!(\"prec: count is implied\")\n         }\n         match c.ty {\n-          ty_bool => debug!{\"type: bool\"},\n-          ty_str => debug!{\"type: str\"},\n-          ty_char => debug!{\"type: char\"},\n+          ty_bool => debug!(\"type: bool\"),\n+          ty_str => debug!(\"type: str\"),\n+          ty_char => debug!(\"type: char\"),\n           ty_int(s) => match s {\n-            signed => debug!{\"type: signed\"},\n-            unsigned => debug!{\"type: unsigned\"}\n+            signed => debug!(\"type: signed\"),\n+            unsigned => debug!(\"type: unsigned\")\n           },\n-          ty_bits => debug!{\"type: bits\"},\n+          ty_bits => debug!(\"type: bits\"),\n           ty_hex(cs) => match cs {\n-            case_upper => debug!{\"type: uhex\"},\n-            case_lower => debug!{\"type: lhex\"},\n+            case_upper => debug!(\"type: uhex\"),\n+            case_lower => debug!(\"type: lhex\"),\n           },\n-          ty_octal => debug!{\"type: octal\"},\n-          ty_float => debug!{\"type: float\"},\n-          ty_poly => debug!{\"type: poly\"}\n+          ty_octal => debug!(\"type: octal\"),\n+          ty_float => debug!(\"type: float\"),\n+          ty_poly => debug!(\"type: poly\")\n         }\n     }\n     let fmt_sp = args[0].span;\n@@ -254,7 +254,7 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n                               ~\"not enough arguments to #fmt \" +\n                                   ~\"for the given format string\");\n             }\n-            debug!{\"Building conversion:\"};\n+            debug!(\"Building conversion:\");\n             log_conv(conv);\n             let arg_expr = args[n];\n             let c_expr = make_new_conv(cx, fmt_sp, conv, arg_expr);\n@@ -266,8 +266,8 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n \n     if expected_nargs < nargs {\n         cx.span_fatal\n-            (sp, fmt!{\"too many arguments to #fmt. found %u, expected %u\",\n-                           nargs, expected_nargs});\n+            (sp, fmt!(\"too many arguments to #fmt. found %u, expected %u\",\n+                           nargs, expected_nargs));\n     }\n \n     let arg_vec = mk_fixed_vec_e(cx, fmt_sp, piece_exprs);"}, {"sha": "60d1d666a7fdc490e16c86dd8eee8e947d8c8677", "filename": "src/libsyntax/ext/pipes/check.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -32,9 +32,9 @@ impl ext_ctxt: proto::visitor<(), (), ()>  {\n         if state.messages.len() == 0 {\n             self.span_warn(\n                 state.span, // use a real span!\n-                fmt!{\"state %s contains no messages, \\\n+                fmt!(\"state %s contains no messages, \\\n                       consider stepping to a terminal state instead\",\n-                      state.name})\n+                      state.name))\n         }\n     }\n \n@@ -48,20 +48,20 @@ impl ext_ctxt: proto::visitor<(), (), ()>  {\n                 // track span information.\n                 self.span_err(\n                     proto.get_state(next).span,\n-                    fmt!{\"message %s steps to undefined state, %s\",\n-                         name, next});\n+                    fmt!(\"message %s steps to undefined state, %s\",\n+                         name, next));\n             }\n             else {\n                 let next = proto.get_state(next);\n \n                 if next.ty_params.len() != next_tys.len() {\n                     self.span_err(\n                         next.span, // use a real span\n-                        fmt!{\"message %s target (%s) \\\n+                        fmt!(\"message %s target (%s) \\\n                               needs %u type parameters, but got %u\",\n                              name, next.name,\n                              next.ty_params.len(),\n-                             next_tys.len()});\n+                             next_tys.len()));\n                 }\n             }\n           }"}, {"sha": "a3dfdb6a76960b8b1a6cb1f63622ee570c9da4bc", "filename": "src/libsyntax/ext/pipes/liveness.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -32,7 +32,7 @@ import std::bitv::{bitv};\n import ast_builder::empty_span;\n \n fn analyze(proto: protocol, _cx: ext_ctxt) {\n-    debug!{\"initializing colive analysis\"};\n+    debug!(\"initializing colive analysis\");\n     let num_states = proto.num_states();\n     let colive = do (copy proto.states).map_to_vec |state| {\n         let bv = ~bitv(num_states, false);\n@@ -46,7 +46,7 @@ fn analyze(proto: protocol, _cx: ext_ctxt) {\n     let mut changed = true;\n     while changed {\n         changed = false;\n-        debug!{\"colive iteration %?\", i};\n+        debug!(\"colive iteration %?\", i);\n         for colive.eachi |i, this_colive| {\n             let this = proto.get_state_by_id(i);\n             for this_colive.ones |j| {\n@@ -59,7 +59,7 @@ fn analyze(proto: protocol, _cx: ext_ctxt) {\n         i += 1;\n     }\n \n-    debug!{\"colive analysis complete\"};\n+    debug!(\"colive analysis complete\");\n \n     // Determine if we're bounded\n     let mut self_live = ~[];\n@@ -72,20 +72,20 @@ fn analyze(proto: protocol, _cx: ext_ctxt) {\n     if self_live.len() > 0 {\n         let states = str::connect(self_live.map(|s| s.name), ~\" \");\n \n-        debug!{\"protocol %s is unbounded due to loops involving: %s\",\n-               proto.name, states};\n+        debug!(\"protocol %s is unbounded due to loops involving: %s\",\n+               proto.name, states);\n \n         // Someday this will be configurable with a warning\n         //cx.span_warn(empty_span(),\n-        //              fmt!{\"protocol %s is unbounded due to loops \\\n+        //              fmt!(\"protocol %s is unbounded due to loops \\\n         //                    involving these states: %s\",\n         //                   *proto.name,\n-        //                   states});\n+        //                   states));\n \n         proto.bounded = some(false);\n     }\n     else {\n-        debug!{\"protocol %s is bounded. yay!\", proto.name};\n+        debug!(\"protocol %s is bounded. yay!\", proto.name);\n         proto.bounded = some(true);\n     }\n }\n\\ No newline at end of file"}, {"sha": "315d02eadd38003521373fdf42ef309bfdfbfbc1", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -39,7 +39,7 @@ trait gen_init {\n \n impl message: gen_send {\n     fn gen_send(cx: ext_ctxt, try: bool) -> @ast::item {\n-        debug!{\"pipec: gen_send\"};\n+        debug!(\"pipec: gen_send\");\n         match self {\n           message(id, span, tys, this,\n                   some({state: next, tys: next_tys})) => {\n@@ -75,9 +75,9 @@ impl message: gen_send {\n                 body += fmt!(\"let %s = pipes::send_packet_buffered(\\\n                               ptr::addr_of(b.buffer.data.%s));\\n\",\n                              sp, next.name);\n-                body += fmt!{\"let %s = pipes::recv_packet_buffered(\\\n+                body += fmt!(\"let %s = pipes::recv_packet_buffered(\\\n                               ptr::addr_of(b.buffer.data.%s));\\n\",\n-                             rp, next.name};\n+                             rp, next.name);\n             }\n             else {\n                 let pat = match (this.dir, next.dir) {\n@@ -97,7 +97,7 @@ impl message: gen_send {\n                                       ~\", \"));\n \n             if !try {\n-                body += fmt!{\"pipes::send(pipe, message);\\n\"};\n+                body += fmt!(\"pipes::send(pipe, message);\\n\");\n                 // return the new channel\n                 body += ~\"c }\";\n             }\n@@ -127,7 +127,7 @@ impl message: gen_send {\n           }\n \n             message(id, span, tys, this, none) => {\n-                debug!{\"pipec: no next state\"};\n+                debug!(\"pipec: no next state\");\n                 let arg_names = tys.mapi(|i, _ty| (~\"x_\" + i.to_str()));\n \n                 let args_ast = (arg_names, tys).map(\n@@ -150,13 +150,13 @@ impl message: gen_send {\n                 };\n \n                 let mut body = ~\"{ \";\n-                body += fmt!{\"let message = %s::%s%s;\\n\",\n+                body += fmt!(\"let message = %s::%s%s;\\n\",\n                              this.proto.name,\n                              self.name(),\n-                             message_args};\n+                             message_args);\n \n                 if !try {\n-                    body += fmt!{\"pipes::send(pipe, message);\\n\"};\n+                    body += fmt!(\"pipes::send(pipe, message);\\n\");\n                     body += ~\" }\";\n                 } else {\n                     body += fmt!(\"if pipes::send(pipe, message) { \\\n@@ -192,7 +192,7 @@ impl message: gen_send {\n \n impl state: to_type_decls {\n     fn to_type_decls(cx: ext_ctxt) -> ~[@ast::item] {\n-        debug!{\"pipec: to_type_decls\"};\n+        debug!(\"pipec: to_type_decls\");\n         // This compiles into two different type declarations. Say the\n         // state is called ping. This will generate both `ping` and\n         // `ping_message`. The first contains data that the user cares\n@@ -238,7 +238,7 @@ impl state: to_type_decls {\n     }\n \n     fn to_endpoint_decls(cx: ext_ctxt, dir: direction) -> ~[@ast::item] {\n-        debug!{\"pipec: to_endpoint_decls\"};\n+        debug!(\"pipec: to_endpoint_decls\");\n         let dir = match dir {\n           send => (*self).dir,\n           recv => (*self).dir.reverse()\n@@ -293,7 +293,7 @@ impl protocol: gen_init {\n     fn gen_init(cx: ext_ctxt) -> @ast::item {\n         let ext_cx = cx;\n \n-        debug!{\"gen_init\"};\n+        debug!(\"gen_init\");\n         let start_state = self.states[0];\n \n         let body = if !self.is_bounded() {\n@@ -320,12 +320,12 @@ impl protocol: gen_init {\n             }\n         };\n \n-        cx.parse_item(fmt!{\"fn init%s() -> (client::%s, server::%s)\\\n+        cx.parse_item(fmt!(\"fn init%s() -> (client::%s, server::%s)\\\n                             { import pipes::has_buffer; %s }\",\n                            start_state.ty_params.to_source(cx),\n                            start_state.to_ty(cx).to_source(cx),\n                            start_state.to_ty(cx).to_source(cx),\n-                           body.to_source(cx)})\n+                           body.to_source(cx)))\n     }\n \n     fn gen_buffer_init(ext_cx: ext_ctxt) -> @ast::expr {\n@@ -337,7 +337,7 @@ impl protocol: gen_init {\n     }\n \n     fn gen_init_bounded(ext_cx: ext_ctxt) -> @ast::expr {\n-        debug!{\"gen_init_bounded\"};\n+        debug!(\"gen_init_bounded\");\n         let buffer_fields = self.gen_buffer_init(ext_cx);\n \n         let buffer = #ast {\n@@ -349,11 +349,11 @@ impl protocol: gen_init {\n             ext_cx.block(\n                 self.states.map_to_vec(\n                     |s| ext_cx.parse_stmt(\n-                        fmt!{\"data.%s.set_buffer(buffer)\",\n-                             s.name})),\n+                        fmt!(\"data.%s.set_buffer(buffer)\",\n+                             s.name))),\n                 ext_cx.parse_expr(\n-                    fmt!{\"ptr::addr_of(data.%s)\",\n-                         self.states[0].name})));\n+                    fmt!(\"ptr::addr_of(data.%s)\",\n+                         self.states[0].name))));\n \n         #ast {{\n             let buffer = $(buffer);\n@@ -490,7 +490,7 @@ impl ext_ctxt: ext_ctxt_parse_utils {\n         match res {\n           some(ast) => ast,\n           none => {\n-            error!{\"Parse error with ```\\n%s\\n```\", s};\n+            error!(\"Parse error with ```\\n%s\\n```\", s);\n             fail\n           }\n         }"}, {"sha": "eea4e434956ad4f346815aba3484846f91f71eb9", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -152,9 +152,9 @@ struct protocol_ {\n         let bounded = self.bounded.get();\n         bounded\n         //if bounded && self.has_ty_params() {\n-        //    debug!{\"protocol %s has is bounded, but type parameters\\\n+        //    debug!(\"protocol %s has is bounded, but type parameters\\\n         //            are not yet supported.\",\n-        //           *self.name};\n+        //           *self.name);\n         //    false\n         //}\n         //else { bounded }"}, {"sha": "de4d1975e24a60eaf6bc78aacb6d382214c3712c", "filename": "src/libsyntax/ext/qquote.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibsyntax%2Fext%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibsyntax%2Fext%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fqquote.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -205,7 +205,7 @@ fn finish<T: qq_helper>\n {\n     let cm = ecx.codemap();\n     let str = @codemap::span_to_snippet(body.span, cm);\n-    debug!{\"qquote--str==%?\", str};\n+    debug!(\"qquote--str==%?\", str);\n     let fname = codemap::mk_substr_filename(cm, body.span);\n     let node = parse_from_source_str\n         (f, fname, codemap::fss_internal(body.span), str,\n@@ -231,7 +231,7 @@ fn finish<T: qq_helper>\n     do str::chars_iter(*str) |ch| {\n         if (j < g_len && i == cx.gather[j].lo) {\n             assert ch == '$';\n-            let repl = fmt!{\"$%u \", j};\n+            let repl = fmt!(\"$%u \", j);\n             state = skip(str::char_len(repl));\n             str2 += repl;\n         }"}, {"sha": "7c37312a4333a28adc260431ac454844256d50ce", "filename": "src/libsyntax/ext/simplext.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsimplext.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -255,9 +255,9 @@ fn free_vars(b: bindings, e: @expr, it: fn(ident)) {\n \n fn wrong_occurs(cx: ext_ctxt, l: ident, l_c: uint, r: ident, r_c: uint)\n     -> ~str {\n-    fmt!{\"'%s' occurs %u times, but '%s' occurs %u times\",\n+    fmt!(\"'%s' occurs %u times, but '%s' occurs %u times\",\n          *cx.parse_sess().interner.get(l), l_c,\n-         *cx.parse_sess().interner.get(r), r_c}\n+         *cx.parse_sess().interner.get(r), r_c)\n }\n \n /* handle sequences (anywhere in the AST) of exprs, either real or ...ed */"}, {"sha": "b74a1165b793a4512c99578d9b80e7ca2c7e0cd8", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -13,23 +13,23 @@ export expand_include;\n export expand_include_str;\n export expand_include_bin;\n \n-/* line!{}: expands to the current line number */\n+/* line!(): expands to the current line number */\n fn expand_line(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n                _body: ast::mac_body) -> @ast::expr {\n     get_mac_args(cx, sp, arg, 0u, option::some(0u), ~\"line\");\n     let loc = codemap::lookup_char_pos(cx.codemap(), sp.lo);\n     return mk_uint(cx, sp, loc.line);\n }\n \n-/* col!{}: expands to the current column number */\n+/* col!(): expands to the current column number */\n fn expand_col(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n               _body: ast::mac_body) -> @ast::expr {\n     get_mac_args(cx, sp, arg, 0u, option::some(0u), ~\"col\");\n     let loc = codemap::lookup_char_pos(cx.codemap(), sp.lo);\n     return mk_uint(cx, sp, loc.col);\n }\n \n-/* file!{}: expands to the current filename */\n+/* file!(): expands to the current filename */\n /* The filemap (`loc.file`) contains a bunch more information we could spit\n  * out if we wanted. */\n fn expand_file(cx: ext_ctxt, sp: span, arg: ast::mac_arg,"}, {"sha": "c9a6928a72dc53747bd64a737f1b17abc889a45a", "filename": "src/libsyntax/ext/tt/earley_parser.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibsyntax%2Fext%2Ftt%2Fearley_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibsyntax%2Fext%2Ftt%2Fearley_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fearley_parser.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -274,15 +274,15 @@ fn parse(sess: parse_sess, cfg: ast::crate_cfg, rdr: reader, ms: ~[matcher])\n                 let nts = str::connect(vec::map(bb_eis, |ei| {\n                     match ei.elts[ei.idx].node {\n                       match_nonterminal(bind,name,_) => {\n-                        fmt!{\"%s ('%s')\", *sess.interner.get(name),\n-                             *sess.interner.get(bind)}\n+                        fmt!(\"%s ('%s')\", *sess.interner.get(name),\n+                             *sess.interner.get(bind))\n                       }\n                       _ => fail\n                     } }), ~\" or \");\n-                return error(sp, fmt!{\n+                return error(sp, fmt!(\n                     \"Local ambiguity: multiple parsing options: \\\n                      built-in NTs %s or %u other options.\",\n-                    nts, next_eis.len()});\n+                    nts, next_eis.len()));\n             } else if (bb_eis.len() == 0u && next_eis.len() == 0u) {\n                 return failure(sp, ~\"No rules expected the token \"\n                             + to_str(rdr.interner(), tok));"}, {"sha": "981e483f13df319f1d80d6f70c9dd693d82787fb", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -112,9 +112,9 @@ fn lockstep_iter_size(t: token_tree, r: tt_reader) -> lis {\n             lis_constraint(r_len, r_id) => {\n                 let l_n = *r.interner.get(l_id);\n                 let r_n = *r.interner.get(r_id);\n-                lis_contradiction(fmt!{\"Inconsistent lockstep iteration: \\\n+                lis_contradiction(fmt!(\"Inconsistent lockstep iteration: \\\n                                        '%s' has %u items, but '%s' has %u\",\n-                                        l_n, l_len, r_n, r_len})\n+                                        l_n, l_len, r_n, r_len))\n             }\n           }\n         }\n@@ -231,8 +231,8 @@ fn tt_next_token(&&r: tt_reader) -> {tok: token, sp: span} {\n               matched_seq(*) => {\n                 r.sp_diag.span_fatal(\n                     copy r.cur_span, /* blame the macro writer */\n-                    fmt!{\"variable '%s' is still repeating at this depth\",\n-                         *r.interner.get(ident)});\n+                    fmt!(\"variable '%s' is still repeating at this depth\",\n+                         *r.interner.get(ident)));\n               }\n             }\n           }"}, {"sha": "b80e472c04747d47958aee61d0fdeb6f6b67aaf2", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -118,7 +118,7 @@ fn consume_non_eol_whitespace(rdr: string_reader) {\n }\n \n fn push_blank_line_comment(rdr: string_reader, &comments: ~[cmnt]) {\n-    debug!{\">>> blank-line comment\"};\n+    debug!(\">>> blank-line comment\");\n     let v: ~[~str] = ~[];\n     vec::push(comments, {style: blank_line, lines: v, pos: rdr.chpos});\n }\n@@ -136,9 +136,9 @@ fn consume_whitespace_counting_blank_lines(rdr: string_reader,\n \n fn read_shebang_comment(rdr: string_reader, code_to_the_left: bool,\n                                                         &comments: ~[cmnt]) {\n-    debug!{\">>> shebang comment\"};\n+    debug!(\">>> shebang comment\");\n     let p = rdr.chpos;\n-    debug!{\"<<< shebang comment\"};\n+    debug!(\"<<< shebang comment\");\n     vec::push(comments, {\n         style: if code_to_the_left { trailing } else { isolated },\n         lines: ~[read_one_line_comment(rdr)],\n@@ -148,7 +148,7 @@ fn read_shebang_comment(rdr: string_reader, code_to_the_left: bool,\n \n fn read_line_comments(rdr: string_reader, code_to_the_left: bool,\n                                                         &comments: ~[cmnt]) {\n-    debug!{\">>> line comments\"};\n+    debug!(\">>> line comments\");\n     let p = rdr.chpos;\n     let mut lines: ~[~str] = ~[];\n     while rdr.curr == '/' && nextch(rdr) == '/' {\n@@ -160,7 +160,7 @@ fn read_line_comments(rdr: string_reader, code_to_the_left: bool,\n         vec::push(lines, line);\n         consume_non_eol_whitespace(rdr);\n     }\n-    debug!{\"<<< line comments\"};\n+    debug!(\"<<< line comments\");\n     if !lines.is_empty() {\n         vec::push(comments, {\n             style: if code_to_the_left { trailing } else { isolated },\n@@ -193,7 +193,7 @@ fn trim_whitespace_prefix_and_push_line(&lines: ~[~str],\n \n fn read_block_comment(rdr: string_reader, code_to_the_left: bool,\n                                                         &comments: ~[cmnt]) {\n-    debug!{\">>> block comment\"};\n+    debug!(\">>> block comment\");\n     let p = rdr.chpos;\n     let mut lines: ~[~str] = ~[];\n     let mut col: uint = rdr.col;\n@@ -215,7 +215,7 @@ fn read_block_comment(rdr: string_reader, code_to_the_left: bool,\n     let mut curr_line = ~\"/*\";\n     let mut level: int = 1;\n     while level > 0 {\n-        debug!{\"=== block comment level %d\", level};\n+        debug!(\"=== block comment level %d\", level);\n         if is_eof(rdr) {(rdr as reader).fatal(~\"unterminated block comment\");}\n         if rdr.curr == '\\n' {\n             trim_whitespace_prefix_and_push_line(lines, curr_line, col);\n@@ -246,7 +246,7 @@ fn read_block_comment(rdr: string_reader, code_to_the_left: bool,\n     if !is_eof(rdr) && rdr.curr != '\\n' && vec::len(lines) == 1u {\n         style = mixed;\n     }\n-    debug!{\"<<< block comment\"};\n+    debug!(\"<<< block comment\");\n     vec::push(comments, {style: style, lines: lines, pos: p});\n }\n \n@@ -258,15 +258,15 @@ fn peeking_at_comment(rdr: string_reader) -> bool {\n \n fn consume_comment(rdr: string_reader, code_to_the_left: bool,\n                    &comments: ~[cmnt]) {\n-    debug!{\">>> consume comment\"};\n+    debug!(\">>> consume comment\");\n     if rdr.curr == '/' && nextch(rdr) == '/' {\n         read_line_comments(rdr, code_to_the_left, comments);\n     } else if rdr.curr == '/' && nextch(rdr) == '*' {\n         read_block_comment(rdr, code_to_the_left, comments);\n     } else if rdr.curr == '#' && nextch(rdr) == '!' {\n         read_shebang_comment(rdr, code_to_the_left, comments);\n     } else { fail; }\n-    debug!{\"<<< consume comment\"};\n+    debug!(\"<<< consume comment\");\n }\n \n type lit = {lit: ~str, pos: uint};"}, {"sha": "afb9c91fc8d845ba960f7252855b617314538d41", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -115,7 +115,7 @@ impl parser: parser_common {\n     // A sanity check that the word we are asking for is a known keyword\n     fn require_keyword(word: ~str) {\n         if !self.keywords.contains_key_ref(&word) {\n-            self.bug(fmt!{\"unknown keyword: %s\", word});\n+            self.bug(fmt!(\"unknown keyword: %s\", word));\n         }\n     }\n "}, {"sha": "2eafa4a6f34aeed407e8982d11f4315707b4b209", "filename": "src/libsyntax/parse/eval.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibsyntax%2Fparse%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibsyntax%2Fparse%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Feval.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -20,9 +20,9 @@ fn eval_crate_directives(cx: ctx,\n fn eval_crate_directives_to_mod(cx: ctx, cdirs: ~[@ast::crate_directive],\n                                 prefix: ~str, suffix: option<~str>)\n     -> (ast::_mod, ~[ast::attribute]) {\n-    debug!{\"eval crate prefix: %s\", prefix};\n-    debug!{\"eval crate suffix: %s\",\n-           option::get_default(suffix, ~\"none\")};\n+    debug!(\"eval crate prefix: %s\", prefix);\n+    debug!(\"eval crate suffix: %s\",\n+           option::get_default(suffix, ~\"none\"));\n     let (cview_items, citems, cattrs)\n         = parse_companion_mod(cx, prefix, suffix);\n     let mut view_items: ~[@ast::view_item] = ~[];\n@@ -63,9 +63,9 @@ fn parse_companion_mod(cx: ctx, prefix: ~str, suffix: option<~str>)\n     }\n \n     let modpath = companion_file(prefix, suffix);\n-    debug!{\"looking for companion mod %s\", modpath};\n+    debug!(\"looking for companion mod %s\", modpath);\n     if file_exists(modpath) {\n-        debug!{\"found companion mod\"};\n+        debug!(\"found companion mod\");\n         let (p0, r0) = new_parser_etc_from_file(cx.sess, cx.cfg,\n                                                 modpath, SOURCE_FILE);\n         let inner_attrs = p0.parse_inner_attrs_and_next();"}, {"sha": "854633aa06ecab429580231b7dcec7175cbb8bdd", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -419,8 +419,8 @@ fn scan_number(c: char, rdr: string_reader) -> token::token {\n         }\n         let parsed = option::get(u64::from_str_radix(num_str, base as u64));\n \n-        debug!{\"lexing %s as an unsuffixed integer literal\",\n-               num_str};\n+        debug!(\"lexing %s as an unsuffixed integer literal\",\n+               num_str);\n         return token::LIT_INT_UNSUFFIXED(parsed as i64);\n     }\n }\n@@ -431,7 +431,7 @@ fn scan_numeric_escape(rdr: string_reader, n_hex_digits: uint) -> char {\n         let n = rdr.curr;\n         bump(rdr);\n         if !is_hex_digit(n) {\n-            rdr.fatal(fmt!{\"illegal numeric character escape: %d\", n as int});\n+            rdr.fatal(fmt!(\"illegal numeric character escape: %d\", n as int));\n         }\n         accum_int *= 16;\n         accum_int += hex_digit_val(n);\n@@ -578,7 +578,7 @@ fn next_token_inner(rdr: string_reader) -> token::token {\n               'u' => { c2 = scan_numeric_escape(rdr, 4u); }\n               'U' => { c2 = scan_numeric_escape(rdr, 8u); }\n               c2 => {\n-                rdr.fatal(fmt!{\"unknown character escape: %d\", c2 as int});\n+                rdr.fatal(fmt!(\"unknown character escape: %d\", c2 as int));\n               }\n             }\n         }\n@@ -593,8 +593,8 @@ fn next_token_inner(rdr: string_reader) -> token::token {\n         bump(rdr);\n         while rdr.curr != '\"' {\n             if is_eof(rdr) {\n-                rdr.fatal(fmt!{\"unterminated double quote string: %s\",\n-                               get_str_from(rdr, n)});\n+                rdr.fatal(fmt!(\"unterminated double quote string: %s\",\n+                               get_str_from(rdr, n)));\n             }\n \n             let ch = rdr.curr;\n@@ -621,7 +621,7 @@ fn next_token_inner(rdr: string_reader) -> token::token {\n                     str::push_char(accum_str, scan_numeric_escape(rdr, 8u));\n                   }\n                   c2 => {\n-                    rdr.fatal(fmt!{\"unknown string escape: %d\", c2 as int});\n+                    rdr.fatal(fmt!(\"unknown string escape: %d\", c2 as int));\n                   }\n                 }\n               }\n@@ -656,7 +656,7 @@ fn next_token_inner(rdr: string_reader) -> token::token {\n       '/' => { return binop(rdr, token::SLASH); }\n       '^' => { return binop(rdr, token::CARET); }\n       '%' => { return binop(rdr, token::PERCENT); }\n-      c => { rdr.fatal(fmt!{\"unknown start of token: %d\", c as int}); }\n+      c => { rdr.fatal(fmt!(\"unknown start of token: %d\", c as int)); }\n     }\n }\n "}, {"sha": "2aef7c99dbc9d772e52f75c287bbb306f472481f", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -126,7 +126,7 @@ enum view_item_parse_mode {\n /* The expr situation is not as complex as I thought it would be.\n The important thing is to make sure that lookahead doesn't balk\n at INTERPOLATED tokens */\n-macro_rules! maybe_whole_expr {\n+macro_rules! maybe_whole_expr (\n     {$p:expr} => { match copy $p.token {\n       INTERPOLATED(token::nt_expr(e)) => {\n         $p.bump();\n@@ -139,9 +139,9 @@ macro_rules! maybe_whole_expr {\n       }\n       _ => ()\n     }}\n-}\n+)\n \n-macro_rules! maybe_whole {\n+macro_rules! maybe_whole (\n     {$p:expr, $constructor:ident} => { match copy $p.token {\n       INTERPOLATED(token::$constructor(x)) => { $p.bump(); return x; }\n       _ => ()\n@@ -166,7 +166,7 @@ macro_rules! maybe_whole {\n       _ => ()\n     }}\n \n-}\n+)\n \n \n pure fn maybe_append(+lhs: ~[attribute], rhs: option<~[attribute]>)\n@@ -325,13 +325,13 @@ struct parser {\n             let self_ty = if is_static { static_sty } else { self_ty };\n \n             let hi = p.last_span.hi;\n-            debug!{\"parse_trait_methods(): trait method signature ends in \\\n+            debug!(\"parse_trait_methods(): trait method signature ends in \\\n                     `%s`\",\n-                   token_to_str(p.reader, p.token)};\n+                   token_to_str(p.reader, p.token));\n             match p.token {\n               token::SEMI => {\n                 p.bump();\n-                debug!{\"parse_trait_methods(): parsing required method\"};\n+                debug!(\"parse_trait_methods(): parsing required method\");\n                 // NB: at the moment, visibility annotations on required\n                 // methods are ignored; this could change.\n                 required({ident: ident, attrs: attrs,\n@@ -340,7 +340,7 @@ struct parser {\n                           id: p.get_id(), span: mk_sp(lo, hi)})\n               }\n               token::LBRACE => {\n-                debug!{\"parse_trait_methods(): parsing provided method\"};\n+                debug!(\"parse_trait_methods(): parsing provided method\");\n                 let (inner_attrs, body) =\n                     p.parse_inner_attrs_and_block(true);\n                 let attrs = vec::append(attrs, inner_attrs);\n@@ -441,7 +441,7 @@ struct parser {\n     }\n \n     fn parse_ty(colons_before_params: bool) -> @ty {\n-        maybe_whole!{self, nt_ty};\n+        maybe_whole!(self, nt_ty);\n \n         let lo = self.span.lo;\n \n@@ -708,7 +708,7 @@ struct parser {\n         parse_ident: fn(parser) -> ident,\n         parse_last_ident: fn(parser) -> ident) -> @path {\n \n-        maybe_whole!{self, nt_path};\n+        maybe_whole!(self, nt_path);\n         let lo = self.span.lo;\n         let global = self.eat(token::MOD_SEP);\n         let mut ids = ~[];\n@@ -735,9 +735,9 @@ struct parser {\n     }\n \n     fn parse_path_with_tps(colons: bool) -> @path {\n-        debug!{\"parse_path_with_tps(colons=%b)\", colons};\n+        debug!(\"parse_path_with_tps(colons=%b)\", colons);\n \n-        maybe_whole!{self, nt_path};\n+        maybe_whole!(self, nt_path);\n         let lo = self.span.lo;\n         let path = self.parse_path_without_tps();\n         if colons && !self.eat(token::MOD_SEP) {\n@@ -829,7 +829,7 @@ struct parser {\n     }\n \n     fn parse_bottom_expr() -> pexpr {\n-        maybe_whole_expr!{self};\n+        maybe_whole_expr!(self);\n         let lo = self.span.lo;\n         let mut hi = self.span.hi;\n \n@@ -1197,7 +1197,7 @@ struct parser {\n     }\n \n     fn parse_token_tree() -> token_tree {\n-        maybe_whole!{deref self, nt_tt};\n+        maybe_whole!(deref self, nt_tt);\n \n         fn parse_tt_tok(p: parser, delim_ok: bool) -> token_tree {\n             match p.token {\n@@ -1249,7 +1249,7 @@ struct parser {\n     fn parse_matchers() -> ~[matcher] {\n         // unification of matchers and token_trees would vastly improve\n         // the interpolation of matchers\n-        maybe_whole!{self, nt_matchers};\n+        maybe_whole!(self, nt_matchers);\n         let name_idx = @mut 0u;\n         return match self.token {\n           token::LBRACE | token::LPAREN | token::LBRACKET => {\n@@ -1598,9 +1598,9 @@ struct parser {\n             // There may be other types of expressions that can\n             // represent the callee in `for` and `do` expressions\n             // but they aren't represented by tests\n-            debug!{\"sugary call on %?\", e.node};\n+            debug!(\"sugary call on %?\", e.node);\n             self.span_fatal(\n-                lo, fmt!{\"`%s` must be followed by a block call\", keyword});\n+                lo, fmt!(\"`%s` must be followed by a block call\", keyword));\n           }\n         }\n     }\n@@ -1801,7 +1801,7 @@ struct parser {\n     }\n \n     fn parse_pat(refutable: bool) -> @pat {\n-        maybe_whole!{self, nt_pat};\n+        maybe_whole!(self, nt_pat);\n \n         let lo = self.span.lo;\n         let mut hi = self.span.hi;\n@@ -2077,7 +2077,7 @@ struct parser {\n     }\n \n     fn parse_stmt(+first_item_attrs: ~[attribute]) -> @stmt {\n-        maybe_whole!{self, nt_stmt};\n+        maybe_whole!(self, nt_stmt);\n \n         fn check_expected_item(p: parser, current_attrs: ~[attribute]) {\n             // If we have attributes then we should have an item\n@@ -2140,7 +2140,7 @@ struct parser {\n     fn parse_inner_attrs_and_block(parse_attrs: bool)\n         -> (~[attribute], blk) {\n \n-        maybe_whole!{pair_empty self, nt_block};\n+        maybe_whole!(pair_empty self, nt_block);\n \n         fn maybe_parse_inner_attrs_and_next(p: parser, parse_attrs: bool) ->\n             {inner: ~[attribute], next: ~[attribute]} {\n@@ -2812,7 +2812,7 @@ struct parser {\n                            token_to_str(self.reader, self.token) + ~\"`\");\n               }\n             }\n-            debug!{\"parse_mod_items: attrs=%?\", attrs};\n+            debug!(\"parse_mod_items: attrs=%?\", attrs);\n         }\n \n         if first && attrs_remaining.len() > 0u {\n@@ -3139,7 +3139,7 @@ struct parser {\n \n     fn parse_item_or_view_item(+attrs: ~[attribute], items_allowed: bool)\n                             -> item_or_view_item {\n-        maybe_whole!{iovi self,nt_item};\n+        maybe_whole!(iovi self,nt_item);\n         let lo = self.span.lo;\n \n         let visibility;\n@@ -3303,7 +3303,7 @@ struct parser {\n         let lo = self.span.lo;\n         let first_ident = self.parse_ident();\n         let mut path = ~[first_ident];\n-        debug!{\"parsed view_path: %s\", *self.id_to_str(first_ident)};\n+        debug!(\"parsed view_path: %s\", *self.id_to_str(first_ident));\n         match self.token {\n           token::EQ => {\n             // x = foo::bar"}, {"sha": "fbca90b5f4982a6cb5060e34bb897a1f43e413bf", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -63,7 +63,7 @@ enum token { STRING(@~str, int), BREAK(break_t), BEGIN(begin_t), END, EOF, }\n \n fn tok_str(++t: token) -> ~str {\n     match t {\n-      STRING(s, len) => return fmt!{\"STR(%s,%d)\", *s, len},\n+      STRING(s, len) => return fmt!(\"STR(%s,%d)\", *s, len),\n       BREAK(_) => return ~\"BREAK\",\n       BEGIN(_) => return ~\"BEGIN\",\n       END => return ~\"END\",\n@@ -81,7 +81,7 @@ fn buf_str(toks: ~[mut token], szs: ~[mut int], left: uint, right: uint,\n     while i != right && L != 0u {\n         L -= 1u;\n         if i != left { s += ~\", \"; }\n-        s += fmt!{\"%d=%s\", szs[i], tok_str(toks[i])};\n+        s += fmt!(\"%d=%s\", szs[i], tok_str(toks[i]));\n         i += 1u;\n         i %= n;\n     }\n@@ -99,7 +99,7 @@ fn mk_printer(out: io::Writer, linewidth: uint) -> printer {\n     // Yes 3, it makes the ring buffers big enough to never\n     // fall behind.\n     let n: uint = 3u * linewidth;\n-    debug!{\"mk_printer %u\", linewidth};\n+    debug!(\"mk_printer %u\", linewidth);\n     let token: ~[mut token] = vec::to_mut(vec::from_elem(n, EOF));\n     let size: ~[mut int] = vec::to_mut(vec::from_elem(n, 0));\n     let scan_stack: ~[mut uint] = vec::to_mut(vec::from_elem(n, 0u));\n@@ -237,7 +237,7 @@ impl printer {\n     // be very careful with this!\n     fn replace_last_token(t: token) { self.token[self.right] = t; }\n     fn pretty_print(t: token) {\n-        debug!{\"pp ~[%u,%u]\", self.left, self.right};\n+        debug!(\"pp ~[%u,%u]\", self.left, self.right);\n         match t {\n           EOF => {\n             if !self.scan_stack_empty {\n@@ -254,18 +254,18 @@ impl printer {\n                 self.left = 0u;\n                 self.right = 0u;\n             } else { self.advance_right(); }\n-            debug!{\"pp BEGIN(%d)/buffer ~[%u,%u]\",\n-                   b.offset, self.left, self.right};\n+            debug!(\"pp BEGIN(%d)/buffer ~[%u,%u]\",\n+                   b.offset, self.left, self.right);\n             self.token[self.right] = t;\n             self.size[self.right] = -self.right_total;\n             self.scan_push(self.right);\n           }\n           END => {\n             if self.scan_stack_empty {\n-                debug!{\"pp END/print ~[%u,%u]\", self.left, self.right};\n+                debug!(\"pp END/print ~[%u,%u]\", self.left, self.right);\n                 self.print(t, 0);\n             } else {\n-                debug!{\"pp END/buffer ~[%u,%u]\", self.left, self.right};\n+                debug!(\"pp END/buffer ~[%u,%u]\", self.left, self.right);\n                 self.advance_right();\n                 self.token[self.right] = t;\n                 self.size[self.right] = -1;\n@@ -279,8 +279,8 @@ impl printer {\n                 self.left = 0u;\n                 self.right = 0u;\n             } else { self.advance_right(); }\n-            debug!{\"pp BREAK(%d)/buffer ~[%u,%u]\",\n-                   b.offset, self.left, self.right};\n+            debug!(\"pp BREAK(%d)/buffer ~[%u,%u]\",\n+                   b.offset, self.left, self.right);\n             self.check_stack(0);\n             self.scan_push(self.right);\n             self.token[self.right] = t;\n@@ -289,12 +289,12 @@ impl printer {\n           }\n           STRING(s, len) => {\n             if self.scan_stack_empty {\n-                debug!{\"pp STRING('%s')/print ~[%u,%u]\",\n-                       *s, self.left, self.right};\n+                debug!(\"pp STRING('%s')/print ~[%u,%u]\",\n+                       *s, self.left, self.right);\n                 self.print(t, len);\n             } else {\n-                debug!{\"pp STRING('%s')/buffer ~[%u,%u]\",\n-                       *s, self.left, self.right};\n+                debug!(\"pp STRING('%s')/buffer ~[%u,%u]\",\n+                       *s, self.left, self.right);\n                 self.advance_right();\n                 self.token[self.right] = t;\n                 self.size[self.right] = len;\n@@ -305,14 +305,14 @@ impl printer {\n         }\n     }\n     fn check_stream() {\n-        debug!{\"check_stream ~[%u, %u] with left_total=%d, right_total=%d\",\n-               self.left, self.right, self.left_total, self.right_total};\n+        debug!(\"check_stream ~[%u, %u] with left_total=%d, right_total=%d\",\n+               self.left, self.right, self.left_total, self.right_total);\n         if self.right_total - self.left_total > self.space {\n-            debug!{\"scan window is %d, longer than space on line (%d)\",\n-                   self.right_total - self.left_total, self.space};\n+            debug!(\"scan window is %d, longer than space on line (%d)\",\n+                   self.right_total - self.left_total, self.space);\n             if !self.scan_stack_empty {\n                 if self.left == self.scan_stack[self.bottom] {\n-                    debug!{\"setting %u to infinity and popping\", self.left};\n+                    debug!(\"setting %u to infinity and popping\", self.left);\n                     self.size[self.scan_pop_bottom()] = size_infinity;\n                 }\n             }\n@@ -321,7 +321,7 @@ impl printer {\n         }\n     }\n     fn scan_push(x: uint) {\n-        debug!{\"scan_push %u\", x};\n+        debug!(\"scan_push %u\", x);\n         if self.scan_stack_empty {\n             self.scan_stack_empty = false;\n         } else {\n@@ -357,8 +357,8 @@ impl printer {\n         assert (self.right != self.left);\n     }\n     fn advance_left(++x: token, L: int) {\n-        debug!{\"advnce_left ~[%u,%u], sizeof(%u)=%d\", self.left, self.right,\n-               self.left, L};\n+        debug!(\"advnce_left ~[%u,%u], sizeof(%u)=%d\", self.left, self.right,\n+               self.left, L);\n         if L >= 0 {\n             self.print(x, L);\n             match x {\n@@ -398,13 +398,13 @@ impl printer {\n         }\n     }\n     fn print_newline(amount: int) {\n-        debug!{\"NEWLINE %d\", amount};\n+        debug!(\"NEWLINE %d\", amount);\n         self.out.write_str(~\"\\n\");\n         self.pending_indentation = 0;\n         self.indent(amount);\n     }\n     fn indent(amount: int) {\n-        debug!{\"INDENT %d\", amount};\n+        debug!(\"INDENT %d\", amount);\n         self.pending_indentation += amount;\n     }\n     fn get_top() -> print_stack_elt {\n@@ -423,58 +423,58 @@ impl printer {\n         self.out.write_str(s);\n     }\n     fn print(x: token, L: int) {\n-        debug!{\"print %s %d (remaining line space=%d)\", tok_str(x), L,\n-               self.space};\n+        debug!(\"print %s %d (remaining line space=%d)\", tok_str(x), L,\n+               self.space);\n         log(debug, buf_str(self.token, self.size, self.left, self.right, 6u));\n         match x {\n           BEGIN(b) => {\n             if L > self.space {\n                 let col = self.margin - self.space + b.offset;\n-                debug!{\"print BEGIN -> push broken block at col %d\", col};\n+                debug!(\"print BEGIN -> push broken block at col %d\", col);\n                 self.print_stack.push({offset: col,\n                                        pbreak: broken(b.breaks)});\n             } else {\n-                debug!{\"print BEGIN -> push fitting block\"};\n+                debug!(\"print BEGIN -> push fitting block\");\n                 self.print_stack.push({offset: 0,\n                                        pbreak: fits});\n             }\n           }\n           END => {\n-            debug!{\"print END -> pop END\"};\n+            debug!(\"print END -> pop END\");\n             assert (self.print_stack.len() != 0u);\n             self.print_stack.pop();\n           }\n           BREAK(b) => {\n             let top = self.get_top();\n             match top.pbreak {\n               fits => {\n-                debug!{\"print BREAK(%d) in fitting block\", b.blank_space};\n+                debug!(\"print BREAK(%d) in fitting block\", b.blank_space);\n                 self.space -= b.blank_space;\n                 self.indent(b.blank_space);\n               }\n               broken(consistent) => {\n-                debug!{\"print BREAK(%d+%d) in consistent block\",\n-                       top.offset, b.offset};\n+                debug!(\"print BREAK(%d+%d) in consistent block\",\n+                       top.offset, b.offset);\n                 self.print_newline(top.offset + b.offset);\n                 self.space = self.margin - (top.offset + b.offset);\n               }\n               broken(inconsistent) => {\n                 if L > self.space {\n-                    debug!{\"print BREAK(%d+%d) w/ newline in inconsistent\",\n-                           top.offset, b.offset};\n+                    debug!(\"print BREAK(%d+%d) w/ newline in inconsistent\",\n+                           top.offset, b.offset);\n                     self.print_newline(top.offset + b.offset);\n                     self.space = self.margin - (top.offset + b.offset);\n                 } else {\n-                    debug!{\"print BREAK(%d) w/o newline in inconsistent\",\n-                           b.blank_space};\n+                    debug!(\"print BREAK(%d) w/o newline in inconsistent\",\n+                           b.blank_space);\n                     self.indent(b.blank_space);\n                     self.space -= b.blank_space;\n                 }\n               }\n             }\n           }\n           STRING(s, len) => {\n-            debug!{\"print STRING(%s)\", *s};\n+            debug!(\"print STRING(%s)\", *s);\n             assert (L == len);\n             // assert L <= space;\n             self.space -= len;"}, {"sha": "8320d438b4e631557c7ae6a36ad430260c1ac367", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -937,14 +937,14 @@ fn print_mac(s: ps, m: ast::mac) {\n         bclose(s, m.span);\n       }\n       ast::mac_ellipsis => word(s.s, ~\"...\"),\n-      ast::mac_var(v) => word(s.s, fmt!{\"$%u\", v}),\n+      ast::mac_var(v) => word(s.s, fmt!(\"$%u\", v)),\n       _ => { /* fixme */ }\n     }\n }\n \n fn print_vstore(s: ps, t: ast::vstore) {\n     match t {\n-      ast::vstore_fixed(some(i)) => word(s.s, fmt!{\"%u\", i}),\n+      ast::vstore_fixed(some(i)) => word(s.s, fmt!(\"%u\", i)),\n       ast::vstore_fixed(none) => word(s.s, ~\"_\"),\n       ast::vstore_uniq => word(s.s, ~\"~\"),\n       ast::vstore_box => word(s.s, ~\"@\"),"}, {"sha": "33fce8bc72c7ac8f8d5cfba84a9c8d9d42128b29", "filename": "src/rustc/back/link.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Flink.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -343,7 +343,7 @@ fn build_link_meta(sess: session, c: ast::crate, output: ~str,\n                               metas: provided_metas,\n                               dep_hashes: ~[~str]) -> ~str {\n         fn len_and_str(s: ~str) -> ~str {\n-            return fmt!{\"%u_%s\", str::len(s), s};\n+            return fmt!(\"%u_%s\", str::len(s), s);\n         }\n \n         fn len_and_str_lit(l: ast::lit) -> ~str {\n@@ -379,8 +379,8 @@ fn build_link_meta(sess: session, c: ast::crate, output: ~str,\n \n     fn warn_missing(sess: session, name: ~str, default: ~str) {\n         if !sess.building_library { return; }\n-        sess.warn(fmt!{\"missing crate link meta `%s`, using `%s` as default\",\n-                       name, default});\n+        sess.warn(fmt!(\"missing crate link meta `%s`, using `%s` as default\",\n+                       name, default));\n     }\n \n     fn crate_meta_name(sess: session, _crate: ast::crate,\n@@ -393,8 +393,8 @@ fn build_link_meta(sess: session, c: ast::crate, output: ~str,\n                         let mut os =\n                             str::split_char(path::basename(output), '.');\n                         if (vec::len(os) < 2u) {\n-                            sess.fatal(fmt!{\"output file name `%s` doesn't\\\n-                              appear to have an extension\", output});\n+                            sess.fatal(fmt!(\"output file name `%s` doesn't\\\n+                              appear to have an extension\", output));\n                         }\n                         vec::pop(os);\n                         str::connect(os, ~\".\")\n@@ -505,7 +505,7 @@ fn mangle(sess: session, ss: path) -> ~str {\n     for ss.each |s| {\n         match s { path_name(s) | path_mod(s) => {\n           let sani = sanitize(sess.str_of(s));\n-          n += fmt!{\"%u%s\", str::len(sani), sani};\n+          n += fmt!(\"%u%s\", str::len(sani), sani);\n         } }\n     }\n     n += ~\"E\"; // End name-sequence.\n@@ -581,12 +581,12 @@ fn link_binary(sess: session,\n \n     let output = if sess.building_library {\n         let long_libname =\n-            os::dll_filename(fmt!{\"%s-%s-%s\",\n-                                  lm.name, lm.extras_hash, lm.vers});\n-        debug!{\"link_meta.name:  %s\", lm.name};\n-        debug!{\"long_libname: %s\", long_libname};\n-        debug!{\"out_filename: %s\", out_filename};\n-        debug!{\"dirname(out_filename): %s\", path::dirname(out_filename)};\n+            os::dll_filename(fmt!(\"%s-%s-%s\",\n+                                  lm.name, lm.extras_hash, lm.vers));\n+        debug!(\"link_meta.name:  %s\", lm.name);\n+        debug!(\"long_libname: %s\", long_libname);\n+        debug!(\"out_filename: %s\", out_filename);\n+        debug!(\"dirname(out_filename): %s\", path::dirname(out_filename));\n \n         path::connect(path::dirname(out_filename), long_libname)\n     } else { out_filename };\n@@ -703,14 +703,14 @@ fn link_binary(sess: session,\n     // extern libraries might live, based on the addl_lib_search_paths\n     vec::push_all(cc_args, rpath::get_rpath_flags(sess, output));\n \n-    debug!{\"%s link args: %s\", cc_prog, str::connect(cc_args, ~\" \")};\n+    debug!(\"%s link args: %s\", cc_prog, str::connect(cc_args, ~\" \"));\n     // We run 'cc' here\n     let prog = run::program_output(cc_prog, cc_args);\n     if 0 != prog.status {\n-        sess.err(fmt!{\"linking with `%s` failed with code %d\",\n-                      cc_prog, prog.status});\n-        sess.note(fmt!{\"%s arguments: %s\",\n-                       cc_prog, str::connect(cc_args, ~\" \")});\n+        sess.err(fmt!(\"linking with `%s` failed with code %d\",\n+                      cc_prog, prog.status));\n+        sess.note(fmt!(\"%s arguments: %s\",\n+                       cc_prog, str::connect(cc_args, ~\" \")));\n         sess.note(prog.err + prog.out);\n         sess.abort_if_errors();\n     }\n@@ -723,8 +723,8 @@ fn link_binary(sess: session,\n     // Remove the temporary object file if we aren't saving temps\n     if !sess.opts.save_temps {\n         if ! os::remove_file(obj_filename) {\n-            sess.warn(fmt!{\"failed to delete object file `%s`\",\n-                           obj_filename});\n+            sess.warn(fmt!(\"failed to delete object file `%s`\",\n+                           obj_filename));\n         }\n     }\n }"}, {"sha": "b6f6d17e444031ce5df6624ef35d257477bfc922", "filename": "src/rustc/back/rpath.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Frpath.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -21,7 +21,7 @@ fn get_rpath_flags(sess: session::session, out_filename: ~str) -> ~[~str] {\n         return ~[];\n     }\n \n-    debug!{\"preparing the RPATH!\"};\n+    debug!(\"preparing the RPATH!\");\n \n     let cwd = os::getcwd();\n     let sysroot = sess.filesearch.sysroot();\n@@ -45,20 +45,20 @@ fn get_sysroot_absolute_rt_lib(sess: session::session) -> path::Path {\n }\n \n fn rpaths_to_flags(rpaths: ~[~str]) -> ~[~str] {\n-    vec::map(rpaths, |rpath| fmt!{\"-Wl,-rpath,%s\",rpath} )\n+    vec::map(rpaths, |rpath| fmt!(\"-Wl,-rpath,%s\",rpath) )\n }\n \n fn get_rpaths(os: session::os, cwd: path::Path, sysroot: path::Path,\n               output: path::Path, libs: ~[path::Path],\n               target_triple: ~str) -> ~[~str] {\n-    debug!{\"cwd: %s\", cwd};\n-    debug!{\"sysroot: %s\", sysroot};\n-    debug!{\"output: %s\", output};\n-    debug!{\"libs:\"};\n+    debug!(\"cwd: %s\", cwd);\n+    debug!(\"sysroot: %s\", sysroot);\n+    debug!(\"output: %s\", output);\n+    debug!(\"libs:\");\n     for libs.each |libpath| {\n-        debug!{\"    %s\", libpath};\n+        debug!(\"    %s\", libpath);\n     }\n-    debug!{\"target_triple: %s\", target_triple};\n+    debug!(\"target_triple: %s\", target_triple);\n \n     // Use relative paths to the libraries. Binaries can be moved\n     // as long as they maintain the relative relationship to the\n@@ -73,9 +73,9 @@ fn get_rpaths(os: session::os, cwd: path::Path, sysroot: path::Path,\n     let fallback_rpaths = ~[get_install_prefix_rpath(cwd, target_triple)];\n \n     fn log_rpaths(desc: ~str, rpaths: ~[~str]) {\n-        debug!{\"%s rpaths:\", desc};\n+        debug!(\"%s rpaths:\", desc);\n         for rpaths.each |rpath| {\n-            debug!{\"    %s\", rpath};\n+            debug!(\"    %s\", rpath);\n         }\n     }\n \n@@ -124,8 +124,8 @@ fn get_rpath_relative_to_output(os: session::os,\n fn get_relative_to(abs1: path::Path, abs2: path::Path) -> path::Path {\n     assert path::path_is_absolute(abs1);\n     assert path::path_is_absolute(abs2);\n-    debug!{\"finding relative path from %s to %s\",\n-           abs1, abs2};\n+    debug!(\"finding relative path from %s to %s\",\n+           abs1, abs2);\n     let normal1 = path::normalize(abs1);\n     let normal2 = path::normalize(abs2);\n     let split1 = path::split(normal1);\n@@ -171,7 +171,7 @@ fn get_absolute(cwd: path::Path, lib: path::Path) -> path::Path {\n }\n \n fn get_install_prefix_rpath(cwd: path::Path, target_triple: ~str) -> ~str {\n-    let install_prefix = env!{\"CFG_PREFIX\"};\n+    let install_prefix = env!(\"CFG_PREFIX\");\n \n     if install_prefix == ~\"\" {\n         fail ~\"rustc compiled without CFG_PREFIX environment variable\";\n@@ -222,7 +222,7 @@ mod test {\n     #[test]\n     fn test_prefix_rpath() {\n         let res = get_install_prefix_rpath(~\"/usr/lib\", ~\"triple\");\n-        let d = path::connect(env!{\"CFG_PREFIX\"}, ~\"/lib/rustc/triple/lib\");\n+        let d = path::connect(env!(\"CFG_PREFIX\"), ~\"/lib/rustc/triple/lib\");\n         assert str::ends_with(res, d);\n     }\n "}, {"sha": "97358154e99b8409f335ccf8a6f314196194045f", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -116,8 +116,8 @@ fn time<T>(do_it: bool, what: ~str, thunk: fn() -> T) -> T {\n     let start = std::time::precise_time_s();\n     let rv = thunk();\n     let end = std::time::precise_time_s();\n-    io::stdout().write_str(fmt!{\"time: %3.3f s\\t%s\\n\",\n-                                end - start, what});\n+    io::stdout().write_str(fmt!(\"time: %3.3f s\\t%s\\n\",\n+                                end - start, what));\n     return rv;\n }\n \n@@ -403,7 +403,7 @@ fn host_triple() -> ~str {\n     // FIXME (#2400): Instead of grabbing the host triple we really should\n     // be grabbing (at compile time) the target triple that this rustc is\n     // built with and calling that (at runtime) the host triple.\n-    let ht = env!{\"CFG_HOST_TRIPLE\"};\n+    let ht = env!(\"CFG_HOST_TRIPLE\");\n     return if ht != ~\"\" {\n             ht\n         } else {\n@@ -438,8 +438,8 @@ fn build_session_options(matches: getopts::matches,\n             let lint_name = str::replace(lint_name, ~\"-\", ~\"_\");\n             match lint_dict.find(lint_name) {\n               none => {\n-                early_error(demitter, fmt!{\"unknown %s flag: %s\",\n-                                           level_name, lint_name});\n+                early_error(demitter, fmt!(\"unknown %s flag: %s\",\n+                                           level_name, lint_name));\n               }\n               some(lint) => {\n                 vec::push(lint_opts, (lint.lint, level));\n@@ -458,7 +458,7 @@ fn build_session_options(matches: getopts::matches,\n             if name == debug_flag { this_bit = bit; break; }\n         }\n         if this_bit == 0u {\n-            early_error(demitter, fmt!{\"unknown debug flag: %s\", debug_flag})\n+            early_error(demitter, fmt!(\"unknown debug flag: %s\", debug_flag))\n         }\n         debugging_opts |= this_bit;\n     }"}, {"sha": "0770a132a1d3d7aa6b5a086d17862546bc65973a", "filename": "src/rustc/driver/rustc.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Frustc.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -21,14 +21,14 @@ import rustc::middle::lint;\n \n fn version(argv0: ~str) {\n     let mut vers = ~\"unknown version\";\n-    let env_vers = env!{\"CFG_VERSION\"};\n+    let env_vers = env!(\"CFG_VERSION\");\n     if str::len(env_vers) != 0u { vers = env_vers; }\n-    io::println(fmt!{\"%s %s\", argv0, vers});\n-    io::println(fmt!{\"host: %s\", host_triple()});\n+    io::println(fmt!(\"%s %s\", argv0, vers));\n+    io::println(fmt!(\"host: %s\", host_triple()));\n }\n \n fn usage(argv0: ~str) {\n-    io::println(fmt!{\"Usage: %s [options] <input>\\n\", argv0} +\n+    io::println(fmt!(\"Usage: %s [options] <input>\\n\", argv0) +\n                  ~\"\n Options:\n \n@@ -85,31 +85,31 @@ fn describe_warnings() {\n     fn padded(max: uint, s: ~str) -> ~str {\n         str::from_bytes(vec::from_elem(max - s.len(), ' ' as u8)) + s\n     }\n-    io::println(fmt!{\"\\nAvailable lint checks:\\n\"});\n-    io::println(fmt!{\"    %s  %7.7s  %s\",\n-                     padded(max_key, ~\"name\"), ~\"default\", ~\"meaning\"});\n-    io::println(fmt!{\"    %s  %7.7s  %s\\n\",\n-                     padded(max_key, ~\"----\"), ~\"-------\", ~\"-------\"});\n+    io::println(fmt!(\"\\nAvailable lint checks:\\n\"));\n+    io::println(fmt!(\"    %s  %7.7s  %s\",\n+                     padded(max_key, ~\"name\"), ~\"default\", ~\"meaning\"));\n+    io::println(fmt!(\"    %s  %7.7s  %s\\n\",\n+                     padded(max_key, ~\"----\"), ~\"-------\", ~\"-------\"));\n     for lint_dict.each |k, v| {\n         let k = str::replace(k, ~\"_\", ~\"-\");\n-        io::println(fmt!{\"    %s  %7.7s  %s\",\n+        io::println(fmt!(\"    %s  %7.7s  %s\",\n                          padded(max_key, k),\n                          match v.default {\n                              lint::allow => ~\"allow\",\n                              lint::warn => ~\"warn\",\n                              lint::deny => ~\"deny\",\n                              lint::forbid => ~\"forbid\"\n                          },\n-                         v.desc});\n+                         v.desc));\n     }\n     io::println(~\"\");\n }\n \n fn describe_debug_flags() {\n-    io::println(fmt!{\"\\nAvailable debug options:\\n\"});\n+    io::println(fmt!(\"\\nAvailable debug options:\\n\"));\n     for session::debugging_opts_map().each |pair| {\n         let (name, desc, _) = pair;\n-        io::println(fmt!{\"    -Z%-20s -- %s\", name, desc});\n+        io::println(fmt!(\"    -Z%-20s -- %s\", name, desc));\n     }\n }\n "}, {"sha": "28d0af2aec2c6c92a3589bfca15520e02553c8c4", "filename": "src/rustc/front/intrinsic_inject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Ffront%2Fintrinsic_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Ffront%2Fintrinsic_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Fintrinsic_inject.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -7,7 +7,7 @@ export inject_intrinsic;\n fn inject_intrinsic(sess: session,\n                     crate: @ast::crate) -> @ast::crate {\n \n-    let intrinsic_module = @include_str!{\"intrinsic.rs\"};\n+    let intrinsic_module = @include_str!(\"intrinsic.rs\");\n \n     let item = parse::parse_item_from_source_str(~\"<intrinsic>\",\n                                                  intrinsic_module,"}, {"sha": "cba7e89dcbb1210bd6f8e30014a295ff57e8df91", "filename": "src/rustc/front/test.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Ftest.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -100,8 +100,8 @@ fn fold_item(cx: test_ctxt, &&i: @ast::item, fld: fold::ast_fold) ->\n    option<@ast::item> {\n \n     vec::push(cx.path, i.ident);\n-    debug!{\"current path: %s\",\n-           ast_util::path_name_i(cx.path, cx.sess.parse_sess.interner)};\n+    debug!(\"current path: %s\",\n+           ast_util::path_name_i(cx.path, cx.sess.parse_sess.interner));\n \n     if is_test_fn(i) {\n         match i.node {\n@@ -111,12 +111,12 @@ fn fold_item(cx: test_ctxt, &&i: @ast::item, fld: fold::ast_fold) ->\n                 ~\"unsafe functions cannot be used for tests\");\n           }\n           _ => {\n-            debug!{\"this is a test function\"};\n+            debug!(\"this is a test function\");\n             let test = {span: i.span,\n                         path: cx.path, ignore: is_ignored(cx, i),\n                         should_fail: should_fail(i)};\n             cx.testfns.push(test);\n-            debug!{\"have %u test functions\", cx.testfns.len()};\n+            debug!(\"have %u test functions\", cx.testfns.len());\n           }\n         }\n     }\n@@ -203,8 +203,8 @@ fn mk_test_module(cx: test_ctxt) -> @ast::item {\n          vis: ast::public,\n          span: dummy_sp()};\n \n-    debug!{\"Synthetic test module:\\n%s\\n\",\n-           pprust::item_to_str(@item, cx.sess.intr())};\n+    debug!(\"Synthetic test module:\\n%s\\n\",\n+           pprust::item_to_str(@item, cx.sess.intr()));\n \n     return @item;\n }\n@@ -280,7 +280,7 @@ fn mk_test_desc_vec_ty(cx: test_ctxt) -> @ast::ty {\n }\n \n fn mk_test_desc_vec(cx: test_ctxt) -> @ast::expr {\n-    debug!{\"building test vector from %u tests\", cx.testfns.len()};\n+    debug!(\"building test vector from %u tests\", cx.testfns.len());\n     let mut descs = ~[];\n     for cx.testfns.each |test| {\n         vec::push(descs, mk_test_desc_rec(cx, test));\n@@ -300,8 +300,8 @@ fn mk_test_desc_rec(cx: test_ctxt, test: test) -> @ast::expr {\n     let span = test.span;\n     let path = test.path;\n \n-    debug!{\"encoding %s\", ast_util::path_name_i(path,\n-                                                cx.sess.parse_sess.interner)};\n+    debug!(\"encoding %s\", ast_util::path_name_i(path,\n+                                                cx.sess.parse_sess.interner));\n \n     let name_lit: ast::lit =\n         nospan(ast::lit_str(@ast_util::path_name_i(path, cx.sess.parse_sess"}, {"sha": "1ad517b3007ffe058cf05b4e485615b2faecfdda", "filename": "src/rustc/lib/llvm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Flib%2Fllvm.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -1090,7 +1090,7 @@ fn type_to_str_inner(names: type_names, outer0: ~[TypeRef], ty: TypeRef) ->\n             if addrspace == 0u {\n                 ~\"\"\n             } else {\n-                fmt!{\"addrspace(%u)\", addrspace}\n+                fmt!(\"addrspace(%u)\", addrspace)\n             }\n         };\n         return addrstr + ~\"*\" +"}, {"sha": "5867dc12672711b945df85c885fd8912c3e25527", "filename": "src/rustc/metadata/creader.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcreader.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -45,11 +45,11 @@ type cache_entry = {\n };\n \n fn dump_crates(crate_cache: DVec<cache_entry>) {\n-    debug!{\"resolved crates:\"};\n+    debug!(\"resolved crates:\");\n     for crate_cache.each |entry| {\n-        debug!{\"cnum: %?\", entry.cnum};\n-        debug!{\"span: %?\", entry.span};\n-        debug!{\"hash: %?\", entry.hash};\n+        debug!(\"cnum: %?\", entry.cnum);\n+        debug!(\"span: %?\", entry.span);\n+        debug!(\"hash: %?\", entry.hash);\n     }\n }\n \n@@ -73,7 +73,7 @@ fn warn_if_multiple_versions(e: env, diag: span_handler,\n \n         if matches.len() != 1u {\n             diag.handler().warn(\n-                fmt!{\"using multiple versions of crate `%s`\", name});\n+                fmt!(\"using multiple versions of crate `%s`\", name));\n             for matches.each |match_| {\n                 diag.span_note(match_.span, ~\"used here\");\n                 let attrs = ~[\n@@ -99,7 +99,7 @@ type env = @{diag: span_handler,\n fn visit_view_item(e: env, i: @ast::view_item) {\n     match i.node {\n       ast::view_item_use(ident, meta_items, id) => {\n-        debug!{\"resolving use stmt. ident: %?, meta: %?\", ident, meta_items};\n+        debug!(\"resolving use stmt. ident: %?, meta: %?\", ident, meta_items);\n         let cnum = resolve_crate(e, ident, meta_items, ~\"\", i.span);\n         cstore::add_use_stmt_cnum(e.cstore, id, cnum);\n       }\n@@ -236,25 +236,25 @@ fn resolve_crate(e: env, ident: ast::ident, metas: ~[@ast::meta_item],\n \n // Go through the crate metadata and load any crates that it references\n fn resolve_crate_deps(e: env, cdata: @~[u8]) -> cstore::cnum_map {\n-    debug!{\"resolving deps of external crate\"};\n+    debug!(\"resolving deps of external crate\");\n     // The map from crate numbers in the crate we're resolving to local crate\n     // numbers\n     let cnum_map = int_hash::<ast::crate_num>();\n     for decoder::get_crate_deps(e.intr, cdata).each |dep| {\n         let extrn_cnum = dep.cnum;\n         let cname = dep.name;\n         let cmetas = metas_with(dep.vers, ~\"vers\", ~[]);\n-        debug!{\"resolving dep crate %s ver: %s hash: %s\",\n-               *e.intr.get(dep.name), dep.vers, dep.hash};\n+        debug!(\"resolving dep crate %s ver: %s hash: %s\",\n+               *e.intr.get(dep.name), dep.vers, dep.hash);\n         match existing_match(e, metas_with_ident(*e.intr.get(cname), cmetas),\n                              dep.hash) {\n           some(local_cnum) => {\n-            debug!{\"already have it\"};\n+            debug!(\"already have it\");\n             // We've already seen this crate\n             cnum_map.insert(extrn_cnum, local_cnum);\n           }\n           none => {\n-            debug!{\"need to load it\"};\n+            debug!(\"need to load it\");\n             // This is a new one so we've got to load it\n             // FIXME (#2404): Need better error reporting than just a bogus\n             // span."}, {"sha": "dbf4d7d5566d19e353d4618bcd0ff5e15ca658b1", "filename": "src/rustc/metadata/csearch.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcsearch.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -137,17 +137,17 @@ fn get_field_type(tcx: ty::ctxt, class_id: ast::def_id,\n     let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, class_id.crate);\n     let all_items = ebml::get_doc(ebml::doc(cdata.data), tag_items);\n-    debug!{\"Looking up %?\", class_id};\n+    debug!(\"Looking up %?\", class_id);\n     let class_doc = expect(tcx.diag,\n                            decoder::maybe_find_item(class_id.node, all_items),\n-                           || fmt!{\"get_field_type: class ID %? not found\",\n-                                   class_id} );\n-    debug!{\"looking up %? : %?\", def, class_doc};\n+                           || fmt!(\"get_field_type: class ID %? not found\",\n+                                   class_id) );\n+    debug!(\"looking up %? : %?\", def, class_doc);\n     let the_field = expect(tcx.diag,\n         decoder::maybe_find_item(def.node, class_doc),\n-        || fmt!{\"get_field_type: in class %?, field ID %? not found\",\n-                 class_id, def} );\n-    debug!{\"got field data %?\", the_field};\n+        || fmt!(\"get_field_type: in class %?, field ID %? not found\",\n+                 class_id, def) );\n+    debug!(\"got field data %?\", the_field);\n     let ty = decoder::item_type(def, the_field, tcx, cdata);\n     return {bounds: @~[],\n             region_param: none,"}, {"sha": "4b65953781a65d1821bba2b29f6a1f49f3b80aa4", "filename": "src/rustc/metadata/cstore.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcstore.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -163,14 +163,14 @@ fn get_dep_hashes(cstore: cstore) -> ~[~str] {\n     for p(cstore).use_crate_map.each_value |cnum| {\n         let cdata = cstore::get_crate_data(cstore, cnum);\n         let hash = decoder::get_crate_hash(cdata.data);\n-        debug!{\"Add hash[%s]: %s\", cdata.name, hash};\n+        debug!(\"Add hash[%s]: %s\", cdata.name, hash);\n         vec::push(result, {name: cdata.name, hash: hash});\n     };\n     pure fn lteq(a: &crate_hash, b: &crate_hash) -> bool {a.name <= b.name}\n     let sorted = std::sort::merge_sort(lteq, result);\n-    debug!{\"sorted:\"};\n+    debug!(\"sorted:\");\n     for sorted.each |x| {\n-        debug!{\"  hash[%s]: %s\", x.name, x.hash};\n+        debug!(\"  hash[%s]: %s\", x.name, x.hash);\n     }\n     fn mapper(ch: crate_hash) -> ~str { return ch.hash; }\n     return vec::map(sorted, mapper);"}, {"sha": "37f00be40ff2da1f03a9e2214cfc5aa92b736c3d", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -100,7 +100,7 @@ fn find_item(item_id: int, items: ebml::doc) -> ebml::doc {\n fn lookup_item(item_id: int, data: @~[u8]) -> ebml::doc {\n     let items = ebml::get_doc(ebml::doc(data), tag_items);\n     match maybe_find_item(item_id, items) {\n-       none => fail(fmt!{\"lookup_item: id not found: %d\", item_id}),\n+       none => fail(fmt!(\"lookup_item: id not found: %d\", item_id)),\n        some(d) => d\n     }\n }\n@@ -379,8 +379,8 @@ fn get_class_method(intr: ident_interner, cdata: cmd, id: ast::node_id,\n     let mut found = none;\n     let cls_items = match maybe_find_item(id, items) {\n       some(it) => it,\n-      none => fail (fmt!{\"get_class_method: class id not found \\\n-                              when looking up method %s\", *intr.get(name)})\n+      none => fail (fmt!(\"get_class_method: class id not found \\\n+                              when looking up method %s\", *intr.get(name)))\n     };\n     for ebml::tagged_docs(cls_items, tag_item_trait_method) |mid| {\n         let m_did = item_def_id(mid, cdata);\n@@ -390,8 +390,8 @@ fn get_class_method(intr: ident_interner, cdata: cmd, id: ast::node_id,\n     }\n     match found {\n       some(found) => found,\n-      none => fail (fmt!{\"get_class_method: no method named %s\",\n-                         *intr.get(name)})\n+      none => fail (fmt!(\"get_class_method: no method named %s\",\n+                         *intr.get(name)))\n     }\n }\n \n@@ -400,8 +400,8 @@ fn class_dtor(cdata: cmd, id: ast::node_id) -> option<ast::def_id> {\n     let mut found = none;\n     let cls_items = match maybe_find_item(id, items) {\n             some(it) => it,\n-            none     => fail (fmt!{\"class_dtor: class id not found \\\n-              when looking up dtor for %d\", id})\n+            none     => fail (fmt!(\"class_dtor: class id not found \\\n+              when looking up dtor for %d\", id))\n     };\n     for ebml::tagged_docs(cls_items, tag_item_dtor) |doc| {\n          let doc1 = ebml::get_doc(doc, tag_def_id);\n@@ -461,7 +461,7 @@ fn each_path(intr: ident_interner, cdata: cmd, f: fn(path_entry) -> bool) {\n                 let def_id = item_def_id(item_doc, cdata);\n \n                 // Construct the def for this item.\n-                debug!{\"(each_path) yielding explicit item: %s\", path};\n+                debug!(\"(each_path) yielding explicit item: %s\", path);\n                 let def_like = item_to_def_like(item_doc, def_id, cdata.cnum);\n \n                 // Hand the information off to the iteratee.\n@@ -539,7 +539,7 @@ fn maybe_get_item_ast(intr: ident_interner, cdata: cmd, tcx: ty::ctxt,\n                       id: ast::node_id,\n                       decode_inlined_item: decode_inlined_item\n                      ) -> csearch::found_ast {\n-    debug!{\"Looking up item: %d\", id};\n+    debug!(\"Looking up item: %d\", id);\n     let item_doc = lookup_item(id, cdata.data);\n     let path = vec::init(item_path(intr, item_doc));\n     match decode_inlined_item(cdata, tcx, path, item_doc) {\n@@ -609,7 +609,7 @@ fn get_self_ty(item: ebml::doc) -> ast::self_ty_ {\n             'm' => { ast::m_mutbl }\n             'c' => { ast::m_const }\n             _ => {\n-                fail fmt!{\"unknown mutability character: `%c`\", ch as char}\n+                fail fmt!(\"unknown mutability character: `%c`\", ch as char)\n             }\n         }\n     }\n@@ -626,7 +626,7 @@ fn get_self_ty(item: ebml::doc) -> ast::self_ty_ {\n         '~' => { return ast::sty_uniq(get_mutability(string[1])); }\n         '&' => { return ast::sty_region(get_mutability(string[1])); }\n         _ => {\n-            fail fmt!{\"unknown self type code: `%c`\", self_ty_kind as char};\n+            fail fmt!(\"unknown self type code: `%c`\", self_ty_kind as char);\n         }\n     }\n }\n@@ -658,8 +658,8 @@ fn get_impls_for_mod(intr: ident_interner, cdata: cmd,\n     for ebml::tagged_docs(mod_item, tag_mod_impl) |doc| {\n         let did = ebml::with_doc_data(doc, |d| parse_def_id(d));\n         let local_did = translate_def_id(cdata, did);\n-        debug!{\"(get impls for mod) getting did %? for '%?'\",\n-               local_did, name};\n+        debug!(\"(get impls for mod) getting did %? for '%?'\",\n+               local_did, name);\n           // The impl may be defined in a different crate. Ask the caller\n           // to give us the metadata\n         let impl_cdata = get_cdata(local_did.crate);\n@@ -797,7 +797,7 @@ fn describe_def(items: ebml::doc, id: ast::def_id) -> ~str {\n     if id.crate != ast::local_crate { return ~\"external\"; }\n     let it = match maybe_find_item(id.node, items) {\n         some(it) => it,\n-        none => fail (fmt!{\"describe_def: item not found %?\", id})\n+        none => fail (fmt!(\"describe_def: item not found %?\", id))\n     };\n     return item_family_to_str(item_family(it));\n }\n@@ -877,16 +877,16 @@ fn get_attributes(md: ebml::doc) -> ~[ast::attribute] {\n fn list_meta_items(intr: ident_interner,\n                    meta_items: ebml::doc, out: io::Writer) {\n     for get_meta_items(meta_items).each |mi| {\n-        out.write_str(fmt!{\"%s\\n\", pprust::meta_item_to_str(mi, intr)});\n+        out.write_str(fmt!(\"%s\\n\", pprust::meta_item_to_str(mi, intr)));\n     }\n }\n \n fn list_crate_attributes(intr: ident_interner, md: ebml::doc, hash: ~str,\n                          out: io::Writer) {\n-    out.write_str(fmt!{\"=Crate Attributes (%s)=\\n\", hash});\n+    out.write_str(fmt!(\"=Crate Attributes (%s)=\\n\", hash));\n \n     for get_attributes(md).each |attr| {\n-        out.write_str(fmt!{\"%s\\n\", pprust::attribute_to_str(attr, intr)});\n+        out.write_str(fmt!(\"%s\\n\", pprust::attribute_to_str(attr, intr)));\n     }\n \n     out.write_str(~\"\\n\\n\");\n@@ -922,8 +922,8 @@ fn list_crate_deps(intr: ident_interner, data: @~[u8], out: io::Writer) {\n \n     for get_crate_deps(intr, data).each |dep| {\n         out.write_str(\n-            fmt!{\"%d %s-%s-%s\\n\",\n-                 dep.cnum, *intr.get(dep.name), dep.hash, dep.vers});\n+            fmt!(\"%d %s-%s-%s\\n\",\n+                 dep.cnum, *intr.get(dep.name), dep.hash, dep.vers));\n     }\n \n     out.write_str(~\"\\n\");"}, {"sha": "8737e31e614bc94b6f91f06074ef43194d6b241d", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -126,7 +126,7 @@ fn encode_family(ebml_w: ebml::writer, c: char) {\n     ebml_w.end_tag();\n }\n \n-fn def_to_str(did: def_id) -> ~str { fmt!{\"%d:%d\", did.crate, did.node} }\n+fn def_to_str(did: def_id) -> ~str { fmt!(\"%d:%d\", did.crate, did.node) }\n \n fn encode_ty_type_param_bounds(ebml_w: ebml::writer, ecx: @encode_ctxt,\n                                params: @~[ty::param_bounds]) {\n@@ -178,7 +178,7 @@ fn encode_symbol(ecx: @encode_ctxt, ebml_w: ebml::writer, id: node_id) {\n       some(x) => x,\n       none => {\n         ecx.diag.handler().bug(\n-            fmt!{\"encode_symbol: id not found %d\", id});\n+            fmt!(\"encode_symbol: id not found %d\", id));\n       }\n     };\n     ebml_w.writer.write(str::bytes(sym));\n@@ -265,20 +265,20 @@ fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: ebml::writer, md: _mod,\n     encode_def_id(ebml_w, local_def(id));\n     encode_family(ebml_w, 'm');\n     encode_name(ecx, ebml_w, name);\n-    debug!{\"(encoding info for module) encoding info for module ID %d\", id};\n+    debug!(\"(encoding info for module) encoding info for module ID %d\", id);\n \n     // Encode info about all the module children.\n     for md.items.each |item| {\n         match item.node {\n             item_impl(*) | item_class(*) => {\n                 let (ident, did) = (item.ident, item.id);\n-                debug!{\"(encoding info for module) ... encoding impl %s \\\n+                debug!(\"(encoding info for module) ... encoding impl %s \\\n                         (%?/%?), exported? %?\",\n                         ecx.tcx.sess.str_of(ident),\n                         did,\n                         ast_map::node_id_to_str(ecx.tcx.items, did, ecx.tcx\n                                                 .sess.parse_sess.interner),\n-                        ast_util::is_exported(ident, md)};\n+                        ast_util::is_exported(ident, md));\n \n                 ebml_w.start_tag(tag_mod_impl);\n                 ebml_w.wr_str(def_to_str(local_def(did)));\n@@ -378,8 +378,8 @@ fn encode_info_for_class(ecx: @encode_ctxt, ebml_w: ebml::writer,\n                 vec::push(*global_index, {val: id,\n                                           pos: ebml_w.writer.tell()});\n                 ebml_w.start_tag(tag_items_data_item);\n-                debug!{\"encode_info_for_class: doing %s %d\",\n-                       tcx.sess.str_of(nm), id};\n+                debug!(\"encode_info_for_class: doing %s %d\",\n+                       tcx.sess.str_of(nm), id);\n                 encode_visibility(ebml_w, vis);\n                 encode_name(ecx, ebml_w, nm);\n                 encode_path(ecx, ebml_w, path, ast_map::path_name(nm));\n@@ -400,8 +400,8 @@ fn encode_info_for_class(ecx: @encode_ctxt, ebml_w: ebml::writer,\n                           {val: m.id, pos: ebml_w.writer.tell()});\n                 let impl_path = vec::append_one(path,\n                                                 ast_map::path_name(m.ident));\n-                debug!{\"encode_info_for_class: doing %s %d\",\n-                       ecx.tcx.sess.str_of(m.ident), m.id};\n+                debug!(\"encode_info_for_class: doing %s %d\",\n+                       ecx.tcx.sess.str_of(m.ident), m.id);\n                 encode_info_for_method(ecx, ebml_w, impl_path,\n                                        should_inline(m.attrs), id, m,\n                                        vec::append(class_tps, m.tps));\n@@ -423,9 +423,9 @@ fn encode_info_for_fn(ecx: @encode_ctxt, ebml_w: ebml::writer,\n         encode_family(ebml_w, purity_fn_family(decl.purity));\n         encode_type_param_bounds(ebml_w, ecx, tps);\n         let its_ty = node_id_to_type(ecx.tcx, id);\n-        debug!{\"fn name = %s ty = %s its node id = %d\",\n+        debug!(\"fn name = %s ty = %s its node id = %d\",\n                ecx.tcx.sess.str_of(ident),\n-               util::ppaux::ty_to_str(ecx.tcx, its_ty), id};\n+               util::ppaux::ty_to_str(ecx.tcx, its_ty), id);\n         encode_type(ecx, ebml_w, its_ty);\n         encode_path(ecx, ebml_w, path, ast_map::path_name(ident));\n         match item {\n@@ -443,8 +443,8 @@ fn encode_info_for_method(ecx: @encode_ctxt, ebml_w: ebml::writer,\n                           impl_path: ast_map::path, should_inline: bool,\n                           parent_id: node_id,\n                           m: @method, all_tps: ~[ty_param]) {\n-    debug!{\"encode_info_for_method: %d %s %u\", m.id,\n-           ecx.tcx.sess.str_of(m.ident), all_tps.len()};\n+    debug!(\"encode_info_for_method: %d %s %u\", m.id,\n+           ecx.tcx.sess.str_of(m.ident), all_tps.len());\n     ebml_w.start_tag(tag_items_data_item);\n     encode_def_id(ebml_w, local_def(m.id));\n     encode_family(ebml_w, purity_fn_family(m.decl.purity));\n@@ -668,8 +668,8 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n \n         /* Encode the constructor */\n         for struct_def.ctor.each |ctor| {\n-            debug!{\"encoding info for ctor %s %d\",\n-                   ecx.tcx.sess.str_of(item.ident), ctor.node.id};\n+            debug!(\"encoding info for ctor %s %d\",\n+                   ecx.tcx.sess.str_of(item.ident), ctor.node.id);\n             vec::push(*index, {\n                 val: ctor.node.id,\n                 pos: ebml_w.writer.tell()"}, {"sha": "726618911639eb78cd4dc37ea4c8cc580c3ea2cb", "filename": "src/rustc/metadata/filesearch.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ffilesearch.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -62,7 +62,7 @@ fn mk_filesearch(maybe_sysroot: option<Path>,\n     }\n \n     let sysroot = get_sysroot(maybe_sysroot);\n-    debug!{\"using sysroot = %s\", sysroot};\n+    debug!(\"using sysroot = %s\", sysroot);\n     {sysroot: sysroot,\n      addl_lib_search_paths: addl_lib_search_paths,\n      target_triple: target_triple} as filesearch\n@@ -71,16 +71,16 @@ fn mk_filesearch(maybe_sysroot: option<Path>,\n fn search<T: copy>(filesearch: filesearch, pick: pick<T>) -> option<T> {\n     let mut rslt = none;\n     for filesearch.lib_search_paths().each |lib_search_path| {\n-        debug!{\"searching %s\", lib_search_path};\n+        debug!(\"searching %s\", lib_search_path);\n         for os::list_dir_path(lib_search_path).each |path| {\n-            debug!{\"testing %s\", path};\n+            debug!(\"testing %s\", path);\n             let maybe_picked = pick(path);\n             if option::is_some(maybe_picked) {\n-                debug!{\"picked %s\", path};\n+                debug!(\"picked %s\", path);\n                 rslt = maybe_picked;\n                 break;\n             } else {\n-                debug!{\"rejected %s\", path};\n+                debug!(\"rejected %s\", path);\n             }\n         }\n         if option::is_some(rslt) { break; }\n@@ -168,7 +168,7 @@ fn get_cargo_lib_path_nearest() -> result<Path, ~str> {\n // The name of the directory rustc expects libraries to be located.\n // On Unix should be \"lib\", on windows \"bin\"\n fn libdir() -> ~str {\n-   let libdir = env!{\"CFG_LIBDIR\"};\n+   let libdir = env!(\"CFG_LIBDIR\");\n    if str::is_empty(libdir) {\n       fail ~\"rustc compiled without CFG_LIBDIR environment variable\";\n    }"}, {"sha": "f010b7e9754dff5dee8bbac7acf7a1c646428fa1", "filename": "src/rustc/metadata/loader.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Floader.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -43,8 +43,8 @@ fn load_library_crate(cx: ctxt) -> {ident: ~str, data: @~[u8]} {\n       some(t) => return t,\n       none => {\n         cx.diag.span_fatal(\n-            cx.span, fmt!{\"can't find crate for `%s`\",\n-                          *cx.intr.get(cx.ident)});\n+            cx.span, fmt!(\"can't find crate for `%s`\",\n+                          *cx.intr.get(cx.ident)));\n       }\n     }\n }\n@@ -74,27 +74,27 @@ fn find_library_crate_aux(cx: ctxt,\n \n     let mut matches = ~[];\n     filesearch::search(filesearch, |path| {\n-        debug!{\"inspecting file %s\", path};\n+        debug!(\"inspecting file %s\", path);\n         let f: ~str = path::basename(path);\n         if !(str::starts_with(f, prefix) && str::ends_with(f, suffix)) {\n-            debug!{\"skipping %s, doesn't look like %s*%s\", path, prefix,\n-                   suffix};\n+            debug!(\"skipping %s, doesn't look like %s*%s\", path, prefix,\n+                   suffix);\n             option::none::<()>\n         } else {\n-            debug!{\"%s is a candidate\", path};\n+            debug!(\"%s is a candidate\", path);\n             match get_metadata_section(cx.os, path) {\n               option::some(cvec) => {\n                 if !crate_matches(cvec, cx.metas, cx.hash) {\n-                    debug!{\"skipping %s, metadata doesn't match\", path};\n+                    debug!(\"skipping %s, metadata doesn't match\", path);\n                     option::none::<()>\n                 } else {\n-                    debug!{\"found %s with matching metadata\", path};\n+                    debug!(\"found %s with matching metadata\", path);\n                     vec::push(matches, {ident: path, data: cvec});\n                     option::none::<()>\n                 }\n               }\n               _ => {\n-                debug!{\"could not load metadata for %s\", path};\n+                debug!(\"could not load metadata for %s\", path);\n                 option::none::<()>\n               }\n             }\n@@ -107,10 +107,10 @@ fn find_library_crate_aux(cx: ctxt,\n         some(matches[0])\n     } else {\n         cx.diag.span_err(\n-            cx.span, fmt!{\"multiple matching crates for `%s`\", crate_name});\n+            cx.span, fmt!(\"multiple matching crates for `%s`\", crate_name));\n         cx.diag.handler().note(~\"candidates:\");\n         for matches.each |match_| {\n-            cx.diag.handler().note(fmt!{\"path: %s\", match_.ident});\n+            cx.diag.handler().note(fmt!(\"path: %s\", match_.ident));\n             let attrs = decoder::get_crate_attributes(match_.data);\n             note_linkage_attrs(cx.intr, cx.diag, attrs);\n         }\n@@ -137,8 +137,8 @@ fn crate_name_from_metas(metas: ~[@ast::meta_item]) -> ~str {\n fn note_linkage_attrs(intr: ident_interner, diag: span_handler,\n                       attrs: ~[ast::attribute]) {\n     for attr::find_linkage_metas(attrs).each |mi| {\n-        diag.handler().note(fmt!{\"meta: %s\",\n-              pprust::meta_item_to_str(mi,intr)});\n+        diag.handler().note(fmt!(\"meta: %s\",\n+              pprust::meta_item_to_str(mi,intr)));\n     }\n }\n \n@@ -156,8 +156,8 @@ fn crate_matches(crate_data: @~[u8], metas: ~[@ast::meta_item],\n fn metadata_matches(extern_metas: ~[@ast::meta_item],\n                     local_metas: ~[@ast::meta_item]) -> bool {\n \n-    debug!{\"matching %u metadata requirements against %u items\",\n-           vec::len(local_metas), vec::len(extern_metas)};\n+    debug!(\"matching %u metadata requirements against %u items\",\n+           vec::len(local_metas), vec::len(extern_metas));\n \n     for local_metas.each |needed| {\n         if !attr::contains(extern_metas, needed) {"}, {"sha": "e8cfe22f0bcfc85f29c10c047406bb96aae3565f", "filename": "src/rustc/metadata/tydecode.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftydecode.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -308,16 +308,16 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n       }\n       'B' => ty::mk_opaque_box(st.tcx),\n       'a' => {\n-          debug!{\"saw a class\"};\n+          debug!(\"saw a class\");\n           assert (next(st) == '[');\n-          debug!{\"saw a [\"};\n+          debug!(\"saw a [\");\n           let did = parse_def(st, conv);\n-          debug!{\"parsed a def_id %?\", did};\n+          debug!(\"parsed a def_id %?\", did);\n           let substs = parse_substs(st, conv);\n           assert (next(st) == ']');\n           return ty::mk_class(st.tcx, did, substs);\n       }\n-      c => { error!{\"unexpected char in type string: %c\", c}; fail;}\n+      c => { error!(\"unexpected char in type string: %c\", c); fail;}\n     }\n }\n \n@@ -403,7 +403,7 @@ fn parse_def_id(buf: &[u8]) -> ast::def_id {\n     let len = vec::len(buf);\n     while colon_idx < len && buf[colon_idx] != ':' as u8 { colon_idx += 1u; }\n     if colon_idx == len {\n-        error!{\"didn't find ':' when parsing def id\"};\n+        error!(\"didn't find ':' when parsing def id\");\n         fail;\n     }\n \n@@ -412,13 +412,13 @@ fn parse_def_id(buf: &[u8]) -> ast::def_id {\n \n     let crate_num = match uint::parse_buf(crate_part, 10u) {\n        some(cn) => cn as int,\n-       none => fail (fmt!{\"internal error: parse_def_id: crate number \\\n-                               expected, but found %?\", crate_part})\n+       none => fail (fmt!(\"internal error: parse_def_id: crate number \\\n+                               expected, but found %?\", crate_part))\n     };\n     let def_num = match uint::parse_buf(def_part, 10u) {\n        some(dn) => dn as int,\n-       none => fail (fmt!{\"internal error: parse_def_id: id expected, but \\\n-                               found %?\", def_part})\n+       none => fail (fmt!(\"internal error: parse_def_id: id expected, but \\\n+                               found %?\", def_part))\n     };\n     return {crate: crate_num, node: def_num};\n }"}, {"sha": "f8c2b87a95a0c9cd83abb390ce1b5fd59ea71c9a", "filename": "src/rustc/metadata/tyencode.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftyencode.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -298,15 +298,15 @@ fn enc_sty(w: io::Writer, cx: @ctxt, st: ty::sty) {\n       ty::ty_opaque_closure_ptr(ty::ck_uniq) => w.write_str(&\"C~\"),\n       ty::ty_opaque_box => w.write_char('B'),\n       ty::ty_class(def, substs) => {\n-          debug!{\"~~~~ %s\", ~\"a[\"};\n+          debug!(\"~~~~ %s\", ~\"a[\");\n           w.write_str(&\"a[\");\n           let s = cx.ds(def);\n-          debug!{\"~~~~ %s\", s};\n+          debug!(\"~~~~ %s\", s);\n           w.write_str(s);\n-          debug!{\"~~~~ %s\", ~\"|\"};\n+          debug!(\"~~~~ %s\", ~\"|\");\n           w.write_char('|');\n           enc_substs(w, cx, substs);\n-          debug!{\"~~~~ %s\", ~\"]\"};\n+          debug!(\"~~~~ %s\", ~\"]\");\n           w.write_char(']');\n       }\n     }"}, {"sha": "b8e097dc8e92fbf503724b612628afd41ccc4d50", "filename": "src/rustc/middle/astencode.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fastencode.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -82,10 +82,10 @@ fn encode_inlined_item(ecx: @e::encode_ctxt,\n                        path: ast_map::path,\n                        ii: ast::inlined_item,\n                        maps: maps) {\n-    debug!{\"> Encoding inlined item: %s::%s (%u)\",\n+    debug!(\"> Encoding inlined item: %s::%s (%u)\",\n            ast_map::path_to_str(path, ecx.tcx.sess.parse_sess.interner),\n            ecx.tcx.sess.str_of(ii.ident()),\n-           ebml_w.writer.tell()};\n+           ebml_w.writer.tell());\n \n     let id_range = ast_util::compute_id_range_for_inlined_item(ii);\n     do ebml_w.wr_tag(c::tag_ast as uint) {\n@@ -94,10 +94,10 @@ fn encode_inlined_item(ecx: @e::encode_ctxt,\n         encode_side_tables_for_ii(ecx, maps, ebml_w, ii);\n     }\n \n-    debug!{\"< Encoded inlined fn: %s::%s (%u)\",\n+    debug!(\"< Encoded inlined fn: %s::%s (%u)\",\n            ast_map::path_to_str(path, ecx.tcx.sess.parse_sess.interner),\n            ecx.tcx.sess.str_of(ii.ident()),\n-           ebml_w.writer.tell()};\n+           ebml_w.writer.tell());\n }\n \n fn decode_inlined_item(cdata: cstore::crate_metadata,\n@@ -109,8 +109,8 @@ fn decode_inlined_item(cdata: cstore::crate_metadata,\n     match par_doc.opt_child(c::tag_ast) {\n       none => none,\n       some(ast_doc) => {\n-        debug!{\"> Decoding inlined fn: %s::?\",\n-               ast_map::path_to_str(path, tcx.sess.parse_sess.interner)};\n+        debug!(\"> Decoding inlined fn: %s::?\",\n+               ast_map::path_to_str(path, tcx.sess.parse_sess.interner));\n         let ast_dsr = ebml::ebml_deserializer(ast_doc);\n         let from_id_range = ast_util::deserialize_id_range(ast_dsr);\n         let to_id_range = reserve_id_range(dcx.tcx.sess, from_id_range);\n@@ -121,15 +121,15 @@ fn decode_inlined_item(cdata: cstore::crate_metadata,\n         let ii = renumber_ast(xcx, raw_ii);\n         ast_map::map_decoded_item(tcx.sess.diagnostic(),\n                                   dcx.tcx.items, path, ii);\n-        debug!{\"Fn named: %s\", tcx.sess.str_of(ii.ident())};\n+        debug!(\"Fn named: %s\", tcx.sess.str_of(ii.ident()));\n         decode_side_tables(xcx, ast_doc);\n-        debug!{\"< Decoded inlined fn: %s::%s\",\n+        debug!(\"< Decoded inlined fn: %s::%s\",\n                ast_map::path_to_str(path, tcx.sess.parse_sess.interner),\n-               tcx.sess.str_of(ii.ident())};\n+               tcx.sess.str_of(ii.ident()));\n         match ii {\n           ast::ii_item(i) => {\n-            debug!{\">>> DECODED ITEM >>>\\n%s\\n<<< DECODED ITEM <<<\",\n-                   syntax::print::pprust::item_to_str(i, tcx.sess.intr())};\n+            debug!(\">>> DECODED ITEM >>>\\n%s\\n<<< DECODED ITEM <<<\",\n+                   syntax::print::pprust::item_to_str(i, tcx.sess.intr()));\n           }\n           _ => { }\n         }\n@@ -650,7 +650,7 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n                              id: ast::node_id) {\n     let tcx = ecx.tcx;\n \n-    debug!{\"Encoding side tables for id %d\", id};\n+    debug!(\"Encoding side tables for id %d\", id);\n \n     do option::iter(tcx.def_map.find(id)) |def| {\n         do ebml_w.tag(c::tag_table_def) {\n@@ -838,9 +838,9 @@ fn decode_side_tables(xcx: extended_decode_ctxt,\n         let id0 = entry_doc[c::tag_table_id as uint].as_int();\n         let id = xcx.tr_id(id0);\n \n-        debug!{\">> Side table document with tag 0x%x \\\n+        debug!(\">> Side table document with tag 0x%x \\\n                 found for id %d (orig %d)\",\n-               tag, id, id0};\n+               tag, id, id0);\n \n         if tag == (c::tag_table_mutbl as uint) {\n             dcx.maps.mutbl_map.insert(id, ());\n@@ -889,11 +889,11 @@ fn decode_side_tables(xcx: extended_decode_ctxt,\n                 dcx.tcx.borrowings.insert(id, borrow);\n             } else {\n                 xcx.dcx.tcx.sess.bug(\n-                    fmt!{\"unknown tag found in side tables: %x\", tag});\n+                    fmt!(\"unknown tag found in side tables: %x\", tag));\n             }\n         }\n \n-        debug!{\">< Side table doc loaded\"};\n+        debug!(\">< Side table doc loaded\");\n     }\n }\n \n@@ -947,8 +947,8 @@ fn roundtrip(in_item: @ast::item) {\n     let out_str =\n         io::with_str_writer(|w| ast::serialize_item(w, *out_item) );\n \n-    debug!{\"expected string: %s\", exp_str};\n-    debug!{\"actual string  : %s\", out_str};\n+    debug!(\"expected string: %s\", exp_str);\n+    debug!(\"actual string  : %s\", out_str);\n \n     assert exp_str == out_str;\n }"}, {"sha": "6de28f3e31663b5c1ee9c46f16b59c9bc0c9945c", "filename": "src/rustc/middle/borrowck.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -255,24 +255,24 @@ fn check_crate(tcx: ty::ctxt,\n \n     if tcx.sess.borrowck_stats() {\n         io::println(~\"--- borrowck stats ---\");\n-        io::println(fmt!{\"paths requiring guarantees: %u\",\n-                        bccx.guaranteed_paths});\n-        io::println(fmt!{\"paths requiring loans     : %s\",\n-                         make_stat(bccx, bccx.loaned_paths_same)});\n-        io::println(fmt!{\"paths requiring imm loans : %s\",\n-                         make_stat(bccx, bccx.loaned_paths_imm)});\n-        io::println(fmt!{\"stable paths              : %s\",\n-                         make_stat(bccx, bccx.stable_paths)});\n-        io::println(fmt!{\"paths requiring purity    : %s\",\n-                         make_stat(bccx, bccx.req_pure_paths)});\n+        io::println(fmt!(\"paths requiring guarantees: %u\",\n+                        bccx.guaranteed_paths));\n+        io::println(fmt!(\"paths requiring loans     : %s\",\n+                         make_stat(bccx, bccx.loaned_paths_same)));\n+        io::println(fmt!(\"paths requiring imm loans : %s\",\n+                         make_stat(bccx, bccx.loaned_paths_imm)));\n+        io::println(fmt!(\"stable paths              : %s\",\n+                         make_stat(bccx, bccx.stable_paths)));\n+        io::println(fmt!(\"paths requiring purity    : %s\",\n+                         make_stat(bccx, bccx.req_pure_paths)));\n     }\n \n     return (bccx.root_map, bccx.mutbl_map);\n \n     fn make_stat(bccx: borrowck_ctxt, stat: uint) -> ~str {\n         let stat_f = stat as float;\n         let total = bccx.guaranteed_paths as float;\n-        fmt!{\"%u (%.0f%%)\", stat  , stat_f * 100f / total}\n+        fmt!(\"%u (%.0f%%)\", stat  , stat_f * 100f / total)\n     }\n }\n \n@@ -412,8 +412,8 @@ impl borrowck_ctxt {\n     fn report(err: bckerr) {\n         self.span_err(\n             err.cmt.span,\n-            fmt!{\"illegal borrow: %s\",\n-                 self.bckerr_code_to_str(err.code)});\n+            fmt!(\"illegal borrow: %s\",\n+                 self.bckerr_code_to_str(err.code)));\n     }\n \n     fn span_err(s: span, m: ~str) {\n@@ -439,8 +439,8 @@ impl borrowck_ctxt {\n     fn bckerr_code_to_str(code: bckerr_code) -> ~str {\n         match code {\n           err_mutbl(req, act) => {\n-            fmt!{\"creating %s alias to aliasable, %s memory\",\n-                 self.mut_to_str(req), self.mut_to_str(act)}\n+            fmt!(\"creating %s alias to aliasable, %s memory\",\n+                 self.mut_to_str(req), self.mut_to_str(act))\n           }\n           err_mut_uniq => {\n             ~\"unique value in aliasable, mutable location\"\n@@ -455,16 +455,16 @@ impl borrowck_ctxt {\n             ~\"rooting is not permitted\"\n           }\n           err_out_of_root_scope(super_scope, sub_scope) => {\n-            fmt!{\"managed value would have to be rooted for %s, \\\n+            fmt!(\"managed value would have to be rooted for %s, \\\n                   but can only be rooted for %s\",\n                   explain_region(self.tcx, sub_scope),\n-                  explain_region(self.tcx, super_scope)}\n+                  explain_region(self.tcx, super_scope))\n           }\n           err_out_of_scope(super_scope, sub_scope) => {\n-            fmt!{\"borrowed pointer must be valid for %s, \\\n+            fmt!(\"borrowed pointer must be valid for %s, \\\n                   but the borrowed value is only valid for %s\",\n                   explain_region(self.tcx, sub_scope),\n-                  explain_region(self.tcx, super_scope)}\n+                  explain_region(self.tcx, super_scope))\n           }\n         }\n     }"}, {"sha": "885d8a65046e1a432832fc1eae09efd818095767", "filename": "src/rustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -156,12 +156,12 @@ impl check_loan_ctxt {\n                                 callee_span: span) {\n         let tcx = self.tcx();\n \n-        debug!{\"check_pure_callee_or_arg(pc=%?, expr=%?, \\\n+        debug!(\"check_pure_callee_or_arg(pc=%?, expr=%?, \\\n                 callee_id=%d, ty=%s)\",\n                pc,\n                opt_expr.map(|e| pprust::expr_to_str(e, tcx.sess.intr()) ),\n                callee_id,\n-               ty_to_str(self.tcx(), ty::node_id_to_type(tcx, callee_id))};\n+               ty_to_str(self.tcx(), ty::node_id_to_type(tcx, callee_id)));\n \n         // Purity rules: an expr B is a legal callee or argument to a\n         // call within a pure function A if at least one of the\n@@ -204,8 +204,8 @@ impl check_loan_ctxt {\n               ast::impure_fn | ast::unsafe_fn | ast::extern_fn => {\n                 self.report_purity_error(\n                     pc, callee_span,\n-                    fmt!{\"access to %s function\",\n-                         pprust::purity_to_str(fn_ty.purity)});\n+                    fmt!(\"access to %s function\",\n+                         pprust::purity_to_str(fn_ty.purity)));\n               }\n             }\n           }\n@@ -256,14 +256,14 @@ impl check_loan_ctxt {\n                       (m_mutbl, m_imm) | (m_imm, m_mutbl) => {\n                         self.bccx.span_err(\n                             new_loan.cmt.span,\n-                            fmt!{\"loan of %s as %s \\\n+                            fmt!(\"loan of %s as %s \\\n                                   conflicts with prior loan\",\n                                  self.bccx.cmt_to_str(new_loan.cmt),\n-                                 self.bccx.mut_to_str(new_loan.mutbl)});\n+                                 self.bccx.mut_to_str(new_loan.mutbl)));\n                         self.bccx.span_note(\n                             old_loan.cmt.span,\n-                            fmt!{\"prior loan as %s granted here\",\n-                                 self.bccx.mut_to_str(old_loan.mutbl)});\n+                            fmt!(\"prior loan as %s granted here\",\n+                                 self.bccx.mut_to_str(old_loan.mutbl)));\n                       }\n                     }\n                 }\n@@ -293,8 +293,8 @@ impl check_loan_ctxt {\n     fn check_assignment(at: assignment_type, ex: @ast::expr) {\n         let cmt = self.bccx.cat_expr(ex);\n \n-        debug!{\"check_assignment(cmt=%s)\",\n-               self.bccx.cmt_to_repr(cmt)};\n+        debug!(\"check_assignment(cmt=%s)\",\n+               self.bccx.cmt_to_repr(cmt));\n \n         if self.in_ctor && self.is_self_field(cmt)\n             && at.checked_by_liveness() {\n@@ -375,12 +375,12 @@ impl check_loan_ctxt {\n               m_imm => {\n                 self.bccx.span_err(\n                     ex.span,\n-                    fmt!{\"%s prohibited due to outstanding loan\",\n-                         at.ing_form(self.bccx.cmt_to_str(cmt))});\n+                    fmt!(\"%s prohibited due to outstanding loan\",\n+                         at.ing_form(self.bccx.cmt_to_str(cmt))));\n                 self.bccx.span_note(\n                     loan.cmt.span,\n-                    fmt!{\"loan of %s granted here\",\n-                         self.bccx.cmt_to_str(loan.cmt)});\n+                    fmt!(\"loan of %s granted here\",\n+                         self.bccx.cmt_to_str(loan.cmt)));\n                 return;\n               }\n             }\n@@ -407,17 +407,17 @@ impl check_loan_ctxt {\n           pc_pure_fn => {\n             self.tcx().sess.span_err(\n                 sp,\n-                fmt!{\"%s prohibited in pure context\", msg});\n+                fmt!(\"%s prohibited in pure context\", msg));\n           }\n           pc_cmt(e) => {\n             if self.reported.insert(e.cmt.id, ()) {\n                 self.tcx().sess.span_err(\n                     e.cmt.span,\n-                    fmt!{\"illegal borrow unless pure: %s\",\n-                         self.bccx.bckerr_code_to_str(e.code)});\n+                    fmt!(\"illegal borrow unless pure: %s\",\n+                         self.bccx.bckerr_code_to_str(e.code)));\n                 self.tcx().sess.span_note(\n                     sp,\n-                    fmt!{\"impure due to %s\", msg});\n+                    fmt!(\"impure due to %s\", msg));\n             }\n           }\n         }\n@@ -429,8 +429,8 @@ impl check_loan_ctxt {\n     }\n \n     fn check_move_out_from_cmt(cmt: cmt) {\n-        debug!{\"check_move_out_from_cmt(cmt=%s)\",\n-               self.bccx.cmt_to_repr(cmt)};\n+        debug!(\"check_move_out_from_cmt(cmt=%s)\",\n+               self.bccx.cmt_to_repr(cmt));\n \n         match cmt.cat {\n           // Rvalues, locals, and arguments can be moved:\n@@ -447,7 +447,7 @@ impl check_loan_ctxt {\n           _ => {\n             self.bccx.span_err(\n                 cmt.span,\n-                fmt!{\"moving out of %s\", self.bccx.cmt_to_str(cmt)});\n+                fmt!(\"moving out of %s\", self.bccx.cmt_to_str(cmt)));\n             return;\n           }\n         }\n@@ -462,12 +462,12 @@ impl check_loan_ctxt {\n         for self.walk_loans_of(cmt.id, lp) |loan| {\n             self.bccx.span_err(\n                 cmt.span,\n-                fmt!{\"moving out of %s prohibited due to outstanding loan\",\n-                     self.bccx.cmt_to_str(cmt)});\n+                fmt!(\"moving out of %s prohibited due to outstanding loan\",\n+                     self.bccx.cmt_to_str(cmt)));\n             self.bccx.span_note(\n                 loan.cmt.span,\n-                fmt!{\"loan of %s granted here\",\n-                     self.bccx.cmt_to_str(loan.cmt)});\n+                fmt!(\"loan of %s granted here\",\n+                     self.bccx.cmt_to_str(loan.cmt)));\n             return;\n         }\n     }\n@@ -482,8 +482,8 @@ impl check_loan_ctxt {\n           some(lp) => lp\n         };\n         for self.walk_loans_of(cmt.id, lp) |_loan| {\n-            debug!{\"Removing last use entry %? due to outstanding loan\",\n-                   expr.id};\n+            debug!(\"Removing last use entry %? due to outstanding loan\",\n+                   expr.id);\n             self.bccx.last_use_map.remove(expr.id);\n             return;\n         }\n@@ -527,7 +527,7 @@ fn check_loans_in_fn(fk: visit::fn_kind, decl: ast::fn_decl, body: ast::blk,\n                      sp: span, id: ast::node_id, &&self: check_loan_ctxt,\n                      visitor: visit::vt<check_loan_ctxt>) {\n \n-    debug!{\"purity on entry=%?\", copy self.declared_purity};\n+    debug!(\"purity on entry=%?\", copy self.declared_purity);\n     do save_and_restore(self.in_ctor) {\n         do save_and_restore(self.declared_purity) {\n             do save_and_restore(self.fn_args) {\n@@ -563,7 +563,7 @@ fn check_loans_in_fn(fk: visit::fn_kind, decl: ast::fn_decl, body: ast::blk,\n             }\n         }\n     }\n-    debug!{\"purity on exit=%?\", copy self.declared_purity};\n+    debug!(\"purity on exit=%?\", copy self.declared_purity);\n }\n \n fn check_loans_in_local(local: @ast::local,"}, {"sha": "648d7f1e9b59ac8777076cf20fd1fa8347035d70", "filename": "src/rustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -90,8 +90,8 @@ fn req_loans_in_expr(ex: @ast::expr,\n     let tcx = bccx.tcx;\n     let old_root_ub = self.root_ub;\n \n-    debug!{\"req_loans_in_expr(ex=%s)\",\n-           pprust::expr_to_str(ex, tcx.sess.intr())};\n+    debug!(\"req_loans_in_expr(ex=%s)\",\n+           pprust::expr_to_str(ex, tcx.sess.intr()));\n \n     // If this expression is borrowed, have to ensure it remains valid:\n     for tcx.borrowings.find(ex.id).each |borrow| {\n@@ -257,10 +257,10 @@ impl gather_loan_ctxt {\n \n         self.bccx.guaranteed_paths += 1;\n \n-        debug!{\"guarantee_valid(cmt=%s, req_mutbl=%s, scope_r=%s)\",\n+        debug!(\"guarantee_valid(cmt=%s, req_mutbl=%s, scope_r=%s)\",\n                self.bccx.cmt_to_repr(cmt),\n                self.bccx.mut_to_str(req_mutbl),\n-               region_to_str(self.tcx(), scope_r)};\n+               region_to_str(self.tcx(), scope_r));\n         let _i = indenter();\n \n         match cmt.lp {\n@@ -289,7 +289,7 @@ impl gather_loan_ctxt {\n                         if self.tcx().sess.borrowck_note_loan() {\n                             self.bccx.span_note(\n                                 cmt.span,\n-                                fmt!{\"immutable loan required\"});\n+                                fmt!(\"immutable loan required\"));\n                         }\n                     } else {\n                         self.bccx.loaned_paths_same += 1;\n@@ -343,7 +343,7 @@ impl gather_loan_ctxt {\n                     if self.tcx().sess.borrowck_note_pure() {\n                         self.bccx.span_note(\n                             cmt.span,\n-                            fmt!{\"purity required\"});\n+                            fmt!(\"purity required\"));\n                     }\n                   }\n                   _ => {"}, {"sha": "07d1a00d61d31a2edda0b47dd25347ecc2af331e", "filename": "src/rustc/middle/borrowck/loan.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Fborrowck%2Floan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Fborrowck%2Floan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Floan.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -57,9 +57,9 @@ impl loan_ctxt {\n     }\n \n     fn loan(cmt: cmt, req_mutbl: ast::mutability) -> bckres<()> {\n-        debug!{\"loan(%s, %s)\",\n+        debug!(\"loan(%s, %s)\",\n                self.bccx.cmt_to_repr(cmt),\n-               self.bccx.mut_to_str(req_mutbl)};\n+               self.bccx.mut_to_str(req_mutbl));\n         let _i = indenter();\n \n         // see stable() above; should only be called when `cmt` is lendable"}, {"sha": "4aca2856f691639a181c5a34ae90af0a38765800", "filename": "src/rustc/middle/borrowck/preserve.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fpreserve.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -58,9 +58,9 @@ priv impl &preserve_ctxt {\n     fn tcx() -> ty::ctxt { self.bccx.tcx }\n \n     fn preserve(cmt: cmt) -> bckres<preserve_condition> {\n-        debug!{\"preserve(cmt=%s, root_ub=%?, root_managed_data=%b)\",\n+        debug!(\"preserve(cmt=%s, root_ub=%?, root_managed_data=%b)\",\n                self.bccx.cmt_to_repr(cmt), self.root_ub,\n-               self.root_managed_data};\n+               self.root_managed_data);\n         let _i = indenter();\n \n         match cmt.cat {\n@@ -155,7 +155,7 @@ priv impl &preserve_ctxt {\n             // otherwise we have no guarantee the pointer will stay\n             // live, so we must root the pointer (i.e., inc the ref\n             // count) for the duration of the loan.\n-            debug!{\"base.mutbl = %?\", self.bccx.mut_to_str(base.mutbl)};\n+            debug!(\"base.mutbl = %?\", self.bccx.mut_to_str(base.mutbl));\n             if base.mutbl == m_imm {\n                 let non_rooting_ctxt =\n                     preserve_ctxt({root_managed_data: false with **self});\n@@ -164,12 +164,12 @@ priv impl &preserve_ctxt {\n                     ok(pc_ok)\n                   }\n                   ok(pc_if_pure(_)) => {\n-                    debug!{\"must root @T, otherwise purity req'd\"};\n+                    debug!(\"must root @T, otherwise purity req'd\");\n                     self.attempt_root(cmt, base, derefs)\n                   }\n                   err(e) => {\n-                    debug!{\"must root @T, err: %s\",\n-                           self.bccx.bckerr_code_to_str(e.code)};\n+                    debug!(\"must root @T, err: %s\",\n+                           self.bccx.bckerr_code_to_str(e.code));\n                     self.attempt_root(cmt, base, derefs)\n                   }\n                 }"}, {"sha": "9bc5955a6d966ee08cefa01cfb706b77a08ff034", "filename": "src/rustc/middle/capture.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Fcapture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Fcapture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcapture.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -43,16 +43,16 @@ fn check_capture_clause(tcx: ty::ctxt,\n         if !vec::any(*freevars, |fv| fv.def == cap_def ) {\n             tcx.sess.span_warn(\n                 cap_item.span,\n-                fmt!{\"captured variable `%s` not used in closure\",\n-                     tcx.sess.str_of(cap_item.name)});\n+                fmt!(\"captured variable `%s` not used in closure\",\n+                     tcx.sess.str_of(cap_item.name)));\n         }\n \n         let cap_def_id = ast_util::def_id_of_def(cap_def).node;\n         if !seen_defs.insert(cap_def_id, ()) {\n             tcx.sess.span_err(\n                 cap_item.span,\n-                fmt!{\"variable `%s` captured more than once\",\n-                     tcx.sess.str_of(cap_item.name)});\n+                fmt!(\"variable `%s` captured more than once\",\n+                     tcx.sess.str_of(cap_item.name)));\n         }\n     }\n }\n@@ -67,8 +67,8 @@ fn compute_capture_vars(tcx: ty::ctxt,\n     // first add entries for anything explicitly named in the cap clause\n \n     for (*cap_clause).each |cap_item| {\n-        debug!{\"Doing capture var: %s (%?)\",\n-               tcx.sess.str_of(cap_item.name), cap_item.id};\n+        debug!(\"Doing capture var: %s (%?)\",\n+               tcx.sess.str_of(cap_item.name), cap_item.id);\n \n         let cap_def = tcx.def_map.get(cap_item.id);\n         let cap_def_id = ast_util::def_id_of_def(cap_def).node;"}, {"sha": "35e0ae24065f9d54d4d1e3dc8a194130890a16e8", "filename": "src/rustc/middle/kind.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fkind.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -214,7 +214,7 @@ fn check_block(b: blk, cx: ctx, v: visit::vt<ctx>) {\n }\n \n fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n-    debug!{\"kind::check_expr(%s)\", expr_to_str(e, cx.tcx.sess.intr())};\n+    debug!(\"kind::check_expr(%s)\", expr_to_str(e, cx.tcx.sess.intr()));\n \n     // Handle any kind bounds on type parameters\n     do option::iter(cx.tcx.node_type_substs.find(e.id)) |ts| {\n@@ -433,7 +433,7 @@ fn check_imm_free_var(cx: ctx, def: def, sp: span) {\n       _ => {\n         cx.tcx.sess.span_bug(\n             sp,\n-            fmt!{\"unknown def for free variable: %?\", def});\n+            fmt!(\"unknown def for free variable: %?\", def));\n       }\n     }\n }\n@@ -524,7 +524,7 @@ fn check_cast_for_escaping_regions(\n       some(ty::re_bound(*)) | some(ty::re_var(*)) => {\n         cx.tcx.sess.span_bug(\n             source.span,\n-            fmt!{\"bad region found in kind: %?\", target_substs.self_r});\n+            fmt!(\"bad region found in kind: %?\", target_substs.self_r));\n       }\n     }\n "}, {"sha": "f85dc4c73245531f9e309175cc6d30cd2ac81c6c", "filename": "src/rustc/middle/lang_items.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flang_items.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -126,8 +126,8 @@ struct LanguageItemCollector {\n                     some(original_def_id)\n                             if original_def_id != item_def_id => {\n \n-                        self.session.err(fmt!{\"duplicate entry for `%s`\",\n-                                              value});\n+                        self.session.err(fmt!(\"duplicate entry for `%s`\",\n+                                              value));\n                     }\n                     some(_) | none => {\n                         // OK.\n@@ -185,7 +185,7 @@ struct LanguageItemCollector {\n         for self.item_refs.each |key, item_ref| {\n             match copy *item_ref {\n                 none => {\n-                    self.session.err(fmt!{\"no item found for `%s`\", key});\n+                    self.session.err(fmt!(\"no item found for `%s`\", key));\n                 }\n                 some(did) => {\n                     // OK."}, {"sha": "1137ec47cdde0fd36b03276eb6e75afa45b725ea", "filename": "src/rustc/middle/lint.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flint.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -251,8 +251,8 @@ impl ctxt {\n                 self.span_lint(\n                     new_ctxt.get_level(unrecognized_lint),\n                     meta.span,\n-                    fmt!{\"unknown `%s` attribute: `%s`\",\n-                         level_to_str(level), lintname});\n+                    fmt!(\"unknown `%s` attribute: `%s`\",\n+                         level_to_str(level), lintname));\n               }\n               some(lint) => {\n \n@@ -261,9 +261,9 @@ impl ctxt {\n                     self.span_lint(\n                         forbid,\n                         meta.span,\n-                        fmt!{\"%s(%s) overruled by outer forbid(%s)\",\n+                        fmt!(\"%s(%s) overruled by outer forbid(%s)\",\n                              level_to_str(level),\n-                             lintname, lintname});\n+                             lintname, lintname));\n                 }\n \n                 // we do multiple unneeded copies of the\n@@ -486,7 +486,7 @@ fn check_item_non_camel_case_types(cx: ty::ctxt, it: @ast::item) {\n }\n \n fn check_pat(tcx: ty::ctxt, pat: @ast::pat) {\n-    debug!{\"lint check_pat pat=%s\", pat_to_str(pat, tcx.sess.intr())};\n+    debug!(\"lint check_pat pat=%s\", pat_to_str(pat, tcx.sess.intr()));\n \n     do pat_bindings(tcx.def_map, pat) |binding_mode, id, span, path| {\n         match binding_mode {\n@@ -498,8 +498,8 @@ fn check_pat(tcx: ty::ctxt, pat: @ast::pat) {\n                 tcx.sess.span_lint(\n                     deprecated_pattern, id, id,\n                     span,\n-                    fmt!{\"binding `%s` should use ref or copy mode\",\n-                         tcx.sess.str_of(path_to_ident(path))});\n+                    fmt!(\"binding `%s` should use ref or copy mode\",\n+                         tcx.sess.str_of(path_to_ident(path))));\n             }\n           }\n         }\n@@ -508,7 +508,7 @@ fn check_pat(tcx: ty::ctxt, pat: @ast::pat) {\n \n fn check_fn(tcx: ty::ctxt, fk: visit::fn_kind, decl: ast::fn_decl,\n             _body: ast::blk, span: span, id: ast::node_id) {\n-    debug!{\"lint check_fn fk=%? id=%?\", fk, id};\n+    debug!(\"lint check_fn fk=%? id=%?\", fk, id);\n \n     // don't complain about blocks, since they tend to get their modes\n     // specified from the outside\n@@ -523,10 +523,10 @@ fn check_fn(tcx: ty::ctxt, fk: visit::fn_kind, decl: ast::fn_decl,\n         let mut counter = 0;\n         do vec::iter2(fn_ty.inputs, decl.inputs) |arg_ty, arg_ast| {\n             counter += 1;\n-            debug!{\"arg %d, ty=%s, mode=%s\",\n+            debug!(\"arg %d, ty=%s, mode=%s\",\n                    counter,\n                    ty_to_str(tcx, arg_ty.ty),\n-                   mode_to_str(arg_ast.mode)};\n+                   mode_to_str(arg_ast.mode));\n             match arg_ast.mode {\n               ast::expl(ast::by_copy) => {\n                 /* always allow by-copy */\n@@ -536,7 +536,7 @@ fn check_fn(tcx: ty::ctxt, fk: visit::fn_kind, decl: ast::fn_decl,\n                 tcx.sess.span_lint(\n                     deprecated_mode, id, id,\n                     span,\n-                    fmt!{\"argument %d uses an explicit mode\", counter});\n+                    fmt!(\"argument %d uses an explicit mode\", counter));\n               }\n \n               ast::infer(_) => {\n@@ -545,9 +545,9 @@ fn check_fn(tcx: ty::ctxt, fk: visit::fn_kind, decl: ast::fn_decl,\n                     tcx.sess.span_lint(\n                         deprecated_mode, id, id,\n                         span,\n-                        fmt!{\"argument %d uses the default mode \\\n+                        fmt!(\"argument %d uses the default mode \\\n                               but shouldn't\",\n-                             counter});\n+                             counter));\n                 }\n               }\n             }"}, {"sha": "2a0e6799574cbcd9ef7446890d97bc3043a39b15", "filename": "src/rustc/middle/liveness.rs", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fliveness.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -153,11 +153,11 @@ fn check_crate(tcx: ty::ctxt,\n }\n \n impl live_node: to_str::ToStr {\n-    fn to_str() -> ~str { fmt!{\"ln(%u)\", *self} }\n+    fn to_str() -> ~str { fmt!(\"ln(%u)\", *self) }\n }\n \n impl variable: to_str::ToStr {\n-    fn to_str() -> ~str { fmt!{\"v(%u)\", *self} }\n+    fn to_str() -> ~str { fmt!(\"v(%u)\", *self) }\n }\n \n // ______________________________________________________________________\n@@ -243,7 +243,7 @@ struct ir_maps {\n         vec::push(self.lnks, lnk);\n         self.num_live_nodes += 1u;\n \n-        debug!{\"%s is of kind %?\", ln.to_str(), lnk};\n+        debug!(\"%s is of kind %?\", ln.to_str(), lnk);\n \n         ln\n     }\n@@ -252,7 +252,7 @@ struct ir_maps {\n         let ln = self.add_live_node(lnk);\n         self.live_node_map.insert(node_id, ln);\n \n-        debug!{\"%s is node %d\", ln.to_str(), node_id};\n+        debug!(\"%s is node %d\", ln.to_str(), node_id);\n     }\n \n     fn add_variable(vk: var_kind) -> variable {\n@@ -271,7 +271,7 @@ struct ir_maps {\n           }\n         }\n \n-        debug!{\"%s is %?\", v.to_str(), vk};\n+        debug!(\"%s is %?\", v.to_str(), vk);\n \n         v\n     }\n@@ -281,7 +281,7 @@ struct ir_maps {\n           some(var) => var,\n           none => {\n             self.tcx.sess.span_bug(\n-                span, fmt!{\"No variable registered for id %d\", node_id});\n+                span, fmt!(\"No variable registered for id %d\", node_id));\n           }\n         }\n     }\n@@ -314,7 +314,7 @@ struct ir_maps {\n \n     fn add_last_use(expr_id: node_id, var: variable) {\n         let vk = self.var_kinds[*var];\n-        debug!{\"Node %d is a last use of variable %?\", expr_id, vk};\n+        debug!(\"Node %d is a last use of variable %?\", expr_id, vk);\n         match vk {\n           vk_arg(id, name, by_move) |\n           vk_arg(id, name, by_copy) |\n@@ -332,25 +332,25 @@ struct ir_maps {\n           }\n           vk_arg(_, _, by_ref) | vk_arg(_, _, by_mutbl_ref) |\n           vk_arg(_, _, by_val) | vk_self | vk_field(_) | vk_implicit_ret => {\n-            debug!{\"--but it is not owned\"};\n+            debug!(\"--but it is not owned\");\n           }\n         }\n     }\n }\n \n fn visit_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n             sp: span, id: node_id, &&self: @ir_maps, v: vt<@ir_maps>) {\n-    debug!{\"visit_fn: id=%d\", id};\n+    debug!(\"visit_fn: id=%d\", id);\n     let _i = util::common::indenter();\n \n     // swap in a new set of IR maps for this function body:\n     let fn_maps = @ir_maps(self.tcx, self.method_map,\n                            self.last_use_map);\n \n-    debug!{\"creating fn_maps: %x\", ptr::addr_of(*fn_maps) as uint};\n+    debug!(\"creating fn_maps: %x\", ptr::addr_of(*fn_maps) as uint);\n \n     for decl.inputs.each |arg| {\n-        debug!{\"adding argument %d\", arg.id};\n+        debug!(\"adding argument %d\", arg.id);\n         let mode = ty::resolved_mode(self.tcx, arg.mode);\n         (*fn_maps).add_variable(vk_arg(arg.id, arg.ident, mode));\n     };\n@@ -405,7 +405,7 @@ fn add_class_fields(self: @ir_maps, did: def_id) {\n fn visit_local(local: @local, &&self: @ir_maps, vt: vt<@ir_maps>) {\n     let def_map = self.tcx.def_map;\n     do pat_util::pat_bindings(def_map, local.node.pat) |_bm, p_id, sp, path| {\n-        debug!{\"adding local variable %d\", p_id};\n+        debug!(\"adding local variable %d\", p_id);\n         let name = ast_util::path_to_ident(path);\n         (*self).add_live_node_for_node(p_id, lnk_vdef(sp));\n         (*self).add_variable(vk_local(p_id, name));\n@@ -418,7 +418,7 @@ fn visit_expr(expr: @expr, &&self: @ir_maps, vt: vt<@ir_maps>) {\n       // live nodes required for uses or definitions of variables:\n       expr_path(_) => {\n         let def = self.tcx.def_map.get(expr.id);\n-        debug!{\"expr %d: path that leads to %?\", expr.id, def};\n+        debug!(\"expr %d: path that leads to %?\", expr.id, def);\n         if relevant_def(def).is_some() {\n             (*self).add_live_node_for_node(expr.id, lnk_expr(expr.span));\n         }\n@@ -541,8 +541,8 @@ struct liveness {\n             // code have to agree about which AST nodes are worth\n             // creating liveness nodes for.\n             self.tcx.sess.span_bug(\n-                span, fmt!{\"No live node registered for node %d\",\n-                           node_id});\n+                span, fmt!(\"No live node registered for node %d\",\n+                           node_id));\n           }\n         }\n     }\n@@ -665,7 +665,7 @@ struct liveness {\n             wr.write_str(~\"[ln(\");\n             wr.write_uint(*ln);\n             wr.write_str(~\") of kind \");\n-            wr.write_str(fmt!{\"%?\", copy self.ir.lnks[*ln]});\n+            wr.write_str(fmt!(\"%?\", copy self.ir.lnks[*ln]));\n             wr.write_str(~\" reads\");\n             self.write_vars(wr, ln, |idx| self.users[idx].reader );\n             wr.write_str(~\"  writes\");\n@@ -696,8 +696,8 @@ struct liveness {\n         self.indices2(ln, succ_ln, |idx, succ_idx| {\n             self.users[idx] = self.users[succ_idx]\n         });\n-        debug!{\"init_from_succ(ln=%s, succ=%s)\",\n-               self.ln_str(ln), self.ln_str(succ_ln)};\n+        debug!(\"init_from_succ(ln=%s, succ=%s)\",\n+               self.ln_str(ln), self.ln_str(succ_ln));\n     }\n \n     fn merge_from_succ(ln: live_node, succ_ln: live_node,\n@@ -716,8 +716,8 @@ struct liveness {\n             }\n         }\n \n-        debug!{\"merge_from_succ(ln=%s, succ=%s, first_merge=%b, changed=%b)\",\n-               ln.to_str(), self.ln_str(succ_ln), first_merge, changed};\n+        debug!(\"merge_from_succ(ln=%s, succ=%s, first_merge=%b, changed=%b)\",\n+               ln.to_str(), self.ln_str(succ_ln), first_merge, changed);\n         return changed;\n \n         fn copy_if_invalid(src: live_node, &dst: live_node) -> bool {\n@@ -739,8 +739,8 @@ struct liveness {\n         self.users[idx].reader = invalid_node();\n         self.users[idx].writer = invalid_node();\n \n-        debug!{\"%s defines %s (idx=%u): %s\", writer.to_str(), var.to_str(),\n-               idx, self.ln_str(writer)};\n+        debug!(\"%s defines %s (idx=%u): %s\", writer.to_str(), var.to_str(),\n+               idx, self.ln_str(writer));\n     }\n \n     // Either read, write, or both depending on the acc bitset\n@@ -763,8 +763,8 @@ struct liveness {\n             self.users[idx].used = true;\n         }\n \n-        debug!{\"%s accesses[%x] %s: %s\",\n-               ln.to_str(), acc, var.to_str(), self.ln_str(ln)};\n+        debug!(\"%s accesses[%x] %s: %s\",\n+               ln.to_str(), acc, var.to_str(), self.ln_str(ln));\n     }\n \n     // _______________________________________________________________________\n@@ -779,14 +779,14 @@ struct liveness {\n             });\n \n         // hack to skip the loop unless #debug is enabled:\n-        debug!{\"^^ liveness computation results for body %d (entry=%s)\",\n+        debug!(\"^^ liveness computation results for body %d (entry=%s)\",\n                {\n                    for uint::range(0u, self.ir.num_live_nodes) |ln_idx| {\n                        #debug[\"%s\", self.ln_str(live_node(ln_idx))];\n                    }\n                    body.node.id\n                },\n-               entry_ln.to_str()};\n+               entry_ln.to_str());\n \n         entry_ln\n     }\n@@ -1372,7 +1372,7 @@ fn check_local(local: @local, &&self: @liveness, vt: vt<@liveness>) {\n         // No initializer: the variable might be unused; if not, it\n         // should not be live at this point.\n \n-        debug!{\"check_local() with no initializer\"};\n+        debug!(\"check_local() with no initializer\");\n         do (*self).pat_bindings(local.node.pat) |ln, var, sp| {\n             if !self.warn_about_unused(sp, ln, var) {\n                 match (*self).live_on_exit(ln, var) {\n@@ -1492,8 +1492,8 @@ impl @liveness {\n               none => { /* ok */ }\n               some(lnk_exit) => {\n                 self.tcx.sess.span_err(\n-                    sp, fmt!{\"field `self.%s` is never initialized\",\n-                             self.tcx.sess.str_of(nm)});\n+                    sp, fmt!(\"field `self.%s` is never initialized\",\n+                             self.tcx.sess.str_of(nm)));\n               }\n               some(lnk) => {\n                 self.report_illegal_read(\n@@ -1531,8 +1531,8 @@ impl @liveness {\n     }\n \n     fn check_move_from_var(span: span, ln: live_node, var: variable) {\n-        debug!{\"check_move_from_var(%s, %s)\",\n-               ln.to_str(), var.to_str()};\n+        debug!(\"check_move_from_var(%s, %s)\",\n+               ln.to_str(), var.to_str());\n \n         match (*self).live_on_exit(ln, var) {\n           none => {}\n@@ -1548,8 +1548,8 @@ impl @liveness {\n     }\n \n     fn check_move_from_expr(expr: @expr, vt: vt<@liveness>) {\n-        debug!{\"check_move_from_expr(node %d: %s)\",\n-               expr.id, expr_to_str(expr, self.tcx.sess.intr())};\n+        debug!(\"check_move_from_expr(node %d: %s)\",\n+               expr.id, expr_to_str(expr, self.tcx.sess.intr()));\n \n         if self.ir.method_map.contains_key(expr.id) {\n             // actually an rvalue, since this calls a method\n@@ -1645,7 +1645,7 @@ impl @liveness {\n           some(lnk) => {\n             self.tcx.sess.span_bug(\n                 orig_span,\n-                fmt!{\"illegal writer: %?\", lnk});\n+                fmt!(\"illegal writer: %?\", lnk));\n           }\n           none => {}\n         }\n@@ -1664,15 +1664,15 @@ impl @liveness {\n               vk_arg(_, name, _) => {\n                 self.tcx.sess.span_err(\n                     move_span,\n-                    fmt!{\"illegal move from argument `%s`, which is not \\\n-                          copy or move mode\", self.tcx.sess.str_of(name)});\n+                    fmt!(\"illegal move from argument `%s`, which is not \\\n+                          copy or move mode\", self.tcx.sess.str_of(name)));\n                 return;\n               }\n               vk_field(name) => {\n                 self.tcx.sess.span_err(\n                     move_span,\n-                    fmt!{\"illegal move from field `%s`\",\n-                         self.tcx.sess.str_of(name)});\n+                    fmt!(\"illegal move from field `%s`\",\n+                         self.tcx.sess.str_of(name)));\n                 return;\n               }\n               vk_self => {\n@@ -1685,8 +1685,8 @@ impl @liveness {\n               vk_local(*) | vk_implicit_ret => {\n                 self.tcx.sess.span_bug(\n                     move_span,\n-                    fmt!{\"illegal reader (%?) for `%?`\",\n-                         lnk, vk});\n+                    fmt!(\"illegal reader (%?) for `%?`\",\n+                         lnk, vk));\n               }\n             }\n         }\n@@ -1713,18 +1713,18 @@ impl @liveness {\n           lnk_freevar(span) => {\n             self.tcx.sess.span_err(\n                 span,\n-                fmt!{\"capture of %s: `%s`\", msg, name});\n+                fmt!(\"capture of %s: `%s`\", msg, name));\n           }\n           lnk_expr(span) => {\n             self.tcx.sess.span_err(\n                 span,\n-                fmt!{\"use of %s: `%s`\", msg, name});\n+                fmt!(\"use of %s: `%s`\", msg, name));\n           }\n           lnk_exit |\n           lnk_vdef(_) => {\n             self.tcx.sess.span_bug(\n                 chk_span,\n-                fmt!{\"illegal reader: %?\", lnk});\n+                fmt!(\"illegal reader: %?\", lnk));\n           }\n         }\n     }\n@@ -1781,11 +1781,11 @@ impl @liveness {\n \n                 if is_assigned {\n                     self.tcx.sess.span_warn(\n-                        sp, fmt!{\"variable `%s` is assigned to, \\\n-                                  but never used\", name});\n+                        sp, fmt!(\"variable `%s` is assigned to, \\\n+                                  but never used\", name));\n                 } else {\n                     self.tcx.sess.span_warn(\n-                        sp, fmt!{\"unused variable: `%s`\", name});\n+                        sp, fmt!(\"unused variable: `%s`\", name));\n                 }\n             }\n             return true;\n@@ -1798,7 +1798,7 @@ impl @liveness {\n             for self.should_warn(var).each |name| {\n                 self.tcx.sess.span_warn(\n                     sp,\n-                    fmt!{\"value assigned to `%s` is never read\", name});\n+                    fmt!(\"value assigned to `%s` is never read\", name));\n             }\n         }\n     }"}, {"sha": "7aa4f186d6802f7e275dc1c5d435f11338c5a442", "filename": "src/rustc/middle/mem_categorization.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fmem_categorization.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -149,8 +149,8 @@ fn deref_kind(tcx: ty::ctxt, t: ty::t) -> deref_kind {\n       some(k) => k,\n       none => {\n         tcx.sess.bug(\n-            fmt!{\"deref_cat() invoked on non-derefable type %s\",\n-                 ty_to_str(tcx, t)});\n+            fmt!(\"deref_cat() invoked on non-derefable type %s\",\n+                 ty_to_str(tcx, t)));\n       }\n     }\n }\n@@ -262,8 +262,8 @@ impl &mem_categorization_ctxt {\n     }\n \n     fn cat_expr(expr: @ast::expr) -> cmt {\n-        debug!{\"cat_expr: id=%d expr=%s\",\n-               expr.id, pprust::expr_to_str(expr, self.tcx.sess.intr())};\n+        debug!(\"cat_expr: id=%d expr=%s\",\n+               expr.id, pprust::expr_to_str(expr, self.tcx.sess.intr()));\n \n         let tcx = self.tcx;\n         let expr_ty = tcx.ty(expr);\n@@ -279,8 +279,8 @@ impl &mem_categorization_ctxt {\n               none => {\n                 tcx.sess.span_bug(\n                     e_base.span,\n-                    fmt!{\"Explicit deref of non-derefable type `%s`\",\n-                         ty_to_str(tcx, tcx.ty(e_base))});\n+                    fmt!(\"Explicit deref of non-derefable type `%s`\",\n+                         ty_to_str(tcx, tcx.ty(e_base))));\n               }\n             }\n           }\n@@ -468,9 +468,9 @@ impl &mem_categorization_ctxt {\n           none => {\n             self.tcx.sess.span_bug(\n                 node.span(),\n-                fmt!{\"Cannot find field `%s` in type `%s`\",\n+                fmt!(\"Cannot find field `%s` in type `%s`\",\n                      self.tcx.sess.str_of(f_name),\n-                     ty_to_str(self.tcx, base_cmt.ty)});\n+                     ty_to_str(self.tcx, base_cmt.ty)));\n           }\n         };\n         let m = self.inherited_mutability(base_cmt.mutbl, f_mutbl);\n@@ -533,8 +533,8 @@ impl &mem_categorization_ctxt {\n           none => {\n             self.tcx.sess.span_bug(\n                 expr.span,\n-                fmt!{\"Explicit index of non-index type `%s`\",\n-                     ty_to_str(self.tcx, base_cmt.ty)});\n+                fmt!(\"Explicit index of non-index type `%s`\",\n+                     ty_to_str(self.tcx, base_cmt.ty)));\n           }\n         };\n \n@@ -655,9 +655,9 @@ impl &mem_categorization_ctxt {\n \n         let _i = indenter();\n         let tcx = self.tcx;\n-        debug!{\"cat_pattern: id=%d pat=%s cmt=%s\",\n+        debug!(\"cat_pattern: id=%d pat=%s cmt=%s\",\n                pat.id, pprust::pat_to_str(pat, tcx.sess.intr()),\n-               self.cmt_to_repr(cmt)};\n+               self.cmt_to_repr(cmt));\n \n         match pat.node {\n           ast::pat_wild => {\n@@ -672,7 +672,7 @@ impl &mem_categorization_ctxt {\n             let enum_did = match self.tcx.def_map.find(pat.id) {\n               some(ast::def_variant(enum_did, _)) => enum_did,\n               e => tcx.sess.span_bug(pat.span,\n-                                     fmt!{\"resolved to %?, not variant\", e})\n+                                     fmt!(\"resolved to %?, not variant\", e))\n             };\n \n             for subpats.each |subpat| {\n@@ -737,15 +737,15 @@ impl &mem_categorization_ctxt {\n           cat_special(sk_heap_upvar) => ~\"heap-upvar\",\n           cat_stack_upvar(_) => ~\"stack-upvar\",\n           cat_rvalue => ~\"rvalue\",\n-          cat_local(node_id) => fmt!{\"local(%d)\", node_id},\n-          cat_binding(node_id) => fmt!{\"binding(%d)\", node_id},\n-          cat_arg(node_id) => fmt!{\"arg(%d)\", node_id},\n+          cat_local(node_id) => fmt!(\"local(%d)\", node_id),\n+          cat_binding(node_id) => fmt!(\"binding(%d)\", node_id),\n+          cat_arg(node_id) => fmt!(\"arg(%d)\", node_id),\n           cat_deref(cmt, derefs, ptr) => {\n-            fmt!{\"%s->(%s, %u)\", self.cat_to_repr(cmt.cat),\n-                 self.ptr_sigil(ptr), derefs}\n+            fmt!(\"%s->(%s, %u)\", self.cat_to_repr(cmt.cat),\n+                 self.ptr_sigil(ptr), derefs)\n           }\n           cat_comp(cmt, comp) => {\n-            fmt!{\"%s.%s\", self.cat_to_repr(cmt.cat), self.comp_to_repr(comp)}\n+            fmt!(\"%s.%s\", self.cat_to_repr(cmt.cat), self.comp_to_repr(comp))\n           }\n           cat_discr(cmt, _) => self.cat_to_repr(cmt.cat)\n         }\n@@ -780,29 +780,29 @@ impl &mem_categorization_ctxt {\n     fn lp_to_str(lp: @loan_path) -> ~str {\n         match *lp {\n           lp_local(node_id) => {\n-            fmt!{\"local(%d)\", node_id}\n+            fmt!(\"local(%d)\", node_id)\n           }\n           lp_arg(node_id) => {\n-            fmt!{\"arg(%d)\", node_id}\n+            fmt!(\"arg(%d)\", node_id)\n           }\n           lp_deref(lp, ptr) => {\n-            fmt!{\"%s->(%s)\", self.lp_to_str(lp),\n-                 self.ptr_sigil(ptr)}\n+            fmt!(\"%s->(%s)\", self.lp_to_str(lp),\n+                 self.ptr_sigil(ptr))\n           }\n           lp_comp(lp, comp) => {\n-            fmt!{\"%s.%s\", self.lp_to_str(lp),\n-                 self.comp_to_repr(comp)}\n+            fmt!(\"%s.%s\", self.lp_to_str(lp),\n+                 self.comp_to_repr(comp))\n           }\n         }\n     }\n \n     fn cmt_to_repr(cmt: cmt) -> ~str {\n-        fmt!{\"{%s id:%d m:%s lp:%s ty:%s}\",\n+        fmt!(\"{%s id:%d m:%s lp:%s ty:%s}\",\n              self.cat_to_repr(cmt.cat),\n              cmt.id,\n              self.mut_to_str(cmt.mutbl),\n              cmt.lp.map_default(~\"none\", |p| self.lp_to_str(p) ),\n-             ty_to_str(self.tcx, cmt.ty)}\n+             ty_to_str(self.tcx, cmt.ty))\n     }\n \n     fn cmt_to_str(cmt: cmt) -> ~str {\n@@ -818,8 +818,8 @@ impl &mem_categorization_ctxt {\n           cat_local(_) => mut_str + ~\" local variable\",\n           cat_binding(_) => ~\"pattern binding\",\n           cat_arg(_) => ~\"argument\",\n-          cat_deref(_, _, pk) => fmt!{\"dereference of %s %s pointer\",\n-                                      mut_str, self.ptr_sigil(pk)},\n+          cat_deref(_, _, pk) => fmt!(\"dereference of %s %s pointer\",\n+                                      mut_str, self.ptr_sigil(pk)),\n           cat_stack_upvar(_) => {\n             ~\"captured outer \" + mut_str + ~\" variable in a stack closure\"\n           }"}, {"sha": "01215eb5396da9c3551cb872ddfb13983908cbb2", "filename": "src/rustc/middle/region.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fregion.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -196,7 +196,7 @@ fn parent_id(cx: ctxt, span: span) -> ast::node_id {\n /// Records the current parent (if any) as the parent of `child_id`.\n fn record_parent(cx: ctxt, child_id: ast::node_id) {\n     for cx.parent.each |parent_id| {\n-        debug!{\"parent of node %d is node %d\", child_id, parent_id};\n+        debug!(\"parent of node %d is node %d\", child_id, parent_id);\n         cx.region_map.insert(child_id, parent_id);\n     }\n }\n@@ -255,13 +255,13 @@ fn resolve_expr(expr: @ast::expr, cx: ctxt, visitor: visit::vt<ctxt>) {\n     let mut new_cx = cx;\n     match expr.node {\n       ast::expr_call(*) => {\n-        debug!{\"node %d: %s\", expr.id, pprust::expr_to_str(expr,\n-                                                           cx.sess.intr())};\n+        debug!(\"node %d: %s\", expr.id, pprust::expr_to_str(expr,\n+                                                           cx.sess.intr()));\n         new_cx.parent = some(expr.id);\n       }\n       ast::expr_match(subexpr, _, _) => {\n-        debug!{\"node %d: %s\", expr.id, pprust::expr_to_str(expr,\n-                                                           cx.sess.intr())};\n+        debug!(\"node %d: %s\", expr.id, pprust::expr_to_str(expr,\n+                                                           cx.sess.intr()));\n         new_cx.parent = some(expr.id);\n       }\n       ast::expr_fn(_, _, _, cap_clause) |\n@@ -314,9 +314,9 @@ fn resolve_fn(fk: visit::fn_kind, decl: ast::fn_decl, body: ast::blk,\n       }\n     };\n \n-    debug!{\"visiting fn with body %d. cx.parent: %? \\\n+    debug!(\"visiting fn with body %d. cx.parent: %? \\\n             fn_cx.parent: %?\",\n-           body.node.id, cx.parent, fn_cx.parent};\n+           body.node.id, cx.parent, fn_cx.parent);\n \n     for decl.inputs.each |input| {\n         cx.region_map.insert(input.id, body.node.id);\n@@ -441,10 +441,10 @@ impl determine_rp_ctxt {\n           some(v) => join_variance(v, variance)\n         };\n \n-        debug![\"add_rp() variance for %s: %? == %? ^ %?\",\n+        debug!(\"add_rp() variance for %s: %? == %? ^ %?\",\n                ast_map::node_id_to_str(self.ast_map, id,\n                                        self.sess.parse_sess.interner),\n-               joined_variance, old_variance, variance];\n+               joined_variance, old_variance, variance);\n \n         if some(joined_variance) != old_variance {\n             self.region_paramd_items.insert(id, joined_variance);\n@@ -458,13 +458,13 @@ impl determine_rp_ctxt {\n     /// contains a value of type `from`, so if `from` is\n     /// region-parameterized, so is the current item.\n     fn add_dep(from: ast::node_id) {\n-        debug![\"add dependency from %d -> %d (%s -> %s) with variance %?\",\n+        debug!(\"add dependency from %d -> %d (%s -> %s) with variance %?\",\n                from, self.item_id,\n                ast_map::node_id_to_str(self.ast_map, from,\n                                        self.sess.parse_sess.interner),\n                ast_map::node_id_to_str(self.ast_map, self.item_id,\n                                        self.sess.parse_sess.interner),\n-               copy self.ambient_variance];\n+               copy self.ambient_variance);\n         let vec = match self.dep_map.find(from) {\n             some(vec) => vec,\n             none => {\n@@ -525,7 +525,7 @@ impl determine_rp_ctxt {\n         let old_anon_implies_rp = self.anon_implies_rp;\n         self.item_id = item_id;\n         self.anon_implies_rp = anon_implies_rp;\n-        debug!{\"with_item_id(%d, %b)\", item_id, anon_implies_rp};\n+        debug!(\"with_item_id(%d, %b)\", item_id, anon_implies_rp);\n         let _i = util::common::indenter();\n         f();\n         self.item_id = old_item_id;\n@@ -590,8 +590,8 @@ fn determine_rp_in_ty(ty: @ast::ty,\n     // locations)\n     match ty.node {\n       ast::ty_rptr(r, _) => {\n-        debug![\"referenced rptr type %s\",\n-               pprust::ty_to_str(ty, cx.sess.intr())];\n+        debug!(\"referenced rptr type %s\",\n+               pprust::ty_to_str(ty, cx.sess.intr()));\n \n         if cx.region_is_relevant(r) {\n             cx.add_rp(cx.item_id, cx.add_variance(rv_contravariant))\n@@ -623,8 +623,8 @@ fn determine_rp_in_ty(ty: @ast::ty,\n                 match csearch::get_region_param(cstore, did) {\n                   none => {}\n                   some(variance) => {\n-                    debug![\"reference to external, rp'd type %s\",\n-                           pprust::ty_to_str(ty, cx.sess.intr())];\n+                    debug!(\"reference to external, rp'd type %s\",\n+                           pprust::ty_to_str(ty, cx.sess.intr()));\n                     cx.add_rp(cx.item_id, cx.add_variance(variance))\n                   }\n                 }\n@@ -743,7 +743,7 @@ fn determine_rp_in_crate(sess: session,\n     while cx.worklist.len() != 0 {\n         let c_id = cx.worklist.pop();\n         let c_variance = cx.region_paramd_items.get(c_id);\n-        debug![\"popped %d from worklist\", c_id];\n+        debug!(\"popped %d from worklist\", c_id);\n         match cx.dep_map.find(c_id) {\n           none => {}\n           some(deps) => {"}, {"sha": "68d2b1458291d7feda4bb1883b573c87a8dc1277", "filename": "src/rustc/middle/resolve3.rs", "status": "modified", "additions": 180, "deletions": 180, "changes": 360, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Fresolve3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Fresolve3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve3.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -1243,9 +1243,9 @@ struct Resolver {\n         if self.block_needs_anonymous_module(block) {\n             let block_id = block.node.id;\n \n-            debug!{\"(building reduced graph for block) creating a new \\\n+            debug!(\"(building reduced graph for block) creating a new \\\n                     anonymous module for block %d\",\n-                   block_id};\n+                   block_id);\n \n             let parent_module = self.get_module_from_parent(parent);\n             let new_module = @Module(BlockParentLink(parent_module, block_id),\n@@ -1414,8 +1414,8 @@ struct Resolver {\n                 // Define or reuse the module node.\n                 match child_name_bindings.module_def {\n                     NoModuleDef => {\n-                        debug!{\"(building reduced graph for external crate) \\\n-                                autovivifying %s\", ident_str};\n+                        debug!(\"(building reduced graph for external crate) \\\n+                                autovivifying %s\", ident_str);\n                         let parent_link = self.get_parent_link(new_parent,\n                                                                ident);\n                         (*child_name_bindings).define_module(parent_link,\n@@ -1445,12 +1445,12 @@ struct Resolver {\n                     // written, we can't process this impl now. We'll get it\n                     // later.\n \n-                    debug!{\"(building reduced graph for external crate) \\\n-                            ignoring impl %s\", final_ident_str};\n+                    debug!(\"(building reduced graph for external crate) \\\n+                            ignoring impl %s\", final_ident_str);\n                 }\n                 dl_field => {\n-                    debug!{\"(building reduced graph for external crate) \\\n-                            ignoring field %s\", final_ident_str};\n+                    debug!(\"(building reduced graph for external crate) \\\n+                            ignoring field %s\", final_ident_str);\n                 }\n             }\n         }\n@@ -1508,14 +1508,14 @@ struct Resolver {\n         let mut i = 0u;\n         let mut prev_unresolved_imports = 0u;\n         loop {\n-            debug!{\"(resolving imports) iteration %u, %u imports left\",\n-                   i, self.unresolved_imports};\n+            debug!(\"(resolving imports) iteration %u, %u imports left\",\n+                   i, self.unresolved_imports);\n \n             let module_root = (*self.graph_root).get_module();\n             self.resolve_imports_for_module_subtree(module_root);\n \n             if self.unresolved_imports == 0u {\n-                debug!{\"(resolving imports) success\"};\n+                debug!(\"(resolving imports) success\");\n                 break;\n             }\n \n@@ -1535,8 +1535,8 @@ struct Resolver {\n      * submodules.\n      */\n     fn resolve_imports_for_module_subtree(module_: @Module) {\n-        debug!{\"(resolving imports for module subtree) resolving %s\",\n-               self.module_to_str(module_)};\n+        debug!(\"(resolving imports for module subtree) resolving %s\",\n+               self.module_to_str(module_));\n         self.resolve_imports_for_module(module_);\n \n         for module_.children.each |_name, child_node| {\n@@ -1558,9 +1558,9 @@ struct Resolver {\n     /// Attempts to resolve imports for the given module only.\n     fn resolve_imports_for_module(module_: @Module) {\n         if (*module_).all_imports_resolved() {\n-            debug!{\"(resolving imports for module) all imports resolved for \\\n+            debug!(\"(resolving imports for module) all imports resolved for \\\n                    %s\",\n-                   self.module_to_str(module_)};\n+                   self.module_to_str(module_));\n             return;\n         }\n \n@@ -1616,10 +1616,10 @@ struct Resolver {\n         let mut resolution_result;\n         let module_path = import_directive.module_path;\n \n-        debug!{\"(resolving import for module) resolving import `%s::...` in \\\n+        debug!(\"(resolving import for module) resolving import `%s::...` in \\\n                 `%s`\",\n                self.atoms_to_str((*module_path).get()),\n-               self.module_to_str(module_)};\n+               self.module_to_str(module_));\n \n         // One-level renaming imports of the form `import foo = bar;` are\n         // handled specially.\n@@ -1700,16 +1700,16 @@ struct Resolver {\n                              target: Atom, source: Atom)\n                           -> ResolveResult<()> {\n \n-        debug!{\"(resolving single import) resolving `%s` = `%s::%s` from \\\n+        debug!(\"(resolving single import) resolving `%s` = `%s::%s` from \\\n                 `%s`\",\n                self.session.str_of(target),\n                self.module_to_str(containing_module),\n                self.session.str_of(source),\n-               self.module_to_str(module_)};\n+               self.module_to_str(module_));\n \n         if !self.name_is_exported(containing_module, source) {\n-            debug!{\"(resolving single import) name `%s` is unexported\",\n-                   self.session.str_of(source)};\n+            debug!(\"(resolving single import) name `%s` is unexported\",\n+                   self.session.str_of(source));\n             return Failed;\n         }\n \n@@ -1756,8 +1756,8 @@ struct Resolver {\n                 // able to resolve this import.\n \n                 if containing_module.glob_count > 0u {\n-                    debug!{\"(resolving single import) unresolved glob; \\\n-                            bailing out\"};\n+                    debug!(\"(resolving single import) unresolved glob; \\\n+                            bailing out\");\n                     return Indeterminate;\n                 }\n \n@@ -1820,8 +1820,8 @@ struct Resolver {\n                     }\n                     some(_) => {\n                         // The import is unresolved. Bail out.\n-                        debug!{\"(resolving single import) unresolved import; \\\n-                                bailing out\"};\n+                        debug!(\"(resolving single import) unresolved import; \\\n+                                bailing out\");\n                         return Indeterminate;\n                     }\n                 }\n@@ -1834,13 +1834,13 @@ struct Resolver {\n \n         match module_result {\n             BoundResult(target_module, name_bindings) => {\n-                debug!{\"(resolving single import) found module binding\"};\n+                debug!(\"(resolving single import) found module binding\");\n                 import_resolution.module_target =\n                     some(Target(target_module, name_bindings));\n             }\n             UnboundResult => {\n-                debug!{\"(resolving single import) didn't find module \\\n-                        binding\"};\n+                debug!(\"(resolving single import) didn't find module \\\n+                        binding\");\n             }\n             UnknownResult => {\n                 fail ~\"module result should be known at this point\";\n@@ -1880,7 +1880,7 @@ struct Resolver {\n         assert import_resolution.outstanding_references >= 1u;\n         import_resolution.outstanding_references -= 1u;\n \n-        debug!{\"(resolving single import) successfully resolved import\"};\n+        debug!(\"(resolving single import) successfully resolved import\");\n         return Success(());\n     }\n \n@@ -1902,8 +1902,8 @@ struct Resolver {\n         // (including globs).\n \n         if !(*containing_module).all_imports_resolved() {\n-            debug!{\"(resolving glob import) target module has unresolved \\\n-                    imports; bailing out\"};\n+            debug!(\"(resolving glob import) target module has unresolved \\\n+                    imports; bailing out\");\n             return Indeterminate;\n         }\n \n@@ -1914,15 +1914,15 @@ struct Resolver {\n                 |atom, target_import_resolution| {\n \n             if !self.name_is_exported(containing_module, atom) {\n-                debug!{\"(resolving glob import) name `%s` is unexported\",\n-                       self.session.str_of(atom)};\n+                debug!(\"(resolving glob import) name `%s` is unexported\",\n+                       self.session.str_of(atom));\n                 again;\n             }\n \n-            debug!{\"(resolving glob import) writing module resolution \\\n+            debug!(\"(resolving glob import) writing module resolution \\\n                     %? into `%s`\",\n                    is_none(target_import_resolution.module_target),\n-                   self.module_to_str(module_)};\n+                   self.module_to_str(module_));\n \n             // Here we merge two import resolutions.\n             match module_.import_resolutions.find(atom) {\n@@ -1978,8 +1978,8 @@ struct Resolver {\n         // Add all children from the containing module.\n         for containing_module.children.each |atom, name_bindings| {\n             if !self.name_is_exported(containing_module, atom) {\n-                debug!{\"(resolving glob import) name `%s` is unexported\",\n-                       self.session.str_of(atom)};\n+                debug!(\"(resolving glob import) name `%s` is unexported\",\n+                       self.session.str_of(atom));\n                 again;\n             }\n \n@@ -1997,31 +1997,31 @@ struct Resolver {\n             }\n \n \n-            debug!{\"(resolving glob import) writing resolution `%s` in `%s` \\\n+            debug!(\"(resolving glob import) writing resolution `%s` in `%s` \\\n                     to `%s`\",\n                    self.session.str_of(atom),\n                    self.module_to_str(containing_module),\n-                   self.module_to_str(module_)};\n+                   self.module_to_str(module_));\n \n             // Merge the child item into the import resolution.\n             if (*name_bindings).defined_in_namespace(ModuleNS) {\n-                debug!{\"(resolving glob import) ... for module target\"};\n+                debug!(\"(resolving glob import) ... for module target\");\n                 dest_import_resolution.module_target =\n                     some(Target(containing_module, name_bindings));\n             }\n             if (*name_bindings).defined_in_namespace(ValueNS) {\n-                debug!{\"(resolving glob import) ... for value target\"};\n+                debug!(\"(resolving glob import) ... for value target\");\n                 dest_import_resolution.value_target =\n                     some(Target(containing_module, name_bindings));\n             }\n             if (*name_bindings).defined_in_namespace(TypeNS) {\n-                debug!{\"(resolving glob import) ... for type target\"};\n+                debug!(\"(resolving glob import) ... for type target\");\n                 dest_import_resolution.type_target =\n                     some(Target(containing_module, name_bindings));\n             }\n         }\n \n-        debug!{\"(resolving glob import) successfully resolved import\"};\n+        debug!(\"(resolving glob import) successfully resolved import\");\n         return Success(());\n     }\n \n@@ -2050,19 +2050,19 @@ struct Resolver {\n                     return Failed;\n                 }\n                 Indeterminate => {\n-                    debug!{\"(resolving module path for import) module \\\n+                    debug!(\"(resolving module path for import) module \\\n                             resolution is indeterminate: %s\",\n-                            self.session.str_of(name)};\n+                            self.session.str_of(name));\n                     return Indeterminate;\n                 }\n                 Success(target) => {\n                     match target.bindings.module_def {\n                         NoModuleDef => {\n                             // Not a module.\n                             self.session.span_err(span,\n-                                                  fmt!{\"not a module: %s\",\n+                                                  fmt!(\"not a module: %s\",\n                                                        self.session.\n-                                                           str_of(name)});\n+                                                           str_of(name)));\n                             return Failed;\n                         }\n                         ModuleDef(module_) => {\n@@ -2091,10 +2091,10 @@ struct Resolver {\n         let module_path_len = (*module_path).len();\n         assert module_path_len > 0u;\n \n-        debug!{\"(resolving module path for import) processing `%s` rooted at \\\n+        debug!(\"(resolving module path for import) processing `%s` rooted at \\\n                `%s`\",\n                self.atoms_to_str((*module_path).get()),\n-               self.module_to_str(module_)};\n+               self.module_to_str(module_));\n \n         // The first element of the module path must be in the current scope\n         // chain.\n@@ -2107,8 +2107,8 @@ struct Resolver {\n                 return Failed;\n             }\n             Indeterminate => {\n-                debug!{\"(resolving module path for import) indeterminate; \\\n-                        bailing\"};\n+                debug!(\"(resolving module path for import) indeterminate; \\\n+                        bailing\");\n                 return Indeterminate;\n             }\n             Success(resulting_module) => {\n@@ -2128,11 +2128,11 @@ struct Resolver {\n                                      namespace: Namespace)\n                                   -> ResolveResult<Target> {\n \n-        debug!{\"(resolving item in lexical scope) resolving `%s` in \\\n+        debug!(\"(resolving item in lexical scope) resolving `%s` in \\\n                 namespace %? in `%s`\",\n                self.session.str_of(name),\n                namespace,\n-               self.module_to_str(module_)};\n+               self.module_to_str(module_));\n \n         // The current module node is handled specially. First, check for\n         // its immediate children.\n@@ -2159,9 +2159,9 @@ struct Resolver {\n                 match (*import_resolution).target_for_namespace(namespace) {\n                     none => {\n                         // Not found; continue.\n-                        debug!{\"(resolving item in lexical scope) found \\\n+                        debug!(\"(resolving item in lexical scope) found \\\n                                 import resolution, but not in namespace %?\",\n-                               namespace};\n+                               namespace);\n                     }\n                     some(target) => {\n                         import_resolution.used = true;\n@@ -2178,8 +2178,8 @@ struct Resolver {\n             match search_module.parent_link {\n                 NoParentLink => {\n                     // No more parents. This module was unresolved.\n-                    debug!{\"(resolving item in lexical scope) unresolved \\\n-                            module\"};\n+                    debug!(\"(resolving item in lexical scope) unresolved \\\n+                            module\");\n                     return Failed;\n                 }\n                 ModuleParentLink(parent_module_node, _) |\n@@ -2198,8 +2198,8 @@ struct Resolver {\n                     // We couldn't see through the higher scope because of an\n                     // unresolved import higher up. Bail.\n \n-                    debug!{\"(resolving item in lexical scope) indeterminate \\\n-                            higher scope; bailing\"};\n+                    debug!(\"(resolving item in lexical scope) indeterminate \\\n+                            higher scope; bailing\");\n                     return Indeterminate;\n                 }\n                 Success(target) => {\n@@ -2217,8 +2217,8 @@ struct Resolver {\n             Success(target) => {\n                 match target.bindings.module_def {\n                     NoModuleDef => {\n-                        error!{\"!!! (resolving module in lexical scope) module\n-                                wasn't actually a module!\"};\n+                        error!(\"!!! (resolving module in lexical scope) module\n+                                wasn't actually a module!\");\n                         return Failed;\n                     }\n                     ModuleDef(module_) => {\n@@ -2227,13 +2227,13 @@ struct Resolver {\n                 }\n             }\n             Indeterminate => {\n-                debug!{\"(resolving module in lexical scope) indeterminate; \\\n-                        bailing\"};\n+                debug!(\"(resolving module in lexical scope) indeterminate; \\\n+                        bailing\");\n                 return Indeterminate;\n             }\n             Failed => {\n-                debug!{\"(resolving module in lexical scope) failed to \\\n-                        resolve\"};\n+                debug!(\"(resolving module in lexical scope) failed to \\\n+                        resolve\");\n                 return Failed;\n             }\n         }\n@@ -2255,13 +2255,13 @@ struct Resolver {\n                               xray: XrayFlag)\n                            -> ResolveResult<Target> {\n \n-        debug!{\"(resolving name in module) resolving `%s` in `%s`\",\n+        debug!(\"(resolving name in module) resolving `%s` in `%s`\",\n                self.session.str_of(name),\n-               self.module_to_str(module_)};\n+               self.module_to_str(module_));\n \n         if xray == NoXray && !self.name_is_exported(module_, name) {\n-            debug!{\"(resolving name in module) name `%s` is unexported\",\n-                   self.session.str_of(name)};\n+            debug!(\"(resolving name in module) name `%s` is unexported\",\n+                   self.session.str_of(name));\n             return Failed;\n         }\n \n@@ -2270,7 +2270,7 @@ struct Resolver {\n             some(name_bindings)\n                     if (*name_bindings).defined_in_namespace(namespace) => {\n \n-                debug!{\"(resolving name in module) found node as child\"};\n+                debug!(\"(resolving name in module) found node as child\");\n                 return Success(Target(module_, name_bindings));\n             }\n             some(_) | none => {\n@@ -2282,28 +2282,28 @@ struct Resolver {\n         // we bail out; we don't know its imports yet.\n \n         if module_.glob_count > 0u {\n-            debug!{\"(resolving name in module) module has glob; bailing out\"};\n+            debug!(\"(resolving name in module) module has glob; bailing out\");\n             return Indeterminate;\n         }\n \n         // Otherwise, we check the list of resolved imports.\n         match module_.import_resolutions.find(name) {\n             some(import_resolution) => {\n                 if import_resolution.outstanding_references != 0u {\n-                    debug!{\"(resolving name in module) import unresolved; \\\n-                            bailing out\"};\n+                    debug!(\"(resolving name in module) import unresolved; \\\n+                            bailing out\");\n                     return Indeterminate;\n                 }\n \n                 match (*import_resolution).target_for_namespace(namespace) {\n                     none => {\n-                        debug!{\"(resolving name in module) name found, but \\\n+                        debug!(\"(resolving name in module) name found, but \\\n                                 not in namespace %?\",\n-                               namespace};\n+                               namespace);\n                     }\n                     some(target) => {\n-                        debug!{\"(resolving name in module) resolved to \\\n-                                import\"};\n+                        debug!(\"(resolving name in module) resolved to \\\n+                                import\");\n                         import_resolution.used = true;\n                         return Success(copy target);\n                     }\n@@ -2315,8 +2315,8 @@ struct Resolver {\n         }\n \n         // We're out of luck.\n-        debug!{\"(resolving name in module) failed to resolve %s\",\n-               self.session.str_of(name)};\n+        debug!(\"(resolving name in module) failed to resolve %s\",\n+               self.session.str_of(name));\n         return Failed;\n     }\n \n@@ -2341,81 +2341,81 @@ struct Resolver {\n             }\n         }\n \n-        debug!{\"(resolving one-level naming result) resolving import `%s` = \\\n+        debug!(\"(resolving one-level naming result) resolving import `%s` = \\\n                 `%s` in `%s`\",\n                 self.session.str_of(target_name),\n                 self.session.str_of(source_name),\n-                self.module_to_str(module_)};\n+                self.module_to_str(module_));\n \n         // Find the matching items in the lexical scope chain for every\n         // namespace. If any of them come back indeterminate, this entire\n         // import is indeterminate.\n \n         let mut module_result;\n-        debug!{\"(resolving one-level naming result) searching for module\"};\n+        debug!(\"(resolving one-level naming result) searching for module\");\n         match self.resolve_item_in_lexical_scope(module_,\n                                                source_name,\n                                                ModuleNS) {\n \n             Failed => {\n-                debug!{\"(resolving one-level renaming import) didn't find \\\n-                        module result\"};\n+                debug!(\"(resolving one-level renaming import) didn't find \\\n+                        module result\");\n                 module_result = none;\n             }\n             Indeterminate => {\n-                debug!{\"(resolving one-level renaming import) module result \\\n-                        is indeterminate; bailing\"};\n+                debug!(\"(resolving one-level renaming import) module result \\\n+                        is indeterminate; bailing\");\n                 return Indeterminate;\n             }\n             Success(name_bindings) => {\n-                debug!{\"(resolving one-level renaming import) module result \\\n-                        found\"};\n+                debug!(\"(resolving one-level renaming import) module result \\\n+                        found\");\n                 module_result = some(copy name_bindings);\n             }\n         }\n \n         let mut value_result;\n-        debug!{\"(resolving one-level naming result) searching for value\"};\n+        debug!(\"(resolving one-level naming result) searching for value\");\n         match self.resolve_item_in_lexical_scope(module_,\n                                                source_name,\n                                                ValueNS) {\n \n             Failed => {\n-                debug!{\"(resolving one-level renaming import) didn't find \\\n-                        value result\"};\n+                debug!(\"(resolving one-level renaming import) didn't find \\\n+                        value result\");\n                 value_result = none;\n             }\n             Indeterminate => {\n-                debug!{\"(resolving one-level renaming import) value result \\\n-                        is indeterminate; bailing\"};\n+                debug!(\"(resolving one-level renaming import) value result \\\n+                        is indeterminate; bailing\");\n                 return Indeterminate;\n             }\n             Success(name_bindings) => {\n-                debug!{\"(resolving one-level renaming import) value result \\\n-                        found\"};\n+                debug!(\"(resolving one-level renaming import) value result \\\n+                        found\");\n                 value_result = some(copy name_bindings);\n             }\n         }\n \n         let mut type_result;\n-        debug!{\"(resolving one-level naming result) searching for type\"};\n+        debug!(\"(resolving one-level naming result) searching for type\");\n         match self.resolve_item_in_lexical_scope(module_,\n                                                source_name,\n                                                TypeNS) {\n \n             Failed => {\n-                debug!{\"(resolving one-level renaming import) didn't find \\\n-                        type result\"};\n+                debug!(\"(resolving one-level renaming import) didn't find \\\n+                        type result\");\n                 type_result = none;\n             }\n             Indeterminate => {\n-                debug!{\"(resolving one-level renaming import) type result is \\\n-                        indeterminate; bailing\"};\n+                debug!(\"(resolving one-level renaming import) type result is \\\n+                        indeterminate; bailing\");\n                 return Indeterminate;\n             }\n             Success(name_bindings) => {\n-                debug!{\"(resolving one-level renaming import) type result \\\n-                        found\"};\n+                debug!(\"(resolving one-level renaming import) type result \\\n+                        found\");\n                 type_result = some(copy name_bindings);\n             }\n         }\n@@ -2455,11 +2455,11 @@ struct Resolver {\n                       import resolution name by now\";\n             }\n             some(import_resolution) => {\n-                debug!{\"(resolving one-level renaming import) writing module \\\n+                debug!(\"(resolving one-level renaming import) writing module \\\n                         result %? for `%s` into `%s`\",\n                        is_none(module_result),\n                        self.session.str_of(target_name),\n-                       self.module_to_str(module_)};\n+                       self.module_to_str(module_));\n \n                 import_resolution.module_target = module_result;\n                 import_resolution.value_target = value_result;\n@@ -2470,7 +2470,7 @@ struct Resolver {\n             }\n         }\n \n-        debug!{\"(resolving one-level renaming import) successfully resolved\"};\n+        debug!(\"(resolving one-level renaming import) successfully resolved\");\n         return Success(());\n     }\n \n@@ -2526,9 +2526,9 @@ struct Resolver {\n             }\n             some(_) => {\n                 // Bail out.\n-                debug!{\"(recording exports for module subtree) not recording \\\n+                debug!(\"(recording exports for module subtree) not recording \\\n                         exports for `%s`\",\n-                       self.module_to_str(module_)};\n+                       self.module_to_str(module_));\n                 return;\n             }\n         }\n@@ -2638,17 +2638,17 @@ struct Resolver {\n             some(name) => {\n                 match orig_module.children.find(name) {\n                     none => {\n-                        debug!{\"!!! (with scope) didn't find `%s` in `%s`\",\n+                        debug!(\"!!! (with scope) didn't find `%s` in `%s`\",\n                                self.session.str_of(name),\n-                               self.module_to_str(orig_module)};\n+                               self.module_to_str(orig_module));\n                     }\n                     some(name_bindings) => {\n                         match (*name_bindings).get_module_if_available() {\n                             none => {\n-                                debug!{\"!!! (with scope) didn't find module \\\n+                                debug!(\"!!! (with scope) didn't find module \\\n                                         for `%s` in `%s`\",\n                                        self.session.str_of(name),\n-                                       self.module_to_str(orig_module)};\n+                                       self.module_to_str(orig_module));\n                             }\n                             some(module_) => {\n                                 self.current_module = module_;\n@@ -2794,7 +2794,7 @@ struct Resolver {\n \n     // XXX: This shouldn't be unsafe!\n     fn resolve_crate() unsafe {\n-        debug!{\"(resolving crate) starting\"};\n+        debug!(\"(resolving crate) starting\");\n \n         // XXX: This is awful!\n         let this = ptr::addr_of(self);\n@@ -2816,8 +2816,8 @@ struct Resolver {\n     }\n \n     fn resolve_item(item: @item, visitor: ResolveVisitor) {\n-        debug!{\"(resolving item) resolving %s\",\n-               self.session.str_of(item.ident)};\n+        debug!(\"(resolving item) resolving %s\",\n+               self.session.str_of(item.ident));\n \n         // Items with the !resolve_unexported attribute are X-ray contexts.\n         // This is used to allow the test runner to run unexported tests.\n@@ -2874,8 +2874,8 @@ struct Resolver {\n                                 // definition of the trait into the definition\n                                 // map.\n \n-                                debug!{\"(resolving trait) found trait def: \\\n-                                       %?\", def};\n+                                debug!(\"(resolving trait) found trait def: \\\n+                                       %?\", def);\n \n                                 self.record_def(trt.ref_id, def);\n                             }\n@@ -3010,8 +3010,8 @@ struct Resolver {\n \n                 for (*type_parameters).eachi |index, type_parameter| {\n                     let name = type_parameter.ident;\n-                    debug!{\"with_type_parameter_rib: %d %d\", node_id,\n-                           type_parameter.id};\n+                    debug!(\"with_type_parameter_rib: %d %d\", node_id,\n+                           type_parameter.id);\n                     let def_like = dl_def(def_ty_param\n                         (local_def(type_parameter.id),\n                          index + initial_index));\n@@ -3126,8 +3126,8 @@ struct Resolver {\n \n                         self.resolve_type(argument.ty, visitor);\n \n-                        debug!{\"(resolving function) recorded argument `%s`\",\n-                               self.session.str_of(name)};\n+                        debug!(\"(resolving function) recorded argument `%s`\",\n+                               self.session.str_of(name));\n                     }\n \n                     self.resolve_type(declaration.output, visitor);\n@@ -3137,7 +3137,7 @@ struct Resolver {\n             // Resolve the function body.\n             self.resolve_block(block, visitor);\n \n-            debug!{\"(resolving function) leaving function\"};\n+            debug!(\"(resolving function) leaving function\");\n         }\n \n         (*self.label_ribs).pop();\n@@ -3193,7 +3193,7 @@ struct Resolver {\n                         // definition of the trait into the definition\n                         // map.\n \n-                        debug!{\"(resolving class) found trait def: %?\", def};\n+                        debug!(\"(resolving class) found trait def: %?\", def);\n \n                         self.record_def(trt.ref_id, def);\n \n@@ -3359,7 +3359,7 @@ struct Resolver {\n                       visitor: ResolveVisitor) {\n \n         // Write the implementations in scope into the module metadata.\n-        debug!{\"(resolving module) resolving module ID %d\", id};\n+        debug!(\"(resolving module) resolving module ID %d\", id);\n         visit_mod(module_, span, id, (), visitor);\n     }\n \n@@ -3411,17 +3411,17 @@ struct Resolver {\n                   none => {\n                     self.session.span_err(\n                         p.span,\n-                        fmt!{\"variable `%s` from pattern #1 is \\\n+                        fmt!(\"variable `%s` from pattern #1 is \\\n                                   not bound in pattern #%u\",\n-                             self.session.str_of(key), i + 1});\n+                             self.session.str_of(key), i + 1));\n                   }\n                   some(binding_i) => {\n                     if binding_0.binding_mode != binding_i.binding_mode {\n                         self.session.span_err(\n                             binding_i.span,\n-                            fmt!{\"variable `%s` is bound with different \\\n+                            fmt!(\"variable `%s` is bound with different \\\n                                       mode in pattern #%u than in pattern #1\",\n-                                 self.session.str_of(key), i + 1});\n+                                 self.session.str_of(key), i + 1));\n                     }\n                   }\n                 }\n@@ -3431,9 +3431,9 @@ struct Resolver {\n                 if !map_0.contains_key(key) {\n                     self.session.span_err(\n                         binding.span,\n-                        fmt!{\"variable `%s` from pattern #%u is \\\n+                        fmt!(\"variable `%s` from pattern #%u is \\\n                                   not bound in pattern #1\",\n-                             self.session.str_of(key), i + 1});\n+                             self.session.str_of(key), i + 1));\n                 }\n             }\n         }\n@@ -3459,16 +3459,16 @@ struct Resolver {\n     }\n \n     fn resolve_block(block: blk, visitor: ResolveVisitor) {\n-        debug!{\"(resolving block) entering block\"};\n+        debug!(\"(resolving block) entering block\");\n         (*self.value_ribs).push(@Rib(NormalRibKind));\n \n         // Move down in the graph, if there's an anonymous module rooted here.\n         let orig_module = self.current_module;\n         match self.current_module.anonymous_children.find(block.node.id) {\n             none => { /* Nothing to do. */ }\n             some(anonymous_module) => {\n-                debug!{\"(resolving block) found anonymous module, moving \\\n-                        down\"};\n+                debug!(\"(resolving block) found anonymous module, moving \\\n+                        down\");\n                 self.current_module = anonymous_module;\n             }\n         }\n@@ -3480,7 +3480,7 @@ struct Resolver {\n         self.current_module = orig_module;\n \n         (*self.value_ribs).pop();\n-        debug!{\"(resolving block) leaving block\"};\n+        debug!(\"(resolving block) leaving block\");\n     }\n \n     fn resolve_type(ty: @ty, visitor: ResolveVisitor) {\n@@ -3495,8 +3495,8 @@ struct Resolver {\n                 let mut result_def;\n                 match self.resolve_path(path, TypeNS, true, visitor) {\n                     some(def) => {\n-                        debug!{\"(resolving type) resolved `%s` to type\",\n-                               self.session.str_of(path.idents.last())};\n+                        debug!(\"(resolving type) resolved `%s` to type\",\n+                               self.session.str_of(path.idents.last()));\n                         result_def = some(def);\n                     }\n                     none => {\n@@ -3532,19 +3532,19 @@ struct Resolver {\n                 match copy result_def {\n                     some(def) => {\n                         // Write the result into the def map.\n-                        debug!{\"(resolving type) writing resolution for `%s` \\\n+                        debug!(\"(resolving type) writing resolution for `%s` \\\n                                 (id %d)\",\n                                connect(path.idents.map(\n                                    |x| self.session.str_of(x)), ~\"::\"),\n-                               path_id};\n+                               path_id);\n                         self.record_def(path_id, def);\n                     }\n                     none => {\n                         self.session.span_err\n-                            (ty.span, fmt!{\"use of undeclared type name `%s`\",\n+                            (ty.span, fmt!(\"use of undeclared type name `%s`\",\n                                            connect(path.idents.map(\n                                                |x| self.session.str_of(x)),\n-                                                   ~\"::\")});\n+                                                   ~\"::\")));\n                     }\n                 }\n             }\n@@ -3582,19 +3582,19 @@ struct Resolver {\n \n                     match self.resolve_enum_variant_or_const(atom) {\n                         FoundEnumVariant(def) if mode == RefutableMode => {\n-                            debug!{\"(resolving pattern) resolving `%s` to \\\n+                            debug!(\"(resolving pattern) resolving `%s` to \\\n                                     enum variant\",\n-                                    self.session.str_of(atom)};\n+                                    self.session.str_of(atom));\n \n                             self.record_def(pattern.id, def);\n                         }\n                         FoundEnumVariant(_) => {\n                             self.session.span_err(pattern.span,\n-                                                  fmt!{\"declaration of `%s` \\\n+                                                  fmt!(\"declaration of `%s` \\\n                                                         shadows an enum \\\n                                                         that's in scope\",\n                                                         self.session\n-                                                        .str_of(atom)});\n+                                                        .str_of(atom)));\n                         }\n                         FoundConst => {\n                             self.session.span_err(pattern.span,\n@@ -3603,8 +3603,8 @@ struct Resolver {\n                                                    in scope\");\n                         }\n                         EnumVariantOrConstNotFound => {\n-                            debug!{\"(resolving pattern) binding `%s`\",\n-                                   self.session.str_of(atom)};\n+                            debug!(\"(resolving pattern) binding `%s`\",\n+                                   self.session.str_of(atom));\n \n                             let is_mutable = mutability == Mutable;\n \n@@ -3647,10 +3647,10 @@ struct Resolver {\n                                       // in the same disjunct, which is an\n                                       // error\n                                      self.session.span_err(pattern.span,\n-                                       fmt!{\"Identifier %s is bound more \\\n+                                       fmt!(\"Identifier %s is bound more \\\n                                              than once in the same pattern\",\n                                             path_to_str(path, self.session\n-                                                        .intr())});\n+                                                        .intr())));\n                                   }\n                                   // Not bound in the same pattern: do nothing\n                                 }\n@@ -3678,9 +3678,9 @@ struct Resolver {\n                         some(_) => {\n                             self.session.span_err(\n                                 path.span,\n-                                fmt!{\"not an enum variant: %s\",\n+                                fmt!(\"not an enum variant: %s\",\n                                      self.session.str_of(\n-                                         path.idents.last())});\n+                                         path.idents.last())));\n                         }\n                         none => {\n                             self.session.span_err(path.span,\n@@ -3835,9 +3835,9 @@ struct Resolver {\n                                          -> NameDefinition {\n \n         if xray == NoXray && !self.name_is_exported(containing_module, name) {\n-            debug!{\"(resolving definition of name in module) name `%s` is \\\n+            debug!(\"(resolving definition of name in module) name `%s` is \\\n                     unexported\",\n-                   self.session.str_of(name)};\n+                   self.session.str_of(name));\n             return NoNameDefinition;\n         }\n \n@@ -3918,9 +3918,9 @@ struct Resolver {\n \n             Failed => {\n                 self.session.span_err(path.span,\n-                                      fmt!{\"use of undeclared module `%s`\",\n+                                      fmt!(\"use of undeclared module `%s`\",\n                                            self.atoms_to_str(\n-                                               (*module_path_atoms).get())});\n+                                               (*module_path_atoms).get())));\n                 return none;\n             }\n \n@@ -3942,9 +3942,9 @@ struct Resolver {\n                 // We failed to resolve the name. Report an error.\n                 self.session.span_err(\n                     path.span,\n-                    fmt!{\"unresolved name: %s::%s\",\n+                    fmt!(\"unresolved name: %s::%s\",\n                          self.atoms_to_str((*module_path_atoms).get()),\n-                         self.session.str_of(name)});\n+                         self.session.str_of(name)));\n                 return none;\n             }\n             ChildNameDefinition(def) | ImportNameDefinition(def) => {\n@@ -3971,9 +3971,9 @@ struct Resolver {\n \n             Failed => {\n                 self.session.span_err(path.span,\n-                                      fmt!{\"use of undeclared module `::%s`\",\n+                                      fmt!(\"use of undeclared module `::%s`\",\n                                             self.atoms_to_str\n-                                              ((*module_path_atoms).get())});\n+                                              ((*module_path_atoms).get())));\n                 return none;\n             }\n \n@@ -3995,9 +3995,9 @@ struct Resolver {\n                 // We failed to resolve the name. Report an error.\n                 self.session.span_err(\n                     path.span,\n-                    fmt!{\"unresolved name: %s::%s\", self.atoms_to_str(\n+                    fmt!(\"unresolved name: %s::%s\", self.atoms_to_str(\n                         (*module_path_atoms).get()),\n-                         self.session.str_of(name)});\n+                         self.session.str_of(name)));\n                 return none;\n             }\n             ChildNameDefinition(def) | ImportNameDefinition(def) => {\n@@ -4028,10 +4028,10 @@ struct Resolver {\n \n         match copy search_result {\n             some(dl_def(def)) => {\n-                debug!{\"(resolving path in local ribs) resolved `%s` to \\\n+                debug!(\"(resolving path in local ribs) resolved `%s` to \\\n                         local: %?\",\n                        self.session.str_of(ident),\n-                       def};\n+                       def);\n                 return some(def);\n             }\n             some(dl_field) | some(dl_impl(_)) | none => {\n@@ -4056,9 +4056,9 @@ struct Resolver {\n                               bindings with no def for that namespace?!\";\n                     }\n                     some(def) => {\n-                        debug!{\"(resolving item path in lexical scope) \\\n+                        debug!(\"(resolving item path in lexical scope) \\\n                                 resolved `%s` to item\",\n-                               self.session.str_of(ident)};\n+                               self.session.str_of(ident));\n                         return some(def.def);\n                     }\n                 }\n@@ -4090,18 +4090,18 @@ struct Resolver {\n                 match self.resolve_path(path, ValueNS, true, visitor) {\n                     some(def) => {\n                         // Write the result into the def map.\n-                        debug!{\"(resolving expr) resolved `%s`\",\n+                        debug!(\"(resolving expr) resolved `%s`\",\n                                connect(path.idents.map(\n-                                   |x| self.session.str_of(x)), ~\"::\")};\n+                                   |x| self.session.str_of(x)), ~\"::\"));\n                         self.record_def(expr.id, def);\n                     }\n                     none => {\n                         self.session.span_err(\n                             expr.span,\n-                            fmt!{\"unresolved name: %s\",\n+                            fmt!(\"unresolved name: %s\",\n                                  connect(path.idents.map(\n                                      |x| self.session.str_of(x)),\n-                                         ~\"::\")});\n+                                         ~\"::\")));\n                     }\n                 }\n \n@@ -4149,10 +4149,10 @@ struct Resolver {\n                     _ => {\n                         self.session.span_err(\n                             path.span,\n-                            fmt!{\"`%s` does not name a structure\",\n+                            fmt!(\"`%s` does not name a structure\",\n                                  connect(path.idents.map(\n                                      |x| self.session.str_of(x)),\n-                                         ~\"::\")});\n+                                         ~\"::\")));\n                     }\n                 }\n \n@@ -4340,11 +4340,11 @@ struct Resolver {\n \n         match self.trait_info.find(trait_def_id) {\n             some(trait_info) if trait_info.contains_key(name) => {\n-                debug!{\"(adding trait info if containing method) found trait \\\n+                debug!(\"(adding trait info if containing method) found trait \\\n                         %d:%d for method '%s'\",\n                        trait_def_id.crate,\n                        trait_def_id.node,\n-                       self.session.str_of(name)};\n+                       self.session.str_of(name));\n                 (*found_traits).push(trait_def_id);\n             }\n             some(_) | none => {\n@@ -4360,7 +4360,7 @@ struct Resolver {\n     }\n \n     fn record_def(node_id: node_id, def: def) {\n-        debug!{\"(recording def) recording %? for %?\", def, node_id};\n+        debug!(\"(recording def) recording %? for %?\", def, node_id);\n         self.def_map.insert(node_id, def);\n     }\n \n@@ -4393,9 +4393,9 @@ struct Resolver {\n             }\n             some(_) => {\n                 // Bail out.\n-                debug!{\"(checking for unused imports in module subtree) not \\\n+                debug!(\"(checking for unused imports in module subtree) not \\\n                         checking for unused imports for `%s`\",\n-                       self.module_to_str(module_)};\n+                       self.module_to_str(module_));\n                 return;\n             }\n         }\n@@ -4491,14 +4491,14 @@ struct Resolver {\n     }\n \n     fn dump_module(module_: @Module) {\n-        debug!{\"Dump of module `%s`:\", self.module_to_str(module_)};\n+        debug!(\"Dump of module `%s`:\", self.module_to_str(module_));\n \n-        debug!{\"Children:\"};\n+        debug!(\"Children:\");\n         for module_.children.each |name, _child| {\n-            debug!{\"* %s\", self.session.str_of(name)};\n+            debug!(\"* %s\", self.session.str_of(name));\n         }\n \n-        debug!{\"Import resolutions:\"};\n+        debug!(\"Import resolutions:\");\n         for module_.import_resolutions.each |name, import_resolution| {\n             let mut module_repr;\n             match (*import_resolution).target_for_namespace(ModuleNS) {\n@@ -4527,9 +4527,9 @@ struct Resolver {\n                 }\n             }\n \n-            debug!{\"* %s:%s%s%s\",\n+            debug!(\"* %s:%s%s%s\",\n                    self.session.str_of(name),\n-                   module_repr, value_repr, type_repr};\n+                   module_repr, value_repr, type_repr);\n         }\n     }\n }"}, {"sha": "60a57540fa9af4b3566348865b613a561375c8af", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 80, "deletions": 80, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -67,8 +67,8 @@ enum dest {\n \n fn dest_str(ccx: @crate_ctxt, d: dest) -> ~str {\n     match d {\n-      by_val(v) => fmt!{\"by_val(%s)\", val_str(ccx.tn, *v)},\n-      save_in(v) => fmt!{\"save_in(%s)\", val_str(ccx.tn, v)},\n+      by_val(v) => fmt!(\"by_val(%s)\", val_str(ccx.tn, *v)),\n+      save_in(v) => fmt!(\"save_in(%s)\", val_str(ccx.tn, v)),\n       ignore => ~\"ignore\"\n     }\n }\n@@ -100,7 +100,7 @@ trait get_insn_ctxt {\n \n impl @crate_ctxt: get_insn_ctxt {\n     fn insn_ctxt(s: &str) -> icx_popper {\n-        debug!{\"new insn_ctxt: %s\", s};\n+        debug!(\"new insn_ctxt: %s\", s);\n         if self.sess.count_llvm_insns() {\n             vec::push(*self.stats.llvm_insn_ctxt, str::from_slice(s));\n         }\n@@ -504,7 +504,7 @@ fn declare_tydesc(ccx: @crate_ctxt, t: ty::t) -> @tydesc_info {\n         mangle_internal_name_by_type_only(ccx, t, ~\"tydesc\")\n     } else { mangle_internal_name_by_seq(ccx, ~\"tydesc\") };\n     note_unique_llvm_symbol(ccx, name);\n-    log(debug, fmt!{\"+++ declare_tydesc %s %s\", ty_to_str(ccx.tcx, t), name});\n+    log(debug, fmt!(\"+++ declare_tydesc %s %s\", ty_to_str(ccx.tcx, t), name));\n     let gvar = str::as_c_str(name, |buf| {\n         llvm::LLVMAddGlobal(ccx.llmod, ccx.tydesc_type, buf)\n     });\n@@ -1116,52 +1116,52 @@ fn lazily_emit_tydesc_glue(ccx: @crate_ctxt, field: uint,\n         match ti.take_glue {\n           some(_) => (),\n           none => {\n-            debug!{\"+++ lazily_emit_tydesc_glue TAKE %s\",\n-                   ppaux::ty_to_str(ccx.tcx, ti.ty)};\n+            debug!(\"+++ lazily_emit_tydesc_glue TAKE %s\",\n+                   ppaux::ty_to_str(ccx.tcx, ti.ty));\n             let glue_fn = declare_generic_glue(ccx, ti.ty, llfnty, ~\"take\");\n             ti.take_glue = some(glue_fn);\n             make_generic_glue(ccx, ti.ty, glue_fn, make_take_glue, ~\"take\");\n-            debug!{\"--- lazily_emit_tydesc_glue TAKE %s\",\n-                   ppaux::ty_to_str(ccx.tcx, ti.ty)};\n+            debug!(\"--- lazily_emit_tydesc_glue TAKE %s\",\n+                   ppaux::ty_to_str(ccx.tcx, ti.ty));\n           }\n         }\n     } else if field == abi::tydesc_field_drop_glue {\n         match ti.drop_glue {\n           some(_) => (),\n           none => {\n-            debug!{\"+++ lazily_emit_tydesc_glue DROP %s\",\n-                   ppaux::ty_to_str(ccx.tcx, ti.ty)};\n+            debug!(\"+++ lazily_emit_tydesc_glue DROP %s\",\n+                   ppaux::ty_to_str(ccx.tcx, ti.ty));\n             let glue_fn = declare_generic_glue(ccx, ti.ty, llfnty, ~\"drop\");\n             ti.drop_glue = some(glue_fn);\n             make_generic_glue(ccx, ti.ty, glue_fn, make_drop_glue, ~\"drop\");\n-            debug!{\"--- lazily_emit_tydesc_glue DROP %s\",\n-                   ppaux::ty_to_str(ccx.tcx, ti.ty)};\n+            debug!(\"--- lazily_emit_tydesc_glue DROP %s\",\n+                   ppaux::ty_to_str(ccx.tcx, ti.ty));\n           }\n         }\n     } else if field == abi::tydesc_field_free_glue {\n         match ti.free_glue {\n           some(_) => (),\n           none => {\n-            debug!{\"+++ lazily_emit_tydesc_glue FREE %s\",\n-                   ppaux::ty_to_str(ccx.tcx, ti.ty)};\n+            debug!(\"+++ lazily_emit_tydesc_glue FREE %s\",\n+                   ppaux::ty_to_str(ccx.tcx, ti.ty));\n             let glue_fn = declare_generic_glue(ccx, ti.ty, llfnty, ~\"free\");\n             ti.free_glue = some(glue_fn);\n             make_generic_glue(ccx, ti.ty, glue_fn, make_free_glue, ~\"free\");\n-            debug!{\"--- lazily_emit_tydesc_glue FREE %s\",\n-                   ppaux::ty_to_str(ccx.tcx, ti.ty)};\n+            debug!(\"--- lazily_emit_tydesc_glue FREE %s\",\n+                   ppaux::ty_to_str(ccx.tcx, ti.ty));\n           }\n         }\n     } else if field == abi::tydesc_field_visit_glue {\n         match ti.visit_glue {\n           some(_) => (),\n           none => {\n-            debug!{\"+++ lazily_emit_tydesc_glue VISIT %s\",\n-                   ppaux::ty_to_str(ccx.tcx, ti.ty)};\n+            debug!(\"+++ lazily_emit_tydesc_glue VISIT %s\",\n+                   ppaux::ty_to_str(ccx.tcx, ti.ty));\n             let glue_fn = declare_generic_glue(ccx, ti.ty, llfnty, ~\"visit\");\n             ti.visit_glue = some(glue_fn);\n             make_generic_glue(ccx, ti.ty, glue_fn, make_visit_glue, ~\"visit\");\n-            debug!{\"--- lazily_emit_tydesc_glue VISIT %s\",\n-                   ppaux::ty_to_str(ccx.tcx, ti.ty)};\n+            debug!(\"--- lazily_emit_tydesc_glue VISIT %s\",\n+                   ppaux::ty_to_str(ccx.tcx, ti.ty));\n           }\n         }\n     }\n@@ -1722,7 +1722,7 @@ fn trans_eager_binop(cx: block, span: span, op: ast::binop, lhs: ValueRef,\n \n fn trans_assign_op(bcx: block, ex: @ast::expr, op: ast::binop,\n                    dst: @ast::expr, src: @ast::expr) -> block {\n-    debug!{\"%s\", expr_to_str(ex, bcx.tcx().sess.parse_sess.interner)};\n+    debug!(\"%s\", expr_to_str(ex, bcx.tcx().sess.parse_sess.interner));\n     let _icx = bcx.insn_ctxt(\"trans_assign_op\");\n     let t = expr_ty(bcx, src);\n     let lhs_res = trans_lval(bcx, dst);\n@@ -1732,9 +1732,9 @@ fn trans_assign_op(bcx: block, ex: @ast::expr, op: ast::binop,\n     match bcx.ccx().maps.method_map.find(ex.id) {\n       some(origin) => {\n         let bcx = lhs_res.bcx;\n-        debug!{\"user-defined method callee_id: %s\",\n+        debug!(\"user-defined method callee_id: %s\",\n                ast_map::node_id_to_str(bcx.tcx().items, ex.callee_id,\n-                                       bcx.sess().parse_sess.interner)};\n+                                       bcx.sess().parse_sess.interner));\n         let fty = node_id_type(bcx, ex.callee_id);\n \n         let dty = expr_ty(bcx, dst);\n@@ -1770,7 +1770,7 @@ fn root_value(bcx: block, val: ValueRef, ty: ty::t,\n     if bcx.sess().trace() {\n         trans_trace(\n             bcx, none,\n-            fmt!{\"preserving until end of scope %d\", scope_id});\n+            fmt!(\"preserving until end of scope %d\", scope_id));\n     }\n \n     let root_loc = alloca_zeroed(bcx, type_of(bcx.ccx(), ty));\n@@ -1789,9 +1789,9 @@ fn autoderef(cx: block, e_id: ast::node_id,\n     let ccx = cx.ccx();\n     let mut derefs = 0u;\n     while derefs < max {\n-        debug!{\"autoderef(e_id=%d, v1=%s, t1=%s, derefs=%u)\",\n+        debug!(\"autoderef(e_id=%d, v1=%s, t1=%s, derefs=%u)\",\n                e_id, val_str(ccx.tn, v1), ppaux::ty_to_str(ccx.tcx, t1),\n-               derefs};\n+               derefs);\n \n         // root the autoderef'd value, if necessary:\n         derefs += 1u;\n@@ -2140,8 +2140,8 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id,\n \n     match ccx.monomorphized.find(hash_id) {\n       some(val) => {\n-        debug!{\"leaving monomorphic fn %s\",\n-               ty::item_path_str(ccx.tcx, fn_id)};\n+        debug!(\"leaving monomorphic fn %s\",\n+               ty::item_path_str(ccx.tcx, fn_id));\n         return {val: val, must_cast: must_cast};\n       }\n       none => ()\n@@ -2151,9 +2151,9 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id,\n     let mut llitem_ty = tpt.ty;\n \n     let map_node = session::expect(ccx.sess, ccx.tcx.items.find(fn_id.node),\n-     || fmt!{\"While monomorphizing %?, couldn't find it in the item map \\\n+     || fmt!(\"While monomorphizing %?, couldn't find it in the item map \\\n         (may have attempted to monomorphize an item defined in a different \\\n-        crate?)\", fn_id});\n+        crate?)\", fn_id));\n     // Get the path so that we can create a symbol\n     let (pt, name, span) = match map_node {\n       ast_map::node_item(i, pt) => (pt, i.ident, i.span),\n@@ -2287,7 +2287,7 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id,\n     };\n     ccx.monomorphizing.insert(fn_id, depth);\n \n-    debug!{\"leaving monomorphic fn %s\", ty::item_path_str(ccx.tcx, fn_id)};\n+    debug!(\"leaving monomorphic fn %s\", ty::item_path_str(ccx.tcx, fn_id));\n     {val: lldecl, must_cast: must_cast}\n }\n \n@@ -2297,8 +2297,8 @@ fn maybe_instantiate_inline(ccx: @crate_ctxt, fn_id: ast::def_id)\n     match ccx.external.find(fn_id) {\n       some(some(node_id)) => {\n         // Already inline\n-        debug!{\"maybe_instantiate_inline(%s): already inline as node id %d\",\n-               ty::item_path_str(ccx.tcx, fn_id), node_id};\n+        debug!(\"maybe_instantiate_inline(%s): already inline as node id %d\",\n+               ty::item_path_str(ccx.tcx, fn_id), node_id);\n         local_def(node_id)\n       }\n       some(none) => fn_id, // Not inlinable\n@@ -2487,8 +2487,8 @@ fn trans_local_var(cx: block, def: ast::def) -> local_var_result {\n         return {val: slf, kind: lv_owned};\n       }\n       _ => {\n-        cx.sess().unimpl(fmt!{\"unsupported def type in trans_local_var: %?\",\n-                              def});\n+        cx.sess().unimpl(fmt!(\"unsupported def type in trans_local_var: %?\",\n+                              def));\n       }\n     }\n }\n@@ -2576,7 +2576,7 @@ fn trans_rec_field_inner(bcx: block, val: ValueRef, ty: ty::t,\n \n     let ix = field_idx_strict(bcx.tcx(), sp, field, fields);\n \n-    debug!{\"val = %s ix = %u\", bcx.val_str(val), ix};\n+    debug!(\"val = %s ix = %u\", bcx.val_str(val), ix);\n \n     /* self is a class with a dtor, which means we\n        have to select out the object itself\n@@ -2628,8 +2628,8 @@ fn trans_index(cx: block, ex: @ast::expr, base: @ast::expr,\n         len = Sub(bcx, len, C_uint(bcx.ccx(), 1u));\n     }\n \n-    debug!{\"trans_index: base %s\", val_str(bcx.ccx().tn, base)};\n-    debug!{\"trans_index: len %s\", val_str(bcx.ccx().tn, len)};\n+    debug!(\"trans_index: base %s\", val_str(bcx.ccx().tn, base));\n+    debug!(\"trans_index: len %s\", val_str(bcx.ccx().tn, len));\n \n     let bounds_check = ICmp(bcx, lib::llvm::IntUGE, scaled_ix, len);\n     let bcx = do with_cond(bcx, bounds_check) |bcx| {\n@@ -2687,8 +2687,8 @@ fn trans_lval(cx: block, e: @ast::expr) -> lval_result {\n         let lv = unrooted(cx, e);\n \n         if !cx.sess().no_asm_comments() {\n-            add_comment(cx, fmt!{\"preserving until end of scope %d\",\n-                                 scope_id});\n+            add_comment(cx, fmt!(\"preserving until end of scope %d\",\n+                                 scope_id));\n         }\n \n         let _icx = lv.bcx.insn_ctxt(\"root_value_lval\");\n@@ -2749,7 +2749,7 @@ fn trans_lval(cx: block, e: @ast::expr) -> lval_result {\n  * wrong address space and thus be the wrong type.\n  */\n fn non_gc_box_cast(cx: block, val: ValueRef) -> ValueRef {\n-    debug!{\"non_gc_box_cast\"};\n+    debug!(\"non_gc_box_cast\");\n     add_comment(cx, ~\"non_gc_box_cast\");\n     assert(llvm::LLVMGetPointerAddressSpace(val_ty(val)) as uint == 1u);\n     let non_gc_t = T_ptr(llvm::LLVMGetElementType(val_ty(val)));\n@@ -2904,7 +2904,7 @@ fn trans_arg_expr(cx: block, arg: ty::arg, lldestty: TypeRef, e: @ast::expr,\n     -> result {\n     let _icx = cx.insn_ctxt(\"trans_arg_expr\");\n     let ccx = cx.ccx();\n-    debug!{\"+++ trans_arg_expr on %s\", expr_to_str(e, ccx.sess.intr())};\n+    debug!(\"+++ trans_arg_expr on %s\", expr_to_str(e, ccx.sess.intr()));\n     let e_ty = expr_ty(cx, e);\n     let is_bot = ty::type_is_bot(e_ty);\n \n@@ -2925,7 +2925,7 @@ fn trans_arg_expr(cx: block, arg: ty::arg, lldestty: TypeRef, e: @ast::expr,\n \n     // auto-deref value as required (this only applies to method\n     // call receivers) of method\n-    debug!{\"   pre-deref value: %s\", val_str(lv.bcx.ccx().tn, lv.val)};\n+    debug!(\"   pre-deref value: %s\", val_str(lv.bcx.ccx().tn, lv.val));\n     let {lv, e_ty} = if derefs == 0u {\n       {lv: lv, e_ty: e_ty}\n     } else {\n@@ -2937,11 +2937,11 @@ fn trans_arg_expr(cx: block, arg: ty::arg, lldestty: TypeRef, e: @ast::expr,\n     };\n \n     // borrow value (convert from @T to &T and so forth)\n-    debug!{\"   pre-adaptation value: %s\", val_str(lv.bcx.ccx().tn, lv.val)};\n+    debug!(\"   pre-adaptation value: %s\", val_str(lv.bcx.ccx().tn, lv.val));\n     let {lv, ty: e_ty} = adapt_borrowed_value(lv, e, e_ty);\n     let mut bcx = lv.bcx;\n     let mut val = lv.val;\n-    debug!{\"   adapted value: %s\", val_str(bcx.ccx().tn, val)};\n+    debug!(\"   adapted value: %s\", val_str(bcx.ccx().tn, val));\n \n     // finally, deal with the various modes\n     let arg_mode = ty::resolved_mode(ccx.tcx, arg.mode);\n@@ -2993,11 +2993,11 @@ fn trans_arg_expr(cx: block, arg: ty::arg, lldestty: TypeRef, e: @ast::expr,\n     }\n \n     if !is_bot && arg.ty != e_ty || ty::type_has_params(arg.ty) {\n-        debug!{\"   casting from %s\", val_str(bcx.ccx().tn, val)};\n+        debug!(\"   casting from %s\", val_str(bcx.ccx().tn, val));\n         val = PointerCast(bcx, val, lldestty);\n     }\n \n-    debug!{\"--- trans_arg_expr passing %s\", val_str(bcx.ccx().tn, val)};\n+    debug!(\"--- trans_arg_expr passing %s\", val_str(bcx.ccx().tn, val));\n     return rslt(bcx, val);\n }\n \n@@ -3038,9 +3038,9 @@ fn adapt_borrowed_value(lv: lval_result,\n         let (base, len) = tvec::get_base_and_len(bcx, val, e_ty);\n         let p = alloca(bcx, T_struct(~[T_ptr(llunit_ty), ccx.int_type]));\n \n-        debug!{\"adapt_borrowed_value: adapting %s to %s\",\n+        debug!(\"adapt_borrowed_value: adapting %s to %s\",\n                val_str(bcx.ccx().tn, val),\n-               val_str(bcx.ccx().tn, p)};\n+               val_str(bcx.ccx().tn, p));\n \n         Store(bcx, base, GEPi(bcx, p, ~[0u, abi::slice_elt_base]));\n         Store(bcx, len, GEPi(bcx, p, ~[0u, abi::slice_elt_len]));\n@@ -3683,9 +3683,9 @@ fn lval_result_to_result(lv: lval_result, ty: ty::t) -> result {\n fn add_root_cleanup(bcx: block, scope_id: ast::node_id,\n                     root_loc: ValueRef, ty: ty::t) {\n \n-    debug!{\"add_root_cleanup(bcx=%s, scope_id=%d, root_loc=%s, ty=%s)\",\n+    debug!(\"add_root_cleanup(bcx=%s, scope_id=%d, root_loc=%s, ty=%s)\",\n            bcx.to_str(), scope_id, val_str(bcx.ccx().tn, root_loc),\n-           ppaux::ty_to_str(bcx.ccx().tcx, ty)};\n+           ppaux::ty_to_str(bcx.ccx().tcx, ty));\n \n     let bcx_scope = find_bcx_for_scope(bcx, scope_id);\n     add_clean_temp_mem(bcx_scope, root_loc, ty);\n@@ -3700,7 +3700,7 @@ fn add_root_cleanup(bcx: block, scope_id: ast::node_id,\n               _ => {\n                 match bcx_sid.parent {\n                   none => bcx.tcx().sess.bug(\n-                      fmt!{\"no enclosing scope with id %d\", scope_id}),\n+                      fmt!(\"no enclosing scope with id %d\", scope_id)),\n                   some(bcx_par) => bcx_par\n                 }\n               }\n@@ -3724,16 +3724,16 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n     return match bcx.ccx().maps.root_map.find({id:e.id, derefs:0u}) {\n       none => unrooted(bcx, e, dest),\n       some(scope_id) => {\n-        debug!{\"expression %d found in root map with scope %d\",\n-               e.id, scope_id};\n+        debug!(\"expression %d found in root map with scope %d\",\n+               e.id, scope_id);\n \n         let ty = expr_ty(bcx, e);\n         let root_loc = alloca_zeroed(bcx, type_of(bcx.ccx(), ty));\n         let bcx = unrooted(bcx, e, save_in(root_loc));\n \n         if !bcx.sess().no_asm_comments() {\n-            add_comment(bcx, fmt!{\"preserving until end of scope %d\",\n-                                  scope_id});\n+            add_comment(bcx, fmt!(\"preserving until end of scope %d\",\n+                                  scope_id));\n         }\n \n         let _icx = bcx.insn_ctxt(\"root_value_expr\");\n@@ -3812,9 +3812,9 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n           ast::expr_fn_block(decl, body, cap_clause) => {\n             match check ty::get(expr_ty(bcx, e)).struct {\n               ty::ty_fn({proto, _}) => {\n-                debug!{\"translating fn_block %s with type %s\",\n+                debug!(\"translating fn_block %s with type %s\",\n                        expr_to_str(e, tcx.sess.intr()),\n-                       ppaux::ty_to_str(tcx, expr_ty(bcx, e))};\n+                       ppaux::ty_to_str(tcx, expr_ty(bcx, e)));\n                 return closure::trans_expr_fn(bcx, proto, decl, body,\n                                            e.id, cap_clause, none, dest);\n               }\n@@ -3945,8 +3945,8 @@ fn lval_to_dps(bcx: block, e: @ast::expr, dest: dest) -> block {\n     let ty = expr_ty(bcx, e);\n     let lv = trans_lval(bcx, e);\n     let last_use = (lv.kind == lv_owned && last_use_map.contains_key(e.id));\n-    debug!{\"is last use (%s) = %b, %d\", expr_to_str(e, bcx.ccx().sess.intr()),\n-           last_use, lv.kind as int};\n+    debug!(\"is last use (%s) = %b, %d\", expr_to_str(e, bcx.ccx().sess.intr()),\n+           last_use, lv.kind as int);\n     lval_result_to_dps(lv, ty, last_use, dest)\n }\n \n@@ -4297,7 +4297,7 @@ fn init_local(bcx: block, local: @ast::local) -> block {\n \n fn trans_stmt(cx: block, s: ast::stmt) -> block {\n     let _icx = cx.insn_ctxt(\"trans_stmt\");\n-    debug!{\"trans_stmt(%s)\", stmt_to_str(s, cx.tcx().sess.intr())};\n+    debug!(\"trans_stmt(%s)\", stmt_to_str(s, cx.tcx().sess.intr()));\n \n     if !cx.sess().no_asm_comments() {\n         add_span_comment(cx, s.span, stmt_to_str(s, cx.ccx().sess.intr()));\n@@ -4434,12 +4434,12 @@ fn cleanup_and_leave(bcx: block, upto: option<BasicBlockRef>,\n     let mut cur = bcx, bcx = bcx;\n     let is_lpad = leave == none;\n     loop {\n-        debug!{\"cleanup_and_leave: leaving %s\", cur.to_str()};\n+        debug!(\"cleanup_and_leave: leaving %s\", cur.to_str());\n \n         if bcx.sess().trace() {\n             trans_trace(\n                 bcx, none,\n-                fmt!{\"cleanup_and_leave(%s)\", cur.to_str()});\n+                fmt!(\"cleanup_and_leave(%s)\", cur.to_str()));\n         }\n \n         match cur.kind {\n@@ -5133,9 +5133,9 @@ fn register_fn_fuller(ccx: @crate_ctxt, sp: span, path: path,\n     let llfn: ValueRef = decl_fn(ccx.llmod, ps, cc, llfty);\n     ccx.item_symbols.insert(node_id, ps);\n \n-    debug!{\"register_fn_fuller created fn %s for item %d with path %s\",\n+    debug!(\"register_fn_fuller created fn %s for item %d with path %s\",\n            val_str(ccx.tn, llfn), node_id,\n-           ast_map::path_to_str(path, ccx.sess.parse_sess.interner)};\n+           ast_map::path_to_str(path, ccx.sess.parse_sess.interner));\n \n     let is_main = is_main_name(path) && !ccx.sess.building_library;\n     if is_main { create_main_wrapper(ccx, sp, llfn, node_type); }\n@@ -5276,16 +5276,16 @@ fn get_dtor_symbol(ccx: @crate_ctxt, path: path, id: ast::node_id,\n                mono_ty)\n          }\n          none => {\n-             ccx.sess.bug(fmt!{\"get_dtor_symbol: not monomorphizing and \\\n-               couldn't find a symbol for dtor %?\", path});\n+             ccx.sess.bug(fmt!(\"get_dtor_symbol: not monomorphizing and \\\n+               couldn't find a symbol for dtor %?\", path));\n          }\n        }\n      }\n   }\n }\n \n fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n-    debug!{\"get_item_val(id=`%?`)\", id};\n+    debug!(\"get_item_val(id=`%?`)\", id);\n     let tcx = ccx.tcx;\n     match ccx.item_vals.find(id) {\n       some(v) => v,\n@@ -5316,7 +5316,7 @@ fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n             }\n           }\n           ast_map::node_trait_method(trait_method, _, pth) => {\n-            debug!{\"get_item_val(): processing a node_trait_method\"};\n+            debug!(\"get_item_val(): processing a node_trait_method\");\n             match *trait_method {\n               ast::required(_) => {\n                 ccx.sess.bug(~\"unexpected variant: required trait method in \\\n@@ -5527,7 +5527,7 @@ fn trap(bcx: block) {\n \n fn push_rtcall(ccx: @crate_ctxt, name: ~str, did: ast::def_id) {\n     if ccx.rtcalls.contains_key(name) {\n-        fail fmt!{\"multiple definitions for runtime call %s\", name};\n+        fail fmt!(\"multiple definitions for runtime call %s\", name);\n     }\n     ccx.rtcalls.insert(name, did);\n }\n@@ -5597,7 +5597,7 @@ fn gather_rtcalls(ccx: @crate_ctxt, crate: @ast::crate) {\n         ~[~\"exchange_free\", ~\"exchange_malloc\", ~\"fail\", ~\"free\", ~\"malloc\"];\n     for vec::each(expected_rtcalls) |name| {\n         if !ccx.rtcalls.contains_key(name) {\n-            fail fmt!{\"no definition for runtime call %s\", name};\n+            fail fmt!(\"no definition for runtime call %s\", name);\n         }\n     }\n }\n@@ -5867,25 +5867,25 @@ fn trans_crate(sess: session::session,\n     write_metadata(ccx, crate);\n     if ccx.sess.trans_stats() {\n         io::println(~\"--- trans stats ---\");\n-        io::println(fmt!{\"n_static_tydescs: %u\",\n-                         ccx.stats.n_static_tydescs});\n-        io::println(fmt!{\"n_glues_created: %u\",\n-                         ccx.stats.n_glues_created});\n-        io::println(fmt!{\"n_null_glues: %u\", ccx.stats.n_null_glues});\n-        io::println(fmt!{\"n_real_glues: %u\", ccx.stats.n_real_glues});\n+        io::println(fmt!(\"n_static_tydescs: %u\",\n+                         ccx.stats.n_static_tydescs));\n+        io::println(fmt!(\"n_glues_created: %u\",\n+                         ccx.stats.n_glues_created));\n+        io::println(fmt!(\"n_null_glues: %u\", ccx.stats.n_null_glues));\n+        io::println(fmt!(\"n_real_glues: %u\", ccx.stats.n_real_glues));\n \n         // FIXME (#2280): this temporary shouldn't be\n         // necessary, but seems to be, for borrowing.\n         let times = copy *ccx.stats.fn_times;\n         for vec::each(times) |timing| {\n-            io::println(fmt!{\"time: %s took %d ms\", timing.ident,\n-                             timing.time});\n+            io::println(fmt!(\"time: %s took %d ms\", timing.ident,\n+                             timing.time));\n         }\n     }\n \n     if ccx.sess.count_llvm_insns() {\n         for ccx.stats.llvm_insns.each |k, v| {\n-            io::println(fmt!{\"%-7u %s\", v, k});\n+            io::println(fmt!(\"%-7u %s\", v, k));\n         }\n     }\n     return (llmod, link_meta);"}, {"sha": "3cf23840f3c9e0010894777196ef07a5f24206d5", "filename": "src/rustc/middle/trans/build.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -142,10 +142,10 @@ fn Invoke(cx: block, Fn: ValueRef, Args: ~[ValueRef],\n     if cx.unreachable { return; }\n     assert (!cx.terminated);\n     cx.terminated = true;\n-    debug!{\"Invoke(%s with arguments (%s))\",\n+    debug!(\"Invoke(%s with arguments (%s))\",\n            val_str(cx.ccx().tn, Fn),\n            str::connect(vec::map(Args, |a| val_str(cx.ccx().tn, a)),\n-                        ~\", \")};\n+                        ~\", \"));\n     unsafe {\n         count_insn(cx, \"invoke\");\n         llvm::LLVMBuildInvoke(B(cx), Fn, vec::unsafe::to_ptr(Args),\n@@ -413,9 +413,9 @@ fn Load(cx: block, PointerVal: ValueRef) -> ValueRef {\n \n fn Store(cx: block, Val: ValueRef, Ptr: ValueRef) {\n     if cx.unreachable { return; }\n-    debug!{\"Store %s -> %s\",\n+    debug!(\"Store %s -> %s\",\n            val_str(cx.ccx().tn, Val),\n-           val_str(cx.ccx().tn, Ptr)};\n+           val_str(cx.ccx().tn, Ptr));\n     count_insn(cx, \"store\");\n     llvm::LLVMBuildStore(B(cx), Val, Ptr);\n }\n@@ -673,9 +673,9 @@ fn Call(cx: block, Fn: ValueRef, Args: ~[ValueRef]) -> ValueRef {\n     unsafe {\n         count_insn(cx, \"call\");\n \n-        debug!{\"Call(Fn=%s, Args=%?)\",\n+        debug!(\"Call(Fn=%s, Args=%?)\",\n                val_str(cx.ccx().tn, Fn),\n-               Args.map(|arg| val_str(cx.ccx().tn, arg))};\n+               Args.map(|arg| val_str(cx.ccx().tn, arg)));\n \n         return llvm::LLVMBuildCall(B(cx), Fn, vec::unsafe::to_ptr(Args),\n                                 Args.len() as c_uint, noname());"}, {"sha": "9b3b5d7e12a10bcc757305d623838ae61f9b0462", "filename": "src/rustc/middle/trans/closure.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -100,12 +100,12 @@ enum environment_value {\n \n fn ev_to_str(ccx: @crate_ctxt, ev: environment_value) -> ~str {\n     match ev {\n-      env_copy(v, t, lk) => fmt!{\"copy(%s,%s)\", val_str(ccx.tn, v),\n-                                ty_to_str(ccx.tcx, t)},\n-      env_move(v, t, lk) => fmt!{\"move(%s,%s)\", val_str(ccx.tn, v),\n-                                ty_to_str(ccx.tcx, t)},\n-      env_ref(v, t, lk) => fmt!{\"ref(%s,%s)\", val_str(ccx.tn, v),\n-                                ty_to_str(ccx.tcx, t)}\n+      env_copy(v, t, lk) => fmt!(\"copy(%s,%s)\", val_str(ccx.tn, v),\n+                                ty_to_str(ccx.tcx, t)),\n+      env_move(v, t, lk) => fmt!(\"move(%s,%s)\", val_str(ccx.tn, v),\n+                                ty_to_str(ccx.tcx, t)),\n+      env_ref(v, t, lk) => fmt!(\"ref(%s,%s)\", val_str(ccx.tn, v),\n+                                ty_to_str(ccx.tcx, t))\n     }\n }\n \n@@ -129,7 +129,7 @@ fn mk_closure_tys(tcx: ty::ctxt,\n         });\n     }\n     let cdata_ty = ty::mk_tup(tcx, bound_tys);\n-    debug!{\"cdata_ty=%s\", ty_to_str(tcx, cdata_ty)};\n+    debug!(\"cdata_ty=%s\", ty_to_str(tcx, cdata_ty));\n     return cdata_ty;\n }\n \n@@ -195,16 +195,16 @@ fn store_environment(bcx: block,\n     let cboxptr_ty = ty::mk_ptr(tcx, {ty:cbox_ty, mutbl:ast::m_imm});\n \n     let llbox = PointerCast(bcx, llbox, type_of(ccx, cboxptr_ty));\n-    debug!{\"tuplify_box_ty = %s\", ty_to_str(tcx, cbox_ty)};\n+    debug!(\"tuplify_box_ty = %s\", ty_to_str(tcx, cbox_ty));\n \n     // Copy expr values into boxed bindings.\n     let mut bcx = bcx;\n     do vec::iteri(bound_values) |i, bv| {\n-        debug!{\"Copy %s into closure\", ev_to_str(ccx, bv)};\n+        debug!(\"Copy %s into closure\", ev_to_str(ccx, bv));\n \n         if !ccx.sess.no_asm_comments() {\n-            add_comment(bcx, fmt!{\"Copy %s into closure\",\n-                                  ev_to_str(ccx, bv)});\n+            add_comment(bcx, fmt!(\"Copy %s into closure\",\n+                                  ev_to_str(ccx, bv)));\n         }\n \n         let bound_data = GEPi(bcx, llbox,\n@@ -225,9 +225,9 @@ fn store_environment(bcx: block,\n             bcx = move_val(bcx, INIT, bound_data, src, ty);\n           }\n           env_ref(val, ty, lv_owned) => {\n-            debug!{\"> storing %s into %s\",\n+            debug!(\"> storing %s into %s\",\n                    val_str(bcx.ccx().tn, val),\n-                   val_str(bcx.ccx().tn, bound_data)};\n+                   val_str(bcx.ccx().tn, bound_data));\n             Store(bcx, val, bound_data);\n           }\n           env_ref(val, ty, lv_owned_imm) => {\n@@ -259,13 +259,13 @@ fn build_closure(bcx0: block,\n \n     // Package up the captured upvars\n     do vec::iter(cap_vars) |cap_var| {\n-        debug!{\"Building closure: captured variable %?\", cap_var};\n+        debug!(\"Building closure: captured variable %?\", cap_var);\n         let lv = trans_local_var(bcx, cap_var.def);\n         let nid = ast_util::def_id_of_def(cap_var.def).node;\n-        debug!{\"Node id is %s\",\n+        debug!(\"Node id is %s\",\n                syntax::ast_map::node_id_to_str\n                    (bcx.ccx().tcx.items, nid,\n-                    bcx.ccx().sess.parse_sess.interner)};\n+                    bcx.ccx().sess.parse_sess.interner));\n         let mut ty = node_id_type(bcx, nid);\n         match cap_var.mode {\n           capture::cap_ref => {"}, {"sha": "47b427f387226e3e9d72e4af9833bce6900bb68a", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -256,9 +256,9 @@ fn cleanup_type(cx: ty::ctxt, ty: ty::t) -> cleantype {\n \n fn add_clean(cx: block, val: ValueRef, ty: ty::t) {\n     if !ty::type_needs_drop(cx.tcx(), ty) { return; }\n-    debug!{\"add_clean(%s, %s, %s)\",\n+    debug!(\"add_clean(%s, %s, %s)\",\n            cx.to_str(), val_str(cx.ccx().tn, val),\n-           ty_to_str(cx.ccx().tcx, ty)};\n+           ty_to_str(cx.ccx().tcx, ty));\n     let cleanup_type = cleanup_type(cx.tcx(), ty);\n     do in_scope_cx(cx) |info| {\n         vec::push(info.cleanups, clean(|a| base::drop_ty(a, val, ty),\n@@ -268,9 +268,9 @@ fn add_clean(cx: block, val: ValueRef, ty: ty::t) {\n }\n fn add_clean_temp(cx: block, val: ValueRef, ty: ty::t) {\n     if !ty::type_needs_drop(cx.tcx(), ty) { return; }\n-    debug!{\"add_clean_temp(%s, %s, %s)\",\n+    debug!(\"add_clean_temp(%s, %s, %s)\",\n            cx.to_str(), val_str(cx.ccx().tn, val),\n-           ty_to_str(cx.ccx().tcx, ty)};\n+           ty_to_str(cx.ccx().tcx, ty));\n     let cleanup_type = cleanup_type(cx.tcx(), ty);\n     fn do_drop(bcx: block, val: ValueRef, ty: ty::t) ->\n        block {\n@@ -288,9 +288,9 @@ fn add_clean_temp(cx: block, val: ValueRef, ty: ty::t) {\n }\n fn add_clean_temp_mem(cx: block, val: ValueRef, ty: ty::t) {\n     if !ty::type_needs_drop(cx.tcx(), ty) { return; }\n-    debug!{\"add_clean_temp_mem(%s, %s, %s)\",\n+    debug!(\"add_clean_temp_mem(%s, %s, %s)\",\n            cx.to_str(), val_str(cx.ccx().tn, val),\n-           ty_to_str(cx.ccx().tcx, ty)};\n+           ty_to_str(cx.ccx().tcx, ty));\n     let cleanup_type = cleanup_type(cx.tcx(), ty);\n     do in_scope_cx(cx) |info| {\n         vec::push(info.cleanups,\n@@ -475,8 +475,8 @@ fn in_scope_cx(cx: block, f: fn(scope_info)) {\n fn block_parent(cx: block) -> block {\n     match cx.parent {\n       some(b) => b,\n-      none    => cx.sess().bug(fmt!{\"block_parent called on root block %?\",\n-                                   cx})\n+      none    => cx.sess().bug(fmt!(\"block_parent called on root block %?\",\n+                                   cx))\n     }\n }\n \n@@ -496,10 +496,10 @@ impl block {\n     fn to_str() -> ~str {\n         match self.node_info {\n           some(node_info) => {\n-            fmt!{\"[block %d]\", node_info.id}\n+            fmt!(\"[block %d]\", node_info.id)\n           }\n           none => {\n-            fmt!{\"[block %x]\", ptr::addr_of(*self) as uint}\n+            fmt!(\"[block %x]\", ptr::addr_of(*self) as uint)\n           }\n         }\n     }\n@@ -876,7 +876,7 @@ fn C_cstr(cx: @crate_ctxt, s: ~str) -> ValueRef {\n         llvm::LLVMConstString(buf, str::len(s) as c_uint, False)\n     };\n     let g =\n-        str::as_c_str(fmt!{\"str%u\", cx.names(~\"str\")},\n+        str::as_c_str(fmt!(\"str%u\", cx.names(~\"str\")),\n                     |buf| llvm::LLVMAddGlobal(cx.llmod, val_ty(sc), buf));\n     llvm::LLVMSetInitializer(g, sc);\n     llvm::LLVMSetGlobalConstant(g, True);\n@@ -930,7 +930,7 @@ fn C_bytes(bytes: ~[u8]) -> ValueRef unsafe {\n \n fn C_shape(ccx: @crate_ctxt, bytes: ~[u8]) -> ValueRef {\n     let llshape = C_bytes(bytes);\n-    let llglobal = str::as_c_str(fmt!{\"shape%u\", ccx.names(~\"shape\")}, |buf| {\n+    let llglobal = str::as_c_str(fmt!(\"shape%u\", ccx.names(~\"shape\")), |buf| {\n         llvm::LLVMAddGlobal(ccx.llmod, val_ty(llshape), buf)\n     });\n     llvm::LLVMSetInitializer(llglobal, llshape);\n@@ -1025,8 +1025,8 @@ fn field_idx_strict(cx: ty::ctxt, sp: span, ident: ast::ident,\n     -> uint {\n     match ty::field_idx(ident, fields) {\n        none => cx.sess.span_bug(\n-           sp, fmt!{\"base expr doesn't appear to \\\n-                         have a field named %s\", cx.sess.str_of(ident)}),\n+           sp, fmt!(\"base expr doesn't appear to \\\n+                         have a field named %s\", cx.sess.str_of(ident))),\n        some(i) => i\n     }\n }"}, {"sha": "18603f0edebdf71f9fc4faf12a49a4d4a0095229", "filename": "src/rustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -179,7 +179,7 @@ fn create_compile_unit(cx: @crate_ctxt)\n                          lli32(DW_LANG_RUST),\n                          llstr(crate_name),\n                          llstr(work_dir),\n-                         llstr(env!{\"CFG_VERSION\"}),\n+                         llstr(env!(\"CFG_VERSION\")),\n                          lli1(true), // deprecated: main compile unit\n                          lli1(cx.sess.opts.optimize != session::No),\n                          llstr(~\"\"), // flags (???)\n@@ -712,7 +712,7 @@ fn create_function(fcx: fn_ctxt) -> @metadata<subprogram_md> {\n     let cx = fcx.ccx;\n     let dbg_cx = option::get(cx.dbg_cx);\n \n-    debug!{\"~~\"};\n+    debug!(\"~~\");\n     log(debug, fcx.id);\n \n     let sp = option::get(fcx.span);"}, {"sha": "d5255bd17137b96418fe7e398c4e1a1d1e0b95ec", "filename": "src/rustc/middle/trans/foreign.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -931,10 +931,10 @@ fn trans_intrinsic(ccx: @crate_ctxt, decl: ValueRef, item: @ast::foreign_item,\n               ast_map::node_expr(e) => e.span\n             };\n             ccx.sess.span_fatal(\n-                sp, fmt!{\"reinterpret_cast called on types \\\n+                sp, fmt!(\"reinterpret_cast called on types \\\n                           with different size: %s (%u) to %s (%u)\",\n                          ty_to_str(ccx.tcx, tp_ty), tp_sz,\n-                         ty_to_str(ccx.tcx, substs.tys[1]), out_sz});\n+                         ty_to_str(ccx.tcx, substs.tys[1]), out_sz));\n         }\n         if !ty::type_is_nil(substs.tys[1]) {\n             let cast = PointerCast(bcx, get_param(decl, first_real_arg),"}, {"sha": "5ea2d8625e60930489845880f6b05f0edf6a2295", "filename": "src/rustc/middle/trans/reachable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -174,9 +174,9 @@ fn traverse_inline_body(cx: ctx, body: blk) {\n                 some(d) => {\n                   traverse_def_id(cx, def_id_of_def(d));\n                 }\n-                none      => cx.tcx.sess.span_bug(e.span, fmt!{\"Unbound node \\\n+                none      => cx.tcx.sess.span_bug(e.span, fmt!(\"Unbound node \\\n                   id %? while traversing %s\", e.id,\n-                  expr_to_str(e, cx.tcx.sess.intr())})\n+                  expr_to_str(e, cx.tcx.sess.intr())))\n             }\n           }\n           expr_field(_, _, _) => {"}, {"sha": "3894c43b4e245939b579fdb26f65aa5b360fe5c0", "filename": "src/rustc/middle/trans/reflect.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -63,15 +63,15 @@ impl reflector {\n         let get_lval = |bcx| {\n             let callee =\n                 impl::trans_trait_callee(bcx, v, mth_ty, mth_idx);\n-            debug!{\"calling mth ty %s, lltype %s\",\n+            debug!(\"calling mth ty %s, lltype %s\",\n                    ty_to_str(bcx.ccx().tcx, mth_ty),\n-                   val_str(bcx.ccx().tn, callee.val)};\n+                   val_str(bcx.ccx().tn, callee.val));\n             callee\n         };\n-        debug!{\"passing %u args:\", vec::len(args)};\n+        debug!(\"passing %u args:\", vec::len(args));\n         let bcx = self.bcx;\n         for args.eachi |i, a| {\n-            debug!{\"arg %u: %s\", i, val_str(bcx.ccx().tn, a)};\n+            debug!(\"arg %u: %s\", i, val_str(bcx.ccx().tn, a));\n         }\n         let d = empty_dest_cell();\n         let bcx =\n@@ -112,8 +112,8 @@ impl reflector {\n     fn visit_ty(t: ty::t) {\n \n         let bcx = self.bcx;\n-        debug!{\"reflect::visit_ty %s\",\n-               ty_to_str(bcx.ccx().tcx, t)};\n+        debug!(\"reflect::visit_ty %s\",\n+               ty_to_str(bcx.ccx().tcx, t));\n \n         match ty::get(t).struct {\n           ty::ty_bot => self.leaf(~\"bot\"),"}, {"sha": "6ba3ac38dc365a156cd4af1a078496b097395ca9", "filename": "src/rustc/middle/trans/tvec.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -209,9 +209,9 @@ fn trans_evec(bcx: block, elements: evec_elements,\n \n     // Store the individual elements.\n     let mut i = 0u, temp_cleanups = ~[val];\n-    debug!{\"trans_evec: v: %s, dataptr: %s\",\n+    debug!(\"trans_evec: v: %s, dataptr: %s\",\n            val_str(ccx.tn, val),\n-           val_str(ccx.tn, dataptr)};\n+           val_str(ccx.tn, dataptr));\n     match elements {\n         individual_evec(args) => {\n             for vec::each(args) |e| {\n@@ -309,7 +309,7 @@ fn get_base_and_len(cx: block, v: ValueRef, e_ty: ty::t)\n         (base, len)\n       }\n       ty::vstore_uniq | ty::vstore_box => {\n-        debug!{\"get_base_and_len: %s\", val_str(ccx.tn, v)};\n+        debug!(\"get_base_and_len: %s\", val_str(ccx.tn, v));\n         let body = tvec::get_bodyptr(cx, v);\n         (tvec::get_dataptr(cx, body), tvec::get_fill(cx, body))\n       }\n@@ -325,13 +325,13 @@ fn trans_estr(bcx: block, s: @~str, vstore: option<ast::vstore>,\n     let c = match vstore {\n       some(ast::vstore_fixed(_)) => {\n         // \"hello\"/_  =>  \"hello\"/5  =>  ~[i8 x 6] in llvm\n-        debug!{\"trans_estr: fixed: %s\", *s};\n+        debug!(\"trans_estr: fixed: %s\", *s);\n         C_postr(*s)\n       }\n \n       some(ast::vstore_slice(_)) | none => {\n         // \"hello\"  =>  (*i8, 6u) in llvm\n-        debug!{\"trans_estr: slice '%s'\", *s};\n+        debug!(\"trans_estr: slice '%s'\", *s);\n         C_estr_slice(ccx, *s)\n       }\n \n@@ -352,7 +352,7 @@ fn trans_estr(bcx: block, s: @~str, vstore: option<ast::vstore>,\n       }\n     };\n \n-    debug!{\"trans_estr: type: %s\", val_str(ccx.tn, c)};\n+    debug!(\"trans_estr: type: %s\", val_str(ccx.tn, c));\n     base::store_in_dest(bcx, c, dest)\n }\n "}, {"sha": "c5d7b5d74498d35edb2d184347e563b4b1b38a09", "filename": "src/rustc/middle/trans/type_of.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -67,7 +67,7 @@ fn type_of_non_gc_box(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n }\n \n fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n-    debug!{\"type_of %?: %?\", t, ty::get(t)};\n+    debug!(\"type_of %?: %?\", t, ty::get(t));\n \n     // Check the cache.\n     if cx.lltypes.contains_key(t) { return cx.lltypes.get(t); }\n@@ -203,7 +203,7 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n fn fill_type_of_enum(cx: @crate_ctxt, did: ast::def_id, t: ty::t,\n                      llty: TypeRef) {\n \n-    debug!{\"type_of_enum %?: %?\", t, ty::get(t)};\n+    debug!(\"type_of_enum %?: %?\", t, ty::get(t));\n \n     let lltys = {\n         let degen = (*ty::enum_variants(cx.tcx, did)).len() == 1u;\n@@ -227,7 +227,7 @@ fn llvm_type_name(cx: @crate_ctxt, t: ty::t) -> ~str {\n       ty::ty_enum(did, substs) => (~\"enum\", did, substs.tps),\n       ty::ty_class(did, substs) => (~\"class\", did, substs.tps)\n     };\n-    return fmt!{\n+    return fmt!(\n         \"%s %s[#%d]\",\n         name,\n         util::ppaux::parameterized(\n@@ -236,7 +236,7 @@ fn llvm_type_name(cx: @crate_ctxt, t: ty::t) -> ~str {\n             none,\n             tps),\n         did.crate\n-    };\n+    );\n }\n \n fn type_of_dtor(ccx: @crate_ctxt, self_ty: ty::t) -> TypeRef {"}, {"sha": "1b084670f94e144ab973303e6f72aa6cacb9773e", "filename": "src/rustc/middle/trans/type_use.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -61,8 +61,8 @@ fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n     }\n     let map_node = match ccx.tcx.items.find(fn_id_loc.node) {\n         some(x) => x,\n-        none    => ccx.sess.bug(fmt!{\"type_uses_for: unbound item ID %?\",\n-                                     fn_id_loc})\n+        none    => ccx.sess.bug(fmt!(\"type_uses_for: unbound item ID %?\",\n+                                     fn_id_loc))\n     };\n     match map_node {\n       ast_map::node_item(@{node: item_fn(_, _, body), _}, _) |"}, {"sha": "1d5d5d6f4fa497bad74ae33425739fd3816425dc", "filename": "src/rustc/middle/trans/uniq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -41,8 +41,8 @@ fn duplicate(bcx: block, v: ValueRef, t: ty::t) -> result {\n     let src_box = v;\n     let src_body = opaque_box_body(bcx, content_ty, src_box);\n     let src_body = load_if_immediate(bcx, src_body, content_ty);\n-    debug!{\"ST: %?\", val_str(bcx.ccx().tn, src_body)};\n-    debug!{\"DT: %?\", val_str(bcx.ccx().tn, dst_body)};\n+    debug!(\"ST: %?\", val_str(bcx.ccx().tn, src_body));\n+    debug!(\"DT: %?\", val_str(bcx.ccx().tn, dst_body));\n     let bcx = copy_val(bcx, INIT, dst_body, src_body, content_ty);\n \n     let src_tydesc_ptr = GEPi(bcx, src_box,"}, {"sha": "8dcbe2251b8f77a8ac9539d9c9c6eb5684125fef", "filename": "src/rustc/middle/tstate/annotate.rs", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftstate%2Fannotate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftstate%2Fannotate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fannotate.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -0,0 +1,76 @@\n+\n+import syntax::ast::*;\n+import syntax::visit;\n+import syntax::codemap::span;\n+import syntax::print::pprust::stmt_to_str;\n+import aux::{num_constraints, get_fn_info, crate_ctxt, add_node};\n+import ann::empty_ann;\n+import pat_util::pat_binding_ids;\n+\n+fn collect_ids_expr(e: @expr, rs: @mut ~[node_id]) { vec::push(*rs, e.id); }\n+\n+fn collect_ids_block(b: blk, rs: @mut ~[node_id]) {\n+    vec::push(*rs, b.node.id);\n+}\n+\n+fn collect_ids_stmt(s: @stmt, rs: @mut ~[node_id]) {\n+    match s.node {\n+      stmt_decl(_, id) | stmt_expr(_, id) | stmt_semi(_, id) {\n+        debug!(\"node_id %s\", int::str(id));\n+        debug!(\"%s\", stmt_to_str(*s));\n+        vec::push(*rs, id);\n+      }\n+    }\n+}\n+\n+fn collect_ids_local(tcx: ty::ctxt, l: @local, rs: @mut ~[node_id]) {\n+    vec::push_all(*rs, pat_binding_ids(tcx.def_map, l.node.pat));\n+}\n+\n+fn node_ids_in_fn(tcx: ty::ctxt, body: blk, rs: @mut ~[node_id]) {\n+    let collect_ids =\n+        visit::mk_simple_visitor(@{visit_expr: |a| collect_ids_expr(a, rs),\n+                                   visit_block: |a| collect_ids_block(a, rs),\n+                                   visit_stmt: |a| collect_ids_stmt(a, rs),\n+                                   visit_local: |a|\n+                                       collect_ids_local(tcx, a, rs)\n+                                   with *visit::default_simple_visitor()});\n+    collect_ids.visit_block(body, (), collect_ids);\n+}\n+\n+fn init_vecs(ccx: crate_ctxt, node_ids: ~[node_id], len: uint) {\n+    for node_ids.each |i| {\n+        log(debug, int::str(i) + ~\" |-> \" + uint::str(len));\n+        add_node(ccx, i, empty_ann(len));\n+    }\n+}\n+\n+fn visit_fn(ccx: crate_ctxt, num_constraints: uint, body: blk) {\n+    let node_ids: @mut ~[node_id] = @mut ~[];\n+    node_ids_in_fn(ccx.tcx, body, node_ids);\n+    let node_id_vec = *node_ids;\n+    init_vecs(ccx, node_id_vec, num_constraints);\n+}\n+\n+fn annotate_in_fn(ccx: crate_ctxt, _fk: visit::fn_kind, _decl: fn_decl,\n+                  body: blk, _sp: span, id: node_id) {\n+    let f_info = get_fn_info(ccx, id);\n+    visit_fn(ccx, num_constraints(f_info), body);\n+}\n+\n+fn annotate_crate(ccx: crate_ctxt, crate: crate) {\n+    let do_ann =\n+        visit::mk_simple_visitor(\n+            @{visit_fn: |a,b,c,d,e| annotate_in_fn(ccx, a, b, c, d, e)\n+              with *visit::default_simple_visitor()});\n+    visit::visit_crate(crate, (), do_ann);\n+}\n+//\n+// Local Variables:\n+// mode: rust\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// End:\n+//"}, {"sha": "805b13b4fe5efca9ce924b28f819218ae5658a39", "filename": "src/rustc/middle/tstate/auxiliary.rs", "status": "added", "additions": 990, "deletions": 0, "changes": 990, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -0,0 +1,990 @@\n+import option::*;\n+import pat_util::*;\n+import syntax::ast::*;\n+import syntax::ast_util::*;\n+import syntax::{visit, codemap};\n+import codemap::span;\n+import std::map::{hashmap, int_hash};\n+import syntax::print::pprust::path_to_str;\n+import tstate::ann::{pre_and_post, pre_and_post_state, empty_ann, prestate,\n+                     poststate, precond, postcond,\n+                     set_prestate, set_poststate, set_in_poststate_,\n+                     extend_prestate, extend_poststate, set_precondition,\n+                     set_postcondition, ts_ann,\n+                     clear_in_postcond,\n+                     clear_in_poststate_};\n+import driver::session::session;\n+import dvec::{dvec, extensions};\n+import tritv::{trit, tfalse, ttrue, dont_care, t};\n+\n+import syntax::print::pprust::{constr_args_to_str, lit_to_str};\n+\n+// Used to communicate which operands should be invalidated\n+// to helper functions\n+enum oper_type {\n+    oper_move,\n+    oper_swap,\n+    oper_assign,\n+    oper_assign_op,\n+    oper_pure,\n+}\n+\n+/* logging funs */\n+fn def_id_to_str(d: def_id) -> ~str {\n+    return int::str(d.crate) + ~\",\" + int::str(d.node);\n+}\n+\n+fn comma_str(args: ~[@constr_arg_use]) -> ~str {\n+    let mut rslt = ~\"\";\n+    let mut comma = false;\n+    for args.each |a| {\n+        if comma { rslt += ~\", \"; } else { comma = true; }\n+        match a.node {\n+          carg_base { rslt += ~\"*\"; }\n+          carg_ident(i) { rslt += *i.ident; }\n+          carg_lit(l) { rslt += lit_to_str(l); }\n+        }\n+    }\n+    return rslt;\n+}\n+\n+fn constraint_to_str(tcx: ty::ctxt, c: sp_constr) -> ~str {\n+    return fmt!(\"%s(%s) - arising from %s\",\n+             path_to_str(c.node.path),\n+             comma_str(c.node.args),\n+             codemap::span_to_str(c.span, tcx.sess.codemap));\n+}\n+\n+fn tritv_to_str(fcx: fn_ctxt, v: tritv::t) -> ~str {\n+    let mut s = ~\"\";\n+    let mut comma = false;\n+    for constraints(fcx).each |p| {\n+        match v.get(p.bit_num) {\n+          dont_care { }\n+          tt {\n+            s +=\n+                if comma { ~\", \" } else { comma = true; ~\"\" } +\n+                    if tt == tfalse { ~\"!\" } else { ~\"\" } +\n+                    constraint_to_str(fcx.ccx.tcx, p.c);\n+          }\n+        }\n+    }\n+    return s;\n+}\n+\n+fn log_tritv(fcx: fn_ctxt, v: tritv::t) {\n+    log(debug, tritv_to_str(fcx, v));\n+}\n+\n+fn first_difference_string(fcx: fn_ctxt, expected: tritv::t, actual: tritv::t)\n+   -> ~str {\n+    let mut s = ~\"\";\n+    for constraints(fcx).each |c| {\n+      if expected.get(c.bit_num) == ttrue &&\n+         actual.get(c.bit_num) != ttrue {\n+            s = constraint_to_str(fcx.ccx.tcx, c.c);\n+            break;\n+        }\n+    }\n+    return s;\n+}\n+\n+fn log_tritv_err(fcx: fn_ctxt, v: tritv::t) {\n+    log(error, tritv_to_str(fcx, v));\n+}\n+\n+fn tos(v: ~[uint]) -> ~str {\n+    let mut rslt = ~\"\";\n+    for v.each |i| {\n+        if i == 0u {\n+            rslt += ~\"0\";\n+        } else if i == 1u { rslt += ~\"1\"; } else { rslt += ~\"?\"; }\n+    }\n+    return rslt;\n+}\n+\n+fn log_cond(v: ~[uint]) { log(debug, tos(v)); }\n+\n+fn log_cond_err(v: ~[uint]) { log(error, tos(v)); }\n+\n+fn log_pp(pp: pre_and_post) {\n+    let p1 = pp.precondition.to_vec();\n+    let p2 = pp.postcondition.to_vec();\n+    debug!(\"pre:\");\n+    log_cond(p1);\n+    debug!(\"post:\");\n+    log_cond(p2);\n+}\n+\n+fn log_pp_err(pp: pre_and_post) {\n+    let p1 = pp.precondition.to_vec();\n+    let p2 = pp.postcondition.to_vec();\n+    error!(\"pre:\");\n+    log_cond_err(p1);\n+    error!(\"post:\");\n+    log_cond_err(p2);\n+}\n+\n+fn log_states(pp: pre_and_post_state) {\n+    let p1 = pp.prestate.to_vec();\n+    let p2 = pp.poststate.to_vec();\n+    debug!(\"prestate:\");\n+    log_cond(p1);\n+    debug!(\"poststate:\");\n+    log_cond(p2);\n+}\n+\n+fn log_states_err(pp: pre_and_post_state) {\n+    let p1 = pp.prestate.to_vec();\n+    let p2 = pp.poststate.to_vec();\n+    error!(\"prestate:\");\n+    log_cond_err(p1);\n+    error!(\"poststate:\");\n+    log_cond_err(p2);\n+}\n+\n+fn print_ident(i: ident) { log(debug, ~\" \" + *i + ~\" \"); }\n+\n+fn print_idents(&idents: ~[ident]) {\n+    if vec::len::<ident>(idents) == 0u { return; }\n+    log(debug, ~\"an ident: \" + *vec::pop::<ident>(idents));\n+    print_idents(idents);\n+}\n+\n+\n+/* data structures */\n+\n+/**********************************************************************/\n+\n+/* Two different data structures represent constraints in different\n+ contexts: constraint and norm_constraint.\n+\n+constraint gets used to record constraints in a table keyed by def_ids.  Each\n+constraint has a single operator but a list of possible argument lists, and\n+thus represents several constraints at once, one for each possible argument\n+list.\n+\n+norm_constraint, in contrast, gets used when handling an instance of a\n+constraint rather than a definition of a constraint. It has only a single\n+argument list.\n+\n+The representation of constraints, where multiple instances of the\n+same predicate are collapsed into one entry in the table, makes it\n+easier to look up a specific instance.\n+\n+Both types are in constrast with the constraint type defined in\n+syntax::ast, which is for predicate constraints only, and is what\n+gets generated by the parser. aux and ast share the same type\n+to represent predicate *arguments* however. This type\n+(constr_arg_general) is parameterized (see comments in syntax::ast).\n+\n+Both types store an ident and span, for error-logging purposes.\n+*/\n+type pred_args_ = {args: ~[@constr_arg_use], bit_num: uint};\n+\n+type pred_args = spanned<pred_args_>;\n+\n+// The attached node ID is the *defining* node ID\n+// for this local.\n+type constr_arg_use = spanned<constr_arg_general_<inst>>;\n+\n+/* Predicate constraints refer to the truth value of a predicate on variables\n+(definitely false, maybe true, or definitely true).  The <path> field (and the\n+<def_id> field in the npred constructor) names a user-defined function that\n+may be the operator in a \"check\" expression in the source.  */\n+\n+type constraint = {\n+    path: @path,\n+    // FIXME (#2539): really only want it to be mut during\n+    // collect_locals.  freeze it after that.\n+    descs: @dvec<pred_args>\n+};\n+\n+type tsconstr = {\n+    path: @path,\n+    def_id: def_id,\n+    args: ~[@constr_arg_use]\n+};\n+\n+type sp_constr = spanned<tsconstr>;\n+\n+type norm_constraint = {bit_num: uint, c: sp_constr};\n+\n+type constr_map = std::map::hashmap<def_id, constraint>;\n+\n+/* Contains stuff that has to be computed up front */\n+/* For easy access, the fn_info stores two special constraints for each\n+function.  So we need context. And so it seems clearer to just have separate\n+constraints. */\n+type fn_info =\n+    /* list, accumulated during pre/postcondition\n+    computation, of all local variables that may be\n+    used */\n+    // Doesn't seem to work without the @ -- bug\n+    {constrs: constr_map,\n+     num_constraints: uint,\n+     cf: ret_style,\n+     used_vars: @mut ~[node_id],\n+     ignore: bool};\n+\n+/* mapping from node ID to typestate annotation */\n+type node_ann_table = @mut ~[mut ts_ann];\n+\n+\n+/* mapping from function name to fn_info map */\n+type fn_info_map = std::map::hashmap<node_id, fn_info>;\n+\n+type fn_ctxt =\n+    {enclosing: fn_info, id: node_id, name: ident, ccx: crate_ctxt};\n+\n+type crate_ctxt = {tcx: ty::ctxt, node_anns: node_ann_table, fm: fn_info_map};\n+\n+fn get_fn_info(ccx: crate_ctxt, id: node_id) -> fn_info {\n+    assert (ccx.fm.contains_key(id));\n+    return ccx.fm.get(id);\n+}\n+\n+fn add_node(ccx: crate_ctxt, i: node_id, a: ts_ann) {\n+    let sz = vec::len(*ccx.node_anns);\n+    if sz <= i as uint {\n+        vec::grow(*ccx.node_anns, (i as uint) - sz + 1u, empty_ann(0u));\n+    }\n+    ccx.node_anns[i] = a;\n+}\n+\n+fn get_ts_ann(ccx: crate_ctxt, i: node_id) -> option<ts_ann> {\n+    if i as uint < vec::len(*ccx.node_anns) {\n+        return some::<ts_ann>(ccx.node_anns[i]);\n+    } else { return none::<ts_ann>; }\n+}\n+\n+\n+/********* utils ********/\n+fn node_id_to_ts_ann(ccx: crate_ctxt, id: node_id) -> ts_ann {\n+    match get_ts_ann(ccx, id) {\n+      none {\n+        error!(\"node_id_to_ts_ann: no ts_ann for node_id %d\", id);\n+        fail;\n+      }\n+      some(tt) { return tt; }\n+    }\n+}\n+\n+fn node_id_to_poststate(ccx: crate_ctxt, id: node_id) -> poststate {\n+    debug!(\"node_id_to_poststate\");\n+    return node_id_to_ts_ann(ccx, id).states.poststate;\n+}\n+\n+fn stmt_to_ann(ccx: crate_ctxt, s: stmt) -> ts_ann {\n+    debug!(\"stmt_to_ann\");\n+    match s.node {\n+      stmt_decl(_, id) | stmt_expr(_, id) | stmt_semi(_, id) {\n+        return node_id_to_ts_ann(ccx, id);\n+      }\n+    }\n+}\n+\n+\n+/* fails if e has no annotation */\n+fn expr_states(ccx: crate_ctxt, e: @expr) -> pre_and_post_state {\n+    debug!(\"expr_states\");\n+    return node_id_to_ts_ann(ccx, e.id).states;\n+}\n+\n+\n+/* fails if e has no annotation */\n+fn expr_pp(ccx: crate_ctxt, e: @expr) -> pre_and_post {\n+    debug!(\"expr_pp\");\n+    return node_id_to_ts_ann(ccx, e.id).conditions;\n+}\n+\n+fn stmt_pp(ccx: crate_ctxt, s: stmt) -> pre_and_post {\n+    return stmt_to_ann(ccx, s).conditions;\n+}\n+\n+\n+/* fails if b has no annotation */\n+fn block_pp(ccx: crate_ctxt, b: blk) -> pre_and_post {\n+    debug!(\"block_pp\");\n+    return node_id_to_ts_ann(ccx, b.node.id).conditions;\n+}\n+\n+fn clear_pp(pp: pre_and_post) {\n+    ann::clear(pp.precondition);\n+    ann::clear(pp.postcondition);\n+}\n+\n+fn clear_precond(ccx: crate_ctxt, id: node_id) {\n+    let pp = node_id_to_ts_ann(ccx, id);\n+    ann::clear(pp.conditions.precondition);\n+}\n+\n+fn block_states(ccx: crate_ctxt, b: blk) -> pre_and_post_state {\n+    debug!(\"block_states\");\n+    return node_id_to_ts_ann(ccx, b.node.id).states;\n+}\n+\n+fn stmt_states(ccx: crate_ctxt, s: stmt) -> pre_and_post_state {\n+    return stmt_to_ann(ccx, s).states;\n+}\n+\n+fn expr_precond(ccx: crate_ctxt, e: @expr) -> precond {\n+    return expr_pp(ccx, e).precondition;\n+}\n+\n+fn expr_postcond(ccx: crate_ctxt, e: @expr) -> postcond {\n+    return expr_pp(ccx, e).postcondition;\n+}\n+\n+fn expr_prestate(ccx: crate_ctxt, e: @expr) -> prestate {\n+    return expr_states(ccx, e).prestate;\n+}\n+\n+fn expr_poststate(ccx: crate_ctxt, e: @expr) -> poststate {\n+    return expr_states(ccx, e).poststate;\n+}\n+\n+fn stmt_precond(ccx: crate_ctxt, s: stmt) -> precond {\n+    return stmt_pp(ccx, s).precondition;\n+}\n+\n+fn stmt_postcond(ccx: crate_ctxt, s: stmt) -> postcond {\n+    return stmt_pp(ccx, s).postcondition;\n+}\n+\n+fn states_to_poststate(ss: pre_and_post_state) -> poststate {\n+    return ss.poststate;\n+}\n+\n+fn stmt_prestate(ccx: crate_ctxt, s: stmt) -> prestate {\n+    return stmt_states(ccx, s).prestate;\n+}\n+\n+fn stmt_poststate(ccx: crate_ctxt, s: stmt) -> poststate {\n+    return stmt_states(ccx, s).poststate;\n+}\n+\n+fn block_precond(ccx: crate_ctxt, b: blk) -> precond {\n+    return block_pp(ccx, b).precondition;\n+}\n+\n+fn block_postcond(ccx: crate_ctxt, b: blk) -> postcond {\n+    return block_pp(ccx, b).postcondition;\n+}\n+\n+fn block_prestate(ccx: crate_ctxt, b: blk) -> prestate {\n+    return block_states(ccx, b).prestate;\n+}\n+\n+fn block_poststate(ccx: crate_ctxt, b: blk) -> poststate {\n+    return block_states(ccx, b).poststate;\n+}\n+\n+fn set_prestate_ann(ccx: crate_ctxt, id: node_id, pre: prestate) -> bool {\n+    debug!(\"set_prestate_ann\");\n+    return set_prestate(node_id_to_ts_ann(ccx, id), pre);\n+}\n+\n+fn extend_prestate_ann(ccx: crate_ctxt, id: node_id, pre: prestate) -> bool {\n+    debug!(\"extend_prestate_ann\");\n+    return extend_prestate(node_id_to_ts_ann(ccx, id).states.prestate, pre);\n+}\n+\n+fn set_poststate_ann(ccx: crate_ctxt, id: node_id, post: poststate) -> bool {\n+    debug!(\"set_poststate_ann\");\n+    return set_poststate(node_id_to_ts_ann(ccx, id), post);\n+}\n+\n+fn extend_poststate_ann(ccx: crate_ctxt, id: node_id, post: poststate) ->\n+   bool {\n+    debug!(\"extend_poststate_ann\");\n+    return extend_poststate(\n+        node_id_to_ts_ann(ccx, id).states.poststate, post);\n+}\n+\n+fn set_pre_and_post(ccx: crate_ctxt, id: node_id, pre: precond,\n+                    post: postcond) {\n+    debug!(\"set_pre_and_post\");\n+    let tt = node_id_to_ts_ann(ccx, id);\n+    set_precondition(tt, pre);\n+    set_postcondition(tt, post);\n+}\n+\n+fn copy_pre_post(ccx: crate_ctxt, id: node_id, sub: @expr) {\n+    debug!(\"set_pre_and_post\");\n+    let p = expr_pp(ccx, sub);\n+    copy_pre_post_(ccx, id, p.precondition, p.postcondition);\n+}\n+\n+fn copy_pre_post_(ccx: crate_ctxt, id: node_id, pre: prestate,\n+                  post: poststate) {\n+    debug!(\"set_pre_and_post\");\n+    let tt = node_id_to_ts_ann(ccx, id);\n+    set_precondition(tt, pre);\n+    set_postcondition(tt, post);\n+}\n+\n+/* sets all bits to *1* */\n+fn set_postcond_false(ccx: crate_ctxt, id: node_id) {\n+    let p = node_id_to_ts_ann(ccx, id);\n+    ann::set(p.conditions.postcondition);\n+}\n+\n+fn pure_exp(ccx: crate_ctxt, id: node_id, p: prestate) -> bool {\n+    return set_prestate_ann(ccx, id, p) | set_poststate_ann(ccx, id, p);\n+}\n+\n+fn num_constraints(m: fn_info) -> uint { return m.num_constraints; }\n+\n+fn new_crate_ctxt(cx: ty::ctxt) -> crate_ctxt {\n+    let na: ~[mut ts_ann] = ~[mut];\n+    return {tcx: cx, node_anns: @mut na, fm: int_hash::<fn_info>()};\n+}\n+\n+/* Use e's type to determine whether it returns.\n+ If it has a function type with a ! annotation,\n+the answer is noreturn. */\n+fn controlflow_expr(ccx: crate_ctxt, e: @expr) -> ret_style {\n+    match ty::get(ty::node_id_to_type(ccx.tcx, e.id)).struct {\n+      ty::ty_fn(f) { return f.ret_style; }\n+      _ { return return_val; }\n+    }\n+}\n+\n+fn constraints_expr(cx: ty::ctxt, e: @expr) -> ~[@ty::constr] {\n+    match ty::get(ty::node_id_to_type(cx, e.id)).struct {\n+      ty::ty_fn(f) { return f.constraints; }\n+      _ { return ~[]; }\n+    }\n+}\n+\n+fn node_id_to_def_strict(cx: ty::ctxt, id: node_id) -> def {\n+    match cx.def_map.find(id) {\n+      none {\n+        error!(\"node_id_to_def: node_id %d has no def\", id);\n+        fail;\n+      }\n+      some(d) { return d; }\n+    }\n+}\n+\n+fn node_id_to_def(ccx: crate_ctxt, id: node_id) -> option<def> {\n+    return ccx.tcx.def_map.find(id);\n+}\n+\n+fn norm_a_constraint(id: def_id, c: constraint) -> ~[norm_constraint] {\n+    let mut rslt: ~[norm_constraint] = ~[];\n+    for (*c.descs).each |pd| {\n+        vec::push(rslt,\n+                  {bit_num: pd.node.bit_num,\n+                   c: respan(pd.span, {path: c.path,\n+                                       def_id: id,\n+                                       args: pd.node.args})});\n+    }\n+    return rslt;\n+}\n+\n+\n+// Tried to write this as an iterator, but I got a\n+// non-exhaustive match in trans.\n+fn constraints(fcx: fn_ctxt) -> ~[norm_constraint] {\n+    let mut rslt: ~[norm_constraint] = ~[];\n+    for fcx.enclosing.constrs.each |key, val| {\n+        vec::push_all(rslt, norm_a_constraint(key, val));\n+    };\n+    return rslt;\n+}\n+\n+// FIXME (#2539): Would rather take an immutable vec as an argument,\n+// should freeze it at some earlier point.\n+fn match_args(fcx: fn_ctxt, occs: @dvec<pred_args>,\n+              occ: ~[@constr_arg_use]) -> uint {\n+    debug!(\"match_args: looking at %s\",\n+           constr_args_to_str(fn@(i: inst) -> ~str { *i.ident }, occ));\n+    for (*occs).each |pd| {\n+        log(debug,\n+                 ~\"match_args: candidate \" + pred_args_to_str(pd));\n+        fn eq(p: inst, q: inst) -> bool { return p.node == q.node; }\n+        if ty::args_eq(eq, pd.node.args, occ) { return pd.node.bit_num; }\n+    }\n+    fcx.ccx.tcx.sess.bug(~\"match_args: no match for occurring args\");\n+}\n+\n+fn def_id_for_constr(tcx: ty::ctxt, t: node_id) -> def_id {\n+    match tcx.def_map.find(t) {\n+      none {\n+        tcx.sess.bug(~\"node_id_for_constr: bad node_id \" + int::str(t));\n+      }\n+      some(def_fn(i, _)) { return i; }\n+      _ { tcx.sess.bug(~\"node_id_for_constr: pred is not a function\"); }\n+    }\n+}\n+\n+fn expr_to_constr_arg(tcx: ty::ctxt, e: @expr) -> @constr_arg_use {\n+    match e.node {\n+      expr_path(p) {\n+        match tcx.def_map.find(e.id) {\n+          some(def_local(nid, _)) | some(def_arg(nid, _)) |\n+          some(def_binding(nid, _)) | some(def_upvar(nid, _, _, _)) {\n+            return @respan(p.span,\n+                        carg_ident({ident: p.idents[0], node: nid}));\n+          }\n+          some(what) {\n+              tcx.sess.span_bug(e.span,\n+                 fmt!(\"exprs_to_constr_args: non-local variable %? \\\n+                                     as pred arg\", what));\n+          }\n+          none {\n+              tcx.sess.span_bug(e.span,\n+                 ~\"exprs_to_constr_args: unbound id as pred arg\");\n+\n+          }\n+        }\n+      }\n+      expr_lit(l) { return @respan(e.span, carg_lit(l)); }\n+      _ {\n+        tcx.sess.span_fatal(e.span,\n+                            ~\"arguments to constrained functions must be \" +\n+                                ~\"literals or local variables\");\n+      }\n+    }\n+}\n+\n+fn exprs_to_constr_args(tcx: ty::ctxt,\n+                        args: ~[@expr]) -> ~[@constr_arg_use] {\n+    let f = |a| expr_to_constr_arg(tcx, a);\n+    let mut rslt: ~[@constr_arg_use] = ~[];\n+    for args.each |e| { vec::push(rslt, f(e)); }\n+    rslt\n+}\n+\n+fn expr_to_constr(tcx: ty::ctxt, e: @expr) -> sp_constr {\n+    match e.node {\n+      expr_call(operator, args, _) {\n+        match operator.node {\n+          expr_path(p) {\n+            return respan(e.span,\n+                       {path: p,\n+                        def_id: def_id_for_constr(tcx, operator.id),\n+                        args: exprs_to_constr_args(tcx, args)});\n+          }\n+          _ {\n+            tcx.sess.span_bug(operator.span,\n+                              ~\"ill-formed operator in predicate\");\n+          }\n+        }\n+      }\n+      _ {\n+        tcx.sess.span_bug(e.span, ~\"ill-formed predicate\");\n+      }\n+    }\n+}\n+\n+fn pred_args_to_str(p: pred_args) -> ~str {\n+    ~\"<\" + uint::str(p.node.bit_num) + ~\", \" +\n+        constr_args_to_str(fn@(i: inst) -> ~str {return *i.ident; },\n+                           p.node.args)\n+        + ~\">\"\n+}\n+\n+fn substitute_constr_args(cx: ty::ctxt, actuals: ~[@expr], c: @ty::constr) ->\n+   tsconstr {\n+    let mut rslt: ~[@constr_arg_use] = ~[];\n+    for c.node.args.each |a| {\n+        vec::push(rslt, substitute_arg(cx, actuals, a));\n+    }\n+    return {path: c.node.path,\n+         def_id: c.node.id,\n+         args: rslt};\n+}\n+\n+fn substitute_arg(cx: ty::ctxt, actuals: ~[@expr], a: @constr_arg) ->\n+   @constr_arg_use {\n+    let num_actuals = vec::len(actuals);\n+    match a.node {\n+      carg_ident(i) {\n+        if i < num_actuals {\n+            return expr_to_constr_arg(cx, actuals[i]);\n+        } else {\n+            cx.sess.span_fatal(a.span, ~\"constraint argument out of bounds\");\n+        }\n+      }\n+      carg_base { return @respan(a.span, carg_base); }\n+      carg_lit(l) { return @respan(a.span, carg_lit(l)); }\n+    }\n+}\n+\n+fn pred_args_matches(pattern: ~[constr_arg_general_<inst>],\n+                     desc: pred_args) ->\n+   bool {\n+    let mut i = 0u;\n+    for desc.node.args.each |c| {\n+        let n = pattern[i];\n+        match c.node {\n+          carg_ident(p) {\n+            match n {\n+              carg_ident(q) { if p.node != q.node { return false; } }\n+              _ { return false; }\n+            }\n+          }\n+          carg_base { if n != carg_base { return false; } }\n+          carg_lit(l) {\n+            match n {\n+              carg_lit(m) { if !const_eval::lit_eq(l, m) { return false; } }\n+              _ { return false; }\n+            }\n+          }\n+        }\n+        i += 1u;\n+    }\n+    return true;\n+}\n+\n+fn find_instance_(pattern: ~[constr_arg_general_<inst>],\n+                  descs: ~[pred_args]) ->\n+   option<uint> {\n+    for descs.each |d| {\n+        if pred_args_matches(pattern, d) { return some(d.node.bit_num); }\n+    }\n+    return none;\n+}\n+\n+type inst = {ident: ident, node: node_id};\n+\n+enum dest {\n+    local_dest(inst), // RHS is assigned to a local variable\n+    call                        // RHS is passed to a function\n+}\n+\n+type subst = ~[{from: inst, to: inst}];\n+\n+fn find_instances(_fcx: fn_ctxt, subst: subst,\n+                  c: constraint) -> ~[{from: uint, to: uint}] {\n+\n+    if vec::len(subst) == 0u { return ~[]; }\n+    let mut res = ~[];\n+    do (*c.descs).swap |v| {\n+        let v <- vec::from_mut(v);\n+        for v.each |d| {\n+            if args_mention(d.node.args, find_in_subst_bool, subst) {\n+                let old_bit_num = d.node.bit_num;\n+                let newv = replace(subst, d);\n+                match find_instance_(newv, v) {\n+                  some(d1) {vec::push(res, {from: old_bit_num, to: d1})}\n+                  _ {}\n+                }\n+            } else {}\n+        }\n+        vec::to_mut(v)\n+    }\n+    return res;\n+}\n+\n+fn find_in_subst(id: node_id, s: subst) -> option<inst> {\n+    for s.each |p| {\n+        if id == p.from.node { return some(p.to); }\n+    }\n+    return none;\n+}\n+\n+fn find_in_subst_bool(s: subst, id: node_id) -> bool {\n+    is_some(find_in_subst(id, s))\n+}\n+\n+fn insts_to_str(stuff: ~[constr_arg_general_<inst>]) -> ~str {\n+    let mut rslt = ~\"<\";\n+    for stuff.each |i| {\n+        rslt +=\n+            ~\" \" +\n+                match i {\n+                  carg_ident(p) { *p.ident }\n+                  carg_base { ~\"*\" }\n+                  carg_lit(_) { ~\"~[lit]\" }\n+                } + ~\" \";\n+    }\n+    rslt += ~\">\";\n+    rslt\n+}\n+\n+fn replace(subst: subst, d: pred_args) -> ~[constr_arg_general_<inst>] {\n+    let mut rslt: ~[constr_arg_general_<inst>] = ~[];\n+    for d.node.args.each |c| {\n+        match c.node {\n+          carg_ident(p) {\n+            match find_in_subst(p.node, subst) {\n+              some(newv) { vec::push(rslt, carg_ident(newv)); }\n+              _ { vec::push(rslt, c.node); }\n+            }\n+          }\n+          _ {\n+            vec::push(rslt, c.node);\n+          }\n+        }\n+    }\n+\n+    return rslt;\n+}\n+\n+enum if_ty { if_check, plain_if, }\n+\n+fn for_constraints_mentioning(fcx: fn_ctxt, id: node_id,\n+                              f: fn(norm_constraint)) {\n+    for constraints(fcx).each |c| {\n+        if constraint_mentions(fcx, c, id) { f(c); }\n+    };\n+}\n+\n+fn local_node_id_to_def_id_strict(fcx: fn_ctxt, sp: span, i: node_id) ->\n+   def_id {\n+    match local_node_id_to_def(fcx, i) {\n+      some(def_local(nid, _)) | some(def_arg(nid, _)) |\n+      some(def_upvar(nid, _, _)) {\n+        return local_def(nid);\n+      }\n+      some(_) {\n+        fcx.ccx.tcx.sess.span_fatal(sp,\n+                                    ~\"local_node_id_to_def_id: id \\\n+               isn't a local\");\n+      }\n+      none {\n+        // should really be bug. span_bug()?\n+        fcx.ccx.tcx.sess.span_fatal(sp,\n+                                    ~\"local_node_id_to_def_id: id \\\n+               is unbound\");\n+      }\n+    }\n+}\n+\n+fn local_node_id_to_def(fcx: fn_ctxt, i: node_id) -> option<def> {\n+    fcx.ccx.tcx.def_map.find(i)\n+}\n+\n+fn local_node_id_to_def_id(fcx: fn_ctxt, i: node_id) -> option<def_id> {\n+    match local_node_id_to_def(fcx, i) {\n+      some(def_local(nid, _)) | some(def_arg(nid, _)) |\n+      some(def_binding(nid, _)) | some(def_upvar(nid, _, _)) {\n+        some(local_def(nid))\n+      }\n+      _ { none }\n+    }\n+}\n+\n+fn local_node_id_to_local_def_id(fcx: fn_ctxt, i: node_id) ->\n+   option<node_id> {\n+    match local_node_id_to_def_id(fcx, i) {\n+      some(did) { some(did.node) }\n+      _ { none }\n+    }\n+}\n+\n+fn copy_in_postcond(fcx: fn_ctxt, parent_exp: node_id, dest: inst, src: inst,\n+                    ty: oper_type) {\n+    let post =\n+        node_id_to_ts_ann(fcx.ccx, parent_exp).conditions.postcondition;\n+    copy_in_poststate_two(fcx, post, post, dest, src, ty);\n+}\n+\n+fn copy_in_poststate(fcx: fn_ctxt, post: poststate, dest: inst, src: inst,\n+                     ty: oper_type) {\n+    copy_in_poststate_two(fcx, post, post, dest, src, ty);\n+}\n+\n+// In target_post, set the bits corresponding to copies of any\n+// constraints mentioning src that are set in src_post, with\n+// dest substituted for src.\n+// (This doesn't create any new constraints. If a new, substituted\n+// constraint isn't already in the bit vector, it's ignored.)\n+fn copy_in_poststate_two(fcx: fn_ctxt, src_post: poststate,\n+                         target_post: poststate, dest: inst, src: inst,\n+                         ty: oper_type) {\n+    let mut subst;\n+    match ty {\n+      oper_swap { subst = ~[{from: dest, to: src}, {from: src, to: dest}]; }\n+      oper_assign_op {\n+        return; // Don't do any propagation\n+      }\n+      _ { subst = ~[{from: src, to: dest}]; }\n+    }\n+\n+\n+    for fcx.enclosing.constrs.each_value |val| {\n+        // replace any occurrences of the src def_id with the\n+        // dest def_id\n+        let insts = find_instances(fcx, subst, val);\n+        for insts.each |p| {\n+            if bitvectors::promises_(p.from, src_post) {\n+                set_in_poststate_(p.to, target_post);\n+            }\n+        }\n+    };\n+}\n+\n+fn forget_in_postcond(fcx: fn_ctxt, parent_exp: node_id, dead_v: node_id) {\n+    // In the postcondition given by parent_exp, clear the bits\n+    // for any constraints mentioning dead_v\n+    let d = local_node_id_to_local_def_id(fcx, dead_v);\n+    do option::iter(d) |d_id| {\n+        do for_constraints_mentioning(fcx, d_id) |c| {\n+                debug!(\"clearing constraint %u %s\",\n+                       c.bit_num,\n+                       constraint_to_str(fcx.ccx.tcx, c.c));\n+                clear_in_postcond(c.bit_num,\n+                                  node_id_to_ts_ann(fcx.ccx,\n+                                                    parent_exp).conditions);\n+        }\n+    };\n+}\n+\n+fn forget_in_poststate(fcx: fn_ctxt, p: poststate, dead_v: node_id) -> bool {\n+    // In the poststate given by parent_exp, clear the bits\n+    // for any constraints mentioning dead_v\n+    let d = local_node_id_to_local_def_id(fcx, dead_v);\n+    let mut changed = false;\n+    do option::iter(d) |d_id| {\n+        do for_constraints_mentioning(fcx, d_id) |c| {\n+                changed |= clear_in_poststate_(c.bit_num, p);\n+        }\n+    }\n+    return changed;\n+}\n+\n+fn any_eq(v: ~[node_id], d: node_id) -> bool {\n+    for v.each |i| { if i == d { return true; } }\n+    false\n+}\n+\n+fn constraint_mentions(_fcx: fn_ctxt, c: norm_constraint, v: node_id) ->\n+   bool {\n+    return args_mention(c.c.node.args, any_eq, ~[v]);\n+}\n+\n+fn args_mention<T>(args: ~[@constr_arg_use],\n+                   q: fn(~[T], node_id) -> bool,\n+                   s: ~[T]) -> bool {\n+\n+    for args.each |a| {\n+        match a.node {\n+          carg_ident(p1) { if q(s, p1.node) { return true; } } _ { }\n+        }\n+    }\n+    return false;\n+}\n+\n+fn use_var(fcx: fn_ctxt, v: node_id) {\n+    vec::push(*fcx.enclosing.used_vars, v);\n+}\n+\n+fn op_to_oper_ty(io: init_op) -> oper_type {\n+    match io { init_move { oper_move } _ { oper_assign } }\n+}\n+\n+// default function visitor\n+fn do_nothing<T>(_fk: visit::fn_kind, _decl: fn_decl, _body: blk,\n+                 _sp: span, _id: node_id,\n+                 _t: T, _v: visit::vt<T>) {\n+}\n+\n+\n+fn args_to_constr_args(tcx: ty::ctxt, args: ~[arg],\n+                       indices: ~[@sp_constr_arg<uint>])\n+    -> ~[@constr_arg_use] {\n+    let mut actuals: ~[@constr_arg_use] = ~[];\n+    let num_args = vec::len(args);\n+    for indices.each |a| {\n+        vec::push(\n+            actuals,\n+            @respan(a.span,\n+                    match a.node {\n+                        carg_base { carg_base }\n+                        carg_ident(i) {\n+                            if i < num_args {\n+                                carg_ident({ident: args[i].ident,\n+                                            node: args[i].id})\n+                            } else {\n+                                tcx.sess.span_bug(a.span,\n+                                                  ~\"index out of bounds in \\\n+                                                   constraint arg\");\n+                            }\n+                        }\n+                        carg_lit(l) { carg_lit(l) }\n+                    }));\n+    }\n+    return actuals;\n+}\n+\n+fn ast_constr_to_ts_constr(tcx: ty::ctxt, args: ~[arg], c: @constr) ->\n+   tsconstr {\n+    let tconstr = ty::ast_constr_to_constr(tcx, c);\n+    return {path: tconstr.node.path,\n+         def_id: tconstr.node.id,\n+         args: args_to_constr_args(tcx, args, tconstr.node.args)};\n+}\n+\n+fn ast_constr_to_sp_constr(tcx: ty::ctxt, args: ~[arg], c: @constr) ->\n+   sp_constr {\n+    let tconstr = ast_constr_to_ts_constr(tcx, args, c);\n+    return respan(c.span, tconstr);\n+}\n+\n+type binding = {lhs: ~[dest], rhs: option<initializer>};\n+\n+fn local_to_bindings(tcx: ty::ctxt, loc: @local) -> binding {\n+    let mut lhs = ~[];\n+    do pat_bindings(tcx.def_map, loc.node.pat) |_bm, p_id, _s, name| {\n+      vec::push(lhs, local_dest({ident: path_to_ident(name), node: p_id}));\n+    };\n+    {lhs: lhs, rhs: loc.node.init}\n+}\n+\n+fn locals_to_bindings(tcx: ty::ctxt, locals: ~[@local]) -> ~[binding] {\n+    let mut rslt = ~[];\n+    for locals.each |loc| { vec::push(rslt, local_to_bindings(tcx, loc)); }\n+    return rslt;\n+}\n+\n+fn callee_modes(fcx: fn_ctxt, callee: node_id) -> ~[mode] {\n+    let ty = ty::type_autoderef(fcx.ccx.tcx,\n+                                ty::node_id_to_type(fcx.ccx.tcx, callee));\n+    match ty::get(ty).struct {\n+      ty::ty_fn({inputs: args, _}) {\n+        let mut modes = ~[];\n+        for args.each |arg| { vec::push(modes, arg.mode); }\n+        return modes;\n+      }\n+      _ {\n+        // Shouldn't happen; callee should be ty_fn.\n+        fcx.ccx.tcx.sess.bug(~\"non-fn callee type in callee_modes: \" +\n+                                 util::ppaux::ty_to_str(fcx.ccx.tcx, ty));\n+      }\n+    }\n+}\n+\n+fn callee_arg_init_ops(fcx: fn_ctxt, callee: node_id) -> ~[init_op] {\n+    do vec::map(callee_modes(fcx, callee)) |m| {\n+        match ty::resolved_mode(fcx.ccx.tcx, m) {\n+          by_move { init_move }\n+          by_copy | by_ref | by_val | by_mutbl_ref { init_assign }\n+        }\n+    }\n+}\n+\n+fn arg_bindings(ops: ~[init_op], es: ~[@expr]) -> ~[binding] {\n+    let mut bindings: ~[binding] = ~[];\n+    let mut i = 0u;\n+    for ops.each |op| {\n+        vec::push(bindings,\n+                  {lhs: ~[call], rhs: some({op: op, expr: es[i]})});\n+        i += 1u;\n+    }\n+    return bindings;\n+}\n+\n+//\n+// Local Variables:\n+// mode: rust\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// End:\n+//"}, {"sha": "c37f067e6981d761dd3871ce04c5fa0f0638d8e3", "filename": "src/rustc/middle/tstate/ck.rs", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftstate%2Fck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftstate%2Fck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fck.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -0,0 +1,153 @@\n+\n+import syntax::ast;\n+import ast::{stmt, fn_ident, node_id, crate, return_val, noreturn, expr};\n+import syntax::{visit, print};\n+import syntax::codemap::span;\n+import middle::ty;\n+import tstate::ann::{precond, prestate,\n+                     implies, ann_precond, ann_prestate};\n+import aux::*;\n+\n+import util::ppaux::ty_to_str;\n+import bitvectors::*;\n+import annotate::annotate_crate;\n+import collect_locals::mk_f_to_fn_info;\n+import pre_post_conditions::fn_pre_post;\n+import states::find_pre_post_state_fn;\n+import syntax::print::pprust::expr_to_str;\n+import driver::session::session;\n+import std::map::hashmap;\n+\n+fn check_states_expr(e: @expr, fcx: fn_ctxt, v: visit::vt<fn_ctxt>) {\n+    visit::visit_expr(e, fcx, v);\n+\n+    let prec: precond = expr_precond(fcx.ccx, e);\n+    let pres: prestate = expr_prestate(fcx.ccx, e);\n+\n+    if !implies(pres, prec) {\n+        let mut s = ~\"\";\n+        let diff = first_difference_string(fcx, prec, pres);\n+        s +=\n+            ~\"unsatisfied precondition constraint (for example, \" + diff +\n+                ~\") for expression:\\n\";\n+        s += syntax::print::pprust::expr_to_str(e);\n+        s += ~\"\\nprecondition:\\n\";\n+        s += tritv_to_str(fcx, prec);\n+        s += ~\"\\nprestate:\\n\";\n+        s += tritv_to_str(fcx, pres);\n+        fcx.ccx.tcx.sess.span_fatal(e.span, s);\n+    }\n+}\n+\n+fn check_states_stmt(s: @stmt, fcx: fn_ctxt, v: visit::vt<fn_ctxt>) {\n+    visit::visit_stmt(s, fcx, v);\n+\n+    let a = stmt_to_ann(fcx.ccx, *s);\n+    let prec: precond = ann_precond(a);\n+    let pres: prestate = ann_prestate(a);\n+\n+    debug!(\"check_states_stmt:\");\n+    log(debug, print::pprust::stmt_to_str(*s));\n+    debug!(\"prec = \");\n+    log_tritv(fcx, prec);\n+    debug!(\"pres = \");\n+    log_tritv(fcx, pres);\n+\n+    if !implies(pres, prec) {\n+        let mut ss = ~\"\";\n+        let diff = first_difference_string(fcx, prec, pres);\n+        ss +=\n+            ~\"unsatisfied precondition constraint (for example, \" + diff +\n+                ~\") for statement:\\n\";\n+        ss += syntax::print::pprust::stmt_to_str(*s);\n+        ss += ~\"\\nprecondition:\\n\";\n+        ss += tritv_to_str(fcx, prec);\n+        ss += ~\"\\nprestate: \\n\";\n+        ss += tritv_to_str(fcx, pres);\n+        fcx.ccx.tcx.sess.span_fatal(s.span, ss);\n+    }\n+}\n+\n+fn check_states_against_conditions(fcx: fn_ctxt,\n+                                   fk: visit::fn_kind,\n+                                   f_decl: ast::fn_decl,\n+                                   f_body: ast::blk,\n+                                   sp: span,\n+                                   id: node_id) {\n+    /* Postorder traversal instead of pre is important\n+       because we want the smallest possible erroneous statement\n+       or expression. */\n+    let visitor = visit::mk_vt(\n+        @{visit_stmt: check_states_stmt,\n+          visit_expr: check_states_expr,\n+          visit_fn: |a,b,c,d,e,f,g| {\n+              do_nothing::<fn_ctxt>(a, b, c, d, e, f, g)\n+          }\n+          with *visit::default_visitor::<fn_ctxt>()});\n+    visit::visit_fn(fk, f_decl, f_body, sp, id, fcx, visitor);\n+}\n+\n+fn check_fn_states(fcx: fn_ctxt,\n+                   fk: visit::fn_kind,\n+                   f_decl: ast::fn_decl,\n+                   f_body: ast::blk,\n+                   sp: span,\n+                   id: node_id) {\n+    /* Compute the pre- and post-states for this function */\n+\n+    // Fixpoint iteration\n+    while find_pre_post_state_fn(fcx, f_decl, f_body) { }\n+\n+    /* Now compare each expr's pre-state to its precondition\n+       and post-state to its postcondition */\n+\n+    check_states_against_conditions(fcx, fk, f_decl, f_body, sp, id);\n+}\n+\n+fn fn_states(fk: visit::fn_kind, f_decl: ast::fn_decl, f_body: ast::blk,\n+             sp: span, id: node_id,\n+             ccx: crate_ctxt, v: visit::vt<crate_ctxt>) {\n+\n+    visit::visit_fn(fk, f_decl, f_body, sp, id, ccx, v);\n+\n+    // We may not care about typestate for this function if it contains\n+    // no constrained calls\n+    if !ccx.fm.get(id).ignore {\n+        /* Look up the var-to-bit-num map for this function */\n+\n+        let f_info = ccx.fm.get(id);\n+        let name = visit::name_of_fn(fk);\n+        let fcx = {enclosing: f_info, id: id, name: name, ccx: ccx};\n+        check_fn_states(fcx, fk, f_decl, f_body, sp, id)\n+    }\n+}\n+\n+fn check_crate(cx: ty::ctxt, crate: @crate) {\n+    let ccx: crate_ctxt = new_crate_ctxt(cx);\n+    /* Build the global map from function id to var-to-bit-num-map */\n+\n+    mk_f_to_fn_info(ccx, crate);\n+    /* Add a blank ts_ann for every statement (and expression) */\n+\n+    annotate_crate(ccx, *crate);\n+    /* Compute the pre and postcondition for every subexpression */\n+\n+    let vtor = visit::default_visitor::<crate_ctxt>();\n+    let vtor = @{visit_fn: fn_pre_post with *vtor};\n+    visit::visit_crate(*crate, ccx, visit::mk_vt(vtor));\n+\n+    /* Check the pre- and postcondition against the pre- and poststate\n+       for every expression */\n+    let vtor = visit::default_visitor::<crate_ctxt>();\n+    let vtor = @{visit_fn: fn_states with *vtor};\n+    visit::visit_crate(*crate, ccx, visit::mk_vt(vtor));\n+}\n+//\n+// Local Variables:\n+// mode: rust\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// End:\n+//"}, {"sha": "d627aab7188917079dedbb90644831bb3f4e6080", "filename": "src/rustc/middle/tstate/collect_locals.rs", "status": "added", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -0,0 +1,165 @@\n+import option::*;\n+import pat_util::*;\n+import syntax::ast::*;\n+import syntax::ast_util::*;\n+import syntax::visit;\n+import syntax::codemap::span;\n+import syntax::ast_util::respan;\n+import driver::session::session;\n+import aux::*;\n+import std::map::hashmap;\n+import dvec::{dvec, extensions};\n+\n+type ctxt = {cs: @mut ~[sp_constr], tcx: ty::ctxt};\n+\n+fn collect_pred(e: @expr, cx: ctxt, v: visit::vt<ctxt>) {\n+    match e.node {\n+      expr_check(_, ch) { vec::push(*cx.cs, expr_to_constr(cx.tcx, ch)); }\n+      expr_if_check(ex, _, _) {\n+        vec::push(*cx.cs, expr_to_constr(cx.tcx, ex));\n+      }\n+\n+      // If it's a call, generate appropriate instances of the\n+      // call's constraints.\n+      expr_call(operator, operands, _) {\n+        for constraints_expr(cx.tcx, operator).each |c| {\n+            let ct: sp_constr =\n+                respan(c.span,\n+                       aux::substitute_constr_args(cx.tcx, operands, c));\n+            vec::push(*cx.cs, ct);\n+        }\n+      }\n+      _ { }\n+    }\n+    // visit subexpressions\n+    visit::visit_expr(e, cx, v);\n+}\n+\n+fn find_locals(tcx: ty::ctxt,\n+               fk: visit::fn_kind,\n+               f_decl: fn_decl,\n+               f_body: blk,\n+               sp: span,\n+               id: node_id) -> ctxt {\n+    let cx: ctxt = {cs: @mut ~[], tcx: tcx};\n+    let visitor = visit::default_visitor::<ctxt>();\n+    let visitor =\n+        @{visit_expr: collect_pred,\n+          visit_fn: do_nothing\n+          with *visitor};\n+    visit::visit_fn(fk, f_decl, f_body, sp,\n+                    id, cx, visit::mk_vt(visitor));\n+    return cx;\n+}\n+\n+fn add_constraint(tcx: ty::ctxt, c: sp_constr, next: uint, tbl: constr_map) ->\n+   uint {\n+    log(debug,\n+             constraint_to_str(tcx, c) + ~\" |-> \" + uint::str(next));\n+\n+    let {path: p, def_id: d_id, args: args} = c.node;\n+    match tbl.find(d_id) {\n+      some(ct) {\n+        (*ct.descs).push(respan(c.span, {args: args, bit_num: next}));\n+      }\n+      none {\n+        let rslt = @dvec();\n+        (*rslt).push(respan(c.span, {args: args, bit_num: next}));\n+        tbl.insert(d_id, {path:p, descs:rslt});\n+      }\n+    }\n+    return next + 1u;\n+}\n+\n+fn contains_constrained_calls(tcx: ty::ctxt, body: blk) -> bool {\n+    type cx = @{\n+        tcx: ty::ctxt,\n+        mut has: bool\n+    };\n+    let cx = @{\n+        tcx: tcx,\n+        mut has: false\n+    };\n+    let vtor = visit::default_visitor::<cx>();\n+    let vtor = @{visit_expr: visit_expr with *vtor};\n+    visit::visit_block(body, cx, visit::mk_vt(vtor));\n+    return cx.has;\n+\n+    fn visit_expr(e: @expr, &&cx: cx, v: visit::vt<cx>) {\n+        import syntax::print::pprust;\n+        debug!(\"visiting %?\", pprust::expr_to_str(e));\n+\n+        visit::visit_expr(e, cx, v);\n+\n+        if constraints_expr(cx.tcx, e).is_not_empty() {\n+            debug!(\"has constraints\");\n+            cx.has = true;\n+        } else {\n+            debug!(\"has not constraints\");\n+        }\n+    }\n+}\n+\n+/* builds a table mapping each local var defined in f\n+   to a bit number in the precondition/postcondition vectors */\n+fn mk_fn_info(ccx: crate_ctxt,\n+              fk: visit::fn_kind,\n+              f_decl: fn_decl,\n+              f_body: blk,\n+              f_sp: span,\n+              id: node_id) {\n+    let name = visit::name_of_fn(fk);\n+    let res_map = new_def_hash::<constraint>();\n+    let mut next: uint = 0u;\n+\n+    let cx: ctxt = find_locals(ccx.tcx, fk, f_decl, f_body, f_sp, id);\n+    /* now we have to add bit nums for both the constraints\n+       and the variables... */\n+\n+    let ignore = !contains_constrained_calls(ccx.tcx, f_body);\n+\n+    if !ignore {\n+        let mut i = 0u, l = vec::len(*cx.cs);\n+        while i < l {\n+            next = add_constraint(cx.tcx, copy cx.cs[i], next, res_map);\n+            i += 1u;\n+        }\n+        /* if this function has any constraints, instantiate them to the\n+        argument names and add them */\n+        for f_decl.constraints.each |c| {\n+            let sc = ast_constr_to_sp_constr(cx.tcx, f_decl.inputs, c);\n+            next = add_constraint(cx.tcx, sc, next, res_map);\n+        }\n+    }\n+\n+    let v: @mut ~[node_id] = @mut ~[];\n+    let rslt =\n+        {constrs: res_map,\n+         num_constraints: next,\n+         cf: f_decl.cf,\n+         used_vars: v,\n+         ignore: ignore};\n+    ccx.fm.insert(id, rslt);\n+    debug!(\"%s has %u constraints\", *name, num_constraints(rslt));\n+}\n+\n+\n+/* initializes the global fn_info_map (mapping each function ID, including\n+   nested locally defined functions, onto a mapping from local variable name\n+   to bit number) */\n+fn mk_f_to_fn_info(ccx: crate_ctxt, c: @crate) {\n+    let visitor =\n+        visit::mk_simple_visitor(@{\n+            visit_fn: |a,b,c,d,e| mk_fn_info(ccx, a, b, c, d, e)\n+            with *visit::default_simple_visitor()});\n+    visit::visit_crate(*c, (), visitor);\n+}\n+//\n+// Local Variables:\n+// mode: rust\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// End:\n+//"}, {"sha": "37900fca27f5933fa1533d6bc69932d44b456d93", "filename": "src/rustc/middle/tstate/pre_post_conditions.rs", "status": "added", "additions": 617, "deletions": 0, "changes": 617, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -0,0 +1,617 @@\n+import tstate::ann::*;\n+import aux::*;\n+import bitvectors::{bit_num, seq_preconds, seq_postconds,\n+                    intersect_states,\n+                    relax_precond_block, gen};\n+import tritv::*;\n+\n+import pat_util::*;\n+import syntax::ast::*;\n+import syntax::ast_util::*;\n+import syntax::print::pprust::{expr_to_str, stmt_to_str};\n+import syntax::visit;\n+import util::common::{field_exprs, has_nonlocal_exits};\n+import syntax::codemap::span;\n+import driver::session::session;\n+import std::map::hashmap;\n+\n+fn find_pre_post_mod(_m: _mod) -> _mod {\n+    debug!(\"implement find_pre_post_mod!\");\n+    fail;\n+}\n+\n+fn find_pre_post_foreign_mod(_m: foreign_mod) -> foreign_mod {\n+    debug!(\"implement find_pre_post_foreign_mod\");\n+    fail;\n+}\n+\n+fn find_pre_post_method(ccx: crate_ctxt, m: @method) {\n+    assert (ccx.fm.contains_key(m.id));\n+    let fcx: fn_ctxt =\n+        {enclosing: ccx.fm.get(m.id),\n+         id: m.id,\n+         name: m.ident,\n+         ccx: ccx};\n+    find_pre_post_fn(fcx, m.body);\n+}\n+\n+fn find_pre_post_item(ccx: crate_ctxt, i: item) {\n+    match i.node {\n+      item_const(_, e) {\n+          // do nothing -- item_consts don't refer to local vars\n+      }\n+      item_fn(_, _, body) {\n+        assert (ccx.fm.contains_key(i.id));\n+        let fcx =\n+            {enclosing: ccx.fm.get(i.id), id: i.id, name: i.ident, ccx: ccx};\n+        find_pre_post_fn(fcx, body);\n+      }\n+      item_mod(m) { find_pre_post_mod(m); }\n+      item_foreign_mod(nm) { find_pre_post_foreign_mod(nm); }\n+      item_ty(*) | item_enum(*) | item_trait(*) { return; }\n+      item_class(*) {\n+          fail ~\"find_pre_post_item: shouldn't be called on item_class\";\n+      }\n+      item_impl(_, _, _, ms) {\n+        for ms.each |m| { find_pre_post_method(ccx, m); }\n+      }\n+      item_mac(*) { fail ~\"item macros unimplemented\" }\n+    }\n+}\n+\n+\n+/* Finds the pre and postcondition for each expr in <args>;\n+   sets the precondition in a to be the result of combining\n+   the preconditions for <args>, and the postcondition in a to\n+   be the union of all postconditions for <args> */\n+fn find_pre_post_exprs(fcx: fn_ctxt, args: ~[@expr], id: node_id) {\n+    if vec::len::<@expr>(args) > 0u {\n+        debug!(\"find_pre_post_exprs: oper = %s\", expr_to_str(args[0]));\n+    }\n+    fn do_one(fcx: fn_ctxt, e: @expr) { find_pre_post_expr(fcx, e); }\n+    for args.each |e| { do_one(fcx, e); }\n+\n+    fn get_pp(ccx: crate_ctxt, &&e: @expr) -> pre_and_post {\n+        return expr_pp(ccx, e);\n+    }\n+    let pps = vec::map(args, |a| get_pp(fcx.ccx, a) );\n+\n+    set_pre_and_post(fcx.ccx, id, seq_preconds(fcx, pps),\n+                     seq_postconds(fcx, vec::map(pps, get_post)));\n+}\n+\n+fn find_pre_post_loop(fcx: fn_ctxt, index: @expr, body: blk, id: node_id) {\n+    find_pre_post_expr(fcx, index);\n+    find_pre_post_block(fcx, body);\n+\n+    let loop_precond =\n+        seq_preconds(fcx, ~[expr_pp(fcx.ccx, index),\n+                           block_pp(fcx.ccx, body)]);\n+    let loop_postcond =\n+        intersect_states(expr_postcond(fcx.ccx, index),\n+                         block_postcond(fcx.ccx, body));\n+    copy_pre_post_(fcx.ccx, id, loop_precond, loop_postcond);\n+}\n+\n+// Generates a pre/post assuming that a is the\n+// annotation for an if-expression with consequent conseq\n+// and alternative maybe_alt\n+fn join_then_else(fcx: fn_ctxt, antec: @expr, conseq: blk,\n+                  maybe_alt: option<@expr>, id: node_id, chck: if_ty) {\n+    find_pre_post_expr(fcx, antec);\n+    find_pre_post_block(fcx, conseq);\n+    match maybe_alt {\n+      none {\n+        match chck {\n+          if_check {\n+            let c: sp_constr = expr_to_constr(fcx.ccx.tcx, antec);\n+            gen(fcx, antec.id, c.node);\n+          }\n+          _ { }\n+        }\n+\n+        let precond_res =\n+            seq_preconds(fcx,\n+                         ~[expr_pp(fcx.ccx, antec),\n+                          block_pp(fcx.ccx, conseq)]);\n+        set_pre_and_post(fcx.ccx, id, precond_res,\n+                         expr_poststate(fcx.ccx, antec));\n+      }\n+      some(altern) {\n+        /*\n+          if check = if_check, then\n+          be sure that the predicate implied by antec\n+          is *not* true in the alternative\n+         */\n+        find_pre_post_expr(fcx, altern);\n+        let precond_false_case =\n+            seq_preconds(fcx,\n+                         ~[expr_pp(fcx.ccx, antec),\n+                          expr_pp(fcx.ccx, altern)]);\n+        let postcond_false_case =\n+            seq_postconds(fcx,\n+                          ~[expr_postcond(fcx.ccx, antec),\n+                           expr_postcond(fcx.ccx, altern)]);\n+\n+        /* Be sure to set the bit for the check condition here,\n+         so that it's *not* set in the alternative. */\n+        match chck {\n+          if_check {\n+            let c: sp_constr = expr_to_constr(fcx.ccx.tcx, antec);\n+            gen(fcx, antec.id, c.node);\n+          }\n+          _ { }\n+        }\n+        let precond_true_case =\n+            seq_preconds(fcx,\n+                         ~[expr_pp(fcx.ccx, antec),\n+                          block_pp(fcx.ccx, conseq)]);\n+        let postcond_true_case =\n+            seq_postconds(fcx,\n+                          ~[expr_postcond(fcx.ccx, antec),\n+                           block_postcond(fcx.ccx, conseq)]);\n+\n+        let precond_res =\n+            seq_postconds(fcx, ~[precond_true_case, precond_false_case]);\n+        let postcond_res =\n+            intersect_states(postcond_true_case, postcond_false_case);\n+        set_pre_and_post(fcx.ccx, id, precond_res, postcond_res);\n+      }\n+    }\n+}\n+\n+fn gen_if_local(fcx: fn_ctxt, lhs: @expr, rhs: @expr, larger_id: node_id,\n+                new_var: node_id) {\n+    match node_id_to_def(fcx.ccx, new_var) {\n+      some(d) {\n+        match d {\n+          def_local(nid, _) {\n+            find_pre_post_expr(fcx, rhs);\n+            let p = expr_pp(fcx.ccx, rhs);\n+            set_pre_and_post(fcx.ccx, larger_id, p.precondition,\n+                             p.postcondition);\n+          }\n+          _ { find_pre_post_exprs(fcx, ~[lhs, rhs], larger_id); }\n+        }\n+      }\n+      _ { find_pre_post_exprs(fcx, ~[lhs, rhs], larger_id); }\n+    }\n+}\n+\n+fn handle_update(fcx: fn_ctxt, parent: @expr, lhs: @expr, rhs: @expr,\n+                 ty: oper_type) {\n+    find_pre_post_expr(fcx, rhs);\n+    match lhs.node {\n+      expr_path(p) {\n+        let post = expr_postcond(fcx.ccx, parent);\n+        let tmp = post.clone();\n+\n+        match ty {\n+          oper_move {\n+            if is_path(rhs) { forget_in_postcond(fcx, parent.id, rhs.id); }\n+          }\n+          oper_swap {\n+            forget_in_postcond(fcx, parent.id, lhs.id);\n+            forget_in_postcond(fcx, parent.id, rhs.id);\n+          }\n+          oper_assign {\n+            forget_in_postcond(fcx, parent.id, lhs.id);\n+          }\n+          _ { }\n+        }\n+\n+        gen_if_local(fcx, lhs, rhs, parent.id, lhs.id);\n+        match rhs.node {\n+          expr_path(p1) {\n+            let d = local_node_id_to_local_def_id(fcx, lhs.id);\n+            let d1 = local_node_id_to_local_def_id(fcx, rhs.id);\n+            match d {\n+              some(id) {\n+                match d1 {\n+                  some(id1) {\n+                    let instlhs =\n+                        {ident: path_to_ident(p), node: id};\n+                    let instrhs =\n+                        {ident: path_to_ident(p1), node: id1};\n+                    copy_in_poststate_two(fcx, tmp, post, instlhs, instrhs,\n+                                          ty);\n+                  }\n+                  _ { }\n+                }\n+              }\n+              _ { }\n+            }\n+          }\n+          _ {/* do nothing */ }\n+        }\n+      }\n+      _ { find_pre_post_expr(fcx, lhs); }\n+    }\n+}\n+\n+fn forget_args_moved_in(fcx: fn_ctxt, parent: @expr, modes: ~[mode],\n+                        operands: ~[@expr]) {\n+    do vec::iteri(modes) |i,mode| {\n+        match ty::resolved_mode(fcx.ccx.tcx, mode) {\n+          by_move { forget_in_postcond(fcx, parent.id, operands[i].id); }\n+          by_ref | by_val | by_mutbl_ref | by_copy { }\n+        }\n+    }\n+}\n+\n+fn find_pre_post_expr_fn_upvars(fcx: fn_ctxt, e: @expr) {\n+    let rslt = expr_pp(fcx.ccx, e);\n+    clear_pp(rslt);\n+}\n+\n+/* Fills in annotations as a side effect. Does not rebuild the expr */\n+fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n+    let enclosing = fcx.enclosing;\n+    let num_local_vars = num_constraints(enclosing);\n+    fn do_rand_(fcx: fn_ctxt, e: @expr) { find_pre_post_expr(fcx, e); }\n+\n+\n+    match e.node {\n+      expr_call(operator, operands, _) {\n+        /* copy */\n+\n+        let mut args = operands;\n+        vec::push(args, operator);\n+\n+        find_pre_post_exprs(fcx, args, e.id);\n+        /* see if the call has any constraints on its type */\n+        for constraints_expr(fcx.ccx.tcx, operator).each |c| {\n+            let i =\n+                bit_num(fcx, substitute_constr_args(fcx.ccx.tcx, args, c));\n+            require(i, expr_pp(fcx.ccx, e));\n+        }\n+\n+        forget_args_moved_in(fcx, e, callee_modes(fcx, operator.id),\n+                             operands);\n+\n+        /* if this is a failing call, its postcondition sets everything */\n+        match controlflow_expr(fcx.ccx, operator) {\n+          noreturn { set_postcond_false(fcx.ccx, e.id); }\n+          _ { }\n+        }\n+      }\n+      expr_vstore(ee, _) {\n+        find_pre_post_expr(fcx, ee);\n+        let p = expr_pp(fcx.ccx, ee);\n+        set_pre_and_post(fcx.ccx, e.id, p.precondition, p.postcondition);\n+      }\n+      expr_vec(args, _) {\n+        find_pre_post_exprs(fcx, args, e.id);\n+      }\n+      expr_path(p) {\n+        let rslt = expr_pp(fcx.ccx, e);\n+        clear_pp(rslt);\n+      }\n+      expr_new(p, _, v) {\n+        find_pre_post_exprs(fcx, ~[p, v], e.id);\n+      }\n+      expr_log(_, lvl, arg) {\n+        find_pre_post_exprs(fcx, ~[lvl, arg], e.id);\n+      }\n+      expr_fn(_, _, _, cap_clause) | expr_fn_block(_, _, cap_clause) {\n+        find_pre_post_expr_fn_upvars(fcx, e);\n+\n+        for (*cap_clause).each |cap_item| {\n+            let d = local_node_id_to_local_def_id(fcx, cap_item.id);\n+            option::iter(d, |id| use_var(fcx, id) );\n+        }\n+\n+        for (*cap_clause).each |cap_item| {\n+            if cap_item.is_move {\n+                log(debug, (~\"forget_in_postcond: \", cap_item));\n+                forget_in_postcond(fcx, e.id, cap_item.id);\n+            }\n+        }\n+      }\n+      expr_block(b) {\n+        find_pre_post_block(fcx, b);\n+        let p = block_pp(fcx.ccx, b);\n+        set_pre_and_post(fcx.ccx, e.id, p.precondition, p.postcondition);\n+      }\n+      expr_rec(fields, maybe_base) {\n+        let mut es = field_exprs(fields);\n+        match maybe_base { none {/* no-op */ } some(b) { vec::push(es, b); } }\n+        find_pre_post_exprs(fcx, es, e.id);\n+      }\n+      expr_tup(elts) { find_pre_post_exprs(fcx, elts, e.id); }\n+      expr_move(lhs, rhs) { handle_update(fcx, e, lhs, rhs, oper_move); }\n+      expr_swap(lhs, rhs) { handle_update(fcx, e, lhs, rhs, oper_swap); }\n+      expr_assign(lhs, rhs) { handle_update(fcx, e, lhs, rhs, oper_assign); }\n+      expr_assign_op(_, lhs, rhs) {\n+        /* Different from expr_assign in that the lhs *must*\n+           already be initialized */\n+\n+        find_pre_post_exprs(fcx, ~[lhs, rhs], e.id);\n+        forget_in_postcond(fcx, e.id, lhs.id);\n+      }\n+      expr_lit(_) { clear_pp(expr_pp(fcx.ccx, e)); }\n+      expr_ret(maybe_val) {\n+        match maybe_val {\n+          none {\n+            clear_precond(fcx.ccx, e.id);\n+            set_postcond_false(fcx.ccx, e.id);\n+          }\n+          some(ret_val) {\n+            find_pre_post_expr(fcx, ret_val);\n+            set_precondition(node_id_to_ts_ann(fcx.ccx, e.id),\n+                             expr_precond(fcx.ccx, ret_val));\n+            set_postcond_false(fcx.ccx, e.id);\n+          }\n+        }\n+      }\n+      expr_if(antec, conseq, maybe_alt) {\n+        join_then_else(fcx, antec, conseq, maybe_alt, e.id, plain_if);\n+      }\n+      expr_binary(bop, l, r) {\n+        if lazy_binop(bop) {\n+            find_pre_post_expr(fcx, l);\n+            find_pre_post_expr(fcx, r);\n+            let overall_pre =\n+                seq_preconds(fcx,\n+                             ~[expr_pp(fcx.ccx, l), expr_pp(fcx.ccx, r)]);\n+            set_precondition(node_id_to_ts_ann(fcx.ccx, e.id), overall_pre);\n+            set_postcondition(node_id_to_ts_ann(fcx.ccx, e.id),\n+                              expr_postcond(fcx.ccx, l));\n+        } else { find_pre_post_exprs(fcx, ~[l, r], e.id); }\n+      }\n+      expr_addr_of(_, x) | expr_cast(x, _) | expr_unary(_, x) |\n+      expr_loop_body(x) | expr_do_body(x) | expr_assert(x) | expr_copy(x) {\n+        find_pre_post_expr(fcx, x);\n+        copy_pre_post(fcx.ccx, e.id, x);\n+      }\n+      expr_while(test, body) {\n+        find_pre_post_expr(fcx, test);\n+        find_pre_post_block(fcx, body);\n+        set_pre_and_post(fcx.ccx, e.id,\n+                         seq_preconds(fcx,\n+                                      ~[expr_pp(fcx.ccx, test),\n+                                       block_pp(fcx.ccx, body)]),\n+                         intersect_states(expr_postcond(fcx.ccx, test),\n+                                          block_postcond(fcx.ccx, body)));\n+      }\n+      expr_loop(body) {\n+        find_pre_post_block(fcx, body);\n+        /* Infinite loop: if control passes it, everything is true. */\n+        let mut loop_postcond = false_postcond(num_local_vars);\n+        /* Conservative approximation: if the body has any nonlocal exits,\n+         the poststate is blank since we don't know what parts of it\n+          execute. */\n+        if has_nonlocal_exits(body) {\n+            loop_postcond = empty_poststate(num_local_vars);\n+        }\n+        set_pre_and_post(fcx.ccx, e.id, block_precond(fcx.ccx, body),\n+                         loop_postcond);\n+      }\n+      expr_index(val, sub) { find_pre_post_exprs(fcx, ~[val, sub], e.id); }\n+      expr_match(ex, alts, _) {\n+        find_pre_post_expr(fcx, ex);\n+        fn do_an_alt(fcx: fn_ctxt, an_alt: arm) -> pre_and_post {\n+            match an_alt.guard {\n+              some(e) { find_pre_post_expr(fcx, e); }\n+              _ {}\n+            }\n+            find_pre_post_block(fcx, an_alt.body);\n+            return block_pp(fcx.ccx, an_alt.body);\n+        }\n+        let mut alt_pps = ~[];\n+        for alts.each |a| { vec::push(alt_pps, do_an_alt(fcx, a)); }\n+        fn combine_pp(antec: pre_and_post, fcx: fn_ctxt, &&pp: pre_and_post,\n+                      &&next: pre_and_post) -> pre_and_post {\n+            union(pp.precondition, seq_preconds(fcx, ~[antec, next]));\n+            intersect(pp.postcondition, next.postcondition);\n+            return pp;\n+        }\n+        let antec_pp = pp_clone(expr_pp(fcx.ccx, ex));\n+        let e_pp =\n+            {precondition: empty_prestate(num_local_vars),\n+             postcondition: false_postcond(num_local_vars)};\n+        let g = |a,b| combine_pp(antec_pp, fcx, a, b);\n+        let alts_overall_pp =\n+            vec::foldl(e_pp, alt_pps, g);\n+        set_pre_and_post(fcx.ccx, e.id, alts_overall_pp.precondition,\n+                         alts_overall_pp.postcondition);\n+      }\n+      expr_field(operator, _, _) {\n+        find_pre_post_expr(fcx, operator);\n+        copy_pre_post(fcx.ccx, e.id, operator);\n+      }\n+      expr_fail(maybe_val) {\n+        let mut prestate;\n+        match maybe_val {\n+          none { prestate = empty_prestate(num_local_vars); }\n+          some(fail_val) {\n+            find_pre_post_expr(fcx, fail_val);\n+            prestate = expr_precond(fcx.ccx, fail_val);\n+          }\n+        }\n+        set_pre_and_post(fcx.ccx, e.id,\n+                         /* if execution continues after fail,\n+                            then everything is true! */\n+                         prestate, false_postcond(num_local_vars));\n+      }\n+      expr_check(_, p) {\n+        find_pre_post_expr(fcx, p);\n+        copy_pre_post(fcx.ccx, e.id, p);\n+        /* predicate p holds after this expression executes */\n+\n+        let c: sp_constr = expr_to_constr(fcx.ccx.tcx, p);\n+        gen(fcx, e.id, c.node);\n+      }\n+      expr_if_check(p, conseq, maybe_alt) {\n+        join_then_else(fcx, p, conseq, maybe_alt, e.id, if_check);\n+      }\n+      expr_break { clear_pp(expr_pp(fcx.ccx, e)); }\n+      expr_again { clear_pp(expr_pp(fcx.ccx, e)); }\n+      expr_mac(_) { fcx.ccx.tcx.sess.bug(~\"unexpanded macro\"); }\n+    }\n+}\n+\n+fn find_pre_post_stmt(fcx: fn_ctxt, s: stmt) {\n+    debug!(\"stmt = %s\", stmt_to_str(s));\n+    match s.node {\n+      stmt_decl(adecl, id) {\n+        match adecl.node {\n+          decl_local(alocals) {\n+            let prev_pp = empty_pre_post(num_constraints(fcx.enclosing));\n+            for alocals.each |alocal| {\n+                match alocal.node.init {\n+                  some(an_init) {\n+                    /* LHS always becomes initialized,\n+                     whether or not this is a move */\n+                    find_pre_post_expr(fcx, an_init.expr);\n+                    do pat_bindings(fcx.ccx.tcx.def_map, alocal.node.pat)\n+                        |p_id, _s, _n| {\n+                        copy_pre_post(fcx.ccx, p_id, an_init.expr);\n+                    };\n+                    /* Inherit ann from initializer, and add var being\n+                       initialized to the postcondition */\n+                    copy_pre_post(fcx.ccx, id, an_init.expr);\n+\n+                    let mut p = none;\n+                    match an_init.expr.node {\n+                      expr_path(_p) { p = some(_p); }\n+                      _ { }\n+                    }\n+\n+                    do pat_bindings(fcx.ccx.tcx.def_map, alocal.node.pat)\n+                        |p_id, _s, n| {\n+                        let ident = path_to_ident(n);\n+                        match p {\n+                          some(p) {\n+                            copy_in_postcond(fcx, id,\n+                                             {ident: ident, node: p_id},\n+                                             {ident:\n+                                                  path_to_ident(p),\n+                                              node: an_init.expr.id},\n+                                             op_to_oper_ty(an_init.op));\n+                          }\n+                          none { }\n+                        }\n+                    };\n+\n+                    /* Clear out anything that the previous initializer\n+                    guaranteed */\n+                    let e_pp = expr_pp(fcx.ccx, an_init.expr);\n+                    prev_pp.precondition.become(\n+                               seq_preconds(fcx, ~[prev_pp, e_pp]));\n+\n+                    /* Include the LHSs too, since those aren't in the\n+                     postconds of the RHSs themselves */\n+                    copy_pre_post_(fcx.ccx, id, prev_pp.precondition,\n+                                   prev_pp.postcondition);\n+                  }\n+                  none {\n+                    do pat_bindings(fcx.ccx.tcx.def_map, alocal.node.pat)\n+                        |p_id, _s, _n| {\n+                        clear_pp(node_id_to_ts_ann(fcx.ccx, p_id).conditions);\n+                    };\n+                    clear_pp(node_id_to_ts_ann(fcx.ccx, id).conditions);\n+                  }\n+                }\n+            }\n+          }\n+          decl_item(anitem) {\n+            clear_pp(node_id_to_ts_ann(fcx.ccx, id).conditions);\n+            find_pre_post_item(fcx.ccx, *anitem);\n+          }\n+        }\n+      }\n+      stmt_expr(e, id) | stmt_semi(e, id) {\n+        find_pre_post_expr(fcx, e);\n+        copy_pre_post(fcx.ccx, id, e);\n+      }\n+    }\n+}\n+\n+fn find_pre_post_block(fcx: fn_ctxt, b: blk) {\n+    /* Want to say that if there is a break or cont in this\n+     block, then that invalidates the poststate upheld by\n+    any of the stmts after it.\n+    Given that the typechecker has run, we know any break will be in\n+    a block that forms a loop body. So that's ok. There'll never be an\n+    expr_break outside a loop body, therefore, no expr_break outside a block.\n+    */\n+\n+    /* Conservative approximation for now: This says that if a block contains\n+     *any* breaks or conts, then its postcondition doesn't promise anything.\n+     This will mean that:\n+     x = 0;\n+     break;\n+\n+     won't have a postcondition that says x is initialized, but that's ok.\n+     */\n+\n+    let nv = num_constraints(fcx.enclosing);\n+    fn do_one_(fcx: fn_ctxt, s: @stmt) {\n+        find_pre_post_stmt(fcx, *s);\n+    }\n+    for b.node.stmts.each |s| { do_one_(fcx, s); }\n+    fn do_inner_(fcx: fn_ctxt, &&e: @expr) { find_pre_post_expr(fcx, e); }\n+    let do_inner = |a| do_inner_(fcx, a);\n+    option::map::<@expr, ()>(b.node.expr, do_inner);\n+\n+    let mut pps: ~[pre_and_post] = ~[];\n+    for b.node.stmts.each |s| { vec::push(pps, stmt_pp(fcx.ccx, *s)); }\n+    match b.node.expr {\n+      none {/* no-op */ }\n+      some(e) { vec::push(pps, expr_pp(fcx.ccx, e)); }\n+    }\n+\n+    let block_precond = seq_preconds(fcx, pps);\n+\n+    let mut postconds = ~[];\n+    for pps.each |pp| { vec::push(postconds, get_post(pp)); }\n+\n+    /* A block may be empty, so this next line ensures that the postconds\n+       vector is non-empty. */\n+    vec::push(postconds, block_precond);\n+\n+    let mut block_postcond = empty_poststate(nv);\n+    /* conservative approximation */\n+\n+    if !has_nonlocal_exits(b) {\n+        block_postcond = seq_postconds(fcx, postconds);\n+    }\n+    set_pre_and_post(fcx.ccx, b.node.id, block_precond, block_postcond);\n+}\n+\n+fn find_pre_post_fn(fcx: fn_ctxt, body: blk) {\n+    find_pre_post_block(fcx, body);\n+\n+    // Treat the tail expression as a return statement\n+    match body.node.expr {\n+      some(tailexpr) { set_postcond_false(fcx.ccx, tailexpr.id); }\n+      none {/* fallthrough */ }\n+    }\n+}\n+\n+fn fn_pre_post(fk: visit::fn_kind, decl: fn_decl, body: blk, sp: span,\n+               id: node_id,\n+               ccx: crate_ctxt, v: visit::vt<crate_ctxt>) {\n+\n+    visit::visit_fn(fk, decl, body, sp, id, ccx, v);\n+    assert (ccx.fm.contains_key(id));\n+    if !ccx.fm.get(id).ignore {\n+        let fcx =\n+            {enclosing: ccx.fm.get(id),\n+             id: id,\n+             name: visit::name_of_fn(fk),\n+             ccx: ccx};\n+        find_pre_post_fn(fcx, body);\n+    }\n+}\n+\n+//\n+// Local Variables:\n+// mode: rust\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// End:\n+//"}, {"sha": "7802841d13e7e14d15ac8890ade0220d4185a3a1", "filename": "src/rustc/middle/tstate/states.rs", "status": "added", "additions": 623, "deletions": 0, "changes": 623, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fstates.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -0,0 +1,623 @@\n+import ann::*;\n+import aux::*;\n+import tritv::*;\n+\n+import syntax::print::pprust::block_to_str;\n+import bitvectors::*;\n+import pat_util::*;\n+import syntax::ast::*;\n+import syntax::ast_util::*;\n+import syntax::print::pprust::{expr_to_str, stmt_to_str};\n+import syntax::codemap::span;\n+import middle::ty::{expr_ty, type_is_bot};\n+import util::common::{field_exprs, has_nonlocal_exits, may_break};\n+import driver::session::session;\n+import std::map::hashmap;\n+\n+fn forbid_upvar(fcx: fn_ctxt, rhs_id: node_id, sp: span, t: oper_type) {\n+    match t {\n+      oper_move {\n+        match local_node_id_to_def(fcx, rhs_id) {\n+          some(def_upvar(_, _, _)) {\n+            fcx.ccx.tcx.sess.span_err(sp,\n+                                      ~\"tried to deinitialize a variable \\\n+              declared in a different scope\");\n+          }\n+          _ { }\n+        }\n+      }\n+      _ {/* do nothing */ }\n+    }\n+}\n+\n+fn handle_move_or_copy(fcx: fn_ctxt, post: poststate, rhs_path: @path,\n+                       rhs_id: node_id, destlhs: dest, init_op: init_op) {\n+    forbid_upvar(fcx, rhs_id, rhs_path.span, op_to_oper_ty(init_op));\n+\n+    let rhs_d_id = local_node_id_to_def_id(fcx, rhs_id);\n+    match rhs_d_id {\n+      some(rhsid) {\n+        // RHS is a local var\n+        let instrhs =\n+            {ident: path_to_ident(rhs_path), node: rhsid.node};\n+        match destlhs {\n+          local_dest(instlhs) {\n+             copy_in_poststate(fcx, post, instlhs, instrhs,\n+                               op_to_oper_ty(init_op));\n+          }\n+          _ {}\n+        }\n+      }\n+      _ {\n+        // not a local -- do nothing\n+      }\n+    }\n+}\n+\n+fn seq_states(fcx: fn_ctxt, pres: prestate, bindings: ~[binding]) ->\n+   {changed: bool, post: poststate} {\n+    let mut changed = false;\n+    let mut post = pres.clone();\n+    for bindings.each |b| {\n+        match b.rhs {\n+          some(an_init) {\n+            // an expression, with or without a destination\n+            changed |=\n+                find_pre_post_state_expr(fcx, post, an_init.expr) || changed;\n+            post = expr_poststate(fcx.ccx, an_init.expr).clone();\n+            for b.lhs.each |d| {\n+                match an_init.expr.node {\n+                  expr_path(p) {\n+                    handle_move_or_copy(fcx, post, p, an_init.expr.id, d,\n+                                        an_init.op);\n+                  }\n+                  _ { }\n+                }\n+            }\n+\n+            // Forget the RHS if we just moved it.\n+            if an_init.op == init_move {\n+                forget_in_poststate(fcx, post, an_init.expr.id);\n+            }\n+          }\n+          none {\n+          }\n+        }\n+    }\n+    return {changed: changed, post: post};\n+}\n+\n+fn find_pre_post_state_sub(fcx: fn_ctxt, pres: prestate, e: @expr,\n+                           parent: node_id, c: option<tsconstr>) -> bool {\n+    let mut changed = find_pre_post_state_expr(fcx, pres, e);\n+\n+    changed = set_prestate_ann(fcx.ccx, parent, pres) || changed;\n+\n+    let post = expr_poststate(fcx.ccx, e).clone();\n+    match c {\n+      none { }\n+      some(c1) { set_in_poststate_(bit_num(fcx, c1), post); }\n+    }\n+\n+    changed = set_poststate_ann(fcx.ccx, parent, post) || changed;\n+    return changed;\n+}\n+\n+fn find_pre_post_state_two(fcx: fn_ctxt, pres: prestate, lhs: @expr,\n+                           rhs: @expr, parent: node_id, ty: oper_type) ->\n+   bool {\n+    let mut changed = set_prestate_ann(fcx.ccx, parent, pres);\n+    changed = find_pre_post_state_expr(fcx, pres, lhs) || changed;\n+    changed =\n+        find_pre_post_state_expr(fcx, expr_poststate(fcx.ccx, lhs), rhs) ||\n+            changed;\n+    forbid_upvar(fcx, rhs.id, rhs.span, ty);\n+\n+    let post = expr_poststate(fcx.ccx, rhs).clone();\n+\n+    match lhs.node {\n+      expr_path(p) {\n+        // for termination, need to make sure intermediate changes don't set\n+        // changed flag\n+        // tmp remembers \"old\" constraints we'd otherwise forget,\n+        // for substitution purposes\n+        let tmp = post.clone();\n+\n+        match ty {\n+          oper_move {\n+            if is_path(rhs) { forget_in_poststate(fcx, post, rhs.id); }\n+            forget_in_poststate(fcx, post, lhs.id);\n+          }\n+          oper_swap {\n+            forget_in_poststate(fcx, post, lhs.id);\n+            forget_in_poststate(fcx, post, rhs.id);\n+          }\n+          _ { forget_in_poststate(fcx, post, lhs.id); }\n+        }\n+\n+        match rhs.node {\n+          expr_path(p1) {\n+            let d = local_node_id_to_local_def_id(fcx, lhs.id);\n+            let d1 = local_node_id_to_local_def_id(fcx, rhs.id);\n+            match d {\n+              some(id) {\n+                match d1 {\n+                  some(id1) {\n+                    let instlhs =\n+                        {ident: path_to_ident(p), node: id};\n+                    let instrhs =\n+                        {ident: path_to_ident(p1), node: id1};\n+                    copy_in_poststate_two(fcx, tmp, post, instlhs, instrhs,\n+                                          ty);\n+                  }\n+                  _ { }\n+                }\n+              }\n+              _ { }\n+            }\n+          }\n+          _ {/* do nothing */ }\n+        }\n+      }\n+      _ { }\n+    }\n+    changed = set_poststate_ann(fcx.ccx, parent, post) || changed;\n+    return changed;\n+}\n+\n+fn find_pre_post_state_call(fcx: fn_ctxt, pres: prestate, a: @expr,\n+                            id: node_id, ops: ~[init_op], bs: ~[@expr],\n+                            cf: ret_style) -> bool {\n+    let mut changed = find_pre_post_state_expr(fcx, pres, a);\n+    // FIXME (#2178): This could be a typestate constraint (except we're\n+    // not using them inside the compiler, I guess... see discussion in\n+    // bug)\n+    if vec::len(bs) != vec::len(ops) {\n+        fcx.ccx.tcx.sess.span_bug(a.span,\n+                                  fmt!(\"mismatched arg lengths: \\\n+                                        %u exprs vs. %u ops\",\n+                                       vec::len(bs), vec::len(ops)));\n+    }\n+    return find_pre_post_state_exprs(fcx, pres, id, ops,\n+                                   bs, cf) || changed;\n+}\n+\n+fn find_pre_post_state_exprs(fcx: fn_ctxt, pres: prestate, id: node_id,\n+                             ops: ~[init_op], es: ~[@expr],\n+                             cf: ret_style) -> bool {\n+    let rs = seq_states(fcx, pres, arg_bindings(ops, es));\n+    let mut changed = rs.changed | set_prestate_ann(fcx.ccx, id, pres);\n+    /* if this is a failing call, it sets everything as initialized */\n+    match cf {\n+      noreturn {\n+        let post = false_postcond(num_constraints(fcx.enclosing));\n+        changed |= set_poststate_ann(fcx.ccx, id, post);\n+      }\n+      _ { changed |= set_poststate_ann(fcx.ccx, id, rs.post); }\n+    }\n+    return changed;\n+}\n+\n+fn join_then_else(fcx: fn_ctxt, antec: @expr, conseq: blk,\n+                  maybe_alt: option<@expr>, id: node_id, chk: if_ty,\n+                  pres: prestate) -> bool {\n+    let mut changed =\n+        set_prestate_ann(fcx.ccx, id, pres) |\n+            find_pre_post_state_expr(fcx, pres, antec);\n+\n+    match maybe_alt {\n+      none {\n+        match chk {\n+          if_check {\n+            let c: sp_constr = expr_to_constr(fcx.ccx.tcx, antec);\n+            let conseq_prestate = expr_poststate(fcx.ccx, antec).clone();\n+            conseq_prestate.set(bit_num(fcx, c.node), ttrue);\n+            changed |=\n+                find_pre_post_state_block(fcx, conseq_prestate, conseq) |\n+                    set_poststate_ann(fcx.ccx, id,\n+                                      expr_poststate(fcx.ccx, antec));\n+          }\n+          _ {\n+            changed |=\n+                find_pre_post_state_block(fcx, expr_poststate(fcx.ccx, antec),\n+                                          conseq) |\n+                    set_poststate_ann(fcx.ccx, id,\n+                                      expr_poststate(fcx.ccx, antec));\n+          }\n+        }\n+      }\n+      some(altern) {\n+        changed |=\n+            find_pre_post_state_expr(fcx, expr_poststate(fcx.ccx, antec),\n+                                     altern);\n+\n+        let mut conseq_prestate = expr_poststate(fcx.ccx, antec);\n+        match chk {\n+          if_check {\n+            let c: sp_constr = expr_to_constr(fcx.ccx.tcx, antec);\n+            conseq_prestate = conseq_prestate.clone();\n+            conseq_prestate.set(bit_num(fcx, c.node),  ttrue);\n+          }\n+          _ { }\n+        }\n+\n+\n+        changed |= find_pre_post_state_block(fcx, conseq_prestate, conseq);\n+\n+        let poststate_res =\n+            intersect_states(block_poststate(fcx.ccx, conseq),\n+                             expr_poststate(fcx.ccx, altern));\n+        /*\n+           fcx.ccx.tcx.sess.span_note(antec.span,\n+           \"poststate_res = \" + aux::tritv_to_str(fcx, poststate_res));\n+        fcx.ccx.tcx.sess.span_note(antec.span,\n+           \"altern poststate = \" +\n+            aux::tritv_to_str(fcx, expr_poststate(fcx.ccx, altern)));\n+        fcx.ccx.tcx.sess.span_note(antec.span,\n+        \"conseq poststate = \" + aux::tritv_to_str(fcx,\n+           block_poststate(fcx.ccx, conseq)));\n+        */\n+\n+        changed |= set_poststate_ann(fcx.ccx, id, poststate_res);\n+      }\n+    }\n+    return changed;\n+}\n+\n+fn find_pre_post_state_cap_clause(fcx: fn_ctxt, e_id: node_id,\n+                                  pres: prestate, cap_clause: capture_clause)\n+    -> bool\n+{\n+    let ccx = fcx.ccx;\n+    let pres_changed = set_prestate_ann(ccx, e_id, pres);\n+    let post = pres.clone();\n+    for (*cap_clause).each |cap_item| {\n+        if cap_item.is_move {\n+            forget_in_poststate(fcx, post, cap_item.id);\n+        }\n+    }\n+    return set_poststate_ann(ccx, e_id, post) || pres_changed;\n+}\n+\n+fn find_pre_post_state_expr(fcx: fn_ctxt, pres: prestate, e: @expr) -> bool {\n+    let num_constrs = num_constraints(fcx.enclosing);\n+\n+    match e.node {\n+      expr_new(p, _, v) {\n+        return find_pre_post_state_two(fcx, pres, p, v, e.id, oper_pure);\n+      }\n+      expr_vstore(ee, _) {\n+        let mut changed = find_pre_post_state_expr(fcx, pres, ee);\n+        set_prestate_ann(fcx.ccx, e.id, expr_prestate(fcx.ccx, ee));\n+        set_poststate_ann(fcx.ccx, e.id, expr_poststate(fcx.ccx, ee));\n+        return changed;\n+      }\n+      expr_vec(elts, _) {\n+        return find_pre_post_state_exprs(fcx, pres, e.id,\n+                                      vec::from_elem(vec::len(elts),\n+                                                    init_assign), elts,\n+                                      return_val);\n+      }\n+      expr_call(operator, operands, _) {\n+        debug!(\"hey it's a call: %s\", expr_to_str(e));\n+        return find_pre_post_state_call(fcx, pres, operator, e.id,\n+                                     callee_arg_init_ops(fcx, operator.id),\n+                                     operands,\n+                                     controlflow_expr(fcx.ccx, operator));\n+      }\n+      expr_path(_) { return pure_exp(fcx.ccx, e.id, pres); }\n+      expr_log(_, lvl, ex) {\n+        return find_pre_post_state_two(fcx, pres, lvl, ex, e.id, oper_pure);\n+      }\n+      expr_mac(_) { fcx.ccx.tcx.sess.bug(~\"unexpanded macro\"); }\n+      expr_lit(l) { return pure_exp(fcx.ccx, e.id, pres); }\n+      expr_fn(_, _, _, cap_clause) {\n+        return find_pre_post_state_cap_clause(fcx, e.id, pres, cap_clause);\n+      }\n+      expr_fn_block(_, _, cap_clause) {\n+        return find_pre_post_state_cap_clause(fcx, e.id, pres, cap_clause);\n+      }\n+      expr_block(b) {\n+        return find_pre_post_state_block(fcx, pres, b) |\n+                set_prestate_ann(fcx.ccx, e.id, pres) |\n+                set_poststate_ann(fcx.ccx, e.id, block_poststate(fcx.ccx, b));\n+      }\n+      expr_rec(fields, maybe_base) {\n+        let exs = field_exprs(fields);\n+        let mut changed =\n+            find_pre_post_state_exprs(fcx, pres, e.id,\n+                                      vec::from_elem(vec::len(fields),\n+                                                    init_assign),\n+                                      exs, return_val);\n+\n+        let base_pres = match vec::last_opt(exs) { none { pres }\n+                          some(f) { expr_poststate(fcx.ccx, f) }};\n+        option::iter(maybe_base, |base| {\n+            changed |= find_pre_post_state_expr(fcx, base_pres, base) |\n+                set_poststate_ann(fcx.ccx, e.id,\n+                                  expr_poststate(fcx.ccx, base))\n+        });\n+        return changed;\n+      }\n+      expr_tup(elts) {\n+        return find_pre_post_state_exprs(fcx, pres, e.id,\n+                                      vec::from_elem(vec::len(elts),\n+                                                    init_assign), elts,\n+                                      return_val);\n+      }\n+      expr_move(lhs, rhs) {\n+        return find_pre_post_state_two(fcx, pres, lhs, rhs, e.id, oper_move);\n+      }\n+      expr_assign(lhs, rhs) {\n+        return find_pre_post_state_two(\n+            fcx, pres, lhs, rhs, e.id, oper_assign);\n+      }\n+      expr_swap(lhs, rhs) {\n+        return find_pre_post_state_two(fcx, pres, lhs, rhs, e.id, oper_swap);\n+        // Could be more precise and actually swap the role of\n+        // lhs and rhs in constraints\n+      }\n+      expr_ret(maybe_ret_val) {\n+        let mut changed = set_prestate_ann(fcx.ccx, e.id, pres);\n+        /* everything is true if execution continues after\n+           a return expression (since execution never continues locally\n+           after a return expression */\n+        let post = false_postcond(num_constrs);\n+\n+        set_poststate_ann(fcx.ccx, e.id, post);\n+\n+        match maybe_ret_val {\n+          none {/* do nothing */ }\n+          some(ret_val) {\n+            changed |= find_pre_post_state_expr(fcx, pres, ret_val);\n+          }\n+        }\n+        return changed;\n+      }\n+      expr_if(antec, conseq, maybe_alt) {\n+        return join_then_else(fcx, antec, conseq, maybe_alt, e.id, plain_if,\n+                           pres);\n+      }\n+      expr_binary(bop, l, r) {\n+        if lazy_binop(bop) {\n+            let mut changed = find_pre_post_state_expr(fcx, pres, l);\n+            changed |=\n+                find_pre_post_state_expr(fcx, expr_poststate(fcx.ccx, l), r);\n+            return changed | set_prestate_ann(fcx.ccx, e.id, pres) |\n+                    set_poststate_ann(fcx.ccx, e.id,\n+                                      expr_poststate(fcx.ccx, l));\n+        } else {\n+            return find_pre_post_state_two(fcx, pres, l, r, e.id, oper_pure);\n+        }\n+      }\n+      expr_assign_op(op, lhs, rhs) {\n+        return find_pre_post_state_two(fcx, pres, lhs, rhs, e.id,\n+                                    oper_assign_op);\n+      }\n+      expr_while(test, body) {\n+        let loop_pres =\n+            intersect_states(block_poststate(fcx.ccx, body), pres);\n+\n+        let mut changed =\n+            set_prestate_ann(fcx.ccx, e.id, loop_pres) |\n+                find_pre_post_state_expr(fcx, loop_pres, test) |\n+                find_pre_post_state_block(fcx, expr_poststate(fcx.ccx, test),\n+                                          body);\n+\n+        /* conservative approximation: if a loop contains a break\n+           or cont, we assume nothing about the poststate */\n+        /* which is still unsound -- see ~[Break-unsound] */\n+        if has_nonlocal_exits(body) {\n+            return changed | set_poststate_ann(fcx.ccx, e.id, pres);\n+        } else {\n+            let e_post = expr_poststate(fcx.ccx, test);\n+            let b_post = block_poststate(fcx.ccx, body);\n+            return changed |\n+                    set_poststate_ann(fcx.ccx, e.id,\n+                                      intersect_states(e_post, b_post));\n+        }\n+      }\n+      expr_loop(body) {\n+        let loop_pres =\n+            intersect_states(block_poststate(fcx.ccx, body), pres);\n+        let mut changed = set_prestate_ann(fcx.ccx, e.id, loop_pres)\n+              | find_pre_post_state_block(fcx, loop_pres, body);\n+        /* conservative approximation: if a loop contains a break\n+           or cont, we assume nothing about the poststate (so, we\n+           set all predicates to \"don't know\" */\n+        /* which is still unsound -- see ~[Break-unsound] */\n+        if may_break(body) {\n+                /* Only do this if there are *breaks* not conts.\n+                 An infinite loop with conts is still an infinite loop.\n+                We assume all preds are FALSE, not '?' -- because in the\n+                worst case, the body could invalidate all preds and\n+                deinitialize everything before breaking */\n+            let post = empty_poststate(num_constrs);\n+            post.kill();\n+            return changed | set_poststate_ann(fcx.ccx, e.id, post);\n+        } else {\n+            return changed | set_poststate_ann(fcx.ccx, e.id,\n+                                            false_postcond(num_constrs));\n+        }\n+      }\n+      expr_index(val, sub) {\n+        return find_pre_post_state_two(fcx, pres, val, sub, e.id, oper_pure);\n+      }\n+      expr_match(val, alts, _) {\n+        let mut changed =\n+            set_prestate_ann(fcx.ccx, e.id, pres) |\n+                find_pre_post_state_expr(fcx, pres, val);\n+        let e_post = expr_poststate(fcx.ccx, val);\n+        let mut a_post;\n+        if vec::len(alts) > 0u {\n+            a_post = false_postcond(num_constrs);\n+            for alts.each |an_alt| {\n+                match an_alt.guard {\n+                  some(e) {\n+                    changed |= find_pre_post_state_expr(fcx, e_post, e);\n+                  }\n+                  _ {}\n+                }\n+                changed |=\n+                    find_pre_post_state_block(fcx, e_post, an_alt.body);\n+                intersect(a_post, block_poststate(fcx.ccx, an_alt.body));\n+                // We deliberately do *not* update changed here, because\n+                // we'd go into an infinite loop that way, and the change\n+                // gets made after the if expression.\n+\n+            }\n+        } else {\n+            // No alts; poststate is the poststate of the test\n+\n+            a_post = e_post;\n+        }\n+        return changed | set_poststate_ann(fcx.ccx, e.id, a_post);\n+      }\n+      expr_field(x, _, _) | expr_loop_body(x) | expr_do_body(x) |\n+      expr_unary(_, x) |\n+      expr_addr_of(_, x) | expr_assert(x) | expr_cast(x, _) |\n+      expr_copy(x) {\n+        return find_pre_post_state_sub(fcx, pres, x, e.id, none);\n+      }\n+      expr_fail(maybe_fail_val) {\n+        /* if execution continues after fail, then everything is true!\n+        woo! */\n+        let post = false_postcond(num_constrs);\n+        return set_prestate_ann(fcx.ccx, e.id, pres) |\n+                set_poststate_ann(fcx.ccx, e.id, post) |\n+                option::map_default(\n+                    maybe_fail_val, false,\n+                    |fail_val|\n+                    find_pre_post_state_expr(fcx, pres, fail_val) );\n+      }\n+      expr_check(_, p) {\n+        /* predicate p holds after this expression executes */\n+        let c: sp_constr = expr_to_constr(fcx.ccx.tcx, p);\n+        return find_pre_post_state_sub(fcx, pres, p, e.id, some(c.node));\n+      }\n+      expr_if_check(p, conseq, maybe_alt) {\n+        return join_then_else(\n+            fcx, p, conseq, maybe_alt, e.id, if_check, pres);\n+      }\n+      expr_break { return pure_exp(fcx.ccx, e.id, pres); }\n+      expr_again { return pure_exp(fcx.ccx, e.id, pres); }\n+    }\n+}\n+\n+fn find_pre_post_state_stmt(fcx: fn_ctxt, pres: prestate, s: @stmt) -> bool {\n+    let stmt_ann = stmt_to_ann(fcx.ccx, *s);\n+\n+    debug!(\"[ %s ]\", *fcx.name);\n+    debug!(\"*At beginning: stmt = %s\", stmt_to_str(*s));\n+    debug!(\"*prestate = %s\", stmt_ann.states.prestate.to_str());\n+    debug!(\"*poststate = %s\", stmt_ann.states.prestate.to_str());\n+\n+    match s.node {\n+      stmt_decl(adecl, id) {\n+        match adecl.node {\n+          decl_local(alocals) {\n+            set_prestate(stmt_ann, pres);\n+            let c_and_p = seq_states(fcx, pres,\n+                  locals_to_bindings(fcx.ccx.tcx, alocals));\n+            /* important to do this in one step to ensure\n+            termination (don't want to set changed to true\n+            for intermediate changes) */\n+\n+            let mut changed =\n+                set_poststate(stmt_ann, c_and_p.post) | c_and_p.changed;\n+\n+            debug!(\"Summary: stmt = %s\", stmt_to_str(*s));\n+            debug!(\"prestate = %s\", stmt_ann.states.prestate.to_str());\n+            debug!(\"poststate = %s\", stmt_ann.states.poststate.to_str());\n+            debug!(\"changed = %s\", bool::to_str(changed));\n+\n+            return changed;\n+          }\n+          decl_item(an_item) {\n+            return set_prestate(stmt_ann, pres)\n+                | set_poststate(stmt_ann, pres);\n+            /* the outer visitor will recurse into the item */\n+          }\n+        }\n+      }\n+      stmt_expr(ex, _) | stmt_semi(ex, _) {\n+        let mut changed =\n+            find_pre_post_state_expr(fcx, pres, ex) |\n+                set_prestate(stmt_ann, expr_prestate(fcx.ccx, ex)) |\n+                set_poststate(stmt_ann, expr_poststate(fcx.ccx, ex));\n+\n+\n+        debug!(\"Finally: %s\", stmt_to_str(*s));\n+        debug!(\"prestate = %s\", stmt_ann.states.prestate.to_str());\n+        debug!(\"poststate = %s\", stmt_ann.states.poststate.to_str());\n+        debug!(\"changed = %s\", bool::to_str(changed));\n+\n+        return changed;\n+      }\n+    }\n+}\n+\n+\n+/* Updates the pre- and post-states of statements in the block,\n+   returns a boolean flag saying whether any pre- or poststates changed */\n+fn find_pre_post_state_block(fcx: fn_ctxt, pres0: prestate, b: blk) -> bool {\n+    /* First, set the pre-states and post-states for every expression */\n+\n+    let mut pres = pres0;\n+    /* Iterate over each stmt. The new prestate is <pres>. The poststate\n+     consist of improving <pres> with whatever variables this stmt\n+     initializes.  Then <pres> becomes the new poststate. */\n+\n+    let mut changed = false;\n+    for b.node.stmts.each |s| {\n+        changed |= find_pre_post_state_stmt(fcx, pres, s);\n+        pres = stmt_poststate(fcx.ccx, *s);\n+    }\n+    let mut post = pres;\n+    match b.node.expr {\n+      none { }\n+      some(e) {\n+        changed |= find_pre_post_state_expr(fcx, pres, e);\n+        post = expr_poststate(fcx.ccx, e);\n+      }\n+    }\n+\n+    set_prestate_ann(fcx.ccx, b.node.id, pres0);\n+    set_poststate_ann(fcx.ccx, b.node.id, post);\n+\n+    return changed;\n+}\n+\n+fn find_pre_post_state_fn(fcx: fn_ctxt,\n+                          f_decl: fn_decl,\n+                          f_body: blk) -> bool {\n+    // All constraints are considered false until proven otherwise.\n+    // This ensures that intersect works correctly.\n+    kill_all_prestate(fcx, f_body.node.id);\n+\n+    // Instantiate any constraints on the arguments so we can use them\n+    let block_pre = block_prestate(fcx.ccx, f_body);\n+    for f_decl.constraints.each |c| {\n+        let tsc = ast_constr_to_ts_constr(fcx.ccx.tcx, f_decl.inputs, c);\n+        set_in_prestate_constr(fcx, tsc, block_pre);\n+    }\n+\n+    let mut changed = find_pre_post_state_block(fcx, block_pre, f_body);\n+\n+    /*\n+        error!(\"find_pre_post_state_fn\");\n+        log(error, changed);\n+        fcx.ccx.tcx.sess.span_note(f_body.span, fcx.name);\n+    */\n+\n+    return changed;\n+}\n+//\n+// Local Variables:\n+// mode: rust\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// End:\n+//"}, {"sha": "fe317f737b140d65c2ca333a8de136ac005a1dce", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 46, "deletions": 46, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -521,17 +521,17 @@ trait vid {\n \n impl tv_vid: vid {\n     pure fn to_uint() -> uint { *self }\n-    pure fn to_str() -> ~str { fmt!{\"<V%u>\", self.to_uint()} }\n+    pure fn to_str() -> ~str { fmt!(\"<V%u>\", self.to_uint()) }\n }\n \n impl tvi_vid: vid {\n     pure fn to_uint() -> uint { *self }\n-    pure fn to_str() -> ~str { fmt!{\"<VI%u>\", self.to_uint()} }\n+    pure fn to_str() -> ~str { fmt!(\"<VI%u>\", self.to_uint()) }\n }\n \n impl region_vid: vid {\n     pure fn to_uint() -> uint { *self }\n-    pure fn to_str() -> ~str { fmt!{\"%?\", self} }\n+    pure fn to_str() -> ~str { fmt!(\"%?\", self) }\n }\n \n trait purity_to_str {\n@@ -1135,23 +1135,23 @@ fn substs_is_noop(substs: &substs) -> bool {\n }\n \n fn substs_to_str(cx: ctxt, substs: &substs) -> ~str {\n-    fmt!{\"substs(self_r=%s, self_ty=%s, tps=%?)\",\n+    fmt!(\"substs(self_r=%s, self_ty=%s, tps=%?)\",\n          substs.self_r.map_default(~\"none\", |r| region_to_str(cx, r)),\n          substs.self_ty.map_default(~\"none\", |t| ty_to_str(cx, t)),\n-         substs.tps.map(|t| ty_to_str(cx, t))}\n+         substs.tps.map(|t| ty_to_str(cx, t)))\n }\n \n fn subst(cx: ctxt,\n          substs: &substs,\n          typ: t) -> t {\n \n-    debug!{\"subst(substs=%s, typ=%s)\",\n+    debug!(\"subst(substs=%s, typ=%s)\",\n            substs_to_str(cx, substs),\n-           ty_to_str(cx, typ)};\n+           ty_to_str(cx, typ));\n \n     if substs_is_noop(substs) { return typ; }\n     let r = do_subst(cx, substs, typ);\n-    debug!{\"  r = %s\", ty_to_str(cx, r)};\n+    debug!(\"  r = %s\", ty_to_str(cx, r));\n     return r;\n \n     fn do_subst(cx: ctxt,\n@@ -1880,27 +1880,27 @@ fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n \n     fn type_requires(cx: ctxt, seen: @mut ~[def_id],\n                      r_ty: t, ty: t) -> bool {\n-        debug!{\"type_requires(%s, %s)?\",\n+        debug!(\"type_requires(%s, %s)?\",\n                ty_to_str(cx, r_ty),\n-               ty_to_str(cx, ty)};\n+               ty_to_str(cx, ty));\n \n         let r = {\n             get(r_ty).struct == get(ty).struct ||\n                 subtypes_require(cx, seen, r_ty, ty)\n         };\n \n-        debug!{\"type_requires(%s, %s)? %b\",\n+        debug!(\"type_requires(%s, %s)? %b\",\n                ty_to_str(cx, r_ty),\n                ty_to_str(cx, ty),\n-               r};\n+               r);\n         return r;\n     }\n \n     fn subtypes_require(cx: ctxt, seen: @mut ~[def_id],\n                         r_ty: t, ty: t) -> bool {\n-        debug!{\"subtypes_require(%s, %s)?\",\n+        debug!(\"subtypes_require(%s, %s)?\",\n                ty_to_str(cx, r_ty),\n-               ty_to_str(cx, ty)};\n+               ty_to_str(cx, ty));\n \n         let r = match get(ty).struct {\n           ty_nil |\n@@ -1976,10 +1976,10 @@ fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n           }\n         };\n \n-        debug!{\"subtypes_require(%s, %s)? %b\",\n+        debug!(\"subtypes_require(%s, %s)? %b\",\n                ty_to_str(cx, r_ty),\n                ty_to_str(cx, ty),\n-               r};\n+               r);\n \n         return r;\n     }\n@@ -1991,7 +1991,7 @@ fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n fn type_structurally_contains(cx: ctxt, ty: t, test: fn(x: &sty) -> bool) ->\n    bool {\n     let sty = &get(ty).struct;\n-    debug!{\"type_structurally_contains: %s\", ty_to_str(cx, ty)};\n+    debug!(\"type_structurally_contains: %s\", ty_to_str(cx, ty));\n     if test(sty) { return true; }\n     match *sty {\n       ty_enum(did, ref substs) => {\n@@ -2326,9 +2326,9 @@ fn node_id_to_type(cx: ctxt, id: ast::node_id) -> t {\n     match smallintmap::find(*cx.node_types, id as uint) {\n        some(t) => t,\n        none => cx.sess.bug(\n-           fmt!{\"node_id_to_type: unbound node ID %s\",\n+           fmt!(\"node_id_to_type: unbound node ID %s\",\n                 ast_map::node_id_to_str(cx.items, id,\n-                                        cx.sess.parse_sess.interner)})\n+                                        cx.sess.parse_sess.interner)))\n     }\n }\n \n@@ -2382,7 +2382,7 @@ fn is_fn_ty(fty: t) -> bool {\n fn ty_region(ty: t) -> region {\n     match get(ty).struct {\n       ty_rptr(r, _) => r,\n-      s => fail fmt!{\"ty_region() invoked on non-rptr: %?\", s}\n+      s => fail fmt!(\"ty_region() invoked on non-rptr: %?\", s)\n     }\n }\n \n@@ -2400,15 +2400,15 @@ fn is_pred_ty(fty: t) -> bool {\n fn ty_var_id(typ: t) -> tv_vid {\n     match get(typ).struct {\n       ty_var(vid) => return vid,\n-      _ => { error!{\"ty_var_id called on non-var ty\"}; fail; }\n+      _ => { error!(\"ty_var_id called on non-var ty\"); fail; }\n     }\n }\n \n fn ty_var_integral_id(typ: t) -> tvi_vid {\n     match get(typ).struct {\n       ty_var_integral(vid) => return vid,\n-      _ => { error!{\"ty_var_integral_id called on ty other than \\\n-                  ty_var_integral\"};\n+      _ => { error!(\"ty_var_integral_id called on ty other than \\\n+                  ty_var_integral\");\n          fail; }\n     }\n }\n@@ -2591,7 +2591,7 @@ fn canon_mode(cx: ctxt, m0: ast::mode) -> ast::mode {\n fn resolved_mode(cx: ctxt, m: ast::mode) -> ast::rmode {\n     match canon_mode(cx, m) {\n       ast::infer(_) => {\n-        cx.sess.bug(fmt!{\"mode %? was never resolved\", m});\n+        cx.sess.bug(fmt!(\"mode %? was never resolved\", m));\n       }\n       ast::expl(m0) => m0\n     }\n@@ -2642,7 +2642,7 @@ fn ty_sort_str(cx: ctxt, t: t) -> ~str {\n         ty_to_str(cx, t)\n       }\n \n-      ty_enum(id, _) => fmt!{\"enum %s\", item_path_str(cx, id)},\n+      ty_enum(id, _) => fmt!(\"enum %s\", item_path_str(cx, id)),\n       ty_box(_) => ~\"@-ptr\",\n       ty_uniq(_) => ~\"~-ptr\",\n       ty_evec(_, _) => ~\"vector\",\n@@ -2651,8 +2651,8 @@ fn ty_sort_str(cx: ctxt, t: t) -> ~str {\n       ty_rptr(_, _) => ~\"&-ptr\",\n       ty_rec(_) => ~\"record\",\n       ty_fn(_) => ~\"fn\",\n-      ty_trait(id, _, _) => fmt!{\"trait %s\", item_path_str(cx, id)},\n-      ty_class(id, _) => fmt!{\"class %s\", item_path_str(cx, id)},\n+      ty_trait(id, _, _) => fmt!(\"trait %s\", item_path_str(cx, id)),\n+      ty_class(id, _) => fmt!(\"class %s\", item_path_str(cx, id)),\n       ty_tup(_) => ~\"tuple\",\n       ty_var(_) => ~\"variable\",\n       ty_var_integral(_) => ~\"integral variable\",\n@@ -2685,14 +2685,14 @@ fn type_err_to_str(cx: ctxt, err: &type_err) -> ~str {\n                     to_str(values.expected))\n       }\n       terr_purity_mismatch(values) => {\n-        fmt!{\"expected %s fn but found %s fn\",\n+        fmt!(\"expected %s fn but found %s fn\",\n                     purity_to_str(values.expected),\n-                    purity_to_str(values.found)}\n+                    purity_to_str(values.found))\n       }\n       terr_proto_mismatch(values) => {\n-        fmt!{\"expected %s closure, found %s closure\",\n+        fmt!(\"expected %s closure, found %s closure\",\n              proto_ty_to_str(cx, values.expected),\n-             proto_ty_to_str(cx, values.found)}\n+             proto_ty_to_str(cx, values.found))\n       }\n       terr_mutability => ~\"values differ in mutability\",\n       terr_box_mutability => ~\"boxed values differ in mutability\",\n@@ -2728,14 +2728,14 @@ fn type_err_to_str(cx: ctxt, err: &type_err) -> ~str {\n              mode_to_str(values.expected), mode_to_str(values.found))\n       }\n       terr_regions_does_not_outlive(subregion, superregion) => {\n-        fmt!{\"%s does not necessarily outlive %s\",\n+        fmt!(\"%s does not necessarily outlive %s\",\n                     explain_region(cx, superregion),\n-                    explain_region(cx, subregion)}\n+                    explain_region(cx, subregion))\n       }\n       terr_regions_not_same(region1, region2) => {\n-        fmt!{\"%s is not the same as %s\",\n+        fmt!(\"%s is not the same as %s\",\n                     explain_region(cx, region1),\n-                    explain_region(cx, region2)}\n+                    explain_region(cx, region2))\n       }\n       terr_regions_no_overlap(region1, region2) => {\n         fmt!(\"%s does not intersect %s\",\n@@ -2753,9 +2753,9 @@ fn type_err_to_str(cx: ctxt, err: &type_err) -> ~str {\n              type_err_to_str(cx, err))\n       }\n       terr_sorts(values) => {\n-        fmt!{\"expected %s but found %s\",\n+        fmt!(\"expected %s but found %s\",\n                     ty_sort_str(cx, values.expected),\n-                    ty_sort_str(cx, values.found)}\n+                    ty_sort_str(cx, values.found))\n       }\n       terr_self_substs => {\n         ~\"inconsistent self substitution\" // XXX this is more of a bug\n@@ -2800,7 +2800,7 @@ fn trait_methods(cx: ctxt, id: ast::def_id) -> @~[method] {\n \n fn impl_traits(cx: ctxt, id: ast::def_id) -> ~[t] {\n     if id.crate == ast::local_crate {\n-        debug!{\"(impl_traits) searching for trait impl %?\", id};\n+        debug!(\"(impl_traits) searching for trait impl %?\", id);\n         match cx.items.find(id.node) {\n            some(ast_map::node_item(@{\n                         node: ast::item_impl(_, trait_refs, _, _),\n@@ -2816,12 +2816,12 @@ fn impl_traits(cx: ctxt, id: ast::def_id) -> ~[t] {\n              match cx.def_map.find(id.node) {\n                some(def_ty(trait_id)) => {\n                    // XXX: Doesn't work cross-crate.\n-                   debug!{\"(impl_traits) found trait id %?\", trait_id};\n+                   debug!(\"(impl_traits) found trait id %?\", trait_id);\n                    ~[node_id_to_type(cx, trait_id.node)]\n                }\n                some(x) => {\n-                 cx.sess.bug(fmt!{\"impl_traits: trait ref is in trait map \\\n-                                   but is bound to %?\", x});\n+                 cx.sess.bug(fmt!(\"impl_traits: trait ref is in trait map \\\n+                                   but is bound to %?\", x));\n                }\n                none => {\n                  ~[]\n@@ -2932,7 +2932,7 @@ fn item_path(cx: ctxt, id: ast::def_id) -> ast_map::path {\n           ast_map::node_stmt(*) | ast_map::node_expr(*) |\n           ast_map::node_arg(*) | ast_map::node_local(*) |\n           ast_map::node_export(*) | ast_map::node_block(*) => {\n-            cx.sess.bug(fmt!{\"cannot find item_path for node %?\", node});\n+            cx.sess.bug(fmt!(\"cannot find item_path for node %?\", node));\n           }\n         }\n     }\n@@ -3080,9 +3080,9 @@ fn lookup_class_fields(cx: ctxt, did: ast::def_id) -> ~[field_ty] {\n        }\n        _ => {\n            cx.sess.bug(\n-               fmt!{\"class ID not bound to an item: %s\",\n+               fmt!(\"class ID not bound to an item: %s\",\n                     ast_map::node_id_to_str(cx.items, did.node,\n-                                            cx.sess.parse_sess.interner)});\n+                                            cx.sess.parse_sess.interner)));\n        }\n     }\n         }\n@@ -3147,8 +3147,8 @@ fn lookup_class_method_by_name(cx:ctxt, did: ast::def_id, name: ident,\n              return ast_util::local_def(m.id);\n          }\n        }\n-       cx.sess.span_fatal(sp, fmt!{\"Class doesn't have a method \\\n-           named %s\", cx.sess.str_of(name)});\n+       cx.sess.span_fatal(sp, fmt!(\"Class doesn't have a method \\\n+           named %s\", cx.sess.str_of(name)));\n     }\n     else {\n       csearch::get_class_method(cx.sess.cstore, did, name)"}, {"sha": "302bc604c2a36cb083842b0439b8f6aca3fbbe94", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -175,7 +175,7 @@ enum crate_ctxt {\n \n // Functions that write types into the node type table\n fn write_ty_to_tcx(tcx: ty::ctxt, node_id: ast::node_id, ty: ty::t) {\n-    debug!{\"write_ty_to_tcx(%d, %s)\", node_id, ty_to_str(tcx, ty)};\n+    debug!(\"write_ty_to_tcx(%d, %s)\", node_id, ty_to_str(tcx, ty));\n     smallintmap::insert(*tcx.node_types, node_id as uint, ty);\n }\n fn write_substs_to_tcx(tcx: ty::ctxt,\n@@ -275,10 +275,10 @@ fn check_main_fn_ty(ccx: @crate_ctxt,\n               arg_is_argv_ty(tcx, inputs[0]);\n         if !ok {\n                 tcx.sess.span_err(main_span,\n-                   fmt!{\"Wrong type in main function: found `%s`, \\\n+                   fmt!(\"Wrong type in main function: found `%s`, \\\n                    expected `extern fn(~[str]) -> ()` \\\n                    or `extern fn() -> ()`\",\n-                         ty_to_str(tcx, main_t)});\n+                         ty_to_str(tcx, main_t)));\n          }\n       }\n       _ => {"}, {"sha": "1b6f4e86a61d99cf7a80393957a941fba9426ece", "filename": "src/rustc/middle/typeck/astconv.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -87,8 +87,8 @@ fn ast_path_to_substs_and_ty<AC: ast_conv, RS: region_scope copy owned>(\n     let {bounds: decl_bounds, region_param: decl_rp, ty: decl_ty} =\n         self.get_item_ty(did);\n \n-    debug![\"ast_path_to_substs_and_ty: did=%? decl_rp=%?\",\n-           did, decl_rp];\n+    debug!(\"ast_path_to_substs_and_ty: did=%? decl_rp=%?\",\n+           did, decl_rp);\n \n     // If the type is parameterized by the self region, then replace self\n     // region with the current anon region binding (in other words,\n@@ -100,9 +100,9 @@ fn ast_path_to_substs_and_ty<AC: ast_conv, RS: region_scope copy owned>(\n       (none, some(_)) => {\n         tcx.sess.span_err(\n             path.span,\n-            fmt!{\"no region bound is allowed on `%s`, \\\n+            fmt!(\"no region bound is allowed on `%s`, \\\n                   which is not declared as containing region pointers\",\n-                 ty::item_path_str(tcx, did)});\n+                 ty::item_path_str(tcx, did)));\n         none\n       }\n       (some(_), none) => {\n@@ -119,8 +119,8 @@ fn ast_path_to_substs_and_ty<AC: ast_conv, RS: region_scope copy owned>(\n     if !vec::same_length(*decl_bounds, path.types) {\n         self.tcx().sess.span_fatal(\n             path.span,\n-            fmt!{\"wrong number of type arguments: expected %u but found %u\",\n-                 (*decl_bounds).len(), path.types.len()});\n+            fmt!(\"wrong number of type arguments: expected %u but found %u\",\n+                 (*decl_bounds).len(), path.types.len()));\n     }\n     let tps = path.types.map(|a_t| ast_ty_to_ty(self, rscope, a_t));\n \n@@ -310,8 +310,8 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope copy owned>(\n       ast::ty_path(path, id) => {\n         let a_def = match tcx.def_map.find(id) {\n           none => tcx.sess.span_fatal(\n-              ast_ty.span, fmt!{\"unbound path %s\",\n-                                path_to_str(path, tcx.sess.intr())}),\n+              ast_ty.span, fmt!(\"unbound path %s\",\n+                                path_to_str(path, tcx.sess.intr()))),\n           some(d) => d\n         };\n         match a_def {\n@@ -368,8 +368,8 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope copy owned>(\n                         |ty| {\n                             tcx.sess.span_err(\n                                 a_t.span,\n-                                fmt!{\"bound not allowed on a %s\",\n-                                     ty::ty_sort_str(tcx, ty.ty)});\n+                                fmt!(\"bound not allowed on a %s\",\n+                                     ty::ty_sort_str(tcx, ty.ty)));\n                             ty.ty\n                         })\n       }\n@@ -470,7 +470,7 @@ fn ty_of_fn_decl<AC: ast_conv, RS: region_scope copy owned>(\n     expected_tys: expected_tys,\n     span: span) -> ty::fn_ty {\n \n-    debug!{\"ty_of_fn_decl\"};\n+    debug!(\"ty_of_fn_decl\");\n     do indent {\n         // new region names that appear inside of the fn decl are bound to\n         // that function type"}, {"sha": "956dc70e5ddc0e2ce2267751b781ca78fd743769", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 68, "deletions": 68, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -209,10 +209,10 @@ fn check_fn(ccx: @crate_ctxt,\n     let arg_tys = fn_ty.inputs.map(|a| a.ty);\n     let ret_ty = fn_ty.output;\n \n-    debug!{\"check_fn(arg_tys=%?, ret_ty=%?, self_info.self_ty=%?)\",\n+    debug!(\"check_fn(arg_tys=%?, ret_ty=%?, self_info.self_ty=%?)\",\n            arg_tys.map(|a| ty_to_str(tcx, a)),\n            ty_to_str(tcx, ret_ty),\n-           option::map(self_info, |s| ty_to_str(tcx, s.self_ty))};\n+           option::map(self_info, |s| ty_to_str(tcx, s.self_ty)));\n \n     // ______________________________________________________________________\n     // Create the function context.  This is either derived from scratch or,\n@@ -329,16 +329,16 @@ fn check_fn(ccx: @crate_ctxt,\n         for self_info.each |info| {\n             assign(info.explicit_self.span,\n                    info.self_id, some(info.self_ty));\n-            debug!{\"self is assigned to %s\",\n-                   fcx.locals.get(info.self_id).to_str()};\n+            debug!(\"self is assigned to %s\",\n+                   fcx.locals.get(info.self_id).to_str());\n         }\n \n         // Add formal parameters.\n         do vec::iter2(arg_tys, decl.inputs) |arg_ty, input| {\n             assign(input.ty.span, input.id, some(arg_ty));\n-            debug!{\"Argument %s is assigned to %s\",\n+            debug!(\"Argument %s is assigned to %s\",\n                    tcx.sess.str_of(input.ident),\n-                   fcx.locals.get(input.id).to_str()};\n+                   fcx.locals.get(input.id).to_str());\n         }\n \n         // Add explicitly-declared locals.\n@@ -349,9 +349,9 @@ fn check_fn(ccx: @crate_ctxt,\n               _ => some(fcx.to_ty(local.node.ty))\n             };\n             assign(local.span, local.node.id, o_ty);\n-            debug!{\"Local variable %s is assigned to %s\",\n+            debug!(\"Local variable %s is assigned to %s\",\n                    pat_to_str(local.node.pat, tcx.sess.intr()),\n-                   fcx.locals.get(local.node.id).to_str()};\n+                   fcx.locals.get(local.node.id).to_str());\n             visit::visit_local(local, e, v);\n         };\n \n@@ -361,9 +361,9 @@ fn check_fn(ccx: @crate_ctxt,\n               ast::pat_ident(_, path, _)\n                   if !pat_util::pat_is_variant(fcx.ccx.tcx.def_map, p) => {\n                 assign(p.span, p.id, none);\n-                debug!{\"Pattern binding %s is assigned to %s\",\n+                debug!(\"Pattern binding %s is assigned to %s\",\n                        tcx.sess.str_of(path.idents[0]),\n-                       fcx.locals.get(p.id).to_str()};\n+                       fcx.locals.get(p.id).to_str());\n               }\n               _ => {}\n             }\n@@ -414,9 +414,9 @@ fn check_no_duplicate_fields(tcx: ty::ctxt, fields:\n         let (id, sp) = p;\n         match field_names.find(id) {\n           some(orig_sp) => {\n-            tcx.sess.span_err(sp, fmt!{\"Duplicate field \\\n+            tcx.sess.span_err(sp, fmt!(\"Duplicate field \\\n                                    name %s in record type declaration\",\n-                                        tcx.sess.str_of(id)});\n+                                        tcx.sess.str_of(id)));\n             tcx.sess.span_note(orig_sp, ~\"First declaration of \\\n                                           this field occurred here\");\n             break;\n@@ -528,7 +528,7 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n                 if (*tpt.bounds).is_not_empty() {\n                     ccx.tcx.sess.span_err(\n                         item.span,\n-                        fmt!{\"foreign items may not have type parameters\"});\n+                        fmt!(\"foreign items may not have type parameters\"));\n                 }\n             }\n         }\n@@ -561,23 +561,23 @@ impl @fn_ctxt: region_scope {\n               none if id == syntax::parse::token::special_idents::blk\n                   => result::ok(self.block_region()),\n               none => {\n-                result::err(fmt!{\"named region `%s` not in scope here\",\n-                                 self.ccx.tcx.sess.str_of(id)})\n+                result::err(fmt!(\"named region `%s` not in scope here\",\n+                                 self.ccx.tcx.sess.str_of(id)))\n               }\n             }\n         }\n     }\n }\n \n impl @fn_ctxt {\n-    fn tag() -> ~str { fmt!{\"%x\", ptr::addr_of(*self) as uint} }\n+    fn tag() -> ~str { fmt!(\"%x\", ptr::addr_of(*self) as uint) }\n     fn block_region() -> ty::region {\n         ty::re_scope(self.region_lb)\n     }\n     #[inline(always)]\n     fn write_ty(node_id: ast::node_id, ty: ty::t) {\n-        debug!{\"write_ty(%d, %s) in fcx %s\",\n-               node_id, ty_to_str(self.tcx(), ty), self.tag()};\n+        debug!(\"write_ty(%d, %s) in fcx %s\",\n+               node_id, ty_to_str(self.tcx(), ty), self.tag());\n         self.node_types.insert(node_id, ty);\n     }\n     fn write_substs(node_id: ast::node_id, +substs: ty::substs) {\n@@ -607,9 +607,9 @@ impl @fn_ctxt {\n           some(t) => t,\n           none => {\n             self.tcx().sess.bug(\n-                fmt!{\"no type for expr %d (%s) in fcx %s\",\n+                fmt!(\"no type for expr %d (%s) in fcx %s\",\n                      ex.id, expr_to_str(ex, self.ccx.tcx.sess.intr()),\n-                     self.tag()});\n+                     self.tag()));\n           }\n         }\n     }\n@@ -618,11 +618,11 @@ impl @fn_ctxt {\n           some(t) => t,\n           none => {\n             self.tcx().sess.bug(\n-                fmt!{\"no type for node %d: %s in fcx %s\",\n+                fmt!(\"no type for node %d: %s in fcx %s\",\n                      id, ast_map::node_id_to_str(\n                          self.tcx().items, id,\n                          self.tcx().sess.parse_sess.interner),\n-                     self.tag()});\n+                     self.tag()));\n           }\n         }\n     }\n@@ -631,11 +631,11 @@ impl @fn_ctxt {\n           some(ts) => ts,\n           none => {\n             self.tcx().sess.bug(\n-                fmt!{\"no type substs for node %d: %s in fcx %s\",\n+                fmt!(\"no type substs for node %d: %s in fcx %s\",\n                      id, ast_map::node_id_to_str(\n                          self.tcx().items, id,\n                          self.tcx().sess.parse_sess.interner),\n-                     self.tag()});\n+                     self.tag()));\n           }\n         }\n     }\n@@ -647,10 +647,10 @@ impl @fn_ctxt {\n                                err: &ty::type_err) {\n         self.ccx.tcx.sess.span_err(\n             sp,\n-            fmt!{\"mismatched types: expected `%s` but found `%s` (%s)\",\n+            fmt!(\"mismatched types: expected `%s` but found `%s` (%s)\",\n                  self.infcx.ty_to_str(e),\n                  self.infcx.ty_to_str(a),\n-                 ty::type_err_to_str(self.ccx.tcx, err)});\n+                 ty::type_err_to_str(self.ccx.tcx, err)));\n     }\n \n     fn mk_subty(a_is_expected: bool, span: span,\n@@ -692,7 +692,7 @@ impl @fn_ctxt {\n           _ => {\n             self.ccx.tcx.sess.span_err(\n                 sp,\n-                fmt!{\"%s requires unsafe function or block\", op});\n+                fmt!(\"%s requires unsafe function or block\", op));\n           }\n         }\n     }\n@@ -863,10 +863,10 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                            expected: option<ty::t>,\n                            unifier: fn()) -> bool {\n \n-    debug!{\n+    debug!(\n         \">> typechecking expr %d (%s)\",\n         expr.id, syntax::print::pprust::expr_to_str(expr,\n-                                                    fcx.ccx.tcx.sess.intr())};\n+                                                    fcx.ccx.tcx.sess.intr()));\n \n     // A generic function to factor out common logic from call and\n     // overloaded operations\n@@ -880,8 +880,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         // Replace all region parameters in the arguments and return\n         // type with fresh region variables.\n \n-        debug!{\"check_call_inner: before universal quant., in_fty=%s\",\n-               fcx.infcx.ty_to_str(in_fty)};\n+        debug!(\"check_call_inner: before universal quant., in_fty=%s\",\n+               fcx.infcx.ty_to_str(in_fty));\n \n         // This is subtle: we expect `fty` to be a function type, which\n         // normally introduce a level of binding.  In this case, we want to\n@@ -907,8 +907,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n             };\n \n         let fty = ty::mk_fn(fcx.tcx(), fn_ty);\n-        debug!{\"check_call_inner: after universal quant., fty=%s\",\n-               fcx.infcx.ty_to_str(fty)};\n+        debug!(\"check_call_inner: after universal quant., fty=%s\",\n+               fcx.infcx.ty_to_str(fty));\n \n         let supplied_arg_count = vec::len(args);\n \n@@ -919,7 +919,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n             fn_ty.inputs.map(|a| a.ty)\n         } else {\n             fcx.ccx.tcx.sess.span_err(\n-                sp, fmt!{\"this function takes %u parameter%s but %u \\\n+                sp, fmt!(\"this function takes %u parameter%s but %u \\\n                           parameter%s supplied\", expected_arg_count,\n                          if expected_arg_count == 1u {\n                              ~\"\"\n@@ -931,7 +931,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                              ~\" was\"\n                          } else {\n                              ~\"s were\"\n-                         }});\n+                         }));\n             fcx.infcx.next_ty_vars(supplied_arg_count)\n         };\n \n@@ -1099,8 +1099,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                 // separate case below.\n                 tcx.sess.span_bug(\n                     expr.span,\n-                    fmt!{\"comparison operator in expr_binop: %s\",\n-                         ast_util::binop_to_str(op)});\n+                    fmt!(\"comparison operator in expr_binop: %s\",\n+                         ast_util::binop_to_str(op)));\n               }\n               _ => lhs_t\n             };\n@@ -1161,8 +1161,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n           some((ret_ty, _)) => ret_ty,\n           _ => {\n             fcx.ccx.tcx.sess.span_err(\n-                ex.span, fmt!{\"cannot apply unary operator `%s` to type `%s`\",\n-                              op_str, fcx.infcx.ty_to_str(rhs_t)});\n+                ex.span, fmt!(\"cannot apply unary operator `%s` to type `%s`\",\n+                              op_str, fcx.infcx.ty_to_str(rhs_t)));\n             rhs_t\n           }\n         }\n@@ -1243,8 +1243,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n \n         let fty = ty::mk_fn(tcx, fn_ty);\n \n-        debug!{\"check_expr_fn_with_unifier %s fty=%s\",\n-               expr_to_str(expr, tcx.sess.intr()), fcx.infcx.ty_to_str(fty)};\n+        debug!(\"check_expr_fn_with_unifier %s fty=%s\",\n+               expr_to_str(expr, tcx.sess.intr()), fcx.infcx.ty_to_str(fty));\n \n         fcx.write_ty(expr.id, fty);\n \n@@ -1285,7 +1285,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n \n               // (1) verify that the class id actually has a field called\n               // field\n-              debug!{\"class named %s\", ty_to_str(tcx, base_t)};\n+              debug!(\"class named %s\", ty_to_str(tcx, base_t));\n               /*\n                 check whether this is a self-reference or not, which\n                 determines whether we look at all fields or only public\n@@ -1335,11 +1335,11 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n               }\n               none => {\n                 let t_err = fcx.infcx.resolve_type_vars_if_possible(expr_t);\n-                let msg = fmt!{\"attempted access of field `%s` on type `%s`, \\\n+                let msg = fmt!(\"attempted access of field `%s` on type `%s`, \\\n                                 but no public field or method with that name \\\n                                 was found\",\n                                 tcx.sess.str_of(field),\n-                                fcx.infcx.ty_to_str(t_err)};\n+                                fcx.infcx.ty_to_str(t_err));\n                 tcx.sess.span_err(expr.span, msg);\n                 // NB: Adding a bogus type to allow typechecking to continue\n                 fcx.write_ty(expr.id, fcx.infcx.next_ty_var());\n@@ -1466,8 +1466,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                   _ => {\n                     tcx.sess.span_err(\n                         expr.span,\n-                        fmt!{\"type %s cannot be dereferenced\",\n-                             fcx.infcx.ty_to_str(oprnd_t)});\n+                        fmt!(\"type %s cannot be dereferenced\",\n+                             fcx.infcx.ty_to_str(oprnd_t)));\n                   }\n                 }\n               }\n@@ -1626,9 +1626,9 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n               result::ok(_) => (),\n               result::err(err) => {\n                 tcx.sess.span_fatal(\n-                    expr.span, fmt!{\"a `loop` function's last argument \\\n+                    expr.span, fmt!(\"a `loop` function's last argument \\\n                                      should return `bool`, not `%s`\",\n-                                    fcx.infcx.ty_to_str(fty.output)});\n+                                    fcx.infcx.ty_to_str(fty.output)));\n               }\n             }\n             (ty::mk_fn(tcx, {output: ty::mk_nil(tcx) with fty}), fty.proto)\n@@ -1702,8 +1702,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         let t_1 = fcx.to_ty(t);\n         let t_e = fcx.expr_ty(e);\n \n-        debug!{\"t_1=%s\", fcx.infcx.ty_to_str(t_1)};\n-        debug!{\"t_e=%s\", fcx.infcx.ty_to_str(t_e)};\n+        debug!(\"t_1=%s\", fcx.infcx.ty_to_str(t_1));\n+        debug!(\"t_e=%s\", fcx.infcx.ty_to_str(t_e));\n \n         match ty::get(t_1).struct {\n           // This will be looked up later on\n@@ -1902,14 +1902,14 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                 none => {\n                     tcx.sess.span_err(\n                         field.span,\n-                        fmt!{\"structure has no field named field named `%s`\",\n-                             tcx.sess.str_of(field.node.ident)});\n+                        fmt!(\"structure has no field named field named `%s`\",\n+                             tcx.sess.str_of(field.node.ident)));\n                 }\n                 some((_, true)) => {\n                     tcx.sess.span_err(\n                         field.span,\n-                        fmt!{\"field `%s` specified more than once\",\n-                             tcx.sess.str_of(field.node.ident)});\n+                        fmt!(\"field `%s` specified more than once\",\n+                             tcx.sess.str_of(field.node.ident)));\n                 }\n                 some((field_id, false)) => {\n                     let expected_field_type =\n@@ -1939,14 +1939,14 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                     }\n \n                     tcx.sess.span_err(expr.span,\n-                                      fmt!{\"missing field%s: %s\",\n+                                      fmt!(\"missing field%s: %s\",\n                                            if missing_fields.len() == 1 {\n                                                ~\"\"\n                                            } else {\n                                                ~\"s\"\n                                            },\n                                            str::connect(missing_fields,\n-                                                        ~\", \")});\n+                                                        ~\", \")));\n                 }\n             }\n             some(base_expr) => {\n@@ -1992,17 +1992,17 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n     }\n     if bot { fcx.write_bot(expr.id); }\n \n-    debug!{\"type of expr %s is %s, expected is %s\",\n+    debug!(\"type of expr %s is %s, expected is %s\",\n            syntax::print::pprust::expr_to_str(expr, tcx.sess.intr()),\n            ty_to_str(tcx, fcx.expr_ty(expr)),\n            match expected {\n                some(t) => ty_to_str(tcx, t),\n                _ => ~\"empty\"\n-           }};\n+           });\n \n     unifier();\n \n-    debug!{\"<< bot=%b\", bot};\n+    debug!(\"<< bot=%b\", bot);\n     return bot;\n }\n \n@@ -2152,10 +2152,10 @@ fn check_instantiable(tcx: ty::ctxt,\n                       item_id: ast::node_id) {\n     let item_ty = ty::node_id_to_type(tcx, item_id);\n     if !ty::is_instantiable(tcx, item_ty) {\n-        tcx.sess.span_err(sp, fmt!{\"this type cannot be instantiated \\\n+        tcx.sess.span_err(sp, fmt!(\"this type cannot be instantiated \\\n                                     without an instance of itself; \\\n                                     consider using `option<%s>`\",\n-                                   ty_to_str(tcx, item_ty)});\n+                                   ty_to_str(tcx, item_ty)));\n     }\n }\n \n@@ -2439,7 +2439,7 @@ fn ast_expr_vstore_to_vstore(fcx: @fn_ctxt, e: @ast::expr, n: uint,\n       ast::vstore_fixed(none) => ty::vstore_fixed(n),\n       ast::vstore_fixed(some(u)) => {\n         if n != u {\n-            let s = fmt!{\"fixed-size sequence mismatch: %u vs. %u\",u, n};\n+            let s = fmt!(\"fixed-size sequence mismatch: %u vs. %u\",u, n);\n             fcx.ccx.tcx.sess.span_err(e.span,s);\n         }\n         ty::vstore_fixed(u)\n@@ -2475,8 +2475,8 @@ fn check_bounds_are_used(ccx: @crate_ctxt,\n     for tps_used.eachi |i, b| {\n         if !b {\n             ccx.tcx.sess.span_err(\n-                span, fmt!{\"type parameter `%s` is unused\",\n-                           ccx.tcx.sess.str_of(tps[i].ident)});\n+                span, fmt!(\"type parameter `%s` is unused\",\n+                           ccx.tcx.sess.str_of(tps[i].ident)));\n         }\n     }\n }\n@@ -2574,14 +2574,14 @@ fn check_intrinsic_type(ccx: @crate_ctxt, it: @ast::foreign_item) {\n     let i_ty = ty::lookup_item_type(ccx.tcx, local_def(it.id));\n     let i_n_tps = (*i_ty.bounds).len();\n     if i_n_tps != n_tps {\n-        tcx.sess.span_err(it.span, fmt!{\"intrinsic has wrong number \\\n+        tcx.sess.span_err(it.span, fmt!(\"intrinsic has wrong number \\\n                                          of type parameters: found %u, \\\n-                                         expected %u\", i_n_tps, n_tps});\n+                                         expected %u\", i_n_tps, n_tps));\n     } else {\n         require_same_types(\n             tcx, none, false, it.span, i_ty.ty, fty,\n-            || fmt!{\"intrinsic has wrong type: \\\n+            || fmt!(\"intrinsic has wrong type: \\\n                       expected `%s`\",\n-                     ty_to_str(ccx.tcx, fty)});\n+                     ty_to_str(ccx.tcx, fty)));\n     }\n }"}, {"sha": "be41fddd7198364627f33af7b0170d22981ff592", "filename": "src/rustc/middle/typeck/check/alt.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -101,12 +101,12 @@ fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::path,\n         if arg_len > 0u {\n             // N-ary variant.\n             if arg_len != subpats_len {\n-                let s = fmt!{\"this pattern has %u field%s, but the \\\n+                let s = fmt!(\"this pattern has %u field%s, but the \\\n                               corresponding variant has %u field%s\",\n                              subpats_len,\n                              if subpats_len == 1u { ~\"\" } else { ~\"s\" },\n                              arg_len,\n-                             if arg_len == 1u { ~\"\" } else { ~\"s\" }};\n+                             if arg_len == 1u { ~\"\" } else { ~\"s\" });\n                 tcx.sess.span_fatal(pat.span, s);\n             }\n \n@@ -117,18 +117,18 @@ fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::path,\n             };\n         } else if subpats_len > 0u {\n             tcx.sess.span_fatal\n-                (pat.span, fmt!{\"this pattern has %u field%s, \\\n+                (pat.span, fmt!(\"this pattern has %u field%s, \\\n                                  but the corresponding variant has no fields\",\n                                 subpats_len,\n                                 if subpats_len == 1u { ~\"\" }\n-                                else { ~\"s\" }});\n+                                else { ~\"s\" }));\n         }\n       }\n       _ => {\n         tcx.sess.span_fatal\n             (pat.span,\n-             fmt!{\"mismatched types: expected enum but found `%s`\",\n-                  fcx.infcx.ty_to_str(expected)});\n+             fmt!(\"mismatched types: expected enum but found `%s`\",\n+                  fcx.infcx.ty_to_str(expected)));\n       }\n     }\n }\n@@ -154,8 +154,8 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n             fcx.infcx.resolve_type_vars_if_possible(fcx.expr_ty(begin));\n         let e_ty =\n             fcx.infcx.resolve_type_vars_if_possible(fcx.expr_ty(end));\n-        debug!{\"pat_range beginning type: %?\", b_ty};\n-        debug!{\"pat_range ending type: %?\", e_ty};\n+        debug!(\"pat_range beginning type: %?\", b_ty);\n+        debug!(\"pat_range ending type: %?\", e_ty);\n         if !require_same_types(\n             tcx, some(fcx.infcx), false, pat.span, b_ty, e_ty,\n             || ~\"mismatched types in range\") {\n@@ -240,18 +240,18 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n           _ => {\n             tcx.sess.span_fatal\n                 (pat.span,\n-                fmt!{\"mismatched types: expected `%s` but found record\",\n-                     fcx.infcx.ty_to_str(expected)});\n+                fmt!(\"mismatched types: expected `%s` but found record\",\n+                     fcx.infcx.ty_to_str(expected)));\n           }\n         };\n         let f_count = vec::len(fields);\n         let ex_f_count = vec::len(ex_fields);\n         if ex_f_count < f_count || !etc && ex_f_count > f_count {\n             tcx.sess.span_fatal\n-                (pat.span, fmt!{\"mismatched types: expected a record \\\n+                (pat.span, fmt!(\"mismatched types: expected a record \\\n                       with %u fields, found one with %u \\\n                       fields\",\n-                                ex_f_count, f_count});\n+                                ex_f_count, f_count));\n         }\n \n         for fields.each |f| {\n@@ -261,9 +261,9 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n               }\n               none => {\n                 tcx.sess.span_fatal(pat.span,\n-                                    fmt!{\"mismatched types: did not \\\n+                                    fmt!(\"mismatched types: did not \\\n                                           expect a record with a field `%s`\",\n-                                          tcx.sess.str_of(f.ident)});\n+                                          tcx.sess.str_of(f.ident)));\n               }\n             }\n         }\n@@ -363,16 +363,16 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n           _ => {\n             tcx.sess.span_fatal\n                 (pat.span,\n-                 fmt!{\"mismatched types: expected `%s`, found tuple\",\n-                      fcx.infcx.ty_to_str(expected)});\n+                 fmt!(\"mismatched types: expected `%s`, found tuple\",\n+                      fcx.infcx.ty_to_str(expected)));\n           }\n         };\n         let e_count = vec::len(elts);\n         if e_count != vec::len(ex_elts) {\n             tcx.sess.span_fatal\n-                (pat.span, fmt!{\"mismatched types: expected a tuple \\\n+                (pat.span, fmt!(\"mismatched types: expected a tuple \\\n                       with %u fields, found one with %u \\\n-                      fields\", vec::len(ex_elts), e_count});\n+                      fields\", vec::len(ex_elts), e_count));\n         }\n         let mut i = 0u;\n         for elts.each |elt| {"}, {"sha": "ae913bb894bb8db0ee5d0d74967cedb1e1fa98df", "filename": "src/rustc/middle/typeck/check/method.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -106,10 +106,10 @@ struct lookup {\n \n     // Entrypoint:\n     fn method() -> option<method_map_entry> {\n-        debug!{\"method lookup(m_name=%s, self_ty=%s, %?)\",\n+        debug!(\"method lookup(m_name=%s, self_ty=%s, %?)\",\n                self.fcx.tcx().sess.str_of(self.m_name),\n                self.fcx.infcx.ty_to_str(self.self_ty),\n-               ty::get(self.self_ty).struct};\n+               ty::get(self.self_ty).struct);\n \n         // Determine if there are any inherent methods we can call.\n         // (An inherent method is one that belongs to no trait, but is\n@@ -122,15 +122,15 @@ struct lookup {\n             optional_inherent_methods = none;\n           }\n           some(base_type_def_id) => {\n-            debug!{\"(checking method) found base type\"};\n+            debug!(\"(checking method) found base type\");\n             optional_inherent_methods =\n                 self.fcx.ccx.coherence_info.inherent_methods.find\n                 (base_type_def_id);\n \n             if optional_inherent_methods.is_none() {\n-                debug!{\"(checking method) ... no inherent methods found\"};\n+                debug!(\"(checking method) ... no inherent methods found\");\n             } else {\n-                debug!{\"(checking method) ... inherent methods found\"};\n+                debug!(\"(checking method) ... inherent methods found\");\n             }\n           }\n         }\n@@ -177,8 +177,8 @@ struct lookup {\n \n             // if we found anything, stop before trying borrows\n             if self.candidates.len() > 0u {\n-                debug!{\"(checking method) found at least one inherent \\\n-                        method; giving up looking now\"};\n+                debug!(\"(checking method) found at least one inherent \\\n+                        method; giving up looking now\");\n                 break;\n             }\n \n@@ -205,8 +205,8 @@ struct lookup {\n \n             // if we found anything, stop before attempting auto-deref.\n             if self.candidates.len() > 0u {\n-                debug!{\"(checking method) found at least one inherent \\\n-                        method; giving up looking now\"};\n+                debug!(\"(checking method) found at least one inherent \\\n+                        method; giving up looking now\");\n                 break;\n             }\n \n@@ -221,8 +221,8 @@ struct lookup {\n         }\n \n         if self.candidates.len() == 0u {\n-            debug!{\"(checking method) couldn't find any candidate methods; \\\n-                    returning none\"};\n+            debug!(\"(checking method) couldn't find any candidate methods; \\\n+                    returning none\");\n             return none;\n         }\n \n@@ -261,30 +261,30 @@ struct lookup {\n         };\n         self.tcx().sess.span_note(\n             span,\n-            fmt!{\"candidate #%u is `%s`\",\n+            fmt!(\"candidate #%u is `%s`\",\n                  (idx+1u),\n-                 ty::item_path_str(self.tcx(), did)});\n+                 ty::item_path_str(self.tcx(), did)));\n     }\n \n     fn report_param_candidate(idx: uint, did: ast::def_id) {\n         self.tcx().sess.span_note(\n             self.expr.span,\n-            fmt!{\"candidate #%u derives from the bound `%s`\",\n+            fmt!(\"candidate #%u derives from the bound `%s`\",\n                  (idx+1u),\n-                 ty::item_path_str(self.tcx(), did)});\n+                 ty::item_path_str(self.tcx(), did)));\n     }\n \n     fn report_trait_candidate(idx: uint, did: ast::def_id) {\n         self.tcx().sess.span_note(\n             self.expr.span,\n-            fmt!{\"candidate #%u derives from the type of the receiver, \\\n+            fmt!(\"candidate #%u derives from the type of the receiver, \\\n                   which is the trait `%s`\",\n                  (idx+1u),\n-                 ty::item_path_str(self.tcx(), did)});\n+                 ty::item_path_str(self.tcx(), did)));\n     }\n \n     fn add_candidates_from_param(n: uint, did: ast::def_id) {\n-        debug!{\"add_candidates_from_param\"};\n+        debug!(\"add_candidates_from_param\");\n \n         let tcx = self.tcx();\n         let mut trait_bnd_idx = 0u; // count only trait bounds\n@@ -334,7 +334,7 @@ struct lookup {\n \n     fn add_candidates_from_trait(did: ast::def_id, trait_substs: ty::substs) {\n \n-        debug!{\"add_candidates_from_trait\"};\n+        debug!(\"add_candidates_from_trait\");\n \n         let ms = *ty::trait_methods(self.tcx(), did);\n         for ms.eachi |i, m| {\n@@ -369,7 +369,7 @@ struct lookup {\n \n     fn add_candidates_from_class(did: ast::def_id, class_substs: ty::substs) {\n \n-        debug!{\"add_candidates_from_class\"};\n+        debug!(\"add_candidates_from_class\");\n \n         let ms = *ty::trait_methods(self.tcx(), did);\n \n@@ -469,7 +469,7 @@ struct lookup {\n                     matches = self.fcx.can_mk_subty(ref_ty, impl_ty);\n                 }\n             }\n-            debug!{\"matches = %?\", matches};\n+            debug!(\"matches = %?\", matches);\n             match matches {\n               result::err(_) => { /* keep looking */ }\n               result::ok(_) => {\n@@ -528,15 +528,15 @@ struct lookup {\n             // Continue.\n           }\n           some(inherent_methods) => {\n-            debug!{\"(adding inherent and extension candidates) adding \\\n-                    inherent candidates\"};\n+            debug!(\"(adding inherent and extension candidates) adding \\\n+                    inherent candidates\");\n             for inherent_methods.each |implementation| {\n-                debug!{\"(adding inherent and extension candidates) \\\n+                debug!(\"(adding inherent and extension candidates) \\\n                         adding candidates from impl: %s\",\n                         node_id_to_str(self.tcx().items,\n                                        implementation.did.node,\n                                        self.fcx.tcx().sess.parse_sess\n-                                           .interner)};\n+                                           .interner));\n                 self.add_candidates_from_impl(implementation, mode);\n             }\n           }\n@@ -549,9 +549,9 @@ struct lookup {\n           }\n           some(trait_ids) => {\n             for (*trait_ids).each |trait_id| {\n-                debug!{\"(adding inherent and extension candidates) \\\n+                debug!(\"(adding inherent and extension candidates) \\\n                         trying trait: %s\",\n-                        self.def_id_to_str(trait_id)};\n+                        self.def_id_to_str(trait_id));\n \n                 let coherence_info = self.fcx.ccx.coherence_info;\n                 match coherence_info.extension_methods.find(trait_id) {\n@@ -560,10 +560,10 @@ struct lookup {\n                   }\n                   some(extension_methods) => {\n                     for extension_methods.each |implementation| {\n-                        debug!{\"(adding inherent and extension \\\n+                        debug!(\"(adding inherent and extension \\\n                                 candidates) adding impl %s\",\n                                 self.def_id_to_str\n-                                (implementation.did)};\n+                                (implementation.did));\n                         self.add_candidates_from_impl(implementation, mode);\n                     }\n                   }\n@@ -586,10 +586,10 @@ struct lookup {\n     fn write_mty_from_candidate(cand: candidate) -> method_map_entry {\n         let tcx = self.fcx.ccx.tcx;\n \n-        debug!{\"write_mty_from_candidate(n_tps_m=%u, fty=%s, entry=%?)\",\n+        debug!(\"write_mty_from_candidate(n_tps_m=%u, fty=%s, entry=%?)\",\n                cand.n_tps_m,\n                self.fcx.infcx.ty_to_str(cand.fty),\n-               cand.entry};\n+               cand.entry);\n \n         match cand.mode {\n             subtyping_mode | assignability_mode => {\n@@ -602,9 +602,9 @@ struct lookup {\n                   result::err(_) => {\n                     self.tcx().sess.span_bug(\n                         self.expr.span,\n-                        fmt!{\"%s was assignable to %s but now is not?\",\n+                        fmt!(\"%s was assignable to %s but now is not?\",\n                              self.fcx.infcx.ty_to_str(cand.self_ty),\n-                             self.fcx.infcx.ty_to_str(cand.rcvr_ty)});\n+                             self.fcx.infcx.ty_to_str(cand.rcvr_ty)));\n                   }\n                 }\n             }"}, {"sha": "fc8997407d8727b1eead3a7e84362b0ee91e11eb", "filename": "src/rustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -156,8 +156,8 @@ fn visit_block(b: ast::blk, &&rcx: @rcx, v: rvt) {\n }\n \n fn visit_expr(e: @ast::expr, &&rcx: @rcx, v: rvt) {\n-    debug!{\"visit_expr(e=%s)\",\n-           pprust::expr_to_str(e, rcx.fcx.tcx().sess.intr())};\n+    debug!(\"visit_expr(e=%s)\",\n+           pprust::expr_to_str(e, rcx.fcx.tcx().sess.intr()));\n \n     match e.node {\n       ast::expr_path(*) => {\n@@ -257,8 +257,8 @@ fn visit_node(id: ast::node_id, span: span, rcx: @rcx) -> bool {\n     let tcx = fcx.ccx.tcx;\n     let encl_region = ty::encl_region(tcx, id);\n \n-    debug!{\"visit_node(ty=%s, id=%d, encl_region=%?)\",\n-           ty_to_str(tcx, ty), id, encl_region};\n+    debug!(\"visit_node(ty=%s, id=%d, encl_region=%?)\",\n+           ty_to_str(tcx, ty), id, encl_region);\n \n     // Otherwise, look at the type and see if it is a region pointer.\n     return constrain_regions_in_type(rcx, encl_region, span, ty);\n@@ -316,8 +316,8 @@ fn constrain_regions_in_type(\n                         region: ty::region) {\n         let tcx = rcx.fcx.ccx.tcx;\n \n-        debug!{\"constrain_region(encl_region=%?, region=%?)\",\n-               encl_region, region};\n+        debug!(\"constrain_region(encl_region=%?, region=%?)\",\n+               encl_region, region);\n \n         match region {\n           ty::re_bound(_) => {"}, {"sha": "b879e4b8fed54c747db91709886683e2bdea5a8a", "filename": "src/rustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -35,15 +35,15 @@ fn replace_bound_regions_in_fn_ty(\n \n     for self_ty.each |t| { vec::push(all_tys, t) }\n \n-    debug!{\"replace_bound_regions_in_fn_ty(self_info.self_ty=%?, fn_ty=%s, \\\n+    debug!(\"replace_bound_regions_in_fn_ty(self_info.self_ty=%?, fn_ty=%s, \\\n                 all_tys=%?)\",\n            self_ty.map(|t| ty_to_str(tcx, t)),\n            ty_to_str(tcx, ty::mk_fn(tcx, *fn_ty)),\n-           all_tys.map(|t| ty_to_str(tcx, t))};\n+           all_tys.map(|t| ty_to_str(tcx, t)));\n     let _i = indenter();\n \n     let isr = do create_bound_region_mapping(tcx, isr, all_tys) |br| {\n-        debug!{\"br=%?\", br};\n+        debug!(\"br=%?\", br);\n         mapf(br)\n     };\n     let ty_fn = ty::ty_fn(*fn_ty);\n@@ -52,10 +52,10 @@ fn replace_bound_regions_in_fn_ty(\n     });\n     let t_self = self_ty.map(|t| replace_bound_regions(tcx, isr, t));\n \n-    debug!{\"result of replace_bound_regions_in_fn_ty: self_info.self_ty=%?, \\\n+    debug!(\"result of replace_bound_regions_in_fn_ty: self_info.self_ty=%?, \\\n                 fn_ty=%s\",\n            t_self.map(|t| ty_to_str(tcx, t)),\n-           ty_to_str(tcx, t_fn)};\n+           ty_to_str(tcx, t_fn));\n \n \n     // Glue updated self_ty back together with its original def_id.\n@@ -161,9 +161,9 @@ fn replace_bound_regions_in_fn_ty(\n                   none if in_fn => r,\n                   none => {\n                     tcx.sess.bug(\n-                        fmt!{\"Bound region not found in \\\n+                        fmt!(\"Bound region not found in \\\n                               in_scope_regions list: %s\",\n-                             region_to_str(tcx, r)});\n+                             region_to_str(tcx, r)));\n                   }\n                 }\n               }"}, {"sha": "930bb3480b943f7282414e0dbb696817d8e3b4a1", "filename": "src/rustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -83,8 +83,8 @@ fn lookup_vtable(fcx: @fn_ctxt,\n     -> vtable_origin\n {\n \n-    debug!{\"lookup_vtable(ty=%s, trait_ty=%s)\",\n-           fcx.infcx.ty_to_str(ty), fcx.infcx.ty_to_str(trait_ty)};\n+    debug!(\"lookup_vtable(ty=%s, trait_ty=%s)\",\n+           fcx.infcx.ty_to_str(ty), fcx.infcx.ty_to_str(trait_ty));\n     let _i = indenter();\n \n     let tcx = fcx.ccx.tcx;\n@@ -116,8 +116,8 @@ fn lookup_vtable(fcx: @fn_ctxt,\n                 match check ty::get(ity).struct {\n                   ty::ty_trait(idid, substs, _) => {\n                     if trait_id == idid {\n-                        debug!{\"(checking vtable) @0 relating ty to trait ty\n-                                with did %?\", idid};\n+                        debug!(\"(checking vtable) @0 relating ty to trait ty\n+                                with did %?\", idid);\n                         relate_trait_tys(fcx, expr, trait_ty, ity);\n                         return vtable_param(n, n_bound);\n                     }\n@@ -130,8 +130,8 @@ fn lookup_vtable(fcx: @fn_ctxt,\n       }\n \n       ty::ty_trait(did, substs, _) if trait_id == did => {\n-        debug!{\"(checking vtable) @1 relating ty to trait ty with did %?\",\n-               did};\n+        debug!(\"(checking vtable) @1 relating ty to trait ty with did %?\",\n+               did);\n \n         relate_trait_tys(fcx, expr, trait_ty, ty);\n         if !allow_unsafe && !is_early {\n@@ -258,9 +258,9 @@ fn fixup_ty(fcx: @fn_ctxt,\n       result::err(e) if !is_early => {\n         tcx.sess.span_fatal(\n             expr.span,\n-            fmt!{\"cannot determine a type \\\n+            fmt!(\"cannot determine a type \\\n                   for this bounded type parameter: %s\",\n-                 fixup_err_to_str(e)})\n+                 fixup_err_to_str(e)))\n       }\n       result::err(e) => {\n         none\n@@ -275,8 +275,8 @@ fn connect_trait_tps(fcx: @fn_ctxt, expr: @ast::expr, impl_tys: ~[ty::t],\n     // XXX: This should work for multiple traits.\n     let ity = ty::impl_traits(tcx, impl_did)[0];\n     let trait_ty = ty::subst_tps(tcx, impl_tys, ity);\n-    debug!{\"(connect trait tps) trait type is %?, impl did is %?\",\n-           ty::get(trait_ty).struct, impl_did};\n+    debug!(\"(connect trait tps) trait type is %?, impl did is %?\",\n+           ty::get(trait_ty).struct, impl_did);\n     match check ty::get(trait_ty).struct {\n       ty::ty_trait(_, substs, _) => {\n         vec::iter2(substs.tps, trait_tys,"}, {"sha": "3201ffc7459f14938753947d0c2f248afdec92e8", "filename": "src/rustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -16,9 +16,9 @@ fn resolve_type_vars_in_type(fcx: @fn_ctxt, sp: span, typ: ty::t) ->\n         if !fcx.ccx.tcx.sess.has_errors() {\n             fcx.ccx.tcx.sess.span_err(\n                 sp,\n-                fmt!{\"cannot determine a type \\\n+                fmt!(\"cannot determine a type \\\n                       for this expression: %s\",\n-                     infer::fixup_err_to_str(e)})\n+                     infer::fixup_err_to_str(e)))\n         }\n         return none;\n       }\n@@ -35,8 +35,8 @@ fn resolve_type_vars_for_node(wbcx: wb_ctxt, sp: span, id: ast::node_id)\n       }\n \n       some(t) => {\n-        debug!{\"resolve_type_vars_for_node(id=%d, n_ty=%s, t=%s)\",\n-               id, ty_to_str(tcx, n_ty), ty_to_str(tcx, t)};\n+        debug!(\"resolve_type_vars_for_node(id=%d, n_ty=%s, t=%s)\",\n+               id, ty_to_str(tcx, n_ty), ty_to_str(tcx, t));\n         write_ty_to_tcx(tcx, id, t);\n         match fcx.opt_node_ty_substs(id) {\n           some(substs) => {\n@@ -116,11 +116,11 @@ fn visit_block(b: ast::blk, wbcx: wb_ctxt, v: wb_vt) {\n fn visit_pat(p: @ast::pat, wbcx: wb_ctxt, v: wb_vt) {\n     if !wbcx.success { return; }\n     resolve_type_vars_for_node(wbcx, p.span, p.id);\n-    debug!{\"Type for pattern binding %s (id %d) resolved to %s\",\n+    debug!(\"Type for pattern binding %s (id %d) resolved to %s\",\n            pat_to_str(p, wbcx.fcx.ccx.tcx.sess.intr()), p.id,\n            wbcx.fcx.infcx.ty_to_str(\n                ty::node_id_to_type(wbcx.fcx.ccx.tcx,\n-                                   p.id))};\n+                                   p.id)));\n     visit::visit_pat(p, wbcx, v);\n }\n fn visit_local(l: @ast::local, wbcx: wb_ctxt, v: wb_vt) {\n@@ -129,17 +129,17 @@ fn visit_local(l: @ast::local, wbcx: wb_ctxt, v: wb_vt) {\n     let var_ty = ty::mk_var(wbcx.fcx.tcx(), var_id);\n     match resolve_type(wbcx.fcx.infcx, var_ty, resolve_all | force_all) {\n       result::ok(lty) => {\n-        debug!{\"Type for local %s (id %d) resolved to %s\",\n+        debug!(\"Type for local %s (id %d) resolved to %s\",\n                pat_to_str(l.node.pat, wbcx.fcx.ccx.tcx.sess.intr()),l.node.id,\n-               wbcx.fcx.infcx.ty_to_str(lty)};\n+               wbcx.fcx.infcx.ty_to_str(lty));\n         write_ty_to_tcx(wbcx.fcx.ccx.tcx, l.node.id, lty);\n       }\n       result::err(e) => {\n         wbcx.fcx.ccx.tcx.sess.span_err(\n             l.span,\n-            fmt!{\"cannot determine a type \\\n+            fmt!(\"cannot determine a type \\\n                   for this local variable: %s\",\n-                 infer::fixup_err_to_str(e)});\n+                 infer::fixup_err_to_str(e)));\n         wbcx.success = false;\n       }\n     }"}, {"sha": "6254d244fc7950cb061c52db37b57ce91cb94b9d", "filename": "src/rustc/middle/typeck/coherence.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -60,13 +60,13 @@ fn get_base_type(inference_context: infer_ctxt, span: span, original_type: t)\n         ty_uniq(base_mutability_and_type) |\n         ty_ptr(base_mutability_and_type) |\n         ty_rptr(_, base_mutability_and_type) => {\n-            debug!{\"(getting base type) recurring\"};\n+            debug!(\"(getting base type) recurring\");\n             get_base_type(inference_context, span,\n                           base_mutability_and_type.ty)\n         }\n \n         ty_enum(*) | ty_trait(*) | ty_class(*) => {\n-            debug!{\"(getting base type) found base type\"};\n+            debug!(\"(getting base type) found base type\");\n             some(resolved_type)\n         }\n \n@@ -75,8 +75,8 @@ fn get_base_type(inference_context: infer_ctxt, span: span, original_type: t)\n         ty_fn(*) | ty_tup(*) | ty_var(*) | ty_var_integral(*) |\n         ty_param(*) | ty_self | ty_type | ty_opaque_box |\n         ty_opaque_closure_ptr(*) | ty_unboxed_vec(*) => {\n-            debug!{\"(getting base type) no base type; found %?\",\n-                   get(original_type).struct};\n+            debug!(\"(getting base type) no base type; found %?\",\n+                   get(original_type).struct);\n             none\n         }\n     }\n@@ -173,9 +173,9 @@ struct CoherenceChecker {\n                 match item.node {\n                   item_trait(_, _, trait_methods) => {\n                     for trait_methods.each |trait_method| {\n-                        debug!{\"(building provided methods map) checking \\\n+                        debug!(\"(building provided methods map) checking \\\n                                 trait `%s` with id %d\",\n-                                sess.str_of(item.ident), item.id};\n+                                sess.str_of(item.ident), item.id);\n \n                         match trait_method {\n                             required(_) => { /* fall through */}\n@@ -191,22 +191,22 @@ struct CoherenceChecker {\n                                       // provided_methods_map, we just\n                                       // need to add this method to\n                                       // that entry.\n-                                      debug!{\"(building provided \\\n+                                      debug!(\"(building provided \\\n                                               methods map) adding \\\n                                               method `%s` to entry for \\\n                                               existing trait\",\n-                                              sess.str_of(mi.ident)};\n+                                              sess.str_of(mi.ident));\n                                       let mut method_infos = mis;\n                                       push(method_infos, mi);\n                                       pmm.insert(item.id, method_infos);\n                                     }\n                                     none => {\n                                       // If the trait doesn't have an\n                                       // entry yet, create one.\n-                                      debug!{\"(building provided \\\n+                                      debug!(\"(building provided \\\n                                               methods map) creating new \\\n                                               entry for method `%s`\",\n-                                              sess.str_of(mi.ident)};\n+                                              sess.str_of(mi.ident));\n                                       pmm.insert(item.id, ~[mi]);\n                                     }\n                                 }\n@@ -229,8 +229,8 @@ struct CoherenceChecker {\n         // inherent methods and extension methods.\n         visit_crate(*crate, (), mk_simple_visitor(@{\n             visit_item: |item| {\n-                debug!{\"(checking coherence) item '%s'\",\n-                       self.crate_context.tcx.sess.str_of(item.ident)};\n+                debug!(\"(checking coherence) item '%s'\",\n+                       self.crate_context.tcx.sess.str_of(item.ident));\n \n                 match item.node {\n                     item_impl(_, associated_traits, _, _) => {\n@@ -270,9 +270,9 @@ struct CoherenceChecker {\n         // base type.\n \n         if associated_traits.len() == 0 {\n-            debug!{\"(checking implementation) no associated traits for item \\\n+            debug!(\"(checking implementation) no associated traits for item \\\n                     '%s'\",\n-                   self.crate_context.tcx.sess.str_of(item.ident)};\n+                   self.crate_context.tcx.sess.str_of(item.ident));\n \n             match get_base_type_def_id(self.inference_context,\n                                        item.span,\n@@ -293,12 +293,12 @@ struct CoherenceChecker {\n         for associated_traits.each |associated_trait| {\n             let trait_did =\n                 self.trait_ref_to_trait_def_id(associated_trait);\n-            debug!{\"(checking implementation) adding impl for trait \\\n+            debug!(\"(checking implementation) adding impl for trait \\\n                     '%s', item '%s'\",\n                     ast_map::node_id_to_str(\n                         self.crate_context.tcx.items, trait_did.node,\n                         self.crate_context.tcx.sess.parse_sess.interner),\n-                    self.crate_context.tcx.sess.str_of(item.ident)};\n+                    self.crate_context.tcx.sess.str_of(item.ident));\n \n             let implementation = self.create_impl_from_item(item);\n             self.add_trait_method(trait_did, implementation);\n@@ -442,10 +442,10 @@ struct CoherenceChecker {\n                         let privileged_types =\n                             self.gather_privileged_types(module_.items);\n                         for privileged_types.each |privileged_type| {\n-                            debug!{\"(checking privileged scopes) entering \\\n+                            debug!(\"(checking privileged scopes) entering \\\n                                     privileged scope of %d:%d\",\n                                    privileged_type.crate,\n-                                   privileged_type.node};\n+                                   privileged_type.node);\n \n                             self.privileged_types.insert(privileged_type, ());\n                         }\n@@ -586,9 +586,9 @@ struct CoherenceChecker {\n                 }\n \n                 if !method_inherent_to_impl {\n-                    debug!{\n+                    debug!(\n                         \"(creating impl) adding provided method `%s` to impl\",\n-                        sess.str_of(provided_method.ident)};\n+                        sess.str_of(provided_method.ident));\n                     push(methods, provided_method);\n                 }\n             }\n@@ -616,14 +616,14 @@ struct CoherenceChecker {\n                     match self.crate_context.provided_methods_map\n                         .find(trait_did.node) {\n                         none => {\n-                            debug!{\"(creating impl) trait with node_id `%d` \\\n-                                    has no provided methods\", trait_did.node};\n+                            debug!(\"(creating impl) trait with node_id `%d` \\\n+                                    has no provided methods\", trait_did.node);\n                             /* fall through */\n                         }\n                         some(all_provided)\n                                     => {\n-                            debug!{\"(creating impl) trait with node_id `%d` \\\n-                                    has provided methods\", trait_did.node};\n+                            debug!(\"(creating impl) trait with node_id `%d` \\\n+                                    has provided methods\", trait_did.node);\n                             // Selectively add only those provided\n                             // methods that aren't inherent to the\n                             // trait.\n@@ -722,11 +722,11 @@ struct CoherenceChecker {\n                                            self_type.ty) {\n                     none => {\n                         let session = self.crate_context.tcx.sess;\n-                        session.bug(fmt!{\n+                        session.bug(fmt!(\n                             \"no base type for external impl \\\n                              with no trait: %s (type %s)!\",\n                              session.str_of(implementation.ident),\n-                             ty_to_str(self.crate_context.tcx,self_type.ty)});\n+                             ty_to_str(self.crate_context.tcx,self_type.ty)));\n                     }\n                     some(_) => {\n                         // Nothing to do."}, {"sha": "132ec2a4e9052eae6ae83182f749dd9df8058d7d", "filename": "src/rustc/middle/typeck/collect.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -95,8 +95,8 @@ impl @crate_ctxt: ast_conv {\n                 ty_of_foreign_item(self, foreign_item)\n               }\n               x => {\n-                self.tcx.sess.bug(fmt!{\"unexpected sort of item \\\n-                                        in get_item_ty(): %?\", x});\n+                self.tcx.sess.bug(fmt!(\"unexpected sort of item \\\n+                                        in get_item_ty(): %?\", x));\n               }\n             }\n         }\n@@ -249,17 +249,17 @@ fn compare_impl_method(tcx: ty::ctxt, sp: span,\n \n     if impl_m.purity != trait_m.purity {\n         tcx.sess.span_err(\n-            sp, fmt!{\"method `%s`'s purity does \\\n+            sp, fmt!(\"method `%s`'s purity does \\\n                           not match the trait method's \\\n-                          purity\", tcx.sess.str_of(impl_m.ident)});\n+                          purity\", tcx.sess.str_of(impl_m.ident)));\n     }\n \n     // is this check right?\n     if impl_m.self_ty != trait_m.self_ty {\n         tcx.sess.span_err(\n-            sp, fmt!{\"method `%s`'s self type does \\\n+            sp, fmt!(\"method `%s`'s self type does \\\n                           not match the trait method's \\\n-                          self type\", tcx.sess.str_of(impl_m.ident)});\n+                          self type\", tcx.sess.str_of(impl_m.ident)));\n     }\n \n     if impl_m.tps != trait_m.tps {\n@@ -269,11 +269,11 @@ fn compare_impl_method(tcx: ty::ctxt, sp: span,\n     }\n \n     if vec::len(impl_m.fty.inputs) != vec::len(trait_m.fty.inputs) {\n-        tcx.sess.span_err(sp,fmt!{\"method `%s` has %u parameters \\\n+        tcx.sess.span_err(sp,fmt!(\"method `%s` has %u parameters \\\n                                    but the trait has %u\",\n                                    tcx.sess.str_of(trait_m.ident),\n                                    vec::len(impl_m.fty.inputs),\n-                                   vec::len(trait_m.fty.inputs)});\n+                                   vec::len(trait_m.fty.inputs)));\n         return;\n     }\n \n@@ -357,8 +357,8 @@ fn check_methods_against_trait(ccx: @crate_ctxt,\n                     none => {\n                       tcx.sess.span_err(\n                           a_trait_ty.path.span,\n-                          fmt!{\"missing method `%s`\",\n-                               tcx.sess.str_of(trait_m.ident)});\n+                          fmt!(\"missing method `%s`\",\n+                               tcx.sess.str_of(trait_m.ident)));\n                     }\n                   }\n                 }\n@@ -413,8 +413,8 @@ fn convert_methods(ccx: @crate_ctxt,\n fn convert(ccx: @crate_ctxt, it: @ast::item) {\n     let tcx = ccx.tcx;\n     let rp = tcx.region_paramd_items.find(it.id);\n-    #debug[\"convert: item %s with id %d rp %?\",\n-           tcx.sess.str_of(it.ident), it.id, rp];\n+    debug!(\"convert: item %s with id %d rp %?\",\n+           tcx.sess.str_of(it.ident), it.id, rp);\n     match it.node {\n       // These don't define types.\n       ast::item_foreign_mod(_) | ast::item_mod(_) => {}\n@@ -440,8 +440,8 @@ fn convert(ccx: @crate_ctxt, it: @ast::item) {\n       }\n       ast::item_trait(tps, _, trait_methods) => {\n         let tpt = ty_of_item(ccx, it);\n-        debug!{\"item_trait(it.id=%d, tpt.ty=%s)\",\n-               it.id, ty_to_str(tcx, tpt.ty)};\n+        debug!(\"item_trait(it.id=%d, tpt.ty=%s)\",\n+               it.id, ty_to_str(tcx, tpt.ty));\n         write_ty_to_tcx(tcx, it.id, tpt.ty);\n         ensure_trait_methods(ccx, it.id, tpt.ty);\n \n@@ -621,8 +621,8 @@ fn ty_of_item(ccx: @crate_ctxt, it: @ast::item)\n         let tpt = {bounds: bounds,\n                    region_param: none,\n                    ty: ty::mk_fn(ccx.tcx, tofd)};\n-        debug!{\"type of %s (id %d) is %s\",\n-               tcx.sess.str_of(it.ident), it.id, ty_to_str(tcx, tpt.ty)};\n+        debug!(\"type of %s (id %d) is %s\",\n+               tcx.sess.str_of(it.ident), it.id, ty_to_str(tcx, tpt.ty));\n         ccx.tcx.tcache.insert(local_def(it.id), tpt);\n         return tpt;\n       }"}, {"sha": "dd5f8bd0db77143a684594deaf0a0f853f2c7e09", "filename": "src/rustc/middle/typeck/infer.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -352,8 +352,8 @@ fn fixup_err_to_str(f: fixup_err) -> ~str {\n       cyclic_ty(_) => ~\"cyclic type of infinite size\",\n       unresolved_region(_) => ~\"unconstrained region\",\n       region_var_bound_by_region_var(r1, r2) => {\n-        fmt!{\"region var %? bound by another region var %?; this is \\\n-              a bug in rustc\", r1, r2}\n+        fmt!(\"region var %? bound by another region var %?; this is \\\n+              a bug in rustc\", r1, r2)\n       }\n     }\n }\n@@ -384,7 +384,7 @@ fn mk_sub(cx: infer_ctxt, a_is_expected: bool, span: span) -> Sub {\n \n fn mk_subty(cx: infer_ctxt, a_is_expected: bool, span: span,\n             a: ty::t, b: ty::t) -> ures {\n-    debug!{\"mk_subty(%s <: %s)\", a.to_str(cx), b.to_str(cx)};\n+    debug!(\"mk_subty(%s <: %s)\", a.to_str(cx), b.to_str(cx));\n     do indent {\n         do cx.commit {\n             mk_sub(cx, a_is_expected, span).tys(a, b)\n@@ -393,7 +393,7 @@ fn mk_subty(cx: infer_ctxt, a_is_expected: bool, span: span,\n }\n \n fn can_mk_subty(cx: infer_ctxt, a: ty::t, b: ty::t) -> ures {\n-    debug!{\"can_mk_subty(%s <: %s)\", a.to_str(cx), b.to_str(cx)};\n+    debug!(\"can_mk_subty(%s <: %s)\", a.to_str(cx), b.to_str(cx));\n     do indent {\n         do cx.probe {\n             mk_sub(cx, true, ast_util::dummy_sp()).tys(a, b)\n@@ -403,7 +403,7 @@ fn can_mk_subty(cx: infer_ctxt, a: ty::t, b: ty::t) -> ures {\n \n fn mk_subr(cx: infer_ctxt, a_is_expected: bool, span: span,\n            a: ty::region, b: ty::region) -> ures {\n-    debug!{\"mk_subr(%s <: %s)\", a.to_str(cx), b.to_str(cx)};\n+    debug!(\"mk_subr(%s <: %s)\", a.to_str(cx), b.to_str(cx));\n     do indent {\n         do cx.commit {\n             mk_sub(cx, a_is_expected, span).regions(a, b)\n@@ -413,7 +413,7 @@ fn mk_subr(cx: infer_ctxt, a_is_expected: bool, span: span,\n \n fn mk_eqty(cx: infer_ctxt, a_is_expected: bool, span: span,\n            a: ty::t, b: ty::t) -> ures {\n-    debug!{\"mk_eqty(%s <: %s)\", a.to_str(cx), b.to_str(cx)};\n+    debug!(\"mk_eqty(%s <: %s)\", a.to_str(cx), b.to_str(cx));\n     do indent {\n         do cx.commit {\n             let suber = mk_sub(cx, a_is_expected, span);\n@@ -424,8 +424,8 @@ fn mk_eqty(cx: infer_ctxt, a_is_expected: bool, span: span,\n \n fn mk_assignty(cx: infer_ctxt, anmnt: &assignment,\n                a: ty::t, b: ty::t) -> ures {\n-    debug!{\"mk_assignty(%? / %s <: %s)\",\n-           anmnt, a.to_str(cx), b.to_str(cx)};\n+    debug!(\"mk_assignty(%? / %s <: %s)\",\n+           anmnt, a.to_str(cx), b.to_str(cx));\n     do indent {\n         do cx.commit {\n             cx.assign_tys(anmnt, a, b)\n@@ -435,8 +435,8 @@ fn mk_assignty(cx: infer_ctxt, anmnt: &assignment,\n \n fn can_mk_assignty(cx: infer_ctxt, anmnt: &assignment,\n                 a: ty::t, b: ty::t) -> ures {\n-    debug!{\"can_mk_assignty(%? / %s <: %s)\",\n-           anmnt, a.to_str(cx), b.to_str(cx)};\n+    debug!(\"can_mk_assignty(%? / %s <: %s)\",\n+           anmnt, a.to_str(cx), b.to_str(cx));\n \n     // FIXME(#2593)---this will not unroll any entries we make in the\n     // borrowings table.  But this is OK for the moment because this\n@@ -464,8 +464,8 @@ fn resolve_borrowings(cx: infer_ctxt) {\n     for cx.borrowings.each |item| {\n         match resolve_region(cx, item.scope, resolve_all|force_all) {\n           ok(region) => {\n-            debug!{\"borrowing for expr %d resolved to region %?, mutbl %?\",\n-                   item.expr_id, region, item.mutbl};\n+            debug!(\"borrowing for expr %d resolved to region %?, mutbl %?\",\n+                   item.expr_id, region, item.mutbl);\n             cx.tcx.borrowings.insert(\n                 item.expr_id, {region: region, mutbl: item.mutbl});\n           }\n@@ -474,7 +474,7 @@ fn resolve_borrowings(cx: infer_ctxt) {\n             let str = fixup_err_to_str(e);\n             cx.tcx.sess.span_err(\n                 item.span,\n-                fmt!{\"could not resolve lifetime for borrow: %s\", str});\n+                fmt!(\"could not resolve lifetime for borrow: %s\", str));\n           }\n         }\n     }\n@@ -573,7 +573,7 @@ impl infer_ctxt {\n     fn commit<T,E>(f: fn() -> result<T,E>) -> result<T,E> {\n         assert !self.in_snapshot();\n \n-        debug!{\"commit()\"};\n+        debug!(\"commit()\");\n         do indent {\n             let r <- self.try(f);\n \n@@ -589,7 +589,7 @@ impl infer_ctxt {\n \n     /// Execute `f`, unroll bindings on failure\n     fn try<T,E>(f: fn() -> result<T,E>) -> result<T,E> {\n-        debug!{\"try()\"};\n+        debug!(\"try()\");\n         do indent {\n             let snapshot = self.start_snapshot();\n             let r = f();\n@@ -603,7 +603,7 @@ impl infer_ctxt {\n \n     /// Execute `f` then unroll any bindings it creates\n     fn probe<T,E>(f: fn() -> result<T,E>) -> result<T,E> {\n-        debug!{\"probe()\"};\n+        debug!(\"probe()\");\n         do indent {\n             let snapshot = self.start_snapshot();\n             let r = self.try(f);"}, {"sha": "105c466d98b19c743e0a801518ad623518c2cbc3", "filename": "src/rustc/middle/typeck/infer/assignment.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fassignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fassignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fassignment.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -63,8 +63,8 @@ impl infer_ctxt {\n             }\n         }\n \n-        debug!{\"assign_tys(anmnt=%?, %s -> %s)\",\n-               anmnt, a.to_str(self), b.to_str(self)};\n+        debug!(\"assign_tys(anmnt=%?, %s -> %s)\",\n+               anmnt, a.to_str(self), b.to_str(self));\n         let _r = indenter();\n \n         match (ty::get(a).struct, ty::get(b).struct) {\n@@ -110,9 +110,9 @@ impl infer_ctxt {\n         a: ty::t, b: ty::t,\n         +a_bnd: option<ty::t>, +b_bnd: option<ty::t>) -> ures {\n \n-        debug!{\"assign_tys_or_sub(anmnt=%?, %s -> %s, %s -> %s)\",\n+        debug!(\"assign_tys_or_sub(anmnt=%?, %s -> %s, %s -> %s)\",\n                anmnt, a.to_str(self), b.to_str(self),\n-               a_bnd.to_str(self), b_bnd.to_str(self)};\n+               a_bnd.to_str(self), b_bnd.to_str(self));\n         let _r = indenter();\n \n         fn is_borrowable(v: ty::vstore) -> bool {\n@@ -167,9 +167,9 @@ impl infer_ctxt {\n                       m: ast::mutability,\n                       r_b: ty::region) -> ures {\n \n-        debug!{\"crosspollinate(anmnt=%?, a=%s, nr_b=%s, r_b=%s)\",\n+        debug!(\"crosspollinate(anmnt=%?, a=%s, nr_b=%s, r_b=%s)\",\n                anmnt, a.to_str(self), nr_b.to_str(self),\n-               r_b.to_str(self)};\n+               r_b.to_str(self));\n \n         do indent {\n             let sub = mk_sub(self, false, anmnt.span);\n@@ -179,12 +179,12 @@ impl infer_ctxt {\n                 let r_a = self.next_region_var(anmnt.span,\n                                                anmnt.borrow_lb);\n \n-                debug!{\"anmnt=%?\", anmnt};\n+                debug!(\"anmnt=%?\", anmnt);\n                 do sub.contraregions(r_a, r_b).chain |_r| {\n                     // if successful, add an entry indicating that\n                     // borrowing occurred\n-                    debug!{\"borrowing expression #%?, scope=%?, m=%?\",\n-                           anmnt, r_a, m};\n+                    debug!(\"borrowing expression #%?, scope=%?, m=%?\",\n+                           anmnt, r_a, m);\n                     self.borrowings.push({expr_id: anmnt.expr_id,\n                                           span: anmnt.span,\n                                           scope: r_a,"}, {"sha": "2c42e32417b912fbb70380a95c2eb20d83ea2c50", "filename": "src/rustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -99,9 +99,9 @@ fn eq_tys<C: combine>(self: &C, a: ty::t, b: ty::t) -> ures {\n }\n \n fn eq_regions<C: combine>(self: &C, a: ty::region, b: ty::region) -> ures {\n-    debug!{\"eq_regions(%s, %s)\",\n+    debug!(\"eq_regions(%s, %s)\",\n            a.to_str(self.infcx()),\n-           b.to_str(self.infcx())};\n+           b.to_str(self.infcx()));\n     let sub = self.sub();\n     do indent {\n         self.infcx().try(|| {\n@@ -140,10 +140,10 @@ fn eq_opt_regions<C:combine>(\n         // consistently have a region parameter or not have a\n         // region parameter.\n         self.infcx().tcx.sess.bug(\n-            fmt!{\"substitution a had opt_region %s and \\\n+            fmt!(\"substitution a had opt_region %s and \\\n                   b had opt_region %s\",\n                  a.to_str(self.infcx()),\n-                 b.to_str(self.infcx())});\n+                 b.to_str(self.infcx())));\n       }\n     }\n }\n@@ -346,10 +346,10 @@ fn super_tys<C:combine>(\n       (ty::ty_var(_), _) |\n       (_, ty::ty_var(_)) => {\n         tcx.sess.bug(\n-            fmt!{\"%s: bot and var types should have been handled (%s,%s)\",\n+            fmt!(\"%s: bot and var types should have been handled (%s,%s)\",\n                  self.tag(),\n                  a.to_str(self.infcx()),\n-                 b.to_str(self.infcx())});\n+                 b.to_str(self.infcx())));\n       }\n \n       // Relate integral variables to other types"}, {"sha": "f2c14b321c4f81d86621e0552d39bee6d7d3c955", "filename": "src/rustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -16,10 +16,10 @@ impl Glb: combine {\n     fn mts(a: ty::mt, b: ty::mt) -> cres<ty::mt> {\n         let tcx = self.infcx.tcx;\n \n-        debug!{\"%s.mts(%s, %s)\",\n+        debug!(\"%s.mts(%s, %s)\",\n                self.tag(),\n                mt_to_str(tcx, a),\n-               mt_to_str(tcx, b)};\n+               mt_to_str(tcx, b));\n \n         match (a.mutbl, b.mutbl) {\n           // If one side or both is mut, then the GLB must use\n@@ -110,10 +110,10 @@ impl Glb: combine {\n     }\n \n     fn regions(a: ty::region, b: ty::region) -> cres<ty::region> {\n-        debug!{\"%s.regions(%?, %?)\",\n+        debug!(\"%s.regions(%?, %?)\",\n                self.tag(),\n                a.to_str(self.infcx),\n-               b.to_str(self.infcx)};\n+               b.to_str(self.infcx));\n \n         do indent {\n             self.infcx.region_vars.glb_regions(self.span, a, b)"}, {"sha": "8cff0b2729dcca4d9d5a6644fe4cc692ccb788f7", "filename": "src/rustc/middle/typeck/infer/integral.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fintegral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fintegral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fintegral.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -37,7 +37,7 @@ fn intersection(a: int_ty_set, b: int_ty_set) -> int_ty_set {\n \n fn single_type_contained_in(tcx: ty::ctxt, a: int_ty_set) ->\n     option<ty::t> {\n-    debug!{\"single_type_contained_in(a=%s)\", uint::to_str(*a, 10u)};\n+    debug!(\"single_type_contained_in(a=%s)\", uint::to_str(*a, 10u));\n \n     if *a == INT_TY_SET_i8    { return some(ty::mk_i8(tcx)); }\n     if *a == INT_TY_SET_u8    { return some(ty::mk_u8(tcx)); }"}, {"sha": "851b08c0fe7d83b82a7f84d8dcb826070c30c3f6", "filename": "src/rustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -37,9 +37,9 @@ impl Glb: lattice_ops {\n fn lattice_tys<L:lattice_ops combine>(\n     self: &L, a: ty::t, b: ty::t) -> cres<ty::t> {\n \n-    debug!{\"%s.lattice_tys(%s, %s)\", self.tag(),\n+    debug!(\"%s.lattice_tys(%s, %s)\", self.tag(),\n            a.to_str(self.infcx()),\n-           b.to_str(self.infcx())};\n+           b.to_str(self.infcx()));\n     if a == b { return ok(a); }\n     do indent {\n         match (ty::get(a).struct, ty::get(b).struct) {\n@@ -84,10 +84,10 @@ fn lattice_vars<L:lattice_ops combine>(\n     let a_bounds = nde_a.possible_types;\n     let b_bounds = nde_b.possible_types;\n \n-    debug!{\"%s.lattice_vars(%s=%s <: %s=%s)\",\n+    debug!(\"%s.lattice_vars(%s=%s <: %s=%s)\",\n            self.tag(),\n            a_vid.to_str(), a_bounds.to_str(self.infcx()),\n-           b_vid.to_str(), b_bounds.to_str(self.infcx())};\n+           b_vid.to_str(), b_bounds.to_str(self.infcx()));\n \n     if a_vid == b_vid {\n         return ok(a_t);\n@@ -123,21 +123,21 @@ fn lattice_var_and_t<L:lattice_ops combine>(\n     // The comments in this function are written for LUB, but they\n     // apply equally well to GLB if you inverse upper/lower/sub/super/etc.\n \n-    debug!{\"%s.lattice_var_and_t(%s=%s <: %s)\",\n+    debug!(\"%s.lattice_var_and_t(%s=%s <: %s)\",\n            self.tag(),\n            a_id.to_str(), a_bounds.to_str(self.infcx()),\n-           b.to_str(self.infcx())};\n+           b.to_str(self.infcx()));\n \n     match self.bnd(a_bounds) {\n       some(a_bnd) => {\n         // If a has an upper bound, return the LUB(a.ub, b)\n-        debug!{\"bnd=some(%s)\", a_bnd.to_str(self.infcx())};\n+        debug!(\"bnd=some(%s)\", a_bnd.to_str(self.infcx()));\n         return c_ts(a_bnd, b);\n       }\n       none => {\n         // If a does not have an upper bound, make b the upper bound of a\n         // and then return b.\n-        debug!{\"bnd=none\"};\n+        debug!(\"bnd=none\");\n         let a_bounds = self.with_bnd(a_bounds, b);\n         do bnds(self, a_bounds.lb, a_bounds.ub).then {\n             self.infcx().set(vb, a_id, root(a_bounds, nde_a.rank));"}, {"sha": "fd9505737fc22bfea03ab8d231ec5b6fbc7b39f6", "filename": "src/rustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -19,10 +19,10 @@ impl Lub: combine {\n     fn mts(a: ty::mt, b: ty::mt) -> cres<ty::mt> {\n         let tcx = self.infcx.tcx;\n \n-        debug!{\"%s.mts(%s, %s)\",\n+        debug!(\"%s.mts(%s, %s)\",\n                self.tag(),\n                mt_to_str(tcx, a),\n-               mt_to_str(tcx, b)};\n+               mt_to_str(tcx, b));\n \n         let m = if a.mutbl == b.mutbl {\n             a.mutbl\n@@ -93,10 +93,10 @@ impl Lub: combine {\n     }\n \n     fn regions(a: ty::region, b: ty::region) -> cres<ty::region> {\n-        debug!{\"%s.regions(%?, %?)\",\n+        debug!(\"%s.regions(%?, %?)\",\n                self.tag(),\n                a.to_str(self.infcx),\n-               b.to_str(self.infcx)};\n+               b.to_str(self.infcx));\n \n         do indent {\n             self.infcx.region_vars.lub_regions(self.span, a, b)"}, {"sha": "d55a71fc237903be716a4967ae914629bf920ca7", "filename": "src/rustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -77,9 +77,9 @@ impl resolve_state {\n     fn resolve_type_chk(typ: ty::t) -> fres<ty::t> {\n         self.err = none;\n \n-        debug!{\"Resolving %s (modes=%x)\",\n+        debug!(\"Resolving %s (modes=%x)\",\n                ty_to_str(self.infcx.tcx, typ),\n-               self.modes};\n+               self.modes);\n \n         // n.b. This is a hokey mess because the current fold doesn't\n         // allow us to pass back errors in any useful way.\n@@ -89,9 +89,9 @@ impl resolve_state {\n         assert vec::is_empty(self.v_seen);\n         match self.err {\n           none => {\n-            debug!{\"Resolved to %s (modes=%x)\",\n+            debug!(\"Resolved to %s (modes=%x)\",\n                    ty_to_str(self.infcx.tcx, rty),\n-                   self.modes};\n+                   self.modes);\n             return ok(rty);\n           }\n           some(e) => return err(e)\n@@ -108,7 +108,7 @@ impl resolve_state {\n     }\n \n     fn resolve_type(typ: ty::t) -> ty::t {\n-        debug!{\"resolve_type(%s)\", typ.to_str(self.infcx)};\n+        debug!(\"resolve_type(%s)\", typ.to_str(self.infcx));\n         indent(fn&() -> ty::t {\n             if !ty::type_needs_infer(typ) { return typ; }\n \n@@ -137,7 +137,7 @@ impl resolve_state {\n     }\n \n     fn resolve_nested_tvar(typ: ty::t) -> ty::t {\n-        debug!{\"Resolve_if_deep(%s)\", typ.to_str(self.infcx)};\n+        debug!(\"Resolve_if_deep(%s)\", typ.to_str(self.infcx));\n         if !self.should(resolve_nested_tvar) {\n             typ\n         } else {\n@@ -146,7 +146,7 @@ impl resolve_state {\n     }\n \n     fn resolve_region(orig: ty::region) -> ty::region {\n-        debug!{\"Resolve_region(%s)\", orig.to_str(self.infcx)};\n+        debug!(\"Resolve_region(%s)\", orig.to_str(self.infcx));\n         match orig {\n           ty::re_var(rid) => self.resolve_region_var(rid),\n           _ => orig"}, {"sha": "edcc5e07b0de1249c495603625575be283b4c76b", "filename": "src/rustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -28,10 +28,10 @@ impl Sub: combine {\n     }\n \n     fn regions(a: ty::region, b: ty::region) -> cres<ty::region> {\n-        debug!{\"%s.regions(%s, %s)\",\n+        debug!(\"%s.regions(%s, %s)\",\n                self.tag(),\n                a.to_str(self.infcx),\n-               b.to_str(self.infcx)};\n+               b.to_str(self.infcx));\n         do indent {\n             match self.infcx.region_vars.make_subregion(self.span, a, b) {\n               ok(()) => ok(a),\n@@ -41,7 +41,7 @@ impl Sub: combine {\n     }\n \n     fn mts(a: ty::mt, b: ty::mt) -> cres<ty::mt> {\n-        debug!{\"mts(%s <: %s)\", a.to_str(self.infcx), b.to_str(self.infcx)};\n+        debug!(\"mts(%s <: %s)\", a.to_str(self.infcx), b.to_str(self.infcx));\n \n         if a.mutbl != b.mutbl && b.mutbl != m_const {\n             return err(ty::terr_mutability);\n@@ -97,8 +97,8 @@ impl Sub: combine {\n     }\n \n     fn tys(a: ty::t, b: ty::t) -> cres<ty::t> {\n-        debug!{\"%s.tys(%s, %s)\", self.tag(),\n-               a.to_str(self.infcx), b.to_str(self.infcx)};\n+        debug!(\"%s.tys(%s, %s)\", self.tag(),\n+               a.to_str(self.infcx), b.to_str(self.infcx));\n         if a == b { return ok(a); }\n         do indent {\n             match (ty::get(a).struct, ty::get(b).struct) {\n@@ -143,9 +143,9 @@ impl Sub: combine {\n                 // NDM--we should not be used dummy_sp() here, but\n                 // rather passing in the span or something like that.\n                 let rvar = self.infcx.next_region_var_nb(dummy_sp());\n-                debug!{\"Bound region %s maps to %s\",\n+                debug!(\"Bound region %s maps to %s\",\n                        bound_region_to_str(self.infcx.tcx, br),\n-                       region_to_str(self.infcx.tcx, rvar)};\n+                       region_to_str(self.infcx.tcx, rvar));\n                 rvar\n             }\n         };"}, {"sha": "9dfd8ae4535d8ac9e8a8ed74312b0726a934a810", "filename": "src/rustc/middle/typeck/infer/to_str.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -34,9 +34,9 @@ impl<V:copy to_str> bound<V>: to_str {\n \n impl<T:copy to_str> bounds<T>: to_str {\n     fn to_str(cx: infer_ctxt) -> ~str {\n-        fmt!{\"{%s <: %s}\",\n+        fmt!(\"{%s <: %s}\",\n              self.lb.to_str(cx),\n-             self.ub.to_str(cx)}\n+             self.ub.to_str(cx))\n     }\n }\n \n@@ -51,9 +51,9 @@ impl int_ty_set: to_str {\n impl<V:copy vid, T:copy to_str> var_value<V, T>: to_str {\n     fn to_str(cx: infer_ctxt) -> ~str {\n         match self {\n-          redirect(vid) => fmt!{\"redirect(%s)\", vid.to_str()},\n-          root(pt, rk) => fmt!{\"root(%s, %s)\", pt.to_str(cx),\n-                               uint::to_str(rk, 10u)}\n+          redirect(vid) => fmt!(\"redirect(%s)\", vid.to_str()),\n+          root(pt, rk) => fmt!(\"root(%s, %s)\", pt.to_str(cx),\n+                               uint::to_str(rk, 10u))\n         }\n     }\n }"}, {"sha": "d2de394202bb88733e8c3b685969ecb110daa71c", "filename": "src/rustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -25,7 +25,7 @@ impl infer_ctxt {\n         let vid_u = vid.to_uint();\n         match vb.vals.find(vid_u) {\n           none => {\n-            self.tcx.sess.bug(fmt!{\"failed lookup of vid `%u`\", vid_u});\n+            self.tcx.sess.bug(fmt!(\"failed lookup of vid `%u`\", vid_u));\n           }\n           some(var_val) => {\n             match var_val {\n@@ -53,8 +53,8 @@ impl infer_ctxt {\n         vec::push(vb.bindings, (vid, old_v));\n         vb.vals.insert(vid.to_uint(), new_v);\n \n-        debug!{\"Updating variable %s from %s to %s\",\n-               vid.to_str(), old_v.to_str(self), new_v.to_str(self)};\n+        debug!(\"Updating variable %s from %s to %s\",\n+               vid.to_str(), old_v.to_str(self), new_v.to_str(self));\n     }\n }\n \n@@ -87,15 +87,15 @@ fn merge_bnds<C: combine>(\n \n     let _r = indenter();\n     do merge_bnd(self, a.ub, b.ub, glb).chain |ub| {\n-        debug!{\"glb of ubs %s and %s is %s\",\n+        debug!(\"glb of ubs %s and %s is %s\",\n                a.ub.to_str(self.infcx()),\n                b.ub.to_str(self.infcx()),\n-               ub.to_str(self.infcx())};\n+               ub.to_str(self.infcx()));\n         do merge_bnd(self, a.lb, b.lb, lub).chain |lb| {\n-            debug!{\"lub of lbs %s and %s is %s\",\n+            debug!(\"lub of lbs %s and %s is %s\",\n                    a.lb.to_str(self.infcx()),\n                    b.lb.to_str(self.infcx()),\n-                   lb.to_str(self.infcx())};\n+                   lb.to_str(self.infcx()));\n             ok({lb: lb, ub: ub})\n         }\n     }\n@@ -134,10 +134,10 @@ fn set_var_to_merged_bounds<C: combine>(\n     //       A     \\ / A\n     //              B\n \n-    debug!{\"merge(%s,%s,%s)\",\n+    debug!(\"merge(%s,%s,%s)\",\n            v_id.to_str(),\n            a.to_str(self.infcx()),\n-           b.to_str(self.infcx())};\n+           b.to_str(self.infcx()));\n \n     // First, relate the lower/upper bounds of A and B.\n     // Note that these relations *must* hold for us to\n@@ -153,9 +153,9 @@ fn set_var_to_merged_bounds<C: combine>(\n                     do merge_bnd(self, a.lb, b.lb,\n                                  |x, y| self.lub().tys(x, y)).chain |lb| {\n                         let bounds = {lb: lb, ub: ub};\n-                        debug!{\"merge(%s): bounds=%s\",\n+                        debug!(\"merge(%s): bounds=%s\",\n                                v_id.to_str(),\n-                               bounds.to_str(self.infcx())};\n+                               bounds.to_str(self.infcx()));\n \n                         // the new bounds must themselves\n                         // be relatable:\n@@ -186,9 +186,9 @@ fn var_sub_var<C: combine>(self: &C,\n     let a_bounds = nde_a.possible_types;\n     let b_bounds = nde_b.possible_types;\n \n-    debug!{\"vars(%s=%s <: %s=%s)\",\n+    debug!(\"vars(%s=%s <: %s=%s)\",\n            a_id.to_str(), a_bounds.to_str(self.infcx()),\n-           b_id.to_str(), b_bounds.to_str(self.infcx())};\n+           b_id.to_str(), b_bounds.to_str(self.infcx()));\n \n     if a_id == b_id { return uok(); }\n \n@@ -214,20 +214,20 @@ fn var_sub_var<C: combine>(self: &C,\n     // Make the node with greater rank the parent of the node with\n     // smaller rank.\n     if nde_a.rank > nde_b.rank {\n-        debug!{\"vars(): a has smaller rank\"};\n+        debug!(\"vars(): a has smaller rank\");\n         // a has greater rank, so a should become b's parent,\n         // i.e., b should redirect to a.\n         self.infcx().set(vb, b_id, redirect(a_id));\n         set_var_to_merged_bounds(\n             self, a_id, a_bounds, b_bounds, nde_a.rank)\n     } else if nde_a.rank < nde_b.rank {\n-        debug!{\"vars(): b has smaller rank\"};\n+        debug!(\"vars(): b has smaller rank\");\n         // b has greater rank, so a should redirect to b.\n         self.infcx().set(vb, a_id, redirect(b_id));\n         set_var_to_merged_bounds(\n             self, b_id, a_bounds, b_bounds, nde_b.rank)\n     } else {\n-        debug!{\"vars(): a and b have equal rank\"};\n+        debug!(\"vars(): a and b have equal rank\");\n         assert nde_a.rank == nde_b.rank;\n         // If equal, just redirect one to the other and increment\n         // the other's rank.  We choose arbitrarily to redirect b\n@@ -247,10 +247,10 @@ fn var_sub_t<C: combine>(self: &C, a_id: ty::tv_vid, b: ty::t) -> ures {\n     let a_id = nde_a.root;\n     let a_bounds = nde_a.possible_types;\n \n-    debug!{\"var_sub_t(%s=%s <: %s)\",\n+    debug!(\"var_sub_t(%s=%s <: %s)\",\n            a_id.to_str(),\n            a_bounds.to_str(self.infcx()),\n-           b.to_str(self.infcx())};\n+           b.to_str(self.infcx()));\n     let b_bounds = {lb: none, ub: some(b)};\n     set_var_to_merged_bounds(self, a_id, a_bounds, b_bounds, nde_a.rank)\n }\n@@ -264,17 +264,17 @@ fn t_sub_var<C: combine>(self: &C, a: ty::t, b_id: ty::tv_vid) -> ures {\n     let b_id = nde_b.root;\n     let b_bounds = nde_b.possible_types;\n \n-    debug!{\"t_sub_var(%s <: %s=%s)\",\n+    debug!(\"t_sub_var(%s <: %s=%s)\",\n            a.to_str(self.infcx()),\n            b_id.to_str(),\n-           b_bounds.to_str(self.infcx())};\n+           b_bounds.to_str(self.infcx()));\n     set_var_to_merged_bounds(self, b_id, a_bounds, b_bounds, nde_b.rank)\n }\n \n fn bnds<C: combine>(\n     self: &C, a: bound<ty::t>, b: bound<ty::t>) -> ures {\n \n-    debug!{\"bnds(%s <: %s)\", a.to_str(self.infcx()), b.to_str(self.infcx())};\n+    debug!(\"bnds(%s <: %s)\", a.to_str(self.infcx()), b.to_str(self.infcx()));\n     do indent {\n         match (a, b) {\n           (none, none) |\n@@ -316,18 +316,18 @@ impl infer_ctxt {\n \n         // Rank optimization\n         if nde_a.rank > nde_b.rank {\n-            debug!{\"vars_integral(): a has smaller rank\"};\n+            debug!(\"vars_integral(): a has smaller rank\");\n             // a has greater rank, so a should become b's parent,\n             // i.e., b should redirect to a.\n             self.set(vb, a_id, root(intersection, nde_a.rank));\n             self.set(vb, b_id, redirect(a_id));\n         } else if nde_a.rank < nde_b.rank {\n-            debug!{\"vars_integral(): b has smaller rank\"};\n+            debug!(\"vars_integral(): b has smaller rank\");\n             // b has greater rank, so a should redirect to b.\n             self.set(vb, b_id, root(intersection, nde_b.rank));\n             self.set(vb, a_id, redirect(b_id));\n         } else {\n-            debug!{\"vars_integral(): a and b have equal rank\"};\n+            debug!(\"vars_integral(): a and b have equal rank\");\n             assert nde_a.rank == nde_b.rank;\n             // If equal, just redirect one to the other and increment\n             // the other's rank.  We choose arbitrarily to redirect b"}, {"sha": "856a0907b43cb16fcec01b1e733b00818ed956f6", "filename": "src/rustc/util/common.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fcommon.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -8,20 +8,20 @@ import syntax::print;\n fn indent<R>(op: fn() -> R) -> R {\n     // Use in conjunction with the log post-processor like `src/etc/indenter`\n     // to make debug output more readable.\n-    debug!{\">>\"};\n+    debug!(\">>\");\n     let r <- op();\n-    debug!{\"<< (Result = %?)\", r};\n+    debug!(\"<< (Result = %?)\", r);\n     return r;\n }\n \n struct _indenter {\n     let _i: ();\n     new(_i: ()) { self._i = (); }\n-    drop { debug!{\"<<\"}; }\n+    drop { debug!(\"<<\"); }\n }\n \n fn indenter() -> _indenter {\n-    debug!{\">>\"};\n+    debug!(\">>\");\n     _indenter(())\n }\n "}, {"sha": "1634d38577e377ae3cde96cfb1b85aba234c87d2", "filename": "src/rustc/util/ppaux.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fppaux.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -100,7 +100,7 @@ fn explain_region_and_span(cx: ctxt, region: ty::region)\n         -> (~str, option<span>)\n     {\n         let lo = codemap::lookup_char_pos_adj(cx.sess.codemap, span.lo);\n-        (fmt!{\"the %s at %u:%u\", heading, lo.line, lo.col}, some(span))\n+        (fmt!(\"the %s at %u:%u\", heading, lo.line, lo.col), some(span))\n     }\n }\n \n@@ -118,7 +118,7 @@ fn bound_region_to_str(cx: ctxt, br: bound_region) -> ~str {\n       // does not fail\n       br_cap_avoid(id, br) => {\n         if cx.sess.ppregions() {\n-            fmt!{\"br_cap_avoid(%?, %s)\", id, bound_region_to_str(cx, *br)}\n+            fmt!(\"br_cap_avoid(%?, %s)\", id, bound_region_to_str(cx, *br))\n         } else {\n             bound_region_to_str(cx, *br)\n         }\n@@ -129,40 +129,40 @@ fn bound_region_to_str(cx: ctxt, br: bound_region) -> ~str {\n fn re_scope_id_to_str(cx: ctxt, node_id: ast::node_id) -> ~str {\n     match cx.items.find(node_id) {\n       some(ast_map::node_block(blk)) => {\n-        fmt!{\"<block at %s>\",\n-             codemap::span_to_str(blk.span, cx.sess.codemap)}\n+        fmt!(\"<block at %s>\",\n+             codemap::span_to_str(blk.span, cx.sess.codemap))\n       }\n       some(ast_map::node_expr(expr)) => {\n         match expr.node {\n           ast::expr_call(*) => {\n-            fmt!{\"<call at %s>\",\n-                 codemap::span_to_str(expr.span, cx.sess.codemap)}\n+            fmt!(\"<call at %s>\",\n+                 codemap::span_to_str(expr.span, cx.sess.codemap))\n           }\n           ast::expr_match(*) => {\n-            fmt!{\"<alt at %s>\",\n-                 codemap::span_to_str(expr.span, cx.sess.codemap)}\n+            fmt!(\"<alt at %s>\",\n+                 codemap::span_to_str(expr.span, cx.sess.codemap))\n           }\n           ast::expr_assign_op(*) |\n           ast::expr_field(*) |\n           ast::expr_unary(*) |\n           ast::expr_binary(*) |\n           ast::expr_index(*) => {\n-            fmt!{\"<method at %s>\",\n-                 codemap::span_to_str(expr.span, cx.sess.codemap)}\n+            fmt!(\"<method at %s>\",\n+                 codemap::span_to_str(expr.span, cx.sess.codemap))\n           }\n           _ => {\n-            fmt!{\"<expression at %s>\",\n-                 codemap::span_to_str(expr.span, cx.sess.codemap)}\n+            fmt!(\"<expression at %s>\",\n+                 codemap::span_to_str(expr.span, cx.sess.codemap))\n           }\n         }\n       }\n       none => {\n-        fmt!{\"<unknown-%d>\", node_id}\n+        fmt!(\"<unknown-%d>\", node_id)\n       }\n       _ => { cx.sess.bug(\n-          fmt!{\"re_scope refers to %s\",\n+          fmt!(\"re_scope refers to %s\",\n                ast_map::node_id_to_str(cx.items, node_id,\n-                                       cx.sess.parse_sess.interner)}) }\n+                                       cx.sess.parse_sess.interner))) }\n     }\n }\n \n@@ -198,7 +198,7 @@ fn mt_to_str(cx: ctxt, m: mt) -> ~str {\n \n fn vstore_to_str(cx: ctxt, vs: ty::vstore) -> ~str {\n     match vs {\n-      ty::vstore_fixed(n) => fmt!{\"%u\", n},\n+      ty::vstore_fixed(n) => fmt!(\"%u\", n),\n       ty::vstore_uniq => ~\"~\",\n       ty::vstore_box => ~\"@\",\n       ty::vstore_slice(r) => region_to_str(cx, r)\n@@ -208,9 +208,9 @@ fn vstore_to_str(cx: ctxt, vs: ty::vstore) -> ~str {\n fn vstore_ty_to_str(cx: ctxt, ty: ~str, vs: ty::vstore) -> ~str {\n     match vs {\n       ty::vstore_fixed(_) => {\n-        fmt!{\"%s/%s\", ty, vstore_to_str(cx, vs)}\n+        fmt!(\"%s/%s\", ty, vstore_to_str(cx, vs))\n       }\n-      _ => fmt!{\"%s%s\", vstore_to_str(cx, vs), ty}\n+      _ => fmt!(\"%s%s\", vstore_to_str(cx, vs), ty)\n     }\n }\n \n@@ -347,7 +347,7 @@ fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n         vstore_ty_to_str(cx, result, vs)\n       }\n       ty_evec(mt, vs) => {\n-        vstore_ty_to_str(cx, fmt!{\"[%s]\", mt_to_str(cx, mt)}, vs)\n+        vstore_ty_to_str(cx, fmt!(\"[%s]\", mt_to_str(cx, mt)), vs)\n       }\n       ty_estr(vs) => vstore_ty_to_str(cx, ~\"str\", vs),\n       ty_opaque_box => ~\"@?\",\n@@ -365,15 +365,15 @@ fn parameterized(cx: ctxt,\n     let r_str = match self_r {\n       none => ~\"\",\n       some(r) => {\n-        fmt!{\"/%s\", region_to_str(cx, r)}\n+        fmt!(\"/%s\", region_to_str(cx, r))\n       }\n     };\n \n     if vec::len(tps) > 0u {\n         let strs = vec::map(tps, |t| ty_to_str(cx, t) );\n-        fmt!{\"%s%s<%s>\", base, r_str, str::connect(strs, ~\",\")}\n+        fmt!(\"%s%s<%s>\", base, r_str, str::connect(strs, ~\",\"))\n     } else {\n-        fmt!{\"%s%s\", base, r_str}\n+        fmt!(\"%s%s\", base, r_str)\n     }\n }\n "}, {"sha": "947c7905c409e82eb8ca91d356d92155dd34c8b6", "filename": "src/rustdoc/attr_parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustdoc%2Fattr_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustdoc%2Fattr_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fattr_parser.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -51,7 +51,7 @@ fn doc_meta(\n \n     if vec::is_not_empty(doc_metas) {\n         if vec::len(doc_metas) != 1u {\n-            warn!{\"ignoring %u doc attributes\", vec::len(doc_metas) - 1u};\n+            warn!(\"ignoring %u doc attributes\", vec::len(doc_metas) - 1u);\n         }\n         some(doc_metas[0])\n     } else {"}, {"sha": "96f418247afb76740b44bfd886f9450642b13191", "filename": "src/rustdoc/config.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fconfig.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -62,7 +62,7 @@ fn usage() {\n     println(~\"Usage: rustdoc ~[options] <cratefile>\\n\");\n     println(~\"Options:\\n\");\n     for opts().each |opt| {\n-        println(fmt!{\"    %s\", opt.second()});\n+        println(fmt!(\"    %s\", opt.second()));\n     }\n     println(~\"\");\n }\n@@ -179,15 +179,15 @@ fn parse_output_format(output_format: ~str) -> result<output_format, ~str> {\n     match output_format {\n       ~\"markdown\" => result::ok(markdown),\n       ~\"html\" => result::ok(pandoc_html),\n-      _ => result::err(fmt!{\"unknown output format '%s'\", output_format})\n+      _ => result::err(fmt!(\"unknown output format '%s'\", output_format))\n     }\n }\n \n fn parse_output_style(output_style: ~str) -> result<output_style, ~str> {\n     match output_style {\n       ~\"doc-per-crate\" => result::ok(doc_per_crate),\n       ~\"doc-per-mod\" => result::ok(doc_per_mod),\n-      _ => result::err(fmt!{\"unknown output style '%s'\", output_style})\n+      _ => result::err(fmt!(\"unknown output style '%s'\", output_style))\n     }\n }\n \n@@ -214,7 +214,7 @@ fn maybe_find_pandoc(\n \n     let pandoc = do vec::find(possible_pandocs) |pandoc| {\n         let output = program_output(pandoc, ~[~\"--version\"]);\n-        debug!{\"testing pandoc cmd %s: %?\", pandoc, output};\n+        debug!(\"testing pandoc cmd %s: %?\", pandoc, output);\n         output.status == 0\n     };\n "}, {"sha": "6ed6dc4abab506c193a3baddfb55435af10d7ea3", "filename": "src/rustdoc/markdown_pass.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_pass.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -124,7 +124,7 @@ fn should_request_new_writer_for_each_page() {\n }\n \n fn write_title(ctxt: ctxt, page: doc::page) {\n-    ctxt.w.write_line(fmt!{\"%% %s\", make_title(page)});\n+    ctxt.w.write_line(fmt!(\"%% %s\", make_title(page)));\n     ctxt.w.write_line(~\"\");\n }\n \n@@ -176,7 +176,7 @@ fn write_header(ctxt: ctxt, lvl: hlvl, doc: doc::itemtag) {\n \n fn write_header_(ctxt: ctxt, lvl: hlvl, title: ~str) {\n     let hashes = str::from_chars(vec::from_elem(lvl as uint, '#'));\n-    ctxt.w.write_line(fmt!{\"%s %s\", hashes, title});\n+    ctxt.w.write_line(fmt!(\"%s %s\", hashes, title));\n     ctxt.w.write_line(~\"\");\n }\n \n@@ -234,7 +234,7 @@ fn header_name(doc: doc::itemtag) -> ~str {\n             }\n             trait_part += trait_type;\n         }\n-        fmt!{\"%s%s for %s\", doc.name(), trait_part, self_ty}\n+        fmt!(\"%s%s for %s\", doc.name(), trait_part, self_ty)\n       }\n       _ => {\n         doc.name()\n@@ -247,12 +247,12 @@ fn header_text(doc: doc::itemtag) -> ~str {\n       doc::impltag(impldoc) => {\n         let header_kind = header_kind(doc);\n         let desc = if impldoc.trait_types.is_empty() {\n-            fmt!{\"for `%s`\", impldoc.self_ty.get()}\n+            fmt!(\"for `%s`\", impldoc.self_ty.get())\n         } else {\n-            fmt!{\"of `%s` for `%s`\", impldoc.trait_types[0],\n-                 impldoc.self_ty.get()}\n+            fmt!(\"of `%s` for `%s`\", impldoc.trait_types[0],\n+                 impldoc.self_ty.get())\n         };\n-        fmt!{\"%s %s\", header_kind, desc}\n+        fmt!(\"%s %s\", header_kind, desc)\n       }\n       _ => {\n         header_text_(header_kind(doc), header_name(doc))\n@@ -261,7 +261,7 @@ fn header_text(doc: doc::itemtag) -> ~str {\n }\n \n fn header_text_(kind: ~str, name: ~str) -> ~str {\n-    fmt!{\"%s `%s`\", kind, name}\n+    fmt!(\"%s `%s`\", kind, name)\n }\n \n fn write_crate(\n@@ -400,10 +400,10 @@ fn write_index(ctxt: ctxt, index: doc::index) {\n         let header = header_text_(entry.kind, entry.name);\n         let id = entry.link;\n         if option::is_some(entry.brief) {\n-            ctxt.w.write_line(fmt!{\"* [%s](%s) - %s\",\n-                                   header, id, option::get(entry.brief)});\n+            ctxt.w.write_line(fmt!(\"* [%s](%s) - %s\",\n+                                   header, id, option::get(entry.brief)));\n         } else {\n-            ctxt.w.write_line(fmt!{\"* [%s](%s)\", header, id});\n+            ctxt.w.write_line(fmt!(\"* [%s](%s)\", header, id));\n         }\n     }\n     ctxt.w.write_line(~\"\");\n@@ -507,7 +507,7 @@ fn write_sig(ctxt: ctxt, sig: option<~str>) {\n \n fn code_block_indent(s: ~str) -> ~str {\n     let lines = str::lines_any(s);\n-    let indented = vec::map(lines, |line| fmt!{\"    %s\", line} );\n+    let indented = vec::map(lines, |line| fmt!(\"    %s\", line) );\n     str::connect(indented, ~\"\\n\")\n }\n \n@@ -619,10 +619,10 @@ fn write_variant(ctxt: ctxt, doc: doc::variantdoc) {\n     let sig = option::get(doc.sig);\n     match doc.desc {\n       some(desc) => {\n-        ctxt.w.write_line(fmt!{\"* `%s` - %s\", sig, desc});\n+        ctxt.w.write_line(fmt!(\"* `%s` - %s\", sig, desc));\n       }\n       none => {\n-        ctxt.w.write_line(fmt!{\"* `%s`\", sig});\n+        ctxt.w.write_line(fmt!(\"* `%s`\", sig));\n       }\n     }\n }\n@@ -776,7 +776,7 @@ mod test {\n     fn render(source: ~str) -> ~str {\n         let (srv, doc) = create_doc_srv(source);\n         let markdown = write_markdown_str_srv(srv, doc);\n-        debug!{\"markdown: %s\", markdown};\n+        debug!(\"markdown: %s\", markdown);\n         markdown\n     }\n \n@@ -789,23 +789,23 @@ mod test {\n             };\n \n             let doc = extract::from_srv(srv, ~\"\");\n-            debug!{\"doc (extract): %?\", doc};\n+            debug!(\"doc (extract): %?\", doc);\n             let doc = tystr_pass::mk_pass().f(srv, doc);\n-            debug!{\"doc (tystr): %?\", doc};\n+            debug!(\"doc (tystr): %?\", doc);\n             let doc = path_pass::mk_pass().f(srv, doc);\n-            debug!{\"doc (path): %?\", doc};\n+            debug!(\"doc (path): %?\", doc);\n             let doc = attr_pass::mk_pass().f(srv, doc);\n-            debug!{\"doc (attr): %?\", doc};\n+            debug!(\"doc (attr): %?\", doc);\n             let doc = desc_to_brief_pass::mk_pass().f(srv, doc);\n-            debug!{\"doc (desc_to_brief): %?\", doc};\n+            debug!(\"doc (desc_to_brief): %?\", doc);\n             let doc = unindent_pass::mk_pass().f(srv, doc);\n-            debug!{\"doc (unindent): %?\", doc};\n+            debug!(\"doc (unindent): %?\", doc);\n             let doc = sectionalize_pass::mk_pass().f(srv, doc);\n-            debug!{\"doc (trim): %?\", doc};\n+            debug!(\"doc (trim): %?\", doc);\n             let doc = trim_pass::mk_pass().f(srv, doc);\n-            debug!{\"doc (sectionalize): %?\", doc};\n+            debug!(\"doc (sectionalize): %?\", doc);\n             let doc = markdown_index_pass::mk_pass(config).f(srv, doc);\n-            debug!{\"doc (index): %?\", doc};\n+            debug!(\"doc (index): %?\", doc);\n             (srv, doc)\n         }\n     }"}, {"sha": "74932ca579d44ae86ba03fc23f42a0482a7c47a3", "filename": "src/rustdoc/markdown_writer.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustdoc%2Fmarkdown_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustdoc%2Fmarkdown_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_writer.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -90,8 +90,8 @@ fn pandoc_writer(\n     do generic_writer |markdown| {\n         import io::WriterUtil;\n \n-        debug!{\"pandoc cmd: %s\", pandoc_cmd};\n-        debug!{\"pandoc args: %s\", str::connect(pandoc_args, ~\" \")};\n+        debug!(\"pandoc cmd: %s\", pandoc_cmd);\n+        debug!(\"pandoc args: %s\", str::connect(pandoc_args, ~\" \"));\n \n         let pipe_in = os::pipe();\n         let pipe_out = os::pipe();\n@@ -123,10 +123,10 @@ fn pandoc_writer(\n         let stderr = comm::recv(stderr_po);\n \n         let status = run::waitpid(pid);\n-        debug!{\"pandoc result: %i\", status};\n+        debug!(\"pandoc result: %i\", status);\n         if status != 0 {\n-            error!{\"pandoc-out: %s\", stdout};\n-            error!{\"pandoc-err: %s\", stderr};\n+            error!(\"pandoc-out: %s\", stdout);\n+            error!(\"pandoc-err: %s\", stderr);\n             fail ~\"pandoc failed\";\n         }\n     }"}, {"sha": "751e94e8649be6e57cf1e69c124c10358d02fe13", "filename": "src/rustdoc/rustdoc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustdoc%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustdoc%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Frustdoc.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -33,7 +33,7 @@ fn run_passes(\n \n     let mut passno = 0;\n     do vec::foldl(doc, passes) |doc, pass| {\n-        log(debug, fmt!{\"pass #%d\", passno});\n+        log(debug, fmt!(\"pass #%d\", passno));\n         passno += 1;\n         log(debug, doc);\n         do time(pass.name) {\n@@ -110,7 +110,7 @@ fn main(args: ~[~str]) {\n     let config = match config::parse_config(args) {\n       result::ok(config) => config,\n       result::err(err) => {\n-        io::println(fmt!{\"error: %s\", err});\n+        io::println(fmt!(\"error: %s\", err));\n         return;\n       }\n     };\n@@ -122,7 +122,7 @@ fn time<T>(what: ~str, f: fn() -> T) -> T {\n     let start = std::time::precise_time_s();\n     let rv = f();\n     let end = std::time::precise_time_s();\n-    info!{\"time: %3.3f s    %s\", end - start, what};\n+    info!(\"time: %3.3f s    %s\", end - start, what);\n     return rv;\n }\n "}, {"sha": "8c25c83d2ad7cd41f8b92460d2fa4e5336f66555", "filename": "src/rustdoc/tystr_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Frustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftystr_pass.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -296,12 +296,12 @@ fn fold_type(\n                 ident: ident,\n                 node: ast::item_ty(ty, params), _\n               }, _) => {\n-                some(fmt!{\n+                some(fmt!(\n                     \"type %s%s = %s\",\n                     to_str(ident),\n                     pprust::typarams_to_str(params, extract::interner()),\n                     pprust::ty_to_str(ty, extract::interner())\n-                })\n+                ))\n               }\n               _ => fail ~\"expected type\"\n             }"}, {"sha": "95ca81bf97fd6737e9ffb4315186f3c8cba2bc1b", "filename": "src/test/auxiliary/cci_class_4.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fauxiliary%2Fcci_class_4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fauxiliary%2Fcci_class_4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class_4.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -4,7 +4,7 @@ struct cat {\n   priv {\n     let mut meows : uint;\n     fn meow() {\n-      error!{\"Meow\"};\n+      error!(\"Meow\");\n       self.meows += 1u;\n       if self.meows % 5u == 0u {\n           self.how_hungry += 1;\n@@ -22,12 +22,12 @@ struct cat {\n \n   fn eat() -> bool {\n     if self.how_hungry > 0 {\n-        error!{\"OM NOM NOM\"};\n+        error!(\"OM NOM NOM\");\n         self.how_hungry -= 2;\n         return true;\n     }\n     else {\n-        error!{\"Not hungry!\"};\n+        error!(\"Not hungry!\");\n         return false;\n     }\n   }"}, {"sha": "3a914a703e1eda182762438252c26974a9af87ce", "filename": "src/test/auxiliary/cci_class_cast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -7,7 +7,7 @@ struct cat : ToStr {\n   priv {\n     let mut meows : uint;\n     fn meow() {\n-      error!{\"Meow\"};\n+      error!(\"Meow\");\n       self.meows += 1u;\n       if self.meows % 5u == 0u {\n           self.how_hungry += 1;\n@@ -25,12 +25,12 @@ struct cat : ToStr {\n \n   fn eat() -> bool {\n     if self.how_hungry > 0 {\n-        error!{\"OM NOM NOM\"};\n+        error!(\"OM NOM NOM\");\n         self.how_hungry -= 2;\n         return true;\n     }\n     else {\n-        error!{\"Not hungry!\"};\n+        error!(\"Not hungry!\");\n         return false;\n     }\n   }"}, {"sha": "f42d65c2436a60559569dcf7818e94d951296312", "filename": "src/test/auxiliary/extern-crosscrate-source.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fauxiliary%2Fextern-crosscrate-source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fauxiliary%2Fextern-crosscrate-source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fextern-crosscrate-source.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -9,7 +9,7 @@ extern mod rustrt {\n }\n \n fn fact(n: uint) -> uint {\n-    debug!{\"n = %?\", n};\n+    debug!(\"n = %?\", n);\n     rustrt::rust_dbg_call(cb, n)\n }\n "}, {"sha": "ae6c2fb571a4e0a0c2b10389ebbd18f6479b4aef", "filename": "src/test/auxiliary/issue_2242_b.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fauxiliary%2Fissue_2242_b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fauxiliary%2Fissue_2242_b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_2242_b.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -5,5 +5,5 @@ use a;\n import a::to_strz;\n \n impl int: to_strz {\n-    fn to_strz() -> ~str { fmt!{\"%?\", self} }\n+    fn to_strz() -> ~str { fmt!(\"%?\", self) }\n }"}, {"sha": "cd057a09e76197de41becb1d88c19617c757ad01", "filename": "src/test/auxiliary/issue_2242_c.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fauxiliary%2Fissue_2242_c.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fauxiliary%2Fissue_2242_c.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_2242_c.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -6,5 +6,5 @@ use a;\n import a::to_strz;\n \n impl bool: to_strz {\n-    fn to_strz() -> ~str { fmt!{\"%b\", self} }\n+    fn to_strz() -> ~str { fmt!(\"%b\", self) }\n }"}, {"sha": "8c89df79811eb1accd4493c0ee1cf1c86a2fad80", "filename": "src/test/auxiliary/test_comm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fauxiliary%2Ftest_comm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fauxiliary%2Ftest_comm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Ftest_comm.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -30,10 +30,10 @@ fn port<T: send>() -> port<T> {\n struct port_ptr<T:send> {\n    let po: *rust_port;\n    new(po: *rust_port) {\n-    debug!{\"in the port_ptr constructor\"};\n+    debug!(\"in the port_ptr constructor\");\n     self.po = po; }\n    drop unsafe {\n-    debug!{\"in the port_ptr destructor\"};\n+    debug!(\"in the port_ptr destructor\");\n        do task::unkillable {\n         let yield = 0u;\n         let yieldp = ptr::addr_of(yield);"}, {"sha": "b912b2cb12d34563d835d2326cf0d88629342402", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -17,12 +17,12 @@ fn main(argv: ~[~str]) {\n \n     let tests = vec::view(argv, 1, argv.len());\n \n-    bench!{shift_push};\n-    bench!{read_line};\n-    bench!{str_set};\n-    bench!{vec_plus};\n-    bench!{vec_append};\n-    bench!{vec_push_all};\n+    bench!(shift_push);\n+    bench!(read_line);\n+    bench!(str_set);\n+    bench!(vec_plus);\n+    bench!(vec_append);\n+    bench!(vec_push_all);\n }\n \n fn maybe_run_test(argv: &[~str], name: ~str, test: fn()) {\n@@ -39,7 +39,7 @@ fn maybe_run_test(argv: &[~str], name: ~str, test: fn()) {\n     test();\n     let stop = precise_time_s();\n \n-    io::println(fmt!{\"%s:\\t\\t%f ms\", name, (stop - start) * 1000f});\n+    io::println(fmt!(\"%s:\\t\\t%f ms\", name, (stop - start) * 1000f));\n }\n \n fn shift_push() {\n@@ -53,7 +53,7 @@ fn shift_push() {\n \n fn read_line() {\n     let path = path::connect(\n-        env!{\"CFG_SRC_DIR\"},\n+        env!(\"CFG_SRC_DIR\"),\n         ~\"src/test/bench/shootout-k-nucleotide.data\"\n     );\n "}, {"sha": "a9641acf45d8e48a3d5f4a39061ce70cab419433", "filename": "src/test/bench/core-vec-append.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fbench%2Fcore-vec-append.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fbench%2Fcore-vec-append.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-vec-append.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -48,18 +48,18 @@ fn main(args: ~[~str]) {\n     let rawf = raw as float;\n     let dvecf = dvec as float;\n     \n-    io::stdout().write_str(fmt!{\"Raw     : %? seconds\\n\", raw});\n-    io::stdout().write_str(fmt!{\"        : %f op/sec\\n\", maxf/rawf});\n-    io::stdout().write_str(fmt!{\"\\n\"});\n-    io::stdout().write_str(fmt!{\"Dvec    : %? seconds\\n\", dvec});\n-    io::stdout().write_str(fmt!{\"        : %f op/sec\\n\", maxf/dvecf});\n-    io::stdout().write_str(fmt!{\"\\n\"});\n+    io::stdout().write_str(fmt!(\"Raw     : %? seconds\\n\", raw));\n+    io::stdout().write_str(fmt!(\"        : %f op/sec\\n\", maxf/rawf));\n+    io::stdout().write_str(fmt!(\"\\n\"));\n+    io::stdout().write_str(fmt!(\"Dvec    : %? seconds\\n\", dvec));\n+    io::stdout().write_str(fmt!(\"        : %f op/sec\\n\", maxf/dvecf));\n+    io::stdout().write_str(fmt!(\"\\n\"));\n     \n     if dvec < raw {\n-        io::stdout().write_str(fmt!{\"Dvec is %f%% faster than raw\\n\",\n-                                    (rawf - dvecf) / rawf * 100.0});\n+        io::stdout().write_str(fmt!(\"Dvec is %f%% faster than raw\\n\",\n+                                    (rawf - dvecf) / rawf * 100.0));\n     } else {\n-        io::stdout().write_str(fmt!{\"Raw is %f%% faster than dvec\\n\",\n-                                    (dvecf - rawf) / dvecf * 100.0});\n+        io::stdout().write_str(fmt!(\"Raw is %f%% faster than dvec\\n\",\n+                                    (dvecf - rawf) / dvecf * 100.0));\n     }\n }"}, {"sha": "78a3dd5ed967f962c63d1133dd2ab6242d398b79", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -167,7 +167,7 @@ fn bfs2(graph: graph, key: node_id) -> bfs_result {\n     let mut i = 0u;\n     while vec::any(colors, is_gray) {\n         // Do the BFS.\n-        log(info, fmt!{\"PBFS iteration %?\", i});\n+        log(info, fmt!(\"PBFS iteration %?\", i));\n         i += 1u;\n         colors = do colors.mapi() |i, c| {\n             let c : color = c;\n@@ -237,7 +237,7 @@ fn pbfs(&&graph: arc::arc<graph>, key: node_id) -> bfs_result {\n     let mut i = 0u;\n     while par::any(colors, is_gray) {\n         // Do the BFS.\n-        log(info, fmt!{\"PBFS iteration %?\", i});\n+        log(info, fmt!(\"PBFS iteration %?\", i));\n         i += 1u;\n         let old_len = colors.len();\n \n@@ -397,8 +397,8 @@ fn main(args: ~[~str]) {\n     let edges = make_edges(scale, 16u);\n     let stop = time::precise_time_s();\n \n-    io::stdout().write_line(fmt!{\"Generated %? edges in %? seconds.\",\n-                                 vec::len(edges), stop - start});\n+    io::stdout().write_line(fmt!(\"Generated %? edges in %? seconds.\",\n+                                 vec::len(edges), stop - start));\n \n     let start = time::precise_time_s();\n     let graph = make_graph(1u << scale, edges);\n@@ -407,9 +407,9 @@ fn main(args: ~[~str]) {\n     let mut total_edges = 0u;\n     vec::each(graph, |edges| { total_edges += edges.len(); true });\n \n-    io::stdout().write_line(fmt!{\"Generated graph with %? edges in %? seconds.\",\n+    io::stdout().write_line(fmt!(\"Generated graph with %? edges in %? seconds.\",\n                                  total_edges / 2u,\n-                                 stop - start});\n+                                 stop - start));\n \n     let mut total_seq = 0.0;\n     let mut total_par = 0.0;\n@@ -418,7 +418,7 @@ fn main(args: ~[~str]) {\n \n     do gen_search_keys(graph, num_keys).map() |root| {\n         io::stdout().write_line(~\"\");\n-        io::stdout().write_line(fmt!{\"Search key: %?\", root});\n+        io::stdout().write_line(fmt!(\"Search key: %?\", root));\n \n         if do_sequential {\n             let start = time::precise_time_s();\n@@ -428,17 +428,17 @@ fn main(args: ~[~str]) {\n             //total_seq += stop - start;\n \n             io::stdout().write_line(\n-                fmt!{\"Sequential BFS completed in %? seconds.\",\n-                     stop - start});\n+                fmt!(\"Sequential BFS completed in %? seconds.\",\n+                     stop - start));\n             \n             if do_validate {\n                 let start = time::precise_time_s();\n                 assert(validate(edges, root, bfs_tree));\n                 let stop = time::precise_time_s();\n                 \n                 io::stdout().write_line(\n-                    fmt!{\"Validation completed in %? seconds.\",\n-                         stop - start});\n+                    fmt!(\"Validation completed in %? seconds.\",\n+                         stop - start));\n             }\n             \n             let start = time::precise_time_s();\n@@ -448,17 +448,17 @@ fn main(args: ~[~str]) {\n             total_seq += stop - start;\n             \n             io::stdout().write_line(\n-                fmt!{\"Alternate Sequential BFS completed in %? seconds.\",\n-                     stop - start});\n+                fmt!(\"Alternate Sequential BFS completed in %? seconds.\",\n+                     stop - start));\n             \n             if do_validate {\n                 let start = time::precise_time_s();\n                 assert(validate(edges, root, bfs_tree));\n                 let stop = time::precise_time_s();\n                 \n                 io::stdout().write_line(\n-                    fmt!{\"Validation completed in %? seconds.\",\n-                         stop - start});\n+                    fmt!(\"Validation completed in %? seconds.\",\n+                         stop - start));\n             }\n         }\n         \n@@ -468,21 +468,21 @@ fn main(args: ~[~str]) {\n \n         total_par += stop - start;\n \n-        io::stdout().write_line(fmt!{\"Parallel BFS completed in %? seconds.\",\n-                                     stop - start});\n+        io::stdout().write_line(fmt!(\"Parallel BFS completed in %? seconds.\",\n+                                     stop - start));\n \n         if do_validate {\n             let start = time::precise_time_s();\n             assert(validate(edges, root, bfs_tree));\n             let stop = time::precise_time_s();\n             \n-            io::stdout().write_line(fmt!{\"Validation completed in %? seconds.\",\n-                                         stop - start});\n+            io::stdout().write_line(fmt!(\"Validation completed in %? seconds.\",\n+                                         stop - start));\n         }\n     };\n \n     io::stdout().write_line(~\"\");\n     io::stdout().write_line(\n-        fmt!{\"Total sequential: %? \\t Total Parallel: %? \\t Speedup: %?x\",\n-             total_seq, total_par, total_seq / total_par});\n+        fmt!(\"Total sequential: %? \\t Total Parallel: %? \\t Speedup: %?x\",\n+             total_seq, total_par, total_seq / total_par));\n }"}, {"sha": "0f16bec626e3a1204d7bee9a9fa4366bec6576fb", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -33,15 +33,15 @@ fn server(requests: port<request>, responses: pipes::chan<uint>) {\n         match requests.try_recv() {\n           some(get_count) => { responses.send(copy count); }\n           some(bytes(b)) => {\n-            //error!{\"server: received %? bytes\", b};\n+            //error!(\"server: received %? bytes\", b);\n             count += b;\n           }\n           none => { done = true; }\n           _ => { }\n         }\n     }\n     responses.send(count);\n-    //error!{\"server exiting\"};\n+    //error!(\"server exiting\");\n }\n \n fn run(args: &[~str]) {\n@@ -61,27 +61,27 @@ fn run(args: &[~str]) {\n             vec::push(worker_results, r);\n         }).spawn {\n             for uint::range(0u, size / workers) |_i| {\n-                //error!{\"worker %?: sending %? bytes\", i, num_bytes};\n+                //error!(\"worker %?: sending %? bytes\", i, num_bytes);\n                 to_child.send(bytes(num_bytes));\n             }\n-            //error!{\"worker %? exiting\", i};\n+            //error!(\"worker %? exiting\", i);\n         };\n     }\n     do task::spawn {\n         server(from_parent, to_parent);\n     }\n \n     vec::iter(worker_results, |r| { future::get(&r); } );\n-    //error!{\"sending stop message\"};\n+    //error!(\"sending stop message\");\n     to_child.send(stop);\n-    move_out!{to_child};\n+    move_out!(to_child);\n     let result = from_child.recv();\n     let end = std::time::precise_time_s();\n     let elapsed = end - start;\n-    io::stdout().write_str(fmt!{\"Count is %?\\n\", result});\n-    io::stdout().write_str(fmt!{\"Test took %? seconds\\n\", elapsed});\n+    io::stdout().write_str(fmt!(\"Count is %?\\n\", result));\n+    io::stdout().write_str(fmt!(\"Test took %? seconds\\n\", elapsed));\n     let thruput = ((size / workers * workers) as float) / (elapsed as float);\n-    io::stdout().write_str(fmt!{\"Throughput=%f per sec\\n\", thruput});\n+    io::stdout().write_str(fmt!(\"Throughput=%f per sec\\n\", thruput));\n     assert result == num_bytes * size;\n }\n \n@@ -94,6 +94,6 @@ fn main(args: ~[~str]) {\n         copy args\n     };        \n \n-    debug!{\"%?\", args};\n+    debug!(\"%?\", args);\n     run(args);\n }"}, {"sha": "7b2930387f4cce0e38b82e3c26d459fd27753532", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -29,15 +29,15 @@ fn server(requests: PortSet<request>, responses: pipes::chan<uint>) {\n         match requests.try_recv() {\n           some(get_count) => { responses.send(copy count); }\n           some(bytes(b)) => {\n-            //error!{\"server: received %? bytes\", b};\n+            //error!(\"server: received %? bytes\", b);\n             count += b;\n           }\n           none => { done = true; }\n           _ => { }\n         }\n     }\n     responses.send(count);\n-    //error!{\"server exiting\"};\n+    //error!(\"server exiting\");\n }\n \n fn run(args: &[~str]) {\n@@ -58,27 +58,27 @@ fn run(args: &[~str]) {\n             vec::push(worker_results, r);\n         }).spawn {\n             for uint::range(0u, size / workers) |_i| {\n-                //error!{\"worker %?: sending %? bytes\", i, num_bytes};\n+                //error!(\"worker %?: sending %? bytes\", i, num_bytes);\n                 to_child.send(bytes(num_bytes));\n             }\n-            //error!{\"worker %? exiting\", i};\n+            //error!(\"worker %? exiting\", i);\n         };\n     }\n     do task::spawn {\n         server(from_parent, to_parent);\n     }\n \n     vec::iter(worker_results, |r| { future::get(&r); } );\n-    //error!{\"sending stop message\"};\n+    //error!(\"sending stop message\");\n     to_child.send(stop);\n-    move_out!{to_child};\n+    move_out!(to_child);\n     let result = from_child.recv();\n     let end = std::time::precise_time_s();\n     let elapsed = end - start;\n-    io::stdout().write_str(fmt!{\"Count is %?\\n\", result});\n-    io::stdout().write_str(fmt!{\"Test took %? seconds\\n\", elapsed});\n+    io::stdout().write_str(fmt!(\"Count is %?\\n\", result));\n+    io::stdout().write_str(fmt!(\"Test took %? seconds\\n\", elapsed));\n     let thruput = ((size / workers * workers) as float) / (elapsed as float);\n-    io::stdout().write_str(fmt!{\"Throughput=%f per sec\\n\", thruput});\n+    io::stdout().write_str(fmt!(\"Throughput=%f per sec\\n\", thruput));\n     assert result == num_bytes * size;\n }\n \n@@ -91,6 +91,6 @@ fn main(args: ~[~str]) {\n         copy args\n     };        \n \n-    debug!{\"%?\", args};\n+    debug!(\"%?\", args);\n     run(args);\n }"}, {"sha": "644bb12f0185251fd06fd72ac8293a7a464f4769", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -45,7 +45,7 @@ fn thread_ring(i: uint,\n     let mut num_port <- some(num_port);\n     // Send/Receive lots of messages.\n     for uint::range(0u, count) |j| {\n-        //error!{\"task %?, iter %?\", i, j};\n+        //error!(\"task %?, iter %?\", i, j);\n         let mut num_chan2 = option::swap_unwrap(&mut num_chan);\n         let mut num_port2 = option::swap_unwrap(&mut num_port);\n         send(&num_chan2, i * j);\n@@ -77,7 +77,7 @@ fn main(args: ~[~str]) {\n     let mut futures = ~[];\n \n     for uint::range(1u, num_tasks) |i| {\n-        //error!{\"spawning %?\", i};\n+        //error!(\"spawning %?\", i);\n         let (new_chan, num_port) = init();\n         let num_chan2 = ~mut none;\n         *num_chan2 <-> num_chan;\n@@ -107,8 +107,8 @@ fn main(args: ~[~str]) {\n     let elapsed = (stop - start);\n     let rate = (num_msgs as float) / elapsed;\n \n-    io::println(fmt!{\"Sent %? messages in %? seconds\",\n-                     num_msgs, elapsed});\n-    io::println(fmt!{\"  %? messages / second\", rate});\n-    io::println(fmt!{\"  %? \u03bcs / message\", 1000000. / rate});\n+    io::println(fmt!(\"Sent %? messages in %? seconds\",\n+                     num_msgs, elapsed));\n+    io::println(fmt!(\"  %? messages / second\", rate));\n+    io::println(fmt!(\"  %? \u03bcs / message\", 1000000. / rate));\n }"}, {"sha": "96f65b3462edf2dafa1df32e98696c79c8d703f0", "filename": "src/test/bench/msgsend-ring-pipes.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -36,7 +36,7 @@ fn thread_ring(i: uint,\n     let mut num_port <- some(num_port);\n     // Send/Receive lots of messages.\n     for uint::range(0u, count) |j| {\n-        //error!{\"task %?, iter %?\", i, j};\n+        //error!(\"task %?, iter %?\", i, j);\n         let mut num_chan2 = none;\n         let mut num_port2 = none;\n         num_chan2 <-> num_chan;\n@@ -46,7 +46,7 @@ fn thread_ring(i: uint,\n         match recv(port) {\n           ring::num(_n, p) => {\n             //log(error, _n);\n-            num_port = some(move_out!{p});\n+            num_port = some(move_out!(p));\n           }\n         }\n     };\n@@ -73,7 +73,7 @@ fn main(args: ~[~str]) {\n     let mut futures = ~[];\n \n     for uint::range(1u, num_tasks) |i| {\n-        //error!{\"spawning %?\", i};\n+        //error!(\"spawning %?\", i);\n         let (new_chan, num_port) = ring::init();\n         let num_chan2 = ~mut none;\n         *num_chan2 <-> num_chan;\n@@ -103,8 +103,8 @@ fn main(args: ~[~str]) {\n     let elapsed = (stop - start);\n     let rate = (num_msgs as float) / elapsed;\n \n-    io::println(fmt!{\"Sent %? messages in %? seconds\",\n-                     num_msgs, elapsed});\n-    io::println(fmt!{\"  %? messages / second\", rate});\n-    io::println(fmt!{\"  %? \u03bcs / message\", 1000000. / rate});\n+    io::println(fmt!(\"Sent %? messages in %? seconds\",\n+                     num_msgs, elapsed));\n+    io::println(fmt!(\"  %? messages / second\", rate));\n+    io::println(fmt!(\"  %? \u03bcs / message\", 1000000. / rate));\n }"}, {"sha": "619340370147a201059762b650cfb2a065838781", "filename": "src/test/bench/msgsend-ring-rw-arcs.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -46,7 +46,7 @@ fn thread_ring(i: uint,\n     let mut num_port <- some(num_port);\n     // Send/Receive lots of messages.\n     for uint::range(0u, count) |j| {\n-        //error!{\"task %?, iter %?\", i, j};\n+        //error!(\"task %?, iter %?\", i, j);\n         let mut num_chan2 = option::swap_unwrap(&mut num_chan);\n         let mut num_port2 = option::swap_unwrap(&mut num_port);\n         send(&num_chan2, i * j);\n@@ -78,7 +78,7 @@ fn main(args: ~[~str]) {\n     let mut futures = ~[];\n \n     for uint::range(1u, num_tasks) |i| {\n-        //error!{\"spawning %?\", i};\n+        //error!(\"spawning %?\", i);\n         let (new_chan, num_port) = init();\n         let num_chan2 = ~mut none;\n         *num_chan2 <-> num_chan;\n@@ -108,8 +108,8 @@ fn main(args: ~[~str]) {\n     let elapsed = (stop - start);\n     let rate = (num_msgs as float) / elapsed;\n \n-    io::println(fmt!{\"Sent %? messages in %? seconds\",\n-                     num_msgs, elapsed});\n-    io::println(fmt!{\"  %? messages / second\", rate});\n-    io::println(fmt!{\"  %? \u03bcs / message\", 1000000. / rate});\n+    io::println(fmt!(\"Sent %? messages in %? seconds\",\n+                     num_msgs, elapsed));\n+    io::println(fmt!(\"  %? messages / second\", rate));\n+    io::println(fmt!(\"  %? \u03bcs / message\", 1000000. / rate));\n }"}, {"sha": "d3fdc472b66ae359b83b259deb4d77ea90805b48", "filename": "src/test/bench/msgsend-ring.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fbench%2Fmsgsend-ring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fbench%2Fmsgsend-ring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -67,8 +67,8 @@ fn main(args: ~[~str]) {\n     let elapsed = (stop - start);\n     let rate = (num_msgs as float) / elapsed;\n \n-    io::println(fmt!{\"Sent %? messages in %? seconds\",\n-                     num_msgs, elapsed});\n-    io::println(fmt!{\"  %? messages / second\", rate});\n-    io::println(fmt!{\"  %? \u03bcs / message\", 1000000. / rate});\n+    io::println(fmt!(\"Sent %? messages in %? seconds\",\n+                     num_msgs, elapsed));\n+    io::println(fmt!(\"  %? messages / second\", rate));\n+    io::println(fmt!(\"  %? \u03bcs / message\", 1000000. / rate));\n }"}, {"sha": "d7c8e8436cd62456c2fefa52429958c34b536b2b", "filename": "src/test/bench/msgsend.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fbench%2Fmsgsend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fbench%2Fmsgsend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -49,10 +49,10 @@ fn run(args: ~[~str]) {\n     let result = comm::recv(from_child);\n     let end = std::time::precise_time_s();\n     let elapsed = end - start;\n-    io::stdout().write_str(fmt!{\"Count is %?\\n\", result});\n-    io::stdout().write_str(fmt!{\"Test took %? seconds\\n\", elapsed});\n+    io::stdout().write_str(fmt!(\"Count is %?\\n\", result));\n+    io::stdout().write_str(fmt!(\"Test took %? seconds\\n\", elapsed));\n     let thruput = ((size / workers * workers) as float) / (elapsed as float);\n-    io::stdout().write_str(fmt!{\"Throughput=%f per sec\\n\", thruput});\n+    io::stdout().write_str(fmt!(\"Throughput=%f per sec\\n\", thruput));\n }\n \n fn main(args: ~[~str]) {\n@@ -64,7 +64,7 @@ fn main(args: ~[~str]) {\n         args\n     };\n \n-    debug!{\"%?\", args};\n+    debug!(\"%?\", args);\n     run(args);\n }\n "}, {"sha": "3cc474df3425e9dafd26f8efa8fc27dc720fd1e8", "filename": "src/test/bench/pingpong.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fbench%2Fpingpong.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fbench%2Fpingpong.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fpingpong.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -11,7 +11,7 @@ proto! pingpong {\n     ping: send {\n         ping -> pong\n     }\n-    \n+\n     pong: recv {\n         pong -> ping\n     }\n@@ -21,7 +21,7 @@ proto! pingpong_unbounded {\n     ping: send {\n         ping -> pong\n     }\n-    \n+\n     pong: recv {\n         pong -> ping\n     }\n@@ -37,7 +37,7 @@ macro_rules! move_it {\n }\n \n macro_rules! follow {\n-    { \n+    {\n         $($message:path($($x: ident),+) -> $next:ident $e:expr)+\n     } => (\n         |m| match move m {\n@@ -50,7 +50,7 @@ macro_rules! follow {\n         }\n     );\n \n-    { \n+    {\n         $($message:path -> $next:ident $e:expr)+\n     } => (\n         |m| match move m {\n@@ -78,9 +78,9 @@ fn bounded(count: uint) {\n         let mut count = count;\n         let mut ch = ch;\n         while count > 0 {\n-            ch = switch(ch, follow! {\n+            ch = switch(ch, follow! (\n                 ping -> next { server::pong(next) }\n-            });\n+            ));\n \n             count -= 1;\n         }\n@@ -90,9 +90,9 @@ fn bounded(count: uint) {\n     while count > 0 {\n         let ch_ = client::ping(ch);\n \n-        ch = switch(ch_, follow! {\n+        ch = switch(ch_, follow! (\n             pong -> next { next }\n-        });\n+        ));\n \n         count -= 1;\n     }\n@@ -105,9 +105,9 @@ fn unbounded(count: uint) {\n         let mut count = count;\n         let mut ch = ch;\n         while count > 0 {\n-            ch = switch(ch, follow! {\n+            ch = switch(ch, follow! (\n                 ping -> next { server::pong(next) }\n-            });\n+            ));\n \n             count -= 1;\n         }\n@@ -117,9 +117,9 @@ fn unbounded(count: uint) {\n     while count > 0 {\n         let ch_ = client::ping(ch);\n \n-        ch = switch(ch_, follow! {\n+        ch = switch(ch_, follow! (\n             pong -> next { next }\n-        });\n+        ));\n \n         count -= 1;\n     }\n@@ -141,13 +141,13 @@ fn main() {\n     let bounded = do timeit { bounded(count) };\n     let unbounded = do timeit { unbounded(count) };\n \n-    io::println(fmt!{\"count: %?\\n\", count});\n-    io::println(fmt!{\"bounded:   %? s\\t(%? \u03bcs/message)\",\n-                     bounded, bounded * 1000000. / (count as float)});\n-    io::println(fmt!{\"unbounded: %? s\\t(%? \u03bcs/message)\",\n-                     unbounded, unbounded * 1000000. / (count as float)});\n+    io::println(fmt!(\"count: %?\\n\", count));\n+    io::println(fmt!(\"bounded:   %? s\\t(%? \u03bcs/message)\",\n+                     bounded, bounded * 1000000. / (count as float)));\n+    io::println(fmt!(\"unbounded: %? s\\t(%? \u03bcs/message)\",\n+                     unbounded, unbounded * 1000000. / (count as float)));\n \n-    io::println(fmt!{\"\\n\\\n+    io::println(fmt!(\"\\n\\\n                       bounded is %?%% faster\",\n-                     (unbounded - bounded) / bounded * 100.});\n+                     (unbounded - bounded) / bounded * 100.));\n }"}, {"sha": "f3a558984ea8e63d41360fccfd9fd3e3b2d780f4", "filename": "src/test/bench/shootout-ackermann.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fbench%2Fshootout-ackermann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fbench%2Fshootout-ackermann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-ackermann.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -21,5 +21,5 @@ fn main(args: ~[~str]) {\n         args\n     };\n     let n = int::from_str(args[1]).get();\n-    io::println(fmt!{\"Ack(3,%d): %d\\n\", n, ack(3, n)});\n+    io::println(fmt!(\"Ack(3,%d): %d\\n\", n, ack(3, n)));\n }"}, {"sha": "37a5d215a7c3a48d9b61a40686eaeb5d86031708", "filename": "src/test/bench/shootout-binarytrees.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -47,9 +47,9 @@ fn main(args: ~[~str]) {\n     let stretch_depth = max_depth + 1;\n     let stretch_tree = bottom_up_tree(&stretch_arena, 0, stretch_depth);\n \n-    io::println(fmt!{\"stretch tree of depth %d\\t check: %d\",\n+    io::println(fmt!(\"stretch tree of depth %d\\t check: %d\",\n                           stretch_depth,\n-                          item_check(stretch_tree)});\n+                          item_check(stretch_tree)));\n \n     let long_lived_arena = arena::arena();\n     let long_lived_tree = bottom_up_tree(&long_lived_arena, 0, max_depth);\n@@ -65,12 +65,12 @@ fn main(args: ~[~str]) {\n             chk += item_check(temp_tree);\n             i += 1;\n         }\n-        io::println(fmt!{\"%d\\t trees of depth %d\\t check: %d\",\n+        io::println(fmt!(\"%d\\t trees of depth %d\\t check: %d\",\n                          iterations * 2, depth,\n-                         chk});\n+                         chk));\n         depth += 2;\n     }\n-    io::println(fmt!{\"long lived trees of depth %d\\t check: %d\",\n+    io::println(fmt!(\"long lived trees of depth %d\\t check: %d\",\n                      max_depth,\n-                          item_check(long_lived_tree)});\n+                          item_check(long_lived_tree)));\n }"}, {"sha": "bde2c79e21885c659518398476452ce4187191ad", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -111,7 +111,7 @@ fn creature(\n             }\n             option::none => {\n                 // log creatures met and evil clones of self\n-                let report = fmt!{\"%u\", creatures_met} + ~\" \" +\n+                let report = fmt!(\"%u\", creatures_met) + ~\" \" +\n                              show_number(evil_clones_met);\n                 comm::send(to_rendezvous_log, report);\n                 break;"}, {"sha": "330397ddc925c5f555082563ed1f4e471a32434d", "filename": "src/test/bench/shootout-fannkuchredux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fbench%2Fshootout-fannkuchredux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fbench%2Fshootout-fannkuchredux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuchredux.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -43,7 +43,7 @@ fn fannkuch(n: int) -> int {\n         let mut go = true;\n         while go {\n             if r == n {\n-                io::println(fmt!{\"%d\", checksum});\n+                io::println(fmt!(\"%d\", checksum));\n                 return flips;\n             }\n             let p0 = perm1[0];\n@@ -68,5 +68,5 @@ fn main(args: ~[~str]) {\n     };\n \n     let n = int::from_str(args[1]).get();\n-    io::println(fmt!{\"Pfannkuchen(%d) = %d\", n, fannkuch(n)});\n+    io::println(fmt!(\"Pfannkuchen(%d) = %d\", n, fannkuch(n)));\n }"}, {"sha": "1bf7c1e47828dc88a24feff22a90357899edc53f", "filename": "src/test/bench/shootout-fibo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fbench%2Fshootout-fibo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fbench%2Fshootout-fibo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fibo.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -17,5 +17,5 @@ fn main(args: ~[~str]) {\n         args\n     };\n     let n = int::from_str(args[1]).get();\n-    io::println(fmt!{\"%d\\n\", fib(n)});\n+    io::println(fmt!(\"%d\\n\", fib(n)));\n }"}, {"sha": "e9054195ee49da2ef295997177ba4c4a7bda7627", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -48,7 +48,7 @@ fn sort_and_fmt(mm: hashmap<~[u8], uint>, total: uint) -> ~str {\n \n    pairs_sorted.each(fn&(kv: (~[u8], float)) -> bool unsafe {\n       let (k,v) = kv;\n-      buffer += (fmt!{\"%s %0.3f\\n\", str::to_upper(str::unsafe::from_bytes(k)), v});\n+      buffer += (fmt!(\"%s %0.3f\\n\", str::to_upper(str::unsafe::from_bytes(k)), v));\n       return true;\n    });\n \n@@ -111,15 +111,15 @@ fn make_sequence_processor(sz: uint, from_parent: pipes::port<~[u8]>,\n    let buffer = match sz { \n        1u => { sort_and_fmt(freqs, total) }\n        2u => { sort_and_fmt(freqs, total) }\n-       3u => { fmt!{\"%u\\t%s\", find(freqs, ~\"GGT\"), ~\"GGT\"} }\n-       4u => { fmt!{\"%u\\t%s\", find(freqs, ~\"GGTA\"), ~\"GGTA\"} }\n-       6u => { fmt!{\"%u\\t%s\", find(freqs, ~\"GGTATT\"), ~\"GGTATT\"} }\n-      12u => { fmt!{\"%u\\t%s\", find(freqs, ~\"GGTATTTTAATT\"), ~\"GGTATTTTAATT\"} }\n-      18u => { fmt!{\"%u\\t%s\", find(freqs, ~\"GGTATTTTAATTTATAGT\"), ~\"GGTATTTTAATTTATAGT\"} }\n+       3u => { fmt!(\"%u\\t%s\", find(freqs, ~\"GGT\"), ~\"GGT\") }\n+       4u => { fmt!(\"%u\\t%s\", find(freqs, ~\"GGTA\"), ~\"GGTA\") }\n+       6u => { fmt!(\"%u\\t%s\", find(freqs, ~\"GGTATT\"), ~\"GGTATT\") }\n+      12u => { fmt!(\"%u\\t%s\", find(freqs, ~\"GGTATTTTAATT\"), ~\"GGTATTTTAATT\") }\n+      18u => { fmt!(\"%u\\t%s\", find(freqs, ~\"GGTATTTTAATTTATAGT\"), ~\"GGTATTTTAATTTATAGT\") }\n         _ => { ~\"\" }\n    };\n \n-   //comm::send(to_parent, fmt!{\"yay{%u}\", sz});\n+   //comm::send(to_parent, fmt!(\"yay{%u}\", sz));\n     to_parent.send(buffer);\n }\n \n@@ -129,7 +129,7 @@ fn main(args: ~[~str]) {\n        // FIXME: Using this compile-time env variable is a crummy way to\n        // get to this massive data set, but #include_bin chokes on it (#2598)\n        let path = path::connect(\n-           env!{\"CFG_SRC_DIR\"},\n+           env!(\"CFG_SRC_DIR\"),\n            ~\"src/test/bench/shootout-k-nucleotide.data\"\n            );\n        result::get(io::file_reader(path))"}, {"sha": "08b17f0dfb3f405e064f968fa1c3d8e0476c4aa9", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -46,7 +46,7 @@ fn sort_and_fmt(mm: hashmap<~[u8], uint>, total: uint) -> ~str {\n \n    pairs_sorted.each(fn&(kv: (~[u8], float)) -> bool unsafe {\n       let (k,v) = kv;\n-      buffer += (fmt!{\"%s %0.3f\\n\", str::to_upper(str::unsafe::from_bytes(k)), v});\n+      buffer += (fmt!(\"%s %0.3f\\n\", str::to_upper(str::unsafe::from_bytes(k)), v));\n       return true;\n    });\n \n@@ -109,15 +109,15 @@ fn make_sequence_processor(sz: uint, from_parent: comm::Port<~[u8]>,\n    let buffer = match sz { \n        1u => { sort_and_fmt(freqs, total) }\n        2u => { sort_and_fmt(freqs, total) }\n-       3u => { fmt!{\"%u\\t%s\", find(freqs, ~\"GGT\"), ~\"GGT\"} }\n-       4u => { fmt!{\"%u\\t%s\", find(freqs, ~\"GGTA\"), ~\"GGTA\"} }\n-       6u => { fmt!{\"%u\\t%s\", find(freqs, ~\"GGTATT\"), ~\"GGTATT\"} }\n-      12u => { fmt!{\"%u\\t%s\", find(freqs, ~\"GGTATTTTAATT\"), ~\"GGTATTTTAATT\"} }\n-      18u => { fmt!{\"%u\\t%s\", find(freqs, ~\"GGTATTTTAATTTATAGT\"), ~\"GGTATTTTAATTTATAGT\"} }\n+       3u => { fmt!(\"%u\\t%s\", find(freqs, ~\"GGT\"), ~\"GGT\") }\n+       4u => { fmt!(\"%u\\t%s\", find(freqs, ~\"GGTA\"), ~\"GGTA\") }\n+       6u => { fmt!(\"%u\\t%s\", find(freqs, ~\"GGTATT\"), ~\"GGTATT\") }\n+      12u => { fmt!(\"%u\\t%s\", find(freqs, ~\"GGTATTTTAATT\"), ~\"GGTATTTTAATT\") }\n+      18u => { fmt!(\"%u\\t%s\", find(freqs, ~\"GGTATTTTAATTTATAGT\"), ~\"GGTATTTTAATTTATAGT\") }\n         _ => { ~\"\" }\n    };\n \n-   //comm::send(to_parent, fmt!{\"yay{%u}\", sz});\n+   //comm::send(to_parent, fmt!(\"yay{%u}\", sz));\n    comm::send(to_parent, buffer);\n }\n \n@@ -127,7 +127,7 @@ fn main(args: ~[~str]) {\n        // FIXME: Using this compile-time env variable is a crummy way to\n        // get to this massive data set, but #include_bin chokes on it (#2598)\n        let path = path::connect(\n-           env!{\"CFG_SRC_DIR\"},\n+           env!(\"CFG_SRC_DIR\"),\n            ~\"src/test/bench/shootout-k-nucleotide.data\"\n            );\n        result::get(io::file_reader(path))"}, {"sha": "1f380d79269b73b95f62d327bf3c3ce0fedc53ba", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -117,20 +117,20 @@ fn writer(path: ~str, writech: comm::Chan<comm::Chan<line>>, size: uint)\n         }\n     };\n     cout.write_line(~\"P4\");\n-    cout.write_line(fmt!{\"%u %u\", size, size});\n+    cout.write_line(fmt!(\"%u %u\", size, size));\n     let lines = std::map::uint_hash();\n     let mut done = 0_u;\n     let mut i = 0_u;\n     while i < size {\n         let aline = comm::recv(p);\n         if aline.i == done {\n-            debug!{\"W %u\", aline.i};\n+            debug!(\"W %u\", aline.i);\n             cout.write(aline.b);\n             done += 1_u;\n             let mut prev = done;\n             while prev <= i {\n                 if lines.contains_key(prev) {\n-                    debug!{\"WS %u\", prev};\n+                    debug!(\"WS %u\", prev);\n                     // FIXME (#2280): this temporary shouldn't be\n                     // necessary, but seems to be, for borrowing.\n                     let v : ~[u8] = lines.get(prev);\n@@ -145,7 +145,7 @@ fn writer(path: ~str, writech: comm::Chan<comm::Chan<line>>, size: uint)\n             };\n         }\n         else {\n-            debug!{\"S %u\", aline.i};\n+            debug!(\"S %u\", aline.i);\n             lines.insert(aline.i, aline.b);\n         };\n         i += 1_u;\n@@ -177,7 +177,7 @@ fn main(args: ~[~str]) {\n     for uint::range(0_u, size) |j| {\n         task::spawn(|| chanmb(j, size, ch) );\n         if j % yieldevery == 0_u {\n-            debug!{\"Y %u\", j};\n+            debug!(\"Y %u\", j);\n             task::yield();\n         };\n     };"}, {"sha": "ef1e6509ee9469bcbab5fc89f4d0cd09674e01fd", "filename": "src/test/bench/shootout-nbody.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-nbody.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -23,10 +23,10 @@ fn main(args: ~[~str]) {\n     };\n     let n = int::from_str(args[1]).get();\n     let bodies: ~[Body::props] = NBodySystem::make();\n-    io::println(fmt!{\"%f\", NBodySystem::energy(bodies)});\n+    io::println(fmt!(\"%f\", NBodySystem::energy(bodies)));\n     let mut i = 0;\n     while i < n { NBodySystem::advance(bodies, 0.01); i += 1; }\n-    io::println(fmt!{\"%f\", NBodySystem::energy(bodies)});\n+    io::println(fmt!(\"%f\", NBodySystem::energy(bodies)));\n }\n \n mod NBodySystem {"}, {"sha": "588f6bf8ce24ec5e9aed41bdf549da95cd15df6c", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -63,7 +63,7 @@ fn stress_task(&&id: int) {\n         let n = 15;\n         assert (fib(n) == fib(n));\n         i += 1;\n-        error!{\"%d: Completed %d iterations\", id, i};\n+        error!(\"%d: Completed %d iterations\", id, i);\n     }\n }\n \n@@ -108,8 +108,8 @@ fn main(args: ~[~str]) {\n \n                 let elapsed = stop - start;\n \n-                out.write_line(fmt!{\"%d\\t%d\\t%s\", n, fibn,\n-                                    u64::str(elapsed)});\n+                out.write_line(fmt!(\"%d\\t%d\\t%s\", n, fibn,\n+                                    u64::str(elapsed)));\n             }\n         }\n     }"}, {"sha": "95f2b257400fc9e066439b23f9575514b399f8fb", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -69,5 +69,5 @@ fn main(args: ~[~str]) {\n         i += 1u;\n     }\n \n-    io::println(fmt!{\"%0.9f\\n\", float::sqrt(vBv / vv)});\n+    io::println(fmt!(\"%0.9f\\n\", float::sqrt(vBv / vv)));\n }"}, {"sha": "91b2c6e5dc8bb85458632ca49e3e359fa438125d", "filename": "src/test/bench/shootout-threadring.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-threadring.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -23,11 +23,11 @@ fn roundtrip(id: int, p: comm::Port<int>, ch: comm::Chan<int>) {\n     while (true) {\n         match comm::recv(p) {\n           1 => {\n-            io::println(fmt!{\"%d\\n\", id});\n+            io::println(fmt!(\"%d\\n\", id));\n             return;\n           }\n           token => {\n-            debug!{\"%d %d\", id, token};\n+            debug!(\"%d %d\", id, token);\n             comm::send(ch, token - 1);\n             if token <= n_threads {\n                 return;"}, {"sha": "7f9a55ab1674a8d431e89844b644171500c5a43c", "filename": "src/test/bench/std-smallintmap.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fstd-smallintmap.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -45,8 +45,8 @@ fn main(args: ~[~str]) {\n \n     let maxf = max as float;\n \n-    io::stdout().write_str(fmt!{\"insert(): %? seconds\\n\", checkf});\n-    io::stdout().write_str(fmt!{\"        : %f op/sec\\n\", maxf/checkf});\n-    io::stdout().write_str(fmt!{\"get()   : %? seconds\\n\", appendf});\n-    io::stdout().write_str(fmt!{\"        : %f op/sec\\n\", maxf/appendf});\n+    io::stdout().write_str(fmt!(\"insert(): %? seconds\\n\", checkf));\n+    io::stdout().write_str(fmt!(\"        : %f op/sec\\n\", maxf/checkf));\n+    io::stdout().write_str(fmt!(\"get()   : %? seconds\\n\", appendf));\n+    io::stdout().write_str(fmt!(\"        : %f op/sec\\n\", maxf/appendf));\n }"}, {"sha": "ef7442b22f2cf330480301a300e09fa6585856b4", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -118,9 +118,9 @@ fn solve_grid(g: grid_t) {\n \n fn write_grid(f: io::Writer, g: grid_t) {\n     for u8::range(0u8, 9u8) |row| {\n-        f.write_str(fmt!{\"%u\", (*g)[row][0] as uint});\n+        f.write_str(fmt!(\"%u\", (*g)[row][0] as uint));\n         for u8::range(1u8, 9u8) |col| {\n-            f.write_str(fmt!{\" %u\", (*g)[row][col] as uint});\n+            f.write_str(fmt!(\" %u\", (*g)[row][col] as uint));\n         }\n         f.write_char('\\n');\n      }"}, {"sha": "992e1557759bf2ab1199ba535177d414778b50fb", "filename": "src/test/bench/task-perf-alloc-unwind.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -17,11 +17,11 @@ fn main() {\n \n fn run(repeat: int, depth: int) {\n     for iter::repeat(repeat as uint) {\n-        debug!{\"starting %.4f\", precise_time_s()};\n+        debug!(\"starting %.4f\", precise_time_s());\n         do task::try {\n             recurse_or_fail(depth, none)\n         };\n-        debug!{\"stopping %.4f\", precise_time_s()};\n+        debug!(\"stopping %.4f\", precise_time_s());\n     }\n }\n \n@@ -48,7 +48,7 @@ struct r {\n \n fn recurse_or_fail(depth: int, st: option<st>) {\n     if depth == 0 {\n-        debug!{\"unwinding %.4f\", precise_time_s()};\n+        debug!(\"unwinding %.4f\", precise_time_s());\n         fail;\n     } else {\n         let depth = depth - 1;"}, {"sha": "7473132940a801ae9fb42058907c931376ad4ed4", "filename": "src/test/bench/task-perf-one-million.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -68,5 +68,5 @@ fn main(args: ~[~str]) {\n     let sum = match check comm::recv(port) {\n       done(sum) => { sum }\n     };\n-    error!{\"How many tasks? %d tasks.\", sum};\n+    error!(\"How many tasks? %d tasks.\", sum);\n }"}, {"sha": "1fff4a72ca21c4a577fbfbdc42c95da472f68036", "filename": "src/test/bench/task-perf-word-count-generic.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -82,7 +82,7 @@ impl io::Reader: word_reader {\n fn file_word_reader(filename: ~str) -> word_reader {\n     match io::file_reader(filename) {\n       result::ok(f) => { f as word_reader }\n-      result::err(e) => { fail fmt!{\"%?\", e} }\n+      result::err(e) => { fail fmt!(\"%?\", e) }\n     }\n }\n \n@@ -101,7 +101,7 @@ fn reduce(&&word: ~str, get: map_reduce::getter<int>) {\n \n     loop { match get() { some(_) => { count += 1; } none => { break; } } }\n     \n-    io::println(fmt!{\"%s\\t%?\", word, count});\n+    io::println(fmt!(\"%s\\t%?\", word, count));\n }\n \n struct box<T> {\n@@ -190,7 +190,7 @@ mod map_reduce {\n                     match pipes::recv(ctrl) {\n                       ctrl_proto::reducer(c_, ctrl) => {\n                         c = some(c_);\n-                        move_out!{ctrl}\n+                        move_out!(ctrl)\n                       }\n                     }\n                 }\n@@ -227,11 +227,11 @@ mod map_reduce {\n             while !is_done || ref_count > 0 {\n                 match recv(p) {\n                   emit_val(v) => {\n-                    // error!{\"received %d\", v};\n+                    // error!(\"received %d\", v);\n                     return some(v);\n                   }\n                   done => {\n-                    // error!{\"all done\"};\n+                    // error!(\"all done\");\n                     is_done = true;\n                   }\n                   addref => { ref_count += 1; }\n@@ -262,7 +262,7 @@ mod map_reduce {\n             let (_ready, message, ctrls) = pipes::select(ctrl);\n             match option::unwrap(message) {\n               ctrl_proto::mapper_done => {\n-                // error!{\"received mapper terminated.\"};\n+                // error!(\"received mapper terminated.\");\n                 num_mappers -= 1;\n                 ctrl = ctrls;\n               }\n@@ -288,7 +288,7 @@ mod map_reduce {\n                 }\n                 ctrl = vec::append_one(\n                     ctrls,\n-                    ctrl_proto::server::reducer(move_out!{cc}, c));\n+                    ctrl_proto::server::reducer(move_out!(cc), c));\n               }\n             }\n         }\n@@ -303,7 +303,7 @@ fn main(argv: ~[~str]) {\n     if vec::len(argv) < 2u && !os::getenv(~\"RUST_BENCH\").is_some() {\n         let out = io::stdout();\n \n-        out.write_line(fmt!{\"Usage: %s <filename> ...\", argv[0]});\n+        out.write_line(fmt!(\"Usage: %s <filename> ...\", argv[0]));\n \n         return;\n     }"}, {"sha": "db0b14edadc78daeb32c8220c9d459315e2d1177", "filename": "src/test/compile-fail/assign-imm-local-twice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fassign-imm-local-twice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fassign-imm-local-twice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassign-imm-local-twice.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -1,9 +1,9 @@\n fn test() {\n     let v: int;\n     v = 1; //~ NOTE prior assignment occurs here\n-    debug!{\"v=%d\", v};\n+    debug!(\"v=%d\", v);\n     v = 2; //~ ERROR re-assignment of immutable variable\n-    debug!{\"v=%d\", v};\n+    debug!(\"v=%d\", v);\n }\n \n fn main() {"}, {"sha": "0208b745d49ee5b0aedc27e89bb4a05502ec4385", "filename": "src/test/compile-fail/assign-to-method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fassign-to-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fassign-to-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassign-to-method.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -11,5 +11,5 @@ struct cat {\n \n fn main() {\n   let nyan : cat = cat(52u, 99);\n-  nyan.speak = fn@() { debug!{\"meow\"}; }; //~ ERROR attempted to take value of method\n+  nyan.speak = fn@() { debug!(\"meow\"); }; //~ ERROR attempted to take value of method\n }"}, {"sha": "e6bbb50044bd31d50809e292c98721675ccf53b9", "filename": "src/test/compile-fail/attr-before-ext.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fattr-before-ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fattr-before-ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fattr-before-ext.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -1,4 +1,4 @@\n fn main() {\n     #[attr]\n-    debug!{\"hi\"}; //~ ERROR expected item\n+    debug!(\"hi\"); //~ ERROR expected item\n }\n\\ No newline at end of file"}, {"sha": "7f00e26e34bc58dd2a6a2051b7b522dc9c41de13", "filename": "src/test/compile-fail/bogus-tag.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fbogus-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fbogus-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbogus-tag.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -7,8 +7,8 @@ enum color { rgb(int, int, int), rgba(int, int, int, int), }\n fn main() {\n     let red: color = rgb(255, 0, 0);\n     match red {\n-      rgb(r, g, b) => { debug!{\"rgb\"}; }\n-      hsl(h, s, l) => { debug!{\"hsl\"}; }\n+      rgb(r, g, b) => { debug!(\"rgb\"); }\n+      hsl(h, s, l) => { debug!(\"hsl\"); }\n     }\n }\n "}, {"sha": "5dbb0b2a33cb2f1e7cf860afe96cb29cc8d15ff1", "filename": "src/test/compile-fail/borrowck-loan-blocks-move-cc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -7,14 +7,14 @@ fn box_imm() {\n     let _w = &mut v; //~ NOTE loan of mutable local variable granted here\n     do task::spawn |move v| {\n         //~^ ERROR moving out of mutable local variable prohibited due to outstanding loan\n-        debug!{\"v=%d\", *v};\n+        debug!(\"v=%d\", *v);\n     }\n \n     let mut v = ~3;\n     let _w = &mut v; //~ NOTE loan of mutable local variable granted here\n     task::spawn(fn~(move v) {\n         //~^ ERROR moving out of mutable local variable prohibited due to outstanding loan\n-        debug!{\"v=%d\", *v};\n+        debug!(\"v=%d\", *v);\n     });\n }\n "}, {"sha": "7a6c85474b58504472cf2651b111eb4bac34b3b5", "filename": "src/test/compile-fail/class-cast-to-trait.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fclass-cast-to-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fclass-cast-to-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclass-cast-to-trait.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -7,7 +7,7 @@ struct cat : noisy {\n   priv {\n     let mut meows : uint;\n     fn meow() {\n-      error!{\"Meow\"};\n+      error!(\"Meow\");\n       self.meows += 1u;\n       if self.meows % 5u == 0u {\n           self.how_hungry += 1;\n@@ -25,12 +25,12 @@ struct cat : noisy {\n \n   fn eat() -> bool {\n     if self.how_hungry > 0 {\n-        error!{\"OM NOM NOM\"};\n+        error!(\"OM NOM NOM\");\n         self.how_hungry -= 2;\n         return true;\n     }\n     else {\n-        error!{\"Not hungry!\"};\n+        error!(\"Not hungry!\");\n         return false;\n     }\n   }"}, {"sha": "57c8ec272e10944eebe832e28c4b2ec453b94be8", "filename": "src/test/compile-fail/class-missing-self.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fclass-missing-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fclass-missing-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclass-missing-self.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -3,7 +3,7 @@ struct cat {\n     let mut meows : uint;\n     fn sleep() { loop{} }\n     fn meow() {\n-      error!{\"Meow\"};\n+      error!(\"Meow\");\n       meows += 1u; //~ ERROR unresolved name\n       sleep();     //~ ERROR unresolved name\n     }"}, {"sha": "fcc08a3d1ed44d64aeaf9c7459bc0aac6731b812", "filename": "src/test/compile-fail/dead-code-ret.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fdead-code-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fdead-code-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdead-code-ret.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -5,5 +5,5 @@\n \n fn f(caller: str) { log(debug, caller); }\n \n-fn main() { return f(\"main\"); debug!{\"Paul is dead\"}; }\n+fn main() { return f(\"main\"); debug!(\"Paul is dead\"); }\n "}, {"sha": "c6115f408535f3b786834fce33463709e43db9ea", "filename": "src/test/compile-fail/does-nothing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fdoes-nothing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fdoes-nothing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdoes-nothing.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -1,3 +1,3 @@\n // error-pattern: unresolved name: this_does_nothing_what_the\n-fn main() { debug!{\"doing\"}; this_does_nothing_what_the; debug!{\"boing\"}; }\n+fn main() { debug!(\"doing\"); this_does_nothing_what_the; debug!(\"boing\"); }\n "}, {"sha": "cc2fcf31e9e9cabd765d346eb3aba491a1bc92e8", "filename": "src/test/compile-fail/export2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fexport2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fexport2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fexport2.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -9,7 +9,7 @@ mod foo {\n mod bar {\n     export y;\n \n-    fn x() { debug!{\"x\"}; }\n+    fn x() { debug!(\"x\"); }\n \n     fn y() { }\n }"}, {"sha": "5c3ca527068fe0b17e649f53e591b4a5cb529e4e", "filename": "src/test/compile-fail/ext-after-attrib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fext-after-attrib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fext-after-attrib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fext-after-attrib.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -3,5 +3,5 @@\n // Don't know how to deal with a syntax extension appearing after an\n // item attribute. Probably could use a better error message.\n #[foo = \"bar\"]\n-fmt!{\"baz\"}\n+fmt!(\"baz\")\n fn main() { }\n\\ No newline at end of file"}, {"sha": "9b0bd51071b423a6a3576d69a541c974b33507a5", "filename": "src/test/compile-fail/ext-nonexistent.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fext-nonexistent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fext-nonexistent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fext-nonexistent.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -1,2 +1,2 @@\n // error-pattern:macro undefined\n-fn main() { iamnotanextensionthatexists!{\"\"}; }\n+fn main() { iamnotanextensionthatexists!(\"\"); }"}, {"sha": "e169db23bf267c996bc3efb79f4b4addcbe28994", "filename": "src/test/compile-fail/extenv-no-args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fextenv-no-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fextenv-no-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextenv-no-args.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -1,3 +1,3 @@\n // error-pattern:#env takes between 1 and 1 arguments\n \n-fn main() { env!{}; }\n+fn main() { env!(); }"}, {"sha": "f9856f96038d82c554c61ee30560e5abf667a293", "filename": "src/test/compile-fail/extenv-not-string-literal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fextenv-not-string-literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fextenv-not-string-literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextenv-not-string-literal.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -1,3 +1,3 @@\n // error-pattern:requires a string\n \n-fn main() { env!{10}; }\n+fn main() { env!(10); }"}, {"sha": "ee5b1b4af74e0de7776ebf952e62cc1f00cbb89a", "filename": "src/test/compile-fail/extenv-too-many-args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fextenv-too-many-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fextenv-too-many-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextenv-too-many-args.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -1,3 +1,3 @@\n // error-pattern:#env takes between 1 and 1 arguments\n \n-fn main() { env!{\"one\", \"two\"}; }\n+fn main() { env!(\"one\", \"two\"); }"}, {"sha": "3737f3097e816a44bbab5ad9f99af281df5631ae", "filename": "src/test/compile-fail/extfmt-missing-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fextfmt-missing-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fextfmt-missing-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-missing-type.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -1,3 +1,3 @@\n // error-pattern:missing type\n \n-fn main() { fmt!{\"%+\"}; }\n+fn main() { fmt!(\"%+\"); }"}, {"sha": "b291fbae2256fc9c5e880c4ea6d90e2353819f27", "filename": "src/test/compile-fail/extfmt-no-args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fextfmt-no-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fextfmt-no-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-no-args.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -1,3 +1,3 @@\n // error-pattern:#fmt needs at least 1 arguments\n \n-fn main() { fmt!{}; }\n+fn main() { fmt!(); }"}, {"sha": "0e2109fac4f0c0a601f66897808f0a140a0fdf0e", "filename": "src/test/compile-fail/extfmt-non-literal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fextfmt-non-literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fextfmt-non-literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-non-literal.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -4,5 +4,5 @@ fn main() {\n     // #fmt's first argument must be a literal.  Hopefully this\n     // restriction can be eased eventually to just require a\n     // compile-time constant.\n-    let x = fmt!{\"a\" + \"b\"};\n+    let x = fmt!(\"a\" + \"b\");\n }"}, {"sha": "cc10845fd9f128ad41a4d62d51cb89f397a102be", "filename": "src/test/compile-fail/extfmt-non-literal2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fextfmt-non-literal2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fextfmt-non-literal2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-non-literal2.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -4,5 +4,5 @@ fn main() {\n     // #fmt's first argument must be a literal.  Hopefully this\n     // restriction can be eased eventually to just require a\n     // compile-time constant.\n-    let x = fmt!{20};\n+    let x = fmt!(20);\n }"}, {"sha": "322b0d00b770aac7b075ffa96f6699c099cf50dd", "filename": "src/test/compile-fail/extfmt-not-enough-args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fextfmt-not-enough-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fextfmt-not-enough-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-not-enough-args.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -2,4 +2,4 @@\n \n use std;\n \n-fn main() { let s = fmt!{\"%s%s%s\", \"test\", \"test\"}; }\n+fn main() { let s = fmt!(\"%s%s%s\", \"test\", \"test\"); }"}, {"sha": "c9b54c9aa94e3ad9a123d629836f4b8816b5c4d4", "filename": "src/test/compile-fail/extfmt-too-many-args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fextfmt-too-many-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fextfmt-too-many-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-too-many-args.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -2,4 +2,4 @@\n \n use std;\n \n-fn main() { let s = fmt!{\"%s\", \"test\", \"test\"}; }\n+fn main() { let s = fmt!(\"%s\", \"test\", \"test\"); }"}, {"sha": "d08fdf70f5c1187560e6376e218b0409fcb4d789", "filename": "src/test/compile-fail/extfmt-unknown-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fextfmt-unknown-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fextfmt-unknown-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-unknown-type.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -1,3 +1,3 @@\n // error-pattern:unknown type\n \n-fn main() { fmt!{\"%w\"}; }\n+fn main() { fmt!(\"%w\"); }"}, {"sha": "d8a9f4fa98dff8e18dbaad1386eea4feeabbc08f", "filename": "src/test/compile-fail/extfmt-unsigned-plus.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fextfmt-unsigned-plus.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fextfmt-unsigned-plus.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-unsigned-plus.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -2,5 +2,5 @@\n \n fn main() {\n     // Can't use a sign on unsigned conversions\n-    fmt!{\"%+u\", 10u};\n+    fmt!(\"%+u\", 10u);\n }"}, {"sha": "001adb521cc30e8585c5dc4421ec49c34742e1e2", "filename": "src/test/compile-fail/extfmt-unsigned-space.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fextfmt-unsigned-space.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fextfmt-unsigned-space.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-unsigned-space.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -2,5 +2,5 @@\n \n fn main() {\n     // Can't use a space on unsigned conversions\n-    fmt!{\"% u\", 10u};\n+    fmt!(\"% u\", 10u);\n }"}, {"sha": "e8367afbb0d110d4b6411ad429278b535c991bdb", "filename": "src/test/compile-fail/extfmt-unterminated-conv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fextfmt-unterminated-conv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fextfmt-unterminated-conv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-unterminated-conv.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -1,3 +1,3 @@\n // error-pattern:unterminated conversion\n \n-fn main() { fmt!{\"%\"}; }\n+fn main() { fmt!(\"%\"); }"}, {"sha": "b8d26822c1ebad59d6ae78ae740387ae7105c359", "filename": "src/test/compile-fail/for-loop-decl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Ffor-loop-decl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Ffor-loop-decl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffor-loop-decl.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -16,4 +16,4 @@ fn bitv_to_str(enclosing: fn_info, v: ~bitv::bitv) -> str {\n     return s;\n }\n \n-fn main() { debug!{\"OK\"}; }\n+fn main() { debug!(\"OK\"); }"}, {"sha": "93ad7dcf975c4b7510a7957d46e4ca63996be18a", "filename": "src/test/compile-fail/import-glob-0.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fimport-glob-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fimport-glob-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-glob-0.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -7,10 +7,10 @@ mod module_of_many_things {\n     export f2;\n     export f4;\n \n-    fn f1() { debug!{\"f1\"}; }\n-    fn f2() { debug!{\"f2\"}; }\n-    fn f3() { debug!{\"f3\"}; }\n-    fn f4() { debug!{\"f4\"}; }\n+    fn f1() { debug!(\"f1\"); }\n+    fn f2() { debug!(\"f2\"); }\n+    fn f3() { debug!(\"f3\"); }\n+    fn f4() { debug!(\"f4\"); }\n }\n \n "}, {"sha": "637b78e4eed79c663ed92eeab5a4fefb48f4fe2e", "filename": "src/test/compile-fail/import-glob-circular.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fimport-glob-circular.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fimport-glob-circular.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-glob-circular.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -5,7 +5,7 @@ mod circ1 {\n     export f1;\n     export f2;\n     export common;\n-    fn f1() { debug!{\"f1\"}; }\n+    fn f1() { debug!(\"f1\"); }\n     fn common() -> uint { return 0u; }\n }\n \n@@ -14,7 +14,7 @@ mod circ2 {\n     export f1;\n     export f2;\n     export common;\n-    fn f2() { debug!{\"f2\"}; }\n+    fn f2() { debug!(\"f2\"); }\n     fn common() -> uint { return 1u; }\n }\n "}, {"sha": "f06ff498fccc63f7ce8070fb6aecfd490413a27f", "filename": "src/test/compile-fail/import.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -3,6 +3,6 @@\n import zed::bar;\n import zed::baz;\n mod zed {\n-    fn bar() { debug!{\"bar\"}; }\n+    fn bar() { debug!(\"bar\"); }\n }\n fn main(args: ~[str]) { bar(); }"}, {"sha": "75493f2a0374514fc29cce6709d3d3967105d7a1", "filename": "src/test/compile-fail/import2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fimport2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fimport2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport2.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -2,6 +2,6 @@\n import baz::zed::bar;\n mod baz { }\n mod zed {\n-    fn bar() { debug!{\"bar3\"}; }\n+    fn bar() { debug!(\"bar3\"); }\n }\n fn main(args: ~[str]) { bar(); }"}, {"sha": "b825901f4a62ce18b364619230d9fbbb29bbdbfa", "filename": "src/test/compile-fail/import3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fimport3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fimport3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport3.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -1,4 +1,4 @@\n // error-pattern: unresolved\n import main::bar;\n \n-fn main(args: ~[str]) { debug!{\"foo\"}; }\n+fn main(args: ~[str]) { debug!(\"foo\"); }"}, {"sha": "6717434273fd730f324986934f77f42008620d98", "filename": "src/test/compile-fail/import4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fimport4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fimport4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport4.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -3,4 +3,4 @@\n mod a { import foo = b::foo; export foo; }\n mod b { import foo = a::foo; export foo; }\n \n-fn main(args: ~[str]) { debug!{\"loop\"}; }\n+fn main(args: ~[str]) { debug!(\"loop\"); }"}, {"sha": "ccd13b709a619245b45d4153f1ef133eadba18d5", "filename": "src/test/compile-fail/issue-1448-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fissue-1448-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fissue-1448-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-1448-1.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -3,5 +3,5 @@\n fn main() {\n     #macro[[#apply[f, [x, ...]], f(x, ...)]];\n     fn add(a: int, b: int) -> int { return a + b; }\n-    assert (apply!{add, [y, 15]} == 16); //~ ERROR unresolved name: y\n+    assert (apply!(add, [y, 15]) == 16); //~ ERROR unresolved name: y\n }"}, {"sha": "62cc4d4f5b2aa910fc1fd4041841eb2c5127c6ee", "filename": "src/test/compile-fail/issue-1448-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fissue-1448-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fissue-1448-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-1448-2.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -1,5 +1,5 @@\n // Regresion test for issue #1448 and #1386\n \n fn main() {\n-    debug!{\"%u\", 10i}; //~ ERROR mismatched types\n+    debug!(\"%u\", 10i); //~ ERROR mismatched types\n }"}, {"sha": "29adc91a4acc305bfd13eb57146e94a505068cfb", "filename": "src/test/compile-fail/liveness-if-with-else.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fliveness-if-with-else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fliveness-if-with-else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-if-with-else.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -3,7 +3,7 @@ fn foo(x: int) { log(debug, x); }\n fn main() {\n     let x: int;\n     if 1 > 2 {\n-        debug!{\"whoops\"};\n+        debug!(\"whoops\");\n     } else {\n         x = 10;\n     }"}, {"sha": "c013c1cb380a2d77da5624a1e85da45f9300880f", "filename": "src/test/compile-fail/liveness-while-break.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fliveness-while-break.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fliveness-while-break.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-while-break.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -4,7 +4,7 @@ fn test(cond: bool) {\n         v = 3;\n         break;\n     }\n-    debug!{\"%d\", v}; //~ ERROR use of possibly uninitialized variable: `v`\n+    debug!(\"%d\", v); //~ ERROR use of possibly uninitialized variable: `v`\n }\n \n fn main() {"}, {"sha": "bb54685f752ff945a7f9159ce4ffffd57f1439b5", "filename": "src/test/compile-fail/macro-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fmacro-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fmacro-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-2.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -6,5 +6,5 @@ fn main() {\n                 f\n             }]];\n \n-    assert (mylambda!{y * 1, y * 2}(8) == 16);\n+    assert (mylambda!(y * 1, y * 2)(8) == 16);\n }"}, {"sha": "477a297c2ab952cff10b91991bbf47895746f02a", "filename": "src/test/compile-fail/macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fmacro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fmacro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -3,6 +3,6 @@\n fn main() {\n     #macro[[#trivial[], 1 * 2 * 4 * 2 * 1]];\n \n-    assert (trivial!{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16} ==\n+    assert (trivial!(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16) ==\n                 16);\n }"}, {"sha": "98ebec81045f0f9ee18fea68d4b38b0e73fc342c", "filename": "src/test/compile-fail/not-utf8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fnot-utf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fnot-utf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnot-utf8.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -1,5 +1,5 @@\n // error-pattern: is not UTF-8\n \n fn foo() {\n-    include!{\"not-utf8.bin\"}\n+    include!(\"not-utf8.bin\")\n }"}, {"sha": "9737b195cfa2a47ae489aa53ae9cb26f41ae9c99", "filename": "src/test/compile-fail/pure-higher-order.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fpure-higher-order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fpure-higher-order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpure-higher-order.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -40,7 +40,7 @@ pure fn range8(from: uint, to: uint) {\n     range(from, to, noop);\n }\n \n-fn print(i: uint) { error!{\"i=%u\", i}; }\n+fn print(i: uint) { error!(\"i=%u\", i); }\n \n pure fn noop(_i: uint) {}\n "}, {"sha": "9bfc39c32dccd10a22a54dde2d10bad8d374e070", "filename": "src/test/compile-fail/regions-addr-of-self.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fregions-addr-of-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fregions-addr-of-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-addr-of-self.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -19,6 +19,6 @@ struct dog {\n fn main() {\n     let d = dog();\n     d.chase_cat();\n-    debug!{\"cats_chased: %u\", d.cats_chased};\n+    debug!(\"cats_chased: %u\", d.cats_chased);\n }\n "}, {"sha": "9f32434ae1a7b2226a9278ddd15e70b6ef3d72b1", "filename": "src/test/compile-fail/regions-escape-via-trait-or-not.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fregions-escape-via-trait-or-not.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fregions-escape-via-trait-or-not.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-escape-via-trait-or-not.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -21,5 +21,5 @@ fn return_it() -> int {\n \n fn main() {\n     let x = return_it();\n-    debug!{\"foo=%d\", x};\n+    debug!(\"foo=%d\", x);\n }"}, {"sha": "c0b87086db8b32d413edfc702e72592b15c14438", "filename": "src/test/compile-fail/regions-ret-borrowed-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed-1.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -13,5 +13,5 @@ fn return_it() -> &a/int {\n \n fn main() {\n     let x = return_it();\n-    debug!{\"foo=%d\", *x};\n+    debug!(\"foo=%d\", *x);\n }"}, {"sha": "9abaa75590ec8de802627a1570628629762d0500", "filename": "src/test/compile-fail/regions-ret-borrowed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -16,5 +16,5 @@ fn return_it() -> &int {\n \n fn main() {\n     let x = return_it();\n-    debug!{\"foo=%d\", *x};\n+    debug!(\"foo=%d\", *x);\n }"}, {"sha": "d1b7a7721f23e50d69ec0bc59a4da1646bd7c65a", "filename": "src/test/compile-fail/unbalanced-comment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Funbalanced-comment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fcompile-fail%2Funbalanced-comment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funbalanced-comment.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -7,5 +7,5 @@\n  */\n \n fn main() {\n-  debug!{\"hello, world.\"};\n+  debug!(\"hello, world.\");\n }"}, {"sha": "4bc01f1c6a9b05159658c78fed8c4b3d4e852dc4", "filename": "src/test/pretty/block-arg-disambig.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fpretty%2Fblock-arg-disambig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Fpretty%2Fblock-arg-disambig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fblock-arg-disambig.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -2,4 +2,4 @@\n // is probably not necessary anymore (#2882)\n \n fn blk1(b: fn()) -> fn@() { return fn@() { }; }\n-fn test1() { (do blk1 { debug!{\"hi\"}; })(); }\n+fn test1() { (do blk1 { debug!(\"hi\"); })(); }"}, {"sha": "0db43856612ad99e01282d026ddb085dfbb65402", "filename": "src/test/run-fail/bug-2470-bounds-check-overflow-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow-2.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -10,8 +10,8 @@ fn main() {\n     // wrap around to a small number.\n \n     let idx = uint::max_value & !(uint::max_value >> 1u);\n-    error!{\"ov2 idx = 0x%x\", idx};\n+    error!(\"ov2 idx = 0x%x\", idx);\n \n     // This should fail.\n-    error!{\"ov2 0x%x\",  x[idx]};\n+    error!(\"ov2 0x%x\",  x[idx]);\n }\n\\ No newline at end of file"}, {"sha": "949d303eb01aad33d411909a29939fb2fee3b9e2", "filename": "src/test/run-fail/bug-2470-bounds-check-overflow-3.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow-3.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -12,17 +12,17 @@ fn main() {\n     // This test is only meaningful on 32-bit hosts.\n \n     let idx = u64::max_value & !(u64::max_value >> 1u);\n-    error!{\"ov3 idx = 0x%8.8x%8.8x\",\n+    error!(\"ov3 idx = 0x%8.8x%8.8x\",\n            (idx >> 32) as uint,\n-           idx as uint};\n+           idx as uint);\n \n     // This should fail.\n-    error!{\"ov3 0x%x\",  x[idx]};\n+    error!(\"ov3 0x%x\",  x[idx]);\n }\n \n #[cfg(target_arch=\"x86_64\")]\n fn main() {\n     // This version just fails anyways, for symmetry on 64-bit hosts.\n     let x = ~[1u,2u,3u];\n-    error!{\"ov3 0x%x\",  x[200]};\n+    error!(\"ov3 0x%x\",  x[200]);\n }"}, {"sha": "f35759639623af6cfef4109beca9ea03bc8d550a", "filename": "src/test/run-fail/bug-2470-bounds-check-overflow.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -12,13 +12,13 @@ fn main() {\n     do vec::as_buf(x) |p, _len| {\n         let base = p as uint;                     // base = 0x1230 say\n         let idx = base / sys::size_of::<uint>();  // idx  = 0x0246 say\n-        error!{\"ov1 base = 0x%x\", base};\n-        error!{\"ov1 idx = 0x%x\", idx};\n-        error!{\"ov1 sizeof::<uint>() = 0x%x\", sys::size_of::<uint>()};\n-        error!{\"ov1 idx * sizeof::<uint>() = 0x%x\",\n-               idx * sys::size_of::<uint>()};\n+        error!(\"ov1 base = 0x%x\", base);\n+        error!(\"ov1 idx = 0x%x\", idx);\n+        error!(\"ov1 sizeof::<uint>() = 0x%x\", sys::size_of::<uint>());\n+        error!(\"ov1 idx * sizeof::<uint>() = 0x%x\",\n+               idx * sys::size_of::<uint>());\n \n         // This should fail.\n-        error!{\"ov1 0x%x\",  x[idx]};\n+        error!(\"ov1 0x%x\",  x[idx]);\n     }\n }\n\\ No newline at end of file"}, {"sha": "71343c6751ecaae3ab481e22892c5ef1ad247acf", "filename": "src/test/run-fail/extern-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-fail%2Fextern-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-fail%2Fextern-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fextern-fail.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -24,7 +24,7 @@ fn main() {\n     for iter::repeat(10u) {\n         do task::spawn {\n             let result = count(5u);\n-            debug!{\"result = %?\", result};\n+            debug!(\"result = %?\", result);\n             fail;\n         };\n     }"}, {"sha": "27ece3b45c9624100d82673d5c9a90a8fd62d376", "filename": "src/test/run-fail/fmt-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-fail%2Ffmt-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-fail%2Ffmt-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffmt-fail.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -1,4 +1,4 @@\n // error-pattern:meh\n use std;\n \n-fn main() { let str_var: ~str = ~\"meh\"; fail fmt!{\"%s\", str_var}; }\n+fn main() { let str_var: ~str = ~\"meh\"; fail fmt!(\"%s\", str_var); }"}, {"sha": "af7c673913ee6bb8edfc99f34df24bf00243213e", "filename": "src/test/run-pass-fulldeps/qquote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -92,7 +92,7 @@ fn check_pp<T>(cx: fake_ext_ctxt,\n     let str = mem_buffer_str(buf);\n     stdout().write_line(str);\n     if expect != ~\"\" {\n-        error!{\"expect: '%s', got: '%s'\", expect, str};\n+        error!(\"expect: '%s', got: '%s'\", expect, str);\n         assert str == expect;\n     }\n }"}, {"sha": "4def6d7601cafc82bea8209bc252821aa91e0b91", "filename": "src/test/run-pass/acyclic-unwind.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Facyclic-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Facyclic-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Facyclic-unwind.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -17,7 +17,7 @@ fn f(c: comm::_chan<int>) {\n \n     loop {\n         // spin waiting for the parent to kill us.\n-        debug!{\"child waiting to die...\"};\n+        debug!(\"child waiting to die...\");\n \n         // while waiting to die, the messages we are\n         // sending to the channel are never received\n@@ -35,5 +35,5 @@ fn main() {\n     // synchronize on event from child.\n     i = p.recv();\n \n-    debug!{\"parent exiting, killing child\"};\n+    debug!(\"parent exiting, killing child\");\n }"}, {"sha": "410bc9b570b6161145fd3d687719e7941a096ca5", "filename": "src/test/run-pass/alignment-gep-tup-like-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-1.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -8,7 +8,7 @@ fn f<A:copy owned>(a: A, b: u16) -> fn@() -> (A, u16) {\n \n fn main() {\n     let (a, b) = f(22_u64, 44u16)();\n-    debug!{\"a=%? b=%?\", a, b};\n+    debug!(\"a=%? b=%?\", a, b);\n     assert a == 22u64;\n     assert b == 44u16;\n }\n\\ No newline at end of file"}, {"sha": "1153c801dd98db122c44ca8d14d32e440bf578d6", "filename": "src/test/run-pass/alignment-gep-tup-like-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -23,7 +23,7 @@ fn main() {\n     let z = f(~x, y);\n     make_cycle(z);\n     let (a, b) = z();\n-    debug!{\"a=%u b=%u\", *a as uint, b as uint};\n+    debug!(\"a=%u b=%u\", *a as uint, b as uint);\n     assert *a == x;\n     assert b == y;\n }\n\\ No newline at end of file"}, {"sha": "c77b0432ad62e63d97ca0cf989fb2d3e9b6c888b", "filename": "src/test/run-pass/alt-join.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Falt-join.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Falt-join.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-join.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -19,4 +19,4 @@ fn foo<T>(y: option<T>) {\n     return;\n }\n \n-fn main() { debug!{\"hello\"}; foo::<int>(some::<int>(5)); }\n+fn main() { debug!(\"hello\"); foo::<int>(some::<int>(5)); }"}, {"sha": "0e276acb8c39d7b188a76972c3df8412e7374938", "filename": "src/test/run-pass/alt-pattern-drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Falt-pattern-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Falt-pattern-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-pattern-drop.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -14,7 +14,7 @@ fn foo(s: @int) {\n         log(debug, y); // ref up then down\n \n       }\n-      _ => { debug!{\"?\"}; fail; }\n+      _ => { debug!(\"?\"); fail; }\n     }\n     log(debug, sys::refcount(s));\n     assert (sys::refcount(s) == count + 1u);"}, {"sha": "8432077cd25ce755a32c8096652edbaa0225f50e", "filename": "src/test/run-pass/alt-pattern-lit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Falt-pattern-lit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Falt-pattern-lit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-pattern-lit.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -2,8 +2,8 @@\n \n fn altlit(f: int) -> int {\n     match check f {\n-      10 => { debug!{\"case 10\"}; return 20; }\n-      11 => { debug!{\"case 11\"}; return 22; }\n+      10 => { debug!(\"case 10\"); return 20; }\n+      11 => { debug!(\"case 11\"); return 22; }\n     }\n }\n "}, {"sha": "8a91257271e873b379f4e24dd816cbe5ec6f321c", "filename": "src/test/run-pass/alt-pattern-no-type-params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Falt-pattern-no-type-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Falt-pattern-no-type-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-pattern-no-type-params.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -1,7 +1,7 @@\n enum maybe<T> { nothing, just(T), }\n \n fn foo(x: maybe<int>) {\n-    match x { nothing => { error!{\"A\"}; } just(a) => { error!{\"B\"}; } }\n+    match x { nothing => { error!(\"A\"); } just(a) => { error!(\"B\"); } }\n }\n \n fn main() { }"}, {"sha": "9fdbe59780f3e3b0a0de0946847e017c930f410b", "filename": "src/test/run-pass/alt-tag.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Falt-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Falt-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-tag.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -11,9 +11,9 @@ enum color {\n fn process(c: color) -> int {\n     let mut x: int;\n     match c {\n-      rgb(r, _, _) => { debug!{\"rgb\"}; log(debug, r); x = r; }\n-      rgba(_, _, _, a) => { debug!{\"rgba\"}; log(debug, a); x = a; }\n-      hsl(_, s, _) => { debug!{\"hsl\"}; log(debug, s); x = s; }\n+      rgb(r, _, _) => { debug!(\"rgb\"); log(debug, r); x = r; }\n+      rgba(_, _, _, a) => { debug!(\"rgba\"); log(debug, a); x = a; }\n+      hsl(_, s, _) => { debug!(\"hsl\"); log(debug, s); x = s; }\n     }\n     return x;\n }"}, {"sha": "4ca0d24b7cff31700f113d14846713c43fb6037e", "filename": "src/test/run-pass/alt-unique-bind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Falt-unique-bind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Falt-unique-bind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-unique-bind.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -1,7 +1,7 @@\n fn main() {\n     match ~100 {\n       ~x => {\n-        debug!{\"%?\", x};\n+        debug!(\"%?\", x);\n         assert x == 100;\n       }\n     }"}, {"sha": "af3ec0652dd3887f938af5c6d2177f3ad444ba1a", "filename": "src/test/run-pass/auto_serialize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto_serialize.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -16,7 +16,7 @@ fn test_ser_and_deser<A>(a1: A,\n     // check the pretty printer:\n     io_ser_fn(io::stdout(), a1);\n     let s = io::with_str_writer(|w| io_ser_fn(w, a1) );\n-    debug!{\"s == %?\", s};\n+    debug!(\"s == %?\", s);\n     assert s == expected;\n \n     // check the EBML serializer:"}, {"sha": "a3df02fd686a3cd5b41a7def50c90cea62385b6b", "filename": "src/test/run-pass/basic-1.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fbasic-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fbasic-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbasic-1.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -18,15 +18,15 @@ fn main() {\n     let mut n: int = 0;\n     n = recv(p);\n     n = recv(p);\n-    //    debug!{\"Finished.\"};\n+    //    debug!(\"Finished.\");\n }\n \n fn b(c: Chan<int>) {\n-    //    debug!{\"task b0\"};\n-    //    debug!{\"task b1\"};\n-    //    debug!{\"task b2\"};\n-    //    debug!{\"task b3\"};\n-    //    debug!{\"task b4\"};\n-    //    debug!{\"task b5\"};\n+    //    debug!(\"task b0\");\n+    //    debug!(\"task b1\");\n+    //    debug!(\"task b2\");\n+    //    debug!(\"task b3\");\n+    //    debug!(\"task b4\");\n+    //    debug!(\"task b5\");\n     send(c, 10);\n }"}, {"sha": "2f0fe8fe0065847eb1ad5ea4116474672276885d", "filename": "src/test/run-pass/basic-2.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fbasic-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fbasic-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbasic-2.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -9,7 +9,7 @@ import comm::chan;\n import comm::recv;\n import task;\n \n-fn a(c: Chan<int>) { debug!{\"task a0\"}; debug!{\"task a1\"}; send(c, 10); }\n+fn a(c: Chan<int>) { debug!(\"task a0\"); debug!(\"task a1\"); send(c, 10); }\n \n fn main() {\n     let p = port();\n@@ -19,14 +19,14 @@ fn main() {\n     let mut n: int = 0;\n     n = recv(p);\n     n = recv(p);\n-    debug!{\"Finished.\"};\n+    debug!(\"Finished.\");\n }\n \n fn b(c: Chan<int>) {\n-    debug!{\"task b0\"};\n-    debug!{\"task b1\"};\n-    debug!{\"task b2\"};\n-    debug!{\"task b2\"};\n-    debug!{\"task b3\"};\n+    debug!(\"task b0\");\n+    debug!(\"task b1\");\n+    debug!(\"task b2\");\n+    debug!(\"task b2\");\n+    debug!(\"task b3\");\n     send(c, 10);\n }"}, {"sha": "abef48171ab2bc4188c5ee19a0c1589c904d4437", "filename": "src/test/run-pass/basic.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbasic.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -10,11 +10,11 @@ import task;\n \n fn a(c: Chan<int>) {\n     if true {\n-        debug!{\"task a\"};\n-        debug!{\"task a\"};\n-        debug!{\"task a\"};\n-        debug!{\"task a\"};\n-        debug!{\"task a\"};\n+        debug!(\"task a\");\n+        debug!(\"task a\");\n+        debug!(\"task a\");\n+        debug!(\"task a\");\n+        debug!(\"task a\");\n     }\n     send(c, 10);\n }\n@@ -40,17 +40,17 @@ fn main() {\n     log(debug, x);\n     n = recv(p);\n     n = recv(p);\n-    debug!{\"children finished, root finishing\"};\n+    debug!(\"children finished, root finishing\");\n }\n \n fn b(c: Chan<int>) {\n     if true {\n-        debug!{\"task b\"};\n-        debug!{\"task b\"};\n-        debug!{\"task b\"};\n-        debug!{\"task b\"};\n-        debug!{\"task b\"};\n-        debug!{\"task b\"};\n+        debug!(\"task b\");\n+        debug!(\"task b\");\n+        debug!(\"task b\");\n+        debug!(\"task b\");\n+        debug!(\"task b\");\n+        debug!(\"task b\");\n     }\n     send(c, 10);\n }"}, {"sha": "2a2a3c3c612db74335cd33604ffd25bbac82402d", "filename": "src/test/run-pass/binops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fbinops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fbinops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbinops.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -136,9 +136,9 @@ fn test_class() {\n   let r = p(1, 2);\n   \n   unsafe {\n-  error!{\"q = %x, r = %x\",\n+  error!(\"q = %x, r = %x\",\n          (unsafe::reinterpret_cast::<*p, uint>(ptr::addr_of(q))),\n-         (unsafe::reinterpret_cast::<*p, uint>(ptr::addr_of(r)))};\n+         (unsafe::reinterpret_cast::<*p, uint>(ptr::addr_of(r))));\n   }\n   assert(q == r);\n   r.y = 17;"}, {"sha": "6db380735cba75a575b03e46762c559999c69e6e", "filename": "src/test/run-pass/borrowck-mut-uniq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fborrowck-mut-uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fborrowck-mut-uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-mut-uniq.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -19,8 +19,8 @@ fn main() {\n     add_int(ints, 44);\n \n     for iter_ints(ints) |i| {\n-        error!{\"int = %d\", *i};\n+        error!(\"int = %d\", *i);\n     }\n \n-    error!{\"ints=%?\", ints};\n+    error!(\"ints=%?\", ints);\n }"}, {"sha": "373830d77afd89125f9da8d4e28c97450f883a3b", "filename": "src/test/run-pass/borrowck-preserve-box-in-discr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-discr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-discr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-discr.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -9,7 +9,7 @@ fn main() {\n \n         x = @{f: ~4};\n \n-        debug!{\"ptr::addr_of(*b_x) = %x\", ptr::addr_of(*b_x) as uint};\n+        debug!(\"ptr::addr_of(*b_x) = %x\", ptr::addr_of(*b_x) as uint);\n         assert *b_x == 3;\n         assert ptr::addr_of(*x.f) != ptr::addr_of(*b_x);\n       }"}, {"sha": "7ab2dc4b99da937ed512cda945acb769d2da9b56", "filename": "src/test/run-pass/borrowck-preserve-box-in-field.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-field.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -14,7 +14,7 @@ fn main() {\n         assert ptr::addr_of(*x.f) == ptr::addr_of(*b_x);\n         x = @{f: ~4};\n \n-        debug!{\"ptr::addr_of(*b_x) = %x\", ptr::addr_of(*b_x) as uint};\n+        debug!(\"ptr::addr_of(*b_x) = %x\", ptr::addr_of(*b_x) as uint);\n         assert *b_x == 3;\n         assert ptr::addr_of(*x.f) != ptr::addr_of(*b_x);\n     }"}, {"sha": "599879f82f1dabb9e185dee55e72e322cb8c248f", "filename": "src/test/run-pass/borrowck-preserve-box-in-pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-pat.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -9,7 +9,7 @@ fn main() {\n \n         *x = @{f: ~4};\n \n-        debug!{\"ptr::addr_of(*b_x) = %x\", ptr::addr_of(*b_x) as uint};\n+        debug!(\"ptr::addr_of(*b_x) = %x\", ptr::addr_of(*b_x) as uint);\n         assert *b_x == 3;\n         assert ptr::addr_of(*x.f) != ptr::addr_of(*b_x);\n       }"}, {"sha": "bd43ad65cffbd5837fddd3cb3a55bddeed76436a", "filename": "src/test/run-pass/borrowck-preserve-box-in-uniq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-uniq.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -14,7 +14,7 @@ fn main() {\n         assert ptr::addr_of(*x.f) == ptr::addr_of(*b_x);\n         *x = @{f: ~4};\n \n-        debug!{\"ptr::addr_of(*b_x) = %x\", ptr::addr_of(*b_x) as uint};\n+        debug!(\"ptr::addr_of(*b_x) = %x\", ptr::addr_of(*b_x) as uint);\n         assert *b_x == 3;\n         assert ptr::addr_of(*x.f) != ptr::addr_of(*b_x);\n     }"}, {"sha": "8d59975204b1a21e7b1d12555cebd5e9fe97bf92", "filename": "src/test/run-pass/borrowck-preserve-box.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -14,7 +14,7 @@ fn main() {\n         assert ptr::addr_of(*x) == ptr::addr_of(*b_x);\n         x = @22;\n \n-        debug!{\"ptr::addr_of(*b_x) = %x\", ptr::addr_of(*b_x) as uint};\n+        debug!(\"ptr::addr_of(*b_x) = %x\", ptr::addr_of(*b_x) as uint);\n         assert *b_x == 3;\n         assert ptr::addr_of(*x) != ptr::addr_of(*b_x);\n     }"}, {"sha": "291ebb085566fb5a956877a5f23abb0226885f55", "filename": "src/test/run-pass/borrowck-preserve-cond-box.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fborrowck-preserve-cond-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fborrowck-preserve-cond-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-cond-box.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -14,13 +14,13 @@ fn testfn(cond: bool) {\n         exp = 4;\n     }\n \n-    debug!{\"*r = %d, exp = %d\", *r, exp};\n+    debug!(\"*r = %d, exp = %d\", *r, exp);\n     assert *r == exp;\n \n     x = @5;\n     y = @6;\n \n-    debug!{\"*r = %d, exp = %d\", *r, exp};\n+    debug!(\"*r = %d, exp = %d\", *r, exp);\n     assert *r == exp;\n }\n "}, {"sha": "e126ecc4340b535f53371d2a2c462ea1450f452c", "filename": "src/test/run-pass/borrowck-preserve-expl-deref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fborrowck-preserve-expl-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fborrowck-preserve-expl-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-expl-deref.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -14,7 +14,7 @@ fn main() {\n         assert ptr::addr_of(*x.f) == ptr::addr_of(*b_x);\n         x = @{f: ~4};\n \n-        debug!{\"ptr::addr_of(*b_x) = %x\", ptr::addr_of(*b_x) as uint};\n+        debug!(\"ptr::addr_of(*b_x) = %x\", ptr::addr_of(*b_x) as uint);\n         assert *b_x == 3;\n         assert ptr::addr_of(*x.f) != ptr::addr_of(*b_x);\n     }"}, {"sha": "df8539634eb5b3c538ebea4725dd4eea8f9feb73", "filename": "src/test/run-pass/box-inside-if.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fbox-inside-if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fbox-inside-if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbox-inside-if.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -9,7 +9,7 @@ fn is_odd(n: int) -> bool { return true; }\n fn length_is_even(vs: @int) -> bool { return true; }\n \n fn foo(acc: int, n: int) {\n-    if is_odd(n) && length_is_even(some_box(1)) { error!{\"bloop\"}; }\n+    if is_odd(n) && length_is_even(some_box(1)) { error!(\"bloop\"); }\n }\n \n fn main() { foo(67, 5); }"}, {"sha": "6f91206a7f698e992901d704cf7a872261eabcc2", "filename": "src/test/run-pass/box-inside-if2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fbox-inside-if2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fbox-inside-if2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbox-inside-if2.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -9,7 +9,7 @@ fn is_odd(n: int) -> bool { return true; }\n fn length_is_even(vs: @int) -> bool { return true; }\n \n fn foo(acc: int, n: int) {\n-    if is_odd(n) || length_is_even(some_box(1)) { error!{\"bloop\"}; }\n+    if is_odd(n) || length_is_even(some_box(1)) { error!(\"bloop\"); }\n }\n \n fn main() { foo(67, 5); }"}, {"sha": "e189066c09f2afb979fa3091a4b2528673b38c56", "filename": "src/test/run-pass/box-unbox.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fbox-unbox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fbox-unbox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbox-unbox.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -7,6 +7,6 @@ fn unbox<T: copy>(b: box<T>) -> T { return *b.c; }\n fn main() {\n     let foo: int = 17;\n     let bfoo: box<int> = {c: @foo};\n-    debug!{\"see what's in our box\"};\n+    debug!(\"see what's in our box\");\n     assert (unbox::<int>(bfoo) == foo);\n }"}, {"sha": "ca181c07bd50d1512058d58c92f9c0623c66a4b5", "filename": "src/test/run-pass/by-val-and-by-move.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fby-val-and-by-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fby-val-and-by-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fby-val-and-by-move.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -3,7 +3,7 @@\n \n fn it_takes_two(x: @int, -y: @int) -> int {\n     free(y);\n-    debug!{\"about to deref\"};\n+    debug!(\"about to deref\");\n     *x\n }\n "}, {"sha": "0a261e8a38f42636e23c9b882267c381b09170ca", "filename": "src/test/run-pass/cast-region-to-uint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fcast-region-to-uint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fcast-region-to-uint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcast-region-to-uint.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -1,4 +1,4 @@\n fn main() {\n     let x = 3;\n-    debug!{\"&x=%x\", ptr::to_uint(&x)};\n+    debug!(\"&x=%x\", ptr::to_uint(&x));\n }\n\\ No newline at end of file"}, {"sha": "aeeb80f10ccce0d5083eb22aba6998b71cd1f76f", "filename": "src/test/run-pass/cci_borrow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fcci_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fcci_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcci_borrow.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -7,6 +7,6 @@ import cci_borrow_lib::foo;\n fn main() {\n     let p = @22u;\n     let r = foo(p);\n-    debug!{\"r=%u\", r};\n+    debug!(\"r=%u\", r);\n     assert r == 22u;\n }"}, {"sha": "764208a6608698b5fd72911921d09199e9a3ce65", "filename": "src/test/run-pass/cci_impl_exe.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fcci_impl_exe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fcci_impl_exe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcci_impl_exe.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -6,13 +6,13 @@ import cci_impl_lib::uint_helpers;\n \n fn main() {\n     //let bt0 = sys::frame_address();\n-    //debug!{\"%?\", bt0};\n+    //debug!(\"%?\", bt0);\n \n     do 3u.to(10u) |i| {\n-        io::print(fmt!{\"%u\\n\", i});\n+        io::print(fmt!(\"%u\\n\", i));\n \n         //let bt1 = sys::frame_address();\n-        //debug!{\"%?\", bt1};\n+        //debug!(\"%?\", bt1);\n         //assert bt0 == bt1;\n     }\n }"}, {"sha": "48cdf2132691b67db30a87c91c30b1d8265101d7", "filename": "src/test/run-pass/cci_iter_exe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fcci_iter_exe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fcci_iter_exe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcci_iter_exe.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -5,9 +5,9 @@ use cci_iter_lib;\n \n fn main() {\n     //let bt0 = sys::rusti::frame_address(1u32);\n-    //debug!{\"%?\", bt0};\n+    //debug!(\"%?\", bt0);\n     do cci_iter_lib::iter(~[1, 2, 3]) |i| {\n-        io::print(fmt!{\"%d\", i});\n+        io::print(fmt!(\"%d\", i));\n         //assert bt0 == sys::rusti::frame_address(2u32);\n     }\n }"}, {"sha": "a29710eff85c7188b176b59683c16632259bfd34", "filename": "src/test/run-pass/cci_no_inline_exe.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fcci_no_inline_exe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fcci_no_inline_exe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcci_no_inline_exe.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -11,12 +11,12 @@ fn main() {\n     // sys::frame_address() to determine if we are inlining is\n     // actually working.\n     //let bt0 = sys::frame_address();\n-    //debug!{\"%?\", bt0};\n+    //debug!(\"%?\", bt0);\n     do iter(~[1u, 2u, 3u]) |i| {\n-        io::print(fmt!{\"%u\\n\", i});\n+        io::print(fmt!(\"%u\\n\", i));\n \n         //let bt1 = sys::frame_address();\n-        //debug!{\"%?\", bt1};\n+        //debug!(\"%?\", bt1);\n \n         //assert bt0 != bt1;\n     }"}, {"sha": "edc582cb0068bf27571d963c9058b8ca2eb205ee", "filename": "src/test/run-pass/class-attributes-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fclass-attributes-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fclass-attributes-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-attributes-1.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -4,7 +4,7 @@ struct cat {\n     #[cat_maker]\n     new(name: ~str) { self.name = name; }\n     #[cat_dropper]\n-    drop { error! {\"%s landed on hir feet\",self.name }; }\n+    drop { error!(\"%s landed on hir feet\",self.name); }\n     name: ~str;\n }\n "}, {"sha": "772aea9867bc50153c90477ea9c9712c8593a52a", "filename": "src/test/run-pass/class-attributes-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fclass-attributes-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fclass-attributes-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-attributes-2.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -9,7 +9,7 @@ struct cat {\n   /**\n      Actually, cats don't always land on their feet when you drop them.\n   */\n-  drop { error!{\"%s landed on hir feet\", self.name}; }\n+  drop { error!(\"%s landed on hir feet\", self.name); }\n }\n \n fn main() {"}, {"sha": "9206d89394d59c1b60b3c572ff77b9fcc59f243a", "filename": "src/test/run-pass/class-cast-to-trait-cross-crate-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-cross-crate-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-cross-crate-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-cross-crate-2.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -6,7 +6,7 @@ import cci_class_cast::kitty::*;\n \n fn print_out<T: ToStr>(thing: T, expected: ~str) {\n   let actual = thing.to_str();\n-  debug!{\"%s\", actual};\n+  debug!(\"%s\", actual);\n   assert(actual == expected);\n }\n "}, {"sha": "a10733c79d9b52ff6d33ba3e7a0a1bdf15c20ad2", "filename": "src/test/run-pass/class-cast-to-trait-cross-crate.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-cross-crate.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -7,7 +7,7 @@ class cat : to_str {\n   priv {\n     let mut meows : uint;\n     fn meow() {\n-      error!{\"Meow\"};\n+      error!(\"Meow\");\n       self.meows += 1u;\n       if self.meows % 5u == 0u {\n           self.how_hungry += 1;\n@@ -25,12 +25,12 @@ class cat : to_str {\n \n   fn eat() -> bool {\n     if self.how_hungry > 0 {\n-        error!{\"OM NOM NOM\"};\n+        error!(\"OM NOM NOM\");\n         self.how_hungry -= 2;\n         return true;\n     }\n     else {\n-        error!{\"Not hungry!\"};\n+        error!(\"Not hungry!\");\n         return false;\n     }\n   }\n@@ -40,7 +40,7 @@ class cat : to_str {\n \n fn print_out<T: to_str>(thing: T, expected: str) {\n   let actual = thing.to_str();\n-  debug!{\"%s\", actual};\n+  debug!(\"%s\", actual);\n   assert(actual == expected);\n }\n "}, {"sha": "28d96f64be960a9546be12f910563684733d6558", "filename": "src/test/run-pass/class-cast-to-trait-multiple-types.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-multiple-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-multiple-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-multiple-types.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -6,15 +6,15 @@ struct dog : noisy {\n   priv {\n     let barks : @mut uint;\n     fn bark() -> int {\n-      debug!{\"Woof %u %d\", *self.barks, *self.volume};\n+      debug!(\"Woof %u %d\", *self.barks, *self.volume);\n       *self.barks += 1u;\n       if *self.barks % 3u == 0u {\n           *self.volume += 1;\n       }\n       if *self.barks % 10u == 0u {\n           *self.volume -= 2;\n       }\n-      debug!{\"Grrr %u %d\", *self.barks, *self.volume};\n+      debug!(\"Grrr %u %d\", *self.barks, *self.volume);\n       *self.volume\n     }\n   }\n@@ -30,7 +30,7 @@ struct cat : noisy {\n   priv {\n     let meows : @mut uint;\n     fn meow() -> uint {\n-      debug!{\"Meow\"};\n+      debug!(\"Meow\");\n       *self.meows += 1u;\n       if *self.meows % 5u == 0u {\n           *self.how_hungry += 1;"}, {"sha": "3126824c18439ff35a7dd426d7bf1fb36404cbb8", "filename": "src/test/run-pass/class-cast-to-trait.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -6,7 +6,7 @@ struct cat : noisy {\n   priv {\n     let mut meows : uint;\n     fn meow() {\n-      error!{\"Meow\"};\n+      error!(\"Meow\");\n       self.meows += 1u;\n       if self.meows % 5u == 0u {\n           self.how_hungry += 1;\n@@ -24,12 +24,12 @@ struct cat : noisy {\n \n   fn eat() -> bool {\n     if self.how_hungry > 0 {\n-        error!{\"OM NOM NOM\"};\n+        error!(\"OM NOM NOM\");\n         self.how_hungry -= 2;\n         return true;\n     }\n     else {\n-        error!{\"Not hungry!\"};\n+        error!(\"Not hungry!\");\n         return false;\n     }\n   }"}, {"sha": "91b5886265a5f4549b0b6b79af0361839389b4d2", "filename": "src/test/run-pass/class-impl-parameterized-trait.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fclass-impl-parameterized-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fclass-impl-parameterized-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-impl-parameterized-trait.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -10,7 +10,7 @@ class cat : map<int, bool> {\n     let mut meows : int;\n     fn meow() {\n       self.meows += 1;\n-      error!{\"Meow %d\", self.meows};\n+      error!(\"Meow %d\", self.meows);\n       if self.meows % 5 == 0 {\n           self.how_hungry += 1;\n       }\n@@ -27,12 +27,12 @@ class cat : map<int, bool> {\n \n   fn eat() -> bool {\n     if self.how_hungry > 0 {\n-        error!{\"OM NOM NOM\"};\n+        error!(\"OM NOM NOM\");\n         self.how_hungry -= 2;\n         return true;\n     }\n     else {\n-        error!{\"Not hungry!\"};\n+        error!(\"Not hungry!\");\n         return false;\n     }\n   }"}, {"sha": "f24b19882277f556aefb355479b6661ec973b517", "filename": "src/test/run-pass/class-impl-very-parameterized-trait.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -13,7 +13,7 @@ struct cat<T: copy> : map<int, T> {\n     let mut meows : int;\n     fn meow() {\n       self.meows += 1;\n-      error!{\"Meow %d\", self.meows};\n+      error!(\"Meow %d\", self.meows);\n       if self.meows % 5 == 0 {\n           self.how_hungry += 1;\n       }\n@@ -30,12 +30,12 @@ struct cat<T: copy> : map<int, T> {\n \n   fn eat() -> bool {\n     if self.how_hungry > 0 {\n-        error!{\"OM NOM NOM\"};\n+        error!(\"OM NOM NOM\");\n         self.how_hungry -= 2;\n         return true;\n     }\n     else {\n-        error!{\"Not hungry!\"};\n+        error!(\"Not hungry!\");\n         return false;\n     }\n   }"}, {"sha": "c1eb20c9d30da44650213f855133163d2aa1dda9", "filename": "src/test/run-pass/class-implement-trait-cross-crate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fclass-implement-trait-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fclass-implement-trait-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-implement-trait-cross-crate.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -7,7 +7,7 @@ struct cat : noisy {\n   priv {\n     let mut meows : uint;\n     fn meow() {\n-      error!{\"Meow\"};\n+      error!(\"Meow\");\n       self.meows += 1u;\n       if self.meows % 5u == 0u {\n           self.how_hungry += 1;\n@@ -25,12 +25,12 @@ struct cat : noisy {\n \n   fn eat() -> bool {\n     if self.how_hungry > 0 {\n-        error!{\"OM NOM NOM\"};\n+        error!(\"OM NOM NOM\");\n         self.how_hungry -= 2;\n         return true;\n     }\n     else {\n-        error!{\"Not hungry!\"};\n+        error!(\"Not hungry!\");\n         return false;\n     }\n   }"}, {"sha": "4eead77e8059501a3cba8f4f6240e57fe3e632cc", "filename": "src/test/run-pass/class-implement-traits.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fclass-implement-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fclass-implement-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-implement-traits.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -6,7 +6,7 @@ struct cat : noisy {\n   priv {\n     let mut meows : uint;\n     fn meow() {\n-      error!{\"Meow\"};\n+      error!(\"Meow\");\n       self.meows += 1u;\n       if self.meows % 5u == 0u {\n           self.how_hungry += 1;\n@@ -24,12 +24,12 @@ struct cat : noisy {\n \n   fn eat() -> bool {\n     if self.how_hungry > 0 {\n-        error!{\"OM NOM NOM\"};\n+        error!(\"OM NOM NOM\");\n         self.how_hungry -= 2;\n         return true;\n     }\n     else {\n-        error!{\"Not hungry!\"};\n+        error!(\"Not hungry!\");\n         return false;\n     }\n   }"}, {"sha": "3af94a4094896142ec19036a2044d5a1cf59bda8", "filename": "src/test/run-pass/class-implements-multiple-traits.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fclass-implements-multiple-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fclass-implements-multiple-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-implements-multiple-traits.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -33,7 +33,7 @@ class cat : noisy, scratchy, bitey {\n     let bite_counts : hashmap<body_part, uint>;\n \n     fn meow() -> uint {\n-      debug!{\"Meow: %u\", *self.meows};\n+      debug!(\"Meow: %u\", *self.meows);\n       *self.meows += 1u;\n       if *self.meows % 5u == 0u {\n           *self.how_hungry += 1;\n@@ -72,32 +72,32 @@ class cat : noisy, scratchy, bitey {\n     rslt\n   }\n   fn bite() -> body_part {\n-    error!{\"In bite()\"};\n+    error!(\"In bite()\");\n     let all = ~[toe, nose, ear];\n     let mut min = finger;\n     do iter(all) |next| {\n-      debug!{\"min = %?\", min};\n+      debug!(\"min = %?\", min);\n         if self.bite_counts.get(next) < self.bite_counts.get(min) {\n             min = next;\n           }};\n     self.bite_counts.insert(min, self.bite_counts.get(min) + 1u);\n-    debug!{\"Bit %?\", min};\n+    debug!(\"Bit %?\", min);\n     min\n   }\n }\n \n fn annoy_neighbors<T: noisy>(critter: T) {\n   for uint::range(0u, 10u) |i| {\n       let what = critter.speak();\n-      debug!{\"%u %d\", i, what};\n+      debug!(\"%u %d\", i, what);\n   }\n }\n \n fn bite_everything<T: bitey>(critter: T) -> bool {\n   let mut left : ~[body_part] = ~[finger, toe, nose, ear];\n   while vec::len(left) > 0u {\n     let part = critter.bite();\n-    debug!{\"%? %?\", left, part};\n+    debug!(\"%? %?\", left, part);\n     if vec_includes(left, part) {\n         left = vec::filter(left, |p| p != part );\n     }"}, {"sha": "b70b55cc10352ee8d84b97b7c215bc56355d8cc3", "filename": "src/test/run-pass/class-separate-impl.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fclass-separate-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fclass-separate-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-separate-impl.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -6,7 +6,7 @@ struct cat {\n   priv {\n     let mut meows : uint;\n     fn meow() {\n-      error!{\"Meow\"};\n+      error!(\"Meow\");\n       self.meows += 1u;\n       if self.meows % 5u == 0u {\n           self.how_hungry += 1;\n@@ -24,12 +24,12 @@ struct cat {\n \n   fn eat() -> bool {\n     if self.how_hungry > 0 {\n-        error!{\"OM NOM NOM\"};\n+        error!(\"OM NOM NOM\");\n         self.how_hungry -= 2;\n         return true;\n     }\n     else {\n-        error!{\"Not hungry!\"};\n+        error!(\"Not hungry!\");\n         return false;\n     }\n   }\n@@ -41,7 +41,7 @@ impl cat: ToStr {\n \n fn print_out<T: ToStr>(thing: T, expected: ~str) {\n   let actual = thing.to_str();\n-  debug!{\"%s\", actual};\n+  debug!(\"%s\", actual);\n   assert(actual == expected);\n }\n "}, {"sha": "3f0d9ad311ccea23e05b711ff275a519e92136b0", "filename": "src/test/run-pass/classes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fclasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fclasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclasses.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -2,7 +2,7 @@ struct cat {\n   priv {\n     let mut meows : uint;\n     fn meow() {\n-      error!{\"Meow\"};\n+      error!(\"Meow\");\n       self.meows += 1u;\n       if self.meows % 5u == 0u {\n           self.how_hungry += 1;\n@@ -20,12 +20,12 @@ struct cat {\n \n   fn eat() -> bool {\n     if self.how_hungry > 0 {\n-        error!{\"OM NOM NOM\"};\n+        error!(\"OM NOM NOM\");\n         self.how_hungry -= 2;\n         return true;\n     }\n     else {\n-        error!{\"Not hungry!\"};\n+        error!(\"Not hungry!\");\n         return false;\n     }\n   }"}, {"sha": "ed0388b2bcec670b5189ceb95336a3426540592f", "filename": "src/test/run-pass/close-over-big-then-small-data.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fclose-over-big-then-small-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fclose-over-big-then-small-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclose-over-big-then-small-data.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -12,7 +12,7 @@ fn f<A:copy owned>(a: A, b: u16) -> fn@() -> (A, u16) {\n \n fn main() {\n     let (a, b) = f(22_u64, 44u16)();\n-    debug!{\"a=%? b=%?\", a, b};\n+    debug!(\"a=%? b=%?\", a, b);\n     assert a == 22u64;\n     assert b == 44u16;\n }"}, {"sha": "833552ccbf8b9924576a4da7eebec1d8958eb767", "filename": "src/test/run-pass/comm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcomm.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -13,13 +13,13 @@ fn main() {\n     let ch = comm::chan(p);\n     let t = task::spawn(|| child(ch) );\n     let y = recv(p);\n-    error!{\"received\"};\n+    error!(\"received\");\n     log(error, y);\n     assert (y == 10);\n }\n \n fn child(c: Chan<int>) {\n-    error!{\"sending\"};\n+    error!(\"sending\");\n     send(c, 10);\n-    error!{\"value sent\"};\n+    error!(\"value sent\");\n }"}, {"sha": "6ccc7b879b37611f84c7b5534a33cd90b3f3c391", "filename": "src/test/run-pass/complex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fcomplex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fcomplex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcomplex.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -28,6 +28,6 @@ fn foo(x: int) -> int {\n fn main() {\n     let x: int = 2 + 2;\n     log(debug, x);\n-    debug!{\"hello, world\"};\n+    debug!(\"hello, world\");\n     log(debug, 10);\n }"}, {"sha": "c62e0b79d7cb25dcc713512b66cc4894d66afc3a", "filename": "src/test/run-pass/const-rec-and-tup.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fconst-rec-and-tup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fconst-rec-and-tup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-rec-and-tup.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -9,5 +9,5 @@ const y : { x: (i64, i64),\n fn main() {\n     let (p, _) = y.x;\n     assert p == 0xf0f0f0f0_f0f0f0f0;\n-    io::println(fmt!{\"0x%x\", p as uint});\n+    io::println(fmt!(\"0x%x\", p as uint));\n }"}, {"sha": "07d3357a947cf2abd7e6d1fecb0a9899d4471e69", "filename": "src/test/run-pass/const-struct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fconst-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fconst-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-struct.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -9,6 +9,6 @@ fn main() {\n     assert x.b == 2;\n     assert x == y;\n     assert z.b == 22;\n-    io::println(fmt!{\"0x%x\", x.b as uint});\n-    io::println(fmt!{\"0x%x\", z.c as uint});\n+    io::println(fmt!(\"0x%x\", x.b as uint));\n+    io::println(fmt!(\"0x%x\", z.c as uint));\n }"}, {"sha": "46c7edc63a497f232163a36444a1926b5765932f", "filename": "src/test/run-pass/dead-code-one-arm-if.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fdead-code-one-arm-if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fdead-code-one-arm-if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdead-code-one-arm-if.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -2,4 +2,4 @@\n \n \n // -*- rust -*-\n-fn main() { if 1 == 1 { return; } debug!{\"Paul is dead\"}; }\n+fn main() { if 1 == 1 { return; } debug!(\"Paul is dead\"); }"}, {"sha": "206f8f239e0e65fc902d819ba0f1662dc6907676", "filename": "src/test/run-pass/export-non-interference2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fexport-non-interference2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fexport-non-interference2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexport-non-interference2.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -6,7 +6,7 @@ mod foo {\n         fn y() { x(); }\n     }\n \n-    fn x() { debug!{\"x\"}; }\n+    fn x() { debug!(\"x\"); }\n }\n \n fn main() { foo::bar::y(); }"}, {"sha": "41cc6bd7d23fbf975770feb1403fb1739a260818", "filename": "src/test/run-pass/export-non-interference3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fexport-non-interference3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fexport-non-interference3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexport-non-interference3.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -7,7 +7,7 @@ mod foo {\n mod bar {\n     export x;\n \n-    fn x() { debug!{\"x\"}; }\n+    fn x() { debug!(\"x\"); }\n }\n \n fn main() { foo::x(); }"}, {"sha": "05404032a73f3b41c3a6efce798b8728b88ffe4b", "filename": "src/test/run-pass/extern-call-deep.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fextern-call-deep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fextern-call-deep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-call-deep.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -12,12 +12,12 @@ extern fn cb(data: libc::uintptr_t) -> libc::uintptr_t {\n }\n \n fn count(n: uint) -> uint {\n-    debug!{\"n = %?\", n};\n+    debug!(\"n = %?\", n);\n     rustrt::rust_dbg_call(cb, n)\n }\n \n fn main() {\n     let result = count(1000u);\n-    debug!{\"result = %?\", result};\n+    debug!(\"result = %?\", result);\n     assert result == 1000u;\n }\n\\ No newline at end of file"}, {"sha": "23a34a45d8d62135893bcb70105568e3cee14d0c", "filename": "src/test/run-pass/extern-call-deep2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fextern-call-deep2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fextern-call-deep2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-call-deep2.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -12,7 +12,7 @@ extern fn cb(data: libc::uintptr_t) -> libc::uintptr_t {\n }\n \n fn count(n: uint) -> uint {\n-    debug!{\"n = %?\", n};\n+    debug!(\"n = %?\", n);\n     rustrt::rust_dbg_call(cb, n)\n }\n \n@@ -21,7 +21,7 @@ fn main() {\n     // has a large stack)\n     do task::spawn {\n         let result = count(1000u);\n-        debug!{\"result = %?\", result};\n+        debug!(\"result = %?\", result);\n         assert result == 1000u;\n     };\n }\n\\ No newline at end of file"}, {"sha": "49e55cca1c80030f56c465afe1c5b1573fcf9cb9", "filename": "src/test/run-pass/extern-call-scrub.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fextern-call-scrub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fextern-call-scrub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-call-scrub.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -16,7 +16,7 @@ extern fn cb(data: libc::uintptr_t) -> libc::uintptr_t {\n }\n \n fn count(n: uint) -> uint {\n-    debug!{\"n = %?\", n};\n+    debug!(\"n = %?\", n);\n     rustrt::rust_dbg_call(cb, n)\n }\n \n@@ -25,7 +25,7 @@ fn main() {\n     // has a large stack)\n     do task::spawn {\n         let result = count(12u);\n-        debug!{\"result = %?\", result};\n+        debug!(\"result = %?\", result);\n         assert result == 2048u;\n     };\n }\n\\ No newline at end of file"}, {"sha": "6f8cfc288603e91b21a541d31254a72a07c08a54", "filename": "src/test/run-pass/extern-call.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fextern-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fextern-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-call.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -12,12 +12,12 @@ extern fn cb(data: libc::uintptr_t) -> libc::uintptr_t {\n }\n \n fn fact(n: uint) -> uint {\n-    debug!{\"n = %?\", n};\n+    debug!(\"n = %?\", n);\n     rustrt::rust_dbg_call(cb, n)\n }\n \n fn main() {\n     let result = fact(10u);\n-    debug!{\"result = %?\", result};\n+    debug!(\"result = %?\", result);\n     assert result == 3628800u;\n }\n\\ No newline at end of file"}, {"sha": "34da3e33e6fd25fc98be8160f777b1086765dd93", "filename": "src/test/run-pass/extern-crosscrate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fextern-crosscrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fextern-crosscrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-crosscrate.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -4,12 +4,12 @@\n use externcallback(vers = \"0.1\");\n \n fn fact(n: uint) -> uint {\n-    debug!{\"n = %?\", n};\n+    debug!(\"n = %?\", n);\n     externcallback::rustrt::rust_dbg_call(externcallback::cb, n)\n }\n \n fn main() {\n     let result = fact(10u);\n-    debug!{\"result = %?\", result};\n+    debug!(\"result = %?\", result);\n     assert result == 3628800u;\n }"}, {"sha": "eff78a6f0ad1bbc04d00dfbfff71187baaefecaf", "filename": "src/test/run-pass/extern-yield.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fextern-yield.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fextern-yield.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-yield.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -20,7 +20,7 @@ fn main() {\n     for iter::repeat(10u) {\n         do task::spawn {\n             let result = count(5u);\n-            debug!{\"result = %?\", result};\n+            debug!(\"result = %?\", result);\n             assert result == 16u;\n         };\n     }"}, {"sha": "4d55badaad8d8cdb2b0fca32ed70582e721cb278", "filename": "src/test/run-pass/fact.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Ffact.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Ffact.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffact.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -3,18 +3,18 @@\n \n // -*- rust -*-\n fn f(x: int) -> int {\n-    // debug!{\"in f:\"};\n+    // debug!(\"in f:\");\n \n     log(debug, x);\n     if x == 1 {\n-        // debug!{\"bottoming out\"};\n+        // debug!(\"bottoming out\");\n \n         return 1;\n     } else {\n-        // debug!{\"recurring\"};\n+        // debug!(\"recurring\");\n \n         let y: int = x * f(x - 1);\n-        // debug!{\"returned\"};\n+        // debug!(\"returned\");\n \n         log(debug, y);\n         return y;\n@@ -23,6 +23,6 @@ fn f(x: int) -> int {\n \n fn main() {\n     assert (f(5) == 120);\n-    // debug!{\"all done\"};\n+    // debug!(\"all done\");\n \n }"}, {"sha": "d71fd80d0abcd8a29bba81808637ac5431d6f7c8", "filename": "src/test/run-pass/float.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffloat.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -5,6 +5,6 @@ fn main() {\n     log(debug, -pi * (pi + 2.0 / pi) - pi * 5.0);\n     if pi == 5.0 || pi < 10.0 || pi <= 2.0 || pi != 22.0 / 7.0 || pi >= 10.0\n            || pi > 1.0 {\n-        debug!{\"yes\"};\n+        debug!(\"yes\");\n     }\n }"}, {"sha": "e9cdfd224c579d1c269087c180f3aaf80a4e9348", "filename": "src/test/run-pass/fn-bare-item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Ffn-bare-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Ffn-bare-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffn-bare-item.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -1,5 +1,5 @@\n fn f() {\n-    debug!{\"This is a bare function\"};\n+    debug!(\"This is a bare function\");\n }\n \n fn main() {"}, {"sha": "e0e62599145b8a666c48afaf5be486ca628c4330", "filename": "src/test/run-pass/foreach-simple-outer-slot.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fforeach-simple-outer-slot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fforeach-simple-outer-slot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-simple-outer-slot.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -4,13 +4,13 @@\n // -*- rust -*-\n fn main() {\n     let mut sum: int = 0;\n-    do first_ten |i| { debug!{\"main\"}; log(debug, i); sum = sum + i; }\n-    debug!{\"sum\"};\n+    do first_ten |i| { debug!(\"main\"); log(debug, i); sum = sum + i; }\n+    debug!(\"sum\");\n     log(debug, sum);\n     assert (sum == 45);\n }\n \n fn first_ten(it: fn(int)) {\n     let mut i: int = 0;\n-    while i < 10 { debug!{\"first_ten\"}; it(i); i = i + 1; }\n+    while i < 10 { debug!(\"first_ten\"); it(i); i = i + 1; }\n }"}, {"sha": "3b1432258770494b58cc562a52d2f81bdaf329b5", "filename": "src/test/run-pass/generic-tag-alt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fgeneric-tag-alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fgeneric-tag-alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-tag-alt.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -4,7 +4,7 @@ enum foo<T> { arm(T), }\n \n fn altfoo<T>(f: foo<T>) {\n     let mut hit = false;\n-    match f { arm::<T>(x) => { debug!{\"in arm\"}; hit = true; } }\n+    match f { arm::<T>(x) => { debug!(\"in arm\"); hit = true; } }\n     assert (hit);\n }\n "}, {"sha": "015feb47e513dfbf5495e3fc91f309da6a3484c2", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -50,9 +50,9 @@ mod map_reduce {\n               some(_c) => { c = _c }\n               none => {\n                 let p = port();\n-                error!{\"sending find_reducer\"};\n+                error!(\"sending find_reducer\");\n                 send(ctrl, find_reducer(str::bytes(key), chan(p)));\n-                error!{\"receiving\"};\n+                error!(\"receiving\");\n                 c = recv(p);\n                 log(error, c);\n                 im.insert(key, c);"}, {"sha": "5f61c554992d9c13fde2d928f20ab6c0d7c1f7cf", "filename": "src/test/run-pass/hello.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fhello.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fhello.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhello.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -2,4 +2,4 @@\n \n \n // -*- rust -*-\n-fn main() { debug!{\"hello, world.\"}; }\n+fn main() { debug!(\"hello, world.\"); }"}, {"sha": "5e935ab17dc670f2236c137add55fcbea3f323ee", "filename": "src/test/run-pass/html-literals.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fhtml-literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fhtml-literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhtml-literals.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -75,14 +75,14 @@ macro_rules! parse_node {\n }\n \n fn main() {\n-    let page = html! {\n+    let page = html! (\n         <html>\n             <head><title>This is the title.</title></head>\n             <body>\n             <p>This is some text</p>\n             </body>\n         </html>\n-    };\n+    );\n }\n \n enum HTMLFragment {"}, {"sha": "39abe0c80823c2f685107ba9486407c355444e88", "filename": "src/test/run-pass/import-glob-0.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fimport-glob-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fimport-glob-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimport-glob-0.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -5,10 +5,10 @@ mod module_of_many_things {\n     export f1;\n     export f2;\n     export f4;\n-    fn f1() { debug!{\"f1\"}; }\n-    fn f2() { debug!{\"f2\"}; }\n-    fn f3() { debug!{\"f3\"}; }\n-    fn f4() { debug!{\"f4\"}; }\n+    fn f1() { debug!(\"f1\"); }\n+    fn f2() { debug!(\"f2\"); }\n+    fn f3() { debug!(\"f3\"); }\n+    fn f4() { debug!(\"f4\"); }\n }\n \n mod dug {\n@@ -17,8 +17,8 @@ mod dug {\n             mod and {\n                 mod too {\n                     mod deep {\n-                        fn nameless_fear() { debug!{\"Boo!\"}; }\n-                        fn also_redstone() { debug!{\"Whatever.\"}; }\n+                        fn nameless_fear() { debug!(\"Boo!\"); }\n+                        fn also_redstone() { debug!(\"Whatever.\"); }\n                     }\n                 }\n             }"}, {"sha": "09e84cf721623a4740b5a8c177069d54212f14c2", "filename": "src/test/run-pass/import-glob-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fimport-glob-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fimport-glob-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimport-glob-1.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -32,7 +32,7 @@ mod a2 {\n     mod b2 {\n         //   |\n         fn word_traveler() { //   |\n-            debug!{\"ahoy!\"}; //  -/\n+            debug!(\"ahoy!\"); //  -/\n         } //\n     } //\n }"}, {"sha": "6b4596e2b44162eeaf46f227b543a5de2ed06e61", "filename": "src/test/run-pass/import2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fimport2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fimport2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimport2.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -2,7 +2,7 @@\n import zed::bar;\n \n mod zed {\n-    fn bar() { debug!{\"bar\"}; }\n+    fn bar() { debug!(\"bar\"); }\n }\n \n fn main() { bar(); }"}, {"sha": "6b6402cd2dca78b262ba12d8f49b7a4332948335", "filename": "src/test/run-pass/import3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fimport3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f32b4a7298b0807408658bc8add1de8a06ab12/src%2Ftest%2Frun-pass%2Fimport3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimport3.rs?ref=29f32b4a7298b0807408658bc8add1de8a06ab12", "patch": "@@ -4,7 +4,7 @@ import zed::bar;\n \n mod baz {\n     mod zed {\n-        fn bar() { debug!{\"bar2\"}; }\n+        fn bar() { debug!(\"bar2\"); }\n     }\n }\n "}]}