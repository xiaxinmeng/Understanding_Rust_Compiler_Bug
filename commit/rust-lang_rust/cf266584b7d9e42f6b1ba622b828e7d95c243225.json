{"sha": "cf266584b7d9e42f6b1ba622b828e7d95c243225", "node_id": "C_kwDOAAsO6NoAKGNmMjY2NTg0YjdkOWU0MmY2YjFiYTYyMmI4MjhlN2Q5NWMyNDMyMjU", "commit": {"author": {"name": "Andy Wang", "email": "cbeuw.andy@gmail.com", "date": "2022-04-16T00:01:49Z"}, "committer": {"name": "Andy Wang", "email": "cbeuw.andy@gmail.com", "date": "2022-06-06T18:15:21Z"}, "message": "Comment out and provide context to C++20 test", "tree": {"sha": "404ae97e24aec19607f2bd8481a7bbf90da44c02", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/404ae97e24aec19607f2bd8481a7bbf90da44c02"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf266584b7d9e42f6b1ba622b828e7d95c243225", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE7dcbcBMl24/h63ldGBtJ+fOPM3QFAmKeRDkACgkQGBtJ+fOP\nM3S2Bwv9Gjh9WrK92sfSfLbj1X7EqKX1wkiDrDziSrejWVkPX/2tCvkXiTCtnpXl\ntEI1ecVE7TTiB7oWp2wChCoRPjBmX3+RsGQAu+DM+D8Yjt44Kw8CMbNHDSnFWgrp\nSJMkbDPjRajxfLi6QfTtX8DOnu0WWGL5fJPVuLKsTpurj4LZOYnbQDfQaJm/JCz6\nw5W0uFAXhbgGXP2YLAJR5a+tuulW79lD19zq6J4VzD2xwJRbnrrCrOS3e8JYcJTq\nKppEbk/Ow3RvdUe4WMPdh2ztX/q+oRGJNZsi1zjoXvgrgiFxxPwJ06xgsYIMA6E2\n7jcY8VObCcdDaDXf1GG/D+g1vV8Br6D/uXZVclwzZC0H3KmL8rqq8oGy1gc+CHRY\n8J41U7qVhAQcM6vyPGSkmmXZBJVahJmY2jcDpbfcJpzcVQLr8l9e2BJphc9payCO\n/CzhIcWqV6Pg2L/c+rsoJsli6XrgX8IvuV5H6A/xMh9tLTERL1P2MGpAL+e/NY6d\nMZvh3pct\n=5S8r\n-----END PGP SIGNATURE-----", "payload": "tree 404ae97e24aec19607f2bd8481a7bbf90da44c02\nparent aca3b3a645e6d0295e9f1829c37af811a6de5251\nauthor Andy Wang <cbeuw.andy@gmail.com> 1650067309 +0100\ncommitter Andy Wang <cbeuw.andy@gmail.com> 1654539321 +0100\n\nComment out and provide context to C++20 test\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf266584b7d9e42f6b1ba622b828e7d95c243225", "html_url": "https://github.com/rust-lang/rust/commit/cf266584b7d9e42f6b1ba622b828e7d95c243225", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf266584b7d9e42f6b1ba622b828e7d95c243225/comments", "author": {"login": "cbeuw", "id": 7034308, "node_id": "MDQ6VXNlcjcwMzQzMDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7034308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cbeuw", "html_url": "https://github.com/cbeuw", "followers_url": "https://api.github.com/users/cbeuw/followers", "following_url": "https://api.github.com/users/cbeuw/following{/other_user}", "gists_url": "https://api.github.com/users/cbeuw/gists{/gist_id}", "starred_url": "https://api.github.com/users/cbeuw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cbeuw/subscriptions", "organizations_url": "https://api.github.com/users/cbeuw/orgs", "repos_url": "https://api.github.com/users/cbeuw/repos", "events_url": "https://api.github.com/users/cbeuw/events{/privacy}", "received_events_url": "https://api.github.com/users/cbeuw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cbeuw", "id": 7034308, "node_id": "MDQ6VXNlcjcwMzQzMDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7034308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cbeuw", "html_url": "https://github.com/cbeuw", "followers_url": "https://api.github.com/users/cbeuw/followers", "following_url": "https://api.github.com/users/cbeuw/following{/other_user}", "gists_url": "https://api.github.com/users/cbeuw/gists{/gist_id}", "starred_url": "https://api.github.com/users/cbeuw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cbeuw/subscriptions", "organizations_url": "https://api.github.com/users/cbeuw/orgs", "repos_url": "https://api.github.com/users/cbeuw/repos", "events_url": "https://api.github.com/users/cbeuw/events{/privacy}", "received_events_url": "https://api.github.com/users/cbeuw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aca3b3a645e6d0295e9f1829c37af811a6de5251", "url": "https://api.github.com/repos/rust-lang/rust/commits/aca3b3a645e6d0295e9f1829c37af811a6de5251", "html_url": "https://github.com/rust-lang/rust/commit/aca3b3a645e6d0295e9f1829c37af811a6de5251"}], "stats": {"total": 144, "additions": 75, "deletions": 69}, "files": [{"sha": "efbbc45909cfd905600502f1f4599ffe993e9ead", "filename": "tests/run-pass/concurrency/weak_memory.rs", "status": "modified", "additions": 75, "deletions": 69, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/cf266584b7d9e42f6b1ba622b828e7d95c243225/tests%2Frun-pass%2Fconcurrency%2Fweak_memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf266584b7d9e42f6b1ba622b828e7d95c243225/tests%2Frun-pass%2Fconcurrency%2Fweak_memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconcurrency%2Fweak_memory.rs?ref=cf266584b7d9e42f6b1ba622b828e7d95c243225", "patch": "@@ -63,73 +63,6 @@ fn reads_value(loc: &AtomicUsize, val: usize) -> usize {\n     val\n }\n \n-// https://plv.mpi-sws.org/scfix/paper.pdf\n-// Test case SB\n-fn test_sc_store_buffering() {\n-    let x = static_atomic(0);\n-    let y = static_atomic(0);\n-\n-    let j1 = spawn(move || {\n-        x.store(1, SeqCst);\n-        y.load(SeqCst)\n-    });\n-\n-    let j2 = spawn(move || {\n-        y.store(1, SeqCst);\n-        x.load(SeqCst)\n-    });\n-\n-    let a = j1.join().unwrap();\n-    let b = j2.join().unwrap();\n-\n-    assert_ne!((a, b), (0, 0));\n-}\n-\n-// https://plv.mpi-sws.org/scfix/paper.pdf\n-// 2.2 Second Problem: SC Fences are Too Weak\n-fn test_rwc_syncs() {\n-    /*\n-    int main() {\n-        atomic_int x = 0;\n-        atomic_int y = 0;\n-\n-        {{{ x.store(1,mo_relaxed);\n-        ||| { r1=x.load(mo_relaxed).readsvalue(1);\n-              fence(mo_seq_cst);\n-              r2=y.load(mo_relaxed); }\n-        ||| { y.store(1,mo_relaxed);\n-              fence(mo_seq_cst);\n-              r3=x.load(mo_relaxed); }\n-        }}}\n-        return 0;\n-    }\n-    */\n-    let x = static_atomic(0);\n-    let y = static_atomic(0);\n-\n-    let j1 = spawn(move || {\n-        x.store(1, Relaxed);\n-    });\n-\n-    let j2 = spawn(move || {\n-        reads_value(&x, 1);\n-        fence(SeqCst);\n-        y.load(Relaxed)\n-    });\n-\n-    let j3 = spawn(move || {\n-        y.store(1, Relaxed);\n-        fence(SeqCst);\n-        x.load(Relaxed)\n-    });\n-\n-    j1.join().unwrap();\n-    let b = j2.join().unwrap();\n-    let c = j3.join().unwrap();\n-\n-    assert_ne!((b, c), (0, 0));\n-}\n-\n fn test_corr() {\n     let x = static_atomic(0);\n     let y = static_atomic(0);\n@@ -263,18 +196,91 @@ fn test_mixed_access() {\n     assert_eq!(r2, 2);\n }\n \n+// The following two tests are taken from Repairing Sequential Consistency in C/C++11\n+// by Lahav et al.\n+// https://plv.mpi-sws.org/scfix/paper.pdf\n+\n+// Test case SB\n+fn test_sc_store_buffering() {\n+    let x = static_atomic(0);\n+    let y = static_atomic(0);\n+\n+    let j1 = spawn(move || {\n+        x.store(1, SeqCst);\n+        y.load(SeqCst)\n+    });\n+\n+    let j2 = spawn(move || {\n+        y.store(1, SeqCst);\n+        x.load(SeqCst)\n+    });\n+\n+    let a = j1.join().unwrap();\n+    let b = j2.join().unwrap();\n+\n+    assert_ne!((a, b), (0, 0));\n+}\n+\n+// 2.2 Second Problem: SC Fences are Too Weak\n+// This test should pass under the C++20 model Rust is using.\n+// Unfortunately, Miri's weak memory emulation only follows C++11 model\n+// as we don't know how to correctly emulate C++20's revised SC semantics\n+#[allow(dead_code)]\n+fn test_cpp20_rwc_syncs() {\n+    /*\n+    int main() {\n+        atomic_int x = 0;\n+        atomic_int y = 0;\n+\n+        {{{ x.store(1,mo_relaxed);\n+        ||| { r1=x.load(mo_relaxed).readsvalue(1);\n+              fence(mo_seq_cst);\n+              r2=y.load(mo_relaxed); }\n+        ||| { y.store(1,mo_relaxed);\n+              fence(mo_seq_cst);\n+              r3=x.load(mo_relaxed); }\n+        }}}\n+        return 0;\n+    }\n+    */\n+    let x = static_atomic(0);\n+    let y = static_atomic(0);\n+\n+    let j1 = spawn(move || {\n+        x.store(1, Relaxed);\n+    });\n+\n+    let j2 = spawn(move || {\n+        reads_value(&x, 1);\n+        fence(SeqCst);\n+        y.load(Relaxed)\n+    });\n+\n+    let j3 = spawn(move || {\n+        y.store(1, Relaxed);\n+        fence(SeqCst);\n+        x.load(Relaxed)\n+    });\n+\n+    j1.join().unwrap();\n+    let b = j2.join().unwrap();\n+    let c = j3.join().unwrap();\n+\n+    assert_ne!((b, c), (0, 0));\n+}\n+\n pub fn main() {\n     // TODO: does this make chances of spurious success\n     // \"sufficiently low\"? This also takes a long time to run,\n     // prehaps each function should be its own test case so they\n     // can be run in parallel\n     for _ in 0..500 {\n-        test_sc_store_buffering();\n         test_mixed_access();\n         test_load_buffering_acq_rel();\n         test_message_passing();\n         test_wrc();\n         test_corr();\n-        test_rwc_syncs();\n+        test_sc_store_buffering();\n+        // test_cpp20_rwc_syncs();\n     }\n }"}]}