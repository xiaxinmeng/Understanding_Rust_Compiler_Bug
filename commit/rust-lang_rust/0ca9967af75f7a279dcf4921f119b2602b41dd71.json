{"sha": "0ca9967af75f7a279dcf4921f119b2602b41dd71", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjYTk5NjdhZjc1ZjdhMjc5ZGNmNDkyMWYxMTliMjYwMmI0MWRkNzE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-11-02T15:44:33Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-11-02T15:44:33Z"}, "message": "Auto merge of #36948 - brson:sys, r=brson\n\nMore refactoring to obey platform abstraction lint\n\nThe most interesting things here are moving `std/sys/common` to `std/sys_common`, and `std/num/{f32,f64}.rs` to `std/{f32,f64}.rs`, and adding more documentation to `std/lib.rs`.\n\nr? @alexcrichton", "tree": {"sha": "19cfc9cd4d8d59b95357fac17c868dd3a6dc07a2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/19cfc9cd4d8d59b95357fac17c868dd3a6dc07a2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0ca9967af75f7a279dcf4921f119b2602b41dd71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0ca9967af75f7a279dcf4921f119b2602b41dd71", "html_url": "https://github.com/rust-lang/rust/commit/0ca9967af75f7a279dcf4921f119b2602b41dd71", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0ca9967af75f7a279dcf4921f119b2602b41dd71/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "acfe959701ce221af37516401726be6d2814cc3f", "url": "https://api.github.com/repos/rust-lang/rust/commits/acfe959701ce221af37516401726be6d2814cc3f", "html_url": "https://github.com/rust-lang/rust/commit/acfe959701ce221af37516401726be6d2814cc3f"}, {"sha": "6135cbc9e2b9a7e62ae274cf57e9921f60f6ec73", "url": "https://api.github.com/repos/rust-lang/rust/commits/6135cbc9e2b9a7e62ae274cf57e9921f60f6ec73", "html_url": "https://github.com/rust-lang/rust/commit/6135cbc9e2b9a7e62ae274cf57e9921f60f6ec73"}], "stats": {"total": 654, "additions": 354, "deletions": 300}, "files": [{"sha": "7a676c041ad89084e72b2ea5325923f0e0fabf4b", "filename": "src/libstd/f32.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Flibstd%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Flibstd%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff32.rs?ref=0ca9967af75f7a279dcf4921f119b2602b41dd71", "previous_filename": "src/libstd/num/f32.rs"}, {"sha": "67a1c302483d20644bdd157def4bed445c47e6fa", "filename": "src/libstd/f64.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Flibstd%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Flibstd%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff64.rs?ref=0ca9967af75f7a279dcf4921f119b2602b41dd71", "previous_filename": "src/libstd/num/f64.rs"}, {"sha": "193f396c0d4ab3a3d6a0fb0bbab3401effba48a9", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=0ca9967af75f7a279dcf4921f119b2602b41dd71", "patch": "@@ -289,7 +289,7 @@ mod lazy;\n mod util;\n mod stdio;\n \n-const DEFAULT_BUF_SIZE: usize = 8 * 1024;\n+const DEFAULT_BUF_SIZE: usize = ::sys_common::io::DEFAULT_BUF_SIZE;\n \n // A few methods below (read_to_string, read_line) will append data into a\n // `String` buffer, but we need to be pretty careful when doing this. The"}, {"sha": "1777b79ea1b59b422ed23c5f35e3ac0db1c7d241", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=0ca9967af75f7a279dcf4921f119b2602b41dd71", "patch": "@@ -214,15 +214,7 @@ pub fn stdin() -> Stdin {\n             _ => Maybe::Fake\n         };\n \n-        // The default buffer capacity is 64k, but apparently windows\n-        // doesn't like 64k reads on stdin. See #13304 for details, but the\n-        // idea is that on windows we use a slightly smaller buffer that's\n-        // been seen to be acceptable.\n-        Arc::new(Mutex::new(if cfg!(windows) {\n-            BufReader::with_capacity(8 * 1024, stdin)\n-        } else {\n-            BufReader::new(stdin)\n-        }))\n+        Arc::new(Mutex::new(BufReader::with_capacity(stdio::STDIN_BUF_SIZE, stdin)))\n     }\n }\n "}, {"sha": "8d973fc1ade472924bc1eba43b09545558d24d3c", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 70, "deletions": 76, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=0ca9967af75f7a279dcf4921f119b2602b41dd71", "patch": "@@ -210,8 +210,27 @@\n        test(no_crate_inject, attr(deny(warnings))),\n        test(attr(allow(dead_code, deprecated, unused_variables, unused_mut))))]\n \n+// Don't link to std. We are std.\n+#![no_std]\n+\n+#![deny(missing_docs)]\n+\n+// Tell the compiler to link to either panic_abort or panic_unwind\n #![needs_panic_runtime]\n \n+// Always use alloc_system during stage0 since jemalloc might be unavailable or\n+// disabled (Issue #30592)\n+#![cfg_attr(stage0, feature(alloc_system))]\n+\n+// Turn warnings into errors, but only after stage0, where it can be useful for\n+// code to emit warnings during language transitions\n+#![cfg_attr(not(stage0), deny(warnings))]\n+\n+// std may use features in a platform-specific way\n+#![allow(unused_features)]\n+\n+// std is implemented with unstable features, many of which are internal\n+// compiler details that will never be stable\n #![feature(alloc)]\n #![feature(allow_internal_unstable)]\n #![feature(asm)]\n@@ -248,7 +267,6 @@\n #![feature(link_args)]\n #![feature(linkage)]\n #![feature(macro_reexport)]\n-#![cfg_attr(test, feature(map_values_mut))]\n #![feature(needs_panic_runtime)]\n #![feature(num_bits_bytes)]\n #![feature(old_wrapping)]\n@@ -284,21 +302,13 @@\n #![feature(zero_one)]\n #![cfg_attr(test, feature(update_panic_count))]\n \n-// Issue# 30592: Systematically use alloc_system during stage0 since jemalloc\n-// might be unavailable or disabled\n-#![cfg_attr(stage0, feature(alloc_system))]\n-\n-// Don't link to std. We are std.\n-#![no_std]\n-\n-#![deny(missing_docs)]\n-#![allow(unused_features)] // std may use features in a platform-specific way\n-#![cfg_attr(not(stage0), deny(warnings))]\n-\n+// Explicitly import the prelude. The compiler uses this same unstable attribute\n+// to import the prelude implicitly when building crates that depend on std.\n #[prelude_import]\n #[allow(unused)]\n use prelude::v1::*;\n \n+// Access to Bencher, etc.\n #[cfg(test)] extern crate test;\n \n // We want to reexport a few macros from core but libcore has already been\n@@ -326,11 +336,22 @@ extern crate alloc_system;\n // compiler-rt intrinsics\n extern crate compiler_builtins;\n \n-// Make std testable by not duplicating lang items and other globals. See #2912\n+// During testing, this crate is not actually the \"real\" std library, but rather\n+// it links to the real std library, which was compiled from this same source\n+// code. So any lang items std defines are conditionally excluded (or else they\n+// wolud generate duplicate lang item errors), and any globals it defines are\n+// _not_ the globals used by \"real\" std. So this import, defined only during\n+// testing gives test-std access to real-std lang items and globals. See #2912\n #[cfg(test)] extern crate std as realstd;\n \n-// NB: These reexports are in the order they should be listed in rustdoc\n+// The standard macros that are not built-in to the compiler.\n+#[macro_use]\n+mod macros;\n+\n+// The Rust prelude\n+pub mod prelude;\n \n+// Public module declarations and reexports\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::any;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -363,48 +384,6 @@ pub use core::raw;\n pub use core::result;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::option;\n-\n-pub mod error;\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use alloc::boxed;\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use alloc::rc;\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core_collections::borrow;\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core_collections::fmt;\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core_collections::slice;\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core_collections::str;\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core_collections::string;\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core_collections::vec;\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use rustc_unicode::char;\n-\n-/* Exported macros */\n-\n-#[macro_use]\n-mod macros;\n-\n-mod rtdeps;\n-\n-/* The Prelude. */\n-\n-pub mod prelude;\n-\n-\n-/* Primitive types */\n-\n-// NB: slice and str are primitive types too, but their module docs + primitive\n-// doc pages are inlined from the public re-exports of core_collections::{slice,\n-// str} above.\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::isize;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -415,7 +394,6 @@ pub use core::i16;\n pub use core::i32;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::i64;\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::usize;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -426,46 +404,62 @@ pub use core::u16;\n pub use core::u32;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::u64;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use alloc::boxed;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use alloc::rc;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use core_collections::borrow;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use core_collections::fmt;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use core_collections::slice;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use core_collections::str;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use core_collections::string;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use core_collections::vec;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use rustc_unicode::char;\n \n-#[path = \"num/f32.rs\"]   pub mod f32;\n-#[path = \"num/f64.rs\"]   pub mod f64;\n-\n-pub mod ascii;\n-\n-/* Common traits */\n-\n-pub mod num;\n-\n-/* Runtime and platform support */\n+pub mod f32;\n+pub mod f64;\n \n #[macro_use]\n pub mod thread;\n-\n+pub mod ascii;\n pub mod collections;\n pub mod env;\n+pub mod error;\n pub mod ffi;\n pub mod fs;\n pub mod io;\n pub mod net;\n+pub mod num;\n pub mod os;\n pub mod panic;\n pub mod path;\n pub mod process;\n pub mod sync;\n pub mod time;\n-mod memchr;\n \n+// Platform-abstraction modules\n #[macro_use]\n-#[path = \"sys/common/mod.rs\"] mod sys_common;\n-\n-#[cfg(unix)]\n-#[path = \"sys/unix/mod.rs\"] mod sys;\n-#[cfg(windows)]\n-#[path = \"sys/windows/mod.rs\"] mod sys;\n+mod sys_common;\n+mod sys;\n \n-pub mod rt;\n+// Private support modules\n mod panicking;\n mod rand;\n+mod memchr;\n+\n+// This module just defines per-platform native library dependencies\n+mod rtdeps;\n+\n+// The runtime entry point and a few unstable public functions used by the\n+// compiler\n+pub mod rt;\n \n // Some external utilities of the standard library rely on randomness (aka\n // rustc_back::TempDir and tests) and need a way to get at the OS rng we've got"}, {"sha": "d1c2fc3d3fce9371a3584bf88f07f120834f139c", "filename": "src/libstd/num.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Flibstd%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Flibstd%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum.rs?ref=0ca9967af75f7a279dcf4921f119b2602b41dd71", "previous_filename": "src/libstd/num/mod.rs"}, {"sha": "84f41a1c535c75655607739af4629efefc8fbe91", "filename": "src/libstd/sys/mod.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Flibstd%2Fsys%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Flibstd%2Fsys%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fmod.rs?ref=0ca9967af75f7a279dcf4921f119b2602b41dd71", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Platform-dependent platform abstraction\n+//!\n+//! The `std::sys` module is the abstracted interface through which\n+//! `std` talks to the underlying operating system. It has different\n+//! implementations for different operating system families, today\n+//! just Unix and Windows.\n+//!\n+//! The centralization of platform-specific code in this module is\n+//! enforced by the \"platform abstraction layer\" tidy script in\n+//! `tools/tidy/pal.rs`.\n+//!\n+//! This module is closely related to the platform-independent system\n+//! integration code in `std::sys_common`. See that module's\n+//! documentation for details.\n+//!\n+//! In the future it would be desirable for the indepedent\n+//! implementations of this module to be extracted to their own crates\n+//! that `std` can link to, thus enabling their implementation\n+//! out-of-tree via crate replacement. Though due to the complex\n+//! inter-dependencies within `std` that will be a challenging goal to\n+//! achieve.\n+\n+pub use self::imp::*;\n+\n+#[cfg(unix)]\n+#[path = \"unix/mod.rs\"]\n+mod imp;\n+\n+#[cfg(windows)]\n+#[path = \"windows/mod.rs\"]\n+mod imp;"}, {"sha": "0c625e7add9d0eb81b3efa976a3374eaf929c8d4", "filename": "src/libstd/sys/unix/fast_thread_local.rs", "status": "added", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Flibstd%2Fsys%2Funix%2Ffast_thread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Flibstd%2Fsys%2Funix%2Ffast_thread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffast_thread_local.rs?ref=0ca9967af75f7a279dcf4921f119b2602b41dd71", "patch": "@@ -0,0 +1,167 @@\n+// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![cfg(target_thread_local)]\n+#![unstable(feature = \"thread_local_internals\", issue = \"0\")]\n+\n+use cell::{Cell, UnsafeCell};\n+use intrinsics;\n+use ptr;\n+\n+pub struct Key<T> {\n+    inner: UnsafeCell<Option<T>>,\n+\n+    // Metadata to keep track of the state of the destructor. Remember that\n+    // these variables are thread-local, not global.\n+    dtor_registered: Cell<bool>,\n+    dtor_running: Cell<bool>,\n+}\n+\n+unsafe impl<T> ::marker::Sync for Key<T> { }\n+\n+impl<T> Key<T> {\n+    pub const fn new() -> Key<T> {\n+        Key {\n+            inner: UnsafeCell::new(None),\n+            dtor_registered: Cell::new(false),\n+            dtor_running: Cell::new(false)\n+        }\n+    }\n+\n+    pub fn get(&'static self) -> Option<&'static UnsafeCell<Option<T>>> {\n+        unsafe {\n+            if intrinsics::needs_drop::<T>() && self.dtor_running.get() {\n+                return None\n+            }\n+            self.register_dtor();\n+        }\n+        Some(&self.inner)\n+    }\n+\n+    unsafe fn register_dtor(&self) {\n+        if !intrinsics::needs_drop::<T>() || self.dtor_registered.get() {\n+            return\n+        }\n+\n+        register_dtor(self as *const _ as *mut u8,\n+                      destroy_value::<T>);\n+        self.dtor_registered.set(true);\n+    }\n+}\n+\n+#[cfg(any(target_os = \"linux\", target_os = \"fuchsia\"))]\n+unsafe fn register_dtor_fallback(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n+    // The fallback implementation uses a vanilla OS-based TLS key to track\n+    // the list of destructors that need to be run for this thread. The key\n+    // then has its own destructor which runs all the other destructors.\n+    //\n+    // The destructor for DTORS is a little special in that it has a `while`\n+    // loop to continuously drain the list of registered destructors. It\n+    // *should* be the case that this loop always terminates because we\n+    // provide the guarantee that a TLS key cannot be set after it is\n+    // flagged for destruction.\n+    use sys_common::thread_local as os;\n+\n+    static DTORS: os::StaticKey = os::StaticKey::new(Some(run_dtors));\n+    type List = Vec<(*mut u8, unsafe extern fn(*mut u8))>;\n+    if DTORS.get().is_null() {\n+        let v: Box<List> = box Vec::new();\n+        DTORS.set(Box::into_raw(v) as *mut u8);\n+    }\n+    let list: &mut List = &mut *(DTORS.get() as *mut List);\n+    list.push((t, dtor));\n+\n+    unsafe extern fn run_dtors(mut ptr: *mut u8) {\n+        while !ptr.is_null() {\n+            let list: Box<List> = Box::from_raw(ptr as *mut List);\n+            for &(ptr, dtor) in list.iter() {\n+                dtor(ptr);\n+            }\n+            ptr = DTORS.get();\n+            DTORS.set(ptr::null_mut());\n+        }\n+    }\n+}\n+\n+// Since what appears to be glibc 2.18 this symbol has been shipped which\n+// GCC and clang both use to invoke destructors in thread_local globals, so\n+// let's do the same!\n+//\n+// Note, however, that we run on lots older linuxes, as well as cross\n+// compiling from a newer linux to an older linux, so we also have a\n+// fallback implementation to use as well.\n+//\n+// Due to rust-lang/rust#18804, make sure this is not generic!\n+#[cfg(target_os = \"linux\")]\n+unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n+    use mem;\n+    use libc;\n+\n+    extern {\n+        #[linkage = \"extern_weak\"]\n+        static __dso_handle: *mut u8;\n+        #[linkage = \"extern_weak\"]\n+        static __cxa_thread_atexit_impl: *const libc::c_void;\n+    }\n+    if !__cxa_thread_atexit_impl.is_null() {\n+        type F = unsafe extern fn(dtor: unsafe extern fn(*mut u8),\n+                                  arg: *mut u8,\n+                                  dso_handle: *mut u8) -> libc::c_int;\n+        mem::transmute::<*const libc::c_void, F>(__cxa_thread_atexit_impl)\n+            (dtor, t, &__dso_handle as *const _ as *mut _);\n+        return\n+    }\n+    register_dtor_fallback(t, dtor);\n+}\n+\n+// OSX's analog of the above linux function is this _tlv_atexit function.\n+// The disassembly of thread_local globals in C++ (at least produced by\n+// clang) will have this show up in the output.\n+#[cfg(target_os = \"macos\")]\n+unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n+    extern {\n+        fn _tlv_atexit(dtor: unsafe extern fn(*mut u8),\n+                       arg: *mut u8);\n+    }\n+    _tlv_atexit(dtor, t);\n+}\n+\n+// Just use the thread_local fallback implementation, at least until there's\n+// a more direct implementation.\n+#[cfg(target_os = \"fuchsia\")]\n+unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n+    register_dtor_fallback(t, dtor);\n+}\n+\n+pub unsafe extern fn destroy_value<T>(ptr: *mut u8) {\n+    let ptr = ptr as *mut Key<T>;\n+    // Right before we run the user destructor be sure to flag the\n+    // destructor as running for this thread so calls to `get` will return\n+    // `None`.\n+    (*ptr).dtor_running.set(true);\n+\n+    // The OSX implementation of TLS apparently had an odd aspect to it\n+    // where the pointer we have may be overwritten while this destructor\n+    // is running. Specifically if a TLS destructor re-accesses TLS it may\n+    // trigger a re-initialization of all TLS variables, paving over at\n+    // least some destroyed ones with initial values.\n+    //\n+    // This means that if we drop a TLS value in place on OSX that we could\n+    // revert the value to its original state halfway through the\n+    // destructor, which would be bad!\n+    //\n+    // Hence, we use `ptr::read` on OSX (to move to a \"safe\" location)\n+    // instead of drop_in_place.\n+    if cfg!(target_os = \"macos\") {\n+        ptr::read((*ptr).inner.get());\n+    } else {\n+        ptr::drop_in_place((*ptr).inner.get());\n+    }\n+}"}, {"sha": "fd7dc17cccd8cbf36d3a24684215adebeb41326f", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=0ca9967af75f7a279dcf4921f119b2602b41dd71", "patch": "@@ -38,6 +38,7 @@ pub mod backtrace;\n pub mod condvar;\n pub mod env;\n pub mod ext;\n+pub mod fast_thread_local;\n pub mod fd;\n pub mod fs;\n pub mod memchr;\n@@ -162,3 +163,14 @@ pub fn cvt_r<T, F>(mut f: F) -> io::Result<T>\n         }\n     }\n }\n+\n+// On Unix-like platforms, libc::abort will unregister signal handlers\n+// including the SIGABRT handler, preventing the abort from being blocked, and\n+// fclose streams, with the side effect of flushing them so libc bufferred\n+// output will be printed.  Additionally the shell will generally print a more\n+// understandable error message like \"Abort trap\" rather than \"Illegal\n+// instruction\" that intrinsics::abort would cause, as intrinsics::abort is\n+// implemented as an illegal instruction.\n+pub unsafe fn abort_internal() -> ! {\n+    ::libc::abort()\n+}"}, {"sha": "273341b1918d1c0e6c42200b0b97b238fd9ff3d1", "filename": "src/libstd/sys/unix/stdio.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Flibstd%2Fsys%2Funix%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Flibstd%2Fsys%2Funix%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fstdio.rs?ref=0ca9967af75f7a279dcf4921f119b2602b41dd71", "patch": "@@ -67,3 +67,4 @@ impl io::Write for Stderr {\n }\n \n pub const EBADF_ERR: i32 = ::libc::EBADF as i32;\n+pub const STDIN_BUF_SIZE: usize = ::sys_common::io::DEFAULT_BUF_SIZE;"}, {"sha": "defc41c5f46a38ccc33954d99bf265a6b111e635", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=0ca9967af75f7a279dcf4921f119b2602b41dd71", "patch": "@@ -179,7 +179,7 @@ pub fn truncate_utf16_at_nul<'a>(v: &'a [u16]) -> &'a [u16] {\n     }\n }\n \n-trait IsZero {\n+pub trait IsZero {\n     fn is_zero(&self) -> bool;\n }\n \n@@ -193,15 +193,15 @@ macro_rules! impl_is_zero {\n \n impl_is_zero! { i8 i16 i32 i64 isize u8 u16 u32 u64 usize }\n \n-fn cvt<I: IsZero>(i: I) -> io::Result<I> {\n+pub fn cvt<I: IsZero>(i: I) -> io::Result<I> {\n     if i.is_zero() {\n         Err(io::Error::last_os_error())\n     } else {\n         Ok(i)\n     }\n }\n \n-fn dur2timeout(dur: Duration) -> c::DWORD {\n+pub fn dur2timeout(dur: Duration) -> c::DWORD {\n     // Note that a duration is a (u64, u32) (seconds, nanoseconds) pair, and the\n     // timeouts in windows APIs are typically u32 milliseconds. To translate, we\n     // have two pieces to take care of:\n@@ -221,3 +221,17 @@ fn dur2timeout(dur: Duration) -> c::DWORD {\n         }\n     }).unwrap_or(c::INFINITE)\n }\n+\n+// On Windows, use the processor-specific __fastfail mechanism.  In Windows 8\n+// and later, this will terminate the process immediately without running any\n+// in-process exception handlers.  In earlier versions of Windows, this\n+// sequence of instructions will be treated as an access violation,\n+// terminating the process but without necessarily bypassing all exception\n+// handlers.\n+//\n+// https://msdn.microsoft.com/en-us/library/dn774154.aspx\n+#[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n+pub unsafe fn abort_internal() -> ! {\n+    asm!(\"int $$0x29\" :: \"{ecx}\"(7) ::: volatile); // 7 is FAST_FAIL_FATAL_APP_EXIT\n+    ::intrinsics::unreachable();\n+}"}, {"sha": "72788776dedd6ebdf4f60143e9774334c6860cc1", "filename": "src/libstd/sys/windows/stdio.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs?ref=0ca9967af75f7a279dcf4921f119b2602b41dd71", "patch": "@@ -207,3 +207,8 @@ fn invalid_encoding() -> io::Error {\n }\n \n pub const EBADF_ERR: i32 = ::sys::c::ERROR_INVALID_HANDLE as i32;\n+// The default buffer capacity is 64k, but apparently windows\n+// doesn't like 64k reads on stdin. See #13304 for details, but the\n+// idea is that on windows we use a slightly smaller buffer that's\n+// been seen to be acceptable.\n+pub const STDIN_BUF_SIZE: usize = 8 * 1024;"}, {"sha": "ce6fd4cb0754b1cc9297b4a97394b08aebc1356c", "filename": "src/libstd/sys_common/at_exit_imp.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Flibstd%2Fsys_common%2Fat_exit_imp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Flibstd%2Fsys_common%2Fat_exit_imp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fat_exit_imp.rs?ref=0ca9967af75f7a279dcf4921f119b2602b41dd71", "previous_filename": "src/libstd/sys/common/at_exit_imp.rs"}, {"sha": "a8540fed9286f1aaae8f9843c25ec5f293d301e7", "filename": "src/libstd/sys_common/backtrace.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Flibstd%2Fsys_common%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Flibstd%2Fsys_common%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fbacktrace.rs?ref=0ca9967af75f7a279dcf4921f119b2602b41dd71", "previous_filename": "src/libstd/sys/common/backtrace.rs"}, {"sha": "b6f29dd5fc3d3184f6a528fcb36f70b64b3f1051", "filename": "src/libstd/sys_common/condvar.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Flibstd%2Fsys_common%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Flibstd%2Fsys_common%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fcondvar.rs?ref=0ca9967af75f7a279dcf4921f119b2602b41dd71", "previous_filename": "src/libstd/sys/common/condvar.rs"}, {"sha": "b5802afc109435ec1e5e2cf8dd1b71951780c592", "filename": "src/libstd/sys_common/gnu/libbacktrace.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Flibstd%2Fsys_common%2Fgnu%2Flibbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Flibstd%2Fsys_common%2Fgnu%2Flibbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fgnu%2Flibbacktrace.rs?ref=0ca9967af75f7a279dcf4921f119b2602b41dd71", "previous_filename": "src/libstd/sys/common/gnu/libbacktrace.rs"}, {"sha": "3a8cf2d84259173af8317ef21e96261c437cfec4", "filename": "src/libstd/sys_common/gnu/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Flibstd%2Fsys_common%2Fgnu%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Flibstd%2Fsys_common%2Fgnu%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fgnu%2Fmod.rs?ref=0ca9967af75f7a279dcf4921f119b2602b41dd71", "previous_filename": "src/libstd/sys/common/gnu/mod.rs"}, {"sha": "23daeeb5187b7f75551ed3ea4612cdf194c715a4", "filename": "src/libstd/sys_common/io.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Flibstd%2Fsys_common%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Flibstd%2Fsys_common%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fio.rs?ref=0ca9967af75f7a279dcf4921f119b2602b41dd71", "patch": "@@ -12,6 +12,8 @@ use io::ErrorKind;\n use io::Read;\n use slice::from_raw_parts_mut;\n \n+pub const DEFAULT_BUF_SIZE: usize = 8 * 1024;\n+\n // Provides read_to_end functionality over an uninitialized buffer.\n // This function is unsafe because it calls the underlying\n // read function with a slice into uninitialized memory. The default", "previous_filename": "src/libstd/sys/common/io.rs"}, {"sha": "3824a5fb5284c85c430f148704c8a5516ddb44f1", "filename": "src/libstd/sys_common/memchr.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Flibstd%2Fsys_common%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Flibstd%2Fsys_common%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fmemchr.rs?ref=0ca9967af75f7a279dcf4921f119b2602b41dd71", "previous_filename": "src/libstd/sys/common/memchr.rs"}, {"sha": "1dd9b73e262c82d5bbdc7520e1eb43e9c983ebb4", "filename": "src/libstd/sys_common/mod.rs", "status": "renamed", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Flibstd%2Fsys_common%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Flibstd%2Fsys_common%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fmod.rs?ref=0ca9967af75f7a279dcf4921f119b2602b41dd71", "patch": "@@ -8,23 +8,25 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! Platform-independent platform abstraction\n+//!\n+//! This is the platform-independent portion of the standard libraries\n+//! platform abstraction layer, whereas `std::sys` is the\n+//! platform-specific portion.\n+//!\n+//! The relationship between `std::sys_common`, `std::sys` and the\n+//! rest of `std` is complex, with dependencies going in all\n+//! directions: `std` depending on `sys_common`, `sys_common`\n+//! depending on `sys`, and `sys` depending on `sys_common` and `std`.\n+//! Ideally `sys_common` would be split into two and the dependencies\n+//! between them all would form a dag, facilitating the extraction of\n+//! `std::sys` from the standard library.\n+\n #![allow(missing_docs)]\n \n use sync::Once;\n use sys;\n \n-macro_rules! rtabort {\n-    ($($t:tt)*) => (::sys_common::util::abort(format_args!($($t)*)))\n-}\n-\n-macro_rules! rtassert {\n-    ($e:expr) => ({\n-        if !$e {\n-            rtabort!(concat!(\"assertion failed: \", stringify!($e)))\n-        }\n-    })\n-}\n-\n pub mod at_exit_imp;\n #[cfg(any(not(cargobuild), feature = \"backtrace\"))]\n pub mod backtrace;\n@@ -87,6 +89,10 @@ pub fn at_exit<F: FnOnce() + Send + 'static>(f: F) -> Result<(), ()> {\n     if at_exit_imp::push(Box::new(f)) {Ok(())} else {Err(())}\n }\n \n+macro_rules! rtabort {\n+    ($($t:tt)*) => (::sys_common::util::abort(format_args!($($t)*)))\n+}\n+\n /// One-time runtime cleanup.\n pub fn cleanup() {\n     static CLEANUP: Once = Once::new();", "previous_filename": "src/libstd/sys/common/mod.rs"}, {"sha": "d1a738770d3893fb66189c036009fd62375984db", "filename": "src/libstd/sys_common/mutex.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Flibstd%2Fsys_common%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Flibstd%2Fsys_common%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fmutex.rs?ref=0ca9967af75f7a279dcf4921f119b2602b41dd71", "previous_filename": "src/libstd/sys/common/mutex.rs"}, {"sha": "10ad61f4c800c26b9593a7979edbf2f5cac55ce1", "filename": "src/libstd/sys_common/net.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Flibstd%2Fsys_common%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Flibstd%2Fsys_common%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fnet.rs?ref=0ca9967af75f7a279dcf4921f119b2602b41dd71", "previous_filename": "src/libstd/sys/common/net.rs"}, {"sha": "bdc727f1dfcfe0f20536ce50054f7ec5e6cff3e7", "filename": "src/libstd/sys_common/poison.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Flibstd%2Fsys_common%2Fpoison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Flibstd%2Fsys_common%2Fpoison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fpoison.rs?ref=0ca9967af75f7a279dcf4921f119b2602b41dd71", "previous_filename": "src/libstd/sys/common/poison.rs"}, {"sha": "4d0407ccf6c8903bb20eee0059b492319a94d81f", "filename": "src/libstd/sys_common/remutex.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Flibstd%2Fsys_common%2Fremutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Flibstd%2Fsys_common%2Fremutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fremutex.rs?ref=0ca9967af75f7a279dcf4921f119b2602b41dd71", "previous_filename": "src/libstd/sys/common/remutex.rs"}, {"sha": "71a4f01ec4cab9f2d3edcee78af3373f2484e24f", "filename": "src/libstd/sys_common/rwlock.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Flibstd%2Fsys_common%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Flibstd%2Fsys_common%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Frwlock.rs?ref=0ca9967af75f7a279dcf4921f119b2602b41dd71", "previous_filename": "src/libstd/sys/common/rwlock.rs"}, {"sha": "3ee160da5fa5b7876ab1a2c957b77c9cc3aa75f8", "filename": "src/libstd/sys_common/thread.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Flibstd%2Fsys_common%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Flibstd%2Fsys_common%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fthread.rs?ref=0ca9967af75f7a279dcf4921f119b2602b41dd71", "previous_filename": "src/libstd/sys/common/thread.rs"}, {"sha": "95d8b6cc9516d2e3e5573863d9287ed65d70e105", "filename": "src/libstd/sys_common/thread_info.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Flibstd%2Fsys_common%2Fthread_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Flibstd%2Fsys_common%2Fthread_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fthread_info.rs?ref=0ca9967af75f7a279dcf4921f119b2602b41dd71", "previous_filename": "src/libstd/sys/common/thread_info.rs"}, {"sha": "25a9d5720d9338bfb14ed8dba43bd03edaf36362", "filename": "src/libstd/sys_common/thread_local.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Flibstd%2Fsys_common%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Flibstd%2Fsys_common%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fthread_local.rs?ref=0ca9967af75f7a279dcf4921f119b2602b41dd71", "previous_filename": "src/libstd/sys/common/thread_local.rs"}, {"sha": "daa0c15920b666703f323463a8952a5e753d937e", "filename": "src/libstd/sys_common/util.rs", "status": "renamed", "additions": 1, "deletions": 27, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Flibstd%2Fsys_common%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Flibstd%2Fsys_common%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Futil.rs?ref=0ca9967af75f7a279dcf4921f119b2602b41dd71", "patch": "@@ -33,40 +33,14 @@ pub fn dumb_print(args: fmt::Arguments) {\n     let _ = Stderr::new().map(|mut stderr| stderr.write_fmt(args));\n }\n \n-// On Unix-like platforms, libc::abort will unregister signal handlers\n-// including the SIGABRT handler, preventing the abort from being blocked, and\n-// fclose streams, with the side effect of flushing them so libc bufferred\n-// output will be printed.  Additionally the shell will generally print a more\n-// understandable error message like \"Abort trap\" rather than \"Illegal\n-// instruction\" that intrinsics::abort would cause, as intrinsics::abort is\n-// implemented as an illegal instruction.\n-#[cfg(unix)]\n-unsafe fn abort_internal() -> ! {\n-    ::libc::abort()\n-}\n-\n-// On Windows, use the processor-specific __fastfail mechanism.  In Windows 8\n-// and later, this will terminate the process immediately without running any\n-// in-process exception handlers.  In earlier versions of Windows, this\n-// sequence of instructions will be treated as an access violation,\n-// terminating the process but without necessarily bypassing all exception\n-// handlers.\n-//\n-// https://msdn.microsoft.com/en-us/library/dn774154.aspx\n-#[cfg(all(windows, any(target_arch = \"x86\", target_arch = \"x86_64\")))]\n-unsafe fn abort_internal() -> ! {\n-    asm!(\"int $$0x29\" :: \"{ecx}\"(7) ::: volatile); // 7 is FAST_FAIL_FATAL_APP_EXIT\n-    ::intrinsics::unreachable();\n-}\n-\n // Other platforms should use the appropriate platform-specific mechanism for\n // aborting the process.  If no platform-specific mechanism is available,\n // ::intrinsics::abort() may be used instead.  The above implementations cover\n // all targets currently supported by libstd.\n \n pub fn abort(args: fmt::Arguments) -> ! {\n     dumb_print(format_args!(\"fatal runtime error: {}\\n\", args));\n-    unsafe { abort_internal(); }\n+    unsafe { ::sys::abort_internal(); }\n }\n \n #[allow(dead_code)] // stack overflow detection not enabled on all platforms", "previous_filename": "src/libstd/sys/common/util.rs"}, {"sha": "0a94ff1e958236e6337d8700ab4bb9f36bfff905", "filename": "src/libstd/sys_common/wtf8.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Flibstd%2Fsys_common%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Flibstd%2Fsys_common%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fwtf8.rs?ref=0ca9967af75f7a279dcf4921f119b2602b41dd71", "previous_filename": "src/libstd/sys/common/wtf8.rs"}, {"sha": "f74dd5924951c1f02daaa2d6835e91ac919bbcba", "filename": "src/libstd/thread/local.rs", "status": "modified", "additions": 2, "deletions": 161, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Flibstd%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Flibstd%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Flocal.rs?ref=0ca9967af75f7a279dcf4921f119b2602b41dd71", "patch": "@@ -166,8 +166,8 @@ macro_rules! __thread_local_inner {\n         {\n             #[thread_local]\n             #[cfg(target_thread_local)]\n-            static __KEY: $crate::thread::__ElfLocalKeyInner<$t> =\n-                $crate::thread::__ElfLocalKeyInner::new();\n+            static __KEY: $crate::thread::__FastLocalKeyInner<$t> =\n+                $crate::thread::__FastLocalKeyInner::new();\n \n             #[cfg(not(target_thread_local))]\n             static __KEY: $crate::thread::__OsLocalKeyInner<$t> =\n@@ -310,165 +310,6 @@ impl<T: 'static> LocalKey<T> {\n     }\n }\n \n-#[cfg(target_thread_local)]\n-#[doc(hidden)]\n-pub mod elf {\n-    use cell::{Cell, UnsafeCell};\n-    use intrinsics;\n-    use ptr;\n-\n-    pub struct Key<T> {\n-        inner: UnsafeCell<Option<T>>,\n-\n-        // Metadata to keep track of the state of the destructor. Remember that\n-        // these variables are thread-local, not global.\n-        dtor_registered: Cell<bool>,\n-        dtor_running: Cell<bool>,\n-    }\n-\n-    unsafe impl<T> ::marker::Sync for Key<T> { }\n-\n-    impl<T> Key<T> {\n-        pub const fn new() -> Key<T> {\n-            Key {\n-                inner: UnsafeCell::new(None),\n-                dtor_registered: Cell::new(false),\n-                dtor_running: Cell::new(false)\n-            }\n-        }\n-\n-        pub fn get(&'static self) -> Option<&'static UnsafeCell<Option<T>>> {\n-            unsafe {\n-                if intrinsics::needs_drop::<T>() && self.dtor_running.get() {\n-                    return None\n-                }\n-                self.register_dtor();\n-            }\n-            Some(&self.inner)\n-        }\n-\n-        unsafe fn register_dtor(&self) {\n-            if !intrinsics::needs_drop::<T>() || self.dtor_registered.get() {\n-                return\n-            }\n-\n-            register_dtor(self as *const _ as *mut u8,\n-                          destroy_value::<T>);\n-            self.dtor_registered.set(true);\n-        }\n-    }\n-\n-    #[cfg(any(target_os = \"linux\", target_os = \"fuchsia\"))]\n-    unsafe fn register_dtor_fallback(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n-        // The fallback implementation uses a vanilla OS-based TLS key to track\n-        // the list of destructors that need to be run for this thread. The key\n-        // then has its own destructor which runs all the other destructors.\n-        //\n-        // The destructor for DTORS is a little special in that it has a `while`\n-        // loop to continuously drain the list of registered destructors. It\n-        // *should* be the case that this loop always terminates because we\n-        // provide the guarantee that a TLS key cannot be set after it is\n-        // flagged for destruction.\n-        use sys_common::thread_local as os;\n-\n-        static DTORS: os::StaticKey = os::StaticKey::new(Some(run_dtors));\n-        type List = Vec<(*mut u8, unsafe extern fn(*mut u8))>;\n-        if DTORS.get().is_null() {\n-            let v: Box<List> = box Vec::new();\n-            DTORS.set(Box::into_raw(v) as *mut u8);\n-        }\n-        let list: &mut List = &mut *(DTORS.get() as *mut List);\n-        list.push((t, dtor));\n-\n-        unsafe extern fn run_dtors(mut ptr: *mut u8) {\n-            while !ptr.is_null() {\n-                let list: Box<List> = Box::from_raw(ptr as *mut List);\n-                for &(ptr, dtor) in list.iter() {\n-                    dtor(ptr);\n-                }\n-                ptr = DTORS.get();\n-                DTORS.set(ptr::null_mut());\n-            }\n-        }\n-    }\n-\n-    // Since what appears to be glibc 2.18 this symbol has been shipped which\n-    // GCC and clang both use to invoke destructors in thread_local globals, so\n-    // let's do the same!\n-    //\n-    // Note, however, that we run on lots older linuxes, as well as cross\n-    // compiling from a newer linux to an older linux, so we also have a\n-    // fallback implementation to use as well.\n-    //\n-    // Due to rust-lang/rust#18804, make sure this is not generic!\n-    #[cfg(target_os = \"linux\")]\n-    unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n-        use mem;\n-        use libc;\n-\n-        extern {\n-            #[linkage = \"extern_weak\"]\n-            static __dso_handle: *mut u8;\n-            #[linkage = \"extern_weak\"]\n-            static __cxa_thread_atexit_impl: *const libc::c_void;\n-        }\n-        if !__cxa_thread_atexit_impl.is_null() {\n-            type F = unsafe extern fn(dtor: unsafe extern fn(*mut u8),\n-                                      arg: *mut u8,\n-                                      dso_handle: *mut u8) -> libc::c_int;\n-            mem::transmute::<*const libc::c_void, F>(__cxa_thread_atexit_impl)\n-            (dtor, t, &__dso_handle as *const _ as *mut _);\n-            return\n-        }\n-        register_dtor_fallback(t, dtor);\n-    }\n-\n-    // OSX's analog of the above linux function is this _tlv_atexit function.\n-    // The disassembly of thread_local globals in C++ (at least produced by\n-    // clang) will have this show up in the output.\n-    #[cfg(target_os = \"macos\")]\n-    unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n-        extern {\n-            fn _tlv_atexit(dtor: unsafe extern fn(*mut u8),\n-                           arg: *mut u8);\n-        }\n-        _tlv_atexit(dtor, t);\n-    }\n-\n-    // Just use the thread_local fallback implementation, at least until there's\n-    // a more direct implementation.\n-    #[cfg(target_os = \"fuchsia\")]\n-    unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n-        register_dtor_fallback(t, dtor);\n-    }\n-\n-    pub unsafe extern fn destroy_value<T>(ptr: *mut u8) {\n-        let ptr = ptr as *mut Key<T>;\n-        // Right before we run the user destructor be sure to flag the\n-        // destructor as running for this thread so calls to `get` will return\n-        // `None`.\n-        (*ptr).dtor_running.set(true);\n-\n-        // The OSX implementation of TLS apparently had an odd aspect to it\n-        // where the pointer we have may be overwritten while this destructor\n-        // is running. Specifically if a TLS destructor re-accesses TLS it may\n-        // trigger a re-initialization of all TLS variables, paving over at\n-        // least some destroyed ones with initial values.\n-        //\n-        // This means that if we drop a TLS value in place on OSX that we could\n-        // revert the value to its original state halfway through the\n-        // destructor, which would be bad!\n-        //\n-        // Hence, we use `ptr::read` on OSX (to move to a \"safe\" location)\n-        // instead of drop_in_place.\n-        if cfg!(target_os = \"macos\") {\n-            ptr::read((*ptr).inner.get());\n-        } else {\n-            ptr::drop_in_place((*ptr).inner.get());\n-        }\n-    }\n-}\n-\n #[doc(hidden)]\n pub mod os {\n     use cell::{Cell, UnsafeCell};"}, {"sha": "255cd2a9bc0f19cf73af3676d50a2c6e40db1cb3", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=0ca9967af75f7a279dcf4921f119b2602b41dd71", "patch": "@@ -181,9 +181,18 @@ use time::Duration;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::local::{LocalKey, LocalKeyState};\n \n+// The types used by the thread_local! macro to access TLS keys. Note that there\n+// are two types, the \"OS\" type and the \"fast\" type. The OS thread local key\n+// type is accessed via platform-specific API calls and is slow, while the fast\n+// key type is accessed via code generated via LLVM, where TLS keys are set up\n+// by the elf linker. Note that the OS TLS type is always available: on macOS\n+// the standard library is compiled with support for older platform versions\n+// where fast TLS was not available; end-user code is compiled with fast TLS\n+// where available, but both are needed.\n+\n #[unstable(feature = \"libstd_thread_internals\", issue = \"0\")]\n #[cfg(target_thread_local)]\n-#[doc(hidden)] pub use self::local::elf::Key as __ElfLocalKeyInner;\n+#[doc(hidden)] pub use sys::fast_thread_local::Key as __FastLocalKeyInner;\n #[unstable(feature = \"libstd_thread_internals\", issue = \"0\")]\n #[doc(hidden)] pub use self::local::os::Key as __OsLocalKeyInner;\n "}, {"sha": "a5e4e5a4c2672bf6bf585e2e259fbf91e9087e19", "filename": "src/tools/tidy/src/pal.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ca9967af75f7a279dcf4921f119b2602b41dd71/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs?ref=0ca9967af75f7a279dcf4921f119b2602b41dd71", "patch": "@@ -57,22 +57,18 @@ const EXCEPTION_PATHS: &'static [&'static str] = &[\n     \"src/libpanic_abort\",\n     \"src/libpanic_unwind\",\n     \"src/libunwind\",\n-    \"src/libstd/sys/unix\", // This is where platform-specific code for std should live\n-    \"src/libstd/sys/windows\", // Ditto\n+    \"src/libstd/sys/\", // Platform-specific code for std lives here.\n+                       // This has the trailing slash so that sys_common is not excepted.\n     \"src/libstd/os\", // Platform-specific public interfaces\n     \"src/rtstartup\", // Not sure what to do about this. magic stuff for mingw\n \n     // temporary exceptions\n-    \"src/libstd/lib.rs\", // This could probably be done within the sys directory\n     \"src/libstd/rtdeps.rs\", // Until rustbuild replaces make\n     \"src/libstd/path.rs\",\n-    \"src/libstd/io/stdio.rs\",\n-    \"src/libstd/num/f32.rs\",\n-    \"src/libstd/num/f64.rs\",\n-    \"src/libstd/thread/local.rs\",\n-    \"src/libstd/sys/common/mod.rs\",\n-    \"src/libstd/sys/common/net.rs\",\n-    \"src/libstd/sys/common/util.rs\",\n+    \"src/libstd/f32.rs\",\n+    \"src/libstd/f64.rs\",\n+    \"src/libstd/sys_common/mod.rs\",\n+    \"src/libstd/sys_common/net.rs\",\n     \"src/libterm\", // Not sure how to make this crate portable, but test needs it\n     \"src/libtest\", // Probably should defer to unstable std::sys APIs\n "}]}