{"sha": "fbdb10f9fabe47eb763cb4b52b5721740cc63783", "node_id": "C_kwDOAAsO6NoAKGZiZGIxMGY5ZmFiZTQ3ZWI3NjNjYjRiNTJiNTcyMTc0MGNjNjM3ODM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-09T11:05:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-09T11:05:30Z"}, "message": "Auto merge of #95840 - Dylan-DPC:rollup-erz5u6w, r=Dylan-DPC\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #95308 (Reduce the amount of unstable features used in libproc_macro)\n - #95676 (Update RLS)\n - #95769 (Hide cross-crate `#[doc(hidden)]` associated items in trait impls)\n - #95785 (interpret: err instead of ICE on size mismatches in to_bits_or_ptr_internal)\n - #95802 (fix unused constant warning on some Windows targets)\n - #95810 (Use `format-args-capture` and remove unnecessary nested blocks)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "dd3bd6dacdacbd30ee6a962cde4215d85a4c51fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dd3bd6dacdacbd30ee6a962cde4215d85a4c51fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fbdb10f9fabe47eb763cb4b52b5721740cc63783", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fbdb10f9fabe47eb763cb4b52b5721740cc63783", "html_url": "https://github.com/rust-lang/rust/commit/fbdb10f9fabe47eb763cb4b52b5721740cc63783", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fbdb10f9fabe47eb763cb4b52b5721740cc63783/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "399dd8049d4b27329350937e3e17077205bdc0bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/399dd8049d4b27329350937e3e17077205bdc0bf", "html_url": "https://github.com/rust-lang/rust/commit/399dd8049d4b27329350937e3e17077205bdc0bf"}, {"sha": "ece6b97f19d7c6e8c7def59898c693d17ec336fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/ece6b97f19d7c6e8c7def59898c693d17ec336fe", "html_url": "https://github.com/rust-lang/rust/commit/ece6b97f19d7c6e8c7def59898c693d17ec336fe"}], "stats": {"total": 580, "additions": 341, "deletions": 239}, "files": [{"sha": "325503a0e956488318c60b2e37b3cbeeb5f7adda", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fbdb10f9fabe47eb763cb4b52b5721740cc63783/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/fbdb10f9fabe47eb763cb4b52b5721740cc63783/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=fbdb10f9fabe47eb763cb4b52b5721740cc63783", "patch": "@@ -2950,9 +2950,9 @@ dependencies = [\n \n [[package]]\n name = \"racer\"\n-version = \"2.2.0\"\n+version = \"2.2.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b0b4b5faaf07040474e8af74a9e19ff167d5d204df5db5c5c765edecfb900358\"\n+checksum = \"64954e44fc0d1dcc64e0b9f2b155249ad62849eba25354b76ae1598d1e8f0fa0\"\n dependencies = [\n  \"bitflags\",\n  \"clap 2.34.0\","}, {"sha": "e7fd89c140fc7986ba6d04dfbd5deb2300bb8a24", "filename": "compiler/rustc_borrowck/src/diagnostics/move_errors.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/fbdb10f9fabe47eb763cb4b52b5721740cc63783/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdb10f9fabe47eb763cb4b52b5721740cc63783/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs?ref=fbdb10f9fabe47eb763cb4b52b5721740cc63783", "patch": "@@ -157,14 +157,14 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             // Error with the match place\n             LookupResult::Parent(_) => {\n                 for ge in &mut *grouped_errors {\n-                    if let GroupedMoveError::MovesFromPlace { span, binds_to, .. } = ge {\n-                        if match_span == *span {\n-                            debug!(\"appending local({:?}) to list\", bind_to);\n-                            if !binds_to.is_empty() {\n-                                binds_to.push(bind_to);\n-                            }\n-                            return;\n+                    if let GroupedMoveError::MovesFromPlace { span, binds_to, .. } = ge\n+                        && match_span == *span\n+                    {\n+                        debug!(\"appending local({:?}) to list\", bind_to);\n+                        if !binds_to.is_empty() {\n+                            binds_to.push(bind_to);\n                         }\n+                        return;\n                     }\n                 }\n                 debug!(\"found a new move error location\");\n@@ -353,7 +353,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     None => bug!(\"closure kind not inferred by borrowck\"),\n                 };\n                 let capture_description =\n-                    format!(\"captured variable in an `{}` closure\", closure_kind);\n+                    format!(\"captured variable in an `{closure_kind}` closure\");\n \n                 let upvar = &self.upvars[upvar_field.unwrap().index()];\n                 let upvar_hir_id = upvar.place.get_root_variable();\n@@ -364,9 +364,9 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n                 let place_description =\n                     if self.is_upvar_field_projection(move_place.as_ref()).is_some() {\n-                        format!(\"{}, a {}\", place_name, capture_description)\n+                        format!(\"{place_name}, a {capture_description}\")\n                     } else {\n-                        format!(\"{}, as `{}` is a {}\", place_name, upvar_name, capture_description)\n+                        format!(\"{place_name}, as `{upvar_name}` is a {capture_description}\")\n                     };\n \n                 debug!(\n@@ -379,7 +379,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 diag.span_label(upvar_span, \"captured outer variable\");\n                 diag.span_label(\n                     self.body.span,\n-                    format!(\"captured by this `{}` closure\", closure_kind),\n+                    format!(\"captured by this `{closure_kind}` closure\"),\n                 );\n \n                 diag\n@@ -390,7 +390,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 {\n                     (Some(place_desc), Some(source_desc)) => self.cannot_move_out_of(\n                         span,\n-                        &format!(\"`{}` which is behind a {}\", place_desc, source_desc),\n+                        &format!(\"`{place_desc}` which is behind a {source_desc}\"),\n                     ),\n                     (_, _) => self.cannot_move_out_of(\n                         span,\n@@ -435,15 +435,15 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     err.span_suggestion(\n                         span,\n                         \"consider borrowing here\",\n-                        format!(\"&{}\", snippet),\n+                        format!(\"&{snippet}\"),\n                         Applicability::Unspecified,\n                     );\n                 }\n \n                 if binds_to.is_empty() {\n                     let place_ty = move_from.ty(self.body, self.infcx.tcx).ty;\n                     let place_desc = match self.describe_place(move_from.as_ref()) {\n-                        Some(desc) => format!(\"`{}`\", desc),\n+                        Some(desc) => format!(\"`{desc}`\"),\n                         None => \"value\".to_string(),\n                     };\n \n@@ -472,12 +472,12 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 let span = use_spans.var_or_use();\n                 let place_ty = original_path.ty(self.body, self.infcx.tcx).ty;\n                 let place_desc = match self.describe_place(original_path.as_ref()) {\n-                    Some(desc) => format!(\"`{}`\", desc),\n+                    Some(desc) => format!(\"`{desc}`\"),\n                     None => \"value\".to_string(),\n                 };\n                 self.note_type_does_not_implement_copy(err, &place_desc, place_ty, Some(span), \"\");\n \n-                use_spans.args_span_label(err, format!(\"move out of {} occurs here\", place_desc));\n+                use_spans.args_span_label(err, format!(\"move out of {place_desc} occurs here\"));\n             }\n         }\n     }\n@@ -511,7 +511,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         for (span, to_remove, suggestion) in suggestions {\n             err.span_suggestion(\n                 span,\n-                &format!(\"consider removing the `{}`\", to_remove),\n+                &format!(\"consider removing the `{to_remove}`\"),\n                 suggestion,\n                 Applicability::MachineApplicable,\n             );"}, {"sha": "8b12db071b6ac255a210b215a181b0d12b25169b", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 72, "deletions": 78, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/fbdb10f9fabe47eb763cb4b52b5721740cc63783/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdb10f9fabe47eb763cb4b52b5721740cc63783/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=fbdb10f9fabe47eb763cb4b52b5721740cc63783", "patch": "@@ -55,7 +55,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     reason = \", as it is not declared as mutable\".to_string();\n                 } else {\n                     let name = self.local_names[local].expect(\"immutable unnamed local\");\n-                    reason = format!(\", as `{}` is not declared as mutable\", name);\n+                    reason = format!(\", as `{name}` is not declared as mutable\");\n                 }\n             }\n \n@@ -88,7 +88,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         reason = \", as it is not declared as mutable\".to_string();\n                     } else {\n                         let name = self.upvars[upvar_index.index()].place.to_string(self.infcx.tcx);\n-                        reason = format!(\", as `{}` is not declared as mutable\", name);\n+                        reason = format!(\", as `{name}` is not declared as mutable\");\n                     }\n                 }\n             }\n@@ -103,14 +103,14 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 if self.body.local_decls[local].is_ref_to_static() =>\n             {\n                 if access_place.projection.len() == 1 {\n-                    item_msg = format!(\"immutable static item {}\", access_place_desc);\n+                    item_msg = format!(\"immutable static item {access_place_desc}\");\n                     reason = String::new();\n                 } else {\n                     item_msg = access_place_desc;\n                     let local_info = &self.body.local_decls[local].local_info;\n                     if let Some(box LocalInfo::StaticRef { def_id, .. }) = *local_info {\n                         let static_name = &self.infcx.tcx.item_name(def_id);\n-                        reason = format!(\", as `{}` is an immutable static item\", static_name);\n+                        reason = format!(\", as `{static_name}` is an immutable static item\");\n                     } else {\n                         bug!(\"is_ref_to_static return true, but not ref to static?\");\n                     }\n@@ -148,15 +148,15 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     let pointer_type = source.describe_for_immutable_place(self.infcx.tcx);\n                     opt_source = Some(source);\n                     if let Some(desc) = self.describe_place(access_place.as_ref()) {\n-                        item_msg = format!(\"`{}`\", desc);\n+                        item_msg = format!(\"`{desc}`\");\n                         reason = match error_access {\n-                            AccessKind::Mutate => format!(\", which is behind {}\", pointer_type),\n+                            AccessKind::Mutate => format!(\", which is behind {pointer_type}\"),\n                             AccessKind::MutableBorrow => {\n-                                format!(\", as it is behind {}\", pointer_type)\n+                                format!(\", as it is behind {pointer_type}\")\n                             }\n                         }\n                     } else {\n-                        item_msg = format!(\"data in {}\", pointer_type);\n+                        item_msg = format!(\"data in {pointer_type}\");\n                         reason = String::new();\n                     }\n                 }\n@@ -362,29 +362,27 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n                 let upvar_hir_id = captured_place.get_root_variable();\n \n-                if let Some(Node::Binding(pat)) = self.infcx.tcx.hir().find(upvar_hir_id) {\n-                    if let hir::PatKind::Binding(\n+                if let Some(Node::Binding(pat)) = self.infcx.tcx.hir().find(upvar_hir_id)\n+                    && let hir::PatKind::Binding(\n                         hir::BindingAnnotation::Unannotated,\n                         _,\n                         upvar_ident,\n                         _,\n                     ) = pat.kind\n-                    {\n-                        err.span_suggestion(\n-                            upvar_ident.span,\n-                            \"consider changing this to be mutable\",\n-                            format!(\"mut {}\", upvar_ident.name),\n-                            Applicability::MachineApplicable,\n-                        );\n-                    }\n+                {\n+                    err.span_suggestion(\n+                        upvar_ident.span,\n+                        \"consider changing this to be mutable\",\n+                        format!(\"mut {}\", upvar_ident.name),\n+                        Applicability::MachineApplicable,\n+                    );\n                 }\n \n                 let tcx = self.infcx.tcx;\n                 if let ty::Ref(_, ty, Mutability::Mut) = the_place_err.ty(self.body, tcx).ty.kind()\n+                    && let ty::Closure(id, _) = *ty.kind()\n                 {\n-                    if let ty::Closure(id, _) = *ty.kind() {\n-                        self.show_mutating_upvar(tcx, id, the_place_err, &mut err);\n-                    }\n+                    self.show_mutating_upvar(tcx, id, the_place_err, &mut err);\n                 }\n             }\n \n@@ -544,8 +542,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                                     err.span_suggestion(\n                                         err_help_span,\n                                         &format!(\n-                                            \"consider changing this to be a mutable {}\",\n-                                            pointer_desc\n+                                            \"consider changing this to be a mutable {pointer_desc}\"\n                                         ),\n                                         suggested_code,\n                                         Applicability::MachineApplicable,\n@@ -554,8 +551,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                                     err.span_suggestion(\n                                         x,\n                                         &format!(\n-                                            \"consider changing that to be a mutable {}\",\n-                                            pointer_desc\n+                                            \"consider changing that to be a mutable {pointer_desc}\"\n                                         ),\n                                         suggested_code,\n                                         Applicability::MachineApplicable,\n@@ -606,15 +602,13 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     Some(BorrowedContentSource::OverloadedDeref(ty)) => {\n                         err.help(&format!(\n                             \"trait `DerefMut` is required to modify through a dereference, \\\n-                                but it is not implemented for `{}`\",\n-                            ty,\n+                                but it is not implemented for `{ty}`\",\n                         ));\n                     }\n                     Some(BorrowedContentSource::OverloadedIndex(ty)) => {\n                         err.help(&format!(\n                             \"trait `IndexMut` is required to modify indexed content, \\\n-                                but it is not implemented for `{}`\",\n-                            ty,\n+                                but it is not implemented for `{ty}`\",\n                         ));\n                     }\n                     _ => (),\n@@ -724,18 +718,18 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                             ty::UpvarCapture::ByRef(\n                                 ty::BorrowKind::MutBorrow | ty::BorrowKind::UniqueImmBorrow,\n                             ) => {\n-                                capture_reason = format!(\"mutable borrow of `{}`\", upvar);\n+                                capture_reason = format!(\"mutable borrow of `{upvar}`\");\n                             }\n                             ty::UpvarCapture::ByValue => {\n-                                capture_reason = format!(\"possible mutation of `{}`\", upvar);\n+                                capture_reason = format!(\"possible mutation of `{upvar}`\");\n                             }\n-                            _ => bug!(\"upvar `{}` borrowed, but not mutably\", upvar),\n+                            _ => bug!(\"upvar `{upvar}` borrowed, but not mutably\"),\n                         }\n                         break;\n                     }\n                 }\n                 if capture_reason.is_empty() {\n-                    bug!(\"upvar `{}` borrowed, but cannot find reason\", upvar);\n+                    bug!(\"upvar `{upvar}` borrowed, but cannot find reason\");\n                 }\n                 capture_reason\n             } else {\n@@ -829,27 +823,27 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                                         .as_str()\n                                         .starts_with(&original_method_ident.name.to_string())\n                             })\n-                            .map(|ident| format!(\"{}()\", ident))\n+                            .map(|ident| format!(\"{ident}()\"))\n                             .peekable()\n                     });\n \n-                if let Some(mut suggestions) = opt_suggestions {\n-                    if suggestions.peek().is_some() {\n-                        err.span_suggestions(\n-                            *span,\n-                            \"use mutable method\",\n-                            suggestions,\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n+                if let Some(mut suggestions) = opt_suggestions\n+                    && suggestions.peek().is_some()\n+                {\n+                    err.span_suggestions(\n+                        *span,\n+                        \"use mutable method\",\n+                        suggestions,\n+                        Applicability::MaybeIncorrect,\n+                    );\n                 }\n             }\n         };\n     }\n \n     /// Targeted error when encountering an `FnMut` closure where an `Fn` closure was expected.\n     fn expected_fn_found_fn_mut_call(&self, err: &mut Diagnostic, sp: Span, act: &str) {\n-        err.span_label(sp, format!(\"cannot {}\", act));\n+        err.span_label(sp, format!(\"cannot {act}\"));\n \n         let hir = self.infcx.tcx.hir();\n         let closure_id = self.mir_hir_id();\n@@ -1011,35 +1005,35 @@ fn suggest_ampmut<'tcx>(\n     opt_assignment_rhs_span: Option<Span>,\n     opt_ty_info: Option<Span>,\n ) -> (Span, String) {\n-    if let Some(assignment_rhs_span) = opt_assignment_rhs_span {\n-        if let Ok(src) = tcx.sess.source_map().span_to_snippet(assignment_rhs_span) {\n-            let is_mutbl = |ty: &str| -> bool {\n-                if let Some(rest) = ty.strip_prefix(\"mut\") {\n-                    match rest.chars().next() {\n-                        // e.g. `&mut x`\n-                        Some(c) if c.is_whitespace() => true,\n-                        // e.g. `&mut(x)`\n-                        Some('(') => true,\n-                        // e.g. `&mut{x}`\n-                        Some('{') => true,\n-                        // e.g. `&mutablevar`\n-                        _ => false,\n-                    }\n-                } else {\n-                    false\n-                }\n-            };\n-            if let (true, Some(ws_pos)) = (src.starts_with(\"&'\"), src.find(char::is_whitespace)) {\n-                let lt_name = &src[1..ws_pos];\n-                let ty = src[ws_pos..].trim_start();\n-                if !is_mutbl(ty) {\n-                    return (assignment_rhs_span, format!(\"&{} mut {}\", lt_name, ty));\n-                }\n-            } else if let Some(stripped) = src.strip_prefix('&') {\n-                let stripped = stripped.trim_start();\n-                if !is_mutbl(stripped) {\n-                    return (assignment_rhs_span, format!(\"&mut {}\", stripped));\n+    if let Some(assignment_rhs_span) = opt_assignment_rhs_span\n+        && let Ok(src) = tcx.sess.source_map().span_to_snippet(assignment_rhs_span)\n+    {\n+        let is_mutbl = |ty: &str| -> bool {\n+            if let Some(rest) = ty.strip_prefix(\"mut\") {\n+                match rest.chars().next() {\n+                    // e.g. `&mut x`\n+                    Some(c) if c.is_whitespace() => true,\n+                    // e.g. `&mut(x)`\n+                    Some('(') => true,\n+                    // e.g. `&mut{x}`\n+                    Some('{') => true,\n+                    // e.g. `&mutablevar`\n+                    _ => false,\n                 }\n+            } else {\n+                false\n+            }\n+        };\n+        if let (true, Some(ws_pos)) = (src.starts_with(\"&'\"), src.find(char::is_whitespace)) {\n+            let lt_name = &src[1..ws_pos];\n+            let ty = src[ws_pos..].trim_start();\n+            if !is_mutbl(ty) {\n+                return (assignment_rhs_span, format!(\"&{lt_name} mut {ty}\"));\n+            }\n+        } else if let Some(stripped) = src.strip_prefix('&') {\n+            let stripped = stripped.trim_start();\n+            if !is_mutbl(stripped) {\n+                return (assignment_rhs_span, format!(\"&mut {stripped}\"));\n             }\n         }\n     }\n@@ -1054,12 +1048,12 @@ fn suggest_ampmut<'tcx>(\n         None => local_decl.source_info.span,\n     };\n \n-    if let Ok(src) = tcx.sess.source_map().span_to_snippet(highlight_span) {\n-        if let (true, Some(ws_pos)) = (src.starts_with(\"&'\"), src.find(char::is_whitespace)) {\n-            let lt_name = &src[1..ws_pos];\n-            let ty = &src[ws_pos..];\n-            return (highlight_span, format!(\"&{} mut{}\", lt_name, ty));\n-        }\n+    if let Ok(src) = tcx.sess.source_map().span_to_snippet(highlight_span)\n+        && let (true, Some(ws_pos)) = (src.starts_with(\"&'\"), src.find(char::is_whitespace))\n+    {\n+        let lt_name = &src[1..ws_pos];\n+        let ty = &src[ws_pos..];\n+        return (highlight_span, format!(\"&{} mut{}\", lt_name, ty));\n     }\n \n     let ty_mut = local_decl.ty.builtin_deref(true).unwrap();"}, {"sha": "ab9c206a46f4519e872d41945445bddc32306db1", "filename": "compiler/rustc_borrowck/src/diagnostics/outlives_suggestion.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fbdb10f9fabe47eb763cb4b52b5721740cc63783/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Foutlives_suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdb10f9fabe47eb763cb4b52b5721740cc63783/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Foutlives_suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Foutlives_suggestion.rs?ref=fbdb10f9fabe47eb763cb4b52b5721740cc63783", "patch": "@@ -168,13 +168,12 @@ impl OutlivesSuggestionBuilder {\n         let fr_name = self.region_vid_to_name(mbcx, errci.fr);\n         let outlived_fr_name = self.region_vid_to_name(mbcx, errci.outlived_fr);\n \n-        if let (Some(fr_name), Some(outlived_fr_name)) = (fr_name, outlived_fr_name) {\n-            if !matches!(outlived_fr_name.source, RegionNameSource::Static) {\n-                diag.help(&format!(\n-                    \"consider adding the following bound: `{}: {}`\",\n-                    fr_name, outlived_fr_name\n-                ));\n-            }\n+        if let (Some(fr_name), Some(outlived_fr_name)) = (fr_name, outlived_fr_name)\n+            && !matches!(outlived_fr_name.source, RegionNameSource::Static)\n+        {\n+            diag.help(&format!(\n+                \"consider adding the following bound: `{fr_name}: {outlived_fr_name}`\",\n+            ));\n         }\n     }\n "}, {"sha": "5fd9ecf4513661c4301705d5d0db35c7950a122d", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fbdb10f9fabe47eb763cb4b52b5721740cc63783/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdb10f9fabe47eb763cb4b52b5721740cc63783/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=fbdb10f9fabe47eb763cb4b52b5721740cc63783", "patch": "@@ -337,7 +337,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     ty::Ref(_, inner_ty, mutbl) => {\n                         assert_eq!(*mutbl, rustc_hir::Mutability::Mut);\n                         (\n-                            format!(\"a mutable reference to `{}`\", inner_ty),\n+                            format!(\"a mutable reference to `{inner_ty}`\"),\n                             \"mutable references are invariant over their type parameter\"\n                                 .to_string(),\n                         )\n@@ -523,23 +523,19 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         if let Some((Some(outlived_fr_name), outlived_fr_span)) = outlived_fr_name_and_span {\n             diag.span_label(\n                 outlived_fr_span,\n-                format!(\n-                    \"`{}` declared here, outside of the {} body\",\n-                    outlived_fr_name, escapes_from\n-                ),\n+                format!(\"`{outlived_fr_name}` declared here, outside of the {escapes_from} body\",),\n             );\n         }\n \n         if let Some((Some(fr_name), fr_span)) = fr_name_and_span {\n             diag.span_label(\n                 fr_span,\n                 format!(\n-                    \"`{}` is a reference that is only valid in the {} body\",\n-                    fr_name, escapes_from\n+                    \"`{fr_name}` is a reference that is only valid in the {escapes_from} body\",\n                 ),\n             );\n \n-            diag.span_label(*span, format!(\"`{}` escapes the {} body here\", fr_name, escapes_from));\n+            diag.span_label(*span, format!(\"`{fr_name}` escapes the {escapes_from} body here\"));\n         }\n \n         // Only show an extra note if we can find an 'error region' for both of the region\n@@ -611,9 +607,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 diag.span_label(\n                     *span,\n                     format!(\n-                        \"{} was supposed to return data with lifetime `{}` but it is returning \\\n-                         data with lifetime `{}`\",\n-                        mir_def_name, outlived_fr_name, fr_name\n+                        \"{mir_def_name} was supposed to return data with lifetime `{outlived_fr_name}` but it is returning \\\n+                         data with lifetime `{fr_name}`\",\n                     ),\n                 );\n             }\n@@ -698,7 +693,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 // If there is a static predicate, then the only sensible suggestion is to replace\n                 // fr with `'static`.\n                 if has_static_predicate {\n-                    diag.help(&format!(\"consider replacing `{}` with `{}`\", fr_name, static_str));\n+                    diag.help(&format!(\"consider replacing `{fr_name}` with `{static_str}`\"));\n                 } else {\n                     // Otherwise, we should suggest adding a constraint on the return type.\n                     let span = self.infcx.tcx.def_span(did);\n@@ -714,14 +709,13 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         } else {\n                             span\n                         };\n-                        let suggestion = format!(\" + {}\", suggestable_fr_name);\n+                        let suggestion = format!(\" + {suggestable_fr_name}\");\n                         let span = span.shrink_to_hi();\n                         diag.span_suggestion(\n                             span,\n                             &format!(\n                                 \"to allow this `impl Trait` to capture borrowed data with lifetime \\\n-                                 `{}`, add `{}` as a bound\",\n-                                fr_name, suggestable_fr_name,\n+                                 `{fr_name}`, add `{suggestable_fr_name}` as a bound\",\n                             ),\n                             suggestion,\n                             Applicability::MachineApplicable,"}, {"sha": "7742813888e535848e185b5404e6d85992aec197", "filename": "compiler/rustc_borrowck/src/diagnostics/region_name.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fbdb10f9fabe47eb763cb4b52b5721740cc63783/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdb10f9fabe47eb763cb4b52b5721740cc63783/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs?ref=fbdb10f9fabe47eb763cb4b52b5721740cc63783", "patch": "@@ -102,27 +102,24 @@ impl RegionName {\n         match &self.source {\n             RegionNameSource::NamedFreeRegion(span)\n             | RegionNameSource::NamedEarlyBoundRegion(span) => {\n-                diag.span_label(*span, format!(\"lifetime `{}` defined here\", self));\n+                diag.span_label(*span, format!(\"lifetime `{self}` defined here\"));\n             }\n             RegionNameSource::SynthesizedFreeEnvRegion(span, note) => {\n-                diag.span_label(\n-                    *span,\n-                    format!(\"lifetime `{}` represents this closure's body\", self),\n-                );\n+                diag.span_label(*span, format!(\"lifetime `{self}` represents this closure's body\"));\n                 diag.note(note);\n             }\n             RegionNameSource::AnonRegionFromArgument(RegionNameHighlight::CannotMatchHirTy(\n                 span,\n                 type_name,\n             )) => {\n-                diag.span_label(*span, format!(\"has type `{}`\", type_name));\n+                diag.span_label(*span, format!(\"has type `{type_name}`\"));\n             }\n             RegionNameSource::AnonRegionFromArgument(RegionNameHighlight::MatchedHirTy(span))\n             | RegionNameSource::AnonRegionFromOutput(RegionNameHighlight::MatchedHirTy(span), _)\n             | RegionNameSource::AnonRegionFromAsyncFn(span) => {\n                 diag.span_label(\n                     *span,\n-                    format!(\"let's call the lifetime of this reference `{}`\", self),\n+                    format!(\"let's call the lifetime of this reference `{self}`\"),\n                 );\n             }\n             RegionNameSource::AnonRegionFromArgument(\n@@ -132,15 +129,15 @@ impl RegionName {\n                 RegionNameHighlight::MatchedAdtAndSegment(span),\n                 _,\n             ) => {\n-                diag.span_label(*span, format!(\"let's call this `{}`\", self));\n+                diag.span_label(*span, format!(\"let's call this `{self}`\"));\n             }\n             RegionNameSource::AnonRegionFromArgument(RegionNameHighlight::Occluded(\n                 span,\n                 type_name,\n             )) => {\n                 diag.span_label(\n                     *span,\n-                    format!(\"lifetime `{}` appears in the type {}\", self, type_name),\n+                    format!(\"lifetime `{self}` appears in the type {type_name}\"),\n                 );\n             }\n             RegionNameSource::AnonRegionFromOutput(\n@@ -150,25 +147,24 @@ impl RegionName {\n                 diag.span_label(\n                     *span,\n                     format!(\n-                        \"return type{} `{}` contains a lifetime `{}`\",\n-                        mir_description, type_name, self\n+                        \"return type{mir_description} `{type_name}` contains a lifetime `{self}`\"\n                     ),\n                 );\n             }\n             RegionNameSource::AnonRegionFromUpvar(span, upvar_name) => {\n                 diag.span_label(\n                     *span,\n-                    format!(\"lifetime `{}` appears in the type of `{}`\", self, upvar_name),\n+                    format!(\"lifetime `{self}` appears in the type of `{upvar_name}`\"),\n                 );\n             }\n             RegionNameSource::AnonRegionFromOutput(\n                 RegionNameHighlight::CannotMatchHirTy(span, type_name),\n                 mir_description,\n             ) => {\n-                diag.span_label(*span, format!(\"return type{} is {}\", mir_description, type_name));\n+                diag.span_label(*span, format!(\"return type{mir_description} is {type_name}\"));\n             }\n             RegionNameSource::AnonRegionFromYieldTy(span, type_name) => {\n-                diag.span_label(*span, format!(\"yield type is {}\", type_name));\n+                diag.span_label(*span, format!(\"yield type is {type_name}\"));\n             }\n             RegionNameSource::Static => {}\n         }\n@@ -442,7 +438,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n             \"highlight_if_we_cannot_match_hir_ty: type_name={:?} needle_fr={:?}\",\n             type_name, needle_fr\n         );\n-        if type_name.contains(&format!(\"'{}\", counter)) {\n+        if type_name.contains(&format!(\"'{counter}\")) {\n             // Only add a label if we can confirm that a region was labelled.\n             RegionNameHighlight::CannotMatchHirTy(span, type_name)\n         } else {\n@@ -809,7 +805,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n         // Note: generators from `async fn` yield `()`, so we don't have to\n         // worry about them here.\n         let yield_ty = self.regioncx.universal_regions().yield_ty?;\n-        debug!(\"give_name_if_anonymous_region_appears_in_yield_ty: yield_ty = {:?}\", yield_ty,);\n+        debug!(\"give_name_if_anonymous_region_appears_in_yield_ty: yield_ty = {:?}\", yield_ty);\n \n         let tcx = self.infcx.tcx;\n "}, {"sha": "498b2f1b081b3308dd65720a419537a7db89f7dc", "filename": "compiler/rustc_const_eval/src/const_eval/eval_queries.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fbdb10f9fabe47eb763cb4b52b5721740cc63783/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdb10f9fabe47eb763cb4b52b5721740cc63783/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=fbdb10f9fabe47eb763cb4b52b5721740cc63783", "patch": "@@ -167,17 +167,18 @@ pub(super) fn op_to_const<'tcx>(\n             },\n             Immediate::ScalarPair(a, b) => {\n                 // We know `offset` is relative to the allocation, so we can use `into_parts`.\n-                let (data, start) = match ecx.scalar_to_ptr(a.check_init().unwrap()).into_parts() {\n-                    (Some(alloc_id), offset) => {\n-                        (ecx.tcx.global_alloc(alloc_id).unwrap_memory(), offset.bytes())\n-                    }\n-                    (None, _offset) => (\n-                        ecx.tcx.intern_const_alloc(Allocation::from_bytes_byte_aligned_immutable(\n-                            b\"\" as &[u8],\n-                        )),\n-                        0,\n-                    ),\n-                };\n+                let (data, start) =\n+                    match ecx.scalar_to_ptr(a.check_init().unwrap()).unwrap().into_parts() {\n+                        (Some(alloc_id), offset) => {\n+                            (ecx.tcx.global_alloc(alloc_id).unwrap_memory(), offset.bytes())\n+                        }\n+                        (None, _offset) => (\n+                            ecx.tcx.intern_const_alloc(\n+                                Allocation::from_bytes_byte_aligned_immutable(b\"\" as &[u8]),\n+                            ),\n+                            0,\n+                        ),\n+                    };\n                 let len = b.to_machine_usize(ecx).unwrap();\n                 let start = start.try_into().unwrap();\n                 let len: usize = len.try_into().unwrap();"}, {"sha": "d57504deeab90594d79bd30d4c7baec4dbbda4a5", "filename": "compiler/rustc_const_eval/src/const_eval/machine.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fbdb10f9fabe47eb763cb4b52b5721740cc63783/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdb10f9fabe47eb763cb4b52b5721740cc63783/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=fbdb10f9fabe47eb763cb4b52b5721740cc63783", "patch": "@@ -197,8 +197,8 @@ impl interpret::MayLeak for ! {\n }\n \n impl<'mir, 'tcx: 'mir> CompileTimeEvalContext<'mir, 'tcx> {\n-    fn guaranteed_eq(&mut self, a: Scalar, b: Scalar) -> bool {\n-        match (a, b) {\n+    fn guaranteed_eq(&mut self, a: Scalar, b: Scalar) -> InterpResult<'tcx, bool> {\n+        Ok(match (a, b) {\n             // Comparisons between integers are always known.\n             (Scalar::Int { .. }, Scalar::Int { .. }) => a == b,\n             // Equality with integers can never be known for sure.\n@@ -207,25 +207,25 @@ impl<'mir, 'tcx: 'mir> CompileTimeEvalContext<'mir, 'tcx> {\n             // some things (like functions and vtables) do not have stable addresses\n             // so we need to be careful around them (see e.g. #73722).\n             (Scalar::Ptr(..), Scalar::Ptr(..)) => false,\n-        }\n+        })\n     }\n \n-    fn guaranteed_ne(&mut self, a: Scalar, b: Scalar) -> bool {\n-        match (a, b) {\n+    fn guaranteed_ne(&mut self, a: Scalar, b: Scalar) -> InterpResult<'tcx, bool> {\n+        Ok(match (a, b) {\n             // Comparisons between integers are always known.\n             (Scalar::Int(_), Scalar::Int(_)) => a != b,\n             // Comparisons of abstract pointers with null pointers are known if the pointer\n             // is in bounds, because if they are in bounds, the pointer can't be null.\n             // Inequality with integers other than null can never be known for sure.\n             (Scalar::Int(int), ptr @ Scalar::Ptr(..))\n             | (ptr @ Scalar::Ptr(..), Scalar::Int(int)) => {\n-                int.is_null() && !self.scalar_may_be_null(ptr)\n+                int.is_null() && !self.scalar_may_be_null(ptr)?\n             }\n             // FIXME: return `true` for at least some comparisons where we can reliably\n             // determine the result of runtime inequality tests at compile-time.\n             // Examples include comparison of addresses in different static items.\n             (Scalar::Ptr(..), Scalar::Ptr(..)) => false,\n-        }\n+        })\n     }\n }\n \n@@ -329,9 +329,9 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n                 let a = ecx.read_immediate(&args[0])?.to_scalar()?;\n                 let b = ecx.read_immediate(&args[1])?.to_scalar()?;\n                 let cmp = if intrinsic_name == sym::ptr_guaranteed_eq {\n-                    ecx.guaranteed_eq(a, b)\n+                    ecx.guaranteed_eq(a, b)?\n                 } else {\n-                    ecx.guaranteed_ne(a, b)\n+                    ecx.guaranteed_ne(a, b)?\n                 };\n                 ecx.write_scalar(Scalar::from_bool(cmp), dest)?;\n             }"}, {"sha": "3ea3729dbcd17d765c1be73eba98948927cb08c5", "filename": "compiler/rustc_const_eval/src/interpret/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbdb10f9fabe47eb763cb4b52b5721740cc63783/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdb10f9fabe47eb763cb4b52b5721740cc63783/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs?ref=fbdb10f9fabe47eb763cb4b52b5721740cc63783", "patch": "@@ -283,7 +283,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 if let Some(entry_idx) = vptr_entry_idx {\n                     let entry_idx = u64::try_from(entry_idx).unwrap();\n                     let (old_data, old_vptr) = val.to_scalar_pair()?;\n-                    let old_vptr = self.scalar_to_ptr(old_vptr);\n+                    let old_vptr = self.scalar_to_ptr(old_vptr)?;\n                     let new_vptr = self\n                         .read_new_vtable_after_trait_upcasting_from_vtable(old_vptr, entry_idx)?;\n                     self.write_immediate(Immediate::new_dyn_trait(old_data, new_vptr, self), dest)"}, {"sha": "f0fff602fe4cfbf8a647c415035898a04eaa8e6f", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbdb10f9fabe47eb763cb4b52b5721740cc63783/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdb10f9fabe47eb763cb4b52b5721740cc63783/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=fbdb10f9fabe47eb763cb4b52b5721740cc63783", "patch": "@@ -640,7 +640,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 Ok(Some((size, align)))\n             }\n             ty::Dynamic(..) => {\n-                let vtable = self.scalar_to_ptr(metadata.unwrap_meta());\n+                let vtable = self.scalar_to_ptr(metadata.unwrap_meta())?;\n                 // Read size and align from vtable (already checks size).\n                 Ok(Some(self.read_size_and_align_from_vtable(vtable)?))\n             }"}, {"sha": "1fda60c021eed7f744a53d30e97799cae93d8940", "filename": "compiler/rustc_const_eval/src/interpret/intern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbdb10f9fabe47eb763cb4b52b5721740cc63783/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdb10f9fabe47eb763cb4b52b5721740cc63783/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs?ref=fbdb10f9fabe47eb763cb4b52b5721740cc63783", "patch": "@@ -202,7 +202,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx, const_eval::Memory\n             if let ty::Dynamic(..) =\n                 tcx.struct_tail_erasing_lifetimes(referenced_ty, self.ecx.param_env).kind()\n             {\n-                let ptr = self.ecx.scalar_to_ptr(mplace.meta.unwrap_meta());\n+                let ptr = self.ecx.scalar_to_ptr(mplace.meta.unwrap_meta())?;\n                 if let Some(alloc_id) = ptr.provenance {\n                     // Explicitly choose const mode here, since vtables are immutable, even\n                     // if the reference of the fat pointer is mutable."}, {"sha": "556a44a52381960ba47bae4242f04ef315767e73", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 23, "deletions": 15, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/fbdb10f9fabe47eb763cb4b52b5721740cc63783/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdb10f9fabe47eb763cb4b52b5721740cc63783/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=fbdb10f9fabe47eb763cb4b52b5721740cc63783", "patch": "@@ -1102,30 +1102,38 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n /// Machine pointer introspection.\n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n-    pub fn scalar_to_ptr(&self, scalar: Scalar<M::PointerTag>) -> Pointer<Option<M::PointerTag>> {\n+    pub fn scalar_to_ptr(\n+        &self,\n+        scalar: Scalar<M::PointerTag>,\n+    ) -> InterpResult<'tcx, Pointer<Option<M::PointerTag>>> {\n         // We use `to_bits_or_ptr_internal` since we are just implementing the method people need to\n         // call to force getting out a pointer.\n-        match scalar.to_bits_or_ptr_internal(self.pointer_size()) {\n-            Err(ptr) => ptr.into(),\n-            Ok(bits) => {\n-                let addr = u64::try_from(bits).unwrap();\n-                let ptr = M::ptr_from_addr(&self, addr);\n-                if addr == 0 {\n-                    assert!(ptr.provenance.is_none(), \"null pointer can never have an AllocId\");\n+        Ok(\n+            match scalar\n+                .to_bits_or_ptr_internal(self.pointer_size())\n+                .map_err(|s| err_ub!(ScalarSizeMismatch(s)))?\n+            {\n+                Err(ptr) => ptr.into(),\n+                Ok(bits) => {\n+                    let addr = u64::try_from(bits).unwrap();\n+                    let ptr = M::ptr_from_addr(&self, addr);\n+                    if addr == 0 {\n+                        assert!(ptr.provenance.is_none(), \"null pointer can never have an AllocId\");\n+                    }\n+                    ptr\n                 }\n-                ptr\n-            }\n-        }\n+            },\n+        )\n     }\n \n     /// Test if this value might be null.\n     /// If the machine does not support ptr-to-int casts, this is conservative.\n-    pub fn scalar_may_be_null(&self, scalar: Scalar<M::PointerTag>) -> bool {\n-        match scalar.try_to_int() {\n+    pub fn scalar_may_be_null(&self, scalar: Scalar<M::PointerTag>) -> InterpResult<'tcx, bool> {\n+        Ok(match scalar.try_to_int() {\n             Ok(int) => int.is_null(),\n             Err(_) => {\n                 // Can only happen during CTFE.\n-                let ptr = self.scalar_to_ptr(scalar);\n+                let ptr = self.scalar_to_ptr(scalar)?;\n                 match self.ptr_try_get_alloc_id(ptr) {\n                     Ok((alloc_id, offset, _)) => {\n                         let (size, _align) = self\n@@ -1138,7 +1146,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     Err(_offset) => bug!(\"a non-int scalar is always a pointer\"),\n                 }\n             }\n-        }\n+        })\n     }\n \n     /// Turning a \"maybe pointer\" into a proper pointer (and some information"}, {"sha": "dfc0028e87fcc92a2ebd04f8a71dbd06a7e4a229", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fbdb10f9fabe47eb763cb4b52b5721740cc63783/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdb10f9fabe47eb763cb4b52b5721740cc63783/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=fbdb10f9fabe47eb763cb4b52b5721740cc63783", "patch": "@@ -342,7 +342,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         &self,\n         op: &OpTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, Pointer<Option<M::PointerTag>>> {\n-        Ok(self.scalar_to_ptr(self.read_scalar(op)?.check_init()?))\n+        self.scalar_to_ptr(self.read_scalar(op)?.check_init()?)\n     }\n \n     // Turn the wide MPlace into a string (must already be dereferenced!)\n@@ -738,7 +738,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         // okay. Everything else, we conservatively reject.\n                         let ptr_valid = niche_start == 0\n                             && variants_start == variants_end\n-                            && !self.scalar_may_be_null(tag_val);\n+                            && !self.scalar_may_be_null(tag_val)?;\n                         if !ptr_valid {\n                             throw_ub!(InvalidTag(dbg_val))\n                         }"}, {"sha": "51d47af2f8e24c960db26a3619dd4fd82bda3588", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fbdb10f9fabe47eb763cb4b52b5721740cc63783/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdb10f9fabe47eb763cb4b52b5721740cc63783/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=fbdb10f9fabe47eb763cb4b52b5721740cc63783", "patch": "@@ -281,7 +281,7 @@ where\n         };\n \n         let mplace = MemPlace {\n-            ptr: self.scalar_to_ptr(ptr.check_init()?),\n+            ptr: self.scalar_to_ptr(ptr.check_init()?)?,\n             // We could use the run-time alignment here. For now, we do not, because\n             // the point of tracking the alignment here is to make sure that the *static*\n             // alignment information emitted with the loads is correct. The run-time\n@@ -1104,7 +1104,7 @@ where\n         &self,\n         mplace: &MPlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, (ty::Instance<'tcx>, MPlaceTy<'tcx, M::PointerTag>)> {\n-        let vtable = self.scalar_to_ptr(mplace.vtable()); // also sanity checks the type\n+        let vtable = self.scalar_to_ptr(mplace.vtable())?; // also sanity checks the type\n         let (instance, ty) = self.read_drop_type_from_vtable(vtable)?;\n         let layout = self.layout_of(ty)?;\n "}, {"sha": "c2664565f15cb18b7dce2a22621f7537769e2678", "filename": "compiler/rustc_const_eval/src/interpret/terminator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbdb10f9fabe47eb763cb4b52b5721740cc63783/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdb10f9fabe47eb763cb4b52b5721740cc63783/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs?ref=fbdb10f9fabe47eb763cb4b52b5721740cc63783", "patch": "@@ -519,7 +519,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         .kind(),\n                     ty::Dynamic(..)\n                 ));\n-                let vtable = self.scalar_to_ptr(receiver_place.meta.unwrap_meta());\n+                let vtable = self.scalar_to_ptr(receiver_place.meta.unwrap_meta())?;\n                 let fn_val = self.get_vtable_slot(vtable, u64::try_from(idx).unwrap())?;\n \n                 // `*mut receiver_place.layout.ty` is almost the layout that we"}, {"sha": "235938422a89313e99ebc0254a2457addfb75752", "filename": "compiler/rustc_const_eval/src/interpret/traits.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fbdb10f9fabe47eb763cb4b52b5721740cc63783/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdb10f9fabe47eb763cb4b52b5721740cc63783/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Ftraits.rs?ref=fbdb10f9fabe47eb763cb4b52b5721740cc63783", "patch": "@@ -50,7 +50,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let vtable_slot = self\n             .get_ptr_alloc(vtable_slot, ptr_size, self.tcx.data_layout.pointer_align.abi)?\n             .expect(\"cannot be a ZST\");\n-        let fn_ptr = self.scalar_to_ptr(vtable_slot.read_ptr_sized(Size::ZERO)?.check_init()?);\n+        let fn_ptr = self.scalar_to_ptr(vtable_slot.read_ptr_sized(Size::ZERO)?.check_init()?)?;\n         self.get_ptr_fn(fn_ptr)\n     }\n \n@@ -75,7 +75,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             .check_init()?;\n         // We *need* an instance here, no other kind of function value, to be able\n         // to determine the type.\n-        let drop_instance = self.get_ptr_fn(self.scalar_to_ptr(drop_fn))?.as_instance()?;\n+        let drop_instance = self.get_ptr_fn(self.scalar_to_ptr(drop_fn)?)?.as_instance()?;\n         trace!(\"Found drop fn: {:?}\", drop_instance);\n         let fn_sig = drop_instance.ty(*self.tcx, self.param_env).fn_sig(*self.tcx);\n         let fn_sig = self.tcx.normalize_erasing_late_bound_regions(self.param_env, fn_sig);\n@@ -132,7 +132,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             .get_ptr_alloc(vtable_slot, pointer_size, self.tcx.data_layout.pointer_align.abi)?\n             .expect(\"cannot be a ZST\");\n \n-        let new_vtable = self.scalar_to_ptr(new_vtable.read_ptr_sized(Size::ZERO)?.check_init()?);\n+        let new_vtable =\n+            self.scalar_to_ptr(new_vtable.read_ptr_sized(Size::ZERO)?.check_init()?)?;\n \n         Ok(new_vtable)\n     }"}, {"sha": "4a0aa41de739b3caa13f0ed80fa3170fc8c3d331", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fbdb10f9fabe47eb763cb4b52b5721740cc63783/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdb10f9fabe47eb763cb4b52b5721740cc63783/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=fbdb10f9fabe47eb763cb4b52b5721740cc63783", "patch": "@@ -312,7 +312,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         let tail = self.ecx.tcx.struct_tail_erasing_lifetimes(pointee.ty, self.ecx.param_env);\n         match tail.kind() {\n             ty::Dynamic(..) => {\n-                let vtable = self.ecx.scalar_to_ptr(meta.unwrap_meta());\n+                let vtable = self.ecx.scalar_to_ptr(meta.unwrap_meta())?;\n                 // Direct call to `check_ptr_access_align` checks alignment even on CTFE machines.\n                 try_validation!(\n                     self.ecx.check_ptr_access_align(\n@@ -577,7 +577,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n \n                 // If we check references recursively, also check that this points to a function.\n                 if let Some(_) = self.ref_tracking {\n-                    let ptr = self.ecx.scalar_to_ptr(value);\n+                    let ptr = self.ecx.scalar_to_ptr(value)?;\n                     let _fn = try_validation!(\n                         self.ecx.get_ptr_fn(ptr),\n                         self.path,\n@@ -590,7 +590,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                     // FIXME: Check if the signature matches\n                 } else {\n                     // Otherwise (for standalone Miri), we have to still check it to be non-null.\n-                    if self.ecx.scalar_may_be_null(value) {\n+                    if self.ecx.scalar_may_be_null(value)? {\n                         throw_validation_failure!(self.path, { \"a null function pointer\" });\n                     }\n                 }\n@@ -667,7 +667,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 // We support 2 kinds of ranges here: full range, and excluding zero.\n                 if start == 1 && end == max_value {\n                     // Only null is the niche.  So make sure the ptr is NOT null.\n-                    if self.ecx.scalar_may_be_null(value) {\n+                    if self.ecx.scalar_may_be_null(value)? {\n                         throw_validation_failure!(self.path,\n                             { \"a potentially null pointer\" }\n                             expected {"}, {"sha": "438f356f072c6d863e093668d022327785efb3d9", "filename": "compiler/rustc_middle/src/mir/interpret/allocation.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fbdb10f9fabe47eb763cb4b52b5721740cc63783/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdb10f9fabe47eb763cb4b52b5721740cc63783/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs?ref=fbdb10f9fabe47eb763cb4b52b5721740cc63783", "patch": "@@ -15,8 +15,8 @@ use rustc_target::abi::{Align, HasDataLayout, Size};\n \n use super::{\n     read_target_uint, write_target_uint, AllocId, InterpError, InterpResult, Pointer, Provenance,\n-    ResourceExhaustionInfo, Scalar, ScalarMaybeUninit, UndefinedBehaviorInfo, UninitBytesAccess,\n-    UnsupportedOpInfo,\n+    ResourceExhaustionInfo, Scalar, ScalarMaybeUninit, ScalarSizeMismatch, UndefinedBehaviorInfo,\n+    UninitBytesAccess, UnsupportedOpInfo,\n };\n use crate::ty;\n \n@@ -81,6 +81,8 @@ impl<'tcx, Tag, Extra> ConstAllocation<'tcx, Tag, Extra> {\n /// is added when converting to `InterpError`.\n #[derive(Debug)]\n pub enum AllocError {\n+    /// A scalar had the wrong size.\n+    ScalarSizeMismatch(ScalarSizeMismatch),\n     /// Encountered a pointer where we needed raw bytes.\n     ReadPointerAsBytes,\n     /// Partially overwriting a pointer.\n@@ -90,10 +92,19 @@ pub enum AllocError {\n }\n pub type AllocResult<T = ()> = Result<T, AllocError>;\n \n+impl From<ScalarSizeMismatch> for AllocError {\n+    fn from(s: ScalarSizeMismatch) -> Self {\n+        AllocError::ScalarSizeMismatch(s)\n+    }\n+}\n+\n impl AllocError {\n     pub fn to_interp_error<'tcx>(self, alloc_id: AllocId) -> InterpError<'tcx> {\n         use AllocError::*;\n         match self {\n+            ScalarSizeMismatch(s) => {\n+                InterpError::UndefinedBehavior(UndefinedBehaviorInfo::ScalarSizeMismatch(s))\n+            }\n             ReadPointerAsBytes => InterpError::Unsupported(UnsupportedOpInfo::ReadPointerAsBytes),\n             PartialPointerOverwrite(offset) => InterpError::Unsupported(\n                 UnsupportedOpInfo::PartialPointerOverwrite(Pointer::new(alloc_id, offset)),\n@@ -425,7 +436,7 @@ impl<Tag: Provenance, Extra> Allocation<Tag, Extra> {\n \n         // `to_bits_or_ptr_internal` is the right method because we just want to store this data\n         // as-is into memory.\n-        let (bytes, provenance) = match val.to_bits_or_ptr_internal(range.size) {\n+        let (bytes, provenance) = match val.to_bits_or_ptr_internal(range.size)? {\n             Err(val) => {\n                 let (provenance, offset) = val.into_parts();\n                 (u128::from(offset.bytes()), Some(provenance))"}, {"sha": "9afe9523fcab0438f102cf84226e57f6ee5df2b5", "filename": "compiler/rustc_middle/src/mir/interpret/error.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fbdb10f9fabe47eb763cb4b52b5721740cc63783/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdb10f9fabe47eb763cb4b52b5721740cc63783/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs?ref=fbdb10f9fabe47eb763cb4b52b5721740cc63783", "patch": "@@ -221,6 +221,13 @@ pub struct UninitBytesAccess {\n     pub uninit_size: Size,\n }\n \n+/// Information about a size mismatch.\n+#[derive(Debug)]\n+pub struct ScalarSizeMismatch {\n+    pub target_size: u64,\n+    pub data_size: u64,\n+}\n+\n /// Error information for when the program caused Undefined Behavior.\n pub enum UndefinedBehaviorInfo<'tcx> {\n     /// Free-form case. Only for errors that are never caught!\n@@ -298,10 +305,7 @@ pub enum UndefinedBehaviorInfo<'tcx> {\n     /// Working with a local that is not currently live.\n     DeadLocal,\n     /// Data size is not equal to target size.\n-    ScalarSizeMismatch {\n-        target_size: u64,\n-        data_size: u64,\n-    },\n+    ScalarSizeMismatch(ScalarSizeMismatch),\n     /// A discriminant of an uninhabited enum variant is written.\n     UninhabitedEnumVariantWritten,\n }\n@@ -408,7 +412,7 @@ impl fmt::Display for UndefinedBehaviorInfo<'_> {\n                 \"using uninitialized data, but this operation requires initialized memory\"\n             ),\n             DeadLocal => write!(f, \"accessing a dead local variable\"),\n-            ScalarSizeMismatch { target_size, data_size } => write!(\n+            ScalarSizeMismatch(self::ScalarSizeMismatch { target_size, data_size }) => write!(\n                 f,\n                 \"scalar size mismatch: expected {} bytes but got {} bytes instead\",\n                 target_size, data_size"}, {"sha": "d8cba39c6d97bf9bc58a14321f8f12646e86d081", "filename": "compiler/rustc_middle/src/mir/interpret/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fbdb10f9fabe47eb763cb4b52b5721740cc63783/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdb10f9fabe47eb763cb4b52b5721740cc63783/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs?ref=fbdb10f9fabe47eb763cb4b52b5721740cc63783", "patch": "@@ -120,7 +120,8 @@ use crate::ty::{self, Instance, Ty, TyCtxt};\n pub use self::error::{\n     struct_error, CheckInAllocMsg, ErrorHandled, EvalToAllocationRawResult, EvalToConstValueResult,\n     InterpError, InterpErrorInfo, InterpResult, InvalidProgramInfo, MachineStopType,\n-    ResourceExhaustionInfo, UndefinedBehaviorInfo, UninitBytesAccess, UnsupportedOpInfo,\n+    ResourceExhaustionInfo, ScalarSizeMismatch, UndefinedBehaviorInfo, UninitBytesAccess,\n+    UnsupportedOpInfo,\n };\n \n pub use self::value::{get_slice_bytes, ConstAlloc, ConstValue, Scalar, ScalarMaybeUninit};"}, {"sha": "9cffdf2993ed5bdb97c2ddba9a2beddb0a3ae61c", "filename": "compiler/rustc_middle/src/mir/interpret/value.rs", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fbdb10f9fabe47eb763cb4b52b5721740cc63783/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdb10f9fabe47eb763cb4b52b5721740cc63783/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs?ref=fbdb10f9fabe47eb763cb4b52b5721740cc63783", "patch": "@@ -12,6 +12,7 @@ use crate::ty::{Lift, ParamEnv, ScalarInt, Ty, TyCtxt};\n \n use super::{\n     AllocId, AllocRange, ConstAllocation, InterpResult, Pointer, PointerArithmetic, Provenance,\n+    ScalarSizeMismatch,\n };\n \n /// Represents the result of const evaluation via the `eval_to_allocation` query.\n@@ -300,16 +301,29 @@ impl<Tag> Scalar<Tag> {\n     ///\n     /// This method only exists for the benefit of low-level operations that truly need to treat the\n     /// scalar in whatever form it is.\n+    ///\n+    /// This throws UB (instead of ICEing) on a size mismatch since size mismatches can arise in\n+    /// Miri when someone declares a function that we shim (such as `malloc`) with a wrong type.\n     #[inline]\n-    pub fn to_bits_or_ptr_internal(self, target_size: Size) -> Result<u128, Pointer<Tag>> {\n+    pub fn to_bits_or_ptr_internal(\n+        self,\n+        target_size: Size,\n+    ) -> Result<Result<u128, Pointer<Tag>>, ScalarSizeMismatch> {\n         assert_ne!(target_size.bytes(), 0, \"you should never look at the bits of a ZST\");\n-        match self {\n-            Scalar::Int(int) => Ok(int.assert_bits(target_size)),\n+        Ok(match self {\n+            Scalar::Int(int) => Ok(int.to_bits(target_size).map_err(|size| {\n+                ScalarSizeMismatch { target_size: target_size.bytes(), data_size: size.bytes() }\n+            })?),\n             Scalar::Ptr(ptr, sz) => {\n-                assert_eq!(target_size.bytes(), u64::from(sz));\n+                if target_size.bytes() != sz.into() {\n+                    return Err(ScalarSizeMismatch {\n+                        target_size: target_size.bytes(),\n+                        data_size: sz.into(),\n+                    });\n+                }\n                 Err(ptr)\n             }\n-        }\n+        })\n     }\n }\n \n@@ -348,10 +362,10 @@ impl<'tcx, Tag: Provenance> Scalar<Tag> {\n         assert_ne!(target_size.bytes(), 0, \"you should never look at the bits of a ZST\");\n         self.try_to_int().map_err(|_| err_unsup!(ReadPointerAsBytes))?.to_bits(target_size).map_err(\n             |size| {\n-                err_ub!(ScalarSizeMismatch {\n+                err_ub!(ScalarSizeMismatch(ScalarSizeMismatch {\n                     target_size: target_size.bytes(),\n                     data_size: size.bytes(),\n-                })\n+                }))\n                 .into()\n             },\n         )"}, {"sha": "bb3ba3e596d1449b996ec065eaab5108b26344ce", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbdb10f9fabe47eb763cb4b52b5721740cc63783/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdb10f9fabe47eb763cb4b52b5721740cc63783/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=fbdb10f9fabe47eb763cb4b52b5721740cc63783", "patch": "@@ -146,7 +146,7 @@ impl IntRange {\n                     // straight to the result, after doing a bit of checking. (We\n                     // could remove this branch and just fall through, which\n                     // is more general but much slower.)\n-                    if let Ok(bits) = scalar.to_bits_or_ptr_internal(target_size) {\n+                    if let Ok(bits) = scalar.to_bits_or_ptr_internal(target_size).unwrap() {\n                         return Some(bits);\n                     }\n                 }"}, {"sha": "2bcb3182a7bf2eac0ec9b998ba0c78350bcfc1f1", "filename": "library/panic_abort/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fbdb10f9fabe47eb763cb4b52b5721740cc63783/library%2Fpanic_abort%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdb10f9fabe47eb763cb4b52b5721740cc63783/library%2Fpanic_abort%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fpanic_abort%2Fsrc%2Flib.rs?ref=fbdb10f9fabe47eb763cb4b52b5721740cc63783", "patch": "@@ -65,6 +65,7 @@ pub unsafe extern \"C-unwind\" fn __rust_start_panic(_payload: *mut &mut dyn BoxMe\n             //\n             // Note: this is the same implementation as in libstd's `abort_internal`\n             unsafe fn abort() -> ! {\n+                #[allow(unused)]\n                 const FAST_FAIL_FATAL_APP_EXIT: usize = 7;\n                 cfg_if::cfg_if! {\n                     if #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))] {"}, {"sha": "cf51d8da16db5afd3136797712fcb56230b751d9", "filename": "library/proc_macro/src/bridge/client.rs", "status": "modified", "additions": 31, "deletions": 15, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/fbdb10f9fabe47eb763cb4b52b5721740cc63783/library%2Fproc_macro%2Fsrc%2Fbridge%2Fclient.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdb10f9fabe47eb763cb4b52b5721740cc63783/library%2Fproc_macro%2Fsrc%2Fbridge%2Fclient.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fclient.rs?ref=fbdb10f9fabe47eb763cb4b52b5721740cc63783", "patch": "@@ -2,6 +2,8 @@\n \n use super::*;\n \n+use std::marker::PhantomData;\n+\n macro_rules! define_handles {\n     (\n         'owned: $($oty:ident,)*\n@@ -45,20 +47,25 @@ macro_rules! define_handles {\n \n         $(\n             #[repr(C)]\n-            pub(crate) struct $oty(handle::Handle);\n-            impl !Send for $oty {}\n-            impl !Sync for $oty {}\n+            pub(crate) struct $oty {\n+                handle: handle::Handle,\n+                // Prevent Send and Sync impls\n+                _marker: PhantomData<*mut ()>,\n+            }\n \n             // Forward `Drop::drop` to the inherent `drop` method.\n             impl Drop for $oty {\n                 fn drop(&mut self) {\n-                    $oty(self.0).drop();\n+                    $oty {\n+                        handle: self.handle,\n+                        _marker: PhantomData,\n+                    }.drop();\n                 }\n             }\n \n             impl<S> Encode<S> for $oty {\n                 fn encode(self, w: &mut Writer, s: &mut S) {\n-                    let handle = self.0;\n+                    let handle = self.handle;\n                     mem::forget(self);\n                     handle.encode(w, s);\n                 }\n@@ -74,7 +81,7 @@ macro_rules! define_handles {\n \n             impl<S> Encode<S> for &$oty {\n                 fn encode(self, w: &mut Writer, s: &mut S) {\n-                    self.0.encode(w, s);\n+                    self.handle.encode(w, s);\n                 }\n             }\n \n@@ -88,7 +95,7 @@ macro_rules! define_handles {\n \n             impl<S> Encode<S> for &mut $oty {\n                 fn encode(self, w: &mut Writer, s: &mut S) {\n-                    self.0.encode(w, s);\n+                    self.handle.encode(w, s);\n                 }\n             }\n \n@@ -113,21 +120,26 @@ macro_rules! define_handles {\n \n             impl<S> DecodeMut<'_, '_, S> for $oty {\n                 fn decode(r: &mut Reader<'_>, s: &mut S) -> Self {\n-                    $oty(handle::Handle::decode(r, s))\n+                    $oty {\n+                        handle: handle::Handle::decode(r, s),\n+                        _marker: PhantomData,\n+                    }\n                 }\n             }\n         )*\n \n         $(\n             #[repr(C)]\n             #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n-            pub(crate) struct $ity(handle::Handle);\n-            impl !Send for $ity {}\n-            impl !Sync for $ity {}\n+            pub(crate) struct $ity {\n+                handle: handle::Handle,\n+                // Prevent Send and Sync impls\n+                _marker: PhantomData<*mut ()>,\n+            }\n \n             impl<S> Encode<S> for $ity {\n                 fn encode(self, w: &mut Writer, s: &mut S) {\n-                    self.0.encode(w, s);\n+                    self.handle.encode(w, s);\n                 }\n             }\n \n@@ -149,7 +161,10 @@ macro_rules! define_handles {\n \n             impl<S> DecodeMut<'_, '_, S> for $ity {\n                 fn decode(r: &mut Reader<'_>, s: &mut S) -> Self {\n-                    $ity(handle::Handle::decode(r, s))\n+                    $ity {\n+                        handle: handle::Handle::decode(r, s),\n+                        _marker: PhantomData,\n+                    }\n                 }\n             }\n         )*\n@@ -310,15 +325,16 @@ impl Bridge<'_> {\n         // NB. the server can't do this because it may use a different libstd.\n         static HIDE_PANICS_DURING_EXPANSION: Once = Once::new();\n         HIDE_PANICS_DURING_EXPANSION.call_once(|| {\n-            panic::update_hook(move |prev, info| {\n+            let prev = panic::take_hook();\n+            panic::set_hook(Box::new(move |info| {\n                 let show = BridgeState::with(|state| match state {\n                     BridgeState::NotConnected => true,\n                     BridgeState::Connected(_) | BridgeState::InUse => force_show_panics,\n                 });\n                 if show {\n                     prev(info)\n                 }\n-            });\n+            }));\n         });\n \n         BRIDGE_STATE.with(|state| state.set(BridgeState::Connected(self), f))"}, {"sha": "06f76d2fc9140aa903bc91f36c7d12cfc63e16ec", "filename": "library/proc_macro/src/bridge/closure.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fbdb10f9fabe47eb763cb4b52b5721740cc63783/library%2Fproc_macro%2Fsrc%2Fbridge%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdb10f9fabe47eb763cb4b52b5721740cc63783/library%2Fproc_macro%2Fsrc%2Fbridge%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fclosure.rs?ref=fbdb10f9fabe47eb763cb4b52b5721740cc63783", "patch": "@@ -1,24 +1,23 @@\n //! Closure type (equivalent to `&mut dyn FnMut(A) -> R`) that's `repr(C)`.\n \n+use std::marker::PhantomData;\n+\n #[repr(C)]\n pub struct Closure<'a, A, R> {\n-    call: unsafe extern \"C\" fn(&mut Env, A) -> R,\n-    env: &'a mut Env,\n-}\n-\n-extern \"C\" {\n-    type Env;\n+    call: unsafe extern \"C\" fn(*mut Env, A) -> R,\n+    env: *mut Env,\n+    // Ensure Closure is !Send and !Sync\n+    _marker: PhantomData<*mut &'a mut ()>,\n }\n \n-impl<'a, A, R> !Sync for Closure<'a, A, R> {}\n-impl<'a, A, R> !Send for Closure<'a, A, R> {}\n+struct Env;\n \n impl<'a, A, R, F: FnMut(A) -> R> From<&'a mut F> for Closure<'a, A, R> {\n     fn from(f: &'a mut F) -> Self {\n-        unsafe extern \"C\" fn call<A, R, F: FnMut(A) -> R>(env: &mut Env, arg: A) -> R {\n+        unsafe extern \"C\" fn call<A, R, F: FnMut(A) -> R>(env: *mut Env, arg: A) -> R {\n             (*(env as *mut _ as *mut F))(arg)\n         }\n-        Closure { call: call::<A, R, F>, env: unsafe { &mut *(f as *mut _ as *mut Env) } }\n+        Closure { call: call::<A, R, F>, env: f as *mut _ as *mut Env, _marker: PhantomData }\n     }\n }\n "}, {"sha": "f7c9df6564f873753fce668e298ce399489e9e07", "filename": "library/proc_macro/src/bridge/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fbdb10f9fabe47eb763cb4b52b5721740cc63783/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdb10f9fabe47eb763cb4b52b5721740cc63783/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs?ref=fbdb10f9fabe47eb763cb4b52b5721740cc63783", "patch": "@@ -231,10 +231,10 @@ pub struct Bridge<'a> {\n \n     /// If 'true', always invoke the default panic hook\n     force_show_panics: bool,\n-}\n \n-impl<'a> !Sync for Bridge<'a> {}\n-impl<'a> !Send for Bridge<'a> {}\n+    // Prevent Send and Sync impls\n+    _marker: marker::PhantomData<*mut ()>,\n+}\n \n #[forbid(unsafe_code)]\n #[allow(non_camel_case_types)]"}, {"sha": "2e0400d32a0af0024776ad05d6efb3c80b6bc22d", "filename": "library/proc_macro/src/bridge/server.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fbdb10f9fabe47eb763cb4b52b5721740cc63783/library%2Fproc_macro%2Fsrc%2Fbridge%2Fserver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdb10f9fabe47eb763cb4b52b5721740cc63783/library%2Fproc_macro%2Fsrc%2Fbridge%2Fserver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fserver.rs?ref=fbdb10f9fabe47eb763cb4b52b5721740cc63783", "patch": "@@ -153,7 +153,12 @@ impl ExecutionStrategy for SameThread {\n         let mut dispatch = |b| dispatcher.dispatch(b);\n \n         run_client(\n-            Bridge { cached_buffer: input, dispatch: (&mut dispatch).into(), force_show_panics },\n+            Bridge {\n+                cached_buffer: input,\n+                dispatch: (&mut dispatch).into(),\n+                force_show_panics,\n+                _marker: marker::PhantomData,\n+            },\n             client_data,\n         )\n     }\n@@ -189,6 +194,7 @@ impl ExecutionStrategy for CrossThread1 {\n                     cached_buffer: input,\n                     dispatch: (&mut dispatch).into(),\n                     force_show_panics,\n+                    _marker: marker::PhantomData,\n                 },\n                 client_data,\n             )\n@@ -241,6 +247,7 @@ impl ExecutionStrategy for CrossThread2 {\n                     cached_buffer: input,\n                     dispatch: (&mut dispatch).into(),\n                     force_show_panics,\n+                    _marker: marker::PhantomData,\n                 },\n                 client_data,\n             );"}, {"sha": "00b8bb1eb2637706833f8bd1b6eea3909cc5c87c", "filename": "library/proc_macro/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fbdb10f9fabe47eb763cb4b52b5721740cc63783/library%2Fproc_macro%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdb10f9fabe47eb763cb4b52b5721740cc63783/library%2Fproc_macro%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Flib.rs?ref=fbdb10f9fabe47eb763cb4b52b5721740cc63783", "patch": "@@ -17,18 +17,18 @@\n     test(no_crate_inject, attr(deny(warnings))),\n     test(attr(allow(dead_code, deprecated, unused_variables, unused_mut)))\n )]\n+// This library is copied into rust-analyzer to allow loading rustc compiled proc macros.\n+// Please avoid unstable features where possible to minimize the amount of changes necessary\n+// to make it compile with rust-analyzer on stable.\n #![feature(rustc_allow_const_fn_unstable)]\n #![feature(nll)]\n #![feature(staged_api)]\n #![feature(allow_internal_unstable)]\n #![feature(decl_macro)]\n-#![feature(extern_types)]\n #![feature(negative_impls)]\n-#![feature(auto_traits)]\n #![feature(restricted_std)]\n #![feature(rustc_attrs)]\n #![feature(min_specialization)]\n-#![feature(panic_update_hook)]\n #![recursion_limit = \"256\"]\n \n #[unstable(feature = \"proc_macro_internals\", issue = \"27812\")]"}, {"sha": "47917e57b19ed53f38a223d43ec2a6733ff405fe", "filename": "library/std/src/sys/windows/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fbdb10f9fabe47eb763cb4b52b5721740cc63783/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdb10f9fabe47eb763cb4b52b5721740cc63783/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs?ref=fbdb10f9fabe47eb763cb4b52b5721740cc63783", "patch": "@@ -289,6 +289,7 @@ pub fn dur2timeout(dur: Duration) -> c::DWORD {\n /// that function for more information on `__fastfail`\n #[allow(unreachable_code)]\n pub fn abort_internal() -> ! {\n+    #[allow(unused)]\n     const FAST_FAIL_FATAL_APP_EXIT: usize = 7;\n     #[cfg(not(miri))] // inline assembly does not work in Miri\n     unsafe {"}, {"sha": "d06e4fa1cc2f57cefef059ac9f2a1675fe3cc2c3", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fbdb10f9fabe47eb763cb4b52b5721740cc63783/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdb10f9fabe47eb763cb4b52b5721740cc63783/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=fbdb10f9fabe47eb763cb4b52b5721740cc63783", "patch": "@@ -425,13 +425,26 @@ crate fn build_impl(\n         None => (\n             tcx.associated_items(did)\n                 .in_definition_order()\n-                .filter_map(|item| {\n-                    if associated_trait.is_some() || item.vis.is_public() {\n-                        Some(item.clean(cx))\n+                .filter(|item| {\n+                    // If this is a trait impl, filter out associated items whose corresponding item\n+                    // in the associated trait is marked `doc(hidden)`.\n+                    // If this is an inherent impl, filter out private associated items.\n+                    if let Some(associated_trait) = associated_trait {\n+                        let trait_item = tcx\n+                            .associated_items(associated_trait.def_id)\n+                            .find_by_name_and_kind(\n+                                tcx,\n+                                item.ident(tcx),\n+                                item.kind,\n+                                associated_trait.def_id,\n+                            )\n+                            .unwrap(); // corresponding associated item has to exist\n+                        !tcx.is_doc_hidden(trait_item.def_id)\n                     } else {\n-                        None\n+                        item.vis.is_public()\n                     }\n                 })\n+                .map(|item| item.clean(cx))\n                 .collect::<Vec<_>>(),\n             clean::enter_impl_trait(cx, |cx| {\n                 clean_ty_generics(cx, tcx.generics_of(did), predicates)"}, {"sha": "3baf8a6c07ee8e203311cc6abda56cf90e32dd94", "filename": "src/test/rustdoc/auxiliary/cross-crate-hidden-assoc-trait-items.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fbdb10f9fabe47eb763cb4b52b5721740cc63783/src%2Ftest%2Frustdoc%2Fauxiliary%2Fcross-crate-hidden-assoc-trait-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdb10f9fabe47eb763cb4b52b5721740cc63783/src%2Ftest%2Frustdoc%2Fauxiliary%2Fcross-crate-hidden-assoc-trait-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fauxiliary%2Fcross-crate-hidden-assoc-trait-items.rs?ref=fbdb10f9fabe47eb763cb4b52b5721740cc63783", "patch": "@@ -0,0 +1,19 @@\n+pub trait Tr {\n+    type VisibleAssoc;\n+    #[doc(hidden)]\n+    type HiddenAssoc;\n+\n+    const VISIBLE_ASSOC: ();\n+    #[doc(hidden)]\n+    const HIDDEN_ASSOC: ();\n+}\n+\n+pub struct Ty;\n+\n+impl Tr for Ty {\n+    type VisibleAssoc = ();\n+    type HiddenAssoc = ();\n+\n+    const VISIBLE_ASSOC: () = ();\n+    const HIDDEN_ASSOC: () = ();\n+}"}, {"sha": "d02bc4fe712505ea412efa34bb90fdf102c76cc4", "filename": "src/test/rustdoc/cross-crate-hidden-assoc-trait-items.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fbdb10f9fabe47eb763cb4b52b5721740cc63783/src%2Ftest%2Frustdoc%2Fcross-crate-hidden-assoc-trait-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdb10f9fabe47eb763cb4b52b5721740cc63783/src%2Ftest%2Frustdoc%2Fcross-crate-hidden-assoc-trait-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fcross-crate-hidden-assoc-trait-items.rs?ref=fbdb10f9fabe47eb763cb4b52b5721740cc63783", "patch": "@@ -0,0 +1,23 @@\n+// Regression test for issue #95717\n+// Hide cross-crate `#[doc(hidden)]` associated items in trait impls.\n+\n+#![crate_name = \"dependent\"]\n+// edition:2021\n+// aux-crate:dependency=cross-crate-hidden-assoc-trait-items.rs\n+\n+// The trait `Tr` contains 2 hidden and 2 visisible associated items.\n+// Instead of checking for the absence of the hidden items, check for the presence of the\n+// visible items instead and assert that there are *exactly two* associated items\n+// (by counting the number of `section`s). This is more robust and future-proof.\n+\n+// @has dependent/struct.Ty.html\n+// @has - '//*[@id=\"associatedtype.VisibleAssoc\"]' 'type VisibleAssoc = ()'\n+// @has - '//*[@id=\"associatedconstant.VISIBLE_ASSOC\"]' 'const VISIBLE_ASSOC: ()'\n+// @count - '//*[@class=\"impl-items\"]/section' 2\n+\n+// @has dependent/trait.Tr.html\n+// @has - '//*[@id=\"associatedtype.VisibleAssoc-1\"]' 'type VisibleAssoc = ()'\n+// @has - '//*[@id=\"associatedconstant.VISIBLE_ASSOC-1\"]' 'const VISIBLE_ASSOC: ()'\n+// @count - '//*[@class=\"impl-items\"]/section' 2\n+\n+pub use dependency::{Tr, Ty};"}, {"sha": "e6f71c9cadf9bbd2eff21334d1d51016c7f5e19d", "filename": "src/tools/rls", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frls?ref=fbdb10f9fabe47eb763cb4b52b5721740cc63783", "patch": "@@ -1 +1 @@\n-Subproject commit 3df74381f37617ec800537c11fb0c3130f5f3616\n+Subproject commit e6f71c9cadf9bbd2eff21334d1d51016c7f5e19d"}]}