{"sha": "3315edfae7854d1f9f58840bbec4d43392c3fa51", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzMTVlZGZhZTc4NTRkMWY5ZjU4ODQwYmJlYzRkNDMzOTJjM2ZhNTE=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@gmail", "date": "2013-07-17T10:12:08Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@gmail", "date": "2013-07-23T13:38:55Z"}, "message": "Adapted `trans::common::{block, fn_ctxt, scope_info}` to new naming convention.", "tree": {"sha": "f09c4e3f00e3938b252b02cf3d801ebfc9c04802", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f09c4e3f00e3938b252b02cf3d801ebfc9c04802"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3315edfae7854d1f9f58840bbec4d43392c3fa51", "comment_count": 8, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3315edfae7854d1f9f58840bbec4d43392c3fa51", "html_url": "https://github.com/rust-lang/rust/commit/3315edfae7854d1f9f58840bbec4d43392c3fa51", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3315edfae7854d1f9f58840bbec4d43392c3fa51/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "69a237ed7b40221c0f0bf8dc3774fddc3832f62d", "url": "https://api.github.com/repos/rust-lang/rust/commits/69a237ed7b40221c0f0bf8dc3774fddc3832f62d", "html_url": "https://github.com/rust-lang/rust/commit/69a237ed7b40221c0f0bf8dc3774fddc3832f62d"}], "stats": {"total": 1317, "additions": 657, "deletions": 660}, "files": [{"sha": "2ff0c39476feb80f87b72f0c6b561cff38558d91", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 51, "deletions": 51, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/3315edfae7854d1f9f58840bbec4d43392c3fa51/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3315edfae7854d1f9f58840bbec4d43392c3fa51/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=3315edfae7854d1f9f58840bbec4d43392c3fa51", "patch": "@@ -258,7 +258,7 @@ pub enum opt_result {\n     lower_bound(Result),\n     range_result(Result, Result),\n }\n-pub fn trans_opt(bcx: block, o: &Opt) -> opt_result {\n+pub fn trans_opt(bcx: @mut Block, o: &Opt) -> opt_result {\n     let _icx = push_ctxt(\"match::trans_opt\");\n     let ccx = bcx.ccx();\n     let bcx = bcx;\n@@ -292,7 +292,7 @@ pub fn trans_opt(bcx: block, o: &Opt) -> opt_result {\n     }\n }\n \n-pub fn variant_opt(bcx: block, pat_id: ast::node_id)\n+pub fn variant_opt(bcx: @mut Block, pat_id: ast::node_id)\n     -> Opt {\n     let ccx = bcx.ccx();\n     match ccx.tcx.def_map.get_copy(&pat_id) {\n@@ -342,7 +342,7 @@ pub type BindingsMap = HashMap<ident, BindingInfo>;\n \n #[deriving(Clone)]\n pub struct ArmData<'self> {\n-    bodycx: block,\n+    bodycx: @mut Block,\n     arm: &'self ast::arm,\n     bindings_map: @BindingsMap\n }\n@@ -353,7 +353,7 @@ pub struct Match<'self> {\n     data: ArmData<'self>\n }\n \n-pub fn match_to_str(bcx: block, m: &Match) -> ~str {\n+pub fn match_to_str(bcx: @mut Block, m: &Match) -> ~str {\n     if bcx.sess().verbose() {\n         // for many programs, this just take too long to serialize\n         fmt!(\"%?\", m.pats.map(|p| pat_to_str(*p, bcx.sess().intr())))\n@@ -362,7 +362,7 @@ pub fn match_to_str(bcx: block, m: &Match) -> ~str {\n     }\n }\n \n-pub fn matches_to_str(bcx: block, m: &[Match]) -> ~str {\n+pub fn matches_to_str(bcx: @mut Block, m: &[Match]) -> ~str {\n     fmt!(\"%?\", m.map(|n| match_to_str(bcx, n)))\n }\n \n@@ -376,7 +376,7 @@ pub fn has_nested_bindings(m: &[Match], col: uint) -> bool {\n     return false;\n }\n \n-pub fn expand_nested_bindings<'r>(bcx: block,\n+pub fn expand_nested_bindings<'r>(bcx: @mut Block,\n                                   m: &[Match<'r>],\n                                   col: uint,\n                                   val: ValueRef)\n@@ -411,7 +411,7 @@ pub fn expand_nested_bindings<'r>(bcx: block,\n     }\n }\n \n-pub fn assert_is_binding_or_wild(bcx: block, p: @ast::pat) {\n+pub fn assert_is_binding_or_wild(bcx: @mut Block, p: @ast::pat) {\n     if !pat_is_binding_or_wild(bcx.tcx().def_map, p) {\n         bcx.sess().span_bug(\n             p.span,\n@@ -422,7 +422,7 @@ pub fn assert_is_binding_or_wild(bcx: block, p: @ast::pat) {\n \n pub type enter_pat<'self> = &'self fn(@ast::pat) -> Option<~[@ast::pat]>;\n \n-pub fn enter_match<'r>(bcx: block,\n+pub fn enter_match<'r>(bcx: @mut Block,\n                        dm: DefMap,\n                        m: &[Match<'r>],\n                        col: uint,\n@@ -472,7 +472,7 @@ pub fn enter_match<'r>(bcx: block,\n     return result;\n }\n \n-pub fn enter_default<'r>(bcx: block,\n+pub fn enter_default<'r>(bcx: @mut Block,\n                          dm: DefMap,\n                          m: &[Match<'r>],\n                          col: uint,\n@@ -518,7 +518,7 @@ pub fn enter_default<'r>(bcx: block,\n // <nmatsakis> so all patterns must either be records (resp. tuples) or\n //             wildcards\n \n-pub fn enter_opt<'r>(bcx: block,\n+pub fn enter_opt<'r>(bcx: @mut Block,\n                      m: &[Match<'r>],\n                      opt: &Opt,\n                      col: uint,\n@@ -630,7 +630,7 @@ pub fn enter_opt<'r>(bcx: block,\n     }\n }\n \n-pub fn enter_rec_or_struct<'r>(bcx: block,\n+pub fn enter_rec_or_struct<'r>(bcx: @mut Block,\n                                dm: DefMap,\n                                m: &[Match<'r>],\n                                col: uint,\n@@ -665,7 +665,7 @@ pub fn enter_rec_or_struct<'r>(bcx: block,\n     }\n }\n \n-pub fn enter_tup<'r>(bcx: block,\n+pub fn enter_tup<'r>(bcx: @mut Block,\n                      dm: DefMap,\n                      m: &[Match<'r>],\n                      col: uint,\n@@ -691,7 +691,7 @@ pub fn enter_tup<'r>(bcx: block,\n     }\n }\n \n-pub fn enter_tuple_struct<'r>(bcx: block,\n+pub fn enter_tuple_struct<'r>(bcx: @mut Block,\n                               dm: DefMap,\n                               m: &[Match<'r>],\n                               col: uint,\n@@ -717,7 +717,7 @@ pub fn enter_tuple_struct<'r>(bcx: block,\n     }\n }\n \n-pub fn enter_box<'r>(bcx: block,\n+pub fn enter_box<'r>(bcx: @mut Block,\n                      dm: DefMap,\n                      m: &[Match<'r>],\n                      col: uint,\n@@ -744,7 +744,7 @@ pub fn enter_box<'r>(bcx: block,\n     }\n }\n \n-pub fn enter_uniq<'r>(bcx: block,\n+pub fn enter_uniq<'r>(bcx: @mut Block,\n                       dm: DefMap,\n                       m: &[Match<'r>],\n                       col: uint,\n@@ -771,7 +771,7 @@ pub fn enter_uniq<'r>(bcx: block,\n     }\n }\n \n-pub fn enter_region<'r>(bcx: block,\n+pub fn enter_region<'r>(bcx: @mut Block,\n                         dm: DefMap,\n                         m: &[Match<'r>],\n                         col: uint,\n@@ -801,7 +801,7 @@ pub fn enter_region<'r>(bcx: block,\n // Returns the options in one column of matches. An option is something that\n // needs to be conditionally matched at runtime; for example, the discriminant\n // on a set of enum variants or a literal.\n-pub fn get_options(bcx: block, m: &[Match], col: uint) -> ~[Opt] {\n+pub fn get_options(bcx: @mut Block, m: &[Match], col: uint) -> ~[Opt] {\n     let ccx = bcx.ccx();\n     fn add_to_set(tcx: ty::ctxt, set: &mut ~[Opt], val: Opt) {\n         if set.iter().any(|l| opt_eq(tcx, l, &val)) {return;}\n@@ -869,10 +869,10 @@ pub fn get_options(bcx: block, m: &[Match], col: uint) -> ~[Opt] {\n \n pub struct ExtractedBlock {\n     vals: ~[ValueRef],\n-    bcx: block\n+    bcx: @mut Block\n }\n \n-pub fn extract_variant_args(bcx: block,\n+pub fn extract_variant_args(bcx: @mut Block,\n                             repr: &adt::Repr,\n                             disr_val: int,\n                             val: ValueRef)\n@@ -885,7 +885,7 @@ pub fn extract_variant_args(bcx: block,\n     ExtractedBlock { vals: args, bcx: bcx }\n }\n \n-fn match_datum(bcx: block, val: ValueRef, pat_id: ast::node_id) -> Datum {\n+fn match_datum(bcx: @mut Block, val: ValueRef, pat_id: ast::node_id) -> Datum {\n     //! Helper for converting from the ValueRef that we pass around in\n     //! the match code, which is always by ref, into a Datum. Eventually\n     //! we should just pass around a Datum and be done with it.\n@@ -895,7 +895,7 @@ fn match_datum(bcx: block, val: ValueRef, pat_id: ast::node_id) -> Datum {\n }\n \n \n-pub fn extract_vec_elems(bcx: block,\n+pub fn extract_vec_elems(bcx: @mut Block,\n                          pat_span: span,\n                          pat_id: ast::node_id,\n                          elem_count: uint,\n@@ -950,7 +950,7 @@ pub fn extract_vec_elems(bcx: block,\n }\n \n // NB: This function does not collect fields from struct-like enum variants.\n-pub fn collect_record_or_struct_fields(bcx: block,\n+pub fn collect_record_or_struct_fields(bcx: @mut Block,\n                                        m: &[Match],\n                                        col: uint)\n                                     -> ~[ast::ident] {\n@@ -978,7 +978,7 @@ pub fn collect_record_or_struct_fields(bcx: block,\n     }\n }\n \n-pub fn pats_require_rooting(bcx: block,\n+pub fn pats_require_rooting(bcx: @mut Block,\n                             m: &[Match],\n                             col: uint)\n                          -> bool {\n@@ -989,11 +989,11 @@ pub fn pats_require_rooting(bcx: block,\n     }\n }\n \n-pub fn root_pats_as_necessary(mut bcx: block,\n+pub fn root_pats_as_necessary(mut bcx: @mut Block,\n                               m: &[Match],\n                               col: uint,\n                               val: ValueRef)\n-                           -> block {\n+                           -> @mut Block {\n     for m.iter().advance |br| {\n         let pat_id = br.pats[col].id;\n         if pat_id != 0 {\n@@ -1036,7 +1036,7 @@ pub fn any_tup_pat(m: &[Match], col: uint) -> bool {\n     any_pat!(m, ast::pat_tup(_))\n }\n \n-pub fn any_tuple_struct_pat(bcx: block, m: &[Match], col: uint) -> bool {\n+pub fn any_tuple_struct_pat(bcx: @mut Block, m: &[Match], col: uint) -> bool {\n     do m.iter().any |br| {\n         let pat = br.pats[col];\n         match pat.node {\n@@ -1090,7 +1090,7 @@ pub enum branch_kind { no_branch, single, switch, compare, compare_vec_len, }\n // Compiles a comparison between two things.\n //\n // NB: This must produce an i1, not a Rust bool (i8).\n-pub fn compare_values(cx: block,\n+pub fn compare_values(cx: @mut Block,\n                       lhs: ValueRef,\n                       rhs: ValueRef,\n                       rhs_t: ty::t)\n@@ -1133,10 +1133,10 @@ pub fn compare_values(cx: block,\n     }\n }\n \n-fn store_non_ref_bindings(bcx: block,\n+fn store_non_ref_bindings(bcx: @mut Block,\n                           bindings_map: &BindingsMap,\n                           mut opt_temp_cleanups: Option<&mut ~[ValueRef]>)\n-                          -> block\n+                          -> @mut Block\n {\n     /*!\n      *\n@@ -1167,10 +1167,10 @@ fn store_non_ref_bindings(bcx: block,\n     return bcx;\n }\n \n-fn insert_lllocals(bcx: block,\n+fn insert_lllocals(bcx: @mut Block,\n                    bindings_map: &BindingsMap,\n                    binding_mode: IrrefutablePatternBindingMode,\n-                   add_cleans: bool) -> block {\n+                   add_cleans: bool) -> @mut Block {\n     /*!\n      * For each binding in `data.bindings_map`, adds an appropriate entry into\n      * the `fcx.lllocals` map.  If add_cleans is true, then adds cleanups for\n@@ -1206,13 +1206,13 @@ fn insert_lllocals(bcx: block,\n     return bcx;\n }\n \n-pub fn compile_guard(bcx: block,\n+pub fn compile_guard(bcx: @mut Block,\n                      guard_expr: @ast::expr,\n                      data: &ArmData,\n                      m: &[Match],\n                      vals: &[ValueRef],\n                      chk: Option<mk_fail>)\n-                  -> block {\n+                  -> @mut Block {\n     debug!(\"compile_guard(bcx=%s, guard_expr=%s, m=%s, vals=%?)\",\n            bcx.to_str(),\n            bcx.expr_to_str(guard_expr),\n@@ -1248,7 +1248,7 @@ pub fn compile_guard(bcx: block,\n         bcx\n     };\n \n-    fn drop_bindings(bcx: block, data: &ArmData) -> block {\n+    fn drop_bindings(bcx: @mut Block, data: &ArmData) -> @mut Block {\n         let mut bcx = bcx;\n         for data.bindings_map.each_value |&binding_info| {\n             match binding_info.trmode {\n@@ -1263,7 +1263,7 @@ pub fn compile_guard(bcx: block,\n     }\n }\n \n-pub fn compile_submatch(bcx: block,\n+pub fn compile_submatch(bcx: @mut Block,\n                         m: &[Match],\n                         vals: &[ValueRef],\n                         chk: Option<mk_fail>) {\n@@ -1313,7 +1313,7 @@ pub fn compile_submatch(bcx: block,\n     }\n }\n \n-fn compile_submatch_continue(mut bcx: block,\n+fn compile_submatch_continue(mut bcx: @mut Block,\n                              m: &[Match],\n                              vals: &[ValueRef],\n                              chk: Option<mk_fail>,\n@@ -1625,18 +1625,18 @@ fn compile_submatch_continue(mut bcx: block,\n     }\n }\n \n-pub fn trans_match(bcx: block,\n+pub fn trans_match(bcx: @mut Block,\n                    match_expr: &ast::expr,\n                    discr_expr: @ast::expr,\n                    arms: &[ast::arm],\n-                   dest: Dest) -> block {\n+                   dest: Dest) -> @mut Block {\n     let _icx = push_ctxt(\"match::trans_match\");\n     do with_scope(bcx, match_expr.info(), \"match\") |bcx| {\n         trans_match_inner(bcx, discr_expr, arms, dest)\n     }\n }\n \n-fn create_bindings_map(bcx: block, pat: @ast::pat) -> BindingsMap {\n+fn create_bindings_map(bcx: @mut Block, pat: @ast::pat) -> BindingsMap {\n     // Create the bindings map, which is a mapping from each binding name\n     // to an alloca() that will be the value for that local variable.\n     // Note that we use the names because each binding will have many ids\n@@ -1673,10 +1673,10 @@ fn create_bindings_map(bcx: block, pat: @ast::pat) -> BindingsMap {\n     return bindings_map;\n }\n \n-pub fn trans_match_inner(scope_cx: block,\n+pub fn trans_match_inner(scope_cx: @mut Block,\n                          discr_expr: @ast::expr,\n                          arms: &[ast::arm],\n-                         dest: Dest) -> block {\n+                         dest: Dest) -> @mut Block {\n     let _icx = push_ctxt(\"match::trans_match_inner\");\n     let mut bcx = scope_cx;\n     let tcx = bcx.tcx();\n@@ -1745,7 +1745,7 @@ pub fn trans_match_inner(scope_cx: block,\n     bcx = controlflow::join_blocks(scope_cx, arm_cxs);\n     return bcx;\n \n-    fn mk_fail(bcx: block, sp: span, msg: @str,\n+    fn mk_fail(bcx: @mut Block, sp: span, msg: @str,\n                finished: @mut Option<BasicBlockRef>) -> BasicBlockRef {\n         match *finished { Some(bb) => return bb, _ => () }\n         let fail_cx = sub_block(bcx, \"case_fallthrough\");\n@@ -1762,10 +1762,10 @@ pub enum IrrefutablePatternBindingMode {\n     BindArgument\n }\n \n-pub fn store_local(bcx: block,\n+pub fn store_local(bcx: @mut Block,\n                    pat: @ast::pat,\n                    opt_init_expr: Option<@ast::expr>)\n-                               -> block {\n+                               -> @mut Block {\n     /*!\n      * Generates code for a local variable declaration like\n      * `let <pat>;` or `let <pat> = <opt_init_expr>`.\n@@ -1816,7 +1816,7 @@ pub fn store_local(bcx: block,\n         }\n     };\n \n-    fn create_dummy_locals(mut bcx: block, pat: @ast::pat) -> block {\n+    fn create_dummy_locals(mut bcx: @mut Block, pat: @ast::pat) -> @mut Block {\n         // create dummy memory for the variables if we have no\n         // value to store into them immediately\n         let tcx = bcx.tcx();\n@@ -1829,10 +1829,10 @@ pub fn store_local(bcx: block,\n     }\n }\n \n-pub fn store_arg(mut bcx: block,\n+pub fn store_arg(mut bcx: @mut Block,\n                  pat: @ast::pat,\n                  llval: ValueRef)\n-                 -> block {\n+                 -> @mut Block {\n     /*!\n      * Generates code for argument patterns like `fn foo(<pat>: T)`.\n      * Creates entries in the `llargs` map for each of the bindings\n@@ -1872,11 +1872,11 @@ pub fn store_arg(mut bcx: block,\n     return bcx;\n }\n \n-fn mk_binding_alloca(mut bcx: block,\n+fn mk_binding_alloca(mut bcx: @mut Block,\n                      p_id: ast::node_id,\n                      path: &ast::Path,\n                      binding_mode: IrrefutablePatternBindingMode,\n-                     populate: &fn(block, ty::t, ValueRef) -> block) -> block {\n+                     populate: &fn(@mut Block, ty::t, ValueRef) -> @mut Block) -> @mut Block {\n     let var_ty = node_id_type(bcx, p_id);\n     let ident = ast_util::path_to_ident(path);\n     let llval = alloc_ty(bcx, var_ty, bcx.ident(ident));\n@@ -1890,11 +1890,11 @@ fn mk_binding_alloca(mut bcx: block,\n     return bcx;\n }\n \n-fn bind_irrefutable_pat(bcx: block,\n+fn bind_irrefutable_pat(bcx: @mut Block,\n                         pat: @ast::pat,\n                         val: ValueRef,\n                         binding_mode: IrrefutablePatternBindingMode)\n-                        -> block {\n+                        -> @mut Block {\n     /*!\n      * A simple version of the pattern matching code that only handles\n      * irrefutable patterns. This is used in let/argument patterns,"}, {"sha": "ee53bfdcbda78ca417776fad9ed37e5ddaffaa0c", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3315edfae7854d1f9f58840bbec4d43392c3fa51/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3315edfae7854d1f9f58840bbec4d43392c3fa51/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=3315edfae7854d1f9f58840bbec4d43392c3fa51", "patch": "@@ -106,7 +106,7 @@ pub struct Struct {\n  * these, for places in trans where the `ty::t` isn't directly\n  * available.\n  */\n-pub fn represent_node(bcx: block, node: ast::node_id) -> @Repr {\n+pub fn represent_node(bcx: @mut Block, node: ast::node_id) -> @Repr {\n     represent_type(bcx.ccx(), node_id_type(bcx, node))\n }\n \n@@ -283,7 +283,7 @@ fn struct_llfields(cx: &mut CrateContext, st: &Struct, sizing: bool) -> ~[Type]\n  *\n  * This should ideally be less tightly tied to `_match`.\n  */\n-pub fn trans_switch(bcx: block, r: &Repr, scrutinee: ValueRef)\n+pub fn trans_switch(bcx: @mut Block, r: &Repr, scrutinee: ValueRef)\n     -> (_match::branch_kind, Option<ValueRef>) {\n     match *r {\n         CEnum(*) | General(*) => {\n@@ -301,7 +301,7 @@ pub fn trans_switch(bcx: block, r: &Repr, scrutinee: ValueRef)\n \n \n /// Obtain the actual discriminant of a value.\n-pub fn trans_get_discr(bcx: block, r: &Repr, scrutinee: ValueRef)\n+pub fn trans_get_discr(bcx: @mut Block, r: &Repr, scrutinee: ValueRef)\n     -> ValueRef {\n     match *r {\n         CEnum(min, max) => load_discr(bcx, scrutinee, min, max),\n@@ -315,7 +315,7 @@ pub fn trans_get_discr(bcx: block, r: &Repr, scrutinee: ValueRef)\n     }\n }\n \n-fn nullable_bitdiscr(bcx: block, nonnull: &Struct, nndiscr: int, ptrfield: uint,\n+fn nullable_bitdiscr(bcx: @mut Block, nonnull: &Struct, nndiscr: int, ptrfield: uint,\n                      scrutinee: ValueRef) -> ValueRef {\n     let cmp = if nndiscr == 0 { IntEQ } else { IntNE };\n     let llptr = Load(bcx, GEPi(bcx, scrutinee, [0, ptrfield]));\n@@ -324,7 +324,7 @@ fn nullable_bitdiscr(bcx: block, nonnull: &Struct, nndiscr: int, ptrfield: uint,\n }\n \n /// Helper for cases where the discriminant is simply loaded.\n-fn load_discr(bcx: block, scrutinee: ValueRef, min: int, max: int)\n+fn load_discr(bcx: @mut Block, scrutinee: ValueRef, min: int, max: int)\n     -> ValueRef {\n     let ptr = GEPi(bcx, scrutinee, [0, 0]);\n     if max + 1 == min {\n@@ -348,7 +348,7 @@ fn load_discr(bcx: block, scrutinee: ValueRef, min: int, max: int)\n  *\n  * This should ideally be less tightly tied to `_match`.\n  */\n-pub fn trans_case(bcx: block, r: &Repr, discr: int) -> _match::opt_result {\n+pub fn trans_case(bcx: @mut Block, r: &Repr, discr: int) -> _match::opt_result {\n     match *r {\n         CEnum(*) => {\n             _match::single_result(rslt(bcx, C_int(bcx.ccx(), discr)))\n@@ -371,7 +371,7 @@ pub fn trans_case(bcx: block, r: &Repr, discr: int) -> _match::opt_result {\n  * representation.  The fields, if any, should then be initialized via\n  * `trans_field_ptr`.\n  */\n-pub fn trans_start_init(bcx: block, r: &Repr, val: ValueRef, discr: int) {\n+pub fn trans_start_init(bcx: @mut Block, r: &Repr, val: ValueRef, discr: int) {\n     match *r {\n         CEnum(min, max) => {\n             assert!(min <= discr && discr <= max);\n@@ -417,7 +417,7 @@ pub fn num_args(r: &Repr, discr: int) -> uint {\n }\n \n /// Access a field, at a point when the value's case is known.\n-pub fn trans_field_ptr(bcx: block, r: &Repr, val: ValueRef, discr: int,\n+pub fn trans_field_ptr(bcx: @mut Block, r: &Repr, val: ValueRef, discr: int,\n                        ix: uint) -> ValueRef {\n     // Note: if this ever needs to generate conditionals (e.g., if we\n     // decide to do some kind of cdr-coding-like non-unique repr\n@@ -449,7 +449,7 @@ pub fn trans_field_ptr(bcx: block, r: &Repr, val: ValueRef, discr: int,\n     }\n }\n \n-fn struct_field_ptr(bcx: block, st: &Struct, val: ValueRef, ix: uint,\n+fn struct_field_ptr(bcx: @mut Block, st: &Struct, val: ValueRef, ix: uint,\n               needs_cast: bool) -> ValueRef {\n     let ccx = bcx.ccx();\n \n@@ -467,7 +467,7 @@ fn struct_field_ptr(bcx: block, st: &Struct, val: ValueRef, ix: uint,\n }\n \n /// Access the struct drop flag, if present.\n-pub fn trans_drop_flag_ptr(bcx: block, r: &Repr, val: ValueRef) -> ValueRef {\n+pub fn trans_drop_flag_ptr(bcx: @mut Block, r: &Repr, val: ValueRef) -> ValueRef {\n     match *r {\n         Univariant(ref st, true) => GEPi(bcx, val, [0, st.fields.len() - 1]),\n         _ => bcx.ccx().sess.bug(\"tried to get drop flag of non-droppable type\")"}, {"sha": "b76b76ff603d58066c9645ce2428f2de82f8ce96", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3315edfae7854d1f9f58840bbec4d43392c3fa51/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3315edfae7854d1f9f58840bbec4d43392c3fa51/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=3315edfae7854d1f9f58840bbec4d43392c3fa51", "patch": "@@ -25,7 +25,7 @@ use std::str;\n use syntax::ast;\n \n // Take an inline assembly expression and splat it out via LLVM\n-pub fn trans_inline_asm(bcx: block, ia: &ast::inline_asm) -> block {\n+pub fn trans_inline_asm(bcx: @mut Block, ia: &ast::inline_asm) -> @mut Block {\n \n     let mut bcx = bcx;\n     let mut constraints = ~[];"}, {"sha": "699cfab429b37bc354463f586b6156373f251805", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 108, "deletions": 105, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/3315edfae7854d1f9f58840bbec4d43392c3fa51/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3315edfae7854d1f9f58840bbec4d43392c3fa51/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=3315edfae7854d1f9f58840bbec4d43392c3fa51", "patch": "@@ -131,7 +131,7 @@ pub fn push_ctxt(s: &'static str) -> _InsnCtxt {\n     _InsnCtxt { _x: () }\n }\n \n-fn fcx_has_nonzero_span(fcx: fn_ctxt) -> bool {\n+fn fcx_has_nonzero_span(fcx: &FunctionContext) -> bool {\n     match fcx.span {\n         None => true,\n         Some(span) => *span.lo != 0 || *span.hi != 0\n@@ -228,13 +228,13 @@ pub fn get_extern_const(externs: &mut ExternMap, llmod: ModuleRef,\n         return c;\n     }\n }\n-pub fn umax(cx: block, a: ValueRef, b: ValueRef) -> ValueRef {\n+pub fn umax(cx: @mut Block, a: ValueRef, b: ValueRef) -> ValueRef {\n     let _icx = push_ctxt(\"umax\");\n     let cond = ICmp(cx, lib::llvm::IntULT, a, b);\n     return Select(cx, cond, b, a);\n }\n \n-pub fn umin(cx: block, a: ValueRef, b: ValueRef) -> ValueRef {\n+pub fn umin(cx: @mut Block, a: ValueRef, b: ValueRef) -> ValueRef {\n     let _icx = push_ctxt(\"umin\");\n     let cond = ICmp(cx, lib::llvm::IntULT, a, b);\n     return Select(cx, cond, a, b);\n@@ -243,15 +243,15 @@ pub fn umin(cx: block, a: ValueRef, b: ValueRef) -> ValueRef {\n // Given a pointer p, returns a pointer sz(p) (i.e., inc'd by sz bytes).\n // The type of the returned pointer is always i8*.  If you care about the\n // return type, use bump_ptr().\n-pub fn ptr_offs(bcx: block, base: ValueRef, sz: ValueRef) -> ValueRef {\n+pub fn ptr_offs(bcx: @mut Block, base: ValueRef, sz: ValueRef) -> ValueRef {\n     let _icx = push_ctxt(\"ptr_offs\");\n     let raw = PointerCast(bcx, base, Type::i8p());\n     InBoundsGEP(bcx, raw, [sz])\n }\n \n // Increment a pointer by a given amount and then cast it to be a pointer\n // to a given type.\n-pub fn bump_ptr(bcx: block, t: ty::t, base: ValueRef, sz: ValueRef) ->\n+pub fn bump_ptr(bcx: @mut Block, t: ty::t, base: ValueRef, sz: ValueRef) ->\n    ValueRef {\n     let _icx = push_ctxt(\"bump_ptr\");\n     let ccx = bcx.ccx();\n@@ -265,7 +265,7 @@ pub fn bump_ptr(bcx: block, t: ty::t, base: ValueRef, sz: ValueRef) ->\n // known.\n //\n // The runtime equivalent is box_body() in \"rust_internal.h\".\n-pub fn opaque_box_body(bcx: block,\n+pub fn opaque_box_body(bcx: @mut Block,\n                        body_t: ty::t,\n                        boxptr: ValueRef) -> ValueRef {\n     let _icx = push_ctxt(\"opaque_box_body\");\n@@ -278,14 +278,14 @@ pub fn opaque_box_body(bcx: block,\n \n // malloc_raw_dyn: allocates a box to contain a given type, but with a\n // potentially dynamic size.\n-pub fn malloc_raw_dyn(bcx: block,\n+pub fn malloc_raw_dyn(bcx: @mut Block,\n                       t: ty::t,\n                       heap: heap,\n                       size: ValueRef) -> Result {\n     let _icx = push_ctxt(\"malloc_raw\");\n     let ccx = bcx.ccx();\n \n-    fn require_alloc_fn(bcx: block, t: ty::t, it: LangItem) -> ast::def_id {\n+    fn require_alloc_fn(bcx: @mut Block, t: ty::t, it: LangItem) -> ast::def_id {\n         let li = &bcx.tcx().lang_items;\n         match li.require(it) {\n             Ok(id) => id,\n@@ -345,21 +345,21 @@ pub fn malloc_raw_dyn(bcx: block,\n // malloc_raw: expects an unboxed type and returns a pointer to\n // enough space for a box of that type.  This includes a rust_opaque_box\n // header.\n-pub fn malloc_raw(bcx: block, t: ty::t, heap: heap) -> Result {\n+pub fn malloc_raw(bcx: @mut Block, t: ty::t, heap: heap) -> Result {\n     let ty = type_of(bcx.ccx(), t);\n     let size = llsize_of(bcx.ccx(), ty);\n     malloc_raw_dyn(bcx, t, heap, size)\n }\n \n pub struct MallocResult {\n-    bcx: block,\n+    bcx: @mut Block,\n     box: ValueRef,\n     body: ValueRef\n }\n \n // malloc_general_dyn: usefully wraps malloc_raw_dyn; allocates a box,\n // and pulls out the body\n-pub fn malloc_general_dyn(bcx: block, t: ty::t, heap: heap, size: ValueRef)\n+pub fn malloc_general_dyn(bcx: @mut Block, t: ty::t, heap: heap, size: ValueRef)\n     -> MallocResult {\n     assert!(heap != heap_exchange);\n     let _icx = push_ctxt(\"malloc_general\");\n@@ -369,25 +369,25 @@ pub fn malloc_general_dyn(bcx: block, t: ty::t, heap: heap, size: ValueRef)\n     MallocResult { bcx: bcx, box: llbox, body: body }\n }\n \n-pub fn malloc_general(bcx: block, t: ty::t, heap: heap) -> MallocResult {\n+pub fn malloc_general(bcx: @mut Block, t: ty::t, heap: heap) -> MallocResult {\n     let ty = type_of(bcx.ccx(), t);\n     assert!(heap != heap_exchange);\n     malloc_general_dyn(bcx, t, heap, llsize_of(bcx.ccx(), ty))\n }\n-pub fn malloc_boxed(bcx: block, t: ty::t)\n+pub fn malloc_boxed(bcx: @mut Block, t: ty::t)\n     -> MallocResult {\n     malloc_general(bcx, t, heap_managed)\n }\n \n-pub fn heap_for_unique(bcx: block, t: ty::t) -> heap {\n+pub fn heap_for_unique(bcx: @mut Block, t: ty::t) -> heap {\n     if ty::type_contents(bcx.tcx(), t).contains_managed() {\n         heap_managed_unique\n     } else {\n         heap_exchange\n     }\n }\n \n-pub fn maybe_set_managed_unique_rc(bcx: block, bx: ValueRef, heap: heap) {\n+pub fn maybe_set_managed_unique_rc(bcx: @mut Block, bx: ValueRef, heap: heap) {\n     assert!(heap != heap_exchange);\n     if heap == heap_managed_unique {\n         // In cases where we are looking at a unique-typed allocation in the\n@@ -562,7 +562,7 @@ pub fn maybe_name_value(cx: &CrateContext, v: ValueRef, s: &str) {\n pub enum scalar_type { nil_type, signed_int, unsigned_int, floating_point, }\n \n // NB: This produces an i1, not a Rust bool (i8).\n-pub fn compare_scalar_types(cx: block,\n+pub fn compare_scalar_types(cx: @mut Block,\n                             lhs: ValueRef,\n                             rhs: ValueRef,\n                             t: ty::t,\n@@ -593,14 +593,14 @@ pub fn compare_scalar_types(cx: block,\n \n \n // A helper function to do the actual comparison of scalar values.\n-pub fn compare_scalar_values(cx: block,\n+pub fn compare_scalar_values(cx: @mut Block,\n                              lhs: ValueRef,\n                              rhs: ValueRef,\n                              nt: scalar_type,\n                              op: ast::binop)\n                           -> ValueRef {\n     let _icx = push_ctxt(\"compare_scalar_values\");\n-    fn die(cx: block) -> ! {\n+    fn die(cx: @mut Block) -> ! {\n         cx.tcx().sess.bug(\"compare_scalar_values: must be a\\\n                            comparison operator\");\n     }\n@@ -654,24 +654,24 @@ pub fn compare_scalar_values(cx: block,\n     }\n }\n \n-pub type val_and_ty_fn<'self> = &'self fn(block, ValueRef, ty::t) -> block;\n+pub type val_and_ty_fn<'self> = &'self fn(@mut Block, ValueRef, ty::t) -> @mut Block;\n \n-pub fn load_inbounds(cx: block, p: ValueRef, idxs: &[uint]) -> ValueRef {\n+pub fn load_inbounds(cx: @mut Block, p: ValueRef, idxs: &[uint]) -> ValueRef {\n     return Load(cx, GEPi(cx, p, idxs));\n }\n \n-pub fn store_inbounds(cx: block, v: ValueRef, p: ValueRef, idxs: &[uint]) {\n+pub fn store_inbounds(cx: @mut Block, v: ValueRef, p: ValueRef, idxs: &[uint]) {\n     Store(cx, v, GEPi(cx, p, idxs));\n }\n \n // Iterates through the elements of a structural type.\n-pub fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n-                          f: val_and_ty_fn) -> block {\n+pub fn iter_structural_ty(cx: @mut Block, av: ValueRef, t: ty::t,\n+                          f: val_and_ty_fn) -> @mut Block {\n     let _icx = push_ctxt(\"iter_structural_ty\");\n \n-    fn iter_variant(cx: block, repr: &adt::Repr, av: ValueRef,\n+    fn iter_variant(cx: @mut Block, repr: &adt::Repr, av: ValueRef,\n                     variant: @ty::VariantInfo,\n-                    tps: &[ty::t], f: val_and_ty_fn) -> block {\n+                    tps: &[ty::t], f: val_and_ty_fn) -> @mut Block {\n         let _icx = push_ctxt(\"iter_variant\");\n         let tcx = cx.tcx();\n         let mut cx = cx;\n@@ -757,7 +757,7 @@ pub fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n     return cx;\n }\n \n-pub fn cast_shift_expr_rhs(cx: block, op: ast::binop,\n+pub fn cast_shift_expr_rhs(cx: @mut Block, op: ast::binop,\n                            lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     cast_shift_rhs(op, lhs, rhs,\n                    |a,b| Trunc(cx, a, b),\n@@ -798,8 +798,8 @@ pub fn cast_shift_rhs(op: ast::binop,\n     }\n }\n \n-pub fn fail_if_zero(cx: block, span: span, divrem: ast::binop,\n-                    rhs: ValueRef, rhs_t: ty::t) -> block {\n+pub fn fail_if_zero(cx: @mut Block, span: span, divrem: ast::binop,\n+                    rhs: ValueRef, rhs_t: ty::t) -> @mut Block {\n     let text = if divrem == ast::div {\n         @\"attempted to divide by zero\"\n     } else {\n@@ -824,7 +824,7 @@ pub fn fail_if_zero(cx: block, span: span, divrem: ast::binop,\n     }\n }\n \n-pub fn null_env_ptr(bcx: block) -> ValueRef {\n+pub fn null_env_ptr(bcx: @mut Block) -> ValueRef {\n     C_null(Type::opaque_box(bcx.ccx()).ptr_to())\n }\n \n@@ -844,8 +844,8 @@ pub fn trans_external_path(ccx: &mut CrateContext, did: ast::def_id, t: ty::t)\n     };\n }\n \n-pub fn invoke(bcx: block, llfn: ValueRef, llargs: ~[ValueRef])\n-           -> (ValueRef, block) {\n+pub fn invoke(bcx: @mut Block, llfn: ValueRef, llargs: ~[ValueRef])\n+           -> (ValueRef, @mut Block) {\n     let _icx = push_ctxt(\"invoke_\");\n     if bcx.unreachable {\n         return (C_null(Type::i8()), bcx);\n@@ -889,7 +889,7 @@ pub fn invoke(bcx: block, llfn: ValueRef, llargs: ~[ValueRef])\n     }\n }\n \n-pub fn need_invoke(bcx: block) -> bool {\n+pub fn need_invoke(bcx: @mut Block) -> bool {\n     if (bcx.ccx().sess.opts.debugging_opts & session::no_landing_pads != 0) {\n         return false;\n     }\n@@ -931,7 +931,7 @@ pub fn need_invoke(bcx: block) -> bool {\n     }\n }\n \n-pub fn have_cached_lpad(bcx: block) -> bool {\n+pub fn have_cached_lpad(bcx: @mut Block) -> bool {\n     let mut res = false;\n     do in_lpad_scope_cx(bcx) |inf| {\n         match inf.landing_pad {\n@@ -942,7 +942,7 @@ pub fn have_cached_lpad(bcx: block) -> bool {\n     return res;\n }\n \n-pub fn in_lpad_scope_cx(bcx: block, f: &fn(si: &mut scope_info)) {\n+pub fn in_lpad_scope_cx(bcx: @mut Block, f: &fn(si: &mut ScopeInfo)) {\n     let mut bcx = bcx;\n     let mut cur_scope = bcx.scope;\n     loop {\n@@ -962,7 +962,7 @@ pub fn in_lpad_scope_cx(bcx: block, f: &fn(si: &mut scope_info)) {\n     }\n }\n \n-pub fn get_landing_pad(bcx: block) -> BasicBlockRef {\n+pub fn get_landing_pad(bcx: @mut Block) -> BasicBlockRef {\n     let _icx = push_ctxt(\"get_landing_pad\");\n \n     let mut cached = None;\n@@ -1013,7 +1013,7 @@ pub fn get_landing_pad(bcx: block) -> BasicBlockRef {\n     return pad_bcx.llbb;\n }\n \n-pub fn find_bcx_for_scope(bcx: block, scope_id: ast::node_id) -> block {\n+pub fn find_bcx_for_scope(bcx: @mut Block, scope_id: ast::node_id) -> @mut Block {\n     let mut bcx_sid = bcx;\n     let mut cur_scope = bcx_sid.scope;\n     loop {\n@@ -1042,7 +1042,7 @@ pub fn find_bcx_for_scope(bcx: block, scope_id: ast::node_id) -> block {\n }\n \n \n-pub fn do_spill(bcx: block, v: ValueRef, t: ty::t) -> ValueRef {\n+pub fn do_spill(bcx: @mut Block, v: ValueRef, t: ty::t) -> ValueRef {\n     if ty::type_is_bot(t) {\n         return C_null(Type::i8p());\n     }\n@@ -1053,25 +1053,25 @@ pub fn do_spill(bcx: block, v: ValueRef, t: ty::t) -> ValueRef {\n \n // Since this function does *not* root, it is the caller's responsibility to\n // ensure that the referent is pointed to by a root.\n-pub fn do_spill_noroot(cx: block, v: ValueRef) -> ValueRef {\n+pub fn do_spill_noroot(cx: @mut Block, v: ValueRef) -> ValueRef {\n     let llptr = alloca(cx, val_ty(v), \"\");\n     Store(cx, v, llptr);\n     return llptr;\n }\n \n-pub fn spill_if_immediate(cx: block, v: ValueRef, t: ty::t) -> ValueRef {\n+pub fn spill_if_immediate(cx: @mut Block, v: ValueRef, t: ty::t) -> ValueRef {\n     let _icx = push_ctxt(\"spill_if_immediate\");\n     if ty::type_is_immediate(cx.tcx(), t) { return do_spill(cx, v, t); }\n     return v;\n }\n \n-pub fn load_if_immediate(cx: block, v: ValueRef, t: ty::t) -> ValueRef {\n+pub fn load_if_immediate(cx: @mut Block, v: ValueRef, t: ty::t) -> ValueRef {\n     let _icx = push_ctxt(\"load_if_immediate\");\n     if ty::type_is_immediate(cx.tcx(), t) { return Load(cx, v); }\n     return v;\n }\n \n-pub fn trans_trace(bcx: block, sp_opt: Option<span>, trace_str: @str) {\n+pub fn trans_trace(bcx: @mut Block, sp_opt: Option<span>, trace_str: @str) {\n     if !bcx.sess().trace() { return; }\n     let _icx = push_ctxt(\"trans_trace\");\n     add_comment(bcx, trace_str);\n@@ -1093,13 +1093,13 @@ pub fn trans_trace(bcx: block, sp_opt: Option<span>, trace_str: @str) {\n     Call(bcx, ccx.upcalls.trace, args);\n }\n \n-pub fn ignore_lhs(_bcx: block, local: &ast::Local) -> bool {\n+pub fn ignore_lhs(_bcx: @mut Block, local: &ast::Local) -> bool {\n     match local.pat.node {\n         ast::pat_wild => true, _ => false\n     }\n }\n \n-pub fn init_local(bcx: block, local: &ast::Local) -> block {\n+pub fn init_local(bcx: @mut Block, local: &ast::Local) -> @mut Block {\n \n     debug!(\"init_local(bcx=%s, local.id=%?)\",\n            bcx.to_str(), local.id);\n@@ -1120,7 +1120,7 @@ pub fn init_local(bcx: block, local: &ast::Local) -> block {\n     _match::store_local(bcx, local.pat, local.init)\n }\n \n-pub fn trans_stmt(cx: block, s: &ast::stmt) -> block {\n+pub fn trans_stmt(cx: @mut Block, s: &ast::stmt) -> @mut Block {\n     let _icx = push_ctxt(\"trans_stmt\");\n     debug!(\"trans_stmt(%s)\", stmt_to_str(s, cx.tcx().sess.intr()));\n \n@@ -1155,19 +1155,22 @@ pub fn trans_stmt(cx: block, s: &ast::stmt) -> block {\n \n // You probably don't want to use this one. See the\n // next three functions instead.\n-pub fn new_block(cx: fn_ctxt, parent: Option<block>, scope: Option<@mut scope_info>,\n-                 is_lpad: bool, name: &str, opt_node_info: Option<NodeInfo>)\n-    -> block {\n-\n+pub fn new_block(cx: @mut FunctionContext,\n+                 parent: Option<@mut Block>,\n+                 scope: Option<@mut ScopeInfo>,\n+                 is_lpad: bool,\n+                 name: &str,\n+                 opt_node_info: Option<NodeInfo>)\n+              -> @mut Block {\n     unsafe {\n         let llbb = do name.as_c_str |buf| {\n             llvm::LLVMAppendBasicBlockInContext(cx.ccx.llcx, cx.llfn, buf)\n         };\n-        let bcx = mk_block(llbb,\n-                           parent,\n-                           is_lpad,\n-                           opt_node_info,\n-                           cx);\n+        let bcx = @mut Block::new(llbb,\n+                                  parent,\n+                                  is_lpad,\n+                                  opt_node_info,\n+                                  cx);\n         bcx.scope = scope;\n         for parent.iter().advance |cx| {\n             if cx.unreachable {\n@@ -1179,9 +1182,9 @@ pub fn new_block(cx: fn_ctxt, parent: Option<block>, scope: Option<@mut scope_in\n     }\n }\n \n-pub fn simple_block_scope(parent: Option<@mut scope_info>,\n-                          node_info: Option<NodeInfo>) -> @mut scope_info {\n-    @mut scope_info {\n+pub fn simple_block_scope(parent: Option<@mut ScopeInfo>,\n+                          node_info: Option<NodeInfo>) -> @mut ScopeInfo {\n+    @mut ScopeInfo {\n         parent: parent,\n         loop_break: None,\n         loop_label: None,\n@@ -1193,25 +1196,25 @@ pub fn simple_block_scope(parent: Option<@mut scope_info>,\n }\n \n // Use this when you're at the top block of a function or the like.\n-pub fn top_scope_block(fcx: fn_ctxt, opt_node_info: Option<NodeInfo>)\n-                    -> block {\n+pub fn top_scope_block(fcx: @mut FunctionContext, opt_node_info: Option<NodeInfo>)\n+                    -> @mut Block {\n     return new_block(fcx, None, Some(simple_block_scope(None, opt_node_info)), false,\n                   \"function top level\", opt_node_info);\n }\n \n-pub fn scope_block(bcx: block,\n+pub fn scope_block(bcx: @mut Block,\n                    opt_node_info: Option<NodeInfo>,\n-                   n: &str) -> block {\n+                   n: &str) -> @mut Block {\n     return new_block(bcx.fcx, Some(bcx), Some(simple_block_scope(None, opt_node_info)), bcx.is_lpad,\n                   n, opt_node_info);\n }\n \n-pub fn loop_scope_block(bcx: block,\n-                        loop_break: block,\n+pub fn loop_scope_block(bcx: @mut Block,\n+                        loop_break: @mut Block,\n                         loop_label: Option<ident>,\n                         n: &str,\n-                        opt_node_info: Option<NodeInfo>) -> block {\n-    return new_block(bcx.fcx, Some(bcx), Some(@mut scope_info {\n+                        opt_node_info: Option<NodeInfo>) -> @mut Block {\n+    return new_block(bcx.fcx, Some(bcx), Some(@mut ScopeInfo {\n         parent: None,\n         loop_break: Some(loop_break),\n         loop_label: loop_label,\n@@ -1223,17 +1226,17 @@ pub fn loop_scope_block(bcx: block,\n }\n \n // Use this when creating a block for the inside of a landing pad.\n-pub fn lpad_block(bcx: block, n: &str) -> block {\n+pub fn lpad_block(bcx: @mut Block, n: &str) -> @mut Block {\n     new_block(bcx.fcx, Some(bcx), None, true, n, None)\n }\n \n // Use this when you're making a general CFG BB within a scope.\n-pub fn sub_block(bcx: block, n: &str) -> block {\n+pub fn sub_block(bcx: @mut Block, n: &str) -> @mut Block {\n     new_block(bcx.fcx, Some(bcx), None, bcx.is_lpad, n, None)\n }\n \n-pub fn raw_block(fcx: fn_ctxt, is_lpad: bool, llbb: BasicBlockRef) -> block {\n-    mk_block(llbb, None, is_lpad, None, fcx)\n+pub fn raw_block(fcx: @mut FunctionContext, is_lpad: bool, llbb: BasicBlockRef) -> @mut Block {\n+    @mut Block::new(llbb, None, is_lpad, None, fcx)\n }\n \n \n@@ -1244,14 +1247,14 @@ pub fn raw_block(fcx: fn_ctxt, is_lpad: bool, llbb: BasicBlockRef) -> block {\n // need to make sure those variables go out of scope when the block ends.  We\n // do that by running a 'cleanup' function for each variable.\n // trans_block_cleanups runs all the cleanup functions for the block.\n-pub fn trans_block_cleanups(bcx: block, cleanups: ~[cleanup]) -> block {\n+pub fn trans_block_cleanups(bcx: @mut Block, cleanups: ~[cleanup]) -> @mut Block {\n     trans_block_cleanups_(bcx, cleanups, false)\n }\n \n-pub fn trans_block_cleanups_(bcx: block,\n+pub fn trans_block_cleanups_(bcx: @mut Block,\n                              cleanups: &[cleanup],\n                              /* cleanup_cx: block, */\n-                             is_lpad: bool) -> block {\n+                             is_lpad: bool) -> @mut Block {\n     let _icx = push_ctxt(\"trans_block_cleanups\");\n     // NB: Don't short-circuit even if this block is unreachable because\n     // GC-based cleanup needs to the see that the roots are live.\n@@ -1276,7 +1279,7 @@ pub fn trans_block_cleanups_(bcx: block,\n // In the last argument, Some(block) mean jump to this block, and none means\n // this is a landing pad and leaving should be accomplished with a resume\n // instruction.\n-pub fn cleanup_and_leave(bcx: block,\n+pub fn cleanup_and_leave(bcx: @mut Block,\n                          upto: Option<BasicBlockRef>,\n                          leave: Option<BasicBlockRef>) {\n     let _icx = push_ctxt(\"cleanup_and_leave\");\n@@ -1350,7 +1353,7 @@ pub fn cleanup_and_leave(bcx: block,\n     }\n }\n \n-pub fn cleanup_block(bcx: block, upto: Option<BasicBlockRef>) -> block{\n+pub fn cleanup_block(bcx: @mut Block, upto: Option<BasicBlockRef>) -> @mut Block{\n     let _icx = push_ctxt(\"cleanup_block\");\n     let mut cur = bcx;\n     let mut bcx = bcx;\n@@ -1386,23 +1389,23 @@ pub fn cleanup_block(bcx: block, upto: Option<BasicBlockRef>) -> block{\n     bcx\n }\n \n-pub fn cleanup_and_Br(bcx: block, upto: block, target: BasicBlockRef) {\n+pub fn cleanup_and_Br(bcx: @mut Block, upto: @mut Block, target: BasicBlockRef) {\n     let _icx = push_ctxt(\"cleanup_and_Br\");\n     cleanup_and_leave(bcx, Some(upto.llbb), Some(target));\n }\n \n-pub fn leave_block(bcx: block, out_of: block) -> block {\n+pub fn leave_block(bcx: @mut Block, out_of: @mut Block) -> @mut Block {\n     let _icx = push_ctxt(\"leave_block\");\n     let next_cx = sub_block(block_parent(out_of), \"next\");\n     if bcx.unreachable { Unreachable(next_cx); }\n     cleanup_and_Br(bcx, out_of, next_cx.llbb);\n     next_cx\n }\n \n-pub fn with_scope(bcx: block,\n+pub fn with_scope(bcx: @mut Block,\n                   opt_node_info: Option<NodeInfo>,\n                   name: &str,\n-                  f: &fn(block) -> block) -> block {\n+                  f: &fn(@mut Block) -> @mut Block) -> @mut Block {\n     let _icx = push_ctxt(\"with_scope\");\n \n     debug!(\"with_scope(bcx=%s, opt_node_info=%?, name=%s)\",\n@@ -1417,10 +1420,10 @@ pub fn with_scope(bcx: block,\n     ret\n }\n \n-pub fn with_scope_result(bcx: block,\n+pub fn with_scope_result(bcx: @mut Block,\n                          opt_node_info: Option<NodeInfo>,\n                          _name: &str,\n-                         f: &fn(block) -> Result) -> Result {\n+                         f: &fn(@mut Block) -> Result) -> Result {\n     let _icx = push_ctxt(\"with_scope_result\");\n \n     let scope = simple_block_scope(bcx.scope, opt_node_info);\n@@ -1434,8 +1437,8 @@ pub fn with_scope_result(bcx: block,\n     rslt(out_bcx, val)\n }\n \n-pub fn with_scope_datumblock(bcx: block, opt_node_info: Option<NodeInfo>,\n-                             name: &str, f: &fn(block) -> datum::DatumBlock)\n+pub fn with_scope_datumblock(bcx: @mut Block, opt_node_info: Option<NodeInfo>,\n+                             name: &str, f: &fn(@mut Block) -> datum::DatumBlock)\n                           -> datum::DatumBlock {\n     use middle::trans::datum::DatumBlock;\n \n@@ -1460,7 +1463,7 @@ pub fn block_locals(b: &ast::Block, it: &fn(@ast::Local)) {\n     }\n }\n \n-pub fn with_cond(bcx: block, val: ValueRef, f: &fn(block) -> block) -> block {\n+pub fn with_cond(bcx: @mut Block, val: ValueRef, f: &fn(@mut Block) -> @mut Block) -> @mut Block {\n     let _icx = push_ctxt(\"with_cond\");\n     let next_cx = base::sub_block(bcx, \"next\");\n     let cond_cx = base::sub_block(bcx, \"cond\");\n@@ -1470,7 +1473,7 @@ pub fn with_cond(bcx: block, val: ValueRef, f: &fn(block) -> block) -> block {\n     next_cx\n }\n \n-pub fn call_memcpy(cx: block, dst: ValueRef, src: ValueRef, n_bytes: ValueRef, align: u32) {\n+pub fn call_memcpy(cx: @mut Block, dst: ValueRef, src: ValueRef, n_bytes: ValueRef, align: u32) {\n     let _icx = push_ctxt(\"call_memcpy\");\n     let ccx = cx.ccx();\n     let key = match ccx.sess.targ_cfg.arch {\n@@ -1486,7 +1489,7 @@ pub fn call_memcpy(cx: block, dst: ValueRef, src: ValueRef, n_bytes: ValueRef, a\n     Call(cx, memcpy, [dst_ptr, src_ptr, size, align, volatile]);\n }\n \n-pub fn memcpy_ty(bcx: block, dst: ValueRef, src: ValueRef, t: ty::t) {\n+pub fn memcpy_ty(bcx: @mut Block, dst: ValueRef, src: ValueRef, t: ty::t) {\n     let _icx = push_ctxt(\"memcpy_ty\");\n     let ccx = bcx.ccx();\n     if ty::type_is_structural(t) {\n@@ -1499,7 +1502,7 @@ pub fn memcpy_ty(bcx: block, dst: ValueRef, src: ValueRef, t: ty::t) {\n     }\n }\n \n-pub fn zero_mem(cx: block, llptr: ValueRef, t: ty::t) {\n+pub fn zero_mem(cx: @mut Block, llptr: ValueRef, t: ty::t) {\n     if cx.unreachable { return; }\n     let _icx = push_ctxt(\"zero_mem\");\n     let bcx = cx;\n@@ -1531,7 +1534,7 @@ pub fn memzero(b: &Builder, llptr: ValueRef, ty: Type) {\n     b.call(llintrinsicfn, [llptr, llzeroval, size, align, volatile]);\n }\n \n-pub fn alloc_ty(bcx: block, t: ty::t, name: &str) -> ValueRef {\n+pub fn alloc_ty(bcx: @mut Block, t: ty::t, name: &str) -> ValueRef {\n     let _icx = push_ctxt(\"alloc_ty\");\n     let ccx = bcx.ccx();\n     let ty = type_of::type_of(ccx, t);\n@@ -1540,11 +1543,11 @@ pub fn alloc_ty(bcx: block, t: ty::t, name: &str) -> ValueRef {\n     return val;\n }\n \n-pub fn alloca(cx: block, ty: Type, name: &str) -> ValueRef {\n+pub fn alloca(cx: @mut Block, ty: Type, name: &str) -> ValueRef {\n     alloca_maybe_zeroed(cx, ty, name, false)\n }\n \n-pub fn alloca_maybe_zeroed(cx: block, ty: Type, name: &str, zero: bool) -> ValueRef {\n+pub fn alloca_maybe_zeroed(cx: @mut Block, ty: Type, name: &str, zero: bool) -> ValueRef {\n     let _icx = push_ctxt(\"alloca\");\n     if cx.unreachable {\n         unsafe {\n@@ -1560,7 +1563,7 @@ pub fn alloca_maybe_zeroed(cx: block, ty: Type, name: &str, zero: bool) -> Value\n     p\n }\n \n-pub fn arrayalloca(cx: block, ty: Type, v: ValueRef) -> ValueRef {\n+pub fn arrayalloca(cx: @mut Block, ty: Type, v: ValueRef) -> ValueRef {\n     let _icx = push_ctxt(\"arrayalloca\");\n     if cx.unreachable {\n         unsafe {\n@@ -1592,7 +1595,7 @@ pub fn mk_return_basic_block(llfn: ValueRef) -> BasicBlockRef {\n \n // Creates and returns space for, or returns the argument representing, the\n // slot where the return value of the function must go.\n-pub fn make_return_pointer(fcx: fn_ctxt, output_type: ty::t) -> ValueRef {\n+pub fn make_return_pointer(fcx: @mut FunctionContext, output_type: ty::t) -> ValueRef {\n     unsafe {\n         if !ty::type_is_immediate(fcx.ccx.tcx, output_type) {\n             llvm::LLVMGetParam(fcx.llfn, 0)\n@@ -1619,7 +1622,7 @@ pub fn new_fn_ctxt_w_id(ccx: @mut CrateContext,\n                         param_substs: Option<@param_substs>,\n                         opt_node_info: Option<NodeInfo>,\n                         sp: Option<span>)\n-                     -> fn_ctxt {\n+                     -> @mut FunctionContext {\n     for param_substs.iter().advance |p| { p.validate(); }\n \n     debug!(\"new_fn_ctxt_w_id(path=%s, id=%?, \\\n@@ -1635,7 +1638,7 @@ pub fn new_fn_ctxt_w_id(ccx: @mut CrateContext,\n         }\n     };\n     let is_immediate = ty::type_is_immediate(ccx.tcx, substd_output_type);\n-    let fcx = @mut fn_ctxt_ {\n+    let fcx = @mut FunctionContext {\n           llfn: llfndecl,\n           llenv: unsafe {\n               llvm::LLVMGetUndef(Type::i8p().to_ref())\n@@ -1680,7 +1683,7 @@ pub fn new_fn_ctxt(ccx: @mut CrateContext,\n                    llfndecl: ValueRef,\n                    output_type: ty::t,\n                    sp: Option<span>)\n-                -> fn_ctxt {\n+                -> @mut FunctionContext {\n     new_fn_ctxt_w_id(ccx, path, llfndecl, -1, output_type, false, None, None, sp)\n }\n \n@@ -1698,7 +1701,7 @@ pub fn new_fn_ctxt(ccx: @mut CrateContext,\n // spaces that have been created for them (by code in the llallocas field of\n // the function's fn_ctxt).  create_llargs_for_fn_args populates the llargs\n // field of the fn_ctxt with\n-pub fn create_llargs_for_fn_args(cx: fn_ctxt,\n+pub fn create_llargs_for_fn_args(cx: @mut FunctionContext,\n                                  self_arg: self_arg,\n                                  args: &[ast::arg])\n                               -> ~[ValueRef] {\n@@ -1739,11 +1742,11 @@ pub fn create_llargs_for_fn_args(cx: fn_ctxt,\n     })\n }\n \n-pub fn copy_args_to_allocas(fcx: fn_ctxt,\n-                            bcx: block,\n+pub fn copy_args_to_allocas(fcx: @mut FunctionContext,\n+                            bcx: @mut Block,\n                             args: &[ast::arg],\n                             raw_llargs: &[ValueRef],\n-                            arg_tys: &[ty::t]) -> block {\n+                            arg_tys: &[ty::t]) -> @mut Block {\n     let _icx = push_ctxt(\"copy_args_to_allocas\");\n     let mut bcx = bcx;\n \n@@ -1796,7 +1799,7 @@ pub fn copy_args_to_allocas(fcx: fn_ctxt,\n \n // Ties up the llstaticallocas -> llloadenv -> lltop edges,\n // and builds the return block.\n-pub fn finish_fn(fcx: fn_ctxt, last_bcx: block) {\n+pub fn finish_fn(fcx: @mut FunctionContext, last_bcx: @mut Block) {\n     let _icx = push_ctxt(\"finish_fn\");\n \n     let ret_cx = match fcx.llreturn {\n@@ -1813,7 +1816,7 @@ pub fn finish_fn(fcx: fn_ctxt, last_bcx: block) {\n }\n \n // Builds the return block for a function.\n-pub fn build_return_block(fcx: fn_ctxt, ret_cx: block) {\n+pub fn build_return_block(fcx: &FunctionContext, ret_cx: @mut Block) {\n     // Return the value if this function immediate; otherwise, return void.\n     if fcx.llretptr.is_some() && fcx.has_immediate_return_value {\n         Ret(ret_cx, Load(ret_cx, fcx.llretptr.get()))\n@@ -1837,8 +1840,8 @@ pub fn trans_closure(ccx: @mut CrateContext,\n                      id: ast::node_id,\n                      attributes: &[ast::Attribute],\n                      output_type: ty::t,\n-                     maybe_load_env: &fn(fn_ctxt),\n-                     finish: &fn(block)) {\n+                     maybe_load_env: &fn(@mut FunctionContext),\n+                     finish: &fn(@mut Block)) {\n     ccx.stats.n_closures += 1;\n     let _icx = push_ctxt(\"trans_closure\");\n     set_uwtable(llfndecl);\n@@ -1944,7 +1947,7 @@ pub fn trans_fn(ccx: @mut CrateContext,\n                   |_bcx| { });\n }\n \n-fn insert_synthetic_type_entries(bcx: block,\n+fn insert_synthetic_type_entries(bcx: @mut Block,\n                                  fn_args: &[ast::arg],\n                                  arg_tys: &[ty::t])\n {\n@@ -2416,7 +2419,7 @@ pub fn create_entry_wrapper(ccx: @mut CrateContext,\n     }\n }\n \n-pub fn fill_fn_pair(bcx: block, pair: ValueRef, llfn: ValueRef,\n+pub fn fill_fn_pair(bcx: @mut Block, pair: ValueRef, llfn: ValueRef,\n                     llenvptr: ValueRef) {\n     let ccx = bcx.ccx();\n     let code_cell = GEPi(bcx, pair, [0u, abi::fn_field_code]);\n@@ -2637,7 +2640,7 @@ pub fn trans_constants(ccx: @mut CrateContext, crate: &ast::Crate) {\n         })));\n }\n \n-pub fn vp2i(cx: block, v: ValueRef) -> ValueRef {\n+pub fn vp2i(cx: @mut Block, v: ValueRef) -> ValueRef {\n     let ccx = cx.ccx();\n     return PtrToInt(cx, v, ccx.int_type);\n }\n@@ -2737,7 +2740,7 @@ pub fn declare_dbg_intrinsics(llmod: ModuleRef, intrinsics: &mut HashMap<&'stati\n     ifn!(\"llvm.dbg.value\",   [Type::metadata(), Type::i64(), Type::metadata()], Type::void());\n }\n \n-pub fn trap(bcx: block) {\n+pub fn trap(bcx: @mut Block) {\n     match bcx.ccx().intrinsics.find_equiv(& &\"llvm.trap\") {\n       Some(&x) => { Call(bcx, x, []); },\n       _ => bcx.sess().bug(\"unbound llvm.trap in trap\")"}, {"sha": "9c34d2a3526b6b32aff30b6854c7381ea638e92d", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 107, "deletions": 107, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/3315edfae7854d1f9f58840bbec4d43392c3fa51/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3315edfae7854d1f9f58840bbec4d43392c3fa51/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=3315edfae7854d1f9f58840bbec4d43392c3fa51", "patch": "@@ -23,17 +23,17 @@ use middle::trans::type_::Type;\n use std::cast;\n use std::libc::{c_uint, c_ulonglong, c_char};\n \n-pub fn terminate(cx: block, _: &str) {\n+pub fn terminate(cx: @mut Block, _: &str) {\n     cx.terminated = true;\n }\n \n-pub fn check_not_terminated(cx: block) {\n+pub fn check_not_terminated(cx: @mut Block) {\n     if cx.terminated {\n         fail!(\"already terminated!\");\n     }\n }\n \n-pub fn B(cx: block) -> Builder {\n+pub fn B(cx: @mut Block) -> Builder {\n     let b = cx.fcx.ccx.builder();\n     b.position_at_end(cx.llbb);\n     b\n@@ -47,43 +47,43 @@ pub fn B(cx: block) -> Builder {\n // for (fail/break/return statements, call to diverging functions, etc), and\n // further instructions to the block should simply be ignored.\n \n-pub fn RetVoid(cx: block) {\n+pub fn RetVoid(cx: @mut Block) {\n     if cx.unreachable { return; }\n     check_not_terminated(cx);\n     terminate(cx, \"RetVoid\");\n     B(cx).ret_void();\n }\n \n-pub fn Ret(cx: block, V: ValueRef) {\n+pub fn Ret(cx: @mut Block, V: ValueRef) {\n     if cx.unreachable { return; }\n     check_not_terminated(cx);\n     terminate(cx, \"Ret\");\n     B(cx).ret(V);\n }\n \n-pub fn AggregateRet(cx: block, RetVals: &[ValueRef]) {\n+pub fn AggregateRet(cx: @mut Block, RetVals: &[ValueRef]) {\n     if cx.unreachable { return; }\n     check_not_terminated(cx);\n     terminate(cx, \"AggregateRet\");\n     B(cx).aggregate_ret(RetVals);\n }\n \n-pub fn Br(cx: block, Dest: BasicBlockRef) {\n+pub fn Br(cx: @mut Block, Dest: BasicBlockRef) {\n     if cx.unreachable { return; }\n     check_not_terminated(cx);\n     terminate(cx, \"Br\");\n     B(cx).br(Dest);\n }\n \n-pub fn CondBr(cx: block, If: ValueRef, Then: BasicBlockRef,\n+pub fn CondBr(cx: @mut Block, If: ValueRef, Then: BasicBlockRef,\n               Else: BasicBlockRef) {\n     if cx.unreachable { return; }\n     check_not_terminated(cx);\n     terminate(cx, \"CondBr\");\n     B(cx).cond_br(If, Then, Else);\n }\n \n-pub fn Switch(cx: block, V: ValueRef, Else: BasicBlockRef, NumCases: uint)\n+pub fn Switch(cx: @mut Block, V: ValueRef, Else: BasicBlockRef, NumCases: uint)\n     -> ValueRef {\n     if cx.unreachable { return _Undef(V); }\n     check_not_terminated(cx);\n@@ -98,14 +98,14 @@ pub fn AddCase(S: ValueRef, OnVal: ValueRef, Dest: BasicBlockRef) {\n     }\n }\n \n-pub fn IndirectBr(cx: block, Addr: ValueRef, NumDests: uint) {\n+pub fn IndirectBr(cx: @mut Block, Addr: ValueRef, NumDests: uint) {\n     if cx.unreachable { return; }\n     check_not_terminated(cx);\n     terminate(cx, \"IndirectBr\");\n     B(cx).indirect_br(Addr, NumDests);\n }\n \n-pub fn Invoke(cx: block,\n+pub fn Invoke(cx: @mut Block,\n               Fn: ValueRef,\n               Args: &[ValueRef],\n               Then: BasicBlockRef,\n@@ -122,15 +122,15 @@ pub fn Invoke(cx: block,\n     B(cx).invoke(Fn, Args, Then, Catch)\n }\n \n-pub fn FastInvoke(cx: block, Fn: ValueRef, Args: &[ValueRef],\n+pub fn FastInvoke(cx: @mut Block, Fn: ValueRef, Args: &[ValueRef],\n                   Then: BasicBlockRef, Catch: BasicBlockRef) {\n     if cx.unreachable { return; }\n     check_not_terminated(cx);\n     terminate(cx, \"FastInvoke\");\n     B(cx).fast_invoke(Fn, Args, Then, Catch);\n }\n \n-pub fn Unreachable(cx: block) {\n+pub fn Unreachable(cx: @mut Block) {\n     if cx.unreachable { return; }\n     cx.unreachable = true;\n     if !cx.terminated {\n@@ -145,177 +145,177 @@ pub fn _Undef(val: ValueRef) -> ValueRef {\n }\n \n /* Arithmetic */\n-pub fn Add(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn Add(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).add(LHS, RHS)\n }\n \n-pub fn NSWAdd(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn NSWAdd(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).nswadd(LHS, RHS)\n }\n \n-pub fn NUWAdd(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn NUWAdd(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).nuwadd(LHS, RHS)\n }\n \n-pub fn FAdd(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn FAdd(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).fadd(LHS, RHS)\n }\n \n-pub fn Sub(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn Sub(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).sub(LHS, RHS)\n }\n \n-pub fn NSWSub(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn NSWSub(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).nswsub(LHS, RHS)\n }\n \n-pub fn NUWSub(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn NUWSub(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).nuwsub(LHS, RHS)\n }\n \n-pub fn FSub(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn FSub(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).fsub(LHS, RHS)\n }\n \n-pub fn Mul(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn Mul(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).mul(LHS, RHS)\n }\n \n-pub fn NSWMul(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn NSWMul(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).nswmul(LHS, RHS)\n }\n \n-pub fn NUWMul(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn NUWMul(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).nuwmul(LHS, RHS)\n }\n \n-pub fn FMul(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn FMul(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).fmul(LHS, RHS)\n }\n \n-pub fn UDiv(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn UDiv(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).udiv(LHS, RHS)\n }\n \n-pub fn SDiv(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn SDiv(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).sdiv(LHS, RHS)\n }\n \n-pub fn ExactSDiv(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn ExactSDiv(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).exactsdiv(LHS, RHS)\n }\n \n-pub fn FDiv(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn FDiv(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).fdiv(LHS, RHS)\n }\n \n-pub fn URem(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn URem(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).urem(LHS, RHS)\n }\n \n-pub fn SRem(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn SRem(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).srem(LHS, RHS)\n }\n \n-pub fn FRem(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn FRem(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).frem(LHS, RHS)\n }\n \n-pub fn Shl(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn Shl(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).shl(LHS, RHS)\n }\n \n-pub fn LShr(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn LShr(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).lshr(LHS, RHS)\n }\n \n-pub fn AShr(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn AShr(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).ashr(LHS, RHS)\n }\n \n-pub fn And(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn And(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).and(LHS, RHS)\n }\n \n-pub fn Or(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn Or(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).or(LHS, RHS)\n }\n \n-pub fn Xor(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn Xor(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).xor(LHS, RHS)\n }\n \n-pub fn BinOp(cx: block, Op: Opcode, LHS: ValueRef, RHS: ValueRef)\n+pub fn BinOp(cx: @mut Block, Op: Opcode, LHS: ValueRef, RHS: ValueRef)\n           -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).binop(Op, LHS, RHS)\n }\n \n-pub fn Neg(cx: block, V: ValueRef) -> ValueRef {\n+pub fn Neg(cx: @mut Block, V: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(V); }\n     B(cx).neg(V)\n }\n \n-pub fn NSWNeg(cx: block, V: ValueRef) -> ValueRef {\n+pub fn NSWNeg(cx: @mut Block, V: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(V); }\n     B(cx).nswneg(V)\n }\n \n-pub fn NUWNeg(cx: block, V: ValueRef) -> ValueRef {\n+pub fn NUWNeg(cx: @mut Block, V: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(V); }\n     B(cx).nuwneg(V)\n }\n-pub fn FNeg(cx: block, V: ValueRef) -> ValueRef {\n+pub fn FNeg(cx: @mut Block, V: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(V); }\n     B(cx).fneg(V)\n }\n \n-pub fn Not(cx: block, V: ValueRef) -> ValueRef {\n+pub fn Not(cx: @mut Block, V: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(V); }\n     B(cx).not(V)\n }\n \n /* Memory */\n-pub fn Malloc(cx: block, Ty: Type) -> ValueRef {\n+pub fn Malloc(cx: @mut Block, Ty: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::i8p().to_ref()); }\n         B(cx).malloc(Ty)\n     }\n }\n \n-pub fn ArrayMalloc(cx: block, Ty: Type, Val: ValueRef) -> ValueRef {\n+pub fn ArrayMalloc(cx: @mut Block, Ty: Type, Val: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::i8p().to_ref()); }\n         B(cx).array_malloc(Ty, Val)\n     }\n }\n \n-pub fn Alloca(cx: block, Ty: Type, name: &str) -> ValueRef {\n+pub fn Alloca(cx: @mut Block, Ty: Type, name: &str) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Ty.ptr_to().to_ref()); }\n         let b = cx.fcx.ccx.builder();\n@@ -324,7 +324,7 @@ pub fn Alloca(cx: block, Ty: Type, name: &str) -> ValueRef {\n     }\n }\n \n-pub fn ArrayAlloca(cx: block, Ty: Type, Val: ValueRef) -> ValueRef {\n+pub fn ArrayAlloca(cx: @mut Block, Ty: Type, Val: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Ty.ptr_to().to_ref()); }\n         let b = cx.fcx.ccx.builder();\n@@ -333,12 +333,12 @@ pub fn ArrayAlloca(cx: block, Ty: Type, Val: ValueRef) -> ValueRef {\n     }\n }\n \n-pub fn Free(cx: block, PointerVal: ValueRef) {\n+pub fn Free(cx: @mut Block, PointerVal: ValueRef) {\n     if cx.unreachable { return; }\n     B(cx).free(PointerVal)\n }\n \n-pub fn Load(cx: block, PointerVal: ValueRef) -> ValueRef {\n+pub fn Load(cx: @mut Block, PointerVal: ValueRef) -> ValueRef {\n     unsafe {\n         let ccx = cx.fcx.ccx;\n         if cx.unreachable {\n@@ -354,7 +354,7 @@ pub fn Load(cx: block, PointerVal: ValueRef) -> ValueRef {\n     }\n }\n \n-pub fn AtomicLoad(cx: block, PointerVal: ValueRef, order: AtomicOrdering) -> ValueRef {\n+pub fn AtomicLoad(cx: @mut Block, PointerVal: ValueRef, order: AtomicOrdering) -> ValueRef {\n     unsafe {\n         let ccx = cx.fcx.ccx;\n         if cx.unreachable {\n@@ -365,7 +365,7 @@ pub fn AtomicLoad(cx: block, PointerVal: ValueRef, order: AtomicOrdering) -> Val\n }\n \n \n-pub fn LoadRangeAssert(cx: block, PointerVal: ValueRef, lo: c_ulonglong,\n+pub fn LoadRangeAssert(cx: @mut Block, PointerVal: ValueRef, lo: c_ulonglong,\n                        hi: c_ulonglong, signed: lib::llvm::Bool) -> ValueRef {\n     if cx.unreachable {\n         let ccx = cx.fcx.ccx;\n@@ -383,17 +383,17 @@ pub fn LoadRangeAssert(cx: block, PointerVal: ValueRef, lo: c_ulonglong,\n     }\n }\n \n-pub fn Store(cx: block, Val: ValueRef, Ptr: ValueRef) {\n+pub fn Store(cx: @mut Block, Val: ValueRef, Ptr: ValueRef) {\n     if cx.unreachable { return; }\n     B(cx).store(Val, Ptr)\n }\n \n-pub fn AtomicStore(cx: block, Val: ValueRef, Ptr: ValueRef, order: AtomicOrdering) {\n+pub fn AtomicStore(cx: @mut Block, Val: ValueRef, Ptr: ValueRef, order: AtomicOrdering) {\n     if cx.unreachable { return; }\n     B(cx).atomic_store(Val, Ptr, order)\n }\n \n-pub fn GEP(cx: block, Pointer: ValueRef, Indices: &[ValueRef]) -> ValueRef {\n+pub fn GEP(cx: @mut Block, Pointer: ValueRef, Indices: &[ValueRef]) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref()); }\n         B(cx).gep(Pointer, Indices)\n@@ -403,170 +403,170 @@ pub fn GEP(cx: block, Pointer: ValueRef, Indices: &[ValueRef]) -> ValueRef {\n // Simple wrapper around GEP that takes an array of ints and wraps them\n // in C_i32()\n #[inline]\n-pub fn GEPi(cx: block, base: ValueRef, ixs: &[uint]) -> ValueRef {\n+pub fn GEPi(cx: @mut Block, base: ValueRef, ixs: &[uint]) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref()); }\n         B(cx).gepi(base, ixs)\n     }\n }\n \n-pub fn InBoundsGEP(cx: block, Pointer: ValueRef, Indices: &[ValueRef]) -> ValueRef {\n+pub fn InBoundsGEP(cx: @mut Block, Pointer: ValueRef, Indices: &[ValueRef]) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref()); }\n         B(cx).inbounds_gep(Pointer, Indices)\n     }\n }\n \n-pub fn StructGEP(cx: block, Pointer: ValueRef, Idx: uint) -> ValueRef {\n+pub fn StructGEP(cx: @mut Block, Pointer: ValueRef, Idx: uint) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref()); }\n         B(cx).struct_gep(Pointer, Idx)\n     }\n }\n \n-pub fn GlobalString(cx: block, _Str: *c_char) -> ValueRef {\n+pub fn GlobalString(cx: @mut Block, _Str: *c_char) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::i8p().to_ref()); }\n         B(cx).global_string(_Str)\n     }\n }\n \n-pub fn GlobalStringPtr(cx: block, _Str: *c_char) -> ValueRef {\n+pub fn GlobalStringPtr(cx: @mut Block, _Str: *c_char) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::i8p().to_ref()); }\n         B(cx).global_string_ptr(_Str)\n     }\n }\n \n /* Casts */\n-pub fn Trunc(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn Trunc(cx: @mut Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).trunc(Val, DestTy)\n     }\n }\n \n-pub fn ZExt(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn ZExt(cx: @mut Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).zext(Val, DestTy)\n     }\n }\n \n-pub fn SExt(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn SExt(cx: @mut Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).sext(Val, DestTy)\n     }\n }\n \n-pub fn FPToUI(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn FPToUI(cx: @mut Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).fptoui(Val, DestTy)\n     }\n }\n \n-pub fn FPToSI(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn FPToSI(cx: @mut Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).fptosi(Val, DestTy)\n     }\n }\n \n-pub fn UIToFP(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn UIToFP(cx: @mut Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).uitofp(Val, DestTy)\n     }\n }\n \n-pub fn SIToFP(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn SIToFP(cx: @mut Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).sitofp(Val, DestTy)\n     }\n }\n \n-pub fn FPTrunc(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn FPTrunc(cx: @mut Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).fptrunc(Val, DestTy)\n     }\n }\n \n-pub fn FPExt(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn FPExt(cx: @mut Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).fpext(Val, DestTy)\n     }\n }\n \n-pub fn PtrToInt(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn PtrToInt(cx: @mut Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).ptrtoint(Val, DestTy)\n     }\n }\n \n-pub fn IntToPtr(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn IntToPtr(cx: @mut Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).inttoptr(Val, DestTy)\n     }\n }\n \n-pub fn BitCast(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn BitCast(cx: @mut Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).bitcast(Val, DestTy)\n     }\n }\n \n-pub fn ZExtOrBitCast(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn ZExtOrBitCast(cx: @mut Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).zext_or_bitcast(Val, DestTy)\n     }\n }\n \n-pub fn SExtOrBitCast(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn SExtOrBitCast(cx: @mut Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).sext_or_bitcast(Val, DestTy)\n     }\n }\n \n-pub fn TruncOrBitCast(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn TruncOrBitCast(cx: @mut Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).trunc_or_bitcast(Val, DestTy)\n     }\n }\n \n-pub fn Cast(cx: block, Op: Opcode, Val: ValueRef, DestTy: Type, _: *u8)\n+pub fn Cast(cx: @mut Block, Op: Opcode, Val: ValueRef, DestTy: Type, _: *u8)\n      -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).cast(Op, Val, DestTy)\n     }\n }\n \n-pub fn PointerCast(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn PointerCast(cx: @mut Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).pointercast(Val, DestTy)\n     }\n }\n \n-pub fn IntCast(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn IntCast(cx: @mut Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).intcast(Val, DestTy)\n     }\n }\n \n-pub fn FPCast(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn FPCast(cx: @mut Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).fpcast(Val, DestTy)\n@@ -575,15 +575,15 @@ pub fn FPCast(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n \n \n /* Comparisons */\n-pub fn ICmp(cx: block, Op: IntPredicate, LHS: ValueRef, RHS: ValueRef)\n+pub fn ICmp(cx: @mut Block, Op: IntPredicate, LHS: ValueRef, RHS: ValueRef)\n      -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::i1().to_ref()); }\n         B(cx).icmp(Op, LHS, RHS)\n     }\n }\n \n-pub fn FCmp(cx: block, Op: RealPredicate, LHS: ValueRef, RHS: ValueRef)\n+pub fn FCmp(cx: @mut Block, Op: RealPredicate, LHS: ValueRef, RHS: ValueRef)\n      -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::i1().to_ref()); }\n@@ -592,14 +592,14 @@ pub fn FCmp(cx: block, Op: RealPredicate, LHS: ValueRef, RHS: ValueRef)\n }\n \n /* Miscellaneous instructions */\n-pub fn EmptyPhi(cx: block, Ty: Type) -> ValueRef {\n+pub fn EmptyPhi(cx: @mut Block, Ty: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Ty.to_ref()); }\n         B(cx).empty_phi(Ty)\n     }\n }\n \n-pub fn Phi(cx: block, Ty: Type, vals: &[ValueRef], bbs: &[BasicBlockRef]) -> ValueRef {\n+pub fn Phi(cx: @mut Block, Ty: Type, vals: &[ValueRef], bbs: &[BasicBlockRef]) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Ty.to_ref()); }\n         B(cx).phi(Ty, vals, bbs)\n@@ -615,7 +615,7 @@ pub fn AddIncomingToPhi(phi: ValueRef, val: ValueRef, bb: BasicBlockRef) {\n     }\n }\n \n-pub fn _UndefReturn(cx: block, Fn: ValueRef) -> ValueRef {\n+pub fn _UndefReturn(cx: @mut Block, Fn: ValueRef) -> ValueRef {\n     unsafe {\n         let ccx = cx.fcx.ccx;\n         let ty = val_ty(Fn);\n@@ -629,142 +629,142 @@ pub fn _UndefReturn(cx: block, Fn: ValueRef) -> ValueRef {\n     }\n }\n \n-pub fn add_span_comment(cx: block, sp: span, text: &str) {\n+pub fn add_span_comment(cx: @mut Block, sp: span, text: &str) {\n     B(cx).add_span_comment(sp, text)\n }\n \n-pub fn add_comment(cx: block, text: &str) {\n+pub fn add_comment(cx: @mut Block, text: &str) {\n     B(cx).add_comment(text)\n }\n \n-pub fn InlineAsmCall(cx: block, asm: *c_char, cons: *c_char,\n+pub fn InlineAsmCall(cx: @mut Block, asm: *c_char, cons: *c_char,\n                      inputs: &[ValueRef], output: Type,\n                      volatile: bool, alignstack: bool,\n                      dia: AsmDialect) -> ValueRef {\n     B(cx).inline_asm_call(asm, cons, inputs, output, volatile, alignstack, dia)\n }\n \n-pub fn Call(cx: block, Fn: ValueRef, Args: &[ValueRef]) -> ValueRef {\n+pub fn Call(cx: @mut Block, Fn: ValueRef, Args: &[ValueRef]) -> ValueRef {\n     if cx.unreachable { return _UndefReturn(cx, Fn); }\n     B(cx).call(Fn, Args)\n }\n \n-pub fn FastCall(cx: block, Fn: ValueRef, Args: &[ValueRef]) -> ValueRef {\n+pub fn FastCall(cx: @mut Block, Fn: ValueRef, Args: &[ValueRef]) -> ValueRef {\n     if cx.unreachable { return _UndefReturn(cx, Fn); }\n     B(cx).call(Fn, Args)\n }\n \n-pub fn CallWithConv(cx: block, Fn: ValueRef, Args: &[ValueRef],\n+pub fn CallWithConv(cx: @mut Block, Fn: ValueRef, Args: &[ValueRef],\n                     Conv: CallConv) -> ValueRef {\n     if cx.unreachable { return _UndefReturn(cx, Fn); }\n     B(cx).call_with_conv(Fn, Args, Conv)\n }\n \n-pub fn Select(cx: block, If: ValueRef, Then: ValueRef, Else: ValueRef) -> ValueRef {\n+pub fn Select(cx: @mut Block, If: ValueRef, Then: ValueRef, Else: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(Then); }\n     B(cx).select(If, Then, Else)\n }\n \n-pub fn VAArg(cx: block, list: ValueRef, Ty: Type) -> ValueRef {\n+pub fn VAArg(cx: @mut Block, list: ValueRef, Ty: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Ty.to_ref()); }\n         B(cx).va_arg(list, Ty)\n     }\n }\n \n-pub fn ExtractElement(cx: block, VecVal: ValueRef, Index: ValueRef) -> ValueRef {\n+pub fn ExtractElement(cx: @mut Block, VecVal: ValueRef, Index: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n         B(cx).extract_element(VecVal, Index)\n     }\n }\n \n-pub fn InsertElement(cx: block, VecVal: ValueRef, EltVal: ValueRef,\n+pub fn InsertElement(cx: @mut Block, VecVal: ValueRef, EltVal: ValueRef,\n                      Index: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n         B(cx).insert_element(VecVal, EltVal, Index)\n     }\n }\n \n-pub fn ShuffleVector(cx: block, V1: ValueRef, V2: ValueRef,\n+pub fn ShuffleVector(cx: @mut Block, V1: ValueRef, V2: ValueRef,\n                      Mask: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n         B(cx).shuffle_vector(V1, V2, Mask)\n     }\n }\n \n-pub fn VectorSplat(cx: block, NumElts: uint, EltVal: ValueRef) -> ValueRef {\n+pub fn VectorSplat(cx: @mut Block, NumElts: uint, EltVal: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n         B(cx).vector_splat(NumElts, EltVal)\n     }\n }\n \n-pub fn ExtractValue(cx: block, AggVal: ValueRef, Index: uint) -> ValueRef {\n+pub fn ExtractValue(cx: @mut Block, AggVal: ValueRef, Index: uint) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n         B(cx).extract_value(AggVal, Index)\n     }\n }\n \n-pub fn InsertValue(cx: block, AggVal: ValueRef, EltVal: ValueRef, Index: uint) {\n+pub fn InsertValue(cx: @mut Block, AggVal: ValueRef, EltVal: ValueRef, Index: uint) {\n     if cx.unreachable { return; }\n     B(cx).insert_value(AggVal, EltVal, Index)\n }\n \n-pub fn IsNull(cx: block, Val: ValueRef) -> ValueRef {\n+pub fn IsNull(cx: @mut Block, Val: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::i1().to_ref()); }\n         B(cx).is_null(Val)\n     }\n }\n \n-pub fn IsNotNull(cx: block, Val: ValueRef) -> ValueRef {\n+pub fn IsNotNull(cx: @mut Block, Val: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::i1().to_ref()); }\n         B(cx).is_not_null(Val)\n     }\n }\n \n-pub fn PtrDiff(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn PtrDiff(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     unsafe {\n         let ccx = cx.fcx.ccx;\n         if cx.unreachable { return llvm::LLVMGetUndef(ccx.int_type.to_ref()); }\n         B(cx).ptrdiff(LHS, RHS)\n     }\n }\n \n-pub fn Trap(cx: block) {\n+pub fn Trap(cx: @mut Block) {\n     if cx.unreachable { return; }\n     B(cx).trap();\n }\n \n-pub fn LandingPad(cx: block, Ty: Type, PersFn: ValueRef,\n+pub fn LandingPad(cx: @mut Block, Ty: Type, PersFn: ValueRef,\n                   NumClauses: uint) -> ValueRef {\n     check_not_terminated(cx);\n     assert!(!cx.unreachable);\n     B(cx).landing_pad(Ty, PersFn, NumClauses)\n }\n \n-pub fn SetCleanup(cx: block, LandingPad: ValueRef) {\n+pub fn SetCleanup(cx: @mut Block, LandingPad: ValueRef) {\n     B(cx).set_cleanup(LandingPad)\n }\n \n-pub fn Resume(cx: block, Exn: ValueRef) -> ValueRef {\n+pub fn Resume(cx: @mut Block, Exn: ValueRef) -> ValueRef {\n     check_not_terminated(cx);\n     terminate(cx, \"Resume\");\n     B(cx).resume(Exn)\n }\n \n // Atomic Operations\n-pub fn AtomicCmpXchg(cx: block, dst: ValueRef,\n+pub fn AtomicCmpXchg(cx: @mut Block, dst: ValueRef,\n                      cmp: ValueRef, src: ValueRef,\n                      order: AtomicOrdering) -> ValueRef {\n     B(cx).atomic_cmpxchg(dst, cmp, src, order)\n }\n-pub fn AtomicRMW(cx: block, op: AtomicBinOp,\n+pub fn AtomicRMW(cx: @mut Block, op: AtomicBinOp,\n                  dst: ValueRef, src: ValueRef,\n                  order: AtomicOrdering) -> ValueRef {\n     B(cx).atomic_rmw(op, dst, src, order)"}, {"sha": "d6215cd60af32be1824212aa4cdda952fa1c4ca0", "filename": "src/librustc/middle/trans/cabi.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3315edfae7854d1f9f58840bbec4d43392c3fa51/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3315edfae7854d1f9f58840bbec4d43392c3fa51/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs?ref=3315edfae7854d1f9f58840bbec4d43392c3fa51", "patch": "@@ -56,7 +56,7 @@ impl FnType {\n         return llfn;\n     }\n \n-    pub fn build_shim_args(&self, bcx: block, arg_tys: &[Type], llargbundle: ValueRef)\n+    pub fn build_shim_args(&self, bcx: @mut Block, arg_tys: &[Type], llargbundle: ValueRef)\n                            -> ~[ValueRef] {\n         let mut atys: &[LLVMType] = self.arg_tys;\n         let mut attrs: &[option::Option<Attribute>] = self.attrs;\n@@ -90,7 +90,7 @@ impl FnType {\n         return llargvals;\n     }\n \n-    pub fn build_shim_ret(&self, bcx: block, arg_tys: &[Type], ret_def: bool,\n+    pub fn build_shim_ret(&self, bcx: @mut Block, arg_tys: &[Type], ret_def: bool,\n                           llargbundle: ValueRef, llretval: ValueRef) {\n         for self.attrs.iter().enumerate().advance |(i, a)| {\n             match *a {\n@@ -120,7 +120,7 @@ impl FnType {\n         };\n     }\n \n-    pub fn build_wrap_args(&self, bcx: block, ret_ty: Type,\n+    pub fn build_wrap_args(&self, bcx: @mut Block, ret_ty: Type,\n                            llwrapfn: ValueRef, llargbundle: ValueRef) {\n         let mut atys: &[LLVMType] = self.arg_tys;\n         let mut attrs: &[option::Option<Attribute>] = self.attrs;\n@@ -156,7 +156,7 @@ impl FnType {\n         store_inbounds(bcx, llretptr, llargbundle, [0u, n]);\n     }\n \n-    pub fn build_wrap_ret(&self, bcx: block, arg_tys: &[Type], llargbundle: ValueRef) {\n+    pub fn build_wrap_ret(&self, bcx: @mut Block, arg_tys: &[Type], llargbundle: ValueRef) {\n         if self.ret_ty.ty.kind() == Void {\n             return;\n         }"}, {"sha": "5f76981c794674530587fb5da3b8d4b75f8d02dd", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/3315edfae7854d1f9f58840bbec4d43392c3fa51/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3315edfae7854d1f9f58840bbec4d43392c3fa51/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=3315edfae7854d1f9f58840bbec4d43392c3fa51", "patch": "@@ -72,11 +72,11 @@ pub enum CalleeData {\n }\n \n pub struct Callee {\n-    bcx: block,\n+    bcx: @mut Block,\n     data: CalleeData\n }\n \n-pub fn trans(bcx: block, expr: @ast::expr) -> Callee {\n+pub fn trans(bcx: @mut Block, expr: @ast::expr) -> Callee {\n     let _icx = push_ctxt(\"trans_callee\");\n     debug!(\"callee::trans(expr=%s)\", expr.repr(bcx.tcx()));\n \n@@ -91,7 +91,7 @@ pub fn trans(bcx: block, expr: @ast::expr) -> Callee {\n     // any other expressions are closures:\n     return datum_callee(bcx, expr);\n \n-    fn datum_callee(bcx: block, expr: @ast::expr) -> Callee {\n+    fn datum_callee(bcx: @mut Block, expr: @ast::expr) -> Callee {\n         let DatumBlock {bcx, datum} = expr::trans_to_datum(bcx, expr);\n         match ty::get(datum.ty).sty {\n             ty::ty_bare_fn(*) => {\n@@ -110,11 +110,11 @@ pub fn trans(bcx: block, expr: @ast::expr) -> Callee {\n         }\n     }\n \n-    fn fn_callee(bcx: block, fd: FnData) -> Callee {\n+    fn fn_callee(bcx: @mut Block, fd: FnData) -> Callee {\n         return Callee {bcx: bcx, data: Fn(fd)};\n     }\n \n-    fn trans_def(bcx: block, def: ast::def, ref_expr: @ast::expr) -> Callee {\n+    fn trans_def(bcx: @mut Block, def: ast::def, ref_expr: @ast::expr) -> Callee {\n         match def {\n             ast::def_fn(did, _) | ast::def_static_method(did, None, _) => {\n                 fn_callee(bcx, trans_fn_ref(bcx, did, ref_expr.id))\n@@ -155,14 +155,14 @@ pub fn trans(bcx: block, expr: @ast::expr) -> Callee {\n     }\n }\n \n-pub fn trans_fn_ref_to_callee(bcx: block,\n+pub fn trans_fn_ref_to_callee(bcx: @mut Block,\n                               def_id: ast::def_id,\n                               ref_id: ast::node_id) -> Callee {\n     Callee {bcx: bcx,\n             data: Fn(trans_fn_ref(bcx, def_id, ref_id))}\n }\n \n-pub fn trans_fn_ref(bcx: block,\n+pub fn trans_fn_ref(bcx: @mut Block,\n                     def_id: ast::def_id,\n                     ref_id: ast::node_id) -> FnData {\n     /*!\n@@ -182,7 +182,7 @@ pub fn trans_fn_ref(bcx: block,\n }\n \n pub fn trans_fn_ref_with_vtables_to_callee(\n-        bcx: block,\n+        bcx: @mut Block,\n         def_id: ast::def_id,\n         ref_id: ast::node_id,\n         type_params: &[ty::t],\n@@ -193,7 +193,7 @@ pub fn trans_fn_ref_with_vtables_to_callee(\n                                                type_params, vtables))}\n }\n \n-fn get_impl_resolutions(bcx: block,\n+fn get_impl_resolutions(bcx: @mut Block,\n                         impl_id: ast::def_id)\n                          -> typeck::vtable_res {\n     if impl_id.crate == ast::local_crate {\n@@ -208,7 +208,7 @@ fn get_impl_resolutions(bcx: block,\n     }\n }\n \n-fn resolve_default_method_vtables(bcx: block,\n+fn resolve_default_method_vtables(bcx: @mut Block,\n                                   impl_id: ast::def_id,\n                                   method: &ty::Method,\n                                   substs: &ty::substs,\n@@ -246,7 +246,7 @@ fn resolve_default_method_vtables(bcx: block,\n \n \n pub fn trans_fn_ref_with_vtables(\n-        bcx: block,            //\n+        bcx: @mut Block,       //\n         def_id: ast::def_id,   // def id of fn\n         ref_id: ast::node_id,  // node id of use of fn; may be zero if N/A\n         type_params: &[ty::t], // values for fn's ty params\n@@ -431,13 +431,13 @@ pub fn trans_fn_ref_with_vtables(\n // ______________________________________________________________________\n // Translating calls\n \n-pub fn trans_call(in_cx: block,\n+pub fn trans_call(in_cx: @mut Block,\n                   call_ex: @ast::expr,\n                   f: @ast::expr,\n                   args: CallArgs,\n                   id: ast::node_id,\n                   dest: expr::Dest)\n-                  -> block {\n+                  -> @mut Block {\n     let _icx = push_ctxt(\"trans_call\");\n     trans_call_inner(in_cx,\n                      call_ex.info(),\n@@ -449,13 +449,13 @@ pub fn trans_call(in_cx: block,\n                      DontAutorefArg).bcx\n }\n \n-pub fn trans_method_call(in_cx: block,\n+pub fn trans_method_call(in_cx: @mut Block,\n                          call_ex: @ast::expr,\n                          callee_id: ast::node_id,\n                          rcvr: @ast::expr,\n                          args: CallArgs,\n                          dest: expr::Dest)\n-                         -> block {\n+                         -> @mut Block {\n     let _icx = push_ctxt(\"trans_method_call\");\n     debug!(\"trans_method_call(call_ex=%s, rcvr=%s)\",\n            call_ex.repr(in_cx.tcx()),\n@@ -487,7 +487,7 @@ pub fn trans_method_call(in_cx: block,\n         DontAutorefArg).bcx\n }\n \n-pub fn trans_lang_call(bcx: block,\n+pub fn trans_lang_call(bcx: @mut Block,\n                        did: ast::def_id,\n                        args: &[ValueRef],\n                        dest: Option<expr::Dest>)\n@@ -514,12 +514,12 @@ pub fn trans_lang_call(bcx: block,\n                              DontAutorefArg)\n }\n \n-pub fn trans_lang_call_with_type_params(bcx: block,\n+pub fn trans_lang_call_with_type_params(bcx: @mut Block,\n                                         did: ast::def_id,\n                                         args: &[ValueRef],\n                                         type_params: &[ty::t],\n                                         dest: expr::Dest)\n-    -> block {\n+    -> @mut Block {\n     let fty;\n     if did.crate == ast::local_crate {\n         fty = ty::node_id_to_type(bcx.tcx(), did.node);\n@@ -572,11 +572,11 @@ pub fn body_contains_ret(body: &ast::Block) -> bool {\n }\n \n // See [Note-arg-mode]\n-pub fn trans_call_inner(in_cx: block,\n+pub fn trans_call_inner(in_cx: @mut Block,\n                         call_info: Option<NodeInfo>,\n                         fn_expr_ty: ty::t,\n                         ret_ty: ty::t,\n-                        get_callee: &fn(block) -> Callee,\n+                        get_callee: &fn(@mut Block) -> Callee,\n                         args: CallArgs,\n                         dest: Option<expr::Dest>,\n                         autoref_arg: AutorefArg)\n@@ -718,7 +718,7 @@ pub enum CallArgs<'self> {\n     ArgVals(&'self [ValueRef])\n }\n \n-pub fn trans_ret_slot(bcx: block, fn_ty: ty::t, dest: Option<expr::Dest>)\n+pub fn trans_ret_slot(bcx: @mut Block, fn_ty: ty::t, dest: Option<expr::Dest>)\n                       -> ValueRef {\n     let retty = ty::ty_fn_ret(fn_ty);\n \n@@ -736,12 +736,12 @@ pub fn trans_ret_slot(bcx: block, fn_ty: ty::t, dest: Option<expr::Dest>)\n     }\n }\n \n-pub fn trans_args(cx: block,\n+pub fn trans_args(cx: @mut Block,\n                   args: CallArgs,\n                   fn_ty: ty::t,\n                   ret_flag: Option<ValueRef>,\n                   autoref_arg: AutorefArg,\n-                  llargs: &mut ~[ValueRef]) -> block\n+                  llargs: &mut ~[ValueRef]) -> @mut Block\n {\n     let _icx = push_ctxt(\"trans_args\");\n     let mut temp_cleanups = ~[];\n@@ -790,7 +790,7 @@ pub enum AutorefArg {\n \n // temp_cleanups: cleanups that should run only if failure occurs before the\n // call takes place:\n-pub fn trans_arg_expr(bcx: block,\n+pub fn trans_arg_expr(bcx: @mut Block,\n                       formal_arg_ty: ty::t,\n                       self_mode: ty::SelfMode,\n                       arg_expr: @ast::expr,"}, {"sha": "6e0f0eeee87717839ca7be938dc5994a8d2dcfb0", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3315edfae7854d1f9f58840bbec4d43392c3fa51/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3315edfae7854d1f9f58840bbec4d43392c3fa51/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=3315edfae7854d1f9f58840bbec4d43392c3fa51", "patch": "@@ -156,15 +156,15 @@ pub fn mk_closure_tys(tcx: ty::ctxt,\n     return cdata_ty;\n }\n \n-fn heap_for_unique_closure(bcx: block, t: ty::t) -> heap {\n+fn heap_for_unique_closure(bcx: @mut Block, t: ty::t) -> heap {\n     if ty::type_contents(bcx.tcx(), t).contains_managed() {\n         heap_managed_unique\n     } else {\n         heap_exchange_closure\n     }\n }\n \n-pub fn allocate_cbox(bcx: block, sigil: ast::Sigil, cdata_ty: ty::t)\n+pub fn allocate_cbox(bcx: @mut Block, sigil: ast::Sigil, cdata_ty: ty::t)\n                   -> Result {\n     let _icx = push_ctxt(\"closure::allocate_cbox\");\n     let ccx = bcx.ccx();\n@@ -189,14 +189,14 @@ pub fn allocate_cbox(bcx: block, sigil: ast::Sigil, cdata_ty: ty::t)\n pub struct ClosureResult {\n     llbox: ValueRef, // llvalue of ptr to closure\n     cdata_ty: ty::t, // type of the closure data\n-    bcx: block       // final bcx\n+    bcx: @mut Block       // final bcx\n }\n \n // Given a block context and a list of tydescs and values to bind\n // construct a closure out of them. If copying is true, it is a\n // heap allocated closure that copies the upvars into environment.\n // Otherwise, it is stack allocated and copies pointers to the upvars.\n-pub fn store_environment(bcx: block,\n+pub fn store_environment(bcx: @mut Block,\n                          bound_values: ~[EnvValue],\n                          sigil: ast::Sigil) -> ClosureResult {\n     let _icx = push_ctxt(\"closure::store_environment\");\n@@ -257,7 +257,7 @@ pub fn store_environment(bcx: block,\n \n // Given a context and a list of upvars, build a closure. This just\n // collects the upvars and packages them up for store_environment.\n-pub fn build_closure(bcx0: block,\n+pub fn build_closure(bcx0: @mut Block,\n                      cap_vars: &[moves::CaptureVar],\n                      sigil: ast::Sigil,\n                      include_ret_handle: Option<ValueRef>) -> ClosureResult {\n@@ -318,7 +318,7 @@ pub fn build_closure(bcx0: block,\n // Given an enclosing block context, a new function context, a closure type,\n // and a list of upvars, generate code to load and populate the environment\n // with the upvars and type descriptors.\n-pub fn load_environment(fcx: fn_ctxt,\n+pub fn load_environment(fcx: @mut FunctionContext,\n                         cdata_ty: ty::t,\n                         cap_vars: &[moves::CaptureVar],\n                         load_ret_handle: bool,\n@@ -355,14 +355,14 @@ pub fn load_environment(fcx: fn_ctxt,\n     }\n }\n \n-pub fn trans_expr_fn(bcx: block,\n+pub fn trans_expr_fn(bcx: @mut Block,\n                      sigil: ast::Sigil,\n                      decl: &ast::fn_decl,\n                      body: &ast::Block,\n                      outer_id: ast::node_id,\n                      user_id: ast::node_id,\n                      is_loop_body: Option<Option<ValueRef>>,\n-                     dest: expr::Dest) -> block {\n+                     dest: expr::Dest) -> @mut Block {\n     /*!\n      *\n      * Translates the body of a closure expression.\n@@ -455,10 +455,10 @@ pub fn trans_expr_fn(bcx: block,\n }\n \n pub fn make_closure_glue(\n-        cx: block,\n+        cx: @mut Block,\n         v: ValueRef,\n         t: ty::t,\n-        glue_fn: &fn(block, v: ValueRef, t: ty::t) -> block) -> block {\n+        glue_fn: &fn(@mut Block, v: ValueRef, t: ty::t) -> @mut Block) -> @mut Block {\n     let _icx = push_ctxt(\"closure::make_closure_glue\");\n     let bcx = cx;\n     let tcx = cx.tcx();\n@@ -478,10 +478,10 @@ pub fn make_closure_glue(\n }\n \n pub fn make_opaque_cbox_take_glue(\n-    bcx: block,\n+    bcx: @mut Block,\n     sigil: ast::Sigil,\n     cboxptr: ValueRef)     // ptr to ptr to the opaque closure\n-    -> block {\n+    -> @mut Block {\n     // Easy cases:\n     let _icx = push_ctxt(\"closure::make_opaque_cbox_take_glue\");\n     match sigil {\n@@ -499,10 +499,10 @@ pub fn make_opaque_cbox_take_glue(\n }\n \n pub fn make_opaque_cbox_drop_glue(\n-    bcx: block,\n+    bcx: @mut Block,\n     sigil: ast::Sigil,\n     cboxptr: ValueRef)     // ptr to the opaque closure\n-    -> block {\n+    -> @mut Block {\n     let _icx = push_ctxt(\"closure::make_opaque_cbox_drop_glue\");\n     match sigil {\n         ast::BorrowedSigil => bcx,\n@@ -520,10 +520,10 @@ pub fn make_opaque_cbox_drop_glue(\n }\n \n pub fn make_opaque_cbox_free_glue(\n-    bcx: block,\n+    bcx: @mut Block,\n     sigil: ast::Sigil,\n     cbox: ValueRef)     // ptr to ptr to the opaque closure\n-    -> block {\n+    -> @mut Block {\n     let _icx = push_ctxt(\"closure::make_opaque_cbox_free_glue\");\n     match sigil {\n         ast::BorrowedSigil => {"}, {"sha": "fef6607bbed8e925eeda2f00c3c9ac6ad69089d1", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 120, "deletions": 125, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/3315edfae7854d1f9f58840bbec4d43392c3fa51/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3315edfae7854d1f9f58840bbec4d43392c3fa51/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=3315edfae7854d1f9f58840bbec4d43392c3fa51", "patch": "@@ -157,7 +157,7 @@ impl Repr for param_substs {\n \n // Function context.  Every LLVM function we create will have one of\n // these.\n-pub struct fn_ctxt_ {\n+pub struct FunctionContext {\n     // The ValueRef returned from a call to llvm::LLVMAddFunction; the\n     // address of the first instruction in the sequence of\n     // instructions for this function that will go in the .text\n@@ -174,7 +174,7 @@ pub struct fn_ctxt_ {\n     // always be Some.\n     llretptr: Option<ValueRef>,\n \n-    entry_bcx: Option<block>,\n+    entry_bcx: Option<@mut Block>,\n \n     // These elements: \"hoisted basic blocks\" containing\n     // administrative activities that have to happen in only one place in\n@@ -227,7 +227,7 @@ pub struct fn_ctxt_ {\n     ccx: @mut CrateContext\n }\n \n-impl fn_ctxt_ {\n+impl FunctionContext {\n     pub fn arg_pos(&self, arg: uint) -> uint {\n         if self.has_immediate_return_value {\n             arg + 1u\n@@ -266,8 +266,6 @@ impl fn_ctxt_ {\n     }\n }\n \n-pub type fn_ctxt = @mut fn_ctxt_;\n-\n pub fn warn_not_to_commit(ccx: &mut CrateContext, msg: &str) {\n     if !ccx.do_not_commit_warning_issued {\n         ccx.do_not_commit_warning_issued = true;\n@@ -291,8 +289,8 @@ pub enum cleantype {\n }\n \n pub enum cleanup {\n-    clean(@fn(block) -> block, cleantype),\n-    clean_temp(ValueRef, @fn(block) -> block, cleantype),\n+    clean(@fn(@mut Block) -> @mut Block, cleantype),\n+    clean_temp(ValueRef, @fn(@mut Block) -> @mut Block, cleantype),\n }\n \n // Can't use deriving(Clone) because of the managed closure.\n@@ -314,13 +312,13 @@ pub struct cleanup_path {\n     dest: BasicBlockRef\n }\n \n-pub fn shrink_scope_clean(scope_info: &mut scope_info, size: uint) {\n+pub fn shrink_scope_clean(scope_info: &mut ScopeInfo, size: uint) {\n     scope_info.landing_pad = None;\n     scope_info.cleanup_paths = scope_info.cleanup_paths.iter()\n             .take_while(|&cu| cu.size <= size).transform(|&x|x).collect();\n }\n \n-pub fn grow_scope_clean(scope_info: &mut scope_info) {\n+pub fn grow_scope_clean(scope_info: &mut ScopeInfo) {\n     scope_info.landing_pad = None;\n }\n \n@@ -332,7 +330,7 @@ pub fn cleanup_type(cx: ty::ctxt, ty: ty::t) -> cleantype {\n     }\n }\n \n-pub fn add_clean(bcx: block, val: ValueRef, t: ty::t) {\n+pub fn add_clean(bcx: @mut Block, val: ValueRef, t: ty::t) {\n     if !ty::type_needs_drop(bcx.tcx(), t) { return; }\n \n     debug!(\"add_clean(%s, %s, %s)\", bcx.to_str(), bcx.val_to_str(val), t.repr(bcx.tcx()));\n@@ -344,7 +342,7 @@ pub fn add_clean(bcx: block, val: ValueRef, t: ty::t) {\n     }\n }\n \n-pub fn add_clean_temp_immediate(cx: block, val: ValueRef, ty: ty::t) {\n+pub fn add_clean_temp_immediate(cx: @mut Block, val: ValueRef, ty: ty::t) {\n     if !ty::type_needs_drop(cx.tcx(), ty) { return; }\n     debug!(\"add_clean_temp_immediate(%s, %s, %s)\",\n            cx.to_str(), cx.val_to_str(val),\n@@ -358,15 +356,18 @@ pub fn add_clean_temp_immediate(cx: block, val: ValueRef, ty: ty::t) {\n     }\n }\n \n-pub fn add_clean_temp_mem(bcx: block, val: ValueRef, t: ty::t) {\n+pub fn add_clean_temp_mem(bcx: @mut Block, val: ValueRef, t: ty::t) {\n     add_clean_temp_mem_in_scope_(bcx, None, val, t);\n }\n \n-pub fn add_clean_temp_mem_in_scope(bcx: block, scope_id: ast::node_id, val: ValueRef, t: ty::t) {\n+pub fn add_clean_temp_mem_in_scope(bcx: @mut Block,\n+                                   scope_id: ast::node_id,\n+                                   val: ValueRef,\n+                                   t: ty::t) {\n     add_clean_temp_mem_in_scope_(bcx, Some(scope_id), val, t);\n }\n \n-pub fn add_clean_temp_mem_in_scope_(bcx: block, scope_id: Option<ast::node_id>,\n+pub fn add_clean_temp_mem_in_scope_(bcx: @mut Block, scope_id: Option<ast::node_id>,\n                                     val: ValueRef, t: ty::t) {\n     if !ty::type_needs_drop(bcx.tcx(), t) { return; }\n     debug!(\"add_clean_temp_mem(%s, %s, %s)\",\n@@ -378,7 +379,7 @@ pub fn add_clean_temp_mem_in_scope_(bcx: block, scope_id: Option<ast::node_id>,\n         grow_scope_clean(scope_info);\n     }\n }\n-pub fn add_clean_return_to_mut(bcx: block,\n+pub fn add_clean_return_to_mut(bcx: @mut Block,\n                                scope_id: ast::node_id,\n                                root_key: root_map_key,\n                                frozen_val_ref: ValueRef,\n@@ -407,14 +408,14 @@ pub fn add_clean_return_to_mut(bcx: block,\n         grow_scope_clean(scope_info);\n     }\n }\n-pub fn add_clean_free(cx: block, ptr: ValueRef, heap: heap) {\n+pub fn add_clean_free(cx: @mut Block, ptr: ValueRef, heap: heap) {\n     let free_fn = match heap {\n       heap_managed | heap_managed_unique => {\n-        let f: @fn(block) -> block = |a| glue::trans_free(a, ptr);\n+        let f: @fn(@mut Block) -> @mut Block = |a| glue::trans_free(a, ptr);\n         f\n       }\n       heap_exchange | heap_exchange_closure => {\n-        let f: @fn(block) -> block = |a| glue::trans_exchange_free(a, ptr);\n+        let f: @fn(@mut Block) -> @mut Block = |a| glue::trans_exchange_free(a, ptr);\n         f\n       }\n     };\n@@ -429,7 +430,7 @@ pub fn add_clean_free(cx: block, ptr: ValueRef, heap: heap) {\n // to a system where we can also cancel the cleanup on local variables, but\n // this will be more involved. For now, we simply zero out the local, and the\n // drop glue checks whether it is zero.\n-pub fn revoke_clean(cx: block, val: ValueRef) {\n+pub fn revoke_clean(cx: @mut Block, val: ValueRef) {\n     do in_scope_cx(cx, None) |scope_info| {\n         let cleanup_pos = scope_info.cleanups.iter().position(\n             |cu| match *cu {\n@@ -446,16 +447,16 @@ pub fn revoke_clean(cx: block, val: ValueRef) {\n     }\n }\n \n-pub fn block_cleanups(bcx: block) -> ~[cleanup] {\n+pub fn block_cleanups(bcx: @mut Block) -> ~[cleanup] {\n     match bcx.scope {\n        None  => ~[],\n        Some(inf) => inf.cleanups.clone(),\n     }\n }\n \n-pub struct scope_info {\n-    parent: Option<@mut scope_info>,\n-    loop_break: Option<block>,\n+pub struct ScopeInfo {\n+    parent: Option<@mut ScopeInfo>,\n+    loop_break: Option<@mut Block>,\n     loop_label: Option<ident>,\n     // A list of functions that must be run at when leaving this\n     // block, cleaning up any variables that were introduced in the\n@@ -470,7 +471,7 @@ pub struct scope_info {\n     node_info: Option<NodeInfo>,\n }\n \n-impl scope_info {\n+impl ScopeInfo {\n     pub fn empty_cleanups(&mut self) -> bool {\n         self.cleanups.is_empty()\n     }\n@@ -513,7 +514,7 @@ pub struct NodeInfo {\n // code.  Each basic block we generate is attached to a function, typically\n // with many basic blocks per function.  All the basic blocks attached to a\n // function are organized as a directed graph.\n-pub struct block_ {\n+pub struct Block {\n     // The BasicBlockRef returned from a call to\n     // llvm::LLVMAppendBasicBlock(llfn, name), which adds a basic\n     // block to the function pointed to by llfn.  We insert\n@@ -522,53 +523,105 @@ pub struct block_ {\n     llbb: BasicBlockRef,\n     terminated: bool,\n     unreachable: bool,\n-    parent: Option<block>,\n+    parent: Option<@mut Block>,\n     // The current scope within this basic block\n-    scope: Option<@mut scope_info>,\n+    scope: Option<@mut ScopeInfo>,\n     // Is this block part of a landing pad?\n     is_lpad: bool,\n     // info about the AST node this block originated from, if any\n     node_info: Option<NodeInfo>,\n     // The function context for the function to which this block is\n     // attached.\n-    fcx: fn_ctxt\n-}\n+    fcx: @mut FunctionContext\n+}\n+\n+impl Block {\n+\n+    pub fn new(llbb: BasicBlockRef,\n+               parent: Option<@mut Block>,\n+               is_lpad: bool,\n+               node_info: Option<NodeInfo>,\n+               fcx: @mut FunctionContext)\n+            -> Block {\n+        Block {\n+            llbb: llbb,\n+            terminated: false,\n+            unreachable: false,\n+            parent: parent,\n+            scope: None,\n+            is_lpad: is_lpad,\n+            node_info: node_info,\n+            fcx: fcx\n+        }\n+    }\n+\n+    pub fn ccx(&self) -> @mut CrateContext { self.fcx.ccx }\n+    pub fn tcx(&self) -> ty::ctxt { self.fcx.ccx.tcx }\n+    pub fn sess(&self) -> Session { self.fcx.ccx.sess }\n \n-pub fn block_(llbb: BasicBlockRef, parent: Option<block>,\n-              is_lpad: bool, node_info: Option<NodeInfo>, fcx: fn_ctxt)\n-    -> block_ {\n+    pub fn ident(&self, ident: ident) -> @str {\n+        token::ident_to_str(&ident)\n+    }\n \n-    block_ {\n-        llbb: llbb,\n-        terminated: false,\n-        unreachable: false,\n-        parent: parent,\n-        scope: None,\n-        is_lpad: is_lpad,\n-        node_info: node_info,\n-        fcx: fcx\n+    pub fn node_id_to_str(&self, id: ast::node_id) -> ~str {\n+        ast_map::node_id_to_str(self.tcx().items, id, self.sess().intr())\n+    }\n+\n+    pub fn expr_to_str(&self, e: @ast::expr) -> ~str {\n+        e.repr(self.tcx())\n+    }\n+\n+    pub fn expr_is_lval(&self, e: &ast::expr) -> bool {\n+        ty::expr_is_lval(self.tcx(), self.ccx().maps.method_map, e)\n+    }\n+\n+    pub fn expr_kind(&self, e: &ast::expr) -> ty::ExprKind {\n+        ty::expr_kind(self.tcx(), self.ccx().maps.method_map, e)\n+    }\n+\n+    pub fn def(&self, nid: ast::node_id) -> ast::def {\n+        match self.tcx().def_map.find(&nid) {\n+            Some(&v) => v,\n+            None => {\n+                self.tcx().sess.bug(fmt!(\n+                    \"No def associated with node id %?\", nid));\n+            }\n+        }\n+    }\n+\n+    pub fn val_to_str(&self, val: ValueRef) -> ~str {\n+        self.ccx().tn.val_to_str(val)\n+    }\n+\n+    pub fn llty_str(&self, ty: Type) -> ~str {\n+        self.ccx().tn.type_to_str(ty)\n     }\n-}\n \n-pub type block = @mut block_;\n+    pub fn ty_to_str(&self, t: ty::t) -> ~str {\n+        t.repr(self.tcx())\n+    }\n \n-pub fn mk_block(llbb: BasicBlockRef, parent: Option<block>,\n-            is_lpad: bool, node_info: Option<NodeInfo>, fcx: fn_ctxt)\n-    -> block {\n-    @mut block_(llbb, parent, is_lpad, node_info, fcx)\n+    pub fn to_str(&self) -> ~str {\n+        unsafe {\n+            match self.node_info {\n+                Some(node_info) => fmt!(\"[block %d]\", node_info.id),\n+                None => fmt!(\"[block %x]\", transmute(&*self)),\n+            }\n+        }\n+    }\n }\n \n pub struct Result {\n-    bcx: block,\n+    bcx: @mut Block,\n     val: ValueRef\n }\n \n-pub fn rslt(bcx: block, val: ValueRef) -> Result {\n+pub fn rslt(bcx: @mut Block, val: ValueRef) -> Result {\n     Result {bcx: bcx, val: val}\n }\n \n impl Result {\n-    pub fn unpack(&self, bcx: &mut block) -> ValueRef {\n+    pub fn unpack(&self, bcx: &mut @mut Block) -> ValueRef {\n         *bcx = self.bcx;\n         return self.val;\n     }\n@@ -580,7 +633,7 @@ pub fn val_ty(v: ValueRef) -> Type {\n     }\n }\n \n-pub fn in_scope_cx(cx: block, scope_id: Option<ast::node_id>, f: &fn(si: &mut scope_info)) {\n+pub fn in_scope_cx(cx: @mut Block, scope_id: Option<ast::node_id>, f: &fn(si: &mut ScopeInfo)) {\n     let mut cur = cx;\n     let mut cur_scope = cur.scope;\n     loop {\n@@ -610,72 +663,14 @@ pub fn in_scope_cx(cx: block, scope_id: Option<ast::node_id>, f: &fn(si: &mut sc\n     }\n }\n \n-pub fn block_parent(cx: block) -> block {\n+pub fn block_parent(cx: @mut Block) -> @mut Block {\n     match cx.parent {\n       Some(b) => b,\n       None    => cx.sess().bug(fmt!(\"block_parent called on root block %?\",\n                                    cx))\n     }\n }\n \n-// Accessors\n-\n-impl block_ {\n-    pub fn ccx(&self) -> @mut CrateContext { self.fcx.ccx }\n-    pub fn tcx(&self) -> ty::ctxt { self.fcx.ccx.tcx }\n-    pub fn sess(&self) -> Session { self.fcx.ccx.sess }\n-\n-    pub fn ident(&self, ident: ident) -> @str {\n-        token::ident_to_str(&ident)\n-    }\n-\n-    pub fn node_id_to_str(&self, id: ast::node_id) -> ~str {\n-        ast_map::node_id_to_str(self.tcx().items, id, self.sess().intr())\n-    }\n-\n-    pub fn expr_to_str(&self, e: @ast::expr) -> ~str {\n-        e.repr(self.tcx())\n-    }\n-\n-    pub fn expr_is_lval(&self, e: &ast::expr) -> bool {\n-        ty::expr_is_lval(self.tcx(), self.ccx().maps.method_map, e)\n-    }\n-\n-    pub fn expr_kind(&self, e: &ast::expr) -> ty::ExprKind {\n-        ty::expr_kind(self.tcx(), self.ccx().maps.method_map, e)\n-    }\n-\n-    pub fn def(&self, nid: ast::node_id) -> ast::def {\n-        match self.tcx().def_map.find(&nid) {\n-            Some(&v) => v,\n-            None => {\n-                self.tcx().sess.bug(fmt!(\n-                    \"No def associated with node id %?\", nid));\n-            }\n-        }\n-    }\n-\n-    pub fn val_to_str(&self, val: ValueRef) -> ~str {\n-        self.ccx().tn.val_to_str(val)\n-    }\n-\n-    pub fn llty_str(&self, ty: Type) -> ~str {\n-        self.ccx().tn.type_to_str(ty)\n-    }\n-\n-    pub fn ty_to_str(&self, t: ty::t) -> ~str {\n-        t.repr(self.tcx())\n-    }\n-\n-    pub fn to_str(&self) -> ~str {\n-        unsafe {\n-            match self.node_info {\n-                Some(node_info) => fmt!(\"[block %d]\", node_info.id),\n-                None => fmt!(\"[block %x]\", transmute(&*self)),\n-            }\n-        }\n-    }\n-}\n \n // Let T be the content of a box @T.  tuplify_box_ty(t) returns the\n // representation of @T as a tuple (i.e., the ty::t version of what T_box()\n@@ -940,17 +935,17 @@ pub struct mono_id_ {\n \n pub type mono_id = @mono_id_;\n \n-pub fn umax(cx: block, a: ValueRef, b: ValueRef) -> ValueRef {\n+pub fn umax(cx: @mut Block, a: ValueRef, b: ValueRef) -> ValueRef {\n     let cond = build::ICmp(cx, lib::llvm::IntULT, a, b);\n     return build::Select(cx, cond, b, a);\n }\n \n-pub fn umin(cx: block, a: ValueRef, b: ValueRef) -> ValueRef {\n+pub fn umin(cx: @mut Block, a: ValueRef, b: ValueRef) -> ValueRef {\n     let cond = build::ICmp(cx, lib::llvm::IntULT, a, b);\n     return build::Select(cx, cond, a, b);\n }\n \n-pub fn align_to(cx: block, off: ValueRef, align: ValueRef) -> ValueRef {\n+pub fn align_to(cx: @mut Block, off: ValueRef, align: ValueRef) -> ValueRef {\n     let mask = build::Sub(cx, align, C_int(cx.ccx(), 1));\n     let bumped = build::Add(cx, off, mask);\n     return build::And(cx, bumped, build::Not(cx, mask));\n@@ -974,7 +969,7 @@ pub fn path_str(sess: session::Session, p: &[path_elt]) -> ~str {\n     r\n }\n \n-pub fn monomorphize_type(bcx: block, t: ty::t) -> ty::t {\n+pub fn monomorphize_type(bcx: @mut Block, t: ty::t) -> ty::t {\n     match bcx.fcx.param_substs {\n         Some(substs) => {\n             ty::subst_tps(bcx.tcx(), substs.tys, substs.self_ty, t)\n@@ -987,23 +982,23 @@ pub fn monomorphize_type(bcx: block, t: ty::t) -> ty::t {\n     }\n }\n \n-pub fn node_id_type(bcx: block, id: ast::node_id) -> ty::t {\n+pub fn node_id_type(bcx: @mut Block, id: ast::node_id) -> ty::t {\n     let tcx = bcx.tcx();\n     let t = ty::node_id_to_type(tcx, id);\n     monomorphize_type(bcx, t)\n }\n \n-pub fn expr_ty(bcx: block, ex: &ast::expr) -> ty::t {\n+pub fn expr_ty(bcx: @mut Block, ex: &ast::expr) -> ty::t {\n     node_id_type(bcx, ex.id)\n }\n \n-pub fn expr_ty_adjusted(bcx: block, ex: &ast::expr) -> ty::t {\n+pub fn expr_ty_adjusted(bcx: @mut Block, ex: &ast::expr) -> ty::t {\n     let tcx = bcx.tcx();\n     let t = ty::expr_ty_adjusted(tcx, ex);\n     monomorphize_type(bcx, t)\n }\n \n-pub fn node_id_type_params(bcx: block, id: ast::node_id) -> ~[ty::t] {\n+pub fn node_id_type_params(bcx: @mut Block, id: ast::node_id) -> ~[ty::t] {\n     let tcx = bcx.tcx();\n     let params = ty::node_id_to_type_params(tcx, id);\n \n@@ -1023,14 +1018,14 @@ pub fn node_id_type_params(bcx: block, id: ast::node_id) -> ~[ty::t] {\n     }\n }\n \n-pub fn node_vtables(bcx: block, id: ast::node_id)\n+pub fn node_vtables(bcx: @mut Block, id: ast::node_id)\n                  -> Option<typeck::vtable_res> {\n     let raw_vtables = bcx.ccx().maps.vtable_map.find(&id);\n     raw_vtables.map(\n         |&vts| resolve_vtables_in_fn_ctxt(bcx.fcx, *vts))\n }\n \n-pub fn resolve_vtables_in_fn_ctxt(fcx: fn_ctxt, vts: typeck::vtable_res)\n+pub fn resolve_vtables_in_fn_ctxt(fcx: &FunctionContext, vts: typeck::vtable_res)\n     -> typeck::vtable_res {\n     resolve_vtables_under_param_substs(fcx.ccx.tcx,\n                                        fcx.param_substs,\n@@ -1051,9 +1046,9 @@ pub fn resolve_vtables_under_param_substs(tcx: ty::ctxt,\n }\n \n \n-// Apply the typaram substitutions in the fn_ctxt to a vtable. This should\n+// Apply the typaram substitutions in the FunctionContext to a vtable. This should\n // eliminate any vtable_params.\n-pub fn resolve_vtable_in_fn_ctxt(fcx: fn_ctxt, vt: &typeck::vtable_origin)\n+pub fn resolve_vtable_in_fn_ctxt(fcx: &FunctionContext, vt: &typeck::vtable_origin)\n     -> typeck::vtable_origin {\n     resolve_vtable_under_param_substs(fcx.ccx.tcx,\n                                       fcx.param_substs,\n@@ -1125,7 +1120,7 @@ pub fn dummy_substs(tps: ~[ty::t]) -> ty::substs {\n     }\n }\n \n-pub fn filename_and_line_num_from_span(bcx: block,\n+pub fn filename_and_line_num_from_span(bcx: @mut Block,\n                                        span: span) -> (ValueRef, ValueRef) {\n     let loc = bcx.sess().parse_sess.cm.lookup_char_pos(span.lo);\n     let filename_cstr = C_cstr(bcx.ccx(), loc.file.name);\n@@ -1135,11 +1130,11 @@ pub fn filename_and_line_num_from_span(bcx: block,\n }\n \n // Casts a Rust bool value to an i1.\n-pub fn bool_to_i1(bcx: block, llval: ValueRef) -> ValueRef {\n+pub fn bool_to_i1(bcx: @mut Block, llval: ValueRef) -> ValueRef {\n     build::ICmp(bcx, lib::llvm::IntNE, llval, C_bool(false))\n }\n \n-pub fn langcall(bcx: block, span: Option<span>, msg: &str,\n+pub fn langcall(bcx: @mut Block, span: Option<span>, msg: &str,\n                 li: LangItem) -> ast::def_id {\n     match bcx.tcx().lang_items.require(li) {\n         Ok(id) => id,"}, {"sha": "9c66beaa8601bc3bdce36857a91043b47fc555ef", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/3315edfae7854d1f9f58840bbec4d43392c3fa51/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3315edfae7854d1f9f58840bbec4d43392c3fa51/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=3315edfae7854d1f9f58840bbec4d43392c3fa51", "patch": "@@ -34,7 +34,7 @@ use syntax::ast_map::path_mod;\n use syntax::ast_util;\n use syntax::codemap::span;\n \n-pub fn trans_block(bcx: block, b: &ast::Block, dest: expr::Dest) -> block {\n+pub fn trans_block(bcx: @mut Block, b: &ast::Block, dest: expr::Dest) -> @mut Block {\n     let _icx = push_ctxt(\"trans_block\");\n     let mut bcx = bcx;\n     for b.stmts.iter().advance |s| {\n@@ -53,12 +53,12 @@ pub fn trans_block(bcx: block, b: &ast::Block, dest: expr::Dest) -> block {\n     return bcx;\n }\n \n-pub fn trans_if(bcx: block,\n+pub fn trans_if(bcx: @mut Block,\n             cond: @ast::expr,\n             thn: &ast::Block,\n             els: Option<@ast::expr>,\n             dest: expr::Dest)\n-         -> block {\n+         -> @mut Block {\n     debug!(\"trans_if(bcx=%s, cond=%s, thn=%?, dest=%s)\",\n            bcx.to_str(), bcx.expr_to_str(cond), thn.id,\n            dest.to_str(bcx.ccx()));\n@@ -132,8 +132,8 @@ pub fn trans_if(bcx: block,\n     return next_bcx;\n \n     // trans `else [ if { .. } ... | { .. } ]`\n-    fn trans_if_else(bcx: block, elexpr: @ast::expr,\n-                     dest: expr::Dest, scope_name: &str) -> (block, block) {\n+    fn trans_if_else(bcx: @mut Block, elexpr: @ast::expr,\n+                     dest: expr::Dest, scope_name: &str) -> (@mut Block, @mut Block) {\n         let else_bcx_in = scope_block(bcx, elexpr.info(), scope_name);\n         let else_bcx_out = match elexpr.node {\n             ast::expr_if(_, _, _) => {\n@@ -152,7 +152,7 @@ pub fn trans_if(bcx: block,\n     }\n }\n \n-pub fn join_blocks(parent_bcx: block, in_cxs: &[block]) -> block {\n+pub fn join_blocks(parent_bcx: @mut Block, in_cxs: &[@mut Block]) -> @mut Block {\n     let out = sub_block(parent_bcx, \"join\");\n     let mut reachable = false;\n     for in_cxs.iter().advance |bcx| {\n@@ -167,7 +167,7 @@ pub fn join_blocks(parent_bcx: block, in_cxs: &[block]) -> block {\n     return out;\n }\n \n-pub fn trans_while(bcx: block, cond: @ast::expr, body: &ast::Block) -> block {\n+pub fn trans_while(bcx: @mut Block, cond: @ast::expr, body: &ast::Block) -> @mut Block {\n     let _icx = push_ctxt(\"trans_while\");\n     let next_bcx = sub_block(bcx, \"while next\");\n \n@@ -206,10 +206,10 @@ pub fn trans_while(bcx: block, cond: @ast::expr, body: &ast::Block) -> block {\n     return next_bcx;\n }\n \n-pub fn trans_loop(bcx:block,\n+pub fn trans_loop(bcx:@mut Block,\n                   body: &ast::Block,\n                   opt_label: Option<ident>)\n-               -> block {\n+               -> @mut Block {\n     let _icx = push_ctxt(\"trans_loop\");\n     let next_bcx = sub_block(bcx, \"next\");\n     let body_bcx_in = loop_scope_block(bcx, next_bcx, opt_label, \"`loop`\",\n@@ -222,8 +222,8 @@ pub fn trans_loop(bcx:block,\n \n pub fn trans_log(log_ex: &ast::expr,\n                  lvl: @ast::expr,\n-                 bcx: block,\n-                 e: @ast::expr) -> block {\n+                 bcx: @mut Block,\n+                 e: @ast::expr) -> @mut Block {\n     let _icx = push_ctxt(\"trans_log\");\n     let ccx = bcx.ccx();\n     let mut bcx = bcx;\n@@ -286,18 +286,18 @@ pub fn trans_log(log_ex: &ast::expr,\n     }\n }\n \n-pub fn trans_break_cont(bcx: block,\n+pub fn trans_break_cont(bcx: @mut Block,\n                         opt_label: Option<ident>,\n                         to_end: bool)\n-                     -> block {\n+                     -> @mut Block {\n     let _icx = push_ctxt(\"trans_break_cont\");\n     // Locate closest loop block, outputting cleanup as we go.\n     let mut unwind = bcx;\n     let mut cur_scope = unwind.scope;\n     let mut target;\n     loop {\n         cur_scope = match cur_scope {\n-            Some(@scope_info {\n+            Some(@ScopeInfo {\n                 loop_break: Some(brk),\n                 loop_label: l,\n                 parent,\n@@ -340,15 +340,15 @@ pub fn trans_break_cont(bcx: block,\n     return bcx;\n }\n \n-pub fn trans_break(bcx: block, label_opt: Option<ident>) -> block {\n+pub fn trans_break(bcx: @mut Block, label_opt: Option<ident>) -> @mut Block {\n     return trans_break_cont(bcx, label_opt, true);\n }\n \n-pub fn trans_cont(bcx: block, label_opt: Option<ident>) -> block {\n+pub fn trans_cont(bcx: @mut Block, label_opt: Option<ident>) -> @mut Block {\n     return trans_break_cont(bcx, label_opt, false);\n }\n \n-pub fn trans_ret(bcx: block, e: Option<@ast::expr>) -> block {\n+pub fn trans_ret(bcx: @mut Block, e: Option<@ast::expr>) -> @mut Block {\n     let _icx = push_ctxt(\"trans_ret\");\n     let mut bcx = bcx;\n     let dest = match bcx.fcx.loop_ret {\n@@ -380,10 +380,10 @@ pub fn trans_ret(bcx: block, e: Option<@ast::expr>) -> block {\n     return bcx;\n }\n \n-pub fn trans_fail_expr(bcx: block,\n+pub fn trans_fail_expr(bcx: @mut Block,\n                        sp_opt: Option<span>,\n                        fail_expr: Option<@ast::expr>)\n-                    -> block {\n+                    -> @mut Block {\n     let _icx = push_ctxt(\"trans_fail_expr\");\n     let mut bcx = bcx;\n     match fail_expr {\n@@ -408,19 +408,19 @@ pub fn trans_fail_expr(bcx: block,\n     }\n }\n \n-pub fn trans_fail(bcx: block,\n+pub fn trans_fail(bcx: @mut Block,\n                   sp_opt: Option<span>,\n                   fail_str: @str)\n-               -> block {\n+               -> @mut Block {\n     let _icx = push_ctxt(\"trans_fail\");\n     let V_fail_str = C_cstr(bcx.ccx(), fail_str);\n     return trans_fail_value(bcx, sp_opt, V_fail_str);\n }\n \n-fn trans_fail_value(bcx: block,\n+fn trans_fail_value(bcx: @mut Block,\n                     sp_opt: Option<span>,\n                     V_fail_str: ValueRef)\n-                 -> block {\n+                 -> @mut Block {\n     let _icx = push_ctxt(\"trans_fail_value\");\n     let ccx = bcx.ccx();\n     let (V_filename, V_line) = match sp_opt {\n@@ -443,8 +443,8 @@ fn trans_fail_value(bcx: block,\n     return bcx;\n }\n \n-pub fn trans_fail_bounds_check(bcx: block, sp: span,\n-                               index: ValueRef, len: ValueRef) -> block {\n+pub fn trans_fail_bounds_check(bcx: @mut Block, sp: span,\n+                               index: ValueRef, len: ValueRef) -> @mut Block {\n     let _icx = push_ctxt(\"trans_fail_bounds_check\");\n     let (filename, line) = filename_and_line_num_from_span(bcx, sp);\n     let args = ~[filename, line, index, len];"}, {"sha": "f929d4f68ae4f83603e5f4b7670b38402abdcaa7", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/3315edfae7854d1f9f58840bbec4d43392c3fa51/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3315edfae7854d1f9f58840bbec4d43392c3fa51/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=3315edfae7854d1f9f58840bbec4d43392c3fa51", "patch": "@@ -128,7 +128,7 @@ pub struct Datum {\n }\n \n pub struct DatumBlock {\n-    bcx: block,\n+    bcx: @mut Block,\n     datum: Datum,\n }\n \n@@ -165,14 +165,14 @@ pub fn immediate_rvalue(val: ValueRef, ty: ty::t) -> Datum {\n     return Datum {val: val, ty: ty, mode: ByValue};\n }\n \n-pub fn immediate_rvalue_bcx(bcx: block,\n+pub fn immediate_rvalue_bcx(bcx: @mut Block,\n                             val: ValueRef,\n                             ty: ty::t)\n                          -> DatumBlock {\n     return DatumBlock {bcx: bcx, datum: immediate_rvalue(val, ty)};\n }\n \n-pub fn scratch_datum(bcx: block, ty: ty::t, name: &str, zero: bool) -> Datum {\n+pub fn scratch_datum(bcx: @mut Block, ty: ty::t, name: &str, zero: bool) -> Datum {\n     /*!\n      * Allocates temporary space on the stack using alloca() and\n      * returns a by-ref Datum pointing to it.  If `zero` is true, the\n@@ -206,10 +206,10 @@ pub fn appropriate_mode(tcx: ty::ctxt, ty: ty::t) -> DatumMode {\n \n impl Datum {\n     pub fn store_to(&self,\n-                    bcx: block,\n+                    bcx: @mut Block,\n                     action: CopyAction,\n                     dst: ValueRef)\n-                    -> block {\n+                    -> @mut Block {\n         /*!\n          *\n          * Stores this value into its final home.  This moves if\n@@ -224,9 +224,9 @@ impl Datum {\n     }\n \n     pub fn store_to_dest(&self,\n-                         bcx: block,\n+                         bcx: @mut Block,\n                          dest: expr::Dest)\n-                         -> block {\n+                         -> @mut Block {\n         match dest {\n             expr::Ignore => {\n                 return bcx;\n@@ -238,30 +238,30 @@ impl Datum {\n     }\n \n     pub fn store_to_datum(&self,\n-                          bcx: block,\n+                          bcx: @mut Block,\n                           action: CopyAction,\n                           datum: Datum)\n-                          -> block {\n+                          -> @mut Block {\n         debug!(\"store_to_datum(self=%s, action=%?, datum=%s)\",\n                self.to_str(bcx.ccx()), action, datum.to_str(bcx.ccx()));\n         assert!(datum.mode.is_by_ref());\n         self.store_to(bcx, action, datum.val)\n     }\n \n-    pub fn move_to_datum(&self, bcx: block, action: CopyAction, datum: Datum)\n-                         -> block {\n+    pub fn move_to_datum(&self, bcx: @mut Block, action: CopyAction, datum: Datum)\n+                         -> @mut Block {\n         assert!(datum.mode.is_by_ref());\n         self.move_to(bcx, action, datum.val)\n     }\n \n-    pub fn copy_to_datum(&self, bcx: block, action: CopyAction, datum: Datum)\n-                         -> block {\n+    pub fn copy_to_datum(&self, bcx: @mut Block, action: CopyAction, datum: Datum)\n+                         -> @mut Block {\n         assert!(datum.mode.is_by_ref());\n         self.copy_to(bcx, action, datum.val)\n     }\n \n-    pub fn copy_to(&self, bcx: block, action: CopyAction, dst: ValueRef)\n-                   -> block {\n+    pub fn copy_to(&self, bcx: @mut Block, action: CopyAction, dst: ValueRef)\n+                   -> @mut Block {\n         /*!\n          *\n          * Copies the value into `dst`, which should be a pointer to a\n@@ -304,10 +304,10 @@ impl Datum {\n     }\n \n     pub fn copy_to_no_check(&self,\n-                            bcx: block,\n+                            bcx: @mut Block,\n                             action: CopyAction,\n                             dst: ValueRef)\n-                            -> block {\n+                            -> @mut Block {\n         /*!\n          *\n          * A helper for `copy_to()` which does not check to see if we\n@@ -335,8 +335,8 @@ impl Datum {\n     // This works like copy_val, except that it deinitializes the source.\n     // Since it needs to zero out the source, src also needs to be an lval.\n     //\n-    pub fn move_to(&self, bcx: block, action: CopyAction, dst: ValueRef)\n-                   -> block {\n+    pub fn move_to(&self, bcx: @mut Block, action: CopyAction, dst: ValueRef)\n+                   -> @mut Block {\n         let _icx = push_ctxt(\"move_to\");\n         let mut bcx = bcx;\n \n@@ -365,7 +365,7 @@ impl Datum {\n         return bcx;\n     }\n \n-    pub fn add_clean(&self, bcx: block) {\n+    pub fn add_clean(&self, bcx: @mut Block) {\n         /*!\n          * Schedules this datum for cleanup in `bcx`.  The datum\n          * must be an rvalue.\n@@ -385,7 +385,7 @@ impl Datum {\n         }\n     }\n \n-    pub fn cancel_clean(&self, bcx: block) {\n+    pub fn cancel_clean(&self, bcx: @mut Block) {\n         if ty::type_needs_drop(bcx.tcx(), self.ty) {\n             match self.mode {\n                 ByValue |\n@@ -410,7 +410,7 @@ impl Datum {\n              self.mode)\n     }\n \n-    pub fn to_value_datum(&self, bcx: block) -> Datum {\n+    pub fn to_value_datum(&self, bcx: @mut Block) -> Datum {\n         /*!\n          *\n          * Yields a by-value form of this datum.  This may involve\n@@ -427,7 +427,7 @@ impl Datum {\n         }\n     }\n \n-    pub fn to_value_llval(&self, bcx: block) -> ValueRef {\n+    pub fn to_value_llval(&self, bcx: @mut Block) -> ValueRef {\n         /*!\n          *\n          * Yields the value itself. */\n@@ -448,7 +448,7 @@ impl Datum {\n         }\n     }\n \n-    pub fn to_ref_datum(&self, bcx: block) -> Datum {\n+    pub fn to_ref_datum(&self, bcx: @mut Block) -> Datum {\n         /*!\n          * Yields a by-ref form of this datum.  This may involve\n          * creation of a temporary stack slot.  The value returned by\n@@ -465,7 +465,7 @@ impl Datum {\n         }\n     }\n \n-    pub fn to_ref_llval(&self, bcx: block) -> ValueRef {\n+    pub fn to_ref_llval(&self, bcx: @mut Block) -> ValueRef {\n         match self.mode {\n             ByRef(_) => self.val,\n             ByValue => {\n@@ -480,7 +480,7 @@ impl Datum {\n         }\n     }\n \n-    pub fn to_zeroable_ref_llval(&self, bcx: block) -> ValueRef {\n+    pub fn to_zeroable_ref_llval(&self, bcx: @mut Block) -> ValueRef {\n         /*!\n          * Returns a by-ref llvalue that can be zeroed in order to\n          * cancel cleanup. This is a kind of hokey bridge used\n@@ -511,7 +511,7 @@ impl Datum {\n         appropriate_mode(tcx, self.ty)\n     }\n \n-    pub fn to_appropriate_llval(&self, bcx: block) -> ValueRef {\n+    pub fn to_appropriate_llval(&self, bcx: @mut Block) -> ValueRef {\n         /*!\n          *\n          * Yields an llvalue with the `appropriate_mode()`. */\n@@ -522,7 +522,7 @@ impl Datum {\n         }\n     }\n \n-    pub fn to_appropriate_datum(&self, bcx: block) -> Datum {\n+    pub fn to_appropriate_datum(&self, bcx: @mut Block) -> Datum {\n         /*!\n          *\n          * Yields a datum with the `appropriate_mode()`. */\n@@ -534,7 +534,7 @@ impl Datum {\n     }\n \n     pub fn get_element(&self,\n-                       bcx: block,\n+                       bcx: @mut Block,\n                        ty: ty::t,\n                        source: DatumCleanup,\n                        gep: &fn(ValueRef) -> ValueRef)\n@@ -547,7 +547,7 @@ impl Datum {\n         }\n     }\n \n-    pub fn drop_val(&self, bcx: block) -> block {\n+    pub fn drop_val(&self, bcx: @mut Block) -> @mut Block {\n         if !ty::type_needs_drop(bcx.tcx(), self.ty) {\n             return bcx;\n         }\n@@ -558,7 +558,7 @@ impl Datum {\n         };\n     }\n \n-    pub fn box_body(&self, bcx: block) -> Datum {\n+    pub fn box_body(&self, bcx: @mut Block) -> Datum {\n         /*!\n          *\n          * This datum must represent an @T or ~T box.  Returns a new\n@@ -591,7 +591,7 @@ impl Datum {\n         }\n     }\n \n-    pub fn to_rptr(&self, bcx: block) -> Datum {\n+    pub fn to_rptr(&self, bcx: @mut Block) -> Datum {\n         //! Returns a new datum of region-pointer type containing the\n         //! the same ptr as this datum (after converting to by-ref\n         //! using `to_ref_llval()`).\n@@ -612,12 +612,12 @@ impl Datum {\n     /// derefs: Number of times deref'd already.\n     /// is_auto: If true, only deref if auto-derefable.\n     pub fn try_deref(&self,\n-                     bcx: block,\n+                     bcx: @mut Block,\n                      span: span,\n                      expr_id: ast::node_id,\n                      derefs: uint,\n                      is_auto: bool)\n-                     -> (Option<Datum>, block) {\n+                     -> (Option<Datum>, @mut Block) {\n         let ccx = bcx.ccx();\n \n         debug!(\"try_deref(expr_id=%?, derefs=%?, is_auto=%b, self=%?)\",\n@@ -716,7 +716,7 @@ impl Datum {\n             }\n         }\n \n-        fn deref_ptr(bcx: block, lv: &Datum, ty: ty::t) -> Datum {\n+        fn deref_ptr(bcx: @mut Block, lv: &Datum, ty: ty::t) -> Datum {\n             Datum {\n                 val: lv.to_value_llval(bcx),\n                 ty: ty,\n@@ -726,7 +726,7 @@ impl Datum {\n     }\n \n     /// expr: The deref expression.\n-    pub fn deref(&self, bcx: block, expr: &ast::expr, derefs: uint)\n+    pub fn deref(&self, bcx: @mut Block, expr: &ast::expr, derefs: uint)\n                  -> DatumBlock {\n         match self.try_deref(bcx, expr.span, expr.id, derefs, false) {\n             (Some(lvres), bcx) => DatumBlock { bcx: bcx, datum: lvres },\n@@ -738,7 +738,7 @@ impl Datum {\n     }\n \n     pub fn autoderef(&self,\n-                     bcx: block,\n+                     bcx: @mut Block,\n                      span: span,\n                      expr_id: ast::node_id,\n                      max: uint)\n@@ -771,11 +771,11 @@ impl Datum {\n     }\n \n     pub fn get_vec_base_and_len(&self,\n-                                mut bcx: block,\n+                                mut bcx: @mut Block,\n                                 span: span,\n                                 expr_id: ast::node_id,\n                                 derefs: uint)\n-                                -> (block, ValueRef, ValueRef) {\n+                                -> (@mut Block, ValueRef, ValueRef) {\n         //! Converts a vector into the slice pair. Performs rooting\n         //! and write guards checks.\n \n@@ -785,7 +785,7 @@ impl Datum {\n         (bcx, base, len)\n     }\n \n-    pub fn get_vec_base_and_len_no_root(&self, bcx: block)\n+    pub fn get_vec_base_and_len_no_root(&self, bcx: @mut Block)\n                                         -> (ValueRef, ValueRef) {\n         //! Converts a vector into the slice pair. Des not root\n         //! nor perform write guard checks.\n@@ -795,21 +795,21 @@ impl Datum {\n     }\n \n     pub fn root_and_write_guard(&self,\n-                                bcx: block,\n+                                bcx: @mut Block,\n                                 span: span,\n                                 expr_id: ast::node_id,\n                                 derefs: uint)\n-                                -> block {\n+                                -> @mut Block {\n         write_guard::root_and_write_guard(self, bcx, span, expr_id, derefs)\n     }\n \n-    pub fn to_result(&self, bcx: block) -> common::Result {\n+    pub fn to_result(&self, bcx: @mut Block) -> common::Result {\n         rslt(bcx, self.to_appropriate_llval(bcx))\n     }\n }\n \n impl DatumBlock {\n-    pub fn unpack(&self, bcx: &mut block) -> Datum {\n+    pub fn unpack(&self, bcx: &mut @mut Block) -> Datum {\n         *bcx = self.bcx;\n         return self.datum;\n     }\n@@ -819,22 +819,22 @@ impl DatumBlock {\n         *self\n     }\n \n-    pub fn drop_val(&self) -> block {\n+    pub fn drop_val(&self) -> @mut Block {\n         self.datum.drop_val(self.bcx)\n     }\n \n     pub fn store_to(&self,\n                     action: CopyAction,\n                     dst: ValueRef)\n-                    -> block {\n+                    -> @mut Block {\n         self.datum.store_to(self.bcx, action, dst)\n     }\n \n-    pub fn copy_to(&self, action: CopyAction, dst: ValueRef) -> block {\n+    pub fn copy_to(&self, action: CopyAction, dst: ValueRef) -> @mut Block {\n         self.datum.copy_to(self.bcx, action, dst)\n     }\n \n-    pub fn move_to(&self, action: CopyAction, dst: ValueRef) -> block {\n+    pub fn move_to(&self, action: CopyAction, dst: ValueRef) -> @mut Block {\n         self.datum.move_to(self.bcx, action, dst)\n     }\n "}, {"sha": "11d21abb2e6d0c19b2b04c8122e5d43cee0bf124", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3315edfae7854d1f9f58840bbec4d43392c3fa51/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3315edfae7854d1f9f58840bbec4d43392c3fa51/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=3315edfae7854d1f9f58840bbec4d43392c3fa51", "patch": "@@ -134,7 +134,7 @@ pub fn finalize(cx: @mut CrateContext) {\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n /// The return value should be ignored if called from outside of the debuginfo module.\n-pub fn create_local_var_metadata(bcx: block, local: @ast::Local) -> DIVariable {\n+pub fn create_local_var_metadata(bcx: @mut Block, local: @ast::Local) -> DIVariable {\n     let cx = bcx.ccx();\n \n     let ident = match local.pat.node {\n@@ -198,7 +198,7 @@ pub fn create_local_var_metadata(bcx: block, local: @ast::Local) -> DIVariable {\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n /// The return value should be ignored if called from outside of the debuginfo module.\n-pub fn create_argument_metadata(bcx: block, arg: &ast::arg, span: span) -> Option<DIVariable> {\n+pub fn create_argument_metadata(bcx: @mut Block, arg: &ast::arg, span: span) -> Option<DIVariable> {\n     debug!(\"create_argument_metadata\");\n     if true {\n         // XXX create_argument_metadata disabled for now because \"node_id_type(bcx, arg.id)\" below\n@@ -260,7 +260,7 @@ pub fn create_argument_metadata(bcx: block, arg: &ast::arg, span: span) -> Optio\n /// Sets the current debug location at the beginning of the span\n ///\n /// Maps to a call to llvm::LLVMSetCurrentDebugLocation(...)\n-pub fn update_source_pos(bcx: block, span: span) {\n+pub fn update_source_pos(bcx: @mut Block, span: span) {\n     if !bcx.sess().opts.debuginfo || (*span.lo == 0 && *span.hi == 0) {\n         return;\n     }\n@@ -273,9 +273,8 @@ pub fn update_source_pos(bcx: block, span: span) {\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n /// The return value should be ignored if called from outside of the debuginfo module.\n-pub fn create_function_metadata(fcx: fn_ctxt) -> DISubprogram {\n+pub fn create_function_metadata(fcx: &FunctionContext) -> DISubprogram {\n     let cx = fcx.ccx;\n-    let fcx = &mut *fcx;\n     let span = fcx.span.get();\n \n     let fnitem = cx.tcx.items.get_copy(&fcx.id);\n@@ -445,7 +444,7 @@ fn file_metadata(cx: &mut CrateContext, full_path: &str) -> DIFile {\n }\n \n /// Get or create the lexical block metadata node for the given LLVM basic block.\n-fn lexical_block_metadata(bcx: block) -> DILexicalBlock {\n+fn lexical_block_metadata(bcx: @mut Block) -> DILexicalBlock {\n     let cx = bcx.ccx();\n     let mut bcx = bcx;\n "}, {"sha": "f552eded1638af4ab442ac36e4076307137e690d", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/3315edfae7854d1f9f58840bbec4d43392c3fa51/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3315edfae7854d1f9f58840bbec4d43392c3fa51/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=3315edfae7854d1f9f58840bbec4d43392c3fa51", "patch": "@@ -175,13 +175,13 @@ impl Dest {\n     }\n }\n \n-fn drop_and_cancel_clean(bcx: block, dat: Datum) -> block {\n+fn drop_and_cancel_clean(bcx: @mut Block, dat: Datum) -> @mut Block {\n     let bcx = dat.drop_val(bcx);\n     dat.cancel_clean(bcx);\n     return bcx;\n }\n \n-pub fn trans_to_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n+pub fn trans_to_datum(bcx: @mut Block, expr: @ast::expr) -> DatumBlock {\n     debug!(\"trans_to_datum(expr=%s)\", bcx.expr_to_str(expr));\n \n     let mut bcx = bcx;\n@@ -231,11 +231,11 @@ pub fn trans_to_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n     debug!(\"after adjustments, datum=%s\", datum.to_str(bcx.ccx()));\n     return DatumBlock {bcx: bcx, datum: datum};\n \n-    fn auto_ref(bcx: block, datum: Datum) -> DatumBlock {\n+    fn auto_ref(bcx: @mut Block, datum: Datum) -> DatumBlock {\n         DatumBlock {bcx: bcx, datum: datum.to_rptr(bcx)}\n     }\n \n-    fn auto_borrow_fn(bcx: block,\n+    fn auto_borrow_fn(bcx: @mut Block,\n                       adjusted_ty: ty::t,\n                       datum: Datum) -> DatumBlock {\n         // Currently, all closure types are represented precisely the\n@@ -246,7 +246,7 @@ pub fn trans_to_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n                                   mode: datum.mode}}\n     }\n \n-    fn auto_slice(bcx: block,\n+    fn auto_slice(bcx: @mut Block,\n                   autoderefs: uint,\n                   expr: &ast::expr,\n                   datum: Datum) -> DatumBlock {\n@@ -274,7 +274,7 @@ pub fn trans_to_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n         DatumBlock {bcx: bcx, datum: scratch}\n     }\n \n-    fn add_env(bcx: block, expr: &ast::expr, datum: Datum) -> DatumBlock {\n+    fn add_env(bcx: @mut Block, expr: &ast::expr, datum: Datum) -> DatumBlock {\n         // This is not the most efficient thing possible; since closures\n         // are two words it'd be better if this were compiled in\n         // 'dest' mode, but I can't find a nice way to structure the\n@@ -293,7 +293,7 @@ pub fn trans_to_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n         DatumBlock {bcx: bcx, datum: scratch}\n     }\n \n-    fn auto_slice_and_ref(bcx: block,\n+    fn auto_slice_and_ref(bcx: @mut Block,\n                           autoderefs: uint,\n                           expr: &ast::expr,\n                           datum: Datum) -> DatumBlock {\n@@ -302,7 +302,7 @@ pub fn trans_to_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n     }\n }\n \n-pub fn trans_into(bcx: block, expr: @ast::expr, dest: Dest) -> block {\n+pub fn trans_into(bcx: @mut Block, expr: @ast::expr, dest: Dest) -> @mut Block {\n     if bcx.tcx().adjustments.contains_key(&expr.id) {\n         // use trans_to_datum, which is mildly less efficient but\n         // which will perform the adjustments:\n@@ -360,7 +360,7 @@ pub fn trans_into(bcx: block, expr: @ast::expr, dest: Dest) -> block {\n     };\n }\n \n-fn trans_lvalue(bcx: block, expr: @ast::expr) -> DatumBlock {\n+fn trans_lvalue(bcx: @mut Block, expr: @ast::expr) -> DatumBlock {\n     /*!\n      *\n      * Translates an lvalue expression, always yielding a by-ref\n@@ -379,7 +379,7 @@ fn trans_lvalue(bcx: block, expr: @ast::expr) -> DatumBlock {\n     };\n }\n \n-fn trans_to_datum_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n+fn trans_to_datum_unadjusted(bcx: @mut Block, expr: @ast::expr) -> DatumBlock {\n     /*!\n      * Translates an expression into a datum.  If this expression\n      * is an rvalue, this will result in a temporary value being\n@@ -439,13 +439,13 @@ fn trans_to_datum_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n         }\n     }\n \n-    fn nil(bcx: block, ty: ty::t) -> DatumBlock {\n+    fn nil(bcx: @mut Block, ty: ty::t) -> DatumBlock {\n         let datum = immediate_rvalue(C_nil(), ty);\n         DatumBlock {bcx: bcx, datum: datum}\n     }\n }\n \n-fn trans_rvalue_datum_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n+fn trans_rvalue_datum_unadjusted(bcx: @mut Block, expr: @ast::expr) -> DatumBlock {\n     let _icx = push_ctxt(\"trans_rvalue_datum_unadjusted\");\n \n     trace_span!(bcx, expr.span, shorten(bcx.expr_to_str(expr)));\n@@ -495,7 +495,7 @@ fn trans_rvalue_datum_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n     }\n }\n \n-fn trans_rvalue_stmt_unadjusted(bcx: block, expr: @ast::expr) -> block {\n+fn trans_rvalue_stmt_unadjusted(bcx: @mut Block, expr: @ast::expr) -> @mut Block {\n     let mut bcx = bcx;\n     let _icx = push_ctxt(\"trans_rvalue_stmt\");\n \n@@ -551,8 +551,8 @@ fn trans_rvalue_stmt_unadjusted(bcx: block, expr: @ast::expr) -> block {\n     };\n }\n \n-fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n-                               dest: Dest) -> block {\n+fn trans_rvalue_dps_unadjusted(bcx: @mut Block, expr: @ast::expr,\n+                               dest: Dest) -> @mut Block {\n     let _icx = push_ctxt(\"trans_rvalue_dps_unadjusted\");\n     let tcx = bcx.tcx();\n \n@@ -697,8 +697,8 @@ fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n     }\n }\n \n-fn trans_def_dps_unadjusted(bcx: block, ref_expr: &ast::expr,\n-                            def: ast::def, dest: Dest) -> block {\n+fn trans_def_dps_unadjusted(bcx: @mut Block, ref_expr: &ast::expr,\n+                            def: ast::def, dest: Dest) -> @mut Block {\n     let _icx = push_ctxt(\"trans_def_dps_unadjusted\");\n     let ccx = bcx.ccx();\n \n@@ -743,7 +743,7 @@ fn trans_def_dps_unadjusted(bcx: block, ref_expr: &ast::expr,\n     }\n }\n \n-fn trans_def_datum_unadjusted(bcx: block,\n+fn trans_def_datum_unadjusted(bcx: @mut Block,\n                               ref_expr: &ast::expr,\n                               def: ast::def) -> DatumBlock\n {\n@@ -767,7 +767,7 @@ fn trans_def_datum_unadjusted(bcx: block,\n         }\n     }\n \n-    fn fn_data_to_datum(bcx: block,\n+    fn fn_data_to_datum(bcx: @mut Block,\n                         ref_expr: &ast::expr,\n                         def_id: ast::def_id,\n                         fn_data: callee::FnData) -> DatumBlock {\n@@ -802,7 +802,7 @@ fn trans_def_datum_unadjusted(bcx: block,\n     }\n }\n \n-fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n+fn trans_lvalue_unadjusted(bcx: @mut Block, expr: @ast::expr) -> DatumBlock {\n     /*!\n      *\n      * Translates an lvalue expression, always yielding a by-ref\n@@ -841,7 +841,7 @@ fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n         }\n     };\n \n-    fn trans_rec_field(bcx: block,\n+    fn trans_rec_field(bcx: @mut Block,\n                        base: @ast::expr,\n                        field: ast::ident) -> DatumBlock {\n         //! Translates `base.field`.\n@@ -864,7 +864,7 @@ fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n         }\n     }\n \n-    fn trans_index(bcx: block,\n+    fn trans_index(bcx: @mut Block,\n                    index_expr: &ast::expr,\n                    base: @ast::expr,\n                    idx: @ast::expr) -> DatumBlock {\n@@ -928,7 +928,7 @@ fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n         };\n     }\n \n-    fn trans_def_lvalue(bcx: block,\n+    fn trans_def_lvalue(bcx: @mut Block,\n                         ref_expr: &ast::expr,\n                         def: ast::def)\n         -> DatumBlock\n@@ -950,7 +950,7 @@ fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n                     }\n                 }\n \n-                fn get_val(bcx: block, did: ast::def_id, const_ty: ty::t)\n+                fn get_val(bcx: @mut Block, did: ast::def_id, const_ty: ty::t)\n                            -> ValueRef {\n                     // For external constants, we don't inline.\n                     if did.crate == ast::local_crate {\n@@ -1004,7 +1004,7 @@ fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n     }\n }\n \n-pub fn trans_local_var(bcx: block, def: ast::def) -> Datum {\n+pub fn trans_local_var(bcx: @mut Block, def: ast::def) -> Datum {\n     let _icx = push_ctxt(\"trans_local_var\");\n \n     return match def {\n@@ -1056,7 +1056,7 @@ pub fn trans_local_var(bcx: block, def: ast::def) -> Datum {\n         }\n     };\n \n-    fn take_local(bcx: block,\n+    fn take_local(bcx: @mut Block,\n                   table: &HashMap<ast::node_id, ValueRef>,\n                   nid: ast::node_id) -> Datum {\n         let v = match table.find(&nid) {\n@@ -1123,12 +1123,12 @@ pub fn with_field_tys<R>(tcx: ty::ctxt,\n     }\n }\n \n-fn trans_rec_or_struct(bcx: block,\n+fn trans_rec_or_struct(bcx: @mut Block,\n                        fields: &[ast::Field],\n                        base: Option<@ast::expr>,\n                        expr_span: codemap::span,\n                        id: ast::node_id,\n-                       dest: Dest) -> block\n+                       dest: Dest) -> @mut Block\n {\n     let _icx = push_ctxt(\"trans_rec\");\n     let bcx = bcx;\n@@ -1200,10 +1200,10 @@ struct StructBaseInfo {\n  * - `optbase` contains information on the base struct (if any) from\n  * which remaining fields are copied; see comments on `StructBaseInfo`.\n  */\n-fn trans_adt(bcx: block, repr: &adt::Repr, discr: int,\n+fn trans_adt(bcx: @mut Block, repr: &adt::Repr, discr: int,\n              fields: &[(uint, @ast::expr)],\n              optbase: Option<StructBaseInfo>,\n-             dest: Dest) -> block {\n+             dest: Dest) -> @mut Block {\n     let _icx = push_ctxt(\"trans_adt\");\n     let mut bcx = bcx;\n     let addr = match dest {\n@@ -1248,15 +1248,15 @@ fn trans_adt(bcx: block, repr: &adt::Repr, discr: int,\n }\n \n \n-fn trans_immediate_lit(bcx: block, expr: @ast::expr,\n+fn trans_immediate_lit(bcx: @mut Block, expr: @ast::expr,\n                        lit: ast::lit) -> DatumBlock {\n     // must not be a string constant, that is a RvalueDpsExpr\n     let _icx = push_ctxt(\"trans_immediate_lit\");\n     let ty = expr_ty(bcx, expr);\n     immediate_rvalue_bcx(bcx, consts::const_lit(bcx.ccx(), expr, lit), ty)\n }\n \n-fn trans_unary_datum(bcx: block,\n+fn trans_unary_datum(bcx: @mut Block,\n                      un_expr: &ast::expr,\n                      op: ast::unop,\n                      sub_expr: @ast::expr) -> DatumBlock {\n@@ -1316,7 +1316,7 @@ fn trans_unary_datum(bcx: block,\n         }\n     };\n \n-    fn trans_boxed_expr(bcx: block,\n+    fn trans_boxed_expr(bcx: @mut Block,\n                         box_ty: ty::t,\n                         contents: @ast::expr,\n                         contents_ty: ty::t,\n@@ -1342,7 +1342,7 @@ fn trans_unary_datum(bcx: block,\n     }\n }\n \n-fn trans_addr_of(bcx: block, expr: &ast::expr,\n+fn trans_addr_of(bcx: @mut Block, expr: &ast::expr,\n                  subexpr: @ast::expr) -> DatumBlock {\n     let _icx = push_ctxt(\"trans_addr_of\");\n     let mut bcx = bcx;\n@@ -1353,7 +1353,7 @@ fn trans_addr_of(bcx: block, expr: &ast::expr,\n \n // Important to get types for both lhs and rhs, because one might be _|_\n // and the other not.\n-fn trans_eager_binop(bcx: block,\n+fn trans_eager_binop(bcx: @mut Block,\n                      binop_expr: &ast::expr,\n                      binop_ty: ty::t,\n                      op: ast::binop,\n@@ -1456,7 +1456,7 @@ fn trans_eager_binop(bcx: block,\n // refinement types would obviate the need for this\n enum lazy_binop_ty { lazy_and, lazy_or }\n \n-fn trans_lazy_binop(bcx: block,\n+fn trans_lazy_binop(bcx: @mut Block,\n                     binop_expr: &ast::expr,\n                     op: lazy_binop_ty,\n                     a: @ast::expr,\n@@ -1501,7 +1501,7 @@ fn trans_lazy_binop(bcx: block,\n     return immediate_rvalue_bcx(join, phi, binop_ty);\n }\n \n-fn trans_binary(bcx: block,\n+fn trans_binary(bcx: @mut Block,\n                 binop_expr: &ast::expr,\n                 op: ast::binop,\n                 lhs: @ast::expr,\n@@ -1527,14 +1527,14 @@ fn trans_binary(bcx: block,\n     }\n }\n \n-fn trans_overloaded_op(bcx: block,\n+fn trans_overloaded_op(bcx: @mut Block,\n                        expr: &ast::expr,\n                        callee_id: ast::node_id,\n                        rcvr: @ast::expr,\n                        args: ~[@ast::expr],\n                        ret_ty: ty::t,\n                        dest: Dest)\n-                       -> block {\n+                       -> @mut Block {\n     let origin = bcx.ccx().maps.method_map.get_copy(&expr.id);\n     let fty = node_id_type(bcx, callee_id);\n     callee::trans_call_inner(bcx,\n@@ -1552,7 +1552,7 @@ fn trans_overloaded_op(bcx: block,\n                              DoAutorefArg).bcx\n }\n \n-fn int_cast(bcx: block, lldsttype: Type, llsrctype: Type,\n+fn int_cast(bcx: @mut Block, lldsttype: Type, llsrctype: Type,\n             llsrc: ValueRef, signed: bool) -> ValueRef {\n     let _icx = push_ctxt(\"int_cast\");\n     unsafe {\n@@ -1570,7 +1570,7 @@ fn int_cast(bcx: block, lldsttype: Type, llsrctype: Type,\n     }\n }\n \n-fn float_cast(bcx: block, lldsttype: Type, llsrctype: Type,\n+fn float_cast(bcx: @mut Block, lldsttype: Type, llsrctype: Type,\n               llsrc: ValueRef) -> ValueRef {\n     let _icx = push_ctxt(\"float_cast\");\n     let srcsz = llsrctype.float_width();\n@@ -1604,7 +1604,7 @@ pub fn cast_type_kind(t: ty::t) -> cast_kind {\n     }\n }\n \n-fn trans_imm_cast(bcx: block, expr: @ast::expr,\n+fn trans_imm_cast(bcx: @mut Block, expr: @ast::expr,\n                   id: ast::node_id) -> DatumBlock {\n     let _icx = push_ctxt(\"trans_cast\");\n     let ccx = bcx.ccx();\n@@ -1666,12 +1666,12 @@ fn trans_imm_cast(bcx: block, expr: @ast::expr,\n     return immediate_rvalue_bcx(bcx, newval, t_out);\n }\n \n-fn trans_assign_op(bcx: block,\n+fn trans_assign_op(bcx: @mut Block,\n                    expr: @ast::expr,\n                    callee_id: ast::node_id,\n                    op: ast::binop,\n                    dst: @ast::expr,\n-                   src: @ast::expr) -> block\n+                   src: @ast::expr) -> @mut Block\n {\n     let _icx = push_ctxt(\"trans_assign_op\");\n     let mut bcx = bcx;"}, {"sha": "f8131c63378444a57c88c6100de1c991bc4fd1e4", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3315edfae7854d1f9f58840bbec4d43392c3fa51/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3315edfae7854d1f9f58840bbec4d43392c3fa51/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=3315edfae7854d1f9f58840bbec4d43392c3fa51", "patch": "@@ -128,11 +128,11 @@ fn shim_types(ccx: @mut CrateContext, id: ast::node_id) -> ShimTypes {\n }\n \n type shim_arg_builder<'self> =\n-    &'self fn(bcx: block, tys: &ShimTypes,\n+    &'self fn(bcx: @mut Block, tys: &ShimTypes,\n               llargbundle: ValueRef) -> ~[ValueRef];\n \n type shim_ret_builder<'self> =\n-    &'self fn(bcx: block, tys: &ShimTypes,\n+    &'self fn(bcx: @mut Block, tys: &ShimTypes,\n               llargbundle: ValueRef,\n               llretval: ValueRef);\n \n@@ -171,12 +171,12 @@ fn build_shim_fn_(ccx: @mut CrateContext,\n     return llshimfn;\n }\n \n-type wrap_arg_builder<'self> = &'self fn(bcx: block,\n+type wrap_arg_builder<'self> = &'self fn(bcx: @mut Block,\n                                          tys: &ShimTypes,\n                                          llwrapfn: ValueRef,\n                                          llargbundle: ValueRef);\n \n-type wrap_ret_builder<'self> = &'self fn(bcx: block,\n+type wrap_ret_builder<'self> = &'self fn(bcx: @mut Block,\n                                          tys: &ShimTypes,\n                                          llargbundle: ValueRef);\n \n@@ -369,13 +369,13 @@ pub fn trans_foreign_mod(ccx: @mut CrateContext,\n \n         let _icx = push_ctxt(\"foreign::build_shim_fn\");\n \n-        fn build_args(bcx: block, tys: &ShimTypes, llargbundle: ValueRef)\n+        fn build_args(bcx: @mut Block, tys: &ShimTypes, llargbundle: ValueRef)\n                    -> ~[ValueRef] {\n             let _icx = push_ctxt(\"foreign::shim::build_args\");\n             tys.fn_ty.build_shim_args(bcx, tys.llsig.llarg_tys, llargbundle)\n         }\n \n-        fn build_ret(bcx: block,\n+        fn build_ret(bcx: @mut Block,\n                      tys: &ShimTypes,\n                      llargbundle: ValueRef,\n                      llretval: ValueRef) {\n@@ -491,7 +491,7 @@ pub fn trans_foreign_mod(ccx: @mut CrateContext,\n                        build_args,\n                        build_ret);\n \n-        fn build_args(bcx: block,\n+        fn build_args(bcx: @mut Block,\n                       tys: &ShimTypes,\n                       llwrapfn: ValueRef,\n                       llargbundle: ValueRef) {\n@@ -517,7 +517,7 @@ pub fn trans_foreign_mod(ccx: @mut CrateContext,\n             }\n         }\n \n-        fn build_ret(bcx: block,\n+        fn build_ret(bcx: @mut Block,\n                      shim_types: &ShimTypes,\n                      llargbundle: ValueRef) {\n             let _icx = push_ctxt(\"foreign::wrap::build_ret\");\n@@ -539,7 +539,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n                        ref_id: Option<ast::node_id>) {\n     debug!(\"trans_intrinsic(item.ident=%s)\", ccx.sess.str_of(item.ident));\n \n-    fn simple_llvm_intrinsic(bcx: block, name: &'static str, num_args: uint) {\n+    fn simple_llvm_intrinsic(bcx: @mut Block, name: &'static str, num_args: uint) {\n         assert!(num_args <= 4);\n         let mut args = [0 as ValueRef, ..4];\n         let first_real_arg = bcx.fcx.arg_pos(0u);\n@@ -550,7 +550,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n         Ret(bcx, Call(bcx, llfn, args.slice(0, num_args)));\n     }\n \n-    fn memcpy_intrinsic(bcx: block, name: &'static str, tp_ty: ty::t, sizebits: u8) {\n+    fn memcpy_intrinsic(bcx: @mut Block, name: &'static str, tp_ty: ty::t, sizebits: u8) {\n         let ccx = bcx.ccx();\n         let lltp_ty = type_of::type_of(ccx, tp_ty);\n         let align = C_i32(machine::llalign_of_min(ccx, lltp_ty) as i32);\n@@ -571,7 +571,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n         RetVoid(bcx);\n     }\n \n-    fn memset_intrinsic(bcx: block, name: &'static str, tp_ty: ty::t, sizebits: u8) {\n+    fn memset_intrinsic(bcx: @mut Block, name: &'static str, tp_ty: ty::t, sizebits: u8) {\n         let ccx = bcx.ccx();\n         let lltp_ty = type_of::type_of(ccx, tp_ty);\n         let align = C_i32(machine::llalign_of_min(ccx, lltp_ty) as i32);\n@@ -592,7 +592,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n         RetVoid(bcx);\n     }\n \n-    fn count_zeros_intrinsic(bcx: block, name: &'static str) {\n+    fn count_zeros_intrinsic(bcx: @mut Block, name: &'static str) {\n         let x = get_param(bcx.fcx.llfn, bcx.fcx.arg_pos(0u));\n         let y = C_i1(false);\n         let llfn = bcx.ccx().intrinsics.get_copy(&name);\n@@ -1020,7 +1020,7 @@ pub fn trans_foreign_fn(ccx: @mut CrateContext,\n \n         let _icx = push_ctxt(\"foreign::foreign::build_shim_fn\");\n \n-        fn build_args(bcx: block, tys: &ShimTypes, llargbundle: ValueRef)\n+        fn build_args(bcx: @mut Block, tys: &ShimTypes, llargbundle: ValueRef)\n                       -> ~[ValueRef] {\n             let _icx = push_ctxt(\"foreign::extern::shim::build_args\");\n             let ccx = bcx.ccx();\n@@ -1050,7 +1050,7 @@ pub fn trans_foreign_fn(ccx: @mut CrateContext,\n             return llargvals;\n         }\n \n-        fn build_ret(bcx: block,\n+        fn build_ret(bcx: @mut Block,\n                      shim_types: &ShimTypes,\n                      llargbundle: ValueRef,\n                      llretval: ValueRef) {\n@@ -1107,7 +1107,7 @@ pub fn trans_foreign_fn(ccx: @mut CrateContext,\n                        build_args,\n                        build_ret);\n \n-        fn build_args(bcx: block,\n+        fn build_args(bcx: @mut Block,\n                       tys: &ShimTypes,\n                       llwrapfn: ValueRef,\n                       llargbundle: ValueRef) {\n@@ -1118,7 +1118,7 @@ pub fn trans_foreign_fn(ccx: @mut CrateContext,\n                                       llargbundle);\n         }\n \n-        fn build_ret(bcx: block, tys: &ShimTypes, llargbundle: ValueRef) {\n+        fn build_ret(bcx: @mut Block, tys: &ShimTypes, llargbundle: ValueRef) {\n             let _icx = push_ctxt(\"foreign::foreign::wrap::build_ret\");\n             tys.fn_ty.build_wrap_ret(bcx, tys.llsig.llarg_tys, llargbundle);\n         }"}, {"sha": "d554526a6d2370146c720c860be82f0316fca86f", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/3315edfae7854d1f9f58840bbec4d43392c3fa51/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3315edfae7854d1f9f58840bbec4d43392c3fa51/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=3315edfae7854d1f9f58840bbec4d43392c3fa51", "patch": "@@ -42,23 +42,23 @@ use std::libc::c_uint;\n use std::str;\n use syntax::ast;\n \n-pub fn trans_free(cx: block, v: ValueRef) -> block {\n+pub fn trans_free(cx: @mut Block, v: ValueRef) -> @mut Block {\n     let _icx = push_ctxt(\"trans_free\");\n     callee::trans_lang_call(cx,\n         langcall(cx, None, \"\", FreeFnLangItem),\n         [PointerCast(cx, v, Type::i8p())],\n         Some(expr::Ignore)).bcx\n }\n \n-pub fn trans_exchange_free(cx: block, v: ValueRef) -> block {\n+pub fn trans_exchange_free(cx: @mut Block, v: ValueRef) -> @mut Block {\n     let _icx = push_ctxt(\"trans_exchange_free\");\n     callee::trans_lang_call(cx,\n         langcall(cx, None, \"\", ExchangeFreeFnLangItem),\n         [PointerCast(cx, v, Type::i8p())],\n         Some(expr::Ignore)).bcx\n }\n \n-pub fn take_ty(cx: block, v: ValueRef, t: ty::t) -> block {\n+pub fn take_ty(cx: @mut Block, v: ValueRef, t: ty::t) -> @mut Block {\n     // NB: v is an *alias* of type t here, not a direct value.\n     let _icx = push_ctxt(\"take_ty\");\n     if ty::type_needs_drop(cx.tcx(), t) {\n@@ -67,7 +67,7 @@ pub fn take_ty(cx: block, v: ValueRef, t: ty::t) -> block {\n     return cx;\n }\n \n-pub fn drop_ty(cx: block, v: ValueRef, t: ty::t) -> block {\n+pub fn drop_ty(cx: @mut Block, v: ValueRef, t: ty::t) -> @mut Block {\n     // NB: v is an *alias* of type t here, not a direct value.\n     let _icx = push_ctxt(\"drop_ty\");\n     if ty::type_needs_drop(cx.tcx(), t) {\n@@ -76,7 +76,7 @@ pub fn drop_ty(cx: block, v: ValueRef, t: ty::t) -> block {\n     return cx;\n }\n \n-pub fn drop_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> block {\n+pub fn drop_ty_immediate(bcx: @mut Block, v: ValueRef, t: ty::t) -> @mut Block {\n     let _icx = push_ctxt(\"drop_ty_immediate\");\n     match ty::get(t).sty {\n         ty::ty_uniq(_)\n@@ -93,7 +93,7 @@ pub fn drop_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> block {\n     }\n }\n \n-pub fn free_ty(cx: block, v: ValueRef, t: ty::t) -> block {\n+pub fn free_ty(cx: @mut Block, v: ValueRef, t: ty::t) -> @mut Block {\n     // NB: v is an *alias* of type t here, not a direct value.\n     let _icx = push_ctxt(\"free_ty\");\n     if ty::type_needs_drop(cx.tcx(), t) {\n@@ -102,7 +102,7 @@ pub fn free_ty(cx: block, v: ValueRef, t: ty::t) -> block {\n     return cx;\n }\n \n-pub fn free_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> block {\n+pub fn free_ty_immediate(bcx: @mut Block, v: ValueRef, t: ty::t) -> @mut Block {\n     let _icx = push_ctxt(\"free_ty_immediate\");\n     match ty::get(t).sty {\n       ty::ty_uniq(_) |\n@@ -273,7 +273,7 @@ pub fn lazily_emit_tydesc_glue(ccx: @mut CrateContext,\n }\n \n // See [Note-arg-mode]\n-pub fn call_tydesc_glue_full(bcx: block,\n+pub fn call_tydesc_glue_full(bcx: @mut Block,\n                              v: ValueRef,\n                              tydesc: ValueRef,\n                              field: uint,\n@@ -334,15 +334,15 @@ pub fn call_tydesc_glue_full(bcx: block,\n }\n \n // See [Note-arg-mode]\n-pub fn call_tydesc_glue(cx: block, v: ValueRef, t: ty::t, field: uint)\n-    -> block {\n+pub fn call_tydesc_glue(cx: @mut Block, v: ValueRef, t: ty::t, field: uint)\n+    -> @mut Block {\n     let _icx = push_ctxt(\"call_tydesc_glue\");\n     let ti = get_tydesc(cx.ccx(), t);\n     call_tydesc_glue_full(cx, v, ti.tydesc, field, Some(ti));\n     return cx;\n }\n \n-pub fn make_visit_glue(bcx: block, v: ValueRef, t: ty::t) -> block {\n+pub fn make_visit_glue(bcx: @mut Block, v: ValueRef, t: ty::t) -> @mut Block {\n     let _icx = push_ctxt(\"make_visit_glue\");\n     do with_scope(bcx, None, \"visitor cleanup\") |bcx| {\n         let mut bcx = bcx;\n@@ -360,7 +360,7 @@ pub fn make_visit_glue(bcx: block, v: ValueRef, t: ty::t) -> block {\n     }\n }\n \n-pub fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) -> block {\n+pub fn make_free_glue(bcx: @mut Block, v: ValueRef, t: ty::t) -> @mut Block {\n     // NB: v0 is an *alias* of type t here, not a direct value.\n     let _icx = push_ctxt(\"make_free_glue\");\n     match ty::get(t).sty {\n@@ -397,8 +397,8 @@ pub fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) -> block {\n     }\n }\n \n-pub fn trans_struct_drop_flag(bcx: block, t: ty::t, v0: ValueRef, dtor_did: ast::def_id,\n-                              class_did: ast::def_id, substs: &ty::substs) -> block {\n+pub fn trans_struct_drop_flag(bcx: @mut Block, t: ty::t, v0: ValueRef, dtor_did: ast::def_id,\n+                              class_did: ast::def_id, substs: &ty::substs) -> @mut Block {\n     let repr = adt::represent_type(bcx.ccx(), t);\n     let drop_flag = adt::trans_drop_flag_ptr(bcx, repr, v0);\n     do with_cond(bcx, IsNotNull(bcx, Load(bcx, drop_flag))) |cx| {\n@@ -435,8 +435,8 @@ pub fn trans_struct_drop_flag(bcx: block, t: ty::t, v0: ValueRef, dtor_did: ast:\n     }\n }\n \n-pub fn trans_struct_drop(mut bcx: block, t: ty::t, v0: ValueRef, dtor_did: ast::def_id,\n-                         class_did: ast::def_id, substs: &ty::substs) -> block {\n+pub fn trans_struct_drop(mut bcx: @mut Block, t: ty::t, v0: ValueRef, dtor_did: ast::def_id,\n+                         class_did: ast::def_id, substs: &ty::substs) -> @mut Block {\n     let repr = adt::represent_type(bcx.ccx(), t);\n \n     // Find and call the actual destructor\n@@ -468,7 +468,7 @@ pub fn trans_struct_drop(mut bcx: block, t: ty::t, v0: ValueRef, dtor_did: ast::\n     bcx\n }\n \n-pub fn make_drop_glue(bcx: block, v0: ValueRef, t: ty::t) -> block {\n+pub fn make_drop_glue(bcx: @mut Block, v0: ValueRef, t: ty::t) -> @mut Block {\n     // NB: v0 is an *alias* of type t here, not a direct value.\n     let _icx = push_ctxt(\"make_drop_glue\");\n     let ccx = bcx.ccx();\n@@ -539,10 +539,10 @@ pub fn make_drop_glue(bcx: block, v0: ValueRef, t: ty::t) -> block {\n }\n \n // box_ptr_ptr is optional, it is constructed if not supplied.\n-pub fn decr_refcnt_maybe_free(bcx: block, box_ptr: ValueRef,\n+pub fn decr_refcnt_maybe_free(bcx: @mut Block, box_ptr: ValueRef,\n                               box_ptr_ptr: Option<ValueRef>,\n                               t: ty::t)\n-                           -> block {\n+                           -> @mut Block {\n     let _icx = push_ctxt(\"decr_refcnt_maybe_free\");\n     let ccx = bcx.ccx();\n \n@@ -566,7 +566,7 @@ pub fn decr_refcnt_maybe_free(bcx: block, box_ptr: ValueRef,\n }\n \n \n-pub fn make_take_glue(bcx: block, v: ValueRef, t: ty::t) -> block {\n+pub fn make_take_glue(bcx: @mut Block, v: ValueRef, t: ty::t) -> @mut Block {\n     let _icx = push_ctxt(\"make_take_glue\");\n     // NB: v is a *pointer* to type t here, not a direct value.\n     match ty::get(t).sty {\n@@ -630,7 +630,7 @@ pub fn make_take_glue(bcx: block, v: ValueRef, t: ty::t) -> block {\n     }\n }\n \n-pub fn incr_refcnt_of_boxed(cx: block, box_ptr: ValueRef) {\n+pub fn incr_refcnt_of_boxed(cx: @mut Block, box_ptr: ValueRef) {\n     let _icx = push_ctxt(\"incr_refcnt_of_boxed\");\n     let ccx = cx.ccx();\n     let rc_ptr = GEPi(cx, box_ptr, [0u, abi::box_field_refcnt]);\n@@ -677,7 +677,7 @@ pub fn declare_tydesc(ccx: &mut CrateContext, t: ty::t) -> @mut tydesc_info {\n     return inf;\n }\n \n-pub type glue_helper<'self> = &'self fn(block, ValueRef, ty::t) -> block;\n+pub type glue_helper<'self> = &'self fn(@mut Block, ValueRef, ty::t) -> @mut Block;\n \n pub fn declare_generic_glue(ccx: &mut CrateContext, t: ty::t, llfnty: Type,\n                             name: &str) -> ValueRef {"}, {"sha": "a65999ff2aa178d08ce6407ead25c035b92ac3f1", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3315edfae7854d1f9f58840bbec4d43392c3fa51/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3315edfae7854d1f9f58840bbec4d43392c3fa51/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=3315edfae7854d1f9f58840bbec4d43392c3fa51", "patch": "@@ -124,7 +124,7 @@ pub fn trans_method(ccx: @mut CrateContext,\n              []);\n }\n \n-pub fn trans_self_arg(bcx: block,\n+pub fn trans_self_arg(bcx: @mut Block,\n                       base: @ast::expr,\n                       temp_cleanups: &mut ~[ValueRef],\n                       mentry: typeck::method_map_entry) -> Result {\n@@ -141,7 +141,7 @@ pub fn trans_self_arg(bcx: block,\n                    DontAutorefArg)\n }\n \n-pub fn trans_method_callee(bcx: block,\n+pub fn trans_method_callee(bcx: @mut Block,\n                            callee_id: ast::node_id,\n                            this: @ast::expr,\n                            mentry: typeck::method_map_entry)\n@@ -251,7 +251,7 @@ pub fn trans_method_callee(bcx: block,\n     }\n }\n \n-pub fn trans_static_method_callee(bcx: block,\n+pub fn trans_static_method_callee(bcx: @mut Block,\n                                   method_id: ast::def_id,\n                                   trait_id: ast::def_id,\n                                   callee_id: ast::node_id)\n@@ -348,7 +348,7 @@ pub fn method_with_name(ccx: &mut CrateContext,\n     meth.def_id\n }\n \n-pub fn trans_monomorphized_callee(bcx: block,\n+pub fn trans_monomorphized_callee(bcx: @mut Block,\n                                   callee_id: ast::node_id,\n                                   base: @ast::expr,\n                                   mentry: typeck::method_map_entry,\n@@ -409,7 +409,7 @@ pub fn trans_monomorphized_callee(bcx: block,\n \n }\n \n-pub fn combine_impl_and_methods_tps(bcx: block,\n+pub fn combine_impl_and_methods_tps(bcx: @mut Block,\n                                     mth_did: ast::def_id,\n                                     callee_id: ast::node_id,\n                                     rcvr_substs: &[ty::t],\n@@ -459,7 +459,7 @@ pub fn combine_impl_and_methods_tps(bcx: block,\n }\n \n \n-pub fn trans_trait_callee(bcx: block,\n+pub fn trans_trait_callee(bcx: @mut Block,\n                           callee_id: ast::node_id,\n                           n_method: uint,\n                           self_expr: @ast::expr,\n@@ -496,7 +496,7 @@ pub fn trans_trait_callee(bcx: block,\n                                   explicit_self)\n }\n \n-pub fn trans_trait_callee_from_llval(bcx: block,\n+pub fn trans_trait_callee_from_llval(bcx: @mut Block,\n                                      callee_ty: ty::t,\n                                      n_method: uint,\n                                      llpair: ValueRef,\n@@ -628,7 +628,7 @@ pub fn vtable_id(ccx: @mut CrateContext,\n \n /// Creates a returns a dynamic vtable for the given type and vtable origin.\n /// This is used only for objects.\n-pub fn get_vtable(bcx: block,\n+pub fn get_vtable(bcx: @mut Block,\n                   self_ty: ty::t,\n                   origin: typeck::vtable_origin)\n                   -> ValueRef {\n@@ -672,7 +672,7 @@ pub fn make_vtable(ccx: &mut CrateContext,\n }\n \n /// Generates a dynamic vtable for objects.\n-pub fn make_impl_vtable(bcx: block,\n+pub fn make_impl_vtable(bcx: @mut Block,\n                         impl_id: ast::def_id,\n                         self_ty: ty::t,\n                         substs: &[ty::t],\n@@ -716,12 +716,12 @@ pub fn make_impl_vtable(bcx: block,\n     make_vtable(ccx, tydesc, methods)\n }\n \n-pub fn trans_trait_cast(bcx: block,\n+pub fn trans_trait_cast(bcx: @mut Block,\n                         val: @ast::expr,\n                         id: ast::node_id,\n                         dest: expr::Dest,\n                         _store: ty::TraitStore)\n-                     -> block {\n+                     -> @mut Block {\n     let mut bcx = bcx;\n     let _icx = push_ctxt(\"impl::trans_cast\");\n "}, {"sha": "84b001953e0459138cefc2ae389e343d8f65ed09", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3315edfae7854d1f9f58840bbec4d43392c3fa51/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3315edfae7854d1f9f58840bbec4d43392c3fa51/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=3315edfae7854d1f9f58840bbec4d43392c3fa51", "patch": "@@ -37,9 +37,9 @@ use middle::trans::type_::Type;\n pub struct Reflector {\n     visitor_val: ValueRef,\n     visitor_methods: @~[@ty::Method],\n-    final_bcx: block,\n+    final_bcx: @mut Block,\n     tydesc_ty: Type,\n-    bcx: block\n+    bcx: @mut Block\n }\n \n impl Reflector {\n@@ -374,11 +374,11 @@ impl Reflector {\n }\n \n // Emit a sequence of calls to visit_ty::visit_foo\n-pub fn emit_calls_to_trait_visit_ty(bcx: block,\n+pub fn emit_calls_to_trait_visit_ty(bcx: @mut Block,\n                                     t: ty::t,\n                                     visitor_val: ValueRef,\n                                     visitor_trait_id: def_id)\n-                                 -> block {\n+                                 -> @mut Block {\n     let final = sub_block(bcx, \"final\");\n     let tydesc_ty = ty::get_tydesc_ty(bcx.ccx().tcx).unwrap();\n     let tydesc_ty = type_of(bcx.ccx(), tydesc_ty);"}, {"sha": "2f29d92574c2f8d924fc97b446f1a617dda69336", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/3315edfae7854d1f9f58840bbec4d43392c3fa51/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3315edfae7854d1f9f58840bbec4d43392c3fa51/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=3315edfae7854d1f9f58840bbec4d43392c3fa51", "patch": "@@ -53,38 +53,38 @@ pub fn expand_boxed_vec_ty(tcx: ty::ctxt, t: ty::t) -> ty::t {\n     }\n }\n \n-pub fn get_fill(bcx: block, vptr: ValueRef) -> ValueRef {\n+pub fn get_fill(bcx: @mut Block, vptr: ValueRef) -> ValueRef {\n     let _icx = push_ctxt(\"tvec::get_fill\");\n     Load(bcx, GEPi(bcx, vptr, [0u, abi::vec_elt_fill]))\n }\n-pub fn set_fill(bcx: block, vptr: ValueRef, fill: ValueRef) {\n+pub fn set_fill(bcx: @mut Block, vptr: ValueRef, fill: ValueRef) {\n     Store(bcx, fill, GEPi(bcx, vptr, [0u, abi::vec_elt_fill]));\n }\n-pub fn get_alloc(bcx: block, vptr: ValueRef) -> ValueRef {\n+pub fn get_alloc(bcx: @mut Block, vptr: ValueRef) -> ValueRef {\n     Load(bcx, GEPi(bcx, vptr, [0u, abi::vec_elt_alloc]))\n }\n \n-pub fn get_bodyptr(bcx: block, vptr: ValueRef, t: ty::t) -> ValueRef {\n+pub fn get_bodyptr(bcx: @mut Block, vptr: ValueRef, t: ty::t) -> ValueRef {\n     if ty::type_contents(bcx.tcx(), t).contains_managed() {\n         GEPi(bcx, vptr, [0u, abi::box_field_body])\n     } else {\n         vptr\n     }\n }\n \n-pub fn get_dataptr(bcx: block, vptr: ValueRef) -> ValueRef {\n+pub fn get_dataptr(bcx: @mut Block, vptr: ValueRef) -> ValueRef {\n     let _icx = push_ctxt(\"tvec::get_dataptr\");\n     GEPi(bcx, vptr, [0u, abi::vec_elt_elems, 0u])\n }\n \n-pub fn pointer_add(bcx: block, ptr: ValueRef, bytes: ValueRef) -> ValueRef {\n+pub fn pointer_add(bcx: @mut Block, ptr: ValueRef, bytes: ValueRef) -> ValueRef {\n     let _icx = push_ctxt(\"tvec::pointer_add\");\n     let old_ty = val_ty(ptr);\n     let bptr = PointerCast(bcx, ptr, Type::i8p());\n     return PointerCast(bcx, InBoundsGEP(bcx, bptr, [bytes]), old_ty);\n }\n \n-pub fn alloc_raw(bcx: block, unit_ty: ty::t,\n+pub fn alloc_raw(bcx: @mut Block, unit_ty: ty::t,\n                  fill: ValueRef, alloc: ValueRef, heap: heap) -> Result {\n     let _icx = push_ctxt(\"tvec::alloc_uniq\");\n     let ccx = bcx.ccx();\n@@ -107,12 +107,12 @@ pub fn alloc_raw(bcx: block, unit_ty: ty::t,\n     }\n }\n \n-pub fn alloc_uniq_raw(bcx: block, unit_ty: ty::t,\n+pub fn alloc_uniq_raw(bcx: @mut Block, unit_ty: ty::t,\n                       fill: ValueRef, alloc: ValueRef) -> Result {\n     alloc_raw(bcx, unit_ty, fill, alloc, base::heap_for_unique(bcx, unit_ty))\n }\n \n-pub fn alloc_vec(bcx: block,\n+pub fn alloc_vec(bcx: @mut Block,\n                  unit_ty: ty::t,\n                  elts: uint,\n                  heap: heap)\n@@ -130,8 +130,8 @@ pub fn alloc_vec(bcx: block,\n     return rslt(bcx, vptr);\n }\n \n-pub fn make_drop_glue_unboxed(bcx: block, vptr: ValueRef, vec_ty: ty::t) ->\n-   block {\n+pub fn make_drop_glue_unboxed(bcx: @mut Block, vptr: ValueRef, vec_ty: ty::t) ->\n+   @mut Block {\n     let _icx = push_ctxt(\"tvec::make_drop_glue_unboxed\");\n     let tcx = bcx.tcx();\n     let unit_ty = ty::sequence_element_type(tcx, vec_ty);\n@@ -157,11 +157,11 @@ impl VecTypes {\n     }\n }\n \n-pub fn trans_fixed_vstore(bcx: block,\n+pub fn trans_fixed_vstore(bcx: @mut Block,\n                           vstore_expr: @ast::expr,\n                           content_expr: &ast::expr,\n                           dest: expr::Dest)\n-                       -> block {\n+                       -> @mut Block {\n     //!\n     //\n     // [...] allocates a fixed-size array and moves it around \"by value\".\n@@ -186,11 +186,11 @@ pub fn trans_fixed_vstore(bcx: block,\n     };\n }\n \n-pub fn trans_slice_vstore(bcx: block,\n+pub fn trans_slice_vstore(bcx: @mut Block,\n                           vstore_expr: @ast::expr,\n                           content_expr: @ast::expr,\n                           dest: expr::Dest)\n-                       -> block {\n+                       -> @mut Block {\n     //!\n     //\n     // &[...] allocates memory on the stack and writes the values into it,\n@@ -245,11 +245,11 @@ pub fn trans_slice_vstore(bcx: block,\n     return bcx;\n }\n \n-pub fn trans_lit_str(bcx: block,\n+pub fn trans_lit_str(bcx: @mut Block,\n                      lit_expr: @ast::expr,\n                      str_lit: @str,\n                      dest: Dest)\n-                  -> block {\n+                  -> @mut Block {\n     //!\n     //\n     // Literal strings translate to slices into static memory.  This is\n@@ -280,7 +280,7 @@ pub fn trans_lit_str(bcx: block,\n }\n \n \n-pub fn trans_uniq_or_managed_vstore(bcx: block, heap: heap, vstore_expr: @ast::expr,\n+pub fn trans_uniq_or_managed_vstore(bcx: @mut Block, heap: heap, vstore_expr: @ast::expr,\n                                     content_expr: &ast::expr) -> DatumBlock {\n     //!\n     //\n@@ -341,12 +341,12 @@ pub fn trans_uniq_or_managed_vstore(bcx: block, heap: heap, vstore_expr: @ast::e\n     return immediate_rvalue_bcx(bcx, val, vt.vec_ty);\n }\n \n-pub fn write_content(bcx: block,\n+pub fn write_content(bcx: @mut Block,\n                      vt: &VecTypes,\n                      vstore_expr: @ast::expr,\n                      content_expr: &ast::expr,\n                      dest: Dest)\n-                  -> block {\n+                  -> @mut Block {\n     let _icx = push_ctxt(\"tvec::write_content\");\n     let mut bcx = bcx;\n \n@@ -469,12 +469,12 @@ pub fn write_content(bcx: block,\n     }\n }\n \n-pub fn vec_types_from_expr(bcx: block, vec_expr: &ast::expr) -> VecTypes {\n+pub fn vec_types_from_expr(bcx: @mut Block, vec_expr: &ast::expr) -> VecTypes {\n     let vec_ty = node_id_type(bcx, vec_expr.id);\n     vec_types(bcx, vec_ty)\n }\n \n-pub fn vec_types(bcx: block, vec_ty: ty::t) -> VecTypes {\n+pub fn vec_types(bcx: @mut Block, vec_ty: ty::t) -> VecTypes {\n     let ccx = bcx.ccx();\n     let unit_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n     let llunit_ty = type_of::type_of(ccx, unit_ty);\n@@ -486,7 +486,7 @@ pub fn vec_types(bcx: block, vec_ty: ty::t) -> VecTypes {\n               llunit_size: llunit_size}\n }\n \n-pub fn elements_required(bcx: block, content_expr: &ast::expr) -> uint {\n+pub fn elements_required(bcx: @mut Block, content_expr: &ast::expr) -> uint {\n     //! Figure out the number of elements we need to store this content\n \n     match content_expr.node {\n@@ -502,7 +502,7 @@ pub fn elements_required(bcx: block, content_expr: &ast::expr) -> uint {\n     }\n }\n \n-pub fn get_base_and_len(bcx: block,\n+pub fn get_base_and_len(bcx: @mut Block,\n                         llval: ValueRef,\n                         vec_ty: ty::t) -> (ValueRef, ValueRef) {\n     //!\n@@ -540,10 +540,10 @@ pub fn get_base_and_len(bcx: block,\n     }\n }\n \n-pub type iter_vec_block<'self> = &'self fn(block, ValueRef, ty::t) -> block;\n+pub type iter_vec_block<'self> = &'self fn(@mut Block, ValueRef, ty::t) -> @mut Block;\n \n-pub fn iter_vec_raw(bcx: block, data_ptr: ValueRef, vec_ty: ty::t,\n-                    fill: ValueRef, f: iter_vec_block) -> block {\n+pub fn iter_vec_raw(bcx: @mut Block, data_ptr: ValueRef, vec_ty: ty::t,\n+                    fill: ValueRef, f: iter_vec_block) -> @mut Block {\n     let _icx = push_ctxt(\"tvec::iter_vec_raw\");\n \n     let unit_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n@@ -573,15 +573,15 @@ pub fn iter_vec_raw(bcx: block, data_ptr: ValueRef, vec_ty: ty::t,\n \n }\n \n-pub fn iter_vec_uniq(bcx: block, vptr: ValueRef, vec_ty: ty::t,\n-                     fill: ValueRef, f: iter_vec_block) -> block {\n+pub fn iter_vec_uniq(bcx: @mut Block, vptr: ValueRef, vec_ty: ty::t,\n+                     fill: ValueRef, f: iter_vec_block) -> @mut Block {\n     let _icx = push_ctxt(\"tvec::iter_vec_uniq\");\n     let data_ptr = get_dataptr(bcx, get_bodyptr(bcx, vptr, vec_ty));\n     iter_vec_raw(bcx, data_ptr, vec_ty, fill, f)\n }\n \n-pub fn iter_vec_unboxed(bcx: block, body_ptr: ValueRef, vec_ty: ty::t,\n-                        f: iter_vec_block) -> block {\n+pub fn iter_vec_unboxed(bcx: @mut Block, body_ptr: ValueRef, vec_ty: ty::t,\n+                        f: iter_vec_block) -> @mut Block {\n     let _icx = push_ctxt(\"tvec::iter_vec_unboxed\");\n     let fill = get_fill(bcx, body_ptr);\n     let dataptr = get_dataptr(bcx, body_ptr);"}, {"sha": "93335de229275391842d6d2ac37013bf23f23f6c", "filename": "src/librustc/middle/trans/uniq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3315edfae7854d1f9f58840bbec4d43392c3fa51/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3315edfae7854d1f9f58840bbec4d43392c3fa51/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs?ref=3315edfae7854d1f9f58840bbec4d43392c3fa51", "patch": "@@ -17,8 +17,8 @@ use middle::trans::datum::immediate_rvalue;\n use middle::trans::glue;\n use middle::ty;\n \n-pub fn make_free_glue(bcx: block, vptrptr: ValueRef, box_ty: ty::t)\n-    -> block {\n+pub fn make_free_glue(bcx: @mut Block, vptrptr: ValueRef, box_ty: ty::t)\n+    -> @mut Block {\n     let _icx = push_ctxt(\"uniq::make_free_glue\");\n     let box_datum = immediate_rvalue(Load(bcx, vptrptr), box_ty);\n "}, {"sha": "13c20591ba3e190bdd6964536d187266342083bc", "filename": "src/librustc/middle/trans/write_guard.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3315edfae7854d1f9f58840bbec4d43392c3fa51/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3315edfae7854d1f9f58840bbec4d43392c3fa51/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs?ref=3315edfae7854d1f9f58840bbec4d43392c3fa51", "patch": "@@ -34,10 +34,10 @@ use syntax::ast;\n use middle::trans::type_::Type;\n \n pub fn root_and_write_guard(datum: &Datum,\n-                            mut bcx: block,\n+                            mut bcx: @mut Block,\n                             span: span,\n                             expr_id: ast::node_id,\n-                            derefs: uint) -> block {\n+                            derefs: uint) -> @mut Block {\n     let key = root_map_key { id: expr_id, derefs: derefs };\n     debug!(\"write_guard::root_and_write_guard(key=%?)\", key);\n \n@@ -60,12 +60,12 @@ pub fn root_and_write_guard(datum: &Datum,\n     }\n }\n \n-pub fn return_to_mut(mut bcx: block,\n+pub fn return_to_mut(mut bcx: @mut Block,\n                      root_key: root_map_key,\n                      frozen_val_ref: ValueRef,\n                      bits_val_ref: ValueRef,\n                      filename_val: ValueRef,\n-                     line_val: ValueRef) -> block {\n+                     line_val: ValueRef) -> @mut Block {\n     debug!(\"write_guard::return_to_mut(root_key=%?, %s, %s, %s)\",\n            root_key,\n            bcx.to_str(),\n@@ -102,10 +102,10 @@ pub fn return_to_mut(mut bcx: block,\n }\n \n fn root(datum: &Datum,\n-        mut bcx: block,\n+        mut bcx: @mut Block,\n         span: span,\n         root_key: root_map_key,\n-        root_info: RootInfo) -> block {\n+        root_info: RootInfo) -> @mut Block {\n     //! In some cases, borrowck will decide that an @T/@[]/@str\n     //! value must be rooted for the program to be safe.  In that\n     //! case, we will call this function, which will stash a copy\n@@ -182,8 +182,8 @@ fn root(datum: &Datum,\n }\n \n fn perform_write_guard(datum: &Datum,\n-                       bcx: block,\n-                       span: span) -> block {\n+                       bcx: @mut Block,\n+                       span: span) -> @mut Block {\n     debug!(\"perform_write_guard\");\n \n     let llval = datum.to_value_llval(bcx);"}]}