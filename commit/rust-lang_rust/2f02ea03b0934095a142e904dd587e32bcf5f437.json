{"sha": "2f02ea03b0934095a142e904dd587e32bcf5f437", "node_id": "C_kwDOAAsO6NoAKDJmMDJlYTAzYjA5MzQwOTVhMTQyZTkwNGRkNTg3ZTMyYmNmNWY0Mzc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-19T10:57:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-19T10:57:02Z"}, "message": "Auto merge of #13041 - DorianListens:dscheidt/gen-fn-self-assoc-2, r=Veykril\n\nfeat: Generate static method using Self::assoc() syntax\n\nThis change improves the `generate_function` assist to support generating static methods/associated functions using the `Self::assoc()` syntax. Previously, one could generate a static method, but only when specifying the type name directly (like `Foo::assoc()`). After this change, `Self` is supported as well as the type name.\n\nFixes #13012", "tree": {"sha": "70bcc877e138023224ff7e51e830402309f2e815", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/70bcc877e138023224ff7e51e830402309f2e815"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f02ea03b0934095a142e904dd587e32bcf5f437", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f02ea03b0934095a142e904dd587e32bcf5f437", "html_url": "https://github.com/rust-lang/rust/commit/2f02ea03b0934095a142e904dd587e32bcf5f437", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f02ea03b0934095a142e904dd587e32bcf5f437/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "62c31070650a9d3579f1aae6da3bcdc0bad02afc", "url": "https://api.github.com/repos/rust-lang/rust/commits/62c31070650a9d3579f1aae6da3bcdc0bad02afc", "html_url": "https://github.com/rust-lang/rust/commit/62c31070650a9d3579f1aae6da3bcdc0bad02afc"}, {"sha": "48ea3825b8951a39e27503ea16cacc9147255d79", "url": "https://api.github.com/repos/rust-lang/rust/commits/48ea3825b8951a39e27503ea16cacc9147255d79", "html_url": "https://github.com/rust-lang/rust/commit/48ea3825b8951a39e27503ea16cacc9147255d79"}], "stats": {"total": 142, "additions": 106, "deletions": 36}, "files": [{"sha": "e26c76da1891649c0a035706e5eb278aa325b99e", "filename": "crates/ide-assists/src/handlers/generate_function.rs", "status": "modified", "additions": 106, "deletions": 36, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/2f02ea03b0934095a142e904dd587e32bcf5f437/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f02ea03b0934095a142e904dd587e32bcf5f437/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs?ref=2f02ea03b0934095a142e904dd587e32bcf5f437", "patch": "@@ -61,56 +61,72 @@ fn gen_fn(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     }\n \n     let fn_name = &*name_ref.text();\n-    let target_module;\n-    let mut adt_name = None;\n+    let TargetInfo { target_module, adt_name, target, file, insert_offset } =\n+        fn_target_info(ctx, path, &call, fn_name)?;\n+    let function_builder = FunctionBuilder::from_call(ctx, &call, fn_name, target_module, target)?;\n+    let text_range = call.syntax().text_range();\n+    let label = format!(\"Generate {} function\", function_builder.fn_name);\n+    add_func_to_accumulator(\n+        acc,\n+        ctx,\n+        text_range,\n+        function_builder,\n+        insert_offset,\n+        file,\n+        adt_name,\n+        label,\n+    )\n+}\n+\n+struct TargetInfo {\n+    target_module: Option<Module>,\n+    adt_name: Option<hir::Name>,\n+    target: GeneratedFunctionTarget,\n+    file: FileId,\n+    insert_offset: TextSize,\n+}\n \n-    let (target, file, insert_offset) = match path.qualifier() {\n+impl TargetInfo {\n+    fn new(\n+        target_module: Option<Module>,\n+        adt_name: Option<hir::Name>,\n+        target: GeneratedFunctionTarget,\n+        file: FileId,\n+        insert_offset: TextSize,\n+    ) -> Self {\n+        Self { target_module, adt_name, target, file, insert_offset }\n+    }\n+}\n+\n+fn fn_target_info(\n+    ctx: &AssistContext<'_>,\n+    path: ast::Path,\n+    call: &CallExpr,\n+    fn_name: &str,\n+) -> Option<TargetInfo> {\n+    match path.qualifier() {\n         Some(qualifier) => match ctx.sema.resolve_path(&qualifier) {\n             Some(hir::PathResolution::Def(hir::ModuleDef::Module(module))) => {\n-                target_module = Some(module);\n-                get_fn_target(ctx, &target_module, call.clone())?\n+                get_fn_target_info(ctx, &Some(module), call.clone())\n             }\n             Some(hir::PathResolution::Def(hir::ModuleDef::Adt(adt))) => {\n                 if let hir::Adt::Enum(_) = adt {\n                     // Don't suggest generating function if the name starts with an uppercase letter\n-                    if name_ref.text().starts_with(char::is_uppercase) {\n+                    if fn_name.starts_with(char::is_uppercase) {\n                         return None;\n                     }\n                 }\n \n-                let current_module = ctx.sema.scope(call.syntax())?.module();\n-                let module = adt.module(ctx.sema.db);\n-                target_module = if current_module == module { None } else { Some(module) };\n-                if current_module.krate() != module.krate() {\n-                    return None;\n-                }\n-                let (impl_, file) = get_adt_source(ctx, &adt, fn_name)?;\n-                let (target, insert_offset) = get_method_target(ctx, &module, &impl_)?;\n-                adt_name = if impl_.is_none() { Some(adt.name(ctx.sema.db)) } else { None };\n-                (target, file, insert_offset)\n+                assoc_fn_target_info(ctx, call, adt, fn_name)\n             }\n-            _ => {\n-                return None;\n+            Some(hir::PathResolution::SelfType(impl_)) => {\n+                let adt = impl_.self_ty(ctx.db()).as_adt()?;\n+                assoc_fn_target_info(ctx, call, adt, fn_name)\n             }\n+            _ => None,\n         },\n-        _ => {\n-            target_module = None;\n-            get_fn_target(ctx, &target_module, call.clone())?\n-        }\n-    };\n-    let function_builder = FunctionBuilder::from_call(ctx, &call, fn_name, target_module, target)?;\n-    let text_range = call.syntax().text_range();\n-    let label = format!(\"Generate {} function\", function_builder.fn_name);\n-    add_func_to_accumulator(\n-        acc,\n-        ctx,\n-        text_range,\n-        function_builder,\n-        insert_offset,\n-        file,\n-        adt_name,\n-        label,\n-    )\n+        _ => get_fn_target_info(ctx, &None, call.clone()),\n+    }\n }\n \n fn gen_method(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n@@ -366,6 +382,15 @@ fn make_return_type(\n     (ret_type, should_focus_return_type)\n }\n \n+fn get_fn_target_info(\n+    ctx: &AssistContext<'_>,\n+    target_module: &Option<Module>,\n+    call: CallExpr,\n+) -> Option<TargetInfo> {\n+    let (target, file, insert_offset) = get_fn_target(ctx, target_module, call)?;\n+    Some(TargetInfo::new(*target_module, None, target, file, insert_offset))\n+}\n+\n fn get_fn_target(\n     ctx: &AssistContext<'_>,\n     target_module: &Option<Module>,\n@@ -399,6 +424,24 @@ fn get_method_target(\n     Some((target.clone(), get_insert_offset(&target)))\n }\n \n+fn assoc_fn_target_info(\n+    ctx: &AssistContext<'_>,\n+    call: &CallExpr,\n+    adt: hir::Adt,\n+    fn_name: &str,\n+) -> Option<TargetInfo> {\n+    let current_module = ctx.sema.scope(call.syntax())?.module();\n+    let module = adt.module(ctx.sema.db);\n+    let target_module = if current_module == module { None } else { Some(module) };\n+    if current_module.krate() != module.krate() {\n+        return None;\n+    }\n+    let (impl_, file) = get_adt_source(ctx, &adt, fn_name)?;\n+    let (target, insert_offset) = get_method_target(ctx, &module, &impl_)?;\n+    let adt_name = if impl_.is_none() { Some(adt.name(ctx.sema.db)) } else { None };\n+    Some(TargetInfo::new(target_module, adt_name, target, file, insert_offset))\n+}\n+\n fn get_insert_offset(target: &GeneratedFunctionTarget) -> TextSize {\n     match &target {\n         GeneratedFunctionTarget::BehindItem(it) => it.text_range().end(),\n@@ -1633,6 +1676,33 @@ fn bar() ${0:-> _} {\n         )\n     }\n \n+    #[test]\n+    fn create_static_method_within_an_impl_with_self_syntax() {\n+        check_assist(\n+            generate_function,\n+            r\"\n+struct S;\n+impl S {\n+    fn foo(&self) {\n+        Self::bar$0();\n+    }\n+}\n+\",\n+            r\"\n+struct S;\n+impl S {\n+    fn foo(&self) {\n+        Self::bar();\n+    }\n+\n+    fn bar() ${0:-> _} {\n+        todo!()\n+    }\n+}\n+\",\n+        )\n+    }\n+\n     #[test]\n     fn no_panic_on_invalid_global_path() {\n         check_assist("}]}