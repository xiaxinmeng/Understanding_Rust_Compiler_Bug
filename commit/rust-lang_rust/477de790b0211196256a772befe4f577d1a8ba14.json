{"sha": "477de790b0211196256a772befe4f577d1a8ba14", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3N2RlNzkwYjAyMTExOTYyNTZhNzcyYmVmZTRmNTc3ZDFhOGJhMTQ=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-11-10T14:36:45Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-11-10T14:36:45Z"}, "message": "Merge #222\n\n222: Validate string literals r=aochagavia a=aochagavia\n\nRelated: #6 (some validators are still missing), fixes #27\n\nCo-authored-by: Adolfo Ochagav\u00eda <github@adolfo.ochagavia.xyz>", "tree": {"sha": "42c40e9201adf64d1c06bc1c69524f5688ee6e9f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/42c40e9201adf64d1c06bc1c69524f5688ee6e9f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/477de790b0211196256a772befe4f577d1a8ba14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/477de790b0211196256a772befe4f577d1a8ba14", "html_url": "https://github.com/rust-lang/rust/commit/477de790b0211196256a772befe4f577d1a8ba14", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/477de790b0211196256a772befe4f577d1a8ba14/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "5a9150df9bcdaf5faed5b500c22333f1f7c99f32", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a9150df9bcdaf5faed5b500c22333f1f7c99f32", "html_url": "https://github.com/rust-lang/rust/commit/5a9150df9bcdaf5faed5b500c22333f1f7c99f32"}, {"sha": "3b4c02c19e4af645fd37e8bff774b05d546dc0b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b4c02c19e4af645fd37e8bff774b05d546dc0b6", "html_url": "https://github.com/rust-lang/rust/commit/3b4c02c19e4af645fd37e8bff774b05d546dc0b6"}], "stats": {"total": 895, "additions": 621, "deletions": 274}, "files": [{"sha": "2e9ae263a9854ca212090d5be70bfc7bfffb1dbd", "filename": "crates/ra_syntax/src/ast/generated.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/477de790b0211196256a772befe4f577d1a8ba14/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/477de790b0211196256a772befe4f577d1a8ba14/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs?ref=477de790b0211196256a772befe4f577d1a8ba14", "patch": "@@ -3236,6 +3236,43 @@ impl<'a> AstNode<'a> for Stmt<'a> {\n \n impl<'a> Stmt<'a> {}\n \n+// String\n+#[derive(Debug, Clone, Copy,)]\n+pub struct StringNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n+    pub(crate) syntax: SyntaxNode<R>,\n+}\n+pub type String<'a> = StringNode<RefRoot<'a>>;\n+\n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<StringNode<R1>> for StringNode<R2> {\n+    fn eq(&self, other: &StringNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for StringNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for StringNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n+impl<'a> AstNode<'a> for String<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+        match syntax.kind() {\n+            STRING => Some(String { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n+}\n+\n+impl<R: TreeRoot<RaTypes>> StringNode<R> {\n+    pub fn borrowed(&self) -> String {\n+        StringNode { syntax: self.syntax.borrowed() }\n+    }\n+    pub fn owned(&self) -> StringNode {\n+        StringNode { syntax: self.syntax.owned() }\n+    }\n+}\n+\n+\n+impl<'a> String<'a> {}\n+\n // StructDef\n #[derive(Debug, Clone, Copy,)]\n pub struct StructDefNode<R: TreeRoot<RaTypes> = OwnedRoot> {"}, {"sha": "f20714ede6d6d450837644bd901cecda97a4fb44", "filename": "crates/ra_syntax/src/ast/mod.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/477de790b0211196256a772befe4f577d1a8ba14/crates%2Fra_syntax%2Fsrc%2Fast%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/477de790b0211196256a772befe4f577d1a8ba14/crates%2Fra_syntax%2Fsrc%2Fast%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fmod.rs?ref=477de790b0211196256a772befe4f577d1a8ba14", "patch": "@@ -1,6 +1,7 @@\n mod generated;\n \n use std::marker::PhantomData;\n+use std::string::String as RustString;\n \n use itertools::Itertools;\n \n@@ -76,7 +77,7 @@ pub trait DocCommentsOwner<'a>: AstNode<'a> {\n \n     /// Returns the textual content of a doc comment block as a single string.\n     /// That is, strips leading `///` and joins lines\n-    fn doc_comment_text(self) -> String {\n+    fn doc_comment_text(self) -> RustString {\n         self.doc_comments()\n             .map(|comment| {\n                 let prefix = comment.prefix();\n@@ -133,6 +134,12 @@ impl<'a> Char<'a> {\n     }\n }\n \n+impl<'a> String<'a> {\n+    pub fn text(&self) -> &SmolStr {\n+        &self.syntax().leaf_text().unwrap()\n+    }\n+}\n+\n impl<'a> Comment<'a> {\n     pub fn text(&self) -> &SmolStr {\n         self.syntax().leaf_text().unwrap()"}, {"sha": "c3184667e854a9390b46fef1ab02835a29671d25", "filename": "crates/ra_syntax/src/grammar.ron", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/477de790b0211196256a772befe4f577d1a8ba14/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "raw_url": "https://github.com/rust-lang/rust/raw/477de790b0211196256a772befe4f577d1a8ba14/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron?ref=477de790b0211196256a772befe4f577d1a8ba14", "patch": "@@ -411,6 +411,7 @@ Grammar(\n         \"PrefixExpr\": (),\n         \"RangeExpr\": (),\n         \"BinExpr\": (),\n+        \"String\": (),\n         \"Char\": (),\n         \"Literal\": (),\n "}, {"sha": "d613bb0429a9ce11cfa3da3db99c19c92440e3ae", "filename": "crates/ra_syntax/src/string_lexing.rs", "status": "renamed", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/477de790b0211196256a772befe4f577d1a8ba14/crates%2Fra_syntax%2Fsrc%2Fstring_lexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/477de790b0211196256a772befe4f577d1a8ba14/crates%2Fra_syntax%2Fsrc%2Fstring_lexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fstring_lexing.rs?ref=477de790b0211196256a772befe4f577d1a8ba14", "patch": "@@ -1,6 +1,68 @@\n use self::CharComponentKind::*;\n use rowan::{TextRange, TextUnit};\n \n+pub fn parse_string_literal(src: &str) -> StringComponentIterator {\n+    StringComponentIterator {\n+        parser: Parser::new(src),\n+        has_closing_quote: false,\n+    }\n+}\n+\n+#[derive(Debug, Eq, PartialEq, Clone)]\n+pub struct StringComponent {\n+    pub range: TextRange,\n+    pub kind: StringComponentKind,\n+}\n+\n+impl StringComponent {\n+    fn new(range: TextRange, kind: StringComponentKind) -> StringComponent {\n+        StringComponent { range, kind }\n+    }\n+}\n+\n+#[derive(Debug, Eq, PartialEq, Clone)]\n+pub enum StringComponentKind {\n+    IgnoreNewline,\n+    Char(CharComponentKind),\n+}\n+\n+pub struct StringComponentIterator<'a> {\n+    parser: Parser<'a>,\n+    pub has_closing_quote: bool,\n+}\n+\n+impl<'a> Iterator for StringComponentIterator<'a> {\n+    type Item = StringComponent;\n+    fn next(&mut self) -> Option<StringComponent> {\n+        if self.parser.pos == 0 {\n+            assert!(\n+                self.parser.advance() == '\"',\n+                \"string literal should start with double quotes\"\n+            );\n+        }\n+\n+        if let Some(component) = self.parser.parse_string_component() {\n+            return Some(component);\n+        }\n+\n+        // We get here when there are no char components left to parse\n+        if self.parser.peek() == Some('\"') {\n+            self.parser.advance();\n+            self.has_closing_quote = true;\n+        }\n+\n+        assert!(\n+            self.parser.peek() == None,\n+            \"string literal should leave no unparsed input: src = {}, pos = {}, length = {}\",\n+            self.parser.src,\n+            self.parser.pos,\n+            self.parser.src.len()\n+        );\n+\n+        None\n+    }\n+}\n+\n pub fn parse_char_literal(src: &str) -> CharComponentIterator {\n     CharComponentIterator {\n         parser: Parser::new(src),\n@@ -93,6 +155,12 @@ impl<'a> Parser<'a> {\n         next\n     }\n \n+    pub fn skip_whitespace(&mut self) {\n+        while self.peek().map(|c| c.is_whitespace()) == Some(true) {\n+            self.advance();\n+        }\n+    }\n+\n     pub fn get_pos(&self) -> TextUnit {\n         (self.pos as u32).into()\n     }\n@@ -172,6 +240,51 @@ impl<'a> Parser<'a> {\n             ))\n         }\n     }\n+\n+    pub fn parse_ignore_newline(&mut self, start: TextUnit) -> Option<StringComponent> {\n+        // In string literals, when a `\\` occurs immediately before the newline, the `\\`,\n+        // the newline, and all whitespace at the beginning of the next line are ignored\n+        match self.peek() {\n+            Some('\\n') | Some('\\r') => {\n+                self.skip_whitespace();\n+                Some(StringComponent::new(\n+                    TextRange::from_to(start, self.get_pos()),\n+                    StringComponentKind::IgnoreNewline,\n+                ))\n+            }\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn parse_string_component(&mut self) -> Option<StringComponent> {\n+        let next = self.peek()?;\n+\n+        // Ignore string close\n+        if next == '\"' {\n+            return None;\n+        }\n+\n+        let start = self.get_pos();\n+        self.advance();\n+\n+        if next == '\\\\' {\n+            // Strings can use `\\` to ignore newlines, so we first try to parse one of those\n+            // before falling back to parsing char escapes\n+            self.parse_ignore_newline(start).or_else(|| {\n+                let char_component = self.parse_escape(start);\n+                Some(StringComponent::new(\n+                    char_component.range,\n+                    StringComponentKind::Char(char_component.kind),\n+                ))\n+            })\n+        } else {\n+            let end = self.get_pos();\n+            Some(StringComponent::new(\n+                TextRange::from_to(start, end),\n+                StringComponentKind::Char(CodePoint),\n+            ))\n+        }\n+    }\n }\n \n #[cfg(test)]", "previous_filename": "crates/ra_syntax/src/string_lexing/mod.rs"}, {"sha": "a10b297c0f061195187ad0c5f9eec6f947ee4275", "filename": "crates/ra_syntax/src/validation.rs", "status": "removed", "additions": 0, "deletions": 271, "changes": 271, "blob_url": "https://github.com/rust-lang/rust/blob/5a9150df9bcdaf5faed5b500c22333f1f7c99f32/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a9150df9bcdaf5faed5b500c22333f1f7c99f32/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs?ref=5a9150df9bcdaf5faed5b500c22333f1f7c99f32", "patch": "@@ -1,271 +0,0 @@\n-use std::u32;\n-\n-use arrayvec::ArrayString;\n-\n-use crate::{\n-    algo::visit::{visitor_ctx, VisitorCtx},\n-    ast::{self, AstNode},\n-    SourceFileNode,\n-    string_lexing::{self, CharComponentKind},\n-    yellow::{\n-        SyntaxError,\n-        SyntaxErrorKind::*,\n-    },\n-};\n-\n-pub(crate) fn validate(file: &SourceFileNode) -> Vec<SyntaxError> {\n-    let mut errors = Vec::new();\n-    for node in file.syntax().descendants() {\n-        let _ = visitor_ctx(&mut errors)\n-            .visit::<ast::Char, _>(validate_char)\n-            .accept(node);\n-    }\n-    errors\n-}\n-\n-fn validate_char(node: ast::Char, errors: &mut Vec<SyntaxError>) {\n-    let mut components = string_lexing::parse_char_literal(node.text());\n-    let mut len = 0;\n-    for component in &mut components {\n-        len += 1;\n-\n-        // Validate escapes\n-        let text = &node.text()[component.range];\n-        let range = component.range + node.syntax().range().start();\n-        use self::CharComponentKind::*;\n-        match component.kind {\n-            AsciiEscape => {\n-                if text.len() == 1 {\n-                    // Escape sequence consists only of leading `\\`\n-                    errors.push(SyntaxError::new(EmptyAsciiEscape, range));\n-                } else {\n-                    let escape_code = text.chars().skip(1).next().unwrap();\n-                    if !is_ascii_escape(escape_code) {\n-                        errors.push(SyntaxError::new(InvalidAsciiEscape, range));\n-                    }\n-                }\n-            }\n-            AsciiCodeEscape => {\n-                // An AsciiCodeEscape has 4 chars, example: `\\xDD`\n-                if text.len() < 4 {\n-                    errors.push(SyntaxError::new(TooShortAsciiCodeEscape, range));\n-                } else {\n-                    assert!(\n-                        text.chars().count() == 4,\n-                        \"AsciiCodeEscape cannot be longer than 4 chars\"\n-                    );\n-\n-                    match u8::from_str_radix(&text[2..], 16) {\n-                        Ok(code) if code < 128 => { /* Escape code is valid */ }\n-                        Ok(_) => errors.push(SyntaxError::new(AsciiCodeEscapeOutOfRange, range)),\n-                        Err(_) => errors.push(SyntaxError::new(MalformedAsciiCodeEscape, range)),\n-                    }\n-                }\n-            }\n-            UnicodeEscape => {\n-                assert!(&text[..2] == \"\\\\u\", \"UnicodeEscape always starts with \\\\u\");\n-\n-                if text.len() == 2 {\n-                    // No starting `{`\n-                    errors.push(SyntaxError::new(MalformedUnicodeEscape, range));\n-                    return;\n-                }\n-\n-                if text.len() == 3 {\n-                    // Only starting `{`\n-                    errors.push(SyntaxError::new(UnclosedUnicodeEscape, range));\n-                    return;\n-                }\n-\n-                let mut code = ArrayString::<[_; 6]>::new();\n-                let mut closed = false;\n-                for c in text[3..].chars() {\n-                    assert!(!closed, \"no characters after escape is closed\");\n-\n-                    if c.is_digit(16) {\n-                        if code.len() == 6 {\n-                            errors.push(SyntaxError::new(OverlongUnicodeEscape, range));\n-                            return;\n-                        }\n-\n-                        code.push(c);\n-                    } else if c == '_' {\n-                        // Reject leading _\n-                        if code.len() == 0 {\n-                            errors.push(SyntaxError::new(MalformedUnicodeEscape, range));\n-                            return;\n-                        }\n-                    } else if c == '}' {\n-                        closed = true;\n-                    } else {\n-                        errors.push(SyntaxError::new(MalformedUnicodeEscape, range));\n-                        return;\n-                    }\n-                }\n-\n-                if !closed {\n-                    errors.push(SyntaxError::new(UnclosedUnicodeEscape, range))\n-                }\n-\n-                if code.len() == 0 {\n-                    errors.push(SyntaxError::new(EmptyUnicodeEcape, range));\n-                    return;\n-                }\n-\n-                match u32::from_str_radix(&code, 16) {\n-                    Ok(code_u32) if code_u32 > 0x10FFFF => {\n-                        errors.push(SyntaxError::new(UnicodeEscapeOutOfRange, range));\n-                    }\n-                    Ok(_) => {\n-                        // Valid escape code\n-                    }\n-                    Err(_) => {\n-                        errors.push(SyntaxError::new(MalformedUnicodeEscape, range));\n-                    }\n-                }\n-            }\n-            CodePoint => {\n-                // These code points must always be escaped\n-                if text == \"\\t\" || text == \"\\r\" {\n-                    errors.push(SyntaxError::new(UnescapedCodepoint, range));\n-                }\n-            }\n-        }\n-    }\n-\n-    if !components.has_closing_quote {\n-        errors.push(SyntaxError::new(UnclosedChar, node.syntax().range()));\n-    }\n-\n-    if len == 0 {\n-        errors.push(SyntaxError::new(EmptyChar, node.syntax().range()));\n-    }\n-\n-    if len > 1 {\n-        errors.push(SyntaxError::new(LongChar, node.syntax().range()));\n-    }\n-}\n-\n-fn is_ascii_escape(code: char) -> bool {\n-    match code {\n-        '\\\\' | '\\'' | '\"' | 'n' | 'r' | 't' | '0' => true,\n-        _ => false,\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use crate::SourceFileNode;\n-\n-    fn build_file(literal: &str) -> SourceFileNode {\n-        let src = format!(\"const C: char = '{}';\", literal);\n-        SourceFileNode::parse(&src)\n-    }\n-\n-    fn assert_valid_char(literal: &str) {\n-        let file = build_file(literal);\n-        assert!(\n-            file.errors().len() == 0,\n-            \"Errors for literal '{}': {:?}\",\n-            literal,\n-            file.errors()\n-        );\n-    }\n-\n-    fn assert_invalid_char(literal: &str) {\n-        let file = build_file(literal);\n-        assert!(file.errors().len() > 0);\n-    }\n-\n-    #[test]\n-    fn test_ansi_codepoints() {\n-        for byte in 0..=255u8 {\n-            match byte {\n-                b'\\n' | b'\\r' | b'\\t' => assert_invalid_char(&(byte as char).to_string()),\n-                b'\\'' | b'\\\\' => { /* Ignore character close and backslash */ }\n-                _ => assert_valid_char(&(byte as char).to_string()),\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_unicode_codepoints() {\n-        let valid = [\"\u0191\", \"\u30d0\", \"\u30e1\", \"\ufdfd\"];\n-        for c in &valid {\n-            assert_valid_char(c);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_unicode_multiple_codepoints() {\n-        let invalid = [\"\u0928\u0940\", \"\ud83d\udc68\u200d\ud83d\udc68\u200d\"];\n-        for c in &invalid {\n-            assert_invalid_char(c);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_valid_ascii_escape() {\n-        let valid = [\n-            r\"\\'\", \"\\\"\", \"\\\\\\\\\", \"\\\\\\\"\", r\"\\n\", r\"\\r\", r\"\\t\", r\"\\0\", \"a\", \"b\",\n-        ];\n-        for c in &valid {\n-            assert_valid_char(c);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_invalid_ascii_escape() {\n-        let invalid = [r\"\\a\", r\"\\?\", r\"\\\"];\n-        for c in &invalid {\n-            assert_invalid_char(c);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_valid_ascii_code_escape() {\n-        let valid = [r\"\\x00\", r\"\\x7F\", r\"\\x55\"];\n-        for c in &valid {\n-            assert_valid_char(c);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_invalid_ascii_code_escape() {\n-        let invalid = [r\"\\x\", r\"\\x7\", r\"\\xF0\"];\n-        for c in &invalid {\n-            assert_invalid_char(c);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_valid_unicode_escape() {\n-        let valid = [\n-            r\"\\u{FF}\",\n-            r\"\\u{0}\",\n-            r\"\\u{F}\",\n-            r\"\\u{10FFFF}\",\n-            r\"\\u{1_0__FF___FF_____}\",\n-        ];\n-        for c in &valid {\n-            assert_valid_char(c);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_invalid_unicode_escape() {\n-        let invalid = [\n-            r\"\\u\",\n-            r\"\\u{}\",\n-            r\"\\u{\",\n-            r\"\\u{FF\",\n-            r\"\\u{FFFFFF}\",\n-            r\"\\u{_F}\",\n-            r\"\\u{00FFFFF}\",\n-            r\"\\u{110000}\",\n-        ];\n-        for c in &invalid {\n-            assert_invalid_char(c);\n-        }\n-    }\n-}"}, {"sha": "63f9bad248a3cb2e377648d939a68be24f0c0fe6", "filename": "crates/ra_syntax/src/validation/char.rs", "status": "added", "additions": 270, "deletions": 0, "changes": 270, "blob_url": "https://github.com/rust-lang/rust/blob/477de790b0211196256a772befe4f577d1a8ba14/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/477de790b0211196256a772befe4f577d1a8ba14/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fchar.rs?ref=477de790b0211196256a772befe4f577d1a8ba14", "patch": "@@ -0,0 +1,270 @@\n+use std::u32;\n+\n+use arrayvec::ArrayString;\n+\n+use crate::{\n+    ast::{self, AstNode},\n+    string_lexing::{self, CharComponentKind},\n+    TextRange,\n+    yellow::{\n+        SyntaxError,\n+        SyntaxErrorKind::*,\n+    },\n+};\n+\n+pub(crate) fn validate_char_node(node: ast::Char, errors: &mut Vec<SyntaxError>) {\n+    let literal_text = node.text();\n+    let literal_range = node.syntax().range();\n+    let mut components = string_lexing::parse_char_literal(literal_text);\n+    let mut len = 0;\n+    for component in &mut components {\n+        len += 1;\n+        let text = &literal_text[component.range];\n+        let range = component.range + literal_range.start();\n+        validate_char_component(text, component.kind, range, errors);\n+    }\n+\n+    if !components.has_closing_quote {\n+        errors.push(SyntaxError::new(UnclosedChar, literal_range));\n+    }\n+\n+    if len == 0 {\n+        errors.push(SyntaxError::new(EmptyChar, literal_range));\n+    }\n+\n+    if len > 1 {\n+        errors.push(SyntaxError::new(OverlongChar, literal_range));\n+    }\n+}\n+\n+pub(crate) fn validate_char_component(\n+    text: &str,\n+    kind: CharComponentKind,\n+    range: TextRange,\n+    errors: &mut Vec<SyntaxError>,\n+) {\n+    // Validate escapes\n+    use self::CharComponentKind::*;\n+    match kind {\n+        AsciiEscape => {\n+            if text.len() == 1 {\n+                // Escape sequence consists only of leading `\\`\n+                errors.push(SyntaxError::new(EmptyAsciiEscape, range));\n+            } else {\n+                let escape_code = text.chars().skip(1).next().unwrap();\n+                if !is_ascii_escape(escape_code) {\n+                    errors.push(SyntaxError::new(InvalidAsciiEscape, range));\n+                }\n+            }\n+        }\n+        AsciiCodeEscape => {\n+            // An AsciiCodeEscape has 4 chars, example: `\\xDD`\n+            if text.len() < 4 {\n+                errors.push(SyntaxError::new(TooShortAsciiCodeEscape, range));\n+            } else {\n+                assert!(\n+                    text.chars().count() == 4,\n+                    \"AsciiCodeEscape cannot be longer than 4 chars\"\n+                );\n+\n+                match u8::from_str_radix(&text[2..], 16) {\n+                    Ok(code) if code < 128 => { /* Escape code is valid */ }\n+                    Ok(_) => errors.push(SyntaxError::new(AsciiCodeEscapeOutOfRange, range)),\n+                    Err(_) => errors.push(SyntaxError::new(MalformedAsciiCodeEscape, range)),\n+                }\n+            }\n+        }\n+        UnicodeEscape => {\n+            assert!(&text[..2] == \"\\\\u\", \"UnicodeEscape always starts with \\\\u\");\n+\n+            if text.len() == 2 {\n+                // No starting `{`\n+                errors.push(SyntaxError::new(MalformedUnicodeEscape, range));\n+                return;\n+            }\n+\n+            if text.len() == 3 {\n+                // Only starting `{`\n+                errors.push(SyntaxError::new(UnclosedUnicodeEscape, range));\n+                return;\n+            }\n+\n+            let mut code = ArrayString::<[_; 6]>::new();\n+            let mut closed = false;\n+            for c in text[3..].chars() {\n+                assert!(!closed, \"no characters after escape is closed\");\n+\n+                if c.is_digit(16) {\n+                    if code.len() == 6 {\n+                        errors.push(SyntaxError::new(OverlongUnicodeEscape, range));\n+                        return;\n+                    }\n+\n+                    code.push(c);\n+                } else if c == '_' {\n+                    // Reject leading _\n+                    if code.len() == 0 {\n+                        errors.push(SyntaxError::new(MalformedUnicodeEscape, range));\n+                        return;\n+                    }\n+                } else if c == '}' {\n+                    closed = true;\n+                } else {\n+                    errors.push(SyntaxError::new(MalformedUnicodeEscape, range));\n+                    return;\n+                }\n+            }\n+\n+            if !closed {\n+                errors.push(SyntaxError::new(UnclosedUnicodeEscape, range))\n+            }\n+\n+            if code.len() == 0 {\n+                errors.push(SyntaxError::new(EmptyUnicodeEcape, range));\n+                return;\n+            }\n+\n+            match u32::from_str_radix(&code, 16) {\n+                Ok(code_u32) if code_u32 > 0x10FFFF => {\n+                    errors.push(SyntaxError::new(UnicodeEscapeOutOfRange, range));\n+                }\n+                Ok(_) => {\n+                    // Valid escape code\n+                }\n+                Err(_) => {\n+                    errors.push(SyntaxError::new(MalformedUnicodeEscape, range));\n+                }\n+            }\n+        }\n+        CodePoint => {\n+            // These code points must always be escaped\n+            if text == \"\\t\" || text == \"\\r\" {\n+                errors.push(SyntaxError::new(UnescapedCodepoint, range));\n+            }\n+        }\n+    }\n+}\n+\n+fn is_ascii_escape(code: char) -> bool {\n+    match code {\n+        '\\\\' | '\\'' | '\"' | 'n' | 'r' | 't' | '0' => true,\n+        _ => false,\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use crate::SourceFileNode;\n+\n+    fn build_file(literal: &str) -> SourceFileNode {\n+        let src = format!(\"const C: char = '{}';\", literal);\n+        SourceFileNode::parse(&src)\n+    }\n+\n+    fn assert_valid_char(literal: &str) {\n+        let file = build_file(literal);\n+        assert!(\n+            file.errors().len() == 0,\n+            \"Errors for literal '{}': {:?}\",\n+            literal,\n+            file.errors()\n+        );\n+    }\n+\n+    fn assert_invalid_char(literal: &str) {\n+        let file = build_file(literal);\n+        assert!(file.errors().len() > 0);\n+    }\n+\n+    #[test]\n+    fn test_ansi_codepoints() {\n+        for byte in 0..=255u8 {\n+            match byte {\n+                b'\\n' | b'\\r' | b'\\t' => assert_invalid_char(&(byte as char).to_string()),\n+                b'\\'' | b'\\\\' => { /* Ignore character close and backslash */ }\n+                _ => assert_valid_char(&(byte as char).to_string()),\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_unicode_codepoints() {\n+        let valid = [\"\u0191\", \"\u30d0\", \"\u30e1\", \"\ufdfd\"];\n+        for c in &valid {\n+            assert_valid_char(c);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_unicode_multiple_codepoints() {\n+        let invalid = [\"\u0928\u0940\", \"\ud83d\udc68\u200d\ud83d\udc68\u200d\"];\n+        for c in &invalid {\n+            assert_invalid_char(c);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_valid_ascii_escape() {\n+        let valid = [\n+            r\"\\'\", \"\\\"\", \"\\\\\\\\\", \"\\\\\\\"\", r\"\\n\", r\"\\r\", r\"\\t\", r\"\\0\", \"a\", \"b\",\n+        ];\n+        for c in &valid {\n+            assert_valid_char(c);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_invalid_ascii_escape() {\n+        let invalid = [r\"\\a\", r\"\\?\", r\"\\\"];\n+        for c in &invalid {\n+            assert_invalid_char(c);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_valid_ascii_code_escape() {\n+        let valid = [r\"\\x00\", r\"\\x7F\", r\"\\x55\"];\n+        for c in &valid {\n+            assert_valid_char(c);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_invalid_ascii_code_escape() {\n+        let invalid = [r\"\\x\", r\"\\x7\", r\"\\xF0\"];\n+        for c in &invalid {\n+            assert_invalid_char(c);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_valid_unicode_escape() {\n+        let valid = [\n+            r\"\\u{FF}\",\n+            r\"\\u{0}\",\n+            r\"\\u{F}\",\n+            r\"\\u{10FFFF}\",\n+            r\"\\u{1_0__FF___FF_____}\",\n+        ];\n+        for c in &valid {\n+            assert_valid_char(c);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_invalid_unicode_escape() {\n+        let invalid = [\n+            r\"\\u\",\n+            r\"\\u{}\",\n+            r\"\\u{\",\n+            r\"\\u{FF\",\n+            r\"\\u{FFFFFF}\",\n+            r\"\\u{_F}\",\n+            r\"\\u{00FFFFF}\",\n+            r\"\\u{110000}\",\n+        ];\n+        for c in &invalid {\n+            assert_invalid_char(c);\n+        }\n+    }\n+}"}, {"sha": "2ff0bc26d321f817623ab38e591cdc87073a7bc6", "filename": "crates/ra_syntax/src/validation/mod.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/477de790b0211196256a772befe4f577d1a8ba14/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/477de790b0211196256a772befe4f577d1a8ba14/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fmod.rs?ref=477de790b0211196256a772befe4f577d1a8ba14", "patch": "@@ -0,0 +1,20 @@\n+use crate::{\n+    algo::visit::{visitor_ctx, VisitorCtx},\n+    ast,\n+    SourceFileNode,\n+    yellow::SyntaxError,\n+};\n+\n+mod char;\n+mod string;\n+\n+pub(crate) fn validate(file: &SourceFileNode) -> Vec<SyntaxError> {\n+    let mut errors = Vec::new();\n+    for node in file.syntax().descendants() {\n+        let _ = visitor_ctx(&mut errors)\n+            .visit::<ast::Char, _>(self::char::validate_char_node)\n+            .visit::<ast::String, _>(self::string::validate_string_node)\n+            .accept(node);\n+    }\n+    errors\n+}"}, {"sha": "089879d1530748b2e412ae6ad1c235c9ec54c24a", "filename": "crates/ra_syntax/src/validation/string.rs", "status": "added", "additions": 168, "deletions": 0, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/477de790b0211196256a772befe4f577d1a8ba14/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/477de790b0211196256a772befe4f577d1a8ba14/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fstring.rs?ref=477de790b0211196256a772befe4f577d1a8ba14", "patch": "@@ -0,0 +1,168 @@\n+use crate::{\n+    ast::{self, AstNode},\n+    string_lexing::{self, StringComponentKind},\n+    yellow::{\n+        SyntaxError,\n+        SyntaxErrorKind::*,\n+    },\n+};\n+\n+use super::char;\n+\n+pub(crate) fn validate_string_node(node: ast::String, errors: &mut Vec<SyntaxError>) {\n+    let literal_text = node.text();\n+    let literal_range = node.syntax().range();\n+    let mut components = string_lexing::parse_string_literal(literal_text);\n+    for component in &mut components {\n+        let range = component.range + literal_range.start();\n+\n+        match component.kind {\n+            StringComponentKind::Char(kind) => {\n+                // Chars must escape \\t, \\n and \\r codepoints, but strings don't\n+                let text = &literal_text[component.range];\n+                match text {\n+                    \"\\t\" | \"\\n\" | \"\\r\" => { /* always valid */ }\n+                    _ => char::validate_char_component(text, kind, range, errors),\n+                }\n+            }\n+            StringComponentKind::IgnoreNewline => { /* always valid */ }\n+        }\n+    }\n+\n+    if !components.has_closing_quote {\n+        errors.push(SyntaxError::new(UnclosedString, literal_range));\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use crate::SourceFileNode;\n+\n+    fn build_file(literal: &str) -> SourceFileNode {\n+        let src = format!(r#\"const S: &'static str = \"{}\";\"#, literal);\n+        println!(\"Source: {}\", src);\n+        SourceFileNode::parse(&src)\n+    }\n+\n+    fn assert_valid_str(literal: &str) {\n+        let file = build_file(literal);\n+        assert!(\n+            file.errors().len() == 0,\n+            \"Errors for literal '{}': {:?}\",\n+            literal,\n+            file.errors()\n+        );\n+    }\n+\n+    fn assert_invalid_str(literal: &str) {\n+        let file = build_file(literal);\n+        assert!(file.errors().len() > 0);\n+    }\n+\n+    #[test]\n+    fn test_ansi_codepoints() {\n+        for byte in 0..=255u8 {\n+            match byte {\n+                b'\\\"' | b'\\\\' => { /* Ignore string close and backslash */ }\n+                _ => assert_valid_str(&(byte as char).to_string()),\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_unicode_codepoints() {\n+        let valid = [\"\u0191\", \"\u30d0\", \"\u30e1\", \"\ufdfd\"];\n+        for c in &valid {\n+            assert_valid_str(c);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_unicode_multiple_codepoints() {\n+        let valid = [\"\u0928\u0940\", \"\ud83d\udc68\u200d\ud83d\udc68\u200d\"];\n+        for c in &valid {\n+            assert_valid_str(c);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_valid_ascii_escape() {\n+        let valid = [r\"\\'\", r#\"\\\"\"#, r\"\\\\\", r\"\\n\", r\"\\r\", r\"\\t\", r\"\\0\", \"a\", \"b\"];\n+        for c in &valid {\n+            assert_valid_str(c);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_invalid_ascii_escape() {\n+        let invalid = [r\"\\a\", r\"\\?\", r\"\\\"];\n+        for c in &invalid {\n+            assert_invalid_str(c);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_valid_ascii_code_escape() {\n+        let valid = [r\"\\x00\", r\"\\x7F\", r\"\\x55\"];\n+        for c in &valid {\n+            assert_valid_str(c);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_invalid_ascii_code_escape() {\n+        let invalid = [r\"\\x\", r\"\\x7\", r\"\\xF0\"];\n+        for c in &invalid {\n+            assert_invalid_str(c);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_valid_unicode_escape() {\n+        let valid = [\n+            r\"\\u{FF}\",\n+            r\"\\u{0}\",\n+            r\"\\u{F}\",\n+            r\"\\u{10FFFF}\",\n+            r\"\\u{1_0__FF___FF_____}\",\n+        ];\n+        for c in &valid {\n+            assert_valid_str(c);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_invalid_unicode_escape() {\n+        let invalid = [\n+            r\"\\u\",\n+            r\"\\u{}\",\n+            r\"\\u{\",\n+            r\"\\u{FF\",\n+            r\"\\u{FFFFFF}\",\n+            r\"\\u{_F}\",\n+            r\"\\u{00FFFFF}\",\n+            r\"\\u{110000}\",\n+        ];\n+        for c in &invalid {\n+            assert_invalid_str(c);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_mixed() {\n+        assert_valid_str(\n+            r\"This is the tale of a string\n+with a newline in between, some emoji (\ud83d\udc68\u200d\ud83d\udc68\u200d) here and there,\n+unicode escapes like this: \\u{1FFBB} and weird stuff like\n+this \ufdfd\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_ignore_newline() {\n+        assert_valid_str(\n+            \"Hello \\\n+             World\",\n+        );\n+    }\n+}"}, {"sha": "cf7b1d495c8653bb36a7ea8f9733ab2bd29a1dd7", "filename": "crates/ra_syntax/src/yellow/syntax_error.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/477de790b0211196256a772befe4f577d1a8ba14/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fsyntax_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/477de790b0211196256a772befe4f577d1a8ba14/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fsyntax_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fsyntax_error.rs?ref=477de790b0211196256a772befe4f577d1a8ba14", "patch": "@@ -71,7 +71,7 @@ pub enum SyntaxErrorKind {\n     UnescapedCodepoint,\n     EmptyChar,\n     UnclosedChar,\n-    LongChar,\n+    OverlongChar,\n     EmptyAsciiEscape,\n     InvalidAsciiEscape,\n     TooShortAsciiCodeEscape,\n@@ -82,6 +82,7 @@ pub enum SyntaxErrorKind {\n     EmptyUnicodeEcape,\n     OverlongUnicodeEscape,\n     UnicodeEscapeOutOfRange,\n+    UnclosedString,\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -96,7 +97,7 @@ impl fmt::Display for SyntaxErrorKind {\n             InvalidAsciiEscape => write!(f, \"Invalid escape sequence\"),\n             EmptyChar => write!(f, \"Empty char literal\"),\n             UnclosedChar => write!(f, \"Unclosed char literal\"),\n-            LongChar => write!(f, \"Char literal should be one character long\"),\n+            OverlongChar => write!(f, \"Char literal should be one character long\"),\n             TooShortAsciiCodeEscape => write!(f, \"Escape sequence should have two digits\"),\n             AsciiCodeEscapeOutOfRange => {\n                 write!(f, \"Escape sequence should be between \\\\x00 and \\\\x7F\")\n@@ -109,6 +110,7 @@ impl fmt::Display for SyntaxErrorKind {\n                 write!(f, \"Unicode escape sequence should have at most 6 digits\")\n             }\n             UnicodeEscapeOutOfRange => write!(f, \"Unicode escape code should be at most 0x10FFFF\"),\n+            UnclosedString => write!(f, \"Unclosed string literal\"),\n             ParseError(msg) => write!(f, \"{}\", msg.0),\n         }\n     }"}]}