{"sha": "a209b4f447b528362354edfd78aa96349633dc17", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyMDliNGY0NDdiNTI4MzYyMzU0ZWRmZDc4YWE5NjM0OTYzM2RjMTc=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-04-09T03:29:40Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-09T03:29:40Z"}, "message": "Rollup merge of #70822 - jonas-schievink:curse-of-the-recursion, r=ecstatic-morse\n\nDon't lint for self-recursion when the function can diverge\n\nFixes https://github.com/rust-lang/rust/issues/54444", "tree": {"sha": "509e31e4c92762c090aa0742e1607cd57fe00512", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/509e31e4c92762c090aa0742e1607cd57fe00512"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a209b4f447b528362354edfd78aa96349633dc17", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJejpakCRBK7hj4Ov3rIwAAdHIIAInsuPuXHFfdSH4bKryvzbk8\nKDnpsdGrZTyH8eR+3Yf9ylPLxTRpsDwAOzW4+YptNik9xvtLGC8Rx88JpZjF2W49\nx5nz86yedarHqWGPeqIFRhs5KnAti48CkK+gcaBVO/sWFWXFeJ5CoYOz45861HTK\nf6K8PBqGL/p1FMfli+Q8uqxHCTf6z8EYjAsnJUpAKfpZvpeEzuf90ddoQY1pO8Md\neX6GIL30S/s36TyAChCuvo2DtJ6aKTbE/3tB0JgLbtmjRQ2c097SzayPmNtdwdqr\nFQPLImjfA81viCO9fFJ/d9JKDBfT4AUbDB+8ilR9bn+E9bvdPzOg8IKAYXB+V18=\n=M8KI\n-----END PGP SIGNATURE-----\n", "payload": "tree 509e31e4c92762c090aa0742e1607cd57fe00512\nparent ba50bc588e36a06a7b42970366534946beea5ce9\nparent b8f416d67ff77d6eb71902895b59abbfb50737db\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1586402980 +0200\ncommitter GitHub <noreply@github.com> 1586402980 +0200\n\nRollup merge of #70822 - jonas-schievink:curse-of-the-recursion, r=ecstatic-morse\n\nDon't lint for self-recursion when the function can diverge\n\nFixes https://github.com/rust-lang/rust/issues/54444\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a209b4f447b528362354edfd78aa96349633dc17", "html_url": "https://github.com/rust-lang/rust/commit/a209b4f447b528362354edfd78aa96349633dc17", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a209b4f447b528362354edfd78aa96349633dc17/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ba50bc588e36a06a7b42970366534946beea5ce9", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba50bc588e36a06a7b42970366534946beea5ce9", "html_url": "https://github.com/rust-lang/rust/commit/ba50bc588e36a06a7b42970366534946beea5ce9"}, {"sha": "b8f416d67ff77d6eb71902895b59abbfb50737db", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8f416d67ff77d6eb71902895b59abbfb50737db", "html_url": "https://github.com/rust-lang/rust/commit/b8f416d67ff77d6eb71902895b59abbfb50737db"}], "stats": {"total": 249, "additions": 152, "deletions": 97}, "files": [{"sha": "6e1a4ecf47a44e98ebb7f5cfb643aa041cf68653", "filename": "src/librustc_mir_build/build/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a209b4f447b528362354edfd78aa96349633dc17/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a209b4f447b528362354edfd78aa96349633dc17/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs?ref=a209b4f447b528362354edfd78aa96349633dc17", "patch": "@@ -178,11 +178,11 @@ fn mir_build(tcx: TyCtxt<'_>, def_id: DefId) -> BodyAndCache<'_> {\n             build::construct_const(cx, body_id, return_ty, return_ty_span)\n         };\n \n-        lints::check(tcx, &body, def_id);\n-\n         let mut body = BodyAndCache::new(body);\n         body.ensure_predecessors();\n \n+        lints::check(tcx, &body.unwrap_read_only(), def_id);\n+\n         // The borrow checker will replace all the regions here with its own\n         // inference variables. There's no point having non-erased regions here.\n         // The exception is `body.user_type_annotations`, which is used unmodified"}, {"sha": "a7370c36f0b9f85b1b0efc039016b60ab68f1c36", "filename": "src/librustc_mir_build/lints.rs", "status": "modified", "additions": 132, "deletions": 95, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/a209b4f447b528362354edfd78aa96349633dc17/src%2Flibrustc_mir_build%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a209b4f447b528362354edfd78aa96349633dc17/src%2Flibrustc_mir_build%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Flints.rs?ref=a209b4f447b528362354edfd78aa96349633dc17", "patch": "@@ -1,138 +1,175 @@\n use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::FnKind;\n use rustc_index::bit_set::BitSet;\n+use rustc_index::vec::IndexVec;\n use rustc_middle::hir::map::blocks::FnLikeNode;\n-use rustc_middle::mir::{self, Body, TerminatorKind};\n+use rustc_middle::mir::{BasicBlock, Body, ReadOnlyBodyAndCache, TerminatorKind, START_BLOCK};\n use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::{self, AssocItem, AssocItemContainer, Instance, TyCtxt};\n use rustc_session::lint::builtin::UNCONDITIONAL_RECURSION;\n+use std::collections::VecDeque;\n \n-crate fn check<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>, def_id: DefId) {\n+crate fn check<'tcx>(tcx: TyCtxt<'tcx>, body: &ReadOnlyBodyAndCache<'_, 'tcx>, def_id: DefId) {\n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n \n     if let Some(fn_like_node) = FnLikeNode::from_node(tcx.hir().get(hir_id)) {\n-        check_fn_for_unconditional_recursion(tcx, fn_like_node.kind(), body, def_id);\n+        if let FnKind::Closure(_) = fn_like_node.kind() {\n+            // closures can't recur, so they don't matter.\n+            return;\n+        }\n+\n+        check_fn_for_unconditional_recursion(tcx, body, def_id);\n     }\n }\n \n fn check_fn_for_unconditional_recursion<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    fn_kind: FnKind<'_>,\n-    body: &Body<'tcx>,\n+    body: &ReadOnlyBodyAndCache<'_, 'tcx>,\n     def_id: DefId,\n ) {\n-    if let FnKind::Closure(_) = fn_kind {\n-        // closures can't recur, so they don't matter.\n-        return;\n-    }\n+    let self_calls = find_blocks_calling_self(tcx, &body, def_id);\n \n-    //FIXME(#54444) rewrite this lint to use the dataflow framework\n-\n-    // Walk through this function (say `f`) looking to see if\n-    // every possible path references itself, i.e., the function is\n-    // called recursively unconditionally. This is done by trying\n-    // to find a path from the entry node to the exit node that\n-    // *doesn't* call `f` by traversing from the entry while\n-    // pretending that calls of `f` are sinks (i.e., ignoring any\n-    // exit edges from them).\n-    //\n-    // NB. this has an edge case with non-returning statements,\n-    // like `loop {}` or `panic!()`: control flow never reaches\n-    // the exit node through these, so one can have a function\n-    // that never actually calls itself but is still picked up by\n-    // this lint:\n-    //\n-    //     fn f(cond: bool) {\n-    //         if !cond { panic!() } // could come from `assert!(cond)`\n-    //         f(false)\n-    //     }\n-    //\n-    // In general, functions of that form may be able to call\n-    // itself a finite number of times and then diverge. The lint\n-    // considers this to be an error for two reasons, (a) it is\n-    // easier to implement, and (b) it seems rare to actually want\n-    // to have behaviour like the above, rather than\n-    // e.g., accidentally recursing after an assert.\n-\n-    let basic_blocks = body.basic_blocks();\n-    let mut reachable_without_self_call_queue = vec![mir::START_BLOCK];\n-    let mut reached_exit_without_self_call = false;\n-    let mut self_call_locations = vec![];\n-    let mut visited = BitSet::new_empty(basic_blocks.len());\n+    // Stores a list of `Span`s for every basic block. Those are the spans of self-calls where we\n+    // know that one of them will definitely be reached. If the list is empty, the block either\n+    // wasn't processed yet or will not always go to a self-call.\n+    let mut results = IndexVec::from_elem_n(vec![], body.basic_blocks().len());\n \n-    let param_env = tcx.param_env(def_id);\n-    let trait_substs_count = match tcx.opt_associated_item(def_id) {\n-        Some(AssocItem { container: AssocItemContainer::TraitContainer(trait_def_id), .. }) => {\n-            tcx.generics_of(trait_def_id).count()\n-        }\n-        _ => 0,\n-    };\n-    let caller_substs = &InternalSubsts::identity_for_item(tcx, def_id)[..trait_substs_count];\n+    // We start the analysis at the self calls and work backwards.\n+    let mut queue: VecDeque<_> = self_calls.iter().collect();\n \n-    while let Some(bb) = reachable_without_self_call_queue.pop() {\n-        if !visited.insert(bb) {\n-            //already done\n+    while let Some(bb) = queue.pop_front() {\n+        if !results[bb].is_empty() {\n+            // Already propagated.\n             continue;\n         }\n \n-        let block = &basic_blocks[bb];\n-\n-        if let Some(ref terminator) = block.terminator {\n-            match terminator.kind {\n-                TerminatorKind::Call { ref func, .. } => {\n-                    let func_ty = func.ty(body, tcx);\n-\n-                    if let ty::FnDef(fn_def_id, substs) = func_ty.kind {\n-                        let (call_fn_id, call_substs) = if let Some(instance) =\n-                            Instance::resolve(tcx, param_env, fn_def_id, substs)\n-                        {\n-                            (instance.def_id(), instance.substs)\n-                        } else {\n-                            (fn_def_id, substs)\n-                        };\n-\n-                        let is_self_call = call_fn_id == def_id\n-                            && &call_substs[..caller_substs.len()] == caller_substs;\n-\n-                        if is_self_call {\n-                            self_call_locations.push(terminator.source_info);\n-\n-                            //this is a self call so we shouldn't explore\n-                            //further down this path\n-                            continue;\n-                        }\n-                    }\n+        let locations = if self_calls.contains(bb) {\n+            // `bb` *is* a self-call.\n+            // We don't look at successors here because they are irrelevant here and we don't want\n+            // to lint them (eg. `f(); f()` should only lint the first call).\n+            vec![bb]\n+        } else {\n+            // If *all* successors of `bb` lead to a self-call, emit notes at all of their\n+            // locations.\n+\n+            // Determine all \"relevant\" successors. We ignore successors only reached via unwinding.\n+            let terminator = body[bb].terminator();\n+            let relevant_successors = match &terminator.kind {\n+                TerminatorKind::Call { destination: None, .. }\n+                | TerminatorKind::Yield { .. }\n+                | TerminatorKind::GeneratorDrop => None.into_iter().chain(&[]),\n+                TerminatorKind::SwitchInt { targets, .. } => None.into_iter().chain(targets),\n+                TerminatorKind::Goto { target }\n+                | TerminatorKind::Drop { target, .. }\n+                | TerminatorKind::DropAndReplace { target, .. }\n+                | TerminatorKind::Assert { target, .. }\n+                | TerminatorKind::FalseEdges { real_target: target, .. }\n+                | TerminatorKind::FalseUnwind { real_target: target, .. }\n+                | TerminatorKind::Call { destination: Some((_, target)), .. } => {\n+                    Some(target).into_iter().chain(&[])\n                 }\n-                TerminatorKind::Abort | TerminatorKind::Return => {\n-                    //found a path!\n-                    reached_exit_without_self_call = true;\n-                    break;\n+                TerminatorKind::Resume\n+                | TerminatorKind::Abort\n+                | TerminatorKind::Return\n+                | TerminatorKind::Unreachable => {\n+                    // We propagate backwards, so these should never be encountered here.\n+                    unreachable!(\"unexpected terminator {:?}\", terminator.kind)\n                 }\n-                _ => {}\n+            };\n+\n+            // If all our successors are known to lead to self-calls, then we do too.\n+            let all_are_self_calls =\n+                relevant_successors.clone().all(|&succ| !results[succ].is_empty());\n+\n+            if all_are_self_calls {\n+                // We'll definitely lead to a self-call. Merge all call locations of the successors\n+                // for linting them later.\n+                relevant_successors.flat_map(|&succ| results[succ].iter().copied()).collect()\n+            } else {\n+                // At least 1 successor does not always lead to a self-call, so we also don't.\n+                vec![]\n             }\n+        };\n \n-            for successor in terminator.successors() {\n-                reachable_without_self_call_queue.push(*successor);\n-            }\n+        if !locations.is_empty() {\n+            // This is a newly confirmed-to-always-reach-self-call block.\n+            results[bb] = locations;\n+\n+            // Propagate backwards through the CFG.\n+            debug!(\"propagate loc={:?} in {:?} -> {:?}\", results[bb], bb, body.predecessors()[bb]);\n+            queue.extend(body.predecessors()[bb].iter().copied());\n         }\n     }\n \n-    // Check the number of self calls because a function that\n-    // doesn't return (e.g., calls a `-> !` function or `loop { /*\n-    // no break */ }`) shouldn't be linted unless it actually\n-    // recurs.\n-    if !reached_exit_without_self_call && !self_call_locations.is_empty() {\n+    debug!(\"unconditional recursion results: {:?}\", results);\n+\n+    let self_call_locations = &mut results[START_BLOCK];\n+    self_call_locations.sort();\n+    self_call_locations.dedup();\n+\n+    if !self_call_locations.is_empty() {\n         let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n         let sp = tcx.sess.source_map().guess_head_span(tcx.hir().span(hir_id));\n         tcx.struct_span_lint_hir(UNCONDITIONAL_RECURSION, hir_id, sp, |lint| {\n             let mut db = lint.build(\"function cannot return without recursing\");\n             db.span_label(sp, \"cannot return without recursing\");\n             // offer some help to the programmer.\n-            for location in &self_call_locations {\n-                db.span_label(location.span, \"recursive call site\");\n+            for bb in self_call_locations {\n+                let span = body.basic_blocks()[*bb].terminator().source_info.span;\n+                db.span_label(span, \"recursive call site\");\n             }\n             db.help(\"a `loop` may express intention better if this is on purpose\");\n             db.emit();\n         });\n     }\n }\n+\n+/// Finds blocks with `Call` terminators that would end up calling back into the same method.\n+fn find_blocks_calling_self<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    body: &Body<'tcx>,\n+    def_id: DefId,\n+) -> BitSet<BasicBlock> {\n+    let param_env = tcx.param_env(def_id);\n+\n+    // If this is trait/impl method, extract the trait's substs.\n+    let trait_substs_count = match tcx.opt_associated_item(def_id) {\n+        Some(AssocItem { container: AssocItemContainer::TraitContainer(trait_def_id), .. }) => {\n+            tcx.generics_of(trait_def_id).count()\n+        }\n+        _ => 0,\n+    };\n+    let trait_substs = &InternalSubsts::identity_for_item(tcx, def_id)[..trait_substs_count];\n+\n+    let mut self_calls = BitSet::new_empty(body.basic_blocks().len());\n+\n+    for (bb, data) in body.basic_blocks().iter_enumerated() {\n+        if let TerminatorKind::Call { func, .. } = &data.terminator().kind {\n+            let func_ty = func.ty(body, tcx);\n+\n+            if let ty::FnDef(fn_def_id, substs) = func_ty.kind {\n+                let (call_fn_id, call_substs) =\n+                    if let Some(instance) = Instance::resolve(tcx, param_env, fn_def_id, substs) {\n+                        (instance.def_id(), instance.substs)\n+                    } else {\n+                        (fn_def_id, substs)\n+                    };\n+\n+                // FIXME(#57965): Make this work across function boundaries\n+\n+                // If this is a trait fn, the substs on the trait have to match, or we might be\n+                // calling into an entirely different method (for example, a call from the default\n+                // method in the trait to `<A as Trait<B>>::method`, where `A` and/or `B` are\n+                // specific types).\n+                let is_self_call =\n+                    call_fn_id == def_id && &call_substs[..trait_substs.len()] == trait_substs;\n+\n+                if is_self_call {\n+                    self_calls.insert(bb);\n+                }\n+            }\n+        }\n+    }\n+\n+    self_calls\n+}"}, {"sha": "d2a0329585b71b0d9302f8fafe51d78d5692d4b8", "filename": "src/test/ui/lint/lint-unconditional-recursion.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a209b4f447b528362354edfd78aa96349633dc17/src%2Ftest%2Fui%2Flint%2Flint-unconditional-recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a209b4f447b528362354edfd78aa96349633dc17/src%2Ftest%2Fui%2Flint%2Flint-unconditional-recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-unconditional-recursion.rs?ref=a209b4f447b528362354edfd78aa96349633dc17", "patch": "@@ -131,4 +131,22 @@ trait Bar {\n     }\n }\n \n+// Do not trigger on functions that may diverge instead of self-recursing (#54444)\n+\n+pub fn loops(x: bool) {\n+    if x {\n+        loops(x);\n+    } else {\n+        loop {}\n+    }\n+}\n+\n+pub fn panics(x: bool) {\n+    if x {\n+        panics(!x);\n+    } else {\n+        panic!(\"panics\");\n+    }\n+}\n+\n fn main() {}"}]}