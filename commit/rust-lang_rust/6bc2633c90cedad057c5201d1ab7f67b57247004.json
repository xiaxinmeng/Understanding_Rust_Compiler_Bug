{"sha": "6bc2633c90cedad057c5201d1ab7f67b57247004", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiYzI2MzNjOTBjZWRhZDA1N2M1MjAxZDFhYjdmNjdiNTcyNDcwMDQ=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-08-13T15:58:35Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-08-13T15:59:27Z"}, "message": "Align parser names with grammar", "tree": {"sha": "4293492e643f9a604c5f30e051289bcea182694c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4293492e643f9a604c5f30e051289bcea182694c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6bc2633c90cedad057c5201d1ab7f67b57247004", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6bc2633c90cedad057c5201d1ab7f67b57247004", "html_url": "https://github.com/rust-lang/rust/commit/6bc2633c90cedad057c5201d1ab7f67b57247004", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6bc2633c90cedad057c5201d1ab7f67b57247004/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1b0c7701cc97cd7bef8bb9729011d4cf291a60c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b0c7701cc97cd7bef8bb9729011d4cf291a60c5", "html_url": "https://github.com/rust-lang/rust/commit/1b0c7701cc97cd7bef8bb9729011d4cf291a60c5"}], "stats": {"total": 347, "additions": 124, "deletions": 223}, "files": [{"sha": "562e92252b2a40d9561270a11d883952eea00189", "filename": "crates/parser/src/grammar.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6bc2633c90cedad057c5201d1ab7f67b57247004/crates%2Fparser%2Fsrc%2Fgrammar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bc2633c90cedad057c5201d1ab7f67b57247004/crates%2Fparser%2Fsrc%2Fgrammar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar.rs?ref=6bc2633c90cedad057c5201d1ab7f67b57247004", "patch": "@@ -142,19 +142,19 @@ pub(crate) fn reparser(\n ) -> Option<fn(&mut Parser)> {\n     let res = match node {\n         BLOCK_EXPR => expressions::block_expr,\n-        RECORD_FIELD_LIST => items::record_field_def_list,\n-        RECORD_EXPR_FIELD_LIST => items::record_field_list,\n-        VARIANT_LIST => items::enum_variant_list,\n+        RECORD_FIELD_LIST => items::record_field_list,\n+        RECORD_EXPR_FIELD_LIST => items::record_expr_field_list,\n+        VARIANT_LIST => items::variant_list,\n         MATCH_ARM_LIST => items::match_arm_list,\n         USE_TREE_LIST => items::use_tree_list,\n         EXTERN_ITEM_LIST => items::extern_item_list,\n         TOKEN_TREE if first_child? == T!['{'] => items::token_tree,\n         ASSOC_ITEM_LIST => match parent? {\n-            IMPL => items::impl_item_list,\n-            TRAIT => items::trait_item_list,\n+            IMPL => items::assoc_item_list,\n+            TRAIT => items::assoc_item_list,\n             _ => return None,\n         },\n-        ITEM_LIST => items::mod_item_list,\n+        ITEM_LIST => items::item_list,\n         _ => return None,\n     };\n     Some(res)\n@@ -217,7 +217,7 @@ fn opt_visibility(p: &mut Parser) -> bool {\n     true\n }\n \n-fn opt_alias(p: &mut Parser) {\n+fn opt_rename(p: &mut Parser) {\n     if p.at(T![as]) {\n         let m = p.start();\n         p.bump(T![as]);\n@@ -239,7 +239,7 @@ fn abi(p: &mut Parser) {\n     abi.complete(p, ABI);\n }\n \n-fn opt_fn_ret_type(p: &mut Parser) -> bool {\n+fn opt_ret_type(p: &mut Parser) -> bool {\n     if p.at(T![->]) {\n         let m = p.start();\n         p.bump(T![->]);"}, {"sha": "dab0f62c3caaf6fcea791cddeac9e585e1b1bdf7", "filename": "crates/parser/src/grammar/attributes.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6bc2633c90cedad057c5201d1ab7f67b57247004/crates%2Fparser%2Fsrc%2Fgrammar%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bc2633c90cedad057c5201d1ab7f67b57247004/crates%2Fparser%2Fsrc%2Fgrammar%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fattributes.rs?ref=6bc2633c90cedad057c5201d1ab7f67b57247004", "patch": "@@ -2,19 +2,19 @@\n \n use super::*;\n \n-pub(super) fn inner_attributes(p: &mut Parser) {\n+pub(super) fn inner_attrs(p: &mut Parser) {\n     while p.at(T![#]) && p.nth(1) == T![!] {\n-        attribute(p, true)\n+        attr(p, true)\n     }\n }\n \n-pub(super) fn outer_attributes(p: &mut Parser) {\n+pub(super) fn outer_attrs(p: &mut Parser) {\n     while p.at(T![#]) {\n-        attribute(p, false)\n+        attr(p, false)\n     }\n }\n \n-fn attribute(p: &mut Parser, inner: bool) {\n+fn attr(p: &mut Parser, inner: bool) {\n     let attr = p.start();\n     assert!(p.at(T![#]));\n     p.bump(T![#]);"}, {"sha": "e72929f8ccdab3d0dec31b97a22e0cd2cb9cc48c", "filename": "crates/parser/src/grammar/expressions.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6bc2633c90cedad057c5201d1ab7f67b57247004/crates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bc2633c90cedad057c5201d1ab7f67b57247004/crates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions.rs?ref=6bc2633c90cedad057c5201d1ab7f67b57247004", "patch": "@@ -22,7 +22,7 @@ pub(super) fn expr(p: &mut Parser) -> (Option<CompletedMarker>, BlockLike) {\n pub(super) fn expr_with_attrs(p: &mut Parser) -> bool {\n     let m = p.start();\n     let has_attrs = p.at(T![#]);\n-    attributes::outer_attributes(p);\n+    attributes::outer_attrs(p);\n \n     let (cm, _block_like) = expr(p);\n     let success = cm.is_some();\n@@ -64,7 +64,7 @@ pub(super) fn stmt(p: &mut Parser, with_semi: StmtWithSemi) {\n     //     #[D] return ();\n     // }\n     let has_attrs = p.at(T![#]);\n-    attributes::outer_attributes(p);\n+    attributes::outer_attrs(p);\n \n     if p.at(T![let]) {\n         let_stmt(p, m, with_semi);\n@@ -175,7 +175,7 @@ pub(super) fn stmt(p: &mut Parser, with_semi: StmtWithSemi) {\n \n pub(super) fn expr_block_contents(p: &mut Parser) {\n     // This is checked by a validator\n-    attributes::inner_attributes(p);\n+    attributes::inner_attrs(p);\n \n     while !p.at(EOF) && !p.at(T!['}']) {\n         // test nocontentexpr\n@@ -489,7 +489,7 @@ fn method_call_expr(p: &mut Parser, lhs: CompletedMarker) -> CompletedMarker {\n     let m = lhs.precede(p);\n     p.bump_any();\n     name_ref(p);\n-    type_args::opt_type_arg_list(p, true);\n+    type_args::opt_generic_arg_list(p, true);\n     if p.at(T!['(']) {\n         arg_list(p);\n     }\n@@ -585,7 +585,7 @@ fn path_expr(p: &mut Parser, r: Restrictions) -> (CompletedMarker, BlockLike) {\n     paths::expr_path(p);\n     match p.current() {\n         T!['{'] if !r.forbid_structs => {\n-            record_field_list(p);\n+            record_expr_field_list(p);\n             (m.complete(p, RECORD_EXPR), BlockLike::NotBlock)\n         }\n         T![!] if !p.at(T![!=]) => {\n@@ -603,7 +603,7 @@ fn path_expr(p: &mut Parser, r: Restrictions) -> (CompletedMarker, BlockLike) {\n //     S { x, y: 32, ..Default::default() };\n //     TupleStruct { 0: 1 };\n // }\n-pub(crate) fn record_field_list(p: &mut Parser) {\n+pub(crate) fn record_expr_field_list(p: &mut Parser) {\n     assert!(p.at(T!['{']));\n     let m = p.start();\n     p.bump(T!['{']);\n@@ -613,7 +613,7 @@ pub(crate) fn record_field_list(p: &mut Parser) {\n         // fn main() {\n         //     S { #[cfg(test)] field: 1 }\n         // }\n-        attributes::outer_attributes(p);\n+        attributes::outer_attrs(p);\n \n         match p.current() {\n             IDENT | INT_NUMBER => {"}, {"sha": "ba6dd2fbcc4681944f039a321b5109cad9f0b054", "filename": "crates/parser/src/grammar/expressions/atom.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6bc2633c90cedad057c5201d1ab7f67b57247004/crates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bc2633c90cedad057c5201d1ab7f67b57247004/crates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs?ref=6bc2633c90cedad057c5201d1ab7f67b57247004", "patch": "@@ -75,9 +75,9 @@ pub(super) fn atom_expr(p: &mut Parser, r: Restrictions) -> Option<(CompletedMar\n         T!['('] => tuple_expr(p),\n         T!['['] => array_expr(p),\n         L_DOLLAR => meta_var_expr(p),\n-        T![|] => lambda_expr(p),\n-        T![move] if la == T![|] => lambda_expr(p),\n-        T![async] if la == T![|] || (la == T![move] && p.nth(2) == T![|]) => lambda_expr(p),\n+        T![|] => closure_expr(p),\n+        T![move] if la == T![|] => closure_expr(p),\n+        T![async] if la == T![|] || (la == T![move] && p.nth(2) == T![|]) => closure_expr(p),\n         T![if] => if_expr(p),\n \n         T![loop] => loop_expr(p, None),\n@@ -228,7 +228,7 @@ fn array_expr(p: &mut Parser) -> CompletedMarker {\n //     move || {};\n //     async move || {};\n // }\n-fn lambda_expr(p: &mut Parser) -> CompletedMarker {\n+fn closure_expr(p: &mut Parser) -> CompletedMarker {\n     assert!(\n         p.at(T![|])\n             || (p.at(T![move]) && p.nth(1) == T![|])\n@@ -239,7 +239,7 @@ fn lambda_expr(p: &mut Parser) -> CompletedMarker {\n     p.eat(T![async]);\n     p.eat(T![move]);\n     params::param_list_closure(p);\n-    if opt_fn_ret_type(p) {\n+    if opt_ret_type(p) {\n         // test lambda_ret_block\n         // fn main() { || -> i32 { 92 }(); }\n         block_expr(p);\n@@ -265,7 +265,7 @@ fn if_expr(p: &mut Parser) -> CompletedMarker {\n     assert!(p.at(T![if]));\n     let m = p.start();\n     p.bump(T![if]);\n-    cond(p);\n+    condition(p);\n     block_expr(p);\n     if p.at(T![else]) {\n         p.bump(T![else]);\n@@ -314,7 +314,7 @@ fn while_expr(p: &mut Parser, m: Option<Marker>) -> CompletedMarker {\n     assert!(p.at(T![while]));\n     let m = m.unwrap_or_else(|| p.start());\n     p.bump(T![while]);\n-    cond(p);\n+    condition(p);\n     block_expr(p);\n     m.complete(p, WHILE_EXPR)\n }\n@@ -342,7 +342,7 @@ fn for_expr(p: &mut Parser, m: Option<Marker>) -> CompletedMarker {\n //     while let Some(_) | Some(_) = None {}\n //     while let | Some(_) = None {}\n // }\n-fn cond(p: &mut Parser) {\n+fn condition(p: &mut Parser) {\n     let m = p.start();\n     if p.eat(T![let]) {\n         patterns::pattern_top(p);\n@@ -386,7 +386,7 @@ pub(crate) fn match_arm_list(p: &mut Parser) {\n     //         _ => (),\n     //     }\n     // }\n-    attributes::inner_attributes(p);\n+    attributes::inner_attrs(p);\n \n     while !p.at(EOF) && !p.at(T!['}']) {\n         if p.at(T!['{']) {\n@@ -437,7 +437,7 @@ fn match_arm(p: &mut Parser) -> BlockLike {\n     //         _ => (),\n     //     }\n     // }\n-    attributes::outer_attributes(p);\n+    attributes::outer_attrs(p);\n \n     patterns::pattern_top_r(p, TokenSet::EMPTY);\n     if p.at(T![if]) {"}, {"sha": "b2f7cc21f68122a12eec22394b5e06ad25f31853", "filename": "crates/parser/src/grammar/items.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/6bc2633c90cedad057c5201d1ab7f67b57247004/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bc2633c90cedad057c5201d1ab7f67b57247004/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems.rs?ref=6bc2633c90cedad057c5201d1ab7f67b57247004", "patch": "@@ -6,9 +6,9 @@ mod traits;\n mod use_item;\n \n pub(crate) use self::{\n-    adt::{enum_variant_list, record_field_def_list},\n-    expressions::{match_arm_list, record_field_list},\n-    traits::{impl_item_list, trait_item_list},\n+    adt::{record_field_list, variant_list},\n+    expressions::{match_arm_list, record_expr_field_list},\n+    traits::assoc_item_list,\n     use_item::use_tree_list,\n };\n use super::*;\n@@ -20,7 +20,7 @@ use super::*;\n // super::baz! {}\n // struct S;\n pub(super) fn mod_contents(p: &mut Parser, stop_on_r_curly: bool) {\n-    attributes::inner_attributes(p);\n+    attributes::inner_attrs(p);\n     while !(stop_on_r_curly && p.at(T!['}']) || p.at(EOF)) {\n         item_or_macro(p, stop_on_r_curly)\n     }\n@@ -33,7 +33,7 @@ pub(super) const ITEM_RECOVERY_SET: TokenSet = token_set![\n \n pub(super) fn item_or_macro(p: &mut Parser, stop_on_r_curly: bool) {\n     let m = p.start();\n-    attributes::outer_attributes(p);\n+    attributes::outer_attrs(p);\n     let m = match maybe_item(p, m) {\n         Ok(()) => {\n             if p.at(T![;]) {\n@@ -144,30 +144,30 @@ pub(super) fn maybe_item(p: &mut Parser, m: Marker) -> Result<(), Marker> {\n         // test fn\n         // fn foo() {}\n         T![fn] => {\n-            fn_def(p);\n+            fn_(p);\n             m.complete(p, FN);\n         }\n \n         // test trait\n         // trait T {}\n         T![trait] => {\n-            traits::trait_def(p);\n+            traits::trait_(p);\n             m.complete(p, TRAIT);\n         }\n \n         T![const] => {\n-            consts::const_def(p, m);\n+            consts::konst(p, m);\n         }\n \n         // test impl\n         // impl T for S {}\n         T![impl] => {\n-            traits::impl_def(p);\n+            traits::impl_(p);\n             m.complete(p, IMPL);\n         }\n \n         T![type] => {\n-            type_def(p, m);\n+            type_alias(p, m);\n         }\n         _ => {\n             if !has_visibility && !has_mods {\n@@ -190,9 +190,9 @@ fn items_without_modifiers(p: &mut Parser, m: Marker) -> Result<(), Marker> {\n     match p.current() {\n         // test extern_crate\n         // extern crate foo;\n-        T![extern] if la == T![crate] => extern_crate_item(p, m),\n+        T![extern] if la == T![crate] => extern_crate(p, m),\n         T![type] => {\n-            type_def(p, m);\n+            type_alias(p, m);\n         }\n         T![mod] => mod_item(p, m),\n         T![struct] => {\n@@ -205,7 +205,7 @@ fn items_without_modifiers(p: &mut Parser, m: Marker) -> Result<(), Marker> {\n             //     a: i32,\n             //     b: f32,\n             // }\n-            adt::struct_def(p, m);\n+            adt::strukt(p, m);\n         }\n         // test pub_macro_def\n         // pub macro m($:ident) {}\n@@ -219,12 +219,12 @@ fn items_without_modifiers(p: &mut Parser, m: Marker) -> Result<(), Marker> {\n             //     a: i32,\n             //     b: f32,\n             // }\n-            adt::union_def(p, m);\n+            adt::union(p, m);\n         }\n-        T![enum] => adt::enum_def(p, m),\n-        T![use] => use_item::use_item(p, m),\n-        T![const] if (la == IDENT || la == T![_] || la == T![mut]) => consts::const_def(p, m),\n-        T![static] => consts::static_def(p, m),\n+        T![enum] => adt::enum_(p, m),\n+        T![use] => use_item::use_(p, m),\n+        T![const] if (la == IDENT || la == T![_] || la == T![mut]) => consts::konst(p, m),\n+        T![static] => consts::static_(p, m),\n         // test extern_block\n         // extern {}\n         T![extern]\n@@ -239,7 +239,7 @@ fn items_without_modifiers(p: &mut Parser, m: Marker) -> Result<(), Marker> {\n     Ok(())\n }\n \n-fn extern_crate_item(p: &mut Parser, m: Marker) {\n+fn extern_crate(p: &mut Parser, m: Marker) {\n     assert!(p.at(T![extern]));\n     p.bump(T![extern]);\n     assert!(p.at(T![crate]));\n@@ -251,7 +251,7 @@ fn extern_crate_item(p: &mut Parser, m: Marker) {\n         name_ref(p);\n     }\n \n-    opt_alias(p);\n+    opt_rename(p);\n     p.expect(T![;]);\n     m.complete(p, EXTERN_CRATE);\n }\n@@ -265,14 +265,14 @@ pub(crate) fn extern_item_list(p: &mut Parser) {\n     m.complete(p, EXTERN_ITEM_LIST);\n }\n \n-fn fn_def(p: &mut Parser) {\n+fn fn_(p: &mut Parser) {\n     assert!(p.at(T![fn]));\n     p.bump(T![fn]);\n \n     name_r(p, ITEM_RECOVERY_SET);\n     // test function_type_params\n     // fn foo<T: Clone + Copy>(){}\n-    type_params::opt_type_param_list(p);\n+    type_params::opt_generic_param_list(p);\n \n     if p.at(T!['(']) {\n         params::param_list_fn_def(p);\n@@ -282,7 +282,7 @@ fn fn_def(p: &mut Parser) {\n     // test function_ret_type\n     // fn foo() {}\n     // fn bar() -> () {}\n-    opt_fn_ret_type(p);\n+    opt_ret_type(p);\n \n     // test function_where_clause\n     // fn foo<T>() where T: Copy {}\n@@ -299,15 +299,15 @@ fn fn_def(p: &mut Parser) {\n \n // test type_item\n // type Foo = Bar;\n-fn type_def(p: &mut Parser, m: Marker) {\n+fn type_alias(p: &mut Parser, m: Marker) {\n     assert!(p.at(T![type]));\n     p.bump(T![type]);\n \n     name(p);\n \n     // test type_item_type_params\n     // type Result<T> = ();\n-    type_params::opt_type_param_list(p);\n+    type_params::opt_generic_param_list(p);\n \n     if p.at(T![:]) {\n         type_params::bounds(p);\n@@ -329,14 +329,14 @@ pub(crate) fn mod_item(p: &mut Parser, m: Marker) {\n \n     name(p);\n     if p.at(T!['{']) {\n-        mod_item_list(p);\n+        item_list(p);\n     } else if !p.eat(T![;]) {\n         p.error(\"expected `;` or `{`\");\n     }\n     m.complete(p, MODULE);\n }\n \n-pub(crate) fn mod_item_list(p: &mut Parser) {\n+pub(crate) fn item_list(p: &mut Parser) {\n     assert!(p.at(T!['{']));\n     let m = p.start();\n     p.bump(T!['{']);"}, {"sha": "67c0c56970716b7e717b586a3dc83191ec5b0937", "filename": "crates/parser/src/grammar/items/adt.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6bc2633c90cedad057c5201d1ab7f67b57247004/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bc2633c90cedad057c5201d1ab7f67b57247004/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems%2Fadt.rs?ref=6bc2633c90cedad057c5201d1ab7f67b57247004", "patch": "@@ -2,29 +2,29 @@\n \n use super::*;\n \n-pub(super) fn struct_def(p: &mut Parser, m: Marker) {\n+pub(super) fn strukt(p: &mut Parser, m: Marker) {\n     assert!(p.at(T![struct]));\n     p.bump(T![struct]);\n     struct_or_union(p, m, T![struct], STRUCT);\n }\n \n-pub(super) fn union_def(p: &mut Parser, m: Marker) {\n+pub(super) fn union(p: &mut Parser, m: Marker) {\n     assert!(p.at_contextual_kw(\"union\"));\n     p.bump_remap(T![union]);\n     struct_or_union(p, m, T![union], UNION);\n }\n \n fn struct_or_union(p: &mut Parser, m: Marker, kw: SyntaxKind, def: SyntaxKind) {\n     name_r(p, ITEM_RECOVERY_SET);\n-    type_params::opt_type_param_list(p);\n+    type_params::opt_generic_param_list(p);\n     match p.current() {\n         T![where] => {\n             type_params::opt_where_clause(p);\n             match p.current() {\n                 T![;] => {\n                     p.bump(T![;]);\n                 }\n-                T!['{'] => record_field_def_list(p),\n+                T!['{'] => record_field_list(p),\n                 _ => {\n                     //FIXME: special case `(` error message\n                     p.error(\"expected `;` or `{`\");\n@@ -34,9 +34,9 @@ fn struct_or_union(p: &mut Parser, m: Marker, kw: SyntaxKind, def: SyntaxKind) {\n         T![;] if kw == T![struct] => {\n             p.bump(T![;]);\n         }\n-        T!['{'] => record_field_def_list(p),\n+        T!['{'] => record_field_list(p),\n         T!['('] if kw == T![struct] => {\n-            tuple_field_def_list(p);\n+            tuple_field_list(p);\n             // test tuple_struct_where\n             // struct Test<T>(T) where T: Clone;\n             // struct Test<T>(T);\n@@ -53,21 +53,21 @@ fn struct_or_union(p: &mut Parser, m: Marker, kw: SyntaxKind, def: SyntaxKind) {\n     m.complete(p, def);\n }\n \n-pub(super) fn enum_def(p: &mut Parser, m: Marker) {\n+pub(super) fn enum_(p: &mut Parser, m: Marker) {\n     assert!(p.at(T![enum]));\n     p.bump(T![enum]);\n     name_r(p, ITEM_RECOVERY_SET);\n-    type_params::opt_type_param_list(p);\n+    type_params::opt_generic_param_list(p);\n     type_params::opt_where_clause(p);\n     if p.at(T!['{']) {\n-        enum_variant_list(p);\n+        variant_list(p);\n     } else {\n         p.error(\"expected `{`\")\n     }\n     m.complete(p, ENUM);\n }\n \n-pub(crate) fn enum_variant_list(p: &mut Parser) {\n+pub(crate) fn variant_list(p: &mut Parser) {\n     assert!(p.at(T!['{']));\n     let m = p.start();\n     p.bump(T!['{']);\n@@ -77,12 +77,12 @@ pub(crate) fn enum_variant_list(p: &mut Parser) {\n             continue;\n         }\n         let var = p.start();\n-        attributes::outer_attributes(p);\n+        attributes::outer_attrs(p);\n         if p.at(IDENT) {\n             name(p);\n             match p.current() {\n-                T!['{'] => record_field_def_list(p),\n-                T!['('] => tuple_field_def_list(p),\n+                T!['{'] => record_field_list(p),\n+                T!['('] => tuple_field_list(p),\n                 _ => (),\n             }\n \n@@ -104,7 +104,7 @@ pub(crate) fn enum_variant_list(p: &mut Parser) {\n     m.complete(p, VARIANT_LIST);\n }\n \n-pub(crate) fn record_field_def_list(p: &mut Parser) {\n+pub(crate) fn record_field_list(p: &mut Parser) {\n     assert!(p.at(T!['{']));\n     let m = p.start();\n     p.bump(T!['{']);\n@@ -128,7 +128,7 @@ pub(crate) fn record_field_def_list(p: &mut Parser) {\n         //     #[serde(with = \"url_serde\")]\n         //     pub uri: Uri,\n         // }\n-        attributes::outer_attributes(p);\n+        attributes::outer_attrs(p);\n         opt_visibility(p);\n         if p.at(IDENT) {\n             name(p);\n@@ -142,7 +142,7 @@ pub(crate) fn record_field_def_list(p: &mut Parser) {\n     }\n }\n \n-fn tuple_field_def_list(p: &mut Parser) {\n+fn tuple_field_list(p: &mut Parser) {\n     assert!(p.at(T!['(']));\n     let m = p.start();\n     if !p.expect(T!['(']) {\n@@ -159,7 +159,7 @@ fn tuple_field_def_list(p: &mut Parser) {\n         // enum S {\n         //     Uri(#[serde(with = \"url_serde\")] Uri),\n         // }\n-        attributes::outer_attributes(p);\n+        attributes::outer_attrs(p);\n         opt_visibility(p);\n         if !p.at_ts(types::TYPE_FIRST) {\n             p.error(\"expected a type\");"}, {"sha": "eb7d1f8281dee00d6d2fab4f316663d36e13d597", "filename": "crates/parser/src/grammar/items/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6bc2633c90cedad057c5201d1ab7f67b57247004/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bc2633c90cedad057c5201d1ab7f67b57247004/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems%2Fconsts.rs?ref=6bc2633c90cedad057c5201d1ab7f67b57247004", "patch": "@@ -2,11 +2,11 @@\n \n use super::*;\n \n-pub(super) fn static_def(p: &mut Parser, m: Marker) {\n+pub(super) fn static_(p: &mut Parser, m: Marker) {\n     const_or_static(p, m, T![static], STATIC)\n }\n \n-pub(super) fn const_def(p: &mut Parser, m: Marker) {\n+pub(super) fn konst(p: &mut Parser, m: Marker) {\n     const_or_static(p, m, T![const], CONST)\n }\n "}, {"sha": "8394020dafae3b70d3daa24f637147470237dfa8", "filename": "crates/parser/src/grammar/items/traits.rs", "status": "modified", "additions": 8, "deletions": 30, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/6bc2633c90cedad057c5201d1ab7f67b57247004/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bc2633c90cedad057c5201d1ab7f67b57247004/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems%2Ftraits.rs?ref=6bc2633c90cedad057c5201d1ab7f67b57247004", "patch": "@@ -5,11 +5,11 @@ use super::*;\n // test trait_item\n // trait T<U>: Hash + Clone where U: Copy {}\n // trait X<U: Debug + Display>: Hash + Clone where U: Copy {}\n-pub(super) fn trait_def(p: &mut Parser) {\n+pub(super) fn trait_(p: &mut Parser) {\n     assert!(p.at(T![trait]));\n     p.bump(T![trait]);\n     name_r(p, ITEM_RECOVERY_SET);\n-    type_params::opt_type_param_list(p);\n+    type_params::opt_generic_param_list(p);\n     // test trait_alias\n     // trait Z<U> = T<U>;\n     // trait Z<U> = T<U> where U: Copy;\n@@ -25,41 +25,19 @@ pub(super) fn trait_def(p: &mut Parser) {\n     }\n     type_params::opt_where_clause(p);\n     if p.at(T!['{']) {\n-        trait_item_list(p);\n+        assoc_item_list(p);\n     } else {\n         p.error(\"expected `{`\");\n     }\n }\n \n-// test trait_item_list\n-// impl F {\n-//     type A: Clone;\n-//     const B: i32;\n-//     fn foo() {}\n-//     fn bar(&self);\n-// }\n-pub(crate) fn trait_item_list(p: &mut Parser) {\n-    assert!(p.at(T!['{']));\n-    let m = p.start();\n-    p.bump(T!['{']);\n-    while !p.at(EOF) && !p.at(T!['}']) {\n-        if p.at(T!['{']) {\n-            error_block(p, \"expected an item\");\n-            continue;\n-        }\n-        item_or_macro(p, true);\n-    }\n-    p.expect(T!['}']);\n-    m.complete(p, ASSOC_ITEM_LIST);\n-}\n-\n // test impl_def\n // impl Foo {}\n-pub(super) fn impl_def(p: &mut Parser) {\n+pub(super) fn impl_(p: &mut Parser) {\n     assert!(p.at(T![impl]));\n     p.bump(T![impl]);\n     if choose_type_params_over_qpath(p) {\n-        type_params::opt_type_param_list(p);\n+        type_params::opt_generic_param_list(p);\n     }\n \n     // FIXME: never type\n@@ -74,7 +52,7 @@ pub(super) fn impl_def(p: &mut Parser) {\n     }\n     type_params::opt_where_clause(p);\n     if p.at(T!['{']) {\n-        impl_item_list(p);\n+        assoc_item_list(p);\n     } else {\n         p.error(\"expected `{`\");\n     }\n@@ -87,7 +65,7 @@ pub(super) fn impl_def(p: &mut Parser) {\n //     fn foo() {}\n //     fn bar(&self) {}\n // }\n-pub(crate) fn impl_item_list(p: &mut Parser) {\n+pub(crate) fn assoc_item_list(p: &mut Parser) {\n     assert!(p.at(T!['{']));\n     let m = p.start();\n     p.bump(T!['{']);\n@@ -97,7 +75,7 @@ pub(crate) fn impl_item_list(p: &mut Parser) {\n     //      //! This is a doc comment\n     //      #![doc(\"This is also a doc comment\")]\n     // }\n-    attributes::inner_attributes(p);\n+    attributes::inner_attrs(p);\n \n     while !p.at(EOF) && !p.at(T!['}']) {\n         if p.at(T!['{']) {"}, {"sha": "20e6a13cf96da0933c2ce7947ec1d160e6c0a4b0", "filename": "crates/parser/src/grammar/items/use_item.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6bc2633c90cedad057c5201d1ab7f67b57247004/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems%2Fuse_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bc2633c90cedad057c5201d1ab7f67b57247004/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems%2Fuse_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems%2Fuse_item.rs?ref=6bc2633c90cedad057c5201d1ab7f67b57247004", "patch": "@@ -2,7 +2,7 @@\n \n use super::*;\n \n-pub(super) fn use_item(p: &mut Parser, m: Marker) {\n+pub(super) fn use_(p: &mut Parser, m: Marker) {\n     assert!(p.at(T![use]));\n     p.bump(T![use]);\n     use_tree(p, true);\n@@ -80,7 +80,7 @@ fn use_tree(p: &mut Parser, top_level: bool) {\n                     //  running::out::of::synonyms::for_::different::*\n                     // };\n                     // use Trait as _;\n-                    opt_alias(p);\n+                    opt_rename(p);\n                 }\n                 T![:] if p.at(T![::]) => {\n                     p.bump(T![::]);"}, {"sha": "a665ffc133c9a97816c15a197b9478d2a551a548", "filename": "crates/parser/src/grammar/params.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6bc2633c90cedad057c5201d1ab7f67b57247004/crates%2Fparser%2Fsrc%2Fgrammar%2Fparams.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bc2633c90cedad057c5201d1ab7f67b57247004/crates%2Fparser%2Fsrc%2Fgrammar%2Fparams.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fparams.rs?ref=6bc2633c90cedad057c5201d1ab7f67b57247004", "patch": "@@ -47,20 +47,20 @@ fn list_(p: &mut Parser, flavor: Flavor) {\n     if let FnDef = flavor {\n         // test self_param_outer_attr\n         // fn f(#[must_use] self) {}\n-        attributes::outer_attributes(p);\n+        attributes::outer_attrs(p);\n         opt_self_param(p);\n     }\n \n     while !p.at(EOF) && !p.at(ket) {\n         // test param_outer_arg\n         // fn f(#[attr1] pat: Type) {}\n-        attributes::outer_attributes(p);\n+        attributes::outer_attrs(p);\n \n-        if !p.at_ts(VALUE_PARAMETER_FIRST) {\n+        if !p.at_ts(PARAM_FIRST) {\n             p.error(\"expected value parameter\");\n             break;\n         }\n-        let param = value_parameter(p, flavor);\n+        let param = param(p, flavor);\n         if !p.at(ket) {\n             p.expect(T![,]);\n         }\n@@ -73,11 +73,11 @@ fn list_(p: &mut Parser, flavor: Flavor) {\n     m.complete(p, PARAM_LIST);\n }\n \n-const VALUE_PARAMETER_FIRST: TokenSet = patterns::PATTERN_FIRST.union(types::TYPE_FIRST);\n+const PARAM_FIRST: TokenSet = patterns::PATTERN_FIRST.union(types::TYPE_FIRST);\n \n struct Variadic(bool);\n \n-fn value_parameter(p: &mut Parser, flavor: Flavor) -> Variadic {\n+fn param(p: &mut Parser, flavor: Flavor) -> Variadic {\n     let mut res = Variadic(false);\n     let m = p.start();\n     match flavor {"}, {"sha": "52562afa41c7c0fde56041e974727fc10ee38128", "filename": "crates/parser/src/grammar/paths.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6bc2633c90cedad057c5201d1ab7f67b57247004/crates%2Fparser%2Fsrc%2Fgrammar%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bc2633c90cedad057c5201d1ab7f67b57247004/crates%2Fparser%2Fsrc%2Fgrammar%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fpaths.rs?ref=6bc2633c90cedad057c5201d1ab7f67b57247004", "patch": "@@ -105,11 +105,11 @@ fn opt_path_type_args(p: &mut Parser, mode: Mode) {\n             // type F = Box<Fn(i32) -> ()>;\n             if p.at(T!['(']) {\n                 params::param_list_fn_trait(p);\n-                opt_fn_ret_type(p);\n+                opt_ret_type(p);\n             } else {\n-                type_args::opt_type_arg_list(p, false)\n+                type_args::opt_generic_arg_list(p, false)\n             }\n         }\n-        Mode::Expr => type_args::opt_type_arg_list(p, true),\n+        Mode::Expr => type_args::opt_generic_arg_list(p, true),\n     }\n }"}, {"sha": "07b1d6dd53c4c8c8516dab3392d4d19d8553aaef", "filename": "crates/parser/src/grammar/patterns.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6bc2633c90cedad057c5201d1ab7f67b57247004/crates%2Fparser%2Fsrc%2Fgrammar%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bc2633c90cedad057c5201d1ab7f67b57247004/crates%2Fparser%2Fsrc%2Fgrammar%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fpatterns.rs?ref=6bc2633c90cedad057c5201d1ab7f67b57247004", "patch": "@@ -79,22 +79,22 @@ const PAT_RECOVERY_SET: TokenSet =\n fn atom_pat(p: &mut Parser, recovery_set: TokenSet) -> Option<CompletedMarker> {\n     let m = match p.nth(0) {\n         T![box] => box_pat(p),\n-        T![ref] | T![mut] => bind_pat(p, true),\n+        T![ref] | T![mut] => ident_pat(p, true),\n         IDENT => match p.nth(1) {\n             // Checks the token after an IDENT to see if a pattern is a path (Struct { .. }) or macro\n             // (T![x]).\n             T!['('] | T!['{'] | T![!] => path_or_macro_pat(p),\n             T![:] if p.nth_at(1, T![::]) => path_or_macro_pat(p),\n-            _ => bind_pat(p, true),\n+            _ => ident_pat(p, true),\n         },\n \n         // test type_path_in_pattern\n         // fn main() { let <_>::Foo = (); }\n         _ if paths::is_path_start(p) => path_or_macro_pat(p),\n         _ if is_literal_pat_start(p) => literal_pat(p),\n \n-        T![.] if p.at(T![..]) => dot_dot_pat(p),\n-        T![_] => placeholder_pat(p),\n+        T![.] if p.at(T![..]) => rest_pat(p),\n+        T![_] => wildcard_pat(p),\n         T![&] => ref_pat(p),\n         T!['('] => tuple_pat(p),\n         T!['['] => slice_pat(p),\n@@ -149,7 +149,7 @@ fn path_or_macro_pat(p: &mut Parser) -> CompletedMarker {\n             TUPLE_STRUCT_PAT\n         }\n         T!['{'] => {\n-            record_field_pat_list(p);\n+            record_pat_field_list(p);\n             RECORD_PAT\n         }\n         // test marco_pat\n@@ -186,7 +186,7 @@ fn tuple_pat_fields(p: &mut Parser) {\n //     let S { h: _, ..} = ();\n //     let S { h: _, } = ();\n // }\n-fn record_field_pat_list(p: &mut Parser) {\n+fn record_pat_field_list(p: &mut Parser) {\n     assert!(p.at(T!['{']));\n     let m = p.start();\n     p.bump(T!['{']);\n@@ -214,7 +214,7 @@ fn record_field_pat_list(p: &mut Parser) {\n                         box_pat(p);\n                     }\n                     _ => {\n-                        bind_pat(p, false);\n+                        ident_pat(p, false);\n                     }\n                 }\n                 m.complete(p, RECORD_PAT_FIELD);\n@@ -230,7 +230,7 @@ fn record_field_pat_list(p: &mut Parser) {\n \n // test placeholder_pat\n // fn main() { let _ = (); }\n-fn placeholder_pat(p: &mut Parser) -> CompletedMarker {\n+fn wildcard_pat(p: &mut Parser) -> CompletedMarker {\n     assert!(p.at(T![_]));\n     let m = p.start();\n     p.bump(T![_]);\n@@ -263,7 +263,7 @@ fn placeholder_pat(p: &mut Parser) -> CompletedMarker {\n //     let [head, .., mid, tail @ ..] = ();\n //     let [head, .., mid, .., cons] = ();\n // }\n-fn dot_dot_pat(p: &mut Parser) -> CompletedMarker {\n+fn rest_pat(p: &mut Parser) -> CompletedMarker {\n     assert!(p.at(T![..]));\n     let m = p.start();\n     p.bump(T![..]);\n@@ -353,7 +353,7 @@ fn pat_list(p: &mut Parser, ket: SyntaxKind) {\n //     let e @ _ = ();\n //     let ref mut f @ g @ _ = ();\n // }\n-fn bind_pat(p: &mut Parser, with_at: bool) -> CompletedMarker {\n+fn ident_pat(p: &mut Parser, with_at: bool) -> CompletedMarker {\n     let m = p.start();\n     p.eat(T![ref]);\n     p.eat(T![mut]);"}, {"sha": "f2d34a749955f1f58ff3f5aaf4e407663e5e6dd5", "filename": "crates/parser/src/grammar/type_args.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6bc2633c90cedad057c5201d1ab7f67b57247004/crates%2Fparser%2Fsrc%2Fgrammar%2Ftype_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bc2633c90cedad057c5201d1ab7f67b57247004/crates%2Fparser%2Fsrc%2Fgrammar%2Ftype_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Ftype_args.rs?ref=6bc2633c90cedad057c5201d1ab7f67b57247004", "patch": "@@ -2,7 +2,7 @@\n \n use super::*;\n \n-pub(super) fn opt_type_arg_list(p: &mut Parser, colon_colon_required: bool) {\n+pub(super) fn opt_generic_arg_list(p: &mut Parser, colon_colon_required: bool) {\n     let m;\n     if p.at(T![::]) && p.nth(2) == T![<] {\n         m = p.start();\n@@ -16,7 +16,7 @@ pub(super) fn opt_type_arg_list(p: &mut Parser, colon_colon_required: bool) {\n     }\n \n     while !p.at(EOF) && !p.at(T![>]) {\n-        type_arg(p);\n+        generic_arg(p);\n         if !p.at(T![>]) && !p.expect(T![,]) {\n             break;\n         }\n@@ -27,7 +27,7 @@ pub(super) fn opt_type_arg_list(p: &mut Parser, colon_colon_required: bool) {\n \n // test type_arg\n // type A = B<'static, i32, 1, { 2 }, Item=u64>;\n-fn type_arg(p: &mut Parser) {\n+fn generic_arg(p: &mut Parser) {\n     let m = p.start();\n     match p.current() {\n         LIFETIME => {"}, {"sha": "bc7d8d7244a3b5ed574187461776cddba7b8552b", "filename": "crates/parser/src/grammar/type_params.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6bc2633c90cedad057c5201d1ab7f67b57247004/crates%2Fparser%2Fsrc%2Fgrammar%2Ftype_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bc2633c90cedad057c5201d1ab7f67b57247004/crates%2Fparser%2Fsrc%2Fgrammar%2Ftype_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Ftype_params.rs?ref=6bc2633c90cedad057c5201d1ab7f67b57247004", "patch": "@@ -2,14 +2,14 @@\n \n use super::*;\n \n-pub(super) fn opt_type_param_list(p: &mut Parser) {\n+pub(super) fn opt_generic_param_list(p: &mut Parser) {\n     if !p.at(T![<]) {\n         return;\n     }\n-    type_param_list(p);\n+    generic_param_list(p);\n }\n \n-fn type_param_list(p: &mut Parser) {\n+fn generic_param_list(p: &mut Parser) {\n     assert!(p.at(T![<]));\n     let m = p.start();\n     p.bump(T![<]);\n@@ -20,12 +20,12 @@ fn type_param_list(p: &mut Parser) {\n         // test generic_lifetime_type_attribute\n         // fn foo<#[derive(Lifetime)] 'a, #[derive(Type)] T>(_: &'a T) {\n         // }\n-        attributes::outer_attributes(p);\n+        attributes::outer_attrs(p);\n \n         match p.current() {\n             LIFETIME => lifetime_param(p, m),\n             IDENT => type_param(p, m),\n-            CONST_KW => type_const_param(p, m),\n+            CONST_KW => const_param(p, m),\n             _ => {\n                 m.abandon(p);\n                 p.err_and_bump(\"expected type parameter\")\n@@ -65,7 +65,7 @@ fn type_param(p: &mut Parser, m: Marker) {\n \n // test const_param\n // struct S<const N: u32>;\n-fn type_const_param(p: &mut Parser, m: Marker) {\n+fn const_param(p: &mut Parser, m: Marker) {\n     assert!(p.at(CONST_KW));\n     p.bump(T![const]);\n     name(p);"}, {"sha": "c876545f441d9918bec4af35bd845107a44f51af", "filename": "crates/parser/src/grammar/types.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6bc2633c90cedad057c5201d1ab7f67b57247004/crates%2Fparser%2Fsrc%2Fgrammar%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bc2633c90cedad057c5201d1ab7f67b57247004/crates%2Fparser%2Fsrc%2Fgrammar%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Ftypes.rs?ref=6bc2633c90cedad057c5201d1ab7f67b57247004", "patch": "@@ -32,11 +32,11 @@ fn type_with_bounds_cond(p: &mut Parser, allow_bounds: bool) {\n     match p.current() {\n         T!['('] => paren_or_tuple_type(p),\n         T![!] => never_type(p),\n-        T![*] => pointer_type(p),\n+        T![*] => ptr_type(p),\n         T!['['] => array_or_slice_type(p),\n-        T![&] => reference_type(p),\n-        T![_] => placeholder_type(p),\n-        T![fn] | T![unsafe] | T![extern] => fn_pointer_type(p),\n+        T![&] => ref_type(p),\n+        T![_] => infer_type(p),\n+        T![fn] | T![unsafe] | T![extern] => fn_ptr_type(p),\n         T![for] => for_type(p),\n         T![impl] => impl_trait_type(p),\n         T![dyn] => dyn_trait_type(p),\n@@ -96,7 +96,7 @@ fn never_type(p: &mut Parser) {\n     m.complete(p, NEVER_TYPE);\n }\n \n-fn pointer_type(p: &mut Parser) {\n+fn ptr_type(p: &mut Parser) {\n     assert!(p.at(T![*]));\n     let m = p.start();\n     p.bump(T![*]);\n@@ -156,7 +156,7 @@ fn array_or_slice_type(p: &mut Parser) {\n // type A = &();\n // type B = &'static ();\n // type C = &mut ();\n-fn reference_type(p: &mut Parser) {\n+fn ref_type(p: &mut Parser) {\n     assert!(p.at(T![&]));\n     let m = p.start();\n     p.bump(T![&]);\n@@ -168,7 +168,7 @@ fn reference_type(p: &mut Parser) {\n \n // test placeholder_type\n // type Placeholder = _;\n-fn placeholder_type(p: &mut Parser) {\n+fn infer_type(p: &mut Parser) {\n     assert!(p.at(T![_]));\n     let m = p.start();\n     p.bump(T![_]);\n@@ -180,7 +180,7 @@ fn placeholder_type(p: &mut Parser) {\n // type B = unsafe fn();\n // type C = unsafe extern \"C\" fn();\n // type D = extern \"C\" fn ( u8 , ... ) -> u8;\n-fn fn_pointer_type(p: &mut Parser) {\n+fn fn_ptr_type(p: &mut Parser) {\n     let m = p.start();\n     p.eat(T![unsafe]);\n     if p.at(T![extern]) {\n@@ -200,15 +200,15 @@ fn fn_pointer_type(p: &mut Parser) {\n     }\n     // test fn_pointer_type_with_ret\n     // type F = fn() -> ();\n-    opt_fn_ret_type(p);\n+    opt_ret_type(p);\n     m.complete(p, FN_PTR_TYPE);\n }\n \n pub(super) fn for_binder(p: &mut Parser) {\n     assert!(p.at(T![for]));\n     p.bump(T![for]);\n     if p.at(T![<]) {\n-        type_params::opt_type_param_list(p);\n+        type_params::opt_generic_param_list(p);\n     } else {\n         p.error(\"expected `<`\");\n     }"}, {"sha": "c7289e4008adf9a2431729e56fe5fe55d682751d", "filename": "crates/syntax/test_data/parser/inline/ok/0001_trait_item_list.rast", "status": "removed", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/1b0c7701cc97cd7bef8bb9729011d4cf291a60c5/crates%2Fsyntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0001_trait_item_list.rast", "raw_url": "https://github.com/rust-lang/rust/raw/1b0c7701cc97cd7bef8bb9729011d4cf291a60c5/crates%2Fsyntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0001_trait_item_list.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0001_trait_item_list.rast?ref=1b0c7701cc97cd7bef8bb9729011d4cf291a60c5", "patch": "@@ -1,71 +0,0 @@\n-SOURCE_FILE@0..83\n-  IMPL@0..82\n-    IMPL_KW@0..4 \"impl\"\n-    WHITESPACE@4..5 \" \"\n-    PATH_TYPE@5..6\n-      PATH@5..6\n-        PATH_SEGMENT@5..6\n-          NAME_REF@5..6\n-            IDENT@5..6 \"F\"\n-    WHITESPACE@6..7 \" \"\n-    ASSOC_ITEM_LIST@7..82\n-      L_CURLY@7..8 \"{\"\n-      WHITESPACE@8..13 \"\\n    \"\n-      TYPE_ALIAS@13..27\n-        TYPE_KW@13..17 \"type\"\n-        WHITESPACE@17..18 \" \"\n-        NAME@18..19\n-          IDENT@18..19 \"A\"\n-        COLON@19..20 \":\"\n-        WHITESPACE@20..21 \" \"\n-        TYPE_BOUND_LIST@21..26\n-          TYPE_BOUND@21..26\n-            PATH_TYPE@21..26\n-              PATH@21..26\n-                PATH_SEGMENT@21..26\n-                  NAME_REF@21..26\n-                    IDENT@21..26 \"Clone\"\n-        SEMICOLON@26..27 \";\"\n-      WHITESPACE@27..32 \"\\n    \"\n-      CONST@32..45\n-        CONST_KW@32..37 \"const\"\n-        WHITESPACE@37..38 \" \"\n-        NAME@38..39\n-          IDENT@38..39 \"B\"\n-        COLON@39..40 \":\"\n-        WHITESPACE@40..41 \" \"\n-        PATH_TYPE@41..44\n-          PATH@41..44\n-            PATH_SEGMENT@41..44\n-              NAME_REF@41..44\n-                IDENT@41..44 \"i32\"\n-        SEMICOLON@44..45 \";\"\n-      WHITESPACE@45..50 \"\\n    \"\n-      FN@50..61\n-        FN_KW@50..52 \"fn\"\n-        WHITESPACE@52..53 \" \"\n-        NAME@53..56\n-          IDENT@53..56 \"foo\"\n-        PARAM_LIST@56..58\n-          L_PAREN@56..57 \"(\"\n-          R_PAREN@57..58 \")\"\n-        WHITESPACE@58..59 \" \"\n-        BLOCK_EXPR@59..61\n-          L_CURLY@59..60 \"{\"\n-          R_CURLY@60..61 \"}\"\n-      WHITESPACE@61..66 \"\\n    \"\n-      FN@66..80\n-        FN_KW@66..68 \"fn\"\n-        WHITESPACE@68..69 \" \"\n-        NAME@69..72\n-          IDENT@69..72 \"bar\"\n-        PARAM_LIST@72..79\n-          L_PAREN@72..73 \"(\"\n-          SELF_PARAM@73..78\n-            AMP@73..74 \"&\"\n-            SELF_KW@74..78 \"self\"\n-          R_PAREN@78..79 \")\"\n-        SEMICOLON@79..80 \";\"\n-      WHITESPACE@80..81 \"\\n\"\n-      R_CURLY@81..82 \"}\"\n-  WHITESPACE@82..83 \"\\n\""}, {"sha": "a5ec3239f8fe2a060fbfbce7f86f192ae72a0f5a", "filename": "crates/syntax/test_data/parser/inline/ok/0001_trait_item_list.rs", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1b0c7701cc97cd7bef8bb9729011d4cf291a60c5/crates%2Fsyntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0001_trait_item_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b0c7701cc97cd7bef8bb9729011d4cf291a60c5/crates%2Fsyntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0001_trait_item_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0001_trait_item_list.rs?ref=1b0c7701cc97cd7bef8bb9729011d4cf291a60c5", "patch": "@@ -1,6 +0,0 @@\n-impl F {\n-    type A: Clone;\n-    const B: i32;\n-    fn foo() {}\n-    fn bar(&self);\n-}"}]}