{"sha": "4bd4e4130ed531a644263db26bf8461704215c77", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiZDRlNDEzMGVkNTMxYTY0NDI2M2RiMjZiZjg0NjE3MDQyMTVjNzc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-25T20:40:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-25T20:40:31Z"}, "message": "Auto merge of #54490 - wesleywiser:rewrite_it_in_mir, r=oli-obk\n\nRewrite the `UnconditionalRecursion` lint to use MIR\n\nPart of #51002\n\nr? @eddyb", "tree": {"sha": "1ea4c9d52368ab1271659dea4807bc4a7151918a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ea4c9d52368ab1271659dea4807bc4a7151918a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4bd4e4130ed531a644263db26bf8461704215c77", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4bd4e4130ed531a644263db26bf8461704215c77", "html_url": "https://github.com/rust-lang/rust/commit/4bd4e4130ed531a644263db26bf8461704215c77", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4bd4e4130ed531a644263db26bf8461704215c77/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "html_url": "https://github.com/rust-lang/rust/commit/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a"}, {"sha": "f81d1dd29401cd586a13b77db729f42076f07902", "url": "https://api.github.com/repos/rust-lang/rust/commits/f81d1dd29401cd586a13b77db729f42076f07902", "html_url": "https://github.com/rust-lang/rust/commit/f81d1dd29401cd586a13b77db729f42076f07902"}], "stats": {"total": 527, "additions": 240, "deletions": 287}, "files": [{"sha": "266b1c4d4a084dc83dd058713a3397f5371ecf0f", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4bd4e4130ed531a644263db26bf8461704215c77/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd4e4130ed531a644263db26bf8461704215c77/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=4bd4e4130ed531a644263db26bf8461704215c77", "patch": "@@ -233,6 +233,12 @@ declare_lint! {\n     \"detect mut variables which don't need to be mutable\"\n }\n \n+declare_lint! {\n+    pub UNCONDITIONAL_RECURSION,\n+    Warn,\n+    \"functions that cannot return without calling themselves\"\n+}\n+\n declare_lint! {\n     pub SINGLE_USE_LIFETIMES,\n     Allow,\n@@ -402,6 +408,7 @@ impl LintPass for HardwiredLints {\n             DEPRECATED,\n             UNUSED_UNSAFE,\n             UNUSED_MUT,\n+            UNCONDITIONAL_RECURSION,\n             SINGLE_USE_LIFETIMES,\n             UNUSED_LIFETIMES,\n             UNUSED_LABELS,"}, {"sha": "19f9168cf0a0e2e8c32712eba0c764d9cb659764", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 0, "deletions": 277, "changes": 277, "blob_url": "https://github.com/rust-lang/rust/blob/4bd4e4130ed531a644263db26bf8461704215c77/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd4e4130ed531a644263db26bf8461704215c77/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=4bd4e4130ed531a644263db26bf8461704215c77", "patch": "@@ -30,10 +30,7 @@\n \n use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n-use rustc::cfg;\n-use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty};\n-use rustc::traits;\n use hir::Node;\n use util::nodemap::NodeSet;\n use lint::{LateContext, LintContext, LintArray};\n@@ -844,279 +841,6 @@ impl EarlyLintPass for UnusedDocComment {\n     }\n }\n \n-declare_lint! {\n-    pub UNCONDITIONAL_RECURSION,\n-    Warn,\n-    \"functions that cannot return without calling themselves\"\n-}\n-\n-#[derive(Copy, Clone)]\n-pub struct UnconditionalRecursion;\n-\n-\n-impl LintPass for UnconditionalRecursion {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array![UNCONDITIONAL_RECURSION]\n-    }\n-}\n-\n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n-    fn check_fn(&mut self,\n-                cx: &LateContext,\n-                fn_kind: FnKind,\n-                _: &hir::FnDecl,\n-                body: &hir::Body,\n-                sp: Span,\n-                id: ast::NodeId) {\n-        let method = match fn_kind {\n-            FnKind::ItemFn(..) => None,\n-            FnKind::Method(..) => {\n-                Some(cx.tcx.associated_item(cx.tcx.hir.local_def_id(id)))\n-            }\n-            // closures can't recur, so they don't matter.\n-            FnKind::Closure(_) => return,\n-        };\n-\n-        // Walk through this function (say `f`) looking to see if\n-        // every possible path references itself, i.e. the function is\n-        // called recursively unconditionally. This is done by trying\n-        // to find a path from the entry node to the exit node that\n-        // *doesn't* call `f` by traversing from the entry while\n-        // pretending that calls of `f` are sinks (i.e. ignoring any\n-        // exit edges from them).\n-        //\n-        // NB. this has an edge case with non-returning statements,\n-        // like `loop {}` or `panic!()`: control flow never reaches\n-        // the exit node through these, so one can have a function\n-        // that never actually calls itself but is still picked up by\n-        // this lint:\n-        //\n-        //     fn f(cond: bool) {\n-        //         if !cond { panic!() } // could come from `assert!(cond)`\n-        //         f(false)\n-        //     }\n-        //\n-        // In general, functions of that form may be able to call\n-        // itself a finite number of times and then diverge. The lint\n-        // considers this to be an error for two reasons, (a) it is\n-        // easier to implement, and (b) it seems rare to actually want\n-        // to have behaviour like the above, rather than\n-        // e.g. accidentally recursing after an assert.\n-\n-        let cfg = cfg::CFG::new(cx.tcx, &body);\n-\n-        let mut work_queue = vec![cfg.entry];\n-        let mut reached_exit_without_self_call = false;\n-        let mut self_call_spans = vec![];\n-        let mut visited = FxHashSet::default();\n-\n-        while let Some(idx) = work_queue.pop() {\n-            if idx == cfg.exit {\n-                // found a path!\n-                reached_exit_without_self_call = true;\n-                break;\n-            }\n-\n-            let cfg_id = idx.node_id();\n-            if visited.contains(&cfg_id) {\n-                // already done\n-                continue;\n-            }\n-            visited.insert(cfg_id);\n-\n-            // is this a recursive call?\n-            let local_id = cfg.graph.node_data(idx).id();\n-            if local_id != hir::DUMMY_ITEM_LOCAL_ID {\n-                let node_id = cx.tcx.hir.hir_to_node_id(hir::HirId {\n-                    owner: body.value.hir_id.owner,\n-                    local_id\n-                });\n-                let self_recursive = match method {\n-                    Some(ref method) => expr_refers_to_this_method(cx, method, node_id),\n-                    None => expr_refers_to_this_fn(cx, id, node_id),\n-                };\n-                if self_recursive {\n-                    self_call_spans.push(cx.tcx.hir.span(node_id));\n-                    // this is a self call, so we shouldn't explore past\n-                    // this node in the CFG.\n-                    continue;\n-                }\n-            }\n-\n-            // add the successors of this node to explore the graph further.\n-            for (_, edge) in cfg.graph.outgoing_edges(idx) {\n-                let target_idx = edge.target();\n-                let target_cfg_id = target_idx.node_id();\n-                if !visited.contains(&target_cfg_id) {\n-                    work_queue.push(target_idx)\n-                }\n-            }\n-        }\n-\n-        // Check the number of self calls because a function that\n-        // doesn't return (e.g. calls a `-> !` function or `loop { /*\n-        // no break */ }`) shouldn't be linted unless it actually\n-        // recurs.\n-        if !reached_exit_without_self_call && !self_call_spans.is_empty() {\n-            let sp = cx.tcx.sess.source_map().def_span(sp);\n-            let mut db = cx.struct_span_lint(UNCONDITIONAL_RECURSION,\n-                                             sp,\n-                                             \"function cannot return without recursing\");\n-            db.span_label(sp, \"cannot return without recursing\");\n-            // offer some help to the programmer.\n-            for call in &self_call_spans {\n-                db.span_label(*call, \"recursive call site\");\n-            }\n-            db.help(\"a `loop` may express intention better if this is on purpose\");\n-            db.emit();\n-        }\n-\n-        // all done\n-        return;\n-\n-        // Functions for identifying if the given Expr NodeId `id`\n-        // represents a call to the function `fn_id`/method `method`.\n-\n-        fn expr_refers_to_this_fn(cx: &LateContext, fn_id: ast::NodeId, id: ast::NodeId) -> bool {\n-            match cx.tcx.hir.get(id) {\n-                Node::Expr(&hir::Expr { node: hir::ExprKind::Call(ref callee, _), .. }) => {\n-                    let def = if let hir::ExprKind::Path(ref qpath) = callee.node {\n-                        cx.tables.qpath_def(qpath, callee.hir_id)\n-                    } else {\n-                        return false;\n-                    };\n-                    match def {\n-                        Def::Local(..) | Def::Upvar(..) => false,\n-                        _ => def.def_id() == cx.tcx.hir.local_def_id(fn_id)\n-                    }\n-                }\n-                _ => false,\n-            }\n-        }\n-\n-        // Check if the expression `id` performs a call to `method`.\n-        fn expr_refers_to_this_method(cx: &LateContext,\n-                                      method: &ty::AssociatedItem,\n-                                      id: ast::NodeId)\n-                                      -> bool {\n-            use rustc::ty::adjustment::*;\n-\n-            // Ignore non-expressions.\n-            let expr = if let Node::Expr(e) = cx.tcx.hir.get(id) {\n-                e\n-            } else {\n-                return false;\n-            };\n-\n-            // Check for overloaded autoderef method calls.\n-            let mut source = cx.tables.expr_ty(expr);\n-            for adjustment in cx.tables.expr_adjustments(expr) {\n-                if let Adjust::Deref(Some(deref)) = adjustment.kind {\n-                    let (def_id, substs) = deref.method_call(cx.tcx, source);\n-                    if method_call_refers_to_method(cx, method, def_id, substs, id) {\n-                        return true;\n-                    }\n-                }\n-                source = adjustment.target;\n-            }\n-\n-            // Check for method calls and overloaded operators.\n-            if cx.tables.is_method_call(expr) {\n-                let hir_id = cx.tcx.hir.definitions().node_to_hir_id(id);\n-                if let Some(def) = cx.tables.type_dependent_defs().get(hir_id) {\n-                    let def_id = def.def_id();\n-                    let substs = cx.tables.node_substs(hir_id);\n-                    if method_call_refers_to_method(cx, method, def_id, substs, id) {\n-                        return true;\n-                    }\n-                } else {\n-                    cx.tcx.sess.delay_span_bug(expr.span,\n-                                               \"no type-dependent def for method call\");\n-                }\n-            }\n-\n-            // Check for calls to methods via explicit paths (e.g. `T::method()`).\n-            match expr.node {\n-                hir::ExprKind::Call(ref callee, _) => {\n-                    let def = if let hir::ExprKind::Path(ref qpath) = callee.node {\n-                        cx.tables.qpath_def(qpath, callee.hir_id)\n-                    } else {\n-                        return false;\n-                    };\n-                    match def {\n-                        Def::Method(def_id) => {\n-                            let substs = cx.tables.node_substs(callee.hir_id);\n-                            method_call_refers_to_method(cx, method, def_id, substs, id)\n-                        }\n-                        _ => false,\n-                    }\n-                }\n-                _ => false,\n-            }\n-        }\n-\n-        // Check if the method call to the method with the ID `callee_id`\n-        // and instantiated with `callee_substs` refers to method `method`.\n-        fn method_call_refers_to_method<'a, 'tcx>(cx: &LateContext<'a, 'tcx>,\n-                                                  method: &ty::AssociatedItem,\n-                                                  callee_id: DefId,\n-                                                  callee_substs: &Substs<'tcx>,\n-                                                  expr_id: ast::NodeId)\n-                                                  -> bool {\n-            let tcx = cx.tcx;\n-            let callee_item = tcx.associated_item(callee_id);\n-\n-            match callee_item.container {\n-                // This is an inherent method, so the `def_id` refers\n-                // directly to the method definition.\n-                ty::ImplContainer(_) => callee_id == method.def_id,\n-\n-                // A trait method, from any number of possible sources.\n-                // Attempt to select a concrete impl before checking.\n-                ty::TraitContainer(trait_def_id) => {\n-                    let trait_ref = ty::TraitRef::from_method(tcx, trait_def_id, callee_substs);\n-                    let trait_ref = ty::Binder::bind(trait_ref);\n-                    let span = tcx.hir.span(expr_id);\n-                    let obligation =\n-                        traits::Obligation::new(traits::ObligationCause::misc(span, expr_id),\n-                                                cx.param_env,\n-                                                trait_ref.to_poly_trait_predicate());\n-\n-                    tcx.infer_ctxt().enter(|infcx| {\n-                        let mut selcx = traits::SelectionContext::new(&infcx);\n-                        match selcx.select(&obligation) {\n-                            // The method comes from a `T: Trait` bound.\n-                            // If `T` is `Self`, then this call is inside\n-                            // a default method definition.\n-                            Ok(Some(traits::VtableParam(_))) => {\n-                                let on_self = trait_ref.self_ty().is_self();\n-                                // We can only be recursing in a default\n-                                // method if we're being called literally\n-                                // on the `Self` type.\n-                                on_self && callee_id == method.def_id\n-                            }\n-\n-                            // The `impl` is known, so we check that with a\n-                            // special case:\n-                            Ok(Some(traits::VtableImpl(vtable_impl))) => {\n-                                let container = ty::ImplContainer(vtable_impl.impl_def_id);\n-                                // It matches if it comes from the same impl,\n-                                // and has the same method name.\n-                                container == method.container &&\n-                                callee_item.ident.name == method.ident.name\n-                            }\n-\n-                            // There's no way to know if this call is\n-                            // recursive, so we assume it's not.\n-                            _ => false,\n-                        }\n-                    })\n-                }\n-            }\n-        }\n-    }\n-}\n-\n declare_lint! {\n     PLUGIN_AS_LIBRARY,\n     Warn,\n@@ -1724,7 +1448,6 @@ impl LintPass for SoftLints {\n             MISSING_DEBUG_IMPLEMENTATIONS,\n             ANONYMOUS_PARAMETERS,\n             UNUSED_DOC_COMMENTS,\n-            UNCONDITIONAL_RECURSION,\n             PLUGIN_AS_LIBRARY,\n             NO_MANGLE_CONST_ITEMS,\n             NO_MANGLE_GENERIC_ITEMS,"}, {"sha": "f289acc032be8fd5cca2a547d18c253cf1ba1558", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4bd4e4130ed531a644263db26bf8461704215c77/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd4e4130ed531a644263db26bf8461704215c77/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=4bd4e4130ed531a644263db26bf8461704215c77", "patch": "@@ -144,7 +144,6 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n         UnusedAllocation: UnusedAllocation,\n         MissingCopyImplementations: MissingCopyImplementations,\n         UnstableFeatures: UnstableFeatures,\n-        UnconditionalRecursion: UnconditionalRecursion,\n         InvalidNoMangleItems: InvalidNoMangleItems,\n         PluginAsLibrary: PluginAsLibrary,\n         MutableTransmutes: MutableTransmutes,"}, {"sha": "e6dd0107e919801234c82242e210e1b4648542b8", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bd4e4130ed531a644263db26bf8461704215c77/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd4e4130ed531a644263db26bf8461704215c77/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=4bd4e4130ed531a644263db26bf8461704215c77", "patch": "@@ -35,6 +35,8 @@ use syntax_pos::Span;\n use transform::MirSource;\n use util as mir_util;\n \n+use super::lints;\n+\n /// Construct the MIR for a given def-id.\n pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'tcx> {\n     let id = tcx.hir.as_local_node_id(def_id).unwrap();\n@@ -176,6 +178,8 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'t\n         mir_util::dump_mir(tcx, None, \"mir_map\", &0,\n                            MirSource::item(def_id), &mir, |_, _| Ok(()) );\n \n+        lints::check(tcx, &mir, def_id);\n+\n         mir\n     })\n }"}, {"sha": "75417982aa189992d9743acba2bb54608fb26ac8", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4bd4e4130ed531a644263db26bf8461704215c77/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd4e4130ed531a644263db26bf8461704215c77/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=4bd4e4130ed531a644263db26bf8461704215c77", "patch": "@@ -79,6 +79,7 @@ mod borrow_check;\n mod build;\n mod dataflow;\n mod hair;\n+mod lints;\n mod shim;\n pub mod transform;\n pub mod util;"}, {"sha": "4c7938504c10f6a43199415ef3b185f97b8bd54a", "filename": "src/librustc_mir/lints.rs", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/4bd4e4130ed531a644263db26bf8461704215c77/src%2Flibrustc_mir%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd4e4130ed531a644263db26bf8461704215c77/src%2Flibrustc_mir%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flints.rs?ref=4bd4e4130ed531a644263db26bf8461704215c77", "patch": "@@ -0,0 +1,156 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc_data_structures::bit_set::BitSet;\n+use rustc::hir::def_id::DefId;\n+use rustc::hir::intravisit::FnKind;\n+use rustc::hir::map::blocks::FnLikeNode;\n+use rustc::lint::builtin::UNCONDITIONAL_RECURSION;\n+use rustc::mir::{self, Mir, TerminatorKind};\n+use rustc::ty::{AssociatedItem, AssociatedItemContainer, Instance, TyCtxt, TyKind};\n+use rustc::ty::subst::Substs;\n+\n+pub fn check(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+             mir: &Mir<'tcx>,\n+             def_id: DefId) {\n+    let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n+\n+    if let Some(fn_like_node) = FnLikeNode::from_node(tcx.hir.get(node_id)) {\n+        check_fn_for_unconditional_recursion(tcx, fn_like_node.kind(), mir, def_id);\n+    }\n+}\n+\n+fn check_fn_for_unconditional_recursion(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                        fn_kind: FnKind,\n+                                        mir: &Mir<'tcx>,\n+                                        def_id: DefId) {\n+    if let FnKind::Closure(_) = fn_kind {\n+        // closures can't recur, so they don't matter.\n+        return;\n+    }\n+\n+    //FIXME(#54444) rewrite this lint to use the dataflow framework\n+\n+    // Walk through this function (say `f`) looking to see if\n+    // every possible path references itself, i.e. the function is\n+    // called recursively unconditionally. This is done by trying\n+    // to find a path from the entry node to the exit node that\n+    // *doesn't* call `f` by traversing from the entry while\n+    // pretending that calls of `f` are sinks (i.e. ignoring any\n+    // exit edges from them).\n+    //\n+    // NB. this has an edge case with non-returning statements,\n+    // like `loop {}` or `panic!()`: control flow never reaches\n+    // the exit node through these, so one can have a function\n+    // that never actually calls itself but is still picked up by\n+    // this lint:\n+    //\n+    //     fn f(cond: bool) {\n+    //         if !cond { panic!() } // could come from `assert!(cond)`\n+    //         f(false)\n+    //     }\n+    //\n+    // In general, functions of that form may be able to call\n+    // itself a finite number of times and then diverge. The lint\n+    // considers this to be an error for two reasons, (a) it is\n+    // easier to implement, and (b) it seems rare to actually want\n+    // to have behaviour like the above, rather than\n+    // e.g. accidentally recursing after an assert.\n+\n+    let basic_blocks = mir.basic_blocks();\n+    let mut reachable_without_self_call_queue = vec![mir::START_BLOCK];\n+    let mut reached_exit_without_self_call = false;\n+    let mut self_call_locations = vec![];\n+    let mut visited = BitSet::new_empty(basic_blocks.len());\n+\n+    let param_env = tcx.param_env(def_id);\n+    let trait_substs_count =\n+        match tcx.opt_associated_item(def_id) {\n+            Some(AssociatedItem {\n+                container: AssociatedItemContainer::TraitContainer(trait_def_id),\n+                ..\n+            }) => tcx.generics_of(trait_def_id).count(),\n+            _ => 0\n+        };\n+    let caller_substs = &Substs::identity_for_item(tcx, def_id)[..trait_substs_count];\n+\n+    while let Some(bb) = reachable_without_self_call_queue.pop() {\n+        if visited.contains(bb) {\n+            //already done\n+            continue;\n+        }\n+\n+        visited.insert(bb);\n+\n+        let block = &basic_blocks[bb];\n+\n+        if let Some(ref terminator) = block.terminator {\n+            match terminator.kind {\n+                TerminatorKind::Call { ref func, .. } => {\n+                    let func_ty = func.ty(mir, tcx);\n+\n+                    if let TyKind::FnDef(fn_def_id, substs) = func_ty.sty {\n+                        let (call_fn_id, call_substs) =\n+                            if let Some(instance) = Instance::resolve(tcx,\n+                                                                        param_env,\n+                                                                        fn_def_id,\n+                                                                        substs) {\n+                                (instance.def_id(), instance.substs)\n+                            } else {\n+                                (fn_def_id, substs)\n+                            };\n+\n+                        let is_self_call =\n+                            call_fn_id == def_id &&\n+                                &call_substs[..caller_substs.len()] == caller_substs;\n+\n+                        if is_self_call {\n+                            self_call_locations.push(terminator.source_info);\n+\n+                            //this is a self call so we shouldn't explore\n+                            //further down this path\n+                            continue;\n+                        }\n+                    }\n+                },\n+                TerminatorKind::Abort | TerminatorKind::Return => {\n+                    //found a path!\n+                    reached_exit_without_self_call = true;\n+                    break;\n+                }\n+                _ => {}\n+            }\n+\n+            for successor in terminator.successors() {\n+                reachable_without_self_call_queue.push(*successor);\n+            }\n+        }\n+    }\n+\n+    // Check the number of self calls because a function that\n+    // doesn't return (e.g. calls a `-> !` function or `loop { /*\n+    // no break */ }`) shouldn't be linted unless it actually\n+    // recurs.\n+    if !reached_exit_without_self_call && !self_call_locations.is_empty() {\n+        let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n+        let sp = tcx.sess.source_map().def_span(tcx.hir.span(node_id));\n+        let mut db = tcx.struct_span_lint_node(UNCONDITIONAL_RECURSION,\n+                                                node_id,\n+                                                sp,\n+                                                \"function cannot return without recursing\");\n+        db.span_label(sp, \"cannot return without recursing\");\n+        // offer some help to the programmer.\n+        for location in &self_call_locations {\n+            db.span_label(location.span, \"recursive call site\");\n+        }\n+        db.help(\"a `loop` may express intention better if this is on purpose\");\n+        db.emit();\n+    }\n+}"}, {"sha": "fca29c9a9f64437b4b806e182997b5e4a8e362af", "filename": "src/test/ui/did_you_mean/issue-31424.nll.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4bd4e4130ed531a644263db26bf8461704215c77/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-31424.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4bd4e4130ed531a644263db26bf8461704215c77/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-31424.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-31424.nll.stderr?ref=4bd4e4130ed531a644263db26bf8461704215c77", "patch": "@@ -7,8 +7,20 @@ LL |         (&mut self).bar(); //~ ERROR cannot borrow\n    |         cannot borrow as mutable\n    |         try removing `&mut` here\n \n+warning: function cannot return without recursing\n+  --> $DIR/issue-31424.rs:22:5\n+   |\n+LL |     fn bar(self: &mut Self) {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^ cannot return without recursing\n+LL |         //~^ WARN function cannot return without recursing\n+LL |         (&mut self).bar(); //~ ERROR cannot borrow\n+   |         ----------------- recursive call site\n+   |\n+   = note: #[warn(unconditional_recursion)] on by default\n+   = help: a `loop` may express intention better if this is on purpose\n+\n error[E0596]: cannot borrow `self` as mutable, as it is not declared as mutable\n-  --> $DIR/issue-31424.rs:23:9\n+  --> $DIR/issue-31424.rs:24:9\n    |\n LL |         (&mut self).bar(); //~ ERROR cannot borrow\n    |         ^^^^^^^^^^^"}, {"sha": "903a76a8243382301001e0c65e4d84f2ac6d59c3", "filename": "src/test/ui/did_you_mean/issue-31424.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4bd4e4130ed531a644263db26bf8461704215c77/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-31424.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd4e4130ed531a644263db26bf8461704215c77/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-31424.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-31424.rs?ref=4bd4e4130ed531a644263db26bf8461704215c77", "patch": "@@ -20,6 +20,7 @@ impl Struct {\n     // In this case we could keep the suggestion, but to distinguish the\n     // two cases is pretty hard. It's an obscure case anyway.\n     fn bar(self: &mut Self) {\n+        //~^ WARN function cannot return without recursing\n         (&mut self).bar(); //~ ERROR cannot borrow\n     }\n }"}, {"sha": "2e4bcc7f95947e31811a5d2baf549cfc9e52d491", "filename": "src/test/ui/did_you_mean/issue-31424.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4bd4e4130ed531a644263db26bf8461704215c77/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-31424.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4bd4e4130ed531a644263db26bf8461704215c77/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-31424.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-31424.stderr?ref=4bd4e4130ed531a644263db26bf8461704215c77", "patch": "@@ -7,8 +7,20 @@ LL |         (&mut self).bar(); //~ ERROR cannot borrow\n    |               cannot reborrow mutably\n    |               try removing `&mut` here\n \n+warning: function cannot return without recursing\n+  --> $DIR/issue-31424.rs:22:5\n+   |\n+LL |     fn bar(self: &mut Self) {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^ cannot return without recursing\n+LL |         //~^ WARN function cannot return without recursing\n+LL |         (&mut self).bar(); //~ ERROR cannot borrow\n+   |         ----------------- recursive call site\n+   |\n+   = note: #[warn(unconditional_recursion)] on by default\n+   = help: a `loop` may express intention better if this is on purpose\n+\n error[E0596]: cannot borrow immutable argument `self` as mutable\n-  --> $DIR/issue-31424.rs:23:15\n+  --> $DIR/issue-31424.rs:24:15\n    |\n LL |         (&mut self).bar(); //~ ERROR cannot borrow\n    |               ^^^^ cannot borrow mutably"}, {"sha": "0f8372e094d6adeed53f41f5878f6f1bef4c552a", "filename": "src/test/ui/nll/issue-51191.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4bd4e4130ed531a644263db26bf8461704215c77/src%2Ftest%2Fui%2Fnll%2Fissue-51191.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd4e4130ed531a644263db26bf8461704215c77/src%2Ftest%2Fui%2Fnll%2Fissue-51191.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-51191.rs?ref=4bd4e4130ed531a644263db26bf8461704215c77", "patch": "@@ -14,6 +14,7 @@ struct Struct;\n \n impl Struct {\n     fn bar(self: &mut Self) {\n+        //~^ WARN function cannot return without recursing\n         (&mut self).bar();\n         //~^ ERROR cannot borrow `self` as mutable, as it is not declared as mutable [E0596]\n     }"}, {"sha": "88c653effb405d7a6f50907a13517c24b537bcdb", "filename": "src/test/ui/nll/issue-51191.stderr", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4bd4e4130ed531a644263db26bf8461704215c77/src%2Ftest%2Fui%2Fnll%2Fissue-51191.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4bd4e4130ed531a644263db26bf8461704215c77/src%2Ftest%2Fui%2Fnll%2Fissue-51191.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-51191.stderr?ref=4bd4e4130ed531a644263db26bf8461704215c77", "patch": "@@ -1,5 +1,17 @@\n+warning: function cannot return without recursing\n+  --> $DIR/issue-51191.rs:16:5\n+   |\n+LL |     fn bar(self: &mut Self) {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^ cannot return without recursing\n+LL |         //~^ WARN function cannot return without recursing\n+LL |         (&mut self).bar();\n+   |         ----------------- recursive call site\n+   |\n+   = note: #[warn(unconditional_recursion)] on by default\n+   = help: a `loop` may express intention better if this is on purpose\n+\n error[E0596]: cannot borrow `self` as mutable, as it is not declared as mutable\n-  --> $DIR/issue-51191.rs:17:9\n+  --> $DIR/issue-51191.rs:18:9\n    |\n LL |         (&mut self).bar();\n    |         ^^^^^^^^^^^\n@@ -8,27 +20,27 @@ LL |         (&mut self).bar();\n    |         try removing `&mut` here\n \n error[E0596]: cannot borrow `self` as mutable, as it is not declared as mutable\n-  --> $DIR/issue-51191.rs:22:9\n+  --> $DIR/issue-51191.rs:23:9\n    |\n LL |     fn imm(self) {\n    |            ---- help: consider changing this to be mutable: `mut self`\n LL |         (&mut self).bar();\n    |         ^^^^^^^^^^^ cannot borrow as mutable\n \n error[E0596]: cannot borrow `self` as mutable, as it is not declared as mutable\n-  --> $DIR/issue-51191.rs:31:9\n+  --> $DIR/issue-51191.rs:32:9\n    |\n LL |         (&mut self).bar();\n    |         ^^^^^^^^^^^ cannot borrow as mutable\n \n error[E0596]: cannot borrow data in a `&` reference as mutable\n-  --> $DIR/issue-51191.rs:31:9\n+  --> $DIR/issue-51191.rs:32:9\n    |\n LL |         (&mut self).bar();\n    |         ^^^^^^^^^^^ cannot borrow as mutable\n \n error[E0596]: cannot borrow `self` as mutable, as it is not declared as mutable\n-  --> $DIR/issue-51191.rs:37:9\n+  --> $DIR/issue-51191.rs:38:9\n    |\n LL |         (&mut self).bar();\n    |         ^^^^^^^^^^^"}, {"sha": "f94da326883bd3f95081ab7a4dea1743e107e19d", "filename": "src/test/ui/regions/region-bound-on-closure-outlives-call.nll.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4bd4e4130ed531a644263db26bf8461704215c77/src%2Ftest%2Fui%2Fregions%2Fregion-bound-on-closure-outlives-call.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4bd4e4130ed531a644263db26bf8461704215c77/src%2Ftest%2Fui%2Fregions%2Fregion-bound-on-closure-outlives-call.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregion-bound-on-closure-outlives-call.nll.stderr?ref=4bd4e4130ed531a644263db26bf8461704215c77", "patch": "@@ -1,5 +1,17 @@\n+warning: function cannot return without recursing\n+  --> $DIR/region-bound-on-closure-outlives-call.rs:11:1\n+   |\n+LL | fn call_rec<F>(mut f: F) -> usize where F: FnMut(usize) -> usize {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot return without recursing\n+LL |     //~^ WARN function cannot return without recursing\n+LL |     (|x| f(x))(call_rec(f)) //~ ERROR cannot move out of `f`\n+   |                ----------- recursive call site\n+   |\n+   = note: #[warn(unconditional_recursion)] on by default\n+   = help: a `loop` may express intention better if this is on purpose\n+\n error[E0505]: cannot move out of `f` because it is borrowed\n-  --> $DIR/region-bound-on-closure-outlives-call.rs:12:25\n+  --> $DIR/region-bound-on-closure-outlives-call.rs:13:25\n    |\n LL |     (|x| f(x))(call_rec(f)) //~ ERROR cannot move out of `f`\n    |     ----------          ^ move out of `f` occurs here"}, {"sha": "f931e281c83fc54da1c97b608c5ae0da1322d9a8", "filename": "src/test/ui/regions/region-bound-on-closure-outlives-call.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4bd4e4130ed531a644263db26bf8461704215c77/src%2Ftest%2Fui%2Fregions%2Fregion-bound-on-closure-outlives-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd4e4130ed531a644263db26bf8461704215c77/src%2Ftest%2Fui%2Fregions%2Fregion-bound-on-closure-outlives-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregion-bound-on-closure-outlives-call.rs?ref=4bd4e4130ed531a644263db26bf8461704215c77", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n fn call_rec<F>(mut f: F) -> usize where F: FnMut(usize) -> usize {\n+    //~^ WARN function cannot return without recursing\n     (|x| f(x))(call_rec(f)) //~ ERROR cannot move out of `f`\n }\n "}, {"sha": "6465f1ccf334581d931666084c26acd36ad4a9db", "filename": "src/test/ui/regions/region-bound-on-closure-outlives-call.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4bd4e4130ed531a644263db26bf8461704215c77/src%2Ftest%2Fui%2Fregions%2Fregion-bound-on-closure-outlives-call.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4bd4e4130ed531a644263db26bf8461704215c77/src%2Ftest%2Fui%2Fregions%2Fregion-bound-on-closure-outlives-call.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregion-bound-on-closure-outlives-call.stderr?ref=4bd4e4130ed531a644263db26bf8461704215c77", "patch": "@@ -1,5 +1,17 @@\n+warning: function cannot return without recursing\n+  --> $DIR/region-bound-on-closure-outlives-call.rs:11:1\n+   |\n+LL | fn call_rec<F>(mut f: F) -> usize where F: FnMut(usize) -> usize {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot return without recursing\n+LL |     //~^ WARN function cannot return without recursing\n+LL |     (|x| f(x))(call_rec(f)) //~ ERROR cannot move out of `f`\n+   |                ----------- recursive call site\n+   |\n+   = note: #[warn(unconditional_recursion)] on by default\n+   = help: a `loop` may express intention better if this is on purpose\n+\n error[E0505]: cannot move out of `f` because it is borrowed\n-  --> $DIR/region-bound-on-closure-outlives-call.rs:12:25\n+  --> $DIR/region-bound-on-closure-outlives-call.rs:13:25\n    |\n LL |     (|x| f(x))(call_rec(f)) //~ ERROR cannot move out of `f`\n    |      ---                ^ move out of `f` occurs here"}]}