{"sha": "d59e9b40a3712fa29e59b17cc2a9a10549cae79f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1OWU5YjQwYTM3MTJmYTI5ZTU5YjE3Y2MyYTlhMTA1NDljYWU3OWY=", "commit": {"author": {"name": "Charles Lew", "email": "crlf0710@gmail.com", "date": "2020-01-11T08:56:21Z"}, "committer": {"name": "Charles Lew", "email": "crlf0710@gmail.com", "date": "2020-01-11T17:51:04Z"}, "message": "Implement Cursor for linked lists. (RFC 2570).", "tree": {"sha": "cac03b8bca508d1975e0fb34d7ad0525b5e227bb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cac03b8bca508d1975e0fb34d7ad0525b5e227bb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d59e9b40a3712fa29e59b17cc2a9a10549cae79f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d59e9b40a3712fa29e59b17cc2a9a10549cae79f", "html_url": "https://github.com/rust-lang/rust/commit/d59e9b40a3712fa29e59b17cc2a9a10549cae79f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d59e9b40a3712fa29e59b17cc2a9a10549cae79f/comments", "author": {"login": "crlf0710", "id": 451806, "node_id": "MDQ6VXNlcjQ1MTgwNg==", "avatar_url": "https://avatars.githubusercontent.com/u/451806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/crlf0710", "html_url": "https://github.com/crlf0710", "followers_url": "https://api.github.com/users/crlf0710/followers", "following_url": "https://api.github.com/users/crlf0710/following{/other_user}", "gists_url": "https://api.github.com/users/crlf0710/gists{/gist_id}", "starred_url": "https://api.github.com/users/crlf0710/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/crlf0710/subscriptions", "organizations_url": "https://api.github.com/users/crlf0710/orgs", "repos_url": "https://api.github.com/users/crlf0710/repos", "events_url": "https://api.github.com/users/crlf0710/events{/privacy}", "received_events_url": "https://api.github.com/users/crlf0710/received_events", "type": "User", "site_admin": false}, "committer": {"login": "crlf0710", "id": 451806, "node_id": "MDQ6VXNlcjQ1MTgwNg==", "avatar_url": "https://avatars.githubusercontent.com/u/451806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/crlf0710", "html_url": "https://github.com/crlf0710", "followers_url": "https://api.github.com/users/crlf0710/followers", "following_url": "https://api.github.com/users/crlf0710/following{/other_user}", "gists_url": "https://api.github.com/users/crlf0710/gists{/gist_id}", "starred_url": "https://api.github.com/users/crlf0710/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/crlf0710/subscriptions", "organizations_url": "https://api.github.com/users/crlf0710/orgs", "repos_url": "https://api.github.com/users/crlf0710/repos", "events_url": "https://api.github.com/users/crlf0710/events{/privacy}", "received_events_url": "https://api.github.com/users/crlf0710/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "88d1109600660d1acb471e85631e1ea349843fd9", "url": "https://api.github.com/repos/rust-lang/rust/commits/88d1109600660d1acb471e85631e1ea349843fd9", "html_url": "https://github.com/rust-lang/rust/commit/88d1109600660d1acb471e85631e1ea349843fd9"}], "stats": {"total": 555, "additions": 531, "deletions": 24}, "files": [{"sha": "d0ad1ec283942acc5bb49e38cf35bd9b7c754d79", "filename": "src/liballoc/collections/linked_list.rs", "status": "modified", "additions": 433, "deletions": 24, "changes": 457, "blob_url": "https://github.com/rust-lang/rust/blob/d59e9b40a3712fa29e59b17cc2a9a10549cae79f/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d59e9b40a3712fa29e59b17cc2a9a10549cae79f/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Flinked_list.rs?ref=d59e9b40a3712fa29e59b17cc2a9a10549cae79f", "patch": "@@ -242,6 +242,88 @@ impl<T> LinkedList<T> {\n \n         self.len -= 1;\n     }\n+\n+    /// Splices a series of nodes between two existing nodes.\n+    ///\n+    /// Warning: this will not check that the provided node belongs to the two existing lists.\n+    #[inline]\n+    unsafe fn splice_nodes(\n+        &mut self,\n+        existing_prev: Option<NonNull<Node<T>>>,\n+        existing_next: Option<NonNull<Node<T>>>,\n+        splice_start: NonNull<Node<T>>,\n+        splice_end: NonNull<Node<T>>,\n+        splice_length: usize,\n+    ) {\n+        // This method takes care not to create multiple mutable references to whole nodes at the same time,\n+        // to maintain validity of aliasing pointers into `element`.\n+        if let Some(mut existing_prev) = existing_prev {\n+            existing_prev.as_mut().next = Some(splice_start);\n+        } else {\n+            self.head = Some(splice_start);\n+        }\n+        if let Some(mut existing_next) = existing_next {\n+            existing_next.as_mut().prev = Some(splice_end);\n+        } else {\n+            self.tail = Some(splice_end);\n+        }\n+        let mut splice_start = splice_start;\n+        splice_start.as_mut().prev = existing_prev;\n+        let mut splice_end = splice_end;\n+        splice_end.as_mut().next = existing_next;\n+\n+        self.len += splice_length;\n+    }\n+\n+    /// Detaches all nodes from a linked list as a series of nodes.\n+    #[inline]\n+    fn detach_all_nodes(mut self) -> Option<(NonNull<Node<T>>, NonNull<Node<T>>, usize)> {\n+        let head = self.head.take();\n+        let tail = self.tail.take();\n+        let len = mem::replace(&mut self.len, 0);\n+        if let Some(head) = head {\n+            let tail = tail.unwrap_or_else(|| unsafe { core::hint::unreachable_unchecked() });\n+            Some((head, tail, len))\n+        } else {\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    unsafe fn split_off_after_node(\n+        &mut self,\n+        split_node: Option<NonNull<Node<T>>>,\n+        at: usize,\n+    ) -> Self {\n+        // The split node is the new tail node of the first part and owns\n+        // the head of the second part.\n+        if let Some(mut split_node) = split_node {\n+            let second_part_head;\n+            let second_part_tail;\n+            second_part_head = split_node.as_mut().next.take();\n+            if let Some(mut head) = second_part_head {\n+                head.as_mut().prev = None;\n+                second_part_tail = self.tail;\n+            } else {\n+                second_part_tail = None;\n+            }\n+\n+            let second_part = LinkedList {\n+                head: second_part_head,\n+                tail: second_part_tail,\n+                len: self.len - at,\n+                marker: PhantomData,\n+            };\n+\n+            // Fix the tail ptr of the first part\n+            self.tail = Some(split_node);\n+            self.len = at;\n+\n+            second_part\n+        } else {\n+            mem::replace(self, LinkedList::new())\n+        }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -319,6 +401,27 @@ impl<T> LinkedList<T> {\n         }\n     }\n \n+    /// Moves all elements from `other` to the begin of the list.\n+    #[unstable(feature = \"linked_list_prepend\", issue = \"none\")]\n+    pub fn prepend(&mut self, other: &mut Self) {\n+        match self.head {\n+            None => mem::swap(self, other),\n+            Some(mut head) => {\n+                // `as_mut` is okay here because we have exclusive access to the entirety\n+                // of both lists.\n+                if let Some(mut other_tail) = other.tail.take() {\n+                    unsafe {\n+                        head.as_mut().prev = Some(other_tail);\n+                        other_tail.as_mut().next = Some(head);\n+                    }\n+\n+                    self.head = other.head.take();\n+                    self.len += mem::replace(&mut other.len, 0);\n+                }\n+            }\n+        }\n+    }\n+\n     /// Provides a forward iterator.\n     ///\n     /// # Examples\n@@ -373,6 +476,20 @@ impl<T> LinkedList<T> {\n         IterMut { head: self.head, tail: self.tail, len: self.len, list: self }\n     }\n \n+    /// Provides a cursor.\n+    #[inline]\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn cursor(&self) -> Cursor<'_, T> {\n+        Cursor { index: 0, current: self.head, list: self }\n+    }\n+\n+    /// Provides a cursor with editing operations.\n+    #[inline]\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn cursor_mut(&mut self) -> CursorMut<'_, T> {\n+        CursorMut { index: 0, current: self.head, list: self }\n+    }\n+\n     /// Returns `true` if the `LinkedList` is empty.\n     ///\n     /// This operation should compute in O(1) time.\n@@ -703,30 +820,7 @@ impl<T> LinkedList<T> {\n             }\n             iter.tail\n         };\n-\n-        // The split node is the new tail node of the first part and owns\n-        // the head of the second part.\n-        let second_part_head;\n-\n-        unsafe {\n-            second_part_head = split_node.unwrap().as_mut().next.take();\n-            if let Some(mut head) = second_part_head {\n-                head.as_mut().prev = None;\n-            }\n-        }\n-\n-        let second_part = LinkedList {\n-            head: second_part_head,\n-            tail: self.tail,\n-            len: len - at,\n-            marker: PhantomData,\n-        };\n-\n-        // Fix the tail ptr of the first part\n-        self.tail = split_node;\n-        self.len = at;\n-\n-        second_part\n+        unsafe { self.split_off_after_node(split_node, at) }\n     }\n \n     /// Creates an iterator which uses a closure to determine if an element should be removed.\n@@ -986,6 +1080,321 @@ impl<T> IterMut<'_, T> {\n     }\n }\n \n+/// A cursor over a `LinkedList`.\n+///\n+/// A `Cursor` is like an iterator, except that it can freely seek back-and-forth, and can\n+/// safely mutate the list during iteration. This is because the lifetime of its yielded\n+/// references is tied to its own lifetime, instead of just the underlying list. This means\n+/// cursors cannot yield multiple elements at once.\n+///\n+/// Cursors always rest between two elements in the list, and index in a logically circular way.\n+/// To accommodate this, there is a \"ghost\" non-element that yields `None` between the head and\n+/// tail of the list.\n+///\n+/// When created, cursors start at the front of the list, or the ghost element if the list is empty.\n+#[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+pub struct Cursor<'a, T: 'a> {\n+    index: usize,\n+    current: Option<NonNull<Node<T>>>,\n+    list: &'a LinkedList<T>,\n+}\n+\n+#[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+impl<T: fmt::Debug> fmt::Debug for Cursor<'_, T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_tuple(\"Cursor\").field(&self.list).field(&self.index).finish()\n+    }\n+}\n+\n+/// A cursor over a `LinkedList` with editing operations.\n+///\n+/// A `Cursor` is like an iterator, except that it can freely seek back-and-forth, and can\n+/// safely mutate the list during iteration. This is because the lifetime of its yielded\n+/// references is tied to its own lifetime, instead of just the underlying list. This means\n+/// cursors cannot yield multiple elements at once.\n+///\n+/// Cursors always rest between two elements in the list, and index in a logically circular way.\n+/// To accommodate this, there is a \"ghost\" non-element that yields `None` between the head and\n+/// tail of the list.\n+///\n+/// When created, cursors start at the front of the list, or the ghost element if the list is empty.\n+#[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+pub struct CursorMut<'a, T: 'a> {\n+    index: usize,\n+    current: Option<NonNull<Node<T>>>,\n+    list: &'a mut LinkedList<T>,\n+}\n+\n+#[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+impl<T: fmt::Debug> fmt::Debug for CursorMut<'_, T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_tuple(\"CursorMut\").field(&self.list).field(&self.index).finish()\n+    }\n+}\n+\n+impl<'a, T> Cursor<'a, T> {\n+    /// Move to the subsequent element of the list if it exists or the empty\n+    /// element\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn move_next(&mut self) {\n+        match self.current.take() {\n+            // We had no current element; the cursor was sitting at the start position\n+            // Next element should be the head of the list\n+            None => {\n+                self.current = self.list.head;\n+                self.index = 0;\n+            }\n+            // We had a previous element, so let's go to its next\n+            Some(current) => unsafe {\n+                self.current = current.as_ref().next;\n+                self.index += 1;\n+            },\n+        }\n+    }\n+\n+    /// Move to the previous element of the list\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn move_prev(&mut self) {\n+        match self.current.take() {\n+            // No current. We're at the start of the list. Yield None and jump to the end.\n+            None => {\n+                self.current = self.list.tail;\n+                self.index = self.list.len().checked_sub(1).unwrap_or(0);\n+            }\n+            // Have a prev. Yield it and go to the previous element.\n+            Some(current) => unsafe {\n+                self.current = current.as_ref().prev;\n+                self.index = self.index.checked_sub(1).unwrap_or_else(|| self.list.len());\n+            },\n+        }\n+    }\n+\n+    /// Get the current element\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn current(&self) -> Option<&'a T> {\n+        unsafe { self.current.map(|current| &(*current.as_ptr()).element) }\n+    }\n+\n+    /// Get the next element\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn peek_next(&self) -> Option<&'a T> {\n+        unsafe {\n+            let next = match self.current {\n+                None => self.list.head,\n+                Some(current) => current.as_ref().next,\n+            };\n+            next.map(|next| &(*next.as_ptr()).element)\n+        }\n+    }\n+\n+    /// Get the previous element\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn peek_prev(&self) -> Option<&'a T> {\n+        unsafe {\n+            let prev = match self.current {\n+                None => self.list.tail,\n+                Some(current) => current.as_ref().prev,\n+            };\n+            prev.map(|prev| &(*prev.as_ptr()).element)\n+        }\n+    }\n+}\n+\n+impl<'a, T> CursorMut<'a, T> {\n+    /// Move to the subsequent element of the list if it exists or the empty\n+    /// element\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn move_next(&mut self) {\n+        match self.current.take() {\n+            // We had no current element; the cursor was sitting at the start position\n+            // Next element should be the head of the list\n+            None => {\n+                self.current = self.list.head;\n+                self.index = 0;\n+            }\n+            // We had a previous element, so let's go to its next\n+            Some(current) => unsafe {\n+                self.current = current.as_ref().next;\n+                self.index += 1;\n+            },\n+        }\n+    }\n+\n+    /// Move to the previous element of the list\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn move_prev(&mut self) {\n+        match self.current.take() {\n+            // No current. We're at the start of the list. Yield None and jump to the end.\n+            None => {\n+                self.current = self.list.tail;\n+                self.index = self.list.len().checked_sub(1).unwrap_or(0);\n+            }\n+            // Have a prev. Yield it and go to the previous element.\n+            Some(current) => unsafe {\n+                self.current = current.as_ref().prev;\n+                self.index = self.index.checked_sub(1).unwrap_or_else(|| self.list.len());\n+            },\n+        }\n+    }\n+\n+    /// Get the current element\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn current(&mut self) -> Option<&mut T> {\n+        unsafe { self.current.map(|current| &mut (*current.as_ptr()).element) }\n+    }\n+\n+    /// Get the next element\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn peek_next(&mut self) -> Option<&mut T> {\n+        unsafe {\n+            let next = match self.current {\n+                None => self.list.head,\n+                Some(current) => current.as_ref().next,\n+            };\n+            next.map(|next| &mut (*next.as_ptr()).element)\n+        }\n+    }\n+\n+    /// Get the previous element\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn peek_prev(&mut self) -> Option<&mut T> {\n+        unsafe {\n+            let prev = match self.current {\n+                None => self.list.tail,\n+                Some(current) => current.as_ref().prev,\n+            };\n+            prev.map(|prev| &mut (*prev.as_ptr()).element)\n+        }\n+    }\n+\n+    /// Get an immutable cursor at the current element\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn as_cursor<'cm>(&'cm self) -> Cursor<'cm, T> {\n+        Cursor { list: self.list, current: self.current, index: self.index }\n+    }\n+}\n+\n+// Now the list editing operations\n+\n+impl<'a, T> CursorMut<'a, T> {\n+    /// Insert `item` after the cursor\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn insert_after(&mut self, item: T) {\n+        unsafe {\n+            let spliced_node = Box::into_raw_non_null(Box::new(Node::new(item)));\n+            let (node, node_next) = match self.current {\n+                None => (None, self.list.head),\n+                Some(node) => {\n+                    let node_next = node.as_ref().next;\n+                    (Some(node), node_next)\n+                }\n+            };\n+            self.list.splice_nodes(node, node_next, spliced_node, spliced_node, 1);\n+            if self.current.is_none() {\n+                // The ghost element's index has increased by 1.\n+                self.index += 1;\n+            }\n+        }\n+    }\n+\n+    /// Insert `item` before the cursor\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn insert_before(&mut self, item: T) {\n+        unsafe {\n+            let spliced_node = Box::into_raw_non_null(Box::new(Node::new(item)));\n+            let (node_prev, node) = match self.current {\n+                None => (self.list.tail, None),\n+                Some(node) => {\n+                    let node_prev = node.as_ref().prev;\n+                    (node_prev, Some(node))\n+                }\n+            };\n+            self.list.splice_nodes(node_prev, node, spliced_node, spliced_node, 1);\n+            self.index += 1;\n+        }\n+    }\n+\n+    /// Remove and return the current item, moving the cursor to the next item\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn remove(&mut self) -> Option<T> {\n+        let unlinked_node = self.current?;\n+        unsafe {\n+            self.current = unlinked_node.as_ref().next;\n+            self.list.unlink_node(unlinked_node);\n+            let unlinked_node = Box::from_raw(unlinked_node.as_ptr());\n+            Some((*unlinked_node).element)\n+        }\n+    }\n+\n+    /// Insert `list` between the current element and the next\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn splice_after(&mut self, list: LinkedList<T>) {\n+        unsafe {\n+            let (splice_head, splice_tail, splice_len) = match list.detach_all_nodes() {\n+                Some(parts) => parts,\n+                _ => return,\n+            };\n+            let (node, node_next) = match self.current {\n+                None => (None, self.list.head),\n+                Some(node) => {\n+                    let node_next = node.as_ref().next;\n+                    (Some(node), node_next)\n+                }\n+            };\n+            self.list.splice_nodes(node, node_next, splice_head, splice_tail, splice_len);\n+            if self.current.is_none() {\n+                // The ghost element's index has increased by `splice_len`.\n+                self.index += splice_len;\n+            }\n+        }\n+    }\n+\n+    /// Insert `list` between the previous element and current\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn splice_before(&mut self, list: LinkedList<T>) {\n+        unsafe {\n+            let (splice_head, splice_tail, splice_len) = match list.detach_all_nodes() {\n+                Some(parts) => parts,\n+                _ => return,\n+            };\n+            let (node_prev, node) = match self.current {\n+                None => (self.list.tail, None),\n+                Some(node) => {\n+                    let node_prev = node.as_ref().prev;\n+                    (node_prev, Some(node))\n+                }\n+            };\n+            self.list.splice_nodes(node_prev, node, splice_head, splice_tail, splice_len);\n+            self.index += splice_len;\n+        }\n+    }\n+\n+    /// Split the list in two after the current element\n+    /// The returned list consists of all elements following the current one.\n+    // note: consuming the cursor is not necessary here, but it makes sense\n+    // given the interface\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn split_after(self) -> LinkedList<T> {\n+        let split_off_idx = if self.index == self.list.len { 0 } else { self.index + 1 };\n+        unsafe {\n+            let split_off_node = self.current;\n+            self.list.split_off_after_node(split_off_node, split_off_idx)\n+        }\n+    }\n+    /// Split the list in two before the current element\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn split_before(self) -> LinkedList<T> {\n+        let split_off_idx = self.index;\n+        unsafe {\n+            let split_off_node = match self.current {\n+                Some(node) => node.as_ref().prev,\n+                None => self.list.tail,\n+            };\n+            self.list.split_off_after_node(split_off_node, split_off_idx)\n+        }\n+    }\n+}\n+\n /// An iterator produced by calling `drain_filter` on LinkedList.\n #[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n pub struct DrainFilter<'a, T: 'a, F: 'a>"}, {"sha": "51b23e23cd276e07827c3c593289551972326d82", "filename": "src/liballoc/collections/linked_list/tests.rs", "status": "modified", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/d59e9b40a3712fa29e59b17cc2a9a10549cae79f/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d59e9b40a3712fa29e59b17cc2a9a10549cae79f/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs?ref=d59e9b40a3712fa29e59b17cc2a9a10549cae79f", "patch": "@@ -304,3 +304,101 @@ fn drain_to_empty_test() {\n     assert_eq!(deleted, &[1, 2, 3, 4, 5, 6]);\n     assert_eq!(m.into_iter().collect::<Vec<_>>(), &[]);\n }\n+\n+#[test]\n+fn test_cursor_move_peek() {\n+    let mut m: LinkedList<u32> = LinkedList::new();\n+    m.extend(&[1, 2, 3, 4, 5, 6]);\n+    let mut cursor = m.cursor();\n+    assert_eq!(cursor.current(), Some(&1));\n+    assert_eq!(cursor.peek_next(), Some(&2));\n+    assert_eq!(cursor.peek_prev(), None);\n+    cursor.move_prev();\n+    assert_eq!(cursor.current(), None);\n+    assert_eq!(cursor.peek_next(), Some(&1));\n+    assert_eq!(cursor.peek_prev(), Some(&6));\n+    cursor.move_next();\n+    cursor.move_next();\n+    assert_eq!(cursor.current(), Some(&2));\n+    assert_eq!(cursor.peek_next(), Some(&3));\n+    assert_eq!(cursor.peek_prev(), Some(&1));\n+\n+    let mut m: LinkedList<u32> = LinkedList::new();\n+    m.extend(&[1, 2, 3, 4, 5, 6]);\n+    let mut cursor = m.cursor_mut();\n+    assert_eq!(cursor.current(), Some(&mut 1));\n+    assert_eq!(cursor.peek_next(), Some(&mut 2));\n+    assert_eq!(cursor.peek_prev(), None);\n+    cursor.move_prev();\n+    assert_eq!(cursor.current(), None);\n+    assert_eq!(cursor.peek_next(), Some(&mut 1));\n+    assert_eq!(cursor.peek_prev(), Some(&mut 6));\n+    cursor.move_next();\n+    cursor.move_next();\n+    assert_eq!(cursor.current(), Some(&mut 2));\n+    assert_eq!(cursor.peek_next(), Some(&mut 3));\n+    assert_eq!(cursor.peek_prev(), Some(&mut 1));\n+    let mut cursor2 = cursor.as_cursor();\n+    assert_eq!(cursor2.current(), Some(&2));\n+    cursor2.move_next();\n+    assert_eq!(cursor2.current(), Some(&3));\n+    assert_eq!(cursor.current(), Some(&mut 2));\n+}\n+\n+#[test]\n+fn test_cursor_mut_insert() {\n+    let mut m: LinkedList<u32> = LinkedList::new();\n+    m.extend(&[1, 2, 3, 4, 5, 6]);\n+    let mut cursor = m.cursor_mut();\n+    cursor.insert_before(7);\n+    cursor.insert_after(8);\n+    check_links(&m);\n+    assert_eq!(m.iter().cloned().collect::<Vec<_>>(), &[7, 1, 8, 2, 3, 4, 5, 6]);\n+    let mut cursor = m.cursor_mut();\n+    cursor.move_prev();\n+    cursor.insert_before(9);\n+    cursor.insert_after(10);\n+    check_links(&m);\n+    assert_eq!(m.iter().cloned().collect::<Vec<_>>(), &[10, 7, 1, 8, 2, 3, 4, 5, 6, 9]);\n+    let mut cursor = m.cursor_mut();\n+    cursor.move_prev();\n+    assert_eq!(cursor.remove(), None);\n+    cursor.move_next();\n+    cursor.move_next();\n+    assert_eq!(cursor.remove(), Some(7));\n+    cursor.move_prev();\n+    cursor.move_prev();\n+    cursor.move_prev();\n+    assert_eq!(cursor.remove(), Some(9));\n+    cursor.move_next();\n+    assert_eq!(cursor.remove(), Some(10));\n+    check_links(&m);\n+    assert_eq!(m.iter().cloned().collect::<Vec<_>>(), &[1, 8, 2, 3, 4, 5, 6]);\n+    let mut cursor = m.cursor_mut();\n+    let mut p: LinkedList<u32> = LinkedList::new();\n+    p.extend(&[100, 101, 102, 103]);\n+    let mut q: LinkedList<u32> = LinkedList::new();\n+    q.extend(&[200, 201, 202, 203]);\n+    cursor.splice_after(p);\n+    cursor.splice_before(q);\n+    check_links(&m);\n+    assert_eq!(\n+        m.iter().cloned().collect::<Vec<_>>(),\n+        &[200, 201, 202, 203, 1, 100, 101, 102, 103, 8, 2, 3, 4, 5, 6]\n+    );\n+    let mut cursor = m.cursor_mut();\n+    cursor.move_prev();\n+    let tmp = cursor.split_before();\n+    assert_eq!(tmp.into_iter().collect::<Vec<_>>(), &[]);\n+    let mut cursor = m.cursor_mut();\n+    cursor.move_next();\n+    cursor.move_next();\n+    cursor.move_next();\n+    cursor.move_next();\n+    cursor.move_next();\n+    cursor.move_next();\n+    let tmp = cursor.split_after();\n+    assert_eq!(tmp.into_iter().collect::<Vec<_>>(), &[102, 103, 8, 2, 3, 4, 5, 6]);\n+    check_links(&m);\n+    assert_eq!(m.iter().cloned().collect::<Vec<_>>(), &[200, 201, 202, 203, 1, 100, 101]);\n+}"}]}