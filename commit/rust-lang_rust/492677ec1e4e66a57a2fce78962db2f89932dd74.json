{"sha": "492677ec1e4e66a57a2fce78962db2f89932dd74", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5MjY3N2VjMWU0ZTY2YTU3YTJmY2U3ODk2MmRiMmY4OTkzMmRkNzQ=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-11-19T20:21:21Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-11-19T20:40:19Z"}, "message": "libsyntax: Change all uses of `&fn` to `||`.", "tree": {"sha": "7215ca2d3af530efb17aee207f95365ca374ac00", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7215ca2d3af530efb17aee207f95365ca374ac00"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/492677ec1e4e66a57a2fce78962db2f89932dd74", "comment_count": 3, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/492677ec1e4e66a57a2fce78962db2f89932dd74", "html_url": "https://github.com/rust-lang/rust/commit/492677ec1e4e66a57a2fce78962db2f89932dd74", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/492677ec1e4e66a57a2fce78962db2f89932dd74/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18a30aff4564437ccd2698be367ca98c81122ac0", "url": "https://api.github.com/repos/rust-lang/rust/commits/18a30aff4564437ccd2698be367ca98c81122ac0", "html_url": "https://github.com/rust-lang/rust/commit/18a30aff4564437ccd2698be367ca98c81122ac0"}], "stats": {"total": 250, "additions": 139, "deletions": 111}, "files": [{"sha": "c2283bf1227ed7faf6f6d6418247c1593f00d362", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/492677ec1e4e66a57a2fce78962db2f89932dd74/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/492677ec1e4e66a57a2fce78962db2f89932dd74/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=492677ec1e4e66a57a2fce78962db2f89932dd74", "patch": "@@ -84,7 +84,7 @@ static AbiDatas: &'static [AbiData] = &[\n     AbiData {abi: RustIntrinsic, name: \"rust-intrinsic\", abi_arch: RustArch},\n ];\n \n-fn each_abi(op: &fn(abi: Abi) -> bool) -> bool {\n+fn each_abi(op: |abi: Abi| -> bool) -> bool {\n     /*!\n      *\n      * Iterates through each of the defined ABIs.\n@@ -201,7 +201,7 @@ impl AbiSet {\n         self.bits |= (1 << abi.index());\n     }\n \n-    pub fn each(&self, op: &fn(abi: Abi) -> bool) -> bool {\n+    pub fn each(&self, op: |abi: Abi| -> bool) -> bool {\n         each_abi(|abi| !self.contains(abi) || op(abi))\n     }\n "}, {"sha": "c5ad371491757488aa0ef1387e6266627b094cee", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/492677ec1e4e66a57a2fce78962db2f89932dd74/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/492677ec1e4e66a57a2fce78962db2f89932dd74/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=492677ec1e4e66a57a2fce78962db2f89932dd74", "patch": "@@ -122,7 +122,7 @@ pub enum ast_node {\n }\n \n impl ast_node {\n-    pub fn with_attrs<T>(&self, f: &fn(Option<&[Attribute]>) -> T) -> T {\n+    pub fn with_attrs<T>(&self, f: |Option<&[Attribute]>| -> T) -> T {\n         let attrs = match *self {\n             node_item(i, _) => Some(i.attrs.as_slice()),\n             node_foreign_item(fi, _, _, _) => Some(fi.attrs.as_slice()),\n@@ -480,9 +480,8 @@ pub fn node_id_to_str(map: map, id: NodeId, itr: @ident_interner) -> ~str {\n     }\n }\n \n-pub fn node_item_query<Result>(items: map, id: NodeId,\n-                               query: &fn(@item) -> Result,\n-                               error_msg: ~str) -> Result {\n+pub fn node_item_query<Result>(items: map, id: NodeId, query: |@item| -> Result, error_msg: ~str)\n+                       -> Result {\n     match items.find(&id) {\n         Some(&node_item(it, _)) => query(it),\n         _ => fail!(\"{}\", error_msg)"}, {"sha": "a49109911de423cd3de4c1ff396aafcbf64b8e50", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/492677ec1e4e66a57a2fce78962db2f89932dd74/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/492677ec1e4e66a57a2fce78962db2f89932dd74/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=492677ec1e4e66a57a2fce78962db2f89932dd74", "patch": "@@ -636,7 +636,7 @@ pub fn is_item_impl(item: @ast::item) -> bool {\n     }\n }\n \n-pub fn walk_pat(pat: @Pat, it: &fn(@Pat) -> bool) -> bool {\n+pub fn walk_pat(pat: @Pat, it: |@Pat| -> bool) -> bool {\n     if !it(pat) {\n         return false;\n     }\n@@ -665,7 +665,7 @@ pub fn walk_pat(pat: @Pat, it: &fn(@Pat) -> bool) -> bool {\n }\n \n pub trait EachViewItem {\n-    fn each_view_item(&self, f: &fn(&ast::view_item) -> bool) -> bool;\n+    fn each_view_item(&self, f: |&ast::view_item| -> bool) -> bool;\n }\n \n struct EachViewItemData<'self> {\n@@ -679,7 +679,7 @@ impl<'self> Visitor<()> for EachViewItemData<'self> {\n }\n \n impl EachViewItem for ast::Crate {\n-    fn each_view_item(&self, f: &fn(&ast::view_item) -> bool) -> bool {\n+    fn each_view_item(&self, f: |&ast::view_item| -> bool) -> bool {\n         let mut visit = EachViewItemData {\n             callback: f,\n         };"}, {"sha": "15b827306294980ea1d60cb63ae2416cadad4524", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/492677ec1e4e66a57a2fce78962db2f89932dd74/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/492677ec1e4e66a57a2fce78962db2f89932dd74/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=492677ec1e4e66a57a2fce78962db2f89932dd74", "patch": "@@ -347,9 +347,11 @@ fn print_macro_backtrace(cm: @codemap::CodeMap, sp: Span) {\n     }\n }\n \n-pub fn expect<T:Clone>(diag: @mut span_handler,\n-                       opt: Option<T>,\n-                       msg: &fn() -> ~str) -> T {\n+pub fn expect<T:Clone>(\n+              diag: @mut span_handler,\n+              opt: Option<T>,\n+              msg: || -> ~str)\n+              -> T {\n     match opt {\n        Some(ref t) => (*t).clone(),\n        None => diag.handler().bug(msg()),"}, {"sha": "448f8ee88f90a33f67634d24b5b136c25ac0ab9e", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/492677ec1e4e66a57a2fce78962db2f89932dd74/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/492677ec1e4e66a57a2fce78962db2f89932dd74/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=492677ec1e4e66a57a2fce78962db2f89932dd74", "patch": "@@ -559,11 +559,11 @@ impl <K: Eq + Hash + IterBytes + 'static, V: 'static> MapChain<K,V>{\n     // should each_key and each_value operate on shadowed\n     // names? I think not.\n     // delaying implementing this....\n-    pub fn each_key (&self, _f: &fn (&K)->bool) {\n+    pub fn each_key (&self, _f: |&K| -> bool) {\n         fail!(\"unimplemented 2013-02-15T10:01\");\n     }\n \n-    pub fn each_value (&self, _f: &fn (&V) -> bool) {\n+    pub fn each_value (&self, _f: |&V| -> bool) {\n         fail!(\"unimplemented 2013-02-15T10:02\");\n     }\n \n@@ -601,7 +601,11 @@ impl <K: Eq + Hash + IterBytes + 'static, V: 'static> MapChain<K,V>{\n     // ... there are definitely some opportunities for abstraction\n     // here that I'm ignoring. (e.g., manufacturing a predicate on\n     // the maps in the chain, and using an abstract \"find\".\n-    pub fn insert_into_frame(&mut self, key: K, ext: @V, n: K, pred: &fn(&@V)->bool) {\n+    pub fn insert_into_frame(&mut self,\n+                             key: K,\n+                             ext: @V,\n+                             n: K,\n+                             pred: |&@V| -> bool) {\n         match *self {\n             BaseMapChain (~ref mut map) => {\n                 if satisfies_pred(map,&n,pred) {\n@@ -622,10 +626,12 @@ impl <K: Eq + Hash + IterBytes + 'static, V: 'static> MapChain<K,V>{\n }\n \n // returns true if the binding for 'n' satisfies 'pred' in 'map'\n-fn satisfies_pred<K : Eq + Hash + IterBytes,V>(map : &mut HashMap<K,V>,\n-                                               n: &K,\n-                                               pred: &fn(&V)->bool)\n-    -> bool {\n+fn satisfies_pred<K:Eq + Hash + IterBytes,\n+                  V>(\n+                  map: &mut HashMap<K,V>,\n+                  n: &K,\n+                  pred: |&V| -> bool)\n+                  -> bool {\n     match map.find(n) {\n         Some(ref v) => (pred(*v)),\n         None => false\n@@ -637,7 +643,8 @@ mod test {\n     use super::MapChain;\n     use std::hashmap::HashMap;\n \n-    #[test] fn testenv () {\n+    #[test]\n+    fn testenv() {\n         let mut a = HashMap::new();\n         a.insert (@\"abc\",@15);\n         let m = MapChain::new(~a);"}, {"sha": "2f9222ccb56f63e7b1daacd7c2dcd25c06dac5ff", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/492677ec1e4e66a57a2fce78962db2f89932dd74/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/492677ec1e4e66a57a2fce78962db2f89932dd74/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=492677ec1e4e66a57a2fce78962db2f89932dd74", "patch": "@@ -124,9 +124,12 @@ fn decodable_substructure(cx: @ExtCtxt, span: Span,\n /// Create a decoder for a single enum variant/struct:\n /// - `outer_pat_ident` is the name of this enum variant/struct\n /// - `getarg` should retrieve the `uint`-th field with name `@str`.\n-fn decode_static_fields(cx: @ExtCtxt, outer_span: Span, outer_pat_ident: Ident,\n+fn decode_static_fields(cx: @ExtCtxt,\n+                        outer_span: Span,\n+                        outer_pat_ident: Ident,\n                         fields: &StaticFields,\n-                        getarg: &fn(Span, @str, uint) -> @Expr) -> @Expr {\n+                        getarg: |Span, @str, uint| -> @Expr)\n+                        -> @Expr {\n     match *fields {\n         Unnamed(ref fields) => {\n             if fields.is_empty() {"}, {"sha": "23dc38fdc31e579414bb154bf36f7698562af9a5", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/492677ec1e4e66a57a2fce78962db2f89932dd74/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/492677ec1e4e66a57a2fce78962db2f89932dd74/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=492677ec1e4e66a57a2fce78962db2f89932dd74", "patch": "@@ -1064,14 +1064,13 @@ Fold the fields. `use_foldl` controls whether this is done\n left-to-right (`true`) or right-to-left (`false`).\n */\n pub fn cs_fold(use_foldl: bool,\n-               f: &fn(@ExtCtxt, Span,\n-                      old: @Expr,\n-                      self_f: @Expr,\n-                      other_fs: &[@Expr]) -> @Expr,\n+               f: |@ExtCtxt, Span, @Expr, @Expr, &[@Expr]| -> @Expr,\n                base: @Expr,\n                enum_nonmatch_f: EnumNonMatchFunc,\n-               cx: @ExtCtxt, trait_span: Span,\n-               substructure: &Substructure) -> @Expr {\n+               cx: @ExtCtxt,\n+               trait_span: Span,\n+               substructure: &Substructure)\n+               -> @Expr {\n     match *substructure.fields {\n         EnumMatching(_, _, ref all_fields) | Struct(ref all_fields) => {\n             if use_foldl {\n@@ -1104,10 +1103,12 @@ f(cx, span, ~[self_1.method(__arg_1_1, __arg_2_1),\n ~~~\n */\n #[inline]\n-pub fn cs_same_method(f: &fn(@ExtCtxt, Span, ~[@Expr]) -> @Expr,\n+pub fn cs_same_method(f: |@ExtCtxt, Span, ~[@Expr]| -> @Expr,\n                       enum_nonmatch_f: EnumNonMatchFunc,\n-                      cx: @ExtCtxt, trait_span: Span,\n-                      substructure: &Substructure) -> @Expr {\n+                      cx: @ExtCtxt,\n+                      trait_span: Span,\n+                      substructure: &Substructure)\n+                      -> @Expr {\n     match *substructure.fields {\n         EnumMatching(_, _, ref all_fields) | Struct(ref all_fields) => {\n             // call self_n.method(other_1_n, other_2_n, ...)\n@@ -1136,11 +1137,13 @@ fields. `use_foldl` controls whether this is done left-to-right\n */\n #[inline]\n pub fn cs_same_method_fold(use_foldl: bool,\n-                           f: &fn(@ExtCtxt, Span, @Expr, @Expr) -> @Expr,\n+                           f: |@ExtCtxt, Span, @Expr, @Expr| -> @Expr,\n                            base: @Expr,\n                            enum_nonmatch_f: EnumNonMatchFunc,\n-                           cx: @ExtCtxt, trait_span: Span,\n-                           substructure: &Substructure) -> @Expr {\n+                           cx: @ExtCtxt,\n+                           trait_span: Span,\n+                           substructure: &Substructure)\n+                           -> @Expr {\n     cs_same_method(\n         |cx, span, vals| {\n             if use_foldl {"}, {"sha": "1877a6eb85bef277ed89211fa16a05ac9343376f", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/492677ec1e4e66a57a2fce78962db2f89932dd74/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/492677ec1e4e66a57a2fce78962db2f89932dd74/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=492677ec1e4e66a57a2fce78962db2f89932dd74", "patch": "@@ -128,10 +128,12 @@ fn rand_substructure(cx: @ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n         _ => cx.bug(\"Non-static method in `deriving(Rand)`\")\n     };\n \n-    fn rand_thing(cx: @ExtCtxt, span: Span,\n+    fn rand_thing(cx: @ExtCtxt,\n+                  span: Span,\n                   ctor_ident: Ident,\n                   summary: &StaticFields,\n-                  rand_call: &fn(Span) -> @Expr) -> @Expr {\n+                  rand_call: |Span| -> @Expr)\n+                  -> @Expr {\n         match *summary {\n             Unnamed(ref fields) => {\n                 if fields.is_empty() {"}, {"sha": "62592650416dafa3360afe9bf96e2570a67e6854", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/492677ec1e4e66a57a2fce78962db2f89932dd74/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/492677ec1e4e66a57a2fce78962db2f89932dd74/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=492677ec1e4e66a57a2fce78962db2f89932dd74", "patch": "@@ -381,7 +381,7 @@ pub trait ast_fold {\n         }\n     }\n \n-    fn map_exprs(&self, f: &fn(@Expr) -> @Expr, es: &[@Expr]) -> ~[@Expr] {\n+    fn map_exprs(&self, f: |@Expr| -> @Expr, es: &[@Expr]) -> ~[@Expr] {\n         es.map(|x| f(*x))\n     }\n "}, {"sha": "3a0b7c6adc44f44bd9a40b65aa185109394d721a", "filename": "src/libsyntax/opt_vec.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/492677ec1e4e66a57a2fce78962db2f89932dd74/src%2Flibsyntax%2Fopt_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/492677ec1e4e66a57a2fce78962db2f89932dd74/src%2Flibsyntax%2Fopt_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fopt_vec.rs?ref=492677ec1e4e66a57a2fce78962db2f89932dd74", "patch": "@@ -50,14 +50,14 @@ impl<T> OptVec<T> {\n         *self = Vec(~[t]);\n     }\n \n-    pub fn map<U>(&self, op: &fn(&T) -> U) -> OptVec<U> {\n+    pub fn map<U>(&self, op: |&T| -> U) -> OptVec<U> {\n         match *self {\n             Empty => Empty,\n             Vec(ref v) => Vec(v.map(op))\n         }\n     }\n \n-    pub fn map_move<U>(self, op: &fn(T) -> U) -> OptVec<U> {\n+    pub fn map_move<U>(self, op: |T| -> U) -> OptVec<U> {\n         match self {\n             Empty => Empty,\n             Vec(v) => Vec(v.move_iter().map(op).collect())\n@@ -91,11 +91,11 @@ impl<T> OptVec<T> {\n     }\n \n     #[inline]\n-    pub fn map_to_vec<B>(&self, op: &fn(&T) -> B) -> ~[B] {\n+    pub fn map_to_vec<B>(&self, op: |&T| -> B) -> ~[B] {\n         self.iter().map(op).collect()\n     }\n \n-    pub fn mapi_to_vec<B>(&self, op: &fn(uint, &T) -> B) -> ~[B] {\n+    pub fn mapi_to_vec<B>(&self, op: |uint, &T| -> B) -> ~[B] {\n         let mut index = 0;\n         self.map_to_vec(|a| {\n             let i = index;"}, {"sha": "26de9215dbfdbf15849a2d903a2de48447a3c8a1", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/492677ec1e4e66a57a2fce78962db2f89932dd74/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/492677ec1e4e66a57a2fce78962db2f89932dd74/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=492677ec1e4e66a57a2fce78962db2f89932dd74", "patch": "@@ -216,16 +216,22 @@ fn byte_offset(rdr: &StringReader, pos: BytePos) -> BytePos {\n /// Calls `f` with a string slice of the source text spanning from `start`\n /// up to but excluding `rdr.last_pos`, meaning the slice does not include\n /// the character `rdr.curr`.\n-pub fn with_str_from<T>(rdr: @mut StringReader, start: BytePos, f: &fn(s: &str) -> T) -> T {\n+pub fn with_str_from<T>(\n+                     rdr: @mut StringReader,\n+                     start: BytePos,\n+                     f: |s: &str| -> T)\n+                     -> T {\n     with_str_from_to(rdr, start, rdr.last_pos, f)\n }\n \n /// Calls `f` with astring slice of the source text spanning from `start`\n /// up to but excluding `end`.\n-fn with_str_from_to<T>(rdr: @mut StringReader,\n-                       start: BytePos,\n-                       end: BytePos,\n-                       f: &fn(s: &str) -> T) -> T {\n+fn with_str_from_to<T>(\n+                    rdr: @mut StringReader,\n+                    start: BytePos,\n+                    end: BytePos,\n+                    f: |s: &str| -> T)\n+                    -> T {\n     f(rdr.src.slice(\n             byte_offset(rdr, start).to_uint(),\n             byte_offset(rdr, end).to_uint()))"}, {"sha": "947f7a7fc29a8c1e4be782b182bb83c4c6203cb5", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/492677ec1e4e66a57a2fce78962db2f89932dd74/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/492677ec1e4e66a57a2fce78962db2f89932dd74/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=492677ec1e4e66a57a2fce78962db2f89932dd74", "patch": "@@ -177,19 +177,14 @@ pub fn parse_tts_from_source_str(\n // consumed all of the input before returning the function's\n // result.\n pub fn parse_from_source_str<T>(\n-    f: &fn(&Parser) -> T,\n-    name: @str, ss: codemap::FileSubstr,\n-    source: @str,\n-    cfg: ast::CrateConfig,\n-    sess: @mut ParseSess\n-) -> T {\n-    let p = new_parser_from_source_substr(\n-        sess,\n-        cfg,\n-        name,\n-        ss,\n-        source\n-    );\n+                             f: |&Parser| -> T,\n+                             name: @str,\n+                             ss: codemap::FileSubstr,\n+                             source: @str,\n+                             cfg: ast::CrateConfig,\n+                             sess: @mut ParseSess)\n+                             -> T {\n+    let p = new_parser_from_source_substr(sess, cfg, name, ss, source);\n     let r = f(&p);\n     if !p.reader.is_eof() {\n         p.reader.fatal(~\"expected end-of-string\");"}, {"sha": "3adedf76eb840cfa97547c364483a6e06e96b967", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/492677ec1e4e66a57a2fce78962db2f89932dd74/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/492677ec1e4e66a57a2fce78962db2f89932dd74/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=492677ec1e4e66a57a2fce78962db2f89932dd74", "patch": "@@ -82,7 +82,7 @@ impl ParserObsoleteMethods for Parser {\n             ),\n             ObsoleteBareFnType => (\n                 \"bare function type\",\n-                \"use `&fn` or `extern fn` instead\"\n+                \"use `|A| -> B` or `extern fn(A) -> B` instead\"\n             ),\n             ObsoleteNamedExternModule => (\n                 \"named external module\","}, {"sha": "6c2df4ad3142a202d7714e34d5666c887bb75fce", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 53, "deletions": 46, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/492677ec1e4e66a57a2fce78962db2f89932dd74/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/492677ec1e4e66a57a2fce78962db2f89932dd74/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=492677ec1e4e66a57a2fce78962db2f89932dd74", "patch": "@@ -581,10 +581,8 @@ impl Parser {\n     }\n \n     // Parse a sequence bracketed by `|` and `|`, stopping before the `|`.\n-    fn parse_seq_to_before_or<T>(&self,\n-                                 sep: &token::Token,\n-                                 f: &fn(&Parser) -> T)\n-                                 -> ~[T] {\n+    fn parse_seq_to_before_or<T>(&self, sep: &token::Token, f: |&Parser| -> T)\n+                              -> ~[T] {\n         let mut first = true;\n         let mut vector = ~[];\n         while *self.token != token::BINOP(token::OR) &&\n@@ -619,10 +617,11 @@ impl Parser {\n \n     // parse a sequence bracketed by '<' and '>', stopping\n     // before the '>'.\n-    pub fn parse_seq_to_before_gt<T>(&self,\n-                                     sep: Option<token::Token>,\n-                                     f: &fn(&Parser) -> T)\n-                                     -> OptVec<T> {\n+    pub fn parse_seq_to_before_gt<T>(\n+                                  &self,\n+                                  sep: Option<token::Token>,\n+                                  f: |&Parser| -> T)\n+                                  -> OptVec<T> {\n         let mut first = true;\n         let mut v = opt_vec::Empty;\n         while *self.token != token::GT\n@@ -639,10 +638,11 @@ impl Parser {\n         return v;\n     }\n \n-    pub fn parse_seq_to_gt<T>(&self,\n-                              sep: Option<token::Token>,\n-                              f: &fn(&Parser) -> T)\n-                              -> OptVec<T> {\n+    pub fn parse_seq_to_gt<T>(\n+                           &self,\n+                           sep: Option<token::Token>,\n+                           f: |&Parser| -> T)\n+                           -> OptVec<T> {\n         let v = self.parse_seq_to_before_gt(sep, f);\n         self.expect_gt();\n         return v;\n@@ -651,11 +651,12 @@ impl Parser {\n     // parse a sequence, including the closing delimiter. The function\n     // f must consume tokens until reaching the next separator or\n     // closing bracket.\n-    pub fn parse_seq_to_end<T>(&self,\n-                               ket: &token::Token,\n-                               sep: SeqSep,\n-                               f: &fn(&Parser) -> T)\n-                               -> ~[T] {\n+    pub fn parse_seq_to_end<T>(\n+                            &self,\n+                            ket: &token::Token,\n+                            sep: SeqSep,\n+                            f: |&Parser| -> T)\n+                            -> ~[T] {\n         let val = self.parse_seq_to_before_end(ket, sep, f);\n         self.bump();\n         val\n@@ -664,11 +665,12 @@ impl Parser {\n     // parse a sequence, not including the closing delimiter. The function\n     // f must consume tokens until reaching the next separator or\n     // closing bracket.\n-    pub fn parse_seq_to_before_end<T>(&self,\n-                                      ket: &token::Token,\n-                                      sep: SeqSep,\n-                                      f: &fn(&Parser) -> T)\n-                                      -> ~[T] {\n+    pub fn parse_seq_to_before_end<T>(\n+                                   &self,\n+                                   ket: &token::Token,\n+                                   sep: SeqSep,\n+                                   f: |&Parser| -> T)\n+                                   -> ~[T] {\n         let mut first: bool = true;\n         let mut v: ~[T] = ~[];\n         while *self.token != *ket {\n@@ -688,12 +690,13 @@ impl Parser {\n     // parse a sequence, including the closing delimiter. The function\n     // f must consume tokens until reaching the next separator or\n     // closing bracket.\n-    pub fn parse_unspanned_seq<T>(&self,\n-                                  bra: &token::Token,\n-                                  ket: &token::Token,\n-                                  sep: SeqSep,\n-                                  f: &fn(&Parser) -> T)\n-                                  -> ~[T] {\n+    pub fn parse_unspanned_seq<T>(\n+                               &self,\n+                               bra: &token::Token,\n+                               ket: &token::Token,\n+                               sep: SeqSep,\n+                               f: |&Parser| -> T)\n+                               -> ~[T] {\n         self.expect(bra);\n         let result = self.parse_seq_to_before_end(ket, sep, f);\n         self.bump();\n@@ -702,12 +705,13 @@ impl Parser {\n \n     // NB: Do not use this function unless you actually plan to place the\n     // spanned list in the AST.\n-    pub fn parse_seq<T>(&self,\n-                        bra: &token::Token,\n-                        ket: &token::Token,\n-                        sep: SeqSep,\n-                        f: &fn(&Parser) -> T)\n-                        -> Spanned<~[T]> {\n+    pub fn parse_seq<T>(\n+                     &self,\n+                     bra: &token::Token,\n+                     ket: &token::Token,\n+                     sep: SeqSep,\n+                     f: |&Parser| -> T)\n+                     -> Spanned<~[T]> {\n         let lo = self.span.lo;\n         self.expect(bra);\n         let result = self.parse_seq_to_before_end(ket, sep, f);\n@@ -765,8 +769,8 @@ impl Parser {\n         }\n         return (4 - *self.buffer_start) + *self.buffer_end;\n     }\n-    pub fn look_ahead<R>(&self, distance: uint, f: &fn(&token::Token) -> R)\n-                         -> R {\n+    pub fn look_ahead<R>(&self, distance: uint, f: |&token::Token| -> R)\n+                      -> R {\n         let dist = distance as int;\n         while self.buffer_length() < dist {\n             self.buffer[*self.buffer_end] = self.reader.next_token();\n@@ -1272,7 +1276,8 @@ impl Parser {\n     // parse the type following a @ or a ~\n     pub fn parse_box_or_uniq_pointee(&self,\n                                      sigil: ast::Sigil,\n-                                     ctor: &fn(v: mt) -> ty_) -> ty_ {\n+                                     ctor: |v: mt| -> ty_)\n+                                     -> ty_ {\n         // ~'foo fn() or ~fn() are parsed directly as obsolete fn types:\n         match *self.token {\n             token::LIFETIME(*) => {\n@@ -2467,8 +2472,8 @@ impl Parser {\n     // this is used both in parsing a lambda expr\n     // and in parsing a block expr as e.g. in for...\n     pub fn parse_lambda_expr_(&self,\n-                              parse_decl: &fn() -> fn_decl,\n-                              parse_body: &fn() -> @Expr)\n+                              parse_decl: || -> fn_decl,\n+                              parse_body: || -> @Expr)\n                               -> @Expr {\n         let lo = self.last_span.lo;\n         let decl = parse_decl();\n@@ -2513,10 +2518,11 @@ impl Parser {\n     // parse a 'for' or 'do'.\n     // the 'for' and 'do' expressions parse as calls, but look like\n     // function calls followed by a closure expression.\n-    pub fn parse_sugary_call_expr(&self, lo: BytePos,\n+    pub fn parse_sugary_call_expr(&self,\n+                                  lo: BytePos,\n                                   keyword: ~str,\n                                   sugar: CallSugar,\n-                                  ctor: &fn(v: @Expr) -> Expr_)\n+                                  ctor: |v: @Expr| -> Expr_)\n                                   -> @Expr {\n         // Parse the callee `foo` in\n         //    for foo || {\n@@ -3611,11 +3617,12 @@ impl Parser {\n \n     // parse the argument list and result type of a function\n     // that may have a self type.\n-    fn parse_fn_decl_with_self(&self, parse_arg_fn: &fn(&Parser) -> arg)\n-        -> (explicit_self, fn_decl) {\n-\n-        fn maybe_parse_explicit_self(cnstr: &fn(v: Mutability) -> ast::explicit_self_,\n-                                     p: &Parser) -> ast::explicit_self_ {\n+    fn parse_fn_decl_with_self(&self, parse_arg_fn: |&Parser| -> arg)\n+                               -> (explicit_self, fn_decl) {\n+        fn maybe_parse_explicit_self(cnstr: |v: Mutability| ->\n+                                        ast::explicit_self_,\n+                                     p: &Parser)\n+                                     -> ast::explicit_self_ {\n             // We need to make sure it isn't a type\n             if p.look_ahead(1, |t| token::is_keyword(keywords::Self, t)) ||\n                 ((p.look_ahead(1, |t| token::is_keyword(keywords::Const, t)) ||"}, {"sha": "8d31133e9e24a8fa69f465477b21ee773d02ce38", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/492677ec1e4e66a57a2fce78962db2f89932dd74/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/492677ec1e4e66a57a2fce78962db2f89932dd74/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=492677ec1e4e66a57a2fce78962db2f89932dd74", "patch": "@@ -331,7 +331,7 @@ pub fn synth_comment(s: @ps, text: ~str) {\n     word(s.s, \"*/\");\n }\n \n-pub fn commasep<T>(s: @ps, b: breaks, elts: &[T], op: &fn(@ps, &T)) {\n+pub fn commasep<T>(s: @ps, b: breaks, elts: &[T], op: |@ps, &T|) {\n     box(s, 0u, b);\n     let mut first = true;\n     for elt in elts.iter() {\n@@ -342,8 +342,12 @@ pub fn commasep<T>(s: @ps, b: breaks, elts: &[T], op: &fn(@ps, &T)) {\n }\n \n \n-pub fn commasep_cmnt<T>(s: @ps, b: breaks, elts: &[T], op: &fn(@ps, &T),\n-                               get_span: &fn(&T) -> codemap::Span) {\n+pub fn commasep_cmnt<T>(\n+                     s: @ps,\n+                     b: breaks,\n+                     elts: &[T],\n+                     op: |@ps, &T|,\n+                     get_span: |&T| -> codemap::Span) {\n     box(s, 0u, b);\n     let len = elts.len();\n     let mut i = 0u;\n@@ -2289,7 +2293,7 @@ pub fn print_string(s: @ps, st: &str, style: ast::StrStyle) {\n     word(s.s, st);\n }\n \n-pub fn to_str<T>(t: &T, f: &fn(@ps, &T), intr: @ident_interner) -> ~str {\n+pub fn to_str<T>(t: &T, f: |@ps, &T|, intr: @ident_interner) -> ~str {\n     let wr = @mut MemWriter::new();\n     let s = rust_printer(wr as @mut io::Writer, intr);\n     f(s, t);"}, {"sha": "3a2a8b10c9666c6276ddd37505d8983e9a352fc2", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/492677ec1e4e66a57a2fce78962db2f89932dd74/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/492677ec1e4e66a57a2fce78962db2f89932dd74/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=492677ec1e4e66a57a2fce78962db2f89932dd74", "patch": "@@ -39,7 +39,7 @@ pub fn string_to_parser(source_str: @str) -> Parser {\n     p\n }\n \n-fn with_error_checking_parse<T>(s: @str, f: &fn(&mut Parser) -> T) -> T {\n+fn with_error_checking_parse<T>(s: @str, f: |&mut Parser| -> T) -> T {\n     let mut p = string_to_parser(s);\n     let x = f(&mut p);\n     p.abort_if_errors();"}]}