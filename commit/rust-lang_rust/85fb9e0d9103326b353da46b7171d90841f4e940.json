{"sha": "85fb9e0d9103326b353da46b7171d90841f4e940", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1ZmI5ZTBkOTEwMzMyNmIzNTNkYTQ2YjcxNzFkOTA4NDFmNGU5NDA=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2017-04-22T19:46:34Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2017-07-06T20:50:02Z"}, "message": "Check types for privacy", "tree": {"sha": "722706c8758bf5767cc45f87733d59dd1027b486", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/722706c8758bf5767cc45f87733d59dd1027b486"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/85fb9e0d9103326b353da46b7171d90841f4e940", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/85fb9e0d9103326b353da46b7171d90841f4e940", "html_url": "https://github.com/rust-lang/rust/commit/85fb9e0d9103326b353da46b7171d90841f4e940", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/85fb9e0d9103326b353da46b7171d90841f4e940/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd72f2e269357ea4da4d0cf5502af35f4f9dab9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd72f2e269357ea4da4d0cf5502af35f4f9dab9e", "html_url": "https://github.com/rust-lang/rust/commit/cd72f2e269357ea4da4d0cf5502af35f4f9dab9e"}], "stats": {"total": 588, "additions": 581, "deletions": 7}, "files": [{"sha": "bce7943b3059efeba907d1b9bf9c911c80d456bb", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 330, "deletions": 2, "changes": 332, "blob_url": "https://github.com/rust-lang/rust/blob/85fb9e0d9103326b353da46b7171d90841f4e940/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85fb9e0d9103326b353da46b7171d90841f4e940/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=85fb9e0d9103326b353da46b7171d90841f4e940", "patch": "@@ -18,13 +18,13 @@\n \n #![feature(rustc_diagnostic_macros)]\n \n-extern crate rustc;\n+#[macro_use] extern crate rustc;\n #[macro_use] extern crate syntax;\n extern crate syntax_pos;\n \n use rustc::hir::{self, PatKind};\n use rustc::hir::def::Def;\n-use rustc::hir::def_id::{LOCAL_CRATE, CrateNum, DefId};\n+use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, CrateNum, DefId};\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::itemlikevisit::DeepVisitor;\n use rustc::lint;\n@@ -537,6 +537,324 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n     }\n }\n \n+////////////////////////////////////////////////////////////////////////////////////////////\n+/// Type privacy visitor, checks types for privacy and reports violations.\n+/// Both explicitly written types and inferred types of expressions and patters are checked.\n+/// Checks are performed on \"semantic\" types regardless of names and their hygiene.\n+////////////////////////////////////////////////////////////////////////////////////////////\n+\n+struct TypePrivacyVisitor<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tables: &'a ty::TypeckTables<'tcx>,\n+    current_item: DefId,\n+    span: Span,\n+}\n+\n+impl<'a, 'tcx> TypePrivacyVisitor<'a, 'tcx> {\n+    fn def_id_visibility(&self, did: DefId) -> ty::Visibility {\n+        match self.tcx.hir.as_local_node_id(did) {\n+            Some(node_id) => {\n+                let vis = match self.tcx.hir.get(node_id) {\n+                    hir::map::NodeItem(item) => &item.vis,\n+                    hir::map::NodeForeignItem(foreign_item) => &foreign_item.vis,\n+                    hir::map::NodeImplItem(impl_item) => &impl_item.vis,\n+                    hir::map::NodeTraitItem(..) |\n+                    hir::map::NodeVariant(..) => {\n+                        return self.def_id_visibility(self.tcx.hir.get_parent_did(node_id));\n+                    }\n+                    hir::map::NodeStructCtor(vdata) => {\n+                        let struct_node_id = self.tcx.hir.get_parent(node_id);\n+                        let struct_vis = match self.tcx.hir.get(struct_node_id) {\n+                            hir::map::NodeItem(item) => &item.vis,\n+                            node => bug!(\"unexpected node kind: {:?}\", node),\n+                        };\n+                        let mut ctor_vis\n+                            = ty::Visibility::from_hir(struct_vis, struct_node_id, self.tcx);\n+                        for field in vdata.fields() {\n+                            let field_vis = ty::Visibility::from_hir(&field.vis, node_id, self.tcx);\n+                            if ctor_vis.is_at_least(field_vis, self.tcx) {\n+                                ctor_vis = field_vis;\n+                            }\n+                        }\n+                        return ctor_vis;\n+                    }\n+                    node => bug!(\"unexpected node kind: {:?}\", node)\n+                };\n+                ty::Visibility::from_hir(vis, node_id, self.tcx)\n+            }\n+            None => self.tcx.sess.cstore.visibility(did),\n+        }\n+    }\n+\n+    fn item_is_accessible(&self, did: DefId) -> bool {\n+        self.def_id_visibility(did).is_accessible_from(self.current_item, self.tcx)\n+    }\n+\n+    fn check_expr_pat_type(&mut self, id: ast::NodeId, span: Span) -> bool {\n+        if let Some(ty) = self.tables.node_id_to_type_opt(id) {\n+            self.span = span;\n+            ty.visit_with(self)\n+        } else {\n+            false\n+        }\n+    }\n+\n+    fn check_item(&mut self, item_id: ast::NodeId) -> &mut Self {\n+        self.current_item = self.tcx.hir.local_def_id(item_id);\n+        self.span = self.tcx.hir.span(item_id);\n+        self\n+    }\n+\n+    // Convenience methods for checking item interfaces\n+    fn ty(&mut self) -> &mut Self {\n+        self.tcx.type_of(self.current_item).visit_with(self);\n+        self\n+    }\n+\n+    fn generics(&mut self) -> &mut Self {\n+        for def in &self.tcx.generics_of(self.current_item).types {\n+            if def.has_default {\n+                self.tcx.type_of(def.def_id).visit_with(self);\n+            }\n+        }\n+        self\n+    }\n+\n+    fn predicates(&mut self) -> &mut Self {\n+        self.tcx.predicates_of(self.current_item).visit_with(self);\n+        self\n+    }\n+\n+    fn impl_trait_ref(&mut self) -> &mut Self {\n+        self.tcx.impl_trait_ref(self.current_item).visit_with(self);\n+        self\n+    }\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n+    /// We want to visit items in the context of their containing\n+    /// module and so forth, so supply a crate for doing a deep walk.\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::All(&self.tcx.hir)\n+    }\n+\n+    fn visit_nested_body(&mut self, body: hir::BodyId) {\n+        let orig_tables = replace(&mut self.tables, self.tcx.body_tables(body));\n+        let body = self.tcx.hir.body(body);\n+        self.visit_body(body);\n+        self.tables = orig_tables;\n+    }\n+\n+    // Check types of expressions\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n+        if self.check_expr_pat_type(expr.id, expr.span) {\n+            // Do not check nested expressions if the error already happened.\n+            return;\n+        }\n+        match expr.node {\n+            hir::ExprAssign(.., ref rhs) | hir::ExprMatch(ref rhs, ..) => {\n+                // Do not report duplicate errors for `x = y` and `match x { ... }`.\n+                if self.check_expr_pat_type(rhs.id, rhs.span) {\n+                    return;\n+                }\n+            }\n+            hir::ExprMethodCall(name, ..) => {\n+                // Method calls have to be checked specially.\n+                if let Some(method) = self.tables.method_map.get(&ty::MethodCall::expr(expr.id)) {\n+                    self.span = name.span;\n+                    if method.ty.visit_with(self) || method.substs.visit_with(self) {\n+                        return;\n+                    }\n+                }\n+            }\n+            _ => {}\n+        }\n+\n+        intravisit::walk_expr(self, expr);\n+    }\n+\n+    // Check types of patterns\n+    fn visit_pat(&mut self, pattern: &'tcx hir::Pat) {\n+        if self.check_expr_pat_type(pattern.id, pattern.span) {\n+            // Do not check nested patterns if the error already happened.\n+            return;\n+        }\n+\n+        intravisit::walk_pat(self, pattern);\n+    }\n+\n+    fn visit_local(&mut self, local: &'tcx hir::Local) {\n+        if let Some(ref init) = local.init {\n+            if self.check_expr_pat_type(init.id, init.span) {\n+                // Do not report duplicate errors for `let x = y`.\n+                return;\n+            }\n+        }\n+\n+        intravisit::walk_local(self, local);\n+    }\n+\n+    // Check types in item interfaces\n+    fn visit_item(&mut self, item: &'tcx hir::Item) {\n+        let orig_current_item = self.current_item;\n+\n+        match item.node {\n+            hir::ItemExternCrate(..) | hir::ItemMod(..) |\n+            hir::ItemUse(..) | hir::ItemGlobalAsm(..) => {}\n+            hir::ItemConst(..) | hir::ItemStatic(..) |\n+            hir::ItemTy(..) | hir::ItemFn(..) => {\n+                self.check_item(item.id).generics().predicates().ty();\n+            }\n+            hir::ItemTrait(.., ref trait_item_refs) => {\n+                self.check_item(item.id).generics().predicates();\n+                for trait_item_ref in trait_item_refs {\n+                    let mut check = self.check_item(trait_item_ref.id.node_id);\n+                    check.generics().predicates();\n+                    if trait_item_ref.kind != hir::AssociatedItemKind::Type ||\n+                       trait_item_ref.defaultness.has_value() {\n+                        check.ty();\n+                    }\n+                }\n+            }\n+            hir::ItemEnum(ref def, _) => {\n+                self.check_item(item.id).generics().predicates();\n+                for variant in &def.variants {\n+                    for field in variant.node.data.fields() {\n+                        self.check_item(field.id).ty();\n+                    }\n+                }\n+            }\n+            hir::ItemForeignMod(ref foreign_mod) => {\n+                for foreign_item in &foreign_mod.items {\n+                    self.check_item(foreign_item.id).generics().predicates().ty();\n+                }\n+            }\n+            hir::ItemStruct(ref struct_def, _) |\n+            hir::ItemUnion(ref struct_def, _) => {\n+                self.check_item(item.id).generics().predicates();\n+                for field in struct_def.fields() {\n+                    self.check_item(field.id).ty();\n+                }\n+            }\n+            hir::ItemDefaultImpl(..) => {\n+                self.check_item(item.id).impl_trait_ref();\n+            }\n+            hir::ItemImpl(.., ref trait_ref, _, ref impl_item_refs) => {\n+                {\n+                    let mut check = self.check_item(item.id);\n+                    check.ty().generics().predicates();\n+                    if trait_ref.is_some() {\n+                        check.impl_trait_ref();\n+                    }\n+                }\n+                for impl_item_ref in impl_item_refs {\n+                    let impl_item = self.tcx.hir.impl_item(impl_item_ref.id);\n+                    self.check_item(impl_item.id).generics().predicates().ty();\n+                }\n+            }\n+        }\n+\n+        self.current_item = self.tcx.hir.local_def_id(item.id);\n+        intravisit::walk_item(self, item);\n+        self.current_item = orig_current_item;\n+    }\n+}\n+\n+impl<'a, 'tcx> TypeVisitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n+    fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n+        match ty.sty {\n+            ty::TyAdt(&ty::AdtDef { did: def_id, .. }, ..) | ty::TyFnDef(def_id, ..) => {\n+                if !self.item_is_accessible(def_id) {\n+                    let msg = format!(\"type `{}` is private\", ty);\n+                    self.tcx.sess.span_err(self.span, &msg);\n+                    return true;\n+                }\n+                if let ty::TyFnDef(..) = ty.sty {\n+                    // Inherent static methods don't have self type in substs,\n+                    // we have to check it additionally.\n+                    let mut impl_def_id = None;\n+                    if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n+                        if let hir::map::NodeImplItem(..) = self.tcx.hir.get(node_id) {\n+                            impl_def_id = Some(self.tcx.hir.get_parent_did(node_id));\n+                        }\n+                    } else if let Some(Def::Method(..)) = self.tcx.describe_def(def_id) {\n+                        let candidate_impl_def_id = self.tcx.parent_def_id(def_id)\n+                                                            .expect(\"no parent for method def_id\");\n+                        // `is_none` means it's an impl, not a trait\n+                        if self.tcx.describe_def(candidate_impl_def_id).is_none() {\n+                            impl_def_id = Some(candidate_impl_def_id)\n+                        }\n+                    }\n+                    if let Some(impl_def_id) = impl_def_id {\n+                        let self_ty = self.tcx.type_of(impl_def_id);\n+                        if self_ty.visit_with(self) {\n+                            return true;\n+                        }\n+                    }\n+                }\n+            }\n+            ty::TyDynamic(ref predicates, ..) => {\n+                let is_private = predicates.skip_binder().iter().any(|predicate| {\n+                    let def_id = match *predicate {\n+                        ty::ExistentialPredicate::Trait(trait_ref) => trait_ref.def_id,\n+                        ty::ExistentialPredicate::Projection(proj) => proj.trait_ref.def_id,\n+                        ty::ExistentialPredicate::AutoTrait(def_id) => def_id,\n+                    };\n+                    !self.item_is_accessible(def_id)\n+                });\n+                if is_private {\n+                    let msg = format!(\"type `{}` is private\", ty);\n+                    self.tcx.sess.span_err(self.span, &msg);\n+                    return true;\n+                }\n+            }\n+            ty::TyAnon(def_id, ..) => {\n+                for predicate in &self.tcx.predicates_of(def_id).predicates {\n+                    let trait_ref = match *predicate {\n+                        ty::Predicate::Trait(ref poly_trait_predicate) => {\n+                            Some(poly_trait_predicate.skip_binder().trait_ref)\n+                        }\n+                        ty::Predicate::Projection(ref poly_projection_predicate) => {\n+                            if poly_projection_predicate.skip_binder().ty.visit_with(self) {\n+                                return true;\n+                            }\n+                            Some(poly_projection_predicate.skip_binder().projection_ty.trait_ref)\n+                        }\n+                        ty::Predicate::TypeOutlives(..) => None,\n+                        _ => bug!(\"unexpected predicate: {:?}\", predicate),\n+                    };\n+                    if let Some(trait_ref) = trait_ref {\n+                        if !self.item_is_accessible(trait_ref.def_id) {\n+                            let msg = format!(\"trait `{}` is private\", trait_ref);\n+                            self.tcx.sess.span_err(self.span, &msg);\n+                            return true;\n+                        }\n+                        // Skip `Self` to avoid infinite recursion\n+                        for subst in trait_ref.substs.iter().skip(1) {\n+                            if subst.visit_with(self) {\n+                                return true;\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            _ => {}\n+        }\n+\n+        ty.super_visit_with(self)\n+    }\n+\n+    fn visit_trait_ref(&mut self, trait_ref: ty::TraitRef<'tcx>) -> bool {\n+        if !self.item_is_accessible(trait_ref.def_id) {\n+            let msg = format!(\"trait `{}` is private\", trait_ref);\n+            self.tcx.sess.span_err(self.span, &msg);\n+            return true;\n+        }\n+\n+        trait_ref.super_visit_with(self)\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////////\n /// Obsolete visitors for checking for private items in public interfaces.\n /// These visitors are supposed to be kept in frozen state and produce an\n@@ -1225,6 +1543,16 @@ fn privacy_access_levels<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     };\n     intravisit::walk_crate(&mut visitor, krate);\n \n+    // Check privacy of explicitly written types and traits as well as\n+    // inferred types of expressions and patterns.\n+    let mut visitor = TypePrivacyVisitor {\n+        tcx: tcx,\n+        tables: &ty::TypeckTables::empty(),\n+        current_item: DefId::local(CRATE_DEF_INDEX),\n+        span: krate.span,\n+    };\n+    intravisit::walk_crate(&mut visitor, krate);\n+\n     // Build up a set of all exported items in the AST. This is a set of all\n     // items which are reachable from external crates based on visibility.\n     let mut visitor = EmbargoVisitor {"}, {"sha": "1230ae8f84ae0077a85021e2d396804d9c2bc48b", "filename": "src/test/compile-fail/auxiliary/private-inferred-type.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/85fb9e0d9103326b353da46b7171d90841f4e940/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Fprivate-inferred-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85fb9e0d9103326b353da46b7171d90841f4e940/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Fprivate-inferred-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Fprivate-inferred-type.rs?ref=85fb9e0d9103326b353da46b7171d90841f4e940", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(decl_macro)]\n+\n+fn priv_fn() {}\n+enum PrivEnum { Variant }\n+pub enum PubEnum { Variant }\n+trait PrivTrait { fn method() {} }\n+impl PrivTrait for u8 {}\n+pub trait PubTrait { fn method() {} }\n+impl PubTrait for u8 {}\n+struct PrivTupleStruct(u8);\n+pub struct PubTupleStruct(u8);\n+impl PubTupleStruct { fn method() {} }\n+\n+struct Priv;\n+pub type Alias = Priv;\n+pub struct Pub<T = Alias>(pub T);\n+\n+impl Pub<Priv> {\n+    pub fn static_method() {}\n+}\n+\n+pub macro m() {\n+    priv_fn;\n+    PrivEnum::Variant;\n+    PubEnum::Variant;\n+    <u8 as PrivTrait>::method;\n+    <u8 as PubTrait>::method;\n+    PrivTupleStruct;\n+    PubTupleStruct;\n+    Pub::static_method;\n+}"}, {"sha": "aa67e5c5f4db7bcaf1d43feb2d228b63982cca6e", "filename": "src/test/compile-fail/hygiene/auxiliary/intercrate.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/85fb9e0d9103326b353da46b7171d90841f4e940/src%2Ftest%2Fcompile-fail%2Fhygiene%2Fauxiliary%2Fintercrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85fb9e0d9103326b353da46b7171d90841f4e940/src%2Ftest%2Fcompile-fail%2Fhygiene%2Fauxiliary%2Fintercrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fhygiene%2Fauxiliary%2Fintercrate.rs?ref=85fb9e0d9103326b353da46b7171d90841f4e940", "previous_filename": "src/test/run-pass/hygiene/auxiliary/intercrate.rs"}, {"sha": "64217770b13c9ad278b1381f4697ba86dde7e3ec", "filename": "src/test/compile-fail/hygiene/fields.rs", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/85fb9e0d9103326b353da46b7171d90841f4e940/src%2Ftest%2Fcompile-fail%2Fhygiene%2Ffields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85fb9e0d9103326b353da46b7171d90841f4e940/src%2Ftest%2Fcompile-fail%2Fhygiene%2Ffields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fhygiene%2Ffields.rs?ref=85fb9e0d9103326b353da46b7171d90841f4e940", "patch": "@@ -22,11 +22,11 @@ mod foo {\n             x: i32,\n         }\n \n-        let s = S { x: 0 };\n-        let _ = s.x;\n+        let s = S { x: 0 }; //~ ERROR type `foo::S` is private\n+        let _ = s.x; //~ ERROR type `foo::S` is private\n \n-        let t = T(0);\n-        let _ = t.0;\n+        let t = T(0); //~ ERROR type `foo::T` is private\n+        let _ = t.0; //~ ERROR type `foo::T` is private\n \n         let s = $S { $x: 0, x: 1 };\n         assert_eq!((s.$x, s.x), (0, 1));", "previous_filename": "src/test/run-pass/hygiene/fields.rs"}, {"sha": "445aa62f2361ee0ebf02dfe089430934a60c0116", "filename": "src/test/compile-fail/hygiene/impl_items.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85fb9e0d9103326b353da46b7171d90841f4e940/src%2Ftest%2Fcompile-fail%2Fhygiene%2Fimpl_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85fb9e0d9103326b353da46b7171d90841f4e940/src%2Ftest%2Fcompile-fail%2Fhygiene%2Fimpl_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fhygiene%2Fimpl_items.rs?ref=85fb9e0d9103326b353da46b7171d90841f4e940", "patch": "@@ -19,7 +19,7 @@ mod foo {\n     }\n \n     pub macro m() {\n-        let _: () = S.f();\n+        let _: () = S.f(); //~ ERROR type `fn(&foo::S) {foo::S::f}` is private\n     }\n }\n ", "previous_filename": "src/test/run-pass/hygiene/impl_items.rs"}, {"sha": "50fc985ba34faea982f93aa51efb5f468af4f073", "filename": "src/test/compile-fail/hygiene/intercrate.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85fb9e0d9103326b353da46b7171d90841f4e940/src%2Ftest%2Fcompile-fail%2Fhygiene%2Fintercrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85fb9e0d9103326b353da46b7171d90841f4e940/src%2Ftest%2Fcompile-fail%2Fhygiene%2Fintercrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fhygiene%2Fintercrate.rs?ref=85fb9e0d9103326b353da46b7171d90841f4e940", "patch": "@@ -12,6 +12,8 @@\n \n // aux-build:intercrate.rs\n \n+// error-pattern:type `fn() -> u32 {intercrate::foo::bar::f}` is private\n+\n #![feature(decl_macro)]\n \n extern crate intercrate;", "previous_filename": "src/test/run-pass/hygiene/intercrate.rs"}, {"sha": "ba8b3d1810a05dc605c62a152113d23d4b811604", "filename": "src/test/compile-fail/private-inferred-type-1.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/85fb9e0d9103326b353da46b7171d90841f4e940/src%2Ftest%2Fcompile-fail%2Fprivate-inferred-type-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85fb9e0d9103326b353da46b7171d90841f4e940/src%2Ftest%2Fcompile-fail%2Fprivate-inferred-type-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-inferred-type-1.rs?ref=85fb9e0d9103326b353da46b7171d90841f4e940", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Arr0 {\n+    fn arr0_secret(&self);\n+}\n+trait TyParam {\n+    fn ty_param_secret(&self);\n+}\n+\n+mod m {\n+    struct Priv;\n+\n+    impl ::Arr0 for [Priv; 0] { fn arr0_secret(&self) {} }\n+    impl ::TyParam for Option<Priv> { fn ty_param_secret(&self) {} }\n+}\n+\n+fn main() {\n+    [].arr0_secret(); //~ ERROR type `m::Priv` is private\n+    None.ty_param_secret(); //~ ERROR type `m::Priv` is private\n+}"}, {"sha": "e981f1257501511c0d8f881b6b001b439d45cc0f", "filename": "src/test/compile-fail/private-inferred-type-2.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/85fb9e0d9103326b353da46b7171d90841f4e940/src%2Ftest%2Fcompile-fail%2Fprivate-inferred-type-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85fb9e0d9103326b353da46b7171d90841f4e940/src%2Ftest%2Fcompile-fail%2Fprivate-inferred-type-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-inferred-type-2.rs?ref=85fb9e0d9103326b353da46b7171d90841f4e940", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:private-inferred-type.rs\n+\n+extern crate private_inferred_type as ext;\n+\n+mod m {\n+    struct Priv;\n+    pub struct Pub<T>(pub T);\n+\n+    impl Pub<Priv> {\n+        pub fn get_priv() -> Priv { Priv }\n+        pub fn static_method() {}\n+    }\n+}\n+\n+fn main() {\n+    m::Pub::get_priv; //~ ERROR type `m::Priv` is private\n+    m::Pub::static_method; //~ ERROR type `m::Priv` is private\n+    ext::Pub::static_method; //~ ERROR type `ext::Priv` is private\n+}"}, {"sha": "fb9357f9373b78382087d949326205c8ce9a014e", "filename": "src/test/compile-fail/private-inferred-type-3.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/85fb9e0d9103326b353da46b7171d90841f4e940/src%2Ftest%2Fcompile-fail%2Fprivate-inferred-type-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85fb9e0d9103326b353da46b7171d90841f4e940/src%2Ftest%2Fcompile-fail%2Fprivate-inferred-type-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-inferred-type-3.rs?ref=85fb9e0d9103326b353da46b7171d90841f4e940", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:private-inferred-type.rs\n+\n+// error-pattern:type `fn() {ext::priv_fn}` is private\n+// error-pattern:type `ext::PrivEnum` is private\n+// error-pattern:type `fn() {<u8 as ext::PrivTrait>::method}` is private\n+// error-pattern:type `fn(u8) -> ext::PrivTupleStruct {ext::PrivTupleStruct::{{constructor}}}` is pr\n+// error-pattern:type `fn(u8) -> ext::PubTupleStruct {ext::PubTupleStruct::{{constructor}}}` is priv\n+// error-pattern:type `ext::Priv` is private\n+\n+#![feature(decl_macro)]\n+\n+extern crate private_inferred_type as ext;\n+\n+fn main() {\n+    ext::m!();\n+}"}, {"sha": "6f39872ecf6cf8b55d6ad7c49cf8d8f2c079311e", "filename": "src/test/compile-fail/private-inferred-type.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/85fb9e0d9103326b353da46b7171d90841f4e940/src%2Ftest%2Fcompile-fail%2Fprivate-inferred-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85fb9e0d9103326b353da46b7171d90841f4e940/src%2Ftest%2Fcompile-fail%2Fprivate-inferred-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-inferred-type.rs?ref=85fb9e0d9103326b353da46b7171d90841f4e940", "patch": "@@ -0,0 +1,83 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(conservative_impl_trait)]\n+#![feature(decl_macro)]\n+\n+mod m {\n+    fn priv_fn() {}\n+    enum PrivEnum { Variant }\n+    pub enum PubEnum { Variant }\n+    trait PrivTrait { fn method() {} }\n+    impl PrivTrait for u8 {}\n+    pub trait PubTrait { fn method() {} }\n+    impl PubTrait for u8 {}\n+    struct PrivTupleStruct(u8);\n+    pub struct PubTupleStruct(u8);\n+    impl PubTupleStruct { fn method() {} }\n+\n+    struct Priv;\n+    pub type Alias = Priv;\n+    pub struct Pub<T = Alias>(pub T);\n+\n+    impl Pub<Priv> {\n+        pub fn static_method() {}\n+    }\n+\n+    pub macro m() {\n+        priv_fn; //~ ERROR type `fn() {m::priv_fn}` is private\n+        PrivEnum::Variant; //~ ERROR type `m::PrivEnum` is private\n+        PubEnum::Variant; // OK\n+        <u8 as PrivTrait>::method; //~ ERROR type `fn() {<u8 as m::PrivTrait>::method}` is private\n+        <u8 as PubTrait>::method; // OK\n+        PrivTupleStruct;\n+        //~^ ERROR type `fn(u8) -> m::PrivTupleStruct {m::PrivTupleStruct::{{constructor}}}` is priv\n+        PubTupleStruct;\n+        //~^ ERROR type `fn(u8) -> m::PubTupleStruct {m::PubTupleStruct::{{constructor}}}` is privat\n+        Pub::static_method; //~ ERROR type `m::Priv` is private\n+    }\n+\n+    trait Trait {}\n+    pub trait TraitWithTyParam<T> {}\n+    pub trait TraitWithAssocTy { type X; }\n+    impl Trait for u8 {}\n+    impl<T> TraitWithTyParam<T> for u8 {}\n+    impl TraitWithAssocTy for u8 { type X = Priv; }\n+\n+    pub fn leak_anon1() -> impl Trait + 'static { 0 }\n+    pub fn leak_anon2() -> impl TraitWithTyParam<Alias> { 0 }\n+    pub fn leak_anon3() -> impl TraitWithAssocTy<X = Alias> { 0 }\n+\n+    pub fn leak_dyn1() -> Box<Trait + 'static> { Box::new(0) }\n+    pub fn leak_dyn2() -> Box<TraitWithTyParam<Alias>> { Box::new(0) }\n+    pub fn leak_dyn3() -> Box<TraitWithAssocTy<X = Alias>> { Box::new(0) }\n+}\n+\n+fn main() {\n+    m::Alias {}; //~ ERROR type `m::Priv` is private\n+    m::Pub { 0: m::Alias {} }; //~ ERROR type `m::Priv` is private\n+    m::m!();\n+\n+    m::leak_anon1(); //~ ERROR trait `m::Trait` is private\n+    m::leak_anon2(); //~ ERROR type `m::Priv` is private\n+    m::leak_anon3(); //~ ERROR type `m::Priv` is private\n+\n+    m::leak_dyn1(); //~ ERROR type `m::Trait + 'static` is private\n+    m::leak_dyn2(); //~ ERROR type `m::Priv` is private\n+    m::leak_dyn3(); //~ ERROR type `m::Priv` is private\n+\n+    // Check that messages are not duplicated for various kinds of assignments\n+    let a = m::Alias {}; //~ ERROR type `m::Priv` is private\n+    let mut b = a; //~ ERROR type `m::Priv` is private\n+    b = a; //~ ERROR type `m::Priv` is private\n+    match a { //~ ERROR type `m::Priv` is private\n+        _ => {}\n+    }\n+}"}, {"sha": "e4b52895c14e22cc7e2036a966bc8acfa0824db4", "filename": "src/test/compile-fail/private-type-in-interface.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/85fb9e0d9103326b353da46b7171d90841f4e940/src%2Ftest%2Fcompile-fail%2Fprivate-type-in-interface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85fb9e0d9103326b353da46b7171d90841f4e940/src%2Ftest%2Fcompile-fail%2Fprivate-type-in-interface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-type-in-interface.rs?ref=85fb9e0d9103326b353da46b7171d90841f4e940", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:private-inferred-type.rs\n+\n+#![feature(conservative_impl_trait)]\n+\n+extern crate private_inferred_type as ext;\n+\n+mod m {\n+    struct Priv;\n+    pub type Alias = Priv;\n+}\n+\n+fn f(_: m::Alias) {} //~ ERROR type `m::Priv` is private\n+                     //~^ ERROR type `m::Priv` is private\n+fn f_ext(_: ext::Alias) {} //~ ERROR type `ext::Priv` is private\n+                           //~^ ERROR type `ext::Priv` is private\n+\n+trait Tr1 {}\n+impl m::Alias {} //~ ERROR type `m::Priv` is private\n+impl Tr1 for ext::Alias {} //~ ERROR type `ext::Priv` is private\n+                           //~^ ERROR type `ext::Priv` is private\n+\n+trait Tr2<T> {}\n+impl<T> Tr2<T> for u8 {}\n+fn g() -> impl Tr2<m::Alias> { 0 } //~ ERROR type `m::Priv` is private\n+fn g_ext() -> impl Tr2<ext::Alias> { 0 } //~ ERROR type `ext::Priv` is private\n+\n+fn main() {}"}]}