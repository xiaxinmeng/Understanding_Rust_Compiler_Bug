{"sha": "1397dca2dd07b93789226a22b2ccc456d0a5317a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzOTdkY2EyZGQwN2I5Mzc4OTIyNmEyMmIyY2NjNDU2ZDBhNTMxN2E=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-20T00:29:54Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-20T02:08:32Z"}, "message": "core: Move TLS to task::local_data", "tree": {"sha": "f12c69d4b48ee5a1630feedc9c3ad48538938255", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f12c69d4b48ee5a1630feedc9c3ad48538938255"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1397dca2dd07b93789226a22b2ccc456d0a5317a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1397dca2dd07b93789226a22b2ccc456d0a5317a", "html_url": "https://github.com/rust-lang/rust/commit/1397dca2dd07b93789226a22b2ccc456d0a5317a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1397dca2dd07b93789226a22b2ccc456d0a5317a/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1643794e0190ed2284bedcdd3fcbc44187a4a98f", "url": "https://api.github.com/repos/rust-lang/rust/commits/1643794e0190ed2284bedcdd3fcbc44187a4a98f", "html_url": "https://github.com/rust-lang/rust/commit/1643794e0190ed2284bedcdd3fcbc44187a4a98f"}], "stats": {"total": 723, "additions": 372, "deletions": 351}, "files": [{"sha": "9bb13af5a82239672fd4ad2ff92ce54ee076ec07", "filename": "src/libcore/core.rc", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1397dca2dd07b93789226a22b2ccc456d0a5317a/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/1397dca2dd07b93789226a22b2ccc456d0a5317a/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=1397dca2dd07b93789226a22b2ccc456d0a5317a", "patch": "@@ -219,7 +219,9 @@ mod send_map;\n \n // Concurrency\n mod comm;\n-mod task;\n+mod task {\n+    mod local_data;\n+}\n mod future;\n mod pipes;\n "}, {"sha": "788802a5fe9e3b0eb984f3b327e7e84d6e2bb1c3", "filename": "src/libcore/task.rs", "status": "modified", "additions": 8, "deletions": 343, "changes": 351, "blob_url": "https://github.com/rust-lang/rust/blob/1397dca2dd07b93789226a22b2ccc456d0a5317a/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1397dca2dd07b93789226a22b2ccc456d0a5317a/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=1397dca2dd07b93789226a22b2ccc456d0a5317a", "patch": "@@ -66,11 +66,7 @@ export get_task;\n export unkillable, rekillable;\n export atomically;\n \n-export local_data_key;\n-export local_data_pop;\n-export local_data_get;\n-export local_data_set;\n-export local_data_modify;\n+export local_data;\n \n export SingleThreaded;\n export ThreadPerCore;\n@@ -1213,7 +1209,7 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n     /*######################################################################*\n      * Step 1. Get spawner's taskgroup info.\n      *######################################################################*/\n-    let spawner_group = match unsafe { local_get(spawner,\n+    let spawner_group = match unsafe { local_data::local_get(spawner,\n                                                  taskgroup_key!()) } {\n         None => {\n             // Main task, doing first spawn ever. Lazily initialise here.\n@@ -1225,7 +1221,9 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n             // Main task/group has no ancestors, no notifier, etc.\n             let group =\n                 @TCB(spawner, move tasks, AncestorList(None), true, None);\n-            unsafe { local_set(spawner, taskgroup_key!(), group); }\n+            unsafe {\n+                local_data::local_set(spawner, taskgroup_key!(), group);\n+            }\n             group\n         }\n         Some(group) => group\n@@ -1352,7 +1350,9 @@ fn spawn_raw(+opts: TaskOpts, +f: fn~()) {\n             if enlist_many(child, &child_arc, &mut ancestors) {\n                 let group = @TCB(child, move child_arc, move ancestors,\n                                  is_main, move notifier);\n-                unsafe { local_set(child, taskgroup_key!(), group); }\n+                unsafe {\n+                    local_data::local_set(child, taskgroup_key!(), group);\n+                }\n \n                 // Run the child's body.\n                 f();\n@@ -1429,230 +1429,6 @@ fn spawn_raw(+opts: TaskOpts, +f: fn~()) {\n     }\n }\n \n-/* **************************************************************************\n- * Task local data management\n- *\n- * Allows storing boxes with arbitrary types inside, to be accessed anywhere\n- * within a task, keyed by a pointer to a global finaliser function. Useful\n- * for task-spawning metadata (tracking linked failure state), dynamic\n- * variables, and interfacing with foreign code with bad callback interfaces.\n- *\n- * To use, declare a monomorphic global function at the type to store, and use\n- * it as the 'key' when accessing. See the 'tls' tests below for examples.\n- *\n- * Casting 'Arcane Sight' reveals an overwhelming aura of Transmutation magic.\n- ****************************************************************************/\n-\n-/**\n- * Indexes a task-local data slot. The function's code pointer is used for\n- * comparison. Recommended use is to write an empty function for each desired\n- * task-local data slot (and use class destructors, not code inside the\n- * function, if specific teardown is needed). DO NOT use multiple\n- * instantiations of a single polymorphic function to index data of different\n- * types; arbitrary type coercion is possible this way.\n- *\n- * One other exception is that this global state can be used in a destructor\n- * context to create a circular @-box reference, which will crash during task\n- * failure (see issue #3039).\n- *\n- * These two cases aside, the interface is safe.\n- */\n-type LocalDataKey<T: Owned> = &fn(+@T);\n-\n-trait LocalData { }\n-impl<T: Owned> @T: LocalData { }\n-\n-impl LocalData: Eq {\n-    pure fn eq(&&other: LocalData) -> bool unsafe {\n-        let ptr_a: (uint, uint) = cast::reinterpret_cast(&self);\n-        let ptr_b: (uint, uint) = cast::reinterpret_cast(&other);\n-        return ptr_a == ptr_b;\n-    }\n-    pure fn ne(&&other: LocalData) -> bool { !self.eq(other) }\n-}\n-\n-// We use dvec because it's the best data structure in core. If TLS is used\n-// heavily in future, this could be made more efficient with a proper map.\n-type TaskLocalElement = (*libc::c_void, *libc::c_void, LocalData);\n-// Has to be a pointer at outermost layer; the foreign call returns void *.\n-type TaskLocalMap = @dvec::DVec<Option<TaskLocalElement>>;\n-\n-extern fn cleanup_task_local_map(map_ptr: *libc::c_void) unsafe {\n-    assert !map_ptr.is_null();\n-    // Get and keep the single reference that was created at the beginning.\n-    let _map: TaskLocalMap = cast::reinterpret_cast(&map_ptr);\n-    // All local_data will be destroyed along with the map.\n-}\n-\n-// Gets the map from the runtime. Lazily initialises if not done so already.\n-unsafe fn get_task_local_map(task: *rust_task) -> TaskLocalMap {\n-\n-    // Relies on the runtime initialising the pointer to null.\n-    // NOTE: The map's box lives in TLS invisibly referenced once. Each time\n-    // we retrieve it for get/set, we make another reference, which get/set\n-    // drop when they finish. No \"re-storing after modifying\" is needed.\n-    let map_ptr = rustrt::rust_get_task_local_data(task);\n-    if map_ptr.is_null() {\n-        let map: TaskLocalMap = @dvec::DVec();\n-        // Use reinterpret_cast -- transmute would take map away from us also.\n-        rustrt::rust_set_task_local_data(\n-            task, cast::reinterpret_cast(&map));\n-        rustrt::rust_task_local_data_atexit(task, cleanup_task_local_map);\n-        // Also need to reference it an extra time to keep it for now.\n-        cast::bump_box_refcount(map);\n-        map\n-    } else {\n-        let map = cast::transmute(move map_ptr);\n-        cast::bump_box_refcount(map);\n-        map\n-    }\n-}\n-\n-unsafe fn key_to_key_value<T: Owned>(\n-    key: LocalDataKey<T>) -> *libc::c_void {\n-\n-    // Keys are closures, which are (fnptr,envptr) pairs. Use fnptr.\n-    // Use reintepret_cast -- transmute would leak (forget) the closure.\n-    let pair: (*libc::c_void, *libc::c_void) = cast::reinterpret_cast(&key);\n-    pair.first()\n-}\n-\n-// If returning Some(..), returns with @T with the map's reference. Careful!\n-unsafe fn local_data_lookup<T: Owned>(\n-    map: TaskLocalMap, key: LocalDataKey<T>)\n-    -> Option<(uint, *libc::c_void)> {\n-\n-    let key_value = key_to_key_value(key);\n-    let map_pos = (*map).position(|entry|\n-        match entry {\n-            Some((k,_,_)) => k == key_value,\n-            None => false\n-        }\n-    );\n-    do map_pos.map |index| {\n-        // .get() is guaranteed because of \"None { false }\" above.\n-        let (_, data_ptr, _) = (*map)[index].get();\n-        (index, data_ptr)\n-    }\n-}\n-\n-unsafe fn local_get_helper<T: Owned>(\n-    task: *rust_task, key: LocalDataKey<T>,\n-    do_pop: bool) -> Option<@T> {\n-\n-    let map = get_task_local_map(task);\n-    // Interpreturn our findings from the map\n-    do local_data_lookup(map, key).map |result| {\n-        // A reference count magically appears on 'data' out of thin air. It\n-        // was referenced in the local_data box, though, not here, so before\n-        // overwriting the local_data_box we need to give an extra reference.\n-        // We must also give an extra reference when not removing.\n-        let (index, data_ptr) = result;\n-        let data: @T = cast::transmute(move data_ptr);\n-        cast::bump_box_refcount(data);\n-        if do_pop {\n-            (*map).set_elt(index, None);\n-        }\n-        data\n-    }\n-}\n-\n-unsafe fn local_pop<T: Owned>(\n-    task: *rust_task,\n-    key: LocalDataKey<T>) -> Option<@T> {\n-\n-    local_get_helper(task, key, true)\n-}\n-\n-unsafe fn local_get<T: Owned>(\n-    task: *rust_task,\n-    key: LocalDataKey<T>) -> Option<@T> {\n-\n-    local_get_helper(task, key, false)\n-}\n-\n-unsafe fn local_set<T: Owned>(\n-    task: *rust_task, key: LocalDataKey<T>, +data: @T) {\n-\n-    let map = get_task_local_map(task);\n-    // Store key+data as *voids. Data is invisibly referenced once; key isn't.\n-    let keyval = key_to_key_value(key);\n-    // We keep the data in two forms: one as an unsafe pointer, so we can get\n-    // it back by casting; another in an existential box, so the reference we\n-    // own on it can be dropped when the box is destroyed. The unsafe pointer\n-    // does not have a reference associated with it, so it may become invalid\n-    // when the box is destroyed.\n-    let data_ptr = cast::reinterpret_cast(&data);\n-    let data_box = data as LocalData;\n-    // Construct new entry to store in the map.\n-    let new_entry = Some((keyval, data_ptr, data_box));\n-    // Find a place to put it.\n-    match local_data_lookup(map, key) {\n-        Some((index, _old_data_ptr)) => {\n-            // Key already had a value set, _old_data_ptr, whose reference\n-            // will get dropped when the local_data box is overwritten.\n-            (*map).set_elt(index, new_entry);\n-        }\n-        None => {\n-            // Find an empty slot. If not, grow the vector.\n-            match (*map).position(|x| x.is_none()) {\n-                Some(empty_index) => (*map).set_elt(empty_index, new_entry),\n-                None => (*map).push(new_entry)\n-            }\n-        }\n-    }\n-}\n-\n-unsafe fn local_modify<T: Owned>(\n-    task: *rust_task, key: LocalDataKey<T>,\n-    modify_fn: fn(Option<@T>) -> Option<@T>) {\n-\n-    // Could be more efficient by doing the lookup work, but this is easy.\n-    let newdata = modify_fn(local_pop(task, key));\n-    if newdata.is_some() {\n-        local_set(task, key, option::unwrap(move newdata));\n-    }\n-}\n-\n-/* Exported interface for task-local data (plus local_data_key above). */\n-/**\n- * Remove a task-local data value from the table, returning the\n- * reference that was originally created to insert it.\n- */\n-unsafe fn local_data_pop<T: Owned>(\n-    key: LocalDataKey<T>) -> Option<@T> {\n-\n-    local_pop(rustrt::rust_get_task(), key)\n-}\n-/**\n- * Retrieve a task-local data value. It will also be kept alive in the\n- * table until explicitly removed.\n- */\n-unsafe fn local_data_get<T: Owned>(\n-    key: LocalDataKey<T>) -> Option<@T> {\n-\n-    local_get(rustrt::rust_get_task(), key)\n-}\n-/**\n- * Store a value in task-local data. If this key already has a value,\n- * that value is overwritten (and its destructor is run).\n- */\n-unsafe fn local_data_set<T: Owned>(\n-    key: LocalDataKey<T>, +data: @T) {\n-\n-    local_set(rustrt::rust_get_task(), key, data)\n-}\n-/**\n- * Modify a task-local data value. If the function returns 'None', the\n- * data is removed (and its reference dropped).\n- */\n-unsafe fn local_data_modify<T: Owned>(\n-    key: LocalDataKey<T>,\n-    modify_fn: fn(Option<@T>) -> Option<@T>) {\n-\n-    local_modify(rustrt::rust_get_task(), key, modify_fn)\n-}\n-\n extern mod rustrt {\n     #[rust_stack]\n     fn rust_task_yield(task: *rust_task) -> bool;\n@@ -2317,117 +2093,6 @@ fn test_child_doesnt_ref_parent() {\n     task::spawn(child_no(0));\n }\n \n-#[test]\n-fn test_tls_multitask() unsafe {\n-    fn my_key(+_x: @~str) { }\n-    local_data_set(my_key, @~\"parent data\");\n-    do task::spawn unsafe {\n-        assert local_data_get(my_key).is_none(); // TLS shouldn't carry over.\n-        local_data_set(my_key, @~\"child data\");\n-        assert *(local_data_get(my_key).get()) == ~\"child data\";\n-        // should be cleaned up for us\n-    }\n-    // Must work multiple times\n-    assert *(local_data_get(my_key).get()) == ~\"parent data\";\n-    assert *(local_data_get(my_key).get()) == ~\"parent data\";\n-    assert *(local_data_get(my_key).get()) == ~\"parent data\";\n-}\n-\n-#[test]\n-fn test_tls_overwrite() unsafe {\n-    fn my_key(+_x: @~str) { }\n-    local_data_set(my_key, @~\"first data\");\n-    local_data_set(my_key, @~\"next data\"); // Shouldn't leak.\n-    assert *(local_data_get(my_key).get()) == ~\"next data\";\n-}\n-\n-#[test]\n-fn test_tls_pop() unsafe {\n-    fn my_key(+_x: @~str) { }\n-    local_data_set(my_key, @~\"weasel\");\n-    assert *(local_data_pop(my_key).get()) == ~\"weasel\";\n-    // Pop must remove the data from the map.\n-    assert local_data_pop(my_key).is_none();\n-}\n-\n-#[test]\n-fn test_tls_modify() unsafe {\n-    fn my_key(+_x: @~str) { }\n-    local_data_modify(my_key, |data| {\n-        match data {\n-            Some(@val) => fail ~\"unwelcome value: \" + val,\n-            None       => Some(@~\"first data\")\n-        }\n-    });\n-    local_data_modify(my_key, |data| {\n-        match data {\n-            Some(@~\"first data\") => Some(@~\"next data\"),\n-            Some(@val)           => fail ~\"wrong value: \" + val,\n-            None                 => fail ~\"missing value\"\n-        }\n-    });\n-    assert *(local_data_pop(my_key).get()) == ~\"next data\";\n-}\n-\n-#[test]\n-fn test_tls_crust_automorestack_memorial_bug() unsafe {\n-    // This might result in a stack-canary clobber if the runtime fails to set\n-    // sp_limit to 0 when calling the cleanup extern - it might automatically\n-    // jump over to the rust stack, which causes next_c_sp to get recorded as\n-    // Something within a rust stack segment. Then a subsequent upcall (esp.\n-    // for logging, think vsnprintf) would run on a stack smaller than 1 MB.\n-    fn my_key(+_x: @~str) { }\n-    do task::spawn {\n-        unsafe { local_data_set(my_key, @~\"hax\"); }\n-    }\n-}\n-\n-#[test]\n-fn test_tls_multiple_types() unsafe {\n-    fn str_key(+_x: @~str) { }\n-    fn box_key(+_x: @@()) { }\n-    fn int_key(+_x: @int) { }\n-    do task::spawn unsafe {\n-        local_data_set(str_key, @~\"string data\");\n-        local_data_set(box_key, @@());\n-        local_data_set(int_key, @42);\n-    }\n-}\n-\n-#[test]\n-fn test_tls_overwrite_multiple_types() {\n-    fn str_key(+_x: @~str) { }\n-    fn box_key(+_x: @@()) { }\n-    fn int_key(+_x: @int) { }\n-    do task::spawn unsafe {\n-        local_data_set(str_key, @~\"string data\");\n-        local_data_set(int_key, @42);\n-        // This could cause a segfault if overwriting-destruction is done with\n-        // the crazy polymorphic transmute rather than the provided finaliser.\n-        local_data_set(int_key, @31337);\n-    }\n-}\n-\n-#[test]\n-#[should_fail]\n-#[ignore(cfg(windows))]\n-fn test_tls_cleanup_on_failure() unsafe {\n-    fn str_key(+_x: @~str) { }\n-    fn box_key(+_x: @@()) { }\n-    fn int_key(+_x: @int) { }\n-    local_data_set(str_key, @~\"parent data\");\n-    local_data_set(box_key, @@());\n-    do task::spawn unsafe { // spawn_linked\n-        local_data_set(str_key, @~\"string data\");\n-        local_data_set(box_key, @@());\n-        local_data_set(int_key, @42);\n-        fail;\n-    }\n-    // Not quite nondeterministic.\n-    local_data_set(int_key, @31337);\n-    fail;\n-}\n-\n #[test]\n fn test_sched_thread_per_core() {\n     let (chan, port) = pipes::stream();"}, {"sha": "4fbf0475c0a5b99a33107811afe8c6a599cbf6b1", "filename": "src/libcore/task/local_data.rs", "status": "added", "additions": 346, "deletions": 0, "changes": 346, "blob_url": "https://github.com/rust-lang/rust/blob/1397dca2dd07b93789226a22b2ccc456d0a5317a/src%2Flibcore%2Ftask%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1397dca2dd07b93789226a22b2ccc456d0a5317a/src%2Flibcore%2Ftask%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Flocal_data.rs?ref=1397dca2dd07b93789226a22b2ccc456d0a5317a", "patch": "@@ -0,0 +1,346 @@\n+/*!\n+\n+Task local data management\n+\n+Allows storing boxes with arbitrary types inside, to be accessed anywhere\n+within a task, keyed by a pointer to a global finaliser function. Useful\n+for task-spawning metadata (tracking linked failure state), dynamic\n+variables, and interfacing with foreign code with bad callback interfaces.\n+\n+To use, declare a monomorphic global function at the type to store, and use\n+it as the 'key' when accessing. See the 'tls' tests below for examples.\n+\n+Casting 'Arcane Sight' reveals an overwhelming aura of Transmutation magic.\n+\n+*/\n+\n+export local_data_key;\n+export local_data_pop;\n+export local_data_get;\n+export local_data_set;\n+export local_data_modify;\n+\n+// XXX: These shouldn't be exported but they are used by task.rs\n+export local_get;\n+export local_set;\n+\n+/**\n+ * Indexes a task-local data slot. The function's code pointer is used for\n+ * comparison. Recommended use is to write an empty function for each desired\n+ * task-local data slot (and use class destructors, not code inside the\n+ * function, if specific teardown is needed). DO NOT use multiple\n+ * instantiations of a single polymorphic function to index data of different\n+ * types; arbitrary type coercion is possible this way.\n+ *\n+ * One other exception is that this global state can be used in a destructor\n+ * context to create a circular @-box reference, which will crash during task\n+ * failure (see issue #3039).\n+ *\n+ * These two cases aside, the interface is safe.\n+ */\n+type LocalDataKey<T: Owned> = &fn(+@T);\n+\n+trait LocalData { }\n+impl<T: Owned> @T: LocalData { }\n+\n+impl LocalData: Eq {\n+    pure fn eq(&&other: LocalData) -> bool unsafe {\n+        let ptr_a: (uint, uint) = cast::reinterpret_cast(&self);\n+        let ptr_b: (uint, uint) = cast::reinterpret_cast(&other);\n+        return ptr_a == ptr_b;\n+    }\n+    pure fn ne(&&other: LocalData) -> bool { !self.eq(other) }\n+}\n+\n+// We use dvec because it's the best data structure in core. If TLS is used\n+// heavily in future, this could be made more efficient with a proper map.\n+type TaskLocalElement = (*libc::c_void, *libc::c_void, LocalData);\n+// Has to be a pointer at outermost layer; the foreign call returns void *.\n+type TaskLocalMap = @dvec::DVec<Option<TaskLocalElement>>;\n+\n+extern fn cleanup_task_local_map(map_ptr: *libc::c_void) unsafe {\n+    assert !map_ptr.is_null();\n+    // Get and keep the single reference that was created at the beginning.\n+    let _map: TaskLocalMap = cast::reinterpret_cast(&map_ptr);\n+    // All local_data will be destroyed along with the map.\n+}\n+\n+// Gets the map from the runtime. Lazily initialises if not done so already.\n+unsafe fn get_task_local_map(task: *rust_task) -> TaskLocalMap {\n+\n+    // Relies on the runtime initialising the pointer to null.\n+    // NOTE: The map's box lives in TLS invisibly referenced once. Each time\n+    // we retrieve it for get/set, we make another reference, which get/set\n+    // drop when they finish. No \"re-storing after modifying\" is needed.\n+    let map_ptr = rustrt::rust_get_task_local_data(task);\n+    if map_ptr.is_null() {\n+        let map: TaskLocalMap = @dvec::DVec();\n+        // Use reinterpret_cast -- transmute would take map away from us also.\n+        rustrt::rust_set_task_local_data(\n+            task, cast::reinterpret_cast(&map));\n+        rustrt::rust_task_local_data_atexit(task, cleanup_task_local_map);\n+        // Also need to reference it an extra time to keep it for now.\n+        cast::bump_box_refcount(map);\n+        map\n+    } else {\n+        let map = cast::transmute(move map_ptr);\n+        cast::bump_box_refcount(map);\n+        map\n+    }\n+}\n+\n+unsafe fn key_to_key_value<T: Owned>(\n+    key: LocalDataKey<T>) -> *libc::c_void {\n+\n+    // Keys are closures, which are (fnptr,envptr) pairs. Use fnptr.\n+    // Use reintepret_cast -- transmute would leak (forget) the closure.\n+    let pair: (*libc::c_void, *libc::c_void) = cast::reinterpret_cast(&key);\n+    pair.first()\n+}\n+\n+// If returning Some(..), returns with @T with the map's reference. Careful!\n+unsafe fn local_data_lookup<T: Owned>(\n+    map: TaskLocalMap, key: LocalDataKey<T>)\n+    -> Option<(uint, *libc::c_void)> {\n+\n+    let key_value = key_to_key_value(key);\n+    let map_pos = (*map).position(|entry|\n+        match entry {\n+            Some((k,_,_)) => k == key_value,\n+            None => false\n+        }\n+    );\n+    do map_pos.map |index| {\n+        // .get() is guaranteed because of \"None { false }\" above.\n+        let (_, data_ptr, _) = (*map)[index].get();\n+        (index, data_ptr)\n+    }\n+}\n+\n+unsafe fn local_get_helper<T: Owned>(\n+    task: *rust_task, key: LocalDataKey<T>,\n+    do_pop: bool) -> Option<@T> {\n+\n+    let map = get_task_local_map(task);\n+    // Interpreturn our findings from the map\n+    do local_data_lookup(map, key).map |result| {\n+        // A reference count magically appears on 'data' out of thin air. It\n+        // was referenced in the local_data box, though, not here, so before\n+        // overwriting the local_data_box we need to give an extra reference.\n+        // We must also give an extra reference when not removing.\n+        let (index, data_ptr) = result;\n+        let data: @T = cast::transmute(move data_ptr);\n+        cast::bump_box_refcount(data);\n+        if do_pop {\n+            (*map).set_elt(index, None);\n+        }\n+        data\n+    }\n+}\n+\n+unsafe fn local_pop<T: Owned>(\n+    task: *rust_task,\n+    key: LocalDataKey<T>) -> Option<@T> {\n+\n+    local_get_helper(task, key, true)\n+}\n+\n+unsafe fn local_get<T: Owned>(\n+    task: *rust_task,\n+    key: LocalDataKey<T>) -> Option<@T> {\n+\n+    local_get_helper(task, key, false)\n+}\n+\n+unsafe fn local_set<T: Owned>(\n+    task: *rust_task, key: LocalDataKey<T>, +data: @T) {\n+\n+    let map = get_task_local_map(task);\n+    // Store key+data as *voids. Data is invisibly referenced once; key isn't.\n+    let keyval = key_to_key_value(key);\n+    // We keep the data in two forms: one as an unsafe pointer, so we can get\n+    // it back by casting; another in an existential box, so the reference we\n+    // own on it can be dropped when the box is destroyed. The unsafe pointer\n+    // does not have a reference associated with it, so it may become invalid\n+    // when the box is destroyed.\n+    let data_ptr = cast::reinterpret_cast(&data);\n+    let data_box = data as LocalData;\n+    // Construct new entry to store in the map.\n+    let new_entry = Some((keyval, data_ptr, data_box));\n+    // Find a place to put it.\n+    match local_data_lookup(map, key) {\n+        Some((index, _old_data_ptr)) => {\n+            // Key already had a value set, _old_data_ptr, whose reference\n+            // will get dropped when the local_data box is overwritten.\n+            (*map).set_elt(index, new_entry);\n+        }\n+        None => {\n+            // Find an empty slot. If not, grow the vector.\n+            match (*map).position(|x| x.is_none()) {\n+                Some(empty_index) => (*map).set_elt(empty_index, new_entry),\n+                None => (*map).push(new_entry)\n+            }\n+        }\n+    }\n+}\n+\n+unsafe fn local_modify<T: Owned>(\n+    task: *rust_task, key: LocalDataKey<T>,\n+    modify_fn: fn(Option<@T>) -> Option<@T>) {\n+\n+    // Could be more efficient by doing the lookup work, but this is easy.\n+    let newdata = modify_fn(local_pop(task, key));\n+    if newdata.is_some() {\n+        local_set(task, key, option::unwrap(move newdata));\n+    }\n+}\n+\n+/* Exported interface for task-local data (plus local_data_key above). */\n+/**\n+ * Remove a task-local data value from the table, returning the\n+ * reference that was originally created to insert it.\n+ */\n+unsafe fn local_data_pop<T: Owned>(\n+    key: LocalDataKey<T>) -> Option<@T> {\n+\n+    local_pop(rustrt::rust_get_task(), key)\n+}\n+/**\n+ * Retrieve a task-local data value. It will also be kept alive in the\n+ * table until explicitly removed.\n+ */\n+unsafe fn local_data_get<T: Owned>(\n+    key: LocalDataKey<T>) -> Option<@T> {\n+\n+    local_get(rustrt::rust_get_task(), key)\n+}\n+/**\n+ * Store a value in task-local data. If this key already has a value,\n+ * that value is overwritten (and its destructor is run).\n+ */\n+unsafe fn local_data_set<T: Owned>(\n+    key: LocalDataKey<T>, +data: @T) {\n+\n+    local_set(rustrt::rust_get_task(), key, data)\n+}\n+/**\n+ * Modify a task-local data value. If the function returns 'None', the\n+ * data is removed (and its reference dropped).\n+ */\n+unsafe fn local_data_modify<T: Owned>(\n+    key: LocalDataKey<T>,\n+    modify_fn: fn(Option<@T>) -> Option<@T>) {\n+\n+    local_modify(rustrt::rust_get_task(), key, modify_fn)\n+}\n+\n+#[test]\n+fn test_tls_multitask() unsafe {\n+    fn my_key(+_x: @~str) { }\n+    local_data_set(my_key, @~\"parent data\");\n+    do task::spawn unsafe {\n+        assert local_data_get(my_key).is_none(); // TLS shouldn't carry over.\n+        local_data_set(my_key, @~\"child data\");\n+        assert *(local_data_get(my_key).get()) == ~\"child data\";\n+        // should be cleaned up for us\n+    }\n+    // Must work multiple times\n+    assert *(local_data_get(my_key).get()) == ~\"parent data\";\n+    assert *(local_data_get(my_key).get()) == ~\"parent data\";\n+    assert *(local_data_get(my_key).get()) == ~\"parent data\";\n+}\n+\n+#[test]\n+fn test_tls_overwrite() unsafe {\n+    fn my_key(+_x: @~str) { }\n+    local_data_set(my_key, @~\"first data\");\n+    local_data_set(my_key, @~\"next data\"); // Shouldn't leak.\n+    assert *(local_data_get(my_key).get()) == ~\"next data\";\n+}\n+\n+#[test]\n+fn test_tls_pop() unsafe {\n+    fn my_key(+_x: @~str) { }\n+    local_data_set(my_key, @~\"weasel\");\n+    assert *(local_data_pop(my_key).get()) == ~\"weasel\";\n+    // Pop must remove the data from the map.\n+    assert local_data_pop(my_key).is_none();\n+}\n+\n+#[test]\n+fn test_tls_modify() unsafe {\n+    fn my_key(+_x: @~str) { }\n+    local_data_modify(my_key, |data| {\n+        match data {\n+            Some(@val) => fail ~\"unwelcome value: \" + val,\n+            None       => Some(@~\"first data\")\n+        }\n+    });\n+    local_data_modify(my_key, |data| {\n+        match data {\n+            Some(@~\"first data\") => Some(@~\"next data\"),\n+            Some(@val)           => fail ~\"wrong value: \" + val,\n+            None                 => fail ~\"missing value\"\n+        }\n+    });\n+    assert *(local_data_pop(my_key).get()) == ~\"next data\";\n+}\n+\n+#[test]\n+fn test_tls_crust_automorestack_memorial_bug() unsafe {\n+    // This might result in a stack-canary clobber if the runtime fails to set\n+    // sp_limit to 0 when calling the cleanup extern - it might automatically\n+    // jump over to the rust stack, which causes next_c_sp to get recorded as\n+    // Something within a rust stack segment. Then a subsequent upcall (esp.\n+    // for logging, think vsnprintf) would run on a stack smaller than 1 MB.\n+    fn my_key(+_x: @~str) { }\n+    do task::spawn {\n+        unsafe { local_data_set(my_key, @~\"hax\"); }\n+    }\n+}\n+\n+#[test]\n+fn test_tls_multiple_types() unsafe {\n+    fn str_key(+_x: @~str) { }\n+    fn box_key(+_x: @@()) { }\n+    fn int_key(+_x: @int) { }\n+    do task::spawn unsafe {\n+        local_data_set(str_key, @~\"string data\");\n+        local_data_set(box_key, @@());\n+        local_data_set(int_key, @42);\n+    }\n+}\n+\n+#[test]\n+fn test_tls_overwrite_multiple_types() {\n+    fn str_key(+_x: @~str) { }\n+    fn box_key(+_x: @@()) { }\n+    fn int_key(+_x: @int) { }\n+    do task::spawn unsafe {\n+        local_data_set(str_key, @~\"string data\");\n+        local_data_set(int_key, @42);\n+        // This could cause a segfault if overwriting-destruction is done with\n+        // the crazy polymorphic transmute rather than the provided finaliser.\n+        local_data_set(int_key, @31337);\n+    }\n+}\n+\n+#[test]\n+#[should_fail]\n+#[ignore(cfg(windows))]\n+fn test_tls_cleanup_on_failure() unsafe {\n+    fn str_key(+_x: @~str) { }\n+    fn box_key(+_x: @@()) { }\n+    fn int_key(+_x: @int) { }\n+    local_data_set(str_key, @~\"parent data\");\n+    local_data_set(box_key, @@());\n+    do task::spawn unsafe { // spawn_linked\n+        local_data_set(str_key, @~\"string data\");\n+        local_data_set(box_key, @@());\n+        local_data_set(int_key, @42);\n+        fail;\n+    }\n+    // Not quite nondeterministic.\n+    local_data_set(int_key, @31337);\n+    fail;\n+}"}, {"sha": "f7aa0f7555ee2367c305f8a1470f9495a9fbaf25", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1397dca2dd07b93789226a22b2ccc456d0a5317a/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1397dca2dd07b93789226a22b2ccc456d0a5317a/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=1397dca2dd07b93789226a22b2ccc456d0a5317a", "patch": "@@ -39,15 +39,19 @@ macro_rules! interner_key (\n )\n \n fn serialize_ident<S: Serializer>(s: S, i: ident) {\n-    let intr = match unsafe{task::local_data_get(interner_key!())}{\n+    let intr = match unsafe{\n+        task::local_data::local_data_get(interner_key!())\n+    } {\n         None => fail ~\"serialization: TLS interner not set up\",\n         Some(intr) => intr\n     };\n \n     s.emit_str(*(*intr).get(i));\n }\n fn deserialize_ident<D: Deserializer>(d: D) -> ident  {\n-    let intr = match unsafe{task::local_data_get(interner_key!())}{\n+    let intr = match unsafe{\n+        task::local_data::local_data_get(interner_key!())\n+    } {\n         None => fail ~\"deserialization: TLS interner not set up\",\n         Some(intr) => intr\n     };"}, {"sha": "5629907ff1446fee058f9d1381b7447e3116aad0", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1397dca2dd07b93789226a22b2ccc456d0a5317a/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1397dca2dd07b93789226a22b2ccc456d0a5317a/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=1397dca2dd07b93789226a22b2ccc456d0a5317a", "patch": "@@ -348,8 +348,12 @@ fn mk_ident_interner() -> ident_interner {\n     let rv = interner::mk_prefill::<@~str>(init_vec);\n \n     /* having multiple interners will just confuse the serializer */\n-    unsafe{ assert task::local_data_get(interner_key!()).is_none() };\n-    unsafe{ task::local_data_set(interner_key!(), @rv) };\n+    unsafe {\n+        assert task::local_data::local_data_get(interner_key!()).is_none()\n+    };\n+    unsafe {\n+        task::local_data::local_data_set(interner_key!(), @rv)\n+    };\n     rv\n }\n "}, {"sha": "ba617b7cce61b0671d5b69005a42cdb9f915aab4", "filename": "src/rustdoc/extract.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1397dca2dd07b93789226a22b2ccc456d0a5317a/src%2Frustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1397dca2dd07b93789226a22b2ccc456d0a5317a/src%2Frustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fextract.rs?ref=1397dca2dd07b93789226a22b2ccc456d0a5317a", "patch": "@@ -2,10 +2,10 @@\n \n use syntax::ast;\n use doc::ItemUtils;\n+use task::local_data::local_data_get;\n \n export from_srv, extract, to_str, interner;\n \n-\n /* can't import macros yet, so this is copied from token.rs. See its comment\n  * there. */\n macro_rules! interner_key (\n@@ -16,13 +16,13 @@ macro_rules! interner_key (\n // Hack; rather than thread an interner through everywhere, rely on\n // thread-local data\n fn to_str(id: ast::ident) -> ~str {\n-    let intr = unsafe{ task::local_data_get(interner_key!()) };\n+    let intr = unsafe{ local_data_get(interner_key!()) };\n \n     return *(*intr.get()).get(id);\n }\n \n fn interner() -> syntax::parse::token::ident_interner {\n-    return *(unsafe{ task::local_data_get(interner_key!()) }).get();\n+    return *(unsafe{ local_data_get(interner_key!()) }).get();\n }\n \n fn from_srv("}]}