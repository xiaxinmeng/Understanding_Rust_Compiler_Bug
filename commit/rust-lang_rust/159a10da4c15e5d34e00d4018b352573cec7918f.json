{"sha": "159a10da4c15e5d34e00d4018b352573cec7918f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1OWExMGRhNGMxNWU1ZDM0ZTAwZDQwMThiMzUyNTczY2VjNzkxOGY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-04-22T05:02:19Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-04-23T17:03:43Z"}, "message": "rustc: Tweak the borrow on closure invocations\n\nThis alters the borrow checker's requirements on invoking closures from\nrequiring an immutable borrow to requiring a unique immutable borrow. This means\nthat it is illegal to invoke a closure through a `&` pointer because there is no\nguarantee that is not aliased. This does not mean that a closure is required to\nbe in a mutable location, but rather a location which can be proven to be\nunique (often through a mutable pointer).\n\nFor example, the following code is unsound and is no longer allowed:\n\n    type Fn<'a> = ||:'a;\n\n    fn call(f: |Fn|) {\n        f(|| {\n            f(|| {})\n        });\n    }\n\n    fn main() {\n        call(|a| {\n            a();\n        });\n    }\n\nThere is no replacement for this pattern. For all closures which are stored in\nstructures, it was previously allowed to invoke the closure through `&self` but\nit now requires invocation through `&mut self`.\n\nThe standard library has a good number of violations of this new rule, but the\nfixes will be separated into multiple breaking change commits.\n\nCloses #12224\n\n[breaking-change]", "tree": {"sha": "c6d05aa64f6248997959828c97143b2e4d0964da", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c6d05aa64f6248997959828c97143b2e4d0964da"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/159a10da4c15e5d34e00d4018b352573cec7918f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/159a10da4c15e5d34e00d4018b352573cec7918f", "html_url": "https://github.com/rust-lang/rust/commit/159a10da4c15e5d34e00d4018b352573cec7918f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/159a10da4c15e5d34e00d4018b352573cec7918f/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1e3358903d1ca150856183a696701b7dc7ceb568", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e3358903d1ca150856183a696701b7dc7ceb568", "html_url": "https://github.com/rust-lang/rust/commit/1e3358903d1ca150856183a696701b7dc7ceb568"}], "stats": {"total": 144, "additions": 125, "deletions": 19}, "files": [{"sha": "d0f4796683250dfe4b9ad4a6e5404aea475b4232", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/159a10da4c15e5d34e00d4018b352573cec7918f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/159a10da4c15e5d34e00d4018b352573cec7918f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=159a10da4c15e5d34e00d4018b352573cec7918f", "patch": "@@ -327,7 +327,7 @@ impl<'a> CheckLoanCtxt<'a> {\n                             self.bccx.loan_path_to_str(&*old_loan.loan_path))\n                 }\n \n-                AddrOf | AutoRef | RefBinding => {\n+                AddrOf | AutoRef | RefBinding | ClosureInvocation => {\n                     format!(\"previous borrow of `{}` occurs here\",\n                             self.bccx.loan_path_to_str(&*old_loan.loan_path))\n                 }"}, {"sha": "8bb95b798d0aa46e11446ec0a7fa0204505a54bc", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/159a10da4c15e5d34e00d4018b352573cec7918f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/159a10da4c15e5d34e00d4018b352573cec7918f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=159a10da4c15e5d34e00d4018b352573cec7918f", "patch": "@@ -292,6 +292,26 @@ fn gather_loans_in_expr(this: &mut GatherLoanCtxt,\n           visit::walk_expr(this, ex, ());\n       }\n \n+      ast::ExprCall(f, _) => {\n+          let expr_ty = ty::expr_ty_adjusted(tcx, f);\n+          match ty::get(expr_ty).sty {\n+              ty::ty_closure(~ty::ClosureTy {\n+                  store: ty::RegionTraitStore(..), ..\n+              }) => {\n+                  let scope_r = ty::ReScope(ex.id);\n+                  let base_cmt = this.bccx.cat_expr(f);\n+                  this.guarantee_valid_kind(f.id,\n+                                            f.span,\n+                                            base_cmt,\n+                                            ty::UniqueImmBorrow,\n+                                            scope_r,\n+                                            ClosureInvocation);\n+              }\n+              _ => {}\n+          }\n+          visit::walk_expr(this, ex, ());\n+      }\n+\n       _ => {\n           visit::walk_expr(this, ex, ());\n       }"}, {"sha": "3de64f151917e24436ec0f05671aa25959c9f276", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/159a10da4c15e5d34e00d4018b352573cec7918f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/159a10da4c15e5d34e00d4018b352573cec7918f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=159a10da4c15e5d34e00d4018b352573cec7918f", "patch": "@@ -202,6 +202,7 @@ pub enum LoanCause {\n     AddrOf,\n     AutoRef,\n     RefBinding,\n+    ClosureInvocation,\n }\n \n #[deriving(Eq, TotalEq, Hash)]\n@@ -629,6 +630,10 @@ impl<'a> BorrowckCtxt<'a> {\n                     AddrOf | RefBinding | AutoRef => {\n                         format!(\"cannot borrow {} as mutable\", descr)\n                     }\n+                    ClosureInvocation => {\n+                        self.tcx.sess.span_bug(err.span,\n+                            \"err_mutbl with a closure invocation\");\n+                    }\n                 }\n             }\n             err_out_of_root_scope(..) => {\n@@ -677,6 +682,10 @@ impl<'a> BorrowckCtxt<'a> {\n             BorrowViolation(RefBinding) => {\n                 \"cannot borrow data mutably\"\n             }\n+\n+            BorrowViolation(ClosureInvocation) => {\n+                \"closure invocation\"\n+            }\n         };\n \n         match cause {"}, {"sha": "b59da8910af8b4ff8d00f590c46f5168a9dabdd7", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 31, "deletions": 18, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/159a10da4c15e5d34e00d4018b352573cec7918f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/159a10da4c15e5d34e00d4018b352573cec7918f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=159a10da4c15e5d34e00d4018b352573cec7918f", "patch": "@@ -751,7 +751,15 @@ fn constrain_callee(rcx: &mut Rcx,\n         ty::ty_bare_fn(..) => { }\n         ty::ty_closure(ref closure_ty) => {\n             let region = match closure_ty.store {\n-                ty::RegionTraitStore(r, _) => r,\n+                ty::RegionTraitStore(r, _) => {\n+                    // While we're here, link the closure's region with a unique\n+                    // immutable borrow (gathered later in borrowck)\n+                    let mc = mc::MemCategorizationContext { typer: &*rcx };\n+                    let expr_cmt = ignore_err!(mc.cat_expr(callee_expr));\n+                    link_region(mc.typer, callee_expr.span, call_region,\n+                                ty::UniqueImmBorrow, expr_cmt);\n+                    r\n+                }\n                 ty::UniqTraitStore => ty::ReStatic\n             };\n             rcx.fcx.mk_subr(true, infer::InvokeClosure(callee_expr.span),\n@@ -874,7 +882,8 @@ fn constrain_autoderefs(rcx: &mut Rcx,\n                 {\n                     let mc = mc::MemCategorizationContext { typer: &*rcx };\n                     let self_cmt = ignore_err!(mc.cat_expr_autoderefd(deref_expr, i));\n-                    link_region(mc.typer, deref_expr.span, r, m, self_cmt);\n+                    link_region(mc.typer, deref_expr.span, r,\n+                                ty::BorrowKind::from_mutbl(m), self_cmt);\n                 }\n \n                 // Specialized version of constrain_call.\n@@ -1092,7 +1101,8 @@ fn link_pattern(mc: mc::MemCategorizationContext<&Rcx>,\n                     match mc.cat_slice_pattern(sub_cmt, slice_pat) {\n                         Ok((slice_cmt, slice_mutbl, slice_r)) => {\n                             link_region(mc.typer, sub_pat.span, slice_r,\n-                                        slice_mutbl, slice_cmt);\n+                                        ty::BorrowKind::from_mutbl(slice_mutbl),\n+                                        slice_cmt);\n                         }\n                         Err(()) => {}\n                     }\n@@ -1118,17 +1128,20 @@ fn link_autoref(rcx: &Rcx,\n \n     match *autoref {\n         ty::AutoPtr(r, m) => {\n-            link_region(mc.typer, expr.span, r, m, expr_cmt);\n+            link_region(mc.typer, expr.span, r,\n+                        ty::BorrowKind::from_mutbl(m), expr_cmt);\n         }\n \n         ty::AutoBorrowVec(r, m) | ty::AutoBorrowVecRef(r, m) => {\n             let cmt_index = mc.cat_index(expr, expr_cmt, autoderefs+1);\n-            link_region(mc.typer, expr.span, r, m, cmt_index);\n+            link_region(mc.typer, expr.span, r,\n+                        ty::BorrowKind::from_mutbl(m), cmt_index);\n         }\n \n         ty::AutoBorrowObj(r, m) => {\n             let cmt_deref = mc.cat_deref_obj(expr, expr_cmt);\n-            link_region(mc.typer, expr.span, r, m, cmt_deref);\n+            link_region(mc.typer, expr.span, r,\n+                        ty::BorrowKind::from_mutbl(m), cmt_deref);\n         }\n \n         ty::AutoUnsafe(_) => {}\n@@ -1150,7 +1163,7 @@ fn link_by_ref(rcx: &Rcx,\n     let mc = mc::MemCategorizationContext { typer: rcx };\n     let expr_cmt = ignore_err!(mc.cat_expr(expr));\n     let region_min = ty::ReScope(callee_scope);\n-    link_region(mc.typer, expr.span, region_min, ast::MutImmutable, expr_cmt);\n+    link_region(mc.typer, expr.span, region_min, ty::ImmBorrow, expr_cmt);\n }\n \n fn link_region_from_node_type(rcx: &Rcx,\n@@ -1169,18 +1182,19 @@ fn link_region_from_node_type(rcx: &Rcx,\n         let tcx = rcx.fcx.ccx.tcx;\n         debug!(\"rptr_ty={}\", ty_to_str(tcx, rptr_ty));\n         let r = ty::ty_region(tcx, span, rptr_ty);\n-        link_region(rcx, span, r, mutbl, cmt_borrowed);\n+        link_region(rcx, span, r, ty::BorrowKind::from_mutbl(mutbl),\n+                    cmt_borrowed);\n     }\n }\n \n fn link_region(rcx: &Rcx,\n                span: Span,\n                region_min: ty::Region,\n-               mutbl: ast::Mutability,\n+               kind: ty::BorrowKind,\n                cmt_borrowed: mc::cmt) {\n     /*!\n      * Informs the inference engine that a borrow of `cmt`\n-     * must have mutability `mutbl` and lifetime `region_min`.\n+     * must have the borrow kind `kind` and lifetime `region_min`.\n      * If `cmt` is a deref of a region pointer with\n      * lifetime `r_borrowed`, this will add the constraint that\n      * `region_min <= r_borrowed`.\n@@ -1190,9 +1204,9 @@ fn link_region(rcx: &Rcx,\n     // for the lifetime `region_min` for the borrow to be valid:\n     let mut cmt_borrowed = cmt_borrowed;\n     loop {\n-        debug!(\"link_region(region_min={}, mutbl={}, cmt_borrowed={})\",\n+        debug!(\"link_region(region_min={}, kind={}, cmt_borrowed={})\",\n                region_min.repr(rcx.tcx()),\n-               mutbl.repr(rcx.tcx()),\n+               kind.repr(rcx.tcx()),\n                cmt_borrowed.repr(rcx.tcx()));\n         match cmt_borrowed.cat.clone() {\n             mc::cat_deref(base, _, mc::BorrowedPtr(_, r_borrowed)) => {\n@@ -1214,7 +1228,7 @@ fn link_region(rcx: &Rcx,\n                                 adjust_upvar_borrow_kind_for_loan(\n                                     *upvar_id,\n                                     upvar_borrow,\n-                                    mutbl);\n+                                    kind);\n                                 infer::ReborrowUpvar(span, *upvar_id)\n                             }\n                             None => {\n@@ -1236,7 +1250,7 @@ fn link_region(rcx: &Rcx,\n                        r_borrowed.repr(rcx.tcx()));\n                 rcx.fcx.mk_subr(true, cause, region_min, r_borrowed);\n \n-                if mutbl == ast::MutMutable {\n+                if kind != ty::ImmBorrow {\n                     // If this is a mutable borrow, then the thing\n                     // being borrowed will have to be unique.\n                     // In user code, this means it must be an `&mut`\n@@ -1428,12 +1442,11 @@ fn link_upvar_borrow_kind_for_nested_closures(rcx: &mut Rcx,\n \n fn adjust_upvar_borrow_kind_for_loan(upvar_id: ty::UpvarId,\n                                      upvar_borrow: &mut ty::UpvarBorrow,\n-                                     mutbl: ast::Mutability) {\n+                                     kind: ty::BorrowKind) {\n     debug!(\"adjust_upvar_borrow_kind_for_loan: upvar_id={:?} kind={:?} -> {:?}\",\n-           upvar_id, upvar_borrow.kind, mutbl);\n+           upvar_id, upvar_borrow.kind, kind);\n \n-    adjust_upvar_borrow_kind(upvar_id, upvar_borrow,\n-                             ty::BorrowKind::from_mutbl(mutbl))\n+    adjust_upvar_borrow_kind(upvar_id, upvar_borrow, kind)\n }\n \n fn adjust_upvar_borrow_kind(upvar_id: ty::UpvarId,"}, {"sha": "002ae5a7d28b418ab394d40247ff8aa100f4bf42", "filename": "src/test/compile-fail/borrowck-call-is-borrow-issue-12224.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/159a10da4c15e5d34e00d4018b352573cec7918f/src%2Ftest%2Fcompile-fail%2Fborrowck-call-is-borrow-issue-12224.rs", "raw_url": "https://github.com/rust-lang/rust/raw/159a10da4c15e5d34e00d4018b352573cec7918f/src%2Ftest%2Fcompile-fail%2Fborrowck-call-is-borrow-issue-12224.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-call-is-borrow-issue-12224.rs?ref=159a10da4c15e5d34e00d4018b352573cec7918f", "patch": "@@ -0,0 +1,64 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Ensure that invoking a closure counts as a unique immutable borrow\n+\n+\n+type Fn<'a> = ||:'a;\n+\n+struct Test<'a> {\n+    f: ||: 'a\n+}\n+\n+fn call(f: |Fn|) {\n+    f(|| {\n+    //~^ ERROR: closure requires unique access to `f` but it is already borrowed\n+        f(|| {})\n+    });\n+}\n+\n+fn test1() {\n+    call(|a| {\n+        a();\n+    });\n+}\n+\n+fn test2(f: &||) {\n+    (*f)(); //~ ERROR: closure invocation in a `&` reference\n+}\n+\n+fn test3(f: &mut ||) {\n+    (*f)();\n+}\n+\n+fn test4(f: &Test) {\n+    (f.f)() //~ ERROR: closure invocation in a `&` reference\n+}\n+\n+fn test5(f: &mut Test) {\n+    (f.f)()\n+}\n+\n+fn test6() {\n+    let f = || {};\n+    (|| {\n+        f();\n+    })();\n+}\n+\n+fn test7() {\n+    fn foo(_: |g: |int|, b: int|) {}\n+    let f = |g: |int|, b: int| {};\n+    f(|a| { //~ ERROR: cannot borrow `f` as immutable because previous closure\n+        foo(f); //~ ERROR: cannot move out of captured outer variable\n+    }, 3);\n+}\n+\n+fn main() {}"}]}