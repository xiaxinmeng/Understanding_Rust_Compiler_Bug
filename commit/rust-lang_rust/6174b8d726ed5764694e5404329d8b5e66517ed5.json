{"sha": "6174b8d726ed5764694e5404329d8b5e66517ed5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxNzRiOGQ3MjZlZDU3NjQ2OTRlNTQwNDMyOWQ4YjVlNjY1MTdlZDU=", "commit": {"author": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2015-08-13T16:39:46Z"}, "committer": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2015-08-22T22:28:56Z"}, "message": "Refactor low-level UTF-16 decoding.\n\n* Rename `utf16_items` to `decode_utf16`. \"Items\" is meaningless.\n* Move it to `rustc_unicode::char`, exposed in `std::char`.\n* Generalize it to any `u16` iterable, not just `&[u16]`.\n* Make it yield `Result` instead of a custom `Utf16Item` enum that was isomorphic to `Result`. This enable using the `FromIterator for Result` impl.\n* Add a `REPLACEMENT_CHARACTER` constant.\n* Document how `result.unwrap_or(REPLACEMENT_CHARACTER)` replaces `Utf16Item::to_char_lossy`.", "tree": {"sha": "47dd9d787f7550a5d47301652fc5081446f6495e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/47dd9d787f7550a5d47301652fc5081446f6495e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6174b8d726ed5764694e5404329d8b5e66517ed5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6174b8d726ed5764694e5404329d8b5e66517ed5", "html_url": "https://github.com/rust-lang/rust/commit/6174b8d726ed5764694e5404329d8b5e66517ed5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6174b8d726ed5764694e5404329d8b5e66517ed5/comments", "author": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c408b7863389aa2bdb253ffa363e693bcd02439f", "url": "https://api.github.com/repos/rust-lang/rust/commits/c408b7863389aa2bdb253ffa363e693bcd02439f", "html_url": "https://github.com/rust-lang/rust/commit/c408b7863389aa2bdb253ffa363e693bcd02439f"}], "stats": {"total": 225, "additions": 164, "deletions": 61}, "files": [{"sha": "d1e91b28c46fd23028c7f451ecbe0150d16f4795", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6174b8d726ed5764694e5404329d8b5e66517ed5/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6174b8d726ed5764694e5404329d8b5e66517ed5/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=6174b8d726ed5764694e5404329d8b5e66517ed5", "patch": "@@ -56,6 +56,7 @@\n #![feature(unicode)]\n #![feature(unique)]\n #![feature(unsafe_no_drop_flag, filling_drop)]\n+#![feature(decode_utf16)]\n #![feature(utf8_error)]\n #![cfg_attr(test, feature(rand, test))]\n "}, {"sha": "e7b2423c7c41fe42d4e4a8e3475dc99c557d10be", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6174b8d726ed5764694e5404329d8b5e66517ed5/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6174b8d726ed5764694e5404329d8b5e66517ed5/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=6174b8d726ed5764694e5404329d8b5e66517ed5", "patch": "@@ -20,8 +20,8 @@ use core::ops::{self, Deref, Add, Index};\n use core::ptr;\n use core::slice;\n use core::str::pattern::Pattern;\n+use rustc_unicode::char::{decode_utf16, REPLACEMENT_CHARACTER};\n use rustc_unicode::str as unicode_str;\n-use rustc_unicode::str::Utf16Item;\n \n use borrow::{Cow, IntoCow};\n use range::RangeArgument;\n@@ -267,14 +267,7 @@ impl String {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn from_utf16(v: &[u16]) -> Result<String, FromUtf16Error> {\n-        let mut s = String::with_capacity(v.len());\n-        for c in unicode_str::utf16_items(v) {\n-            match c {\n-                Utf16Item::ScalarValue(c) => s.push(c),\n-                Utf16Item::LoneSurrogate(_) => return Err(FromUtf16Error(())),\n-            }\n-        }\n-        Ok(s)\n+        decode_utf16(v.iter().cloned()).collect::<Result<_, _>>().map_err(|_| FromUtf16Error(()))\n     }\n \n     /// Decode a UTF-16 encoded vector `v` into a string, replacing\n@@ -294,7 +287,7 @@ impl String {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn from_utf16_lossy(v: &[u16]) -> String {\n-        unicode_str::utf16_items(v).map(|c| c.to_char_lossy()).collect()\n+        decode_utf16(v.iter().cloned()).map(|r| r.unwrap_or(REPLACEMENT_CHARACTER)).collect()\n     }\n \n     /// Creates a new `String` from a length, capacity, and pointer."}, {"sha": "9512b35267cfc25013969622829d13fe360e8eaa", "filename": "src/libcoretest/char.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6174b8d726ed5764694e5404329d8b5e66517ed5/src%2Flibcoretest%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6174b8d726ed5764694e5404329d8b5e66517ed5/src%2Flibcoretest%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fchar.rs?ref=6174b8d726ed5764694e5404329d8b5e66517ed5", "patch": "@@ -211,3 +211,12 @@ fn test_len_utf16() {\n     assert!('\\u{a66e}'.len_utf16() == 1);\n     assert!('\\u{1f4a9}'.len_utf16() == 2);\n }\n+\n+#[test]\n+fn test_decode_utf16() {\n+    fn check(s: &[u16], expected: &[Result<char, u16>]) {\n+        assert_eq!(::std::char::decode_utf16(s.iter().cloned()).collect::<Vec<_>>(), expected);\n+    }\n+    check(&[0xD800, 0x41, 0x42], &[Err(0xD800), Ok('A'), Ok('B')]);\n+    check(&[0xD800, 0], &[Err(0xD800), Ok('\\0')]);\n+}"}, {"sha": "dda1b096e88ed68c202587a233b0daf61b9b0088", "filename": "src/libcoretest/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6174b8d726ed5764694e5404329d8b5e66517ed5/src%2Flibcoretest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6174b8d726ed5764694e5404329d8b5e66517ed5/src%2Flibcoretest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Flib.rs?ref=6174b8d726ed5764694e5404329d8b5e66517ed5", "patch": "@@ -19,6 +19,7 @@\n #![feature(float_from_str_radix)]\n #![feature(flt2dec)]\n #![feature(dec2flt)]\n+#![feature(decode_utf16)]\n #![feature(fmt_radix)]\n #![feature(iter_arith)]\n #![feature(iter_arith)]"}, {"sha": "e08b3244109d579c2243f44dd79c4d38d8e145d5", "filename": "src/librustc_unicode/char.rs", "status": "modified", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/6174b8d726ed5764694e5404329d8b5e66517ed5/src%2Flibrustc_unicode%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6174b8d726ed5764694e5404329d8b5e66517ed5/src%2Flibrustc_unicode%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_unicode%2Fchar.rs?ref=6174b8d726ed5764694e5404329d8b5e66517ed5", "patch": "@@ -503,3 +503,116 @@ impl char {\n         ToUppercase(CaseMappingIter::new(conversions::to_upper(self)))\n     }\n }\n+\n+/// An iterator that decodes UTF-16 encoded codepoints from an iterator of `u16`s.\n+#[unstable(feature = \"decode_utf16\", reason = \"recently exposed\", issue = \"27830\")]\n+#[derive(Clone)]\n+pub struct DecodeUtf16<I> where I: Iterator<Item=u16> {\n+    iter: I,\n+    buf: Option<u16>,\n+}\n+\n+/// Create an iterator over the UTF-16 encoded codepoints in `iterable`,\n+/// returning unpaired surrogates as `Err`s.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(decode_utf16)]\n+///\n+/// use std::char::decode_utf16;\n+///\n+/// fn main() {\n+///     // \ud834\udd1emus<invalid>ic<invalid>\n+///     let v = [0xD834, 0xDD1E, 0x006d, 0x0075,\n+///              0x0073, 0xDD1E, 0x0069, 0x0063,\n+///              0xD834];\n+///\n+///     assert_eq!(decode_utf16(v.iter().cloned()).collect::<Vec<_>>(),\n+///                vec![Ok('\ud834\udd1e'),\n+///                     Ok('m'), Ok('u'), Ok('s'),\n+///                     Err(0xDD1E),\n+///                     Ok('i'), Ok('c'),\n+///                     Err(0xD834)]);\n+/// }\n+/// ```\n+///\n+/// A lossy decoder can be obtained by replacing `Err` results with the replacement character:\n+///\n+/// ```\n+/// #![feature(decode_utf16)]\n+///\n+/// use std::char::{decode_utf16, REPLACEMENT_CHARACTER};\n+///\n+/// fn main() {\n+///     // \ud834\udd1emus<invalid>ic<invalid>\n+///     let v = [0xD834, 0xDD1E, 0x006d, 0x0075,\n+///              0x0073, 0xDD1E, 0x0069, 0x0063,\n+///              0xD834];\n+///\n+///     assert_eq!(decode_utf16(v.iter().cloned())\n+///                    .map(|r| r.unwrap_or(REPLACEMENT_CHARACTER))\n+///                    .collect::<String>(),\n+///                \"\ud834\udd1emus\ufffdic\ufffd\");\n+/// }\n+/// ```\n+#[unstable(feature = \"decode_utf16\", reason = \"recently exposed\", issue = \"27830\")]\n+#[inline]\n+pub fn decode_utf16<I: IntoIterator<Item=u16>>(iterable: I) -> DecodeUtf16<I::IntoIter> {\n+    DecodeUtf16 {\n+        iter: iterable.into_iter(),\n+        buf: None,\n+    }\n+}\n+\n+#[unstable(feature = \"decode_utf16\", reason = \"recently exposed\", issue = \"27830\")]\n+impl<I: Iterator<Item=u16>> Iterator for DecodeUtf16<I> {\n+    type Item = Result<char, u16>;\n+\n+    fn next(&mut self) -> Option<Result<char, u16>> {\n+        let u = match self.buf.take() {\n+            Some(buf) => buf,\n+            None => match self.iter.next() {\n+                Some(u) => u,\n+                None => return None\n+            }\n+        };\n+\n+        if u < 0xD800 || 0xDFFF < u {\n+            // not a surrogate\n+            Some(Ok(unsafe { from_u32_unchecked(u as u32) }))\n+        } else if u >= 0xDC00 {\n+            // a trailing surrogate\n+            Some(Err(u))\n+        } else {\n+            let u2 = match self.iter.next() {\n+                Some(u2) => u2,\n+                // eof\n+                None => return Some(Err(u))\n+            };\n+            if u2 < 0xDC00 || u2 > 0xDFFF {\n+                // not a trailing surrogate so we're not a valid\n+                // surrogate pair, so rewind to redecode u2 next time.\n+                self.buf = Some(u2);\n+                return Some(Err(u))\n+            }\n+\n+            // all ok, so lets decode it.\n+            let c = (((u - 0xD800) as u32) << 10 | (u2 - 0xDC00) as u32) + 0x1_0000;\n+            Some(Ok(unsafe { from_u32_unchecked(c) }))\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (low, high) = self.iter.size_hint();\n+        // we could be entirely valid surrogates (2 elements per\n+        // char), or entirely non-surrogates (1 element per char)\n+        (low / 2, high)\n+    }\n+}\n+\n+/// U+FFFD REPLACEMENT CHARACTER (\ufffd) is used in Unicode to represent a decoding error.\n+/// It can occur, for example, when giving ill-formed UTF-8 bytes to `String::from_utf8_lossy`.\n+#[unstable(feature = \"decode_utf16\", reason = \"recently added\", issue = \"27830\")]\n+pub const REPLACEMENT_CHARACTER: char = '\\u{FFFD}';"}, {"sha": "4f0aa69d7719930e6811d4224b71bd577a05730e", "filename": "src/librustc_unicode/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6174b8d726ed5764694e5404329d8b5e66517ed5/src%2Flibrustc_unicode%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6174b8d726ed5764694e5404329d8b5e66517ed5/src%2Flibrustc_unicode%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_unicode%2Flib.rs?ref=6174b8d726ed5764694e5404329d8b5e66517ed5", "patch": "@@ -46,6 +46,7 @@ mod tables;\n mod u_str;\n pub mod char;\n \n+#[allow(deprecated)]\n pub mod str {\n     pub use u_str::{UnicodeStr, SplitWhitespace};\n     pub use u_str::{utf8_char_width, is_utf16, Utf16Items, Utf16Item};"}, {"sha": "67333c98fcf84bc5dd40e63fc6a323225995d3cf", "filename": "src/librustc_unicode/u_str.rs", "status": "modified", "additions": 24, "deletions": 39, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/6174b8d726ed5764694e5404329d8b5e66517ed5/src%2Flibrustc_unicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6174b8d726ed5764694e5404329d8b5e66517ed5/src%2Flibrustc_unicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_unicode%2Fu_str.rs?ref=6174b8d726ed5764694e5404329d8b5e66517ed5", "patch": "@@ -13,8 +13,9 @@\n //! This module provides functionality to `str` that requires the Unicode methods provided by the\n //! unicode parts of the CharExt trait.\n \n+use char::{DecodeUtf16, decode_utf16};\n use core::char;\n-use core::iter::Filter;\n+use core::iter::{Cloned, Filter};\n use core::slice;\n use core::str::Split;\n \n@@ -119,11 +120,18 @@ pub fn is_utf16(v: &[u16]) -> bool {\n \n /// An iterator that decodes UTF-16 encoded codepoints from a vector\n /// of `u16`s.\n+#[deprecated(since = \"1.4.0\", reason = \"renamed to `char::DecodeUtf16`\")]\n+#[unstable(feature = \"decode_utf16\", reason = \"not exposed in std\", issue = \"27830\")]\n+#[allow(deprecated)]\n #[derive(Clone)]\n pub struct Utf16Items<'a> {\n-    iter: slice::Iter<'a, u16>\n+    decoder: DecodeUtf16<Cloned<slice::Iter<'a, u16>>>\n }\n+\n /// The possibilities for values decoded from a `u16` stream.\n+#[deprecated(since = \"1.4.0\", reason = \"`char::DecodeUtf16` uses `Result<char, u16>` instead\")]\n+#[unstable(feature = \"decode_utf16\", reason = \"not exposed in std\", issue = \"27830\")]\n+#[allow(deprecated)]\n #[derive(Copy, PartialEq, Eq, Clone, Debug)]\n pub enum Utf16Item {\n     /// A valid codepoint.\n@@ -132,6 +140,7 @@ pub enum Utf16Item {\n     LoneSurrogate(u16)\n }\n \n+#[allow(deprecated)]\n impl Utf16Item {\n     /// Convert `self` to a `char`, taking `LoneSurrogate`s to the\n     /// replacement character (U+FFFD).\n@@ -144,49 +153,22 @@ impl Utf16Item {\n     }\n }\n \n+#[deprecated(since = \"1.4.0\", reason = \"use `char::DecodeUtf16` instead\")]\n+#[unstable(feature = \"decode_utf16\", reason = \"not exposed in std\", issue = \"27830\")]\n+#[allow(deprecated)]\n impl<'a> Iterator for Utf16Items<'a> {\n     type Item = Utf16Item;\n \n     fn next(&mut self) -> Option<Utf16Item> {\n-        let u = match self.iter.next() {\n-            Some(u) => *u,\n-            None => return None\n-        };\n-\n-        if u < 0xD800 || 0xDFFF < u {\n-            // not a surrogate\n-            Some(Utf16Item::ScalarValue(unsafe { char::from_u32_unchecked(u as u32) }))\n-        } else if u >= 0xDC00 {\n-            // a trailing surrogate\n-            Some(Utf16Item::LoneSurrogate(u))\n-        } else {\n-            // preserve state for rewinding.\n-            let old = self.iter.clone();\n-\n-            let u2 = match self.iter.next() {\n-                Some(u2) => *u2,\n-                // eof\n-                None => return Some(Utf16Item::LoneSurrogate(u))\n-            };\n-            if u2 < 0xDC00 || u2 > 0xDFFF {\n-                // not a trailing surrogate so we're not a valid\n-                // surrogate pair, so rewind to redecode u2 next time.\n-                self.iter = old.clone();\n-                return Some(Utf16Item::LoneSurrogate(u))\n-            }\n-\n-            // all ok, so lets decode it.\n-            let c = (((u - 0xD800) as u32) << 10 | (u2 - 0xDC00) as u32) + 0x1_0000;\n-            Some(Utf16Item::ScalarValue(unsafe { char::from_u32_unchecked(c) }))\n-        }\n+        self.decoder.next().map(|result| match result {\n+            Ok(c) => Utf16Item::ScalarValue(c),\n+            Err(s) => Utf16Item::LoneSurrogate(s),\n+        })\n     }\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (low, high) = self.iter.size_hint();\n-        // we could be entirely valid surrogates (2 elements per\n-        // char), or entirely non-surrogates (1 element per char)\n-        (low / 2, high)\n+        self.decoder.size_hint()\n     }\n }\n \n@@ -196,7 +178,7 @@ impl<'a> Iterator for Utf16Items<'a> {\n /// # Examples\n ///\n /// ```\n-/// #![feature(unicode)]\n+/// #![feature(unicode, decode_utf16)]\n ///\n /// extern crate rustc_unicode;\n ///\n@@ -216,8 +198,11 @@ impl<'a> Iterator for Utf16Items<'a> {\n ///                     LoneSurrogate(0xD834)]);\n /// }\n /// ```\n+#[deprecated(since = \"1.4.0\", reason = \"renamed to `char::decode_utf16`\")]\n+#[unstable(feature = \"decode_utf16\", reason = \"not exposed in std\", issue = \"27830\")]\n+#[allow(deprecated)]\n pub fn utf16_items<'a>(v: &'a [u16]) -> Utf16Items<'a> {\n-    Utf16Items { iter : v.iter() }\n+    Utf16Items { decoder: decode_utf16(v.iter().cloned()) }\n }\n \n /// Iterator adaptor for encoding `char`s to UTF-16."}, {"sha": "09f98978653e3b9418be3afefd305a67984e627c", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6174b8d726ed5764694e5404329d8b5e66517ed5/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6174b8d726ed5764694e5404329d8b5e66517ed5/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=6174b8d726ed5764694e5404329d8b5e66517ed5", "patch": "@@ -209,8 +209,6 @@ use std::str::FromStr;\n use std::string;\n use std::{char, f64, fmt, str};\n use std;\n-use rustc_unicode::str as unicode_str;\n-use rustc_unicode::str::Utf16Item;\n \n use Encodable;\n \n@@ -1712,11 +1710,13 @@ impl<T: Iterator<Item=char>> Parser<T> {\n                                 _ => return self.error(UnexpectedEndOfHexEscape),\n                             }\n \n-                            let buf = [n1, try!(self.decode_hex_escape())];\n-                            match unicode_str::utf16_items(&buf).next() {\n-                                Some(Utf16Item::ScalarValue(c)) => res.push(c),\n-                                _ => return self.error(LoneLeadingSurrogateInHexEscape),\n+                            let n2 = try!(self.decode_hex_escape());\n+                            if n2 < 0xDC00 || n2 > 0xDFFF {\n+                                return self.error(LoneLeadingSurrogateInHexEscape)\n                             }\n+                            let c = (((n1 - 0xD800) as u32) << 10 |\n+                                     (n2 - 0xDC00) as u32) + 0x1_0000;\n+                            res.push(char::from_u32(c).unwrap());\n                         }\n \n                         n => match char::from_u32(n as u32) {"}, {"sha": "fca4c66112eb6c89e3ad878ef0f442abbb6cf1e2", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6174b8d726ed5764694e5404329d8b5e66517ed5/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6174b8d726ed5764694e5404329d8b5e66517ed5/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=6174b8d726ed5764694e5404329d8b5e66517ed5", "patch": "@@ -242,6 +242,7 @@\n #![feature(unicode)]\n #![feature(unique)]\n #![feature(unsafe_no_drop_flag, filling_drop)]\n+#![feature(decode_utf16)]\n #![feature(vec_push_all)]\n #![feature(vec_resize)]\n #![feature(wrapping)]"}, {"sha": "eb313d275a19178006b524dd392a98d7011d6c82", "filename": "src/libstd/sys/common/wtf8.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6174b8d726ed5764694e5404329d8b5e66517ed5/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6174b8d726ed5764694e5404329d8b5e66517ed5/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs?ref=6174b8d726ed5764694e5404329d8b5e66517ed5", "patch": "@@ -37,7 +37,6 @@ use hash::{Hash, Hasher};\n use iter::FromIterator;\n use mem;\n use ops;\n-use rustc_unicode::str::{Utf16Item, utf16_items};\n use slice;\n use str;\n use string::String;\n@@ -186,14 +185,14 @@ impl Wtf8Buf {\n     /// will always return the original code units.\n     pub fn from_wide(v: &[u16]) -> Wtf8Buf {\n         let mut string = Wtf8Buf::with_capacity(v.len());\n-        for item in utf16_items(v) {\n+        for item in char::decode_utf16(v.iter().cloned()) {\n             match item {\n-                Utf16Item::ScalarValue(c) => string.push_char(c),\n-                Utf16Item::LoneSurrogate(s) => {\n+                Ok(ch) => string.push_char(ch),\n+                Err(surrogate) => {\n                     // Surrogates are known to be in the code point range.\n-                    let code_point = unsafe { CodePoint::from_u32_unchecked(s as u32) };\n+                    let code_point = unsafe { CodePoint::from_u32_unchecked(surrogate as u32) };\n                     // Skip the WTF-8 concatenation check,\n-                    // surrogate pairs are already decoded by utf16_items\n+                    // surrogate pairs are already decoded by decode_utf16\n                     string.push_code_point_unchecked(code_point)\n                 }\n             }"}]}