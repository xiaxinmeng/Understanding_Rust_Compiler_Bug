{"sha": "e203f30bc743ff3de271d8db80acd21991e903df", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyMDNmMzBiYzc0M2ZmM2RlMjcxZDhkYjgwYWNkMjE5OTFlOTAzZGY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-29T21:14:34Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-29T22:56:16Z"}, "message": "Register new snapshots", "tree": {"sha": "0715830a57d2924ae41537b243024eb5e836976d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0715830a57d2924ae41537b243024eb5e836976d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e203f30bc743ff3de271d8db80acd21991e903df", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e203f30bc743ff3de271d8db80acd21991e903df", "html_url": "https://github.com/rust-lang/rust/commit/e203f30bc743ff3de271d8db80acd21991e903df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e203f30bc743ff3de271d8db80acd21991e903df/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "886819cca1208210cb73892f8fe4b7b9140068dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/886819cca1208210cb73892f8fe4b7b9140068dc", "html_url": "https://github.com/rust-lang/rust/commit/886819cca1208210cb73892f8fe4b7b9140068dc"}], "stats": {"total": 6802, "additions": 22, "deletions": 6780}, "files": [{"sha": "e002e656d974ae392963c9106c88f8f2a5611d12", "filename": "mk/stage0.mk", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e203f30bc743ff3de271d8db80acd21991e903df/mk%2Fstage0.mk", "raw_url": "https://github.com/rust-lang/rust/raw/e203f30bc743ff3de271d8db80acd21991e903df/mk%2Fstage0.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fstage0.mk?ref=e203f30bc743ff3de271d8db80acd21991e903df", "patch": "@@ -98,17 +98,13 @@ $$(HLIB0_H_$(1))/$(CFG_EXTRALIB_$(1)): \\\n \t$$(Q)cp $$(TLIB$(2)_T_$(1)_H_$(3))/$(EXTRALIB_GLOB_$(1)) $$@\n \t$$(call LIST_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(EXTRALIB_GLOB_$(4)),$$(notdir $$@))\n \n-$$(HLIB0_H_$(1))/$(CFG_LIBRUSTUV_$(1)):\n-\ttouch $$@\n-# NOTE: this should get uncommented after a snapshot and the rule above this can\n-#\tget deleted, right now we're not expecting a librustuv in a snapshot.\n-# $$(HLIB0_H_$(1))/$(CFG_LIBRUSTUV_$(1)): \\\n-# \t\t$$(TLIB$(2)_T_$(1)_H_$(3))/$(CFG_LIBRUSTUV_$(1)) \\\n-# \t\t| $(HLIB0_H_$(1))/\n-# \t@$$(call E, cp: $$@)\n-# \t$$(call CHECK_FOR_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(LIBRUSTUV_GLOB_$(4)),$$(notdir $$@))\n-# \t$$(Q)cp $$(TLIB$(2)_T_$(1)_H_$(3))/$(LIBRUSTUV_GLOB_$(1)) $$@\n-# \t$$(call LIST_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(LIBRUSTUV_GLOB_$(4)),$$(notdir $$@))\n+$$(HLIB0_H_$(1))/$(CFG_LIBRUSTUV_$(1)): \\\n+\t\t$$(TLIB$(2)_T_$(1)_H_$(3))/$(CFG_LIBRUSTUV_$(1)) \\\n+\t\t| $(HLIB0_H_$(1))/\n+\t@$$(call E, cp: $$@)\n+\t$$(call CHECK_FOR_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(LIBRUSTUV_GLOB_$(4)),$$(notdir $$@))\n+\t$$(Q)cp $$(TLIB$(2)_T_$(1)_H_$(3))/$(LIBRUSTUV_GLOB_$(1)) $$@\n+\t$$(call LIST_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(LIBRUSTUV_GLOB_$(4)),$$(notdir $$@))\n \n $$(HLIB0_H_$(1))/$(CFG_LIBRUSTC_$(1)): \\\n \t\t$$(TLIB$(2)_T_$(1)_H_$(3))/$(CFG_LIBRUSTC_$(1)) \\"}, {"sha": "9119d1fb4e39374d307b9e12b57d824a4a4e1295", "filename": "src/librustuv/rustuv.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e203f30bc743ff3de271d8db80acd21991e903df/src%2Flibrustuv%2Frustuv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e203f30bc743ff3de271d8db80acd21991e903df/src%2Flibrustuv%2Frustuv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Frustuv.rs?ref=e203f30bc743ff3de271d8db80acd21991e903df", "patch": "@@ -232,15 +232,14 @@ impl<H, W: Watcher + NativeHandle<*H>> WatcherInterop for W {\n         }\n     }\n \n-    fn close(self, cb: NullCallback) {\n-        let mut this = self;\n+    fn close(mut self, cb: NullCallback) {\n         {\n-            let data = this.get_watcher_data();\n+            let data = self.get_watcher_data();\n             assert!(data.close_cb.is_none());\n             data.close_cb = Some(cb);\n         }\n \n-        unsafe { uvll::close(this.native_handle(), close_cb); }\n+        unsafe { uvll::close(self.native_handle(), close_cb); }\n \n         extern fn close_cb(handle: *uvll::uv_handle_t) {\n             let mut h: Handle = NativeHandle::from_native_handle(handle);"}, {"sha": "8ea3e2ddcc67a8c0205fb4d2617f063bdae6a756", "filename": "src/librustuv/uvio.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e203f30bc743ff3de271d8db80acd21991e903df/src%2Flibrustuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e203f30bc743ff3de271d8db80acd21991e903df/src%2Flibrustuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvio.rs?ref=e203f30bc743ff3de271d8db80acd21991e903df", "patch": "@@ -122,10 +122,9 @@ trait HomingIO {\n         a // return the result of the IO\n     }\n \n-    fn home_for_io_consume<A>(self, io: &fn(Self) -> A) -> A {\n-        let mut this = self;\n-        let home = this.go_to_IO_home();\n-        let a = io(this); // do IO\n+    fn home_for_io_consume<A>(mut self, io: &fn(Self) -> A) -> A {\n+        let home = self.go_to_IO_home();\n+        let a = io(self); // do IO\n         HomingIO::restore_original_home(None::<Self>, home);\n         a // return the result of the IO\n     }\n@@ -239,7 +238,7 @@ impl EventLoop for UvEventLoop {\n     }\n }\n \n-#[cfg(not(stage0), not(test))]\n+#[cfg(not(test))]\n #[lang = \"event_loop_factory\"]\n pub extern \"C\" fn new_loop() -> ~EventLoop {\n     ~UvEventLoop::new() as ~EventLoop"}, {"sha": "a7a5b0084a275681e4271659f6d68b6e0e577270", "filename": "src/libstd/rt/crate_map.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e203f30bc743ff3de271d8db80acd21991e903df/src%2Flibstd%2Frt%2Fcrate_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e203f30bc743ff3de271d8db80acd21991e903df/src%2Flibstd%2Frt%2Fcrate_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcrate_map.rs?ref=e203f30bc743ff3de271d8db80acd21991e903df", "patch": "@@ -12,7 +12,6 @@ use container::MutableSet;\n use hashmap::HashSet;\n use option::{Some, None, Option};\n use vec::ImmutableVector;\n-#[cfg(not(stage0))]\n use rt::rtio::EventLoop;\n \n // Need to tell the linker on OS X to not barf on undefined symbols\n@@ -27,14 +26,6 @@ pub struct ModEntry<'self> {\n     log_level: *mut u32\n }\n \n-#[cfg(stage0)]\n-pub struct CrateMap<'self> {\n-    version: i32,\n-    entries: &'self [ModEntry<'self>],\n-    children: &'self [&'self CrateMap<'self>]\n-}\n-\n-#[cfg(not(stage0))]\n pub struct CrateMap<'self> {\n     version: i32,\n     entries: &'self [ModEntry<'self>],\n@@ -45,12 +36,6 @@ pub struct CrateMap<'self> {\n #[cfg(not(windows))]\n pub fn get_crate_map() -> Option<&'static CrateMap<'static>> {\n     extern {\n-        #[cfg(stage0)]\n-        #[weak_linkage]\n-        #[link_name = \"_rust_crate_map_toplevel\"]\n-        static CRATE_MAP: CrateMap<'static>;\n-\n-        #[cfg(not(stage0))]\n         #[crate_map]\n         static CRATE_MAP: CrateMap<'static>;\n     }"}, {"sha": "a247b4afb80caf692885fbf4d018314c2c14464a", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e203f30bc743ff3de271d8db80acd21991e903df/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e203f30bc743ff3de271d8db80acd21991e903df/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=e203f30bc743ff3de271d8db80acd21991e903df", "patch": "@@ -121,10 +121,6 @@ pub mod io;\n /// The EventLoop and internal synchronous I/O interface.\n pub mod rtio;\n \n-/// libuv and default rtio implementation.\n-#[cfg(stage0)]\n-pub mod uv;\n-\n /// The Local trait for types that are accessible via thread-local\n /// or task-local storage.\n pub mod local;\n@@ -463,13 +459,6 @@ pub fn in_green_task_context() -> bool {\n     }\n }\n \n-#[cfg(stage0)]\n-pub fn new_event_loop() -> ~rtio::EventLoop {\n-    use rt::uv::uvio::UvEventLoop;\n-    ~UvEventLoop::new() as ~rtio::EventLoop\n-}\n-\n-#[cfg(not(stage0))]\n pub fn new_event_loop() -> ~rtio::EventLoop {\n     #[fixed_stack_segment]; #[allow(cstack)];\n "}, {"sha": "a1593d5c8db73efa44583ae751549bf40101f59c", "filename": "src/libstd/rt/uv/addrinfo.rs", "status": "removed", "additions": 0, "deletions": 276, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/886819cca1208210cb73892f8fe4b7b9140068dc/src%2Flibstd%2Frt%2Fuv%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886819cca1208210cb73892f8fe4b7b9140068dc/src%2Flibstd%2Frt%2Fuv%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Faddrinfo.rs?ref=886819cca1208210cb73892f8fe4b7b9140068dc", "patch": "@@ -1,276 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use cast::transmute;\n-use cell::Cell;\n-use c_str::ToCStr;\n-use libc::{c_int, c_void};\n-use option::{Option, Some, None};\n-use ptr::null;\n-use rt::uv::uvll;\n-use rt::uv::uvll::UV_GETADDRINFO;\n-use rt::uv::{Loop, UvError, NativeHandle};\n-use rt::uv::status_to_maybe_uv_error;\n-use rt::uv::net;\n-use ai = rt::io::net::addrinfo;\n-\n-type GetAddrInfoCallback = ~fn(GetAddrInfoRequest, &net::UvAddrInfo, Option<UvError>);\n-\n-pub struct GetAddrInfoRequest(*uvll::uv_getaddrinfo_t);\n-\n-pub struct RequestData {\n-    priv getaddrinfo_cb: Option<GetAddrInfoCallback>,\n-}\n-\n-impl GetAddrInfoRequest {\n-    pub fn new() -> GetAddrInfoRequest {\n-        let req = unsafe { uvll::malloc_req(UV_GETADDRINFO) };\n-        assert!(req.is_not_null());\n-        let mut req: GetAddrInfoRequest = NativeHandle::from_native_handle(req);\n-        req.install_req_data();\n-        return req;\n-    }\n-\n-    pub fn getaddrinfo(&mut self, loop_: &Loop, node: Option<&str>,\n-                       service: Option<&str>, hints: Option<ai::Hint>,\n-                       cb: GetAddrInfoCallback) {\n-\n-        assert!(node.is_some() || service.is_some());\n-\n-        let (c_node, c_node_ptr) = match node {\n-            Some(n) => {\n-                let c_node = n.to_c_str();\n-                let c_node_ptr = c_node.with_ref(|r| r);\n-                (Some(c_node), c_node_ptr)\n-            }\n-            None => (None, null())\n-        };\n-\n-        let (c_service, c_service_ptr) = match service {\n-            Some(s) => {\n-                let c_service = s.to_c_str();\n-                let c_service_ptr = c_service.with_ref(|r| r);\n-                (Some(c_service), c_service_ptr)\n-            }\n-            None => (None, null())\n-        };\n-\n-        let cb = Cell::new(cb);\n-        let wrapper_cb: GetAddrInfoCallback = |req, addrinfo, err| {\n-            // Capture some heap values that need to stay alive for the\n-            // getaddrinfo call\n-            let _ = &c_node;\n-            let _ = &c_service;\n-\n-            let cb = cb.take();\n-            cb(req, addrinfo, err)\n-        };\n-\n-        let hint = hints.map(|hint| {\n-            let mut flags = 0;\n-            do each_ai_flag |cval, aival| {\n-                if hint.flags & (aival as uint) != 0 {\n-                    flags |= cval as i32;\n-                }\n-            }\n-            /* XXX: do we really want to support these?\n-            let socktype = match hint.socktype {\n-                Some(ai::Stream) => uvll::rust_SOCK_STREAM(),\n-                Some(ai::Datagram) => uvll::rust_SOCK_DGRAM(),\n-                Some(ai::Raw) => uvll::rust_SOCK_RAW(),\n-                None => 0,\n-            };\n-            let protocol = match hint.protocol {\n-                Some(ai::UDP) => uvll::rust_IPPROTO_UDP(),\n-                Some(ai::TCP) => uvll::rust_IPPROTO_TCP(),\n-                _ => 0,\n-            };\n-            */\n-            let socktype = 0;\n-            let protocol = 0;\n-\n-            uvll::addrinfo {\n-                ai_flags: flags,\n-                ai_family: hint.family as c_int,\n-                ai_socktype: socktype,\n-                ai_protocol: protocol,\n-                ai_addrlen: 0,\n-                ai_canonname: null(),\n-                ai_addr: null(),\n-                ai_next: null(),\n-            }\n-        });\n-        let hint_ptr = hint.as_ref().map_default(null(), |x| x as *uvll::addrinfo);\n-\n-        self.get_req_data().getaddrinfo_cb = Some(wrapper_cb);\n-\n-        unsafe {\n-            assert!(0 == uvll::getaddrinfo(loop_.native_handle(),\n-                                           self.native_handle(),\n-                                           getaddrinfo_cb,\n-                                           c_node_ptr,\n-                                           c_service_ptr,\n-                                           hint_ptr));\n-        }\n-\n-        extern \"C\" fn getaddrinfo_cb(req: *uvll::uv_getaddrinfo_t,\n-                                     status: c_int,\n-                                     res: *uvll::addrinfo) {\n-            let mut req: GetAddrInfoRequest = NativeHandle::from_native_handle(req);\n-            let err = status_to_maybe_uv_error(status);\n-            let addrinfo = net::UvAddrInfo(res);\n-            let data = req.get_req_data();\n-            (*data.getaddrinfo_cb.get_ref())(req, &addrinfo, err);\n-            unsafe {\n-                uvll::freeaddrinfo(res);\n-            }\n-        }\n-    }\n-\n-    fn get_loop(&self) -> Loop {\n-        unsafe {\n-            Loop {\n-                handle: uvll::get_loop_from_fs_req(self.native_handle())\n-            }\n-        }\n-    }\n-\n-    fn install_req_data(&mut self) {\n-        let req = self.native_handle() as *uvll::uv_getaddrinfo_t;\n-        let data = ~RequestData {\n-            getaddrinfo_cb: None\n-        };\n-        unsafe {\n-            let data = transmute::<~RequestData, *c_void>(data);\n-            uvll::set_data_for_req(req, data);\n-        }\n-    }\n-\n-    fn get_req_data<'r>(&'r mut self) -> &'r mut RequestData {\n-        unsafe {\n-            let data = uvll::get_data_for_req(self.native_handle());\n-            let data = transmute::<&*c_void, &mut ~RequestData>(&data);\n-            return &mut **data;\n-        }\n-    }\n-\n-    fn delete(self) {\n-        unsafe {\n-            let data = uvll::get_data_for_req(self.native_handle());\n-            let _data = transmute::<*c_void, ~RequestData>(data);\n-            uvll::set_data_for_req(self.native_handle(), null::<()>());\n-            uvll::free_req(self.native_handle());\n-        }\n-    }\n-}\n-\n-fn each_ai_flag(_f: &fn(c_int, ai::Flag)) {\n-    /* XXX: do we really want to support these?\n-    unsafe {\n-        f(uvll::rust_AI_ADDRCONFIG(), ai::AddrConfig);\n-        f(uvll::rust_AI_ALL(), ai::All);\n-        f(uvll::rust_AI_CANONNAME(), ai::CanonName);\n-        f(uvll::rust_AI_NUMERICHOST(), ai::NumericHost);\n-        f(uvll::rust_AI_NUMERICSERV(), ai::NumericServ);\n-        f(uvll::rust_AI_PASSIVE(), ai::Passive);\n-        f(uvll::rust_AI_V4MAPPED(), ai::V4Mapped);\n-    }\n-    */\n-}\n-\n-// Traverse the addrinfo linked list, producing a vector of Rust socket addresses\n-pub fn accum_addrinfo(addr: &net::UvAddrInfo) -> ~[ai::Info] {\n-    unsafe {\n-        let &net::UvAddrInfo(addr) = addr;\n-        let mut addr = addr;\n-\n-        let mut addrs = ~[];\n-        loop {\n-            let uvaddr = net::sockaddr_to_UvSocketAddr((*addr).ai_addr);\n-            let rustaddr = net::uv_socket_addr_to_socket_addr(uvaddr);\n-\n-            let mut flags = 0;\n-            do each_ai_flag |cval, aival| {\n-                if (*addr).ai_flags & cval != 0 {\n-                    flags |= aival as uint;\n-                }\n-            }\n-\n-            /* XXX: do we really want to support these\n-            let protocol = match (*addr).ai_protocol {\n-                p if p == uvll::rust_IPPROTO_UDP() => Some(ai::UDP),\n-                p if p == uvll::rust_IPPROTO_TCP() => Some(ai::TCP),\n-                _ => None,\n-            };\n-            let socktype = match (*addr).ai_socktype {\n-                p if p == uvll::rust_SOCK_STREAM() => Some(ai::Stream),\n-                p if p == uvll::rust_SOCK_DGRAM() => Some(ai::Datagram),\n-                p if p == uvll::rust_SOCK_RAW() => Some(ai::Raw),\n-                _ => None,\n-            };\n-            */\n-            let protocol = None;\n-            let socktype = None;\n-\n-            addrs.push(ai::Info {\n-                address: rustaddr,\n-                family: (*addr).ai_family as uint,\n-                socktype: socktype,\n-                protocol: protocol,\n-                flags: flags,\n-            });\n-            if (*addr).ai_next.is_not_null() {\n-                addr = (*addr).ai_next;\n-            } else {\n-                break;\n-            }\n-        }\n-\n-        return addrs;\n-    }\n-}\n-\n-impl NativeHandle<*uvll::uv_getaddrinfo_t> for GetAddrInfoRequest {\n-    fn from_native_handle(handle: *uvll::uv_getaddrinfo_t) -> GetAddrInfoRequest {\n-        GetAddrInfoRequest(handle)\n-    }\n-    fn native_handle(&self) -> *uvll::uv_getaddrinfo_t {\n-        match self { &GetAddrInfoRequest(ptr) => ptr }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use option::{Some, None};\n-    use rt::uv::Loop;\n-    use rt::io::net::ip::{SocketAddr, Ipv4Addr};\n-    use super::*;\n-\n-    #[test]\n-    fn getaddrinfo_test() {\n-        let mut loop_ = Loop::new();\n-        let mut req = GetAddrInfoRequest::new();\n-        do req.getaddrinfo(&loop_, Some(\"localhost\"), None, None) |_, addrinfo, _| {\n-            let sockaddrs = accum_addrinfo(addrinfo);\n-            let mut found_local = false;\n-            let local_addr = &SocketAddr {\n-                ip: Ipv4Addr(127, 0, 0, 1),\n-                port: 0\n-            };\n-            for addr in sockaddrs.iter() {\n-                found_local = found_local || addr.address == *local_addr;\n-            }\n-            assert!(found_local);\n-        }\n-        loop_.run();\n-        loop_.close();\n-        req.delete();\n-    }\n-}"}, {"sha": "108aef43c3c9ab8c2ef57351cf2124eb19583181", "filename": "src/libstd/rt/uv/async.rs", "status": "removed", "additions": 0, "deletions": 85, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/886819cca1208210cb73892f8fe4b7b9140068dc/src%2Flibstd%2Frt%2Fuv%2Fasync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886819cca1208210cb73892f8fe4b7b9140068dc/src%2Flibstd%2Frt%2Fuv%2Fasync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fasync.rs?ref=886819cca1208210cb73892f8fe4b7b9140068dc", "patch": "@@ -1,85 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use libc::c_int;\n-use option::Some;\n-use rt::uv::uvll;\n-use rt::uv::uvll::UV_ASYNC;\n-use rt::uv::{Watcher, Loop, NativeHandle, AsyncCallback};\n-use rt::uv::WatcherInterop;\n-use rt::uv::status_to_maybe_uv_error;\n-\n-pub struct AsyncWatcher(*uvll::uv_async_t);\n-impl Watcher for AsyncWatcher { }\n-\n-impl AsyncWatcher {\n-    pub fn new(loop_: &mut Loop, cb: AsyncCallback) -> AsyncWatcher {\n-        unsafe {\n-            let handle = uvll::malloc_handle(UV_ASYNC);\n-            assert!(handle.is_not_null());\n-            let mut watcher: AsyncWatcher = NativeHandle::from_native_handle(handle);\n-            watcher.install_watcher_data();\n-            let data = watcher.get_watcher_data();\n-            data.async_cb = Some(cb);\n-            assert_eq!(0, uvll::async_init(loop_.native_handle(), handle, async_cb));\n-            return watcher;\n-        }\n-\n-        extern fn async_cb(handle: *uvll::uv_async_t, status: c_int) {\n-            let mut watcher: AsyncWatcher = NativeHandle::from_native_handle(handle);\n-            let status = status_to_maybe_uv_error(status);\n-            let data = watcher.get_watcher_data();\n-            let cb = data.async_cb.get_ref();\n-            (*cb)(watcher, status);\n-        }\n-    }\n-\n-    pub fn send(&mut self) {\n-        unsafe {\n-            let handle = self.native_handle();\n-            uvll::async_send(handle);\n-        }\n-    }\n-}\n-\n-impl NativeHandle<*uvll::uv_async_t> for AsyncWatcher {\n-    fn from_native_handle(handle: *uvll::uv_async_t) -> AsyncWatcher {\n-        AsyncWatcher(handle)\n-    }\n-    fn native_handle(&self) -> *uvll::uv_async_t {\n-        match self { &AsyncWatcher(ptr) => ptr }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-\n-    use super::*;\n-    use rt::uv::Loop;\n-    use unstable::run_in_bare_thread;\n-    use rt::thread::Thread;\n-    use cell::Cell;\n-\n-    #[test]\n-    fn smoke_test() {\n-        do run_in_bare_thread {\n-            let mut loop_ = Loop::new();\n-            let watcher = AsyncWatcher::new(&mut loop_, |w, _| w.close(||()) );\n-            let watcher_cell = Cell::new(watcher);\n-            let thread = do Thread::start {\n-                let mut watcher = watcher_cell.take();\n-                watcher.send();\n-            };\n-            loop_.run();\n-            loop_.close();\n-            thread.join();\n-        }\n-    }\n-}"}, {"sha": "d2ca15959b025990942f81fef6da567aa0a117e3", "filename": "src/libstd/rt/uv/file.rs", "status": "removed", "additions": 0, "deletions": 648, "changes": 648, "blob_url": "https://github.com/rust-lang/rust/blob/886819cca1208210cb73892f8fe4b7b9140068dc/src%2Flibstd%2Frt%2Fuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886819cca1208210cb73892f8fe4b7b9140068dc/src%2Flibstd%2Frt%2Fuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Ffile.rs?ref=886819cca1208210cb73892f8fe4b7b9140068dc", "patch": "@@ -1,648 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use prelude::*;\n-use ptr::null;\n-use c_str;\n-use c_str::CString;\n-use libc::c_void;\n-use rt::uv::{Request, NativeHandle, Loop, FsCallback, Buf,\n-             status_to_maybe_uv_error, UvError};\n-use rt::uv::uvll;\n-use rt::uv::uvll::*;\n-use cast::transmute;\n-use libc;\n-use libc::{c_int};\n-use option::{None, Some, Option};\n-\n-pub struct FsRequest(*uvll::uv_fs_t);\n-impl Request for FsRequest {}\n-\n-pub struct RequestData {\n-    priv complete_cb: Option<FsCallback>\n-}\n-\n-impl FsRequest {\n-    pub fn new() -> FsRequest {\n-        let fs_req = unsafe { malloc_req(UV_FS) };\n-        assert!(fs_req.is_not_null());\n-        let fs_req: FsRequest = NativeHandle::from_native_handle(fs_req);\n-        fs_req\n-    }\n-\n-    pub fn open(self, loop_: &Loop, path: &CString, flags: int, mode: int,\n-                cb: FsCallback) {\n-        let complete_cb_ptr = {\n-            let mut me = self;\n-            me.req_boilerplate(Some(cb))\n-        };\n-        let ret = path.with_ref(|p| unsafe {\n-            uvll::fs_open(loop_.native_handle(),\n-                          self.native_handle(), p, flags, mode, complete_cb_ptr)\n-        });\n-        assert_eq!(ret, 0);\n-    }\n-\n-    pub fn open_sync(self, loop_: &Loop, path: &CString,\n-                     flags: int, mode: int) -> Result<c_int, UvError> {\n-        let complete_cb_ptr = {\n-            let mut me = self;\n-            me.req_boilerplate(None)\n-        };\n-        let result = path.with_ref(|p| unsafe {\n-            uvll::fs_open(loop_.native_handle(),\n-                    self.native_handle(), p, flags, mode, complete_cb_ptr)\n-        });\n-        self.sync_cleanup(result)\n-    }\n-\n-    pub fn unlink(self, loop_: &Loop, path: &CString, cb: FsCallback) {\n-        let complete_cb_ptr = {\n-            let mut me = self;\n-            me.req_boilerplate(Some(cb))\n-        };\n-        let ret = path.with_ref(|p| unsafe {\n-            uvll::fs_unlink(loop_.native_handle(),\n-                          self.native_handle(), p, complete_cb_ptr)\n-        });\n-        assert_eq!(ret, 0);\n-    }\n-\n-    pub fn unlink_sync(self, loop_: &Loop, path: &CString)\n-      -> Result<c_int, UvError> {\n-        let complete_cb_ptr = {\n-            let mut me = self;\n-            me.req_boilerplate(None)\n-        };\n-        let result = path.with_ref(|p| unsafe {\n-            uvll::fs_unlink(loop_.native_handle(),\n-                          self.native_handle(), p, complete_cb_ptr)\n-        });\n-        self.sync_cleanup(result)\n-    }\n-\n-    pub fn stat(self, loop_: &Loop, path: &CString, cb: FsCallback) {\n-        let complete_cb_ptr = {\n-            let mut me = self;\n-            me.req_boilerplate(Some(cb))\n-        };\n-        let ret = path.with_ref(|p| unsafe {\n-            uvll::fs_stat(loop_.native_handle(),\n-                          self.native_handle(), p, complete_cb_ptr)\n-        });\n-        assert_eq!(ret, 0);\n-    }\n-\n-    pub fn write(self, loop_: &Loop, fd: c_int, buf: Buf, offset: i64, cb: FsCallback) {\n-        let complete_cb_ptr = {\n-            let mut me = self;\n-            me.req_boilerplate(Some(cb))\n-        };\n-        let base_ptr = buf.base as *c_void;\n-        let len = buf.len as uint;\n-        let ret = unsafe {\n-            uvll::fs_write(loop_.native_handle(), self.native_handle(),\n-                           fd, base_ptr,\n-                           len, offset, complete_cb_ptr)\n-        };\n-        assert_eq!(ret, 0);\n-    }\n-    pub fn write_sync(self, loop_: &Loop, fd: c_int, buf: Buf, offset: i64)\n-          -> Result<c_int, UvError> {\n-        let complete_cb_ptr = {\n-            let mut me = self;\n-            me.req_boilerplate(None)\n-        };\n-        let base_ptr = buf.base as *c_void;\n-        let len = buf.len as uint;\n-        let result = unsafe {\n-            uvll::fs_write(loop_.native_handle(), self.native_handle(),\n-                           fd, base_ptr,\n-                           len, offset, complete_cb_ptr)\n-        };\n-        self.sync_cleanup(result)\n-    }\n-\n-    pub fn read(self, loop_: &Loop, fd: c_int, buf: Buf, offset: i64, cb: FsCallback) {\n-        let complete_cb_ptr = {\n-            let mut me = self;\n-            me.req_boilerplate(Some(cb))\n-        };\n-        let buf_ptr = buf.base as *c_void;\n-        let len = buf.len as uint;\n-        let ret = unsafe {\n-            uvll::fs_read(loop_.native_handle(), self.native_handle(),\n-                           fd, buf_ptr,\n-                           len, offset, complete_cb_ptr)\n-        };\n-        assert_eq!(ret, 0);\n-    }\n-    pub fn read_sync(self, loop_: &Loop, fd: c_int, buf: Buf, offset: i64)\n-          -> Result<c_int, UvError> {\n-        let complete_cb_ptr = {\n-            let mut me = self;\n-            me.req_boilerplate(None)\n-        };\n-        let buf_ptr = buf.base as *c_void;\n-        let len = buf.len as uint;\n-        let result = unsafe {\n-            uvll::fs_read(loop_.native_handle(), self.native_handle(),\n-                           fd, buf_ptr,\n-                           len, offset, complete_cb_ptr)\n-        };\n-        self.sync_cleanup(result)\n-    }\n-\n-    pub fn close(self, loop_: &Loop, fd: c_int, cb: FsCallback) {\n-        let complete_cb_ptr = {\n-            let mut me = self;\n-            me.req_boilerplate(Some(cb))\n-        };\n-        let ret = unsafe {\n-            uvll::fs_close(loop_.native_handle(), self.native_handle(),\n-                           fd, complete_cb_ptr)\n-        };\n-        assert_eq!(ret, 0);\n-    }\n-    pub fn close_sync(self, loop_: &Loop, fd: c_int) -> Result<c_int, UvError> {\n-        let complete_cb_ptr = {\n-            let mut me = self;\n-            me.req_boilerplate(None)\n-        };\n-        let result = unsafe {\n-            uvll::fs_close(loop_.native_handle(), self.native_handle(),\n-                           fd, complete_cb_ptr)\n-        };\n-        self.sync_cleanup(result)\n-    }\n-\n-    pub fn mkdir(self, loop_: &Loop, path: &CString, mode: int, cb: FsCallback) {\n-        let complete_cb_ptr = {\n-            let mut me = self;\n-            me.req_boilerplate(Some(cb))\n-        };\n-        let ret = path.with_ref(|p| unsafe {\n-            uvll::fs_mkdir(loop_.native_handle(),\n-                           self.native_handle(), p, mode, complete_cb_ptr)\n-        });\n-        assert_eq!(ret, 0);\n-    }\n-\n-    pub fn rmdir(self, loop_: &Loop, path: &CString, cb: FsCallback) {\n-        let complete_cb_ptr = {\n-            let mut me = self;\n-            me.req_boilerplate(Some(cb))\n-        };\n-        let ret = path.with_ref(|p| unsafe {\n-            uvll::fs_rmdir(loop_.native_handle(),\n-                           self.native_handle(), p, complete_cb_ptr)\n-        });\n-        assert_eq!(ret, 0);\n-    }\n-\n-    pub fn readdir(self, loop_: &Loop, path: &CString,\n-                   flags: c_int, cb: FsCallback) {\n-        let complete_cb_ptr = {\n-            let mut me = self;\n-            me.req_boilerplate(Some(cb))\n-        };\n-        let ret = path.with_ref(|p| unsafe {\n-            uvll::fs_readdir(loop_.native_handle(),\n-                             self.native_handle(), p, flags, complete_cb_ptr)\n-        });\n-        assert_eq!(ret, 0);\n-    }\n-\n-    // accessors/utility funcs\n-    fn sync_cleanup(self, result: c_int)\n-          -> Result<c_int, UvError> {\n-        self.cleanup_and_delete();\n-        match status_to_maybe_uv_error(result as i32) {\n-            Some(err) => Err(err),\n-            None => Ok(result)\n-        }\n-    }\n-    fn req_boilerplate(&mut self, cb: Option<FsCallback>) -> *u8 {\n-        let result = match cb {\n-            Some(_) => {\n-                compl_cb as *u8\n-            },\n-            None => 0 as *u8\n-        };\n-        self.install_req_data(cb);\n-        result\n-    }\n-    pub fn install_req_data(&mut self, cb: Option<FsCallback>) {\n-        let fs_req = (self.native_handle()) as *uvll::uv_write_t;\n-        let data = ~RequestData {\n-            complete_cb: cb\n-        };\n-        unsafe {\n-            let data = transmute::<~RequestData, *c_void>(data);\n-            uvll::set_data_for_req(fs_req, data);\n-        }\n-    }\n-\n-    fn get_req_data<'r>(&'r mut self) -> &'r mut RequestData {\n-        unsafe {\n-            let data = uvll::get_data_for_req((self.native_handle()));\n-            let data = transmute::<&*c_void, &mut ~RequestData>(&data);\n-            &mut **data\n-        }\n-    }\n-\n-    pub fn get_result(&mut self) -> c_int {\n-        unsafe {\n-            uvll::get_result_from_fs_req(self.native_handle())\n-        }\n-    }\n-\n-    pub fn get_loop(&self) -> Loop {\n-        unsafe { Loop{handle:uvll::get_loop_from_fs_req(self.native_handle())} }\n-    }\n-\n-    pub fn get_stat(&self) -> uv_stat_t {\n-        let stat = uv_stat_t::new();\n-        unsafe { uvll::populate_stat(self.native_handle(), &stat); }\n-        stat\n-    }\n-\n-    pub fn get_ptr(&self) -> *libc::c_void {\n-        unsafe {\n-            uvll::get_ptr_from_fs_req(self.native_handle())\n-        }\n-    }\n-\n-    pub fn each_path(&mut self, f: &fn(&CString)) {\n-        let ptr = self.get_ptr();\n-        match self.get_result() {\n-            n if (n <= 0) => {}\n-            n => {\n-                let n_len = n as uint;\n-                // we pass in the len that uv tells us is there\n-                // for the entries and we don't continue past that..\n-                // it appears that sometimes the multistring isn't\n-                // correctly delimited and we stray into garbage memory?\n-                // in any case, passing Some(n_len) fixes it and ensures\n-                // good results\n-                unsafe {\n-                    c_str::from_c_multistring(ptr as *libc::c_char,\n-                                              Some(n_len), f);\n-                }\n-            }\n-        }\n-    }\n-\n-    fn cleanup_and_delete(self) {\n-        unsafe {\n-            let data = uvll::get_data_for_req(self.native_handle());\n-            let _data = transmute::<*c_void, ~RequestData>(data);\n-            uvll::set_data_for_req(self.native_handle(), null::<()>());\n-            uvll::fs_req_cleanup(self.native_handle());\n-            free_req(self.native_handle() as *c_void)\n-        }\n-    }\n-}\n-\n-impl NativeHandle<*uvll::uv_fs_t> for FsRequest {\n-    fn from_native_handle(handle: *uvll:: uv_fs_t) -> FsRequest {\n-        FsRequest(handle)\n-    }\n-    fn native_handle(&self) -> *uvll::uv_fs_t {\n-        match self { &FsRequest(ptr) => ptr }\n-    }\n-}\n-\n-fn sync_cleanup(result: int)\n-    -> Result<int, UvError> {\n-    match status_to_maybe_uv_error(result as i32) {\n-        Some(err) => Err(err),\n-        None => Ok(result)\n-    }\n-}\n-\n-extern fn compl_cb(req: *uv_fs_t) {\n-    let mut req: FsRequest = NativeHandle::from_native_handle(req);\n-    // pull the user cb out of the req data\n-    let cb = {\n-        let data = req.get_req_data();\n-        assert!(data.complete_cb.is_some());\n-        // option dance, option dance. oooooh yeah.\n-        data.complete_cb.take_unwrap()\n-    };\n-    // in uv_fs_open calls, the result will be the fd in the\n-    // case of success, otherwise it's -1 indicating an error\n-    let result = req.get_result();\n-    let status = status_to_maybe_uv_error(result);\n-    // we have a req and status, call the user cb..\n-    // only giving the user a ref to the FsRequest, as we\n-    // have to clean it up, afterwards (and they aren't really\n-    // reusable, anyways\n-    cb(&mut req, status);\n-    // clean up the req (and its data!) after calling the user cb\n-    req.cleanup_and_delete();\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use super::*;\n-    //use rt::test::*;\n-    use libc::{STDOUT_FILENO};\n-    use vec;\n-    use str;\n-    use unstable::run_in_bare_thread;\n-    use rt::uv::{Loop, Buf, slice_to_uv_buf};\n-    use libc::{O_CREAT, O_RDWR, O_RDONLY, S_IWUSR, S_IRUSR};\n-\n-    #[test]\n-    fn file_test_full_simple() {\n-        do run_in_bare_thread {\n-            let mut loop_ = Loop::new();\n-            let create_flags = O_RDWR | O_CREAT;\n-            let read_flags = O_RDONLY;\n-            // 0644 BZZT! WRONG! 0600! See below.\n-            let mode = S_IWUSR |S_IRUSR;\n-                // these aren't defined in std::libc :(\n-                //map_mode(S_IRGRP) |\n-                //map_mode(S_IROTH);\n-            let path_str = \"./tmp/file_full_simple.txt\";\n-            let write_val = \"hello\".as_bytes().to_owned();\n-            let write_buf  = slice_to_uv_buf(write_val);\n-            let write_buf_ptr: *Buf = &write_buf;\n-            let read_buf_len = 1028;\n-            let read_mem = vec::from_elem(read_buf_len, 0u8);\n-            let read_buf = slice_to_uv_buf(read_mem);\n-            let read_buf_ptr: *Buf = &read_buf;\n-            let open_req = FsRequest::new();\n-            do open_req.open(&loop_, &path_str.to_c_str(), create_flags as int,\n-                             mode as int) |req, uverr| {\n-                assert!(uverr.is_none());\n-                let fd = req.get_result();\n-                let buf = unsafe { *write_buf_ptr };\n-                let write_req = FsRequest::new();\n-                do write_req.write(&req.get_loop(), fd, buf, -1) |req, uverr| {\n-                    let close_req = FsRequest::new();\n-                    do close_req.close(&req.get_loop(), fd) |req, _| {\n-                        assert!(uverr.is_none());\n-                        let loop_ = req.get_loop();\n-                        let open_req = FsRequest::new();\n-                        do open_req.open(&loop_, &path_str.to_c_str(),\n-                                         read_flags as int,0) |req, uverr| {\n-                            assert!(uverr.is_none());\n-                            let loop_ = req.get_loop();\n-                            let fd = req.get_result();\n-                            let read_buf = unsafe { *read_buf_ptr };\n-                            let read_req = FsRequest::new();\n-                            do read_req.read(&loop_, fd, read_buf, 0) |req, uverr| {\n-                                assert!(uverr.is_none());\n-                                let loop_ = req.get_loop();\n-                                // we know nread >=0 because uverr is none..\n-                                let nread = req.get_result() as uint;\n-                                // nread == 0 would be EOF\n-                                if nread > 0 {\n-                                    let read_str = unsafe {\n-                                        let read_buf = *read_buf_ptr;\n-                                        str::from_utf8(\n-                                            vec::from_buf(\n-                                                read_buf.base, nread))\n-                                    };\n-                                    assert!(read_str == ~\"hello\");\n-                                    let close_req = FsRequest::new();\n-                                    do close_req.close(&loop_, fd) |req,uverr| {\n-                                        assert!(uverr.is_none());\n-                                        let loop_ = &req.get_loop();\n-                                        let unlink_req = FsRequest::new();\n-                                        do unlink_req.unlink(loop_,\n-                                                             &path_str.to_c_str())\n-                                        |_,uverr| {\n-                                            assert!(uverr.is_none());\n-                                        };\n-                                    };\n-                                };\n-                            };\n-                        };\n-                    };\n-                };\n-            };\n-            loop_.run();\n-            loop_.close();\n-        }\n-    }\n-\n-    #[test]\n-    fn file_test_full_simple_sync() {\n-        do run_in_bare_thread {\n-            // setup\n-            let mut loop_ = Loop::new();\n-            let create_flags = O_RDWR |\n-                O_CREAT;\n-            let read_flags = O_RDONLY;\n-            // 0644\n-            let mode = S_IWUSR |\n-                S_IRUSR;\n-                //S_IRGRP |\n-                //S_IROTH;\n-            let path_str = \"./tmp/file_full_simple_sync.txt\";\n-            let write_val = \"hello\".as_bytes().to_owned();\n-            let write_buf = slice_to_uv_buf(write_val);\n-            // open/create\n-            let open_req = FsRequest::new();\n-            let result = open_req.open_sync(&loop_, &path_str.to_c_str(),\n-                                            create_flags as int, mode as int);\n-            assert!(result.is_ok());\n-            let fd = result.unwrap();\n-            // write\n-            let write_req = FsRequest::new();\n-            let result = write_req.write_sync(&loop_, fd, write_buf, -1);\n-            assert!(result.is_ok());\n-            // close\n-            let close_req = FsRequest::new();\n-            let result = close_req.close_sync(&loop_, fd);\n-            assert!(result.is_ok());\n-            // re-open\n-            let open_req = FsRequest::new();\n-            let result = open_req.open_sync(&loop_, &path_str.to_c_str(),\n-                                                   read_flags as int,0);\n-            assert!(result.is_ok());\n-            let len = 1028;\n-            let fd = result.unwrap();\n-            // read\n-            let read_mem: ~[u8] = vec::from_elem(len, 0u8);\n-            let buf = slice_to_uv_buf(read_mem);\n-            let read_req = FsRequest::new();\n-            let result = read_req.read_sync(&loop_, fd, buf, 0);\n-            assert!(result.is_ok());\n-            let nread = result.unwrap();\n-            // nread == 0 would be EOF.. we know it's >= zero because otherwise\n-            // the above assert would fail\n-            if nread > 0 {\n-                let read_str = str::from_utf8(\n-                    read_mem.slice(0, nread as uint));\n-                assert!(read_str == ~\"hello\");\n-                // close\n-                let close_req = FsRequest::new();\n-                let result = close_req.close_sync(&loop_, fd);\n-                assert!(result.is_ok());\n-                // unlink\n-                let unlink_req = FsRequest::new();\n-                let result = unlink_req.unlink_sync(&loop_, &path_str.to_c_str());\n-                assert!(result.is_ok());\n-            } else { fail!(\"nread was 0.. wudn't expectin' that.\"); }\n-            loop_.close();\n-        }\n-    }\n-\n-    fn naive_print(loop_: &Loop, input: &str) {\n-        let write_val = input.as_bytes();\n-        let write_buf = slice_to_uv_buf(write_val);\n-        let write_req = FsRequest::new();\n-        write_req.write_sync(loop_, STDOUT_FILENO, write_buf, -1);\n-    }\n-\n-    #[test]\n-    fn file_test_write_to_stdout() {\n-        do run_in_bare_thread {\n-            let mut loop_ = Loop::new();\n-            naive_print(&loop_, \"zanzibar!\\n\");\n-            loop_.run();\n-            loop_.close();\n-        };\n-    }\n-    #[test]\n-    fn file_test_stat_simple() {\n-        do run_in_bare_thread {\n-            let mut loop_ = Loop::new();\n-            let path = \"./tmp/file_test_stat_simple.txt\";\n-            let create_flags = O_RDWR |\n-                O_CREAT;\n-            let mode = S_IWUSR |\n-                S_IRUSR;\n-            let write_val = \"hello\".as_bytes().to_owned();\n-            let write_buf  = slice_to_uv_buf(write_val);\n-            let write_buf_ptr: *Buf = &write_buf;\n-            let open_req = FsRequest::new();\n-            do open_req.open(&loop_, &path.to_c_str(), create_flags as int,\n-                             mode as int) |req, uverr| {\n-                assert!(uverr.is_none());\n-                let fd = req.get_result();\n-                let buf = unsafe { *write_buf_ptr };\n-                let write_req = FsRequest::new();\n-                do write_req.write(&req.get_loop(), fd, buf, 0) |req, uverr| {\n-                    assert!(uverr.is_none());\n-                    let loop_ = req.get_loop();\n-                    let stat_req = FsRequest::new();\n-                    do stat_req.stat(&loop_, &path.to_c_str()) |req, uverr| {\n-                        assert!(uverr.is_none());\n-                        let loop_ = req.get_loop();\n-                        let stat = req.get_stat();\n-                        let sz: uint = stat.st_size as uint;\n-                        assert!(sz > 0);\n-                        let close_req = FsRequest::new();\n-                        do close_req.close(&loop_, fd) |req, uverr| {\n-                            assert!(uverr.is_none());\n-                            let loop_ = req.get_loop();\n-                            let unlink_req = FsRequest::new();\n-                            do unlink_req.unlink(&loop_,\n-                                                 &path.to_c_str()) |req,uverr| {\n-                                assert!(uverr.is_none());\n-                                let loop_ = req.get_loop();\n-                                let stat_req = FsRequest::new();\n-                                do stat_req.stat(&loop_,\n-                                                 &path.to_c_str()) |_, uverr| {\n-                                    // should cause an error because the\n-                                    // file doesn't exist anymore\n-                                    assert!(uverr.is_some());\n-                                };\n-                            };\n-                        };\n-                    };\n-                };\n-            };\n-            loop_.run();\n-            loop_.close();\n-        }\n-    }\n-\n-    #[test]\n-    fn file_test_mk_rm_dir() {\n-        do run_in_bare_thread {\n-            let mut loop_ = Loop::new();\n-            let path = \"./tmp/mk_rm_dir\";\n-            let mode = S_IWUSR |\n-                S_IRUSR;\n-            let mkdir_req = FsRequest::new();\n-            do mkdir_req.mkdir(&loop_, &path.to_c_str(),\n-                               mode as int) |req,uverr| {\n-                assert!(uverr.is_none());\n-                let loop_ = req.get_loop();\n-                let stat_req = FsRequest::new();\n-                do stat_req.stat(&loop_, &path.to_c_str()) |req, uverr| {\n-                    assert!(uverr.is_none());\n-                    let loop_ = req.get_loop();\n-                    let stat = req.get_stat();\n-                    naive_print(&loop_, format!(\"{:?}\", stat));\n-                    assert!(stat.is_dir());\n-                    let rmdir_req = FsRequest::new();\n-                    do rmdir_req.rmdir(&loop_, &path.to_c_str()) |req,uverr| {\n-                        assert!(uverr.is_none());\n-                        let loop_ = req.get_loop();\n-                        let stat_req = FsRequest::new();\n-                        do stat_req.stat(&loop_, &path.to_c_str()) |_req, uverr| {\n-                            assert!(uverr.is_some());\n-                        }\n-                    }\n-                }\n-            }\n-            loop_.run();\n-            loop_.close();\n-        }\n-    }\n-    #[test]\n-    fn file_test_mkdir_chokes_on_double_create() {\n-        do run_in_bare_thread {\n-            let mut loop_ = Loop::new();\n-            let path = \"./tmp/double_create_dir\";\n-            let mode = S_IWUSR |\n-                S_IRUSR;\n-            let mkdir_req = FsRequest::new();\n-            do mkdir_req.mkdir(&loop_, &path.to_c_str(), mode as int) |req,uverr| {\n-                assert!(uverr.is_none());\n-                let loop_ = req.get_loop();\n-                let mkdir_req = FsRequest::new();\n-                do mkdir_req.mkdir(&loop_, &path.to_c_str(),\n-                                   mode as int) |req,uverr| {\n-                    assert!(uverr.is_some());\n-                    let loop_ = req.get_loop();\n-                    let _stat = req.get_stat();\n-                    let rmdir_req = FsRequest::new();\n-                    do rmdir_req.rmdir(&loop_, &path.to_c_str()) |req,uverr| {\n-                        assert!(uverr.is_none());\n-                        let _loop = req.get_loop();\n-                    }\n-                }\n-            }\n-            loop_.run();\n-            loop_.close();\n-        }\n-    }\n-    #[test]\n-    fn file_test_rmdir_chokes_on_nonexistant_path() {\n-        do run_in_bare_thread {\n-            let mut loop_ = Loop::new();\n-            let path = \"./tmp/never_existed_dir\";\n-            let rmdir_req = FsRequest::new();\n-            do rmdir_req.rmdir(&loop_, &path.to_c_str()) |_req, uverr| {\n-                assert!(uverr.is_some());\n-            }\n-            loop_.run();\n-            loop_.close();\n-        }\n-    }\n-}"}, {"sha": "40f0750b2d0742d1ab0b78787387ee1e1d2cccc2", "filename": "src/libstd/rt/uv/idle.rs", "status": "removed", "additions": 0, "deletions": 138, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/886819cca1208210cb73892f8fe4b7b9140068dc/src%2Flibstd%2Frt%2Fuv%2Fidle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886819cca1208210cb73892f8fe4b7b9140068dc/src%2Flibstd%2Frt%2Fuv%2Fidle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fidle.rs?ref=886819cca1208210cb73892f8fe4b7b9140068dc", "patch": "@@ -1,138 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use libc::c_int;\n-use option::Some;\n-use rt::uv::uvll;\n-use rt::uv::{Watcher, Loop, NativeHandle, IdleCallback};\n-use rt::uv::status_to_maybe_uv_error;\n-\n-pub struct IdleWatcher(*uvll::uv_idle_t);\n-impl Watcher for IdleWatcher { }\n-\n-impl IdleWatcher {\n-    pub fn new(loop_: &mut Loop) -> IdleWatcher {\n-        unsafe {\n-            let handle = uvll::malloc_handle(uvll::UV_IDLE);\n-            assert!(handle.is_not_null());\n-            assert_eq!(uvll::idle_init(loop_.native_handle(), handle), 0);\n-            let mut watcher: IdleWatcher = NativeHandle::from_native_handle(handle);\n-            watcher.install_watcher_data();\n-            return watcher\n-        }\n-    }\n-\n-    pub fn start(&mut self, cb: IdleCallback) {\n-        {\n-            let data = self.get_watcher_data();\n-            data.idle_cb = Some(cb);\n-        }\n-\n-        unsafe {\n-            assert_eq!(uvll::idle_start(self.native_handle(), idle_cb), 0)\n-        }\n-    }\n-\n-    pub fn restart(&mut self) {\n-        unsafe {\n-            assert!(self.get_watcher_data().idle_cb.is_some());\n-            assert_eq!(uvll::idle_start(self.native_handle(), idle_cb), 0)\n-        }\n-    }\n-\n-    pub fn stop(&mut self) {\n-        // NB: Not resetting the Rust idle_cb to None here because `stop` is\n-        // likely called from *within* the idle callback, causing a use after\n-        // free\n-\n-        unsafe {\n-            assert_eq!(uvll::idle_stop(self.native_handle()), 0);\n-        }\n-    }\n-}\n-\n-impl NativeHandle<*uvll::uv_idle_t> for IdleWatcher {\n-    fn from_native_handle(handle: *uvll::uv_idle_t) -> IdleWatcher {\n-        IdleWatcher(handle)\n-    }\n-    fn native_handle(&self) -> *uvll::uv_idle_t {\n-        match self { &IdleWatcher(ptr) => ptr }\n-    }\n-}\n-\n-extern fn idle_cb(handle: *uvll::uv_idle_t, status: c_int) {\n-    let mut idle_watcher: IdleWatcher = NativeHandle::from_native_handle(handle);\n-    let data = idle_watcher.get_watcher_data();\n-    let cb: &IdleCallback = data.idle_cb.get_ref();\n-    let status = status_to_maybe_uv_error(status);\n-    (*cb)(idle_watcher, status);\n-}\n-\n-#[cfg(test)]\n-mod test {\n-\n-    use rt::uv::Loop;\n-    use super::*;\n-    use unstable::run_in_bare_thread;\n-\n-    #[test]\n-    #[ignore(reason = \"valgrind - loop destroyed before watcher?\")]\n-    fn idle_new_then_close() {\n-        do run_in_bare_thread {\n-            let mut loop_ = Loop::new();\n-            let idle_watcher = { IdleWatcher::new(&mut loop_) };\n-            idle_watcher.close(||());\n-        }\n-    }\n-\n-    #[test]\n-    fn idle_smoke_test() {\n-        do run_in_bare_thread {\n-            let mut loop_ = Loop::new();\n-            let mut idle_watcher = { IdleWatcher::new(&mut loop_) };\n-            let mut count = 10;\n-            let count_ptr: *mut int = &mut count;\n-            do idle_watcher.start |idle_watcher, status| {\n-                let mut idle_watcher = idle_watcher;\n-                assert!(status.is_none());\n-                if unsafe { *count_ptr == 10 } {\n-                    idle_watcher.stop();\n-                    idle_watcher.close(||());\n-                } else {\n-                    unsafe { *count_ptr = *count_ptr + 1; }\n-                }\n-            }\n-            loop_.run();\n-            loop_.close();\n-            assert_eq!(count, 10);\n-        }\n-    }\n-\n-    #[test]\n-    fn idle_start_stop_start() {\n-        do run_in_bare_thread {\n-            let mut loop_ = Loop::new();\n-            let mut idle_watcher = { IdleWatcher::new(&mut loop_) };\n-            do idle_watcher.start |idle_watcher, status| {\n-                let mut idle_watcher = idle_watcher;\n-                assert!(status.is_none());\n-                idle_watcher.stop();\n-                do idle_watcher.start |idle_watcher, status| {\n-                    assert!(status.is_none());\n-                    let mut idle_watcher = idle_watcher;\n-                    idle_watcher.stop();\n-                    idle_watcher.close(||());\n-                }\n-            }\n-            loop_.run();\n-            loop_.close();\n-        }\n-    }\n-}"}, {"sha": "b0e2569a07633f5fe3ff3d5165b1875989f3dbbd", "filename": "src/libstd/rt/uv/mod.rs", "status": "removed", "additions": 0, "deletions": 416, "changes": 416, "blob_url": "https://github.com/rust-lang/rust/blob/886819cca1208210cb73892f8fe4b7b9140068dc/src%2Flibstd%2Frt%2Fuv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886819cca1208210cb73892f8fe4b7b9140068dc/src%2Flibstd%2Frt%2Fuv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fmod.rs?ref=886819cca1208210cb73892f8fe4b7b9140068dc", "patch": "@@ -1,416 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-\n-Bindings to libuv, along with the default implementation of `std::rt::rtio`.\n-\n-UV types consist of the event loop (Loop), Watchers, Requests and\n-Callbacks.\n-\n-Watchers and Requests encapsulate pointers to uv *handles*, which have\n-subtyping relationships with each other.  This subtyping is reflected\n-in the bindings with explicit or implicit coercions. For example, an\n-upcast from TcpWatcher to StreamWatcher is done with\n-`tcp_watcher.as_stream()`. In other cases a callback on a specific\n-type of watcher will be passed a watcher of a supertype.\n-\n-Currently all use of Request types (connect/write requests) are\n-encapsulated in the bindings and don't need to be dealt with by the\n-caller.\n-\n-# Safety note\n-\n-Due to the complex lifecycle of uv handles, as well as compiler bugs,\n-this module is not memory safe and requires explicit memory management,\n-via `close` and `delete` methods.\n-\n-*/\n-\n-use container::Container;\n-use option::*;\n-use str::raw::from_c_str;\n-use to_str::ToStr;\n-use ptr::RawPtr;\n-use vec;\n-use vec::ImmutableVector;\n-use ptr;\n-use str;\n-use libc::{c_void, c_int, size_t, malloc, free};\n-use cast::transmute;\n-use ptr::null;\n-use unstable::finally::Finally;\n-use rt::io::net::ip::SocketAddr;\n-use rt::io::signal::Signum;\n-\n-use rt::io::IoError;\n-\n-//#[cfg(test)] use unstable::run_in_bare_thread;\n-\n-pub use self::file::{FsRequest};\n-pub use self::net::{StreamWatcher, TcpWatcher, UdpWatcher};\n-pub use self::idle::IdleWatcher;\n-pub use self::timer::TimerWatcher;\n-pub use self::async::AsyncWatcher;\n-pub use self::process::Process;\n-pub use self::pipe::Pipe;\n-pub use self::signal::SignalWatcher;\n-\n-/// The implementation of `rtio` for libuv\n-pub mod uvio;\n-\n-/// C bindings to libuv\n-pub mod uvll;\n-\n-pub mod file;\n-pub mod net;\n-pub mod idle;\n-pub mod timer;\n-pub mod async;\n-pub mod addrinfo;\n-pub mod process;\n-pub mod pipe;\n-pub mod tty;\n-pub mod signal;\n-\n-/// XXX: Loop(*handle) is buggy with destructors. Normal structs\n-/// with dtors may not be destructured, but tuple structs can,\n-/// but the results are not correct.\n-pub struct Loop {\n-    priv handle: *uvll::uv_loop_t\n-}\n-\n-pub struct Handle(*uvll::uv_handle_t);\n-\n-impl Watcher for Handle {}\n-impl NativeHandle<*uvll::uv_handle_t> for Handle {\n-    fn from_native_handle(h: *uvll::uv_handle_t) -> Handle { Handle(h) }\n-    fn native_handle(&self) -> *uvll::uv_handle_t { **self }\n-}\n-\n-/// The trait implemented by uv 'watchers' (handles). Watchers are\n-/// non-owning wrappers around the uv handles and are not completely\n-/// safe - there may be multiple instances for a single underlying\n-/// handle.  Watchers are generally created, then `start`ed, `stop`ed\n-/// and `close`ed, but due to their complex life cycle may not be\n-/// entirely memory safe if used in unanticipated patterns.\n-pub trait Watcher { }\n-\n-pub trait Request { }\n-\n-/// A type that wraps a native handle\n-pub trait NativeHandle<T> {\n-    fn from_native_handle(T) -> Self;\n-    fn native_handle(&self) -> T;\n-}\n-\n-impl Loop {\n-    pub fn new() -> Loop {\n-        let handle = unsafe { uvll::loop_new() };\n-        assert!(handle.is_not_null());\n-        NativeHandle::from_native_handle(handle)\n-    }\n-\n-    pub fn run(&mut self) {\n-        unsafe { uvll::run(self.native_handle()) };\n-    }\n-\n-    pub fn close(&mut self) {\n-        unsafe { uvll::loop_delete(self.native_handle()) };\n-    }\n-}\n-\n-impl NativeHandle<*uvll::uv_loop_t> for Loop {\n-    fn from_native_handle(handle: *uvll::uv_loop_t) -> Loop {\n-        Loop { handle: handle }\n-    }\n-    fn native_handle(&self) -> *uvll::uv_loop_t {\n-        self.handle\n-    }\n-}\n-\n-// XXX: The uv alloc callback also has a *uv_handle_t arg\n-pub type AllocCallback = ~fn(uint) -> Buf;\n-pub type ReadCallback = ~fn(StreamWatcher, int, Buf, Option<UvError>);\n-pub type NullCallback = ~fn();\n-pub type IdleCallback = ~fn(IdleWatcher, Option<UvError>);\n-pub type ConnectionCallback = ~fn(StreamWatcher, Option<UvError>);\n-pub type FsCallback = ~fn(&mut FsRequest, Option<UvError>);\n-// first int is exit_status, second is term_signal\n-pub type ExitCallback = ~fn(Process, int, int, Option<UvError>);\n-pub type TimerCallback = ~fn(TimerWatcher, Option<UvError>);\n-pub type AsyncCallback = ~fn(AsyncWatcher, Option<UvError>);\n-pub type UdpReceiveCallback = ~fn(UdpWatcher, int, Buf, SocketAddr, uint, Option<UvError>);\n-pub type UdpSendCallback = ~fn(UdpWatcher, Option<UvError>);\n-pub type SignalCallback = ~fn(SignalWatcher, Signum);\n-\n-\n-/// Callbacks used by StreamWatchers, set as custom data on the foreign handle.\n-/// XXX: Would be better not to have all watchers allocate room for all callback types.\n-struct WatcherData {\n-    read_cb: Option<ReadCallback>,\n-    write_cb: Option<ConnectionCallback>,\n-    connect_cb: Option<ConnectionCallback>,\n-    close_cb: Option<NullCallback>,\n-    alloc_cb: Option<AllocCallback>,\n-    idle_cb: Option<IdleCallback>,\n-    timer_cb: Option<TimerCallback>,\n-    async_cb: Option<AsyncCallback>,\n-    udp_recv_cb: Option<UdpReceiveCallback>,\n-    udp_send_cb: Option<UdpSendCallback>,\n-    exit_cb: Option<ExitCallback>,\n-    signal_cb: Option<SignalCallback>,\n-}\n-\n-pub trait WatcherInterop {\n-    fn event_loop(&self) -> Loop;\n-    fn install_watcher_data(&mut self);\n-    fn get_watcher_data<'r>(&'r mut self) -> &'r mut WatcherData;\n-    fn drop_watcher_data(&mut self);\n-    fn close(self, cb: NullCallback);\n-    fn close_async(self);\n-}\n-\n-impl<H, W: Watcher + NativeHandle<*H>> WatcherInterop for W {\n-    /// Get the uv event loop from a Watcher\n-    fn event_loop(&self) -> Loop {\n-        unsafe {\n-            let handle = self.native_handle();\n-            let loop_ = uvll::get_loop_for_uv_handle(handle);\n-            NativeHandle::from_native_handle(loop_)\n-        }\n-    }\n-\n-    fn install_watcher_data(&mut self) {\n-        unsafe {\n-            let data = ~WatcherData {\n-                read_cb: None,\n-                write_cb: None,\n-                connect_cb: None,\n-                close_cb: None,\n-                alloc_cb: None,\n-                idle_cb: None,\n-                timer_cb: None,\n-                async_cb: None,\n-                udp_recv_cb: None,\n-                udp_send_cb: None,\n-                exit_cb: None,\n-                signal_cb: None,\n-            };\n-            let data = transmute::<~WatcherData, *c_void>(data);\n-            uvll::set_data_for_uv_handle(self.native_handle(), data);\n-        }\n-    }\n-\n-    fn get_watcher_data<'r>(&'r mut self) -> &'r mut WatcherData {\n-        unsafe {\n-            let data = uvll::get_data_for_uv_handle(self.native_handle());\n-            let data = transmute::<&*c_void, &mut ~WatcherData>(&data);\n-            return &mut **data;\n-        }\n-    }\n-\n-    fn drop_watcher_data(&mut self) {\n-        unsafe {\n-            let data = uvll::get_data_for_uv_handle(self.native_handle());\n-            let _data = transmute::<*c_void, ~WatcherData>(data);\n-            uvll::set_data_for_uv_handle(self.native_handle(), null::<()>());\n-        }\n-    }\n-\n-    fn close(mut self, cb: NullCallback) {\n-        {\n-            let data = self.get_watcher_data();\n-            assert!(data.close_cb.is_none());\n-            data.close_cb = Some(cb);\n-        }\n-\n-        unsafe { uvll::close(self.native_handle(), close_cb); }\n-\n-        extern fn close_cb(handle: *uvll::uv_handle_t) {\n-            let mut h: Handle = NativeHandle::from_native_handle(handle);\n-            h.get_watcher_data().close_cb.take_unwrap()();\n-            h.drop_watcher_data();\n-            unsafe { uvll::free_handle(handle as *c_void) }\n-        }\n-    }\n-\n-    fn close_async(self) {\n-        unsafe { uvll::close(self.native_handle(), close_cb); }\n-\n-        extern fn close_cb(handle: *uvll::uv_handle_t) {\n-            let mut h: Handle = NativeHandle::from_native_handle(handle);\n-            h.drop_watcher_data();\n-            unsafe { uvll::free_handle(handle as *c_void) }\n-        }\n-    }\n-}\n-\n-// XXX: Need to define the error constants like EOF so they can be\n-// compared to the UvError type\n-\n-pub struct UvError(c_int);\n-\n-impl UvError {\n-    pub fn name(&self) -> ~str {\n-        unsafe {\n-            let inner = match self { &UvError(a) => a };\n-            let name_str = uvll::err_name(inner);\n-            assert!(name_str.is_not_null());\n-            from_c_str(name_str)\n-        }\n-    }\n-\n-    pub fn desc(&self) -> ~str {\n-        unsafe {\n-            let inner = match self { &UvError(a) => a };\n-            let desc_str = uvll::strerror(inner);\n-            assert!(desc_str.is_not_null());\n-            from_c_str(desc_str)\n-        }\n-    }\n-\n-    pub fn is_eof(&self) -> bool {\n-        **self == uvll::EOF\n-    }\n-}\n-\n-impl ToStr for UvError {\n-    fn to_str(&self) -> ~str {\n-        format!(\"{}: {}\", self.name(), self.desc())\n-    }\n-}\n-\n-#[test]\n-fn error_smoke_test() {\n-    let err: UvError = UvError(uvll::EOF);\n-    assert_eq!(err.to_str(), ~\"EOF: end of file\");\n-}\n-\n-pub fn uv_error_to_io_error(uverr: UvError) -> IoError {\n-    unsafe {\n-        // Importing error constants\n-        use rt::uv::uvll::*;\n-        use rt::io::*;\n-\n-        // uv error descriptions are static\n-        let c_desc = uvll::strerror(*uverr);\n-        let desc = str::raw::c_str_to_static_slice(c_desc);\n-\n-        let kind = match *uverr {\n-            UNKNOWN => OtherIoError,\n-            OK => OtherIoError,\n-            EOF => EndOfFile,\n-            EACCES => PermissionDenied,\n-            ECONNREFUSED => ConnectionRefused,\n-            ECONNRESET => ConnectionReset,\n-            ENOTCONN => NotConnected,\n-            EPIPE => BrokenPipe,\n-            ECONNABORTED => ConnectionAborted,\n-            err => {\n-                rtdebug!(\"uverr.code {}\", err as int);\n-                // XXX: Need to map remaining uv error types\n-                OtherIoError\n-            }\n-        };\n-\n-        IoError {\n-            kind: kind,\n-            desc: desc,\n-            detail: None\n-        }\n-    }\n-}\n-\n-/// Given a uv handle, convert a callback status to a UvError\n-pub fn status_to_maybe_uv_error(status: c_int) -> Option<UvError>\n-{\n-    if status >= 0 {\n-        None\n-    } else {\n-        Some(UvError(status))\n-    }\n-}\n-\n-/// The uv buffer type\n-pub type Buf = uvll::uv_buf_t;\n-\n-pub fn empty_buf() -> Buf {\n-    uvll::uv_buf_t {\n-        base: null(),\n-        len: 0,\n-    }\n-}\n-\n-/// Borrow a slice to a Buf\n-pub fn slice_to_uv_buf(v: &[u8]) -> Buf {\n-    let data = vec::raw::to_ptr(v);\n-    unsafe { uvll::buf_init(data, v.len()) }\n-}\n-\n-// XXX: Do these conversions without copying\n-\n-/// Transmute an owned vector to a Buf\n-pub fn vec_to_uv_buf(v: ~[u8]) -> Buf {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    unsafe {\n-        let data = malloc(v.len() as size_t) as *u8;\n-        assert!(data.is_not_null());\n-        do v.as_imm_buf |b, l| {\n-            let data = data as *mut u8;\n-            ptr::copy_memory(data, b, l)\n-        }\n-        uvll::buf_init(data, v.len())\n-    }\n-}\n-\n-/// Transmute a Buf that was once a ~[u8] back to ~[u8]\n-pub fn vec_from_uv_buf(buf: Buf) -> Option<~[u8]> {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    if !(buf.len == 0 && buf.base.is_null()) {\n-        let v = unsafe { vec::from_buf(buf.base, buf.len as uint) };\n-        unsafe { free(buf.base as *c_void) };\n-        return Some(v);\n-    } else {\n-        // No buffer\n-        rtdebug!(\"No buffer!\");\n-        return None;\n-    }\n-}\n-/*\n-#[test]\n-fn test_slice_to_uv_buf() {\n-    let slice = [0, .. 20];\n-    let buf = slice_to_uv_buf(slice);\n-\n-    assert!(buf.len == 20);\n-\n-    unsafe {\n-        let base = transmute::<*u8, *mut u8>(buf.base);\n-        (*base) = 1;\n-        (*ptr::mut_offset(base, 1)) = 2;\n-    }\n-\n-    assert!(slice[0] == 1);\n-    assert!(slice[1] == 2);\n-}\n-\n-\n-#[test]\n-fn loop_smoke_test() {\n-    do run_in_bare_thread {\n-        let mut loop_ = Loop::new();\n-        loop_.run();\n-        loop_.close();\n-    }\n-}\n-*/"}, {"sha": "77de8348c14613a7a0aa09167a7d4adea3bb8426", "filename": "src/libstd/rt/uv/net.rs", "status": "removed", "additions": 0, "deletions": 853, "changes": 853, "blob_url": "https://github.com/rust-lang/rust/blob/886819cca1208210cb73892f8fe4b7b9140068dc/src%2Flibstd%2Frt%2Fuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886819cca1208210cb73892f8fe4b7b9140068dc/src%2Flibstd%2Frt%2Fuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fnet.rs?ref=886819cca1208210cb73892f8fe4b7b9140068dc", "patch": "@@ -1,853 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use prelude::*;\n-use libc::{size_t, ssize_t, c_int, c_void, c_uint};\n-use rt::uv::uvll;\n-use rt::uv::uvll::*;\n-use rt::uv::{AllocCallback, ConnectionCallback, ReadCallback, UdpReceiveCallback, UdpSendCallback};\n-use rt::uv::{Loop, Watcher, Request, UvError, Buf, NativeHandle,\n-             status_to_maybe_uv_error, empty_buf};\n-use rt::io::net::ip::{SocketAddr, Ipv4Addr, Ipv6Addr};\n-use vec;\n-use str;\n-use from_str::{FromStr};\n-\n-pub struct UvAddrInfo(*uvll::addrinfo);\n-\n-pub enum UvSocketAddr {\n-    UvIpv4SocketAddr(*sockaddr_in),\n-    UvIpv6SocketAddr(*sockaddr_in6),\n-}\n-\n-pub fn sockaddr_to_UvSocketAddr(addr: *uvll::sockaddr) -> UvSocketAddr {\n-    unsafe {\n-        assert!((is_ip4_addr(addr) || is_ip6_addr(addr)));\n-        assert!(!(is_ip4_addr(addr) && is_ip6_addr(addr)));\n-        match addr {\n-            _ if is_ip4_addr(addr) => UvIpv4SocketAddr(addr as *uvll::sockaddr_in),\n-            _ if is_ip6_addr(addr) => UvIpv6SocketAddr(addr as *uvll::sockaddr_in6),\n-            _ => fail!(),\n-        }\n-    }\n-}\n-\n-fn socket_addr_as_uv_socket_addr<T>(addr: SocketAddr, f: &fn(UvSocketAddr) -> T) -> T {\n-    let malloc = match addr.ip {\n-        Ipv4Addr(*) => malloc_ip4_addr,\n-        Ipv6Addr(*) => malloc_ip6_addr,\n-    };\n-    let wrap = match addr.ip {\n-        Ipv4Addr(*) => UvIpv4SocketAddr,\n-        Ipv6Addr(*) => UvIpv6SocketAddr,\n-    };\n-    let free = match addr.ip {\n-        Ipv4Addr(*) => free_ip4_addr,\n-        Ipv6Addr(*) => free_ip6_addr,\n-    };\n-\n-    let addr = unsafe { malloc(addr.ip.to_str(), addr.port as int) };\n-    do (|| {\n-        f(wrap(addr))\n-    }).finally {\n-        unsafe { free(addr) };\n-    }\n-}\n-\n-fn uv_socket_addr_as_socket_addr<T>(addr: UvSocketAddr, f: &fn(SocketAddr) -> T) -> T {\n-    let ip_size = match addr {\n-        UvIpv4SocketAddr(*) => 4/*groups of*/ * 3/*digits separated by*/ + 3/*periods*/,\n-        UvIpv6SocketAddr(*) => 8/*groups of*/ * 4/*hex digits separated by*/ + 7 /*colons*/,\n-    };\n-    let ip_name = {\n-        let buf = vec::from_elem(ip_size + 1 /*null terminated*/, 0u8);\n-        unsafe {\n-            let buf_ptr = vec::raw::to_ptr(buf);\n-            match addr {\n-                UvIpv4SocketAddr(addr) => uvll::ip4_name(addr, buf_ptr, ip_size as size_t),\n-                UvIpv6SocketAddr(addr) => uvll::ip6_name(addr, buf_ptr, ip_size as size_t),\n-            }\n-        };\n-        buf\n-    };\n-    let ip_port = unsafe {\n-        let port = match addr {\n-            UvIpv4SocketAddr(addr) => uvll::ip4_port(addr),\n-            UvIpv6SocketAddr(addr) => uvll::ip6_port(addr),\n-        };\n-        port as u16\n-    };\n-    let ip_str = str::from_utf8_slice(ip_name).trim_right_chars(&'\\x00');\n-    let ip_addr = FromStr::from_str(ip_str).unwrap();\n-\n-    // finally run the closure\n-    f(SocketAddr { ip: ip_addr, port: ip_port })\n-}\n-\n-pub fn uv_socket_addr_to_socket_addr(addr: UvSocketAddr) -> SocketAddr {\n-    use util;\n-    uv_socket_addr_as_socket_addr(addr, util::id)\n-}\n-\n-#[cfg(test)]\n-#[test]\n-fn test_ip4_conversion() {\n-    use rt;\n-    let ip4 = rt::test::next_test_ip4();\n-    assert_eq!(ip4, socket_addr_as_uv_socket_addr(ip4, uv_socket_addr_to_socket_addr));\n-}\n-\n-#[cfg(test)]\n-#[test]\n-fn test_ip6_conversion() {\n-    use rt;\n-    let ip6 = rt::test::next_test_ip6();\n-    assert_eq!(ip6, socket_addr_as_uv_socket_addr(ip6, uv_socket_addr_to_socket_addr));\n-}\n-\n-// uv_stream_t is the parent class of uv_tcp_t, uv_pipe_t, uv_tty_t\n-// and uv_file_t\n-pub struct StreamWatcher(*uvll::uv_stream_t);\n-impl Watcher for StreamWatcher { }\n-\n-impl StreamWatcher {\n-    pub fn read_start(&mut self, alloc: AllocCallback, cb: ReadCallback) {\n-        unsafe {\n-            match uvll::read_start(self.native_handle(), alloc_cb, read_cb) {\n-                0 => {\n-                    let data = self.get_watcher_data();\n-                    data.alloc_cb = Some(alloc);\n-                    data.read_cb = Some(cb);\n-                }\n-                n => {\n-                    cb(*self, 0, empty_buf(), Some(UvError(n)))\n-                }\n-            }\n-        }\n-\n-        extern fn alloc_cb(stream: *uvll::uv_stream_t, suggested_size: size_t) -> Buf {\n-            let mut stream_watcher: StreamWatcher = NativeHandle::from_native_handle(stream);\n-            let alloc_cb = stream_watcher.get_watcher_data().alloc_cb.get_ref();\n-            return (*alloc_cb)(suggested_size as uint);\n-        }\n-\n-        extern fn read_cb(stream: *uvll::uv_stream_t, nread: ssize_t, buf: Buf) {\n-            rtdebug!(\"buf addr: {}\", buf.base);\n-            rtdebug!(\"buf len: {}\", buf.len);\n-            let mut stream_watcher: StreamWatcher = NativeHandle::from_native_handle(stream);\n-            let cb = stream_watcher.get_watcher_data().read_cb.get_ref();\n-            let status = status_to_maybe_uv_error(nread as c_int);\n-            (*cb)(stream_watcher, nread as int, buf, status);\n-        }\n-    }\n-\n-    pub fn read_stop(&mut self) {\n-        // It would be nice to drop the alloc and read callbacks here,\n-        // but read_stop may be called from inside one of them and we\n-        // would end up freeing the in-use environment\n-        let handle = self.native_handle();\n-        unsafe { assert_eq!(uvll::read_stop(handle), 0); }\n-    }\n-\n-    pub fn write(&mut self, buf: Buf, cb: ConnectionCallback) {\n-        let req = WriteRequest::new();\n-        return unsafe {\n-            match uvll::write(req.native_handle(), self.native_handle(),\n-                              [buf], write_cb) {\n-                0 => {\n-                    let data = self.get_watcher_data();\n-                    assert!(data.write_cb.is_none());\n-                    data.write_cb = Some(cb);\n-                }\n-                n => {\n-                    req.delete();\n-                    cb(*self, Some(UvError(n)))\n-                }\n-            }\n-        };\n-\n-        extern fn write_cb(req: *uvll::uv_write_t, status: c_int) {\n-            let write_request: WriteRequest = NativeHandle::from_native_handle(req);\n-            let mut stream_watcher = write_request.stream();\n-            write_request.delete();\n-            let cb = stream_watcher.get_watcher_data().write_cb.take_unwrap();\n-            let status = status_to_maybe_uv_error(status);\n-            cb(stream_watcher, status);\n-        }\n-    }\n-\n-\n-    pub fn listen(&mut self, cb: ConnectionCallback) -> Result<(), UvError> {\n-        {\n-            let data = self.get_watcher_data();\n-            assert!(data.connect_cb.is_none());\n-            data.connect_cb = Some(cb);\n-        }\n-\n-        return unsafe {\n-            static BACKLOG: c_int = 128; // XXX should be configurable\n-            match uvll::listen(self.native_handle(), BACKLOG, connection_cb) {\n-                0 => Ok(()),\n-                n => Err(UvError(n))\n-            }\n-        };\n-\n-        extern fn connection_cb(handle: *uvll::uv_stream_t, status: c_int) {\n-            rtdebug!(\"connection_cb\");\n-            let mut stream_watcher: StreamWatcher = NativeHandle::from_native_handle(handle);\n-            let cb = stream_watcher.get_watcher_data().connect_cb.get_ref();\n-            let status = status_to_maybe_uv_error(status);\n-            (*cb)(stream_watcher, status);\n-        }\n-    }\n-\n-    pub fn accept(&mut self, stream: StreamWatcher) {\n-        let self_handle = self.native_handle() as *c_void;\n-        let stream_handle = stream.native_handle() as *c_void;\n-        assert_eq!(0, unsafe { uvll::accept(self_handle, stream_handle) } );\n-    }\n-}\n-\n-impl NativeHandle<*uvll::uv_stream_t> for StreamWatcher {\n-    fn from_native_handle(handle: *uvll::uv_stream_t) -> StreamWatcher {\n-        StreamWatcher(handle)\n-    }\n-    fn native_handle(&self) -> *uvll::uv_stream_t {\n-        match self { &StreamWatcher(ptr) => ptr }\n-    }\n-}\n-\n-pub struct TcpWatcher(*uvll::uv_tcp_t);\n-impl Watcher for TcpWatcher { }\n-\n-impl TcpWatcher {\n-    pub fn new(loop_: &Loop) -> TcpWatcher {\n-        unsafe {\n-            let handle = malloc_handle(UV_TCP);\n-            assert!(handle.is_not_null());\n-            assert_eq!(0, uvll::tcp_init(loop_.native_handle(), handle));\n-            let mut watcher: TcpWatcher = NativeHandle::from_native_handle(handle);\n-            watcher.install_watcher_data();\n-            return watcher;\n-        }\n-    }\n-\n-    pub fn bind(&mut self, address: SocketAddr) -> Result<(), UvError> {\n-        do socket_addr_as_uv_socket_addr(address) |addr| {\n-            let result = unsafe {\n-                match addr {\n-                    UvIpv4SocketAddr(addr) => uvll::tcp_bind(self.native_handle(), addr),\n-                    UvIpv6SocketAddr(addr) => uvll::tcp_bind6(self.native_handle(), addr),\n-                }\n-            };\n-            match result {\n-                0 => Ok(()),\n-                _ => Err(UvError(result)),\n-            }\n-        }\n-    }\n-\n-    pub fn connect(&mut self, address: SocketAddr, cb: ConnectionCallback) {\n-        unsafe {\n-            assert!(self.get_watcher_data().connect_cb.is_none());\n-            self.get_watcher_data().connect_cb = Some(cb);\n-\n-            let connect_handle = ConnectRequest::new().native_handle();\n-            rtdebug!(\"connect_t: {}\", connect_handle);\n-            do socket_addr_as_uv_socket_addr(address) |addr| {\n-                let result = match addr {\n-                    UvIpv4SocketAddr(addr) => uvll::tcp_connect(connect_handle,\n-                                                      self.native_handle(), addr, connect_cb),\n-                    UvIpv6SocketAddr(addr) => uvll::tcp_connect6(connect_handle,\n-                                                       self.native_handle(), addr, connect_cb),\n-                };\n-                assert_eq!(0, result);\n-            }\n-\n-            extern fn connect_cb(req: *uvll::uv_connect_t, status: c_int) {\n-                rtdebug!(\"connect_t: {}\", req);\n-                let connect_request: ConnectRequest = NativeHandle::from_native_handle(req);\n-                let mut stream_watcher = connect_request.stream();\n-                connect_request.delete();\n-                let cb = stream_watcher.get_watcher_data().connect_cb.take_unwrap();\n-                let status = status_to_maybe_uv_error(status);\n-                cb(stream_watcher, status);\n-            }\n-        }\n-    }\n-\n-    pub fn as_stream(&self) -> StreamWatcher {\n-        NativeHandle::from_native_handle(self.native_handle() as *uvll::uv_stream_t)\n-    }\n-}\n-\n-impl NativeHandle<*uvll::uv_tcp_t> for TcpWatcher {\n-    fn from_native_handle(handle: *uvll::uv_tcp_t) -> TcpWatcher {\n-        TcpWatcher(handle)\n-    }\n-    fn native_handle(&self) -> *uvll::uv_tcp_t {\n-        match self { &TcpWatcher(ptr) => ptr }\n-    }\n-}\n-\n-pub struct UdpWatcher(*uvll::uv_udp_t);\n-impl Watcher for UdpWatcher { }\n-\n-impl UdpWatcher {\n-    pub fn new(loop_: &Loop) -> UdpWatcher {\n-        unsafe {\n-            let handle = malloc_handle(UV_UDP);\n-            assert!(handle.is_not_null());\n-            assert_eq!(0, uvll::udp_init(loop_.native_handle(), handle));\n-            let mut watcher: UdpWatcher = NativeHandle::from_native_handle(handle);\n-            watcher.install_watcher_data();\n-            return watcher;\n-        }\n-    }\n-\n-    pub fn bind(&mut self, address: SocketAddr) -> Result<(), UvError> {\n-        do socket_addr_as_uv_socket_addr(address) |addr| {\n-            let result = unsafe {\n-                match addr {\n-                    UvIpv4SocketAddr(addr) => uvll::udp_bind(self.native_handle(), addr, 0u32),\n-                    UvIpv6SocketAddr(addr) => uvll::udp_bind6(self.native_handle(), addr, 0u32),\n-                }\n-            };\n-            match result {\n-                0 => Ok(()),\n-                _ => Err(UvError(result)),\n-            }\n-        }\n-    }\n-\n-    pub fn recv_start(&mut self, alloc: AllocCallback, cb: UdpReceiveCallback) {\n-        {\n-            let data = self.get_watcher_data();\n-            data.alloc_cb = Some(alloc);\n-            data.udp_recv_cb = Some(cb);\n-        }\n-\n-        unsafe { uvll::udp_recv_start(self.native_handle(), alloc_cb, recv_cb); }\n-\n-        extern fn alloc_cb(handle: *uvll::uv_udp_t, suggested_size: size_t) -> Buf {\n-            let mut udp_watcher: UdpWatcher = NativeHandle::from_native_handle(handle);\n-            let alloc_cb = udp_watcher.get_watcher_data().alloc_cb.get_ref();\n-            return (*alloc_cb)(suggested_size as uint);\n-        }\n-\n-        extern fn recv_cb(handle: *uvll::uv_udp_t, nread: ssize_t, buf: Buf,\n-                          addr: *uvll::sockaddr, flags: c_uint) {\n-            // When there's no data to read the recv callback can be a no-op.\n-            // This can happen if read returns EAGAIN/EWOULDBLOCK. By ignoring\n-            // this we just drop back to kqueue and wait for the next callback.\n-            if nread == 0 {\n-                return;\n-            }\n-\n-            rtdebug!(\"buf addr: {}\", buf.base);\n-            rtdebug!(\"buf len: {}\", buf.len);\n-            let mut udp_watcher: UdpWatcher = NativeHandle::from_native_handle(handle);\n-            let cb = udp_watcher.get_watcher_data().udp_recv_cb.get_ref();\n-            let status = status_to_maybe_uv_error(nread as c_int);\n-            let addr = uv_socket_addr_to_socket_addr(sockaddr_to_UvSocketAddr(addr));\n-            (*cb)(udp_watcher, nread as int, buf, addr, flags as uint, status);\n-        }\n-    }\n-\n-    pub fn recv_stop(&mut self) {\n-        unsafe { uvll::udp_recv_stop(self.native_handle()); }\n-    }\n-\n-    pub fn send(&mut self, buf: Buf, address: SocketAddr, cb: UdpSendCallback) {\n-        {\n-            let data = self.get_watcher_data();\n-            assert!(data.udp_send_cb.is_none());\n-            data.udp_send_cb = Some(cb);\n-        }\n-\n-        let req = UdpSendRequest::new();\n-        do socket_addr_as_uv_socket_addr(address) |addr| {\n-            let result = unsafe {\n-                match addr {\n-                    UvIpv4SocketAddr(addr) => uvll::udp_send(req.native_handle(),\n-                                                   self.native_handle(), [buf], addr, send_cb),\n-                    UvIpv6SocketAddr(addr) => uvll::udp_send6(req.native_handle(),\n-                                                    self.native_handle(), [buf], addr, send_cb),\n-                }\n-            };\n-            assert_eq!(0, result);\n-        }\n-\n-        extern fn send_cb(req: *uvll::uv_udp_send_t, status: c_int) {\n-            let send_request: UdpSendRequest = NativeHandle::from_native_handle(req);\n-            let mut udp_watcher = send_request.handle();\n-            send_request.delete();\n-            let cb = udp_watcher.get_watcher_data().udp_send_cb.take_unwrap();\n-            let status = status_to_maybe_uv_error(status);\n-            cb(udp_watcher, status);\n-        }\n-    }\n-}\n-\n-impl NativeHandle<*uvll::uv_udp_t> for UdpWatcher {\n-    fn from_native_handle(handle: *uvll::uv_udp_t) -> UdpWatcher {\n-        UdpWatcher(handle)\n-    }\n-    fn native_handle(&self) -> *uvll::uv_udp_t {\n-        match self { &UdpWatcher(ptr) => ptr }\n-    }\n-}\n-\n-// uv_connect_t is a subclass of uv_req_t\n-pub struct ConnectRequest(*uvll::uv_connect_t);\n-impl Request for ConnectRequest { }\n-\n-impl ConnectRequest {\n-\n-    pub fn new() -> ConnectRequest {\n-        let connect_handle = unsafe { malloc_req(UV_CONNECT) };\n-        assert!(connect_handle.is_not_null());\n-        ConnectRequest(connect_handle as *uvll::uv_connect_t)\n-    }\n-\n-    fn stream(&self) -> StreamWatcher {\n-        unsafe {\n-            let stream_handle = uvll::get_stream_handle_from_connect_req(self.native_handle());\n-            NativeHandle::from_native_handle(stream_handle)\n-        }\n-    }\n-\n-    fn delete(self) {\n-        unsafe { free_req(self.native_handle() as *c_void) }\n-    }\n-}\n-\n-impl NativeHandle<*uvll::uv_connect_t> for ConnectRequest {\n-    fn from_native_handle(handle: *uvll:: uv_connect_t) -> ConnectRequest {\n-        ConnectRequest(handle)\n-    }\n-    fn native_handle(&self) -> *uvll::uv_connect_t {\n-        match self { &ConnectRequest(ptr) => ptr }\n-    }\n-}\n-\n-pub struct WriteRequest(*uvll::uv_write_t);\n-\n-impl Request for WriteRequest { }\n-\n-impl WriteRequest {\n-    pub fn new() -> WriteRequest {\n-        let write_handle = unsafe { malloc_req(UV_WRITE) };\n-        assert!(write_handle.is_not_null());\n-        WriteRequest(write_handle as *uvll::uv_write_t)\n-    }\n-\n-    pub fn stream(&self) -> StreamWatcher {\n-        unsafe {\n-            let stream_handle = uvll::get_stream_handle_from_write_req(self.native_handle());\n-            NativeHandle::from_native_handle(stream_handle)\n-        }\n-    }\n-\n-    pub fn delete(self) {\n-        unsafe { free_req(self.native_handle() as *c_void) }\n-    }\n-}\n-\n-impl NativeHandle<*uvll::uv_write_t> for WriteRequest {\n-    fn from_native_handle(handle: *uvll:: uv_write_t) -> WriteRequest {\n-        WriteRequest(handle)\n-    }\n-    fn native_handle(&self) -> *uvll::uv_write_t {\n-        match self { &WriteRequest(ptr) => ptr }\n-    }\n-}\n-\n-pub struct UdpSendRequest(*uvll::uv_udp_send_t);\n-impl Request for UdpSendRequest { }\n-\n-impl UdpSendRequest {\n-    pub fn new() -> UdpSendRequest {\n-        let send_handle = unsafe { malloc_req(UV_UDP_SEND) };\n-        assert!(send_handle.is_not_null());\n-        UdpSendRequest(send_handle as *uvll::uv_udp_send_t)\n-    }\n-\n-    pub fn handle(&self) -> UdpWatcher {\n-        let send_request_handle = unsafe {\n-            uvll::get_udp_handle_from_send_req(self.native_handle())\n-        };\n-        NativeHandle::from_native_handle(send_request_handle)\n-    }\n-\n-    pub fn delete(self) {\n-        unsafe { free_req(self.native_handle() as *c_void) }\n-    }\n-}\n-\n-impl NativeHandle<*uvll::uv_udp_send_t> for UdpSendRequest {\n-    fn from_native_handle(handle: *uvll::uv_udp_send_t) -> UdpSendRequest {\n-        UdpSendRequest(handle)\n-    }\n-    fn native_handle(&self) -> *uvll::uv_udp_send_t {\n-        match self { &UdpSendRequest(ptr) => ptr }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use super::*;\n-    use util::ignore;\n-    use cell::Cell;\n-    use vec;\n-    use unstable::run_in_bare_thread;\n-    use rt::thread::Thread;\n-    use rt::test::*;\n-    use rt::uv::{Loop, AllocCallback};\n-    use rt::uv::{vec_from_uv_buf, vec_to_uv_buf, slice_to_uv_buf};\n-    use prelude::*;\n-\n-    #[test]\n-    fn connect_close_ip4() {\n-        do run_in_bare_thread() {\n-            let mut loop_ = Loop::new();\n-            let mut tcp_watcher = { TcpWatcher::new(&mut loop_) };\n-            // Connect to a port where nobody is listening\n-            let addr = next_test_ip4();\n-            do tcp_watcher.connect(addr) |stream_watcher, status| {\n-                rtdebug!(\"tcp_watcher.connect!\");\n-                assert!(status.is_some());\n-                assert_eq!(status.unwrap().name(), ~\"ECONNREFUSED\");\n-                stream_watcher.close(||());\n-            }\n-            loop_.run();\n-            loop_.close();\n-        }\n-    }\n-\n-    #[test]\n-    fn connect_close_ip6() {\n-        do run_in_bare_thread() {\n-            let mut loop_ = Loop::new();\n-            let mut tcp_watcher = { TcpWatcher::new(&mut loop_) };\n-            // Connect to a port where nobody is listening\n-            let addr = next_test_ip6();\n-            do tcp_watcher.connect(addr) |stream_watcher, status| {\n-                rtdebug!(\"tcp_watcher.connect!\");\n-                assert!(status.is_some());\n-                assert_eq!(status.unwrap().name(), ~\"ECONNREFUSED\");\n-                stream_watcher.close(||());\n-            }\n-            loop_.run();\n-            loop_.close();\n-        }\n-    }\n-\n-    #[test]\n-    fn udp_bind_close_ip4() {\n-        do run_in_bare_thread() {\n-            let mut loop_ = Loop::new();\n-            let mut udp_watcher = { UdpWatcher::new(&mut loop_) };\n-            let addr = next_test_ip4();\n-            udp_watcher.bind(addr);\n-            udp_watcher.close(||());\n-            loop_.run();\n-            loop_.close();\n-        }\n-    }\n-\n-    #[test]\n-    fn udp_bind_close_ip6() {\n-        do run_in_bare_thread() {\n-            let mut loop_ = Loop::new();\n-            let mut udp_watcher = { UdpWatcher::new(&mut loop_) };\n-            let addr = next_test_ip6();\n-            udp_watcher.bind(addr);\n-            udp_watcher.close(||());\n-            loop_.run();\n-            loop_.close();\n-        }\n-    }\n-\n-    #[test]\n-    fn listen_ip4() {\n-        do run_in_bare_thread() {\n-            static MAX: int = 10;\n-            let mut loop_ = Loop::new();\n-            let mut server_tcp_watcher = { TcpWatcher::new(&mut loop_) };\n-            let addr = next_test_ip4();\n-            server_tcp_watcher.bind(addr);\n-            let loop_ = loop_;\n-            rtdebug!(\"listening\");\n-            let mut stream = server_tcp_watcher.as_stream();\n-            let res = do stream.listen |mut server_stream_watcher, status| {\n-                rtdebug!(\"listened!\");\n-                assert!(status.is_none());\n-                let mut loop_ = loop_;\n-                let client_tcp_watcher = TcpWatcher::new(&mut loop_);\n-                let mut client_tcp_watcher = client_tcp_watcher.as_stream();\n-                server_stream_watcher.accept(client_tcp_watcher);\n-                let count_cell = Cell::new(0);\n-                let server_stream_watcher = server_stream_watcher;\n-                rtdebug!(\"starting read\");\n-                let alloc: AllocCallback = |size| {\n-                    vec_to_uv_buf(vec::from_elem(size, 0u8))\n-                };\n-                do client_tcp_watcher.read_start(alloc) |stream_watcher, nread, buf, status| {\n-\n-                    rtdebug!(\"i'm reading!\");\n-                    let buf = vec_from_uv_buf(buf);\n-                    let mut count = count_cell.take();\n-                    if status.is_none() {\n-                        rtdebug!(\"got {} bytes\", nread);\n-                        let buf = buf.unwrap();\n-                        for byte in buf.slice(0, nread as uint).iter() {\n-                            assert!(*byte == count as u8);\n-                            rtdebug!(\"{}\", *byte as uint);\n-                            count += 1;\n-                        }\n-                    } else {\n-                        assert_eq!(count, MAX);\n-                        do stream_watcher.close {\n-                            server_stream_watcher.close(||());\n-                        }\n-                    }\n-                    count_cell.put_back(count);\n-                }\n-            };\n-\n-            assert!(res.is_ok());\n-\n-            let client_thread = do Thread::start {\n-                rtdebug!(\"starting client thread\");\n-                let mut loop_ = Loop::new();\n-                let mut tcp_watcher = { TcpWatcher::new(&mut loop_) };\n-                do tcp_watcher.connect(addr) |mut stream_watcher, status| {\n-                    rtdebug!(\"connecting\");\n-                    assert!(status.is_none());\n-                    let msg = ~[0, 1, 2, 3, 4, 5, 6 ,7 ,8, 9];\n-                    let buf = slice_to_uv_buf(msg);\n-                    let msg_cell = Cell::new(msg);\n-                    do stream_watcher.write(buf) |stream_watcher, status| {\n-                        rtdebug!(\"writing\");\n-                        assert!(status.is_none());\n-                        let msg_cell = Cell::new(msg_cell.take());\n-                        stream_watcher.close(||ignore(msg_cell.take()));\n-                    }\n-                }\n-                loop_.run();\n-                loop_.close();\n-            };\n-\n-            let mut loop_ = loop_;\n-            loop_.run();\n-            loop_.close();\n-            client_thread.join();\n-        };\n-    }\n-\n-    #[test]\n-    fn listen_ip6() {\n-        do run_in_bare_thread() {\n-            static MAX: int = 10;\n-            let mut loop_ = Loop::new();\n-            let mut server_tcp_watcher = { TcpWatcher::new(&mut loop_) };\n-            let addr = next_test_ip6();\n-            server_tcp_watcher.bind(addr);\n-            let loop_ = loop_;\n-            rtdebug!(\"listening\");\n-            let mut stream = server_tcp_watcher.as_stream();\n-            let res = do stream.listen |mut server_stream_watcher, status| {\n-                rtdebug!(\"listened!\");\n-                assert!(status.is_none());\n-                let mut loop_ = loop_;\n-                let client_tcp_watcher = TcpWatcher::new(&mut loop_);\n-                let mut client_tcp_watcher = client_tcp_watcher.as_stream();\n-                server_stream_watcher.accept(client_tcp_watcher);\n-                let count_cell = Cell::new(0);\n-                let server_stream_watcher = server_stream_watcher;\n-                rtdebug!(\"starting read\");\n-                let alloc: AllocCallback = |size| {\n-                    vec_to_uv_buf(vec::from_elem(size, 0u8))\n-                };\n-                do client_tcp_watcher.read_start(alloc)\n-                    |stream_watcher, nread, buf, status| {\n-\n-                    rtdebug!(\"i'm reading!\");\n-                    let buf = vec_from_uv_buf(buf);\n-                    let mut count = count_cell.take();\n-                    if status.is_none() {\n-                        rtdebug!(\"got {} bytes\", nread);\n-                        let buf = buf.unwrap();\n-                        let r = buf.slice(0, nread as uint);\n-                        for byte in r.iter() {\n-                            assert!(*byte == count as u8);\n-                            rtdebug!(\"{}\", *byte as uint);\n-                            count += 1;\n-                        }\n-                    } else {\n-                        assert_eq!(count, MAX);\n-                        do stream_watcher.close {\n-                            server_stream_watcher.close(||());\n-                        }\n-                    }\n-                    count_cell.put_back(count);\n-                }\n-            };\n-            assert!(res.is_ok());\n-\n-            let client_thread = do Thread::start {\n-                rtdebug!(\"starting client thread\");\n-                let mut loop_ = Loop::new();\n-                let mut tcp_watcher = { TcpWatcher::new(&mut loop_) };\n-                do tcp_watcher.connect(addr) |mut stream_watcher, status| {\n-                    rtdebug!(\"connecting\");\n-                    assert!(status.is_none());\n-                    let msg = ~[0, 1, 2, 3, 4, 5, 6 ,7 ,8, 9];\n-                    let buf = slice_to_uv_buf(msg);\n-                    let msg_cell = Cell::new(msg);\n-                    do stream_watcher.write(buf) |stream_watcher, status| {\n-                        rtdebug!(\"writing\");\n-                        assert!(status.is_none());\n-                        let msg_cell = Cell::new(msg_cell.take());\n-                        stream_watcher.close(||ignore(msg_cell.take()));\n-                    }\n-                }\n-                loop_.run();\n-                loop_.close();\n-            };\n-\n-            let mut loop_ = loop_;\n-            loop_.run();\n-            loop_.close();\n-            client_thread.join();\n-        }\n-    }\n-\n-    #[test]\n-    fn udp_recv_ip4() {\n-        do run_in_bare_thread() {\n-            static MAX: int = 10;\n-            let mut loop_ = Loop::new();\n-            let server_addr = next_test_ip4();\n-            let client_addr = next_test_ip4();\n-\n-            let mut server = UdpWatcher::new(&loop_);\n-            assert!(server.bind(server_addr).is_ok());\n-\n-            rtdebug!(\"starting read\");\n-            let alloc: AllocCallback = |size| {\n-                vec_to_uv_buf(vec::from_elem(size, 0u8))\n-            };\n-\n-            do server.recv_start(alloc) |mut server, nread, buf, src, flags, status| {\n-                server.recv_stop();\n-                rtdebug!(\"i'm reading!\");\n-                assert!(status.is_none());\n-                assert_eq!(flags, 0);\n-                assert_eq!(src, client_addr);\n-\n-                let buf = vec_from_uv_buf(buf);\n-                let mut count = 0;\n-                rtdebug!(\"got {} bytes\", nread);\n-\n-                let buf = buf.unwrap();\n-                for &byte in buf.slice(0, nread as uint).iter() {\n-                    assert!(byte == count as u8);\n-                    rtdebug!(\"{}\", byte as uint);\n-                    count += 1;\n-                }\n-                assert_eq!(count, MAX);\n-\n-                server.close(||{});\n-            }\n-\n-            let thread = do Thread::start {\n-                let mut loop_ = Loop::new();\n-                let mut client = UdpWatcher::new(&loop_);\n-                assert!(client.bind(client_addr).is_ok());\n-                let msg = ~[0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n-                let buf = slice_to_uv_buf(msg);\n-                do client.send(buf, server_addr) |client, status| {\n-                    rtdebug!(\"writing\");\n-                    assert!(status.is_none());\n-                    client.close(||{});\n-                }\n-\n-                loop_.run();\n-                loop_.close();\n-            };\n-\n-            loop_.run();\n-            loop_.close();\n-            thread.join();\n-        }\n-    }\n-\n-    #[test]\n-    fn udp_recv_ip6() {\n-        do run_in_bare_thread() {\n-            static MAX: int = 10;\n-            let mut loop_ = Loop::new();\n-            let server_addr = next_test_ip6();\n-            let client_addr = next_test_ip6();\n-\n-            let mut server = UdpWatcher::new(&loop_);\n-            assert!(server.bind(server_addr).is_ok());\n-\n-            rtdebug!(\"starting read\");\n-            let alloc: AllocCallback = |size| {\n-                vec_to_uv_buf(vec::from_elem(size, 0u8))\n-            };\n-\n-            do server.recv_start(alloc) |mut server, nread, buf, src, flags, status| {\n-                server.recv_stop();\n-                rtdebug!(\"i'm reading!\");\n-                assert!(status.is_none());\n-                assert_eq!(flags, 0);\n-                assert_eq!(src, client_addr);\n-\n-                let buf = vec_from_uv_buf(buf);\n-                let mut count = 0;\n-                rtdebug!(\"got {} bytes\", nread);\n-\n-                let buf = buf.unwrap();\n-                for &byte in buf.slice(0, nread as uint).iter() {\n-                    assert!(byte == count as u8);\n-                    rtdebug!(\"{}\", byte as uint);\n-                    count += 1;\n-                }\n-                assert_eq!(count, MAX);\n-\n-                server.close(||{});\n-            }\n-\n-            let thread = do Thread::start {\n-                let mut loop_ = Loop::new();\n-                let mut client = UdpWatcher::new(&loop_);\n-                assert!(client.bind(client_addr).is_ok());\n-                let msg = ~[0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n-                let buf = slice_to_uv_buf(msg);\n-                do client.send(buf, server_addr) |client, status| {\n-                    rtdebug!(\"writing\");\n-                    assert!(status.is_none());\n-                    client.close(||{});\n-                }\n-\n-                loop_.run();\n-                loop_.close();\n-            };\n-\n-            loop_.run();\n-            loop_.close();\n-            thread.join();\n-        }\n-    }\n-}"}, {"sha": "74b9312954c83b94703d4418c66a6d1f07f6e042", "filename": "src/libstd/rt/uv/pipe.rs", "status": "removed", "additions": 0, "deletions": 98, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/886819cca1208210cb73892f8fe4b7b9140068dc/src%2Flibstd%2Frt%2Fuv%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886819cca1208210cb73892f8fe4b7b9140068dc/src%2Flibstd%2Frt%2Fuv%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fpipe.rs?ref=886819cca1208210cb73892f8fe4b7b9140068dc", "patch": "@@ -1,98 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use prelude::*;\n-use libc;\n-use c_str::CString;\n-\n-use rt::uv;\n-use rt::uv::net;\n-use rt::uv::uvll;\n-\n-pub struct Pipe(*uvll::uv_pipe_t);\n-\n-impl uv::Watcher for Pipe {}\n-\n-impl Pipe {\n-    pub fn new(loop_: &uv::Loop, ipc: bool) -> Pipe {\n-        unsafe {\n-            let handle = uvll::malloc_handle(uvll::UV_NAMED_PIPE);\n-            assert!(handle.is_not_null());\n-            let ipc = ipc as libc::c_int;\n-            assert_eq!(uvll::pipe_init(loop_.native_handle(), handle, ipc), 0);\n-            let mut ret: Pipe =\n-                    uv::NativeHandle::from_native_handle(handle);\n-            ret.install_watcher_data();\n-            ret\n-        }\n-    }\n-\n-    pub fn as_stream(&self) -> net::StreamWatcher {\n-        net::StreamWatcher(**self as *uvll::uv_stream_t)\n-    }\n-\n-    #[fixed_stack_segment] #[inline(never)]\n-    pub fn open(&mut self, file: libc::c_int) -> Result<(), uv::UvError> {\n-        match unsafe { uvll::pipe_open(self.native_handle(), file) } {\n-            0 => Ok(()),\n-            n => Err(uv::UvError(n))\n-        }\n-    }\n-\n-    #[fixed_stack_segment] #[inline(never)]\n-    pub fn bind(&mut self, name: &CString) -> Result<(), uv::UvError> {\n-        do name.with_ref |name| {\n-            match unsafe { uvll::pipe_bind(self.native_handle(), name) } {\n-                0 => Ok(()),\n-                n => Err(uv::UvError(n))\n-            }\n-        }\n-    }\n-\n-    #[fixed_stack_segment] #[inline(never)]\n-    pub fn connect(&mut self, name: &CString, cb: uv::ConnectionCallback) {\n-        {\n-            let data = self.get_watcher_data();\n-            assert!(data.connect_cb.is_none());\n-            data.connect_cb = Some(cb);\n-        }\n-\n-        let connect = net::ConnectRequest::new();\n-        let name = do name.with_ref |p| { p };\n-\n-        unsafe {\n-            uvll::pipe_connect(connect.native_handle(),\n-                               self.native_handle(),\n-                               name,\n-                               connect_cb)\n-        }\n-\n-        extern \"C\" fn connect_cb(req: *uvll::uv_connect_t, status: libc::c_int) {\n-            let connect_request: net::ConnectRequest =\n-                    uv::NativeHandle::from_native_handle(req);\n-            let mut stream_watcher = connect_request.stream();\n-            connect_request.delete();\n-\n-            let cb = stream_watcher.get_watcher_data().connect_cb.take_unwrap();\n-            let status = uv::status_to_maybe_uv_error(status);\n-            cb(stream_watcher, status);\n-        }\n-    }\n-\n-}\n-\n-impl uv::NativeHandle<*uvll::uv_pipe_t> for Pipe {\n-    fn from_native_handle(handle: *uvll::uv_pipe_t) -> Pipe {\n-        Pipe(handle)\n-    }\n-    fn native_handle(&self) -> *uvll::uv_pipe_t {\n-        match self { &Pipe(ptr) => ptr }\n-    }\n-}"}, {"sha": "f0d0afeb6aa401de1f3f1898c5eae5140c6cebdc", "filename": "src/libstd/rt/uv/process.rs", "status": "removed", "additions": 0, "deletions": 202, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/886819cca1208210cb73892f8fe4b7b9140068dc/src%2Flibstd%2Frt%2Fuv%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886819cca1208210cb73892f8fe4b7b9140068dc/src%2Flibstd%2Frt%2Fuv%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fprocess.rs?ref=886819cca1208210cb73892f8fe4b7b9140068dc", "patch": "@@ -1,202 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use prelude::*;\n-use cell::Cell;\n-use libc;\n-use ptr;\n-use vec;\n-\n-use rt::io::process::*;\n-use rt::uv;\n-use rt::uv::uvio::{UvPipeStream, UvUnboundPipe};\n-use rt::uv::uvll;\n-\n-/// A process wraps the handle of the underlying uv_process_t.\n-pub struct Process(*uvll::uv_process_t);\n-\n-impl uv::Watcher for Process {}\n-\n-impl Process {\n-    /// Creates a new process, ready to spawn inside an event loop\n-    pub fn new() -> Process {\n-        let handle = unsafe { uvll::malloc_handle(uvll::UV_PROCESS) };\n-        assert!(handle.is_not_null());\n-        let mut ret: Process = uv::NativeHandle::from_native_handle(handle);\n-        ret.install_watcher_data();\n-        return ret;\n-    }\n-\n-    /// Spawn a new process inside the specified event loop.\n-    ///\n-    /// The `config` variable will be passed down to libuv, and the `exit_cb`\n-    /// will be run only once, when the process exits.\n-    ///\n-    /// Returns either the corresponding process object or an error which\n-    /// occurred.\n-    pub fn spawn(&mut self, loop_: &uv::Loop, config: ProcessConfig,\n-                 exit_cb: uv::ExitCallback)\n-                    -> Result<~[Option<~UvPipeStream>], uv::UvError>\n-    {\n-        let cwd = config.cwd.map(|s| s.to_c_str());\n-\n-        extern fn on_exit(p: *uvll::uv_process_t,\n-                          exit_status: libc::c_int,\n-                          term_signal: libc::c_int) {\n-            let mut p: Process = uv::NativeHandle::from_native_handle(p);\n-            let err = match exit_status {\n-                0 => None,\n-                _ => uv::status_to_maybe_uv_error(-1)\n-            };\n-            p.get_watcher_data().exit_cb.take_unwrap()(p,\n-                                                       exit_status as int,\n-                                                       term_signal as int,\n-                                                       err);\n-        }\n-\n-        let io = config.io;\n-        let mut stdio = vec::with_capacity::<uvll::uv_stdio_container_t>(io.len());\n-        let mut ret_io = vec::with_capacity(io.len());\n-        unsafe {\n-            vec::raw::set_len(&mut stdio, io.len());\n-            for (slot, other) in stdio.iter().zip(io.iter()) {\n-                let io = set_stdio(slot as *uvll::uv_stdio_container_t, other,\n-                                   loop_);\n-                ret_io.push(io);\n-            }\n-        }\n-\n-        let exit_cb = Cell::new(exit_cb);\n-        let ret_io = Cell::new(ret_io);\n-        do with_argv(config.program, config.args) |argv| {\n-            do with_env(config.env) |envp| {\n-                let options = uvll::uv_process_options_t {\n-                    exit_cb: on_exit,\n-                    file: unsafe { *argv },\n-                    args: argv,\n-                    env: envp,\n-                    cwd: match cwd {\n-                        Some(ref cwd) => cwd.with_ref(|p| p),\n-                        None => ptr::null(),\n-                    },\n-                    flags: 0,\n-                    stdio_count: stdio.len() as libc::c_int,\n-                    stdio: stdio.as_imm_buf(|p, _| p),\n-                    uid: 0,\n-                    gid: 0,\n-                };\n-\n-                match unsafe {\n-                    uvll::spawn(loop_.native_handle(), **self, options)\n-                } {\n-                    0 => {\n-                        (*self).get_watcher_data().exit_cb = Some(exit_cb.take());\n-                        Ok(ret_io.take())\n-                    }\n-                    err => Err(uv::UvError(err))\n-                }\n-            }\n-        }\n-    }\n-\n-    /// Sends a signal to this process.\n-    ///\n-    /// This is a wrapper around `uv_process_kill`\n-    pub fn kill(&self, signum: int) -> Result<(), uv::UvError> {\n-        match unsafe {\n-            uvll::process_kill(self.native_handle(), signum as libc::c_int)\n-        } {\n-            0 => Ok(()),\n-            err => Err(uv::UvError(err))\n-        }\n-    }\n-\n-    /// Returns the process id of a spawned process\n-    pub fn pid(&self) -> libc::pid_t {\n-        unsafe { uvll::process_pid(**self) as libc::pid_t }\n-    }\n-}\n-\n-unsafe fn set_stdio(dst: *uvll::uv_stdio_container_t,\n-                    io: &StdioContainer,\n-                    loop_: &uv::Loop) -> Option<~UvPipeStream> {\n-    match *io {\n-        Ignored => {\n-            uvll::set_stdio_container_flags(dst, uvll::STDIO_IGNORE);\n-            None\n-        }\n-        InheritFd(fd) => {\n-            uvll::set_stdio_container_flags(dst, uvll::STDIO_INHERIT_FD);\n-            uvll::set_stdio_container_fd(dst, fd);\n-            None\n-        }\n-        CreatePipe(readable, writable) => {\n-            let mut flags = uvll::STDIO_CREATE_PIPE as libc::c_int;\n-            if readable {\n-                flags |= uvll::STDIO_READABLE_PIPE as libc::c_int;\n-            }\n-            if writable {\n-                flags |= uvll::STDIO_WRITABLE_PIPE as libc::c_int;\n-            }\n-            let pipe = UvUnboundPipe::new(loop_);\n-            let handle = pipe.pipe.as_stream().native_handle();\n-            uvll::set_stdio_container_flags(dst, flags);\n-            uvll::set_stdio_container_stream(dst, handle);\n-            Some(~UvPipeStream::new(pipe))\n-        }\n-    }\n-}\n-\n-/// Converts the program and arguments to the argv array expected by libuv\n-fn with_argv<T>(prog: &str, args: &[~str], f: &fn(**libc::c_char) -> T) -> T {\n-    // First, allocation space to put all the C-strings (we need to have\n-    // ownership of them somewhere\n-    let mut c_strs = vec::with_capacity(args.len() + 1);\n-    c_strs.push(prog.to_c_str());\n-    for arg in args.iter() {\n-        c_strs.push(arg.to_c_str());\n-    }\n-\n-    // Next, create the char** array\n-    let mut c_args = vec::with_capacity(c_strs.len() + 1);\n-    for s in c_strs.iter() {\n-        c_args.push(s.with_ref(|p| p));\n-    }\n-    c_args.push(ptr::null());\n-    c_args.as_imm_buf(|buf, _| f(buf))\n-}\n-\n-/// Converts the environment to the env array expected by libuv\n-fn with_env<T>(env: Option<&[(~str, ~str)]>, f: &fn(**libc::c_char) -> T) -> T {\n-    let env = match env {\n-        Some(s) => s,\n-        None => { return f(ptr::null()); }\n-    };\n-    // As with argv, create some temporary storage and then the actual array\n-    let mut envp = vec::with_capacity(env.len());\n-    for &(ref key, ref value) in env.iter() {\n-        envp.push(format!(\"{}={}\", *key, *value).to_c_str());\n-    }\n-    let mut c_envp = vec::with_capacity(envp.len() + 1);\n-    for s in envp.iter() {\n-        c_envp.push(s.with_ref(|p| p));\n-    }\n-    c_envp.push(ptr::null());\n-    c_envp.as_imm_buf(|buf, _| f(buf))\n-}\n-\n-impl uv::NativeHandle<*uvll::uv_process_t> for Process {\n-    fn from_native_handle(handle: *uvll::uv_process_t) -> Process {\n-        Process(handle)\n-    }\n-    fn native_handle(&self) -> *uvll::uv_process_t {\n-        match self { &Process(ptr) => ptr }\n-    }\n-}"}, {"sha": "3252c89673d6b550f2cfc4d9913b720934a85b29", "filename": "src/libstd/rt/uv/signal.rs", "status": "removed", "additions": 0, "deletions": 73, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/886819cca1208210cb73892f8fe4b7b9140068dc/src%2Flibstd%2Frt%2Fuv%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886819cca1208210cb73892f8fe4b7b9140068dc/src%2Flibstd%2Frt%2Fuv%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fsignal.rs?ref=886819cca1208210cb73892f8fe4b7b9140068dc", "patch": "@@ -1,73 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use cast;\n-use option::Some;\n-use libc::c_int;\n-use result::{Err, Ok, Result};\n-use rt::io::signal::Signum;\n-use rt::uv::{Loop, NativeHandle, SignalCallback, UvError, Watcher};\n-use rt::uv::uvll;\n-\n-pub struct SignalWatcher(*uvll::uv_signal_t);\n-\n-impl Watcher for SignalWatcher { }\n-\n-impl SignalWatcher {\n-    pub fn new(loop_: &mut Loop) -> SignalWatcher {\n-        unsafe {\n-            let handle = uvll::malloc_handle(uvll::UV_SIGNAL);\n-            assert!(handle.is_not_null());\n-            assert!(0 == uvll::signal_init(loop_.native_handle(), handle));\n-            let mut watcher: SignalWatcher = NativeHandle::from_native_handle(handle);\n-            watcher.install_watcher_data();\n-            return watcher;\n-        }\n-    }\n-\n-    pub fn start(&mut self, signum: Signum, callback: SignalCallback)\n-            -> Result<(), UvError>\n-    {\n-        return unsafe {\n-            match uvll::signal_start(self.native_handle(), signal_cb,\n-                                     signum as c_int) {\n-                0 => {\n-                    let data = self.get_watcher_data();\n-                    data.signal_cb = Some(callback);\n-                    Ok(())\n-                }\n-                n => Err(UvError(n)),\n-            }\n-        };\n-\n-        extern fn signal_cb(handle: *uvll::uv_signal_t, signum: c_int) {\n-            let mut watcher: SignalWatcher = NativeHandle::from_native_handle(handle);\n-            let data = watcher.get_watcher_data();\n-            let cb = data.signal_cb.get_ref();\n-            (*cb)(watcher, unsafe { cast::transmute(signum as int) });\n-        }\n-    }\n-\n-    pub fn stop(&mut self) {\n-        unsafe {\n-            uvll::signal_stop(self.native_handle());\n-        }\n-    }\n-}\n-\n-impl NativeHandle<*uvll::uv_signal_t> for SignalWatcher {\n-    fn from_native_handle(handle: *uvll::uv_signal_t) -> SignalWatcher {\n-        SignalWatcher(handle)\n-    }\n-\n-    fn native_handle(&self) -> *uvll::uv_signal_t {\n-        match self { &SignalWatcher(ptr) => ptr }\n-    }\n-}"}, {"sha": "fb3c84df39f9b83ddb1bcde12837ecafd304320e", "filename": "src/libstd/rt/uv/timer.rs", "status": "removed", "additions": 0, "deletions": 158, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/886819cca1208210cb73892f8fe4b7b9140068dc/src%2Flibstd%2Frt%2Fuv%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886819cca1208210cb73892f8fe4b7b9140068dc/src%2Flibstd%2Frt%2Fuv%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Ftimer.rs?ref=886819cca1208210cb73892f8fe4b7b9140068dc", "patch": "@@ -1,158 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use libc::c_int;\n-use option::Some;\n-use rt::uv::uvll;\n-use rt::uv::{Watcher, Loop, NativeHandle, TimerCallback};\n-use rt::uv::status_to_maybe_uv_error;\n-\n-pub struct TimerWatcher(*uvll::uv_timer_t);\n-impl Watcher for TimerWatcher { }\n-\n-impl TimerWatcher {\n-    pub fn new(loop_: &mut Loop) -> TimerWatcher {\n-        unsafe {\n-            let handle = uvll::malloc_handle(uvll::UV_TIMER);\n-            assert!(handle.is_not_null());\n-            assert!(0 == uvll::timer_init(loop_.native_handle(), handle));\n-            let mut watcher: TimerWatcher = NativeHandle::from_native_handle(handle);\n-            watcher.install_watcher_data();\n-            return watcher;\n-        }\n-    }\n-\n-    pub fn start(&mut self, timeout: u64, repeat: u64, cb: TimerCallback) {\n-        {\n-            let data = self.get_watcher_data();\n-            data.timer_cb = Some(cb);\n-        }\n-\n-        unsafe {\n-            uvll::timer_start(self.native_handle(), timer_cb, timeout, repeat);\n-        }\n-\n-        extern fn timer_cb(handle: *uvll::uv_timer_t, status: c_int) {\n-            let mut watcher: TimerWatcher = NativeHandle::from_native_handle(handle);\n-            let data = watcher.get_watcher_data();\n-            let cb = data.timer_cb.get_ref();\n-            let status = status_to_maybe_uv_error(status);\n-            (*cb)(watcher, status);\n-        }\n-    }\n-\n-    pub fn stop(&mut self) {\n-        unsafe {\n-            uvll::timer_stop(self.native_handle());\n-        }\n-    }\n-}\n-\n-impl NativeHandle<*uvll::uv_timer_t> for TimerWatcher {\n-    fn from_native_handle(handle: *uvll::uv_timer_t) -> TimerWatcher {\n-        TimerWatcher(handle)\n-    }\n-    fn native_handle(&self) -> *uvll::uv_idle_t {\n-        match self { &TimerWatcher(ptr) => ptr }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use super::*;\n-    use rt::uv::Loop;\n-    use unstable::run_in_bare_thread;\n-\n-    #[test]\n-    fn smoke_test() {\n-        do run_in_bare_thread {\n-            let mut count = 0;\n-            let count_ptr: *mut int = &mut count;\n-            let mut loop_ = Loop::new();\n-            let mut timer = TimerWatcher::new(&mut loop_);\n-            do timer.start(10, 0) |timer, status| {\n-                assert!(status.is_none());\n-                unsafe { *count_ptr += 1 };\n-                timer.close(||());\n-            }\n-            loop_.run();\n-            loop_.close();\n-            assert!(count == 1);\n-        }\n-    }\n-\n-    #[test]\n-    fn start_twice() {\n-        do run_in_bare_thread {\n-            let mut count = 0;\n-            let count_ptr: *mut int = &mut count;\n-            let mut loop_ = Loop::new();\n-            let mut timer = TimerWatcher::new(&mut loop_);\n-            do timer.start(10, 0) |timer, status| {\n-                let mut timer = timer;\n-                assert!(status.is_none());\n-                unsafe { *count_ptr += 1 };\n-                do timer.start(10, 0) |timer, status| {\n-                    assert!(status.is_none());\n-                    unsafe { *count_ptr += 1 };\n-                    timer.close(||());\n-                }\n-            }\n-            loop_.run();\n-            loop_.close();\n-            assert!(count == 2);\n-        }\n-    }\n-\n-    #[test]\n-    fn repeat_stop() {\n-        do run_in_bare_thread {\n-            let mut count = 0;\n-            let count_ptr: *mut int = &mut count;\n-            let mut loop_ = Loop::new();\n-            let mut timer = TimerWatcher::new(&mut loop_);\n-            do timer.start(1, 2) |timer, status| {\n-                assert!(status.is_none());\n-                unsafe {\n-                    *count_ptr += 1;\n-\n-                    if *count_ptr == 10 {\n-\n-                        // Stop the timer and do something else\n-                        let mut timer = timer;\n-                        timer.stop();\n-                        // Freeze timer so it can be captured\n-                        let timer = timer;\n-\n-                        let mut loop_ = timer.event_loop();\n-                        let mut timer2 = TimerWatcher::new(&mut loop_);\n-                        do timer2.start(10, 0) |timer2, _| {\n-\n-                            *count_ptr += 1;\n-\n-                            timer2.close(||());\n-\n-                            // Restart the original timer\n-                            let mut timer = timer;\n-                            do timer.start(1, 0) |timer, _| {\n-                                *count_ptr += 1;\n-                                timer.close(||());\n-                            }\n-                        }\n-                    }\n-                };\n-            }\n-            loop_.run();\n-            loop_.close();\n-            assert!(count == 12);\n-        }\n-    }\n-\n-}"}, {"sha": "f44c5ae8eff611b88f8ea635db0b57581ae25462", "filename": "src/libstd/rt/uv/tty.rs", "status": "removed", "additions": 0, "deletions": 84, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/886819cca1208210cb73892f8fe4b7b9140068dc/src%2Flibstd%2Frt%2Fuv%2Ftty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886819cca1208210cb73892f8fe4b7b9140068dc/src%2Flibstd%2Frt%2Fuv%2Ftty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Ftty.rs?ref=886819cca1208210cb73892f8fe4b7b9140068dc", "patch": "@@ -1,84 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use prelude::*;\n-use libc;\n-\n-use rt::uv;\n-use rt::uv::net;\n-use rt::uv::uvll;\n-\n-/// A process wraps the handle of the underlying uv_process_t.\n-pub struct TTY(*uvll::uv_tty_t);\n-\n-impl uv::Watcher for TTY {}\n-\n-impl TTY {\n-    #[fixed_stack_segment] #[inline(never)]\n-    pub fn new(loop_: &uv::Loop, fd: libc::c_int, readable: bool) ->\n-            Result<TTY, uv::UvError>\n-    {\n-        let handle = unsafe { uvll::malloc_handle(uvll::UV_TTY) };\n-        assert!(handle.is_not_null());\n-\n-        let ret = unsafe {\n-            uvll::tty_init(loop_.native_handle(), handle, fd as libc::c_int,\n-                           readable as libc::c_int)\n-        };\n-        match ret {\n-            0 => {\n-                let mut ret: TTY = uv::NativeHandle::from_native_handle(handle);\n-                ret.install_watcher_data();\n-                Ok(ret)\n-            }\n-            n => {\n-                unsafe { uvll::free_handle(handle); }\n-                Err(uv::UvError(n))\n-            }\n-        }\n-    }\n-\n-    pub fn as_stream(&self) -> net::StreamWatcher {\n-        net::StreamWatcher(**self as *uvll::uv_stream_t)\n-    }\n-\n-    #[fixed_stack_segment] #[inline(never)]\n-    pub fn set_mode(&self, raw: bool) -> Result<(), uv::UvError> {\n-        let raw = raw as libc::c_int;\n-        match unsafe { uvll::tty_set_mode(self.native_handle(), raw) } {\n-            0 => Ok(()),\n-            n => Err(uv::UvError(n))\n-        }\n-    }\n-\n-    #[fixed_stack_segment] #[inline(never)] #[allow(unused_mut)]\n-    pub fn get_winsize(&self) -> Result<(int, int), uv::UvError> {\n-        let mut width: libc::c_int = 0;\n-        let mut height: libc::c_int = 0;\n-        let widthptr: *libc::c_int = &width;\n-        let heightptr: *libc::c_int = &width;\n-\n-        match unsafe { uvll::tty_get_winsize(self.native_handle(),\n-                                             widthptr, heightptr) } {\n-            0 => Ok((width as int, height as int)),\n-            n => Err(uv::UvError(n))\n-        }\n-    }\n-}\n-\n-impl uv::NativeHandle<*uvll::uv_tty_t> for TTY {\n-    fn from_native_handle(handle: *uvll::uv_tty_t) -> TTY {\n-        TTY(handle)\n-    }\n-    fn native_handle(&self) -> *uvll::uv_tty_t {\n-        match self { &TTY(ptr) => ptr }\n-    }\n-}\n-"}, {"sha": "2d3ecbbd68907a6fe3ec096ae1852e43efa33a55", "filename": "src/libstd/rt/uv/uvio.rs", "status": "removed", "additions": 0, "deletions": 2527, "changes": 2527, "blob_url": "https://github.com/rust-lang/rust/blob/886819cca1208210cb73892f8fe4b7b9140068dc/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886819cca1208210cb73892f8fe4b7b9140068dc/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=886819cca1208210cb73892f8fe4b7b9140068dc", "patch": "@@ -1,2527 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use c_str::{ToCStr, CString};\n-use cast::transmute;\n-use cast;\n-use cell::Cell;\n-use clone::Clone;\n-use comm::{SendDeferred, SharedChan, Port, PortOne, GenericChan};\n-use libc::{c_int, c_uint, c_void, pid_t};\n-use ops::Drop;\n-use option::*;\n-use ptr;\n-use str;\n-use result::*;\n-use rt::io::IoError;\n-use rt::io::net::ip::{SocketAddr, IpAddr};\n-use rt::io::{standard_error, OtherIoError, SeekStyle, SeekSet, SeekCur, SeekEnd};\n-use rt::io::process::ProcessConfig;\n-use rt::kill::BlockedTask;\n-use rt::local::Local;\n-use rt::rtio::*;\n-use rt::sched::{Scheduler, SchedHandle};\n-use rt::tube::Tube;\n-use rt::task::Task;\n-use rt::uv::*;\n-use rt::uv::idle::IdleWatcher;\n-use rt::uv::net::{UvIpv4SocketAddr, UvIpv6SocketAddr};\n-use rt::uv::addrinfo::{GetAddrInfoRequest, accum_addrinfo};\n-use unstable::sync::Exclusive;\n-use path::{GenericPath, Path};\n-use libc::{lseek, off_t, O_CREAT, O_APPEND, O_TRUNC, O_RDWR, O_RDONLY, O_WRONLY,\n-          S_IRUSR, S_IWUSR, S_IRWXU};\n-use rt::io::{FileMode, FileAccess, OpenOrCreate, Open, Create,\n-             CreateOrTruncate, Append, Truncate, Read, Write, ReadWrite,\n-             FileStat};\n-use rt::io::signal::Signum;\n-use task;\n-use ai = rt::io::net::addrinfo;\n-\n-#[cfg(test)] use container::Container;\n-#[cfg(test)] use unstable::run_in_bare_thread;\n-#[cfg(test)] use rt::test::{spawntask,\n-                            next_test_ip4,\n-                            run_in_mt_newsched_task};\n-#[cfg(test)] use iter::{Iterator, range};\n-#[cfg(test)] use rt::comm::oneshot;\n-\n-// XXX we should not be calling uvll functions in here.\n-\n-trait HomingIO {\n-\n-    fn home<'r>(&'r mut self) -> &'r mut SchedHandle;\n-\n-    /// This function will move tasks to run on their home I/O scheduler. Note\n-    /// that this function does *not* pin the task to the I/O scheduler, but\n-    /// rather it simply moves it to running on the I/O scheduler.\n-    fn go_to_IO_home(&mut self) -> uint {\n-        use rt::sched::RunOnce;\n-\n-        let current_sched_id = do Local::borrow |sched: &mut Scheduler| {\n-            sched.sched_id()\n-        };\n-\n-        // Only need to invoke a context switch if we're not on the right\n-        // scheduler.\n-        if current_sched_id != self.home().sched_id {\n-            do task::unkillable { // FIXME(#8674)\n-                let scheduler: ~Scheduler = Local::take();\n-                do scheduler.deschedule_running_task_and_then |_, task| {\n-                    /* FIXME(#8674) if the task was already killed then wake\n-                     * will return None. In that case, the home pointer will\n-                     * never be set.\n-                     *\n-                     * RESOLUTION IDEA: Since the task is dead, we should\n-                     * just abort the IO action.\n-                     */\n-                    do task.wake().map |task| {\n-                        self.home().send(RunOnce(task));\n-                    };\n-                }\n-            }\n-        }\n-\n-        self.home().sched_id\n-    }\n-\n-    // XXX: dummy self parameter\n-    fn restore_original_home(_: Option<Self>, io_home: uint) {\n-        // It would truly be a sad day if we had moved off the home I/O\n-        // scheduler while we were doing I/O.\n-        assert_eq!(Local::borrow(|sched: &mut Scheduler| sched.sched_id()),\n-                   io_home);\n-\n-        // If we were a homed task, then we must send ourselves back to the\n-        // original scheduler. Otherwise, we can just return and keep running\n-        if !Task::on_appropriate_sched() {\n-            do task::unkillable { // FIXME(#8674)\n-                let scheduler: ~Scheduler = Local::take();\n-                do scheduler.deschedule_running_task_and_then |_, task| {\n-                    do task.wake().map |task| {\n-                        Scheduler::run_task(task);\n-                    };\n-                }\n-            }\n-        }\n-    }\n-\n-    fn home_for_io<A>(&mut self, io: &fn(&mut Self) -> A) -> A {\n-        let home = self.go_to_IO_home();\n-        let a = io(self); // do IO\n-        HomingIO::restore_original_home(None::<Self>, home);\n-        a // return the result of the IO\n-    }\n-\n-    fn home_for_io_consume<A>(mut self, io: &fn(Self) -> A) -> A {\n-        let home = self.go_to_IO_home();\n-        let a = io(self); // do IO\n-        HomingIO::restore_original_home(None::<Self>, home);\n-        a // return the result of the IO\n-    }\n-\n-    fn home_for_io_with_sched<A>(&mut self, io_sched: &fn(&mut Self, ~Scheduler) -> A) -> A {\n-        let home = self.go_to_IO_home();\n-        let a = do task::unkillable { // FIXME(#8674)\n-            let scheduler: ~Scheduler = Local::take();\n-            io_sched(self, scheduler) // do IO and scheduling action\n-        };\n-        HomingIO::restore_original_home(None::<Self>, home);\n-        a // return result of IO\n-    }\n-}\n-\n-// get a handle for the current scheduler\n-macro_rules! get_handle_to_current_scheduler(\n-    () => (do Local::borrow |sched: &mut Scheduler| { sched.make_handle() })\n-)\n-\n-enum SocketNameKind {\n-    TcpPeer,\n-    Tcp,\n-    Udp\n-}\n-\n-fn socket_name<T, U: Watcher + NativeHandle<*T>>(sk: SocketNameKind,\n-                                                 handle: U) -> Result<SocketAddr, IoError> {\n-    let getsockname = match sk {\n-        TcpPeer => uvll::tcp_getpeername,\n-        Tcp     => uvll::tcp_getsockname,\n-        Udp     => uvll::udp_getsockname,\n-    };\n-\n-    // Allocate a sockaddr_storage\n-    // since we don't know if it's ipv4 or ipv6\n-    let r_addr = unsafe { uvll::malloc_sockaddr_storage() };\n-\n-    let r = unsafe {\n-        getsockname(handle.native_handle() as *c_void, r_addr as *uvll::sockaddr_storage)\n-    };\n-\n-    if r != 0 {\n-        let status = status_to_maybe_uv_error(r);\n-        return Err(uv_error_to_io_error(status.unwrap()));\n-    }\n-\n-    let addr = unsafe {\n-        if uvll::is_ip6_addr(r_addr as *uvll::sockaddr) {\n-            net::uv_socket_addr_to_socket_addr(UvIpv6SocketAddr(r_addr as *uvll::sockaddr_in6))\n-        } else {\n-            net::uv_socket_addr_to_socket_addr(UvIpv4SocketAddr(r_addr as *uvll::sockaddr_in))\n-        }\n-    };\n-\n-    unsafe { uvll::free_sockaddr_storage(r_addr); }\n-\n-    Ok(addr)\n-\n-}\n-\n-// Obviously an Event Loop is always home.\n-pub struct UvEventLoop {\n-    priv uvio: UvIoFactory\n-}\n-\n-impl UvEventLoop {\n-    pub fn new() -> UvEventLoop {\n-        UvEventLoop {\n-            uvio: UvIoFactory(Loop::new())\n-        }\n-    }\n-}\n-\n-impl Drop for UvEventLoop {\n-    fn drop(&mut self) {\n-        self.uvio.uv_loop().close();\n-    }\n-}\n-\n-impl EventLoop for UvEventLoop {\n-    fn run(&mut self) {\n-        self.uvio.uv_loop().run();\n-    }\n-\n-    fn callback(&mut self, f: ~fn()) {\n-        let mut idle_watcher =  IdleWatcher::new(self.uvio.uv_loop());\n-        do idle_watcher.start |mut idle_watcher, status| {\n-            assert!(status.is_none());\n-            idle_watcher.stop();\n-            idle_watcher.close(||());\n-            f();\n-        }\n-    }\n-\n-    fn pausible_idle_callback(&mut self) -> ~PausibleIdleCallback {\n-        let idle_watcher = IdleWatcher::new(self.uvio.uv_loop());\n-        ~UvPausibleIdleCallback {\n-            watcher: idle_watcher,\n-            idle_flag: false,\n-            closed: false\n-        } as ~PausibleIdleCallback\n-    }\n-\n-    fn remote_callback(&mut self, f: ~fn()) -> ~RemoteCallback {\n-        ~UvRemoteCallback::new(self.uvio.uv_loop(), f) as ~RemoteCallback\n-    }\n-\n-    fn io<'a>(&'a mut self, f: &fn(&'a mut IoFactory)) {\n-        f(&mut self.uvio as &mut IoFactory)\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n-#[lang = \"event_loop_factory\"]\n-pub extern \"C\" fn new_loop() -> ~EventLoop {\n-    ~UvEventLoop::new() as ~EventLoop\n-}\n-\n-pub struct UvPausibleIdleCallback {\n-    priv watcher: IdleWatcher,\n-    priv idle_flag: bool,\n-    priv closed: bool\n-}\n-\n-impl PausibleIdleCallback for UvPausibleIdleCallback {\n-    #[inline]\n-    fn start(&mut self, f: ~fn()) {\n-        do self.watcher.start |_idle_watcher, _status| {\n-            f();\n-        };\n-        self.idle_flag = true;\n-    }\n-    #[inline]\n-    fn pause(&mut self) {\n-        if self.idle_flag == true {\n-            self.watcher.stop();\n-            self.idle_flag = false;\n-        }\n-    }\n-    #[inline]\n-    fn resume(&mut self) {\n-        if self.idle_flag == false {\n-            self.watcher.restart();\n-            self.idle_flag = true;\n-        }\n-    }\n-    #[inline]\n-    fn close(&mut self) {\n-        self.pause();\n-        if !self.closed {\n-            self.closed = true;\n-            self.watcher.close(||{});\n-        }\n-    }\n-}\n-\n-#[test]\n-fn test_callback_run_once() {\n-    do run_in_bare_thread {\n-        let mut event_loop = UvEventLoop::new();\n-        let mut count = 0;\n-        let count_ptr: *mut int = &mut count;\n-        do event_loop.callback {\n-            unsafe { *count_ptr += 1 }\n-        }\n-        event_loop.run();\n-        assert_eq!(count, 1);\n-    }\n-}\n-\n-// The entire point of async is to call into a loop from other threads so it does not need to home.\n-pub struct UvRemoteCallback {\n-    // The uv async handle for triggering the callback\n-    priv async: AsyncWatcher,\n-    // A flag to tell the callback to exit, set from the dtor. This is\n-    // almost never contested - only in rare races with the dtor.\n-    priv exit_flag: Exclusive<bool>\n-}\n-\n-impl UvRemoteCallback {\n-    pub fn new(loop_: &mut Loop, f: ~fn()) -> UvRemoteCallback {\n-        let exit_flag = Exclusive::new(false);\n-        let exit_flag_clone = exit_flag.clone();\n-        let async = do AsyncWatcher::new(loop_) |watcher, status| {\n-            assert!(status.is_none());\n-\n-            // The synchronization logic here is subtle. To review,\n-            // the uv async handle type promises that, after it is\n-            // triggered the remote callback is definitely called at\n-            // least once. UvRemoteCallback needs to maintain those\n-            // semantics while also shutting down cleanly from the\n-            // dtor. In our case that means that, when the\n-            // UvRemoteCallback dtor calls `async.send()`, here `f` is\n-            // always called later.\n-\n-            // In the dtor both the exit flag is set and the async\n-            // callback fired under a lock.  Here, before calling `f`,\n-            // we take the lock and check the flag. Because we are\n-            // checking the flag before calling `f`, and the flag is\n-            // set under the same lock as the send, then if the flag\n-            // is set then we're guaranteed to call `f` after the\n-            // final send.\n-\n-            // If the check was done after `f()` then there would be a\n-            // period between that call and the check where the dtor\n-            // could be called in the other thread, missing the final\n-            // callback while still destroying the handle.\n-\n-            let should_exit = unsafe {\n-                exit_flag_clone.with_imm(|&should_exit| should_exit)\n-            };\n-\n-            f();\n-\n-            if should_exit {\n-                watcher.close(||());\n-            }\n-\n-        };\n-        UvRemoteCallback {\n-            async: async,\n-            exit_flag: exit_flag\n-        }\n-    }\n-}\n-\n-impl RemoteCallback for UvRemoteCallback {\n-    fn fire(&mut self) { self.async.send() }\n-}\n-\n-impl Drop for UvRemoteCallback {\n-    fn drop(&mut self) {\n-        unsafe {\n-            let this: &mut UvRemoteCallback = cast::transmute_mut(self);\n-            do this.exit_flag.with |should_exit| {\n-                // NB: These two things need to happen atomically. Otherwise\n-                // the event handler could wake up due to a *previous*\n-                // signal and see the exit flag, destroying the handle\n-                // before the final send.\n-                *should_exit = true;\n-                this.async.send();\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test_remote {\n-    use cell::Cell;\n-    use rt::test::*;\n-    use rt::thread::Thread;\n-    use rt::tube::Tube;\n-    use rt::rtio::EventLoop;\n-    use rt::local::Local;\n-    use rt::sched::Scheduler;\n-\n-    #[test]\n-    fn test_uv_remote() {\n-        do run_in_mt_newsched_task {\n-            let mut tube = Tube::new();\n-            let tube_clone = tube.clone();\n-            let remote_cell = Cell::new_empty();\n-            do Local::borrow |sched: &mut Scheduler| {\n-                let tube_clone = tube_clone.clone();\n-                let tube_clone_cell = Cell::new(tube_clone);\n-                let remote = do sched.event_loop.remote_callback {\n-                    // This could be called multiple times\n-                    if !tube_clone_cell.is_empty() {\n-                        tube_clone_cell.take().send(1);\n-                    }\n-                };\n-                remote_cell.put_back(remote);\n-            }\n-            let thread = do Thread::start {\n-                remote_cell.take().fire();\n-            };\n-\n-            assert!(tube.recv() == 1);\n-            thread.join();\n-        }\n-    }\n-}\n-\n-pub struct UvIoFactory(Loop);\n-\n-impl UvIoFactory {\n-    pub fn uv_loop<'a>(&'a mut self) -> &'a mut Loop {\n-        match self { &UvIoFactory(ref mut ptr) => ptr }\n-    }\n-}\n-\n-/// Helper for a variety of simple uv_fs_* functions that\n-/// have no ret val\n-fn uv_fs_helper(loop_: &mut Loop, path: &CString,\n-                cb: ~fn(&mut FsRequest, &mut Loop, &CString,\n-                        ~fn(&FsRequest, Option<UvError>)))\n-        -> Result<(), IoError> {\n-    let result_cell = Cell::new_empty();\n-    let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n-    let path_cell = Cell::new(path);\n-    do task::unkillable { // FIXME(#8674)\n-        let scheduler: ~Scheduler = Local::take();\n-        let mut new_req = FsRequest::new();\n-        do scheduler.deschedule_running_task_and_then |_, task| {\n-            let task_cell = Cell::new(task);\n-            let path = path_cell.take();\n-            do cb(&mut new_req, loop_, path) |_, err| {\n-                let res = match err {\n-                    None => Ok(()),\n-                    Some(err) => Err(uv_error_to_io_error(err))\n-                };\n-                unsafe { (*result_cell_ptr).put_back(res); }\n-                let scheduler: ~Scheduler = Local::take();\n-                scheduler.resume_blocked_task_immediately(task_cell.take());\n-            };\n-        }\n-    }\n-    assert!(!result_cell.is_empty());\n-    return result_cell.take();\n-}\n-\n-impl IoFactory for UvIoFactory {\n-    // Connect to an address and return a new stream\n-    // NB: This blocks the task waiting on the connection.\n-    // It would probably be better to return a future\n-    fn tcp_connect(&mut self, addr: SocketAddr) -> Result<~RtioTcpStream, IoError> {\n-        // Create a cell in the task to hold the result. We will fill\n-        // the cell before resuming the task.\n-        let result_cell = Cell::new_empty();\n-        let result_cell_ptr: *Cell<Result<~RtioTcpStream, IoError>> = &result_cell;\n-\n-        // Block this task and take ownership, switch to scheduler context\n-        do task::unkillable { // FIXME(#8674)\n-            let scheduler: ~Scheduler = Local::take();\n-            do scheduler.deschedule_running_task_and_then |_, task| {\n-\n-                let mut tcp = TcpWatcher::new(self.uv_loop());\n-                let task_cell = Cell::new(task);\n-\n-                // Wait for a connection\n-                do tcp.connect(addr) |stream, status| {\n-                    match status {\n-                        None => {\n-                            let tcp = NativeHandle::from_native_handle(stream.native_handle());\n-                            let home = get_handle_to_current_scheduler!();\n-                            let res = Ok(~UvTcpStream { watcher: tcp, home: home }\n-                                                as ~RtioTcpStream);\n-\n-                            // Store the stream in the task's stack\n-                            unsafe { (*result_cell_ptr).put_back(res); }\n-\n-                            // Context switch\n-                            let scheduler: ~Scheduler = Local::take();\n-                            scheduler.resume_blocked_task_immediately(task_cell.take());\n-                        }\n-                        Some(_) => {\n-                            let task_cell = Cell::new(task_cell.take());\n-                            do stream.close {\n-                                let res = Err(uv_error_to_io_error(status.unwrap()));\n-                                unsafe { (*result_cell_ptr).put_back(res); }\n-                                let scheduler: ~Scheduler = Local::take();\n-                                scheduler.resume_blocked_task_immediately(task_cell.take());\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        assert!(!result_cell.is_empty());\n-        return result_cell.take();\n-    }\n-\n-    fn tcp_bind(&mut self, addr: SocketAddr) -> Result<~RtioTcpListener, IoError> {\n-        let mut watcher = TcpWatcher::new(self.uv_loop());\n-        match watcher.bind(addr) {\n-            Ok(_) => {\n-                let home = get_handle_to_current_scheduler!();\n-                Ok(~UvTcpListener::new(watcher, home) as ~RtioTcpListener)\n-            }\n-            Err(uverr) => {\n-                do task::unkillable { // FIXME(#8674)\n-                    let scheduler: ~Scheduler = Local::take();\n-                    do scheduler.deschedule_running_task_and_then |_, task| {\n-                        let task_cell = Cell::new(task);\n-                        do watcher.as_stream().close {\n-                            let scheduler: ~Scheduler = Local::take();\n-                            scheduler.resume_blocked_task_immediately(task_cell.take());\n-                        }\n-                    }\n-                    Err(uv_error_to_io_error(uverr))\n-                }\n-            }\n-        }\n-    }\n-\n-    fn udp_bind(&mut self, addr: SocketAddr) -> Result<~RtioUdpSocket, IoError> {\n-        let mut watcher = UdpWatcher::new(self.uv_loop());\n-        match watcher.bind(addr) {\n-            Ok(_) => {\n-                let home = get_handle_to_current_scheduler!();\n-                Ok(~UvUdpSocket { watcher: watcher, home: home } as ~RtioUdpSocket)\n-            }\n-            Err(uverr) => {\n-                do task::unkillable { // FIXME(#8674)\n-                    let scheduler: ~Scheduler = Local::take();\n-                    do scheduler.deschedule_running_task_and_then |_, task| {\n-                        let task_cell = Cell::new(task);\n-                        do watcher.close {\n-                            let scheduler: ~Scheduler = Local::take();\n-                            scheduler.resume_blocked_task_immediately(task_cell.take());\n-                        }\n-                    }\n-                    Err(uv_error_to_io_error(uverr))\n-                }\n-            }\n-        }\n-    }\n-\n-    fn timer_init(&mut self) -> Result<~RtioTimer, IoError> {\n-        let watcher = TimerWatcher::new(self.uv_loop());\n-        let home = get_handle_to_current_scheduler!();\n-        Ok(~UvTimer::new(watcher, home) as ~RtioTimer)\n-    }\n-\n-    fn fs_from_raw_fd(&mut self, fd: c_int, close: CloseBehavior) -> ~RtioFileStream {\n-        let loop_ = Loop {handle: self.uv_loop().native_handle()};\n-        let home = get_handle_to_current_scheduler!();\n-        ~UvFileStream::new(loop_, fd, close, home) as ~RtioFileStream\n-    }\n-\n-    fn fs_open(&mut self, path: &CString, fm: FileMode, fa: FileAccess)\n-        -> Result<~RtioFileStream, IoError> {\n-        let mut flags = match fm {\n-            Open => 0,\n-            Create => O_CREAT,\n-            OpenOrCreate => O_CREAT,\n-            Append => O_APPEND,\n-            Truncate => O_TRUNC,\n-            CreateOrTruncate => O_TRUNC | O_CREAT\n-        };\n-        flags = match fa {\n-            Read => flags | O_RDONLY,\n-            Write => flags | O_WRONLY,\n-            ReadWrite => flags | O_RDWR\n-        };\n-        let create_mode = match fm {\n-            Create|OpenOrCreate|CreateOrTruncate =>\n-                S_IRUSR | S_IWUSR,\n-            _ => 0\n-        };\n-        let result_cell = Cell::new_empty();\n-        let result_cell_ptr: *Cell<Result<~RtioFileStream,\n-                                           IoError>> = &result_cell;\n-        let path_cell = Cell::new(path);\n-        do task::unkillable { // FIXME(#8674)\n-            let scheduler: ~Scheduler = Local::take();\n-            let open_req = file::FsRequest::new();\n-            do scheduler.deschedule_running_task_and_then |_, task| {\n-                let task_cell = Cell::new(task);\n-                let path = path_cell.take();\n-                do open_req.open(self.uv_loop(), path, flags as int, create_mode as int)\n-                      |req,err| {\n-                    if err.is_none() {\n-                        let loop_ = Loop {handle: req.get_loop().native_handle()};\n-                        let home = get_handle_to_current_scheduler!();\n-                        let fd = req.get_result() as c_int;\n-                        let fs = ~UvFileStream::new(\n-                            loop_, fd, CloseSynchronously, home) as ~RtioFileStream;\n-                        let res = Ok(fs);\n-                        unsafe { (*result_cell_ptr).put_back(res); }\n-                        let scheduler: ~Scheduler = Local::take();\n-                        scheduler.resume_blocked_task_immediately(task_cell.take());\n-                    } else {\n-                        let res = Err(uv_error_to_io_error(err.unwrap()));\n-                        unsafe { (*result_cell_ptr).put_back(res); }\n-                        let scheduler: ~Scheduler = Local::take();\n-                        scheduler.resume_blocked_task_immediately(task_cell.take());\n-                    }\n-                };\n-            };\n-        };\n-        assert!(!result_cell.is_empty());\n-        return result_cell.take();\n-    }\n-\n-    fn fs_unlink(&mut self, path: &CString) -> Result<(), IoError> {\n-        do uv_fs_helper(self.uv_loop(), path) |unlink_req, l, p, cb| {\n-            do unlink_req.unlink(l, p) |req, err| {\n-                cb(req, err)\n-            };\n-        }\n-    }\n-    fn fs_stat(&mut self, path: &CString) -> Result<FileStat, IoError> {\n-        use str::StrSlice;\n-        let result_cell = Cell::new_empty();\n-        let result_cell_ptr: *Cell<Result<FileStat,\n-                                           IoError>> = &result_cell;\n-        let path_cell = Cell::new(path);\n-        do task::unkillable { // FIXME(#8674)\n-            let scheduler: ~Scheduler = Local::take();\n-            let stat_req = file::FsRequest::new();\n-            do scheduler.deschedule_running_task_and_then |_, task| {\n-                let task_cell = Cell::new(task);\n-                let path = path_cell.take();\n-                // Don't pick up the null byte\n-                let slice = path.as_bytes().slice(0, path.len());\n-                let path_instance = Cell::new(Path::new(slice));\n-                do stat_req.stat(self.uv_loop(), path) |req,err| {\n-                    let res = match err {\n-                        None => {\n-                            let stat = req.get_stat();\n-                            Ok(FileStat {\n-                                path: path_instance.take(),\n-                                is_file: stat.is_file(),\n-                                is_dir: stat.is_dir(),\n-                                device: stat.st_dev,\n-                                mode: stat.st_mode,\n-                                inode: stat.st_ino,\n-                                size: stat.st_size,\n-                                created: stat.st_ctim.tv_sec as u64,\n-                                modified: stat.st_mtim.tv_sec as u64,\n-                                accessed: stat.st_atim.tv_sec as u64\n-                            })\n-                        },\n-                        Some(e) => {\n-                            Err(uv_error_to_io_error(e))\n-                        }\n-                    };\n-                    unsafe { (*result_cell_ptr).put_back(res); }\n-                    let scheduler: ~Scheduler = Local::take();\n-                    scheduler.resume_blocked_task_immediately(task_cell.take());\n-                };\n-            };\n-        };\n-        assert!(!result_cell.is_empty());\n-        return result_cell.take();\n-    }\n-\n-    fn get_host_addresses(&mut self, host: Option<&str>, servname: Option<&str>,\n-                          hint: Option<ai::Hint>) -> Result<~[ai::Info], IoError> {\n-        let result_cell = Cell::new_empty();\n-        let result_cell_ptr: *Cell<Result<~[ai::Info], IoError>> = &result_cell;\n-        let host_ptr: *Option<&str> = &host;\n-        let servname_ptr: *Option<&str> = &servname;\n-        let hint_ptr: *Option<ai::Hint> = &hint;\n-        let addrinfo_req = GetAddrInfoRequest::new();\n-        let addrinfo_req_cell = Cell::new(addrinfo_req);\n-\n-        do task::unkillable { // FIXME(#8674)\n-            let scheduler: ~Scheduler = Local::take();\n-            do scheduler.deschedule_running_task_and_then |_, task| {\n-                let task_cell = Cell::new(task);\n-                let mut addrinfo_req = addrinfo_req_cell.take();\n-                unsafe {\n-                    do addrinfo_req.getaddrinfo(self.uv_loop(),\n-                                                *host_ptr, *servname_ptr,\n-                                                *hint_ptr) |_, addrinfo, err| {\n-                        let res = match err {\n-                            None => Ok(accum_addrinfo(addrinfo)),\n-                            Some(err) => Err(uv_error_to_io_error(err))\n-                        };\n-                        (*result_cell_ptr).put_back(res);\n-                        let scheduler: ~Scheduler = Local::take();\n-                        scheduler.resume_blocked_task_immediately(task_cell.take());\n-                    }\n-                }\n-            }\n-        }\n-        addrinfo_req.delete();\n-        assert!(!result_cell.is_empty());\n-        return result_cell.take();\n-    }\n-    fn fs_mkdir(&mut self, path: &CString) -> Result<(), IoError> {\n-        let mode = S_IRWXU as int;\n-        do uv_fs_helper(self.uv_loop(), path) |mkdir_req, l, p, cb| {\n-            do mkdir_req.mkdir(l, p, mode as int) |req, err| {\n-                cb(req, err)\n-            };\n-        }\n-    }\n-    fn fs_rmdir(&mut self, path: &CString) -> Result<(), IoError> {\n-        do uv_fs_helper(self.uv_loop(), path) |rmdir_req, l, p, cb| {\n-            do rmdir_req.rmdir(l, p) |req, err| {\n-                cb(req, err)\n-            };\n-        }\n-    }\n-    fn fs_readdir(&mut self, path: &CString, flags: c_int) ->\n-        Result<~[Path], IoError> {\n-        use str::StrSlice;\n-        let result_cell = Cell::new_empty();\n-        let result_cell_ptr: *Cell<Result<~[Path],\n-                                           IoError>> = &result_cell;\n-        let path_cell = Cell::new(path);\n-        do task::unkillable { // FIXME(#8674)\n-            let scheduler: ~Scheduler = Local::take();\n-            let stat_req = file::FsRequest::new();\n-            do scheduler.deschedule_running_task_and_then |_, task| {\n-                let task_cell = Cell::new(task);\n-                let path = path_cell.take();\n-                // Don't pick up the null byte\n-                let slice = path.as_bytes().slice(0, path.len());\n-                let path_parent = Cell::new(Path::new(slice));\n-                do stat_req.readdir(self.uv_loop(), path, flags) |req,err| {\n-                    let parent = path_parent.take();\n-                    let res = match err {\n-                        None => {\n-                            let mut paths = ~[];\n-                            do req.each_path |rel_path| {\n-                                let p = rel_path.as_bytes();\n-                                paths.push(parent.join(p.slice_to(rel_path.len())));\n-                            }\n-                            Ok(paths)\n-                        },\n-                        Some(e) => {\n-                            Err(uv_error_to_io_error(e))\n-                        }\n-                    };\n-                    unsafe { (*result_cell_ptr).put_back(res); }\n-                    let scheduler: ~Scheduler = Local::take();\n-                    scheduler.resume_blocked_task_immediately(task_cell.take());\n-                };\n-            };\n-        };\n-        assert!(!result_cell.is_empty());\n-        return result_cell.take();\n-    }\n-\n-    fn spawn(&mut self, config: ProcessConfig)\n-            -> Result<(~RtioProcess, ~[Option<~RtioPipe>]), IoError>\n-    {\n-        // Sadly, we must create the UvProcess before we actually call uv_spawn\n-        // so that the exit_cb can close over it and notify it when the process\n-        // has exited.\n-        let mut ret = ~UvProcess {\n-            process: Process::new(),\n-            home: None,\n-            exit_status: None,\n-            term_signal: None,\n-            exit_error: None,\n-            descheduled: None,\n-        };\n-        let ret_ptr = unsafe {\n-            *cast::transmute::<&~UvProcess, &*mut UvProcess>(&ret)\n-        };\n-\n-        // The purpose of this exit callback is to record the data about the\n-        // exit and then wake up the task which may be waiting for the process\n-        // to exit. This is all performed in the current io-loop, and the\n-        // implementation of UvProcess ensures that reading these fields always\n-        // occurs on the current io-loop.\n-        let exit_cb: ExitCallback = |_, exit_status, term_signal, error| {\n-            unsafe {\n-                assert!((*ret_ptr).exit_status.is_none());\n-                (*ret_ptr).exit_status = Some(exit_status);\n-                (*ret_ptr).term_signal = Some(term_signal);\n-                (*ret_ptr).exit_error = error;\n-                match (*ret_ptr).descheduled.take() {\n-                    Some(task) => {\n-                        let scheduler: ~Scheduler = Local::take();\n-                        scheduler.resume_blocked_task_immediately(task);\n-                    }\n-                    None => {}\n-                }\n-            }\n-        };\n-\n-        match ret.process.spawn(self.uv_loop(), config, exit_cb) {\n-            Ok(io) => {\n-                // Only now do we actually get a handle to this scheduler.\n-                ret.home = Some(get_handle_to_current_scheduler!());\n-                Ok((ret as ~RtioProcess,\n-                    io.move_iter().map(|p| p.map(|p| p as ~RtioPipe)).collect()))\n-            }\n-            Err(uverr) => {\n-                // We still need to close the process handle we created, but\n-                // that's taken care for us in the destructor of UvProcess\n-                Err(uv_error_to_io_error(uverr))\n-            }\n-        }\n-    }\n-\n-    fn unix_bind(&mut self, path: &CString) ->\n-        Result<~RtioUnixListener, IoError> {\n-        let mut pipe = UvUnboundPipe::new(self.uv_loop());\n-        match pipe.pipe.bind(path) {\n-            Ok(()) => Ok(~UvUnixListener::new(pipe) as ~RtioUnixListener),\n-            Err(e) => Err(uv_error_to_io_error(e)),\n-        }\n-    }\n-\n-    fn unix_connect(&mut self, path: &CString) -> Result<~RtioPipe, IoError> {\n-        let pipe = UvUnboundPipe::new(self.uv_loop());\n-        let mut rawpipe = pipe.pipe;\n-\n-        let result_cell = Cell::new_empty();\n-        let result_cell_ptr: *Cell<Result<~RtioPipe, IoError>> = &result_cell;\n-        let pipe_cell = Cell::new(pipe);\n-        let pipe_cell_ptr: *Cell<UvUnboundPipe> = &pipe_cell;\n-\n-        let scheduler: ~Scheduler = Local::take();\n-        do scheduler.deschedule_running_task_and_then |_, task| {\n-            let task_cell = Cell::new(task);\n-            do rawpipe.connect(path) |_stream, err| {\n-                let res = match err {\n-                    None => {\n-                        let pipe = unsafe { (*pipe_cell_ptr).take() };\n-                        Ok(~UvPipeStream::new(pipe) as ~RtioPipe)\n-                    }\n-                    Some(e) => Err(uv_error_to_io_error(e)),\n-                };\n-                unsafe { (*result_cell_ptr).put_back(res); }\n-                let scheduler: ~Scheduler = Local::take();\n-                scheduler.resume_blocked_task_immediately(task_cell.take());\n-            }\n-        }\n-\n-        assert!(!result_cell.is_empty());\n-        return result_cell.take();\n-    }\n-\n-    fn tty_open(&mut self, fd: c_int, readable: bool)\n-            -> Result<~RtioTTY, IoError> {\n-        match tty::TTY::new(self.uv_loop(), fd, readable) {\n-            Ok(tty) => Ok(~UvTTY {\n-                home: get_handle_to_current_scheduler!(),\n-                tty: tty,\n-                fd: fd,\n-            } as ~RtioTTY),\n-            Err(e) => Err(uv_error_to_io_error(e))\n-        }\n-    }\n-\n-    fn pipe_open(&mut self, fd: c_int) -> Result<~RtioPipe, IoError> {\n-        let mut pipe = UvUnboundPipe::new(self.uv_loop());\n-        match pipe.pipe.open(fd) {\n-            Ok(()) => Ok(~UvPipeStream::new(pipe) as ~RtioPipe),\n-            Err(e) => Err(uv_error_to_io_error(e))\n-        }\n-    }\n-\n-    fn signal(&mut self, signum: Signum, channel: SharedChan<Signum>)\n-        -> Result<~RtioSignal, IoError> {\n-        let watcher = SignalWatcher::new(self.uv_loop());\n-        let home = get_handle_to_current_scheduler!();\n-        let mut signal = ~UvSignal::new(watcher, home);\n-        match signal.watcher.start(signum, |_, _| channel.send_deferred(signum)) {\n-            Ok(()) => Ok(signal as ~RtioSignal),\n-            Err(e) => Err(uv_error_to_io_error(e)),\n-        }\n-    }\n-}\n-\n-pub struct UvTcpListener {\n-    priv watcher : TcpWatcher,\n-    priv home: SchedHandle,\n-}\n-\n-impl HomingIO for UvTcpListener {\n-    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n-}\n-\n-impl UvTcpListener {\n-    fn new(watcher: TcpWatcher, home: SchedHandle) -> UvTcpListener {\n-        UvTcpListener { watcher: watcher, home: home }\n-    }\n-}\n-\n-impl Drop for UvTcpListener {\n-    fn drop(&mut self) {\n-        do self.home_for_io_with_sched |self_, scheduler| {\n-            do scheduler.deschedule_running_task_and_then |_, task| {\n-                let task = Cell::new(task);\n-                do self_.watcher.as_stream().close {\n-                    let scheduler: ~Scheduler = Local::take();\n-                    scheduler.resume_blocked_task_immediately(task.take());\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl RtioSocket for UvTcpListener {\n-    fn socket_name(&mut self) -> Result<SocketAddr, IoError> {\n-        do self.home_for_io |self_| {\n-            socket_name(Tcp, self_.watcher)\n-        }\n-    }\n-}\n-\n-impl RtioTcpListener for UvTcpListener {\n-    fn listen(~self) -> Result<~RtioTcpAcceptor, IoError> {\n-        do self.home_for_io_consume |self_| {\n-            let acceptor = ~UvTcpAcceptor::new(self_);\n-            let incoming = Cell::new(acceptor.incoming.clone());\n-            let mut stream = acceptor.listener.watcher.as_stream();\n-            let res = do stream.listen |mut server, status| {\n-                do incoming.with_mut_ref |incoming| {\n-                    let inc = match status {\n-                        Some(_) => Err(standard_error(OtherIoError)),\n-                        None => {\n-                            let inc = TcpWatcher::new(&server.event_loop());\n-                            // first accept call in the callback guarenteed to succeed\n-                            server.accept(inc.as_stream());\n-                            let home = get_handle_to_current_scheduler!();\n-                            Ok(~UvTcpStream { watcher: inc, home: home }\n-                                    as ~RtioTcpStream)\n-                        }\n-                    };\n-                    incoming.send(inc);\n-                }\n-            };\n-            match res {\n-                Ok(()) => Ok(acceptor as ~RtioTcpAcceptor),\n-                Err(e) => Err(uv_error_to_io_error(e)),\n-            }\n-        }\n-    }\n-}\n-\n-pub struct UvTcpAcceptor {\n-    priv listener: UvTcpListener,\n-    priv incoming: Tube<Result<~RtioTcpStream, IoError>>,\n-}\n-\n-impl HomingIO for UvTcpAcceptor {\n-    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { self.listener.home() }\n-}\n-\n-impl UvTcpAcceptor {\n-    fn new(listener: UvTcpListener) -> UvTcpAcceptor {\n-        UvTcpAcceptor { listener: listener, incoming: Tube::new() }\n-    }\n-}\n-\n-impl RtioSocket for UvTcpAcceptor {\n-    fn socket_name(&mut self) -> Result<SocketAddr, IoError> {\n-        do self.home_for_io |self_| {\n-            socket_name(Tcp, self_.listener.watcher)\n-        }\n-    }\n-}\n-\n-fn accept_simultaneously(stream: StreamWatcher, a: int) -> Result<(), IoError> {\n-    let r = unsafe {\n-        uvll::tcp_simultaneous_accepts(stream.native_handle(), a as c_int)\n-    };\n-\n-    match status_to_maybe_uv_error(r) {\n-        Some(err) => Err(uv_error_to_io_error(err)),\n-        None => Ok(())\n-    }\n-}\n-\n-impl RtioTcpAcceptor for UvTcpAcceptor {\n-    fn accept(&mut self) -> Result<~RtioTcpStream, IoError> {\n-        do self.home_for_io |self_| {\n-            self_.incoming.recv()\n-        }\n-    }\n-\n-    fn accept_simultaneously(&mut self) -> Result<(), IoError> {\n-        do self.home_for_io |self_| {\n-            accept_simultaneously(self_.listener.watcher.as_stream(), 1)\n-        }\n-    }\n-\n-    fn dont_accept_simultaneously(&mut self) -> Result<(), IoError> {\n-        do self.home_for_io |self_| {\n-            accept_simultaneously(self_.listener.watcher.as_stream(), 0)\n-        }\n-    }\n-}\n-\n-fn read_stream(mut watcher: StreamWatcher,\n-               scheduler: ~Scheduler,\n-               buf: &mut [u8]) -> Result<uint, IoError> {\n-    let result_cell = Cell::new_empty();\n-    let result_cell_ptr: *Cell<Result<uint, IoError>> = &result_cell;\n-\n-    let buf_ptr: *&mut [u8] = &buf;\n-    do scheduler.deschedule_running_task_and_then |_sched, task| {\n-        let task_cell = Cell::new(task);\n-        // XXX: We shouldn't reallocate these callbacks every\n-        // call to read\n-        let alloc: AllocCallback = |_| unsafe {\n-            slice_to_uv_buf(*buf_ptr)\n-        };\n-        do watcher.read_start(alloc) |mut watcher, nread, _buf, status| {\n-\n-            // Stop reading so that no read callbacks are\n-            // triggered before the user calls `read` again.\n-            // XXX: Is there a performance impact to calling\n-            // stop here?\n-            watcher.read_stop();\n-\n-            let result = if status.is_none() {\n-                assert!(nread >= 0);\n-                Ok(nread as uint)\n-            } else {\n-                Err(uv_error_to_io_error(status.unwrap()))\n-            };\n-\n-            unsafe { (*result_cell_ptr).put_back(result); }\n-\n-            let scheduler: ~Scheduler = Local::take();\n-            scheduler.resume_blocked_task_immediately(task_cell.take());\n-        }\n-    }\n-\n-    assert!(!result_cell.is_empty());\n-    result_cell.take()\n-}\n-\n-fn write_stream(mut watcher: StreamWatcher,\n-                scheduler: ~Scheduler,\n-                buf: &[u8]) -> Result<(), IoError> {\n-    let result_cell = Cell::new_empty();\n-    let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n-    let buf_ptr: *&[u8] = &buf;\n-    do scheduler.deschedule_running_task_and_then |_, task| {\n-        let task_cell = Cell::new(task);\n-        let buf = unsafe { slice_to_uv_buf(*buf_ptr) };\n-        do watcher.write(buf) |_watcher, status| {\n-            let result = if status.is_none() {\n-                Ok(())\n-            } else {\n-                Err(uv_error_to_io_error(status.unwrap()))\n-            };\n-\n-            unsafe { (*result_cell_ptr).put_back(result); }\n-\n-            let scheduler: ~Scheduler = Local::take();\n-            scheduler.resume_blocked_task_immediately(task_cell.take());\n-        }\n-    }\n-\n-    assert!(!result_cell.is_empty());\n-    result_cell.take()\n-}\n-\n-pub struct UvUnboundPipe {\n-    pipe: Pipe,\n-    priv home: SchedHandle,\n-}\n-\n-impl UvUnboundPipe {\n-    /// Creates a new unbound pipe homed to the current scheduler, placed on the\n-    /// specified event loop\n-    pub fn new(loop_: &Loop) -> UvUnboundPipe {\n-        UvUnboundPipe {\n-            pipe: Pipe::new(loop_, false),\n-            home: get_handle_to_current_scheduler!(),\n-        }\n-    }\n-}\n-\n-impl HomingIO for UvUnboundPipe {\n-    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n-}\n-\n-impl Drop for UvUnboundPipe {\n-    fn drop(&mut self) {\n-        do self.home_for_io |self_| {\n-            let scheduler: ~Scheduler = Local::take();\n-            do scheduler.deschedule_running_task_and_then |_, task| {\n-                let task_cell = Cell::new(task);\n-                do self_.pipe.close {\n-                    let scheduler: ~Scheduler = Local::take();\n-                    scheduler.resume_blocked_task_immediately(task_cell.take());\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-pub struct UvPipeStream {\n-    priv inner: UvUnboundPipe,\n-}\n-\n-impl UvPipeStream {\n-    pub fn new(inner: UvUnboundPipe) -> UvPipeStream {\n-        UvPipeStream { inner: inner }\n-    }\n-}\n-\n-impl RtioPipe for UvPipeStream {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n-        do self.inner.home_for_io_with_sched |self_, scheduler| {\n-            read_stream(self_.pipe.as_stream(), scheduler, buf)\n-        }\n-    }\n-    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n-        do self.inner.home_for_io_with_sched |self_, scheduler| {\n-            write_stream(self_.pipe.as_stream(), scheduler, buf)\n-        }\n-    }\n-}\n-\n-pub struct UvTcpStream {\n-    priv watcher: TcpWatcher,\n-    priv home: SchedHandle,\n-}\n-\n-impl HomingIO for UvTcpStream {\n-    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n-}\n-\n-impl Drop for UvTcpStream {\n-    fn drop(&mut self) {\n-        do self.home_for_io_with_sched |self_, scheduler| {\n-            do scheduler.deschedule_running_task_and_then |_, task| {\n-                let task_cell = Cell::new(task);\n-                do self_.watcher.as_stream().close {\n-                    let scheduler: ~Scheduler = Local::take();\n-                    scheduler.resume_blocked_task_immediately(task_cell.take());\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl RtioSocket for UvTcpStream {\n-    fn socket_name(&mut self) -> Result<SocketAddr, IoError> {\n-        do self.home_for_io |self_| {\n-            socket_name(Tcp, self_.watcher)\n-        }\n-    }\n-}\n-\n-impl RtioTcpStream for UvTcpStream {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n-        do self.home_for_io_with_sched |self_, scheduler| {\n-            read_stream(self_.watcher.as_stream(), scheduler, buf)\n-        }\n-    }\n-\n-    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n-        do self.home_for_io_with_sched |self_, scheduler| {\n-            write_stream(self_.watcher.as_stream(), scheduler, buf)\n-        }\n-    }\n-\n-    fn peer_name(&mut self) -> Result<SocketAddr, IoError> {\n-        do self.home_for_io |self_| {\n-            socket_name(TcpPeer, self_.watcher)\n-        }\n-    }\n-\n-    fn control_congestion(&mut self) -> Result<(), IoError> {\n-        do self.home_for_io |self_| {\n-            let r = unsafe { uvll::tcp_nodelay(self_.watcher.native_handle(), 0 as c_int) };\n-\n-            match status_to_maybe_uv_error(r) {\n-                Some(err) => Err(uv_error_to_io_error(err)),\n-                None => Ok(())\n-            }\n-        }\n-    }\n-\n-    fn nodelay(&mut self) -> Result<(), IoError> {\n-        do self.home_for_io |self_| {\n-            let r = unsafe { uvll::tcp_nodelay(self_.watcher.native_handle(), 1 as c_int) };\n-\n-            match status_to_maybe_uv_error(r) {\n-                Some(err) => Err(uv_error_to_io_error(err)),\n-                None => Ok(())\n-            }\n-        }\n-    }\n-\n-    fn keepalive(&mut self, delay_in_seconds: uint) -> Result<(), IoError> {\n-        do self.home_for_io |self_| {\n-            let r = unsafe {\n-                uvll::tcp_keepalive(self_.watcher.native_handle(), 1 as c_int,\n-                                    delay_in_seconds as c_uint)\n-            };\n-\n-            match status_to_maybe_uv_error(r) {\n-                Some(err) => Err(uv_error_to_io_error(err)),\n-                None => Ok(())\n-            }\n-        }\n-    }\n-\n-    fn letdie(&mut self) -> Result<(), IoError> {\n-        do self.home_for_io |self_| {\n-            let r = unsafe {\n-                uvll::tcp_keepalive(self_.watcher.native_handle(), 0 as c_int, 0 as c_uint)\n-            };\n-\n-            match status_to_maybe_uv_error(r) {\n-                Some(err) => Err(uv_error_to_io_error(err)),\n-                None => Ok(())\n-            }\n-        }\n-    }\n-}\n-\n-pub struct UvUdpSocket {\n-    priv watcher: UdpWatcher,\n-    priv home: SchedHandle,\n-}\n-\n-impl HomingIO for UvUdpSocket {\n-    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n-}\n-\n-impl Drop for UvUdpSocket {\n-    fn drop(&mut self) {\n-        do self.home_for_io_with_sched |self_, scheduler| {\n-            do scheduler.deschedule_running_task_and_then |_, task| {\n-                let task_cell = Cell::new(task);\n-                do self_.watcher.close {\n-                    let scheduler: ~Scheduler = Local::take();\n-                    scheduler.resume_blocked_task_immediately(task_cell.take());\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl RtioSocket for UvUdpSocket {\n-    fn socket_name(&mut self) -> Result<SocketAddr, IoError> {\n-        do self.home_for_io |self_| {\n-            socket_name(Udp, self_.watcher)\n-        }\n-    }\n-}\n-\n-impl RtioUdpSocket for UvUdpSocket {\n-    fn recvfrom(&mut self, buf: &mut [u8]) -> Result<(uint, SocketAddr), IoError> {\n-        do self.home_for_io_with_sched |self_, scheduler| {\n-            let result_cell = Cell::new_empty();\n-            let result_cell_ptr: *Cell<Result<(uint, SocketAddr), IoError>> = &result_cell;\n-\n-            let buf_ptr: *&mut [u8] = &buf;\n-            do scheduler.deschedule_running_task_and_then |_, task| {\n-                let task_cell = Cell::new(task);\n-                let alloc: AllocCallback = |_| unsafe { slice_to_uv_buf(*buf_ptr) };\n-                do self_.watcher.recv_start(alloc) |mut watcher, nread, _buf, addr, flags, status| {\n-                    let _ = flags; // /XXX add handling for partials?\n-\n-                    watcher.recv_stop();\n-\n-                    let result = match status {\n-                        None => {\n-                            assert!(nread >= 0);\n-                            Ok((nread as uint, addr))\n-                        }\n-                        Some(err) => Err(uv_error_to_io_error(err)),\n-                    };\n-\n-                    unsafe { (*result_cell_ptr).put_back(result); }\n-\n-                    let scheduler: ~Scheduler = Local::take();\n-                    scheduler.resume_blocked_task_immediately(task_cell.take());\n-                }\n-            }\n-\n-            assert!(!result_cell.is_empty());\n-            result_cell.take()\n-        }\n-    }\n-\n-    fn sendto(&mut self, buf: &[u8], dst: SocketAddr) -> Result<(), IoError> {\n-        do self.home_for_io_with_sched |self_, scheduler| {\n-            let result_cell = Cell::new_empty();\n-            let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n-            let buf_ptr: *&[u8] = &buf;\n-            do scheduler.deschedule_running_task_and_then |_, task| {\n-                let task_cell = Cell::new(task);\n-                let buf = unsafe { slice_to_uv_buf(*buf_ptr) };\n-                do self_.watcher.send(buf, dst) |_watcher, status| {\n-\n-                    let result = match status {\n-                        None => Ok(()),\n-                        Some(err) => Err(uv_error_to_io_error(err)),\n-                    };\n-\n-                    unsafe { (*result_cell_ptr).put_back(result); }\n-\n-                    let scheduler: ~Scheduler = Local::take();\n-                    scheduler.resume_blocked_task_immediately(task_cell.take());\n-                }\n-            }\n-\n-            assert!(!result_cell.is_empty());\n-            result_cell.take()\n-        }\n-    }\n-\n-    fn join_multicast(&mut self, multi: IpAddr) -> Result<(), IoError> {\n-        do self.home_for_io |self_| {\n-            let r = unsafe {\n-                do multi.to_str().with_c_str |m_addr| {\n-                    uvll::udp_set_membership(self_.watcher.native_handle(), m_addr,\n-                                             ptr::null(), uvll::UV_JOIN_GROUP)\n-                }\n-            };\n-\n-            match status_to_maybe_uv_error(r) {\n-                Some(err) => Err(uv_error_to_io_error(err)),\n-                None => Ok(())\n-            }\n-        }\n-    }\n-\n-    fn leave_multicast(&mut self, multi: IpAddr) -> Result<(), IoError> {\n-        do self.home_for_io |self_| {\n-            let r = unsafe {\n-                do multi.to_str().with_c_str |m_addr| {\n-                    uvll::udp_set_membership(self_.watcher.native_handle(), m_addr,\n-                                             ptr::null(), uvll::UV_LEAVE_GROUP)\n-                }\n-            };\n-\n-            match status_to_maybe_uv_error(r) {\n-                Some(err) => Err(uv_error_to_io_error(err)),\n-                None => Ok(())\n-            }\n-        }\n-    }\n-\n-    fn loop_multicast_locally(&mut self) -> Result<(), IoError> {\n-        do self.home_for_io |self_| {\n-\n-            let r = unsafe {\n-                uvll::udp_set_multicast_loop(self_.watcher.native_handle(), 1 as c_int)\n-            };\n-\n-            match status_to_maybe_uv_error(r) {\n-                Some(err) => Err(uv_error_to_io_error(err)),\n-                None => Ok(())\n-            }\n-        }\n-    }\n-\n-    fn dont_loop_multicast_locally(&mut self) -> Result<(), IoError> {\n-        do self.home_for_io |self_| {\n-\n-            let r = unsafe {\n-                uvll::udp_set_multicast_loop(self_.watcher.native_handle(), 0 as c_int)\n-            };\n-\n-            match status_to_maybe_uv_error(r) {\n-                Some(err) => Err(uv_error_to_io_error(err)),\n-                None => Ok(())\n-            }\n-        }\n-    }\n-\n-    fn multicast_time_to_live(&mut self, ttl: int) -> Result<(), IoError> {\n-        do self.home_for_io |self_| {\n-\n-            let r = unsafe {\n-                uvll::udp_set_multicast_ttl(self_.watcher.native_handle(), ttl as c_int)\n-            };\n-\n-            match status_to_maybe_uv_error(r) {\n-                Some(err) => Err(uv_error_to_io_error(err)),\n-                None => Ok(())\n-            }\n-        }\n-    }\n-\n-    fn time_to_live(&mut self, ttl: int) -> Result<(), IoError> {\n-        do self.home_for_io |self_| {\n-\n-            let r = unsafe {\n-                uvll::udp_set_ttl(self_.watcher.native_handle(), ttl as c_int)\n-            };\n-\n-            match status_to_maybe_uv_error(r) {\n-                Some(err) => Err(uv_error_to_io_error(err)),\n-                None => Ok(())\n-            }\n-        }\n-    }\n-\n-    fn hear_broadcasts(&mut self) -> Result<(), IoError> {\n-        do self.home_for_io |self_| {\n-\n-            let r = unsafe {\n-                uvll::udp_set_broadcast(self_.watcher.native_handle(), 1 as c_int)\n-            };\n-\n-            match status_to_maybe_uv_error(r) {\n-                Some(err) => Err(uv_error_to_io_error(err)),\n-                None => Ok(())\n-            }\n-        }\n-    }\n-\n-    fn ignore_broadcasts(&mut self) -> Result<(), IoError> {\n-        do self.home_for_io |self_| {\n-\n-            let r = unsafe {\n-                uvll::udp_set_broadcast(self_.watcher.native_handle(), 0 as c_int)\n-            };\n-\n-            match status_to_maybe_uv_error(r) {\n-                Some(err) => Err(uv_error_to_io_error(err)),\n-                None => Ok(())\n-            }\n-        }\n-    }\n-}\n-\n-pub struct UvTimer {\n-    priv watcher: timer::TimerWatcher,\n-    priv home: SchedHandle,\n-}\n-\n-impl HomingIO for UvTimer {\n-    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n-}\n-\n-impl UvTimer {\n-    fn new(w: timer::TimerWatcher, home: SchedHandle) -> UvTimer {\n-        UvTimer { watcher: w, home: home }\n-    }\n-}\n-\n-impl Drop for UvTimer {\n-    fn drop(&mut self) {\n-        do self.home_for_io_with_sched |self_, scheduler| {\n-            rtdebug!(\"closing UvTimer\");\n-            do scheduler.deschedule_running_task_and_then |_, task| {\n-                let task_cell = Cell::new(task);\n-                do self_.watcher.close {\n-                    let scheduler: ~Scheduler = Local::take();\n-                    scheduler.resume_blocked_task_immediately(task_cell.take());\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl RtioTimer for UvTimer {\n-    fn sleep(&mut self, msecs: u64) {\n-        do self.home_for_io_with_sched |self_, scheduler| {\n-            do scheduler.deschedule_running_task_and_then |_sched, task| {\n-                rtdebug!(\"sleep: entered scheduler context\");\n-                let task_cell = Cell::new(task);\n-                do self_.watcher.start(msecs, 0) |_, status| {\n-                    assert!(status.is_none());\n-                    let scheduler: ~Scheduler = Local::take();\n-                    scheduler.resume_blocked_task_immediately(task_cell.take());\n-                }\n-            }\n-            self_.watcher.stop();\n-        }\n-    }\n-\n-    fn oneshot(&mut self, msecs: u64) -> PortOne<()> {\n-        use comm::oneshot;\n-\n-        let (port, chan) = oneshot();\n-        let chan = Cell::new(chan);\n-        do self.home_for_io |self_| {\n-            let chan = Cell::new(chan.take());\n-            do self_.watcher.start(msecs, 0) |_, status| {\n-                assert!(status.is_none());\n-                assert!(!chan.is_empty());\n-                chan.take().send_deferred(());\n-            }\n-        }\n-\n-        return port;\n-    }\n-\n-    fn period(&mut self, msecs: u64) -> Port<()> {\n-        use comm::stream;\n-\n-        let (port, chan) = stream();\n-        let chan = Cell::new(chan);\n-        do self.home_for_io |self_| {\n-            let chan = Cell::new(chan.take());\n-            do self_.watcher.start(msecs, msecs) |_, status| {\n-                assert!(status.is_none());\n-                do chan.with_ref |chan| {\n-                    chan.send_deferred(());\n-                }\n-            }\n-        }\n-\n-        return port;\n-    }\n-}\n-\n-pub struct UvFileStream {\n-    priv loop_: Loop,\n-    priv fd: c_int,\n-    priv close: CloseBehavior,\n-    priv home: SchedHandle,\n-}\n-\n-impl HomingIO for UvFileStream {\n-    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n-}\n-\n-impl UvFileStream {\n-    fn new(loop_: Loop, fd: c_int, close: CloseBehavior,\n-           home: SchedHandle) -> UvFileStream {\n-        UvFileStream {\n-            loop_: loop_,\n-            fd: fd,\n-            close: close,\n-            home: home,\n-        }\n-    }\n-    fn base_read(&mut self, buf: &mut [u8], offset: i64) -> Result<int, IoError> {\n-        let result_cell = Cell::new_empty();\n-        let result_cell_ptr: *Cell<Result<int, IoError>> = &result_cell;\n-        let buf_ptr: *&mut [u8] = &buf;\n-        do self.home_for_io_with_sched |self_, scheduler| {\n-            do scheduler.deschedule_running_task_and_then |_, task| {\n-                let buf = unsafe { slice_to_uv_buf(*buf_ptr) };\n-                let task_cell = Cell::new(task);\n-                let read_req = file::FsRequest::new();\n-                do read_req.read(&self_.loop_, self_.fd, buf, offset) |req, uverr| {\n-                    let res = match uverr  {\n-                        None => Ok(req.get_result() as int),\n-                        Some(err) => Err(uv_error_to_io_error(err))\n-                    };\n-                    unsafe { (*result_cell_ptr).put_back(res); }\n-                    let scheduler: ~Scheduler = Local::take();\n-                    scheduler.resume_blocked_task_immediately(task_cell.take());\n-                }\n-            }\n-        }\n-        result_cell.take()\n-    }\n-    fn base_write(&mut self, buf: &[u8], offset: i64) -> Result<(), IoError> {\n-        let result_cell = Cell::new_empty();\n-        let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n-        let buf_ptr: *&[u8] = &buf;\n-        do self.home_for_io_with_sched |self_, scheduler| {\n-            do scheduler.deschedule_running_task_and_then |_, task| {\n-                let buf = unsafe { slice_to_uv_buf(*buf_ptr) };\n-                let task_cell = Cell::new(task);\n-                let write_req = file::FsRequest::new();\n-                do write_req.write(&self_.loop_, self_.fd, buf, offset) |_, uverr| {\n-                    let res = match uverr  {\n-                        None => Ok(()),\n-                        Some(err) => Err(uv_error_to_io_error(err))\n-                    };\n-                    unsafe { (*result_cell_ptr).put_back(res); }\n-                    let scheduler: ~Scheduler = Local::take();\n-                    scheduler.resume_blocked_task_immediately(task_cell.take());\n-                }\n-            }\n-        }\n-        result_cell.take()\n-    }\n-    fn seek_common(&mut self, pos: i64, whence: c_int) ->\n-        Result<u64, IoError>{\n-        #[fixed_stack_segment]; #[inline(never)];\n-        unsafe {\n-            match lseek(self.fd, pos as off_t, whence) {\n-                -1 => {\n-                    Err(IoError {\n-                        kind: OtherIoError,\n-                        desc: \"Failed to lseek.\",\n-                        detail: None\n-                    })\n-                },\n-                n => Ok(n as u64)\n-            }\n-        }\n-    }\n-}\n-\n-impl Drop for UvFileStream {\n-    fn drop(&mut self) {\n-        match self.close {\n-            DontClose => {}\n-            CloseAsynchronously => {\n-                let close_req = file::FsRequest::new();\n-                do close_req.close(&self.loop_, self.fd) |_,_| {}\n-            }\n-            CloseSynchronously => {\n-                do self.home_for_io_with_sched |self_, scheduler| {\n-                    do scheduler.deschedule_running_task_and_then |_, task| {\n-                        let task_cell = Cell::new(task);\n-                        let close_req = file::FsRequest::new();\n-                        do close_req.close(&self_.loop_, self_.fd) |_,_| {\n-                            let scheduler: ~Scheduler = Local::take();\n-                            scheduler.resume_blocked_task_immediately(task_cell.take());\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl RtioFileStream for UvFileStream {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<int, IoError> {\n-        self.base_read(buf, -1)\n-    }\n-    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n-        self.base_write(buf, -1)\n-    }\n-    fn pread(&mut self, buf: &mut [u8], offset: u64) -> Result<int, IoError> {\n-        self.base_read(buf, offset as i64)\n-    }\n-    fn pwrite(&mut self, buf: &[u8], offset: u64) -> Result<(), IoError> {\n-        self.base_write(buf, offset as i64)\n-    }\n-    fn seek(&mut self, pos: i64, whence: SeekStyle) -> Result<u64, IoError> {\n-        use libc::{SEEK_SET, SEEK_CUR, SEEK_END};\n-        let whence = match whence {\n-            SeekSet => SEEK_SET,\n-            SeekCur => SEEK_CUR,\n-            SeekEnd => SEEK_END\n-        };\n-        self.seek_common(pos, whence)\n-    }\n-    fn tell(&self) -> Result<u64, IoError> {\n-        use libc::SEEK_CUR;\n-        // this is temporary\n-        let self_ = unsafe { cast::transmute::<&UvFileStream, &mut UvFileStream>(self) };\n-        self_.seek_common(0, SEEK_CUR)\n-    }\n-    fn flush(&mut self) -> Result<(), IoError> {\n-        Ok(())\n-    }\n-}\n-\n-pub struct UvProcess {\n-    priv process: process::Process,\n-\n-    // Sadly, this structure must be created before we return it, so in that\n-    // brief interim the `home` is None.\n-    priv home: Option<SchedHandle>,\n-\n-    // All None until the process exits (exit_error may stay None)\n-    priv exit_status: Option<int>,\n-    priv term_signal: Option<int>,\n-    priv exit_error: Option<UvError>,\n-\n-    // Used to store which task to wake up from the exit_cb\n-    priv descheduled: Option<BlockedTask>,\n-}\n-\n-impl HomingIO for UvProcess {\n-    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { self.home.get_mut_ref() }\n-}\n-\n-impl Drop for UvProcess {\n-    fn drop(&mut self) {\n-        let close = |self_: &mut UvProcess| {\n-            let scheduler: ~Scheduler = Local::take();\n-            do scheduler.deschedule_running_task_and_then |_, task| {\n-                let task = Cell::new(task);\n-                do self_.process.close {\n-                    let scheduler: ~Scheduler = Local::take();\n-                    scheduler.resume_blocked_task_immediately(task.take());\n-                }\n-            }\n-        };\n-\n-        // If home is none, then this process never actually successfully\n-        // spawned, so there's no need to switch event loops\n-        if self.home.is_none() {\n-            close(self)\n-        } else {\n-            self.home_for_io(close)\n-        }\n-    }\n-}\n-\n-impl RtioProcess for UvProcess {\n-    fn id(&self) -> pid_t {\n-        self.process.pid()\n-    }\n-\n-    fn kill(&mut self, signal: int) -> Result<(), IoError> {\n-        do self.home_for_io |self_| {\n-            match self_.process.kill(signal) {\n-                Ok(()) => Ok(()),\n-                Err(uverr) => Err(uv_error_to_io_error(uverr))\n-            }\n-        }\n-    }\n-\n-    fn wait(&mut self) -> int {\n-        // Make sure (on the home scheduler) that we have an exit status listed\n-        do self.home_for_io |self_| {\n-            match self_.exit_status {\n-                Some(*) => {}\n-                None => {\n-                    // If there's no exit code previously listed, then the\n-                    // process's exit callback has yet to be invoked. We just\n-                    // need to deschedule ourselves and wait to be reawoken.\n-                    let scheduler: ~Scheduler = Local::take();\n-                    do scheduler.deschedule_running_task_and_then |_, task| {\n-                        assert!(self_.descheduled.is_none());\n-                        self_.descheduled = Some(task);\n-                    }\n-                    assert!(self_.exit_status.is_some());\n-                }\n-            }\n-        }\n-\n-        self.exit_status.unwrap()\n-    }\n-}\n-\n-pub struct UvUnixListener {\n-    priv inner: UvUnboundPipe\n-}\n-\n-impl HomingIO for UvUnixListener {\n-    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { self.inner.home() }\n-}\n-\n-impl UvUnixListener {\n-    fn new(pipe: UvUnboundPipe) -> UvUnixListener {\n-        UvUnixListener { inner: pipe }\n-    }\n-}\n-\n-impl RtioUnixListener for UvUnixListener {\n-    fn listen(~self) -> Result<~RtioUnixAcceptor, IoError> {\n-        do self.home_for_io_consume |self_| {\n-            let acceptor = ~UvUnixAcceptor::new(self_);\n-            let incoming = Cell::new(acceptor.incoming.clone());\n-            let mut stream = acceptor.listener.inner.pipe.as_stream();\n-            let res = do stream.listen |mut server, status| {\n-                do incoming.with_mut_ref |incoming| {\n-                    let inc = match status {\n-                        Some(e) => Err(uv_error_to_io_error(e)),\n-                        None => {\n-                            let pipe = UvUnboundPipe::new(&server.event_loop());\n-                            server.accept(pipe.pipe.as_stream());\n-                            Ok(~UvPipeStream::new(pipe) as ~RtioPipe)\n-                        }\n-                    };\n-                    incoming.send(inc);\n-                }\n-            };\n-            match res {\n-                Ok(()) => Ok(acceptor as ~RtioUnixAcceptor),\n-                Err(e) => Err(uv_error_to_io_error(e)),\n-            }\n-        }\n-    }\n-}\n-\n-pub struct UvTTY {\n-    tty: tty::TTY,\n-    home: SchedHandle,\n-    fd: c_int,\n-}\n-\n-impl HomingIO for UvTTY {\n-    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n-}\n-\n-impl Drop for UvTTY {\n-    fn drop(&mut self) {\n-        // TTY handles are used for the logger in a task, so this destructor is\n-        // run when a task is destroyed. When a task is being destroyed, a local\n-        // scheduler isn't available, so we can't do the normal \"take the\n-        // scheduler and resume once close is done\". Instead close operations on\n-        // a TTY are asynchronous.\n-        self.tty.close_async();\n-    }\n-}\n-\n-impl RtioTTY for UvTTY {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n-        do self.home_for_io_with_sched |self_, scheduler| {\n-            read_stream(self_.tty.as_stream(), scheduler, buf)\n-        }\n-    }\n-\n-    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n-        do self.home_for_io_with_sched |self_, scheduler| {\n-            write_stream(self_.tty.as_stream(), scheduler, buf)\n-        }\n-    }\n-\n-    fn set_raw(&mut self, raw: bool) -> Result<(), IoError> {\n-        do self.home_for_io |self_| {\n-            match self_.tty.set_mode(raw) {\n-                Ok(p) => Ok(p), Err(e) => Err(uv_error_to_io_error(e))\n-            }\n-        }\n-    }\n-\n-    fn get_winsize(&mut self) -> Result<(int, int), IoError> {\n-        do self.home_for_io |self_| {\n-            match self_.tty.get_winsize() {\n-                Ok(p) => Ok(p), Err(e) => Err(uv_error_to_io_error(e))\n-            }\n-        }\n-    }\n-\n-    fn isatty(&self) -> bool {\n-        unsafe { uvll::guess_handle(self.fd) == uvll::UV_TTY as c_int }\n-    }\n-}\n-\n-pub struct UvUnixAcceptor {\n-    listener: UvUnixListener,\n-    incoming: Tube<Result<~RtioPipe, IoError>>,\n-}\n-\n-impl HomingIO for UvUnixAcceptor {\n-    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { self.listener.home() }\n-}\n-\n-impl UvUnixAcceptor {\n-    fn new(listener: UvUnixListener) -> UvUnixAcceptor {\n-        UvUnixAcceptor { listener: listener, incoming: Tube::new() }\n-    }\n-}\n-\n-impl RtioUnixAcceptor for UvUnixAcceptor {\n-    fn accept(&mut self) -> Result<~RtioPipe, IoError> {\n-        do self.home_for_io |self_| {\n-            self_.incoming.recv()\n-        }\n-    }\n-\n-    fn accept_simultaneously(&mut self) -> Result<(), IoError> {\n-        do self.home_for_io |self_| {\n-            accept_simultaneously(self_.listener.inner.pipe.as_stream(), 1)\n-        }\n-    }\n-\n-    fn dont_accept_simultaneously(&mut self) -> Result<(), IoError> {\n-        do self.home_for_io |self_| {\n-            accept_simultaneously(self_.listener.inner.pipe.as_stream(), 0)\n-        }\n-    }\n-}\n-\n-pub struct UvSignal {\n-    watcher: signal::SignalWatcher,\n-    home: SchedHandle,\n-}\n-\n-impl HomingIO for UvSignal {\n-    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n-}\n-\n-impl UvSignal {\n-    fn new(w: signal::SignalWatcher, home: SchedHandle) -> UvSignal {\n-        UvSignal { watcher: w, home: home }\n-    }\n-}\n-\n-impl RtioSignal for UvSignal {}\n-\n-impl Drop for UvSignal {\n-    fn drop(&mut self) {\n-        do self.home_for_io_with_sched |self_, scheduler| {\n-            rtdebug!(\"closing UvSignal\");\n-            do scheduler.deschedule_running_task_and_then |_, task| {\n-                let task_cell = Cell::new(task);\n-                do self_.watcher.close {\n-                    let scheduler: ~Scheduler = Local::take();\n-                    scheduler.resume_blocked_task_immediately(task_cell.take());\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-// this function is full of lies\n-unsafe fn local_io() -> &'static mut IoFactory {\n-    do Local::borrow |sched: &mut Scheduler| {\n-        let mut io = None;\n-        sched.event_loop.io(|i| io = Some(i));\n-        cast::transmute(io.unwrap())\n-    }\n-}\n-\n-#[test]\n-fn test_simple_io_no_connect() {\n-    do run_in_mt_newsched_task {\n-        unsafe {\n-            let io = local_io();\n-            let addr = next_test_ip4();\n-            let maybe_chan = io.tcp_connect(addr);\n-            assert!(maybe_chan.is_err());\n-        }\n-    }\n-}\n-\n-#[test]\n-fn test_simple_udp_io_bind_only() {\n-    do run_in_mt_newsched_task {\n-        unsafe {\n-            let io = local_io();\n-            let addr = next_test_ip4();\n-            let maybe_socket = io.udp_bind(addr);\n-            assert!(maybe_socket.is_ok());\n-        }\n-    }\n-}\n-\n-#[test]\n-fn test_simple_homed_udp_io_bind_then_move_task_then_home_and_close() {\n-    use rt::sleeper_list::SleeperList;\n-    use rt::work_queue::WorkQueue;\n-    use rt::thread::Thread;\n-    use rt::task::Task;\n-    use rt::sched::{Shutdown, TaskFromFriend};\n-    use rt::task::UnwindResult;\n-    do run_in_bare_thread {\n-        let sleepers = SleeperList::new();\n-        let work_queue1 = WorkQueue::new();\n-        let work_queue2 = WorkQueue::new();\n-        let queues = ~[work_queue1.clone(), work_queue2.clone()];\n-\n-        let loop1 = ~UvEventLoop::new() as ~EventLoop;\n-        let mut sched1 = ~Scheduler::new(loop1, work_queue1, queues.clone(),\n-                                         sleepers.clone());\n-        let loop2 = ~UvEventLoop::new() as ~EventLoop;\n-        let mut sched2 = ~Scheduler::new(loop2, work_queue2, queues.clone(),\n-                                         sleepers.clone());\n-\n-        let handle1 = Cell::new(sched1.make_handle());\n-        let handle2 = Cell::new(sched2.make_handle());\n-        let tasksFriendHandle = Cell::new(sched2.make_handle());\n-\n-        let on_exit: ~fn(UnwindResult) = |exit_status| {\n-            handle1.take().send(Shutdown);\n-            handle2.take().send(Shutdown);\n-            rtassert!(exit_status.is_success());\n-        };\n-\n-        let test_function: ~fn() = || {\n-            let io = unsafe { local_io() };\n-            let addr = next_test_ip4();\n-            let maybe_socket = io.udp_bind(addr);\n-            // this socket is bound to this event loop\n-            assert!(maybe_socket.is_ok());\n-\n-            // block self on sched1\n-            do task::unkillable { // FIXME(#8674)\n-                let scheduler: ~Scheduler = Local::take();\n-                do scheduler.deschedule_running_task_and_then |_, task| {\n-                    // unblock task\n-                    do task.wake().map |task| {\n-                      // send self to sched2\n-                      tasksFriendHandle.take().send(TaskFromFriend(task));\n-                    };\n-                    // sched1 should now sleep since it has nothing else to do\n-                }\n-            }\n-            // sched2 will wake up and get the task\n-            // as we do nothing else, the function ends and the socket goes out of scope\n-            // sched2 will start to run the destructor\n-            // the destructor will first block the task, set it's home as sched1, then enqueue it\n-            // sched2 will dequeue the task, see that it has a home, and send it to sched1\n-            // sched1 will wake up, exec the close function on the correct loop, and then we're done\n-        };\n-\n-        let mut main_task = ~Task::new_root(&mut sched1.stack_pool, None, test_function);\n-        main_task.death.on_exit = Some(on_exit);\n-        let main_task = Cell::new(main_task);\n-\n-        let null_task = Cell::new(~do Task::new_root(&mut sched2.stack_pool, None) || {});\n-\n-        let sched1 = Cell::new(sched1);\n-        let sched2 = Cell::new(sched2);\n-\n-        let thread1 = do Thread::start {\n-            sched1.take().bootstrap(main_task.take());\n-        };\n-        let thread2 = do Thread::start {\n-            sched2.take().bootstrap(null_task.take());\n-        };\n-\n-        thread1.join();\n-        thread2.join();\n-    }\n-}\n-\n-#[test]\n-fn test_simple_homed_udp_io_bind_then_move_handle_then_home_and_close() {\n-    use rt::sleeper_list::SleeperList;\n-    use rt::work_queue::WorkQueue;\n-    use rt::thread::Thread;\n-    use rt::task::Task;\n-    use rt::comm::oneshot;\n-    use rt::sched::Shutdown;\n-    use rt::task::UnwindResult;\n-    do run_in_bare_thread {\n-        let sleepers = SleeperList::new();\n-        let work_queue1 = WorkQueue::new();\n-        let work_queue2 = WorkQueue::new();\n-        let queues = ~[work_queue1.clone(), work_queue2.clone()];\n-\n-        let loop1 = ~UvEventLoop::new() as ~EventLoop;\n-        let mut sched1 = ~Scheduler::new(loop1, work_queue1, queues.clone(),\n-                                         sleepers.clone());\n-        let loop2 = ~UvEventLoop::new() as ~EventLoop;\n-        let mut sched2 = ~Scheduler::new(loop2, work_queue2, queues.clone(),\n-                                         sleepers.clone());\n-\n-        let handle1 = Cell::new(sched1.make_handle());\n-        let handle2 = Cell::new(sched2.make_handle());\n-\n-        let (port, chan) = oneshot();\n-        let port = Cell::new(port);\n-        let chan = Cell::new(chan);\n-\n-        let body1: ~fn() = || {\n-            let io = unsafe { local_io() };\n-            let addr = next_test_ip4();\n-            let socket = io.udp_bind(addr);\n-            assert!(socket.is_ok());\n-            chan.take().send(socket);\n-        };\n-\n-        let body2: ~fn() = || {\n-            let socket = port.take().recv();\n-            assert!(socket.is_ok());\n-            /* The socket goes out of scope and the destructor is called.\n-             * The destructor:\n-             *  - sends itself back to sched1\n-             *  - frees the socket\n-             *  - resets the home of the task to whatever it was previously\n-             */\n-        };\n-\n-        let on_exit: ~fn(UnwindResult) = |exit| {\n-            handle1.take().send(Shutdown);\n-            handle2.take().send(Shutdown);\n-            rtassert!(exit.is_success());\n-        };\n-\n-        let task1 = Cell::new(~Task::new_root(&mut sched1.stack_pool, None, body1));\n-\n-        let mut task2 = ~Task::new_root(&mut sched2.stack_pool, None, body2);\n-        task2.death.on_exit = Some(on_exit);\n-        let task2 = Cell::new(task2);\n-\n-        let sched1 = Cell::new(sched1);\n-        let sched2 = Cell::new(sched2);\n-\n-        let thread1 = do Thread::start {\n-            sched1.take().bootstrap(task1.take());\n-        };\n-        let thread2 = do Thread::start {\n-            sched2.take().bootstrap(task2.take());\n-        };\n-\n-        thread1.join();\n-        thread2.join();\n-    }\n-}\n-\n-#[test]\n-fn test_simple_tcp_server_and_client() {\n-    do run_in_mt_newsched_task {\n-        let addr = next_test_ip4();\n-        let (port, chan) = oneshot();\n-        let port = Cell::new(port);\n-        let chan = Cell::new(chan);\n-\n-        // Start the server first so it's listening when we connect\n-        do spawntask {\n-            unsafe {\n-                let io = local_io();\n-                let listener = io.tcp_bind(addr).unwrap();\n-                let mut acceptor = listener.listen().unwrap();\n-                chan.take().send(());\n-                let mut stream = acceptor.accept().unwrap();\n-                let mut buf = [0, .. 2048];\n-                let nread = stream.read(buf).unwrap();\n-                assert_eq!(nread, 8);\n-                for i in range(0u, nread) {\n-                    rtdebug!(\"{}\", buf[i]);\n-                    assert_eq!(buf[i], i as u8);\n-                }\n-            }\n-        }\n-\n-        do spawntask {\n-            unsafe {\n-                port.take().recv();\n-                let io = local_io();\n-                let mut stream = io.tcp_connect(addr).unwrap();\n-                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-            }\n-        }\n-    }\n-}\n-\n-#[test]\n-fn test_simple_tcp_server_and_client_on_diff_threads() {\n-    use rt::sleeper_list::SleeperList;\n-    use rt::work_queue::WorkQueue;\n-    use rt::thread::Thread;\n-    use rt::task::Task;\n-    use rt::sched::{Shutdown};\n-    use rt::task::UnwindResult;\n-    do run_in_bare_thread {\n-        let sleepers = SleeperList::new();\n-\n-        let server_addr = next_test_ip4();\n-        let client_addr = server_addr.clone();\n-\n-        let server_work_queue = WorkQueue::new();\n-        let client_work_queue = WorkQueue::new();\n-        let queues = ~[server_work_queue.clone(), client_work_queue.clone()];\n-\n-        let sloop = ~UvEventLoop::new() as ~EventLoop;\n-        let mut server_sched = ~Scheduler::new(sloop, server_work_queue,\n-                                               queues.clone(), sleepers.clone());\n-        let cloop = ~UvEventLoop::new() as ~EventLoop;\n-        let mut client_sched = ~Scheduler::new(cloop, client_work_queue,\n-                                               queues.clone(), sleepers.clone());\n-\n-        let server_handle = Cell::new(server_sched.make_handle());\n-        let client_handle = Cell::new(client_sched.make_handle());\n-\n-        let server_on_exit: ~fn(UnwindResult) = |exit_status| {\n-            server_handle.take().send(Shutdown);\n-            rtassert!(exit_status.is_success());\n-        };\n-\n-        let client_on_exit: ~fn(UnwindResult) = |exit_status| {\n-            client_handle.take().send(Shutdown);\n-            rtassert!(exit_status.is_success());\n-        };\n-\n-        let server_fn: ~fn() = || {\n-            let io = unsafe { local_io() };\n-            let listener = io.tcp_bind(server_addr).unwrap();\n-            let mut acceptor = listener.listen().unwrap();\n-            let mut stream = acceptor.accept().unwrap();\n-            let mut buf = [0, .. 2048];\n-            let nread = stream.read(buf).unwrap();\n-            assert_eq!(nread, 8);\n-            for i in range(0u, nread) {\n-                assert_eq!(buf[i], i as u8);\n-            }\n-        };\n-\n-        let client_fn: ~fn() = || {\n-            let io = unsafe { local_io() };\n-            let mut stream = io.tcp_connect(client_addr);\n-            while stream.is_err() {\n-                stream = io.tcp_connect(client_addr);\n-            }\n-            stream.unwrap().write([0, 1, 2, 3, 4, 5, 6, 7]);\n-        };\n-\n-        let mut server_task = ~Task::new_root(&mut server_sched.stack_pool, None, server_fn);\n-        server_task.death.on_exit = Some(server_on_exit);\n-        let server_task = Cell::new(server_task);\n-\n-        let mut client_task = ~Task::new_root(&mut client_sched.stack_pool, None, client_fn);\n-        client_task.death.on_exit = Some(client_on_exit);\n-        let client_task = Cell::new(client_task);\n-\n-        let server_sched = Cell::new(server_sched);\n-        let client_sched = Cell::new(client_sched);\n-\n-        let server_thread = do Thread::start {\n-            server_sched.take().bootstrap(server_task.take());\n-        };\n-        let client_thread = do Thread::start {\n-            client_sched.take().bootstrap(client_task.take());\n-        };\n-\n-        server_thread.join();\n-        client_thread.join();\n-    }\n-}\n-\n-#[test]\n-fn test_simple_udp_server_and_client() {\n-    do run_in_mt_newsched_task {\n-        let server_addr = next_test_ip4();\n-        let client_addr = next_test_ip4();\n-        let (port, chan) = oneshot();\n-        let port = Cell::new(port);\n-        let chan = Cell::new(chan);\n-\n-        do spawntask {\n-            unsafe {\n-                let io = local_io();\n-                let mut server_socket = io.udp_bind(server_addr).unwrap();\n-                chan.take().send(());\n-                let mut buf = [0, .. 2048];\n-                let (nread,src) = server_socket.recvfrom(buf).unwrap();\n-                assert_eq!(nread, 8);\n-                for i in range(0u, nread) {\n-                    rtdebug!(\"{}\", buf[i]);\n-                    assert_eq!(buf[i], i as u8);\n-                }\n-                assert_eq!(src, client_addr);\n-            }\n-        }\n-\n-        do spawntask {\n-            unsafe {\n-                let io = local_io();\n-                let mut client_socket = io.udp_bind(client_addr).unwrap();\n-                port.take().recv();\n-                client_socket.sendto([0, 1, 2, 3, 4, 5, 6, 7], server_addr);\n-            }\n-        }\n-    }\n-}\n-\n-#[test] #[ignore(reason = \"busted\")]\n-fn test_read_and_block() {\n-    do run_in_mt_newsched_task {\n-        let addr = next_test_ip4();\n-        let (port, chan) = oneshot();\n-        let port = Cell::new(port);\n-        let chan = Cell::new(chan);\n-\n-        do spawntask {\n-            let io = unsafe { local_io() };\n-            let listener = io.tcp_bind(addr).unwrap();\n-            let mut acceptor = listener.listen().unwrap();\n-            chan.take().send(());\n-            let mut stream = acceptor.accept().unwrap();\n-            let mut buf = [0, .. 2048];\n-\n-            let expected = 32;\n-            let mut current = 0;\n-            let mut reads = 0;\n-\n-            while current < expected {\n-                let nread = stream.read(buf).unwrap();\n-                for i in range(0u, nread) {\n-                    let val = buf[i] as uint;\n-                    assert_eq!(val, current % 8);\n-                    current += 1;\n-                }\n-                reads += 1;\n-\n-                do task::unkillable { // FIXME(#8674)\n-                    let scheduler: ~Scheduler = Local::take();\n-                    // Yield to the other task in hopes that it\n-                    // will trigger a read callback while we are\n-                    // not ready for it\n-                    do scheduler.deschedule_running_task_and_then |sched, task| {\n-                        let task = Cell::new(task);\n-                        sched.enqueue_blocked_task(task.take());\n-                    }\n-                }\n-            }\n-\n-            // Make sure we had multiple reads\n-            assert!(reads > 1);\n-        }\n-\n-        do spawntask {\n-            unsafe {\n-                port.take().recv();\n-                let io = local_io();\n-                let mut stream = io.tcp_connect(addr).unwrap();\n-                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-            }\n-        }\n-\n-    }\n-}\n-\n-#[test]\n-fn test_read_read_read() {\n-    do run_in_mt_newsched_task {\n-        let addr = next_test_ip4();\n-        static MAX: uint = 500000;\n-        let (port, chan) = oneshot();\n-        let port = Cell::new(port);\n-        let chan = Cell::new(chan);\n-\n-        do spawntask {\n-            unsafe {\n-                let io = local_io();\n-                let listener = io.tcp_bind(addr).unwrap();\n-                let mut acceptor = listener.listen().unwrap();\n-                chan.take().send(());\n-                let mut stream = acceptor.accept().unwrap();\n-                let buf = [1, .. 2048];\n-                let mut total_bytes_written = 0;\n-                while total_bytes_written < MAX {\n-                    stream.write(buf);\n-                    total_bytes_written += buf.len();\n-                }\n-            }\n-        }\n-\n-        do spawntask {\n-            unsafe {\n-                port.take().recv();\n-                let io = local_io();\n-                let mut stream = io.tcp_connect(addr).unwrap();\n-                let mut buf = [0, .. 2048];\n-                let mut total_bytes_read = 0;\n-                while total_bytes_read < MAX {\n-                    let nread = stream.read(buf).unwrap();\n-                    rtdebug!(\"read {} bytes\", nread);\n-                    total_bytes_read += nread;\n-                    for i in range(0u, nread) {\n-                        assert_eq!(buf[i], 1);\n-                    }\n-                }\n-                rtdebug!(\"read {} bytes total\", total_bytes_read);\n-            }\n-        }\n-    }\n-}\n-\n-#[test]\n-#[ignore(cfg(windows))] // FIXME(#10102) the server never sees the second send\n-fn test_udp_twice() {\n-    do run_in_mt_newsched_task {\n-        let server_addr = next_test_ip4();\n-        let client_addr = next_test_ip4();\n-        let (port, chan) = oneshot();\n-        let port = Cell::new(port);\n-        let chan = Cell::new(chan);\n-\n-        do spawntask {\n-            unsafe {\n-                let io = local_io();\n-                let mut client = io.udp_bind(client_addr).unwrap();\n-                port.take().recv();\n-                assert!(client.sendto([1], server_addr).is_ok());\n-                assert!(client.sendto([2], server_addr).is_ok());\n-            }\n-        }\n-\n-        do spawntask {\n-            unsafe {\n-                let io = local_io();\n-                let mut server = io.udp_bind(server_addr).unwrap();\n-                chan.take().send(());\n-                let mut buf1 = [0];\n-                let mut buf2 = [0];\n-                let (nread1, src1) = server.recvfrom(buf1).unwrap();\n-                let (nread2, src2) = server.recvfrom(buf2).unwrap();\n-                assert_eq!(nread1, 1);\n-                assert_eq!(nread2, 1);\n-                assert_eq!(src1, client_addr);\n-                assert_eq!(src2, client_addr);\n-                assert_eq!(buf1[0], 1);\n-                assert_eq!(buf2[0], 2);\n-            }\n-        }\n-    }\n-}\n-\n-#[test]\n-fn test_udp_many_read() {\n-    do run_in_mt_newsched_task {\n-        let server_out_addr = next_test_ip4();\n-        let server_in_addr = next_test_ip4();\n-        let client_out_addr = next_test_ip4();\n-        let client_in_addr = next_test_ip4();\n-        static MAX: uint = 500_000;\n-\n-        let (p1, c1) = oneshot();\n-        let (p2, c2) = oneshot();\n-\n-        let first = Cell::new((p1, c2));\n-        let second = Cell::new((p2, c1));\n-\n-        do spawntask {\n-            unsafe {\n-                let io = local_io();\n-                let mut server_out = io.udp_bind(server_out_addr).unwrap();\n-                let mut server_in = io.udp_bind(server_in_addr).unwrap();\n-                let (port, chan) = first.take();\n-                chan.send(());\n-                port.recv();\n-                let msg = [1, .. 2048];\n-                let mut total_bytes_sent = 0;\n-                let mut buf = [1];\n-                while buf[0] == 1 {\n-                    // send more data\n-                    assert!(server_out.sendto(msg, client_in_addr).is_ok());\n-                    total_bytes_sent += msg.len();\n-                    // check if the client has received enough\n-                    let res = server_in.recvfrom(buf);\n-                    assert!(res.is_ok());\n-                    let (nread, src) = res.unwrap();\n-                    assert_eq!(nread, 1);\n-                    assert_eq!(src, client_out_addr);\n-                }\n-                assert!(total_bytes_sent >= MAX);\n-            }\n-        }\n-\n-        do spawntask {\n-            unsafe {\n-                let io = local_io();\n-                let mut client_out = io.udp_bind(client_out_addr).unwrap();\n-                let mut client_in = io.udp_bind(client_in_addr).unwrap();\n-                let (port, chan) = second.take();\n-                port.recv();\n-                chan.send(());\n-                let mut total_bytes_recv = 0;\n-                let mut buf = [0, .. 2048];\n-                while total_bytes_recv < MAX {\n-                    // ask for more\n-                    assert!(client_out.sendto([1], server_in_addr).is_ok());\n-                    // wait for data\n-                    let res = client_in.recvfrom(buf);\n-                    assert!(res.is_ok());\n-                    let (nread, src) = res.unwrap();\n-                    assert_eq!(src, server_out_addr);\n-                    total_bytes_recv += nread;\n-                    for i in range(0u, nread) {\n-                        assert_eq!(buf[i], 1);\n-                    }\n-                }\n-                // tell the server we're done\n-                assert!(client_out.sendto([0], server_in_addr).is_ok());\n-            }\n-        }\n-    }\n-}\n-\n-#[test]\n-fn test_timer_sleep_simple() {\n-    do run_in_mt_newsched_task {\n-        unsafe {\n-            let io = local_io();\n-            let timer = io.timer_init();\n-            do timer.map_move |mut t| { t.sleep(1) };\n-        }\n-    }\n-}\n-\n-fn file_test_uvio_full_simple_impl() {\n-    use str::StrSlice; // why does this have to be explicitly imported to work?\n-                       // compiler was complaining about no trait for str that\n-                       // does .as_bytes() ..\n-    use rt::io::{Open, Create, ReadWrite, Read};\n-    unsafe {\n-        let io = local_io();\n-        let write_val = \"hello uvio!\";\n-        let path = \"./tmp/file_test_uvio_full.txt\";\n-        {\n-            let create_fm = Create;\n-            let create_fa = ReadWrite;\n-            let mut fd = io.fs_open(&path.to_c_str(), create_fm, create_fa).unwrap();\n-            let write_buf = write_val.as_bytes();\n-            fd.write(write_buf);\n-        }\n-        {\n-            let ro_fm = Open;\n-            let ro_fa = Read;\n-            let mut fd = io.fs_open(&path.to_c_str(), ro_fm, ro_fa).unwrap();\n-            let mut read_vec = [0, .. 1028];\n-            let nread = fd.read(read_vec).unwrap();\n-            let read_val = str::from_utf8(read_vec.slice(0, nread as uint));\n-            assert!(read_val == write_val.to_owned());\n-        }\n-        io.fs_unlink(&path.to_c_str());\n-    }\n-}\n-\n-#[test]\n-fn file_test_uvio_full_simple() {\n-    do run_in_mt_newsched_task {\n-        file_test_uvio_full_simple_impl();\n-    }\n-}\n-\n-fn uvio_naive_print(input: &str) {\n-    use str::StrSlice;\n-    unsafe {\n-        use libc::{STDOUT_FILENO};\n-        let io = local_io();\n-        {\n-            let mut fd = io.fs_from_raw_fd(STDOUT_FILENO, DontClose);\n-            let write_buf = input.as_bytes();\n-            fd.write(write_buf);\n-        }\n-    }\n-}\n-\n-#[test]\n-fn file_test_uvio_write_to_stdout() {\n-    do run_in_mt_newsched_task {\n-        uvio_naive_print(\"jubilation\\n\");\n-    }\n-}"}, {"sha": "2964eb9c58be3f4befbe35ec34f5e2794de442aa", "filename": "src/libstd/rt/uv/uvll.rs", "status": "removed", "additions": 0, "deletions": 1176, "changes": 1176, "blob_url": "https://github.com/rust-lang/rust/blob/886819cca1208210cb73892f8fe4b7b9140068dc/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886819cca1208210cb73892f8fe4b7b9140068dc/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs?ref=886819cca1208210cb73892f8fe4b7b9140068dc", "patch": "@@ -1,1176 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n- * Low-level bindings to the libuv library.\n- *\n- * This module contains a set of direct, 'bare-metal' wrappers around\n- * the libuv C-API.\n- *\n- * We're not bothering yet to redefine uv's structs as Rust structs\n- * because they are quite large and change often between versions.\n- * The maintenance burden is just too high. Instead we use the uv's\n- * `uv_handle_size` and `uv_req_size` to find the correct size of the\n- * structs and allocate them on the heap. This can be revisited later.\n- *\n- * There are also a collection of helper functions to ease interacting\n- * with the low-level API.\n- *\n- * As new functionality, existent in uv.h, is added to the rust stdlib,\n- * the mappings should be added in this module.\n- */\n-\n-#[allow(non_camel_case_types)]; // C types\n-\n-use c_str::ToCStr;\n-use libc::{size_t, c_int, c_uint, c_void, c_char, uintptr_t};\n-use libc::ssize_t;\n-use libc::{malloc, free};\n-use libc;\n-use prelude::*;\n-use ptr;\n-use vec;\n-\n-pub use self::errors::*;\n-\n-pub static OK: c_int = 0;\n-pub static EOF: c_int = -4095;\n-pub static UNKNOWN: c_int = -4094;\n-\n-// uv-errno.h redefines error codes for windows, but not for unix...\n-\n-#[cfg(windows)]\n-pub mod errors {\n-    use libc::c_int;\n-\n-    pub static EACCES: c_int = -4093;\n-    pub static ECONNREFUSED: c_int = -4079;\n-    pub static ECONNRESET: c_int = -4078;\n-    pub static ENOTCONN: c_int = -4054;\n-    pub static EPIPE: c_int = -4048;\n-    pub static ECONNABORTED: c_int = -4080;\n-}\n-#[cfg(not(windows))]\n-pub mod errors {\n-    use libc;\n-    use libc::c_int;\n-\n-    pub static EACCES: c_int = -libc::EACCES;\n-    pub static ECONNREFUSED: c_int = -libc::ECONNREFUSED;\n-    pub static ECONNRESET: c_int = -libc::ECONNRESET;\n-    pub static ENOTCONN: c_int = -libc::ENOTCONN;\n-    pub static EPIPE: c_int = -libc::EPIPE;\n-    pub static ECONNABORTED: c_int = -libc::ECONNABORTED;\n-}\n-\n-pub static PROCESS_SETUID: c_int = 1 << 0;\n-pub static PROCESS_SETGID: c_int = 1 << 1;\n-pub static PROCESS_WINDOWS_VERBATIM_ARGUMENTS: c_int = 1 << 2;\n-pub static PROCESS_DETACHED: c_int = 1 << 3;\n-pub static PROCESS_WINDOWS_HIDE: c_int = 1 << 4;\n-\n-pub static STDIO_IGNORE: c_int = 0x00;\n-pub static STDIO_CREATE_PIPE: c_int = 0x01;\n-pub static STDIO_INHERIT_FD: c_int = 0x02;\n-pub static STDIO_INHERIT_STREAM: c_int = 0x04;\n-pub static STDIO_READABLE_PIPE: c_int = 0x10;\n-pub static STDIO_WRITABLE_PIPE: c_int = 0x20;\n-\n-// see libuv/include/uv-unix.h\n-#[cfg(unix)]\n-pub struct uv_buf_t {\n-    base: *u8,\n-    len: libc::size_t,\n-}\n-\n-// see libuv/include/uv-win.h\n-#[cfg(windows)]\n-pub struct uv_buf_t {\n-    len: u32,\n-    base: *u8,\n-}\n-\n-pub struct uv_process_options_t {\n-    exit_cb: uv_exit_cb,\n-    file: *libc::c_char,\n-    args: **libc::c_char,\n-    env: **libc::c_char,\n-    cwd: *libc::c_char,\n-    flags: libc::c_uint,\n-    stdio_count: libc::c_int,\n-    stdio: *uv_stdio_container_t,\n-    uid: uv_uid_t,\n-    gid: uv_gid_t,\n-}\n-\n-// These fields are private because they must be interfaced with through the\n-// functions below.\n-pub struct uv_stdio_container_t {\n-    priv flags: libc::c_int,\n-    priv stream: *uv_stream_t,\n-}\n-\n-pub type uv_handle_t = c_void;\n-pub type uv_loop_t = c_void;\n-pub type uv_idle_t = c_void;\n-pub type uv_tcp_t = c_void;\n-pub type uv_udp_t = c_void;\n-pub type uv_connect_t = c_void;\n-pub type uv_connection_t = c_void;\n-pub type uv_write_t = c_void;\n-pub type uv_async_t = c_void;\n-pub type uv_timer_t = c_void;\n-pub type uv_stream_t = c_void;\n-pub type uv_fs_t = c_void;\n-pub type uv_udp_send_t = c_void;\n-pub type uv_getaddrinfo_t = c_void;\n-pub type uv_process_t = c_void;\n-pub type uv_pipe_t = c_void;\n-pub type uv_tty_t = c_void;\n-pub type uv_signal_t = c_void;\n-\n-pub struct uv_timespec_t {\n-    tv_sec: libc::c_long,\n-    priv tv_nsec: libc::c_long\n-}\n-\n-pub struct uv_stat_t {\n-    st_dev: libc::uint64_t,\n-    st_mode: libc::uint64_t,\n-    priv st_nlink: libc::uint64_t,\n-    priv st_uid: libc::uint64_t,\n-    priv st_gid: libc::uint64_t,\n-    priv st_rdev: libc::uint64_t,\n-    st_ino: libc::uint64_t,\n-    st_size: libc::uint64_t,\n-    priv st_blksize: libc::uint64_t,\n-    priv st_blocks: libc::uint64_t,\n-    priv st_flags: libc::uint64_t,\n-    priv st_gen: libc::uint64_t,\n-    st_atim: uv_timespec_t,\n-    st_mtim: uv_timespec_t,\n-    st_ctim: uv_timespec_t,\n-    priv st_birthtim: uv_timespec_t\n-}\n-\n-impl uv_stat_t {\n-    pub fn new() -> uv_stat_t {\n-        uv_stat_t {\n-            st_dev: 0,\n-            st_mode: 0,\n-            st_nlink: 0,\n-            st_uid: 0,\n-            st_gid: 0,\n-            st_rdev: 0,\n-            st_ino: 0,\n-            st_size: 0,\n-            st_blksize: 0,\n-            st_blocks: 0,\n-            st_flags: 0,\n-            st_gen: 0,\n-            st_atim: uv_timespec_t { tv_sec: 0, tv_nsec: 0 },\n-            st_mtim: uv_timespec_t { tv_sec: 0, tv_nsec: 0 },\n-            st_ctim: uv_timespec_t { tv_sec: 0, tv_nsec: 0 },\n-            st_birthtim: uv_timespec_t { tv_sec: 0, tv_nsec: 0 }\n-        }\n-    }\n-    pub fn is_file(&self) -> bool {\n-        ((self.st_mode) & libc::S_IFMT as libc::uint64_t) == libc::S_IFREG as libc::uint64_t\n-    }\n-    pub fn is_dir(&self) -> bool {\n-        ((self.st_mode) & libc::S_IFMT as libc::uint64_t) == libc::S_IFDIR as libc::uint64_t\n-    }\n-}\n-\n-pub type uv_idle_cb = extern \"C\" fn(handle: *uv_idle_t,\n-                                    status: c_int);\n-pub type uv_alloc_cb = extern \"C\" fn(stream: *uv_stream_t,\n-                                     suggested_size: size_t) -> uv_buf_t;\n-pub type uv_read_cb = extern \"C\" fn(stream: *uv_stream_t,\n-                                    nread: ssize_t,\n-                                    buf: uv_buf_t);\n-pub type uv_udp_send_cb = extern \"C\" fn(req: *uv_udp_send_t,\n-                                        status: c_int);\n-pub type uv_udp_recv_cb = extern \"C\" fn(handle: *uv_udp_t,\n-                                        nread: ssize_t,\n-                                        buf: uv_buf_t,\n-                                        addr: *sockaddr,\n-                                        flags: c_uint);\n-pub type uv_close_cb = extern \"C\" fn(handle: *uv_handle_t);\n-pub type uv_walk_cb = extern \"C\" fn(handle: *uv_handle_t,\n-                                    arg: *c_void);\n-pub type uv_async_cb = extern \"C\" fn(handle: *uv_async_t,\n-                                     status: c_int);\n-pub type uv_connect_cb = extern \"C\" fn(handle: *uv_connect_t,\n-                                       status: c_int);\n-pub type uv_connection_cb = extern \"C\" fn(handle: *uv_connection_t,\n-                                          status: c_int);\n-pub type uv_timer_cb = extern \"C\" fn(handle: *uv_timer_t,\n-                                     status: c_int);\n-pub type uv_write_cb = extern \"C\" fn(handle: *uv_write_t,\n-                                     status: c_int);\n-pub type uv_getaddrinfo_cb = extern \"C\" fn(req: *uv_getaddrinfo_t,\n-                                           status: c_int,\n-                                           res: *addrinfo);\n-pub type uv_exit_cb = extern \"C\" fn(handle: *uv_process_t,\n-                                    exit_status: c_int,\n-                                    term_signal: c_int);\n-pub type uv_signal_cb = extern \"C\" fn(handle: *uv_signal_t,\n-                                      signum: c_int);\n-\n-pub type sockaddr = c_void;\n-pub type sockaddr_in = c_void;\n-pub type sockaddr_in6 = c_void;\n-pub type sockaddr_storage = c_void;\n-\n-#[cfg(unix)]\n-pub type socklen_t = c_int;\n-\n-// XXX: This is a standard C type. Could probably be defined in libc\n-#[cfg(target_os = \"android\")]\n-#[cfg(target_os = \"linux\")]\n-pub struct addrinfo {\n-    ai_flags: c_int,\n-    ai_family: c_int,\n-    ai_socktype: c_int,\n-    ai_protocol: c_int,\n-    ai_addrlen: socklen_t,\n-    ai_addr: *sockaddr,\n-    ai_canonname: *char,\n-    ai_next: *addrinfo\n-}\n-\n-#[cfg(target_os = \"macos\")]\n-#[cfg(target_os = \"freebsd\")]\n-pub struct addrinfo {\n-    ai_flags: c_int,\n-    ai_family: c_int,\n-    ai_socktype: c_int,\n-    ai_protocol: c_int,\n-    ai_addrlen: socklen_t,\n-    ai_canonname: *char,\n-    ai_addr: *sockaddr,\n-    ai_next: *addrinfo\n-}\n-\n-#[cfg(windows)]\n-pub struct addrinfo {\n-    ai_flags: c_int,\n-    ai_family: c_int,\n-    ai_socktype: c_int,\n-    ai_protocol: c_int,\n-    ai_addrlen: size_t,\n-    ai_canonname: *char,\n-    ai_addr: *sockaddr,\n-    ai_next: *addrinfo\n-}\n-\n-#[cfg(unix)] pub type uv_uid_t = libc::types::os::arch::posix88::uid_t;\n-#[cfg(unix)] pub type uv_gid_t = libc::types::os::arch::posix88::gid_t;\n-#[cfg(windows)] pub type uv_uid_t = libc::c_uchar;\n-#[cfg(windows)] pub type uv_gid_t = libc::c_uchar;\n-\n-#[deriving(Eq)]\n-pub enum uv_handle_type {\n-    UV_UNKNOWN_HANDLE,\n-    UV_ASYNC,\n-    UV_CHECK,\n-    UV_FS_EVENT,\n-    UV_FS_POLL,\n-    UV_HANDLE,\n-    UV_IDLE,\n-    UV_NAMED_PIPE,\n-    UV_POLL,\n-    UV_PREPARE,\n-    UV_PROCESS,\n-    UV_STREAM,\n-    UV_TCP,\n-    UV_TIMER,\n-    UV_TTY,\n-    UV_UDP,\n-    UV_SIGNAL,\n-    UV_FILE,\n-    UV_HANDLE_TYPE_MAX\n-}\n-\n-#[cfg(unix)]\n-#[deriving(Eq)]\n-pub enum uv_req_type {\n-    UV_UNKNOWN_REQ,\n-    UV_REQ,\n-    UV_CONNECT,\n-    UV_WRITE,\n-    UV_SHUTDOWN,\n-    UV_UDP_SEND,\n-    UV_FS,\n-    UV_WORK,\n-    UV_GETADDRINFO,\n-    UV_REQ_TYPE_MAX\n-}\n-\n-// uv_req_type may have additional fields defined by UV_REQ_TYPE_PRIVATE.\n-// See UV_REQ_TYPE_PRIVATE at libuv/include/uv-win.h\n-#[cfg(windows)]\n-#[deriving(Eq)]\n-pub enum uv_req_type {\n-    UV_UNKNOWN_REQ,\n-    UV_REQ,\n-    UV_CONNECT,\n-    UV_WRITE,\n-    UV_SHUTDOWN,\n-    UV_UDP_SEND,\n-    UV_FS,\n-    UV_WORK,\n-    UV_GETADDRINFO,\n-    UV_ACCEPT,\n-    UV_FS_EVENT_REQ,\n-    UV_POLL_REQ,\n-    UV_PROCESS_EXIT,\n-    UV_READ,\n-    UV_UDP_RECV,\n-    UV_WAKEUP,\n-    UV_SIGNAL_REQ,\n-    UV_REQ_TYPE_MAX\n-}\n-\n-#[deriving(Eq)]\n-pub enum uv_membership {\n-    UV_LEAVE_GROUP,\n-    UV_JOIN_GROUP\n-}\n-\n-pub unsafe fn malloc_handle(handle: uv_handle_type) -> *c_void {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    assert!(handle != UV_UNKNOWN_HANDLE && handle != UV_HANDLE_TYPE_MAX);\n-    let size = rust_uv_handle_size(handle as uint);\n-    let p = malloc(size);\n-    assert!(p.is_not_null());\n-    return p;\n-}\n-\n-pub unsafe fn free_handle(v: *c_void) {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    free(v)\n-}\n-\n-pub unsafe fn malloc_req(req: uv_req_type) -> *c_void {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    assert!(req != UV_UNKNOWN_REQ && req != UV_REQ_TYPE_MAX);\n-    let size = rust_uv_req_size(req as uint);\n-    let p = malloc(size);\n-    assert!(p.is_not_null());\n-    return p;\n-}\n-\n-pub unsafe fn free_req(v: *c_void) {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    free(v)\n-}\n-\n-#[test]\n-fn handle_sanity_check() {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    unsafe {\n-        assert_eq!(UV_HANDLE_TYPE_MAX as uint, rust_uv_handle_type_max());\n-    }\n-}\n-\n-#[test]\n-fn request_sanity_check() {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    unsafe {\n-        assert_eq!(UV_REQ_TYPE_MAX as uint, rust_uv_req_type_max());\n-    }\n-}\n-\n-// XXX Event loops ignore SIGPIPE by default.\n-pub unsafe fn loop_new() -> *c_void {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_loop_new();\n-}\n-\n-pub unsafe fn loop_delete(loop_handle: *c_void) {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    rust_uv_loop_delete(loop_handle);\n-}\n-\n-pub unsafe fn run(loop_handle: *c_void) {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    rust_uv_run(loop_handle);\n-}\n-\n-pub unsafe fn close<T>(handle: *T, cb: uv_close_cb) {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    rust_uv_close(handle as *c_void, cb);\n-}\n-\n-pub unsafe fn walk(loop_handle: *c_void, cb: uv_walk_cb, arg: *c_void) {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    rust_uv_walk(loop_handle, cb, arg);\n-}\n-\n-pub unsafe fn idle_init(loop_handle: *uv_loop_t, handle: *uv_idle_t) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    rust_uv_idle_init(loop_handle, handle)\n-}\n-\n-pub unsafe fn idle_start(handle: *uv_idle_t, cb: uv_idle_cb) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    rust_uv_idle_start(handle, cb)\n-}\n-\n-pub unsafe fn idle_stop(handle: *uv_idle_t) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    rust_uv_idle_stop(handle)\n-}\n-\n-pub unsafe fn udp_init(loop_handle: *uv_loop_t, handle: *uv_udp_t) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_udp_init(loop_handle, handle);\n-}\n-\n-pub unsafe fn udp_bind(server: *uv_udp_t, addr: *sockaddr_in, flags: c_uint) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_udp_bind(server, addr, flags);\n-}\n-\n-pub unsafe fn udp_bind6(server: *uv_udp_t, addr: *sockaddr_in6, flags: c_uint) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_udp_bind6(server, addr, flags);\n-}\n-\n-pub unsafe fn udp_send<T>(req: *uv_udp_send_t, handle: *T, buf_in: &[uv_buf_t],\n-                          addr: *sockaddr_in, cb: uv_udp_send_cb) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    let buf_ptr = vec::raw::to_ptr(buf_in);\n-    let buf_cnt = buf_in.len() as i32;\n-    return rust_uv_udp_send(req, handle as *c_void, buf_ptr, buf_cnt, addr, cb);\n-}\n-\n-pub unsafe fn udp_send6<T>(req: *uv_udp_send_t, handle: *T, buf_in: &[uv_buf_t],\n-                          addr: *sockaddr_in6, cb: uv_udp_send_cb) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    let buf_ptr = vec::raw::to_ptr(buf_in);\n-    let buf_cnt = buf_in.len() as i32;\n-    return rust_uv_udp_send6(req, handle as *c_void, buf_ptr, buf_cnt, addr, cb);\n-}\n-\n-pub unsafe fn udp_recv_start(server: *uv_udp_t, on_alloc: uv_alloc_cb,\n-                             on_recv: uv_udp_recv_cb) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_udp_recv_start(server, on_alloc, on_recv);\n-}\n-\n-pub unsafe fn udp_recv_stop(server: *uv_udp_t) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_udp_recv_stop(server);\n-}\n-\n-pub unsafe fn get_udp_handle_from_send_req(send_req: *uv_udp_send_t) -> *uv_udp_t {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_get_udp_handle_from_send_req(send_req);\n-}\n-\n-pub unsafe fn udp_getsockname(handle: *uv_udp_t, name: *sockaddr_storage) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_udp_getsockname(handle, name);\n-}\n-\n-pub unsafe fn udp_set_membership(handle: *uv_udp_t, multicast_addr: *c_char,\n-                                 interface_addr: *c_char, membership: uv_membership) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_udp_set_membership(handle, multicast_addr, interface_addr, membership as c_int);\n-}\n-\n-pub unsafe fn udp_set_multicast_loop(handle: *uv_udp_t, on: c_int) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_udp_set_multicast_loop(handle, on);\n-}\n-\n-pub unsafe fn udp_set_multicast_ttl(handle: *uv_udp_t, ttl: c_int) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_udp_set_multicast_ttl(handle, ttl);\n-}\n-\n-pub unsafe fn udp_set_ttl(handle: *uv_udp_t, ttl: c_int) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_udp_set_ttl(handle, ttl);\n-}\n-\n-pub unsafe fn udp_set_broadcast(handle: *uv_udp_t, on: c_int) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_udp_set_broadcast(handle, on);\n-}\n-\n-pub unsafe fn tcp_init(loop_handle: *c_void, handle: *uv_tcp_t) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_tcp_init(loop_handle, handle);\n-}\n-\n-pub unsafe fn tcp_connect(connect_ptr: *uv_connect_t, tcp_handle_ptr: *uv_tcp_t,\n-                          addr_ptr: *sockaddr_in, after_connect_cb: uv_connect_cb) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_tcp_connect(connect_ptr, tcp_handle_ptr, after_connect_cb, addr_ptr);\n-}\n-\n-pub unsafe fn tcp_connect6(connect_ptr: *uv_connect_t, tcp_handle_ptr: *uv_tcp_t,\n-                           addr_ptr: *sockaddr_in6, after_connect_cb: uv_connect_cb) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_tcp_connect6(connect_ptr, tcp_handle_ptr, after_connect_cb, addr_ptr);\n-}\n-\n-pub unsafe fn tcp_bind(tcp_server_ptr: *uv_tcp_t, addr_ptr: *sockaddr_in) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_tcp_bind(tcp_server_ptr, addr_ptr);\n-}\n-\n-pub unsafe fn tcp_bind6(tcp_server_ptr: *uv_tcp_t, addr_ptr: *sockaddr_in6) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_tcp_bind6(tcp_server_ptr, addr_ptr);\n-}\n-\n-pub unsafe fn tcp_getpeername(tcp_handle_ptr: *uv_tcp_t, name: *sockaddr_storage) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_tcp_getpeername(tcp_handle_ptr, name);\n-}\n-\n-pub unsafe fn tcp_getsockname(handle: *uv_tcp_t, name: *sockaddr_storage) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_tcp_getsockname(handle, name);\n-}\n-\n-pub unsafe fn tcp_nodelay(handle: *uv_tcp_t, enable: c_int) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_tcp_nodelay(handle, enable);\n-}\n-\n-pub unsafe fn tcp_keepalive(handle: *uv_tcp_t, enable: c_int, delay: c_uint) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_tcp_keepalive(handle, enable, delay);\n-}\n-\n-pub unsafe fn tcp_simultaneous_accepts(handle: *uv_tcp_t, enable: c_int) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_tcp_simultaneous_accepts(handle, enable);\n-}\n-\n-pub unsafe fn listen<T>(stream: *T, backlog: c_int,\n-                        cb: uv_connection_cb) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_listen(stream as *c_void, backlog, cb);\n-}\n-\n-pub unsafe fn accept(server: *c_void, client: *c_void) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_accept(server as *c_void, client as *c_void);\n-}\n-\n-pub unsafe fn write<T>(req: *uv_write_t,\n-                       stream: *T,\n-                       buf_in: &[uv_buf_t],\n-                       cb: uv_write_cb) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    let buf_ptr = vec::raw::to_ptr(buf_in);\n-    let buf_cnt = buf_in.len() as i32;\n-    return rust_uv_write(req as *c_void, stream as *c_void, buf_ptr, buf_cnt, cb);\n-}\n-pub unsafe fn read_start(stream: *uv_stream_t,\n-                         on_alloc: uv_alloc_cb,\n-                         on_read: uv_read_cb) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_read_start(stream as *c_void, on_alloc, on_read);\n-}\n-\n-pub unsafe fn read_stop(stream: *uv_stream_t) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_read_stop(stream as *c_void);\n-}\n-\n-pub unsafe fn strerror(err: c_int) -> *c_char {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    return rust_uv_strerror(err);\n-}\n-pub unsafe fn err_name(err: c_int) -> *c_char {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    return rust_uv_err_name(err);\n-}\n-\n-pub unsafe fn async_init(loop_handle: *c_void,\n-                         async_handle: *uv_async_t,\n-                         cb: uv_async_cb) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_async_init(loop_handle, async_handle, cb);\n-}\n-\n-pub unsafe fn async_send(async_handle: *uv_async_t) {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_async_send(async_handle);\n-}\n-pub unsafe fn buf_init(input: *u8, len: uint) -> uv_buf_t {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    let out_buf = uv_buf_t { base: ptr::null(), len: 0 as size_t };\n-    let out_buf_ptr = ptr::to_unsafe_ptr(&out_buf);\n-    rust_uv_buf_init(out_buf_ptr, input, len as size_t);\n-    return out_buf;\n-}\n-\n-pub unsafe fn timer_init(loop_ptr: *c_void, timer_ptr: *uv_timer_t) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_timer_init(loop_ptr, timer_ptr);\n-}\n-pub unsafe fn timer_start(timer_ptr: *uv_timer_t,\n-                          cb: uv_timer_cb, timeout: u64,\n-                          repeat: u64) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_timer_start(timer_ptr, cb, timeout, repeat);\n-}\n-pub unsafe fn timer_stop(timer_ptr: *uv_timer_t) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_timer_stop(timer_ptr);\n-}\n-\n-pub unsafe fn is_ip4_addr(addr: *sockaddr) -> bool {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    match rust_uv_is_ipv4_sockaddr(addr) { 0 => false, _ => true }\n-}\n-\n-pub unsafe fn is_ip6_addr(addr: *sockaddr) -> bool {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    match rust_uv_is_ipv6_sockaddr(addr) { 0 => false, _ => true }\n-}\n-\n-pub unsafe fn malloc_ip4_addr(ip: &str, port: int) -> *sockaddr_in {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    do ip.with_c_str |ip_buf| {\n-        rust_uv_ip4_addrp(ip_buf as *u8, port as libc::c_int)\n-    }\n-}\n-pub unsafe fn malloc_ip6_addr(ip: &str, port: int) -> *sockaddr_in6 {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    do ip.with_c_str |ip_buf| {\n-        rust_uv_ip6_addrp(ip_buf as *u8, port as libc::c_int)\n-    }\n-}\n-\n-pub unsafe fn malloc_sockaddr_storage() -> *sockaddr_storage {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    rust_uv_malloc_sockaddr_storage()\n-}\n-\n-pub unsafe fn free_sockaddr_storage(ss: *sockaddr_storage) {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    rust_uv_free_sockaddr_storage(ss);\n-}\n-\n-pub unsafe fn free_ip4_addr(addr: *sockaddr_in) {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    rust_uv_free_ip4_addr(addr);\n-}\n-\n-pub unsafe fn free_ip6_addr(addr: *sockaddr_in6) {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    rust_uv_free_ip6_addr(addr);\n-}\n-\n-pub unsafe fn ip4_name(addr: *sockaddr_in, dst: *u8, size: size_t) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_ip4_name(addr, dst, size);\n-}\n-\n-pub unsafe fn ip6_name(addr: *sockaddr_in6, dst: *u8, size: size_t) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_ip6_name(addr, dst, size);\n-}\n-\n-pub unsafe fn ip4_port(addr: *sockaddr_in) -> c_uint {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-   return rust_uv_ip4_port(addr);\n-}\n-\n-pub unsafe fn ip6_port(addr: *sockaddr_in6) -> c_uint {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_ip6_port(addr);\n-}\n-\n-pub unsafe fn fs_open(loop_ptr: *uv_loop_t, req: *uv_fs_t, path: *c_char, flags: int, mode: int,\n-                cb: *u8) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    rust_uv_fs_open(loop_ptr, req, path, flags as c_int, mode as c_int, cb)\n-}\n-\n-pub unsafe fn fs_unlink(loop_ptr: *uv_loop_t, req: *uv_fs_t, path: *c_char,\n-                cb: *u8) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    rust_uv_fs_unlink(loop_ptr, req, path, cb)\n-}\n-pub unsafe fn fs_write(loop_ptr: *uv_loop_t, req: *uv_fs_t, fd: c_int, buf: *c_void,\n-                       len: uint, offset: i64, cb: *u8) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    rust_uv_fs_write(loop_ptr, req, fd, buf, len as c_uint, offset, cb)\n-}\n-pub unsafe fn fs_read(loop_ptr: *uv_loop_t, req: *uv_fs_t, fd: c_int, buf: *c_void,\n-                       len: uint, offset: i64, cb: *u8) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    rust_uv_fs_read(loop_ptr, req, fd, buf, len as c_uint, offset, cb)\n-}\n-pub unsafe fn fs_close(loop_ptr: *uv_loop_t, req: *uv_fs_t, fd: c_int,\n-                cb: *u8) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    rust_uv_fs_close(loop_ptr, req, fd, cb)\n-}\n-pub unsafe fn fs_stat(loop_ptr: *uv_loop_t, req: *uv_fs_t, path: *c_char, cb: *u8) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    rust_uv_fs_stat(loop_ptr, req, path, cb)\n-}\n-pub unsafe fn fs_fstat(loop_ptr: *uv_loop_t, req: *uv_fs_t, fd: c_int, cb: *u8) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    rust_uv_fs_fstat(loop_ptr, req, fd, cb)\n-}\n-pub unsafe fn fs_mkdir(loop_ptr: *uv_loop_t, req: *uv_fs_t, path: *c_char, mode: int,\n-                cb: *u8) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    rust_uv_fs_mkdir(loop_ptr, req, path, mode as c_int, cb)\n-}\n-pub unsafe fn fs_rmdir(loop_ptr: *uv_loop_t, req: *uv_fs_t, path: *c_char,\n-                cb: *u8) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    rust_uv_fs_rmdir(loop_ptr, req, path, cb)\n-}\n-pub unsafe fn fs_readdir(loop_ptr: *uv_loop_t, req: *uv_fs_t, path: *c_char,\n-                flags: c_int, cb: *u8) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    rust_uv_fs_readdir(loop_ptr, req, path, flags, cb)\n-}\n-pub unsafe fn populate_stat(req_in: *uv_fs_t, stat_out: *uv_stat_t) {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    rust_uv_populate_uv_stat(req_in, stat_out)\n-}\n-pub unsafe fn fs_req_cleanup(req: *uv_fs_t) {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    rust_uv_fs_req_cleanup(req);\n-}\n-\n-pub unsafe fn spawn(loop_ptr: *c_void, result: *uv_process_t,\n-                    options: uv_process_options_t) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    return rust_uv_spawn(loop_ptr, result, options);\n-}\n-\n-pub unsafe fn process_kill(p: *uv_process_t, signum: c_int) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    return rust_uv_process_kill(p, signum);\n-}\n-\n-pub unsafe fn process_pid(p: *uv_process_t) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    return rust_uv_process_pid(p);\n-}\n-\n-pub unsafe fn set_stdio_container_flags(c: *uv_stdio_container_t,\n-                                        flags: libc::c_int) {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    rust_set_stdio_container_flags(c, flags);\n-}\n-\n-pub unsafe fn set_stdio_container_fd(c: *uv_stdio_container_t,\n-                                     fd: libc::c_int) {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    rust_set_stdio_container_fd(c, fd);\n-}\n-\n-pub unsafe fn set_stdio_container_stream(c: *uv_stdio_container_t,\n-                                         stream: *uv_stream_t) {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    rust_set_stdio_container_stream(c, stream);\n-}\n-\n-pub unsafe fn pipe_init(loop_ptr: *c_void, p: *uv_pipe_t, ipc: c_int) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    rust_uv_pipe_init(loop_ptr, p, ipc)\n-}\n-\n-// data access helpers\n-pub unsafe fn get_result_from_fs_req(req: *uv_fs_t) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    rust_uv_get_result_from_fs_req(req)\n-}\n-pub unsafe fn get_ptr_from_fs_req(req: *uv_fs_t) -> *libc::c_void {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    rust_uv_get_ptr_from_fs_req(req)\n-}\n-pub unsafe fn get_loop_from_fs_req(req: *uv_fs_t) -> *uv_loop_t {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    rust_uv_get_loop_from_fs_req(req)\n-}\n-pub unsafe fn get_loop_from_getaddrinfo_req(req: *uv_getaddrinfo_t) -> *uv_loop_t {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    rust_uv_get_loop_from_getaddrinfo_req(req)\n-}\n-pub unsafe fn get_loop_for_uv_handle<T>(handle: *T) -> *c_void {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_get_loop_for_uv_handle(handle as *c_void);\n-}\n-pub unsafe fn get_stream_handle_from_connect_req(connect: *uv_connect_t) -> *uv_stream_t {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_get_stream_handle_from_connect_req(connect);\n-}\n-pub unsafe fn get_stream_handle_from_write_req(write_req: *uv_write_t) -> *uv_stream_t {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_get_stream_handle_from_write_req(write_req);\n-}\n-pub unsafe fn get_data_for_uv_loop(loop_ptr: *c_void) -> *c_void {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    rust_uv_get_data_for_uv_loop(loop_ptr)\n-}\n-pub unsafe fn set_data_for_uv_loop(loop_ptr: *c_void, data: *c_void) {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    rust_uv_set_data_for_uv_loop(loop_ptr, data);\n-}\n-pub unsafe fn get_data_for_uv_handle<T>(handle: *T) -> *c_void {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_get_data_for_uv_handle(handle as *c_void);\n-}\n-pub unsafe fn set_data_for_uv_handle<T, U>(handle: *T, data: *U) {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    rust_uv_set_data_for_uv_handle(handle as *c_void, data as *c_void);\n-}\n-pub unsafe fn get_data_for_req<T>(req: *T) -> *c_void {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_get_data_for_req(req as *c_void);\n-}\n-pub unsafe fn set_data_for_req<T, U>(req: *T, data: *U) {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    rust_uv_set_data_for_req(req as *c_void, data as *c_void);\n-}\n-pub unsafe fn get_base_from_buf(buf: uv_buf_t) -> *u8 {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_get_base_from_buf(buf);\n-}\n-pub unsafe fn get_len_from_buf(buf: uv_buf_t) -> size_t {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_get_len_from_buf(buf);\n-}\n-pub unsafe fn getaddrinfo(loop_: *uv_loop_t, req: *uv_getaddrinfo_t,\n-               getaddrinfo_cb: uv_getaddrinfo_cb,\n-               node: *c_char, service: *c_char,\n-               hints: *addrinfo) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    return rust_uv_getaddrinfo(loop_, req, getaddrinfo_cb, node, service, hints);\n-}\n-pub unsafe fn freeaddrinfo(ai: *addrinfo) {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    rust_uv_freeaddrinfo(ai);\n-}\n-pub unsafe fn pipe_open(pipe: *uv_pipe_t, file: c_int) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    rust_uv_pipe_open(pipe, file)\n-}\n-pub unsafe fn pipe_bind(pipe: *uv_pipe_t, name: *c_char) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    rust_uv_pipe_bind(pipe, name)\n-}\n-pub unsafe fn pipe_connect(req: *uv_connect_t, handle: *uv_pipe_t,\n-                           name: *c_char, cb: uv_connect_cb) {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    rust_uv_pipe_connect(req, handle, name, cb)\n-}\n-pub unsafe fn tty_init(loop_ptr: *uv_loop_t, tty: *uv_tty_t, fd: c_int,\n-                       readable: c_int) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    rust_uv_tty_init(loop_ptr, tty, fd, readable)\n-}\n-pub unsafe fn tty_set_mode(tty: *uv_tty_t, mode: c_int) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    rust_uv_tty_set_mode(tty, mode)\n-}\n-pub unsafe fn tty_get_winsize(tty: *uv_tty_t, width: *c_int,\n-                              height: *c_int) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    rust_uv_tty_get_winsize(tty, width, height)\n-}\n-// FIXME(#9613) this should return uv_handle_type, not a c_int\n-pub unsafe fn guess_handle(fd: c_int) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    rust_uv_guess_handle(fd)\n-}\n-\n-pub unsafe fn signal_init(loop_: *uv_loop_t, handle: *uv_signal_t) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    return rust_uv_signal_init(loop_, handle);\n-}\n-pub unsafe fn signal_start(handle: *uv_signal_t,\n-                           signal_cb: uv_signal_cb,\n-                           signum: c_int) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    return rust_uv_signal_start(handle, signal_cb, signum);\n-}\n-pub unsafe fn signal_stop(handle: *uv_signal_t) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    return rust_uv_signal_stop(handle);\n-}\n-\n-pub struct uv_err_data {\n-    priv err_name: ~str,\n-    priv err_msg: ~str,\n-}\n-\n-extern {\n-\n-    fn rust_uv_handle_size(type_: uintptr_t) -> size_t;\n-    fn rust_uv_req_size(type_: uintptr_t) -> size_t;\n-    fn rust_uv_handle_type_max() -> uintptr_t;\n-    fn rust_uv_req_type_max() -> uintptr_t;\n-\n-    // libuv public API\n-    fn rust_uv_loop_new() -> *c_void;\n-    fn rust_uv_loop_delete(lp: *c_void);\n-    fn rust_uv_run(loop_handle: *c_void);\n-    fn rust_uv_close(handle: *c_void, cb: uv_close_cb);\n-    fn rust_uv_walk(loop_handle: *c_void, cb: uv_walk_cb, arg: *c_void);\n-\n-    fn rust_uv_idle_init(loop_handle: *uv_loop_t, handle: *uv_idle_t) -> c_int;\n-    fn rust_uv_idle_start(handle: *uv_idle_t, cb: uv_idle_cb) -> c_int;\n-    fn rust_uv_idle_stop(handle: *uv_idle_t) -> c_int;\n-\n-    fn rust_uv_async_send(handle: *uv_async_t);\n-    fn rust_uv_async_init(loop_handle: *c_void,\n-                          async_handle: *uv_async_t,\n-                          cb: uv_async_cb) -> c_int;\n-    fn rust_uv_tcp_init(loop_handle: *c_void, handle_ptr: *uv_tcp_t) -> c_int;\n-    fn rust_uv_buf_init(out_buf: *uv_buf_t, base: *u8, len: size_t);\n-    fn rust_uv_strerror(err: c_int) -> *c_char;\n-    fn rust_uv_err_name(err: c_int) -> *c_char;\n-    fn rust_uv_ip4_addrp(ip: *u8, port: c_int) -> *sockaddr_in;\n-    fn rust_uv_ip6_addrp(ip: *u8, port: c_int) -> *sockaddr_in6;\n-    fn rust_uv_free_ip4_addr(addr: *sockaddr_in);\n-    fn rust_uv_free_ip6_addr(addr: *sockaddr_in6);\n-    fn rust_uv_ip4_name(src: *sockaddr_in, dst: *u8, size: size_t) -> c_int;\n-    fn rust_uv_ip6_name(src: *sockaddr_in6, dst: *u8, size: size_t) -> c_int;\n-    fn rust_uv_ip4_port(src: *sockaddr_in) -> c_uint;\n-    fn rust_uv_ip6_port(src: *sockaddr_in6) -> c_uint;\n-    fn rust_uv_tcp_connect(req: *uv_connect_t, handle: *uv_tcp_t,\n-                           cb: uv_connect_cb,\n-                           addr: *sockaddr_in) -> c_int;\n-    fn rust_uv_tcp_bind(tcp_server: *uv_tcp_t, addr: *sockaddr_in) -> c_int;\n-    fn rust_uv_tcp_connect6(req: *uv_connect_t, handle: *uv_tcp_t,\n-                            cb: uv_connect_cb,\n-                            addr: *sockaddr_in6) -> c_int;\n-    fn rust_uv_tcp_bind6(tcp_server: *uv_tcp_t, addr: *sockaddr_in6) -> c_int;\n-    fn rust_uv_tcp_getpeername(tcp_handle_ptr: *uv_tcp_t, name: *sockaddr_storage) -> c_int;\n-    fn rust_uv_tcp_getsockname(handle: *uv_tcp_t, name: *sockaddr_storage) -> c_int;\n-    fn rust_uv_tcp_nodelay(handle: *uv_tcp_t, enable: c_int) -> c_int;\n-    fn rust_uv_tcp_keepalive(handle: *uv_tcp_t, enable: c_int, delay: c_uint) -> c_int;\n-    fn rust_uv_tcp_simultaneous_accepts(handle: *uv_tcp_t, enable: c_int) -> c_int;\n-\n-    fn rust_uv_udp_init(loop_handle: *uv_loop_t, handle_ptr: *uv_udp_t) -> c_int;\n-    fn rust_uv_udp_bind(server: *uv_udp_t, addr: *sockaddr_in, flags: c_uint) -> c_int;\n-    fn rust_uv_udp_bind6(server: *uv_udp_t, addr: *sockaddr_in6, flags: c_uint) -> c_int;\n-    fn rust_uv_udp_send(req: *uv_udp_send_t, handle: *uv_udp_t, buf_in: *uv_buf_t,\n-                        buf_cnt: c_int, addr: *sockaddr_in, cb: uv_udp_send_cb) -> c_int;\n-    fn rust_uv_udp_send6(req: *uv_udp_send_t, handle: *uv_udp_t, buf_in: *uv_buf_t,\n-                         buf_cnt: c_int, addr: *sockaddr_in6, cb: uv_udp_send_cb) -> c_int;\n-    fn rust_uv_udp_recv_start(server: *uv_udp_t,\n-                              on_alloc: uv_alloc_cb,\n-                              on_recv: uv_udp_recv_cb) -> c_int;\n-    fn rust_uv_udp_recv_stop(server: *uv_udp_t) -> c_int;\n-    fn rust_uv_get_udp_handle_from_send_req(req: *uv_udp_send_t) -> *uv_udp_t;\n-    fn rust_uv_udp_getsockname(handle: *uv_udp_t, name: *sockaddr_storage) -> c_int;\n-    fn rust_uv_udp_set_membership(handle: *uv_udp_t, multicast_addr: *c_char,\n-                                  interface_addr: *c_char, membership: c_int) -> c_int;\n-    fn rust_uv_udp_set_multicast_loop(handle: *uv_udp_t, on: c_int) -> c_int;\n-    fn rust_uv_udp_set_multicast_ttl(handle: *uv_udp_t, ttl: c_int) -> c_int;\n-    fn rust_uv_udp_set_ttl(handle: *uv_udp_t, ttl: c_int) -> c_int;\n-    fn rust_uv_udp_set_broadcast(handle: *uv_udp_t, on: c_int) -> c_int;\n-\n-    fn rust_uv_is_ipv4_sockaddr(addr: *sockaddr) -> c_int;\n-    fn rust_uv_is_ipv6_sockaddr(addr: *sockaddr) -> c_int;\n-    fn rust_uv_malloc_sockaddr_storage() -> *sockaddr_storage;\n-    fn rust_uv_free_sockaddr_storage(ss: *sockaddr_storage);\n-\n-    fn rust_uv_listen(stream: *c_void, backlog: c_int,\n-                      cb: uv_connection_cb) -> c_int;\n-    fn rust_uv_accept(server: *c_void, client: *c_void) -> c_int;\n-    fn rust_uv_write(req: *c_void, stream: *c_void, buf_in: *uv_buf_t, buf_cnt: c_int,\n-                     cb: uv_write_cb) -> c_int;\n-    fn rust_uv_read_start(stream: *c_void,\n-                          on_alloc: uv_alloc_cb,\n-                          on_read: uv_read_cb) -> c_int;\n-    fn rust_uv_read_stop(stream: *c_void) -> c_int;\n-    fn rust_uv_timer_init(loop_handle: *c_void, timer_handle: *uv_timer_t) -> c_int;\n-    fn rust_uv_timer_start(timer_handle: *uv_timer_t, cb: uv_timer_cb, timeout: libc::uint64_t,\n-                           repeat: libc::uint64_t) -> c_int;\n-    fn rust_uv_timer_stop(handle: *uv_timer_t) -> c_int;\n-    fn rust_uv_fs_open(loop_ptr: *c_void, req: *uv_fs_t, path: *c_char,\n-                       flags: c_int, mode: c_int, cb: *u8) -> c_int;\n-    fn rust_uv_fs_unlink(loop_ptr: *c_void, req: *uv_fs_t, path: *c_char,\n-                       cb: *u8) -> c_int;\n-    fn rust_uv_fs_write(loop_ptr: *c_void, req: *uv_fs_t, fd: c_int,\n-                       buf: *c_void, len: c_uint, offset: i64, cb: *u8) -> c_int;\n-    fn rust_uv_fs_read(loop_ptr: *c_void, req: *uv_fs_t, fd: c_int,\n-                       buf: *c_void, len: c_uint, offset: i64, cb: *u8) -> c_int;\n-    fn rust_uv_fs_close(loop_ptr: *c_void, req: *uv_fs_t, fd: c_int,\n-                        cb: *u8) -> c_int;\n-    fn rust_uv_fs_stat(loop_ptr: *c_void, req: *uv_fs_t, path: *c_char, cb: *u8) -> c_int;\n-    fn rust_uv_fs_fstat(loop_ptr: *c_void, req: *uv_fs_t, fd: c_int, cb: *u8) -> c_int;\n-    fn rust_uv_fs_mkdir(loop_ptr: *c_void, req: *uv_fs_t, path: *c_char,\n-                        mode: c_int, cb: *u8) -> c_int;\n-    fn rust_uv_fs_rmdir(loop_ptr: *c_void, req: *uv_fs_t, path: *c_char,\n-                        cb: *u8) -> c_int;\n-    fn rust_uv_fs_readdir(loop_ptr: *c_void, req: *uv_fs_t, path: *c_char,\n-                        flags: c_int, cb: *u8) -> c_int;\n-    fn rust_uv_fs_req_cleanup(req: *uv_fs_t);\n-    fn rust_uv_populate_uv_stat(req_in: *uv_fs_t, stat_out: *uv_stat_t);\n-    fn rust_uv_get_result_from_fs_req(req: *uv_fs_t) -> c_int;\n-    fn rust_uv_get_ptr_from_fs_req(req: *uv_fs_t) -> *libc::c_void;\n-    fn rust_uv_get_loop_from_fs_req(req: *uv_fs_t) -> *uv_loop_t;\n-    fn rust_uv_get_loop_from_getaddrinfo_req(req: *uv_fs_t) -> *uv_loop_t;\n-\n-    fn rust_uv_get_stream_handle_from_connect_req(connect_req: *uv_connect_t) -> *uv_stream_t;\n-    fn rust_uv_get_stream_handle_from_write_req(write_req: *uv_write_t) -> *uv_stream_t;\n-    fn rust_uv_get_loop_for_uv_handle(handle: *c_void) -> *c_void;\n-    fn rust_uv_get_data_for_uv_loop(loop_ptr: *c_void) -> *c_void;\n-    fn rust_uv_set_data_for_uv_loop(loop_ptr: *c_void, data: *c_void);\n-    fn rust_uv_get_data_for_uv_handle(handle: *c_void) -> *c_void;\n-    fn rust_uv_set_data_for_uv_handle(handle: *c_void, data: *c_void);\n-    fn rust_uv_get_data_for_req(req: *c_void) -> *c_void;\n-    fn rust_uv_set_data_for_req(req: *c_void, data: *c_void);\n-    fn rust_uv_get_base_from_buf(buf: uv_buf_t) -> *u8;\n-    fn rust_uv_get_len_from_buf(buf: uv_buf_t) -> size_t;\n-    fn rust_uv_getaddrinfo(loop_: *uv_loop_t, req: *uv_getaddrinfo_t,\n-                           getaddrinfo_cb: uv_getaddrinfo_cb,\n-                           node: *c_char, service: *c_char,\n-                           hints: *addrinfo) -> c_int;\n-    fn rust_uv_freeaddrinfo(ai: *addrinfo);\n-    fn rust_uv_spawn(loop_ptr: *c_void, outptr: *uv_process_t,\n-                     options: uv_process_options_t) -> c_int;\n-    fn rust_uv_process_kill(p: *uv_process_t, signum: c_int) -> c_int;\n-    fn rust_uv_process_pid(p: *uv_process_t) -> c_int;\n-    fn rust_set_stdio_container_flags(c: *uv_stdio_container_t, flags: c_int);\n-    fn rust_set_stdio_container_fd(c: *uv_stdio_container_t, fd: c_int);\n-    fn rust_set_stdio_container_stream(c: *uv_stdio_container_t,\n-                                       stream: *uv_stream_t);\n-    fn rust_uv_pipe_init(loop_ptr: *c_void, p: *uv_pipe_t, ipc: c_int) -> c_int;\n-\n-    fn rust_uv_pipe_open(pipe: *uv_pipe_t, file: c_int) -> c_int;\n-    fn rust_uv_pipe_bind(pipe: *uv_pipe_t, name: *c_char) -> c_int;\n-    fn rust_uv_pipe_connect(req: *uv_connect_t, handle: *uv_pipe_t,\n-                            name: *c_char, cb: uv_connect_cb);\n-    fn rust_uv_tty_init(loop_ptr: *uv_loop_t, tty: *uv_tty_t, fd: c_int,\n-                        readable: c_int) -> c_int;\n-    fn rust_uv_tty_set_mode(tty: *uv_tty_t, mode: c_int) -> c_int;\n-    fn rust_uv_tty_get_winsize(tty: *uv_tty_t, width: *c_int,\n-                               height: *c_int) -> c_int;\n-    fn rust_uv_guess_handle(fd: c_int) -> c_int;\n-\n-    // XXX: see comments in addrinfo.rs\n-    // These should all really be constants...\n-    //#[rust_stack] pub fn rust_SOCK_STREAM() -> c_int;\n-    //#[rust_stack] pub fn rust_SOCK_DGRAM() -> c_int;\n-    //#[rust_stack] pub fn rust_SOCK_RAW() -> c_int;\n-    //#[rust_stack] pub fn rust_IPPROTO_UDP() -> c_int;\n-    //#[rust_stack] pub fn rust_IPPROTO_TCP() -> c_int;\n-    //#[rust_stack] pub fn rust_AI_ADDRCONFIG() -> c_int;\n-    //#[rust_stack] pub fn rust_AI_ALL() -> c_int;\n-    //#[rust_stack] pub fn rust_AI_CANONNAME() -> c_int;\n-    //#[rust_stack] pub fn rust_AI_NUMERICHOST() -> c_int;\n-    //#[rust_stack] pub fn rust_AI_NUMERICSERV() -> c_int;\n-    //#[rust_stack] pub fn rust_AI_PASSIVE() -> c_int;\n-    //#[rust_stack] pub fn rust_AI_V4MAPPED() -> c_int;\n-\n-    fn rust_uv_signal_init(loop_: *uv_loop_t, handle: *uv_signal_t) -> c_int;\n-    fn rust_uv_signal_start(handle: *uv_signal_t,\n-                            signal_cb: uv_signal_cb,\n-                            signum: c_int) -> c_int;\n-    fn rust_uv_signal_stop(handle: *uv_signal_t) -> c_int;\n-}"}, {"sha": "7a12e2fd60d95eda4569e16c08b6f8c76256c59b", "filename": "src/snapshots.txt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e203f30bc743ff3de271d8db80acd21991e903df/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/e203f30bc743ff3de271d8db80acd21991e903df/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=e203f30bc743ff3de271d8db80acd21991e903df", "patch": "@@ -1,3 +1,11 @@\n+S 2013-10-29 fed48cc\n+  freebsd-x86_64 4a43216b432511a5fd6b727753aedb749f6a68dc\n+  linux-i386 53f65d4b1377c17fc12d05d7c4a0fbd92eea071f\n+  linux-x86_64 afa5f19a37a2cf137e5d4277951fa07efda8e072\n+  macos-i386 7522c24f78ed35020e2877e3eada058ea8a11f35\n+  macos-x86_64 a18afdcbbdbb81c1fdf08788b24f0d3ea8701eb1\n+  winnt-i386 c78f0839c9524eda33c54a5232121886021b5352\n+\n S 2013-10-28 2ab4a6f\n   freebsd-x86_64 08af04bcf739930bdb7d0ad244b2c8094cd5096a\n   linux-i386 c233de1ed09872d5c7a3e1ce9ab9eb6e16631201"}]}