{"sha": "40c78ab037c70d61eb4f8c95c7a4fec8f098644b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwYzc4YWIwMzdjNzBkNjFlYjRmOGM5NWM3YTRmZWM4ZjA5ODY0NGI=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-11-14T22:38:41Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-11-21T01:19:24Z"}, "message": "Fallout from libgreen and libnative removal", "tree": {"sha": "83d66a065a6c79f702c62d7abaf54145353a2dc4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/83d66a065a6c79f702c62d7abaf54145353a2dc4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/40c78ab037c70d61eb4f8c95c7a4fec8f098644b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/40c78ab037c70d61eb4f8c95c7a4fec8f098644b", "html_url": "https://github.com/rust-lang/rust/commit/40c78ab037c70d61eb4f8c95c7a4fec8f098644b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/40c78ab037c70d61eb4f8c95c7a4fec8f098644b/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a68ec98166bf638c6cbf4036f51036012695718d", "url": "https://api.github.com/repos/rust-lang/rust/commits/a68ec98166bf638c6cbf4036f51036012695718d", "html_url": "https://github.com/rust-lang/rust/commit/a68ec98166bf638c6cbf4036f51036012695718d"}], "stats": {"total": 396, "additions": 47, "deletions": 349}, "files": [{"sha": "012b43a2b0050479d11cfaca25202a52ac469efa", "filename": "mk/crates.mk", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/40c78ab037c70d61eb4f8c95c7a4fec8f098644b/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/40c78ab037c70d61eb4f8c95c7a4fec8f098644b/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=40c78ab037c70d61eb4f8c95c7a4fec8f098644b", "patch": "@@ -37,7 +37,7 @@\n #\n #   DEPS_<crate>\n #\tThese lists are the dependencies of the <crate> that is to be built.\n-#\tRust dependencies are listed bare (i.e. std, green) and native\n+#\tRust dependencies are listed bare (i.e. std) and native\n #\tdependencies have a \"native:\" prefix (i.e. native:hoedown). All deps\n #\twill be built before the crate itself is built.\n #\n@@ -49,7 +49,7 @@\n # automatically generated for all stage/host/target combinations.\n ################################################################################\n \n-TARGET_CRATES := libc std green flate arena term \\\n+TARGET_CRATES := libc std flate arena term \\\n                  serialize sync getopts collections test time rand \\\n                  log regex graphviz core rbml alloc rustrt \\\n                  unicode\n@@ -66,7 +66,6 @@ DEPS_rustrt := alloc core libc collections native:rustrt_native\n DEPS_std := core libc rand alloc collections rustrt sync unicode \\\n \tnative:rust_builtin native:backtrace\n DEPS_graphviz := std\n-DEPS_green := std native:context_switch\n DEPS_syntax := std term serialize log fmt_macros arena libc\n DEPS_rustc_trans := rustc rustc_back rustc_llvm libc\n DEPS_rustc := syntax flate arena serialize getopts rbml \\"}, {"sha": "c72fd14ec5b6d09487e80d1f6c0938942a906bfa", "filename": "src/README.md", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40c78ab037c70d61eb4f8c95c7a4fec8f098644b/src%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/40c78ab037c70d61eb4f8c95c7a4fec8f098644b/src%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FREADME.md?ref=40c78ab037c70d61eb4f8c95c7a4fec8f098644b", "patch": "@@ -9,8 +9,6 @@ Source layout:\n | `libcore/`          | The Rust core library                                     |\n | `libdebug/`         | Debugging utilities                                       |\n | `libstd/`           | The standard library (imported and linked by default)     |\n-| `libgreen/`         | The M:N runtime library                                   |\n-| `libnative/`        | The 1:1 runtime library                                   |\n | `libsyntax/`        | The Rust parser and pretty-printer                        |\n | `libtest/`          | Rust's test-runner code                                   |\n | ------------------- | --------------------------------------------------------- |"}, {"sha": "f732e06062ecd67a5574892fa253a8aca29e5844", "filename": "src/doc/reference.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/40c78ab037c70d61eb4f8c95c7a4fec8f098644b/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/40c78ab037c70d61eb4f8c95c7a4fec8f098644b/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=40c78ab037c70d61eb4f8c95c7a4fec8f098644b", "patch": "@@ -999,14 +999,14 @@ An example of what will and will not work for `use` items:\n \n ```\n # #![allow(unused_imports)]\n-use foo::native::start;  // good: foo is at the root of the crate\n+use foo::core::iter;  // good: foo is at the root of the crate\n use foo::baz::foobaz;    // good: foo is at the root of the crate\n \n mod foo {\n-    extern crate native;\n+    extern crate core;\n \n-    use foo::native::start; // good: foo is at crate root\n-//  use native::start;      // bad:  native is not at the crate root\n+    use foo::core::iter; // good: foo is at crate root\n+//  use core::iter;      // bad:  native is not at the crate root\n     use self::baz::foobaz;  // good: self refers to module 'foo'\n     use foo::bar::foobar;   // good: foo is at crate root\n "}, {"sha": "173ca008d0356762a3b78b9ea715f6ecae96de86", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/40c78ab037c70d61eb4f8c95c7a4fec8f098644b/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40c78ab037c70d61eb4f8c95c7a4fec8f098644b/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=40c78ab037c70d61eb4f8c95c7a4fec8f098644b", "patch": "@@ -73,7 +73,6 @@ extern crate libc;\n \n // Allow testing this library\n \n-#[cfg(test)] extern crate native;\n #[cfg(test)] #[phase(plugin, link)] extern crate std;\n #[cfg(test)] #[phase(plugin, link)] extern crate log;\n "}, {"sha": "7965ac26a62f8bc22dc4e9bfed43e443a1424376", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/40c78ab037c70d61eb4f8c95c7a4fec8f098644b/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40c78ab037c70d61eb4f8c95c7a4fec8f098644b/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=40c78ab037c70d61eb4f8c95c7a4fec8f098644b", "patch": "@@ -31,7 +31,6 @@\n extern crate unicode;\n extern crate alloc;\n \n-#[cfg(test)] extern crate native;\n #[cfg(test)] extern crate test;\n \n #[cfg(test)] #[phase(plugin, link)] extern crate std;"}, {"sha": "10610b705840650b6a227d901ea903f62a99e01b", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/40c78ab037c70d61eb4f8c95c7a4fec8f098644b/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40c78ab037c70d61eb4f8c95c7a4fec8f098644b/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=40c78ab037c70d61eb4f8c95c7a4fec8f098644b", "patch": "@@ -83,7 +83,6 @@ extern crate core;\n \n #[cfg(test)] extern crate std;\n #[cfg(test)] extern crate test;\n-#[cfg(test)] extern crate native;\n \n pub use self::Nullable::*;\n "}, {"sha": "1ff66d0653f9652085951eefdca6a1f5dd479737", "filename": "src/librand/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/40c78ab037c70d61eb4f8c95c7a4fec8f098644b/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40c78ab037c70d61eb4f8c95c7a4fec8f098644b/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=40c78ab037c70d61eb4f8c95c7a4fec8f098644b", "patch": "@@ -33,7 +33,6 @@ extern crate core;\n \n #[cfg(test)] #[phase(plugin, link)] extern crate std;\n #[cfg(test)] #[phase(plugin, link)] extern crate log;\n-#[cfg(test)] extern crate native;\n \n use core::prelude::*;\n "}, {"sha": "65e6bdb70f818babdb017c2dde3130fe238217d2", "filename": "src/librustrt/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/40c78ab037c70d61eb4f8c95c7a4fec8f098644b/src%2Flibrustrt%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40c78ab037c70d61eb4f8c95c7a4fec8f098644b/src%2Flibrustrt%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flib.rs?ref=40c78ab037c70d61eb4f8c95c7a4fec8f098644b", "patch": "@@ -30,7 +30,6 @@ extern crate collections;\n \n #[cfg(test)] extern crate \"rustrt\" as realrustrt;\n #[cfg(test)] extern crate test;\n-#[cfg(test)] extern crate native;\n \n #[cfg(test)] #[phase(plugin, link)] extern crate std;\n "}, {"sha": "193484496800480f9cf4c88387b84b0fefa9c82f", "filename": "src/librustrt/stack_overflow.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/40c78ab037c70d61eb4f8c95c7a4fec8f098644b/src%2Flibrustrt%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40c78ab037c70d61eb4f8c95c7a4fec8f098644b/src%2Flibrustrt%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fstack_overflow.rs?ref=40c78ab037c70d61eb4f8c95c7a4fec8f098644b", "patch": "@@ -65,14 +65,7 @@ pub unsafe fn report() {\n #[cfg(any(windows, target_os = \"linux\", target_os = \"macos\"))]\n unsafe fn get_task_guard_page() -> Option<uint> {\n     let task: Option<*mut Task> = Local::try_unsafe_borrow();\n-\n-    task.map(|task| {\n-        let runtime = (*task).take_runtime();\n-        let guard = runtime.stack_guard();\n-        (*task).put_runtime(runtime);\n-\n-        guard.unwrap_or(0)\n-    })\n+    task.map(|task| (&*task).stack_guard().unwrap_or(0))\n }\n \n #[cfg(windows)]"}, {"sha": "d4d24c1e12fc88449391980fe6f56358cc424092", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40c78ab037c70d61eb4f8c95c7a4fec8f098644b/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40c78ab037c70d61eb4f8c95c7a4fec8f098644b/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=40c78ab037c70d61eb4f8c95c7a4fec8f098644b", "patch": "@@ -740,8 +740,6 @@ impl Drop for Process {\n mod tests {\n     #![allow(unused_imports)]\n \n-    extern crate native;\n-\n     use super::*;\n     use prelude::*;\n     use io::timer::*;"}, {"sha": "c27faea74bb8f56f560ea350585017f660de2729", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/40c78ab037c70d61eb4f8c95c7a4fec8f098644b/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40c78ab037c70d61eb4f8c95c7a4fec8f098644b/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=40c78ab037c70d61eb4f8c95c7a4fec8f098644b", "patch": "@@ -117,7 +117,6 @@\n \n #![reexport_test_harness_main = \"test_main\"]\n \n-#[cfg(test)] extern crate green;\n #[cfg(test)] #[phase(plugin, link)] extern crate log;\n \n extern crate alloc;"}, {"sha": "b6e57186afef19c736c3aa367d6140c2e8af1f07", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/40c78ab037c70d61eb4f8c95c7a4fec8f098644b/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40c78ab037c70d61eb4f8c95c7a4fec8f098644b/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=40c78ab037c70d61eb4f8c95c7a4fec8f098644b", "patch": "@@ -58,17 +58,17 @@ Several modules in `core` are clients of `rt`:\n \n use failure;\n use rustrt;\n-use startup;\n+use os;\n \n // Reexport some of our utilities which are expected by other crates.\n pub use self::util::{default_sched_threads, min_stack, running_on_valgrind};\n \n // Reexport functionality from librustrt and other crates underneath the\n // standard library which work together to create the entire runtime.\n pub use alloc::heap;\n-pub use rustrt::{task, local, mutex, exclusive, stack, args, rtio, thread};\n+pub use rustrt::{task, local, mutex, exclusive, stack, args, thread};\n pub use rustrt::{Stdio, Stdout, Stderr, begin_unwind, begin_unwind_fmt};\n-pub use rustrt::{bookkeeping, at_exit, unwind, DEFAULT_ERROR_CODE, Runtime};\n+pub use rustrt::{at_exit, unwind, DEFAULT_ERROR_CODE};\n \n // Simple backtrace functionality (to print on panic)\n pub mod backtrace;\n@@ -95,7 +95,7 @@ static OS_DEFAULT_STACK_ESTIMATE: uint = 2 * (1 << 20);\n #[cfg(not(test))]\n #[lang = \"start\"]\n fn lang_start(main: *const u8, argc: int, argv: *const *const u8) -> int {\n-    use std::mem;\n+    use mem;\n     start(argc, argv, proc() {\n         let main: extern \"Rust\" fn() = unsafe { mem::transmute(main) };\n         main();\n@@ -147,8 +147,8 @@ pub fn start(argc: int, argv: *const *const u8, main: proc()) -> int {\n     init(argc, argv);\n     let mut exit_code = None;\n     let mut main = Some(main);\n-    let mut task = task::new((my_stack_bottom, my_stack_top),\n-                             rt::thread::main_guard_page());\n+    let mut task = Task::new(Some((my_stack_bottom, my_stack_top)),\n+                             Some(rt::thread::main_guard_page()));\n     task.name = Some(str::Slice(\"<main>\"));\n     drop(task.run(|| {\n         unsafe {"}, {"sha": "d7c286bf0b9f2e85cbfd8c1c62a1f666216ca1b2", "filename": "src/libstd/sys/common/helper_thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40c78ab037c70d61eb4f8c95c7a4fec8f098644b/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40c78ab037c70d61eb4f8c95c7a4fec8f098644b/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs?ref=40c78ab037c70d61eb4f8c95c7a4fec8f098644b", "patch": "@@ -21,7 +21,7 @@\n //! time.\n \n use mem;\n-use rt::bookkeeping;\n+use rustrt::bookkeeping;\n use rt::mutex::StaticNativeMutex;\n use rt;\n use cell::UnsafeCell;"}, {"sha": "8da32ba4b89cd1c5bcdbcdee093e3e33b45caab6", "filename": "src/libstd/task.rs", "status": "modified", "additions": 12, "deletions": 114, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/40c78ab037c70d61eb4f8c95c7a4fec8f098644b/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40c78ab037c70d61eb4f8c95c7a4fec8f098644b/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=40c78ab037c70d61eb4f8c95c7a4fec8f098644b", "patch": "@@ -11,11 +11,7 @@\n //! Task creation\n //!\n //! An executing Rust program consists of a collection of tasks, each\n-//! with their own stack and local state. A Rust task is typically\n-//! backed by an operating system thread, making tasks 'just threads',\n-//! but may also be implemented via other strategies as well\n-//! (e.g. Rust comes with the [`green`](../../green/index.html)\n-//! scheduling crate for creating tasks backed by green threads).\n+//! with their own stack and local state.\n //!\n //! Tasks generally have their memory *isolated* from each other by\n //! virtue of Rust's owned types (which of course may only be owned by\n@@ -36,60 +32,13 @@\n //! the main task panics the application will exit with a non-zero\n //! exit code.\n //!\n-//! # Basic task scheduling\n-//!\n-//! By default, every task is created with the same \"flavor\" as the calling task.\n-//! This flavor refers to the scheduling mode, with two possibilities currently\n-//! being 1:1 and M:N modes. Green (M:N) tasks are cooperatively scheduled and\n-//! native (1:1) tasks are scheduled by the OS kernel.\n-//!\n //! ## Example\n //!\n //! ```rust\n //! spawn(proc() {\n //!     println!(\"Hello, World!\");\n //! })\n //! ```\n-//!\n-//! # Advanced task scheduling\n-//!\n-//! Task spawning can also be configured to use a particular scheduler, to\n-//! redirect the new task's output, or to yield a `future` representing the\n-//! task's final result. The configuration is established using the\n-//! `TaskBuilder` API:\n-//!\n-//! ## Example\n-//!\n-//! ```rust\n-//! extern crate green;\n-//! extern crate native;\n-//!\n-//! use std::task::TaskBuilder;\n-//! use green::{SchedPool, PoolConfig, GreenTaskBuilder};\n-//! use native::NativeTaskBuilder;\n-//!\n-//! # fn main() {\n-//! // Create a green scheduler pool with the default configuration\n-//! let mut pool = SchedPool::new(PoolConfig::new());\n-//!\n-//! // Spawn a task in the green pool\n-//! let mut fut_green = TaskBuilder::new().green(&mut pool).try_future(proc() {\n-//!     /* ... */\n-//! });\n-//!\n-//! // Spawn a native task\n-//! let mut fut_native = TaskBuilder::new().native().try_future(proc() {\n-//!     /* ... */\n-//! });\n-//!\n-//! // Wait for both tasks to finish, recording their outcome\n-//! let res_green  = fut_green.unwrap();\n-//! let res_native = fut_native.unwrap();\n-//!\n-//! // Shut down the green scheduler pool\n-//! pool.shutdown();\n-//! # }\n-//! ```\n \n #![unstable = \"The task spawning model will be changed as part of runtime reform, and the module \\\n                will likely be renamed from `task` to `thread`.\"]\n@@ -108,26 +57,6 @@ use str::{Str, SendStr, IntoMaybeOwned};\n use string::{String, ToString};\n use sync::Future;\n \n-/// A means of spawning a task\n-pub trait Spawner {\n-    /// Spawn a task, given low-level task options.\n-    fn spawn(self, opts: task::TaskOpts, f: proc():Send);\n-}\n-\n-/// The default task spawner, which spawns siblings to the current task.\n-pub struct SiblingSpawner;\n-\n-impl Spawner for SiblingSpawner {\n-    fn spawn(self, opts: task::TaskOpts, f: proc():Send) {\n-        // bind tb to provide type annotation\n-        let tb: Option<Box<Task>> = Local::try_take();\n-        match tb {\n-            Some(t) => t.spawn_sibling(opts, f),\n-            None => panic!(\"need a local task to spawn a sibling task\"),\n-        };\n-    }\n-}\n-\n /// The task builder type.\n ///\n /// Provides detailed control over the properties and behavior of new tasks.\n@@ -139,7 +68,7 @@ impl Spawner for SiblingSpawner {\n // when you try to reuse the builder to spawn a new task. We'll just\n // sidestep that whole issue by making builders uncopyable and making\n // the run function move them in.\n-pub struct TaskBuilder<S = SiblingSpawner> {\n+pub struct TaskBuilder {\n     // A name for the task-to-be, for identification in panic messages\n     name: Option<SendStr>,\n     // The size of the stack for the spawned task\n@@ -148,88 +77,60 @@ pub struct TaskBuilder<S = SiblingSpawner> {\n     stdout: Option<Box<Writer + Send>>,\n     // Task-local stderr\n     stderr: Option<Box<Writer + Send>>,\n-    // The mechanics of actually spawning the task (i.e.: green or native)\n-    spawner: S,\n     // Optionally wrap the eventual task body\n     gen_body: Option<proc(v: proc():Send):Send -> proc():Send>,\n     nocopy: marker::NoCopy,\n }\n \n-impl TaskBuilder<SiblingSpawner> {\n+impl TaskBuilder {\n     /// Generate the base configuration for spawning a task, off of which more\n     /// configuration methods can be chained.\n-    pub fn new() -> TaskBuilder<SiblingSpawner> {\n+    pub fn new() -> TaskBuilder {\n         TaskBuilder {\n             name: None,\n             stack_size: None,\n             stdout: None,\n             stderr: None,\n-            spawner: SiblingSpawner,\n             gen_body: None,\n             nocopy: marker::NoCopy,\n         }\n     }\n }\n \n-impl<S: Spawner> TaskBuilder<S> {\n+impl TaskBuilder {\n     /// Name the task-to-be. Currently the name is used for identification\n     /// only in panic messages.\n     #[unstable = \"IntoMaybeOwned will probably change.\"]\n-    pub fn named<T: IntoMaybeOwned<'static>>(mut self, name: T) -> TaskBuilder<S> {\n+    pub fn named<T: IntoMaybeOwned<'static>>(mut self, name: T) -> TaskBuilder {\n         self.name = Some(name.into_maybe_owned());\n         self\n     }\n \n     /// Set the size of the stack for the new task.\n-    pub fn stack_size(mut self, size: uint) -> TaskBuilder<S> {\n+    pub fn stack_size(mut self, size: uint) -> TaskBuilder {\n         self.stack_size = Some(size);\n         self\n     }\n \n     /// Redirect task-local stdout.\n     #[experimental = \"May not want to make stdio overridable here.\"]\n-    pub fn stdout(mut self, stdout: Box<Writer + Send>) -> TaskBuilder<S> {\n+    pub fn stdout(mut self, stdout: Box<Writer + Send>) -> TaskBuilder {\n         self.stdout = Some(stdout);\n         self\n     }\n \n     /// Redirect task-local stderr.\n     #[experimental = \"May not want to make stdio overridable here.\"]\n-    pub fn stderr(mut self, stderr: Box<Writer + Send>) -> TaskBuilder<S> {\n+    pub fn stderr(mut self, stderr: Box<Writer + Send>) -> TaskBuilder {\n         self.stderr = Some(stderr);\n         self\n     }\n \n-    /// Set the spawning mechanism for the task.\n-    ///\n-    /// The `TaskBuilder` API configures a task to be spawned, but defers to the\n-    /// \"spawner\" to actually create and spawn the task. The `spawner` method\n-    /// should not be called directly by `TaskBuiler` clients. It is intended\n-    /// for use by downstream crates (like `native` and `green`) that implement\n-    /// tasks. These downstream crates then add extension methods to the\n-    /// builder, like `.native()` and `.green(pool)`, that actually set the\n-    /// spawner.\n-    pub fn spawner<T: Spawner>(self, spawner: T) -> TaskBuilder<T> {\n-        // repackage the entire TaskBuilder since its type is changing.\n-        let TaskBuilder {\n-            name, stack_size, stdout, stderr, spawner: _, gen_body, nocopy\n-        } = self;\n-        TaskBuilder {\n-            name: name,\n-            stack_size: stack_size,\n-            stdout: stdout,\n-            stderr: stderr,\n-            spawner: spawner,\n-            gen_body: gen_body,\n-            nocopy: nocopy,\n-        }\n-    }\n-\n     // Where spawning actually happens (whether yielding a future or not)\n     fn spawn_internal(self, f: proc():Send,\n                       on_exit: Option<proc(Result<(), Box<Any + Send>>):Send>) {\n         let TaskBuilder {\n-            name, stack_size, stdout, stderr, spawner, mut gen_body, nocopy: _\n+            name, stack_size, stdout, stderr, mut gen_body, nocopy: _\n         } = self;\n         let f = match gen_body.take() {\n             Some(gen) => gen(f),\n@@ -348,11 +249,8 @@ pub fn name() -> Option<String> {\n /// Yield control to the task scheduler.\n #[unstable = \"Name will change.\"]\n pub fn deschedule() {\n-    use rt::local::Local;\n-\n-    // FIXME(#7544): Optimize this, since we know we won't block.\n-    let task: Box<Task> = Local::take();\n-    task.yield_now();\n+    use rt::task::Task;\n+    Task::yield_now();\n }\n \n /// True if the running task is currently panicking (e.g. will return `true` inside a"}, {"sha": "b4b2ef5218cef756f8c9fcca9235348662f8ce8c", "filename": "src/libsync/atomic.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/40c78ab037c70d61eb4f8c95c7a4fec8f098644b/src%2Flibsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40c78ab037c70d61eb4f8c95c7a4fec8f098644b/src%2Flibsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fatomic.rs?ref=40c78ab037c70d61eb4f8c95c7a4fec8f098644b", "patch": "@@ -42,7 +42,6 @@\n //! ```\n //! use std::sync::Arc;\n //! use std::sync::atomic::{AtomicUint, SeqCst};\n-//! use std::task::deschedule;\n //!\n //! fn main() {\n //!     let spinlock = Arc::new(AtomicUint::new(1));\n@@ -53,13 +52,7 @@\n //!     });\n //!\n //!     // Wait for the other task to release the lock\n-//!     while spinlock.load(SeqCst) != 0 {\n-//!         // Since tasks may not be preemptive (if they are green threads)\n-//!         // yield to the scheduler to let the other task run. Low level\n-//!         // concurrent code needs to take into account Rust's two threading\n-//!         // models.\n-//!         deschedule();\n-//!     }\n+//!     while spinlock.load(SeqCst) != 0 {}\n //! }\n //! ```\n //!"}, {"sha": "02fdc69448ef70af2152a5ac608962118034276b", "filename": "src/libsync/comm/mod.rs", "status": "modified", "additions": 3, "deletions": 52, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/40c78ab037c70d61eb4f8c95c7a4fec8f098644b/src%2Flibsync%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40c78ab037c70d61eb4f8c95c7a4fec8f098644b/src%2Flibsync%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fcomm%2Fmod.rs?ref=40c78ab037c70d61eb4f8c95c7a4fec8f098644b", "patch": "@@ -65,10 +65,6 @@\n //! the `try_send` method on a `SyncSender`, but no other operations are\n //! guaranteed to be safe.\n //!\n-//! Additionally, channels can interoperate between runtimes. If one task in a\n-//! program is running on libnative and another is running on libgreen, they can\n-//! still communicate with one another using channels.\n-//!\n //! # Example\n //!\n //! Simple usage:\n@@ -328,13 +324,10 @@ pub use self::TrySendError::*;\n use self::Flavor::*;\n \n use alloc::arc::Arc;\n-use alloc::boxed::Box;\n-use core::cell::Cell;\n use core::kinds::marker;\n use core::mem;\n use core::cell::UnsafeCell;\n-use rustrt::local::Local;\n-use rustrt::task::{Task, BlockedTask};\n+use rustrt::task::BlockedTask;\n \n pub use comm::select::{Select, Handle};\n \n@@ -345,21 +338,12 @@ macro_rules! test (\n \n             use std::prelude::*;\n \n-            use native;\n             use comm::*;\n             use super::*;\n             use super::super::*;\n             use std::task;\n \n-            fn f() $b\n-\n-            $(#[$a])* #[test] fn uv() { f() }\n-            $(#[$a])* #[test] fn native() {\n-                use native;\n-                let (tx, rx) = channel();\n-                spawn(proc() { tx.send(f()) });\n-                rx.recv();\n-            }\n+            $(#[$a])* #[test] fn f() { $b }\n         }\n     )\n )\n@@ -370,16 +354,11 @@ mod shared;\n mod stream;\n mod sync;\n \n-// Use a power of 2 to allow LLVM to optimize to something that's not a\n-// division, this is hit pretty regularly.\n-static RESCHED_FREQ: int = 256;\n-\n /// The receiving-half of Rust's channel type. This half can only be owned by\n /// one task\n #[unstable]\n pub struct Receiver<T> {\n     inner: UnsafeCell<Flavor<T>>,\n-    receives: Cell<uint>,\n     // can't share in an arc\n     _marker: marker::NoSync,\n }\n@@ -397,7 +376,6 @@ pub struct Messages<'a, T:'a> {\n #[unstable]\n pub struct Sender<T> {\n     inner: UnsafeCell<Flavor<T>>,\n-    sends: Cell<uint>,\n     // can't share in an arc\n     _marker: marker::NoSync,\n }\n@@ -544,7 +522,6 @@ impl<T: Send> Sender<T> {\n     fn new(inner: Flavor<T>) -> Sender<T> {\n         Sender {\n             inner: UnsafeCell::new(inner),\n-            sends: Cell::new(0),\n             _marker: marker::NoSync,\n         }\n     }\n@@ -608,21 +585,6 @@ impl<T: Send> Sender<T> {\n     /// ```\n     #[unstable = \"this function may be renamed to send() in the future\"]\n     pub fn send_opt(&self, t: T) -> Result<(), T> {\n-        // In order to prevent starvation of other tasks in situations where\n-        // a task sends repeatedly without ever receiving, we occasionally\n-        // yield instead of doing a send immediately.\n-        //\n-        // Don't unconditionally attempt to yield because the TLS overhead can\n-        // be a bit much, and also use `try_take` instead of `take` because\n-        // there's no reason that this send shouldn't be usable off the\n-        // runtime.\n-        let cnt = self.sends.get() + 1;\n-        self.sends.set(cnt);\n-        if cnt % (RESCHED_FREQ as uint) == 0 {\n-            let task: Option<Box<Task>> = Local::try_take();\n-            task.map(|t| t.maybe_yield());\n-        }\n-\n         let (new_inner, ret) = match *unsafe { self.inner() } {\n             Oneshot(ref p) => {\n                 unsafe {\n@@ -809,7 +771,7 @@ impl<T: Send> Drop for SyncSender<T> {\n \n impl<T: Send> Receiver<T> {\n     fn new(inner: Flavor<T>) -> Receiver<T> {\n-        Receiver { inner: UnsafeCell::new(inner), receives: Cell::new(0), _marker: marker::NoSync }\n+        Receiver { inner: UnsafeCell::new(inner), _marker: marker::NoSync }\n     }\n \n     /// Blocks waiting for a value on this receiver\n@@ -854,17 +816,6 @@ impl<T: Send> Receiver<T> {\n     /// This function cannot panic.\n     #[unstable = \"the return type of this function may be altered\"]\n     pub fn try_recv(&self) -> Result<T, TryRecvError> {\n-        // If a thread is spinning in try_recv, we should take the opportunity\n-        // to reschedule things occasionally. See notes above in scheduling on\n-        // sends for why this doesn't always hit TLS, and also for why this uses\n-        // `try_take` instead of `take`.\n-        let cnt = self.receives.get() + 1;\n-        self.receives.set(cnt);\n-        if cnt % (RESCHED_FREQ as uint) == 0 {\n-            let task: Option<Box<Task>> = Local::try_take();\n-            task.map(|t| t.maybe_yield());\n-        }\n-\n         loop {\n             let new_port = match *unsafe { self.inner() } {\n                 Oneshot(ref p) => {"}, {"sha": "96c0acacd80e152a1de40731b89d994e89252642", "filename": "src/libsync/comm/shared.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/40c78ab037c70d61eb4f8c95c7a4fec8f098644b/src%2Flibsync%2Fcomm%2Fshared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40c78ab037c70d61eb4f8c95c7a4fec8f098644b/src%2Flibsync%2Fcomm%2Fshared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fcomm%2Fshared.rs?ref=40c78ab037c70d61eb4f8c95c7a4fec8f098644b", "patch": "@@ -279,17 +279,6 @@ impl<T: Send> Packet<T> {\n             // because the remote sender should finish their enqueue\n             // operation \"very quickly\".\n             //\n-            // Note that this yield loop does *not* attempt to do a green\n-            // yield (regardless of the context), but *always* performs an\n-            // OS-thread yield. The reasoning for this is that the pusher in\n-            // question which is causing the inconsistent state is\n-            // guaranteed to *not* be a blocked task (green tasks can't get\n-            // pre-empted), so it must be on a different OS thread. Also,\n-            // `try_recv` is normally a \"guaranteed no rescheduling\" context\n-            // in a green-thread situation. By yielding control of the\n-            // thread, we will hopefully allow time for the remote task on\n-            // the other OS thread to make progress.\n-            //\n             // Avoiding this yield loop would require a different queue\n             // abstraction which provides the guarantee that after M\n             // pushes have succeeded, at least M pops will succeed. The"}, {"sha": "9d6f6513a658fd84565642f2e16a59e7fccc669b", "filename": "src/libsync/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/40c78ab037c70d61eb4f8c95c7a4fec8f098644b/src%2Flibsync%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40c78ab037c70d61eb4f8c95c7a4fec8f098644b/src%2Flibsync%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Flib.rs?ref=40c78ab037c70d61eb4f8c95c7a4fec8f098644b", "patch": "@@ -38,7 +38,6 @@ extern crate collections;\n extern crate rustrt;\n \n #[cfg(test)] extern crate test;\n-#[cfg(test)] extern crate native;\n #[cfg(test)] #[phase(plugin, link)] extern crate std;\n \n pub use alloc::arc::{Arc, Weak};"}, {"sha": "6f02bff9f310e5e4caee9a005a0c96f529db1c8b", "filename": "src/test/bench/rt-spawn-rate.rs", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/a68ec98166bf638c6cbf4036f51036012695718d/src%2Ftest%2Fbench%2Frt-spawn-rate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a68ec98166bf638c6cbf4036f51036012695718d/src%2Ftest%2Fbench%2Frt-spawn-rate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Frt-spawn-rate.rs?ref=a68ec98166bf638c6cbf4036f51036012695718d", "patch": "@@ -1,41 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![no_start]\n-\n-extern crate green;\n-\n-use std::task::spawn;\n-use std::os;\n-use std::uint;\n-\n-// Very simple spawn rate test. Spawn N tasks that do nothing and\n-// return.\n-\n-#[start]\n-fn start(argc: int, argv: *const *const u8) -> int {\n-    green::start(argc, argv, green::basic::event_loop, main)\n-}\n-\n-fn main() {\n-\n-    let args = os::args();\n-    let args = args.as_slice();\n-    let n = if args.len() == 2 {\n-        from_str::<uint>(args[1].as_slice()).unwrap()\n-    } else {\n-        100000\n-    };\n-\n-    for _ in range(0, n) {\n-        spawn(proc() {});\n-    }\n-\n-}"}, {"sha": "bc2723f6d74b3b2900577d78d43f2c66e31025ef", "filename": "src/test/bench/silly-test-spawn.rs", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a68ec98166bf638c6cbf4036f51036012695718d/src%2Ftest%2Fbench%2Fsilly-test-spawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a68ec98166bf638c6cbf4036f51036012695718d/src%2Ftest%2Fbench%2Fsilly-test-spawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsilly-test-spawn.rs?ref=a68ec98166bf638c6cbf4036f51036012695718d", "patch": "@@ -1,25 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// This is (hopefully) a quick test to get a good idea about spawning\n-// performance in libgreen.\n-\n-extern crate green;\n-\n-#[start]\n-fn start(argc: int, argv: *const *const u8) -> int {\n-    green::start(argc, argv, green::basic::event_loop, main)\n-}\n-\n-fn main() {\n-    for _ in range(1u32, 100_000) {\n-        spawn(proc() {})\n-    }\n-}"}, {"sha": "94a168a74ebb572972aa570ec3edd2ddcd761957", "filename": "src/test/pretty/issue-4264.pp", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/40c78ab037c70d61eb4f8c95c7a4fec8f098644b/src%2Ftest%2Fpretty%2Fissue-4264.pp", "raw_url": "https://github.com/rust-lang/rust/raw/40c78ab037c70d61eb4f8c95c7a4fec8f098644b/src%2Ftest%2Fpretty%2Fissue-4264.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue-4264.pp?ref=40c78ab037c70d61eb4f8c95c7a4fec8f098644b", "patch": "@@ -3,7 +3,6 @@\n #![feature(globs)]\n #[phase(plugin, link)]\n extern crate \"std\" as std;\n-extern crate \"native\" as rt;\n #[prelude_import]\n use std::prelude::*;\n // Copyright 2014 The Rust Project Developers. See the COPYRIGHT"}, {"sha": "0b261676cb2df24621081c3e5b778529c208c35a", "filename": "src/test/run-fail/native-panic.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a68ec98166bf638c6cbf4036f51036012695718d/src%2Ftest%2Frun-fail%2Fnative-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a68ec98166bf638c6cbf4036f51036012695718d/src%2Ftest%2Frun-fail%2Fnative-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fnative-panic.rs?ref=a68ec98166bf638c6cbf4036f51036012695718d", "patch": "@@ -1,21 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ignore-android (FIXME #11419)\n-// error-pattern:explicit panic\n-\n-extern crate native;\n-\n-#[start]\n-fn start(argc: int, argv: *const *const u8) -> int {\n-    native::start(argc, argv, proc() {\n-        panic!();\n-    })\n-}"}, {"sha": "34d9cc48ffe20385f40a344e1ba85bf36b816b8a", "filename": "src/test/run-make/bootstrap-from-c-with-native/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/40c78ab037c70d61eb4f8c95c7a4fec8f098644b/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-native%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40c78ab037c70d61eb4f8c95c7a4fec8f098644b/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-native%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-native%2Flib.rs?ref=40c78ab037c70d61eb4f8c95c7a4fec8f098644b", "patch": "@@ -11,11 +11,11 @@\n #![crate_name=\"boot\"]\n #![crate_type=\"dylib\"]\n \n-extern crate native;\n+use std::rt;\n \n #[no_mangle] // this needs to get called from C\n pub extern \"C\" fn foo(argc: int, argv: *const *const u8) -> int {\n-    native::start(argc, argv, proc() {\n+    rt::start(argc, argv, proc() {\n         spawn(proc() {\n             println!(\"hello\");\n         });"}, {"sha": "a5e65e49d38b127b58328b0a409c49189870d5c0", "filename": "src/test/run-pass/backtrace.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/40c78ab037c70d61eb4f8c95c7a4fec8f098644b/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40c78ab037c70d61eb4f8c95c7a4fec8f098644b/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbacktrace.rs?ref=40c78ab037c70d61eb4f8c95c7a4fec8f098644b", "patch": "@@ -10,18 +10,11 @@\n \n // no-pretty-expanded FIXME #15189\n // ignore-windows FIXME #13259\n-extern crate native;\n-\n use std::os;\n use std::io::process::Command;\n use std::finally::Finally;\n use std::str;\n \n-#[start]\n-fn start(argc: int, argv: *const *const u8) -> int {\n-    native::start(argc, argv, main)\n-}\n-\n #[inline(never)]\n fn foo() {\n     let _v = vec![1i, 2, 3];"}, {"sha": "a6744585e47a3ef240d88abc5c45b3e25110edff", "filename": "src/test/run-pass/capturing-logging.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/40c78ab037c70d61eb4f8c95c7a4fec8f098644b/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40c78ab037c70d61eb4f8c95c7a4fec8f098644b/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs?ref=40c78ab037c70d61eb4f8c95c7a4fec8f098644b", "patch": "@@ -15,7 +15,6 @@\n \n #[phase(plugin, link)]\n extern crate log;\n-extern crate native;\n \n use log::{set_logger, Logger, LogRecord};\n use std::fmt;\n@@ -30,13 +29,6 @@ impl Logger for MyWriter {\n     }\n }\n \n-#[start]\n-fn start(argc: int, argv: *const *const u8) -> int {\n-    native::start(argc, argv, proc() {\n-        main();\n-    })\n-}\n-\n fn main() {\n     let (tx, rx) = channel();\n     let (mut r, w) = (ChanReader::new(rx), ChanWriter::new(tx));"}, {"sha": "2dc25181606ab5cd7e98b817064c95a3dee78c45", "filename": "src/test/run-pass/issue-12699.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/40c78ab037c70d61eb4f8c95c7a4fec8f098644b/src%2Ftest%2Frun-pass%2Fissue-12699.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40c78ab037c70d61eb4f8c95c7a4fec8f098644b/src%2Ftest%2Frun-pass%2Fissue-12699.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-12699.rs?ref=40c78ab037c70d61eb4f8c95c7a4fec8f098644b", "patch": "@@ -8,17 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-extern crate native;\n-\n use std::io::timer;\n use std::time::Duration;\n \n-#[start]\n-fn start(argc: int, argv: *const *const u8) -> int {\n-    native::start(argc, argv, main)\n-}\n-\n fn main() {\n     timer::sleep(Duration::milliseconds(250));\n }"}, {"sha": "35f713c4c2c0bc23cebf873d79be9970c9e40916", "filename": "src/test/run-pass/issue-8860.rs", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/40c78ab037c70d61eb4f8c95c7a4fec8f098644b/src%2Ftest%2Frun-pass%2Fissue-8860.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40c78ab037c70d61eb4f8c95c7a4fec8f098644b/src%2Ftest%2Frun-pass%2Fissue-8860.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-8860.rs?ref=40c78ab037c70d61eb4f8c95c7a4fec8f098644b", "patch": "@@ -8,24 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-extern crate green;\n-\n static mut DROP: int = 0i;\n static mut DROP_S: int = 0i;\n static mut DROP_T: int = 0i;\n \n-#[start]\n-fn start(argc: int, argv: *const *const u8) -> int {\n-    let ret = green::start(argc, argv, green::basic::event_loop, main);\n-    unsafe {\n-        assert_eq!(2, DROP);\n-        assert_eq!(1, DROP_S);\n-        assert_eq!(1, DROP_T);\n-    }\n-    ret\n-}\n-\n struct S;\n impl Drop for S {\n     fn drop(&mut self) {\n@@ -48,7 +34,7 @@ impl Drop for T {\n }\n fn g(ref _t: T) {}\n \n-fn main() {\n+fn do_test() {\n     let s = S;\n     f(s);\n     unsafe {\n@@ -59,3 +45,12 @@ fn main() {\n     g(t);\n     unsafe { assert_eq!(1, DROP_T); }\n }\n+\n+fn main() {\n+    do_test();\n+    unsafe {\n+        assert_eq!(2, DROP);\n+        assert_eq!(1, DROP_S);\n+        assert_eq!(1, DROP_T);\n+    }\n+}"}, {"sha": "ed4c20c80943ab58ca9a98ef0683e8dfc7a3e54a", "filename": "src/test/run-pass/running-with-no-runtime.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/40c78ab037c70d61eb4f8c95c7a4fec8f098644b/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40c78ab037c70d61eb4f8c95c7a4fec8f098644b/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs?ref=40c78ab037c70d61eb4f8c95c7a4fec8f098644b", "patch": "@@ -8,12 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate native;\n+extern crate rustrt;\n \n use std::io::process::{Command, ProcessOutput};\n use std::os;\n use std::str;\n-use std::rt::unwind::try;\n+use std::rt;\n+\n+use rustrt::unwind::try;\n \n local_data_key!(foo: int)\n \n@@ -36,7 +38,7 @@ fn start(argc: int, argv: *const *const u8) -> int {\n         return 0\n     }\n \n-    native::start(argc, argv, main)\n+    rt::start(argc, argv, main)\n }\n \n fn main() {"}]}