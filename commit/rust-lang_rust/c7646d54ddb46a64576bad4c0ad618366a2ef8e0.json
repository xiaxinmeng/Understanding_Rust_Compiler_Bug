{"sha": "c7646d54ddb46a64576bad4c0ad618366a2ef8e0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3NjQ2ZDU0ZGRiNDZhNjQ1NzZiYWQ0YzBhZDYxODM2NmEyZWY4ZTA=", "commit": {"author": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2018-08-08T16:59:59Z"}, "committer": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2018-08-09T06:55:49Z"}, "message": "Refactor expand_preparsed_format_args", "tree": {"sha": "dced325999290f41b18d14b48dc9625ce59af0db", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dced325999290f41b18d14b48dc9625ce59af0db"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c7646d54ddb46a64576bad4c0ad618366a2ef8e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c7646d54ddb46a64576bad4c0ad618366a2ef8e0", "html_url": "https://github.com/rust-lang/rust/commit/c7646d54ddb46a64576bad4c0ad618366a2ef8e0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c7646d54ddb46a64576bad4c0ad618366a2ef8e0/comments", "author": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "76b69a604ee0d70be1edfa2828c769dc1b148d13", "url": "https://api.github.com/repos/rust-lang/rust/commits/76b69a604ee0d70be1edfa2828c769dc1b148d13", "html_url": "https://github.com/rust-lang/rust/commit/76b69a604ee0d70be1edfa2828c769dc1b148d13"}], "stats": {"total": 117, "additions": 62, "deletions": 55}, "files": [{"sha": "5babbcacdc92515c1d6f34ef43fee7e957aaba1b", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 62, "deletions": 55, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/c7646d54ddb46a64576bad4c0ad618366a2ef8e0/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7646d54ddb46a64576bad4c0ad618366a2ef8e0/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=c7646d54ddb46a64576bad4c0ad618366a2ef8e0", "patch": "@@ -772,8 +772,10 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n     // `ArgumentType` does not derive `Clone`.\n     let arg_types: Vec<_> = (0..args.len()).map(|_| Vec::new()).collect();\n     let arg_unique_types: Vec<_> = (0..args.len()).map(|_| Vec::new()).collect();\n+\n     let mut macsp = ecx.call_site();\n     macsp = macsp.apply_mark(ecx.current_expansion.mark);\n+\n     let msg = \"format argument must be a string literal\";\n     let fmt_sp = efmt.span;\n     let fmt = match expr_to_spanned_string(ecx, efmt, msg) {\n@@ -796,11 +798,46 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n             return DummyResult::raw_expr(sp);\n         }\n     };\n+\n     let is_literal = match ecx.codemap().span_to_snippet(fmt_sp) {\n         Ok(ref s) if s.starts_with(\"\\\"\") || s.starts_with(\"r#\") => true,\n         _ => false,\n     };\n \n+    let fmt_str = &*fmt.node.0.as_str();\n+    let str_style = match fmt.node.1 {\n+        ast::StrStyle::Cooked => None,\n+        ast::StrStyle::Raw(raw) => Some(raw as usize),\n+    };\n+\n+    let mut parser = parse::Parser::new(fmt_str, str_style);\n+\n+    let mut unverified_pieces = Vec::new();\n+    while let Some(piece) = parser.next() {\n+        if !parser.errors.is_empty() {\n+            break;\n+        } else {\n+            unverified_pieces.push(piece);\n+        }\n+    }\n+\n+    if !parser.errors.is_empty() {\n+        let err = parser.errors.remove(0);\n+        let sp = fmt.span.from_inner_byte_pos(err.start, err.end);\n+        let mut e = ecx.struct_span_err(sp, &format!(\"invalid format string: {}\",\n+                                                        err.description));\n+        e.span_label(sp, err.label + \" in format string\");\n+        if let Some(note) = err.note {\n+            e.note(&note);\n+        }\n+        e.emit();\n+        return DummyResult::raw_expr(sp);\n+    }\n+\n+    let arg_spans = parser.arg_places.iter()\n+        .map(|&(start, end)| fmt.span.from_inner_byte_pos(start, end))\n+        .collect();\n+\n     let mut cx = Context {\n         ecx,\n         args,\n@@ -815,42 +852,22 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n         count_positions_count: 0,\n         count_args_index_offset: 0,\n         literal: String::new(),\n-        pieces: Vec::new(),\n-        str_pieces: Vec::new(),\n+        pieces: Vec::with_capacity(unverified_pieces.len()),\n+        str_pieces: Vec::with_capacity(unverified_pieces.len()),\n         all_pieces_simple: true,\n         macsp,\n         fmtsp: fmt.span,\n         invalid_refs: Vec::new(),\n-        arg_spans: Vec::new(),\n+        arg_spans,\n         is_literal,\n     };\n \n-    let fmt_str = &*fmt.node.0.as_str();\n-    let str_style = match fmt.node.1 {\n-        ast::StrStyle::Cooked => None,\n-        ast::StrStyle::Raw(raw) => Some(raw as usize),\n-    };\n-    let mut parser = parse::Parser::new(fmt_str, str_style);\n-    let mut unverified_pieces = vec![];\n-    let mut pieces = vec![];\n-\n-    while let Some(piece) = parser.next() {\n-        if !parser.errors.is_empty() {\n-            break;\n-        }\n-        unverified_pieces.push(piece);\n-    }\n-\n-    cx.arg_spans = parser.arg_places.iter()\n-        .map(|&(start, end)| fmt.span.from_inner_byte_pos(start, end))\n-        .collect();\n-\n     // This needs to happen *after* the Parser has consumed all pieces to create all the spans\n-    for mut piece in unverified_pieces {\n+    let pieces = unverified_pieces.into_iter().map(|mut piece| {\n         cx.verify_piece(&piece);\n         cx.resolve_name_inplace(&mut piece);\n-        pieces.push(piece);\n-    }\n+        piece\n+    }).collect::<Vec<_>>();\n \n     let numbered_position_args = pieces.iter().any(|arg: &parse::Piece| {\n         match *arg {\n@@ -867,6 +884,7 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n     cx.build_index_map();\n \n     let mut arg_index_consumed = vec![0usize; cx.arg_index_map.len()];\n+\n     for piece in pieces {\n         if let Some(piece) = cx.build_piece(&piece, &mut arg_index_consumed) {\n             let s = cx.build_literal_string();\n@@ -875,18 +893,6 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n         }\n     }\n \n-    if !parser.errors.is_empty() {\n-        let err = parser.errors.remove(0);\n-        let sp = cx.fmtsp.from_inner_byte_pos(err.start, err.end);\n-        let mut e = cx.ecx.struct_span_err(sp, &format!(\"invalid format string: {}\",\n-                                                        err.description));\n-        e.span_label(sp, err.label + \" in format string\");\n-        if let Some(note) = err.note {\n-            e.note(&note);\n-        }\n-        e.emit();\n-        return DummyResult::raw_expr(sp);\n-    }\n     if !cx.literal.is_empty() {\n         let s = cx.build_literal_string();\n         cx.str_pieces.push(s);\n@@ -898,24 +904,25 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n \n     // Make sure that all arguments were used and all arguments have types.\n     let num_pos_args = cx.args.len() - cx.names.len();\n-    let mut errs = vec![];\n-    for (i, ty) in cx.arg_types.iter().enumerate() {\n-        if ty.len() == 0 {\n-            if cx.count_positions.contains_key(&i) {\n-                continue;\n-            }\n-            let msg = if i >= num_pos_args {\n-                // named argument\n-                \"named argument never used\"\n-            } else {\n-                // positional argument\n-                \"argument never used\"\n-            };\n-            errs.push((cx.args[i].span, msg));\n-        }\n-    }\n+\n+    let errs = cx.arg_types\n+                 .iter()\n+                 .enumerate()\n+                 .filter(|(i, ty)| ty.is_empty() && !cx.count_positions.contains_key(&i))\n+                 .map(|(i, _)| {\n+                    let msg = if i >= num_pos_args {\n+                        // named argument\n+                        \"named argument never used\"\n+                    } else {\n+                        // positional argument\n+                        \"argument never used\"\n+                    };\n+                    (cx.args[i].span, msg)\n+                 })\n+                 .collect::<Vec<_>>();\n+\n     let errs_len = errs.len();\n-    if errs_len > 0 {\n+    if !errs.is_empty() {\n         let args_used = cx.arg_types.len() - errs_len;\n         let args_unused = errs_len;\n "}]}