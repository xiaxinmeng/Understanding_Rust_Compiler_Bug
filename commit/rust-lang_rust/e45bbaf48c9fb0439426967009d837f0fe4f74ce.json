{"sha": "e45bbaf48c9fb0439426967009d837f0fe4f74ce", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0NWJiYWY0OGM5ZmIwNDM5NDI2OTY3MDA5ZDgzN2YwZmU0Zjc0Y2U=", "commit": {"author": {"name": "Christian Poveda", "email": "christianpoveda@protonmail.com", "date": "2019-07-04T06:45:29Z"}, "committer": {"name": "Christian Poveda", "email": "christianpoveda@protonmail.com", "date": "2019-07-04T06:45:29Z"}, "message": "Fix merge conflicts", "tree": {"sha": "a887380eed192d6ea9b2f124574932bcc1297c34", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a887380eed192d6ea9b2f124574932bcc1297c34"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e45bbaf48c9fb0439426967009d837f0fe4f74ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e45bbaf48c9fb0439426967009d837f0fe4f74ce", "html_url": "https://github.com/rust-lang/rust/commit/e45bbaf48c9fb0439426967009d837f0fe4f74ce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e45bbaf48c9fb0439426967009d837f0fe4f74ce/comments", "author": {"login": "pvdrz", "id": 31802960, "node_id": "MDQ6VXNlcjMxODAyOTYw", "avatar_url": "https://avatars.githubusercontent.com/u/31802960?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pvdrz", "html_url": "https://github.com/pvdrz", "followers_url": "https://api.github.com/users/pvdrz/followers", "following_url": "https://api.github.com/users/pvdrz/following{/other_user}", "gists_url": "https://api.github.com/users/pvdrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/pvdrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pvdrz/subscriptions", "organizations_url": "https://api.github.com/users/pvdrz/orgs", "repos_url": "https://api.github.com/users/pvdrz/repos", "events_url": "https://api.github.com/users/pvdrz/events{/privacy}", "received_events_url": "https://api.github.com/users/pvdrz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pvdrz", "id": 31802960, "node_id": "MDQ6VXNlcjMxODAyOTYw", "avatar_url": "https://avatars.githubusercontent.com/u/31802960?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pvdrz", "html_url": "https://github.com/pvdrz", "followers_url": "https://api.github.com/users/pvdrz/followers", "following_url": "https://api.github.com/users/pvdrz/following{/other_user}", "gists_url": "https://api.github.com/users/pvdrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/pvdrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pvdrz/subscriptions", "organizations_url": "https://api.github.com/users/pvdrz/orgs", "repos_url": "https://api.github.com/users/pvdrz/repos", "events_url": "https://api.github.com/users/pvdrz/events{/privacy}", "received_events_url": "https://api.github.com/users/pvdrz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e32b8eb00a94274e680d1ae63c429d5b7db65e99", "url": "https://api.github.com/repos/rust-lang/rust/commits/e32b8eb00a94274e680d1ae63c429d5b7db65e99", "html_url": "https://github.com/rust-lang/rust/commit/e32b8eb00a94274e680d1ae63c429d5b7db65e99"}, {"sha": "b43eb4235ac43c822d903ad26ed806f34cc1a14a", "url": "https://api.github.com/repos/rust-lang/rust/commits/b43eb4235ac43c822d903ad26ed806f34cc1a14a", "html_url": "https://github.com/rust-lang/rust/commit/b43eb4235ac43c822d903ad26ed806f34cc1a14a"}], "stats": {"total": 10379, "additions": 6684, "deletions": 3695}, "files": [{"sha": "2e6c3b7a992af5621184683acbd7a40d080b1659", "filename": ".azure-pipelines/auto.yml", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/.azure-pipelines%2Fauto.yml", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/.azure-pipelines%2Fauto.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.azure-pipelines%2Fauto.yml?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -138,9 +138,8 @@ jobs:\n         IMAGE: x86_64-gnu-full-bootstrap\n       x86_64-gnu-aux:\n         IMAGE: x86_64-gnu-aux\n-        # FIXME: needs reenabling here rather than Travis\n-      # x86_64-gnu-tools:\n-      #   IMAGE: x86_64-gnu-tools\n+      x86_64-gnu-tools:\n+        IMAGE: x86_64-gnu-tools\n       x86_64-gnu-debug:\n         IMAGE: x86_64-gnu-debug\n       x86_64-gnu-nopt:\n@@ -252,12 +251,10 @@ jobs:\n         RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc\n         VCVARS_BAT: vcvars64.bat\n       # MSVC tools tests\n-      # FIXME: broken on azure right now, need to figure out a cause and\n-      # reenable\n-      # x86_64-msvc-tools:\n-      #   MSYS_BITS: 64\n-      #   SCRIPT: src/ci/docker/x86_64-gnu-tools/checktools.sh x.py /tmp/toolstates.json windows\n-      #   RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --save-toolstates=/tmp/toolstates.json --enable-test-miri\n+      x86_64-msvc-tools:\n+        MSYS_BITS: 64\n+        SCRIPT: src/ci/docker/x86_64-gnu-tools/checktools.sh x.py /tmp/toolstates.json windows\n+        RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --save-toolstates=/tmp/toolstates.json --enable-test-miri\n \n       # 32/64-bit MinGW builds.\n       #"}, {"sha": "1ece3ceb088a0a544030d15af62aa483b2541172", "filename": ".azure-pipelines/steps/run.yml", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/.azure-pipelines%2Fsteps%2Frun.yml", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/.azure-pipelines%2Fsteps%2Frun.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.azure-pipelines%2Fsteps%2Frun.yml?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -8,6 +8,13 @@\n \n steps:\n \n+# Disable automatic line ending conversion, which is enabled by default on\n+# Azure's Windows image. Having the conversion enabled caused regressions both\n+# in our test suite (it broke miri tests) and in the ecosystem, since we\n+# started shipping install scripts with CRLF endings instead of the old LF.\n+- bash: git config --global core.autocrlf false\n+  displayName: \"Disable git automatic line ending conversion\"\n+\n - checkout: self\n   fetchDepth: 2\n "}, {"sha": "c5ecfb54fca52df808b9a523857b47fb93bb2f64", "filename": ".mailmap", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -167,6 +167,8 @@ Matthijs Hofstra <thiezz@gmail.com>\n Melody Horn <melody@boringcactus.com> <mathphreak@gmail.com>\n Michael Williams <m.t.williams@live.com>\n Michael Woerister <michaelwoerister@posteo> <michaelwoerister@gmail>\n+Michael Woerister <michaelwoerister@posteo> <michaelwoerister@users.noreply.github.com>\n+Michael Woerister <michaelwoerister@posteo> <michaelwoerister@posteo.net>\n Micka\u00ebl Raybaud-Roig <raybaudroigm@gmail.com> m-r-r <raybaudroigm@gmail.com>\n Ms2ger <ms2ger@gmail.com> <Ms2ger@gmail.com>\n Mukilan Thiagarajan <mukilanthiagarajan@gmail.com>"}, {"sha": "1d35ea0efacc247512c214f8baec0b6cdb0fe1ee", "filename": ".travis.yml", "status": "modified", "additions": 5, "deletions": 159, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -1,164 +1,10 @@\n language: shell\n-sudo: required\n-dist: xenial\n-services:\n-  - docker\n-addons:\n-  apt:\n-    packages:\n-      - gdb\n+script: echo Travis CI is not used anymore\n \n-git:\n-  depth: 2\n-  submodules: false\n-\n-env:\n-  global:\n-    - CI_JOB_NAME=$TRAVIS_JOB_NAME\n-\n-matrix:\n-  fast_finish: true\n-  include:\n-    - env: IMAGE=x86_64-gnu-tools\n-      name: x86_64-gnu-tools\n-      if: branch = auto OR (type = pull_request AND commit_message =~ /(?i:^update.*\\b(rls|rustfmt|clippy|miri|cargo)\\b)/)\n-\n-before_install:\n-  # We'll use the AWS cli to download/upload cached docker layers as well as\n-  # push our deployments, so download that here.\n-  - pip install --user awscli; export PATH=$PATH:$HOME/.local/bin:$HOME/Library/Python/2.7/bin/\n-  - mkdir -p $HOME/rustsrc\n-  # FIXME(#46924): these two commands are required to enable IPv6,\n-  # they shouldn't exist, please revert once more official solutions appeared.\n-  # see https://github.com/travis-ci/travis-ci/issues/8891#issuecomment-353403729\n-  - if [ \"$TRAVIS_OS_NAME\" = linux ]; then\n-      echo '{\"ipv6\":true,\"fixed-cidr-v6\":\"fd9a:8454:6789:13f7::/64\"}' | sudo tee /etc/docker/daemon.json;\n-      sudo service docker restart;\n-    fi\n-\n-install:\n-  - case \"$TRAVIS_OS_NAME\" in\n-        linux)\n-          travis_retry curl -fo $HOME/stamp https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/2017-03-17-stamp-x86_64-unknown-linux-musl &&\n-            chmod +x $HOME/stamp &&\n-            export PATH=$PATH:$HOME\n-          ;;\n-        osx)\n-          if [[ \"$SCRIPT\" == \"./x.py dist\" ]]; then\n-            travis_retry brew update &&\n-            travis_retry brew install xz &&\n-            travis_retry brew install swig@3 &&\n-            brew link --force swig@3;\n-          fi &&\n-          travis_retry curl -fo /usr/local/bin/sccache https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/2018-04-02-sccache-x86_64-apple-darwin &&\n-            chmod +x /usr/local/bin/sccache &&\n-          travis_retry curl -fo /usr/local/bin/stamp https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/2017-03-17-stamp-x86_64-apple-darwin &&\n-            chmod +x /usr/local/bin/stamp &&\n-          travis_retry curl -f http://releases.llvm.org/7.0.0/clang+llvm-7.0.0-x86_64-apple-darwin.tar.xz | tar xJf - &&\n-            export CC=`pwd`/clang+llvm-7.0.0-x86_64-apple-darwin/bin/clang &&\n-            export CXX=`pwd`/clang+llvm-7.0.0-x86_64-apple-darwin/bin/clang++ &&\n-            export AR=ar\n-          ;;\n-    esac\n-\n-before_script:\n-  - >\n-      echo \"#### Disk usage before running script:\";\n-      df -h;\n-      du . | sort -nr | head -n100\n-  - >\n-      RUN_SCRIPT=\"src/ci/init_repo.sh . $HOME/rustsrc\";\n-      if [ \"$TRAVIS_OS_NAME\" = \"osx\" ]; then\n-          export RUN_SCRIPT=\"$RUN_SCRIPT && src/ci/run.sh\";\n-      else\n-          export RUN_SCRIPT=\"$RUN_SCRIPT && src/ci/docker/run.sh $IMAGE\";\n-          # Enable core dump on Linux.\n-          sudo sh -c 'echo \"/checkout/obj/cores/core.%p.%E\" > /proc/sys/kernel/core_pattern';\n-      fi\n-  - >\n-      if [ \"$IMAGE\" = mingw-check ]; then\n-        # verify the publish_toolstate script works.\n-        git clone --depth=1 https://github.com/rust-lang-nursery/rust-toolstate.git;\n-        cd rust-toolstate;\n-        python2.7 \"$TRAVIS_BUILD_DIR/src/tools/publish_toolstate.py\" \"$(git rev-parse HEAD)\" \"$(git log --format=%s -n1 HEAD)\" \"\" \"\";\n-        cd ..;\n-        rm -rf rust-toolstate;\n-      fi\n-\n-# Log time information from this machine and an external machine for insight into possible\n-# clock drift. Timezones don't matter since relative deltas give all the necessary info.\n-script:\n-  - >\n-      date && (curl -fs --head https://google.com | grep ^Date: | sed 's/Date: //g' || true)\n-  - stamp sh -x -c \"$RUN_SCRIPT\"\n-  - >\n-      date && (curl -fs --head https://google.com | grep ^Date: | sed 's/Date: //g' || true)\n-\n-after_success:\n-  - >\n-      echo \"#### Build successful; Disk usage after running script:\";\n-      df -h;\n-      du . | sort -nr | head -n100\n-  - >\n-      if [ \"$DEPLOY$DEPLOY_ALT\" == \"1\" ]; then\n-        mkdir -p deploy/$TRAVIS_COMMIT;\n-        if [ \"$TRAVIS_OS_NAME\" == \"osx\" ]; then\n-            rm -rf build/dist/doc &&\n-            cp -r build/dist/* deploy/$TRAVIS_COMMIT;\n-        else\n-            rm -rf obj/build/dist/doc &&\n-            cp -r obj/build/dist/* deploy/$TRAVIS_COMMIT;\n-        fi;\n-        ls -la deploy/$TRAVIS_COMMIT;\n-        deploy_dir=rustc-builds;\n-        if [ \"$DEPLOY_ALT\" == \"1\" ]; then\n-            deploy_dir=rustc-builds-alt;\n-        fi;\n-        travis_retry aws s3 cp --no-progress --recursive --acl public-read ./deploy s3://rust-lang-ci2/$deploy_dir\n-      fi\n-\n-after_failure:\n-  - >\n-      echo \"#### Build failed; Disk usage after running script:\";\n-      df -h;\n-      du . | sort -nr | head -n100\n-\n-  # Random attempt at debugging currently. Just poking around in here to see if\n-  # anything shows up.\n-\n-  # Dump backtrace for macOS\n-  - ls -lat $HOME/Library/Logs/DiagnosticReports/\n-  - find $HOME/Library/Logs/DiagnosticReports\n-      -type f\n-      -name '*.crash'\n-      -not -name '*.stage2-*.crash'\n-      -not -name 'com.apple.CoreSimulator.CoreSimulatorService-*.crash'\n-      -exec printf travis_fold\":start:crashlog\\n\\033[31;1m%s\\033[0m\\n\" {} \\;\n-      -exec head -750 {} \\;\n-      -exec echo travis_fold\":\"end:crashlog \\; || true\n-\n-  # Dump backtrace for Linux\n-  - ln -s . checkout &&\n-    for CORE in obj/cores/core.*; do\n-      EXE=$(echo $CORE | sed 's|obj/cores/core\\.[0-9]*\\.!checkout!\\(.*\\)|\\1|;y|!|/|');\n-      if [ -f \"$EXE\" ]; then\n-        printf travis_fold\":start:crashlog\\n\\033[31;1m%s\\033[0m\\n\" \"$CORE\";\n-        gdb --batch -q -c \"$CORE\" \"$EXE\"\n-          -iex 'set auto-load off'\n-          -iex 'dir src/'\n-          -iex 'set sysroot .'\n-          -ex bt\n-          -ex q;\n-        echo travis_fold\":\"end:crashlog;\n-      fi;\n-    done || true\n-\n-  # see #50887\n-  - cat ./obj/build/x86_64-unknown-linux-gnu/native/asan/build/lib/asan/clang_rt.asan-dynamic-i386.vers || true\n-\n-  # attempt to debug anything killed by the oom killer on linux, just to see if\n-  # it happened\n-  - dmesg | grep -i kill\n+branches:\n+  only:\n+    - auto\n+    - try\n \n notifications:\n   email: false"}, {"sha": "98dd10955d57d910ca70b7bfae8141dc74731200", "filename": "Cargo.lock", "status": "modified", "additions": 4, "deletions": 22, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -1030,7 +1030,7 @@ version = \"0.1.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"mac 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"new_debug_unreachable 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"new_debug_unreachable 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1760,11 +1760,8 @@ dependencies = [\n \n [[package]]\n name = \"new_debug_unreachable\"\n-version = \"1.0.1\"\n+version = \"1.0.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"unreachable 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n \n [[package]]\n name = \"nodrop\"\n@@ -3450,7 +3447,7 @@ version = \"0.7.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"new_debug_unreachable 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"new_debug_unreachable 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"phf_shared 0.7.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"precomputed-hash 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde 1.0.92 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -4038,14 +4035,6 @@ name = \"unicode_categories\"\n version = \"0.1.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n-[[package]]\n-name = \"unreachable\"\n-version = \"1.0.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"void 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n [[package]]\n name = \"unstable-book-gen\"\n version = \"0.1.0\"\n@@ -4124,11 +4113,6 @@ name = \"version_check\"\n version = \"0.1.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n-[[package]]\n-name = \"void\"\n-version = \"1.0.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n [[package]]\n name = \"vte\"\n version = \"0.3.3\"\n@@ -4388,7 +4372,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum miow 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8c1f2f3b1cf331de6896aabf6e9d55dca90356cc9960cca7eaaf408a355ae919\"\n \"checksum miow 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"396aa0f2003d7df8395cb93e09871561ccc3e785f0acb369170e8cc74ddf9226\"\n \"checksum net2 0.2.33 (registry+https://github.com/rust-lang/crates.io-index)\" = \"42550d9fb7b6684a6d404d9fa7250c2eb2646df731d1c06afc06dcee9e1bcf88\"\n-\"checksum new_debug_unreachable 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0cdc457076c78ab54d5e0d6fa7c47981757f1e34dc39ff92787f217dede586c4\"\n+\"checksum new_debug_unreachable 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f40f005c60db6e03bae699e414c58bf9aa7ea02a2d0b9bfbcf19286cc4c82b30\"\n \"checksum nodrop 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9a2228dca57108069a5262f2ed8bd2e82496d2e074a06d1ccc7ce1687b6ae0a2\"\n \"checksum num-derive 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8af1847c907c2f04d7bfd572fb25bbb4385c637fe5be163cf2f8c5d778fe1e7d\"\n \"checksum num-integer 0.1.39 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e83d528d2677f0518c570baf2b7abdcf0cd2d248860b68507bdcb3e91d4c0cea\"\n@@ -4552,7 +4536,6 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum unicode-xid 0.0.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8c1f860d7d29cf02cb2f3f359fd35991af3d30bac52c57d265a3c461074cb4dc\"\n \"checksum unicode-xid 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"fc72304796d0818e357ead4e000d19c9c174ab23dc11093ac919054d20a6a7fc\"\n \"checksum unicode_categories 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"39ec24b3121d976906ece63c9daad25b85969647682eee313cb5779fdd69e14e\"\n-\"checksum unreachable 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"382810877fe448991dfc7f0dd6e3ae5d58088fd0ea5e35189655f84e6814fa56\"\n \"checksum url 1.7.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dd4e7c0d531266369519a4aa4f399d748bd37043b00bde1e4ff1f60a120b355a\"\n \"checksum url_serde 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"74e7d099f1ee52f823d4bdd60c93c3602043c728f5db3b97bdb548467f7bddea\"\n \"checksum utf-8 0.7.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f1262dfab4c30d5cb7c07026be00ee343a6cf5027fdc0104a9160f354e5db75c\"\n@@ -4562,7 +4545,6 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum vec_map 0.8.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"05c78687fb1a80548ae3250346c3db86a80a7cdd77bda190189f2d0a0987c81a\"\n \"checksum vergen 3.0.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6aba5e34f93dc7051dfad05b98a18e9156f27e7b431fe1d2398cb6061c0a1dba\"\n \"checksum version_check 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"914b1a6776c4c929a602fafd8bc742e06365d4bcbe48c30f9cca5824f70dc9dd\"\n-\"checksum void 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6a02e4885ed3bc0f2de90ea6dd45ebcbb66dacffe03547fadbb0eeae2770887d\"\n \"checksum vte 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4f42f536e22f7fcbb407639765c8fd78707a33109301f834a594758bedd6e8cf\"\n \"checksum walkdir 2.2.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9d9d7ed3431229a144296213105a390676cc49c9b6a72bd19f3176c98e129fa1\"\n \"checksum winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"167dc9d6949a9b857f3451275e911c3f44255842c1f7a76f33c55103a909087a\""}, {"sha": "5ceeea8d037cbc538199a0803fee386bfc4fb96f", "filename": "RELEASES.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -309,9 +309,9 @@ Misc\n \n Compatibility Notes\n -------------------\n-- [`Command::before_exec` is now deprecated in favor of the\n-  unsafe method `Command::pre_exec`.][58059]\n-- [Use of `ATOMIC_{BOOL, ISIZE, USIZE}_INIT` is now deprecated.][57425] As you\n+- [`Command::before_exec` is being replaced by the unsafe method\n+  `Command::pre_exec`][58059] and will be deprecated with Rust 1.37.0.\n+- [Use of `ATOMIC_{BOOL, ISIZE, USIZE}_INIT` is now deprecated][57425] as you\n   can now use `const` functions in `static` variables.\n \n [58370]: https://github.com/rust-lang/rust/pull/58370/"}, {"sha": "003de85184c32b3c4ffa35747f01148c24b948d7", "filename": "appveyor.yml", "status": "modified", "additions": 2, "deletions": 107, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/appveyor.yml", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/appveyor.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/appveyor.yml?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -1,113 +1,8 @@\n-environment:\n-  # This is required for at least an AArch64 compiler in one image, and is also\n-  # going to soon be required for compiling LLVM.\n-  APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2017 Preview\n-\n-  # By default schannel checks revocation of certificates unlike some other SSL\n-  # backends, but we've historically had problems on CI where a revocation\n-  # server goes down presumably. See #43333 for more info\n-  CARGO_HTTP_CHECK_REVOKE: false\n-\n-  matrix:\n-  # MSVC tools tests\n-  - CI_JOB_NAME: x86_64-msvc-tools\n-    MSYS_BITS: 64\n-    SCRIPT: src/ci/docker/x86_64-gnu-tools/checktools.sh x.py /tmp/toolstates.json windows\n-    RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --save-toolstates=/tmp/toolstates.json --enable-test-miri\n-\n-matrix:\n-  fast_finish: true\n-\n-clone_depth: 2\n+clone_depth: 1\n build: false\n \n-install:\n-  # Print which AppVeyor agent version we're running on.\n-  - appveyor version\n-  # If we need to download a custom MinGW, do so here and set the path\n-  # appropriately.\n-  #\n-  # Note that this *also* means that we're not using what is typically\n-  # /mingw32/bin/python2.7.exe, which is a \"correct\" python interpreter where\n-  # /usr/bin/python2.7.exe is not. To ensure we use the right interpreter we\n-  # move `C:\\Python27` ahead in PATH and then also make sure the `python2.7.exe`\n-  # file exists in there (which it doesn't by default).\n-  - if defined MINGW_URL appveyor-retry appveyor DownloadFile %MINGW_URL%/%MINGW_ARCHIVE%\n-  - if defined MINGW_URL 7z x -y %MINGW_ARCHIVE% > nul\n-  - if defined MINGW_URL set PATH=%CD%\\%MINGW_DIR%\\bin;C:\\msys64\\usr\\bin;%PATH%\n-\n-  # If we're compiling for MSVC then we, like most other distribution builders,\n-  # switch to clang as the compiler. This'll allow us eventually to enable LTO\n-  # amongst LLVM and rustc. Note that we only do this on MSVC as I don't think\n-  # clang has an output mode compatible with MinGW that we need. If it does we\n-  # should switch to clang for MinGW as well!\n-  #\n-  # Note that the LLVM installer is an NSIS installer\n-  #\n-  # Original downloaded here came from\n-  # http://releases.llvm.org/8.0.0/LLVM-8.0.0-win64.exe\n-  - if NOT defined MINGW_URL appveyor-retry appveyor DownloadFile https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror/LLVM-8.0.0-win64.exe\n-  - if NOT defined MINGW_URL .\\LLVM-8.0.0-win64.exe /S /NCRC /D=C:\\clang-rust\n-  - if NOT defined MINGW_URL set RUST_CONFIGURE_ARGS=%RUST_CONFIGURE_ARGS% --set llvm.clang-cl=C:\\clang-rust\\bin\\clang-cl.exe\n-\n-  # Here we do a pretty heinous thing which is to mangle the MinGW installation\n-  # we just had above. Currently, as of this writing, we're using MinGW-w64\n-  # builds of gcc, and that's currently at 6.3.0. We use 6.3.0 as it appears to\n-  # be the first version which contains a fix for #40546, builds randomly\n-  # failing during LLVM due to ar.exe/ranlib.exe failures.\n-  #\n-  # Unfortunately, though, 6.3.0 *also* is the first version of MinGW-w64 builds\n-  # to contain a regression in gdb (#40184). As a result if we were to use the\n-  # gdb provided (7.11.1) then we would fail all debuginfo tests.\n-  #\n-  # In order to fix spurious failures (pretty high priority) we use 6.3.0. To\n-  # avoid disabling gdb tests we download an *old* version of gdb, specifically\n-  # that found inside the 6.2.0 distribution. We then overwrite the 6.3.0 gdb\n-  # with the 6.2.0 gdb to get tests passing.\n-  #\n-  # Note that we don't literally overwrite the gdb.exe binary because it appears\n-  # to just use gdborig.exe, so that's the binary we deal with instead.\n-  - if defined MINGW_URL appveyor-retry appveyor DownloadFile %MINGW_URL%/2017-04-20-%MSYS_BITS%bit-gdborig.exe\n-  - if defined MINGW_URL mv 2017-04-20-%MSYS_BITS%bit-gdborig.exe %MINGW_DIR%\\bin\\gdborig.exe\n-\n-  # Otherwise pull in the MinGW installed on appveyor\n-  - if NOT defined MINGW_URL set PATH=C:\\msys64\\mingw%MSYS_BITS%\\bin;C:\\msys64\\usr\\bin;%PATH%\n-\n-  # Prefer the \"native\" Python as LLVM has trouble building with MSYS sometimes\n-  - copy C:\\Python27\\python.exe C:\\Python27\\python2.7.exe\n-  - set PATH=C:\\Python27;%PATH%\n-\n-  # Download and install sccache\n-  - appveyor-retry appveyor DownloadFile https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror/2018-04-26-sccache-x86_64-pc-windows-msvc\n-  - mv 2018-04-26-sccache-x86_64-pc-windows-msvc sccache.exe\n-  - set PATH=%PATH%;%CD%\n-\n-  # Download and install ninja\n-  #\n-  # Note that this is originally from the github releases patch of Ninja\n-  - appveyor-retry appveyor DownloadFile https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror/2017-03-15-ninja-win.zip\n-  - 7z x 2017-03-15-ninja-win.zip\n-  - set RUST_CONFIGURE_ARGS=%RUST_CONFIGURE_ARGS% --enable-ninja\n-  # - set PATH=%PATH%;%CD% -- this already happens above for sccache\n-\n-  # Install InnoSetup to get `iscc` used to produce installers\n-  - appveyor-retry appveyor DownloadFile https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror/2017-08-22-is.exe\n-  - 2017-08-22-is.exe /VERYSILENT /SUPPRESSMSGBOXES /NORESTART /SP-\n-  - set PATH=\"C:\\Program Files (x86)\\Inno Setup 5\";%PATH%\n-\n-  # Help debug some handle issues on AppVeyor\n-  - appveyor-retry appveyor DownloadFile https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror/2017-05-15-Handle.zip\n-  - mkdir handle\n-  - 7z x -ohandle 2017-05-15-Handle.zip\n-  - set PATH=%PATH%;%CD%\\handle\n-  - handle.exe -accepteula -help\n-\n test_script:\n-  - if not exist C:\\cache\\rustsrc\\NUL mkdir C:\\cache\\rustsrc\n-  - sh src/ci/init_repo.sh . /c/cache/rustsrc\n-  - set SRC=.\n-  - set NO_CCACHE=1\n-  - sh src/ci/run.sh\n+  - echo AppVeyor is not used anymore\n \n branches:\n   only:"}, {"sha": "cab7443bf3fe87cf9aa6f921a21de25501b592ac", "filename": "src/bootstrap/builder/tests.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Fbootstrap%2Fbuilder%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Fbootstrap%2Fbuilder%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder%2Ftests.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -598,6 +598,7 @@ fn test_with_no_doc_stage0() {\n         bless: false,\n         compare_mode: None,\n         rustfix_coverage: false,\n+        pass: None,\n     };\n \n     let build = Build::new(config);\n@@ -640,6 +641,7 @@ fn test_exclude() {\n         bless: false,\n         compare_mode: None,\n         rustfix_coverage: false,\n+        pass: None,\n     };\n \n     let build = Build::new(config);"}, {"sha": "179accda0c8b249034899efc1171e1aa255a9e4a", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -58,6 +58,7 @@ pub enum Subcommand {\n         /// Whether to automatically update stderr/stdout files\n         bless: bool,\n         compare_mode: Option<String>,\n+        pass: Option<String>,\n         test_args: Vec<String>,\n         rustc_args: Vec<String>,\n         fail_fast: bool,\n@@ -199,6 +200,12 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\"\n                     \"mode describing what file the actual ui output will be compared to\",\n                     \"COMPARE MODE\",\n                 );\n+                opts.optopt(\n+                    \"\",\n+                    \"pass\",\n+                    \"force {check,build,run}-pass tests to this mode.\",\n+                    \"check | build | run\"\n+                );\n                 opts.optflag(\n                     \"\",\n                     \"rustfix-coverage\",\n@@ -401,6 +408,7 @@ Arguments:\n                 paths,\n                 bless: matches.opt_present(\"bless\"),\n                 compare_mode: matches.opt_str(\"compare-mode\"),\n+                pass: matches.opt_str(\"pass\"),\n                 test_args: matches.opt_strs(\"test-args\"),\n                 rustc_args: matches.opt_strs(\"rustc-args\"),\n                 fail_fast: !matches.opt_present(\"no-fail-fast\"),\n@@ -524,6 +532,15 @@ impl Subcommand {\n             _ => None,\n         }\n     }\n+\n+    pub fn pass(&self) -> Option<&str> {\n+        match *self {\n+            Subcommand::Test {\n+                ref pass, ..\n+            } => pass.as_ref().map(|s| &s[..]),\n+            _ => None,\n+        }\n+    }\n }\n \n fn split(s: &[String]) -> Vec<String> {"}, {"sha": "1d54ca16a315bd22194f145c861672c6c5ba7200", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -1065,6 +1065,11 @@ impl Step for Compiletest {\n             }\n         });\n \n+        if let Some(ref pass) = builder.config.cmd.pass() {\n+            cmd.arg(\"--pass\");\n+            cmd.arg(pass);\n+        }\n+\n         if let Some(ref nodejs) = builder.config.nodejs {\n             cmd.arg(\"--nodejs\").arg(nodejs);\n         }"}, {"sha": "c2cf77d56cb3b120c9eb4bddc0128efb70e5610f", "filename": "src/ci/docker/scripts/musl.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Fci%2Fdocker%2Fscripts%2Fmusl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Fci%2Fdocker%2Fscripts%2Fmusl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Fmusl.sh?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -22,7 +22,7 @@ shift\n \n export CFLAGS=\"-fPIC $CFLAGS\"\n \n-MUSL=musl-1.1.20\n+MUSL=musl-1.1.22\n \n # may have been downloaded in a previous run\n if [ ! -d $MUSL ]; then"}, {"sha": "3cda8d927973ca64c7210d37ecd750093f838ca7", "filename": "src/doc/rustc/src/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -13,5 +13,6 @@\n - [Targets](targets/index.md)\n     - [Built-in Targets](targets/built-in.md)\n     - [Custom Targets](targets/custom.md)\n+- [Profile-guided Optimization](profile-guided-optimization.md)\n - [Linker-plugin based LTO](linker-plugin-lto.md)\n - [Contributing to `rustc`](contributing.md)"}, {"sha": "3773a7783020f8d226b0716e5a9bf9eaf6d78680", "filename": "src/doc/rustc/src/codegen-options/index.md", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -214,3 +214,20 @@ This option lets you control what happens when the code panics.\n ## incremental\n \n This flag allows you to enable incremental compilation.\n+\n+## profile-generate\n+\n+This flag allows for creating instrumented binaries that will collect\n+profiling data for use with profile-guided optimization (PGO). The flag takes\n+an optional argument which is the path to a directory into which the\n+instrumented binary will emit the collected data. See the chapter on\n+[profile-guided optimization](profile-guided-optimization.html) for more\n+information.\n+\n+## profile-use\n+\n+This flag specifies the profiling data file to be used for profile-guided\n+optimization (PGO). The flag takes a mandatory argument which is the path\n+to a valid `.profdata` file. See the chapter on\n+[profile-guided optimization](profile-guided-optimization.html) for more\n+information."}, {"sha": "38be07a6440dab772e199f81687e2f4c3304812b", "filename": "src/doc/rustc/src/profile-guided-optimization.md", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Fdoc%2Frustc%2Fsrc%2Fprofile-guided-optimization.md", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Fdoc%2Frustc%2Fsrc%2Fprofile-guided-optimization.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fprofile-guided-optimization.md?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -0,0 +1,136 @@\n+# Profile Guided Optimization\n+\n+`rustc` supports doing profile-guided optimization (PGO).\n+This chapter describes what PGO is, what it is good for, and how it can be used.\n+\n+## What Is Profiled-Guided Optimization?\n+\n+The basic concept of PGO is to collect data about the typical execution of\n+a program (e.g. which branches it is likely to take) and then use this data\n+to inform optimizations such as inlining, machine-code layout,\n+register allocation, etc.\n+\n+There are different ways of collecting data about a program's execution.\n+One is to run the program inside a profiler (such as `perf`) and another\n+is to create an instrumented binary, that is, a binary that has data\n+collection built into it, and run that.\n+The latter usually provides more accurate data and it is also what is\n+supported by `rustc`.\n+\n+## Usage\n+\n+Generating a PGO-optimized program involves following a workflow with four steps:\n+\n+1. Compile the program with instrumentation enabled\n+   (e.g. `rustc -Cprofile-generate=/tmp/pgo-data main.rs`)\n+2. Run the instrumented program (e.g. `./main`) which generates a\n+   `default_<id>.profraw` file\n+3. Convert the `.profraw` file into a `.profdata` file using\n+   LLVM's `llvm-profdata` tool\n+4. Compile the program again, this time making use of the profiling data\n+   (for example `rustc -Cprofile-use=merged.profdata main.rs`)\n+\n+An instrumented program will create one or more `.profraw` files, one for each\n+instrumented binary. E.g. an instrumented executable that loads two instrumented\n+dynamic libraries at runtime will generate three `.profraw` files. Running an\n+instrumented binary multiple times, on the other hand, will re-use the\n+respective `.profraw` files, updating them in place.\n+\n+These `.profraw` files have to be post-processed before they can be fed back\n+into the compiler. This is done by the `llvm-profdata` tool. This tool\n+is most easily installed via\n+\n+```bash\n+rustup component add llvm-tools-preview\n+```\n+\n+Note that installing the `llvm-tools-preview` component won't add\n+`llvm-profdata` to the `PATH`. Rather, the tool can be found in:\n+\n+```bash\n+~/.rustup/toolchains/<toolchain>/lib/rustlib/<target-triple>/bin/\n+```\n+\n+Alternatively, an `llvm-profdata` coming with a recent LLVM or Clang\n+version usually works too.\n+\n+The `llvm-profdata` tool merges multiple `.profraw` files into a single\n+`.profdata` file that can then be fed back into the compiler via\n+`-Cprofile-use`:\n+\n+```bash\n+# STEP 1: Compile the binary with instrumentation\n+rustc -Cprofile-generate=/tmp/pgo-data -O ./main.rs\n+\n+# STEP 2: Run the binary a few times, maybe with common sets of args.\n+#         Each run will create or update `.profraw` files in /tmp/pgo-data\n+./main mydata1.csv\n+./main mydata2.csv\n+./main mydata3.csv\n+\n+# STEP 3: Merge and post-process all the `.profraw` files in /tmp/pgo-data\n+llvm-profdata merge -o ./merged.profdata /tmp/pgo-data\n+\n+# STEP 4: Use the merged `.profdata` file during optimization. All `rustc`\n+#         flags have to be the same.\n+rustc -Cprofile-use=./merged.profdata -O ./main.rs\n+```\n+\n+### A Complete Cargo Workflow\n+\n+Using this feature with Cargo works very similar to using it with `rustc`\n+directly. Again, we generate an instrumented binary, run it to produce data,\n+merge the data, and feed it back into the compiler. Some things of note:\n+\n+- We use the `RUSTFLAGS` environment variable in order to pass the PGO compiler\n+  flags to the compilation of all crates in the program.\n+\n+- We pass the `--target` flag to Cargo, which prevents the `RUSTFLAGS`\n+  arguments to be passed to Cargo build scripts. We don't want the build\n+  scripts to generate a bunch of `.profraw` files.\n+\n+- We pass `--release` to Cargo because that's where PGO makes the most sense.\n+  In theory, PGO can also be done on debug builds but there is little reason\n+  to do so.\n+\n+- It is recommended to use *absolute paths* for the argument of\n+  `-Cprofile-generate` and `-Cprofile-use`. Cargo can invoke `rustc` with\n+  varying working directories, meaning that `rustc` will not be able to find\n+  the supplied `.profdata` file. With absolute paths this is not an issue.\n+\n+- It is good practice to make sure that there is no left-over profiling data\n+  from previous compilation sessions. Just deleting the directory is a simple\n+  way of doing so (see `STEP 0` below).\n+\n+This is what the entire workflow looks like:\n+\n+```bash\n+# STEP 0: Make sure there is no left-over profiling data from previous runs\n+rm -rf /tmp/pgo-data\n+\n+# STEP 1: Build the instrumented binaries\n+RUSTFLAGS=\"-Cprofile-generate=/tmp/pgo-data\" \\\n+    cargo build --release --target=x86_64-unknown-linux-gnu\n+\n+# STEP 2: Run the instrumented binaries with some typical data\n+./target/x86_64-unknown-linux-gnu/release/myprogram mydata1.csv\n+./target/x86_64-unknown-linux-gnu/release/myprogram mydata2.csv\n+./target/x86_64-unknown-linux-gnu/release/myprogram mydata3.csv\n+\n+# STEP 3: Merge the `.profraw` files into a `.profdata` file\n+llvm-profdata merge -o /tmp/pgo-data/merged.profdata /tmp/pgo-data\n+\n+# STEP 4: Use the `.profdata` file for guiding optimizations\n+RUSTFLAGS=\"-Cprofile-use=/tmp/pgo-data/merged.profdata\" \\\n+    cargo build --release --target=x86_64-unknown-linux-gnu\n+```\n+\n+## Further Reading\n+\n+`rustc`'s PGO support relies entirely on LLVM's implementation of the feature\n+and is equivalent to what Clang offers via the `-fprofile-generate` /\n+`-fprofile-use` flags. The [Profile Guided Optimization][clang-pgo] section\n+in Clang's documentation is therefore an interesting read for anyone who wants\n+to use PGO with Rust.\n+\n+[clang-pgo]: https://clang.llvm.org/docs/UsersManual.html#profile-guided-optimization"}, {"sha": "c9acd3c307b54690851393d1e5304d78cbcee2ad", "filename": "src/doc/rustdoc/src/documentation-tests.md", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -253,19 +253,6 @@ conversion, so type inference fails because the type is not unique. Please note\n that you must write the `(())` in one sequence without intermediate whitespace\n so that rustdoc understands you want an implicit `Result`-returning function.\n \n-As of version 1.37.0, this simplification also works with `Option`s, which can\n-be handy to test e.g. iterators or checked arithmetic, for example:\n-\n-```ignore\n-/// ```\n-/// let _ = &[].iter().next()?;\n-///# Some(())\n-/// ```\n-```\n-\n-Note that the result must be a `Some(())` and this has to be written in one go.\n-In this case disambiguating the result isn't required.\n-\n ## Documenting macros\n \n Here\u2019s an example of documenting a macro:"}, {"sha": "0d11c31aca6e956ab91f3fff9e5e82f9f1b89f23", "filename": "src/doc/unstable-book/src/language-features/member-constraints.md", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmember-constraints.md", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmember-constraints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmember-constraints.md?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -0,0 +1,29 @@\n+# `member_constraints`\n+\n+The tracking issue for this feature is: [#61977]\n+\n+[#61977]: https://github.com/rust-lang/rust/issues/61977\n+\n+------------------------\n+\n+The `member_constraints` feature gate lets you use `impl Trait` syntax with\n+multiple unrelated lifetime parameters.\n+\n+A simple example is:\n+\n+```rust\n+#![feature(member_constraints)]\n+\n+trait Trait<'a, 'b> { }\n+impl<T> Trait<'_, '_> for T {}\n+\n+fn foo<'a, 'b>(x: &'a u32, y: &'b u32) -> impl Trait<'a, 'b> {\n+  (x, y)\n+}\n+\n+fn main() { }\n+```\n+\n+Without the `member_constraints` feature gate, the above example is an\n+error because both `'a` and `'b` appear in the impl Trait bounds, but\n+neither outlives the other."}, {"sha": "00c81f03ba17394be62146924357395aa5a0d194", "filename": "src/doc/unstable-book/src/language-features/slice-patterns.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fslice-patterns.md", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fslice-patterns.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fslice-patterns.md?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -1,8 +1,8 @@\n # `slice_patterns`\n \n-The tracking issue for this feature is: [#23121]\n+The tracking issue for this feature is: [#62254]\n \n-[#23121]: https://github.com/rust-lang/rust/issues/23121\n+[#62254]: https://github.com/rust-lang/rust/issues/62254\n \n ------------------------\n "}, {"sha": "bcdeafc4b113717c431d8f833ae20a6a5c54e441", "filename": "src/doc/unstable-book/src/language-features/type-alias-enum-variants.md", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e32b8eb00a94274e680d1ae63c429d5b7db65e99/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftype-alias-enum-variants.md", "raw_url": "https://github.com/rust-lang/rust/raw/e32b8eb00a94274e680d1ae63c429d5b7db65e99/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftype-alias-enum-variants.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftype-alias-enum-variants.md?ref=e32b8eb00a94274e680d1ae63c429d5b7db65e99", "patch": "@@ -1,36 +0,0 @@\n-# `type_alias_enum_variants`\n-\n-The tracking issue for this feature is: [#49683]\n-\n-[#49683]: https://github.com/rust-lang/rust/issues/49683\n-\n-------------------------\n-\n-The `type_alias_enum_variants` feature enables the use of variants on type\n-aliases that refer to enums, as both a constructor and a pattern. That is,\n-it allows for the syntax `EnumAlias::Variant`, which behaves exactly the same\n-as `Enum::Variant` (assuming that `EnumAlias` is an alias for some enum type\n-`Enum`).\n-\n-Note that since `Self` exists as a type alias, this feature also enables the\n-use of the syntax `Self::Variant` within an impl block for an enum type.\n-\n-```rust\n-#![feature(type_alias_enum_variants)]\n-\n-enum Foo {\n-    Bar(i32),\n-    Baz { i: i32 },\n-}\n-\n-type Alias = Foo;\n-\n-fn main() {\n-    let t = Alias::Bar(0);\n-    let t = Alias::Baz { i: 0 };\n-    match t {\n-        Alias::Bar(_i) => {}\n-        Alias::Baz { i: _i } => {}\n-    }\n-}\n-```"}, {"sha": "0905789079a3e51c072cfcc0c7c621a0cdde7c02", "filename": "src/etc/cpu-usage-over-time-plot.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Fetc%2Fcpu-usage-over-time-plot.sh", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Fetc%2Fcpu-usage-over-time-plot.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fcpu-usage-over-time-plot.sh?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -16,7 +16,7 @@\n \n set -ex\n \n-bucket=rust-lang-ci-evalazure\n+bucket=rust-lang-ci2\n commit=$1\n builder=$2\n "}, {"sha": "fe38c49d2707dcdf9061e2d8fff362c06e62fb3d", "filename": "src/etc/gdb_load_rust_pretty_printers.py", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Fetc%2Fgdb_load_rust_pretty_printers.py", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Fetc%2Fgdb_load_rust_pretty_printers.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_load_rust_pretty_printers.py?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -1,2 +1,3 @@\n+import gdb\n import gdb_rust_pretty_printing\n gdb_rust_pretty_printing.register_printers(gdb.current_objfile())"}, {"sha": "41966360377b3b9f8bfeec6e7648eac2b9920c37", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -367,23 +367,35 @@ impl<T: Clone> Clone for Box<T> {\n     /// ```\n     /// let x = Box::new(5);\n     /// let y = x.clone();\n+    ///\n+    /// // The value is the same\n+    /// assert_eq!(x, y);\n+    ///\n+    /// // But they are unique objects\n+    /// assert_ne!(&*x as *const i32, &*y as *const i32);\n     /// ```\n     #[rustfmt::skip]\n     #[inline]\n     fn clone(&self) -> Box<T> {\n         box { (**self).clone() }\n     }\n+\n     /// Copies `source`'s contents into `self` without creating a new allocation.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// let x = Box::new(5);\n     /// let mut y = Box::new(10);\n+    /// let yp: *const i32 = &*y;\n     ///\n     /// y.clone_from(&x);\n     ///\n-    /// assert_eq!(*y, 5);\n+    /// // The value is the same\n+    /// assert_eq!(x, y);\n+    ///\n+    /// // And no allocation occurred\n+    /// assert_eq!(yp, &*y);\n     /// ```\n     #[inline]\n     fn clone_from(&mut self, source: &Box<T>) {\n@@ -716,6 +728,14 @@ impl<I: Iterator + ?Sized> Iterator for Box<I> {\n         (**self).nth(n)\n     }\n }\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: Iterator + Sized> Iterator for Box<I> {\n+    fn last(self) -> Option<I::Item> where I: Sized {\n+        (*self).last()\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I: DoubleEndedIterator + ?Sized> DoubleEndedIterator for Box<I> {\n     fn next_back(&mut self) -> Option<I::Item> {"}, {"sha": "9f531f5b83c75d6444b56ba7bb82aec8d1c5a929", "filename": "src/liballoc/collections/binary_heap.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -1035,6 +1035,11 @@ impl<'a, T> Iterator for Iter<'a, T> {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         self.iter.size_hint()\n     }\n+\n+    #[inline]\n+    fn last(self) -> Option<&'a T> {\n+        self.iter.last()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "ca35600e857925557e0bad711e8a6d2360ab4529", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 30, "deletions": 2, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -770,8 +770,8 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         }\n \n         // First, we merge `self` and `other` into a sorted sequence in linear time.\n-        let self_iter = mem::replace(self, BTreeMap::new()).into_iter();\n-        let other_iter = mem::replace(other, BTreeMap::new()).into_iter();\n+        let self_iter = mem::take(self).into_iter();\n+        let other_iter = mem::take(other).into_iter();\n         let iter = MergeIter {\n             left: self_iter.peekable(),\n             right: other_iter.peekable(),\n@@ -1193,6 +1193,10 @@ impl<'a, K: 'a, V: 'a> Iterator for Iter<'a, K, V> {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         (self.length, Some(self.length))\n     }\n+\n+    fn last(mut self) -> Option<(&'a K, &'a V)> {\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n@@ -1253,6 +1257,10 @@ impl<'a, K: 'a, V: 'a> Iterator for IterMut<'a, K, V> {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         (self.length, Some(self.length))\n     }\n+\n+    fn last(mut self) -> Option<(&'a K, &'a mut V)> {\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1421,6 +1429,10 @@ impl<'a, K, V> Iterator for Keys<'a, K, V> {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         self.inner.size_hint()\n     }\n+\n+    fn last(mut self) -> Option<&'a K> {\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1458,6 +1470,10 @@ impl<'a, K, V> Iterator for Values<'a, K, V> {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         self.inner.size_hint()\n     }\n+\n+    fn last(mut self) -> Option<&'a V> {\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1495,6 +1511,10 @@ impl<'a, K, V> Iterator for Range<'a, K, V> {\n             unsafe { Some(self.next_unchecked()) }\n         }\n     }\n+\n+    fn last(mut self) -> Option<(&'a K, &'a V)> {\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"map_values_mut\", since = \"1.10.0\")]\n@@ -1508,6 +1528,10 @@ impl<'a, K, V> Iterator for ValuesMut<'a, K, V> {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         self.inner.size_hint()\n     }\n+\n+    fn last(mut self) -> Option<&'a mut V> {\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"map_values_mut\", since = \"1.10.0\")]\n@@ -1626,6 +1650,10 @@ impl<'a, K, V> Iterator for RangeMut<'a, K, V> {\n             unsafe { Some(self.next_unchecked()) }\n         }\n     }\n+\n+    fn last(mut self) -> Option<(&'a K, &'a mut V)> {\n+        self.next_back()\n+    }\n }\n \n impl<'a, K, V> RangeMut<'a, K, V> {"}, {"sha": "d3af910a82c27939dab4b03e1190ccad6b842a86", "filename": "src/liballoc/collections/btree/set.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -1019,6 +1019,9 @@ impl<'a, T> Iterator for Iter<'a, T> {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         self.iter.size_hint()\n     }\n+    fn last(mut self) -> Option<&'a T> {\n+        self.next_back()\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n@@ -1073,6 +1076,10 @@ impl<'a, T> Iterator for Range<'a, T> {\n     fn next(&mut self) -> Option<&'a T> {\n         self.iter.next().map(|(k, _)| k)\n     }\n+\n+    fn last(mut self) -> Option<&'a T> {\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"btree_range\", since = \"1.17.0\")]"}, {"sha": "db0d6e2f9b9d4ac7246783c97a13555c0d3974be", "filename": "src/liballoc/collections/linked_list.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Flinked_list.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -708,7 +708,7 @@ impl<T> LinkedList<T> {\n         let len = self.len();\n         assert!(at <= len, \"Cannot split off at a nonexistent index\");\n         if at == 0 {\n-            return mem::replace(self, Self::new());\n+            return mem::take(self);\n         } else if at == len {\n             return Self::new();\n         }\n@@ -832,6 +832,11 @@ impl<'a, T> Iterator for Iter<'a, T> {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         (self.len, Some(self.len))\n     }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<&'a T> {\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -881,6 +886,11 @@ impl<'a, T> Iterator for IterMut<'a, T> {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         (self.len, Some(self.len))\n     }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<&'a mut T> {\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "573dd86b23aeb0276f266d9be83777c8e34b7d33", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -2206,6 +2206,11 @@ impl<'a, T> Iterator for Iter<'a, T> {\n         self.tail = self.head - iter.len();\n         final_res\n     }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<&'a T> {\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -2319,6 +2324,11 @@ impl<'a, T> Iterator for IterMut<'a, T> {\n         accum = front.iter_mut().fold(accum, &mut f);\n         back.iter_mut().fold(accum, &mut f)\n     }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<&'a mut T> {\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "bfe7d12d9d0babec125041e8accddf69b457f61f", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -112,6 +112,7 @@\n #![feature(maybe_uninit_extra, maybe_uninit_slice, maybe_uninit_array)]\n #![feature(alloc_layout_extra)]\n #![feature(try_trait)]\n+#![feature(mem_take)]\n \n // Allow testing this library\n "}, {"sha": "70a93157c9ee26d12e3070d7b411cf0e51c2e05f", "filename": "src/liballoc/str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Fliballoc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Fliballoc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstr.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -203,7 +203,7 @@ impl ToOwned for str {\n     }\n \n     fn clone_into(&self, target: &mut String) {\n-        let mut b = mem::replace(target, String::new()).into_bytes();\n+        let mut b = mem::take(target).into_bytes();\n         self.as_bytes().clone_into(&mut b);\n         *target = unsafe { String::from_utf8_unchecked(b) }\n     }"}, {"sha": "1b0d3c19692748f53ad26d86076ecb68c0a1b064", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -2385,6 +2385,11 @@ impl Iterator for Drain<'_> {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         self.iter.size_hint()\n     }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<char> {\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"drain\", since = \"1.6.0\")]"}, {"sha": "e0c724f557b9d0d9f84475e68ad5a0a5598d7349", "filename": "src/liballoc/tests/vec.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Fliballoc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Fliballoc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -761,7 +761,6 @@ fn from_into_inner() {\n     it.next().unwrap();\n     let vec = it.collect::<Vec<_>>();\n     assert_eq!(vec, [2, 3]);\n-    #[cfg(not(miri))] // Miri does not support comparing dangling pointers\n     assert!(ptr != vec.as_ptr());\n }\n "}, {"sha": "c0544d7469ca76e0f572275e4e6a8e6cb99bbd71", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -1367,6 +1367,40 @@ impl<T> Vec<T> {\n             self.truncate(new_len);\n         }\n     }\n+\n+    /// Consumes and leaks the `Vec`, returning a mutable reference to the contents,\n+    /// `&'a mut [T]`. Note that the type `T` must outlive the chosen lifetime\n+    /// `'a`. If the type has only static references, or none at all, then this\n+    /// may be chosen to be `'static`.\n+    ///\n+    /// This function is similar to the `leak` function on `Box`.\n+    ///\n+    /// This function is mainly useful for data that lives for the remainder of\n+    /// the program's life. Dropping the returned reference will cause a memory\n+    /// leak.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Simple usage:\n+    ///\n+    /// ```\n+    /// #![feature(vec_leak)]\n+    ///\n+    /// fn main() {\n+    ///     let x = vec![1, 2, 3];\n+    ///     let static_ref: &'static mut [usize] = Vec::leak(x);\n+    ///     static_ref[0] += 1;\n+    ///     assert_eq!(static_ref, &[2, 2, 3]);\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"vec_leak\", issue = \"62195\")]\n+    #[inline]\n+    pub fn leak<'a>(vec: Vec<T>) -> &'a mut [T]\n+    where\n+        T: 'a // Technically not needed, but kept to be explicit.\n+    {\n+        Box::leak(vec.into_boxed_slice())\n+    }\n }\n \n impl<T: Clone> Vec<T> {"}, {"sha": "e6a6fdde540422abac4613b194ae73ae267d3345", "filename": "src/libcore/ascii.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibcore%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibcore%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fascii.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -117,6 +117,7 @@ impl Iterator for EscapeDefault {\n     type Item = u8;\n     fn next(&mut self) -> Option<u8> { self.range.next().map(|i| self.data[i]) }\n     fn size_hint(&self) -> (usize, Option<usize>) { self.range.size_hint() }\n+    fn last(mut self) -> Option<u8> { self.next_back() }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl DoubleEndedIterator for EscapeDefault {"}, {"sha": "e843303380ad0dfd91d58cce14d828d36556de16", "filename": "src/libcore/char/methods.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibcore%2Fchar%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibcore%2Fchar%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmethods.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -337,16 +337,16 @@ impl char {\n     /// ```\n     /// // as chars\n     /// let eastern = '\u6771';\n-    /// let capitol = '\u4eac';\n+    /// let capital = '\u4eac';\n     ///\n     /// // both can be represented as three bytes\n     /// assert_eq!(3, eastern.len_utf8());\n-    /// assert_eq!(3, capitol.len_utf8());\n+    /// assert_eq!(3, capital.len_utf8());\n     ///\n     /// // as a &str, these two are encoded in UTF-8\n     /// let tokyo = \"\u6771\u4eac\";\n     ///\n-    /// let len = eastern.len_utf8() + capitol.len_utf8();\n+    /// let len = eastern.len_utf8() + capital.len_utf8();\n     ///\n     /// // we can see that they take six bytes total...\n     /// assert_eq!(6, tokyo.len());"}, {"sha": "c0de8e2ceb3f38b33802d52d0e1dbf87851e1a7b", "filename": "src/libcore/convert.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -251,12 +251,12 @@ pub trait AsMut<T: ?Sized> {\n ///\n /// # Examples\n ///\n-/// [`String`] implements `Into<Vec<u8>>`:\n+/// [`String`] implements [`Into`]`<`[`Vec`]`<`[`u8`]`>>`:\n ///\n /// In order to express that we want a generic function to take all arguments that can be\n /// converted to a specified type `T`, we can use a trait bound of [`Into`]`<T>`.\n /// For example: The function `is_hello` takes all arguments that can be converted into a\n-/// `Vec<u8>`.\n+/// [`Vec`]`<`[`u8`]`>`.\n ///\n /// ```\n /// fn is_hello<T: Into<Vec<u8>>>(s: T) {\n@@ -274,6 +274,7 @@ pub trait AsMut<T: ?Sized> {\n /// [`String`]: ../../std/string/struct.String.html\n /// [`From`]: trait.From.html\n /// [`Into`]: trait.Into.html\n+/// [`Vec`]: ../../std/vec/struct.Vec.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Into<T>: Sized {\n     /// Performs the conversion.\n@@ -410,12 +411,12 @@ pub trait TryInto<T>: Sized {\n ///\n /// This is useful when you are doing a type conversion that may\n /// trivially succeed but may also need special handling.\n-/// For example, there is no way to convert an `i64` into an `i32`\n-/// using the [`From`] trait, because an `i64` may contain a value\n-/// that an `i32` cannot represent and so the conversion would lose data.\n-/// This might be handled by truncating the `i64` to an `i32` (essentially\n-/// giving the `i64`'s value modulo `i32::MAX`) or by simply returning\n-/// `i32::MAX`, or by some other method.  The `From` trait is intended\n+/// For example, there is no way to convert an [`i64`] into an [`i32`]\n+/// using the [`From`] trait, because an [`i64`] may contain a value\n+/// that an [`i32`] cannot represent and so the conversion would lose data.\n+/// This might be handled by truncating the [`i64`] to an [`i32`] (essentially\n+/// giving the [`i64`]'s value modulo [`i32::MAX`]) or by simply returning\n+/// [`i32::MAX`], or by some other method.  The [`From`] trait is intended\n /// for perfect conversions, so the `TryFrom` trait informs the\n /// programmer when a type conversion could go bad and lets them\n /// decide how to handle it.\n@@ -425,8 +426,8 @@ pub trait TryInto<T>: Sized {\n /// - `TryFrom<T> for U` implies [`TryInto`]`<U> for T`\n /// - [`try_from`] is reflexive, which means that `TryFrom<T> for T`\n /// is implemented and cannot fail -- the associated `Error` type for\n-/// calling `T::try_from()` on a value of type `T` is `Infallible`.\n-/// When the `!` type is stablized `Infallible` and `!` will be\n+/// calling `T::try_from()` on a value of type `T` is [`Infallible`].\n+/// When the [`!`] type is stablized [`Infallible`] and [`!`] will be\n /// equivalent.\n ///\n /// `TryFrom<T>` can be implemented as follows:\n@@ -451,7 +452,7 @@ pub trait TryInto<T>: Sized {\n ///\n /// # Examples\n ///\n-/// As described, [`i32`] implements `TryFrom<i64>`:\n+/// As described, [`i32`] implements `TryFrom<`[`i64`]`>`:\n ///\n /// ```\n /// use std::convert::TryFrom;\n@@ -474,6 +475,8 @@ pub trait TryInto<T>: Sized {\n ///\n /// [`try_from`]: trait.TryFrom.html#tymethod.try_from\n /// [`TryInto`]: trait.TryInto.html\n+/// [`i32::MAX`]: ../../std/i32/constant.MAX.html\n+/// [`!`]: ../../std/primitive.never.html\n #[stable(feature = \"try_from\", since = \"1.34.0\")]\n pub trait TryFrom<T>: Sized {\n     /// The type returned in the event of a conversion error."}, {"sha": "1865160bc3cf428626241165fbf37ef080aa940c", "filename": "src/libcore/iter/traits/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibcore%2Fiter%2Ftraits%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibcore%2Fiter%2Ftraits%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fcollect.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -196,7 +196,7 @@ pub trait FromIterator<A>: Sized {\n /// ```rust\n /// fn collect_as_strings<T>(collection: T) -> Vec<String>\n ///     where T: IntoIterator,\n-///           T::Item : std::fmt::Debug,\n+///           T::Item: std::fmt::Debug,\n /// {\n ///     collection\n ///         .into_iter()"}, {"sha": "d2d08a075b92cac902a8982fe639ccfc24db94b4", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -126,6 +126,7 @@\n #![feature(adx_target_feature)]\n #![feature(maybe_uninit_slice, maybe_uninit_array)]\n #![feature(external_doc)]\n+#![feature(mem_take)]\n \n #[prelude_import]\n #[allow(unused)]"}, {"sha": "d9757d78dcebbf34886c9c6b8915e9faf0e9b9ef", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -73,9 +73,9 @@ impl<T: ?Sized> !Send for *mut T { }\n /// impl Foo for Impl { }\n /// impl Bar for Impl { }\n ///\n-/// let x: &Foo = &Impl;    // OK\n-/// // let y: &Bar = &Impl; // error: the trait `Bar` cannot\n-///                         // be made into an object\n+/// let x: &dyn Foo = &Impl;    // OK\n+/// // let y: &dyn Bar = &Impl; // error: the trait `Bar` cannot\n+///                             // be made into an object\n /// ```\n ///\n /// [trait object]: ../../book/ch17-02-trait-objects.html"}, {"sha": "b31522db474b7613d98757b92a151e39fa37ca27", "filename": "src/libcore/mem/mod.rs", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibcore%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibcore%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmod.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -510,6 +510,8 @@ pub fn swap<T>(x: &mut T, y: &mut T) {\n /// A simple example:\n ///\n /// ```\n+/// #![feature(mem_take)]\n+///\n /// use std::mem;\n ///\n /// let mut v: Vec<i32> = vec![1, 2];\n@@ -540,7 +542,8 @@ pub fn swap<T>(x: &mut T, y: &mut T) {\n /// `self`, allowing it to be returned:\n ///\n /// ```\n-/// # #![allow(dead_code)]\n+/// #![feature(mem_take)]\n+///\n /// use std::mem;\n ///\n /// # struct Buffer<T> { buf: Vec<T> }\n@@ -549,6 +552,12 @@ pub fn swap<T>(x: &mut T, y: &mut T) {\n ///         mem::take(&mut self.buf)\n ///     }\n /// }\n+///\n+/// let mut buffer = Buffer { buf: vec![0, 1] };\n+/// assert_eq!(buffer.buf.len(), 2);\n+///\n+/// assert_eq!(buffer.get_and_reset(), vec![0, 1]);\n+/// assert_eq!(buffer.buf.len(), 0);\n /// ```\n ///\n /// [`Clone`]: ../../std/clone/trait.Clone.html\n@@ -583,17 +592,17 @@ pub fn take<T: Default>(dest: &mut T) -> T {\n /// struct Buffer<T> { buf: Vec<T> }\n ///\n /// impl<T> Buffer<T> {\n-///     fn get_and_reset(&mut self) -> Vec<T> {\n+///     fn replace_index(&mut self, i: usize, v: T) -> T {\n ///         // error: cannot move out of dereference of `&mut`-pointer\n-///         let buf = self.buf;\n-///         self.buf = Vec::new();\n-///         buf\n+///         let t = self.buf[i];\n+///         self.buf[i] = v;\n+///         t\n ///     }\n /// }\n /// ```\n ///\n-/// Note that `T` does not necessarily implement [`Clone`], so it can't even clone and reset\n-/// `self.buf`. But `replace` can be used to disassociate the original value of `self.buf` from\n+/// Note that `T` does not necessarily implement [`Clone`], so we can't even clone `self.buf[i]` to\n+/// avoid the move. But `replace` can be used to disassociate the original value at that index from\n /// `self`, allowing it to be returned:\n ///\n /// ```\n@@ -602,10 +611,16 @@ pub fn take<T: Default>(dest: &mut T) -> T {\n ///\n /// # struct Buffer<T> { buf: Vec<T> }\n /// impl<T> Buffer<T> {\n-///     fn get_and_reset(&mut self) -> Vec<T> {\n-///         mem::replace(&mut self.buf, Vec::new())\n+///     fn replace_index(&mut self, i: usize, v: T) -> T {\n+///         mem::replace(&mut self.buf[i], v)\n ///     }\n /// }\n+///\n+/// let mut buffer = Buffer { buf: vec![0, 1] };\n+/// assert_eq!(buffer.buf[0], 0);\n+///\n+/// assert_eq!(buffer.replace_index(0, 2), 0);\n+/// assert_eq!(buffer.buf[0], 2);\n /// ```\n ///\n /// [`Clone`]: ../../std/clone/trait.Clone.html"}, {"sha": "b27fd4098e167f7bca2be9923fa2a9370329f1e8", "filename": "src/libcore/option.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -777,15 +777,7 @@ impl<T> Option<T> {\n     #[inline]\n     #[stable(feature = \"option_entry\", since = \"1.20.0\")]\n     pub fn get_or_insert(&mut self, v: T) -> &mut T {\n-        match *self {\n-            None => *self = Some(v),\n-            _ => (),\n-        }\n-\n-        match *self {\n-            Some(ref mut v) => v,\n-            None => unsafe { hint::unreachable_unchecked() },\n-        }\n+        self.get_or_insert_with(|| v)\n     }\n \n     /// Inserts a value computed from `f` into the option if it is [`None`], then\n@@ -845,7 +837,7 @@ impl<T> Option<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn take(&mut self) -> Option<T> {\n-        mem::replace(self, None)\n+        mem::take(self)\n     }\n \n     /// Replaces the actual value in the option by the value given in parameter,"}, {"sha": "da781d7e9feeea2fe8f61b93f3675b7755213c09", "filename": "src/libcore/ptr/mod.rs", "status": "modified", "additions": 5, "deletions": 27, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibcore%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibcore%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmod.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -100,16 +100,19 @@ pub use unique::Unique;\n ///   as the compiler doesn't need to prove that it's sound to elide the\n ///   copy.\n ///\n+/// Unaligned values cannot be dropped in place, they must be copied to an aligned\n+/// location first using [`ptr::read_unaligned`].\n+///\n /// [`ptr::read`]: ../ptr/fn.read.html\n+/// [`ptr::read_unaligned`]: ../ptr/fn.read_unaligned.html\n ///\n /// # Safety\n ///\n /// Behavior is undefined if any of the following conditions are violated:\n ///\n /// * `to_drop` must be [valid] for reads.\n ///\n-/// * `to_drop` must be properly aligned. See the example below for how to drop\n-///   an unaligned pointer.\n+/// * `to_drop` must be properly aligned.\n ///\n /// Additionally, if `T` is not [`Copy`], using the pointed-to value after\n /// calling `drop_in_place` can cause undefined behavior. Note that `*to_drop =\n@@ -153,31 +156,6 @@ pub use unique::Unique;\n /// assert!(weak.upgrade().is_none());\n /// ```\n ///\n-/// Unaligned values cannot be dropped in place, they must be copied to an aligned\n-/// location first:\n-/// ```\n-/// use std::ptr;\n-/// use std::mem::{self, MaybeUninit};\n-///\n-/// unsafe fn drop_after_copy<T>(to_drop: *mut T) {\n-///     let mut copy: MaybeUninit<T> = MaybeUninit::uninit();\n-///     ptr::copy(to_drop, copy.as_mut_ptr(), 1);\n-///     drop(copy.assume_init());\n-/// }\n-///\n-/// #[repr(packed, C)]\n-/// struct Packed {\n-///     _padding: u8,\n-///     unaligned: Vec<i32>,\n-/// }\n-///\n-/// let mut p = Packed { _padding: 0, unaligned: vec![42] };\n-/// unsafe {\n-///     drop_after_copy(&mut p.unaligned as *mut _);\n-///     mem::forget(p);\n-/// }\n-/// ```\n-///\n /// Notice that the compiler performs this copy automatically when dropping packed structs,\n /// i.e., you do not usually have to worry about such issues unless you call `drop_in_place`\n /// manually."}, {"sha": "75c329a7d6c10ad4a60d795a1fe58e48f6a69e02", "filename": "src/libcore/raw.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibcore%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibcore%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fraw.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -53,7 +53,7 @@\n /// let value: i32 = 123;\n ///\n /// // let the compiler make a trait object\n-/// let object: &Foo = &value;\n+/// let object: &dyn Foo = &value;\n ///\n /// // look at the raw representation\n /// let raw_object: raw::TraitObject = unsafe { mem::transmute(object) };\n@@ -65,7 +65,7 @@\n ///\n /// // construct a new object, pointing to a different `i32`, being\n /// // careful to use the `i32` vtable from `object`\n-/// let synthesized: &Foo = unsafe {\n+/// let synthesized: &dyn Foo = unsafe {\n ///      mem::transmute(raw::TraitObject {\n ///          data: &other_value as *const _ as *mut (),\n ///          vtable: raw_object.vtable,"}, {"sha": "fe48e2458cd162e5d9c627ad962b0c45aea8f6e6", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -4453,6 +4453,21 @@ impl<'a, T> DoubleEndedIterator for ChunksExact<'a, T> {\n             Some(snd)\n         }\n     }\n+\n+    #[inline]\n+    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n+        let len = self.len();\n+        if n >= len {\n+            self.v = &[];\n+            None\n+        } else {\n+            let start = (len - 1 - n) * self.chunk_size;\n+            let end = start + self.chunk_size;\n+            let nth_back = &self.v[start..end];\n+            self.v = &self.v[..start];\n+            Some(nth_back)\n+        }\n+    }\n }\n \n #[stable(feature = \"chunks_exact\", since = \"1.31.0\")]"}, {"sha": "b027e6bc051b3abe96d10bc8959460ed2edf2825", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 31, "deletions": 16, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -1333,6 +1333,11 @@ impl<'a> Iterator for Lines<'a> {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         self.0.size_hint()\n     }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<&'a str> {\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -3716,10 +3721,10 @@ impl str {\n     ///\n     /// # Text directionality\n     ///\n-    /// A string is a sequence of bytes. 'Left' in this context means the first\n-    /// position of that byte string; for a language like Arabic or Hebrew\n-    /// which are 'right to left' rather than 'left to right', this will be\n-    /// the _right_ side, not the left.\n+    /// A string is a sequence of bytes. `start` in this context means the first\n+    /// position of that byte string; for a left-to-right language like English or\n+    /// Russian, this will be left side, and for right-to-left languages like\n+    /// like Arabic or Hebrew, this will be the right side.\n     ///\n     /// # Examples\n     ///\n@@ -3755,10 +3760,10 @@ impl str {\n     ///\n     /// # Text directionality\n     ///\n-    /// A string is a sequence of bytes. 'Right' in this context means the last\n-    /// position of that byte string; for a language like Arabic or Hebrew\n-    /// which are 'right to left' rather than 'left to right', this will be\n-    /// the _left_ side, not the right.\n+    /// A string is a sequence of bytes. `end` in this context means the last\n+    /// position of that byte string; for a left-to-right language like English or\n+    /// Russian, this will be right side, and for right-to-left languages like\n+    /// like Arabic or Hebrew, this will be the left side.\n     ///\n     /// # Examples\n     ///\n@@ -3804,10 +3809,10 @@ impl str {\n     ///\n     /// # Text directionality\n     ///\n-    /// A string is a sequence of bytes. `start` in this context means the first\n-    /// position of that byte string; for a left-to-right language like English or\n-    /// Russian, this will be left side, and for right-to-left languages like\n-    /// like Arabic or Hebrew, this will be the right side.\n+    /// A string is a sequence of bytes. 'Left' in this context means the first\n+    /// position of that byte string; for a language like Arabic or Hebrew\n+    /// which are 'right to left' rather than 'left to right', this will be\n+    /// the _right_ side, not the left.\n     ///\n     /// # Examples\n     ///\n@@ -3840,10 +3845,10 @@ impl str {\n     ///\n     /// # Text directionality\n     ///\n-    /// A string is a sequence of bytes. `end` in this context means the last\n-    /// position of that byte string; for a left-to-right language like English or\n-    /// Russian, this will be right side, and for right-to-left languages like\n-    /// like Arabic or Hebrew, this will be the left side.\n+    /// A string is a sequence of bytes. 'Right' in this context means the last\n+    /// position of that byte string; for a language like Arabic or Hebrew\n+    /// which are 'right to left' rather than 'left to right', this will be\n+    /// the _left_ side, not the right.\n     ///\n     /// # Examples\n     ///\n@@ -4241,6 +4246,11 @@ impl<'a> Iterator for SplitWhitespace<'a> {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         self.inner.size_hint()\n     }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<&'a str> {\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n@@ -4267,6 +4277,11 @@ impl<'a> Iterator for SplitAsciiWhitespace<'a> {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         self.inner.size_hint()\n     }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<&'a str> {\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"split_ascii_whitespace\", since = \"1.34.0\")]"}, {"sha": "439ed0c81c8b66e5fdda531c4c9c089b2041185b", "filename": "src/libcore/tests/ascii.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibcore%2Ftests%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibcore%2Ftests%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fascii.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -151,7 +151,7 @@ macro_rules! assert_none {\n                            stringify!($what), b);\n                 }\n             }\n-        )*\n+        )+\n     }};\n     ($what:ident, $($str:tt),+,) => (assert_none!($what,$($str),+))\n }"}, {"sha": "d86e21cf40b6e7e36da4238066adf742cd887d58", "filename": "src/libcore/tests/fmt/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibcore%2Ftests%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibcore%2Ftests%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Ffmt%2Fmod.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -3,7 +3,6 @@ mod float;\n mod num;\n \n #[test]\n-#[cfg(not(miri))] // Miri cannot print pointers\n fn test_format_flags() {\n     // No residual flags left by pointer formatting\n     let p = \"\".as_ptr();\n@@ -13,7 +12,6 @@ fn test_format_flags() {\n }\n \n #[test]\n-#[cfg(not(miri))] // Miri cannot print pointers\n fn test_pointer_formats_data_pointer() {\n     let b: &[u8] = b\"\";\n     let s: &str = \"\";"}, {"sha": "06c3a78c1698ac831d548abc54fb3a1057ea4e52", "filename": "src/libcore/tests/pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibcore%2Ftests%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibcore%2Ftests%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fpattern.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -5,7 +5,7 @@ use std::str::pattern::*;\n macro_rules! search_asserts {\n     ($haystack:expr, $needle:expr, $testname:expr, [$($func:ident),*], $result:expr) => {\n         let mut searcher = $needle.into_searcher($haystack);\n-        let arr = [$( Step::from(searcher.$func()) ),+];\n+        let arr = [$( Step::from(searcher.$func()) ),*];\n         assert_eq!(&arr[..], &$result, $testname);\n     }\n }"}, {"sha": "569b3197d09bd64576d7b3fcac10a619071a09c5", "filename": "src/libcore/tests/ptr.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibcore%2Ftests%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibcore%2Ftests%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fptr.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -253,7 +253,6 @@ fn test_unsized_nonnull() {\n \n #[test]\n #[allow(warnings)]\n-#[cfg(not(miri))] // Miri cannot hash pointers\n // Have a symbol for the test below. It doesn\u2019t need to be an actual variadic function, match the\n // ABI, or even point to an actual executable code, because the function itself is never invoked.\n #[no_mangle]\n@@ -293,7 +292,7 @@ fn write_unaligned_drop() {\n }\n \n #[test]\n-#[cfg(not(miri))] // Miri cannot compute actual alignment of an allocation\n+#[cfg(not(miri))] // Miri does not compute a maximal `mid` for `align_offset`\n fn align_offset_zst() {\n     // For pointers of stride = 0, the pointer is already aligned or it cannot be aligned at\n     // all, because no amount of elements will align the pointer.\n@@ -308,7 +307,7 @@ fn align_offset_zst() {\n }\n \n #[test]\n-#[cfg(not(miri))] // Miri cannot compute actual alignment of an allocation\n+#[cfg(not(miri))] // Miri does not compute a maximal `mid` for `align_offset`\n fn align_offset_stride1() {\n     // For pointers of stride = 1, the pointer can always be aligned. The offset is equal to\n     // number of bytes."}, {"sha": "42ec9d451f7901dfbb9aeb00ebcb6d083b595290", "filename": "src/libcore/tests/slice.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fslice.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -275,6 +275,25 @@ fn test_chunks_exact_nth() {\n     assert_eq!(c2.next(), None);\n }\n \n+#[test]\n+fn test_chunks_exact_nth_back() {\n+    let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n+    let mut c = v.chunks_exact(2);\n+    assert_eq!(c.nth_back(1).unwrap(), &[2, 3]);\n+    assert_eq!(c.next().unwrap(), &[0, 1]);\n+    assert_eq!(c.next(), None);\n+\n+    let v2: &[i32] = &[0, 1, 2, 3, 4];\n+    let mut c2 = v2.chunks_exact(3);\n+    assert_eq!(c2.nth_back(0).unwrap(), &[0, 1, 2]);\n+    assert_eq!(c2.next(), None);\n+    assert_eq!(c2.next_back(), None);\n+\n+    let v3: &[i32] = &[0, 1, 2, 3, 4];\n+    let mut c3 = v3.chunks_exact(10);\n+    assert_eq!(c3.nth_back(0), None);\n+}\n+\n #[test]\n fn test_chunks_exact_last() {\n     let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n@@ -1396,7 +1415,7 @@ pub mod memchr {\n }\n \n #[test]\n-#[cfg(not(miri))] // Miri cannot compute actual alignment of an allocation\n+#[cfg(not(miri))] // Miri does not compute a maximal `mid` for `align_offset`\n fn test_align_to_simple() {\n     let bytes = [1u8, 2, 3, 4, 5, 6, 7];\n     let (prefix, aligned, suffix) = unsafe { bytes.align_to::<u16>() };\n@@ -1420,7 +1439,7 @@ fn test_align_to_zst() {\n }\n \n #[test]\n-#[cfg(not(miri))] // Miri cannot compute actual alignment of an allocation\n+#[cfg(not(miri))] // Miri does not compute a maximal `mid` for `align_offset`\n fn test_align_to_non_trivial() {\n     #[repr(align(8))] struct U64(u64, u64);\n     #[repr(align(8))] struct U64U64U32(u64, u64, u32);"}, {"sha": "a51e3a9a33d7b542cd823fdbc315bb1ec76e10b2", "filename": "src/libproc_macro/bridge/buffer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibproc_macro%2Fbridge%2Fbuffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibproc_macro%2Fbridge%2Fbuffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fbridge%2Fbuffer.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -78,7 +78,7 @@ impl<T: Copy> Buffer<T> {\n     }\n \n     pub(super) fn take(&mut self) -> Self {\n-        mem::replace(self, Self::default())\n+        mem::take(self)\n     }\n \n     pub(super) fn extend_from_slice(&mut self, xs: &[T]) {"}, {"sha": "89fb707001589339874dbf48609ffd63ebeef200", "filename": "src/libproc_macro/bridge/scoped_cell.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibproc_macro%2Fbridge%2Fscoped_cell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibproc_macro%2Fbridge%2Fscoped_cell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fbridge%2Fscoped_cell.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -74,7 +74,7 @@ impl<T: LambdaL> ScopedCell<T> {\n     }\n \n     /// Sets the value in `self` to `value` while running `f`.\n-    pub fn set<'a, R>(&self, value: <T as ApplyL<'a>>::Out, f: impl FnOnce() -> R) -> R {\n+    pub fn set<R>(&self, value: <T as ApplyL<'_>>::Out, f: impl FnOnce() -> R) -> R {\n         self.replace(value, |_| f())\n     }\n }"}, {"sha": "2c097238b95b24801d6590aa4b60221699bb5cb4", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -25,6 +25,7 @@\n #![feature(extern_types)]\n #![feature(in_band_lifetimes)]\n #![feature(optin_builtin_traits)]\n+#![feature(mem_take)]\n #![feature(non_exhaustive)]\n #![feature(specialization)]\n "}, {"sha": "a132575b0c673b8b35848e0a2a29871e55f2009e", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -1,11 +1,11 @@\n use crate::cfg::*;\n use crate::middle::region;\n use rustc_data_structures::graph::implementation as graph;\n-use syntax::ptr::P;\n use crate::ty::{self, TyCtxt};\n \n use crate::hir::{self, PatKind};\n use crate::hir::def_id::DefId;\n+use crate::hir::ptr::P;\n \n struct CFGBuilder<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n@@ -30,7 +30,7 @@ struct LoopScope {\n     break_index: CFGIndex,    // where to go on a `break`\n }\n \n-pub fn construct<'tcx>(tcx: TyCtxt<'tcx>, body: &hir::Body) -> CFG {\n+pub fn construct(tcx: TyCtxt<'_>, body: &hir::Body) -> CFG {\n     let mut graph = graph::Graph::new();\n     let entry = graph.add_node(CFGNodeData::Entry);\n "}, {"sha": "88fc7fbfad51ff7692481533906bf8bf6c03d03a", "filename": "src/librustc/cfg/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fcfg%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fcfg%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fmod.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -49,7 +49,7 @@ pub type CFGNode = graph::Node<CFGNodeData>;\n pub type CFGEdge = graph::Edge<CFGEdgeData>;\n \n impl CFG {\n-    pub fn new<'tcx>(tcx: TyCtxt<'tcx>, body: &hir::Body) -> CFG {\n+    pub fn new(tcx: TyCtxt<'_>, body: &hir::Body) -> CFG {\n         construct::construct(tcx, body)\n     }\n "}, {"sha": "3d5e7dd0af1213b009b6f61d88f573916cfc40ef", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -142,9 +142,6 @@ macro_rules! define_dep_nodes {\n                 }\n             }\n \n-            // FIXME: Make `is_anon`, `is_eval_always` and `has_params` properties\n-            // of queries\n-            #[inline(always)]\n             pub fn is_anon(&self) -> bool {\n                 match *self {\n                     $(\n@@ -163,7 +160,6 @@ macro_rules! define_dep_nodes {\n             }\n \n             #[allow(unreachable_code)]\n-            #[inline(always)]\n             pub fn has_params(&self) -> bool {\n                 match *self {\n                     $("}, {"sha": "b8c6c1e3723826a19e070d0bc8c1e254d101da7e", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 14, "deletions": 25, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -841,32 +841,21 @@ impl DepGraph {\n     //\n     // This method will only load queries that will end up in the disk cache.\n     // Other queries will not be executed.\n-    pub fn exec_cache_promotions<'tcx>(&self, tcx: TyCtxt<'tcx>) {\n-        let green_nodes: Vec<DepNode> = {\n-            let data = self.data.as_ref().unwrap();\n-            data.colors.values.indices().filter_map(|prev_index| {\n-                match data.colors.get(prev_index) {\n-                    Some(DepNodeColor::Green(_)) => {\n-                        let dep_node = data.previous.index_to_node(prev_index);\n-                        if dep_node.cache_on_disk(tcx) {\n-                            Some(dep_node)\n-                        } else {\n-                            None\n-                        }\n-                    }\n-                    None |\n-                    Some(DepNodeColor::Red) => {\n-                        // We can skip red nodes because a node can only be marked\n-                        // as red if the query result was recomputed and thus is\n-                        // already in memory.\n-                        None\n-                    }\n+    pub fn exec_cache_promotions(&self, tcx: TyCtxt<'_>) {\n+        let data = self.data.as_ref().unwrap();\n+        for prev_index in data.colors.values.indices() {\n+            match data.colors.get(prev_index) {\n+                Some(DepNodeColor::Green(_)) => {\n+                    let dep_node = data.previous.index_to_node(prev_index);\n+                    dep_node.try_load_from_on_disk_cache(tcx);\n                 }\n-            }).collect()\n-        };\n-\n-        for dep_node in green_nodes {\n-            dep_node.load_from_on_disk_cache(tcx);\n+                None |\n+                Some(DepNodeColor::Red) => {\n+                    // We can skip red nodes because a node can only be marked\n+                    // as red if the query result was recomputed and thus is\n+                    // already in memory.\n+                }\n+            }\n         }\n     }\n "}, {"sha": "9160b8024ee4512042f4c166e90600085af25d63", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -347,7 +347,7 @@ fn is_c_like_enum(item: &hir::Item) -> bool {\n     }\n }\n \n-fn check_mod_attrs<'tcx>(tcx: TyCtxt<'tcx>, module_def_id: DefId) {\n+fn check_mod_attrs(tcx: TyCtxt<'_>, module_def_id: DefId) {\n     tcx.hir().visit_item_likes_in_module(\n         module_def_id,\n         &mut CheckAttrVisitor { tcx }.as_deep_visitor()"}, {"sha": "ef05b57fb8f7dd7d23abe0889ddae10796107080", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -39,6 +39,7 @@ use crate::hir::map::{DefKey, DefPathData, Definitions};\n use crate::hir::def_id::{DefId, DefIndex, CRATE_DEF_INDEX};\n use crate::hir::def::{Res, DefKind, PartialRes, PerNS};\n use crate::hir::{GenericArg, ConstArg};\n+use crate::hir::ptr::P;\n use crate::lint::builtin::{self, PARENTHESIZED_PARAMS_IN_TYPES_AND_MODULES,\n                     ELIDED_LIFETIMES_IN_PATHS};\n use crate::middle::cstore::CrateStore;\n@@ -61,7 +62,6 @@ use syntax::ast::*;\n use syntax::errors;\n use syntax::ext::hygiene::{Mark, SyntaxContext};\n use syntax::print::pprust;\n-use syntax::ptr::P;\n use syntax::source_map::{self, respan, ExpnInfo, CompilerDesugaringKind, Spanned};\n use syntax::source_map::CompilerDesugaringKind::IfTemporary;\n use syntax::std_inject;\n@@ -1111,7 +1111,7 @@ impl<'a> LoweringContext<'a> {\n             },\n         );\n \n-        lowered_generics.params = lowered_generics\n+        let mut lowered_params: Vec<_> = lowered_generics\n             .params\n             .into_iter()\n             .chain(in_band_defs)\n@@ -1121,14 +1121,16 @@ impl<'a> LoweringContext<'a> {\n         // unsorted generic parameters at the moment, so we make sure\n         // that they're ordered correctly here for now. (When we chain\n         // the `in_band_defs`, we might make the order unsorted.)\n-        lowered_generics.params.sort_by_key(|param| {\n+        lowered_params.sort_by_key(|param| {\n             match param.kind {\n                 hir::GenericParamKind::Lifetime { .. } => ParamKindOrd::Lifetime,\n                 hir::GenericParamKind::Type { .. } => ParamKindOrd::Type,\n                 hir::GenericParamKind::Const { .. } => ParamKindOrd::Const,\n             }\n         });\n \n+        lowered_generics.params = lowered_params.into();\n+\n         (lowered_generics, res)\n     }\n \n@@ -1155,13 +1157,13 @@ impl<'a> LoweringContext<'a> {\n         &mut self,\n         capture_clause: CaptureBy,\n         closure_node_id: NodeId,\n-        ret_ty: Option<&Ty>,\n+        ret_ty: Option<syntax::ptr::P<Ty>>,\n         span: Span,\n         body: impl FnOnce(&mut LoweringContext<'_>) -> hir::Expr,\n     ) -> hir::ExprKind {\n         let capture_clause = self.lower_capture_clause(capture_clause);\n         let output = match ret_ty {\n-            Some(ty) => FunctionRetTy::Ty(P(ty.clone())),\n+            Some(ty) => FunctionRetTy::Ty(ty),\n             None => FunctionRetTy::Default(span),\n         };\n         let ast_decl = FnDecl {\n@@ -1278,8 +1280,8 @@ impl<'a> LoweringContext<'a> {\n         let was_in_loop_condition = self.is_in_loop_condition;\n         self.is_in_loop_condition = false;\n \n-        let catch_scopes = mem::replace(&mut self.catch_scopes, Vec::new());\n-        let loop_scopes = mem::replace(&mut self.loop_scopes, Vec::new());\n+        let catch_scopes = mem::take(&mut self.catch_scopes);\n+        let loop_scopes = mem::take(&mut self.loop_scopes);\n         let ret = f(self);\n         self.catch_scopes = catch_scopes;\n         self.loop_scopes = loop_scopes;\n@@ -2725,7 +2727,7 @@ impl<'a> LoweringContext<'a> {\n \n         // ::std::future::Future<future_params>\n         let future_path =\n-            self.std_path(span, &[sym::future, sym::Future], Some(future_params), false);\n+            P(self.std_path(span, &[sym::future, sym::Future], Some(future_params), false));\n \n         hir::GenericBound::Trait(\n             hir::PolyTraitRef {\n@@ -3094,7 +3096,7 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_trait_ref(&mut self, p: &TraitRef, itctx: ImplTraitContext<'_>) -> hir::TraitRef {\n         let path = match self.lower_qpath(p.ref_id, &None, &p.path, ParamMode::Explicit, itctx) {\n-            hir::QPath::Resolved(None, path) => path.and_then(|path| path),\n+            hir::QPath::Resolved(None, path) => path,\n             qpath => bug!(\"lower_trait_ref: unexpected QPath `{:?}`\", qpath),\n         };\n         hir::TraitRef {\n@@ -3620,7 +3622,7 @@ impl<'a> LoweringContext<'a> {\n                             hir::Item {\n                                 hir_id: new_id,\n                                 ident,\n-                                attrs: attrs.clone(),\n+                                attrs: attrs.into_iter().cloned().collect(),\n                                 node: item,\n                                 vis,\n                                 span,\n@@ -3705,7 +3707,7 @@ impl<'a> LoweringContext<'a> {\n                             hir::Item {\n                                 hir_id: new_hir_id,\n                                 ident,\n-                                attrs: attrs.clone(),\n+                                attrs: attrs.into_iter().cloned().collect(),\n                                 node: item,\n                                 vis,\n                                 span: use_tree.span,\n@@ -4567,7 +4569,7 @@ impl<'a> LoweringContext<'a> {\n                         // `|x: u8| future_from_generator(|| -> X { ... })`.\n                         let body_id = this.lower_fn_body(&outer_decl, |this| {\n                             let async_ret_ty = if let FunctionRetTy::Ty(ty) = &decl.output {\n-                                Some(&**ty)\n+                                Some(ty.clone())\n                             } else { None };\n                             let async_body = this.make_async_expr(\n                                 capture_clause, closure_id, async_ret_ty, body.span,\n@@ -5577,7 +5579,7 @@ impl<'a> LoweringContext<'a> {\n                         let principal = hir::PolyTraitRef {\n                             bound_generic_params: hir::HirVec::new(),\n                             trait_ref: hir::TraitRef {\n-                                path: path.and_then(|path| path),\n+                                path,\n                                 hir_ref_id: hir_id,\n                             },\n                             span,"}, {"sha": "891a1956bc971da7ecf4164cbec771ab3e59f3f6", "filename": "src/librustc/hir/map/hir_id_validator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -4,7 +4,7 @@ use crate::hir::itemlikevisit::ItemLikeVisitor;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::{Lock, ParallelIterator, par_iter};\n \n-pub fn check_crate<'hir>(hir_map: &hir::map::Map<'hir>) {\n+pub fn check_crate(hir_map: &hir::map::Map<'_>) {\n     hir_map.dep_graph.assert_ignored();\n \n     let errors = Lock::new(Vec::new());"}, {"sha": "037d04a5d8ed3a21d61655008f25290ae669df95", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -147,15 +147,15 @@ impl Forest {\n         }\n     }\n \n-    pub fn krate<'hir>(&'hir self) -> &'hir Crate {\n+    pub fn krate(&self) -> &Crate {\n         self.dep_graph.read(DepNode::new_no_params(DepKind::Krate));\n         &self.krate\n     }\n \n     /// This is used internally in the dependency tracking system.\n     /// Use the `krate` method to ensure your dependency on the\n     /// crate is tracked.\n-    pub fn untracked_krate<'hir>(&'hir self) -> &'hir Crate {\n+    pub fn untracked_krate(&self) -> &Crate {\n         &self.krate\n     }\n }\n@@ -1085,7 +1085,7 @@ impl<'a> NodesMatchingSuffix<'a> {\n         // If `id` itself is a mod named `m` with parent `p`, then\n         // returns `Some(id, m, p)`.  If `id` has no mod in its parent\n         // chain, then returns `None`.\n-        fn find_first_mod_parent<'a>(map: &'a Map<'_>, mut id: HirId) -> Option<(HirId, Name)> {\n+        fn find_first_mod_parent(map: &Map<'_>, mut id: HirId) -> Option<(HirId, Name)> {\n             loop {\n                 if let Node::Item(item) = map.find(id)? {\n                     if item_is_mod(&item) {"}, {"sha": "bfbd8398f99f33334470bd01fcbf1a0b99d3b77b", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -12,6 +12,7 @@ pub use self::UnsafeSource::*;\n \n use crate::hir::def::{Res, DefKind};\n use crate::hir::def_id::{DefId, DefIndex, LocalDefId, CRATE_DEF_INDEX};\n+use crate::hir::ptr::P;\n use crate::util::nodemap::{NodeMap, FxHashSet};\n use crate::mir::mono::Linkage;\n \n@@ -23,7 +24,6 @@ use syntax::ast::{self, CrateSugar, Ident, Name, NodeId, AsmDialect};\n use syntax::ast::{Attribute, Label, LitKind, StrStyle, FloatTy, IntTy, UintTy};\n use syntax::attr::{InlineAttr, OptimizeAttr};\n use syntax::ext::hygiene::SyntaxContext;\n-use syntax::ptr::P;\n use syntax::symbol::{Symbol, kw};\n use syntax::tokenstream::TokenStream;\n use syntax::util::parser::ExprPrecedence;\n@@ -63,6 +63,7 @@ pub mod lowering;\n pub mod map;\n pub mod pat_util;\n pub mod print;\n+pub mod ptr;\n pub mod upvars;\n \n /// Uniquely identifies a node in the HIR of the current crate. It is\n@@ -1979,13 +1980,15 @@ pub struct InlineAsmOutput {\n     pub span: Span,\n }\n \n+// NOTE(eddyb) This is used within MIR as well, so unlike the rest of the HIR,\n+// it needs to be `Clone` and use plain `Vec<T>` instead of `HirVec<T>`.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct InlineAsm {\n     pub asm: Symbol,\n     pub asm_str_style: StrStyle,\n-    pub outputs: HirVec<InlineAsmOutput>,\n-    pub inputs: HirVec<Symbol>,\n-    pub clobbers: HirVec<Symbol>,\n+    pub outputs: Vec<InlineAsmOutput>,\n+    pub inputs: Vec<Symbol>,\n+    pub clobbers: Vec<Symbol>,\n     pub volatile: bool,\n     pub alignstack: bool,\n     pub dialect: AsmDialect,\n@@ -2217,7 +2220,7 @@ pub enum UseKind {\n /// within the resolution map.\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct TraitRef {\n-    pub path: Path,\n+    pub path: P<Path>,\n     // Don't hash the ref_id. It is tracked via the thing it is used to access\n     #[stable_hasher(ignore)]\n     pub hir_ref_id: HirId,"}, {"sha": "3b33de1a1792636ac26e71dfb4be0cbed5909230", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -6,14 +6,14 @@ use syntax::parse::lexer::comments;\n use syntax::print::pp::{self, Breaks};\n use syntax::print::pp::Breaks::{Consistent, Inconsistent};\n use syntax::print::pprust::{self, PrintState};\n-use syntax::ptr::P;\n use syntax::symbol::kw;\n use syntax::util::parser::{self, AssocOp, Fixity};\n use syntax_pos::{self, BytePos, FileName};\n \n use crate::hir;\n use crate::hir::{PatKind, GenericBound, TraitBoundModifier, RangeEnd};\n use crate::hir::{GenericParam, GenericParamKind, GenericArg};\n+use crate::hir::ptr::P;\n \n use std::borrow::Cow;\n use std::cell::Cell;"}, {"sha": "3a87b36a1b43430486a7d2412f7a0f1d537d71c3", "filename": "src/librustc/hir/ptr.rs", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fhir%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fhir%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fptr.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -0,0 +1,141 @@\n+// HACK(eddyb) this is a copy of `syntax::ptr`, minus the mutation (the HIR is\n+// frozen anyway). The only reason for doing this instead of replacing `P<T>`\n+// with `Box<T>` in HIR, is that `&Box<[T]>` doesn't implement `IntoIterator`.\n+\n+use std::fmt::{self, Display, Debug};\n+use std::iter::FromIterator;\n+use std::ops::Deref;\n+use std::{slice, vec};\n+\n+use serialize::{Encodable, Decodable, Encoder, Decoder};\n+\n+use rustc_data_structures::stable_hasher::{StableHasher, StableHasherResult,\n+                                           HashStable};\n+/// An owned smart pointer.\n+#[derive(Hash, PartialEq, Eq)]\n+pub struct P<T: ?Sized> {\n+    ptr: Box<T>\n+}\n+\n+/// Construct a `P<T>` from a `T` value.\n+#[allow(non_snake_case)]\n+pub fn P<T: 'static>(value: T) -> P<T> {\n+    P {\n+        ptr: box value\n+    }\n+}\n+\n+impl<T: 'static> P<T> {\n+    // HACK(eddyb) used by HIR lowering in a few places still.\n+    // NOTE: do not make this more public than `pub(super)`.\n+    pub(super) fn into_inner(self) -> T {\n+        *self.ptr\n+    }\n+}\n+\n+impl<T: ?Sized> Deref for P<T> {\n+    type Target = T;\n+\n+    fn deref(&self) -> &T {\n+        &self.ptr\n+    }\n+}\n+\n+impl<T: ?Sized + Debug> Debug for P<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        Debug::fmt(&self.ptr, f)\n+    }\n+}\n+\n+impl<T: Display> Display for P<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        Display::fmt(&**self, f)\n+    }\n+}\n+\n+impl<T: 'static + Decodable> Decodable for P<T> {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<P<T>, D::Error> {\n+        Decodable::decode(d).map(P)\n+    }\n+}\n+\n+impl<T: Encodable> Encodable for P<T> {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        (**self).encode(s)\n+    }\n+}\n+\n+impl<T> P<[T]> {\n+    pub const fn new() -> P<[T]> {\n+        // HACK(eddyb) bypass the lack of a `const fn` to create an empty `Box<[T]>`\n+        // (as trait methods, `default` in this case, can't be `const fn` yet).\n+        P {\n+            ptr: unsafe {\n+                use std::ptr::NonNull;\n+                std::mem::transmute(NonNull::<[T; 0]>::dangling() as NonNull<[T]>)\n+            },\n+        }\n+    }\n+\n+    #[inline(never)]\n+    pub fn from_vec(v: Vec<T>) -> P<[T]> {\n+        P { ptr: v.into_boxed_slice() }\n+    }\n+\n+    // HACK(eddyb) used by HIR lowering in a few places still.\n+    // NOTE: do not make this more public than `pub(super)`,\n+    // and do not make this into an `IntoIterator` impl.\n+    pub(super) fn into_iter(self) -> vec::IntoIter<T> {\n+        self.ptr.into_vec().into_iter()\n+    }\n+}\n+\n+\n+impl<T> Default for P<[T]> {\n+    /// Creates an empty `P<[T]>`.\n+    fn default() -> P<[T]> {\n+        P::new()\n+    }\n+}\n+\n+impl<T> From<Vec<T>> for P<[T]> {\n+    fn from(v: Vec<T>) -> Self {\n+        P::from_vec(v)\n+    }\n+}\n+\n+impl<T> FromIterator<T> for P<[T]> {\n+    fn from_iter<I: IntoIterator<Item=T>>(iter: I) -> P<[T]> {\n+        P::from_vec(iter.into_iter().collect())\n+    }\n+}\n+\n+impl<'a, T> IntoIterator for &'a P<[T]> {\n+    type Item = &'a T;\n+    type IntoIter = slice::Iter<'a, T>;\n+    fn into_iter(self) -> Self::IntoIter {\n+        self.ptr.into_iter()\n+    }\n+}\n+\n+impl<T: Encodable> Encodable for P<[T]> {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        Encodable::encode(&**self, s)\n+    }\n+}\n+\n+impl<T: Decodable> Decodable for P<[T]> {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<P<[T]>, D::Error> {\n+        Ok(P::from_vec(Decodable::decode(d)?))\n+    }\n+}\n+\n+impl<CTX, T> HashStable<CTX> for P<T>\n+    where T: ?Sized + HashStable<CTX>\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        (**self).hash_stable(hcx, hasher);\n+    }\n+}"}, {"sha": "b508f91e01ebb22905053676a4c7ba5a33419547", "filename": "src/librustc/infer/canonical/mod.rs", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -23,6 +23,7 @@\n \n use crate::infer::{InferCtxt, RegionVariableOrigin, TypeVariableOrigin, TypeVariableOriginKind};\n use crate::infer::{ConstVariableOrigin, ConstVariableOriginKind};\n+use crate::infer::region_constraints::MemberConstraint;\n use crate::mir::interpret::ConstValue;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_macros::HashStable;\n@@ -189,11 +190,25 @@ pub enum CanonicalTyVarKind {\n #[derive(Clone, Debug, HashStable)]\n pub struct QueryResponse<'tcx, R> {\n     pub var_values: CanonicalVarValues<'tcx>,\n-    pub region_constraints: Vec<QueryRegionConstraint<'tcx>>,\n+    pub region_constraints: QueryRegionConstraints<'tcx>,\n     pub certainty: Certainty,\n     pub value: R,\n }\n \n+#[derive(Clone, Debug, Default, HashStable)]\n+pub struct QueryRegionConstraints<'tcx> {\n+    pub outlives: Vec<QueryOutlivesConstraint<'tcx>>,\n+    pub member_constraints: Vec<MemberConstraint<'tcx>>,\n+}\n+\n+impl QueryRegionConstraints<'_> {\n+    /// Represents an empty (trivially true) set of region\n+    /// constraints.\n+    pub fn is_empty(&self) -> bool {\n+        self.outlives.is_empty() && self.member_constraints.is_empty()\n+    }\n+}\n+\n pub type Canonicalized<'tcx, V> = Canonical<'tcx, V>;\n \n pub type CanonicalizedQueryResponse<'tcx, T> =\n@@ -292,7 +307,8 @@ impl<'tcx, V> Canonical<'tcx, V> {\n     }\n }\n \n-pub type QueryRegionConstraint<'tcx> = ty::Binder<ty::OutlivesPredicate<Kind<'tcx>, Region<'tcx>>>;\n+pub type QueryOutlivesConstraint<'tcx> =\n+    ty::Binder<ty::OutlivesPredicate<Kind<'tcx>, Region<'tcx>>>;\n \n impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     /// Creates a substitution S for the canonical value with fresh\n@@ -540,6 +556,19 @@ BraceStructLiftImpl! {\n     } where R: Lift<'tcx>\n }\n \n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for QueryRegionConstraints<'tcx> {\n+        outlives, member_constraints\n+    }\n+}\n+\n+BraceStructLiftImpl! {\n+    impl<'a, 'tcx> Lift<'tcx> for QueryRegionConstraints<'a> {\n+        type Lifted = QueryRegionConstraints<'tcx>;\n+        outlives, member_constraints\n+    }\n+}\n+\n impl<'tcx> Index<BoundVar> for CanonicalVarValues<'tcx> {\n     type Output = Kind<'tcx>;\n "}, {"sha": "79c5538626be191f80eba1c5671db8b8f56892fd", "filename": "src/librustc/infer/canonical/query_response.rs", "status": "modified", "additions": 28, "deletions": 18, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -11,7 +11,7 @@ use crate::arena::ArenaAllocatable;\n use crate::infer::canonical::substitute::substitute_value;\n use crate::infer::canonical::{\n     Canonical, CanonicalVarValues, CanonicalizedQueryResponse, Certainty,\n-    OriginalQueryValues, QueryRegionConstraint, QueryResponse,\n+    OriginalQueryValues, QueryRegionConstraints, QueryOutlivesConstraint, QueryResponse,\n };\n use crate::infer::region_constraints::{Constraint, RegionConstraintData};\n use crate::infer::InferCtxtBuilder;\n@@ -132,7 +132,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     {\n         self.canonicalize_response(&QueryResponse {\n             var_values: inference_vars,\n-            region_constraints: vec![],\n+            region_constraints: QueryRegionConstraints::default(),\n             certainty: Certainty::Proven, // Ambiguities are OK!\n             value: answer,\n         })\n@@ -174,7 +174,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n \n         let region_obligations = self.take_registered_region_obligations();\n         let region_constraints = self.with_region_constraints(|region_constraints| {\n-            make_query_outlives(\n+            make_query_region_constraints(\n                 tcx,\n                 region_obligations\n                     .iter()\n@@ -222,10 +222,10 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n             mut obligations,\n         } = self.query_response_substitution(cause, param_env, original_values, query_response)?;\n \n-        obligations.extend(self.query_region_constraints_into_obligations(\n+        obligations.extend(self.query_outlives_constraints_into_obligations(\n             cause,\n             param_env,\n-            &query_response.value.region_constraints,\n+            &query_response.value.region_constraints.outlives,\n             &result_subst,\n         ));\n \n@@ -248,9 +248,9 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     /// that come out of these queries, which it wants to convert into\n     /// MIR-based constraints and solve. Therefore, it is most\n     /// convenient for the NLL Type Checker to **directly consume**\n-    /// the `QueryRegionConstraint` values that arise from doing a\n+    /// the `QueryOutlivesConstraint` values that arise from doing a\n     /// query. This is contrast to other parts of the compiler, which\n-    /// would prefer for those `QueryRegionConstraint` to be converted\n+    /// would prefer for those `QueryOutlivesConstraint` to be converted\n     /// into the older infcx-style constraints (e.g., calls to\n     /// `sub_regions` or `register_region_obligation`).\n     ///\n@@ -263,7 +263,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     ///   result. If any errors arise, they are propagated back as an\n     ///   `Err` result.\n     /// - In the case of a successful substitution, we will append\n-    ///   `QueryRegionConstraint` values onto the\n+    ///   `QueryOutlivesConstraint` values onto the\n     ///   `output_query_region_constraints` vector for the solver to\n     ///   use (if an error arises, some values may also be pushed, but\n     ///   they should be ignored).\n@@ -279,15 +279,15 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n         original_values: &OriginalQueryValues<'tcx>,\n         query_response: &Canonical<'tcx, QueryResponse<'tcx, R>>,\n-        output_query_region_constraints: &mut Vec<QueryRegionConstraint<'tcx>>,\n+        output_query_region_constraints: &mut QueryRegionConstraints<'tcx>,\n     ) -> InferResult<'tcx, R>\n     where\n         R: Debug + TypeFoldable<'tcx>,\n     {\n         let result_subst =\n             self.query_response_substitution_guess(cause, original_values, query_response);\n \n-        // Compute `QueryRegionConstraint` values that unify each of\n+        // Compute `QueryOutlivesConstraint` values that unify each of\n         // the original values `v_o` that was canonicalized into a\n         // variable...\n         let mut obligations = vec![];\n@@ -306,8 +306,10 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n                     // To make `v_o = v_r`, we emit `v_o: v_r` and `v_r: v_o`.\n                     if v_o != v_r {\n                         output_query_region_constraints\n+                            .outlives\n                             .push(ty::Binder::dummy(ty::OutlivesPredicate(v_o.into(), v_r)));\n                         output_query_region_constraints\n+                            .outlives\n                             .push(ty::Binder::dummy(ty::OutlivesPredicate(v_r.into(), v_o)));\n                     }\n                 }\n@@ -333,12 +335,12 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         }\n \n         // ...also include the other query region constraints from the query.\n-        output_query_region_constraints.extend(\n-            query_response.value.region_constraints.iter().filter_map(|r_c| {\n+        output_query_region_constraints.outlives.extend(\n+            query_response.value.region_constraints.outlives.iter().filter_map(|r_c| {\n                 let r_c = substitute_value(self.tcx, &result_subst, r_c);\n \n                 // Screen out `'a: 'a` cases -- we skip the binder here but\n-                // only care the inner values to one another, so they are still at\n+                // only compare the inner values to one another, so they are still at\n                 // consistent binding levels.\n                 let &ty::OutlivesPredicate(k1, r2) = r_c.skip_binder();\n                 if k1 != r2.into() {\n@@ -349,6 +351,13 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n             })\n         );\n \n+        // ...also include the query member constraints.\n+        output_query_region_constraints.member_constraints.extend(\n+            query_response.value.region_constraints.member_constraints.iter().map(|p_c| {\n+                substitute_value(self.tcx, &result_subst, p_c)\n+            })\n+        );\n+\n         let user_result: R =\n             query_response.substitute_projected(self.tcx, &result_subst, |q_r| &q_r.value);\n \n@@ -560,11 +569,11 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n \n     /// Converts the region constraints resulting from a query into an\n     /// iterator of obligations.\n-    fn query_region_constraints_into_obligations<'a>(\n+    fn query_outlives_constraints_into_obligations<'a>(\n         &'a self,\n         cause: &'a ObligationCause<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n-        unsubstituted_region_constraints: &'a [QueryRegionConstraint<'tcx>],\n+        unsubstituted_region_constraints: &'a [QueryOutlivesConstraint<'tcx>],\n         result_subst: &'a CanonicalVarValues<'tcx>,\n     ) -> impl Iterator<Item = PredicateObligation<'tcx>> + 'a + Captures<'tcx> {\n         unsubstituted_region_constraints\n@@ -645,15 +654,16 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n \n /// Given the region obligations and constraints scraped from the infcx,\n /// creates query region constraints.\n-pub fn make_query_outlives<'tcx>(\n+pub fn make_query_region_constraints<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     outlives_obligations: impl Iterator<Item = (Ty<'tcx>, ty::Region<'tcx>)>,\n     region_constraints: &RegionConstraintData<'tcx>,\n-) -> Vec<QueryRegionConstraint<'tcx>> {\n+) -> QueryRegionConstraints<'tcx> {\n     let RegionConstraintData {\n         constraints,\n         verifys,\n         givens,\n+        member_constraints,\n     } = region_constraints;\n \n     assert!(verifys.is_empty());\n@@ -684,5 +694,5 @@ pub fn make_query_outlives<'tcx>(\n         )\n         .collect();\n \n-    outlives\n+    QueryRegionConstraints { outlives, member_constraints: member_constraints.clone() }\n }"}, {"sha": "cbfb048c064a2c2e4d3b91d72c632bf1cfb9f402", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -53,6 +53,7 @@ use crate::infer::{self, SuppressRegionErrors};\n use crate::hir;\n use crate::hir::def_id::DefId;\n use crate::hir::Node;\n+use crate::infer::opaque_types;\n use crate::middle::region;\n use crate::traits::{ObligationCause, ObligationCauseCode};\n use crate::ty::error::TypeError;\n@@ -375,6 +376,23 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                             );\n                         }\n                     }\n+\n+                    RegionResolutionError::MemberConstraintFailure {\n+                        opaque_type_def_id,\n+                        hidden_ty,\n+                        member_region,\n+                        span: _,\n+                        choice_regions: _,\n+                    } => {\n+                        let hidden_ty = self.resolve_vars_if_possible(&hidden_ty);\n+                        opaque_types::unexpected_hidden_region_diagnostic(\n+                            self.tcx,\n+                            Some(region_scope_tree),\n+                            opaque_type_def_id,\n+                            hidden_ty,\n+                            member_region,\n+                        ).emit();\n+                    }\n                 }\n             }\n         }\n@@ -411,7 +429,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let is_bound_failure = |e: &RegionResolutionError<'tcx>| match *e {\n             RegionResolutionError::GenericBoundFailure(..) => true,\n             RegionResolutionError::ConcreteFailure(..)\n-            | RegionResolutionError::SubSupConflict(..) => false,\n+                | RegionResolutionError::SubSupConflict(..)\n+                | RegionResolutionError::MemberConstraintFailure { .. } => false,\n         };\n \n         let mut errors = if errors.iter().all(|e| is_bound_failure(e)) {\n@@ -429,6 +448,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             RegionResolutionError::ConcreteFailure(ref sro, _, _) => sro.span(),\n             RegionResolutionError::GenericBoundFailure(ref sro, _, _) => sro.span(),\n             RegionResolutionError::SubSupConflict(_, ref rvo, _, _, _, _) => rvo.span(),\n+            RegionResolutionError::MemberConstraintFailure { span, .. } => span,\n         });\n         errors\n     }"}, {"sha": "d06c4434b3aaf8d4a1b5c9eb003ce63e188dd97c", "filename": "src/librustc/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 238, "deletions": 103, "changes": 341, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -1,26 +1,28 @@\n //! Lexical region resolution.\n \n+use crate::hir::def_id::DefId;\n use crate::infer::region_constraints::Constraint;\n use crate::infer::region_constraints::GenericKind;\n+use crate::infer::region_constraints::MemberConstraint;\n use crate::infer::region_constraints::RegionConstraintData;\n use crate::infer::region_constraints::VarInfos;\n use crate::infer::region_constraints::VerifyBound;\n use crate::infer::RegionVariableOrigin;\n use crate::infer::SubregionOrigin;\n use crate::middle::free_region::RegionRelations;\n+use crate::ty::fold::TypeFoldable;\n+use crate::ty::{self, Ty, TyCtxt};\n+use crate::ty::{ReEarlyBound, ReEmpty, ReErased, ReFree, ReStatic};\n+use crate::ty::{ReLateBound, RePlaceholder, ReScope, ReVar};\n+use crate::ty::{Region, RegionVid};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::graph::implementation::{\n     Direction, Graph, NodeIndex, INCOMING, OUTGOING,\n };\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use smallvec::SmallVec;\n use std::fmt;\n-use std::u32;\n-use crate::ty::fold::TypeFoldable;\n-use crate::ty::{self, Ty, TyCtxt};\n-use crate::ty::{ReEarlyBound, ReEmpty, ReErased, ReFree, ReStatic};\n-use crate::ty::{ReLateBound, ReScope, RePlaceholder, ReVar};\n-use crate::ty::{Region, RegionVid};\n+use syntax_pos::Span;\n \n mod graphviz;\n \n@@ -36,11 +38,7 @@ pub fn resolve<'tcx>(\n ) -> (LexicalRegionResolutions<'tcx>, Vec<RegionResolutionError<'tcx>>) {\n     debug!(\"RegionConstraintData: resolve_regions()\");\n     let mut errors = vec![];\n-    let mut resolver = LexicalResolver {\n-        region_rels,\n-        var_infos,\n-        data,\n-    };\n+    let mut resolver = LexicalResolver { region_rels, var_infos, data };\n     let values = resolver.infer_variable_values(&mut errors);\n     (values, errors)\n }\n@@ -84,6 +82,17 @@ pub enum RegionResolutionError<'tcx> {\n         SubregionOrigin<'tcx>,\n         Region<'tcx>,\n     ),\n+\n+    /// Indicates a failure of a `MemberConstraint`. These arise during\n+    /// impl trait processing explicitly -- basically, the impl trait's hidden type\n+    /// included some region that it was not supposed to.\n+    MemberConstraintFailure {\n+        span: Span,\n+        opaque_type_def_id: DefId,\n+        hidden_ty: Ty<'tcx>,\n+        member_region: Region<'tcx>,\n+        choice_regions: Vec<Region<'tcx>>,\n+    },\n }\n \n struct RegionAndOrigin<'tcx> {\n@@ -121,7 +130,12 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n \n         let graph = self.construct_graph();\n         self.expand_givens(&graph);\n-        self.expansion(&mut var_data);\n+        loop {\n+            self.expansion(&mut var_data);\n+            if !self.enforce_member_constraints(&graph, &mut var_data) {\n+                break;\n+            }\n+        }\n         self.collect_errors(&mut var_data, errors);\n         self.collect_var_errors(&var_data, &graph, errors);\n         var_data\n@@ -136,7 +150,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n     fn construct_var_data(&self, tcx: TyCtxt<'tcx>) -> LexicalRegionResolutions<'tcx> {\n         LexicalRegionResolutions {\n             error_region: tcx.lifetimes.re_static,\n-            values: IndexVec::from_elem_n(VarValue::Value(tcx.lifetimes.re_empty), self.num_vars())\n+            values: IndexVec::from_elem_n(VarValue::Value(tcx.lifetimes.re_empty), self.num_vars()),\n         }\n     }\n \n@@ -182,6 +196,113 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         }\n     }\n \n+    /// Enforce all member constraints and return true if anything\n+    /// changed. See `enforce_member_constraint` for more details.\n+    fn enforce_member_constraints(\n+        &self,\n+        graph: &RegionGraph<'tcx>,\n+        var_values: &mut LexicalRegionResolutions<'tcx>,\n+    ) -> bool {\n+        // Note: we don't use the `any` combinator because we don't\n+        // want to stop at the first constraint that makes a change.\n+        let mut any_changed = false;\n+        for member_constraint in &self.data.member_constraints {\n+            if self.enforce_member_constraint(graph, member_constraint, var_values) {\n+                any_changed = true;\n+            }\n+        }\n+        any_changed\n+    }\n+\n+    /// Enforce a constraint like\n+    ///\n+    /// ```\n+    /// 'r member of ['c...]\n+    /// ```\n+    ///\n+    /// We look for all choice regions from the list `'c...` that:\n+    ///\n+    /// (a) are greater than the current value of `'r` (which is a lower bound)\n+    ///\n+    /// and\n+    ///\n+    /// (b) are compatible with the upper bounds of `'r` that we can\n+    /// find by traversing the graph.\n+    ///\n+    /// From that list, we look for a *minimal* option `'c_min`. If we\n+    /// find one, then we can enforce that `'r: 'c_min`.\n+    fn enforce_member_constraint(\n+        &self,\n+        graph: &RegionGraph<'tcx>,\n+        member_constraint: &MemberConstraint<'tcx>,\n+        var_values: &mut LexicalRegionResolutions<'tcx>,\n+    ) -> bool {\n+        debug!(\"enforce_member_constraint(member_constraint={:#?})\", member_constraint);\n+\n+        // The constraint is some inference variable (`vid`) which\n+        // must be equal to one of the options.\n+        let member_vid = match member_constraint.member_region {\n+            ty::ReVar(vid) => *vid,\n+            _ => return false,\n+        };\n+\n+        // The current value of `vid` is a lower bound LB -- i.e., we\n+        // know that `LB <= vid` must be true.\n+        let member_lower_bound: ty::Region<'tcx> = match var_values.value(member_vid) {\n+            VarValue::ErrorValue => return false,\n+            VarValue::Value(r) => r,\n+        };\n+\n+        // Find all the \"upper bounds\" -- that is, each region `b` such that\n+        // `r0 <= b` must hold.\n+        let (member_upper_bounds, _) = self.collect_concrete_regions(\n+            graph,\n+            member_vid,\n+            OUTGOING,\n+            None,\n+        );\n+\n+        // Get an iterator over the *available choice* -- that is,\n+        // each choice region `c` where `lb <= c` and `c <= ub` for all the\n+        // upper bounds `ub`.\n+        debug!(\"enforce_member_constraint: upper_bounds={:#?}\", member_upper_bounds);\n+        let mut options = member_constraint.choice_regions.iter().filter(|option| {\n+            self.sub_concrete_regions(member_lower_bound, option)\n+                && member_upper_bounds\n+                    .iter()\n+                    .all(|upper_bound| self.sub_concrete_regions(option, upper_bound.region))\n+        });\n+\n+        // If there is more than one option, we only make a choice if\n+        // there is a single *least* choice -- i.e., some available\n+        // region that is `<=` all the others.\n+        let mut least_choice: ty::Region<'tcx> = match options.next() {\n+            Some(&r) => r,\n+            None => return false,\n+        };\n+        debug!(\"enforce_member_constraint: least_choice={:?}\", least_choice);\n+        for &option in options {\n+            debug!(\"enforce_member_constraint: option={:?}\", option);\n+            if !self.sub_concrete_regions(least_choice, option) {\n+                if self.sub_concrete_regions(option, least_choice) {\n+                    debug!(\"enforce_member_constraint: new least choice\");\n+                    least_choice = option;\n+                } else {\n+                    debug!(\"enforce_member_constraint: no least choice\");\n+                    return false;\n+                }\n+            }\n+        }\n+\n+        debug!(\"enforce_member_constraint: final least choice = {:?}\", least_choice);\n+        if least_choice != member_lower_bound {\n+            *var_values.value_mut(member_vid) = VarValue::Value(least_choice);\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n     fn expansion(&self, var_values: &mut LexicalRegionResolutions<'tcx>) {\n         self.iterate_until_fixed_point(\"Expansion\", |constraint| {\n             debug!(\"expansion: constraint={:?}\", constraint);\n@@ -196,15 +317,15 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                         let b_data = var_values.value_mut(b_vid);\n                         let retain = match *b_data {\n                             VarValue::Value(ReStatic) | VarValue::ErrorValue => false,\n-                            _ => true\n+                            _ => true,\n                         };\n                         (a_region, b_vid, b_data, retain)\n                     }\n                 },\n                 Constraint::RegSubReg(..) | Constraint::VarSubReg(..) => {\n                     // These constraints are checked after expansion\n                     // is done, in `collect_errors`.\n-                    return (false, false)\n+                    return (false, false);\n                 }\n             };\n \n@@ -226,16 +347,16 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n \n         match *a_region {\n             // Check if this relationship is implied by a given.\n-            ty::ReEarlyBound(_) | ty::ReFree(_) => if self.data.givens.contains(&(a_region, b_vid))\n-            {\n-                debug!(\"given\");\n-                return false;\n-            },\n+            ty::ReEarlyBound(_) | ty::ReFree(_) => {\n+                if self.data.givens.contains(&(a_region, b_vid)) {\n+                    debug!(\"given\");\n+                    return false;\n+                }\n+            }\n \n             _ => {}\n         }\n \n-\n         match *b_data {\n             VarValue::Value(cur_region) => {\n                 // Identical scopes can show up quite often, if the fixed point\n@@ -267,10 +388,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                     }\n                 }\n \n-                debug!(\n-                    \"Expanding value of {:?} from {:?} to {:?}\",\n-                    b_vid, cur_region, lub\n-                );\n+                debug!(\"Expanding value of {:?} from {:?} to {:?}\", b_vid, cur_region, lub);\n \n                 *b_data = VarValue::Value(lub);\n                 return true;\n@@ -282,6 +400,12 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         }\n     }\n \n+    /// True if `a <= b`, but not defined over inference variables.\n+    fn sub_concrete_regions(&self, a: Region<'tcx>, b: Region<'tcx>) -> bool {\n+        self.lub_concrete_regions(a, b) == b\n+    }\n+\n+    /// Returns the smallest region `c` such that `a <= c` and `b <= c`.\n     fn lub_concrete_regions(&self, a: Region<'tcx>, b: Region<'tcx>) -> Region<'tcx> {\n         let tcx = self.tcx();\n \n@@ -321,17 +445,16 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                 // at least as big as fr.scope\".  So, we can\n                 // reasonably compare free regions and scopes:\n                 let fr_scope = match (a, b) {\n-                    (&ReEarlyBound(ref br), _) | (_, &ReEarlyBound(ref br)) => self.region_rels\n-                        .region_scope_tree\n-                        .early_free_scope(self.tcx(), br),\n-                    (&ReFree(ref fr), _) | (_, &ReFree(ref fr)) => self.region_rels\n-                        .region_scope_tree\n-                        .free_scope(self.tcx(), fr),\n+                    (&ReEarlyBound(ref br), _) | (_, &ReEarlyBound(ref br)) => {\n+                        self.region_rels.region_scope_tree.early_free_scope(self.tcx(), br)\n+                    }\n+                    (&ReFree(ref fr), _) | (_, &ReFree(ref fr)) => {\n+                        self.region_rels.region_scope_tree.free_scope(self.tcx(), fr)\n+                    }\n                     _ => bug!(),\n                 };\n-                let r_id = self.region_rels\n-                    .region_scope_tree\n-                    .nearest_common_ancestor(fr_scope, s_id);\n+                let r_id =\n+                    self.region_rels.region_scope_tree.nearest_common_ancestor(fr_scope, s_id);\n                 if r_id == fr_scope {\n                     // if the free region's scope `fr.scope` is bigger than\n                     // the scope region `s_id`, then the LUB is the free\n@@ -352,9 +475,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                 // The region corresponding to an outer block is a\n                 // subtype of the region corresponding to an inner\n                 // block.\n-                let lub = self.region_rels\n-                    .region_scope_tree\n-                    .nearest_common_ancestor(a_id, b_id);\n+                let lub = self.region_rels.region_scope_tree.nearest_common_ancestor(a_id, b_id);\n                 tcx.mk_region(ReScope(lub))\n             }\n \n@@ -365,11 +486,13 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n \n             // For these types, we cannot define any additional\n             // relationship:\n-            (&RePlaceholder(..), _) | (_, &RePlaceholder(..)) => if a == b {\n-                a\n-            } else {\n-                tcx.lifetimes.re_static\n-            },\n+            (&RePlaceholder(..), _) | (_, &RePlaceholder(..)) => {\n+                if a == b {\n+                    a\n+                } else {\n+                    tcx.lifetimes.re_static\n+                }\n+            }\n         }\n     }\n \n@@ -382,10 +505,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         errors: &mut Vec<RegionResolutionError<'tcx>>,\n     ) {\n         for (constraint, origin) in &self.data.constraints {\n-            debug!(\n-                \"collect_errors: constraint={:?} origin={:?}\",\n-                constraint, origin\n-            );\n+            debug!(\"collect_errors: constraint={:?} origin={:?}\", constraint, origin);\n             match *constraint {\n                 Constraint::RegSubVar(..) | Constraint::VarSubVar(..) => {\n                     // Expansion will ensure that these constraints hold. Ignore.\n@@ -433,6 +553,25 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n             }\n         }\n \n+        // Check that all member constraints are satisfied.\n+        for member_constraint in &self.data.member_constraints {\n+            let member_region = var_data.normalize(self.tcx(), member_constraint.member_region);\n+            let choice_regions = member_constraint\n+                .choice_regions\n+                .iter()\n+                .map(|&choice_region| var_data.normalize(self.tcx(), choice_region));\n+            if !choice_regions.clone().any(|choice_region| member_region == choice_region) {\n+                let span = self.tcx().def_span(member_constraint.opaque_type_def_id);\n+                errors.push(RegionResolutionError::MemberConstraintFailure {\n+                    span,\n+                    opaque_type_def_id: member_constraint.opaque_type_def_id,\n+                    hidden_ty: member_constraint.hidden_ty,\n+                    member_region,\n+                    choice_regions: choice_regions.collect(),\n+                });\n+            }\n+        }\n+\n         for verify in &self.data.verifys {\n             debug!(\"collect_errors: verify={:?}\", verify);\n             let sub = var_data.normalize(self.tcx(), verify.region);\n@@ -483,34 +622,35 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         // idea is to report errors that derive from independent\n         // regions of the graph, but not those that derive from\n         // overlapping locations.\n-        let mut dup_vec = vec![u32::MAX; self.num_vars()];\n+        let mut dup_vec = IndexVec::from_elem_n(None, self.num_vars());\n \n         for (node_vid, value) in var_data.values.iter_enumerated() {\n             match *value {\n                 VarValue::Value(_) => { /* Inference successful */ }\n                 VarValue::ErrorValue => {\n-                    /* Inference impossible: this value contains\n-                       inconsistent constraints.\n-\n-                       I think that in this case we should report an\n-                       error now -- unlike the case above, we can't\n-                       wait to see whether the user needs the result\n-                       of this variable. The reason is that the mere\n-                       existence of this variable implies that the\n-                       region graph is inconsistent, whether or not it\n-                       is used.\n-\n-                       For example, we may have created a region\n-                       variable that is the GLB of two other regions\n-                       which do not have a GLB. Even if that variable\n-                       is not used, it implies that those two regions\n-                       *should* have a GLB.\n-\n-                       At least I think this is true. It may be that\n-                       the mere existence of a conflict in a region variable\n-                       that is not used is not a problem, so if this rule\n-                       starts to create problems we'll have to revisit\n-                       this portion of the code and think hard about it. =) */\n+                    // Inference impossible: this value contains\n+                    // inconsistent constraints.\n+                    //\n+                    // I think that in this case we should report an\n+                    // error now -- unlike the case above, we can't\n+                    // wait to see whether the user needs the result\n+                    // of this variable. The reason is that the mere\n+                    // existence of this variable implies that the\n+                    // region graph is inconsistent, whether or not it\n+                    // is used.\n+                    //\n+                    // For example, we may have created a region\n+                    // variable that is the GLB of two other regions\n+                    // which do not have a GLB. Even if that variable\n+                    // is not used, it implies that those two regions\n+                    // *should* have a GLB.\n+                    //\n+                    // At least I think this is true. It may be that\n+                    // the mere existence of a conflict in a region\n+                    // variable that is not used is not a problem, so\n+                    // if this rule starts to create problems we'll\n+                    // have to revisit this portion of the code and\n+                    // think hard about it. =) -- nikomatsakis\n                     self.collect_error_for_expanding_node(graph, &mut dup_vec, node_vid, errors);\n                 }\n             }\n@@ -562,16 +702,16 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n     fn collect_error_for_expanding_node(\n         &self,\n         graph: &RegionGraph<'tcx>,\n-        dup_vec: &mut [u32],\n+        dup_vec: &mut IndexVec<RegionVid, Option<RegionVid>>,\n         node_idx: RegionVid,\n         errors: &mut Vec<RegionResolutionError<'tcx>>,\n     ) {\n         // Errors in expanding nodes result from a lower-bound that is\n         // not contained by an upper-bound.\n         let (mut lower_bounds, lower_dup) =\n-            self.collect_concrete_regions(graph, node_idx, INCOMING, dup_vec);\n+            self.collect_concrete_regions(graph, node_idx, INCOMING, Some(dup_vec));\n         let (mut upper_bounds, upper_dup) =\n-            self.collect_concrete_regions(graph, node_idx, OUTGOING, dup_vec);\n+            self.collect_concrete_regions(graph, node_idx, OUTGOING, Some(dup_vec));\n \n         if lower_dup || upper_dup {\n             return;\n@@ -604,9 +744,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n             };\n \n             for upper_bound in &upper_bounds {\n-                if !self.region_rels\n-                    .is_subregion_of(effective_lower_bound, upper_bound.region)\n-                {\n+                if !self.region_rels.is_subregion_of(effective_lower_bound, upper_bound.region) {\n                     let origin = self.var_infos[node_idx].origin.clone();\n                     debug!(\n                         \"region inference error at {:?} for {:?}: SubSupConflict sub: {:?} \\\n@@ -643,7 +781,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         graph: &RegionGraph<'tcx>,\n         orig_node_idx: RegionVid,\n         dir: Direction,\n-        dup_vec: &mut [u32],\n+        mut dup_vec: Option<&mut IndexVec<RegionVid, Option<RegionVid>>>,\n     ) -> (Vec<RegionAndOrigin<'tcx>>, bool) {\n         struct WalkState<'tcx> {\n             set: FxHashSet<RegionVid>,\n@@ -667,23 +805,23 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n             let node_idx = state.stack.pop().unwrap();\n \n             // check whether we've visited this node on some previous walk\n-            if dup_vec[node_idx.index() as usize] == u32::MAX {\n-                dup_vec[node_idx.index() as usize] = orig_node_idx.index() as u32;\n-            } else if dup_vec[node_idx.index() as usize] != orig_node_idx.index() as u32 {\n-                state.dup_found = true;\n-            }\n+            if let Some(dup_vec) = &mut dup_vec {\n+                if dup_vec[node_idx].is_none() {\n+                    dup_vec[node_idx] = Some(orig_node_idx);\n+                } else if dup_vec[node_idx] != Some(orig_node_idx) {\n+                    state.dup_found = true;\n+                }\n \n-            debug!(\n-                \"collect_concrete_regions(orig_node_idx={:?}, node_idx={:?})\",\n-                orig_node_idx, node_idx\n-            );\n+                debug!(\n+                    \"collect_concrete_regions(orig_node_idx={:?}, node_idx={:?})\",\n+                    orig_node_idx, node_idx\n+                );\n+            }\n \n             process_edges(&self.data, &mut state, graph, node_idx, dir);\n         }\n \n-        let WalkState {\n-            result, dup_found, ..\n-        } = state;\n+        let WalkState { result, dup_found, .. } = state;\n         return (result, dup_found);\n \n         fn process_edges<'tcx>(\n@@ -699,11 +837,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n             for (_, edge) in graph.adjacent_edges(source_node_index, dir) {\n                 match edge.data {\n                     Constraint::VarSubVar(from_vid, to_vid) => {\n-                        let opp_vid = if from_vid == source_vid {\n-                            to_vid\n-                        } else {\n-                            from_vid\n-                        };\n+                        let opp_vid = if from_vid == source_vid { to_vid } else { from_vid };\n                         if state.set.insert(opp_vid) {\n                             state.stack.push(opp_vid);\n                         }\n@@ -726,7 +860,8 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n     }\n \n     fn iterate_until_fixed_point<F>(&self, tag: &str, mut body: F)\n-        where F: FnMut(&Constraint<'tcx>) -> (bool, bool),\n+    where\n+        F: FnMut(&Constraint<'tcx>) -> (bool, bool),\n     {\n         let mut constraints: SmallVec<[_; 16]> = self.data.constraints.keys().collect();\n         let mut iteration = 0;\n@@ -760,17 +895,17 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                     && self.bound_is_met(b, var_values, generic_ty, min)\n             }\n \n-            VerifyBound::OutlivedBy(r) =>\n-                self.region_rels.is_subregion_of(\n-                    min,\n-                    var_values.normalize(self.tcx(), r),\n-                ),\n+            VerifyBound::OutlivedBy(r) => {\n+                self.region_rels.is_subregion_of(min, var_values.normalize(self.tcx(), r))\n+            }\n \n-            VerifyBound::AnyBound(bs) => bs.iter()\n-                .any(|b| self.bound_is_met(b, var_values, generic_ty, min)),\n+            VerifyBound::AnyBound(bs) => {\n+                bs.iter().any(|b| self.bound_is_met(b, var_values, generic_ty, min))\n+            }\n \n-            VerifyBound::AllBounds(bs) => bs.iter()\n-                .all(|b| self.bound_is_met(b, var_values, generic_ty, min)),\n+            VerifyBound::AllBounds(bs) => {\n+                bs.iter().all(|b| self.bound_is_met(b, var_values, generic_ty, min))\n+            }\n         }\n     }\n }"}, {"sha": "663acd67dcd839b147f5e4b3a7fc263a70e0a0af", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -26,6 +26,7 @@ use crate::ty::{FloatVid, IntVid, TyVid, ConstVid};\n use crate::util::nodemap::FxHashMap;\n \n use errors::DiagnosticBuilder;\n+use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::unify as ut;\n use std::cell::{Cell, Ref, RefCell, RefMut};\n use std::collections::BTreeMap;\n@@ -904,6 +905,21 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             .make_subregion(origin, a, b);\n     }\n \n+    /// Require that the region `r` be equal to one of the regions in\n+    /// the set `regions`.\n+    pub fn member_constraint(\n+        &self,\n+        opaque_type_def_id: DefId,\n+        definition_span: Span,\n+        hidden_ty: Ty<'tcx>,\n+        region: ty::Region<'tcx>,\n+        in_regions: &Lrc<Vec<ty::Region<'tcx>>>,\n+    ) {\n+        debug!(\"member_constraint({:?} <: {:?})\", region, in_regions);\n+        self.borrow_region_constraints()\n+            .member_constraint(opaque_type_def_id, definition_span, hidden_ty, region, in_regions);\n+    }\n+\n     pub fn subtype_predicate(\n         &self,\n         cause: &ObligationCause<'tcx>,\n@@ -1456,7 +1472,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         // Even if the type may have no inference variables, during\n         // type-checking closure types are in local tables only.\n         if !self.in_progress_tables.is_some() || !ty.has_closure_types() {\n-            if let Some((param_env, ty)) = self.tcx.lift_to_global(&(param_env, ty)) {\n+            if !(param_env, ty).has_local_value() {\n                 return ty.is_copy_modulo_regions(self.tcx.global_tcx(), param_env, span);\n             }\n         }"}, {"sha": "a0621af053783865d46f234fea1e9aff97b8a0c2", "filename": "src/librustc/infer/nll_relate/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -364,7 +364,7 @@ where\n         // been fully instantiated and hence the set of scopes we have\n         // doesn't matter -- just to be sure, put an empty vector\n         // in there.\n-        let old_a_scopes = ::std::mem::replace(pair.vid_scopes(self), vec![]);\n+        let old_a_scopes = ::std::mem::take(pair.vid_scopes(self));\n \n         // Relate the generalized kind to the original one.\n         let result = pair.relate_generalized_ty(self, generalized_ty);"}, {"sha": "f43e3fa0b7787f1bf4fc2bb13a99c9b82f497d62", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 340, "deletions": 176, "changes": 516, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -1,16 +1,19 @@\n-use rustc_data_structures::fx::FxHashMap;\n-use syntax_pos::Span;\n-\n-use crate::hir::def_id::DefId;\n use crate::hir;\n+use crate::hir::def_id::DefId;\n use crate::hir::Node;\n-use crate::infer::{self, InferCtxt, InferOk, TypeVariableOrigin, TypeVariableOriginKind};\n use crate::infer::outlives::free_region_map::FreeRegionRelations;\n+use crate::infer::{self, InferCtxt, InferOk, TypeVariableOrigin, TypeVariableOriginKind};\n+use crate::middle::region;\n use crate::traits::{self, PredicateObligation};\n-use crate::ty::{self, Ty, TyCtxt, GenericParamDefKind};\n use crate::ty::fold::{BottomUpFolder, TypeFoldable, TypeFolder, TypeVisitor};\n-use crate::ty::subst::{Kind, InternalSubsts, SubstsRef, UnpackedKind};\n+use crate::ty::subst::{InternalSubsts, Kind, SubstsRef, UnpackedKind};\n+use crate::ty::{self, GenericParamDefKind, Ty, TyCtxt};\n use crate::util::nodemap::DefIdMap;\n+use errors::DiagnosticBuilder;\n+use rustc::session::config::nightly_options;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::sync::Lrc;\n+use syntax_pos::Span;\n \n pub type OpaqueTypeMap<'tcx> = DefIdMap<OpaqueTypeDecl<'tcx>>;\n \n@@ -32,6 +35,20 @@ pub struct OpaqueTypeDecl<'tcx> {\n     /// then `substs` would be `['a, T]`.\n     pub substs: SubstsRef<'tcx>,\n \n+    /// The span of this particular definition of the opaque type.  So\n+    /// for example:\n+    ///\n+    /// ```\n+    /// existential type Foo;\n+    /// fn bar() -> Foo {\n+    ///             ^^^ This is the span we are looking for!\n+    /// ```\n+    ///\n+    /// In cases where the fn returns `(impl Trait, impl Trait)` or\n+    /// other such combinations, the result is currently\n+    /// over-approximated, but better than nothing.\n+    pub definition_span: Span,\n+\n     /// The type variable that represents the value of the abstract type\n     /// that we require. In other words, after we compile this function,\n     /// we will be created a constraint like:\n@@ -98,30 +115,31 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// - `param_env` -- the in-scope parameter environment to be used for\n     ///   obligations\n     /// - `value` -- the value within which we are instantiating opaque types\n+    /// - `value_span` -- the span where the value came from, used in error reporting\n     pub fn instantiate_opaque_types<T: TypeFoldable<'tcx>>(\n         &self,\n         parent_def_id: DefId,\n         body_id: hir::HirId,\n         param_env: ty::ParamEnv<'tcx>,\n         value: &T,\n+        value_span: Span,\n     ) -> InferOk<'tcx, (T, OpaqueTypeMap<'tcx>)> {\n-        debug!(\"instantiate_opaque_types(value={:?}, parent_def_id={:?}, body_id={:?}, \\\n-                param_env={:?})\",\n-               value, parent_def_id, body_id, param_env,\n+        debug!(\n+            \"instantiate_opaque_types(value={:?}, parent_def_id={:?}, body_id={:?}, \\\n+             param_env={:?})\",\n+            value, parent_def_id, body_id, param_env,\n         );\n         let mut instantiator = Instantiator {\n             infcx: self,\n             parent_def_id,\n             body_id,\n             param_env,\n+            value_span,\n             opaque_types: Default::default(),\n             obligations: vec![],\n         };\n         let value = instantiator.instantiate_opaque_types_in_map(value);\n-        InferOk {\n-            value: (value, instantiator.opaque_types),\n-            obligations: instantiator.obligations,\n-        }\n+        InferOk { value: (value, instantiator.opaque_types), obligations: instantiator.obligations }\n     }\n \n     /// Given the map `opaque_types` containing the existential `impl\n@@ -216,22 +234,46 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     ///\n     /// # The Solution\n     ///\n-    /// We make use of the constraint that we *do* have in the `<=`\n-    /// relation. To do that, we find the \"minimum\" of all the\n-    /// arguments that appear in the substs: that is, some region\n-    /// which is less than all the others. In the case of `Foo1<'a>`,\n-    /// that would be `'a` (it's the only choice, after all). Then we\n-    /// apply that as a least bound to the variables (e.g., `'a <=\n-    /// '0`).\n+    /// We generally prefer to make `<=` constraints, since they\n+    /// integrate best into the region solver. To do that, we find the\n+    /// \"minimum\" of all the arguments that appear in the substs: that\n+    /// is, some region which is less than all the others. In the case\n+    /// of `Foo1<'a>`, that would be `'a` (it's the only choice, after\n+    /// all). Then we apply that as a least bound to the variables\n+    /// (e.g., `'a <= '0`).\n     ///\n     /// In some cases, there is no minimum. Consider this example:\n     ///\n     /// ```text\n     /// fn baz<'a, 'b>() -> impl Trait<'a, 'b> { ... }\n     /// ```\n     ///\n-    /// Here we would report an error, because `'a` and `'b` have no\n-    /// relation to one another.\n+    /// Here we would report a more complex \"in constraint\", like `'r\n+    /// in ['a, 'b, 'static]` (where `'r` is some regon appearing in\n+    /// the hidden type).\n+    ///\n+    /// # Constrain regions, not the hidden concrete type\n+    ///\n+    /// Note that generating constraints on each region `Rc` is *not*\n+    /// the same as generating an outlives constraint on `Tc` iself.\n+    /// For example, if we had a function like this:\n+    ///\n+    /// ```rust\n+    /// fn foo<'a, T>(x: &'a u32, y: T) -> impl Foo<'a> {\n+    ///   (x, y)\n+    /// }\n+    ///\n+    /// // Equivalent to:\n+    /// existential type FooReturn<'a, T>: Foo<'a>;\n+    /// fn foo<'a, T>(..) -> FooReturn<'a, T> { .. }\n+    /// ```\n+    ///\n+    /// then the hidden type `Tc` would be `(&'0 u32, T)` (where `'0`\n+    /// is an inference variable). If we generated a constraint that\n+    /// `Tc: 'a`, then this would incorrectly require that `T: 'a` --\n+    /// but this is not necessary, because the existential type we\n+    /// create will be allowed to reference `T`. So we only generate a\n+    /// constraint that `'0: 'a`.\n     ///\n     /// # The `free_region_relations` parameter\n     ///\n@@ -274,6 +316,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n+    /// See `constrain_opaque_types` for documentation.\n     pub fn constrain_opaque_type<FRR: FreeRegionRelations<'tcx>>(\n         &self,\n         def_id: DefId,\n@@ -290,32 +333,25 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n         debug!(\"constrain_opaque_type: concrete_ty={:?}\", concrete_ty);\n \n-        let abstract_type_generics = tcx.generics_of(def_id);\n+        let opaque_type_generics = tcx.generics_of(def_id);\n \n         let span = tcx.def_span(def_id);\n \n         // If there are required region bounds, we can use them.\n         if opaque_defn.has_required_region_bounds {\n             let predicates_of = tcx.predicates_of(def_id);\n-            debug!(\n-                \"constrain_opaque_type: predicates: {:#?}\",\n-                predicates_of,\n-            );\n+            debug!(\"constrain_opaque_type: predicates: {:#?}\", predicates_of,);\n             let bounds = predicates_of.instantiate(tcx, opaque_defn.substs);\n             debug!(\"constrain_opaque_type: bounds={:#?}\", bounds);\n             let opaque_type = tcx.mk_opaque(def_id, opaque_defn.substs);\n \n-            let required_region_bounds = tcx.required_region_bounds(\n-                opaque_type,\n-                bounds.predicates,\n-            );\n+            let required_region_bounds = tcx.required_region_bounds(opaque_type, bounds.predicates);\n             debug_assert!(!required_region_bounds.is_empty());\n \n-            for region in required_region_bounds {\n-                concrete_ty.visit_with(&mut OpaqueTypeOutlivesVisitor {\n-                    infcx: self,\n-                    least_region: region,\n-                    span,\n+            for required_region in required_region_bounds {\n+                concrete_ty.visit_with(&mut ConstrainOpaqueTypeRegionVisitor {\n+                    tcx: self.tcx,\n+                    op: |r| self.sub_regions(infer::CallReturn(span), required_region, r),\n                 });\n             }\n             return;\n@@ -329,11 +365,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         // `['a]` for the first impl trait and `'b` for the\n         // second.\n         let mut least_region = None;\n-        for param in &abstract_type_generics.params {\n+        for param in &opaque_type_generics.params {\n             match param.kind {\n                 GenericParamDefKind::Lifetime => {}\n-                _ => continue\n+                _ => continue,\n             }\n+\n             // Get the value supplied for this region from the substs.\n             let subst_arg = opaque_defn.substs.region_at(param.index as usize);\n \n@@ -350,44 +387,21 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         least_region = Some(subst_arg);\n                     } else {\n                         // There are two regions (`lr` and\n-                        // `subst_arg`) which are not relatable. We can't\n-                        // find a best choice.\n-                        let context_name = match opaque_defn.origin {\n-                            hir::ExistTyOrigin::ExistentialType => \"existential type\",\n-                            hir::ExistTyOrigin::ReturnImplTrait => \"impl Trait\",\n-                            hir::ExistTyOrigin::AsyncFn => \"async fn\",\n-                        };\n-                        let msg = format!(\"ambiguous lifetime bound in `{}`\", context_name);\n-                        let mut err = self.tcx\n-                            .sess\n-                            .struct_span_err(span, &msg);\n-\n-                        let lr_name = lr.to_string();\n-                        let subst_arg_name = subst_arg.to_string();\n-                        let label_owned;\n-                        let label = match (&*lr_name, &*subst_arg_name) {\n-                            (\"'_\", \"'_\") => \"the elided lifetimes here do not outlive one another\",\n-                            _ => {\n-                                label_owned = format!(\n-                                    \"neither `{}` nor `{}` outlives the other\",\n-                                    lr_name,\n-                                    subst_arg_name,\n-                                );\n-                                &label_owned\n-                            }\n-                        };\n-                        err.span_label(span, label);\n-\n-                        if let hir::ExistTyOrigin::AsyncFn = opaque_defn.origin {\n-                            err.note(\"multiple unrelated lifetimes are not allowed in \\\n-                                     `async fn`.\");\n-                            err.note(\"if you're using argument-position elided lifetimes, consider \\\n-                                switching to a single named lifetime.\");\n-                        }\n-                        err.emit();\n-\n-                        least_region = Some(self.tcx.mk_region(ty::ReEmpty));\n-                        break;\n+                        // `subst_arg`) which are not relatable. We\n+                        // can't find a best choice. Therefore,\n+                        // instead of creating a single bound like\n+                        // `'r: 'a` (which is our preferred choice),\n+                        // we will create a \"in bound\" like `'r in\n+                        // ['a, 'b, 'c]`, where `'a..'c` are the\n+                        // regions that appear in the impl trait.\n+                        return self.generate_member_constraint(\n+                            concrete_ty,\n+                            opaque_type_generics,\n+                            opaque_defn,\n+                            def_id,\n+                            lr,\n+                            subst_arg,\n+                        );\n                     }\n                 }\n             }\n@@ -396,13 +410,121 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let least_region = least_region.unwrap_or(tcx.lifetimes.re_static);\n         debug!(\"constrain_opaque_types: least_region={:?}\", least_region);\n \n-        concrete_ty.visit_with(&mut OpaqueTypeOutlivesVisitor {\n-            infcx: self,\n-            least_region,\n-            span,\n+        concrete_ty.visit_with(&mut ConstrainOpaqueTypeRegionVisitor {\n+            tcx: self.tcx,\n+            op: |r| self.sub_regions(infer::CallReturn(span), least_region, r),\n         });\n     }\n \n+    /// As a fallback, we sometimes generate an \"in constraint\". For\n+    /// a case like `impl Foo<'a, 'b>`, where `'a` and `'b` cannot be\n+    /// related, we would generate a constraint `'r in ['a, 'b,\n+    /// 'static]` for each region `'r` that appears in the hidden type\n+    /// (i.e., it must be equal to `'a`, `'b`, or `'static`).\n+    ///\n+    /// `conflict1` and `conflict2` are the two region bounds that we\n+    /// detected which were unrelated. They are used for diagnostics.\n+    fn generate_member_constraint(\n+        &self,\n+        concrete_ty: Ty<'tcx>,\n+        opaque_type_generics: &ty::Generics,\n+        opaque_defn: &OpaqueTypeDecl<'tcx>,\n+        opaque_type_def_id: DefId,\n+        conflict1: ty::Region<'tcx>,\n+        conflict2: ty::Region<'tcx>,\n+    ) {\n+        // For now, enforce a feature gate outside of async functions.\n+        if self.member_constraint_feature_gate(\n+            opaque_defn,\n+            opaque_type_def_id,\n+            conflict1,\n+            conflict2,\n+        ) {\n+            return;\n+        }\n+\n+        // Create the set of choice regions: each region in the hidden\n+        // type can be equal to any of the region parameters of the\n+        // opaque type definition.\n+        let choice_regions: Lrc<Vec<ty::Region<'tcx>>> = Lrc::new(\n+            opaque_type_generics\n+                .params\n+                .iter()\n+                .filter(|param| match param.kind {\n+                    GenericParamDefKind::Lifetime => true,\n+                    GenericParamDefKind::Type { .. } | GenericParamDefKind::Const => false,\n+                })\n+                .map(|param| opaque_defn.substs.region_at(param.index as usize))\n+                .chain(std::iter::once(self.tcx.lifetimes.re_static))\n+                .collect(),\n+        );\n+\n+        concrete_ty.visit_with(&mut ConstrainOpaqueTypeRegionVisitor {\n+            tcx: self.tcx,\n+            op: |r| self.member_constraint(\n+                opaque_type_def_id,\n+                opaque_defn.definition_span,\n+                concrete_ty,\n+                r,\n+                &choice_regions,\n+            ),\n+        });\n+    }\n+\n+    /// Member constraints are presently feature-gated except for\n+    /// async-await. We expect to lift this once we've had a bit more\n+    /// time.\n+    fn member_constraint_feature_gate(\n+        &self,\n+        opaque_defn: &OpaqueTypeDecl<'tcx>,\n+        opaque_type_def_id: DefId,\n+        conflict1: ty::Region<'tcx>,\n+        conflict2: ty::Region<'tcx>,\n+    ) -> bool {\n+        // If we have `#![feature(member_constraints)]`, no problems.\n+        if self.tcx.features().member_constraints {\n+            return false;\n+        }\n+\n+        let span = self.tcx.def_span(opaque_type_def_id);\n+\n+        // Without a feature-gate, we only generate member-constraints for async-await.\n+        let context_name = match opaque_defn.origin {\n+            // No feature-gate required for `async fn`.\n+            hir::ExistTyOrigin::AsyncFn => return false,\n+\n+            // Otherwise, generate the label we'll use in the error message.\n+            hir::ExistTyOrigin::ExistentialType => \"existential type\",\n+            hir::ExistTyOrigin::ReturnImplTrait => \"impl Trait\",\n+        };\n+        let msg = format!(\"ambiguous lifetime bound in `{}`\", context_name);\n+        let mut err = self.tcx.sess.struct_span_err(span, &msg);\n+\n+        let conflict1_name = conflict1.to_string();\n+        let conflict2_name = conflict2.to_string();\n+        let label_owned;\n+        let label = match (&*conflict1_name, &*conflict2_name) {\n+            (\"'_\", \"'_\") => \"the elided lifetimes here do not outlive one another\",\n+            _ => {\n+                label_owned = format!(\n+                    \"neither `{}` nor `{}` outlives the other\",\n+                    conflict1_name, conflict2_name,\n+                );\n+                &label_owned\n+            }\n+        };\n+        err.span_label(span, label);\n+\n+        if nightly_options::is_nightly_build() {\n+            help!(err,\n+                  \"add #![feature(member_constraints)] to the crate attributes \\\n+                   to enable\");\n+        }\n+\n+        err.emit();\n+        true\n+    }\n+\n     /// Given the fully resolved, instantiated type for an opaque\n     /// type, i.e., the value of an inference variable like C1 or C2\n     /// (*), computes the \"definition type\" for an abstract type\n@@ -456,23 +578,98 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         // Convert the type from the function into a type valid outside\n         // the function, by replacing invalid regions with 'static,\n         // after producing an error for each of them.\n-        let definition_ty =\n-            instantiated_ty.fold_with(&mut ReverseMapper::new(\n-                self.tcx,\n-                self.is_tainted_by_errors(),\n-                def_id,\n-                map,\n-                instantiated_ty,\n-            ));\n-        debug!(\n-            \"infer_opaque_definition_from_instantiation: definition_ty={:?}\",\n-            definition_ty\n-        );\n+        let definition_ty = instantiated_ty.fold_with(&mut ReverseMapper::new(\n+            self.tcx,\n+            self.is_tainted_by_errors(),\n+            def_id,\n+            map,\n+            instantiated_ty,\n+        ));\n+        debug!(\"infer_opaque_definition_from_instantiation: definition_ty={:?}\", definition_ty);\n \n         definition_ty\n     }\n }\n \n+pub fn unexpected_hidden_region_diagnostic(\n+    tcx: TyCtxt<'tcx>,\n+    region_scope_tree: Option<&region::ScopeTree>,\n+    opaque_type_def_id: DefId,\n+    hidden_ty: Ty<'tcx>,\n+    hidden_region: ty::Region<'tcx>,\n+) -> DiagnosticBuilder<'tcx> {\n+    let span = tcx.def_span(opaque_type_def_id);\n+    let mut err = struct_span_err!(\n+        tcx.sess,\n+        span,\n+        E0700,\n+        \"hidden type for `impl Trait` captures lifetime that does not appear in bounds\",\n+    );\n+\n+    // Explain the region we are capturing.\n+    if let ty::ReEarlyBound(_) | ty::ReFree(_) | ty::ReStatic | ty::ReEmpty = hidden_region {\n+        // Assuming regionck succeeded (*), we ought to always be\n+        // capturing *some* region from the fn header, and hence it\n+        // ought to be free. So under normal circumstances, we will go\n+        // down this path which gives a decent human readable\n+        // explanation.\n+        //\n+        // (*) if not, the `tainted_by_errors` flag would be set to\n+        // true in any case, so we wouldn't be here at all.\n+        tcx.note_and_explain_free_region(\n+            &mut err,\n+            &format!(\"hidden type `{}` captures \", hidden_ty),\n+            hidden_region,\n+            \"\",\n+        );\n+    } else {\n+        // Ugh. This is a painful case: the hidden region is not one\n+        // that we can easily summarize or explain. This can happen\n+        // in a case like\n+        // `src/test/ui/multiple-lifetimes/ordinary-bounds-unsuited.rs`:\n+        //\n+        // ```\n+        // fn upper_bounds<'a, 'b>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'a, 'b> {\n+        //   if condition() { a } else { b }\n+        // }\n+        // ```\n+        //\n+        // Here the captured lifetime is the intersection of `'a` and\n+        // `'b`, which we can't quite express.\n+\n+        if let Some(region_scope_tree) = region_scope_tree {\n+            // If the `region_scope_tree` is available, this is being\n+            // invoked from the \"region inferencer error\". We can at\n+            // least report a really cryptic error for now.\n+            tcx.note_and_explain_region(\n+                region_scope_tree,\n+                &mut err,\n+                &format!(\"hidden type `{}` captures \", hidden_ty),\n+                hidden_region,\n+                \"\",\n+            );\n+        } else {\n+            // If the `region_scope_tree` is *unavailable*, this is\n+            // being invoked by the code that comes *after* region\n+            // inferencing. This is a bug, as the region inferencer\n+            // ought to have noticed the failed constraint and invoked\n+            // error reporting, which in turn should have prevented us\n+            // from getting trying to infer the hidden type\n+            // completely.\n+            tcx.sess.delay_span_bug(\n+                span,\n+                &format!(\n+                    \"hidden type captures unexpected lifetime `{:?}` \\\n+                     but no region inference failure\",\n+                    hidden_region,\n+                ),\n+            );\n+        }\n+    }\n+\n+    err\n+}\n+\n // Visitor that requires that (almost) all regions in the type visited outlive\n // `least_region`. We cannot use `push_outlives_components` because regions in\n // closure signatures are not included in their outlives components. We need to\n@@ -486,13 +683,18 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n //\n // We ignore any type parameters because impl trait values are assumed to\n // capture all the in-scope type parameters.\n-struct OpaqueTypeOutlivesVisitor<'a, 'tcx> {\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n-    least_region: ty::Region<'tcx>,\n-    span: Span,\n+struct ConstrainOpaqueTypeRegionVisitor<'tcx, OP>\n+where\n+    OP: FnMut(ty::Region<'tcx>),\n+{\n+    tcx: TyCtxt<'tcx>,\n+    op: OP,\n }\n \n-impl<'tcx> TypeVisitor<'tcx> for OpaqueTypeOutlivesVisitor<'_, 'tcx> {\n+impl<'tcx, OP> TypeVisitor<'tcx> for ConstrainOpaqueTypeRegionVisitor<'tcx, OP>\n+where\n+    OP: FnMut(ty::Region<'tcx>),\n+{\n     fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> bool {\n         t.skip_binder().visit_with(self);\n         false // keep visiting\n@@ -503,7 +705,7 @@ impl<'tcx> TypeVisitor<'tcx> for OpaqueTypeOutlivesVisitor<'_, 'tcx> {\n             // ignore bound regions, keep visiting\n             ty::ReLateBound(_, _) => false,\n             _ => {\n-                self.infcx.sub_regions(infer::CallReturn(self.span), self.least_region, r);\n+                (self.op)(r);\n                 false\n             }\n         }\n@@ -519,23 +721,23 @@ impl<'tcx> TypeVisitor<'tcx> for OpaqueTypeOutlivesVisitor<'_, 'tcx> {\n             ty::Closure(def_id, ref substs) => {\n                 // Skip lifetime parameters of the enclosing item(s)\n \n-                for upvar_ty in substs.upvar_tys(def_id, self.infcx.tcx) {\n+                for upvar_ty in substs.upvar_tys(def_id, self.tcx) {\n                     upvar_ty.visit_with(self);\n                 }\n \n-                substs.closure_sig_ty(def_id, self.infcx.tcx).visit_with(self);\n+                substs.closure_sig_ty(def_id, self.tcx).visit_with(self);\n             }\n \n             ty::Generator(def_id, ref substs, _) => {\n                 // Skip lifetime parameters of the enclosing item(s)\n                 // Also skip the witness type, because that has no free regions.\n \n-                for upvar_ty in substs.upvar_tys(def_id, self.infcx.tcx) {\n+                for upvar_ty in substs.upvar_tys(def_id, self.tcx) {\n                     upvar_ty.visit_with(self);\n                 }\n \n-                substs.return_ty(def_id, self.infcx.tcx).visit_with(self);\n-                substs.yield_ty(def_id, self.infcx.tcx).visit_with(self);\n+                substs.return_ty(def_id, self.tcx).visit_with(self);\n+                substs.yield_ty(def_id, self.tcx).visit_with(self);\n             }\n             _ => {\n                 ty.super_visit_with(self);\n@@ -616,40 +818,17 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n             None => {\n                 if !self.map_missing_regions_to_empty && !self.tainted_by_errors {\n                     if let Some(hidden_ty) = self.hidden_ty.take() {\n-                        let span = self.tcx.def_span(self.opaque_type_def_id);\n-                        let mut err = struct_span_err!(\n-                            self.tcx.sess,\n-                            span,\n-                            E0700,\n-                            \"hidden type for `impl Trait` captures lifetime that \\\n-                             does not appear in bounds\",\n-                        );\n-\n-                        // Assuming regionck succeeded, then we must\n-                        // be capturing *some* region from the fn\n-                        // header, and hence it must be free, so it's\n-                        // ok to invoke this fn (which doesn't accept\n-                        // all regions, and would ICE if an\n-                        // inappropriate region is given). We check\n-                        // `is_tainted_by_errors` by errors above, so\n-                        // we don't get in here unless regionck\n-                        // succeeded. (Note also that if regionck\n-                        // failed, then the regions we are attempting\n-                        // to map here may well be giving errors\n-                        // *because* the constraints were not\n-                        // satisfiable.)\n-                        self.tcx.note_and_explain_free_region(\n-                            &mut err,\n-                            &format!(\"hidden type `{}` captures \", hidden_ty),\n+                        unexpected_hidden_region_diagnostic(\n+                            self.tcx,\n+                            None,\n+                            self.opaque_type_def_id,\n+                            hidden_ty,\n                             r,\n-                            \"\"\n-                        );\n-\n-                        err.emit();\n+                        ).emit();\n                     }\n                 }\n                 self.tcx.lifetimes.re_empty\n-            },\n+            }\n         }\n     }\n \n@@ -681,34 +860,32 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n                 // during codegen.\n \n                 let generics = self.tcx.generics_of(def_id);\n-                let substs = self.tcx.mk_substs(substs.substs.iter().enumerate().map(\n-                    |(index, &kind)| {\n+                let substs =\n+                    self.tcx.mk_substs(substs.substs.iter().enumerate().map(|(index, &kind)| {\n                         if index < generics.parent_count {\n                             // Accommodate missing regions in the parent kinds...\n                             self.fold_kind_mapping_missing_regions_to_empty(kind)\n                         } else {\n                             // ...but not elsewhere.\n                             self.fold_kind_normally(kind)\n                         }\n-                    },\n-                ));\n+                    }));\n \n                 self.tcx.mk_closure(def_id, ty::ClosureSubsts { substs })\n             }\n \n             ty::Generator(def_id, substs, movability) => {\n                 let generics = self.tcx.generics_of(def_id);\n-                let substs = self.tcx.mk_substs(substs.substs.iter().enumerate().map(\n-                    |(index, &kind)| {\n+                let substs =\n+                    self.tcx.mk_substs(substs.substs.iter().enumerate().map(|(index, &kind)| {\n                         if index < generics.parent_count {\n                             // Accommodate missing regions in the parent kinds...\n                             self.fold_kind_mapping_missing_regions_to_empty(kind)\n                         } else {\n                             // ...but not elsewhere.\n                             self.fold_kind_normally(kind)\n                         }\n-                    },\n-                ));\n+                    }));\n \n                 self.tcx.mk_generator(def_id, ty::GeneratorSubsts { substs }, movability)\n             }\n@@ -723,6 +900,7 @@ struct Instantiator<'a, 'tcx> {\n     parent_def_id: DefId,\n     body_id: hir::HirId,\n     param_env: ty::ParamEnv<'tcx>,\n+    value_span: Span,\n     opaque_types: OpaqueTypeMap<'tcx>,\n     obligations: Vec<PredicateObligation<'tcx>>,\n }\n@@ -773,12 +951,10 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n                         let parent_def_id = self.parent_def_id;\n                         let def_scope_default = || {\n                             let opaque_parent_hir_id = tcx.hir().get_parent_item(opaque_hir_id);\n-                            parent_def_id == tcx.hir()\n-                                                .local_def_id_from_hir_id(opaque_parent_hir_id)\n+                            parent_def_id\n+                                == tcx.hir().local_def_id_from_hir_id(opaque_parent_hir_id)\n                         };\n-                        let (in_definition_scope, origin) =\n-                            match tcx.hir().find(opaque_hir_id)\n-                        {\n+                        let (in_definition_scope, origin) = match tcx.hir().find(opaque_hir_id) {\n                             Some(Node::Item(item)) => match item.node {\n                                 // Anonymous `impl Trait`\n                                 hir::ItemKind::Existential(hir::ExistTy {\n@@ -847,52 +1023,43 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n         let infcx = self.infcx;\n         let tcx = infcx.tcx;\n \n-        debug!(\n-            \"instantiate_opaque_types: Opaque(def_id={:?}, substs={:?})\",\n-            def_id, substs\n-        );\n+        debug!(\"instantiate_opaque_types: Opaque(def_id={:?}, substs={:?})\", def_id, substs);\n \n         // Use the same type variable if the exact same opaque type appears more\n         // than once in the return type (e.g., if it's passed to a type alias).\n         if let Some(opaque_defn) = self.opaque_types.get(&def_id) {\n             return opaque_defn.concrete_ty;\n         }\n         let span = tcx.def_span(def_id);\n-        let ty_var = infcx.next_ty_var(TypeVariableOrigin {\n-            kind: TypeVariableOriginKind::TypeInference,\n-            span,\n-        });\n+        let ty_var = infcx\n+            .next_ty_var(TypeVariableOrigin { kind: TypeVariableOriginKind::TypeInference, span });\n \n         let predicates_of = tcx.predicates_of(def_id);\n-        debug!(\n-            \"instantiate_opaque_types: predicates={:#?}\",\n-            predicates_of,\n-        );\n+        debug!(\"instantiate_opaque_types: predicates={:#?}\", predicates_of,);\n         let bounds = predicates_of.instantiate(tcx, substs);\n         debug!(\"instantiate_opaque_types: bounds={:?}\", bounds);\n \n         let required_region_bounds = tcx.required_region_bounds(ty, bounds.predicates.clone());\n-        debug!(\n-            \"instantiate_opaque_types: required_region_bounds={:?}\",\n-            required_region_bounds\n-        );\n+        debug!(\"instantiate_opaque_types: required_region_bounds={:?}\", required_region_bounds);\n \n         // Make sure that we are in fact defining the *entire* type\n         // (e.g., `existential type Foo<T: Bound>: Bar;` needs to be\n         // defined by a function like `fn foo<T: Bound>() -> Foo<T>`).\n-        debug!(\n-            \"instantiate_opaque_types: param_env={:#?}\",\n-            self.param_env,\n-        );\n-        debug!(\n-            \"instantiate_opaque_types: generics={:#?}\",\n-            tcx.generics_of(def_id),\n-        );\n+        debug!(\"instantiate_opaque_types: param_env={:#?}\", self.param_env,);\n+        debug!(\"instantiate_opaque_types: generics={:#?}\", tcx.generics_of(def_id),);\n+\n+        // Ideally, we'd get the span where *this specific `ty` came\n+        // from*, but right now we just use the span from the overall\n+        // value being folded. In simple cases like `-> impl Foo`,\n+        // these are the same span, but not in cases like `-> (impl\n+        // Foo, impl Bar)`.\n+        let definition_span = self.value_span;\n \n         self.opaque_types.insert(\n             def_id,\n             OpaqueTypeDecl {\n                 substs,\n+                definition_span,\n                 concrete_ty: ty_var,\n                 has_required_region_bounds: !required_region_bounds.is_empty(),\n                 origin,\n@@ -911,8 +1078,7 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n \n             // Require that the predicate holds for the concrete type.\n             debug!(\"instantiate_opaque_types: predicate={:?}\", predicate);\n-            self.obligations\n-                .push(traits::Obligation::new(cause, self.param_env, predicate));\n+            self.obligations.push(traits::Obligation::new(cause, self.param_env, predicate));\n         }\n \n         ty_var\n@@ -950,9 +1116,7 @@ pub fn may_define_existential_type(\n     );\n \n     // Named existential types can be defined by any siblings or children of siblings.\n-    let scope = tcx.hir()\n-        .get_defining_scope(opaque_hir_id)\n-        .expect(\"could not get defining scope\");\n+    let scope = tcx.hir().get_defining_scope(opaque_hir_id).expect(\"could not get defining scope\");\n     // We walk up the node tree until we hit the root or the scope of the opaque type.\n     while hir_id != scope && hir_id != hir::CRATE_HIR_ID {\n         hir_id = tcx.hir().get_parent_item(hir_id);"}, {"sha": "c085df6a6e7ab6536a99192c8db0232fdfe1e83d", "filename": "src/librustc/infer/outlives/free_region_map.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Finfer%2Foutlives%2Ffree_region_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Finfer%2Foutlives%2Ffree_region_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Ffree_region_map.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -11,6 +11,10 @@ pub struct FreeRegionMap<'tcx> {\n }\n \n impl<'tcx> FreeRegionMap<'tcx> {\n+    pub fn elements(&self) -> impl Iterator<Item=&Region<'tcx>> {\n+        self.relation.elements()\n+    }\n+\n     pub fn is_empty(&self) -> bool {\n         self.relation.is_empty()\n     }"}, {"sha": "e1470e4ef0232318468feb298536a639fe47fda7", "filename": "src/librustc/infer/outlives/obligations.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -112,7 +112,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n \n     /// Trait queries just want to pass back type obligations \"as is\"\n     pub fn take_registered_region_obligations(&self) -> Vec<(hir::HirId, RegionObligation<'tcx>)> {\n-        ::std::mem::replace(&mut *self.region_obligations.borrow_mut(), vec![])\n+        ::std::mem::take(&mut *self.region_obligations.borrow_mut())\n     }\n \n     /// Process the region obligations that must be proven (during"}, {"sha": "21904edb309cb4b2efe6de2899465f6c9c9ec843", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 75, "deletions": 2, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -8,11 +8,14 @@ use super::{MiscVariable, RegionVariableOrigin, SubregionOrigin};\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::indexed_vec::IndexVec;\n+use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::unify as ut;\n+use crate::hir::def_id::DefId;\n use crate::ty::ReStatic;\n use crate::ty::{self, Ty, TyCtxt};\n use crate::ty::{ReLateBound, ReVar};\n use crate::ty::{Region, RegionVid};\n+use syntax_pos::Span;\n \n use std::collections::BTreeMap;\n use std::{cmp, fmt, mem};\n@@ -78,6 +81,11 @@ pub struct RegionConstraintData<'tcx> {\n     /// be a region variable (or neither, as it happens).\n     pub constraints: BTreeMap<Constraint<'tcx>, SubregionOrigin<'tcx>>,\n \n+    /// Constraints of the form `R0 member of [R1, ..., Rn]`, meaning that\n+    /// `R0` must be equal to one of the regions `R1..Rn`. These occur\n+    /// with `impl Trait` quite frequently.\n+    pub member_constraints: Vec<MemberConstraint<'tcx>>,\n+\n     /// A \"verify\" is something that we need to verify after inference\n     /// is done, but which does not directly affect inference in any\n     /// way.\n@@ -137,6 +145,43 @@ impl Constraint<'_> {\n     }\n }\n \n+/// Requires that `region` must be equal to one of the regions in `choice_regions`.\n+/// We often denote this using the syntax:\n+///\n+/// ```\n+/// R0 member of [O1..On]\n+/// ```\n+#[derive(Debug, Clone, HashStable)]\n+pub struct MemberConstraint<'tcx> {\n+    /// The `DefId` of the opaque type causing this constraint: used for error reporting.\n+    pub opaque_type_def_id: DefId,\n+\n+    /// The span where the hidden type was instantiated.\n+    pub definition_span: Span,\n+\n+    /// The hidden type in which `member_region` appears: used for error reporting.\n+    pub hidden_ty: Ty<'tcx>,\n+\n+    /// The region `R0`.\n+    pub member_region: Region<'tcx>,\n+\n+    /// The options `O1..On`.\n+    pub choice_regions: Lrc<Vec<Region<'tcx>>>,\n+}\n+\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for MemberConstraint<'tcx> {\n+        opaque_type_def_id, definition_span, hidden_ty, member_region, choice_regions\n+    }\n+}\n+\n+BraceStructLiftImpl! {\n+    impl<'a, 'tcx> Lift<'tcx> for MemberConstraint<'a> {\n+        type Lifted = MemberConstraint<'tcx>;\n+        opaque_type_def_id, definition_span, hidden_ty, member_region, choice_regions\n+    }\n+}\n+\n /// `VerifyGenericBound(T, _, R, RS)`: the parameter type `T` (or\n /// associated type) must outlive the region `R`. `T` is known to\n /// outlive `RS`. Therefore, verify that `R <= RS[i]` for some\n@@ -410,7 +455,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n             *any_unifications = false;\n         }\n \n-        mem::replace(data, RegionConstraintData::default())\n+        mem::take(data)\n     }\n \n     pub fn data(&self) -> &RegionConstraintData<'tcx> {\n@@ -643,6 +688,30 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         }\n     }\n \n+    pub fn member_constraint(\n+        &mut self,\n+        opaque_type_def_id: DefId,\n+        definition_span: Span,\n+        hidden_ty: Ty<'tcx>,\n+        member_region: ty::Region<'tcx>,\n+        choice_regions: &Lrc<Vec<ty::Region<'tcx>>>,\n+    ) {\n+        debug!(\"member_constraint({:?} in {:#?})\", member_region, choice_regions);\n+\n+        if choice_regions.iter().any(|&r| r == member_region) {\n+            return;\n+        }\n+\n+        self.data.member_constraints.push(MemberConstraint {\n+            opaque_type_def_id,\n+            definition_span,\n+            hidden_ty,\n+            member_region,\n+            choice_regions: choice_regions.clone()\n+        });\n+\n+    }\n+\n     pub fn make_subregion(\n         &mut self,\n         origin: SubregionOrigin<'tcx>,\n@@ -906,9 +975,13 @@ impl<'tcx> RegionConstraintData<'tcx> {\n     pub fn is_empty(&self) -> bool {\n         let RegionConstraintData {\n             constraints,\n+            member_constraints,\n             verifys,\n             givens,\n         } = self;\n-        constraints.is_empty() && verifys.is_empty() && givens.is_empty()\n+        constraints.is_empty() &&\n+            member_constraints.is_empty() &&\n+            verifys.is_empty() &&\n+            givens.is_empty()\n     }\n }"}, {"sha": "e30e86998a8c6f16bde7f8c1d8e932edb1380f31", "filename": "src/librustc/infer/type_variable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ftype_variable.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -115,7 +115,7 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     ///\n     /// Note that this function does not return care whether\n     /// `vid` has been unified with something else or not.\n-    pub fn var_diverges<'a>(&'a self, vid: ty::TyVid) -> bool {\n+    pub fn var_diverges(&self, vid: ty::TyVid) -> bool {\n         self.values.get(vid.index as usize).diverging\n     }\n "}, {"sha": "c4c23428002e63676d7670a721a71701f87a595f", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -35,6 +35,8 @@\n #![feature(arbitrary_self_types)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n+#![feature(const_fn)]\n+#![feature(const_transmute)]\n #![feature(core_intrinsics)]\n #![feature(drain_filter)]\n #![feature(inner_deref)]\n@@ -65,6 +67,7 @@\n #![feature(crate_visibility_modifier)]\n #![feature(proc_macro_hygiene)]\n #![feature(log_syntax)]\n+#![feature(mem_take)]\n \n #![recursion_limit=\"512\"]\n "}, {"sha": "59b08b832d27275fe0f210cc883c414b35d6c900", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -765,7 +765,7 @@ pub fn maybe_lint_level_root(tcx: TyCtxt<'_>, id: hir::HirId) -> bool {\n     attrs.iter().any(|attr| Level::from_symbol(attr.name_or_empty()).is_some())\n }\n \n-fn lint_levels<'tcx>(tcx: TyCtxt<'tcx>, cnum: CrateNum) -> &'tcx LintLevelMap {\n+fn lint_levels(tcx: TyCtxt<'_>, cnum: CrateNum) -> &LintLevelMap {\n     assert_eq!(cnum, LOCAL_CRATE);\n     let mut builder = LintLevelMapBuilder {\n         levels: LintLevelSets::builder(tcx.sess),"}, {"sha": "5a580dfa420b3f22d5a3b33fabf39d7e2c0383ea", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -211,7 +211,7 @@ pub trait CrateStore {\n     fn crates_untracked(&self) -> Vec<CrateNum>;\n \n     // utility functions\n-    fn encode_metadata<'tcx>(&self, tcx: TyCtxt<'tcx>) -> EncodedMetadata;\n+    fn encode_metadata(&self, tcx: TyCtxt<'_>) -> EncodedMetadata;\n     fn metadata_encoding_version(&self) -> &[u8];\n }\n "}, {"sha": "e1889aa555f86d33b155858d796e0df9642362e8", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -26,7 +26,7 @@ use syntax_pos;\n // explored. For example, if it's a live Node::Item that is a\n // function, then we should explore its block to check for codes that\n // may need to be marked as live.\n-fn should_explore<'tcx>(tcx: TyCtxt<'tcx>, hir_id: hir::HirId) -> bool {\n+fn should_explore(tcx: TyCtxt<'_>, hir_id: hir::HirId) -> bool {\n     match tcx.hir().find(hir_id) {\n         Some(Node::Item(..)) |\n         Some(Node::ImplItem(..)) |\n@@ -662,7 +662,7 @@ impl Visitor<'tcx> for DeadVisitor<'tcx> {\n     }\n }\n \n-pub fn check_crate<'tcx>(tcx: TyCtxt<'tcx>) {\n+pub fn check_crate(tcx: TyCtxt<'_>) {\n     let access_levels = &tcx.privacy_access_levels(LOCAL_CRATE);\n     let krate = tcx.hir().krate();\n     let live_symbols = find_live(tcx, access_levels, krate);"}, {"sha": "96b99fe4cdce2c01ca4716a4ba60be190907f59f", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -81,7 +81,7 @@ pub enum Linkage {\n     Dynamic,\n }\n \n-pub fn calculate<'tcx>(tcx: TyCtxt<'tcx>) {\n+pub fn calculate(tcx: TyCtxt<'_>) {\n     let sess = &tcx.sess;\n     let fmts = sess.crate_types.borrow().iter().map(|&ty| {\n         let linkage = calculate_type(tcx, ty);\n@@ -92,7 +92,7 @@ pub fn calculate<'tcx>(tcx: TyCtxt<'tcx>) {\n     sess.dependency_formats.set(fmts);\n }\n \n-fn calculate_type<'tcx>(tcx: TyCtxt<'tcx>, ty: config::CrateType) -> DependencyList {\n+fn calculate_type(tcx: TyCtxt<'_>, ty: config::CrateType) -> DependencyList {\n     let sess = &tcx.sess;\n \n     if !sess.opts.output_types.should_codegen() {\n@@ -267,7 +267,7 @@ fn add_library(\n     }\n }\n \n-fn attempt_static<'tcx>(tcx: TyCtxt<'tcx>) -> Option<DependencyList> {\n+fn attempt_static(tcx: TyCtxt<'_>) -> Option<DependencyList> {\n     let sess = &tcx.sess;\n     let crates = cstore::used_crates(tcx, RequireStatic);\n     if !crates.iter().by_ref().all(|&(_, ref p)| p.is_some()) {\n@@ -324,7 +324,7 @@ fn activate_injected_dep(injected: Option<CrateNum>,\n \n // After the linkage for a crate has been determined we need to verify that\n // there's only going to be one allocator in the output.\n-fn verify_ok<'tcx>(tcx: TyCtxt<'tcx>, list: &[Linkage]) {\n+fn verify_ok(tcx: TyCtxt<'_>, list: &[Linkage]) {\n     let sess = &tcx.sess;\n     if list.len() == 0 {\n         return"}, {"sha": "c93cc847adff22fac64491be68705c8c1b4252b4", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -11,14 +11,14 @@ use self::OverloadedCallType::*;\n \n use crate::hir::def::{CtorOf, Res, DefKind};\n use crate::hir::def_id::DefId;\n+use crate::hir::ptr::P;\n use crate::infer::InferCtxt;\n use crate::middle::mem_categorization as mc;\n use crate::middle::region;\n use crate::ty::{self, DefIdTree, TyCtxt, adjustment};\n \n use crate::hir::{self, PatKind};\n use std::rc::Rc;\n-use syntax::ptr::P;\n use syntax_pos::Span;\n use crate::util::nodemap::ItemLocalSet;\n "}, {"sha": "1cc96c549e7243c943d8629bcfecc3e8f91e76f1", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -10,7 +10,7 @@ use syntax_pos::{Span, sym};\n use crate::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use crate::hir;\n \n-fn check_mod_intrinsics<'tcx>(tcx: TyCtxt<'tcx>, module_def_id: DefId) {\n+fn check_mod_intrinsics(tcx: TyCtxt<'_>, module_def_id: DefId) {\n     tcx.hir().visit_item_likes_in_module(\n         module_def_id,\n         &mut ItemVisitor { tcx }.as_deep_visitor()"}, {"sha": "694b0a986296065b3d005a3d26aa63b5b9ba8f6b", "filename": "src/librustc/middle/lib_features.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fmiddle%2Flib_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fmiddle%2Flib_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flib_features.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -142,7 +142,7 @@ impl Visitor<'tcx> for LibFeatureCollector<'tcx> {\n     }\n }\n \n-pub fn collect<'tcx>(tcx: TyCtxt<'tcx>) -> LibFeatures {\n+pub fn collect(tcx: TyCtxt<'_>) -> LibFeatures {\n     let mut collector = LibFeatureCollector::new(tcx);\n     intravisit::walk_crate(&mut collector, tcx.hir().krate());\n     collector.lib_features"}, {"sha": "30ff835bdcc43c7262081048fed28c6d0769c53b", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -99,6 +99,7 @@ use self::VarKind::*;\n \n use crate::hir::def::*;\n use crate::hir::Node;\n+use crate::hir::ptr::P;\n use crate::ty::{self, TyCtxt};\n use crate::ty::query::Providers;\n use crate::lint;\n@@ -111,7 +112,6 @@ use std::io::prelude::*;\n use std::io;\n use std::rc::Rc;\n use syntax::ast;\n-use syntax::ptr::P;\n use syntax::symbol::{kw, sym};\n use syntax_pos::Span;\n \n@@ -181,7 +181,7 @@ impl<'tcx> Visitor<'tcx> for IrMaps<'tcx> {\n     fn visit_arm(&mut self, a: &'tcx hir::Arm) { visit_arm(self, a); }\n }\n \n-fn check_mod_liveness<'tcx>(tcx: TyCtxt<'tcx>, module_def_id: DefId) {\n+fn check_mod_liveness(tcx: TyCtxt<'_>, module_def_id: DefId) {\n     tcx.hir().visit_item_likes_in_module(\n         module_def_id,\n         &mut IrMaps::new(tcx, module_def_id).as_deep_visitor(),"}, {"sha": "088c862dcb8796974e452f74a733f3f84bf9e717", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -465,9 +465,11 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n     ) -> bool {\n         self.infcx.map(|infcx| infcx.type_is_copy_modulo_regions(param_env, ty, span))\n             .or_else(|| {\n-                self.tcx.lift_to_global(&(param_env, ty)).map(|(param_env, ty)| {\n-                    ty.is_copy_modulo_regions(self.tcx.global_tcx(), param_env, span)\n-                })\n+                if (param_env, ty).has_local_value() {\n+                    None\n+                } else {\n+                    Some(ty.is_copy_modulo_regions(self.tcx, param_env, span))\n+                }\n             })\n             .unwrap_or(true)\n     }"}, {"sha": "6b26be34d75205cfe5e45c394236d65c4c259844", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -42,8 +42,8 @@ fn item_might_be_inlined(tcx: TyCtxt<'tcx>, item: &hir::Item, attrs: CodegenFnAt\n     }\n }\n \n-fn method_might_be_inlined<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+fn method_might_be_inlined(\n+    tcx: TyCtxt<'_>,\n     impl_item: &hir::ImplItem,\n     impl_src: DefId,\n ) -> bool {\n@@ -391,7 +391,7 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a, 'tcx\n #[derive(Clone, HashStable)]\n pub struct ReachableSet(pub Lrc<HirIdSet>);\n \n-fn reachable_set<'tcx>(tcx: TyCtxt<'tcx>, crate_num: CrateNum) -> ReachableSet {\n+fn reachable_set(tcx: TyCtxt<'_>, crate_num: CrateNum) -> ReachableSet {\n     debug_assert!(crate_num == LOCAL_CRATE);\n \n     let access_levels = &tcx.privacy_access_levels(LOCAL_CRATE);"}, {"sha": "f859e835425c435f0bb8002ceb60d24f92175503", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -1375,7 +1375,7 @@ impl<'tcx> Visitor<'tcx> for RegionResolutionVisitor<'tcx> {\n \n         let outer_ec = mem::replace(&mut self.expr_and_pat_count, 0);\n         let outer_cx = self.cx;\n-        let outer_ts = mem::replace(&mut self.terminating_scopes, FxHashSet::default());\n+        let outer_ts = mem::take(&mut self.terminating_scopes);\n         self.terminating_scopes.insert(body.value.hir_id.local_id);\n \n         if let Some(root_id) = self.cx.root_id {\n@@ -1446,7 +1446,7 @@ impl<'tcx> Visitor<'tcx> for RegionResolutionVisitor<'tcx> {\n     }\n }\n \n-fn region_scope_tree<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx ScopeTree {\n+fn region_scope_tree(tcx: TyCtxt<'_>, def_id: DefId) -> &ScopeTree {\n     let closure_base_def_id = tcx.closure_base_def_id(def_id);\n     if closure_base_def_id != def_id {\n         return tcx.region_scope_tree(closure_base_def_id);"}, {"sha": "758f14ebf99a66f96c605dffa36739709cf516f7", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -8,6 +8,7 @@\n use crate::hir::def::{Res, DefKind};\n use crate::hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n use crate::hir::map::Map;\n+use crate::hir::ptr::P;\n use crate::hir::{GenericArg, GenericParam, ItemLocalId, LifetimeName, Node, ParamName};\n use crate::ty::{self, DefIdTree, GenericParamDefKind, TyCtxt};\n \n@@ -18,10 +19,9 @@ use errors::{Applicability, DiagnosticBuilder};\n use rustc_macros::HashStable;\n use std::borrow::Cow;\n use std::cell::Cell;\n-use std::mem::replace;\n+use std::mem::{replace, take};\n use syntax::ast;\n use syntax::attr;\n-use syntax::ptr::P;\n use syntax::symbol::{kw, sym};\n use syntax_pos::Span;\n \n@@ -368,7 +368,7 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n /// entire crate. You should not read the result of this query\n /// directly, but rather use `named_region_map`, `is_late_bound_map`,\n /// etc.\n-fn resolve_lifetimes<'tcx>(tcx: TyCtxt<'tcx>, for_krate: CrateNum) -> &'tcx ResolveLifetimes {\n+fn resolve_lifetimes(tcx: TyCtxt<'_>, for_krate: CrateNum) -> &ResolveLifetimes {\n     assert_eq!(for_krate, LOCAL_CRATE);\n \n     let named_region_map = krate(tcx);\n@@ -395,7 +395,7 @@ fn resolve_lifetimes<'tcx>(tcx: TyCtxt<'tcx>, for_krate: CrateNum) -> &'tcx Reso\n     tcx.arena.alloc(rl)\n }\n \n-fn krate<'tcx>(tcx: TyCtxt<'tcx>) -> NamedRegionMap {\n+fn krate(tcx: TyCtxt<'_>) -> NamedRegionMap {\n     let krate = tcx.hir().krate();\n     let mut map = NamedRegionMap {\n         defs: Default::default(),\n@@ -441,7 +441,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n \n     fn visit_nested_body(&mut self, body: hir::BodyId) {\n         // Each body has their own set of labels, save labels.\n-        let saved = replace(&mut self.labels_in_fn, vec![]);\n+        let saved = take(&mut self.labels_in_fn);\n         let body = self.tcx.hir().body(body);\n         extract_labels(self, body);\n         self.with(\n@@ -1405,9 +1405,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             lifetime_uses,\n             ..\n         } = self;\n-        let labels_in_fn = replace(&mut self.labels_in_fn, vec![]);\n-        let xcrate_object_lifetime_defaults =\n-            replace(&mut self.xcrate_object_lifetime_defaults, DefIdMap::default());\n+        let labels_in_fn = take(&mut self.labels_in_fn);\n+        let xcrate_object_lifetime_defaults = take(&mut self.xcrate_object_lifetime_defaults);\n         let mut this = LifetimeContext {\n             tcx: *tcx,\n             map: map,"}, {"sha": "101563d2d99ef7dde0b73583876a343b6a851cf7", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -466,7 +466,7 @@ impl<'tcx> Index<'tcx> {\n \n /// Cross-references the feature names of unstable APIs with enabled\n /// features and possibly prints errors.\n-fn check_mod_unstable_api_usage<'tcx>(tcx: TyCtxt<'tcx>, module_def_id: DefId) {\n+fn check_mod_unstable_api_usage(tcx: TyCtxt<'_>, module_def_id: DefId) {\n     tcx.hir().visit_item_likes_in_module(module_def_id, &mut Checker { tcx }.as_deep_visitor());\n }\n \n@@ -836,7 +836,7 @@ impl<'tcx> TyCtxt<'tcx> {\n /// Given the list of enabled features that were not language features (i.e., that\n /// were expected to be library features), and the list of features used from\n /// libraries, identify activated features that don't exist and error about them.\n-pub fn check_unused_or_stable_features<'tcx>(tcx: TyCtxt<'tcx>) {\n+pub fn check_unused_or_stable_features(tcx: TyCtxt<'_>) {\n     let access_levels = &tcx.privacy_access_levels(LOCAL_CRATE);\n \n     if tcx.stability().staged_api[&LOCAL_CRATE] {\n@@ -920,8 +920,8 @@ pub fn check_unused_or_stable_features<'tcx>(tcx: TyCtxt<'tcx>) {\n     // don't lint about unused features. We should reenable this one day!\n }\n \n-fn unnecessary_stable_feature_lint<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+fn unnecessary_stable_feature_lint(\n+    tcx: TyCtxt<'_>,\n     span: Span,\n     feature: Symbol,\n     since: Symbol,"}, {"sha": "c8f42b1c604a587b2315e135ae6b51b6eb0d0676", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -18,7 +18,7 @@ use errors::DiagnosticBuilder;\n use syntax_pos::{Pos, Span};\n use syntax::symbol::Symbol;\n \n-#[derive(Debug, Copy, Clone, PartialEq, Eq, HashStable)]\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, HashStable, RustcEncodable, RustcDecodable)]\n pub enum ErrorHandled {\n     /// Already reported a lint or an error for this evaluation.\n     Reported,\n@@ -37,6 +37,10 @@ impl ErrorHandled {\n     }\n }\n \n+CloneTypeFoldableImpls! {\n+    ErrorHandled,\n+}\n+\n pub type ConstEvalRawResult<'tcx> = Result<RawConst<'tcx>, ErrorHandled>;\n pub type ConstEvalResult<'tcx> = Result<&'tcx ty::Const<'tcx>, ErrorHandled>;\n \n@@ -178,7 +182,7 @@ pub fn struct_error<'tcx>(tcx: TyCtxtAt<'tcx>, msg: &str) -> DiagnosticBuilder<'\n /// up with a Rust-level backtrace of where the error occured.\n /// Thsese should always be constructed by calling `.into()` on\n /// a `InterpError`. In `librustc_mir::interpret`, we have the `err!`\n-/// macro for this\n+/// macro for this.\n #[derive(Debug, Clone)]\n pub struct InterpErrorInfo<'tcx> {\n     pub kind: InterpError<'tcx, u64>,"}, {"sha": "59a032d53cfd67991da6d32ac16d5d41707b6597", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -2867,19 +2867,19 @@ impl<'tcx> graph::WithStartNode for Body<'tcx> {\n }\n \n impl<'tcx> graph::WithPredecessors for Body<'tcx> {\n-    fn predecessors<'graph>(\n-        &'graph self,\n+    fn predecessors(\n+        &self,\n         node: Self::Node,\n-    ) -> <Self as GraphPredecessors<'graph>>::Iter {\n+    ) -> <Self as GraphPredecessors<'_>>::Iter {\n         self.predecessors_for(node).clone().into_iter()\n     }\n }\n \n impl<'tcx> graph::WithSuccessors for Body<'tcx> {\n-    fn successors<'graph>(\n-        &'graph self,\n+    fn successors(\n+        &self,\n         node: Self::Node,\n-    ) -> <Self as GraphSuccessors<'graph>>::Iter {\n+    ) -> <Self as GraphSuccessors<'_>>::Iter {\n         self.basic_blocks[node].terminator().successors().cloned()\n     }\n }"}, {"sha": "d2082ab87e738c6acd1ebdbbd27ed17b6781a970", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 40, "deletions": 23, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -2,7 +2,7 @@ use crate::ty::query::QueryDescription;\n use crate::ty::query::queries;\n use crate::ty::{self, ParamEnvAnd, Ty, TyCtxt};\n use crate::ty::subst::SubstsRef;\n-use crate::dep_graph::SerializedDepNodeIndex;\n+use crate::dep_graph::{RecoverKey,DepKind, DepNode, SerializedDepNodeIndex};\n use crate::hir::def_id::{CrateNum, DefId, DefIndex};\n use crate::mir;\n use crate::mir::interpret::GlobalId;\n@@ -33,13 +33,13 @@ rustc_queries! {\n     Other {\n         /// Records the type of every item.\n         query type_of(key: DefId) -> Ty<'tcx> {\n-            cache { key.is_local() }\n+            cache_on_disk_if { key.is_local() }\n         }\n \n         /// Maps from the `DefId` of an item (trait/struct/enum/fn) to its\n         /// associated generics.\n         query generics_of(key: DefId) -> &'tcx ty::Generics {\n-            cache { key.is_local() }\n+            cache_on_disk_if { key.is_local() }\n             load_cached(tcx, id) {\n                 let generics: Option<ty::Generics> = tcx.queries.on_disk_cache\n                                                         .try_load_query_result(tcx, id);\n@@ -62,7 +62,9 @@ rustc_queries! {\n         /// predicate gets in the way of some checks, which are intended\n         /// to operate over only the actual where-clauses written by the\n         /// user.)\n-        query predicates_of(_: DefId) -> &'tcx ty::GenericPredicates<'tcx> {}\n+        query predicates_of(key: DefId) -> &'tcx ty::GenericPredicates<'tcx> {\n+            cache_on_disk_if { key.is_local() }\n+        }\n \n         query native_libraries(_: CrateNum) -> Lrc<Vec<NativeLibrary>> {\n             desc { \"looking up the native libraries of a linked crate\" }\n@@ -93,7 +95,7 @@ rustc_queries! {\n         /// of the MIR qualify_consts pass. The actual meaning of\n         /// the value isn't known except to the pass itself.\n         query mir_const_qualif(key: DefId) -> (u8, &'tcx BitSet<mir::Local>) {\n-            cache { key.is_local() }\n+            cache_on_disk_if { key.is_local() }\n         }\n \n         /// Fetch the MIR for a given `DefId` right after it's built - this includes\n@@ -115,7 +117,7 @@ rustc_queries! {\n         /// MIR after our optimization passes have run. This is MIR that is ready\n         /// for codegen. This is also the only query that can fetch non-local MIR, at present.\n         query optimized_mir(key: DefId) -> &'tcx mir::Body<'tcx> {\n-            cache { key.is_local() }\n+            cache_on_disk_if { key.is_local() }\n             load_cached(tcx, id) {\n                 let mir: Option<crate::mir::Body<'tcx>> = tcx.queries.on_disk_cache\n                                                             .try_load_query_result(tcx, id);\n@@ -285,7 +287,9 @@ rustc_queries! {\n \n     TypeChecking {\n         /// The result of unsafety-checking this `DefId`.\n-        query unsafety_check_result(_: DefId) -> mir::UnsafetyCheckResult {}\n+        query unsafety_check_result(key: DefId) -> mir::UnsafetyCheckResult {\n+            cache_on_disk_if { key.is_local() }\n+        }\n \n         /// HACK: when evaluated, this reports a \"unsafe derive on repr(packed)\" error\n         query unsafe_derive_on_repr_packed(_: DefId) -> () {}\n@@ -348,7 +352,7 @@ rustc_queries! {\n         }\n \n         query typeck_tables_of(key: DefId) -> &'tcx ty::TypeckTables<'tcx> {\n-            cache { key.is_local() }\n+            cache_on_disk_if { key.is_local() }\n             load_cached(tcx, id) {\n                 let typeck_tables: Option<ty::TypeckTables<'tcx>> = tcx\n                     .queries.on_disk_cache\n@@ -360,7 +364,9 @@ rustc_queries! {\n     }\n \n     Other {\n-        query used_trait_imports(_: DefId) -> &'tcx DefIdSet {}\n+        query used_trait_imports(key: DefId) -> &'tcx DefIdSet {\n+            cache_on_disk_if { key.is_local() }\n+        }\n     }\n \n     TypeChecking {\n@@ -372,11 +378,15 @@ rustc_queries! {\n     }\n \n     BorrowChecking {\n-        query borrowck(_: DefId) -> &'tcx BorrowCheckResult {}\n+        query borrowck(key: DefId) -> &'tcx BorrowCheckResult {\n+            cache_on_disk_if { key.is_local() }\n+        }\n \n         /// Borrow-checks the function body. If this is a closure, returns\n         /// additional requirements that the closure's creator must verify.\n-        query mir_borrowck(_: DefId) -> mir::BorrowCheckResult<'tcx> {}\n+        query mir_borrowck(key: DefId) -> mir::BorrowCheckResult<'tcx> {\n+            cache_on_disk_if(tcx, _) { key.is_local() && tcx.is_closure(key) }\n+        }\n     }\n \n     TypeChecking {\n@@ -412,9 +422,10 @@ rustc_queries! {\n                 \"const-evaluating `{}`\",\n                 tcx.def_path_str(key.value.instance.def.def_id())\n             }\n-            cache { true }\n-            load_cached(tcx, id) {\n-                tcx.queries.on_disk_cache.try_load_query_result(tcx, id).map(Ok)\n+            cache_on_disk_if(_, opt_result) {\n+                // Only store results without errors\n+                // FIXME: We never store these\n+                opt_result.map_or(true, |r| r.is_ok())\n             }\n         }\n \n@@ -427,9 +438,9 @@ rustc_queries! {\n                 \"const-evaluating + checking `{}`\",\n                 tcx.def_path_str(key.value.instance.def.def_id())\n             }\n-            cache { true }\n-            load_cached(tcx, id) {\n-                tcx.queries.on_disk_cache.try_load_query_result(tcx, id).map(Ok)\n+            cache_on_disk_if(_, opt_result) {\n+                // Only store results without errors\n+                opt_result.map_or(true, |r| r.is_ok())\n             }\n         }\n \n@@ -453,7 +464,9 @@ rustc_queries! {\n     }\n \n     TypeChecking {\n-        query check_match(_: DefId) -> () {}\n+        query check_match(key: DefId) -> () {\n+            cache_on_disk_if { key.is_local() }\n+        }\n \n         /// Performs part of the privacy check and computes \"access levels\".\n         query privacy_access_levels(_: CrateNum) -> &'tcx AccessLevels {\n@@ -483,7 +496,7 @@ rustc_queries! {\n         query symbol_name(key: ty::Instance<'tcx>) -> ty::SymbolName {\n             no_force\n             desc { \"computing the symbol for `{}`\", key }\n-            cache { true }\n+            cache_on_disk_if { true }\n         }\n \n         query def_kind(_: DefId) -> Option<DefKind> {}\n@@ -501,7 +514,9 @@ rustc_queries! {\n     }\n \n     Codegen {\n-        query codegen_fn_attrs(_: DefId) -> CodegenFnAttrs {}\n+        query codegen_fn_attrs(_: DefId) -> CodegenFnAttrs {\n+            cache_on_disk_if { true }\n+        }\n     }\n \n     Other {\n@@ -519,7 +534,7 @@ rustc_queries! {\n                 \"const checking if rvalue is promotable to static `{}`\",\n                 tcx.def_path_str(key)\n             }\n-            cache { true }\n+            cache_on_disk_if { true }\n         }\n         query rvalue_promotable_map(key: DefId) -> &'tcx ItemLocalSet {\n             desc { |tcx|\n@@ -548,7 +563,7 @@ rustc_queries! {\n             key: (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>)\n         ) -> Vtable<'tcx, ()> {\n             no_force\n-            cache { true }\n+            cache_on_disk_if { true }\n             desc { |tcx|\n                 \"checking if `{}` fulfills its obligations\",\n                 tcx.def_path_str(key.1.def_id())\n@@ -560,7 +575,9 @@ rustc_queries! {\n         query trait_impls_of(key: DefId) -> &'tcx ty::trait_def::TraitImpls {\n             desc { |tcx| \"trait impls of `{}`\", tcx.def_path_str(key) }\n         }\n-        query specialization_graph_of(_: DefId) -> &'tcx specialization_graph::Graph {}\n+        query specialization_graph_of(_: DefId) -> &'tcx specialization_graph::Graph {\n+            cache_on_disk_if { true }\n+        }\n         query is_object_safe(key: DefId) -> bool {\n             desc { |tcx| \"determine object safety of trait `{}`\", tcx.def_path_str(key) }\n         }"}, {"sha": "82c53be3ec70ff15316d2fa9d5f34d9333a23090", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -269,11 +269,11 @@ impl OutputTypes {\n         self.0.contains_key(key)\n     }\n \n-    pub fn keys<'a>(&'a self) -> BTreeMapKeysIter<'a, OutputType, Option<PathBuf>> {\n+    pub fn keys(&self) -> BTreeMapKeysIter<'_, OutputType, Option<PathBuf>> {\n         self.0.keys()\n     }\n \n-    pub fn values<'a>(&'a self) -> BTreeMapValuesIter<'a, OutputType, Option<PathBuf>> {\n+    pub fn values(&self) -> BTreeMapValuesIter<'_, OutputType, Option<PathBuf>> {\n         self.0.values()\n     }\n \n@@ -316,7 +316,7 @@ impl Externs {\n         self.0.get(key)\n     }\n \n-    pub fn iter<'a>(&'a self) -> BTreeMapIter<'a, String, ExternEntry> {\n+    pub fn iter(&self) -> BTreeMapIter<'_, String, ExternEntry> {\n         self.0.iter()\n     }\n }\n@@ -1207,7 +1207,11 @@ options! {CodegenOptions, CodegenSetter, basic_codegen_options,\n     linker_plugin_lto: LinkerPluginLto = (LinkerPluginLto::Disabled,\n         parse_linker_plugin_lto, [TRACKED],\n         \"generate build artifacts that are compatible with linker-based LTO.\"),\n-\n+    profile_generate: SwitchWithOptPath = (SwitchWithOptPath::Disabled,\n+        parse_switch_with_opt_path, [TRACKED],\n+        \"compile the program with profiling instrumentation\"),\n+    profile_use: Option<PathBuf> = (None, parse_opt_pathbuf, [TRACKED],\n+        \"use the given `.profdata` file for profile-guided optimization\"),\n }\n \n options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n@@ -1379,11 +1383,6 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"extra arguments to prepend to the linker invocation (space separated)\"),\n     profile: bool = (false, parse_bool, [TRACKED],\n                      \"insert profiling code\"),\n-    pgo_gen: SwitchWithOptPath = (SwitchWithOptPath::Disabled,\n-        parse_switch_with_opt_path, [TRACKED],\n-        \"Generate PGO profile data, to a given file, or to the default location if it's empty.\"),\n-    pgo_use: Option<PathBuf> = (None, parse_opt_pathbuf, [TRACKED],\n-        \"Use PGO profile data from the given profile file.\"),\n     disable_instrumentation_preinliner: bool = (false, parse_bool, [TRACKED],\n         \"Disable the instrumentation pre-inliner, useful for profiling / PGO.\"),\n     relro_level: Option<RelroLevel> = (None, parse_relro_level, [TRACKED],\n@@ -2036,13 +2035,6 @@ pub fn build_session_options_and_crate_config(\n         }\n     }\n \n-    if debugging_opts.pgo_gen.enabled() && debugging_opts.pgo_use.is_some() {\n-        early_error(\n-            error_format,\n-            \"options `-Z pgo-gen` and `-Z pgo-use` are exclusive\",\n-        );\n-    }\n-\n     let mut output_types = BTreeMap::new();\n     if !debugging_opts.parse_only {\n         for list in matches.opt_strs(\"emit\") {\n@@ -2154,6 +2146,13 @@ pub fn build_session_options_and_crate_config(\n         );\n     }\n \n+    if cg.profile_generate.enabled() && cg.profile_use.is_some() {\n+        early_error(\n+            error_format,\n+            \"options `-C profile-generate` and `-C profile-use` are exclusive\",\n+        );\n+    }\n+\n     let mut prints = Vec::<PrintRequest>::new();\n     if cg.target_cpu.as_ref().map_or(false, |s| s == \"help\") {\n         prints.push(PrintRequest::TargetCPUs);"}, {"sha": "3d6312548a47bcf58b13688c0905092402bbd7fa", "filename": "src/librustc/session/config/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fsession%2Fconfig%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fsession%2Fconfig%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig%2Ftests.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -519,11 +519,11 @@ fn test_codegen_options_tracking_hash() {\n     assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n \n     opts = reference.clone();\n-    opts.debugging_opts.pgo_gen = SwitchWithOptPath::Enabled(None);\n+    opts.cg.profile_generate = SwitchWithOptPath::Enabled(None);\n     assert_ne!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n \n     opts = reference.clone();\n-    opts.debugging_opts.pgo_use = Some(PathBuf::from(\"abc\"));\n+    opts.cg.profile_use = Some(PathBuf::from(\"abc\"));\n     assert_ne!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n \n     opts = reference.clone();"}, {"sha": "3cbf0ee213ae371891821890de7a2086d3e61bc8", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -215,66 +215,66 @@ impl Session {\n         *self.crate_disambiguator.get()\n     }\n \n-    pub fn struct_span_warn<'a, S: Into<MultiSpan>>(\n-        &'a self,\n+    pub fn struct_span_warn<S: Into<MultiSpan>>(\n+        &self,\n         sp: S,\n         msg: &str,\n-    ) -> DiagnosticBuilder<'a> {\n+    ) -> DiagnosticBuilder<'_> {\n         self.diagnostic().struct_span_warn(sp, msg)\n     }\n-    pub fn struct_span_warn_with_code<'a, S: Into<MultiSpan>>(\n-        &'a self,\n+    pub fn struct_span_warn_with_code<S: Into<MultiSpan>>(\n+        &self,\n         sp: S,\n         msg: &str,\n         code: DiagnosticId,\n-    ) -> DiagnosticBuilder<'a> {\n+    ) -> DiagnosticBuilder<'_> {\n         self.diagnostic().struct_span_warn_with_code(sp, msg, code)\n     }\n-    pub fn struct_warn<'a>(&'a self, msg: &str) -> DiagnosticBuilder<'a> {\n+    pub fn struct_warn(&self, msg: &str) -> DiagnosticBuilder<'_> {\n         self.diagnostic().struct_warn(msg)\n     }\n-    pub fn struct_span_err<'a, S: Into<MultiSpan>>(\n-        &'a self,\n+    pub fn struct_span_err<S: Into<MultiSpan>>(\n+        &self,\n         sp: S,\n         msg: &str,\n-    ) -> DiagnosticBuilder<'a> {\n+    ) -> DiagnosticBuilder<'_> {\n         self.diagnostic().struct_span_err(sp, msg)\n     }\n-    pub fn struct_span_err_with_code<'a, S: Into<MultiSpan>>(\n-        &'a self,\n+    pub fn struct_span_err_with_code<S: Into<MultiSpan>>(\n+        &self,\n         sp: S,\n         msg: &str,\n         code: DiagnosticId,\n-    ) -> DiagnosticBuilder<'a> {\n+    ) -> DiagnosticBuilder<'_> {\n         self.diagnostic().struct_span_err_with_code(sp, msg, code)\n     }\n     // FIXME: This method should be removed (every error should have an associated error code).\n-    pub fn struct_err<'a>(&'a self, msg: &str) -> DiagnosticBuilder<'a> {\n+    pub fn struct_err(&self, msg: &str) -> DiagnosticBuilder<'_> {\n         self.diagnostic().struct_err(msg)\n     }\n-    pub fn struct_err_with_code<'a>(\n-        &'a self,\n+    pub fn struct_err_with_code(\n+        &self,\n         msg: &str,\n         code: DiagnosticId,\n-    ) -> DiagnosticBuilder<'a> {\n+    ) -> DiagnosticBuilder<'_> {\n         self.diagnostic().struct_err_with_code(msg, code)\n     }\n-    pub fn struct_span_fatal<'a, S: Into<MultiSpan>>(\n-        &'a self,\n+    pub fn struct_span_fatal<S: Into<MultiSpan>>(\n+        &self,\n         sp: S,\n         msg: &str,\n-    ) -> DiagnosticBuilder<'a> {\n+    ) -> DiagnosticBuilder<'_> {\n         self.diagnostic().struct_span_fatal(sp, msg)\n     }\n-    pub fn struct_span_fatal_with_code<'a, S: Into<MultiSpan>>(\n-        &'a self,\n+    pub fn struct_span_fatal_with_code<S: Into<MultiSpan>>(\n+        &self,\n         sp: S,\n         msg: &str,\n         code: DiagnosticId,\n-    ) -> DiagnosticBuilder<'a> {\n+    ) -> DiagnosticBuilder<'_> {\n         self.diagnostic().struct_span_fatal_with_code(sp, msg, code)\n     }\n-    pub fn struct_fatal<'a>(&'a self, msg: &str) -> DiagnosticBuilder<'a> {\n+    pub fn struct_fatal(&self, msg: &str) -> DiagnosticBuilder<'_> {\n         self.diagnostic().struct_fatal(msg)\n     }\n \n@@ -416,7 +416,7 @@ impl Session {\n     pub fn next_node_id(&self) -> NodeId {\n         self.reserve_node_ids(1)\n     }\n-    pub fn diagnostic<'a>(&'a self) -> &'a errors::Handler {\n+    pub fn diagnostic(&self) -> &errors::Handler {\n         &self.parse_sess.span_diagnostic\n     }\n \n@@ -504,7 +504,7 @@ impl Session {\n         );\n     }\n \n-    pub fn source_map<'a>(&'a self) -> &'a source_map::SourceMap {\n+    pub fn source_map(&self) -> &source_map::SourceMap {\n         self.parse_sess.source_map()\n     }\n     pub fn verbose(&self) -> bool {\n@@ -1295,9 +1295,9 @@ fn validate_commandline_args_with_session_available(sess: &Session) {\n \n     // Make sure that any given profiling data actually exists so LLVM can't\n     // decide to silently skip PGO.\n-    if let Some(ref path) = sess.opts.debugging_opts.pgo_use {\n+    if let Some(ref path) = sess.opts.cg.profile_use {\n         if !path.exists() {\n-            sess.err(&format!(\"File `{}` passed to `-Zpgo-use` does not exist.\",\n+            sess.err(&format!(\"File `{}` passed to `-C profile-use` does not exist.\",\n                               path.display()));\n         }\n     }\n@@ -1306,7 +1306,7 @@ fn validate_commandline_args_with_session_available(sess: &Session) {\n     // an error to combine the two for now. It always runs into an assertions\n     // if LLVM is built with assertions, but without assertions it sometimes\n     // does not crash and will probably generate a corrupted binary.\n-    if sess.opts.debugging_opts.pgo_gen.enabled() &&\n+    if sess.opts.cg.profile_generate.enabled() &&\n        sess.target.target.options.is_like_msvc &&\n        sess.panic_strategy() == PanicStrategy::Unwind {\n         sess.err(\"Profile-guided optimization does not yet work in conjunction \\"}, {"sha": "b6f0addd77107216c344fefa999de768462d56ba", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -48,8 +48,8 @@ pub fn add_placeholder_note(err: &mut errors::DiagnosticBuilder<'_>) {\n /// If there are types that satisfy both impls, invokes `on_overlap`\n /// with a suitably-freshened `ImplHeader` with those types\n /// substituted. Otherwise, invokes `no_overlap`.\n-pub fn overlapping_impls<'tcx, F1, F2, R>(\n-    tcx: TyCtxt<'tcx>,\n+pub fn overlapping_impls<F1, F2, R>(\n+    tcx: TyCtxt<'_>,\n     impl1_def_id: DefId,\n     impl2_def_id: DefId,\n     intercrate_mode: IntercrateMode,\n@@ -247,10 +247,10 @@ pub enum OrphanCheckErr<'tcx> {\n ///\n /// 1. All type parameters in `Self` must be \"covered\" by some local type constructor.\n /// 2. Some local type must appear in `Self`.\n-pub fn orphan_check<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+pub fn orphan_check(\n+    tcx: TyCtxt<'_>,\n     impl_def_id: DefId,\n-) -> Result<(), OrphanCheckErr<'tcx>> {\n+) -> Result<(), OrphanCheckErr<'_>> {\n     debug!(\"orphan_check({:?})\", impl_def_id);\n \n     // We only except this routine to be invoked on implementations"}, {"sha": "d6cc68bcdab468c19c68a709bbcf5fb4457a47ff", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -247,7 +247,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     fn fuzzy_match_tys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n         /// returns the fuzzy category of a given type, or None\n         /// if the type can be equated to any type.\n-        fn type_category<'tcx>(t: Ty<'tcx>) -> Option<u32> {\n+        fn type_category(t: Ty<'_>) -> Option<u32> {\n             match t.sty {\n                 ty::Bool => Some(0),\n                 ty::Char => Some(1),"}, {"sha": "99b5ef3894b9ce02c2c39f396530274a06fbd0c7", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 26, "deletions": 32, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -461,41 +461,35 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n             }\n \n             ty::Predicate::ConstEvaluatable(def_id, substs) => {\n-                match self.selcx.tcx().lift_to_global(&obligation.param_env) {\n-                    None => {\n+                if obligation.param_env.has_local_value() {\n                         ProcessResult::Unchanged\n-                    }\n-                    Some(param_env) => {\n-                        match self.selcx.tcx().lift_to_global(&substs) {\n-                            Some(substs) => {\n-                                let instance = ty::Instance::resolve(\n-                                    self.selcx.tcx().global_tcx(),\n-                                    param_env,\n-                                    def_id,\n-                                    substs,\n-                                );\n-                                if let Some(instance) = instance {\n-                                    let cid = GlobalId {\n-                                        instance,\n-                                        promoted: None,\n-                                    };\n-                                    match self.selcx.tcx().at(obligation.cause.span)\n-                                                          .const_eval(param_env.and(cid)) {\n-                                        Ok(_) => ProcessResult::Changed(vec![]),\n-                                        Err(err) => ProcessResult::Error(\n-                                            CodeSelectionError(ConstEvalFailure(err)))\n-                                    }\n-                                } else {\n-                                    ProcessResult::Error(CodeSelectionError(\n-                                        ConstEvalFailure(ErrorHandled::TooGeneric)\n-                                    ))\n-                                }\n-                            },\n-                            None => {\n-                                pending_obligation.stalled_on = substs.types().collect();\n-                                ProcessResult::Unchanged\n+                } else {\n+                    if !substs.has_local_value() {\n+                        let instance = ty::Instance::resolve(\n+                            self.selcx.tcx().global_tcx(),\n+                            obligation.param_env,\n+                            def_id,\n+                            substs,\n+                        );\n+                        if let Some(instance) = instance {\n+                            let cid = GlobalId {\n+                                instance,\n+                                promoted: None,\n+                            };\n+                            match self.selcx.tcx().at(obligation.cause.span)\n+                                                    .const_eval(obligation.param_env.and(cid)) {\n+                                Ok(_) => ProcessResult::Changed(vec![]),\n+                                Err(err) => ProcessResult::Error(\n+                                    CodeSelectionError(ConstEvalFailure(err)))\n                             }\n+                        } else {\n+                            ProcessResult::Error(CodeSelectionError(\n+                                ConstEvalFailure(ErrorHandled::TooGeneric)\n+                            ))\n                         }\n+                    } else {\n+                        pending_obligation.stalled_on = substs.types().collect();\n+                        ProcessResult::Unchanged\n                     }\n                 }\n             }"}, {"sha": "1ca92d79fa5f66bc5293cfd6dd2b7fd89e9e1fe9", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -457,6 +457,16 @@ pub enum SelectionError<'tcx> {\n     Overflow,\n }\n \n+EnumTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for SelectionError<'tcx> {\n+        (SelectionError::Unimplemented),\n+        (SelectionError::OutputTypeParameterMismatch)(a, b, c),\n+        (SelectionError::TraitNotObjectSafe)(a),\n+        (SelectionError::ConstEvalFailure)(a),\n+        (SelectionError::Overflow),\n+    }\n+}\n+\n pub struct FulfillmentError<'tcx> {\n     pub obligation: PredicateObligation<'tcx>,\n     pub code: FulfillmentErrorCode<'tcx>\n@@ -782,13 +792,11 @@ fn do_normalize_predicates<'tcx>(\n                 return Err(ErrorReported)\n             }\n         };\n-\n-        match tcx.lift_to_global(&predicates) {\n-            Some(predicates) => Ok(predicates),\n-            None => {\n-                // FIXME: shouldn't we, you know, actually report an error here? or an ICE?\n-                Err(ErrorReported)\n-            }\n+        if predicates.has_local_value() {\n+            // FIXME: shouldn't we, you know, actually report an error here? or an ICE?\n+            Err(ErrorReported)\n+        } else {\n+            Ok(predicates)\n         }\n     })\n }"}, {"sha": "37eff852abd01de8b5c485e7fcc4be4cb7c50cdc", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -702,6 +702,6 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n }\n \n-pub(super) fn is_object_safe_provider<'tcx>(tcx: TyCtxt<'tcx>, trait_def_id: DefId) -> bool {\n+pub(super) fn is_object_safe_provider(tcx: TyCtxt<'_>, trait_def_id: DefId) -> bool {\n     tcx.object_safety_violations(trait_def_id).is_empty()\n }"}, {"sha": "20acf443406908baccd56ddeec2db744e3e73d18", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -399,7 +399,8 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n     fn fold_const(&mut self, constant: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n         if let ConstValue::Unevaluated(def_id, substs) = constant.val {\n             let tcx = self.selcx.tcx().global_tcx();\n-            if let Some(param_env) = self.tcx().lift_to_global(&self.param_env) {\n+            let param_env = self.param_env;\n+            if !param_env.has_local_value() {\n                 if substs.needs_infer() || substs.has_placeholders() {\n                     let identity_substs = InternalSubsts::identity_for_item(tcx, def_id);\n                     let instance = ty::Instance::resolve(tcx, param_env, def_id, identity_substs);\n@@ -414,7 +415,7 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n                         }\n                     }\n                 } else {\n-                    if let Some(substs) = self.tcx().lift_to_global(&substs) {\n+                    if !substs.has_local_value() {\n                         let instance = ty::Instance::resolve(tcx, param_env, def_id, substs);\n                         if let Some(instance) = instance {\n                             let cid = GlobalId {\n@@ -1508,8 +1509,8 @@ fn confirm_impl_candidate<'cx, 'tcx>(\n ///\n /// Based on the \"projection mode\", this lookup may in fact only examine the\n /// topmost impl. See the comments for `Reveal` for more details.\n-fn assoc_ty_def<'cx, 'tcx>(\n-    selcx: &SelectionContext<'cx, 'tcx>,\n+fn assoc_ty_def(\n+    selcx: &SelectionContext<'_, '_>,\n     impl_def_id: DefId,\n     assoc_ty_def_id: DefId,\n ) -> specialization_graph::NodeItem<ty::AssocItem> {"}, {"sha": "55e622e46b966f80aec79911845b13fbd80f2bd7", "filename": "src/librustc/traits/query/normalize.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -193,7 +193,8 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n     fn fold_const(&mut self, constant: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n         if let ConstValue::Unevaluated(def_id, substs) = constant.val {\n             let tcx = self.infcx.tcx.global_tcx();\n-            if let Some(param_env) = self.tcx().lift_to_global(&self.param_env) {\n+            let param_env = self.param_env;\n+            if !param_env.has_local_value() {\n                 if substs.needs_infer() || substs.has_placeholders() {\n                     let identity_substs = InternalSubsts::identity_for_item(tcx, def_id);\n                     let instance = ty::Instance::resolve(tcx, param_env, def_id, identity_substs);\n@@ -208,7 +209,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n                         }\n                     }\n                 } else {\n-                    if let Some(substs) = self.tcx().lift_to_global(&substs) {\n+                    if !substs.has_local_value() {\n                         let instance = ty::Instance::resolve(tcx, param_env, def_id, substs);\n                         if let Some(instance) = instance {\n                             let cid = GlobalId {"}, {"sha": "a2a5f3f950c7ac022186769fc0406f77f558d654", "filename": "src/librustc/traits/query/type_op/custom.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -3,7 +3,7 @@ use std::fmt;\n use crate::traits::query::Fallible;\n \n use crate::infer::canonical::query_response;\n-use crate::infer::canonical::QueryRegionConstraint;\n+use crate::infer::canonical::QueryRegionConstraints;\n use std::rc::Rc;\n use syntax::source_map::DUMMY_SP;\n use crate::traits::{ObligationCause, TraitEngine, TraitEngineExt};\n@@ -39,7 +39,7 @@ where\n     fn fully_perform(\n         self,\n         infcx: &InferCtxt<'_, 'tcx>,\n-    ) -> Fallible<(Self::Output, Option<Rc<Vec<QueryRegionConstraint<'tcx>>>>)> {\n+    ) -> Fallible<(Self::Output, Option<Rc<QueryRegionConstraints<'tcx>>>)> {\n         if cfg!(debug_assertions) {\n             info!(\"fully_perform({:?})\", self);\n         }\n@@ -62,7 +62,7 @@ where\n fn scrape_region_constraints<'tcx, R>(\n     infcx: &InferCtxt<'_, 'tcx>,\n     op: impl FnOnce() -> Fallible<InferOk<'tcx, R>>,\n-) -> Fallible<(R, Option<Rc<Vec<QueryRegionConstraint<'tcx>>>>)> {\n+) -> Fallible<(R, Option<Rc<QueryRegionConstraints<'tcx>>>)> {\n     let mut fulfill_cx = TraitEngine::new(infcx.tcx);\n     let dummy_body_id = ObligationCause::dummy().body_id;\n \n@@ -92,7 +92,7 @@ fn scrape_region_constraints<'tcx, R>(\n \n     let region_constraint_data = infcx.take_and_reset_region_constraints();\n \n-    let outlives = query_response::make_query_outlives(\n+    let region_constraints = query_response::make_query_region_constraints(\n         infcx.tcx,\n         region_obligations\n             .iter()\n@@ -101,9 +101,9 @@ fn scrape_region_constraints<'tcx, R>(\n         &region_constraint_data,\n     );\n \n-    if outlives.is_empty() {\n+    if region_constraints.is_empty() {\n         Ok((value, None))\n     } else {\n-        Ok((value, Some(Rc::new(outlives))))\n+        Ok((value, Some(Rc::new(region_constraints))))\n     }\n }"}, {"sha": "e2a5cd9670e0c50d889eb56a733c089e092aeb1a", "filename": "src/librustc/traits/query/type_op/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -1,6 +1,6 @@\n use crate::infer::canonical::{\n     Canonical, Canonicalized, CanonicalizedQueryResponse, OriginalQueryValues,\n-    QueryRegionConstraint, QueryResponse,\n+    QueryRegionConstraints, QueryResponse,\n };\n use crate::infer::{InferCtxt, InferOk};\n use std::fmt;\n@@ -32,7 +32,7 @@ pub trait TypeOp<'tcx>: Sized + fmt::Debug {\n     fn fully_perform(\n         self,\n         infcx: &InferCtxt<'_, 'tcx>,\n-    ) -> Fallible<(Self::Output, Option<Rc<Vec<QueryRegionConstraint<'tcx>>>>)>;\n+    ) -> Fallible<(Self::Output, Option<Rc<QueryRegionConstraints<'tcx>>>)>;\n }\n \n /// \"Query type ops\" are type ops that are implemented using a\n@@ -85,7 +85,7 @@ pub trait QueryTypeOp<'tcx>: fmt::Debug + Sized + TypeFoldable<'tcx> + 'tcx {\n     fn fully_perform_into(\n         query_key: ParamEnvAnd<'tcx, Self>,\n         infcx: &InferCtxt<'_, 'tcx>,\n-        output_query_region_constraints: &mut Vec<QueryRegionConstraint<'tcx>>,\n+        output_query_region_constraints: &mut QueryRegionConstraints<'tcx>,\n     ) -> Fallible<Self::QueryResponse> {\n         if let Some(result) = QueryTypeOp::try_fast_path(infcx.tcx, &query_key) {\n             return Ok(result);\n@@ -140,16 +140,16 @@ where\n     fn fully_perform(\n         self,\n         infcx: &InferCtxt<'_, 'tcx>,\n-    ) -> Fallible<(Self::Output, Option<Rc<Vec<QueryRegionConstraint<'tcx>>>>)> {\n-        let mut qrc = vec![];\n-        let r = Q::fully_perform_into(self, infcx, &mut qrc)?;\n+    ) -> Fallible<(Self::Output, Option<Rc<QueryRegionConstraints<'tcx>>>)> {\n+        let mut region_constraints = QueryRegionConstraints::default();\n+        let r = Q::fully_perform_into(self, infcx, &mut region_constraints)?;\n \n         // Promote the final query-region-constraints into a\n         // (optional) ref-counted vector:\n-        let opt_qrc = if qrc.is_empty() {\n+        let opt_qrc = if region_constraints.is_empty() {\n             None\n         } else {\n-            Some(Rc::new(qrc))\n+            Some(Rc::new(region_constraints))\n         };\n \n         Ok((r, opt_qrc))"}, {"sha": "798a25fe7b1bc0d7be18935c9b0f21b574929bf3", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 37, "deletions": 22, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -328,6 +328,23 @@ impl<'a, 'tcx> ty::Lift<'tcx> for SelectionCandidate<'a> {\n     }\n }\n \n+EnumTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for SelectionCandidate<'tcx> {\n+        (SelectionCandidate::BuiltinCandidate) { has_nested },\n+        (SelectionCandidate::ParamCandidate)(poly_trait_ref),\n+        (SelectionCandidate::ImplCandidate)(def_id),\n+        (SelectionCandidate::AutoImplCandidate)(def_id),\n+        (SelectionCandidate::ProjectionCandidate),\n+        (SelectionCandidate::ClosureCandidate),\n+        (SelectionCandidate::GeneratorCandidate),\n+        (SelectionCandidate::FnPointerCandidate),\n+        (SelectionCandidate::TraitAliasCandidate)(def_id),\n+        (SelectionCandidate::ObjectCandidate),\n+        (SelectionCandidate::BuiltinObjectCandidate),\n+        (SelectionCandidate::BuiltinUnsizeCandidate),\n+    }\n+}\n+\n struct SelectionCandidateSet<'tcx> {\n     // a list of candidates that definitely apply to the current\n     // obligation (meaning: types unify).\n@@ -818,27 +835,25 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n             ty::Predicate::ConstEvaluatable(def_id, substs) => {\n                 let tcx = self.tcx();\n-                match tcx.lift_to_global(&(obligation.param_env, substs)) {\n-                    Some((param_env, substs)) => {\n-                        let instance =\n-                            ty::Instance::resolve(tcx.global_tcx(), param_env, def_id, substs);\n-                        if let Some(instance) = instance {\n-                            let cid = GlobalId {\n-                                instance,\n-                                promoted: None,\n-                            };\n-                            match self.tcx().const_eval(param_env.and(cid)) {\n-                                Ok(_) => Ok(EvaluatedToOk),\n-                                Err(_) => Ok(EvaluatedToErr),\n-                            }\n-                        } else {\n-                            Ok(EvaluatedToErr)\n+                if !(obligation.param_env, substs).has_local_value() {\n+                    let param_env = obligation.param_env;\n+                    let instance =\n+                        ty::Instance::resolve(tcx, param_env, def_id, substs);\n+                    if let Some(instance) = instance {\n+                        let cid = GlobalId {\n+                            instance,\n+                            promoted: None,\n+                        };\n+                        match self.tcx().const_eval(param_env.and(cid)) {\n+                            Ok(_) => Ok(EvaluatedToOk),\n+                            Err(_) => Ok(EvaluatedToErr),\n                         }\n+                    } else {\n+                        Ok(EvaluatedToErr)\n                     }\n-                    None => {\n-                        // Inference variables still left in param_env or substs.\n-                        Ok(EvaluatedToAmbig)\n-                    }\n+                } else {\n+                    // Inference variables still left in param_env or substs.\n+                    Ok(EvaluatedToAmbig)\n                 }\n             }\n         }\n@@ -1172,7 +1187,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n \n         if self.can_use_global_caches(param_env) {\n-            if let Some(trait_ref) = self.tcx().lift_to_global(&trait_ref) {\n+            if !trait_ref.has_local_value() {\n                 debug!(\n                     \"insert_evaluation_cache(trait_ref={:?}, candidate={:?}) global\",\n                     trait_ref, result,\n@@ -1645,8 +1660,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             if let Err(Overflow) = candidate {\n                 // Don't cache overflow globally; we only produce this\n                 // in certain modes.\n-            } else if let Some(trait_ref) = tcx.lift_to_global(&trait_ref) {\n-                if let Some(candidate) = tcx.lift_to_global(&candidate) {\n+            } else if !trait_ref.has_local_value() {\n+                if !candidate.has_local_value() {\n                     debug!(\n                         \"insert_candidate_cache(trait_ref={:?}, candidate={:?}) global\",\n                         trait_ref, candidate,"}, {"sha": "f0389bb037ac5b827aeb4e1e5bcc8e07f1d29d5a", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -145,8 +145,8 @@ pub fn find_associated_item<'tcx>(\n /// Specialization is determined by the sets of types to which the impls apply;\n /// `impl1` specializes `impl2` if it applies to a subset of the types `impl2` applies\n /// to.\n-pub(super) fn specializes<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+pub(super) fn specializes(\n+    tcx: TyCtxt<'_>,\n     (impl1_def_id, impl2_def_id): (DefId, DefId),\n ) -> bool {\n     debug!(\"specializes({:?}, {:?})\", impl1_def_id, impl2_def_id);\n@@ -282,10 +282,10 @@ fn fulfill_implication<'a, 'tcx>(\n }\n \n // Query provider for `specialization_graph_of`.\n-pub(super) fn specialization_graph_provider<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+pub(super) fn specialization_graph_provider(\n+    tcx: TyCtxt<'_>,\n     trait_id: DefId,\n-) -> &'tcx specialization_graph::Graph {\n+) -> &specialization_graph::Graph {\n     let mut sg = specialization_graph::Graph::new();\n \n     let mut trait_impls = tcx.all_impls(trait_id);"}, {"sha": "07d6f633143a2c29b8b99e76ca0a55ef2cd062e7", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -417,7 +417,7 @@ pub struct SupertraitDefIds<'tcx> {\n     visited: FxHashSet<DefId>,\n }\n \n-pub fn supertrait_def_ids<'tcx>(tcx: TyCtxt<'tcx>, trait_def_id: DefId) -> SupertraitDefIds<'tcx> {\n+pub fn supertrait_def_ids(tcx: TyCtxt<'_>, trait_def_id: DefId) -> SupertraitDefIds<'_> {\n     SupertraitDefIds {\n         tcx,\n         stack: vec![trait_def_id],"}, {"sha": "3dd1fd100f2a4658a476818a7629654a8352bc5e", "filename": "src/librustc/ty/erase_regions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fty%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fty%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferase_regions.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -42,10 +42,10 @@ impl TypeFolder<'tcx> for RegionEraserVisitor<'tcx> {\n     }\n \n     fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        if let Some(ty_lifted) = self.tcx.lift_to_global(&ty) {\n-            self.tcx.erase_regions_ty(ty_lifted)\n-        } else {\n+        if ty.has_local_value() {\n             ty.super_fold_with(self)\n+        } else {\n+            self.tcx.erase_regions_ty(ty)\n         }\n     }\n "}, {"sha": "ab7df8e4e845b25a045880068e17c814766ba154", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -91,6 +91,9 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n     fn has_infer_types(&self) -> bool {\n         self.has_type_flags(TypeFlags::HAS_TY_INFER)\n     }\n+    fn has_local_value(&self) -> bool {\n+        self.has_type_flags(TypeFlags::KEEP_IN_LOCAL_TCX)\n+    }\n     fn needs_infer(&self) -> bool {\n         self.has_type_flags(\n             TypeFlags::HAS_TY_INFER | TypeFlags::HAS_RE_INFER | TypeFlags::HAS_CT_INFER\n@@ -922,6 +925,7 @@ impl<'tcx> TypeVisitor<'tcx> for HasEscapingVarsVisitor {\n     }\n }\n \n+// FIXME: Optimize for checking for infer flags\n struct HasTypeFlagsVisitor {\n     flags: ty::TypeFlags,\n }"}, {"sha": "b921272856e28b6de951dcfcf8416ac33af6776c", "filename": "src/librustc/ty/query/config.rs", "status": "modified", "additions": 7, "deletions": 32, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -1,5 +1,5 @@\n use crate::dep_graph::SerializedDepNodeIndex;\n-use crate::dep_graph::DepNode;\n+use crate::dep_graph::{DepKind, DepNode};\n use crate::hir::def_id::{CrateNum, DefId};\n use crate::ty::TyCtxt;\n use crate::ty::query::queries;\n@@ -28,13 +28,18 @@ pub trait QueryConfig<'tcx> {\n }\n \n pub(crate) trait QueryAccessors<'tcx>: QueryConfig<'tcx> {\n+    const ANON: bool;\n+    const EVAL_ALWAYS: bool;\n+\n     fn query(key: Self::Key) -> Query<'tcx>;\n \n     // Don't use this method to access query results, instead use the methods on TyCtxt\n     fn query_cache<'a>(tcx: TyCtxt<'tcx>) -> &'a Lock<QueryCache<'tcx, Self>>;\n \n     fn to_dep_node(tcx: TyCtxt<'tcx>, key: &Self::Key) -> DepNode;\n \n+    fn dep_kind() -> DepKind;\n+\n     // Don't use this method to compute query results, instead use the methods on TyCtxt\n     fn compute(tcx: TyCtxt<'tcx>, key: Self::Key) -> Self::Value;\n \n@@ -50,7 +55,7 @@ pub(crate) trait QueryDescription<'tcx>: QueryAccessors<'tcx> {\n     fn describe(tcx: TyCtxt<'_>, key: Self::Key) -> Cow<'static, str>;\n \n     #[inline]\n-    fn cache_on_disk(_: TyCtxt<'tcx>, _: Self::Key) -> bool {\n+    fn cache_on_disk(_: TyCtxt<'tcx>, _: Self::Key, _: Option<&Self::Value>) -> bool {\n         false\n     }\n \n@@ -75,33 +80,3 @@ impl<'tcx> QueryDescription<'tcx> for queries::analysis<'tcx> {\n         \"running analysis passes on this crate\".into()\n     }\n }\n-\n-macro_rules! impl_disk_cacheable_query(\n-    ($query_name:ident, |$tcx:tt, $key:tt| $cond:expr) => {\n-        impl<'tcx> QueryDescription<'tcx> for queries::$query_name<'tcx> {\n-            #[inline]\n-            fn cache_on_disk($tcx: TyCtxt<'tcx>, $key: Self::Key) -> bool {\n-                $cond\n-            }\n-\n-            #[inline]\n-            fn try_load_from_disk(tcx: TyCtxt<'tcx>,\n-                                      id: SerializedDepNodeIndex)\n-                                      -> Option<Self::Value> {\n-                tcx.queries.on_disk_cache.try_load_query_result(tcx, id)\n-            }\n-        }\n-    }\n-);\n-\n-impl_disk_cacheable_query!(mir_borrowck, |tcx, def_id| {\n-    def_id.is_local() && tcx.is_closure(def_id)\n-});\n-\n-impl_disk_cacheable_query!(unsafety_check_result, |_, def_id| def_id.is_local());\n-impl_disk_cacheable_query!(borrowck, |_, def_id| def_id.is_local());\n-impl_disk_cacheable_query!(check_match, |_, def_id| def_id.is_local());\n-impl_disk_cacheable_query!(predicates_of, |_, def_id| def_id.is_local());\n-impl_disk_cacheable_query!(used_trait_imports, |_, def_id| def_id.is_local());\n-impl_disk_cacheable_query!(codegen_fn_attrs, |_, _| true);\n-impl_disk_cacheable_query!(specialization_graph_of, |_, _| true);"}, {"sha": "e788628bc58e23e903828d82bd4fe81a0a8a120f", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -101,6 +101,6 @@ pub use self::on_disk_cache::OnDiskCache;\n rustc_query_append! { [define_queries!][ <'tcx>\n     Other {\n         /// Runs analysis passes on the crate.\n-        [] fn analysis: Analysis(CrateNum) -> Result<(), ErrorReported>,\n+        [eval_always] fn analysis: Analysis(CrateNum) -> Result<(), ErrorReported>,\n     },\n ]}"}, {"sha": "85153f99b191711eed055fe959d95e2aec3be28d", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 7, "deletions": 25, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -221,26 +221,8 @@ impl<'sess> OnDiskCache<'sess> {\n                 encode_query_results::<check_match<'_>, _>(tcx, enc, qri)?;\n                 encode_query_results::<codegen_fn_attrs<'_>, _>(tcx, enc, qri)?;\n                 encode_query_results::<specialization_graph_of<'_>, _>(tcx, enc, qri)?;\n-\n-                // const eval is special, it only encodes successfully evaluated constants\n-                use crate::ty::query::QueryAccessors;\n-                let cache = const_eval::query_cache(tcx).borrow();\n-                assert!(cache.active.is_empty());\n-                for (key, entry) in cache.results.iter() {\n-                    use crate::ty::query::config::QueryDescription;\n-                    if const_eval::cache_on_disk(tcx, key.clone()) {\n-                        if let Ok(ref value) = entry.value {\n-                            let dep_node = SerializedDepNodeIndex::new(entry.index.index());\n-\n-                            // Record position of the cache entry\n-                            qri.push((dep_node, AbsoluteBytePos::new(enc.position())));\n-\n-                            // Encode the type check tables with the SerializedDepNodeIndex\n-                            // as tag.\n-                            enc.encode_tagged(dep_node, value)?;\n-                        }\n-                    }\n-                }\n+                encode_query_results::<const_eval<'_>, _>(tcx, enc, qri)?;\n+                // FIXME: Include const_eval_raw?\n \n                 Ok(())\n             })?;\n@@ -324,9 +306,9 @@ impl<'sess> OnDiskCache<'sess> {\n     }\n \n     /// Loads a diagnostic emitted during the previous compilation session.\n-    pub fn load_diagnostics<'tcx>(\n+    pub fn load_diagnostics(\n         &self,\n-        tcx: TyCtxt<'tcx>,\n+        tcx: TyCtxt<'_>,\n         dep_node_index: SerializedDepNodeIndex,\n     ) -> Vec<Diagnostic> {\n         let diagnostics: Option<EncodedDiagnostics> = self.load_indexed(\n@@ -353,9 +335,9 @@ impl<'sess> OnDiskCache<'sess> {\n \n     /// Returns the cached query result if there is something in the cache for\n     /// the given `SerializedDepNodeIndex`; otherwise returns `None`.\n-    pub fn try_load_query_result<'tcx, T>(\n+    pub fn try_load_query_result<T>(\n         &self,\n-        tcx: TyCtxt<'tcx>,\n+        tcx: TyCtxt<'_>,\n         dep_node_index: SerializedDepNodeIndex,\n     ) -> Option<T>\n     where\n@@ -1090,7 +1072,7 @@ where\n         let map = Q::query_cache(tcx).borrow();\n         assert!(map.active.is_empty());\n         for (key, entry) in map.results.iter() {\n-            if Q::cache_on_disk(tcx, key.clone()) {\n+            if Q::cache_on_disk(tcx, key.clone(), Some(&entry.value)) {\n                 let dep_node = SerializedDepNodeIndex::new(entry.index.index());\n \n                 // Record position of the cache entry"}, {"sha": "0c9e31e1ff28e9c7b8bd87167e13f701dfcd7900", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 47, "deletions": 77, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -376,15 +376,13 @@ impl<'tcx> TyCtxt<'tcx> {\n             return self.force_query_with_job::<Q>(key, job, null_dep_node).0;\n         }\n \n-        let dep_node = Q::to_dep_node(self, &key);\n-\n-        if dep_node.kind.is_anon() {\n+        if Q::ANON {\n             profq_msg!(self, ProfileQueriesMsg::ProviderBegin);\n             self.sess.profiler(|p| p.start_query(Q::NAME));\n \n             let ((result, dep_node_index), diagnostics) = with_diagnostics(|diagnostics| {\n                 self.start_query(job.job.clone(), diagnostics, |tcx| {\n-                    tcx.dep_graph.with_anon_task(dep_node.kind, || {\n+                    tcx.dep_graph.with_anon_task(Q::dep_kind(), || {\n                         Q::compute(tcx.global_tcx(), key)\n                     })\n                 })\n@@ -405,7 +403,9 @@ impl<'tcx> TyCtxt<'tcx> {\n             return result;\n         }\n \n-        if !dep_node.kind.is_eval_always() {\n+        let dep_node = Q::to_dep_node(self, &key);\n+\n+        if !Q::EVAL_ALWAYS {\n             // The diagnostics for this query will be\n             // promoted to the current session during\n             // try_mark_green(), so we can ignore them here.\n@@ -444,7 +444,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         debug_assert!(self.dep_graph.is_green(dep_node));\n \n         // First we try to load the result from the on-disk cache\n-        let result = if Q::cache_on_disk(self.global_tcx(), key.clone()) &&\n+        let result = if Q::cache_on_disk(self.global_tcx(), key.clone(), None) &&\n                         self.sess.opts.debugging_opts.incremental_queries {\n             self.sess.profiler(|p| p.incremental_load_result_start(Q::NAME));\n             let result = Q::try_load_from_disk(self.global_tcx(), prev_dep_node_index);\n@@ -546,7 +546,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n         let ((result, dep_node_index), diagnostics) = with_diagnostics(|diagnostics| {\n             self.start_query(job.job.clone(), diagnostics, |tcx| {\n-                if dep_node.kind.is_eval_always() {\n+                if Q::EVAL_ALWAYS {\n                     tcx.dep_graph.with_eval_always_task(dep_node,\n                                                         tcx,\n                                                         key,\n@@ -569,8 +569,8 @@ impl<'tcx> TyCtxt<'tcx> {\n             self.dep_graph.mark_loaded_from_cache(dep_node_index, false);\n         }\n \n-        if dep_node.kind != crate::dep_graph::DepKind::Null {\n-            if unlikely!(!diagnostics.is_empty()) {\n+        if unlikely!(!diagnostics.is_empty()) {\n+            if dep_node.kind != crate::dep_graph::DepKind::Null {\n                 self.queries.on_disk_cache\n                     .store_diagnostics(dep_node_index, diagnostics);\n             }\n@@ -589,15 +589,16 @@ impl<'tcx> TyCtxt<'tcx> {\n     ///\n     /// Note: The optimization is only available during incr. comp.\n     pub(super) fn ensure_query<Q: QueryDescription<'tcx>>(self, key: Q::Key) -> () {\n-        let dep_node = Q::to_dep_node(self, &key);\n-\n-        if dep_node.kind.is_eval_always() {\n+        if Q::EVAL_ALWAYS {\n             let _ = self.get_query::<Q>(DUMMY_SP, key);\n             return;\n         }\n \n         // Ensuring an anonymous query makes no sense\n-        assert!(!dep_node.kind.is_anon());\n+        assert!(!Q::ANON);\n+\n+        let dep_node = Q::to_dep_node(self, &key);\n+\n         if self.dep_graph.try_mark_green_and_read(self, &dep_node).is_none() {\n             // A None return from `try_mark_green_and_read` means that this is either\n             // a new dep node or that the dep node has already been marked red.\n@@ -653,6 +654,30 @@ macro_rules! handle_cycle_error {\n     };\n }\n \n+macro_rules! is_anon {\n+    ([]) => {{\n+        false\n+    }};\n+    ([anon$(, $modifiers:ident)*]) => {{\n+        true\n+    }};\n+    ([$other:ident$(, $modifiers:ident)*]) => {\n+        is_anon!([$($modifiers),*])\n+    };\n+}\n+\n+macro_rules! is_eval_always {\n+    ([]) => {{\n+        false\n+    }};\n+    ([eval_always$(, $modifiers:ident)*]) => {{\n+        true\n+    }};\n+    ([$other:ident$(, $modifiers:ident)*]) => {\n+        is_eval_always!([$($modifiers),*])\n+    };\n+}\n+\n macro_rules! hash_result {\n     ([][$hcx:expr, $result:expr]) => {{\n         dep_graph::hash_result($hcx, &$result)\n@@ -933,6 +958,9 @@ macro_rules! define_queries_inner {\n         }\n \n         impl<$tcx> QueryAccessors<$tcx> for queries::$name<$tcx> {\n+            const ANON: bool = is_anon!([$($modifiers)*]);\n+            const EVAL_ALWAYS: bool = is_eval_always!([$($modifiers)*]);\n+\n             #[inline(always)]\n             fn query(key: Self::Key) -> Query<'tcx> {\n                 Query::$name(key)\n@@ -951,6 +979,11 @@ macro_rules! define_queries_inner {\n                 DepNode::new(tcx, $node(*key))\n             }\n \n+            #[inline(always)]\n+            fn dep_kind() -> dep_graph::DepKind {\n+                dep_graph::DepKind::$node\n+            }\n+\n             #[inline]\n             fn compute(tcx: TyCtxt<'tcx>, key: Self::Key) -> Self::Value {\n                 __query_compute::$name(move || {\n@@ -1133,7 +1166,7 @@ macro_rules! define_provider_struct {\n /// then `force_from_dep_node()` should not fail for it. Otherwise, you can just\n /// add it to the \"We don't have enough information to reconstruct...\" group in\n /// the match below.\n-pub fn force_from_dep_node<'tcx>(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> bool {\n+pub fn force_from_dep_node(tcx: TyCtxt<'_>, dep_node: &DepNode) -> bool {\n     use crate::dep_graph::RecoverKey;\n \n     // We must avoid ever having to call force_from_dep_node() for a\n@@ -1210,66 +1243,3 @@ pub fn force_from_dep_node<'tcx>(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> bool\n \n     true\n }\n-\n-\n-// FIXME(#45015): Another piece of boilerplate code that could be generated in\n-//                a combined define_dep_nodes!()/define_queries!() macro.\n-macro_rules! impl_load_from_cache {\n-    ($($dep_kind:ident => $query_name:ident,)*) => {\n-        impl DepNode {\n-            // Check whether the query invocation corresponding to the given\n-            // DepNode is eligible for on-disk-caching.\n-            pub fn cache_on_disk(&self, tcx: TyCtxt<'_>) -> bool {\n-                use crate::ty::query::queries;\n-                use crate::ty::query::QueryDescription;\n-\n-                match self.kind {\n-                    $(DepKind::$dep_kind => {\n-                        let def_id = self.extract_def_id(tcx).unwrap();\n-                        queries::$query_name::cache_on_disk(tcx.global_tcx(), def_id)\n-                    })*\n-                    _ => false\n-                }\n-            }\n-\n-            // This is method will execute the query corresponding to the given\n-            // DepNode. It is only expected to work for DepNodes where the\n-            // above `cache_on_disk` methods returns true.\n-            // Also, as a sanity check, it expects that the corresponding query\n-            // invocation has been marked as green already.\n-            pub fn load_from_on_disk_cache(&self, tcx: TyCtxt<'_>) {\n-                match self.kind {\n-                    $(DepKind::$dep_kind => {\n-                        debug_assert!(tcx.dep_graph\n-                                         .node_color(self)\n-                                         .map(|c| c.is_green())\n-                                         .unwrap_or(false));\n-\n-                        let def_id = self.extract_def_id(tcx).unwrap();\n-                        let _ = tcx.$query_name(def_id);\n-                    })*\n-                    _ => {\n-                        bug!()\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl_load_from_cache!(\n-    typeck_tables_of => typeck_tables_of,\n-    optimized_mir => optimized_mir,\n-    unsafety_check_result => unsafety_check_result,\n-    borrowck => borrowck,\n-    mir_borrowck => mir_borrowck,\n-    mir_const_qualif => mir_const_qualif,\n-    const_is_rvalue_promotable_to_static => const_is_rvalue_promotable_to_static,\n-    check_match => check_match,\n-    type_of => type_of,\n-    generics_of => generics_of,\n-    predicates_of => predicates_of,\n-    used_trait_imports => used_trait_imports,\n-    codegen_fn_attrs => codegen_fn_attrs,\n-    specialization_graph_of => specialization_graph_of,\n-);"}, {"sha": "a6bfc2dee613b0ce04bb8e997f1cd4550cd390ff", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -550,7 +550,7 @@ pub fn super_relate_consts<R: TypeRelation<'tcx>>(\n         if let ConstValue::Unevaluated(def_id, substs) = x.val {\n             // FIXME(eddyb) get the right param_env.\n             let param_env = ty::ParamEnv::empty();\n-            if let Some(substs) = tcx.lift_to_global(&substs) {\n+            if !substs.has_local_value() {\n                 let instance = ty::Instance::resolve(\n                     tcx.global_tcx(),\n                     param_env,"}, {"sha": "28b52dcea80f1126896e75fe02ab5c9027ebb1e9", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -15,6 +15,7 @@ use crate::mir::interpret;\n \n use std::fmt;\n use std::rc::Rc;\n+use std::sync::Arc;\n \n impl fmt::Debug for ty::GenericParamDef {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n@@ -348,7 +349,7 @@ impl<'tcx, A: Lift<'tcx>, B: Lift<'tcx>, C: Lift<'tcx>> Lift<'tcx> for (A, B, C)\n         tcx.lift(&self.0).and_then(|a| {\n             tcx.lift(&self.1).and_then(|b| tcx.lift(&self.2).map(|c| (a, b, c)))\n         })\n-    }\n+   }\n }\n \n impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for Option<T> {\n@@ -378,6 +379,20 @@ impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for Box<T> {\n     }\n }\n \n+impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for Rc<T> {\n+    type Lifted = Rc<T::Lifted>;\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&**self).map(Rc::new)\n+    }\n+}\n+\n+impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for Arc<T> {\n+    type Lifted = Arc<T::Lifted>;\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&**self).map(Arc::new)\n+    }\n+}\n+\n impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for [T] {\n     type Lifted = Vec<T::Lifted>;\n     fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n@@ -821,6 +836,13 @@ EnumTypeFoldableImpl! {\n     } where T: TypeFoldable<'tcx>\n }\n \n+EnumTypeFoldableImpl! {\n+    impl<'tcx, T, E> TypeFoldable<'tcx> for Result<T, E> {\n+        (Ok)(a),\n+        (Err)(a),\n+    } where T: TypeFoldable<'tcx>, E: TypeFoldable<'tcx>,\n+}\n+\n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Rc<T> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         Rc::new((**self).fold_with(folder))\n@@ -831,6 +853,16 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Rc<T> {\n     }\n }\n \n+impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Arc<T> {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        Arc::new((**self).fold_with(folder))\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        (**self).visit_with(visitor)\n+    }\n+}\n+\n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Box<T> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         let content: T = (**self).fold_with(folder);"}, {"sha": "a098cd1761236f3171d7a1872b5e7013ccf4c566", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -354,7 +354,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                                          cmt: &mc::cmt_<'tcx>,\n                                          loan_region: ty::Region<'tcx>,\n                                          borrow_span: Span) {\n-        pub fn borrow_of_local_data<'tcx>(cmt: &mc::cmt_<'tcx>) -> bool {\n+        pub fn borrow_of_local_data(cmt: &mc::cmt_<'_>) -> bool {\n             match cmt.cat {\n                 // Borrows of static items is allowed\n                 Categorization::StaticItem => false,"}, {"sha": "8763a6bc066b35f1f4ba0df2b11efdbd9c902b5e", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -53,7 +53,7 @@ pub struct LoanDataFlowOperator;\n \n pub type LoanDataFlow<'tcx> = DataFlowContext<'tcx, LoanDataFlowOperator>;\n \n-pub fn check_crate<'tcx>(tcx: TyCtxt<'tcx>) {\n+pub fn check_crate(tcx: TyCtxt<'_>) {\n     tcx.par_body_owners(|body_owner_def_id| {\n         tcx.ensure().borrowck(body_owner_def_id);\n     });\n@@ -73,7 +73,7 @@ pub struct AnalysisData<'tcx> {\n     pub move_data: move_data::FlowedMoveData<'tcx>,\n }\n \n-fn borrowck<'tcx>(tcx: TyCtxt<'tcx>, owner_def_id: DefId) -> &'tcx BorrowCheckResult {\n+fn borrowck(tcx: TyCtxt<'_>, owner_def_id: DefId) -> &BorrowCheckResult {\n     assert!(tcx.use_ast_borrowck() || tcx.migrate_borrowck());\n \n     debug!(\"borrowck(body_owner_def_id={:?})\", owner_def_id);"}, {"sha": "dc7014d22ec4d3d6b74b43429b52c72ee6caab5d", "filename": "src/librustc_borrowck/dataflow.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_borrowck%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_borrowck%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fdataflow.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -84,9 +84,9 @@ struct PropagationContext<'a, 'tcx, O> {\n     changed: bool,\n }\n \n-fn get_cfg_indices<'a>(id: hir::ItemLocalId,\n-                       index: &'a FxHashMap<hir::ItemLocalId, Vec<CFGIndex>>)\n-                       -> &'a [CFGIndex] {\n+fn get_cfg_indices(id: hir::ItemLocalId,\n+                   index: &FxHashMap<hir::ItemLocalId, Vec<CFGIndex>>)\n+                   -> &[CFGIndex] {\n     index.get(&id).map_or(&[], |v| &v[..])\n }\n "}, {"sha": "94abf1796d3665f4dd1b904fbd0a97d1f162fdef", "filename": "src/librustc_codegen_llvm/attributes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fattributes.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -102,8 +102,8 @@ pub fn set_probestack(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n         return\n     }\n \n-    // probestack doesn't play nice either with pgo-gen.\n-    if cx.sess().opts.debugging_opts.pgo_gen.enabled() {\n+    // probestack doesn't play nice either with `-C profile-generate`.\n+    if cx.sess().opts.cg.profile_generate.enabled() {\n         return;\n     }\n "}, {"sha": "ca3b2b84655e2939857df0bb775d9e950eb2baef", "filename": "src/librustc_codegen_llvm/back/archive.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_codegen_llvm%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_codegen_llvm%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Farchive.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -205,8 +205,8 @@ impl<'a> LlvmArchiveBuilder<'a> {\n     }\n \n     fn build_with_llvm(&mut self, kind: ArchiveKind) -> io::Result<()> {\n-        let removals = mem::replace(&mut self.removals, Vec::new());\n-        let mut additions = mem::replace(&mut self.additions, Vec::new());\n+        let removals = mem::take(&mut self.removals);\n+        let mut additions = mem::take(&mut self.additions);\n         let mut strings = Vec::new();\n         let mut members = Vec::new();\n "}, {"sha": "b135605cf02d765ab38bf780816a838c2cdcc99b", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -239,9 +239,9 @@ impl<'a> Drop for DiagnosticHandlers<'a> {\n     }\n }\n \n-unsafe extern \"C\" fn report_inline_asm<'a, 'b>(cgcx: &'a CodegenContext<LlvmCodegenBackend>,\n-                                               msg: &'b str,\n-                                               cookie: c_uint) {\n+unsafe extern \"C\" fn report_inline_asm(cgcx: &CodegenContext<LlvmCodegenBackend>,\n+                                       msg: &str,\n+                                       cookie: c_uint) {\n     cgcx.diag_emitter.inline_asm_error(cookie as u32, msg.to_owned());\n }\n "}, {"sha": "21c19e167cfbe9299570d8fd652adbdc83d626d2", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -123,8 +123,8 @@ pub fn compile_codegen_unit(tcx: TyCtxt<'tcx>, cgu_name: InternedString) {\n \n     submit_codegened_module_to_llvm(&LlvmCodegenBackend(()), tcx, module, cost);\n \n-    fn module_codegen<'tcx>(\n-        tcx: TyCtxt<'tcx>,\n+    fn module_codegen(\n+        tcx: TyCtxt<'_>,\n         cgu_name: InternedString,\n     ) -> ModuleCodegen<ModuleLlvm> {\n         let cgu = tcx.codegen_unit(cgu_name);"}, {"sha": "f67c740b777488423bcce75cc8b3ce715c99967b", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -144,7 +144,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    fn build_sibling_block<'b>(&self, name: &'b str) -> Self {\n+    fn build_sibling_block(&self, name: &str) -> Self {\n         Builder::new_block(self.cx, self.llfn(), name)\n     }\n "}, {"sha": "ca63e589a6f95c079cffe719a9c926f10c1e3460", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -21,6 +21,7 @@\n #![feature(link_args)]\n #![feature(static_nobundle)]\n #![feature(trusted_len)]\n+#![feature(mem_take)]\n #![deny(rust_2018_idioms)]\n #![deny(internal)]\n #![deny(unused_lifetimes)]\n@@ -124,7 +125,7 @@ impl ExtraBackendMethods for LlvmCodegenBackend {\n     ) {\n         unsafe { allocator::codegen(tcx, mods, kind) }\n     }\n-    fn compile_codegen_unit<'tcx>(&self, tcx: TyCtxt<'tcx>, cgu_name: InternedString) {\n+    fn compile_codegen_unit(&self, tcx: TyCtxt<'_>, cgu_name: InternedString) {\n         base::compile_codegen_unit(tcx, cgu_name);\n     }\n     fn target_machine_factory("}, {"sha": "d610805b5bbd0e1a8575bd95e0d5a0ac65afc172", "filename": "src/librustc_codegen_ssa/back/command.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_codegen_ssa%2Fback%2Fcommand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_codegen_ssa%2Fback%2Fcommand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fcommand.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -110,7 +110,7 @@ impl Command {\n     }\n \n     pub fn take_args(&mut self) -> Vec<OsString> {\n-        mem::replace(&mut self.args, Vec::new())\n+        mem::take(&mut self.args)\n     }\n \n     /// Returns a `true` if we're pretty sure that this'll blow OS spawn limits,"}, {"sha": "707b7cae16ce73f1d58fa79a05d3dbd1e0dc6b02", "filename": "src/librustc_codegen_ssa/back/link.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -653,10 +653,14 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(sess: &'a Session,\n             linker_error.emit();\n \n             if sess.target.target.options.is_like_msvc && linker_not_found {\n-                sess.note_without_error(\"the msvc targets depend on the msvc linker \\\n-                    but `link.exe` was not found\");\n-                sess.note_without_error(\"please ensure that VS 2013, VS 2015 or VS 2017 \\\n-                    was installed with the Visual C++ option\");\n+                sess.note_without_error(\n+                    \"the msvc targets depend on the msvc linker \\\n+                     but `link.exe` was not found\",\n+                );\n+                sess.note_without_error(\n+                    \"please ensure that VS 2013, VS 2015, VS 2017 or VS 2019 \\\n+                     was installed with the Visual C++ option\",\n+                );\n             }\n             sess.abort_if_errors();\n         }\n@@ -1179,7 +1183,7 @@ fn link_args<'a, B: ArchiveBuilder<'a>>(cmd: &mut dyn Linker,\n         cmd.build_static_executable();\n     }\n \n-    if sess.opts.debugging_opts.pgo_gen.enabled() {\n+    if sess.opts.cg.profile_generate.enabled() {\n         cmd.pgo_gen();\n     }\n "}, {"sha": "b64c9a60d97138d855bb04cc0b8e80a22c8119a6", "filename": "src/librustc_codegen_ssa/back/symbol_export.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -46,10 +46,10 @@ pub fn crates_export_threshold(crate_types: &[config::CrateType]) -> SymbolExpor\n     }\n }\n \n-fn reachable_non_generics_provider<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+fn reachable_non_generics_provider(\n+    tcx: TyCtxt<'_>,\n     cnum: CrateNum,\n-) -> &'tcx DefIdMap<SymbolExportLevel> {\n+) -> &DefIdMap<SymbolExportLevel> {\n     assert_eq!(cnum, LOCAL_CRATE);\n \n     if !tcx.sess.opts.output_types.should_codegen() {\n@@ -157,7 +157,7 @@ fn reachable_non_generics_provider<'tcx>(\n     tcx.arena.alloc(reachable_non_generics)\n }\n \n-fn is_reachable_non_generic_provider_local<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> bool {\n+fn is_reachable_non_generic_provider_local(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n     let export_threshold = threshold(tcx);\n \n     if let Some(&level) = tcx.reachable_non_generics(def_id.krate).get(&def_id) {\n@@ -167,14 +167,14 @@ fn is_reachable_non_generic_provider_local<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefI\n     }\n }\n \n-fn is_reachable_non_generic_provider_extern<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> bool {\n+fn is_reachable_non_generic_provider_extern(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n     tcx.reachable_non_generics(def_id.krate).contains_key(&def_id)\n }\n \n-fn exported_symbols_provider_local<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+fn exported_symbols_provider_local(\n+    tcx: TyCtxt<'_>,\n     cnum: CrateNum,\n-) -> Arc<Vec<(ExportedSymbol<'tcx>, SymbolExportLevel)>> {\n+) -> Arc<Vec<(ExportedSymbol<'_>, SymbolExportLevel)>> {\n     assert_eq!(cnum, LOCAL_CRATE);\n \n     if !tcx.sess.opts.output_types.should_codegen() {\n@@ -203,7 +203,7 @@ fn exported_symbols_provider_local<'tcx>(\n         }\n     }\n \n-    if tcx.sess.opts.debugging_opts.pgo_gen.enabled() {\n+    if tcx.sess.opts.cg.profile_generate.enabled() {\n         // These are weak symbols that point to the profile version and the\n         // profile name, which need to be treated as exported so LTO doesn't nix\n         // them.\n@@ -273,10 +273,10 @@ fn exported_symbols_provider_local<'tcx>(\n     Arc::new(symbols)\n }\n \n-fn upstream_monomorphizations_provider<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+fn upstream_monomorphizations_provider(\n+    tcx: TyCtxt<'_>,\n     cnum: CrateNum,\n-) -> &'tcx DefIdMap<FxHashMap<SubstsRef<'tcx>, CrateNum>> {\n+) -> &DefIdMap<FxHashMap<SubstsRef<'_>, CrateNum>> {\n     debug_assert!(cnum == LOCAL_CRATE);\n \n     let cnums = tcx.all_crate_nums(LOCAL_CRATE);\n@@ -322,10 +322,10 @@ fn upstream_monomorphizations_provider<'tcx>(\n     tcx.arena.alloc(instances)\n }\n \n-fn upstream_monomorphizations_for_provider<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+fn upstream_monomorphizations_for_provider(\n+    tcx: TyCtxt<'_>,\n     def_id: DefId,\n-) -> Option<&'tcx FxHashMap<SubstsRef<'tcx>, CrateNum>> {\n+) -> Option<&FxHashMap<SubstsRef<'_>, CrateNum>> {\n     debug_assert!(!def_id.is_local());\n     tcx.upstream_monomorphizations(LOCAL_CRATE).get(&def_id)\n }"}, {"sha": "fbf57701c5a950f75472f6032a7bbff82064151a", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -423,8 +423,8 @@ pub fn start_async_codegen<B: ExtraBackendMethods>(\n         modules_config.passes.push(\"insert-gcov-profiling\".to_owned())\n     }\n \n-    modules_config.pgo_gen = sess.opts.debugging_opts.pgo_gen.clone();\n-    modules_config.pgo_use = sess.opts.debugging_opts.pgo_use.clone();\n+    modules_config.pgo_gen = sess.opts.cg.profile_generate.clone();\n+    modules_config.pgo_use = sess.opts.cg.profile_use.clone();\n \n     modules_config.opt_level = Some(sess.opts.optimize);\n     modules_config.opt_size = Some(sess.opts.optimize);\n@@ -1345,12 +1345,9 @@ fn start_executing_work<B: ExtraBackendMethods>(\n                     assert!(!started_lto);\n                     started_lto = true;\n \n-                    let needs_fat_lto =\n-                        mem::replace(&mut needs_fat_lto, Vec::new());\n-                    let needs_thin_lto =\n-                        mem::replace(&mut needs_thin_lto, Vec::new());\n-                    let import_only_modules =\n-                        mem::replace(&mut lto_import_only_modules, Vec::new());\n+                    let needs_fat_lto = mem::take(&mut needs_fat_lto);\n+                    let needs_thin_lto = mem::take(&mut needs_thin_lto);\n+                    let import_only_modules = mem::take(&mut lto_import_only_modules);\n \n                     for (work, cost) in generate_lto_work(&cgcx, needs_fat_lto,\n                                                           needs_thin_lto, import_only_modules) {"}, {"sha": "d06460fc856962bd27d5901c31d89eea643349c4", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -700,7 +700,7 @@ impl<B: ExtraBackendMethods> Drop for AbortCodegenOnDrop<B> {\n     }\n }\n \n-fn assert_and_save_dep_graph<'tcx>(tcx: TyCtxt<'tcx>) {\n+fn assert_and_save_dep_graph(tcx: TyCtxt<'_>) {\n     time(tcx.sess,\n          \"assert dep graph\",\n          || ::rustc_incremental::assert_dep_graph(tcx));"}, {"sha": "c9b1c0260e8c36e54b2821e3ac95e1de6b2854d9", "filename": "src/librustc_codegen_ssa/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Fmod.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -10,7 +10,7 @@ pub enum FunctionDebugContext<D> {\n }\n \n impl<D> FunctionDebugContext<D> {\n-    pub fn get_ref<'a>(&'a self, span: Span) -> &'a FunctionDebugContextData<D> {\n+    pub fn get_ref(&self, span: Span) -> &FunctionDebugContextData<D> {\n         match *self {\n             FunctionDebugContext::RegularContext(ref data) => data,\n             FunctionDebugContext::DebugInfoDisabled => {"}, {"sha": "3c1ab600040a112c548e0558c59395116836fc9a", "filename": "src/librustc_codegen_ssa/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_codegen_ssa%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_codegen_ssa%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Flib.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -10,6 +10,7 @@\n #![feature(in_band_lifetimes)]\n #![feature(nll)]\n #![feature(trusted_len)]\n+#![feature(mem_take)]\n #![allow(unused_attributes)]\n #![allow(dead_code)]\n #![deny(rust_2018_idioms)]"}, {"sha": "2af9b448ef1eb03cc57c6733477f1b45a608750b", "filename": "src/librustc_codegen_ssa/mir/analyze.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -273,7 +273,7 @@ impl CleanupKind {\n     }\n }\n \n-pub fn cleanup_kinds<'tcx>(mir: &mir::Body<'tcx>) -> IndexVec<mir::BasicBlock, CleanupKind> {\n+pub fn cleanup_kinds(mir: &mir::Body<'_>) -> IndexVec<mir::BasicBlock, CleanupKind> {\n     fn discover_masters<'tcx>(result: &mut IndexVec<mir::BasicBlock, CleanupKind>,\n                               mir: &mir::Body<'tcx>) {\n         for (bb, data) in mir.basic_blocks().iter_enumerated() {"}, {"sha": "9d5aaa7655db88161ee2994755cfa1d071419b4b", "filename": "src/librustc_codegen_ssa/traits/backend.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -44,7 +44,7 @@ pub trait ExtraBackendMethods: CodegenBackend + WriteBackendMethods + Sized + Se\n         mods: &mut Self::Module,\n         kind: AllocatorKind,\n     );\n-    fn compile_codegen_unit<'tcx>(&self, tcx: TyCtxt<'tcx>, cgu_name: InternedString);\n+    fn compile_codegen_unit(&self, tcx: TyCtxt<'_>, cgu_name: InternedString);\n     // If find_features is true this won't access `sess.crate_types` by assuming\n     // that `is_pie_binary` is false. When we discover LLVM target features\n     // `sess.crate_types` is uninitialized so we cannot access it."}, {"sha": "3a144f0b0e0aa0a879bb5b69188abc4700bdc0fb", "filename": "src/librustc_codegen_ssa/traits/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -36,7 +36,7 @@ pub trait BuilderMethods<'a, 'tcx>:\n {\n     fn new_block<'b>(cx: &'a Self::CodegenCx, llfn: Self::Value, name: &'b str) -> Self;\n     fn with_cx(cx: &'a Self::CodegenCx) -> Self;\n-    fn build_sibling_block<'b>(&self, name: &'b str) -> Self;\n+    fn build_sibling_block(&self, name: &str) -> Self;\n     fn cx(&self) -> &Self::CodegenCx;\n     fn llbb(&self) -> Self::BasicBlock;\n "}, {"sha": "7ab29c5c4c3d024bc759a8bbc438adf49ae8bed3", "filename": "src/librustc_codegen_utils/symbol_names_test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_codegen_utils%2Fsymbol_names_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_codegen_utils%2Fsymbol_names_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names_test.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -11,7 +11,7 @@ use syntax::symbol::{Symbol, sym};\n const SYMBOL_NAME: Symbol = sym::rustc_symbol_name;\n const DEF_PATH: Symbol = sym::rustc_def_path;\n \n-pub fn report_symbol_names<'tcx>(tcx: TyCtxt<'tcx>) {\n+pub fn report_symbol_names(tcx: TyCtxt<'_>) {\n     // if the `rustc_attrs` feature is not enabled, then the\n     // attributes we are interested in cannot be present anyway, so\n     // skip the walk."}, {"sha": "32aa1cb6b1d36575d77eed95d6999f57c7d10ab9", "filename": "src/librustc_data_structures/binary_search_util/mod.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_data_structures%2Fbinary_search_util%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_data_structures%2Fbinary_search_util%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbinary_search_util%2Fmod.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -0,0 +1,49 @@\n+#[cfg(test)]\n+mod test;\n+\n+/// Uses a sorted slice `data: &[E]` as a kind of \"multi-map\". The\n+/// `key_fn` extracts a key of type `K` from the data, and this\n+/// function finds the range of elements that match the key. `data`\n+/// must have been sorted as if by a call to `sort_by_key` for this to\n+/// work.\n+pub fn binary_search_slice<E, K>(data: &'d [E], key_fn: impl Fn(&E) -> K, key: &K) -> &'d [E]\n+where\n+    K: Ord,\n+{\n+    let mid = match data.binary_search_by_key(key, &key_fn) {\n+        Ok(mid) => mid,\n+        Err(_) => return &[],\n+    };\n+\n+    // We get back *some* element with the given key -- so\n+    // search backwards to find the *first* one.\n+    //\n+    // (It'd be more efficient to use a \"galloping\" search\n+    // here, but it's not really worth it for small-ish\n+    // amounts of data.)\n+    let mut start = mid;\n+    while start > 0 {\n+        if key_fn(&data[start - 1]) == *key {\n+            start -= 1;\n+        } else {\n+            break;\n+        }\n+    }\n+\n+    // Now search forward to find the *last* one.\n+    //\n+    // (It'd be more efficient to use a \"galloping\" search\n+    // here, but it's not really worth it for small-ish\n+    // amounts of data.)\n+    let mut end = mid + 1;\n+    let max = data.len();\n+    while end < max {\n+        if key_fn(&data[end]) == *key {\n+            end += 1;\n+        } else {\n+            break;\n+        }\n+    }\n+\n+    &data[start..end]\n+}"}, {"sha": "d74febb5c0fc4a13e2530de71982520e3a944fcf", "filename": "src/librustc_data_structures/binary_search_util/test.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_data_structures%2Fbinary_search_util%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_data_structures%2Fbinary_search_util%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbinary_search_util%2Ftest.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -0,0 +1,23 @@\n+use super::*;\n+\n+type Element = (usize, &'static str);\n+\n+fn test_map() -> Vec<Element> {\n+    let mut data = vec![(3, \"three-a\"), (0, \"zero\"), (3, \"three-b\"), (22, \"twenty-two\")];\n+    data.sort_by_key(get_key);\n+    data\n+}\n+\n+fn get_key(data: &Element) -> usize {\n+    data.0\n+}\n+\n+#[test]\n+fn binary_search_slice_test() {\n+    let map = test_map();\n+    assert_eq!(binary_search_slice(&map, get_key, &0), &[(0, \"zero\")]);\n+    assert_eq!(binary_search_slice(&map, get_key, &1), &[]);\n+    assert_eq!(binary_search_slice(&map, get_key, &3), &[(3, \"three-a\"), (3, \"three-b\")]);\n+    assert_eq!(binary_search_slice(&map, get_key, &22), &[(22, \"twenty-two\")]);\n+    assert_eq!(binary_search_slice(&map, get_key, &23), &[]);\n+}"}, {"sha": "1eb28bccbe382cd4663e853d3aaf62b959849da2", "filename": "src/librustc_data_structures/bit_set.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_data_structures%2Fbit_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_data_structures%2Fbit_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbit_set.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -168,7 +168,7 @@ impl<T: Idx> BitSet<T> {\n \n     /// Iterates over the indices of set bits in a sorted order.\n     #[inline]\n-    pub fn iter<'a>(&'a self) -> BitIter<'a, T> {\n+    pub fn iter(&self) -> BitIter<'_, T> {\n         BitIter {\n             cur: None,\n             iter: self.words.iter().enumerate(),\n@@ -849,7 +849,7 @@ impl<R: Idx, C: Idx> BitMatrix<R, C> {\n \n     /// Iterates through all the columns set to true in a given row of\n     /// the matrix.\n-    pub fn iter<'a>(&'a self, row: R) -> BitIter<'a, C> {\n+    pub fn iter(&self, row: R) -> BitIter<'_, C> {\n         assert!(row.index() < self.num_rows);\n         let (start, end) = self.range(row);\n         BitIter {"}, {"sha": "3bea965ef30411ce3dff6852b0101033a837434b", "filename": "src/librustc_data_structures/fingerprint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_data_structures%2Ffingerprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_data_structures%2Ffingerprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ffingerprint.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -58,7 +58,7 @@ impl Fingerprint {\n         Ok(())\n     }\n \n-    pub fn decode_opaque<'a>(decoder: &mut Decoder<'a>) -> Result<Fingerprint, String> {\n+    pub fn decode_opaque(decoder: &mut Decoder<'_>) -> Result<Fingerprint, String> {\n         let mut bytes = [0; 16];\n \n         decoder.read_raw_bytes(&mut bytes)?;"}, {"sha": "d2699004c81d8f9952d9ebd65952142d2ee39d73", "filename": "src/librustc_data_structures/graph/implementation/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_data_structures%2Fgraph%2Fimplementation%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_data_structures%2Fgraph%2Fimplementation%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fimplementation%2Fmod.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -247,11 +247,11 @@ impl<N: Debug, E: Debug> Graph<N, E> {\n         self.incoming_edges(target).sources()\n     }\n \n-    pub fn depth_traverse<'a>(\n-        &'a self,\n+    pub fn depth_traverse(\n+        &self,\n         start: NodeIndex,\n         direction: Direction,\n-    ) -> DepthFirstTraversal<'a, N, E> {\n+    ) -> DepthFirstTraversal<'_, N, E> {\n         DepthFirstTraversal::with_start_node(self, start, direction)\n     }\n "}, {"sha": "5612778ce07ed1075b89c257745daacad3b4107b", "filename": "src/librustc_data_structures/graph/iterate/mod.rs", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_data_structures%2Fgraph%2Fiterate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_data_structures%2Fgraph%2Fiterate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fiterate%2Fmod.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -1,5 +1,6 @@\n use super::super::indexed_vec::IndexVec;\n-use super::{DirectedGraph, WithSuccessors, WithNumNodes};\n+use super::{DirectedGraph, WithNumNodes, WithSuccessors};\n+use crate::bit_set::BitSet;\n \n #[cfg(test)]\n mod test;\n@@ -51,3 +52,36 @@ pub fn reverse_post_order<G: DirectedGraph + WithSuccessors + WithNumNodes>(\n     vec.reverse();\n     vec\n }\n+\n+/// A \"depth-first search\" iterator for a directed graph.\n+pub struct DepthFirstSearch<'graph, G>\n+where\n+    G: ?Sized + DirectedGraph + WithNumNodes + WithSuccessors,\n+{\n+    graph: &'graph G,\n+    stack: Vec<G::Node>,\n+    visited: BitSet<G::Node>,\n+}\n+\n+impl<G> DepthFirstSearch<'graph, G>\n+where\n+    G: ?Sized + DirectedGraph + WithNumNodes + WithSuccessors,\n+{\n+    pub fn new(graph: &'graph G, start_node: G::Node) -> Self {\n+        Self { graph, stack: vec![start_node], visited: BitSet::new_empty(graph.num_nodes()) }\n+    }\n+}\n+\n+impl<G> Iterator for DepthFirstSearch<'_, G>\n+where\n+    G: ?Sized + DirectedGraph + WithNumNodes + WithSuccessors,\n+{\n+    type Item = G::Node;\n+\n+    fn next(&mut self) -> Option<G::Node> {\n+        let DepthFirstSearch { stack, visited, graph } = self;\n+        let n = stack.pop()?;\n+        stack.extend(graph.successors(n).filter(|&m| visited.insert(m)));\n+        Some(n)\n+    }\n+}"}, {"sha": "e59085a9e3a95e3ea8fd8a7eb2cbe830e410aed7", "filename": "src/librustc_data_structures/graph/mod.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -5,6 +5,7 @@ pub mod implementation;\n pub mod iterate;\n mod reference;\n pub mod scc;\n+pub mod vec_graph;\n \n #[cfg(test)]\n mod test;\n@@ -17,14 +18,25 @@ pub trait WithNumNodes: DirectedGraph {\n     fn num_nodes(&self) -> usize;\n }\n \n+pub trait WithNumEdges: DirectedGraph {\n+    fn num_edges(&self) -> usize;\n+}\n+\n pub trait WithSuccessors: DirectedGraph\n where\n     Self: for<'graph> GraphSuccessors<'graph, Item = <Self as DirectedGraph>::Node>,\n {\n-    fn successors<'graph>(\n-        &'graph self,\n+    fn successors(\n+        &self,\n         node: Self::Node,\n-    ) -> <Self as GraphSuccessors<'graph>>::Iter;\n+    ) -> <Self as GraphSuccessors<'_>>::Iter;\n+\n+    fn depth_first_search(&self, from: Self::Node) -> iterate::DepthFirstSearch<'_, Self>\n+    where\n+        Self: WithNumNodes,\n+    {\n+        iterate::DepthFirstSearch::new(self, from)\n+    }\n }\n \n pub trait GraphSuccessors<'graph> {\n@@ -36,10 +48,10 @@ pub trait WithPredecessors: DirectedGraph\n where\n     Self: for<'graph> GraphPredecessors<'graph, Item = <Self as DirectedGraph>::Node>,\n {\n-    fn predecessors<'graph>(\n-        &'graph self,\n+    fn predecessors(\n+        &self,\n         node: Self::Node,\n-    ) -> <Self as GraphPredecessors<'graph>>::Iter;\n+    ) -> <Self as GraphPredecessors<'_>>::Iter;\n }\n \n pub trait GraphPredecessors<'graph> {"}, {"sha": "9442bb3cdec3b8a11cf73122535d98c569a7f011", "filename": "src/librustc_data_structures/graph/reference.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_data_structures%2Fgraph%2Freference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_data_structures%2Fgraph%2Freference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Freference.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -17,15 +17,15 @@ impl<'graph, G: WithStartNode> WithStartNode for &'graph G {\n }\n \n impl<'graph, G: WithSuccessors> WithSuccessors for &'graph G {\n-    fn successors<'iter>(&'iter self, node: Self::Node) -> <Self as GraphSuccessors<'iter>>::Iter {\n+    fn successors(&self, node: Self::Node) -> <Self as GraphSuccessors<'_>>::Iter {\n         (**self).successors(node)\n     }\n }\n \n impl<'graph, G: WithPredecessors> WithPredecessors for &'graph G {\n-    fn predecessors<'iter>(&'iter self,\n-                           node: Self::Node)\n-                           -> <Self as GraphPredecessors<'iter>>::Iter {\n+    fn predecessors(&self,\n+                    node: Self::Node)\n+                    -> <Self as GraphPredecessors<'_>>::Iter {\n         (**self).predecessors(node)\n     }\n }"}, {"sha": "78554cda77b44b2a8710e37667af151043b20d84", "filename": "src/librustc_data_structures/graph/scc/mod.rs", "status": "modified", "additions": 45, "deletions": 1, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_data_structures%2Fgraph%2Fscc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_data_structures%2Fgraph%2Fscc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fscc%2Fmod.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -4,7 +4,8 @@\n //! O(n) time.\n \n use crate::fx::FxHashSet;\n-use crate::graph::{DirectedGraph, WithNumNodes, WithSuccessors};\n+use crate::graph::{DirectedGraph, WithNumNodes, WithNumEdges, WithSuccessors, GraphSuccessors};\n+use crate::graph::vec_graph::VecGraph;\n use crate::indexed_vec::{Idx, IndexVec};\n use std::ops::Range;\n \n@@ -58,6 +59,49 @@ impl<N: Idx, S: Idx> Sccs<N, S> {\n     pub fn successors(&self, scc: S) -> &[S] {\n         self.scc_data.successors(scc)\n     }\n+\n+    /// Construct the reverse graph of the SCC graph.\n+    pub fn reverse(&self) -> VecGraph<S> {\n+        VecGraph::new(\n+            self.num_sccs(),\n+            self.all_sccs()\n+                .flat_map(|source| self.successors(source).iter().map(move |&target| {\n+                    (target, source)\n+                }))\n+                .collect(),\n+        )\n+    }\n+}\n+\n+impl<N: Idx, S: Idx> DirectedGraph for Sccs<N, S> {\n+    type Node = S;\n+}\n+\n+impl<N: Idx, S: Idx> WithNumNodes for Sccs<N, S> {\n+    fn num_nodes(&self) -> usize {\n+        self.num_sccs()\n+    }\n+}\n+\n+impl<N: Idx, S: Idx> WithNumEdges for Sccs<N, S> {\n+    fn num_edges(&self) -> usize {\n+        self.scc_data.all_successors.len()\n+    }\n+}\n+\n+impl<N: Idx, S: Idx> GraphSuccessors<'graph> for Sccs<N, S> {\n+    type Item = S;\n+\n+    type Iter = std::iter::Cloned<std::slice::Iter<'graph, S>>;\n+}\n+\n+impl<N: Idx, S: Idx> WithSuccessors for Sccs<N, S> {\n+    fn successors<'graph>(\n+        &'graph self,\n+        node: S\n+    ) -> <Self as GraphSuccessors<'graph>>::Iter {\n+        self.successors(node).iter().cloned()\n+    }\n }\n \n impl<S: Idx> SccData<S> {"}, {"sha": "bc142144e930f24e8790df0d40e4b13dc1c8fff3", "filename": "src/librustc_data_structures/graph/test.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_data_structures%2Fgraph%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_data_structures%2Fgraph%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Ftest.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -51,15 +51,15 @@ impl WithNumNodes for TestGraph {\n }\n \n impl WithPredecessors for TestGraph {\n-    fn predecessors<'graph>(&'graph self,\n-                            node: usize)\n-                            -> <Self as GraphPredecessors<'graph>>::Iter {\n+    fn predecessors(&self,\n+                    node: usize)\n+                    -> <Self as GraphPredecessors<'_>>::Iter {\n         self.predecessors[&node].iter().cloned()\n     }\n }\n \n impl WithSuccessors for TestGraph {\n-    fn successors<'graph>(&'graph self, node: usize) -> <Self as GraphSuccessors<'graph>>::Iter {\n+    fn successors(&self, node: usize) -> <Self as GraphSuccessors<'_>>::Iter {\n         self.successors[&node].iter().cloned()\n     }\n }"}, {"sha": "6fb1bb42d2cfd396b7c75a3c5110aef71d86ddc6", "filename": "src/librustc_data_structures/graph/vec_graph/mod.rs", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_data_structures%2Fgraph%2Fvec_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_data_structures%2Fgraph%2Fvec_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fvec_graph%2Fmod.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -0,0 +1,113 @@\n+use crate::indexed_vec::{Idx, IndexVec};\n+use crate::graph::{DirectedGraph, WithNumNodes, WithNumEdges, WithSuccessors, GraphSuccessors};\n+\n+#[cfg(test)]\n+mod test;\n+\n+pub struct VecGraph<N: Idx> {\n+    /// Maps from a given node to an index where the set of successors\n+    /// for that node starts. The index indexes into the `edges`\n+    /// vector. To find the range for a given node, we look up the\n+    /// start for that node and then the start for the next node\n+    /// (i.e., with an index 1 higher) and get the range between the\n+    /// two. This vector always has an extra entry so that this works\n+    /// even for the max element.\n+    node_starts: IndexVec<N, usize>,\n+\n+    edge_targets: Vec<N>,\n+}\n+\n+impl<N: Idx> VecGraph<N> {\n+    pub fn new(\n+        num_nodes: usize,\n+        mut edge_pairs: Vec<(N, N)>,\n+    ) -> Self {\n+        // Sort the edges by the source -- this is important.\n+        edge_pairs.sort();\n+\n+        let num_edges = edge_pairs.len();\n+\n+        // Store the *target* of each edge into `edge_targets`.\n+        let edge_targets: Vec<N> = edge_pairs.iter().map(|&(_, target)| target).collect();\n+\n+        // Create the *edge starts* array. We are iterating over over\n+        // the (sorted) edge pairs. We maintain the invariant that the\n+        // length of the `node_starts` arary is enough to store the\n+        // current source node -- so when we see that the source node\n+        // for an edge is greater than the current length, we grow the\n+        // edge-starts array by just enough.\n+        let mut node_starts = IndexVec::with_capacity(num_edges);\n+        for (index, &(source, _)) in edge_pairs.iter().enumerate() {\n+            // If we have a list like `[(0, x), (2, y)]`:\n+            //\n+            // - Start out with `node_starts` of `[]`\n+            // - Iterate to `(0, x)` at index 0:\n+            //   - Push one entry because `node_starts.len()` (0) is <= the source (0)\n+            //   - Leaving us with `node_starts` of `[0]`\n+            // - Iterate to `(2, y)` at index 1:\n+            //   - Push one entry because `node_starts.len()` (1) is <= the source (2)\n+            //   - Push one entry because `node_starts.len()` (2) is <= the source (2)\n+            //   - Leaving us with `node_starts` of `[0, 1, 1]`\n+            // - Loop terminates\n+            while node_starts.len() <= source.index() {\n+                node_starts.push(index);\n+            }\n+        }\n+\n+        // Pad out the `node_starts` array so that it has `num_nodes +\n+        // 1` entries. Continuing our example above, if `num_nodes` is\n+        // be `3`, we would push one more index: `[0, 1, 1, 2]`.\n+        //\n+        // Interpretation of that vector:\n+        //\n+        // [0, 1, 1, 2]\n+        //        ---- range for N=2\n+        //     ---- range for N=1\n+        //  ---- range for N=0\n+        while node_starts.len() <= num_nodes {\n+            node_starts.push(edge_targets.len());\n+        }\n+\n+        assert_eq!(node_starts.len(), num_nodes + 1);\n+\n+        Self { node_starts, edge_targets }\n+    }\n+\n+    /// Gets the successors for `source` as a slice.\n+    pub fn successors(&self, source: N) -> &[N] {\n+        let start_index = self.node_starts[source];\n+        let end_index = self.node_starts[source.plus(1)];\n+        &self.edge_targets[start_index..end_index]\n+    }\n+}\n+\n+impl<N: Idx> DirectedGraph for VecGraph<N> {\n+    type Node = N;\n+}\n+\n+impl<N: Idx> WithNumNodes for VecGraph<N> {\n+    fn num_nodes(&self) -> usize {\n+        self.node_starts.len() - 1\n+    }\n+}\n+\n+impl<N: Idx> WithNumEdges for VecGraph<N> {\n+    fn num_edges(&self) -> usize {\n+        self.edge_targets.len()\n+    }\n+}\n+\n+impl<N: Idx> GraphSuccessors<'graph> for VecGraph<N> {\n+    type Item = N;\n+\n+    type Iter = std::iter::Cloned<std::slice::Iter<'graph, N>>;\n+}\n+\n+impl<N: Idx> WithSuccessors for VecGraph<N> {\n+    fn successors<'graph>(\n+        &'graph self,\n+        node: N\n+    ) -> <Self as GraphSuccessors<'graph>>::Iter {\n+        self.successors(node).iter().cloned()\n+    }\n+}"}, {"sha": "97a9bd2ad0b08c74fb5528ddcef46aab09669409", "filename": "src/librustc_data_structures/graph/vec_graph/test.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_data_structures%2Fgraph%2Fvec_graph%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_data_structures%2Fgraph%2Fvec_graph%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fvec_graph%2Ftest.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -0,0 +1,51 @@\n+use super::*;\n+\n+fn create_graph() -> VecGraph<usize> {\n+    // Create a simple graph\n+    //\n+    //          5\n+    //          |\n+    //          V\n+    //    0 --> 1 --> 2\n+    //          |\n+    //          v\n+    //          3 --> 4\n+    //\n+    //    6\n+\n+    VecGraph::new(\n+        7,\n+        vec![\n+            (0, 1),\n+            (1, 2),\n+            (1, 3),\n+            (3, 4),\n+            (5, 1),\n+        ],\n+    )\n+}\n+\n+#[test]\n+fn num_nodes() {\n+    let graph = create_graph();\n+    assert_eq!(graph.num_nodes(), 7);\n+}\n+\n+#[test]\n+fn succesors() {\n+    let graph = create_graph();\n+    assert_eq!(graph.successors(0), &[1]);\n+    assert_eq!(graph.successors(1), &[2, 3]);\n+    assert_eq!(graph.successors(2), &[]);\n+    assert_eq!(graph.successors(3), &[4]);\n+    assert_eq!(graph.successors(4), &[]);\n+    assert_eq!(graph.successors(5), &[1]);\n+    assert_eq!(graph.successors(6), &[]);\n+}\n+\n+#[test]\n+fn dfs() {\n+    let graph = create_graph();\n+    let dfs: Vec<_> = graph.depth_first_search(0).collect();\n+    assert_eq!(dfs, vec![0, 1, 3, 4, 2]);\n+}"}, {"sha": "b3a810a622d03dbdf7b2dd7479b1f21e83feeff2", "filename": "src/librustc_data_structures/indexed_vec.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_data_structures%2Findexed_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_data_structures%2Findexed_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_vec.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -19,8 +19,11 @@ pub trait Idx: Copy + 'static + Ord + Debug + Hash {\n     fn index(self) -> usize;\n \n     fn increment_by(&mut self, amount: usize) {\n-        let v = self.index() + amount;\n-        *self = Self::new(v);\n+        *self = self.plus(amount);\n+    }\n+\n+    fn plus(self, amount: usize) -> Self {\n+        Self::new(self.index() + amount)\n     }\n }\n \n@@ -167,6 +170,14 @@ macro_rules! newtype_index {\n             }\n         }\n \n+        impl std::ops::Add<usize> for $type {\n+            type Output = Self;\n+\n+            fn add(self, other: usize) -> Self {\n+                Self::new(self.index() + other)\n+            }\n+        }\n+\n         impl Idx for $type {\n             #[inline]\n             fn new(value: usize) -> Self {"}, {"sha": "98c809f7e25958d7ae98272bf52e0f44940766e6", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -72,6 +72,7 @@ macro_rules! unlikely {\n pub mod macros;\n pub mod svh;\n pub mod base_n;\n+pub mod binary_search_util;\n pub mod bit_set;\n pub mod box_region;\n pub mod const_cstr;"}, {"sha": "d7cbd1e2e4b476e28a2b87727388997c6b9b4f46", "filename": "src/librustc_data_structures/transitive_relation.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftransitive_relation.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -58,6 +58,10 @@ impl<T: Clone + Debug + Eq + Hash> TransitiveRelation<T> {\n         self.edges.is_empty()\n     }\n \n+    pub fn elements(&self) -> impl Iterator<Item=&T> {\n+        self.elements.iter()\n+    }\n+\n     fn index(&self, a: &T) -> Option<Index> {\n         self.map.get(a).cloned()\n     }"}, {"sha": "ff0c4ff548b71eab6b23b93546bbe6eaedb0d1bb", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -188,7 +188,7 @@ impl PpSourceMode {\n             _ => panic!(\"Should use call_with_pp_support_hir\"),\n         }\n     }\n-    fn call_with_pp_support_hir<'tcx, A, F>(&self, tcx: TyCtxt<'tcx>, f: F) -> A\n+    fn call_with_pp_support_hir<A, F>(&self, tcx: TyCtxt<'_>, f: F) -> A\n     where\n         F: FnOnce(&dyn HirPrinterSupport<'_>, &hir::Crate) -> A,\n     {\n@@ -228,7 +228,7 @@ impl PpSourceMode {\n trait PrinterSupport: pprust::PpAnn {\n     /// Provides a uniform interface for re-extracting a reference to a\n     /// `Session` from a value that now owns it.\n-    fn sess<'a>(&'a self) -> &'a Session;\n+    fn sess(&self) -> &Session;\n \n     /// Produces the pretty-print annotation object.\n     ///\n@@ -240,7 +240,7 @@ trait PrinterSupport: pprust::PpAnn {\n trait HirPrinterSupport<'hir>: pprust_hir::PpAnn {\n     /// Provides a uniform interface for re-extracting a reference to a\n     /// `Session` from a value that now owns it.\n-    fn sess<'a>(&'a self) -> &'a Session;\n+    fn sess(&self) -> &Session;\n \n     /// Provides a uniform interface for re-extracting a reference to an\n     /// `hir_map::Map` from a value that now owns it.\n@@ -272,7 +272,7 @@ struct NoAnn<'hir> {\n }\n \n impl<'hir> PrinterSupport for NoAnn<'hir> {\n-    fn sess<'a>(&'a self) -> &'a Session {\n+    fn sess(&self) -> &Session {\n         self.sess\n     }\n \n@@ -282,7 +282,7 @@ impl<'hir> PrinterSupport for NoAnn<'hir> {\n }\n \n impl<'hir> HirPrinterSupport<'hir> for NoAnn<'hir> {\n-    fn sess<'a>(&'a self) -> &'a Session {\n+    fn sess(&self) -> &Session {\n         self.sess\n     }\n \n@@ -313,7 +313,7 @@ struct IdentifiedAnnotation<'hir> {\n }\n \n impl<'hir> PrinterSupport for IdentifiedAnnotation<'hir> {\n-    fn sess<'a>(&'a self) -> &'a Session {\n+    fn sess(&self) -> &Session {\n         self.sess\n     }\n \n@@ -360,7 +360,7 @@ impl<'hir> pprust::PpAnn for IdentifiedAnnotation<'hir> {\n }\n \n impl<'hir> HirPrinterSupport<'hir> for IdentifiedAnnotation<'hir> {\n-    fn sess<'a>(&'a self) -> &'a Session {\n+    fn sess(&self) -> &Session {\n         self.sess\n     }\n \n@@ -458,7 +458,7 @@ struct TypedAnnotation<'a, 'tcx> {\n }\n \n impl<'b, 'tcx> HirPrinterSupport<'tcx> for TypedAnnotation<'b, 'tcx> {\n-    fn sess<'a>(&'a self) -> &'a Session {\n+    fn sess(&self) -> &Session {\n         &self.tcx.sess\n     }\n \n@@ -866,8 +866,8 @@ pub fn print_after_hir_lowering<'tcx>(\n // analysis is performed. However, we want to call `phase_3_run_analysis_passes`\n // with a different callback than the standard driver, so that isn't easy.\n // Instead, we call that function ourselves.\n-fn print_with_analysis<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+fn print_with_analysis(\n+    tcx: TyCtxt<'_>,\n     ppm: PpMode,\n     uii: Option<UserIdentifiedItem>,\n     ofile: Option<&Path>,"}, {"sha": "83a0fb486fd9a34c728910a571f74c00b5ea790d", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -1635,7 +1635,7 @@ impl Destination {\n         }\n     }\n \n-    fn writable<'a>(&'a mut self) -> WritableDst<'a> {\n+    fn writable(&mut self) -> WritableDst<'_> {\n         match *self {\n             Destination::Terminal(ref mut t) => WritableDst::Terminal(t),\n             Destination::Buffered(ref mut t) => {"}, {"sha": "1ffee1cdf691f0be08c3fa835c2049a8eebc9696", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -438,26 +438,26 @@ impl Handler {\n         self.err_count.store(0, SeqCst);\n     }\n \n-    pub fn struct_dummy<'a>(&'a self) -> DiagnosticBuilder<'a> {\n+    pub fn struct_dummy(&self) -> DiagnosticBuilder<'_> {\n         DiagnosticBuilder::new(self, Level::Cancelled, \"\")\n     }\n \n-    pub fn struct_span_warn<'a, S: Into<MultiSpan>>(&'a self,\n-                                                    sp: S,\n-                                                    msg: &str)\n-                                                    -> DiagnosticBuilder<'a> {\n+    pub fn struct_span_warn<S: Into<MultiSpan>>(&self,\n+                                                sp: S,\n+                                                msg: &str)\n+                                                -> DiagnosticBuilder<'_> {\n         let mut result = DiagnosticBuilder::new(self, Level::Warning, msg);\n         result.set_span(sp);\n         if !self.flags.can_emit_warnings {\n             result.cancel();\n         }\n         result\n     }\n-    pub fn struct_span_warn_with_code<'a, S: Into<MultiSpan>>(&'a self,\n-                                                              sp: S,\n-                                                              msg: &str,\n-                                                              code: DiagnosticId)\n-                                                              -> DiagnosticBuilder<'a> {\n+    pub fn struct_span_warn_with_code<S: Into<MultiSpan>>(&self,\n+                                                          sp: S,\n+                                                          msg: &str,\n+                                                          code: DiagnosticId)\n+                                                          -> DiagnosticBuilder<'_> {\n         let mut result = DiagnosticBuilder::new(self, Level::Warning, msg);\n         result.set_span(sp);\n         result.code(code);\n@@ -466,63 +466,63 @@ impl Handler {\n         }\n         result\n     }\n-    pub fn struct_warn<'a>(&'a self, msg: &str) -> DiagnosticBuilder<'a> {\n+    pub fn struct_warn(&self, msg: &str) -> DiagnosticBuilder<'_> {\n         let mut result = DiagnosticBuilder::new(self, Level::Warning, msg);\n         if !self.flags.can_emit_warnings {\n             result.cancel();\n         }\n         result\n     }\n-    pub fn struct_span_err<'a, S: Into<MultiSpan>>(&'a self,\n-                                                   sp: S,\n-                                                   msg: &str)\n-                                                   -> DiagnosticBuilder<'a> {\n+    pub fn struct_span_err<S: Into<MultiSpan>>(&self,\n+                                               sp: S,\n+                                               msg: &str)\n+                                               -> DiagnosticBuilder<'_> {\n         let mut result = DiagnosticBuilder::new(self, Level::Error, msg);\n         result.set_span(sp);\n         result\n     }\n-    pub fn struct_span_err_with_code<'a, S: Into<MultiSpan>>(&'a self,\n-                                                             sp: S,\n-                                                             msg: &str,\n-                                                             code: DiagnosticId)\n-                                                             -> DiagnosticBuilder<'a> {\n+    pub fn struct_span_err_with_code<S: Into<MultiSpan>>(&self,\n+                                                         sp: S,\n+                                                         msg: &str,\n+                                                         code: DiagnosticId)\n+                                                         -> DiagnosticBuilder<'_> {\n         let mut result = DiagnosticBuilder::new(self, Level::Error, msg);\n         result.set_span(sp);\n         result.code(code);\n         result\n     }\n     // FIXME: This method should be removed (every error should have an associated error code).\n-    pub fn struct_err<'a>(&'a self, msg: &str) -> DiagnosticBuilder<'a> {\n+    pub fn struct_err(&self, msg: &str) -> DiagnosticBuilder<'_> {\n         DiagnosticBuilder::new(self, Level::Error, msg)\n     }\n-    pub fn struct_err_with_code<'a>(\n-        &'a self,\n+    pub fn struct_err_with_code(\n+        &self,\n         msg: &str,\n         code: DiagnosticId,\n-    ) -> DiagnosticBuilder<'a> {\n+    ) -> DiagnosticBuilder<'_> {\n         let mut result = DiagnosticBuilder::new(self, Level::Error, msg);\n         result.code(code);\n         result\n     }\n-    pub fn struct_span_fatal<'a, S: Into<MultiSpan>>(&'a self,\n-                                                     sp: S,\n-                                                     msg: &str)\n-                                                     -> DiagnosticBuilder<'a> {\n+    pub fn struct_span_fatal<S: Into<MultiSpan>>(&self,\n+                                                 sp: S,\n+                                                 msg: &str)\n+                                                 -> DiagnosticBuilder<'_> {\n         let mut result = DiagnosticBuilder::new(self, Level::Fatal, msg);\n         result.set_span(sp);\n         result\n     }\n-    pub fn struct_span_fatal_with_code<'a, S: Into<MultiSpan>>(&'a self,\n-                                                               sp: S,\n-                                                               msg: &str,\n-                                                               code: DiagnosticId)\n-                                                               -> DiagnosticBuilder<'a> {\n+    pub fn struct_span_fatal_with_code<S: Into<MultiSpan>>(&self,\n+                                                           sp: S,\n+                                                           msg: &str,\n+                                                           code: DiagnosticId)\n+                                                           -> DiagnosticBuilder<'_> {\n         let mut result = DiagnosticBuilder::new(self, Level::Fatal, msg);\n         result.set_span(sp);\n         result.code(code);\n         result\n     }\n-    pub fn struct_fatal<'a>(&'a self, msg: &str) -> DiagnosticBuilder<'a> {\n+    pub fn struct_fatal(&self, msg: &str) -> DiagnosticBuilder<'_> {\n         DiagnosticBuilder::new(self, Level::Fatal, msg)\n     }\n \n@@ -563,10 +563,10 @@ impl Handler {\n     pub fn span_err<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n         self.emit(&sp.into(), msg, Error);\n     }\n-    pub fn mut_span_err<'a, S: Into<MultiSpan>>(&'a self,\n-                                                sp: S,\n-                                                msg: &str)\n-                                                -> DiagnosticBuilder<'a> {\n+    pub fn mut_span_err<S: Into<MultiSpan>>(&self,\n+                                            sp: S,\n+                                            msg: &str)\n+                                            -> DiagnosticBuilder<'_> {\n         let mut result = DiagnosticBuilder::new(self, Level::Error, msg);\n         result.set_span(sp);\n         result\n@@ -605,10 +605,10 @@ impl Handler {\n     pub fn span_note_without_error<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n         self.emit(&sp.into(), msg, Note);\n     }\n-    pub fn span_note_diag<'a>(&'a self,\n-                              sp: Span,\n-                              msg: &str)\n-                              -> DiagnosticBuilder<'a> {\n+    pub fn span_note_diag(&self,\n+                          sp: Span,\n+                          msg: &str)\n+                          -> DiagnosticBuilder<'_> {\n         let mut db = DiagnosticBuilder::new(self, Note, msg);\n         db.set_span(sp);\n         db"}, {"sha": "38dc6edaf6325e8225514cfa1e19cffca77e6217", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -51,7 +51,7 @@ use std::io::Write;\n use syntax::ast;\n use syntax_pos::Span;\n \n-pub fn assert_dep_graph<'tcx>(tcx: TyCtxt<'tcx>) {\n+pub fn assert_dep_graph(tcx: TyCtxt<'_>) {\n     tcx.dep_graph.with_ignore(|| {\n         if tcx.sess.opts.debugging_opts.dump_dep_graph {\n             dump_graph(tcx);"}, {"sha": "046fdc72270dbb5cb48568b760189846c602e169", "filename": "src/librustc_incremental/assert_module_sources.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_module_sources.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -35,7 +35,7 @@ const MODULE: Symbol = sym::module;\n const CFG: Symbol = sym::cfg;\n const KIND: Symbol = sym::kind;\n \n-pub fn assert_module_sources<'tcx>(tcx: TyCtxt<'tcx>) {\n+pub fn assert_module_sources(tcx: TyCtxt<'_>) {\n     tcx.dep_graph.with_ignore(|| {\n         if tcx.sess.opts.incremental.is_none() {\n             return;"}, {"sha": "1d83aa112a8371f7cad7279431d3afac39173bb3", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -206,7 +206,7 @@ impl Assertion {\n     }\n }\n \n-pub fn check_dirty_clean_annotations<'tcx>(tcx: TyCtxt<'tcx>) {\n+pub fn check_dirty_clean_annotations(tcx: TyCtxt<'_>) {\n     // can't add `#[rustc_dirty]` etc without opting in to this feature\n     if !tcx.features().rustc_attrs {\n         return;"}, {"sha": "90aefb0f32416f8bf56358ba695fb78df55ddb41", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -15,7 +15,7 @@ use super::fs::*;\n use super::file_format;\n use super::work_product;\n \n-pub fn dep_graph_tcx_init<'tcx>(tcx: TyCtxt<'tcx>) {\n+pub fn dep_graph_tcx_init(tcx: TyCtxt<'_>) {\n     if !tcx.dep_graph.is_fully_enabled() {\n         return\n     }\n@@ -192,7 +192,7 @@ pub fn load_dep_graph(sess: &Session) -> DepGraphFuture {\n     }))\n }\n \n-pub fn load_query_result_cache<'sess>(sess: &'sess Session) -> OnDiskCache<'sess> {\n+pub fn load_query_result_cache(sess: &Session) -> OnDiskCache<'_> {\n     if sess.opts.incremental.is_none() ||\n        !sess.opts.debugging_opts.incremental_queries {\n         return OnDiskCache::new_empty(sess.source_map());"}, {"sha": "13e2c5d1c574d6aaccf819798681b8ed19638f89", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -15,7 +15,7 @@ use super::dirty_clean;\n use super::file_format;\n use super::work_product;\n \n-pub fn save_dep_graph<'tcx>(tcx: TyCtxt<'tcx>) {\n+pub fn save_dep_graph(tcx: TyCtxt<'_>) {\n     debug!(\"save_dep_graph()\");\n     tcx.dep_graph.with_ignore(|| {\n         let sess = tcx.sess;"}, {"sha": "d698728198130033bd1028f6ba4bb514a7612269", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -878,7 +878,7 @@ pub fn create_global_ctxt(\n \n /// Runs the resolution, type-checking, region checking and other\n /// miscellaneous analysis passes on the crate.\n-fn analysis<'tcx>(tcx: TyCtxt<'tcx>, cnum: CrateNum) -> Result<()> {\n+fn analysis(tcx: TyCtxt<'_>, cnum: CrateNum) -> Result<()> {\n     assert_eq!(cnum, LOCAL_CRATE);\n \n     let sess = tcx.sess;\n@@ -995,8 +995,8 @@ fn analysis<'tcx>(tcx: TyCtxt<'tcx>, cnum: CrateNum) -> Result<()> {\n     Ok(())\n }\n \n-fn encode_and_write_metadata<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+fn encode_and_write_metadata(\n+    tcx: TyCtxt<'_>,\n     outputs: &OutputFilenames,\n ) -> (middle::cstore::EncodedMetadata, bool) {\n     #[derive(PartialEq, Eq, PartialOrd, Ord)]"}, {"sha": "d888c9e57d326e03852fcca0f8929c2ce47c848c", "filename": "src/librustc_interface/proc_macro_decls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_interface%2Fproc_macro_decls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_interface%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fproc_macro_decls.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -6,11 +6,11 @@ use rustc::ty::query::Providers;\n use syntax::attr;\n use syntax::symbol::sym;\n \n-pub fn find<'tcx>(tcx: TyCtxt<'tcx>) -> Option<DefId> {\n+pub fn find(tcx: TyCtxt<'_>) -> Option<DefId> {\n     tcx.proc_macro_decls_static(LOCAL_CRATE)\n }\n \n-fn proc_macro_decls_static<'tcx>(tcx: TyCtxt<'tcx>, cnum: CrateNum) -> Option<DefId> {\n+fn proc_macro_decls_static(tcx: TyCtxt<'_>, cnum: CrateNum) -> Option<DefId> {\n     assert_eq!(cnum, LOCAL_CRATE);\n \n     let mut finder = Finder { decls: None };"}, {"sha": "6ae5e94b11af389d9afc90388c08642785500bda", "filename": "src/librustc_interface/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_interface%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_interface%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Futil.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -642,14 +642,14 @@ pub fn build_output_filenames(\n                 );\n                 None\n             } else {\n+                if !sess.opts.cg.extra_filename.is_empty() {\n+                    sess.warn(\"ignoring -C extra-filename flag due to -o flag\");\n+                }\n                 Some(out_file.clone())\n             };\n             if *odir != None {\n                 sess.warn(\"ignoring --out-dir flag due to -o flag\");\n             }\n-            if !sess.opts.cg.extra_filename.is_empty() {\n-                sess.warn(\"ignoring -C extra-filename flag due to -o flag\");\n-            }\n \n             OutputFilenames {\n                 out_directory: out_file.parent().unwrap_or_else(|| Path::new(\"\")).to_path_buf(),"}, {"sha": "4c6ceb14ca42a8fa0ec4b25a14788c68e584ddd9", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -74,7 +74,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     };\n }\n \n-fn lint_mod<'tcx>(tcx: TyCtxt<'tcx>, module_def_id: DefId) {\n+fn lint_mod(tcx: TyCtxt<'_>, module_def_id: DefId) {\n     lint::late_lint_mod(tcx, module_def_id, BuiltinCombinedModuleLateLintPass::new());\n }\n "}, {"sha": "2db2e0bc0da96b5b0100e41ce5526556bdfd455f", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 41, "deletions": 7, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -48,7 +48,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n         }\n \n         let ty = cx.tables.expr_ty(&expr);\n-        let type_permits_lack_of_use = check_must_use_ty(cx, ty, &expr, s.span, \"\");\n+        let type_permits_lack_of_use = check_must_use_ty(cx, ty, &expr, s.span, \"\", \"\", false);\n \n         let mut fn_warned = false;\n         let mut op_warned = false;\n@@ -133,23 +133,39 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n             ty: Ty<'tcx>,\n             expr: &hir::Expr,\n             span: Span,\n-            descr_post_path: &str,\n+            descr_pre: &str,\n+            descr_post: &str,\n+            plural: bool,\n         ) -> bool {\n             if ty.is_unit() || cx.tcx.is_ty_uninhabited_from(\n                 cx.tcx.hir().get_module_parent(expr.hir_id), ty)\n             {\n                 return true;\n             }\n \n+            let plural_suffix = if plural { \"s\" } else { \"\" };\n+\n             match ty.sty {\n-                ty::Adt(def, _) => check_must_use_def(cx, def.did, span, \"\", descr_post_path),\n+                ty::Adt(..) if ty.is_box() => {\n+                    let boxed_ty = ty.boxed_ty();\n+                    let descr_pre = &format!(\"{}boxed \", descr_pre);\n+                    check_must_use_ty(cx, boxed_ty, expr, span, descr_pre, descr_post, plural)\n+                }\n+                ty::Adt(def, _) => {\n+                    check_must_use_def(cx, def.did, span, descr_pre, descr_post)\n+                }\n                 ty::Opaque(def, _) => {\n                     let mut has_emitted = false;\n                     for (predicate, _) in &cx.tcx.predicates_of(def).predicates {\n                         if let ty::Predicate::Trait(ref poly_trait_predicate) = predicate {\n                             let trait_ref = poly_trait_predicate.skip_binder().trait_ref;\n                             let def_id = trait_ref.def_id;\n-                            if check_must_use_def(cx, def_id, span, \"implementer of \", \"\") {\n+                            let descr_pre = &format!(\n+                                \"{}implementer{} of \",\n+                                descr_pre,\n+                                plural_suffix,\n+                            );\n+                            if check_must_use_def(cx, def_id, span, descr_pre, descr_post) {\n                                 has_emitted = true;\n                                 break;\n                             }\n@@ -162,7 +178,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n                     for predicate in binder.skip_binder().iter() {\n                         if let ty::ExistentialPredicate::Trait(ref trait_ref) = predicate {\n                             let def_id = trait_ref.def_id;\n-                            if check_must_use_def(cx, def_id, span, \"\", \" trait object\") {\n+                            let descr_post = &format!(\n+                                \" trait object{}{}\",\n+                                plural_suffix,\n+                                descr_post,\n+                            );\n+                            if check_must_use_def(cx, def_id, span, descr_pre, descr_post) {\n                                 has_emitted = true;\n                                 break;\n                             }\n@@ -179,14 +200,27 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n                         vec![]\n                     };\n                     for (i, ty) in tys.iter().map(|k| k.expect_ty()).enumerate() {\n-                        let descr_post_path = &format!(\" in tuple element {}\", i);\n+                        let descr_post = &format!(\" in tuple element {}\", i);\n                         let span = *spans.get(i).unwrap_or(&span);\n-                        if check_must_use_ty(cx, ty, expr, span, descr_post_path) {\n+                        if check_must_use_ty(cx, ty, expr, span, descr_pre, descr_post, plural) {\n                             has_emitted = true;\n                         }\n                     }\n                     has_emitted\n                 }\n+                ty::Array(ty, len) => match len.assert_usize(cx.tcx) {\n+                    // If the array is definitely non-empty, we can do `#[must_use]` checking.\n+                    Some(n) if n != 0 => {\n+                        let descr_pre = &format!(\n+                            \"{}array{} of \",\n+                            descr_pre,\n+                            plural_suffix,\n+                        );\n+                        check_must_use_ty(cx, ty, expr, span, descr_pre, descr_post, true)\n+                    }\n+                    // Otherwise, we don't lint, to avoid false positives.\n+                    _ => false,\n+                }\n                 _ => false,\n             }\n         }"}, {"sha": "e9cf7bca25c4bb27c20b0e945508c684357d8ffa", "filename": "src/librustc_macros/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Flib.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -1,6 +1,8 @@\n #![feature(proc_macro_hygiene)]\n #![deny(rust_2018_idioms)]\n \n+#![recursion_limit=\"128\"]\n+\n extern crate proc_macro;\n \n use synstructure::decl_derive;"}, {"sha": "d47bd0580d6cab8c5c5db56428e661e401ecccf5", "filename": "src/librustc_macros/src/query.rs", "status": "modified", "additions": 78, "deletions": 34, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_macros%2Fsrc%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_macros%2Fsrc%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Fquery.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -1,4 +1,5 @@\n use proc_macro::TokenStream;\n+use proc_macro2::{TokenTree, Delimiter};\n use syn::{\n     Token, Ident, Type, Attribute, ReturnType, Expr, Block, Error,\n     braced, parenthesized, parse_macro_input,\n@@ -35,7 +36,7 @@ enum QueryModifier {\n     Desc(Option<Ident>, Punctuated<Expr, Token![,]>),\n \n     /// Cache the query to disk if the `Expr` returns true.\n-    Cache(Option<Ident>, Expr),\n+    Cache(Option<(IdentOrWild, IdentOrWild)>, Block),\n \n     /// Custom code to load the query from disk.\n     LoadCached(Ident, Ident, Block),\n@@ -77,21 +78,26 @@ impl Parse for QueryModifier {\n             };\n             let desc = attr_content.parse_terminated(Expr::parse)?;\n             Ok(QueryModifier::Desc(tcx, desc))\n-        } else if modifier == \"cache\" {\n+        } else if modifier == \"cache_on_disk_if\" {\n             // Parse a cache modifier like:\n-            // `cache { |tcx| key.is_local() }`\n-            let attr_content;\n-            braced!(attr_content in input);\n-            let tcx = if attr_content.peek(Token![|]) {\n-                attr_content.parse::<Token![|]>()?;\n-                let tcx = attr_content.parse()?;\n-                attr_content.parse::<Token![|]>()?;\n-                Some(tcx)\n+            // `cache(tcx, value) { |tcx| key.is_local() }`\n+            let has_args = if let TokenTree::Group(group) = input.fork().parse()? {\n+                group.delimiter() == Delimiter::Parenthesis\n+            } else {\n+                false\n+            };\n+            let args = if has_args {\n+                let args;\n+                parenthesized!(args in input);\n+                let tcx = args.parse()?;\n+                args.parse::<Token![,]>()?;\n+                let value = args.parse()?;\n+                Some((tcx, value))\n             } else {\n                 None\n             };\n-            let expr = attr_content.parse()?;\n-            Ok(QueryModifier::Cache(tcx, expr))\n+            let block = input.parse()?;\n+            Ok(QueryModifier::Cache(args, block))\n         } else if modifier == \"load_cached\" {\n             // Parse a load_cached modifier like:\n             // `load_cached(tcx, id) { tcx.queries.on_disk_cache.try_load_query_result(tcx, id) }`\n@@ -203,8 +209,8 @@ struct QueryModifiers {\n     /// The description of the query.\n     desc: Option<(Option<Ident>, Punctuated<Expr, Token![,]>)>,\n \n-    /// Cache the query to disk if the `Expr` returns true.\n-    cache: Option<(Option<Ident>, Expr)>,\n+    /// Cache the query to disk if the `Block` returns true.\n+    cache: Option<(Option<(IdentOrWild, IdentOrWild)>, Block)>,\n \n     /// Custom code to load the query from disk.\n     load_cached: Option<(Ident, Ident, Block)>,\n@@ -247,11 +253,11 @@ fn process_modifiers(query: &mut Query) -> QueryModifiers {\n                 }\n                 load_cached = Some((tcx, id, block));\n             }\n-            QueryModifier::Cache(tcx, expr) => {\n+            QueryModifier::Cache(args, expr) => {\n                 if cache.is_some() {\n                     panic!(\"duplicate modifier `cache` for query `{}`\", query.name);\n                 }\n-                cache = Some((tcx, expr));\n+                cache = Some((args, expr));\n             }\n             QueryModifier::Desc(tcx, list) => {\n                 if desc.is_some() {\n@@ -321,7 +327,7 @@ fn add_query_description_impl(\n     let key = &query.key.0;\n \n     // Find out if we should cache the query on disk\n-    let cache = modifiers.cache.as_ref().map(|(tcx, expr)| {\n+    let cache = modifiers.cache.as_ref().map(|(args, expr)| {\n         let try_load_from_disk = if let Some((tcx, id, block)) = modifiers.load_cached.as_ref() {\n             // Use custom code to load the query from disk\n             quote! {\n@@ -346,11 +352,22 @@ fn add_query_description_impl(\n             }\n         };\n \n-        let tcx = tcx.as_ref().map(|t| quote! { #t }).unwrap_or(quote! { _ });\n+        let tcx = args.as_ref().map(|t| {\n+            let t = &(t.0).0;\n+            quote! { #t }\n+        }).unwrap_or(quote! { _ });\n+        let value = args.as_ref().map(|t| {\n+            let t = &(t.1).0;\n+            quote! { #t }\n+        }).unwrap_or(quote! { _ });\n         quote! {\n             #[inline]\n             #[allow(unused_variables)]\n-            fn cache_on_disk(#tcx: TyCtxt<'tcx>, #key: Self::Key) -> bool {\n+            fn cache_on_disk(\n+                #tcx: TyCtxt<'tcx>,\n+                #key: Self::Key,\n+                #value: Option<&Self::Value>\n+            ) -> bool {\n                 #expr\n             }\n \n@@ -395,6 +412,7 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n     let mut query_description_stream = quote! {};\n     let mut dep_node_def_stream = quote! {};\n     let mut dep_node_force_stream = quote! {};\n+    let mut try_load_from_on_disk_cache_stream = quote! {};\n     let mut no_force_queries = Vec::new();\n \n     for group in groups.0 {\n@@ -409,6 +427,22 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n                 _ => quote! { #result_full },\n             };\n \n+            if modifiers.cache.is_some() && !modifiers.no_force {\n+                try_load_from_on_disk_cache_stream.extend(quote! {\n+                    DepKind::#name => {\n+                        debug_assert!(tcx.dep_graph\n+                                         .node_color(self)\n+                                         .map(|c| c.is_green())\n+                                         .unwrap_or(false));\n+\n+                        let key = RecoverKey::recover(tcx.global_tcx(), self).unwrap();\n+                        if queries::#name::cache_on_disk(tcx.global_tcx(), key, None) {\n+                            let _ = tcx.#name(key);\n+                        }\n+                    }\n+                });\n+            }\n+\n             let mut attributes = Vec::new();\n \n             // Pass on the fatal_cycle modifier\n@@ -423,20 +457,6 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n             if modifiers.no_hash {\n                 attributes.push(quote! { no_hash });\n             };\n-\n-            let mut attribute_stream = quote! {};\n-\n-            for e in attributes.into_iter().intersperse(quote! {,}) {\n-                attribute_stream.extend(e);\n-            }\n-\n-            // Add the query to the group\n-            group_stream.extend(quote! {\n-                [#attribute_stream] fn #name: #name(#arg) #result,\n-            });\n-\n-            let mut attributes = Vec::new();\n-\n             // Pass on the anon modifier\n             if modifiers.anon {\n                 attributes.push(quote! { anon });\n@@ -450,6 +470,12 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n             for e in attributes.into_iter().intersperse(quote! {,}) {\n                 attribute_stream.extend(e);\n             }\n+\n+            // Add the query to the group\n+            group_stream.extend(quote! {\n+                [#attribute_stream] fn #name: #name(#arg) #result,\n+            });\n+\n             // Create a dep node for the query\n             dep_node_def_stream.extend(quote! {\n                 [#attribute_stream] #name(#arg),\n@@ -470,7 +496,11 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n                 });\n             }\n \n-            add_query_description_impl(&query, modifiers, &mut query_description_stream);\n+            add_query_description_impl(\n+                &query,\n+                modifiers,\n+                &mut query_description_stream,\n+            );\n         }\n         let name = &group.name;\n         query_stream.extend(quote! {\n@@ -520,5 +550,19 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n             }\n         }\n         #query_description_stream\n+\n+        impl DepNode {\n+            /// Check whether the query invocation corresponding to the given\n+            /// DepNode is eligible for on-disk-caching. If so, this is method\n+            /// will execute the query corresponding to the given DepNode.\n+            /// Also, as a sanity check, it expects that the corresponding query\n+            /// invocation has been marked as green already.\n+            pub fn try_load_from_on_disk_cache(&self, tcx: TyCtxt<'_>) {\n+                match self.kind {\n+                    #try_load_from_on_disk_cache_stream\n+                    _ => (),\n+                }\n+            }\n+        }\n     })\n }"}, {"sha": "2073b317939d78acea4e30e8b64071d1fc09c0df", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -868,7 +868,7 @@ impl<'a> CrateLoader<'a> {\n \n     fn inject_profiler_runtime(&mut self) {\n         if self.sess.opts.debugging_opts.profile ||\n-            self.sess.opts.debugging_opts.pgo_gen.enabled()\n+           self.sess.opts.cg.profile_generate.enabled()\n         {\n             info!(\"loading profiler\");\n "}, {"sha": "914084d7e9ece4f489ef6dc9ee62a71c8a201b4e", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -250,7 +250,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     exported_symbols => { Arc::new(cdata.exported_symbols(tcx)) }\n }\n \n-pub fn provide<'tcx>(providers: &mut Providers<'tcx>) {\n+pub fn provide(providers: &mut Providers<'_>) {\n     // FIXME(#44234) - almost all of these queries have no sub-queries and\n     // therefore no actual inputs, they're just reading tables calculated in\n     // resolve! Does this work? Unsure! That's what the issue is about\n@@ -550,7 +550,7 @@ impl CrateStore for cstore::CStore {\n         self.do_postorder_cnums_untracked()\n     }\n \n-    fn encode_metadata<'tcx>(&self, tcx: TyCtxt<'tcx>) -> EncodedMetadata {\n+    fn encode_metadata(&self, tcx: TyCtxt<'_>) -> EncodedMetadata {\n         encoder::encode_metadata(tcx)\n     }\n "}, {"sha": "73c20ccad5abff6cbf9fcd98fd2c957c2e3d033f", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -1863,7 +1863,7 @@ impl<'tcx, 'v> ItemLikeVisitor<'v> for ImplVisitor<'tcx> {\n // will allow us to slice the metadata to the precise length that we just\n // generated regardless of trailing bytes that end up in it.\n \n-pub fn encode_metadata<'tcx>(tcx: TyCtxt<'tcx>) -> EncodedMetadata {\n+pub fn encode_metadata(tcx: TyCtxt<'_>) -> EncodedMetadata {\n     let mut encoder = opaque::Encoder::new(vec![]);\n     encoder.emit_raw_bytes(METADATA_HEADER);\n \n@@ -1905,7 +1905,7 @@ pub fn encode_metadata<'tcx>(tcx: TyCtxt<'tcx>) -> EncodedMetadata {\n     EncodedMetadata { raw_data: result }\n }\n \n-pub fn get_repr_options<'tcx>(tcx: TyCtxt<'tcx>, did: DefId) -> ReprOptions {\n+pub fn get_repr_options(tcx: TyCtxt<'_>, did: DefId) -> ReprOptions {\n     let ty = tcx.type_of(did);\n     match ty.sty {\n         ty::Adt(ref def, _) => return def.repr,"}, {"sha": "b1f4dfffc7898db33a3dc1450c476610bbd93c59", "filename": "src/librustc_metadata/foreign_modules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_metadata%2Fforeign_modules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_metadata%2Fforeign_modules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fforeign_modules.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -3,7 +3,7 @@ use rustc::hir;\n use rustc::middle::cstore::ForeignModule;\n use rustc::ty::TyCtxt;\n \n-pub fn collect<'tcx>(tcx: TyCtxt<'tcx>) -> Vec<ForeignModule> {\n+pub fn collect(tcx: TyCtxt<'_>) -> Vec<ForeignModule> {\n     let mut collector = Collector {\n         tcx,\n         modules: Vec::new(),"}, {"sha": "728fd004fcb693a2ce8b71b88b6746a9bcb65212", "filename": "src/librustc_metadata/link_args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_metadata%2Flink_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_metadata%2Flink_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flink_args.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -4,7 +4,7 @@ use rustc::ty::TyCtxt;\n use rustc_target::spec::abi::Abi;\n use syntax::symbol::sym;\n \n-pub fn collect<'tcx>(tcx: TyCtxt<'tcx>) -> Vec<String> {\n+pub fn collect(tcx: TyCtxt<'_>) -> Vec<String> {\n     let mut collector = Collector {\n         args: Vec::new(),\n     };"}, {"sha": "4a01d0e559af411a08bb62e8db33faf68518792b", "filename": "src/librustc_metadata/native_libs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_metadata%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_metadata%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fnative_libs.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -11,7 +11,7 @@ use syntax::feature_gate::{self, GateIssue};\n use syntax::symbol::{Symbol, sym};\n use syntax::{span_err, struct_span_err};\n \n-pub fn collect<'tcx>(tcx: TyCtxt<'tcx>) -> Vec<NativeLibrary> {\n+pub fn collect(tcx: TyCtxt<'_>) -> Vec<NativeLibrary> {\n     let mut collector = Collector {\n         tcx,\n         libs: Vec::new(),"}, {"sha": "25ac93cc2422c1559b4dcc551cf2beda2e321e42", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -87,7 +87,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     };\n }\n \n-fn mir_borrowck<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> BorrowCheckResult<'tcx> {\n+fn mir_borrowck(tcx: TyCtxt<'_>, def_id: DefId) -> BorrowCheckResult<'_> {\n     let input_body = tcx.mir_validated(def_id);\n     debug!(\"run query mir_borrowck: {}\", tcx.def_path_str(def_id));\n \n@@ -275,7 +275,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n     mbcx.analyze_results(&mut state); // entry point for DataflowResultsConsumer\n \n     // Convert any reservation warnings into lints.\n-    let reservation_warnings = mem::replace(&mut mbcx.reservation_warnings, Default::default());\n+    let reservation_warnings = mem::take(&mut mbcx.reservation_warnings);\n     for (_, (place, span, location, bk, borrow)) in reservation_warnings {\n         let mut initial_diag =\n             mbcx.report_conflicting_borrow(location, (&place, span), bk, &borrow);"}, {"sha": "b5630251e5830942b194ebc3edcc61c8b3d71a8a", "filename": "src/librustc_mir/borrow_check/nll/constraints/graph.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fgraph.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -1,6 +1,6 @@\n use crate::borrow_check::nll::type_check::Locations;\n-use crate::borrow_check::nll::constraints::ConstraintIndex;\n-use crate::borrow_check::nll::constraints::{ConstraintSet, OutlivesConstraint};\n+use crate::borrow_check::nll::constraints::OutlivesConstraintIndex;\n+use crate::borrow_check::nll::constraints::{OutlivesConstraintSet, OutlivesConstraint};\n use rustc::mir::ConstraintCategory;\n use rustc::ty::RegionVid;\n use rustc_data_structures::graph;\n@@ -12,8 +12,8 @@ use syntax_pos::DUMMY_SP;\n /// -> R2` or `R2 -> R1` depending on the direction type `D`.\n crate struct ConstraintGraph<D: ConstraintGraphDirecton> {\n     _direction: D,\n-    first_constraints: IndexVec<RegionVid, Option<ConstraintIndex>>,\n-    next_constraints: IndexVec<ConstraintIndex, Option<ConstraintIndex>>,\n+    first_constraints: IndexVec<RegionVid, Option<OutlivesConstraintIndex>>,\n+    next_constraints: IndexVec<OutlivesConstraintIndex, Option<OutlivesConstraintIndex>>,\n }\n \n crate type NormalConstraintGraph = ConstraintGraph<Normal>;\n@@ -77,13 +77,13 @@ impl<D: ConstraintGraphDirecton> ConstraintGraph<D> {\n     /// reporting.\n     crate fn new(\n         direction: D,\n-        set: &ConstraintSet,\n+        set: &OutlivesConstraintSet,\n         num_region_vars: usize,\n     ) -> Self {\n         let mut first_constraints = IndexVec::from_elem_n(None, num_region_vars);\n-        let mut next_constraints = IndexVec::from_elem(None, &set.constraints);\n+        let mut next_constraints = IndexVec::from_elem(None, &set.outlives);\n \n-        for (idx, constraint) in set.constraints.iter_enumerated().rev() {\n+        for (idx, constraint) in set.outlives.iter_enumerated().rev() {\n             let head = &mut first_constraints[D::start_region(constraint)];\n             let next = &mut next_constraints[idx];\n             debug_assert!(next.is_none());\n@@ -103,7 +103,7 @@ impl<D: ConstraintGraphDirecton> ConstraintGraph<D> {\n     /// and not constraints.\n     crate fn region_graph<'rg>(\n         &'rg self,\n-        set: &'rg ConstraintSet,\n+        set: &'rg OutlivesConstraintSet,\n         static_region: RegionVid,\n     ) -> RegionGraph<'rg, D> {\n         RegionGraph::new(set, self, static_region)\n@@ -113,7 +113,7 @@ impl<D: ConstraintGraphDirecton> ConstraintGraph<D> {\n     crate fn outgoing_edges<'a>(\n         &'a self,\n         region_sup: RegionVid,\n-        constraints: &'a ConstraintSet,\n+        constraints: &'a OutlivesConstraintSet,\n         static_region: RegionVid,\n     ) -> Edges<'a, D> {\n         //if this is the `'static` region and the graph's direction is normal,\n@@ -142,8 +142,8 @@ impl<D: ConstraintGraphDirecton> ConstraintGraph<D> {\n \n crate struct Edges<'s, D: ConstraintGraphDirecton> {\n     graph: &'s ConstraintGraph<D>,\n-    constraints: &'s ConstraintSet,\n-    pointer: Option<ConstraintIndex>,\n+    constraints: &'s OutlivesConstraintSet,\n+    pointer: Option<OutlivesConstraintIndex>,\n     next_static_idx: Option<usize>,\n     static_region: RegionVid,\n }\n@@ -180,7 +180,7 @@ impl<'s, D: ConstraintGraphDirecton> Iterator for Edges<'s, D> {\n /// reverse) constraint graph. It implements the graph traits and is\n /// usd for doing the SCC computation.\n crate struct RegionGraph<'s, D: ConstraintGraphDirecton> {\n-    set: &'s ConstraintSet,\n+    set: &'s OutlivesConstraintSet,\n     constraint_graph: &'s ConstraintGraph<D>,\n     static_region: RegionVid,\n }\n@@ -191,7 +191,7 @@ impl<'s, D: ConstraintGraphDirecton> RegionGraph<'s, D> {\n     /// construct SCCs for region inference but also for error\n     /// reporting.\n     crate fn new(\n-        set: &'s ConstraintSet,\n+        set: &'s OutlivesConstraintSet,\n         constraint_graph: &'s ConstraintGraph<D>,\n         static_region: RegionVid,\n     ) -> Self {\n@@ -234,10 +234,10 @@ impl<'s, D: ConstraintGraphDirecton> graph::WithNumNodes for RegionGraph<'s, D>\n }\n \n impl<'s, D: ConstraintGraphDirecton> graph::WithSuccessors for RegionGraph<'s, D> {\n-    fn successors<'graph>(\n-        &'graph self,\n+    fn successors(\n+        &self,\n         node: Self::Node,\n-    ) -> <Self as graph::GraphSuccessors<'graph>>::Iter {\n+    ) -> <Self as graph::GraphSuccessors<'_>>::Iter {\n         self.outgoing_regions(node)\n     }\n }"}, {"sha": "6121ed0cf0d1c3282b87dc813de3f85b294e8407", "filename": "src/librustc_mir/borrow_check/nll/constraints/mod.rs", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fmod.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -1,37 +1,40 @@\n+use crate::borrow_check::nll::type_check::Locations;\n use rustc::mir::ConstraintCategory;\n use rustc::ty::RegionVid;\n use rustc_data_structures::graph::scc::Sccs;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n-use crate::borrow_check::nll::type_check::Locations;\n-\n use std::fmt;\n-use std::ops::Deref;\n+use std::ops::Index;\n \n crate mod graph;\n \n+/// A set of NLL region constraints. These include \"outlives\"\n+/// constraints of the form `R1: R2`. Each constraint is identified by\n+/// a unique `OutlivesConstraintIndex` and you can index into the set\n+/// (`constraint_set[i]`) to access the constraint details.\n #[derive(Clone, Default)]\n-crate struct ConstraintSet {\n-    constraints: IndexVec<ConstraintIndex, OutlivesConstraint>,\n+crate struct OutlivesConstraintSet {\n+    outlives: IndexVec<OutlivesConstraintIndex, OutlivesConstraint>,\n }\n \n-impl ConstraintSet {\n+impl OutlivesConstraintSet {\n     crate fn push(&mut self, constraint: OutlivesConstraint) {\n         debug!(\n-            \"ConstraintSet::push({:?}: {:?} @ {:?}\",\n+            \"OutlivesConstraintSet::push({:?}: {:?} @ {:?}\",\n             constraint.sup, constraint.sub, constraint.locations\n         );\n         if constraint.sup == constraint.sub {\n             // 'a: 'a is pretty uninteresting\n             return;\n         }\n-        self.constraints.push(constraint);\n+        self.outlives.push(constraint);\n     }\n \n     /// Constructs a \"normal\" graph from the constraint set; the graph makes it\n     /// easy to find the constraints affecting a particular region.\n     ///\n     /// N.B., this graph contains a \"frozen\" view of the current\n-    /// constraints. Any new constraints added to the `ConstraintSet`\n+    /// constraints. Any new constraints added to the `OutlivesConstraintSet`\n     /// after the graph is built will not be present in the graph.\n     crate fn graph(&self, num_region_vars: usize) -> graph::NormalConstraintGraph {\n         graph::ConstraintGraph::new(graph::Normal, self, num_region_vars)\n@@ -54,13 +57,17 @@ impl ConstraintSet {\n         let region_graph = &constraint_graph.region_graph(self, static_region);\n         Sccs::new(region_graph)\n     }\n+\n+    crate fn outlives(&self) -> &IndexVec<OutlivesConstraintIndex, OutlivesConstraint> {\n+        &self.outlives\n+    }\n }\n \n-impl Deref for ConstraintSet {\n-    type Target = IndexVec<ConstraintIndex, OutlivesConstraint>;\n+impl Index<OutlivesConstraintIndex> for OutlivesConstraintSet {\n+    type Output = OutlivesConstraint;\n \n-    fn deref(&self) -> &Self::Target {\n-        &self.constraints\n+    fn index(&self, i: OutlivesConstraintIndex) -> &Self::Output {\n+        &self.outlives[i]\n     }\n }\n \n@@ -94,8 +101,8 @@ impl fmt::Debug for OutlivesConstraint {\n }\n \n newtype_index! {\n-    pub struct ConstraintIndex {\n-        DEBUG_FORMAT = \"ConstraintIndex({})\"\n+    pub struct OutlivesConstraintIndex {\n+        DEBUG_FORMAT = \"OutlivesConstraintIndex({})\"\n     }\n }\n "}, {"sha": "b5e2e111f38e518828a10d30581ed9badf3adef3", "filename": "src/librustc_mir/borrow_check/nll/member_constraints.rs", "status": "added", "additions": 235, "deletions": 0, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmember_constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmember_constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmember_constraints.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -0,0 +1,235 @@\n+use crate::rustc::ty::{self, Ty};\n+use rustc::hir::def_id::DefId;\n+use rustc::infer::region_constraints::MemberConstraint;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n+use std::hash::Hash;\n+use std::ops::Index;\n+use syntax_pos::Span;\n+\n+/// Compactly stores a set of `R0 member of [R1...Rn]` constraints,\n+/// indexed by the region `R0`.\n+crate struct MemberConstraintSet<'tcx, R>\n+where\n+    R: Copy + Hash + Eq,\n+{\n+    /// Stores the first \"member\" constraint for a given `R0`. This is an\n+    /// index into the `constraints` vector below.\n+    first_constraints: FxHashMap<R, NllMemberConstraintIndex>,\n+\n+    /// Stores the data about each `R0 member of [R1..Rn]` constraint.\n+    /// These are organized into a linked list, so each constraint\n+    /// contains the index of the next constraint with the same `R0`.\n+    constraints: IndexVec<NllMemberConstraintIndex, NllMemberConstraint<'tcx>>,\n+\n+    /// Stores the `R1..Rn` regions for *all* sets. For any given\n+    /// constraint, we keep two indices so that we can pull out a\n+    /// slice.\n+    choice_regions: Vec<ty::RegionVid>,\n+}\n+\n+/// Represents a `R0 member of [R1..Rn]` constraint\n+crate struct NllMemberConstraint<'tcx> {\n+    next_constraint: Option<NllMemberConstraintIndex>,\n+\n+    /// The opaque type whose hidden type is being inferred. (Used in error reporting.)\n+    crate opaque_type_def_id: DefId,\n+\n+    /// The span where the hidden type was instantiated.\n+    crate definition_span: Span,\n+\n+    /// The hidden type in which `R0` appears. (Used in error reporting.)\n+    crate hidden_ty: Ty<'tcx>,\n+\n+    /// The region `R0`.\n+    crate member_region_vid: ty::RegionVid,\n+\n+    /// Index of `R1` in `choice_regions` vector from `MemberConstraintSet`.\n+    start_index: usize,\n+\n+    /// Index of `Rn` in `choice_regions` vector from `MemberConstraintSet`.\n+    end_index: usize,\n+}\n+\n+newtype_index! {\n+    crate struct NllMemberConstraintIndex {\n+        DEBUG_FORMAT = \"MemberConstraintIndex({})\"\n+    }\n+}\n+\n+impl Default for MemberConstraintSet<'tcx, ty::RegionVid> {\n+    fn default() -> Self {\n+        Self {\n+            first_constraints: Default::default(),\n+            constraints: Default::default(),\n+            choice_regions: Default::default(),\n+        }\n+    }\n+}\n+\n+impl<'tcx> MemberConstraintSet<'tcx, ty::RegionVid> {\n+    /// Pushes a member constraint into the set.\n+    ///\n+    /// The input member constraint `m_c` is in the form produced by\n+    /// the the `rustc::infer` code.\n+    ///\n+    /// The `to_region_vid` callback fn is used to convert the regions\n+    /// within into `RegionVid` format -- it typically consults the\n+    /// `UniversalRegions` data structure that is known to the caller\n+    /// (but which this code is unaware of).\n+    crate fn push_constraint(\n+        &mut self,\n+        m_c: &MemberConstraint<'tcx>,\n+        mut to_region_vid: impl FnMut(ty::Region<'tcx>) -> ty::RegionVid,\n+    ) {\n+        debug!(\"push_constraint(m_c={:?})\", m_c);\n+        let member_region_vid: ty::RegionVid = to_region_vid(m_c.member_region);\n+        let next_constraint = self.first_constraints.get(&member_region_vid).cloned();\n+        let start_index = self.choice_regions.len();\n+        let end_index = start_index + m_c.choice_regions.len();\n+        debug!(\"push_constraint: member_region_vid={:?}\", member_region_vid);\n+        let constraint_index = self.constraints.push(NllMemberConstraint {\n+            next_constraint,\n+            member_region_vid,\n+            opaque_type_def_id: m_c.opaque_type_def_id,\n+            definition_span: m_c.definition_span,\n+            hidden_ty: m_c.hidden_ty,\n+            start_index,\n+            end_index,\n+        });\n+        self.first_constraints.insert(member_region_vid, constraint_index);\n+        self.choice_regions.extend(m_c.choice_regions.iter().map(|&r| to_region_vid(r)));\n+    }\n+}\n+\n+impl<R1> MemberConstraintSet<'tcx, R1>\n+where\n+    R1: Copy + Hash + Eq,\n+{\n+    /// Remap the \"member region\" key using `map_fn`, producing a new\n+    /// member constraint set.  This is used in the NLL code to map from\n+    /// the original `RegionVid` to an scc index. In some cases, we\n+    /// may have multiple `R1` values mapping to the same `R2` key -- that\n+    /// is ok, the two sets will be merged.\n+    crate fn into_mapped<R2>(\n+        self,\n+        mut map_fn: impl FnMut(R1) -> R2,\n+    ) -> MemberConstraintSet<'tcx, R2>\n+    where\n+        R2: Copy + Hash + Eq,\n+    {\n+        // We can re-use most of the original data, just tweaking the\n+        // linked list links a bit.\n+        //\n+        // For example if we had two keys `Ra` and `Rb` that both now\n+        // wind up mapped to the same key `S`, we would append the\n+        // linked list for `Ra` onto the end of the linked list for\n+        // `Rb` (or vice versa) -- this basically just requires\n+        // rewriting the final link from one list to point at the othe\n+        // other (see `append_list`).\n+\n+        let MemberConstraintSet { first_constraints, mut constraints, choice_regions } = self;\n+\n+        let mut first_constraints2 = FxHashMap::default();\n+        first_constraints2.reserve(first_constraints.len());\n+\n+        for (r1, start1) in first_constraints {\n+            let r2 = map_fn(r1);\n+            if let Some(&start2) = first_constraints2.get(&r2) {\n+                append_list(&mut constraints, start1, start2);\n+            }\n+            first_constraints2.insert(r2, start1);\n+        }\n+\n+        MemberConstraintSet {\n+            first_constraints: first_constraints2,\n+            constraints,\n+            choice_regions,\n+        }\n+    }\n+}\n+\n+impl<R> MemberConstraintSet<'tcx, R>\n+where\n+    R: Copy + Hash + Eq,\n+{\n+    crate fn all_indices(\n+        &self,\n+    ) -> impl Iterator<Item = NllMemberConstraintIndex> {\n+        self.constraints.indices()\n+    }\n+\n+    /// Iterate down the constraint indices associated with a given\n+    /// peek-region.  You can then use `choice_regions` and other\n+    /// methods to access data.\n+    crate fn indices(\n+        &self,\n+        member_region_vid: R,\n+    ) -> impl Iterator<Item = NllMemberConstraintIndex> + '_ {\n+        let mut next = self.first_constraints.get(&member_region_vid).cloned();\n+        std::iter::from_fn(move || -> Option<NllMemberConstraintIndex> {\n+            if let Some(current) = next {\n+                next = self.constraints[current].next_constraint;\n+                Some(current)\n+            } else {\n+                None\n+            }\n+        })\n+    }\n+\n+    /// Returns the \"choice regions\" for a given member\n+    /// constraint. This is the `R1..Rn` from a constraint like:\n+    ///\n+    /// ```\n+    /// R0 member of [R1..Rn]\n+    /// ```\n+    crate fn choice_regions(&self, pci: NllMemberConstraintIndex) -> &[ty::RegionVid] {\n+        let NllMemberConstraint { start_index, end_index, .. } = &self.constraints[pci];\n+        &self.choice_regions[*start_index..*end_index]\n+    }\n+}\n+\n+impl<'tcx, R> Index<NllMemberConstraintIndex> for MemberConstraintSet<'tcx, R>\n+where\n+    R: Copy + Hash + Eq,\n+{\n+    type Output = NllMemberConstraint<'tcx>;\n+\n+    fn index(&self, i: NllMemberConstraintIndex) -> &NllMemberConstraint<'tcx> {\n+        &self.constraints[i]\n+    }\n+}\n+\n+/// Given a linked list starting at `source_list` and another linked\n+/// list starting at `target_list`, modify `target_list` so that it is\n+/// followed by `source_list`.\n+///\n+/// Before:\n+///\n+/// ```\n+/// target_list: A -> B -> C -> (None)\n+/// source_list: D -> E -> F -> (None)\n+/// ```\n+///\n+/// After:\n+///\n+/// ```\n+/// target_list: A -> B -> C -> D -> E -> F -> (None)\n+/// ```\n+fn append_list(\n+    constraints: &mut IndexVec<NllMemberConstraintIndex, NllMemberConstraint<'_>>,\n+    target_list: NllMemberConstraintIndex,\n+    source_list: NllMemberConstraintIndex,\n+) {\n+    let mut p = target_list;\n+    loop {\n+        let mut r = &mut constraints[p];\n+        match r.next_constraint {\n+            Some(q) => p = q,\n+            None => {\n+                r.next_constraint = Some(source_list);\n+                return;\n+            }\n+        }\n+    }\n+}"}, {"sha": "eb63e0de195e5d6692d56ad9e94d9edb4514ab3e", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -37,6 +37,7 @@ crate mod type_check;\n mod universal_regions;\n \n mod constraints;\n+mod member_constraints;\n \n use self::facts::AllFacts;\n use self::region_infer::RegionInferenceContext;\n@@ -129,6 +130,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n         placeholder_index_to_region: _,\n         mut liveness_constraints,\n         outlives_constraints,\n+        member_constraints,\n         closure_bounds_mapping,\n         type_tests,\n     } = constraints;\n@@ -150,6 +152,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n         universal_region_relations,\n         body,\n         outlives_constraints,\n+        member_constraints,\n         closure_bounds_mapping,\n         type_tests,\n         liveness_constraints,"}, {"sha": "d4f6ce8801e63689639e3949c20cadca1a1d619b", "filename": "src/librustc_mir/borrow_check/nll/region_infer/dump_mir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -71,7 +71,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             }\n         }\n \n-        let mut constraints: Vec<_> = self.constraints.iter().collect();\n+        let mut constraints: Vec<_> = self.constraints.outlives().iter().collect();\n         constraints.sort();\n         for constraint in &constraints {\n             let OutlivesConstraint {"}, {"sha": "9e08961f440f2ab42ae1c05eac54047e31c53228", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/mod.rs", "status": "modified", "additions": 35, "deletions": 6, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -1,4 +1,5 @@\n use crate::borrow_check::nll::constraints::OutlivesConstraint;\n+use crate::borrow_check::nll::region_infer::AppliedMemberConstraint;\n use crate::borrow_check::nll::region_infer::RegionInferenceContext;\n use crate::borrow_check::nll::type_check::Locations;\n use crate::borrow_check::nll::universal_regions::DefiningTy;\n@@ -195,6 +196,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                         Trace::NotVisited => {\n                             bug!(\"found unvisited region {:?} on path to {:?}\", p, r)\n                         }\n+\n                         Trace::FromOutlivesConstraint(c) => {\n                             result.push(c);\n                             p = c.sup;\n@@ -211,10 +213,30 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             // Otherwise, walk over the outgoing constraints and\n             // enqueue any regions we find, keeping track of how we\n             // reached them.\n+\n+            // A constraint like `'r: 'x` can come from our constraint\n+            // graph.\n             let fr_static = self.universal_regions.fr_static;\n-            for constraint in self.constraint_graph\n-                .outgoing_edges(r, &self.constraints, fr_static)\n-            {\n+            let outgoing_edges_from_graph = self.constraint_graph\n+                .outgoing_edges(r, &self.constraints, fr_static);\n+\n+\n+            // But member constraints can also give rise to `'r: 'x`\n+            // edges that were not part of the graph initially, so\n+            // watch out for those.\n+            let outgoing_edges_from_picks = self.applied_member_constraints(r)\n+                .iter()\n+                .map(|&AppliedMemberConstraint { min_choice, member_constraint_index, .. }| {\n+                    let p_c = &self.member_constraints[member_constraint_index];\n+                    OutlivesConstraint {\n+                        sup: r,\n+                        sub: min_choice,\n+                        locations: Locations::All(p_c.definition_span),\n+                        category: ConstraintCategory::OpaqueType,\n+                    }\n+                });\n+\n+            for constraint in outgoing_edges_from_graph.chain(outgoing_edges_from_picks) {\n                 debug_assert_eq!(constraint.sup, r);\n                 let sub_region = constraint.sub;\n                 if let Trace::NotVisited = context[sub_region] {\n@@ -687,7 +709,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n     // Finds some region R such that `fr1: R` and `R` is live at\n     // `elem`.\n-    crate fn find_sub_region_live_at(&self, fr1: RegionVid, elem: Location) -> RegionVid {\n+    crate fn find_sub_region_live_at(\n+        &self,\n+        fr1: RegionVid,\n+        elem: Location,\n+    ) -> RegionVid {\n         debug!(\"find_sub_region_live_at(fr1={:?}, elem={:?})\", fr1, elem);\n         self.find_constraint_paths_between_regions(fr1, |r| {\n             // First look for some `r` such that `fr1: r` and `r` is live at `elem`\n@@ -729,8 +755,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         fr1: RegionVid,\n         fr2: RegionVid,\n     ) -> (ConstraintCategory, Span) {\n-        let (category, _, span) =\n-            self.best_blame_constraint(body, fr1, |r| self.provides_universal_region(r, fr1, fr2));\n+        let (category, _, span) = self.best_blame_constraint(\n+            body,\n+            fr1,\n+            |r| self.provides_universal_region(r, fr1, fr2),\n+        );\n         (category, span)\n     }\n "}, {"sha": "fdf2af9f44ebcae25a6825d8753f5611a01f0ac1", "filename": "src/librustc_mir/borrow_check/nll/region_infer/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fgraphviz.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -63,7 +63,7 @@ impl<'a, 'this, 'tcx> dot::GraphWalk<'this> for RawConstraints<'a, 'tcx> {\n         vids.into()\n     }\n     fn edges(&'this self) -> dot::Edges<'this, OutlivesConstraint> {\n-        (&self.regioncx.constraints.raw[..]).into()\n+        (&self.regioncx.constraints.outlives().raw[..]).into()\n     }\n \n     // Render `a: b` as `a -> b`, indicating the flow"}, {"sha": "4e609460c1f70aeb92ac635c032b79a7e23ae7f1", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 350, "deletions": 120, "changes": 470, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -1,25 +1,32 @@\n use super::universal_regions::UniversalRegions;\n use crate::borrow_check::nll::constraints::graph::NormalConstraintGraph;\n-use crate::borrow_check::nll::constraints::{ConstraintSccIndex, ConstraintSet, OutlivesConstraint};\n+use crate::borrow_check::nll::constraints::{\n+    ConstraintSccIndex, OutlivesConstraint, OutlivesConstraintSet,\n+};\n+use crate::borrow_check::nll::member_constraints::{MemberConstraintSet, NllMemberConstraintIndex};\n use crate::borrow_check::nll::region_infer::values::{\n-    PlaceholderIndices, RegionElement, ToElementIndex\n+    PlaceholderIndices, RegionElement, ToElementIndex,\n };\n-use crate::borrow_check::Upvar;\n use crate::borrow_check::nll::type_check::free_region_relations::UniversalRegionRelations;\n use crate::borrow_check::nll::type_check::Locations;\n+use crate::borrow_check::Upvar;\n use rustc::hir::def_id::DefId;\n-use rustc::infer::canonical::QueryRegionConstraint;\n+use rustc::infer::canonical::QueryOutlivesConstraint;\n+use rustc::infer::opaque_types;\n use rustc::infer::region_constraints::{GenericKind, VarInfos, VerifyBound};\n use rustc::infer::{InferCtxt, NLLRegionVariableOrigin, RegionVariableOrigin};\n use rustc::mir::{\n-    ClosureOutlivesRequirement, ClosureOutlivesSubject, ClosureRegionRequirements,\n-    ConstraintCategory, Local, Location, Body,\n+    Body, ClosureOutlivesRequirement, ClosureOutlivesSubject, ClosureRegionRequirements,\n+    ConstraintCategory, Local, Location,\n };\n use rustc::ty::{self, subst::SubstsRef, RegionVid, Ty, TyCtxt, TypeFoldable};\n use rustc::util::common::{self, ErrorReported};\n+use rustc_data_structures::binary_search_util;\n use rustc_data_structures::bit_set::BitSet;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::graph::WithSuccessors;\n use rustc_data_structures::graph::scc::Sccs;\n+use rustc_data_structures::graph::vec_graph::VecGraph;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_errors::{Diagnostic, DiagnosticBuilder};\n use syntax_pos::Span;\n@@ -49,17 +56,31 @@ pub struct RegionInferenceContext<'tcx> {\n     liveness_constraints: LivenessValues<RegionVid>,\n \n     /// The outlives constraints computed by the type-check.\n-    constraints: Rc<ConstraintSet>,\n+    constraints: Rc<OutlivesConstraintSet>,\n \n     /// The constraint-set, but in graph form, making it easy to traverse\n     /// the constraints adjacent to a particular region. Used to construct\n     /// the SCC (see `constraint_sccs`) and for error reporting.\n     constraint_graph: Rc<NormalConstraintGraph>,\n \n-    /// The SCC computed from `constraints` and the constraint graph. Used to\n+    /// The SCC computed from `constraints` and the constraint\n+    /// graph. We have an edge from SCC A to SCC B if `A: B`. Used to\n     /// compute the values of each region.\n     constraint_sccs: Rc<Sccs<RegionVid, ConstraintSccIndex>>,\n \n+    /// Reverse of the SCC constraint graph -- i.e., an edge `A -> B`\n+    /// exists if `B: A`. Computed lazilly.\n+    rev_constraint_graph: Option<Rc<VecGraph<ConstraintSccIndex>>>,\n+\n+    /// The \"R0 member of [R1..Rn]\" constraints, indexed by SCC.\n+    member_constraints: Rc<MemberConstraintSet<'tcx, ConstraintSccIndex>>,\n+\n+    /// Records the member constraints that we applied to each scc.\n+    /// This is useful for error reporting. Once constraint\n+    /// propagation is done, this vector is sorted according to\n+    /// `member_region_scc`.\n+    member_constraints_applied: Vec<AppliedMemberConstraint>,\n+\n     /// Map closure bounds to a `Span` that should be used for error reporting.\n     closure_bounds_mapping:\n         FxHashMap<Location, FxHashMap<(RegionVid, RegionVid), (ConstraintCategory, Span)>>,\n@@ -95,6 +116,32 @@ pub struct RegionInferenceContext<'tcx> {\n     universal_region_relations: Rc<UniversalRegionRelations<'tcx>>,\n }\n \n+/// Each time that `apply_member_constraint` is successful, it appends\n+/// one of these structs to the `member_constraints_applied` field.\n+/// This is used in error reporting to trace out what happened.\n+///\n+/// The way that `apply_member_constraint` works is that it effectively\n+/// adds a new lower bound to the SCC it is analyzing: so you wind up\n+/// with `'R: 'O` where `'R` is the pick-region and `'O` is the\n+/// minimal viable option.\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]\n+struct AppliedMemberConstraint {\n+    /// The SCC that was affected. (The \"member region\".)\n+    ///\n+    /// The vector if `AppliedMemberConstraint` elements is kept sorted\n+    /// by this field.\n+    member_region_scc: ConstraintSccIndex,\n+\n+    /// The \"best option\" that `apply_member_constraint` found -- this was\n+    /// added as an \"ad-hoc\" lower-bound to `member_region_scc`.\n+    min_choice: ty::RegionVid,\n+\n+    /// The \"member constraint index\" -- we can find out details about\n+    /// the constraint from\n+    /// `set.member_constraints[member_constraint_index]`.\n+    member_constraint_index: NllMemberConstraintIndex,\n+}\n+\n struct RegionDefinition<'tcx> {\n     /// What kind of variable is this -- a free region? existential\n     /// variable? etc. (See the `NLLRegionVariableOrigin` for more\n@@ -186,7 +233,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         placeholder_indices: Rc<PlaceholderIndices>,\n         universal_region_relations: Rc<UniversalRegionRelations<'tcx>>,\n         _body: &Body<'tcx>,\n-        outlives_constraints: ConstraintSet,\n+        outlives_constraints: OutlivesConstraintSet,\n+        member_constraints_in: MemberConstraintSet<'tcx, RegionVid>,\n         closure_bounds_mapping: FxHashMap<\n             Location,\n             FxHashMap<(RegionVid, RegionVid), (ConstraintCategory, Span)>,\n@@ -218,12 +266,18 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         let scc_representatives = Self::compute_scc_representatives(&constraint_sccs, &definitions);\n \n+        let member_constraints =\n+            Rc::new(member_constraints_in.into_mapped(|r| constraint_sccs.scc(r)));\n+\n         let mut result = Self {\n             definitions,\n             liveness_constraints,\n             constraints,\n             constraint_graph,\n             constraint_sccs,\n+            rev_constraint_graph: None,\n+            member_constraints,\n+            member_constraints_applied: Vec::new(),\n             closure_bounds_mapping,\n             scc_universes,\n             scc_representatives,\n@@ -341,9 +395,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                         debug!(\n                             \"init_free_and_bound_regions: placeholder {:?} is \\\n                              not compatible with universe {:?} of its SCC {:?}\",\n-                            placeholder,\n-                            scc_universe,\n-                            scc,\n+                            placeholder, scc_universe, scc,\n                         );\n                         self.add_incompatible_universe(scc);\n                     }\n@@ -394,6 +446,18 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         self.scc_universes[scc]\n     }\n \n+    /// Once region solving has completed, this function will return\n+    /// the member constraints that were applied to the value of a given\n+    /// region `r`. See `AppliedMemberConstraint`.\n+    fn applied_member_constraints(&self, r: impl ToRegionVid) -> &[AppliedMemberConstraint] {\n+        let scc = self.constraint_sccs.scc(r.to_region_vid());\n+        binary_search_util::binary_search_slice(\n+            &self.member_constraints_applied,\n+            |applied| applied.member_region_scc,\n+            &scc,\n+        )\n+    }\n+\n     /// Performs region inference and report errors if we see any\n     /// unsatisfiable constraints. If this is a closure, returns the\n     /// region requirements to propagate to our creator, if any.\n@@ -428,11 +492,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // to store those. Otherwise, we'll pass in `None` to the\n         // functions below, which will trigger them to report errors\n         // eagerly.\n-        let mut outlives_requirements = if infcx.tcx.is_closure(mir_def_id) {\n-            Some(vec![])\n-        } else {\n-            None\n-        };\n+        let mut outlives_requirements =\n+            if infcx.tcx.is_closure(mir_def_id) { Some(vec![]) } else { None };\n \n         self.check_type_tests(\n             infcx,\n@@ -451,16 +512,15 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             errors_buffer,\n         );\n \n+        self.check_member_constraints(infcx, mir_def_id, errors_buffer);\n+\n         let outlives_requirements = outlives_requirements.unwrap_or(vec![]);\n \n         if outlives_requirements.is_empty() {\n             None\n         } else {\n             let num_external_vids = self.universal_regions.num_global_and_external_regions();\n-            Some(ClosureRegionRequirements {\n-                num_external_vids,\n-                outlives_requirements,\n-            })\n+            Some(ClosureRegionRequirements { num_external_vids, outlives_requirements })\n         }\n     }\n \n@@ -472,7 +532,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         debug!(\"propagate_constraints()\");\n \n         debug!(\"propagate_constraints: constraints={:#?}\", {\n-            let mut constraints: Vec<_> = self.constraints.iter().collect();\n+            let mut constraints: Vec<_> = self.constraints.outlives().iter().collect();\n             constraints.sort();\n             constraints\n                 .into_iter()\n@@ -488,8 +548,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         for scc_index in self.constraint_sccs.all_sccs() {\n             self.propagate_constraint_sccs_if_new(scc_index, visited);\n         }\n+\n+        // Sort the applied member constraints so we can binary search\n+        // through them later.\n+        self.member_constraints_applied.sort_by_key(|applied| applied.member_region_scc);\n     }\n \n+    /// Computes the value of the SCC `scc_a` if it has not already\n+    /// been computed. The `visited` parameter is a bitset\n     #[inline]\n     fn propagate_constraint_sccs_if_new(\n         &mut self,\n@@ -501,6 +567,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         }\n     }\n \n+    /// Computes the value of the SCC `scc_a`, which has not yet been\n+    /// computed. This works by first computing all successors of the\n+    /// SCC (if they haven't been computed already) and then unioning\n+    /// together their elements.\n     fn propagate_constraint_sccs_new(\n         &mut self,\n         scc_a: ConstraintSccIndex,\n@@ -510,10 +580,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         // Walk each SCC `B` such that `A: B`...\n         for &scc_b in constraint_sccs.successors(scc_a) {\n-            debug!(\n-                \"propagate_constraint_sccs: scc_a = {:?} scc_b = {:?}\",\n-                scc_a, scc_b\n-            );\n+            debug!(\"propagate_constraint_sccs: scc_a = {:?} scc_b = {:?}\", scc_a, scc_b);\n \n             // ...compute the value of `B`...\n             self.propagate_constraint_sccs_if_new(scc_b, visited);\n@@ -531,13 +598,184 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             }\n         }\n \n+        // Now take member constraints into account.\n+        let member_constraints = self.member_constraints.clone();\n+        for m_c_i in member_constraints.indices(scc_a) {\n+            self.apply_member_constraint(\n+                scc_a,\n+                m_c_i,\n+                member_constraints.choice_regions(m_c_i),\n+            );\n+        }\n+\n         debug!(\n             \"propagate_constraint_sccs: scc_a = {:?} has value {:?}\",\n             scc_a,\n             self.scc_values.region_value_str(scc_a),\n         );\n     }\n \n+    /// Invoked for each `R0 member of [R1..Rn]` constraint.\n+    ///\n+    /// `scc` is the SCC containing R0, and `choice_regions` are the\n+    /// `R1..Rn` regions -- they are always known to be universal\n+    /// regions (and if that's not true, we just don't attempt to\n+    /// enforce the constraint).\n+    ///\n+    /// The current value of `scc` at the time the method is invoked\n+    /// is considered a *lower bound*.  If possible, we will modify\n+    /// the constraint to set it equal to one of the option regions.\n+    /// If we make any changes, returns true, else false.\n+    fn apply_member_constraint(\n+        &mut self,\n+        scc: ConstraintSccIndex,\n+        member_constraint_index: NllMemberConstraintIndex,\n+        choice_regions: &[ty::RegionVid],\n+    ) -> bool {\n+        debug!(\"apply_member_constraint(scc={:?}, choice_regions={:#?})\", scc, choice_regions,);\n+\n+        if let Some(uh_oh) =\n+            choice_regions.iter().find(|&&r| !self.universal_regions.is_universal_region(r))\n+        {\n+            // FIXME(#61773): This case can only occur with\n+            // `impl_trait_in_bindings`, I believe, and we are just\n+            // opting not to handle it for now. See #61773 for\n+            // details.\n+            bug!(\n+                \"member constraint for `{:?}` has an option region `{:?}` \\\n+                 that is not a universal region\",\n+                self.member_constraints[member_constraint_index].opaque_type_def_id,\n+                uh_oh,\n+            );\n+        }\n+\n+        // Create a mutable vector of the options. We'll try to winnow\n+        // them down.\n+        let mut choice_regions: Vec<ty::RegionVid> = choice_regions.to_vec();\n+\n+        // The 'member region' in a member constraint is part of the\n+        // hidden type, which must be in the root universe. Therefore,\n+        // it cannot have any placeholders in its value.\n+        assert!(self.scc_universes[scc] == ty::UniverseIndex::ROOT);\n+        debug_assert!(\n+            self.scc_values.placeholders_contained_in(scc).next().is_none(),\n+            \"scc {:?} in a member constraint has placeholder value: {:?}\",\n+            scc,\n+            self.scc_values.region_value_str(scc),\n+        );\n+\n+        // The existing value for `scc` is a lower-bound. This will\n+        // consist of some set `{P} + {LB}` of points `{P}` and\n+        // lower-bound free regions `{LB}`. As each choice region `O`\n+        // is a free region, it will outlive the points. But we can\n+        // only consider the option `O` if `O: LB`.\n+        choice_regions.retain(|&o_r| {\n+            self.scc_values\n+                .universal_regions_outlived_by(scc)\n+                .all(|lb| self.universal_region_relations.outlives(o_r, lb))\n+        });\n+        debug!(\"apply_member_constraint: after lb, choice_regions={:?}\", choice_regions);\n+\n+        // Now find all the *upper bounds* -- that is, each UB is a\n+        // free region that must outlive the member region `R0` (`UB:\n+        // R0`). Therefore, we need only keep an option `O` if `UB: O`\n+        // for all UB.\n+        if choice_regions.len() > 1 {\n+            let universal_region_relations = self.universal_region_relations.clone();\n+            let rev_constraint_graph = self.rev_constraint_graph();\n+            for ub in self.upper_bounds(scc, &rev_constraint_graph) {\n+                debug!(\"apply_member_constraint: ub={:?}\", ub);\n+                choice_regions.retain(|&o_r| universal_region_relations.outlives(ub, o_r));\n+            }\n+            debug!(\"apply_member_constraint: after ub, choice_regions={:?}\", choice_regions);\n+        }\n+\n+        // If we ruled everything out, we're done.\n+        if choice_regions.is_empty() {\n+            return false;\n+        }\n+\n+        // Otherwise, we need to find the minimum remaining choice, if\n+        // any, and take that.\n+        debug!(\"apply_member_constraint: choice_regions remaining are {:#?}\", choice_regions);\n+        let min = |r1: ty::RegionVid, r2: ty::RegionVid| -> Option<ty::RegionVid> {\n+            let r1_outlives_r2 = self.universal_region_relations.outlives(r1, r2);\n+            let r2_outlives_r1 = self.universal_region_relations.outlives(r2, r1);\n+            if r1_outlives_r2 && r2_outlives_r1 {\n+                Some(r1.min(r2))\n+            } else if r1_outlives_r2 {\n+                Some(r2)\n+            } else if r2_outlives_r1 {\n+                Some(r1)\n+            } else {\n+                None\n+            }\n+        };\n+        let mut min_choice = choice_regions[0];\n+        for &other_option in &choice_regions[1..] {\n+            debug!(\n+                \"apply_member_constraint: min_choice={:?} other_option={:?}\",\n+                min_choice, other_option,\n+            );\n+            match min(min_choice, other_option) {\n+                Some(m) => min_choice = m,\n+                None => {\n+                    debug!(\n+                        \"apply_member_constraint: {:?} and {:?} are incomparable; no min choice\",\n+                        min_choice, other_option,\n+                    );\n+                    return false;\n+                }\n+            }\n+        }\n+\n+        let min_choice_scc = self.constraint_sccs.scc(min_choice);\n+        debug!(\n+            \"apply_member_constraint: min_choice={:?} best_choice_scc={:?}\",\n+            min_choice,\n+            min_choice_scc,\n+        );\n+        if self.scc_values.add_region(scc, min_choice_scc) {\n+            self.member_constraints_applied.push(AppliedMemberConstraint {\n+                member_region_scc: scc,\n+                min_choice,\n+                member_constraint_index,\n+            });\n+\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n+    /// Compute and return the reverse SCC-based constraint graph (lazilly).\n+    fn upper_bounds(\n+        &'a mut self,\n+        scc0: ConstraintSccIndex,\n+        rev_constraint_graph: &'a VecGraph<ConstraintSccIndex>,\n+    ) -> impl Iterator<Item = RegionVid> + 'a {\n+        let scc_values = &self.scc_values;\n+        let mut duplicates = FxHashSet::default();\n+        rev_constraint_graph\n+            .depth_first_search(scc0)\n+            .skip(1)\n+            .flat_map(move |scc1| scc_values.universal_regions_outlived_by(scc1))\n+            .filter(move |&r| duplicates.insert(r))\n+    }\n+\n+    /// Compute and return the reverse SCC-based constraint graph (lazilly).\n+    fn rev_constraint_graph(\n+        &mut self,\n+    ) -> Rc<VecGraph<ConstraintSccIndex>> {\n+        if let Some(g) = &self.rev_constraint_graph {\n+            return g.clone();\n+        }\n+\n+        let rev_graph = Rc::new(self.constraint_sccs.reverse());\n+        self.rev_constraint_graph = Some(rev_graph.clone());\n+        rev_graph\n+    }\n+\n     /// Returns `true` if all the elements in the value of `scc_b` are nameable\n     /// in `scc_a`. Used during constraint propagation, and only once\n     /// the value of `scc_b` has been computed.\n@@ -554,9 +792,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // Otherwise, we have to iterate over the universe elements in\n         // B's value, and check whether all of them are nameable\n         // from universe_a\n-        self.scc_values\n-            .placeholders_contained_in(scc_b)\n-            .all(|p| universe_a.can_name(p.universe))\n+        self.scc_values.placeholders_contained_in(scc_b).all(|p| universe_a.can_name(p.universe))\n     }\n \n     /// Extend `scc` so that it can outlive some placeholder region\n@@ -731,12 +967,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ) -> bool {\n         let tcx = infcx.tcx;\n \n-        let TypeTest {\n-            generic_kind,\n-            lower_bound,\n-            locations,\n-            verify_bound: _,\n-        } = type_test;\n+        let TypeTest { generic_kind, lower_bound, locations, verify_bound: _ } = type_test;\n \n         let generic_ty = generic_kind.to_ty(tcx);\n         let subject = match self.try_promote_type_test_subject(infcx, generic_ty) {\n@@ -809,7 +1040,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         ty: Ty<'tcx>,\n     ) -> Option<ClosureOutlivesSubject<'tcx>> {\n         let tcx = infcx.tcx;\n-        let gcx = tcx.global_tcx();\n \n         debug!(\"try_promote_type_test_subject(ty = {:?})\", ty);\n \n@@ -863,8 +1093,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         });\n         debug!(\"try_promote_type_test_subject: folded ty = {:?}\", ty);\n \n-        // `lift_to_global` will only fail if we failed to promote some region.\n-        gcx.lift_to_global(&ty)?;\n+        // `has_local_value` will only be true if we failed to promote some region.\n+        if ty.has_local_value() {\n+            return None;\n+        }\n \n         Some(ClosureOutlivesSubject::Ty(ty))\n     }\n@@ -885,22 +1117,15 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// except that it converts further takes the non-local upper\n     /// bound of `'y`, so that the final result is non-local.\n     fn non_local_universal_upper_bound(&self, r: RegionVid) -> RegionVid {\n-        debug!(\n-            \"non_local_universal_upper_bound(r={:?}={})\",\n-            r,\n-            self.region_value_str(r)\n-        );\n+        debug!(\"non_local_universal_upper_bound(r={:?}={})\", r, self.region_value_str(r));\n \n         let lub = self.universal_upper_bound(r);\n \n         // Grow further to get smallest universal region known to\n         // creator.\n         let non_local_lub = self.universal_region_relations.non_local_upper_bound(lub);\n \n-        debug!(\n-            \"non_local_universal_upper_bound: non_local_lub={:?}\",\n-            non_local_lub\n-        );\n+        debug!(\"non_local_universal_upper_bound: non_local_lub={:?}\", non_local_lub);\n \n         non_local_lub\n     }\n@@ -920,11 +1145,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// - For each `end('x)` element in `'r`, compute the mutual LUB, yielding\n     ///   a result `'y`.\n     fn universal_upper_bound(&self, r: RegionVid) -> RegionVid {\n-        debug!(\n-            \"universal_upper_bound(r={:?}={})\",\n-            r,\n-            self.region_value_str(r)\n-        );\n+        debug!(\"universal_upper_bound(r={:?}={})\", r, self.region_value_str(r));\n \n         // Find the smallest universal region that contains all other\n         // universal regions within `region`.\n@@ -949,10 +1170,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         lower_bound: RegionVid,\n         verify_bound: &VerifyBound<'tcx>,\n     ) -> bool {\n-        debug!(\n-            \"eval_verify_bound(lower_bound={:?}, verify_bound={:?})\",\n-            lower_bound, verify_bound\n-        );\n+        debug!(\"eval_verify_bound(lower_bound={:?}, verify_bound={:?})\", lower_bound, verify_bound);\n \n         match verify_bound {\n             VerifyBound::IfEq(test_ty, verify_bound1) => {\n@@ -961,7 +1179,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n             VerifyBound::OutlivedBy(r) => {\n                 let r_vid = self.to_region_vid(r);\n-                self.eval_outlives(body, r_vid, lower_bound)\n+                self.eval_outlives(r_vid, lower_bound)\n             }\n \n             VerifyBound::AnyBound(verify_bounds) => verify_bounds.iter().any(|verify_bound| {\n@@ -1034,22 +1252,24 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         })\n     }\n \n-    // Evaluate whether `sup_region: sub_region @ point`.\n-    fn eval_outlives(\n-        &self,\n-        _body: &Body<'tcx>,\n-        sup_region: RegionVid,\n-        sub_region: RegionVid,\n-    ) -> bool {\n+    // Evaluate whether `sup_region == sub_region`.\n+    fn eval_equal(&self, r1: RegionVid, r2: RegionVid) -> bool {\n+        self.eval_outlives(r1, r2) && self.eval_outlives(r2, r1)\n+    }\n+\n+    // Evaluate whether `sup_region: sub_region`.\n+    fn eval_outlives(&self, sup_region: RegionVid, sub_region: RegionVid) -> bool {\n         debug!(\"eval_outlives({:?}: {:?})\", sup_region, sub_region);\n \n         debug!(\n-            \"eval_outlives: sup_region's value = {:?}\",\n+            \"eval_outlives: sup_region's value = {:?} universal={:?}\",\n             self.region_value_str(sup_region),\n+            self.universal_regions.is_universal_region(sup_region),\n         );\n         debug!(\n-            \"eval_outlives: sub_region's value = {:?}\",\n+            \"eval_outlives: sub_region's value = {:?} universal={:?}\",\n             self.region_value_str(sub_region),\n+            self.universal_regions.is_universal_region(sub_region),\n         );\n \n         let sub_region_scc = self.constraint_sccs.scc(sub_region);\n@@ -1061,9 +1281,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // now). Therefore, the sup-region outlives the sub-region if,\n         // for each universal region R1 in the sub-region, there\n         // exists some region R2 in the sup-region that outlives R1.\n-        let universal_outlives = self.scc_values\n-            .universal_regions_outlived_by(sub_region_scc)\n-            .all(|r1| {\n+        let universal_outlives =\n+            self.scc_values.universal_regions_outlived_by(sub_region_scc).all(|r1| {\n                 self.scc_values\n                     .universal_regions_outlived_by(sup_region_scc)\n                     .any(|r2| self.universal_region_relations.outlives(r2, r1))\n@@ -1081,8 +1300,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             return true;\n         }\n \n-        self.scc_values\n-            .contains_points(sup_region_scc, sub_region_scc)\n+        self.scc_values.contains_points(sup_region_scc, sub_region_scc)\n     }\n \n     /// Once regions have been propagated, this method is used to see\n@@ -1164,12 +1382,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // Because this free region must be in the ROOT universe, we\n         // know it cannot contain any bound universes.\n         assert!(self.scc_universes[longer_fr_scc] == ty::UniverseIndex::ROOT);\n-        debug_assert!(\n-            self.scc_values\n-                .placeholders_contained_in(longer_fr_scc)\n-                .next()\n-                .is_none()\n-        );\n+        debug_assert!(self.scc_values.placeholders_contained_in(longer_fr_scc).next().is_none());\n \n         // Only check all of the relations for the main representative of each\n         // SCC, otherwise just check that we outlive said representative. This\n@@ -1223,9 +1436,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         errors_buffer: &mut Vec<Diagnostic>,\n     ) -> Option<ErrorReported> {\n         // If it is known that `fr: o`, carry on.\n-        if self.universal_region_relations\n-            .outlives(longer_fr, shorter_fr)\n-        {\n+        if self.universal_region_relations.outlives(longer_fr, shorter_fr) {\n             return None;\n         }\n \n@@ -1239,9 +1450,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             // We'll call it `fr-` -- it's ever so slightly smaller than\n             // `longer_fr`.\n \n-            if let Some(fr_minus) = self\n-                .universal_region_relations\n-                .non_local_lower_bound(longer_fr)\n+            if let Some(fr_minus) = self.universal_region_relations.non_local_lower_bound(longer_fr)\n             {\n                 debug!(\"check_universal_region: fr_minus={:?}\", fr_minus);\n \n@@ -1251,12 +1460,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 // Grow `shorter_fr` until we find some non-local regions. (We\n                 // always will.)  We'll call them `shorter_fr+` -- they're ever\n                 // so slightly larger than `shorter_fr`.\n-                let shorter_fr_plus = self.universal_region_relations\n-                    .non_local_upper_bounds(&shorter_fr);\n-                debug!(\n-                    \"check_universal_region: shorter_fr_plus={:?}\",\n-                    shorter_fr_plus\n-                );\n+                let shorter_fr_plus =\n+                    self.universal_region_relations.non_local_upper_bounds(&shorter_fr);\n+                debug!(\"check_universal_region: shorter_fr_plus={:?}\", shorter_fr_plus);\n                 for &&fr in &shorter_fr_plus {\n                     // Push the constraint `fr-: shorter_fr+`\n                     propagated_outlives_requirements.push(ClosureOutlivesRequirement {\n@@ -1288,28 +1494,20 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         longer_fr: RegionVid,\n         placeholder: ty::PlaceholderRegion,\n     ) {\n-        debug!(\n-            \"check_bound_universal_region(fr={:?}, placeholder={:?})\",\n-            longer_fr, placeholder,\n-        );\n+        debug!(\"check_bound_universal_region(fr={:?}, placeholder={:?})\", longer_fr, placeholder,);\n \n         let longer_fr_scc = self.constraint_sccs.scc(longer_fr);\n-        debug!(\n-            \"check_bound_universal_region: longer_fr_scc={:?}\",\n-            longer_fr_scc,\n-        );\n+        debug!(\"check_bound_universal_region: longer_fr_scc={:?}\", longer_fr_scc,);\n \n         // If we have some bound universal region `'a`, then the only\n         // elements it can contain is itself -- we don't know anything\n         // else about it!\n         let error_element = match {\n-            self.scc_values\n-                .elements_contained_in(longer_fr_scc)\n-                .find(|element| match element {\n-                    RegionElement::Location(_) => true,\n-                    RegionElement::RootUniversalRegion(_) => true,\n-                    RegionElement::PlaceholderRegion(placeholder1) => placeholder != *placeholder1,\n-                })\n+            self.scc_values.elements_contained_in(longer_fr_scc).find(|element| match element {\n+                RegionElement::Location(_) => true,\n+                RegionElement::RootUniversalRegion(_) => true,\n+                RegionElement::PlaceholderRegion(placeholder1) => placeholder != *placeholder1,\n+            })\n         } {\n             Some(v) => v,\n             None => return,\n@@ -1320,7 +1518,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let error_region = match error_element {\n             RegionElement::Location(l) => self.find_sub_region_live_at(longer_fr, l),\n             RegionElement::RootUniversalRegion(r) => r,\n-            RegionElement::PlaceholderRegion(error_placeholder) => self.definitions\n+            RegionElement::PlaceholderRegion(error_placeholder) => self\n+                .definitions\n                 .iter_enumerated()\n                 .filter_map(|(r, definition)| match definition.origin {\n                     NLLRegionVariableOrigin::Placeholder(p) if p == error_placeholder => Some(r),\n@@ -1338,12 +1537,50 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // the AST-based checker uses a more conservative check,\n         // so to even see this error, one must pass in a special\n         // flag.\n-        let mut diag = infcx\n-            .tcx\n-            .sess\n-            .struct_span_err(span, \"higher-ranked subtype error\");\n+        let mut diag = infcx.tcx.sess.struct_span_err(span, \"higher-ranked subtype error\");\n         diag.emit();\n     }\n+\n+    fn check_member_constraints(\n+        &self,\n+        infcx: &InferCtxt<'_, 'tcx>,\n+        mir_def_id: DefId,\n+        errors_buffer: &mut Vec<Diagnostic>,\n+    ) {\n+        let member_constraints = self.member_constraints.clone();\n+        for m_c_i in member_constraints.all_indices() {\n+            debug!(\"check_member_constraint(m_c_i={:?})\", m_c_i);\n+            let m_c = &member_constraints[m_c_i];\n+            let member_region_vid = m_c.member_region_vid;\n+            debug!(\n+                \"check_member_constraint: member_region_vid={:?} with value {}\",\n+                member_region_vid,\n+                self.region_value_str(member_region_vid),\n+            );\n+            let choice_regions = member_constraints.choice_regions(m_c_i);\n+            debug!(\"check_member_constraint: choice_regions={:?}\", choice_regions);\n+\n+            // Did the member region wind up equal to any of the option regions?\n+            if let Some(o) = choice_regions.iter().find(|&&o_r| {\n+                self.eval_equal(o_r, m_c.member_region_vid)\n+            }) {\n+                debug!(\"check_member_constraint: evaluated as equal to {:?}\", o);\n+                continue;\n+            }\n+\n+            // If not, report an error.\n+            let region_scope_tree = &infcx.tcx.region_scope_tree(mir_def_id);\n+            let member_region = infcx.tcx.mk_region(ty::ReVar(member_region_vid));\n+            opaque_types::unexpected_hidden_region_diagnostic(\n+                infcx.tcx,\n+                Some(region_scope_tree),\n+                m_c.opaque_type_def_id,\n+                m_c.hidden_ty,\n+                member_region,\n+            )\n+            .buffer(errors_buffer);\n+        }\n+    }\n }\n \n impl<'tcx> RegionDefinition<'tcx> {\n@@ -1357,11 +1594,7 @@ impl<'tcx> RegionDefinition<'tcx> {\n             _ => NLLRegionVariableOrigin::Existential,\n         };\n \n-        Self {\n-            origin,\n-            universe,\n-            external_name: None,\n-        }\n+        Self { origin, universe, external_name: None }\n     }\n }\n \n@@ -1371,7 +1604,7 @@ pub trait ClosureRegionRequirementsExt<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         closure_def_id: DefId,\n         closure_substs: SubstsRef<'tcx>,\n-    ) -> Vec<QueryRegionConstraint<'tcx>>;\n+    ) -> Vec<QueryOutlivesConstraint<'tcx>>;\n \n     fn subst_closure_mapping<T>(\n         &self,\n@@ -1401,7 +1634,7 @@ impl<'tcx> ClosureRegionRequirementsExt<'tcx> for ClosureRegionRequirements<'tcx\n         tcx: TyCtxt<'tcx>,\n         closure_def_id: DefId,\n         closure_substs: SubstsRef<'tcx>,\n-    ) -> Vec<QueryRegionConstraint<'tcx>> {\n+    ) -> Vec<QueryOutlivesConstraint<'tcx>> {\n         debug!(\n             \"apply_requirements(closure_def_id={:?}, closure_substs={:?})\",\n             closure_def_id, closure_substs\n@@ -1464,10 +1697,7 @@ impl<'tcx> ClosureRegionRequirementsExt<'tcx> for ClosureRegionRequirements<'tcx\n             if let ty::ReClosureBound(vid) = r {\n                 closure_mapping[*vid]\n             } else {\n-                bug!(\n-                    \"subst_closure_mapping: encountered non-closure bound free region {:?}\",\n-                    r\n-                )\n+                bug!(\"subst_closure_mapping: encountered non-closure bound free region {:?}\", r)\n             }\n         })\n     }"}, {"sha": "6f9f5707935baa75ef782903d642681a23279e41", "filename": "src/librustc_mir/borrow_check/nll/region_infer/values.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -162,7 +162,7 @@ impl<N: Idx> LivenessValues<N> {\n     }\n \n     /// Iterate through each region that has a value in this set.\n-    crate fn rows<'a>(&'a self) -> impl Iterator<Item = N> {\n+    crate fn rows(&self) -> impl Iterator<Item=N> {\n         self.points.rows()\n     }\n "}, {"sha": "8de014522dea76ed302922d7f77baf84da1fc47e", "filename": "src/librustc_mir/borrow_check/nll/type_check/constraint_conversion.rs", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -3,7 +3,8 @@ use crate::borrow_check::nll::region_infer::TypeTest;\n use crate::borrow_check::nll::type_check::{Locations, MirTypeckRegionConstraints};\n use crate::borrow_check::nll::universal_regions::UniversalRegions;\n use crate::borrow_check::nll::ToRegionVid;\n-use rustc::infer::canonical::QueryRegionConstraint;\n+use rustc::infer::canonical::QueryRegionConstraints;\n+use rustc::infer::canonical::QueryOutlivesConstraint;\n use rustc::infer::outlives::env::RegionBoundPairs;\n use rustc::infer::outlives::obligations::{TypeOutlives, TypeOutlivesDelegate};\n use rustc::infer::region_constraints::{GenericKind, VerifyBound};\n@@ -49,13 +50,33 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n         }\n     }\n \n-    pub(super) fn convert_all(&mut self, query_constraints: &[QueryRegionConstraint<'tcx>]) {\n-        for query_constraint in query_constraints {\n+    pub(super) fn convert_all(&mut self, query_constraints: &QueryRegionConstraints<'tcx>) {\n+        debug!(\"convert_all(query_constraints={:#?})\", query_constraints);\n+\n+        let QueryRegionConstraints { outlives, member_constraints } = query_constraints;\n+\n+        // Annoying: to invoke `self.to_region_vid`, we need access to\n+        // `self.constraints`, but we also want to be mutating\n+        // `self.member_constraints`. For now, just swap out the value\n+        // we want and replace at the end.\n+        let mut tmp = std::mem::replace(\n+            &mut self.constraints.member_constraints,\n+            Default::default(),\n+        );\n+        for member_constraint in member_constraints {\n+            tmp.push_constraint(\n+                member_constraint,\n+                |r| self.to_region_vid(r),\n+            );\n+        }\n+        self.constraints.member_constraints = tmp;\n+\n+        for query_constraint in outlives {\n             self.convert(query_constraint);\n         }\n     }\n \n-    pub(super) fn convert(&mut self, query_constraint: &QueryRegionConstraint<'tcx>) {\n+    pub(super) fn convert(&mut self, query_constraint: &QueryOutlivesConstraint<'tcx>) {\n         debug!(\"generate: constraints at: {:#?}\", self.locations);\n \n         // Extract out various useful fields we'll need below."}, {"sha": "d18a8e87453a54e6788fc9eec352390b0588fa6e", "filename": "src/librustc_mir/borrow_check/nll/type_check/free_region_relations.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ffree_region_relations.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -2,7 +2,7 @@ use crate::borrow_check::nll::type_check::constraint_conversion;\n use crate::borrow_check::nll::type_check::{Locations, MirTypeckRegionConstraints};\n use crate::borrow_check::nll::universal_regions::UniversalRegions;\n use crate::borrow_check::nll::ToRegionVid;\n-use rustc::infer::canonical::QueryRegionConstraint;\n+use rustc::infer::canonical::QueryRegionConstraints;\n use rustc::infer::outlives::free_region_map::FreeRegionRelations;\n use rustc::infer::region_constraints::GenericKind;\n use rustc::infer::InferCtxt;\n@@ -287,7 +287,7 @@ impl UniversalRegionRelationsBuilder<'cx, 'tcx> {\n             self.relations.relate_universal_regions(fr, fr_fn_body);\n         }\n \n-        for data in constraint_sets {\n+        for data in &constraint_sets {\n             constraint_conversion::ConstraintConversion::new(\n                 self.infcx,\n                 &self.universal_regions,\n@@ -297,7 +297,7 @@ impl UniversalRegionRelationsBuilder<'cx, 'tcx> {\n                 Locations::All(DUMMY_SP),\n                 ConstraintCategory::Internal,\n                 &mut self.constraints,\n-            ).convert_all(&data);\n+            ).convert_all(data);\n         }\n \n         CreateResult {\n@@ -311,7 +311,7 @@ impl UniversalRegionRelationsBuilder<'cx, 'tcx> {\n     /// either the return type of the MIR or one of its arguments. At\n     /// the same time, compute and add any implied bounds that come\n     /// from this local.\n-    fn add_implied_bounds(&mut self, ty: Ty<'tcx>) -> Option<Rc<Vec<QueryRegionConstraint<'tcx>>>> {\n+    fn add_implied_bounds(&mut self, ty: Ty<'tcx>) -> Option<Rc<QueryRegionConstraints<'tcx>>> {\n         debug!(\"add_implied_bounds(ty={:?})\", ty);\n         let (bounds, constraints) =\n             self.param_env"}, {"sha": "4af78fa5e0f42e4dd64979434aeb0384ff7ebb94", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -1,5 +1,5 @@\n use crate::borrow_check::location::LocationTable;\n-use crate::borrow_check::nll::constraints::ConstraintSet;\n+use crate::borrow_check::nll::constraints::OutlivesConstraintSet;\n use crate::borrow_check::nll::facts::{AllFacts, AllFactsExt};\n use crate::borrow_check::nll::region_infer::values::RegionValueElements;\n use crate::borrow_check::nll::universal_regions::UniversalRegions;\n@@ -107,7 +107,7 @@ fn compute_live_locals(\n fn regions_that_outlive_free_regions(\n     num_region_vars: usize,\n     universal_regions: &UniversalRegions<'tcx>,\n-    constraint_set: &ConstraintSet,\n+    constraint_set: &OutlivesConstraintSet,\n ) -> FxHashSet<RegionVid> {\n     // Build a graph of the outlives constraints thus far. This is\n     // a reverse graph, so for each constraint `R1: R2` we have an"}, {"sha": "f160f658f557640e68731c9b211cf29e19e6025d", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/trace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -6,7 +6,7 @@ use crate::borrow_check::nll::type_check::TypeChecker;\n use crate::dataflow::indexes::MovePathIndex;\n use crate::dataflow::move_paths::MoveData;\n use crate::dataflow::{FlowAtLocation, FlowsAtLocation, MaybeInitializedPlaces};\n-use rustc::infer::canonical::QueryRegionConstraint;\n+use rustc::infer::canonical::QueryRegionConstraints;\n use rustc::mir::{BasicBlock, ConstraintCategory, Local, Location, Body};\n use rustc::traits::query::dropck_outlives::DropckOutlivesResult;\n use rustc::traits::query::type_op::outlives::DropckOutlives;\n@@ -88,7 +88,7 @@ struct LivenessContext<'me, 'typeck, 'flow, 'tcx> {\n \n struct DropData<'tcx> {\n     dropck_result: DropckOutlivesResult<'tcx>,\n-    region_constraint_data: Option<Rc<Vec<QueryRegionConstraint<'tcx>>>>,\n+    region_constraint_data: Option<Rc<QueryRegionConstraints<'tcx>>>,\n }\n \n struct LivenessResults<'me, 'typeck, 'flow, 'tcx> {"}, {"sha": "cdbbe1d02bd92edd54450409dd9ae907ef6b6a08", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 28, "deletions": 10, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -4,7 +4,8 @@\n \n use crate::borrow_check::borrow_set::BorrowSet;\n use crate::borrow_check::location::LocationTable;\n-use crate::borrow_check::nll::constraints::{ConstraintSet, OutlivesConstraint};\n+use crate::borrow_check::nll::constraints::{OutlivesConstraintSet, OutlivesConstraint};\n+use crate::borrow_check::nll::member_constraints::MemberConstraintSet;\n use crate::borrow_check::nll::facts::AllFacts;\n use crate::borrow_check::nll::region_infer::values::LivenessValues;\n use crate::borrow_check::nll::region_infer::values::PlaceholderIndex;\n@@ -23,7 +24,7 @@ use crate::dataflow::MaybeInitializedPlaces;\n use either::Either;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n-use rustc::infer::canonical::QueryRegionConstraint;\n+use rustc::infer::canonical::QueryRegionConstraints;\n use rustc::infer::outlives::env::RegionBoundPairs;\n use rustc::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime, NLLRegionVariableOrigin};\n use rustc::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n@@ -127,7 +128,8 @@ pub(crate) fn type_check<'tcx>(\n         placeholder_indices: PlaceholderIndices::default(),\n         placeholder_index_to_region: IndexVec::default(),\n         liveness_constraints: LivenessValues::new(elements.clone()),\n-        outlives_constraints: ConstraintSet::default(),\n+        outlives_constraints: OutlivesConstraintSet::default(),\n+        member_constraints: MemberConstraintSet::default(),\n         closure_bounds_mapping: Default::default(),\n         type_tests: Vec::default(),\n     };\n@@ -215,7 +217,7 @@ fn translate_outlives_facts(cx: &mut BorrowCheckContext<'_, '_>) {\n         let location_table = cx.location_table;\n         facts\n             .outlives\n-            .extend(cx.constraints.outlives_constraints.iter().flat_map(\n+            .extend(cx.constraints.outlives_constraints.outlives().iter().flat_map(\n                 |constraint: &OutlivesConstraint| {\n                     if let Some(from_location) = constraint.locations.from_location() {\n                         Either::Left(iter::once((\n@@ -582,7 +584,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n         );\n \n         let locations = location.to_locations();\n-        for constraint in constraints.iter() {\n+        for constraint in constraints.outlives().iter() {\n             let mut constraint = *constraint;\n             constraint.locations = locations;\n             if let ConstraintCategory::Return\n@@ -834,6 +836,7 @@ struct TypeChecker<'a, 'tcx> {\n     infcx: &'a InferCtxt<'a, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     last_span: Span,\n+    body: &'a Body<'tcx>,\n     /// User type annotations are shared between the main MIR and the MIR of\n     /// all of the promoted items.\n     user_type_annotations: &'a CanonicalUserTypeAnnotations<'tcx>,\n@@ -884,7 +887,9 @@ crate struct MirTypeckRegionConstraints<'tcx> {\n     /// hence it must report on their liveness constraints.\n     crate liveness_constraints: LivenessValues<RegionVid>,\n \n-    crate outlives_constraints: ConstraintSet,\n+    crate outlives_constraints: OutlivesConstraintSet,\n+\n+    crate member_constraints: MemberConstraintSet<'tcx, RegionVid>,\n \n     crate closure_bounds_mapping:\n         FxHashMap<Location, FxHashMap<(RegionVid, RegionVid), (ConstraintCategory, Span)>>,\n@@ -992,6 +997,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             infcx,\n             last_span: DUMMY_SP,\n             mir_def_id,\n+            body,\n             user_type_annotations: &body.user_type_annotations,\n             param_env,\n             region_bound_pairs,\n@@ -1093,7 +1099,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         &mut self,\n         locations: Locations,\n         category: ConstraintCategory,\n-        data: &[QueryRegionConstraint<'tcx>],\n+        data: &QueryRegionConstraints<'tcx>,\n     ) {\n         debug!(\n             \"push_region_constraints: constraints generated at {:?} are {:#?}\",\n@@ -1109,7 +1115,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             locations,\n             category,\n             &mut self.borrowck_context.constraints,\n-        ).convert_all(&data);\n+        ).convert_all(data);\n     }\n \n     /// Convenient wrapper around `relate_tys::relate_types` -- see\n@@ -1229,6 +1235,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         let infcx = self.infcx;\n         let tcx = infcx.tcx;\n         let param_env = self.param_env;\n+        let body = self.body;\n         debug!(\"eq_opaque_type_and_type: mir_def_id={:?}\", self.mir_def_id);\n         let opaque_type_map = self.fully_perform_op(\n             locations,\n@@ -1244,6 +1251,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                             dummy_body_id,\n                             param_env,\n                             &anon_ty,\n+                            locations.span(body),\n                         ));\n                     debug!(\n                         \"eq_opaque_type_and_type: \\\n@@ -2508,10 +2516,20 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         location: Location,\n     ) -> ty::InstantiatedPredicates<'tcx> {\n         if let Some(closure_region_requirements) = tcx.mir_borrowck(def_id).closure_requirements {\n-            let closure_constraints =\n-                closure_region_requirements.apply_requirements(tcx, def_id, substs);\n+            let closure_constraints = QueryRegionConstraints {\n+                outlives: closure_region_requirements.apply_requirements(tcx, def_id, substs),\n+\n+                // Presently, closures never propagate member\n+                // constraints to their parents -- they are enforced\n+                // locally.  This is largely a non-issue as member\n+                // constraints only come from `-> impl Trait` and\n+                // friends which don't appear (thus far...) in\n+                // closures.\n+                member_constraints: vec![],\n+            };\n \n             let bounds_mapping = closure_constraints\n+                .outlives\n                 .iter()\n                 .enumerate()\n                 .filter_map(|(idx, constraint)| {"}, {"sha": "538ac6881d90ab8d98b8f72c19cebaa4cc2bebb3", "filename": "src/librustc_mir/borrow_check/path_utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -130,7 +130,7 @@ pub(super) fn is_active<'tcx>(\n \n /// Determines if a given borrow is borrowing local data\n /// This is called for all Yield statements on movable generators\n-pub(super) fn borrow_of_local_data<'tcx>(place: &Place<'tcx>) -> bool {\n+pub(super) fn borrow_of_local_data(place: &Place<'_>) -> bool {\n     place.iterate(|place_base, place_projection| {\n         match place_base {\n             PlaceBase::Static(..) => return false,"}, {"sha": "f679a00035d76ebfbb37b4ad30975958bf14c837", "filename": "src/librustc_mir/build/expr/category.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fcategory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fcategory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fcategory.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -31,7 +31,7 @@ pub enum RvalueFunc {\n /// Determines the category for a given expression. Note that scope\n /// and paren expressions have no category.\n impl Category {\n-    pub fn of<'tcx>(ek: &ExprKind<'tcx>) -> Option<Category> {\n+    pub fn of(ek: &ExprKind<'_>) -> Option<Category> {\n         match *ek {\n             ExprKind::Scope { .. } => None,\n "}, {"sha": "7125eb6850bb6c6f7639362b28406ea61d299fdd", "filename": "src/librustc_mir/build/matches/simplify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -28,7 +28,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                                     candidate: &mut Candidate<'pat, 'tcx>) {\n         // repeatedly simplify match pairs until fixed point is reached\n         loop {\n-            let match_pairs = mem::replace(&mut candidate.match_pairs, vec![]);\n+            let match_pairs = mem::take(&mut candidate.match_pairs);\n             let mut changed = false;\n             for match_pair in match_pairs {\n                 match self.simplify_match_pair(match_pair, candidate) {"}, {"sha": "528dfbef6946a3d5546582bb77da17ae7cd8546e", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -826,6 +826,6 @@ impl Test<'_> {\n     }\n }\n \n-fn is_switch_ty<'tcx>(ty: Ty<'tcx>) -> bool {\n+fn is_switch_ty(ty: Ty<'_>) -> bool {\n     ty.is_integral() || ty.is_char() || ty.is_bool()\n }"}, {"sha": "80a035d8287f438222ac63f21eb1d631e86c6921", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -22,7 +22,7 @@ use syntax_pos::Span;\n use super::lints;\n \n /// Construct the MIR for a given `DefId`.\n-pub fn mir_build<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Body<'tcx> {\n+pub fn mir_build(tcx: TyCtxt<'_>, def_id: DefId) -> Body<'_> {\n     let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n \n     // Figure out what primary body this item has.\n@@ -171,11 +171,11 @@ pub fn mir_build<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Body<'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n // BuildMir -- walks a crate, looking for fn items and methods to build MIR from\n \n-fn liberated_closure_env_ty<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+fn liberated_closure_env_ty(\n+    tcx: TyCtxt<'_>,\n     closure_expr_id: hir::HirId,\n     body_id: hir::BodyId,\n-) -> Ty<'tcx> {\n+) -> Ty<'_> {\n     let closure_ty = tcx.body_tables(body_id).node_type(closure_expr_id);\n \n     let (closure_def_id, closure_substs) = match closure_ty.sty {\n@@ -485,7 +485,7 @@ macro_rules! unpack {\n     };\n }\n \n-fn should_abort_on_panic<'tcx>(tcx: TyCtxt<'tcx>, fn_def_id: DefId, abi: Abi) -> bool {\n+fn should_abort_on_panic(tcx: TyCtxt<'_>, fn_def_id: DefId, abi: Abi) -> bool {\n     // Not callable from C, so we can safely unwind through these\n     if abi == Abi::Rust || abi == Abi::RustCall { return false; }\n "}, {"sha": "e95ef0caaafaff626f1802cc7f7444336b172e43", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -22,7 +22,7 @@ use syntax::source_map::{Span, DUMMY_SP};\n use crate::interpret::{self,\n     PlaceTy, MPlaceTy, OpTy, ImmTy, Immediate, Scalar,\n     RawConst, ConstValue,\n-    InterpResult, InterpErrorInfo, InterpError, GlobalId, InterpretCx, StackPopCleanup,\n+    InterpResult, InterpErrorInfo, InterpError, GlobalId, InterpCx, StackPopCleanup,\n     Allocation, AllocId, MemoryKind, Memory,\n     snapshot, RefTracking, intern_const_alloc_recursive,\n };\n@@ -34,7 +34,7 @@ const STEPS_UNTIL_DETECTOR_ENABLED: isize = 1_000_000;\n /// Should be a power of two for performance reasons.\n const DETECTOR_SNAPSHOT_PERIOD: isize = 256;\n \n-/// The `InterpretCx` is only meant to be used to do field and index projections into constants for\n+/// The `InterpCx` is only meant to be used to do field and index projections into constants for\n /// `simd_shuffle` and const patterns in match arms.\n ///\n /// The function containing the `match` that is currently being analyzed may have generic bounds\n@@ -47,7 +47,7 @@ pub(crate) fn mk_eval_cx<'mir, 'tcx>(\n     param_env: ty::ParamEnv<'tcx>,\n ) -> CompileTimeEvalContext<'mir, 'tcx> {\n     debug!(\"mk_eval_cx: {:?}\", param_env);\n-    InterpretCx::new(tcx.at(span), param_env, CompileTimeInterpreter::new(), Default::default())\n+    InterpCx::new(tcx.at(span), param_env, CompileTimeInterpreter::new(), Default::default())\n }\n \n pub(crate) fn eval_promoted<'mir, 'tcx>(\n@@ -303,7 +303,7 @@ impl<K: Hash + Eq, V> interpret::AllocMap<K, V> for FxHashMap<K, V> {\n }\n \n crate type CompileTimeEvalContext<'mir, 'tcx> =\n-    InterpretCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>;\n+    InterpCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>;\n \n impl interpret::MayLeak for ! {\n     #[inline(always)]\n@@ -326,12 +326,12 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n     const STATIC_KIND: Option<!> = None; // no copying of statics allowed\n \n     #[inline(always)]\n-    fn enforce_validity(_ecx: &InterpretCx<'mir, 'tcx, Self>) -> bool {\n+    fn enforce_validity(_ecx: &InterpCx<'mir, 'tcx, Self>) -> bool {\n         false // for now, we don't enforce validity\n     }\n \n     fn find_fn(\n-        ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n+        ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx>],\n         dest: Option<PlaceTy<'tcx>>,\n@@ -371,7 +371,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n     }\n \n     fn call_intrinsic(\n-        ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n+        ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx>],\n         dest: PlaceTy<'tcx>,\n@@ -387,7 +387,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n     }\n \n     fn ptr_op(\n-        _ecx: &InterpretCx<'mir, 'tcx, Self>,\n+        _ecx: &InterpCx<'mir, 'tcx, Self>,\n         _bin_op: mir::BinOp,\n         _left: ImmTy<'tcx>,\n         _right: ImmTy<'tcx>,\n@@ -424,15 +424,15 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n     }\n \n     fn box_alloc(\n-        _ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n+        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         _dest: PlaceTy<'tcx>,\n     ) -> InterpResult<'tcx> {\n         Err(\n             ConstEvalError::NeedsRfc(\"heap allocations via `box` keyword\".to_string()).into(),\n         )\n     }\n \n-    fn before_terminator(ecx: &mut InterpretCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n+    fn before_terminator(ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n         {\n             let steps = &mut ecx.machine.steps_since_detector_enabled;\n \n@@ -457,13 +457,13 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n     }\n \n     #[inline(always)]\n-    fn stack_push(_ecx: &mut InterpretCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n+    fn stack_push(_ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n         Ok(())\n     }\n \n     /// Called immediately before a stack frame gets popped.\n     #[inline(always)]\n-    fn stack_pop(_ecx: &mut InterpretCx<'mir, 'tcx, Self>, _extra: ()) -> InterpResult<'tcx> {\n+    fn stack_pop(_ecx: &mut InterpCx<'mir, 'tcx, Self>, _extra: ()) -> InterpResult<'tcx> {\n         Ok(())\n     }\n }\n@@ -508,7 +508,7 @@ pub fn const_variant_index<'tcx>(\n }\n \n pub fn error_to_const_error<'mir, 'tcx>(\n-    ecx: &InterpretCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>,\n+    ecx: &InterpCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>,\n     mut error: InterpErrorInfo<'tcx>,\n ) -> ConstEvalErr<'tcx> {\n     error.print_backtrace();\n@@ -632,7 +632,7 @@ pub fn const_eval_raw_provider<'tcx>(\n     }\n \n     let span = tcx.def_span(cid.instance.def_id());\n-    let mut ecx = InterpretCx::new(\n+    let mut ecx = InterpCx::new(\n         tcx.at(span),\n         key.param_env,\n         CompileTimeInterpreter::new(),"}, {"sha": "f0014602e2d6b161089727ccbcf901fcf80c8362", "filename": "src/librustc_mir/dataflow/at_location.rs", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -8,6 +8,7 @@ use crate::dataflow::{BitDenotation, DataflowResults, GenKillSet};\n use crate::dataflow::move_paths::{HasMoveData, MovePathIndex};\n \n use std::iter;\n+use std::borrow::Borrow;\n \n /// A trait for \"cartesian products\" of multiple FlowAtLocation.\n ///\n@@ -60,18 +61,20 @@ pub trait FlowsAtLocation {\n /// (e.g., via `reconstruct_statement_effect` and\n /// `reconstruct_terminator_effect`; don't forget to call\n /// `apply_local_effect`).\n-pub struct FlowAtLocation<'tcx, BD>\n+pub struct FlowAtLocation<'tcx, BD, DR = DataflowResults<'tcx, BD>>\n where\n     BD: BitDenotation<'tcx>,\n+    DR: Borrow<DataflowResults<'tcx, BD>>,\n {\n-    base_results: DataflowResults<'tcx, BD>,\n+    base_results: DR,\n     curr_state: BitSet<BD::Idx>,\n     stmt_trans: GenKillSet<BD::Idx>,\n }\n \n-impl<'tcx, BD> FlowAtLocation<'tcx, BD>\n+impl<'tcx, BD, DR> FlowAtLocation<'tcx, BD, DR>\n where\n     BD: BitDenotation<'tcx>,\n+    DR: Borrow<DataflowResults<'tcx, BD>>,\n {\n     /// Iterate over each bit set in the current state.\n     pub fn each_state_bit<F>(&self, f: F)\n@@ -91,8 +94,8 @@ where\n         self.stmt_trans.gen_set.iter().for_each(f)\n     }\n \n-    pub fn new(results: DataflowResults<'tcx, BD>) -> Self {\n-        let bits_per_block = results.sets().bits_per_block();\n+    pub fn new(results: DR) -> Self {\n+        let bits_per_block = results.borrow().sets().bits_per_block();\n         let curr_state = BitSet::new_empty(bits_per_block);\n         let stmt_trans = GenKillSet::from_elem(HybridBitSet::new_empty(bits_per_block));\n         FlowAtLocation {\n@@ -104,7 +107,7 @@ where\n \n     /// Access the underlying operator.\n     pub fn operator(&self) -> &BD {\n-        self.base_results.operator()\n+        self.base_results.borrow().operator()\n     }\n \n     pub fn contains(&self, x: BD::Idx) -> bool {\n@@ -134,39 +137,45 @@ where\n     }\n }\n \n-impl<'tcx, BD> FlowsAtLocation for FlowAtLocation<'tcx, BD>\n-    where BD: BitDenotation<'tcx>\n+impl<'tcx, BD, DR> FlowsAtLocation for FlowAtLocation<'tcx, BD, DR>\n+where\n+    BD: BitDenotation<'tcx>,\n+    DR: Borrow<DataflowResults<'tcx, BD>>,\n {\n     fn reset_to_entry_of(&mut self, bb: BasicBlock) {\n-        self.curr_state.overwrite(self.base_results.sets().entry_set_for(bb.index()));\n+        self.curr_state.overwrite(self.base_results.borrow().sets().entry_set_for(bb.index()));\n     }\n \n     fn reset_to_exit_of(&mut self, bb: BasicBlock) {\n         self.reset_to_entry_of(bb);\n-        let trans = self.base_results.sets().trans_for(bb.index());\n+        let trans = self.base_results.borrow().sets().trans_for(bb.index());\n         trans.apply(&mut self.curr_state)\n     }\n \n     fn reconstruct_statement_effect(&mut self, loc: Location) {\n         self.stmt_trans.clear();\n         self.base_results\n+            .borrow()\n             .operator()\n             .before_statement_effect(&mut self.stmt_trans, loc);\n         self.stmt_trans.apply(&mut self.curr_state);\n \n         self.base_results\n+            .borrow()\n             .operator()\n             .statement_effect(&mut self.stmt_trans, loc);\n     }\n \n     fn reconstruct_terminator_effect(&mut self, loc: Location) {\n         self.stmt_trans.clear();\n         self.base_results\n+            .borrow()\n             .operator()\n             .before_terminator_effect(&mut self.stmt_trans, loc);\n         self.stmt_trans.apply(&mut self.curr_state);\n \n         self.base_results\n+            .borrow()\n             .operator()\n             .terminator_effect(&mut self.stmt_trans, loc);\n     }\n@@ -177,9 +186,10 @@ impl<'tcx, BD> FlowsAtLocation for FlowAtLocation<'tcx, BD>\n }\n \n \n-impl<'tcx, T> FlowAtLocation<'tcx, T>\n+impl<'tcx, T, DR> FlowAtLocation<'tcx, T, DR>\n where\n     T: HasMoveData<'tcx> + BitDenotation<'tcx, Idx = MovePathIndex>,\n+    DR: Borrow<DataflowResults<'tcx, T>>,\n {\n     pub fn has_any_child_of(&self, mpi: T::Idx) -> Option<T::Idx> {\n         // We process `mpi` before the loop below, for two reasons:"}, {"sha": "d94ebdbae24ae9f68d3a9468a431b1cdfd9f84c0", "filename": "src/librustc_mir/dataflow/impls/borrowed_locals.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -92,7 +92,7 @@ struct BorrowedLocalsVisitor<'gk> {\n     trans: &'gk mut GenKillSet<Local>,\n }\n \n-fn find_local<'tcx>(place: &Place<'tcx>) -> Option<Local> {\n+fn find_local(place: &Place<'_>) -> Option<Local> {\n     place.iterate(|place_base, place_projection| {\n         for proj in place_projection {\n             if proj.elem == ProjectionElem::Deref {"}, {"sha": "7fa950cb98d344886fa6b94698647d5fecab2f2b", "filename": "src/librustc_mir/dataflow/impls/storage_liveness.rs", "status": "modified", "additions": 129, "deletions": 1, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -1,7 +1,13 @@\n pub use super::*;\n \n use rustc::mir::*;\n+use rustc::mir::visit::{\n+    PlaceContext, Visitor, NonMutatingUseContext,\n+};\n+use std::cell::RefCell;\n use crate::dataflow::BitDenotation;\n+use crate::dataflow::HaveBeenBorrowedLocals;\n+use crate::dataflow::{DataflowResults, DataflowResultsCursor, DataflowResultsRefCursor};\n \n #[derive(Copy, Clone)]\n pub struct MaybeStorageLive<'a, 'tcx> {\n@@ -27,7 +33,9 @@ impl<'a, 'tcx> BitDenotation<'tcx> for MaybeStorageLive<'a, 'tcx> {\n     }\n \n     fn start_block_effect(&self, _on_entry: &mut BitSet<Local>) {\n-        // Nothing is live on function entry\n+        // Nothing is live on function entry (generators only have a self\n+        // argument, and we don't care about that)\n+        assert_eq!(1, self.body.arg_count);\n     }\n \n     fn statement_effect(&self,\n@@ -63,3 +71,123 @@ impl<'a, 'tcx> BottomValue for MaybeStorageLive<'a, 'tcx> {\n     /// bottom = dead\n     const BOTTOM_VALUE: bool = false;\n }\n+\n+/// Dataflow analysis that determines whether each local requires storage at a\n+/// given location; i.e. whether its storage can go away without being observed.\n+pub struct RequiresStorage<'mir, 'tcx> {\n+    body: &'mir Body<'tcx>,\n+    borrowed_locals:\n+        RefCell<DataflowResultsRefCursor<'mir, 'tcx, HaveBeenBorrowedLocals<'mir, 'tcx>>>,\n+}\n+\n+impl<'mir, 'tcx: 'mir> RequiresStorage<'mir, 'tcx> {\n+    pub fn new(\n+        body: &'mir Body<'tcx>,\n+        borrowed_locals: &'mir DataflowResults<'tcx, HaveBeenBorrowedLocals<'mir, 'tcx>>,\n+    ) -> Self {\n+        RequiresStorage {\n+            body,\n+            borrowed_locals: RefCell::new(DataflowResultsCursor::new(borrowed_locals, body)),\n+        }\n+    }\n+\n+    pub fn body(&self) -> &Body<'tcx> {\n+        self.body\n+    }\n+}\n+\n+impl<'mir, 'tcx> BitDenotation<'tcx> for RequiresStorage<'mir, 'tcx> {\n+    type Idx = Local;\n+    fn name() -> &'static str { \"requires_storage\" }\n+    fn bits_per_block(&self) -> usize {\n+        self.body.local_decls.len()\n+    }\n+\n+    fn start_block_effect(&self, _sets: &mut BitSet<Local>) {\n+        // Nothing is live on function entry (generators only have a self\n+        // argument, and we don't care about that)\n+        assert_eq!(1, self.body.arg_count);\n+    }\n+\n+    fn statement_effect(&self,\n+                        sets: &mut GenKillSet<Local>,\n+                        loc: Location) {\n+        self.check_for_move(sets, loc);\n+        self.check_for_borrow(sets, loc);\n+\n+        let stmt = &self.body[loc.block].statements[loc.statement_index];\n+        match stmt.kind {\n+            StatementKind::StorageLive(l) => sets.gen(l),\n+            StatementKind::StorageDead(l) => sets.kill(l),\n+            StatementKind::Assign(ref place, _)\n+            | StatementKind::SetDiscriminant { ref place, .. } => {\n+                place.base_local().map(|l| sets.gen(l));\n+            }\n+            StatementKind::InlineAsm(box InlineAsm { ref outputs, .. }) => {\n+                for p in &**outputs {\n+                    p.base_local().map(|l| sets.gen(l));\n+                }\n+            }\n+            _ => (),\n+        }\n+    }\n+\n+    fn terminator_effect(&self,\n+                         sets: &mut GenKillSet<Local>,\n+                         loc: Location) {\n+        self.check_for_move(sets, loc);\n+        self.check_for_borrow(sets, loc);\n+    }\n+\n+    fn propagate_call_return(\n+        &self,\n+        in_out: &mut BitSet<Local>,\n+        _call_bb: mir::BasicBlock,\n+        _dest_bb: mir::BasicBlock,\n+        dest_place: &mir::Place<'tcx>,\n+    ) {\n+        dest_place.base_local().map(|l| in_out.insert(l));\n+    }\n+}\n+\n+impl<'mir, 'tcx> RequiresStorage<'mir, 'tcx> {\n+    /// Kill locals that are fully moved and have not been borrowed.\n+    fn check_for_move(&self, sets: &mut GenKillSet<Local>, loc: Location) {\n+        let mut visitor = MoveVisitor {\n+            sets,\n+            borrowed_locals: &self.borrowed_locals,\n+        };\n+        visitor.visit_location(self.body, loc);\n+    }\n+\n+    /// Gen locals that are newly borrowed. This includes borrowing any part of\n+    /// a local (we rely on this behavior of `HaveBeenBorrowedLocals`).\n+    fn check_for_borrow(&self, sets: &mut GenKillSet<Local>, loc: Location) {\n+        let mut borrowed_locals = self.borrowed_locals.borrow_mut();\n+        borrowed_locals.seek(loc);\n+        borrowed_locals.each_gen_bit(|l| sets.gen(l));\n+    }\n+}\n+\n+impl<'mir, 'tcx> BottomValue for RequiresStorage<'mir, 'tcx> {\n+    /// bottom = dead\n+    const BOTTOM_VALUE: bool = false;\n+}\n+\n+struct MoveVisitor<'a, 'mir, 'tcx> {\n+    borrowed_locals:\n+        &'a RefCell<DataflowResultsRefCursor<'mir, 'tcx, HaveBeenBorrowedLocals<'mir, 'tcx>>>,\n+    sets: &'a mut GenKillSet<Local>,\n+}\n+\n+impl<'a, 'mir: 'a, 'tcx> Visitor<'tcx> for MoveVisitor<'a, 'mir, 'tcx> {\n+    fn visit_local(&mut self, local: &Local, context: PlaceContext, loc: Location) {\n+        if PlaceContext::NonMutatingUse(NonMutatingUseContext::Move) == context {\n+            let mut borrowed_locals = self.borrowed_locals.borrow_mut();\n+            borrowed_locals.seek(loc);\n+            if !borrowed_locals.contains(*local) {\n+                self.sets.kill(*local);\n+            }\n+        }\n+    }\n+}"}, {"sha": "5433a9013aa851d2c7dfcd7c2ba6aac3b8ae406d", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 112, "deletions": 3, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -17,7 +17,7 @@ use std::io;\n use std::path::PathBuf;\n use std::usize;\n \n-pub use self::impls::{MaybeStorageLive};\n+pub use self::impls::{MaybeStorageLive, RequiresStorage};\n pub use self::impls::{MaybeInitializedPlaces, MaybeUninitializedPlaces};\n pub use self::impls::DefinitelyInitializedPlaces;\n pub use self::impls::EverInitializedPlaces;\n@@ -228,9 +228,25 @@ where\n     BD: BitDenotation<'tcx>,\n {\n     fn walk_cfg(&mut self, in_out: &mut BitSet<BD::Idx>) {\n-        let mut dirty_queue: WorkQueue<mir::BasicBlock> =\n-            WorkQueue::with_all(self.builder.body.basic_blocks().len());\n         let body = self.builder.body;\n+\n+        // Initialize the dirty queue in reverse post-order. This makes it more likely that the\n+        // entry state for each basic block will have the effects of its predecessors applied\n+        // before it is processed. In fact, for CFGs without back edges, this guarantees that\n+        // dataflow will converge in exactly `N` iterations, where `N` is the number of basic\n+        // blocks.\n+        let mut dirty_queue: WorkQueue<mir::BasicBlock> =\n+            WorkQueue::with_none(body.basic_blocks().len());\n+        for (bb, _) in traversal::reverse_postorder(body) {\n+            dirty_queue.insert(bb);\n+        }\n+\n+        // Add blocks which are not reachable from START_BLOCK to the work queue. These blocks will\n+        // be processed after the ones added above.\n+        for bb in body.basic_blocks().indices() {\n+            dirty_queue.insert(bb);\n+        }\n+\n         while let Some(bb) = dirty_queue.pop() {\n             let (on_entry, trans) = self.builder.flow_state.sets.get_mut(bb.index());\n             debug_assert!(in_out.words().len() == on_entry.words().len());\n@@ -344,6 +360,99 @@ pub(crate) trait DataflowResultsConsumer<'a, 'tcx: 'a> {\n     fn body(&self) -> &'a Body<'tcx>;\n }\n \n+/// Allows iterating dataflow results in a flexible and reasonably fast way.\n+pub struct DataflowResultsCursor<'mir, 'tcx, BD, DR = DataflowResults<'tcx, BD>>\n+where\n+    BD: BitDenotation<'tcx>,\n+    DR: Borrow<DataflowResults<'tcx, BD>>,\n+{\n+    flow_state: FlowAtLocation<'tcx, BD, DR>,\n+\n+    // The statement (or terminator) whose effect has been reconstructed in\n+    // flow_state.\n+    curr_loc: Option<Location>,\n+\n+    body: &'mir Body<'tcx>,\n+}\n+\n+pub type DataflowResultsRefCursor<'mir, 'tcx, BD> =\n+    DataflowResultsCursor<'mir, 'tcx, BD, &'mir DataflowResults<'tcx, BD>>;\n+\n+impl<'mir, 'tcx, BD, DR> DataflowResultsCursor<'mir, 'tcx, BD, DR>\n+where\n+    BD: BitDenotation<'tcx>,\n+    DR: Borrow<DataflowResults<'tcx, BD>>,\n+{\n+    pub fn new(result: DR, body: &'mir Body<'tcx>) -> Self {\n+        DataflowResultsCursor {\n+            flow_state: FlowAtLocation::new(result),\n+            curr_loc: None,\n+            body,\n+        }\n+    }\n+\n+    /// Seek to the given location in MIR. This method is fast if you are\n+    /// traversing your MIR statements in order.\n+    ///\n+    /// After calling `seek`, the current state will reflect all effects up to\n+    /// and including the `before_statement_effect` of the statement at location\n+    /// `loc`. The `statement_effect` of the statement at `loc` will be\n+    /// available as the current effect (see e.g. `each_gen_bit`).\n+    ///\n+    /// If `loc.statement_index` equals the number of statements in the block,\n+    /// we will reconstruct the terminator effect in the same way as described\n+    /// above.\n+    pub fn seek(&mut self, loc: Location) {\n+        if self.curr_loc.map(|cur| loc == cur).unwrap_or(false) {\n+            return;\n+        }\n+\n+        let start_index;\n+        let should_reset = match self.curr_loc {\n+            None => true,\n+            Some(cur)\n+                if loc.block != cur.block || loc.statement_index < cur.statement_index => true,\n+            _ => false,\n+        };\n+        if should_reset {\n+            self.flow_state.reset_to_entry_of(loc.block);\n+            start_index = 0;\n+        } else {\n+            let curr_loc = self.curr_loc.unwrap();\n+            start_index = curr_loc.statement_index;\n+            // Apply the effect from the last seek to the current state.\n+            self.flow_state.apply_local_effect(curr_loc);\n+        }\n+\n+        for stmt in start_index..loc.statement_index {\n+            let mut stmt_loc = loc;\n+            stmt_loc.statement_index = stmt;\n+            self.flow_state.reconstruct_statement_effect(stmt_loc);\n+            self.flow_state.apply_local_effect(stmt_loc);\n+        }\n+\n+        if loc.statement_index == self.body[loc.block].statements.len() {\n+            self.flow_state.reconstruct_terminator_effect(loc);\n+        } else {\n+            self.flow_state.reconstruct_statement_effect(loc);\n+        }\n+        self.curr_loc = Some(loc);\n+    }\n+\n+    /// Return whether the current state contains bit `x`.\n+    pub fn contains(&self, x: BD::Idx) -> bool {\n+        self.flow_state.contains(x)\n+    }\n+\n+    /// Iterate over each `gen` bit in the current effect (invoke `seek` first).\n+    pub fn each_gen_bit<F>(&self, f: F)\n+    where\n+        F: FnMut(BD::Idx),\n+    {\n+        self.flow_state.each_gen_bit(f)\n+    }\n+}\n+\n pub fn state_for_location<'tcx, T: BitDenotation<'tcx>>(loc: Location,\n                                                         analysis: &T,\n                                                         result: &DataflowResults<'tcx, T>,"}, {"sha": "c365cc2ad854416640bfbe8829e871ddbe914c60", "filename": "src/librustc_mir/hair/cx/to_ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Fhair%2Fcx%2Fto_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Fhair%2Fcx%2Fto_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fto_ref.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -1,7 +1,7 @@\n use crate::hair::*;\n \n use rustc::hir;\n-use syntax::ptr::P;\n+use rustc::hir::ptr::P;\n \n pub trait ToRef {\n     type Output;"}, {"sha": "d356194c0034323b0c70ddca7466f8450b0fb870", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -835,7 +835,7 @@ impl<'tcx> IntRange<'tcx> {\n     fn from_ctor(tcx: TyCtxt<'tcx>, ctor: &Constructor<'tcx>) -> Option<IntRange<'tcx>> {\n         // Floating-point ranges are permitted and we don't want\n         // to consider them when constructing integer ranges.\n-        fn is_integral<'tcx>(ty: Ty<'tcx>) -> bool {\n+        fn is_integral(ty: Ty<'_>) -> bool {\n             match ty.sty {\n                 ty::Char | ty::Int(_) | ty::Uint(_) => true,\n                 _ => false,"}, {"sha": "915ce9f20d07d161f867616de07f81cc5b6c92e4", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -18,15 +18,15 @@ use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc::hir::def::*;\n use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n+use rustc::hir::ptr::P;\n use rustc::hir::{self, Pat, PatKind};\n \n use smallvec::smallvec;\n use std::slice;\n \n-use syntax::ptr::P;\n use syntax_pos::{Span, DUMMY_SP, MultiSpan};\n \n-pub(crate) fn check_match<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) {\n+pub(crate) fn check_match(tcx: TyCtxt<'_>, def_id: DefId) {\n     let body_id = if let Some(id) = tcx.hir().as_local_hir_id(def_id) {\n         tcx.hir().body_owned_by(id)\n     } else {\n@@ -43,7 +43,7 @@ pub(crate) fn check_match<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) {\n     }.visit_body(tcx.hir().body(body_id));\n }\n \n-fn create_e0004<'a>(sess: &'a Session, sp: Span, error_message: String) -> DiagnosticBuilder<'a> {\n+fn create_e0004(sess: &Session, sp: Span, error_message: String) -> DiagnosticBuilder<'_> {\n     struct_span_err!(sess, sp, E0004, \"{}\", &error_message)\n }\n "}, {"sha": "6ba2f587768497bf9b89e29e32569ee47227dbcb", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -20,13 +20,13 @@ use rustc::ty::layout::{VariantIdx, Size};\n use rustc::hir::{self, PatKind, RangeEnd};\n use rustc::hir::def::{CtorOf, Res, DefKind, CtorKind};\n use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n+use rustc::hir::ptr::P;\n \n use rustc_data_structures::indexed_vec::Idx;\n \n use std::cmp::Ordering;\n use std::fmt;\n use syntax::ast;\n-use syntax::ptr::P;\n use syntax::symbol::sym;\n use syntax_pos::Span;\n "}, {"sha": "d61fb87336ccf0d5154f8b6117e57992bff4cbef", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -1,7 +1,7 @@\n use rustc::ty::{self, Ty, TypeAndMut};\n use rustc::ty::layout::{self, TyLayout, Size};\n use rustc::ty::adjustment::{PointerCast};\n-use syntax::ast::{FloatTy, IntTy, UintTy};\n+use syntax::ast::FloatTy;\n use syntax::symbol::sym;\n \n use rustc_apfloat::ieee::{Single, Double};\n@@ -11,9 +11,9 @@ use rustc::mir::interpret::{\n };\n use rustc::mir::CastKind;\n \n-use super::{InterpretCx, Machine, PlaceTy, OpTy, Immediate};\n+use super::{InterpCx, Machine, PlaceTy, OpTy, Immediate};\n \n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     fn type_is_fat_ptr(&self, ty: Ty<'tcx>) -> bool {\n         match ty.sty {\n             ty::RawPtr(ty::TypeAndMut { ty, .. }) |\n@@ -151,7 +151,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n                     \"Unexpected cast from type {:?}\", src_layout.ty\n                 );\n                 match val.to_bits_or_ptr(src_layout.size, self) {\n-                    Err(ptr) => self.cast_from_ptr(ptr, dest_layout.ty),\n+                    Err(ptr) => self.cast_from_ptr(ptr, src_layout, dest_layout),\n                     Ok(data) => self.cast_from_int(data, src_layout, dest_layout),\n                 }\n             }\n@@ -239,17 +239,25 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n     fn cast_from_ptr(\n         &self,\n         ptr: Pointer<M::PointerTag>,\n-        ty: Ty<'tcx>\n+        src_layout: TyLayout<'tcx>,\n+        dest_layout: TyLayout<'tcx>,\n     ) -> InterpResult<'tcx, Scalar<M::PointerTag>> {\n         use rustc::ty::TyKind::*;\n-        match ty.sty {\n+\n+        match dest_layout.ty.sty {\n             // Casting to a reference or fn pointer is not permitted by rustc,\n             // no need to support it here.\n-            RawPtr(_) |\n-            Int(IntTy::Isize) |\n-            Uint(UintTy::Usize) => Ok(ptr.into()),\n-            Int(_) | Uint(_) => err!(ReadPointerAsBytes),\n-            _ => err!(Unimplemented(format!(\"ptr to {:?} cast\", ty))),\n+            RawPtr(_) => Ok(ptr.into()),\n+            Int(_) | Uint(_) => {\n+                let size = self.memory.pointer_size();\n+\n+                match self.force_bits(Scalar::Ptr(ptr), size) {\n+                    Ok(bits) => self.cast_from_int(bits, src_layout, dest_layout),\n+                    Err(_) if dest_layout.size == size => Ok(ptr.into()),\n+                    Err(e) => Err(e),\n+                }\n+            }\n+            _ => bug!(\"invalid MIR: ptr to {:?} cast\", dest_layout.ty)\n         }\n     }\n "}, {"sha": "fd5290ee0400c52f467171a4f97241d8a8fa3594", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -26,7 +26,7 @@ use super::{\n     Memory, Machine\n };\n \n-pub struct InterpretCx<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n+pub struct InterpCx<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n     /// Stores the `Machine` instance.\n     pub machine: M,\n \n@@ -158,14 +158,14 @@ impl<'tcx, Tag: Copy + 'static> LocalState<'tcx, Tag> {\n     }\n }\n \n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout for InterpretCx<'mir, 'tcx, M> {\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout for InterpCx<'mir, 'tcx, M> {\n     #[inline]\n     fn data_layout(&self) -> &layout::TargetDataLayout {\n         &self.tcx.data_layout\n     }\n }\n \n-impl<'mir, 'tcx, M> layout::HasTyCtxt<'tcx> for InterpretCx<'mir, 'tcx, M>\n+impl<'mir, 'tcx, M> layout::HasTyCtxt<'tcx> for InterpCx<'mir, 'tcx, M>\n where\n     M: Machine<'mir, 'tcx>,\n {\n@@ -175,7 +175,7 @@ where\n     }\n }\n \n-impl<'mir, 'tcx, M> layout::HasParamEnv<'tcx> for InterpretCx<'mir, 'tcx, M>\n+impl<'mir, 'tcx, M> layout::HasParamEnv<'tcx> for InterpCx<'mir, 'tcx, M>\n where\n     M: Machine<'mir, 'tcx>,\n {\n@@ -184,7 +184,7 @@ where\n     }\n }\n \n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> LayoutOf for InterpretCx<'mir, 'tcx, M> {\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> LayoutOf for InterpCx<'mir, 'tcx, M> {\n     type Ty = Ty<'tcx>;\n     type TyLayout = InterpResult<'tcx, TyLayout<'tcx>>;\n \n@@ -195,14 +195,14 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> LayoutOf for InterpretCx<'mir, 'tcx, M>\n     }\n }\n \n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn new(\n         tcx: TyCtxtAt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         machine: M,\n         memory_extra: M::MemoryExtra,\n     ) -> Self {\n-        InterpretCx {\n+        InterpCx {\n             machine,\n             tcx,\n             param_env,"}, {"sha": "cf36c10a614e5a3fa06512be1149a2017933fe26", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -11,7 +11,7 @@ use rustc::mir::interpret::{\n };\n \n use super::{\n-    Machine, PlaceTy, OpTy, InterpretCx, Immediate,\n+    Machine, PlaceTy, OpTy, InterpCx, Immediate,\n };\n \n mod type_name;\n@@ -39,7 +39,7 @@ fn numeric_intrinsic<'tcx, Tag>(\n     Ok(Scalar::from_uint(bits_out, size))\n }\n \n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Returns `true` if emulation happened.\n     pub fn emulate_intrinsic(\n         &mut self,"}, {"sha": "ff560360f0ad1f186bc97eefec465a2b1d89e178", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -11,7 +11,7 @@ use rustc::ty::{self, query::TyCtxtAt};\n \n use super::{\n     Allocation, AllocId, InterpResult, Scalar, AllocationExtra,\n-    InterpretCx, PlaceTy, OpTy, ImmTy, MemoryKind, Pointer, Memory\n+    InterpCx, PlaceTy, OpTy, ImmTy, MemoryKind, Pointer, Memory\n };\n \n /// Whether this kind of memory is allowed to leak\n@@ -95,11 +95,11 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     const STATIC_KIND: Option<Self::MemoryKinds>;\n \n     /// Whether to enforce the validity invariant\n-    fn enforce_validity(ecx: &InterpretCx<'mir, 'tcx, Self>) -> bool;\n+    fn enforce_validity(ecx: &InterpCx<'mir, 'tcx, Self>) -> bool;\n \n     /// Called before a basic block terminator is executed.\n     /// You can use this to detect endlessly running programs.\n-    fn before_terminator(ecx: &mut InterpretCx<'mir, 'tcx, Self>) -> InterpResult<'tcx>;\n+    fn before_terminator(ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx>;\n \n     /// Entry point to all function calls.\n     ///\n@@ -112,7 +112,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// Passing `dest`and `ret` in the same `Option` proved very annoying when only one of them\n     /// was used.\n     fn find_fn(\n-        ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n+        ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx, Self::PointerTag>],\n         dest: Option<PlaceTy<'tcx, Self::PointerTag>>,\n@@ -122,7 +122,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// Directly process an intrinsic without pushing a stack frame.\n     /// If this returns successfully, the engine will take care of jumping to the next block.\n     fn call_intrinsic(\n-        ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n+        ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx, Self::PointerTag>],\n         dest: PlaceTy<'tcx, Self::PointerTag>,\n@@ -145,15 +145,15 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     ///\n     /// Returns a (value, overflowed) pair if the operation succeeded\n     fn ptr_op(\n-        ecx: &InterpretCx<'mir, 'tcx, Self>,\n+        ecx: &InterpCx<'mir, 'tcx, Self>,\n         bin_op: mir::BinOp,\n         left: ImmTy<'tcx, Self::PointerTag>,\n         right: ImmTy<'tcx, Self::PointerTag>,\n     ) -> InterpResult<'tcx, (Scalar<Self::PointerTag>, bool)>;\n \n     /// Heap allocations via the `box` keyword.\n     fn box_alloc(\n-        ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n+        ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         dest: PlaceTy<'tcx, Self::PointerTag>,\n     ) -> InterpResult<'tcx>;\n \n@@ -193,19 +193,19 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// Executes a retagging operation\n     #[inline]\n     fn retag(\n-        _ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n+        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         _kind: mir::RetagKind,\n         _place: PlaceTy<'tcx, Self::PointerTag>,\n     ) -> InterpResult<'tcx> {\n         Ok(())\n     }\n \n     /// Called immediately before a new stack frame got pushed\n-    fn stack_push(ecx: &mut InterpretCx<'mir, 'tcx, Self>) -> InterpResult<'tcx, Self::FrameExtra>;\n+    fn stack_push(ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx, Self::FrameExtra>;\n \n     /// Called immediately after a stack frame gets popped\n     fn stack_pop(\n-        ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n+        ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         extra: Self::FrameExtra,\n     ) -> InterpResult<'tcx>;\n "}, {"sha": "f5d912595337bcad06be6ba0e8c5bd06023f5c83", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -158,8 +158,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     pub fn reallocate(\n         &mut self,\n         ptr: Pointer<M::PointerTag>,\n-        old_size: Size,\n-        old_align: Align,\n+        old_size_and_align: Option<(Size, Align)>,\n         new_size: Size,\n         new_align: Align,\n         kind: MemoryKind<M::MemoryKinds>,\n@@ -171,15 +170,19 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         // For simplicities' sake, we implement reallocate as \"alloc, copy, dealloc\".\n         // This happens so rarely, the perf advantage is outweighed by the maintenance cost.\n         let new_ptr = self.allocate(new_size, new_align, kind);\n+        let old_size = match old_size_and_align {\n+            Some((size, _align)) => size,\n+            None => Size::from_bytes(self.get(ptr.alloc_id)?.bytes.len() as u64),\n+        };\n         self.copy(\n             ptr.into(),\n-            old_align,\n+            Align::from_bytes(1).unwrap(), // old_align anyway gets checked below by `deallocate`\n             new_ptr.into(),\n             new_align,\n             old_size.min(new_size),\n             /*nonoverlapping*/ true,\n         )?;\n-        self.deallocate(ptr, Some((old_size, old_align)), kind)?;\n+        self.deallocate(ptr, old_size_and_align, kind)?;\n \n         Ok(new_ptr)\n     }\n@@ -198,7 +201,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     pub fn deallocate(\n         &mut self,\n         ptr: Pointer<M::PointerTag>,\n-        size_and_align: Option<(Size, Align)>,\n+        old_size_and_align: Option<(Size, Align)>,\n         kind: MemoryKind<M::MemoryKinds>,\n     ) -> InterpResult<'tcx> {\n         trace!(\"deallocating: {}\", ptr.alloc_id);\n@@ -232,7 +235,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 format!(\"{:?}\", kind),\n             ));\n         }\n-        if let Some((size, align)) = size_and_align {\n+        if let Some((size, align)) = old_size_and_align {\n             if size.bytes() != alloc.bytes.len() as u64 || align != alloc.align {\n                 let bytes = Size::from_bytes(alloc.bytes.len() as u64);\n                 return err!(IncorrectAllocationInformation(size,"}, {"sha": "2b20f9df53837775b24cdf0aefd8313de66f8591", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -19,7 +19,7 @@ mod intern;\n pub use rustc::mir::interpret::*; // have all the `interpret` symbols in one place: here\n \n pub use self::eval_context::{\n-    InterpretCx, Frame, StackPopCleanup, LocalState, LocalValue,\n+    InterpCx, Frame, StackPopCleanup, LocalState, LocalValue,\n };\n \n pub use self::place::{Place, PlaceTy, MemPlace, MPlaceTy};"}, {"sha": "68c9047f7b70842758c4b0484ac805532818e929", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -15,7 +15,7 @@ use rustc::mir::interpret::{\n     sign_extend, truncate,\n };\n use super::{\n-    InterpretCx, Machine,\n+    InterpCx, Machine,\n     MemPlace, MPlaceTy, PlaceTy, Place,\n };\n pub use rustc::mir::interpret::ScalarMaybeUndef;\n@@ -213,7 +213,7 @@ pub(super) fn from_known_layout<'tcx>(\n     }\n }\n \n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Try reading an immediate in memory; this is interesting particularly for `ScalarPair`.\n     /// Returns `None` if the layout does not permit loading this as a value.\n     fn try_read_immediate_from_mplace("}, {"sha": "20180c9cba542423aeaa53acc00b77e23c245692", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -4,10 +4,10 @@ use syntax::ast::FloatTy;\n use rustc_apfloat::Float;\n use rustc::mir::interpret::{InterpResult, Scalar};\n \n-use super::{InterpretCx, PlaceTy, Immediate, Machine, ImmTy};\n+use super::{InterpCx, PlaceTy, Immediate, Machine, ImmTy};\n \n \n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Applies the binary operation `op` to the two operands and writes a tuple of the result\n     /// and a boolean signifying the potential overflow to the destination.\n     pub fn binop_with_overflow(\n@@ -36,7 +36,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n     }\n }\n \n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     fn binary_char_op(\n         &self,\n         bin_op: mir::BinOp,"}, {"sha": "4f3727fbd8d9af00feeedb6f0a30b2eb28f0881d", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -13,7 +13,7 @@ use rustc::ty::TypeFoldable;\n \n use super::{\n     GlobalId, AllocId, Allocation, Scalar, InterpResult, Pointer, PointerArithmetic,\n-    InterpretCx, Machine, AllocMap, AllocationExtra,\n+    InterpCx, Machine, AllocMap, AllocationExtra,\n     RawConst, Immediate, ImmTy, ScalarMaybeUndef, Operand, OpTy, MemoryKind, LocalValue\n };\n \n@@ -290,7 +290,7 @@ impl<'tcx, Tag: ::std::fmt::Debug> PlaceTy<'tcx, Tag> {\n }\n \n // separating the pointer tag for `impl Trait`, see https://github.com/rust-lang/rust/issues/54385\n-impl<'mir, 'tcx, Tag, M> InterpretCx<'mir, 'tcx, M>\n+impl<'mir, 'tcx, Tag, M> InterpCx<'mir, 'tcx, M>\n where\n     // FIXME: Working around https://github.com/rust-lang/rust/issues/54385\n     Tag: ::std::fmt::Debug + Copy + Eq + Hash + 'static,\n@@ -583,7 +583,7 @@ where\n                 // global table but not in its local memory: It calls back into tcx through\n                 // a query, triggering the CTFE machinery to actually turn this lazy reference\n                 // into a bunch of bytes.  IOW, statics are evaluated with CTFE even when\n-                // this InterpretCx uses another Machine (e.g., in miri).  This is what we\n+                // this InterpCx uses another Machine (e.g., in miri).  This is what we\n                 // want!  This way, computing statics works consistently between codegen\n                 // and miri: They use the same query to eventually obtain a `ty::Const`\n                 // and use that for further computation."}, {"sha": "dc5302eb18fc4b2d1ac407b9afd805a55edfc37c", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -1,12 +1,12 @@\n-//! This module contains the `InterpretCx` methods for executing a single step of the interpreter.\n+//! This module contains the `InterpCx` methods for executing a single step of the interpreter.\n //!\n //! The main entry point is the `step` method.\n \n use rustc::mir;\n use rustc::ty::layout::LayoutOf;\n use rustc::mir::interpret::{InterpResult, Scalar, PointerArithmetic};\n \n-use super::{InterpretCx, Machine};\n+use super::{InterpCx, Machine};\n \n /// Classify whether an operator is \"left-homogeneous\", i.e., the LHS has the\n /// same type as the result.\n@@ -35,7 +35,7 @@ fn binop_right_homogeneous(op: mir::BinOp) -> bool {\n     }\n }\n \n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn run(&mut self) -> InterpResult<'tcx> {\n         while self.step()? {}\n         Ok(())"}, {"sha": "d6f3de02ec918bf83e7959f60da11d23a4927039", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -8,10 +8,10 @@ use rustc_target::spec::abi::Abi;\n \n use rustc::mir::interpret::{InterpResult, PointerArithmetic, InterpError, Scalar};\n use super::{\n-    InterpretCx, Machine, Immediate, OpTy, ImmTy, PlaceTy, MPlaceTy, StackPopCleanup\n+    InterpCx, Machine, Immediate, OpTy, ImmTy, PlaceTy, MPlaceTy, StackPopCleanup\n };\n \n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     #[inline]\n     pub fn goto_block(&mut self, target: Option<mir::BasicBlock>) -> InterpResult<'tcx> {\n         if let Some(target) = target {"}, {"sha": "27d127514229c479d7e82a5a3ae32a531964cd68", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -2,9 +2,9 @@ use rustc::ty::{self, Ty, Instance};\n use rustc::ty::layout::{Size, Align, LayoutOf};\n use rustc::mir::interpret::{Scalar, Pointer, InterpResult, PointerArithmetic};\n \n-use super::{InterpretCx, InterpError, Machine, MemoryKind};\n+use super::{InterpCx, InterpError, Machine, MemoryKind};\n \n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Creates a dynamic vtable for the given type and vtable origin. This is used only for\n     /// objects.\n     ///"}, {"sha": "374f42261bf62f533fabec7c9a2d4bae8653c3f9", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -13,7 +13,7 @@ use rustc::mir::interpret::{\n use std::hash::Hash;\n \n use super::{\n-    OpTy, Machine, InterpretCx, ValueVisitor, MPlaceTy,\n+    OpTy, Machine, InterpCx, ValueVisitor, MPlaceTy,\n };\n \n macro_rules! validation_failure {\n@@ -174,7 +174,7 @@ struct ValidityVisitor<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n         MPlaceTy<'tcx, M::PointerTag>,\n         Vec<PathElem>,\n     >>,\n-    ecx: &'rt InterpretCx<'mir, 'tcx, M>,\n+    ecx: &'rt InterpCx<'mir, 'tcx, M>,\n }\n \n impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, 'tcx, M> {\n@@ -259,7 +259,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n     type V = OpTy<'tcx, M::PointerTag>;\n \n     #[inline(always)]\n-    fn ecx(&self) -> &InterpretCx<'mir, 'tcx, M> {\n+    fn ecx(&self) -> &InterpCx<'mir, 'tcx, M> {\n         &self.ecx\n     }\n \n@@ -628,7 +628,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n     }\n }\n \n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// This function checks the data at `op`. `op` is assumed to cover valid memory if it\n     /// is an indirect operand.\n     /// It will error if the bits at the destination do not match the ones described by the layout."}, {"sha": "783d2522637352977299bba19f493ff3a9b105f7", "filename": "src/librustc_mir/interpret/visitor.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -8,7 +8,7 @@ use rustc::mir::interpret::{\n };\n \n use super::{\n-    Machine, InterpretCx, MPlaceTy, OpTy,\n+    Machine, InterpCx, MPlaceTy, OpTy,\n };\n \n // A thing that we can project into, and that has a layout.\n@@ -21,7 +21,7 @@ pub trait Value<'mir, 'tcx, M: Machine<'mir, 'tcx>>: Copy {\n     /// Makes this into an `OpTy`.\n     fn to_op(\n         self,\n-        ecx: &InterpretCx<'mir, 'tcx, M>,\n+        ecx: &InterpCx<'mir, 'tcx, M>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>>;\n \n     /// Creates this from an `MPlaceTy`.\n@@ -30,14 +30,14 @@ pub trait Value<'mir, 'tcx, M: Machine<'mir, 'tcx>>: Copy {\n     /// Projects to the given enum variant.\n     fn project_downcast(\n         self,\n-        ecx: &InterpretCx<'mir, 'tcx, M>,\n+        ecx: &InterpCx<'mir, 'tcx, M>,\n         variant: VariantIdx,\n     ) -> InterpResult<'tcx, Self>;\n \n     /// Projects to the n-th field.\n     fn project_field(\n         self,\n-        ecx: &InterpretCx<'mir, 'tcx, M>,\n+        ecx: &InterpCx<'mir, 'tcx, M>,\n         field: u64,\n     ) -> InterpResult<'tcx, Self>;\n }\n@@ -53,7 +53,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M> for OpTy<'tcx, M::\n     #[inline(always)]\n     fn to_op(\n         self,\n-        _ecx: &InterpretCx<'mir, 'tcx, M>,\n+        _ecx: &InterpCx<'mir, 'tcx, M>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         Ok(self)\n     }\n@@ -66,7 +66,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M> for OpTy<'tcx, M::\n     #[inline(always)]\n     fn project_downcast(\n         self,\n-        ecx: &InterpretCx<'mir, 'tcx, M>,\n+        ecx: &InterpCx<'mir, 'tcx, M>,\n         variant: VariantIdx,\n     ) -> InterpResult<'tcx, Self> {\n         ecx.operand_downcast(self, variant)\n@@ -75,7 +75,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M> for OpTy<'tcx, M::\n     #[inline(always)]\n     fn project_field(\n         self,\n-        ecx: &InterpretCx<'mir, 'tcx, M>,\n+        ecx: &InterpCx<'mir, 'tcx, M>,\n         field: u64,\n     ) -> InterpResult<'tcx, Self> {\n         ecx.operand_field(self, field)\n@@ -91,7 +91,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M> for MPlaceTy<'tcx,\n     #[inline(always)]\n     fn to_op(\n         self,\n-        _ecx: &InterpretCx<'mir, 'tcx, M>,\n+        _ecx: &InterpCx<'mir, 'tcx, M>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         Ok(self.into())\n     }\n@@ -104,7 +104,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M> for MPlaceTy<'tcx,\n     #[inline(always)]\n     fn project_downcast(\n         self,\n-        ecx: &InterpretCx<'mir, 'tcx, M>,\n+        ecx: &InterpCx<'mir, 'tcx, M>,\n         variant: VariantIdx,\n     ) -> InterpResult<'tcx, Self> {\n         ecx.mplace_downcast(self, variant)\n@@ -113,7 +113,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M> for MPlaceTy<'tcx,\n     #[inline(always)]\n     fn project_field(\n         self,\n-        ecx: &InterpretCx<'mir, 'tcx, M>,\n+        ecx: &InterpCx<'mir, 'tcx, M>,\n         field: u64,\n     ) -> InterpResult<'tcx, Self> {\n         ecx.mplace_field(self, field)\n@@ -126,9 +126,9 @@ macro_rules! make_value_visitor {\n         pub trait $visitor_trait_name<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>>: Sized {\n             type V: Value<'mir, 'tcx, M>;\n \n-            /// The visitor must have an `InterpretCx` in it.\n+            /// The visitor must have an `InterpCx` in it.\n             fn ecx(&$($mutability)? self)\n-                -> &$($mutability)? InterpretCx<'mir, 'tcx, M>;\n+                -> &$($mutability)? InterpCx<'mir, 'tcx, M>;\n \n             // Recursive actions, ready to be overloaded.\n             /// Visits the given value, dispatching as appropriate to more specialized visitors."}, {"sha": "b85149cf55676aebaed3312d18aec66c1e79b83e", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -24,6 +24,7 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![feature(slice_concat_ext)]\n #![feature(trusted_len)]\n #![feature(try_blocks)]\n+#![feature(mem_take)]\n \n #![recursion_limit=\"256\"]\n "}, {"sha": "097d76925c8eba59cbac72ab7d207d5f66e2199b", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -281,10 +281,10 @@ impl<'tcx> InliningMap<'tcx> {\n     }\n }\n \n-pub fn collect_crate_mono_items<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+pub fn collect_crate_mono_items(\n+    tcx: TyCtxt<'_>,\n     mode: MonoItemCollectionMode,\n-) -> (FxHashSet<MonoItem<'tcx>>, InliningMap<'tcx>) {\n+) -> (FxHashSet<MonoItem<'_>>, InliningMap<'_>) {\n     let roots = time(tcx.sess, \"collecting roots\", || {\n         collect_roots(tcx, mode)\n     });\n@@ -315,7 +315,7 @@ pub fn collect_crate_mono_items<'tcx>(\n \n // Find all non-generic items by walking the HIR. These items serve as roots to\n // start monomorphizing from.\n-fn collect_roots<'tcx>(tcx: TyCtxt<'tcx>, mode: MonoItemCollectionMode) -> Vec<MonoItem<'tcx>> {\n+fn collect_roots(tcx: TyCtxt<'_>, mode: MonoItemCollectionMode) -> Vec<MonoItem<'_>> {\n     debug!(\"Collecting roots\");\n     let mut roots = Vec::new();\n \n@@ -912,7 +912,7 @@ fn find_vtable_types_for_unsizing<'tcx>(\n     }\n }\n \n-fn create_fn_mono_item<'tcx>(instance: Instance<'tcx>) -> MonoItem<'tcx> {\n+fn create_fn_mono_item(instance: Instance<'_>) -> MonoItem<'_> {\n     debug!(\"create_fn_mono_item(instance={})\", instance);\n     MonoItem::Fn(instance)\n }\n@@ -1114,7 +1114,7 @@ impl RootCollector<'_, 'v> {\n     }\n }\n \n-fn item_requires_monomorphization<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> bool {\n+fn item_requires_monomorphization(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n     let generics = tcx.generics_of(def_id);\n     generics.requires_monomorphization(tcx)\n }\n@@ -1243,7 +1243,7 @@ fn collect_neighbours<'tcx>(\n     }\n }\n \n-fn def_id_to_string<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> String {\n+fn def_id_to_string(tcx: TyCtxt<'_>, def_id: DefId) -> String {\n     let mut output = String::new();\n     let printer = DefPathBasedNames::new(tcx, false, false);\n     printer.push_def_path(def_id, &mut output);"}, {"sha": "a934c921d9257e04893df143aae2d49b074e9d1d", "filename": "src/librustc_mir/monomorphize/partitioning.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -839,10 +839,10 @@ where\n     }\n }\n \n-fn collect_and_partition_mono_items<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+fn collect_and_partition_mono_items(\n+    tcx: TyCtxt<'_>,\n     cnum: CrateNum,\n-) -> (Arc<DefIdSet>, Arc<Vec<Arc<CodegenUnit<'tcx>>>>) {\n+) -> (Arc<DefIdSet>, Arc<Vec<Arc<CodegenUnit<'_>>>>) {\n     assert_eq!(cnum, LOCAL_CRATE);\n \n     let collection_mode = match tcx.sess.opts.debugging_opts.print_mono_items {"}, {"sha": "32b964dbadfa92ac3dcf5e4a5d0dab9f6844db46", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -829,7 +829,7 @@ fn build_call_shim<'tcx>(\n     body\n }\n \n-pub fn build_adt_ctor<'tcx>(tcx: TyCtxt<'tcx>, ctor_id: DefId) -> &'tcx Body<'tcx> {\n+pub fn build_adt_ctor(tcx: TyCtxt<'_>, ctor_id: DefId) -> &Body<'_> {\n     debug_assert!(tcx.is_constructor(ctor_id));\n \n     let span = tcx.hir().span_if_local(ctor_id)"}, {"sha": "de5af0a46b534935102c2de6e231ad2d28fbccfe", "filename": "src/librustc_mir/transform/add_retag.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -14,8 +14,8 @@ pub struct AddRetag;\n /// after the assignment, we can be sure to obtain the same place value.\n /// (Concurrent accesses by other threads are no problem as these are anyway non-atomic\n /// copies.  Data races are UB.)\n-fn is_stable<'tcx>(\n-    place: &Place<'tcx>,\n+fn is_stable(\n+    place: &Place<'_>,\n ) -> bool {\n     use rustc::mir::Place::*;\n "}, {"sha": "9898ba897734d7f74deb56476bea127caf3506ce", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -480,11 +480,11 @@ impl<'a, 'tcx> hir::intravisit::Visitor<'tcx> for UnusedUnsafeVisitor<'a> {\n     }\n }\n \n-fn check_unused_unsafe<'a, 'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+fn check_unused_unsafe(\n+    tcx: TyCtxt<'_>,\n     def_id: DefId,\n     used_unsafe: &FxHashSet<hir::HirId>,\n-    unsafe_blocks: &'a mut Vec<(hir::HirId, bool)>,\n+    unsafe_blocks: &mut Vec<(hir::HirId, bool)>,\n ) {\n     let body_id =\n         tcx.hir().as_local_hir_id(def_id).and_then(|hir_id| {\n@@ -506,7 +506,7 @@ fn check_unused_unsafe<'a, 'tcx>(\n     hir::intravisit::Visitor::visit_body(&mut visitor, body);\n }\n \n-fn unsafety_check_result<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> UnsafetyCheckResult {\n+fn unsafety_check_result(tcx: TyCtxt<'_>, def_id: DefId) -> UnsafetyCheckResult {\n     debug!(\"unsafety_violations({:?})\", def_id);\n \n     // N.B., this borrow is valid because all the consumers of\n@@ -545,7 +545,7 @@ fn unsafety_check_result<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> UnsafetyChec\n     }\n }\n \n-fn unsafe_derive_on_repr_packed<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) {\n+fn unsafe_derive_on_repr_packed(tcx: TyCtxt<'_>, def_id: DefId) {\n     let lint_hir_id = tcx.hir().as_local_hir_id(def_id).unwrap_or_else(||\n         bug!(\"checking unsafety for non-local def id {:?}\", def_id));\n \n@@ -602,7 +602,7 @@ fn report_unused_unsafe(tcx: TyCtxt<'_>, used_unsafe: &FxHashSet<hir::HirId>, id\n     db.emit();\n }\n \n-fn builtin_derive_def_id<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Option<DefId> {\n+fn builtin_derive_def_id(tcx: TyCtxt<'_>, def_id: DefId) -> Option<DefId> {\n     debug!(\"builtin_derive_def_id({:?})\", def_id);\n     if let Some(impl_def_id) = tcx.impl_of_method(def_id) {\n         if tcx.has_attr(impl_def_id, sym::automatically_derived) {\n@@ -618,7 +618,7 @@ fn builtin_derive_def_id<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Option<DefId\n     }\n }\n \n-pub fn check_unsafety<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) {\n+pub fn check_unsafety(tcx: TyCtxt<'_>, def_id: DefId) {\n     debug!(\"check_unsafety({:?})\", def_id);\n \n     // closures are handled by their parent fn."}, {"sha": "29480f88fcedc421e291fa5026cd5352907de848", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -23,7 +23,7 @@ use rustc::ty::layout::{\n };\n \n use crate::interpret::{\n-    self, InterpretCx, ScalarMaybeUndef, Immediate, OpTy,\n+    self, InterpCx, ScalarMaybeUndef, Immediate, OpTy,\n     ImmTy, MemoryKind, StackPopCleanup, LocalValue, LocalState,\n };\n use crate::const_eval::{\n@@ -117,7 +117,7 @@ type Const<'tcx> = OpTy<'tcx>;\n \n /// Finds optimization opportunities on the MIR.\n struct ConstPropagator<'mir, 'tcx> {\n-    ecx: InterpretCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>,\n+    ecx: InterpCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>,\n     tcx: TyCtxt<'tcx>,\n     source: MirSource<'tcx>,\n     can_const_prop: IndexVec<Local, bool>,\n@@ -202,7 +202,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n \n         // If the local is `Unitialized` or `Dead` then we haven't propagated a value into it.\n         //\n-        // `InterpretCx::access_local()` mostly takes care of this for us however, for ZSTs,\n+        // `InterpCx::access_local()` mostly takes care of this for us however, for ZSTs,\n         // it will synthesize a value for us. In doing so, that will cause the\n         // `get_const(l).is_empty()` assert right before we call `set_const()` in `visit_statement`\n         // to fail."}, {"sha": "a6fb555f20bd023cddbf7d14aaa3902d4f82148c", "filename": "src/librustc_mir/transform/dump_mir.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -14,7 +14,7 @@ use crate::util as mir_util;\n pub struct Marker(pub &'static str);\n \n impl MirPass for Marker {\n-    fn name<'a>(&'a self) -> Cow<'a, str> {\n+    fn name(&self) -> Cow<'_, str> {\n         Cow::Borrowed(self.0)\n     }\n \n@@ -52,7 +52,7 @@ pub fn on_mir_pass<'tcx>(\n     }\n }\n \n-pub fn emit_mir<'tcx>(tcx: TyCtxt<'tcx>, outputs: &OutputFilenames) -> io::Result<()> {\n+pub fn emit_mir(tcx: TyCtxt<'_>, outputs: &OutputFilenames) -> io::Result<()> {\n     let path = outputs.path(OutputType::Mir);\n     let mut f = File::create(&path)?;\n     mir_util::write_mir_pretty(tcx, None, &mut f)?;"}, {"sha": "2ed3f7d5c26e28c852e4dd45a30c153c43754c20", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 42, "deletions": 32, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -68,7 +68,7 @@ use crate::transform::simplify;\n use crate::transform::no_landing_pads::no_landing_pads;\n use crate::dataflow::{DataflowResults, DataflowResultsConsumer, FlowAtLocation};\n use crate::dataflow::{do_dataflow, DebugFormatted, state_for_location};\n-use crate::dataflow::{MaybeStorageLive, HaveBeenBorrowedLocals};\n+use crate::dataflow::{MaybeStorageLive, HaveBeenBorrowedLocals, RequiresStorage};\n use crate::util::dump_mir;\n use crate::util::liveness;\n \n@@ -437,16 +437,18 @@ fn locals_live_across_suspend_points(\n \n     // Calculate the MIR locals which have been previously\n     // borrowed (even if they are still active).\n-    // This is only used for immovable generators.\n-    let borrowed_locals = if !movable {\n-        let analysis = HaveBeenBorrowedLocals::new(body);\n-        let result =\n-            do_dataflow(tcx, body, def_id, &[], &dead_unwinds, analysis,\n-                        |bd, p| DebugFormatted::new(&bd.body().local_decls[p]));\n-        Some((analysis, result))\n-    } else {\n-        None\n-    };\n+    let borrowed_locals_analysis = HaveBeenBorrowedLocals::new(body);\n+    let borrowed_locals_result =\n+        do_dataflow(tcx, body, def_id, &[], &dead_unwinds, borrowed_locals_analysis,\n+                    |bd, p| DebugFormatted::new(&bd.body().local_decls[p]));\n+\n+    // Calculate the MIR locals that we actually need to keep storage around\n+    // for.\n+    let requires_storage_analysis = RequiresStorage::new(body, &borrowed_locals_result);\n+    let requires_storage =\n+        do_dataflow(tcx, body, def_id, &[], &dead_unwinds, requires_storage_analysis,\n+                    |bd, p| DebugFormatted::new(&bd.body().local_decls[p]));\n+    let requires_storage_analysis = RequiresStorage::new(body, &borrowed_locals_result);\n \n     // Calculate the liveness of MIR locals ignoring borrows.\n     let mut live_locals = liveness::LiveVarSet::new_empty(body.local_decls.len());\n@@ -471,10 +473,10 @@ fn locals_live_across_suspend_points(\n                 statement_index: data.statements.len(),\n             };\n \n-            if let Some((ref analysis, ref result)) = borrowed_locals {\n+            if !movable {\n                 let borrowed_locals = state_for_location(loc,\n-                                                         analysis,\n-                                                         result,\n+                                                         &borrowed_locals_analysis,\n+                                                         &borrowed_locals_result,\n                                                          body);\n                 // The `liveness` variable contains the liveness of MIR locals ignoring borrows.\n                 // This is correct for movable generators since borrows cannot live across\n@@ -489,34 +491,42 @@ fn locals_live_across_suspend_points(\n                 liveness.outs[block].union(&borrowed_locals);\n             }\n \n-            let mut storage_liveness = state_for_location(loc,\n-                                                          &storage_live_analysis,\n-                                                          &storage_live,\n-                                                          body);\n+            let storage_liveness = state_for_location(loc,\n+                                                      &storage_live_analysis,\n+                                                      &storage_live,\n+                                                      body);\n \n             // Store the storage liveness for later use so we can restore the state\n             // after a suspension point\n             storage_liveness_map.insert(block, storage_liveness.clone());\n \n-            // Mark locals without storage statements as always having live storage\n-            storage_liveness.union(&ignored.0);\n+            let mut storage_required = state_for_location(loc,\n+                                                          &requires_storage_analysis,\n+                                                          &requires_storage,\n+                                                          body);\n+\n+            // Mark locals without storage statements as always requiring storage\n+            storage_required.union(&ignored.0);\n \n             // Locals live are live at this point only if they are used across\n             // suspension points (the `liveness` variable)\n-            // and their storage is live (the `storage_liveness` variable)\n-            let mut live_locals_here = storage_liveness;\n+            // and their storage is required (the `storage_required` variable)\n+            let mut live_locals_here = storage_required;\n             live_locals_here.intersect(&liveness.outs[block]);\n \n             // The generator argument is ignored\n             live_locals_here.remove(self_arg());\n \n+            debug!(\"loc = {:?}, live_locals_here = {:?}\", loc, live_locals_here);\n+\n             // Add the locals live at this suspension point to the set of locals which live across\n             // any suspension points\n             live_locals.union(&live_locals_here);\n \n             live_locals_at_suspension_points.push(live_locals_here);\n         }\n     }\n+    debug!(\"live_locals = {:?}\", live_locals);\n \n     // Renumber our liveness_map bitsets to include only the locals we are\n     // saving.\n@@ -529,8 +539,8 @@ fn locals_live_across_suspend_points(\n         body,\n         &live_locals,\n         &ignored,\n-        storage_live,\n-        storage_live_analysis);\n+        requires_storage,\n+        requires_storage_analysis);\n \n     LivenessInfo {\n         live_locals,\n@@ -567,8 +577,8 @@ fn compute_storage_conflicts(\n     body: &'mir Body<'tcx>,\n     stored_locals: &liveness::LiveVarSet,\n     ignored: &StorageIgnored,\n-    storage_live: DataflowResults<'tcx, MaybeStorageLive<'mir, 'tcx>>,\n-    _storage_live_analysis: MaybeStorageLive<'mir, 'tcx>,\n+    requires_storage: DataflowResults<'tcx, RequiresStorage<'mir, 'tcx>>,\n+    _requires_storage_analysis: RequiresStorage<'mir, 'tcx>,\n ) -> BitMatrix<GeneratorSavedLocal, GeneratorSavedLocal> {\n     assert_eq!(body.local_decls.len(), ignored.0.domain_size());\n     assert_eq!(body.local_decls.len(), stored_locals.domain_size());\n@@ -584,9 +594,9 @@ fn compute_storage_conflicts(\n     let mut visitor = StorageConflictVisitor {\n         body,\n         stored_locals: &stored_locals,\n-        local_conflicts: BitMatrix::from_row_n(&ineligible_locals, body.local_decls.len())\n+        local_conflicts: BitMatrix::from_row_n(&ineligible_locals, body.local_decls.len()),\n     };\n-    let mut state = FlowAtLocation::new(storage_live);\n+    let mut state = FlowAtLocation::new(requires_storage);\n     visitor.analyze_results(&mut state);\n     let local_conflicts = visitor.local_conflicts;\n \n@@ -627,7 +637,7 @@ struct StorageConflictVisitor<'body, 'tcx, 's> {\n impl<'body, 'tcx, 's> DataflowResultsConsumer<'body, 'tcx>\n     for StorageConflictVisitor<'body, 'tcx, 's>\n {\n-    type FlowState = FlowAtLocation<'tcx, MaybeStorageLive<'body, 'tcx>>;\n+    type FlowState = FlowAtLocation<'tcx, RequiresStorage<'body, 'tcx>>;\n \n     fn body(&self) -> &'body Body<'tcx> {\n         self.body\n@@ -657,7 +667,7 @@ impl<'body, 'tcx, 's> DataflowResultsConsumer<'body, 'tcx>\n \n impl<'body, 'tcx, 's> StorageConflictVisitor<'body, 'tcx, 's> {\n     fn apply_state(&mut self,\n-                   flow_state: &FlowAtLocation<'tcx, MaybeStorageLive<'body, 'tcx>>,\n+                   flow_state: &FlowAtLocation<'tcx, RequiresStorage<'body, 'tcx>>,\n                    loc: Location) {\n         // Ignore unreachable blocks.\n         match self.body.basic_blocks()[loc.block].terminator().kind {\n@@ -1018,14 +1028,14 @@ fn create_generator_resume_function<'tcx>(\n     dump_mir(tcx, None, \"generator_resume\", &0, source, body, |_, _| Ok(()) );\n }\n \n-fn source_info<'tcx>(body: &Body<'tcx>) -> SourceInfo {\n+fn source_info(body: &Body<'_>) -> SourceInfo {\n     SourceInfo {\n         span: body.span,\n         scope: OUTERMOST_SOURCE_SCOPE,\n     }\n }\n \n-fn insert_clean_drop<'tcx>(body: &mut Body<'tcx>) -> BasicBlock {\n+fn insert_clean_drop(body: &mut Body<'_>) -> BasicBlock {\n     let return_block = insert_term_block(body, TerminatorKind::Return);\n \n     // Create a block to destroy an unresumed generators. This can only destroy upvars."}, {"sha": "7f43c4a3e89a1adee9f7cf976f1aed2afeea6bd9", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -50,13 +50,13 @@ pub(crate) fn provide(providers: &mut Providers<'_>) {\n     };\n }\n \n-fn is_mir_available<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> bool {\n+fn is_mir_available(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n     tcx.mir_keys(def_id.krate).contains(&def_id)\n }\n \n /// Finds the full set of `DefId`s within the current crate that have\n /// MIR associated with them.\n-fn mir_keys<'tcx>(tcx: TyCtxt<'tcx>, krate: CrateNum) -> &'tcx DefIdSet {\n+fn mir_keys(tcx: TyCtxt<'_>, krate: CrateNum) -> &DefIdSet {\n     assert_eq!(krate, LOCAL_CRATE);\n \n     let mut set = DefIdSet::default();\n@@ -94,7 +94,7 @@ fn mir_keys<'tcx>(tcx: TyCtxt<'tcx>, krate: CrateNum) -> &'tcx DefIdSet {\n     tcx.arena.alloc(set)\n }\n \n-fn mir_built<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx Steal<Body<'tcx>> {\n+fn mir_built(tcx: TyCtxt<'_>, def_id: DefId) -> &Steal<Body<'_>> {\n     let mir = build::mir_build(tcx, def_id);\n     tcx.alloc_steal_mir(mir)\n }\n@@ -137,7 +137,7 @@ pub fn default_name<T: ?Sized>() -> Cow<'static, str> {\n /// pass will be named after the type, and it will consist of a main\n /// loop that goes over each available MIR and applies `run_pass`.\n pub trait MirPass {\n-    fn name<'a>(&'a self) -> Cow<'a, str> {\n+    fn name(&self) -> Cow<'_, str> {\n         default_name::<Self>()\n     }\n \n@@ -192,7 +192,7 @@ pub fn run_passes(\n     }\n }\n \n-fn mir_const<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx Steal<Body<'tcx>> {\n+fn mir_const(tcx: TyCtxt<'_>, def_id: DefId) -> &Steal<Body<'_>> {\n     // Unsafety check uses the raw mir, so make sure it is run\n     let _ = tcx.unsafety_check_result(def_id);\n \n@@ -223,7 +223,7 @@ fn mir_validated(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx Steal<Body<'tcx>> {\n     tcx.alloc_steal_mir(body)\n }\n \n-fn optimized_mir<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx Body<'tcx> {\n+fn optimized_mir(tcx: TyCtxt<'_>, def_id: DefId) -> &Body<'_> {\n     if tcx.is_constructor(def_id) {\n         // There's no reason to run all of the MIR passes on constructors when\n         // we can just output the MIR we want directly. This also saves const"}, {"sha": "3e52d3ee9bbdff021d4d8d56ea2501bd037e1d26", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -1473,7 +1473,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     };\n }\n \n-fn mir_const_qualif<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> (u8, &'tcx BitSet<Local>) {\n+fn mir_const_qualif(tcx: TyCtxt<'_>, def_id: DefId) -> (u8, &BitSet<Local>) {\n     // N.B., this `borrow()` is guaranteed to be valid (i.e., the value\n     // cannot yet be stolen), because `mir_validated()`, which steals\n     // from `mir_const(), forces this query to execute before"}, {"sha": "2eed9d453f23363fded6deb3aa19d811e6e04cbf", "filename": "src/librustc_mir/transform/simplify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -53,7 +53,7 @@ pub fn simplify_cfg(body: &mut Body<'_>) {\n }\n \n impl MirPass for SimplifyCfg {\n-    fn name<'a>(&'a self) -> Cow<'a, str> {\n+    fn name(&self) -> Cow<'_, str> {\n         Cow::Borrowed(&self.label)\n     }\n "}, {"sha": "f39c71ef42d71559c70bc6a04a5bd008ceb3ef03", "filename": "src/librustc_mir/transform/simplify_branches.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -15,7 +15,7 @@ impl SimplifyBranches {\n }\n \n impl MirPass for SimplifyBranches {\n-    fn name<'a>(&'a self) -> Cow<'a, str> {\n+    fn name(&self) -> Cow<'_, str> {\n         Cow::Borrowed(&self.label)\n     }\n "}, {"sha": "59821440c6619cfb2edded3d832b1a19281201a4", "filename": "src/librustc_mir/util/def_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Futil%2Fdef_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Futil%2Fdef_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fdef_use.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -31,7 +31,7 @@ impl DefUseAnalysis {\n         self.clear();\n \n         let mut finder = DefUseFinder {\n-            info: mem::replace(&mut self.info, IndexVec::new()),\n+            info: mem::take(&mut self.info),\n         };\n         finder.visit_body(body);\n         self.info = finder.info"}, {"sha": "9d142d9b700b63498f26f180c88c03233be4258d", "filename": "src/librustc_mir/util/graphviz.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -8,8 +8,8 @@ use std::io::{self, Write};\n use super::pretty::dump_mir_def_ids;\n \n /// Write a graphviz DOT graph of a list of MIRs.\n-pub fn write_mir_graphviz<'tcx, W>(\n-    tcx: TyCtxt<'tcx>,\n+pub fn write_mir_graphviz<W>(\n+    tcx: TyCtxt<'_>,\n     single: Option<DefId>,\n     w: &mut W,\n ) -> io::Result<()>"}, {"sha": "b42eebc7ee3be28dfc0cd3d1cf544b7623535a1b", "filename": "src/librustc_mir/util/liveness.rs", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fliveness.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -56,8 +56,8 @@ pub struct LivenessResult {\n \n /// Computes which local variables are live within the given function\n /// `mir`, including drops.\n-pub fn liveness_of_locals<'tcx>(\n-    body: &Body<'tcx>,\n+pub fn liveness_of_locals(\n+    body: &Body<'_>,\n ) -> LivenessResult {\n     let num_live_vars = body.local_decls.len();\n \n@@ -75,9 +75,24 @@ pub fn liveness_of_locals<'tcx>(\n \n     let mut bits = LiveVarSet::new_empty(num_live_vars);\n \n-    // queue of things that need to be re-processed, and a set containing\n-    // the things currently in the queue\n-    let mut dirty_queue: WorkQueue<BasicBlock> = WorkQueue::with_all(body.basic_blocks().len());\n+    // The dirty queue contains the set of basic blocks whose entry sets have changed since they\n+    // were last processed. At the start of the analysis, we initialize the queue in post-order to\n+    // make it more likely that the entry set for a given basic block will have the effects of all\n+    // its successors in the CFG applied before it is processed.\n+    //\n+    // FIXME(ecstaticmorse): Reverse post-order on the reverse CFG may generate a better iteration\n+    // order when cycles are present, but the overhead of computing the reverse CFG may outweigh\n+    // any benefits. Benchmark this and find out.\n+    let mut dirty_queue: WorkQueue<BasicBlock> = WorkQueue::with_none(body.basic_blocks().len());\n+    for (bb, _) in traversal::postorder(body) {\n+        dirty_queue.insert(bb);\n+    }\n+\n+    // Add blocks which are not reachable from START_BLOCK to the work queue. These blocks will\n+    // be processed after the ones added above.\n+    for bb in body.basic_blocks().indices() {\n+        dirty_queue.insert(bb);\n+    }\n \n     let predecessors = body.predecessors();\n \n@@ -228,8 +243,8 @@ impl<'tcx> Visitor<'tcx> for DefsUsesVisitor\n     }\n }\n \n-fn block<'tcx>(\n-    b: &BasicBlockData<'tcx>,\n+fn block(\n+    b: &BasicBlockData<'_>,\n     locals: usize,\n ) -> DefsUses {\n     let mut visitor = DefsUsesVisitor {"}, {"sha": "fd2a5e452ce4b481d5ae2dc94b2170da0c96798b", "filename": "src/librustc_mir/util/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Futil%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_mir%2Futil%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fmod.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -21,7 +21,7 @@ pub use self::graphviz::{graphviz_safe_def_name, write_mir_graphviz};\n pub use self::graphviz::write_node_label as write_graphviz_node_label;\n \n /// If possible, suggest replacing `ref` with `ref mut`.\n-pub fn suggest_ref_mut<'tcx>(tcx: TyCtxt<'tcx>, binding_span: Span) -> Option<(String)> {\n+pub fn suggest_ref_mut(tcx: TyCtxt<'_>, binding_span: Span) -> Option<(String)> {\n     let hi_src = tcx.sess.source_map().span_to_snippet(binding_span).unwrap();\n     if hi_src.starts_with(\"ref\")\n         && hi_src[\"ref\".len()..].starts_with(Pattern_White_Space)"}, {"sha": "560635962995cb268263db3023691c631fa12f6b", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -837,13 +837,6 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                                  the relevant `fold_*()` method in `PlaceholderExpander`?\");\n     }\n \n-    fn visit_fn_header(&mut self, header: &'a FnHeader) {\n-        if header.asyncness.node.is_async() && self.session.rust_2015() {\n-            struct_span_err!(self.session, header.asyncness.span, E0670,\n-                             \"`async fn` is not permitted in the 2015 edition\").emit();\n-        }\n-    }\n-\n     fn visit_impl_item(&mut self, ii: &'a ImplItem) {\n         match ii.node {\n             ImplItemKind::Method(ref sig, _) => {"}, {"sha": "e7f6abc410a32f90e945347af9089453dc77ac32", "filename": "src/librustc_passes/hir_stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_passes%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_passes%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fhir_stats.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -38,7 +38,7 @@ pub fn print_hir_stats(krate: &hir::Crate) {\n     collector.print(\"HIR STATS\");\n }\n \n-pub fn print_ast_stats<'v>(krate: &'v ast::Crate, title: &str) {\n+pub fn print_ast_stats(krate: &ast::Crate, title: &str) {\n     let mut collector = StatCollector {\n         krate: None,\n         data: FxHashMap::default(),"}, {"sha": "6b1ce578240e4772646c31ef2e2ff71403d9be01", "filename": "src/librustc_passes/layout_test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_passes%2Flayout_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_passes%2Flayout_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flayout_test.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -14,7 +14,7 @@ use rustc::ty::TyCtxt;\n use syntax::ast::Attribute;\n use syntax::symbol::sym;\n \n-pub fn test_layout<'tcx>(tcx: TyCtxt<'tcx>) {\n+pub fn test_layout(tcx: TyCtxt<'_>) {\n     if tcx.features().rustc_attrs {\n         // if the `rustc_attrs` feature is not enabled, don't bother testing layout\n         tcx.hir()"}, {"sha": "616e6974110e680b5cec399a15de685b8024dcd1", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -45,7 +45,7 @@ struct CheckLoopVisitor<'a, 'hir> {\n     cx: Context,\n }\n \n-fn check_mod_loops<'tcx>(tcx: TyCtxt<'tcx>, module_def_id: DefId) {\n+fn check_mod_loops(tcx: TyCtxt<'_>, module_def_id: DefId) {\n     tcx.hir().visit_item_likes_in_module(module_def_id, &mut CheckLoopVisitor {\n         sess: &tcx.sess,\n         hir_map: &tcx.hir(),"}, {"sha": "e14fa07fbbfe4323fbcee04958b0ce7c1105e47c", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -39,7 +39,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     };\n }\n \n-fn const_is_rvalue_promotable_to_static<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> bool {\n+fn const_is_rvalue_promotable_to_static(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n     assert!(def_id.is_local());\n \n     let hir_id = tcx.hir().as_local_hir_id(def_id)\n@@ -48,7 +48,7 @@ fn const_is_rvalue_promotable_to_static<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId)\n     tcx.rvalue_promotable_map(def_id).contains(&body_id.hir_id.local_id)\n }\n \n-fn rvalue_promotable_map<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx ItemLocalSet {\n+fn rvalue_promotable_map(tcx: TyCtxt<'_>, def_id: DefId) -> &ItemLocalSet {\n     let outer_def_id = tcx.closure_base_def_id(def_id);\n     if outer_def_id != def_id {\n         return tcx.rvalue_promotable_map(outer_def_id);"}, {"sha": "816e283a104604e7c4befed74ac8a12c1b50aa84", "filename": "src/librustc_plugin/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_plugin%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_plugin%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fbuild.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -30,11 +30,11 @@ impl<'v> ItemLikeVisitor<'v> for RegistrarFinder {\n }\n \n /// Finds the function marked with `#[plugin_registrar]`, if any.\n-pub fn find_plugin_registrar<'tcx>(tcx: TyCtxt<'tcx>) -> Option<DefId> {\n+pub fn find_plugin_registrar(tcx: TyCtxt<'_>) -> Option<DefId> {\n     tcx.plugin_registrar_fn(LOCAL_CRATE)\n }\n \n-fn plugin_registrar_fn<'tcx>(tcx: TyCtxt<'tcx>, cnum: CrateNum) -> Option<DefId> {\n+fn plugin_registrar_fn(tcx: TyCtxt<'_>, cnum: CrateNum) -> Option<DefId> {\n     assert_eq!(cnum, LOCAL_CRATE);\n \n     let mut finder = RegistrarFinder { registrars: Vec::new() };"}, {"sha": "ec2855f826a46cc9a0a458f828da5e6d2c35a561", "filename": "src/librustc_plugin/registry.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_plugin%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_plugin%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fregistry.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -6,7 +6,7 @@ use rustc::util::nodemap::FxHashMap;\n \n use syntax::ext::base::{SyntaxExtension, SyntaxExtensionKind, NamedSyntaxExtension};\n use syntax::ext::base::MacroExpanderFn;\n-use syntax::symbol::{Symbol, sym};\n+use syntax::symbol::Symbol;\n use syntax::ast;\n use syntax::feature_gate::AttributeType;\n use syntax_pos::Span;\n@@ -77,17 +77,14 @@ impl<'a> Registry<'a> {\n     ///\n     /// Returns empty slice in case the plugin was loaded\n     /// with `--extra-plugins`\n-    pub fn args<'b>(&'b self) -> &'b [ast::NestedMetaItem] {\n+    pub fn args(&self) -> &[ast::NestedMetaItem] {\n         self.args_hidden.as_ref().map(|v| &v[..]).unwrap_or(&[])\n     }\n \n     /// Register a syntax extension of any kind.\n     ///\n     /// This is the most general hook into `libsyntax`'s expansion behavior.\n     pub fn register_syntax_extension(&mut self, name: ast::Name, mut extension: SyntaxExtension) {\n-        if name == sym::macro_rules {\n-            panic!(\"user-defined macros may not be named `macro_rules`\");\n-        }\n         if extension.def_info.is_none() {\n             extension.def_info = Some((ast::CRATE_NODE_ID, self.krate_span));\n         }"}, {"sha": "339021f511afdfb2c23f58b3caae13669ee2198b", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -337,7 +337,7 @@ fn item_tables<'a, 'tcx>(\n     if tcx.has_typeck_tables(def_id) { tcx.typeck_tables_of(def_id) } else { empty_tables }\n }\n \n-fn min<'tcx>(vis1: ty::Visibility, vis2: ty::Visibility, tcx: TyCtxt<'tcx>) -> ty::Visibility {\n+fn min(vis1: ty::Visibility, vis2: ty::Visibility, tcx: TyCtxt<'_>) -> ty::Visibility {\n     if vis1.is_at_least(vis2, tcx) { vis2 } else { vis1 }\n }\n \n@@ -384,14 +384,14 @@ impl<'a, 'tcx, VL: VisibilityLike> DefIdVisitor<'tcx> for FindMin<'a, 'tcx, VL>\n trait VisibilityLike: Sized {\n     const MAX: Self;\n     const SHALLOW: bool = false;\n-    fn new_min<'a, 'tcx>(find: &FindMin<'a, 'tcx, Self>, def_id: DefId) -> Self;\n+    fn new_min(find: &FindMin<'_, '_, Self>, def_id: DefId) -> Self;\n \n     // Returns an over-approximation (`skip_assoc_tys` = true) of visibility due to\n     // associated types for which we can't determine visibility precisely.\n-    fn of_impl<'a, 'tcx>(\n+    fn of_impl(\n         hir_id: hir::HirId,\n-        tcx: TyCtxt<'tcx>,\n-        access_levels: &'a AccessLevels,\n+        tcx: TyCtxt<'_>,\n+        access_levels: &AccessLevels,\n     ) -> Self {\n         let mut find = FindMin { tcx, access_levels, min: Self::MAX };\n         let def_id = tcx.hir().local_def_id_from_hir_id(hir_id);\n@@ -404,7 +404,7 @@ trait VisibilityLike: Sized {\n }\n impl VisibilityLike for ty::Visibility {\n     const MAX: Self = ty::Visibility::Public;\n-    fn new_min<'a, 'tcx>(find: &FindMin<'a, 'tcx, Self>, def_id: DefId) -> Self {\n+    fn new_min(find: &FindMin<'_, '_, Self>, def_id: DefId) -> Self {\n         min(def_id_visibility(find.tcx, def_id).0, find.min, find.tcx)\n     }\n }\n@@ -420,7 +420,7 @@ impl VisibilityLike for Option<AccessLevel> {\n     // both \"shallow\" version of its self type and \"shallow\" version of its trait if it exists\n     // (which require reaching the `DefId`s in them).\n     const SHALLOW: bool = true;\n-    fn new_min<'a, 'tcx>(find: &FindMin<'a, 'tcx, Self>, def_id: DefId) -> Self {\n+    fn new_min(find: &FindMin<'_, '_, Self>, def_id: DefId) -> Self {\n         cmp::min(if let Some(hir_id) = find.tcx.hir().as_local_hir_id(def_id) {\n             find.access_levels.map.get(&hir_id).cloned()\n         } else {\n@@ -1828,7 +1828,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     };\n }\n \n-fn check_mod_privacy<'tcx>(tcx: TyCtxt<'tcx>, module_def_id: DefId) {\n+fn check_mod_privacy(tcx: TyCtxt<'_>, module_def_id: DefId) {\n     let empty_tables = ty::TypeckTables::empty(None);\n \n     // Check privacy of names not checked in previous compilation stages.\n@@ -1855,7 +1855,7 @@ fn check_mod_privacy<'tcx>(tcx: TyCtxt<'tcx>, module_def_id: DefId) {\n     intravisit::walk_mod(&mut visitor, module, hir_id);\n }\n \n-fn privacy_access_levels<'tcx>(tcx: TyCtxt<'tcx>, krate: CrateNum) -> &'tcx AccessLevels {\n+fn privacy_access_levels(tcx: TyCtxt<'_>, krate: CrateNum) -> &AccessLevels {\n     assert_eq!(krate, LOCAL_CRATE);\n \n     // Build up a set of all exported items in the AST. This is a set of all\n@@ -1879,7 +1879,7 @@ fn privacy_access_levels<'tcx>(tcx: TyCtxt<'tcx>, krate: CrateNum) -> &'tcx Acce\n     tcx.arena.alloc(visitor.access_levels)\n }\n \n-fn check_private_in_public<'tcx>(tcx: TyCtxt<'tcx>, krate: CrateNum) {\n+fn check_private_in_public(tcx: TyCtxt<'_>, krate: CrateNum) {\n     assert_eq!(krate, LOCAL_CRATE);\n \n     let access_levels = tcx.privacy_access_levels(LOCAL_CRATE);"}, {"sha": "05247600a4ded357993b0ee6d130917e7a927890", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -4,9 +4,10 @@\n \n #![feature(crate_visibility_modifier)]\n #![feature(label_break_value)]\n+#![feature(mem_take)]\n #![feature(nll)]\n #![feature(rustc_diagnostic_macros)]\n-#![feature(type_alias_enum_variants)]\n+#![cfg_attr(bootstrap, feature(type_alias_enum_variants))]\n \n #![recursion_limit=\"256\"]\n \n@@ -198,9 +199,9 @@ enum ResolutionError<'a> {\n ///\n /// This takes the error provided, combines it with the span and any additional spans inside the\n /// error and emits it.\n-fn resolve_error<'sess, 'a>(resolver: &'sess Resolver<'_>,\n-                            span: Span,\n-                            resolution_error: ResolutionError<'a>) {\n+fn resolve_error(resolver: &Resolver<'_>,\n+                 span: Span,\n+                 resolution_error: ResolutionError<'_>) {\n     resolve_struct_error(resolver, span, resolution_error).emit();\n }\n "}, {"sha": "d8d08107b826a7c649888bf8c8dde7faab76fad0", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -946,7 +946,7 @@ impl<'a> Resolver<'a> {\n         };\n \n         let macro_resolutions =\n-            mem::replace(&mut *module.multi_segment_macro_resolutions.borrow_mut(), Vec::new());\n+            mem::take(&mut *module.multi_segment_macro_resolutions.borrow_mut());\n         for (mut path, path_span, kind, parent_scope, initial_res) in macro_resolutions {\n             // FIXME: Path resolution will ICE if segment IDs present.\n             for seg in &mut path { seg.id = None; }\n@@ -973,7 +973,7 @@ impl<'a> Resolver<'a> {\n         }\n \n         let macro_resolutions =\n-            mem::replace(&mut *module.single_segment_macro_resolutions.borrow_mut(), Vec::new());\n+            mem::take(&mut *module.single_segment_macro_resolutions.borrow_mut());\n         for (ident, kind, parent_scope, initial_binding) in macro_resolutions {\n             match self.early_resolve_ident_in_lexical_scope(ident, ScopeSet::Macro(kind),\n                                                             &parent_scope, true, true, ident.span) {\n@@ -998,7 +998,7 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        let builtin_attrs = mem::replace(&mut *module.builtin_attrs.borrow_mut(), Vec::new());\n+        let builtin_attrs = mem::take(&mut *module.builtin_attrs.borrow_mut());\n         for (ident, parent_scope) in builtin_attrs {\n             let _ = self.early_resolve_ident_in_lexical_scope(\n                 ident, ScopeSet::Macro(MacroKind::Attr), &parent_scope, true, true, ident.span\n@@ -1109,9 +1109,6 @@ impl<'a> Resolver<'a> {\n                         current_legacy_scope: &mut LegacyScope<'a>) {\n         self.local_macro_def_scopes.insert(item.id, self.current_module);\n         let ident = item.ident;\n-        if ident.name == sym::macro_rules {\n-            self.session.span_err(item.span, \"user-defined macros may not be named `macro_rules`\");\n-        }\n \n         let def_id = self.definitions.local_def_id(item.id);\n         let ext = Lrc::new(macro_rules::compile(&self.session.parse_sess,"}, {"sha": "404d728d8808ce5cd54fe8e448a3ee86ea8924b2", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -682,7 +682,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         let mut prev_num_indeterminates = self.indeterminate_imports.len() + 1;\n         while self.indeterminate_imports.len() < prev_num_indeterminates {\n             prev_num_indeterminates = self.indeterminate_imports.len();\n-            for import in mem::replace(&mut self.indeterminate_imports, Vec::new()) {\n+            for import in mem::take(&mut self.indeterminate_imports) {\n                 match self.resolve_import(&import) {\n                     true => self.determined_imports.push(import),\n                     false => self.indeterminate_imports.push(import),"}, {"sha": "b139083e99fc1e9d57d5413b18b5c83fff7352e8", "filename": "src/librustc_target/spec/windows_msvc_base.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_target%2Fspec%2Fwindows_msvc_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_target%2Fspec%2Fwindows_msvc_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fwindows_msvc_base.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -19,6 +19,10 @@ pub fn opts() -> TargetOptions {\n         target_family: Some(\"windows\".to_string()),\n         is_like_windows: true,\n         is_like_msvc: true,\n+        // set VSLANG to 1033 can prevent link.exe from using\n+        // language packs, and avoid generating Non-UTF-8 error\n+        // messages if a link error occurred.\n+        link_env: vec![(\"VSLANG\".to_string(), \"1033\".to_string())],\n         pre_link_args: args,\n         crt_static_allows_dylibs: true,\n         crt_static_respected: true,"}, {"sha": "5c23ad4a4edfbd361fb8d1259402834e7cc88b72", "filename": "src/librustc_traits/chalk_context/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -17,6 +17,7 @@ use rustc::infer::canonical::{\n     CanonicalVarValues,\n     OriginalQueryValues,\n     QueryResponse,\n+    QueryRegionConstraints,\n     Certainty,\n };\n use rustc::traits::{\n@@ -151,14 +152,14 @@ impl context::AggregateOps<ChalkArenas<'tcx>> for ChalkContext<'tcx> {\n         let solution = constrained_subst.unchecked_map(|cs| match ambiguous {\n             true => QueryResponse {\n                 var_values: cs.subst.make_identity(self.tcx),\n-                region_constraints: Vec::new(),\n+                region_constraints: QueryRegionConstraints::default(),\n                 certainty: Certainty::Ambiguous,\n                 value: (),\n             },\n \n             false => QueryResponse {\n                 var_values: cs.subst,\n-                region_constraints: Vec::new(),\n+                region_constraints: QueryRegionConstraints::default(),\n \n                 // FIXME: restore this later once we get better at handling regions\n                 // region_constraints: cs.constraints"}, {"sha": "6e8eed0f907255072a714081506e4a7aeaddecb6", "filename": "src/librustc_traits/chalk_context/program_clauses/primitive.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fprimitive.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -15,7 +15,7 @@ use crate::lowering::Lower;\n use crate::generic_types;\n use std::iter;\n \n-crate fn wf_clause_for_raw_ptr<'tcx>(tcx: TyCtxt<'tcx>, mutbl: hir::Mutability) -> Clauses<'tcx> {\n+crate fn wf_clause_for_raw_ptr(tcx: TyCtxt<'_>, mutbl: hir::Mutability) -> Clauses<'_> {\n     let ptr_ty = generic_types::raw_ptr(tcx, mutbl);\n \n     let wf_clause = ProgramClause {\n@@ -29,13 +29,13 @@ crate fn wf_clause_for_raw_ptr<'tcx>(tcx: TyCtxt<'tcx>, mutbl: hir::Mutability)\n     tcx.mk_clauses(iter::once(wf_clause))\n }\n \n-crate fn wf_clause_for_fn_ptr<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+crate fn wf_clause_for_fn_ptr(\n+    tcx: TyCtxt<'_>,\n     arity_and_output: usize,\n     variadic: bool,\n     unsafety: hir::Unsafety,\n     abi: abi::Abi,\n-) -> Clauses<'tcx> {\n+) -> Clauses<'_> {\n     let fn_ptr = generic_types::fn_ptr(tcx, arity_and_output, variadic, unsafety, abi);\n \n     let wf_clause = ProgramClause {\n@@ -50,7 +50,7 @@ crate fn wf_clause_for_fn_ptr<'tcx>(\n     tcx.mk_clauses(iter::once(wf_clause))\n }\n \n-crate fn wf_clause_for_slice<'tcx>(tcx: TyCtxt<'tcx>) -> Clauses<'tcx> {\n+crate fn wf_clause_for_slice(tcx: TyCtxt<'_>) -> Clauses<'_> {\n     let ty = generic_types::bound(tcx, 0);\n     let slice_ty = tcx.mk_slice(ty);\n \n@@ -111,7 +111,7 @@ crate fn wf_clause_for_array<'tcx>(\n     tcx.mk_clauses(iter::once(wf_clause))\n }\n \n-crate fn wf_clause_for_tuple<'tcx>(tcx: TyCtxt<'tcx>, arity: usize) -> Clauses<'tcx> {\n+crate fn wf_clause_for_tuple(tcx: TyCtxt<'_>, arity: usize) -> Clauses<'_> {\n     let type_list = generic_types::type_list(tcx, arity);\n     let tuple_ty = tcx.mk_ty(ty::Tuple(type_list));\n \n@@ -152,7 +152,7 @@ crate fn wf_clause_for_tuple<'tcx>(tcx: TyCtxt<'tcx>, arity: usize) -> Clauses<'\n     tcx.mk_clauses(iter::once(wf_clause))\n }\n \n-crate fn wf_clause_for_ref<'tcx>(tcx: TyCtxt<'tcx>, mutbl: hir::Mutability) -> Clauses<'tcx> {\n+crate fn wf_clause_for_ref(tcx: TyCtxt<'_>, mutbl: hir::Mutability) -> Clauses<'_> {\n     let region = tcx.mk_region(\n         ty::ReLateBound(ty::INNERMOST, ty::BoundRegion::BrAnon(0))\n     );\n@@ -176,7 +176,7 @@ crate fn wf_clause_for_ref<'tcx>(tcx: TyCtxt<'tcx>, mutbl: hir::Mutability) -> C\n     tcx.mk_clauses(iter::once(wf_clause))\n }\n \n-crate fn wf_clause_for_fn_def<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Clauses<'tcx> {\n+crate fn wf_clause_for_fn_def(tcx: TyCtxt<'_>, def_id: DefId) -> Clauses<'_> {\n     let fn_def = generic_types::fn_def(tcx, def_id);\n \n     let wf_clause = ProgramClause {"}, {"sha": "ecd888b606981d10422cea7acad21d1092fce5d9", "filename": "src/librustc_traits/dropck_outlives.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_traits%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_traits%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fdropck_outlives.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -279,10 +279,10 @@ fn dtorck_constraint_for_ty<'tcx>(\n }\n \n /// Calculates the dtorck constraint for a type.\n-crate fn adt_dtorck_constraint<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+crate fn adt_dtorck_constraint(\n+    tcx: TyCtxt<'_>,\n     def_id: DefId,\n-) -> Result<DtorckConstraint<'tcx>, NoSolution> {\n+) -> Result<DtorckConstraint<'_>, NoSolution> {\n     let def = tcx.adt_def(def_id);\n     let span = tcx.def_span(def_id);\n     debug!(\"dtorck_constraint: {:?}\", def);\n@@ -313,7 +313,7 @@ crate fn adt_dtorck_constraint<'tcx>(\n     Ok(result)\n }\n \n-fn dedup_dtorck_constraint<'tcx>(c: &mut DtorckConstraint<'tcx>) {\n+fn dedup_dtorck_constraint(c: &mut DtorckConstraint<'_>) {\n     let mut outlives = FxHashSet::default();\n     let mut dtorck_types = FxHashSet::default();\n "}, {"sha": "9ff685bb4ee8a8976c12cbe83666aea044edf0d0", "filename": "src/librustc_traits/lowering/environment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -160,7 +160,7 @@ crate fn program_clauses_for_env<'tcx>(\n     );\n }\n \n-crate fn environment<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Environment<'tcx> {\n+crate fn environment(tcx: TyCtxt<'_>, def_id: DefId) -> Environment<'_> {\n     use super::{Lower, IntoFromEnvGoal};\n     use rustc::hir::{Node, TraitItemKind, ImplItemKind, ItemKind, ForeignItemKind};\n "}, {"sha": "b0d9134c834d60dde61a541049fc048b85b736b6", "filename": "src/librustc_traits/lowering/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_traits%2Flowering%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_traits%2Flowering%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering%2Fmod.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -155,7 +155,7 @@ impl<'tcx> IntoWellFormedGoal for DomainGoal<'tcx> {\n     }\n }\n \n-crate fn program_clauses_for<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Clauses<'tcx> {\n+crate fn program_clauses_for(tcx: TyCtxt<'_>, def_id: DefId) -> Clauses<'_> {\n     // FIXME(eddyb) this should only be using `def_kind`.\n     match tcx.def_key(def_id).disambiguated_data.data {\n         DefPathData::TypeNs(..) => match tcx.def_kind(def_id) {\n@@ -181,7 +181,7 @@ crate fn program_clauses_for<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Clauses<\n     }\n }\n \n-fn program_clauses_for_trait<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Clauses<'tcx> {\n+fn program_clauses_for_trait(tcx: TyCtxt<'_>, def_id: DefId) -> Clauses<'_> {\n     // `trait Trait<P1..Pn> where WC { .. } // P0 == Self`\n \n     // Rule Implemented-From-Env (see rustc guide)\n@@ -337,7 +337,7 @@ fn program_clauses_for_impl(tcx: TyCtxt<'tcx>, def_id: DefId) -> Clauses<'tcx> {\n     tcx.mk_clauses(iter::once(Clause::ForAll(ty::Binder::bind(clause))))\n }\n \n-pub fn program_clauses_for_type_def<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Clauses<'tcx> {\n+pub fn program_clauses_for_type_def(tcx: TyCtxt<'_>, def_id: DefId) -> Clauses<'_> {\n     // Rule WellFormed-Type\n     //\n     // `struct Ty<P1..Pn> where WC1, ..., WCm`\n@@ -411,10 +411,10 @@ pub fn program_clauses_for_type_def<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> C\n     tcx.mk_clauses(iter::once(well_formed_clause).chain(from_env_clauses))\n }\n \n-pub fn program_clauses_for_associated_type_def<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+pub fn program_clauses_for_associated_type_def(\n+    tcx: TyCtxt<'_>,\n     item_id: DefId,\n-) -> Clauses<'tcx> {\n+) -> Clauses<'_> {\n     // Rule ProjectionEq-Placeholder\n     //\n     // ```\n@@ -549,10 +549,10 @@ pub fn program_clauses_for_associated_type_def<'tcx>(\n     tcx.mk_clauses(clauses)\n }\n \n-pub fn program_clauses_for_associated_type_value<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+pub fn program_clauses_for_associated_type_value(\n+    tcx: TyCtxt<'_>,\n     item_id: DefId,\n-) -> Clauses<'tcx> {\n+) -> Clauses<'_> {\n     // Rule Normalize-From-Impl (see rustc guide)\n     //\n     // ```\n@@ -611,7 +611,7 @@ pub fn program_clauses_for_associated_type_value<'tcx>(\n     tcx.mk_clauses(iter::once(normalize_clause))\n }\n \n-pub fn dump_program_clauses<'tcx>(tcx: TyCtxt<'tcx>) {\n+pub fn dump_program_clauses(tcx: TyCtxt<'_>) {\n     if !tcx.features().rustc_attrs {\n         return;\n     }"}, {"sha": "1792716d1fb35e6859aa5d8b792ba423e1f6fce2", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -7,6 +7,7 @@ use crate::hir::{self, GenericArg, GenericArgs, ExprKind};\n use crate::hir::def::{CtorOf, Res, DefKind};\n use crate::hir::def_id::DefId;\n use crate::hir::HirVec;\n+use crate::hir::ptr::P;\n use crate::lint;\n use crate::middle::lang_items::SizedTraitLangItem;\n use crate::middle::resolve_lifetime as rl;\n@@ -23,7 +24,6 @@ use crate::require_c_abi_if_c_variadic;\n use smallvec::SmallVec;\n use syntax::ast;\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n-use syntax::ptr::P;\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax::symbol::sym;\n use syntax_pos::{DUMMY_SP, Span, MultiSpan};\n@@ -34,7 +34,6 @@ use std::collections::BTreeSet;\n use std::iter;\n use std::slice;\n \n-use super::{check_type_alias_enum_variants_enabled};\n use rustc_data_structures::fx::FxHashSet;\n \n #[derive(Debug)]\n@@ -1595,7 +1594,6 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 });\n                 if let Some(variant_def) = variant_def {\n                     if permit_variants {\n-                        check_type_alias_enum_variants_enabled(tcx, span);\n                         tcx.check_stability(variant_def.def_id, Some(hir_ref_id), span);\n                         return Ok((qself_ty, DefKind::Variant, variant_def.def_id));\n                     } else {"}, {"sha": "eeed5be867807bc670fe1fae482a9f8987518e18", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -5,14 +5,14 @@ use errors::{Applicability, DiagnosticBuilder};\n use rustc::hir::{self, PatKind, Pat, ExprKind};\n use rustc::hir::def::{Res, DefKind, CtorKind};\n use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n+use rustc::hir::ptr::P;\n use rustc::infer;\n use rustc::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc::traits::{ObligationCause, ObligationCauseCode};\n use rustc::ty::{self, Ty, TypeFoldable};\n use rustc::ty::subst::Kind;\n use syntax::ast;\n use syntax::source_map::Spanned;\n-use syntax::ptr::P;\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax_pos::Span;\n use syntax_pos::hygiene::CompilerDesugaringKind;\n@@ -458,7 +458,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 match ty.sty {\n                                     ty::Array(..) | ty::Slice(..) => {\n                                         err.help(\"the semantics of slice patterns changed \\\n-                                                  recently; see issue #23121\");\n+                                                  recently; see issue #62254\");\n                                     }\n                                     _ => {}\n                                 }"}, {"sha": "94c76deade279c0b248e30d882088b8f3392b740", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -54,6 +54,7 @@ use crate::check::{FnCtxt, Needs};\n use errors::DiagnosticBuilder;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n+use rustc::hir::ptr::P;\n use rustc::infer::{Coercion, InferResult, InferOk};\n use rustc::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc::traits::{self, ObligationCause, ObligationCauseCode};\n@@ -67,7 +68,6 @@ use rustc::ty::relate::RelateResult;\n use smallvec::{smallvec, SmallVec};\n use std::ops::Deref;\n use syntax::feature_gate;\n-use syntax::ptr::P;\n use syntax::symbol::sym;\n use syntax_pos;\n "}, {"sha": "c4c4e10a14cc0ad1838b45c4e87534abcdcf7174", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -29,7 +29,7 @@ use syntax_pos::Span;\n ///    struct/enum definition for the nominal type itself (i.e.\n ///    cannot do `struct S<T>; impl<T:Clone> Drop for S<T> { ... }`).\n ///\n-pub fn check_drop_impl<'tcx>(tcx: TyCtxt<'tcx>, drop_impl_did: DefId) -> Result<(), ErrorReported> {\n+pub fn check_drop_impl(tcx: TyCtxt<'_>, drop_impl_did: DefId) -> Result<(), ErrorReported> {\n     let dtor_self_type = tcx.type_of(drop_impl_did);\n     let dtor_predicates = tcx.predicates_of(drop_impl_did);\n     match dtor_self_type.sty {"}, {"sha": "ccc20bd9585c9095dfcba4c9c942ddb585741b5b", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -20,13 +20,13 @@ use crate::astconv::AstConv as _;\n \n use errors::{Applicability, DiagnosticBuilder};\n use syntax::ast;\n-use syntax::ptr::P;\n use syntax::symbol::{Symbol, LocalInternedString, kw, sym};\n use syntax::source_map::Span;\n use syntax::util::lev_distance::find_best_match_for_name;\n use rustc::hir;\n use rustc::hir::{ExprKind, QPath};\n use rustc::hir::def::{CtorKind, Res, DefKind};\n+use rustc::hir::ptr::P;\n use rustc::infer;\n use rustc::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc::mir::interpret::GlobalId;"}, {"sha": "9b1a8913822092a002b957a7a97e509500c06a01", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -79,7 +79,7 @@ pub fn intrisic_operation_unsafety(intrinsic: &str) -> hir::Unsafety {\n \n /// Remember to add all intrinsics here, in librustc_codegen_llvm/intrinsic.rs,\n /// and in libcore/intrinsics.rs\n-pub fn check_intrinsic_type<'tcx>(tcx: TyCtxt<'tcx>, it: &hir::ForeignItem) {\n+pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem) {\n     let param = |n| tcx.mk_ty_param(n, InternedString::intern(&format!(\"P{}\", n)));\n     let name = it.ident.as_str();\n \n@@ -385,7 +385,7 @@ pub fn check_intrinsic_type<'tcx>(tcx: TyCtxt<'tcx>, it: &hir::ForeignItem) {\n }\n \n /// Type-check `extern \"platform-intrinsic\" { ... }` functions.\n-pub fn check_platform_intrinsic_type<'tcx>(tcx: TyCtxt<'tcx>, it: &hir::ForeignItem) {\n+pub fn check_platform_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem) {\n     let param = |n| {\n         let name = InternedString::intern(&format!(\"P{}\", n));\n         tcx.mk_ty_param(n, name)"}, {"sha": "b8b65279fe7670c58e3d84a5c55687e41840737d", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -26,7 +26,6 @@ use rustc::infer::{self, InferOk};\n use syntax::ast;\n use syntax_pos::Span;\n \n-use crate::{check_type_alias_enum_variants_enabled};\n use self::probe::{IsSuggestion, ProbeScope};\n \n pub fn provide(providers: &mut ty::query::Providers<'_>) {\n@@ -417,8 +416,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     tcx.hygienic_eq(method_name, vd.ident, adt_def.did)\n                 });\n                 if let Some(variant_def) = variant_def {\n-                    check_type_alias_enum_variants_enabled(tcx, span);\n-\n                     // Braced variants generate unusable names in value namespace (reserved for\n                     // possible future use), so variants resolved as associated items may refer to\n                     // them as well. It's ok to use the variant's id as a ctor id since an"}, {"sha": "bd4cf9d208684de104e9da519c6a97502a7eb58b", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -970,9 +970,9 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n \n         debug!(\"pick: actual search failed, assemble diagnotics\");\n \n-        let static_candidates = mem::replace(&mut self.static_candidates, vec![]);\n+        let static_candidates = mem::take(&mut self.static_candidates);\n         let private_candidate = self.private_candidate.take();\n-        let unsatisfied_predicates = mem::replace(&mut self.unsatisfied_predicates, vec![]);\n+        let unsatisfied_predicates = mem::take(&mut self.unsatisfied_predicates);\n \n         // things failed, so lets look at all traits, for diagnostic purposes now:\n         self.reset();"}, {"sha": "be00a6efe55edeeacde981b6bf26891b1897c0ff", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -775,12 +775,12 @@ impl Ord for TraitInfo {\n }\n \n /// Retrieves all traits in this crate and any dependent crates.\n-pub fn all_traits<'tcx>(tcx: TyCtxt<'tcx>) -> Vec<TraitInfo> {\n+pub fn all_traits(tcx: TyCtxt<'_>) -> Vec<TraitInfo> {\n     tcx.all_traits(LOCAL_CRATE).iter().map(|&def_id| TraitInfo { def_id }).collect()\n }\n \n /// Computes all traits in this crate and any dependent crates.\n-fn compute_all_traits<'tcx>(tcx: TyCtxt<'tcx>) -> Vec<DefId> {\n+fn compute_all_traits(tcx: TyCtxt<'_>) -> Vec<DefId> {\n     use hir::itemlikevisit;\n \n     let mut traits = vec![];"}, {"sha": "fb7d681a72da7cf286e7f2c82f642a1ec1d6d103", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 37, "deletions": 29, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -93,6 +93,7 @@ use rustc::hir::def::{CtorOf, Res, DefKind};\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n+use rustc::hir::ptr::P;\n use crate::middle::lang_items;\n use crate::namespace::Namespace;\n use rustc::infer::{self, InferCtxt, InferOk, InferResult};\n@@ -122,7 +123,6 @@ use syntax_pos::hygiene::CompilerDesugaringKind;\n use syntax::ast;\n use syntax::attr;\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n-use syntax::ptr::P;\n use syntax::source_map::{DUMMY_SP, original_sp};\n use syntax::symbol::{kw, sym};\n \n@@ -698,31 +698,31 @@ impl ItemLikeVisitor<'tcx> for CheckItemTypesVisitor<'tcx> {\n     fn visit_impl_item(&mut self, _: &'tcx hir::ImplItem) { }\n }\n \n-pub fn check_wf_new<'tcx>(tcx: TyCtxt<'tcx>) {\n+pub fn check_wf_new(tcx: TyCtxt<'_>) {\n     let mut visit = wfcheck::CheckTypeWellFormedVisitor::new(tcx);\n     tcx.hir().krate().par_visit_all_item_likes(&mut visit);\n }\n \n-fn check_mod_item_types<'tcx>(tcx: TyCtxt<'tcx>, module_def_id: DefId) {\n+fn check_mod_item_types(tcx: TyCtxt<'_>, module_def_id: DefId) {\n     tcx.hir().visit_item_likes_in_module(module_def_id, &mut CheckItemTypesVisitor { tcx });\n }\n \n-fn typeck_item_bodies<'tcx>(tcx: TyCtxt<'tcx>, crate_num: CrateNum) {\n+fn typeck_item_bodies(tcx: TyCtxt<'_>, crate_num: CrateNum) {\n     debug_assert!(crate_num == LOCAL_CRATE);\n     tcx.par_body_owners(|body_owner_def_id| {\n         tcx.ensure().typeck_tables_of(body_owner_def_id);\n     });\n }\n \n-fn check_item_well_formed<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) {\n+fn check_item_well_formed(tcx: TyCtxt<'_>, def_id: DefId) {\n     wfcheck::check_item_well_formed(tcx, def_id);\n }\n \n-fn check_trait_item_well_formed<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) {\n+fn check_trait_item_well_formed(tcx: TyCtxt<'_>, def_id: DefId) {\n     wfcheck::check_trait_item(tcx, def_id);\n }\n \n-fn check_impl_item_well_formed<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) {\n+fn check_impl_item_well_formed(tcx: TyCtxt<'_>, def_id: DefId) {\n     wfcheck::check_impl_item(tcx, def_id);\n }\n \n@@ -742,7 +742,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     };\n }\n \n-fn adt_destructor<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Option<ty::Destructor> {\n+fn adt_destructor(tcx: TyCtxt<'_>, def_id: DefId) -> Option<ty::Destructor> {\n     tcx.calculate_dtor(def_id, &mut dropck::check_drop_impl)\n }\n \n@@ -755,10 +755,10 @@ fn adt_destructor<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Option<ty::Destruct\n /// may not succeed. In some cases where this function returns `None`\n /// (notably closures), `typeck_tables(def_id)` would wind up\n /// redirecting to the owning function.\n-fn primary_body_of<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+fn primary_body_of(\n+    tcx: TyCtxt<'_>,\n     id: hir::HirId,\n-) -> Option<(hir::BodyId, Option<&'tcx hir::FnDecl>)> {\n+) -> Option<(hir::BodyId, Option<&hir::FnDecl>)> {\n     match tcx.hir().get(id) {\n         Node::Item(item) => {\n             match item.node {\n@@ -796,7 +796,7 @@ fn primary_body_of<'tcx>(\n     }\n }\n \n-fn has_typeck_tables<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> bool {\n+fn has_typeck_tables(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n     // Closures' tables come from their outermost function,\n     // as they are part of the same \"inference environment\".\n     let outer_def_id = tcx.closure_base_def_id(def_id);\n@@ -808,11 +808,11 @@ fn has_typeck_tables<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> bool {\n     primary_body_of(tcx, id).is_some()\n }\n \n-fn used_trait_imports<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx DefIdSet {\n+fn used_trait_imports(tcx: TyCtxt<'_>, def_id: DefId) -> &DefIdSet {\n     &*tcx.typeck_tables_of(def_id).used_trait_imports\n }\n \n-fn typeck_tables_of<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx ty::TypeckTables<'tcx> {\n+fn typeck_tables_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::TypeckTables<'_> {\n     // Closures' tables come from their outermost function,\n     // as they are part of the same \"inference environment\".\n     let outer_def_id = tcx.closure_base_def_id(def_id);\n@@ -856,7 +856,8 @@ fn typeck_tables_of<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx ty::TypeckT\n             let revealed_ty = if tcx.features().impl_trait_in_bindings {\n                 fcx.instantiate_opaque_types_from_value(\n                     id,\n-                    &expected_type\n+                    &expected_type,\n+                    body.value.span,\n                 )\n             } else {\n                 expected_type\n@@ -912,7 +913,7 @@ fn typeck_tables_of<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx ty::TypeckT\n     tables\n }\n \n-fn check_abi<'tcx>(tcx: TyCtxt<'tcx>, span: Span, abi: Abi) {\n+fn check_abi(tcx: TyCtxt<'_>, span: Span, abi: Abi) {\n     if !tcx.sess.target.target.is_abi_supported(abi) {\n         struct_span_err!(tcx.sess, span, E0570,\n             \"The ABI `{}` is not supported for the current target\", abi).emit()\n@@ -962,7 +963,8 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx> {\n                 let revealed_ty = if self.fcx.tcx.features().impl_trait_in_bindings {\n                     self.fcx.instantiate_opaque_types_from_value(\n                         self.parent_id,\n-                        &o_ty\n+                        &o_ty,\n+                        ty.span,\n                     )\n                 } else {\n                     o_ty\n@@ -1058,7 +1060,11 @@ fn check_fn<'a, 'tcx>(\n \n     let declared_ret_ty = fn_sig.output();\n     fcx.require_type_is_sized(declared_ret_ty, decl.output.span(), traits::SizedReturnType);\n-    let revealed_ret_ty = fcx.instantiate_opaque_types_from_value(fn_id, &declared_ret_ty);\n+    let revealed_ret_ty = fcx.instantiate_opaque_types_from_value(\n+        fn_id,\n+        &declared_ret_ty,\n+        decl.output.span(),\n+    );\n     fcx.ret_coercion = Some(RefCell::new(CoerceMany::new(revealed_ret_ty)));\n     fn_sig = fcx.tcx.mk_fn_sig(\n         fn_sig.inputs().iter().cloned(),\n@@ -1285,7 +1291,7 @@ fn check_fn<'a, 'tcx>(\n     (fcx, gen_ty)\n }\n \n-fn check_struct<'tcx>(tcx: TyCtxt<'tcx>, id: hir::HirId, span: Span) {\n+fn check_struct(tcx: TyCtxt<'_>, id: hir::HirId, span: Span) {\n     let def_id = tcx.hir().local_def_id_from_hir_id(id);\n     let def = tcx.adt_def(def_id);\n     def.destructor(tcx); // force the destructor to be evaluated\n@@ -1299,7 +1305,7 @@ fn check_struct<'tcx>(tcx: TyCtxt<'tcx>, id: hir::HirId, span: Span) {\n     check_packed(tcx, span, def_id);\n }\n \n-fn check_union<'tcx>(tcx: TyCtxt<'tcx>, id: hir::HirId, span: Span) {\n+fn check_union(tcx: TyCtxt<'_>, id: hir::HirId, span: Span) {\n     let def_id = tcx.hir().local_def_id_from_hir_id(id);\n     let def = tcx.adt_def(def_id);\n     def.destructor(tcx); // force the destructor to be evaluated\n@@ -1461,14 +1467,14 @@ fn maybe_check_static_with_link_section(tcx: TyCtxt<'_>, id: DefId, span: Span)\n     }\n }\n \n-fn check_on_unimplemented<'tcx>(tcx: TyCtxt<'tcx>, trait_def_id: DefId, item: &hir::Item) {\n+fn check_on_unimplemented(tcx: TyCtxt<'_>, trait_def_id: DefId, item: &hir::Item) {\n     let item_def_id = tcx.hir().local_def_id_from_hir_id(item.hir_id);\n     // an error would be reported if this fails.\n     let _ = traits::OnUnimplementedDirective::of_item(tcx, trait_def_id, item_def_id);\n }\n \n-fn report_forbidden_specialization<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+fn report_forbidden_specialization(\n+    tcx: TyCtxt<'_>,\n     impl_item: &hir::ImplItem,\n     parent_impl: DefId,\n ) {\n@@ -1684,7 +1690,7 @@ fn check_impl_items_against_trait<'tcx>(\n /// Checks whether a type can be represented in memory. In particular, it\n /// identifies types that contain themselves without indirection through a\n /// pointer, which would mean their size is unbounded.\n-fn check_representable<'tcx>(tcx: TyCtxt<'tcx>, sp: Span, item_def_id: DefId) -> bool {\n+fn check_representable(tcx: TyCtxt<'_>, sp: Span, item_def_id: DefId) -> bool {\n     let rty = tcx.type_of(item_def_id);\n \n     // Check that it is possible to represent this type. This call identifies\n@@ -1706,7 +1712,7 @@ fn check_representable<'tcx>(tcx: TyCtxt<'tcx>, sp: Span, item_def_id: DefId) ->\n     return true;\n }\n \n-pub fn check_simd<'tcx>(tcx: TyCtxt<'tcx>, sp: Span, def_id: DefId) {\n+pub fn check_simd(tcx: TyCtxt<'_>, sp: Span, def_id: DefId) {\n     let t = tcx.type_of(def_id);\n     if let ty::Adt(def, substs) = t.sty {\n         if def.is_struct() {\n@@ -1735,7 +1741,7 @@ pub fn check_simd<'tcx>(tcx: TyCtxt<'tcx>, sp: Span, def_id: DefId) {\n     }\n }\n \n-fn check_packed<'tcx>(tcx: TyCtxt<'tcx>, sp: Span, def_id: DefId) {\n+fn check_packed(tcx: TyCtxt<'_>, sp: Span, def_id: DefId) {\n     let repr = tcx.adt_def(def_id).repr;\n     if repr.packed() {\n         for attr in tcx.get_attrs(def_id).iter() {\n@@ -1759,7 +1765,7 @@ fn check_packed<'tcx>(tcx: TyCtxt<'tcx>, sp: Span, def_id: DefId) {\n     }\n }\n \n-fn check_packed_inner<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, stack: &mut Vec<DefId>) -> bool {\n+fn check_packed_inner(tcx: TyCtxt<'_>, def_id: DefId, stack: &mut Vec<DefId>) -> bool {\n     let t = tcx.type_of(def_id);\n     if stack.contains(&def_id) {\n         debug!(\"check_packed_inner: {:?} is recursive\", t);\n@@ -1833,7 +1839,7 @@ fn bad_non_zero_sized_fields<'tcx>(\n     err.emit();\n }\n \n-fn check_transparent<'tcx>(tcx: TyCtxt<'tcx>, sp: Span, def_id: DefId) {\n+fn check_transparent(tcx: TyCtxt<'_>, sp: Span, def_id: DefId) {\n     let adt = tcx.adt_def(def_id);\n     if !adt.repr.transparent() {\n         return;\n@@ -1982,7 +1988,7 @@ pub fn check_enum<'tcx>(tcx: TyCtxt<'tcx>, sp: Span, vs: &'tcx [hir::Variant], i\n     check_transparent(tcx, sp, def_id);\n }\n \n-fn report_unexpected_variant_res<'tcx>(tcx: TyCtxt<'tcx>, res: Res, span: Span, qpath: &QPath) {\n+fn report_unexpected_variant_res(tcx: TyCtxt<'_>, res: Res, span: Span, qpath: &QPath) {\n     span_err!(tcx.sess, span, E0533,\n               \"expected unit struct/variant or constant, found {} `{}`\",\n               res.descr(),\n@@ -2445,6 +2451,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         parent_id: hir::HirId,\n         value: &T,\n+        value_span: Span,\n     ) -> T {\n         let parent_def_id = self.tcx.hir().local_def_id_from_hir_id(parent_id);\n         debug!(\"instantiate_opaque_types_from_value(parent_def_id={:?}, value={:?})\",\n@@ -2457,6 +2464,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.body_id,\n                 self.param_env,\n                 value,\n+                value_span,\n             )\n         );\n "}, {"sha": "3aa144ca35282ad1e5a0f99e70da5e1e280a858a", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -3,7 +3,7 @@ use crate::constrained_generic_params::{identify_constrained_generic_params, Par\n \n use crate::hir::def_id::DefId;\n use rustc::traits::{self, ObligationCauseCode};\n-use rustc::ty::{self, Lift, Ty, TyCtxt, GenericParamDefKind, TypeFoldable, ToPredicate};\n+use rustc::ty::{self, Ty, TyCtxt, GenericParamDefKind, TypeFoldable, ToPredicate};\n use rustc::ty::subst::{Subst, InternalSubsts};\n use rustc::util::nodemap::{FxHashSet, FxHashMap};\n use rustc::mir::interpret::ConstValue;\n@@ -68,7 +68,7 @@ impl<'tcx> CheckWfFcxBuilder<'tcx> {\n /// We do this check as a pre-pass before checking fn bodies because if these constraints are\n /// not included it frequently leads to confusing errors in fn bodies. So it's better to check\n /// the types first.\n-pub fn check_item_well_formed<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) {\n+pub fn check_item_well_formed(tcx: TyCtxt<'_>, def_id: DefId) {\n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n     let item = tcx.hir().expect_item(hir_id);\n \n@@ -156,7 +156,7 @@ pub fn check_item_well_formed<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) {\n     }\n }\n \n-pub fn check_trait_item<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) {\n+pub fn check_trait_item(tcx: TyCtxt<'_>, def_id: DefId) {\n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n     let trait_item = tcx.hir().expect_trait_item(hir_id);\n \n@@ -167,7 +167,7 @@ pub fn check_trait_item<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) {\n     check_associated_item(tcx, trait_item.hir_id, trait_item.span, method_sig);\n }\n \n-pub fn check_impl_item<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) {\n+pub fn check_impl_item(tcx: TyCtxt<'_>, def_id: DefId) {\n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n     let impl_item = tcx.hir().expect_impl_item(hir_id);\n \n@@ -178,8 +178,8 @@ pub fn check_impl_item<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) {\n     check_associated_item(tcx, impl_item.hir_id, impl_item.span, method_sig);\n }\n \n-fn check_associated_item<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+fn check_associated_item(\n+    tcx: TyCtxt<'_>,\n     item_id: hir::HirId,\n     span: Span,\n     sig_if_method: Option<&hir::MethodSig>,\n@@ -231,7 +231,7 @@ fn for_item<'tcx>(tcx: TyCtxt<'tcx>, item: &hir::Item) -> CheckWfFcxBuilder<'tcx\n     for_id(tcx, item.hir_id, item.span)\n }\n \n-fn for_id<'tcx>(tcx: TyCtxt<'tcx>, id: hir::HirId, span: Span) -> CheckWfFcxBuilder<'tcx> {\n+fn for_id(tcx: TyCtxt<'_>, id: hir::HirId, span: Span) -> CheckWfFcxBuilder<'_> {\n     let def_id = tcx.hir().local_def_id_from_hir_id(id);\n     CheckWfFcxBuilder {\n         inherited: Inherited::build(tcx, def_id),\n@@ -261,14 +261,15 @@ fn check_type_defn<'tcx, F>(\n             let needs_drop_copy = || {\n                 packed && {\n                     let ty = variant.fields.last().unwrap().ty;\n-                    fcx.tcx.erase_regions(&ty).lift_to_tcx(fcx_tcx)\n-                        .map(|ty| ty.needs_drop(fcx_tcx, fcx_tcx.param_env(def_id)))\n-                        .unwrap_or_else(|| {\n+                    let ty = fcx.tcx.erase_regions(&ty);\n+                    if ty.has_local_value() {\n                             fcx_tcx.sess.delay_span_bug(\n                                 item.span, &format!(\"inference variables in {:?}\", ty));\n                             // Just treat unresolved type expression as if it needs drop.\n                             true\n-                        })\n+                    } else {\n+                        ty.needs_drop(fcx_tcx, fcx_tcx.param_env(def_id))\n+                    }\n                 }\n             };\n             let all_sized =\n@@ -316,7 +317,7 @@ fn check_type_defn<'tcx, F>(\n     });\n }\n \n-fn check_trait<'tcx>(tcx: TyCtxt<'tcx>, item: &hir::Item) {\n+fn check_trait(tcx: TyCtxt<'_>, item: &hir::Item) {\n     debug!(\"check_trait: {:?}\", item.hir_id);\n \n     let trait_def_id = tcx.hir().local_def_id_from_hir_id(item.hir_id);\n@@ -339,7 +340,7 @@ fn check_trait<'tcx>(tcx: TyCtxt<'tcx>, item: &hir::Item) {\n     });\n }\n \n-fn check_item_fn<'tcx>(tcx: TyCtxt<'tcx>, item: &hir::Item) {\n+fn check_item_fn(tcx: TyCtxt<'_>, item: &hir::Item) {\n     for_item(tcx, item).with_fcx(|fcx, tcx| {\n         let def_id = fcx.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n         let sig = fcx.tcx.fn_sig(def_id);\n@@ -351,8 +352,8 @@ fn check_item_fn<'tcx>(tcx: TyCtxt<'tcx>, item: &hir::Item) {\n     })\n }\n \n-fn check_item_type<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+fn check_item_type(\n+    tcx: TyCtxt<'_>,\n     item_id: hir::HirId,\n     ty_span: Span,\n     allow_foreign_ty: bool,\n@@ -979,7 +980,7 @@ fn check_variances_for_type_defn<'tcx>(\n     }\n }\n \n-fn report_bivariance<'tcx>(tcx: TyCtxt<'tcx>, span: Span, param_name: ast::Name) {\n+fn report_bivariance(tcx: TyCtxt<'_>, span: Span, param_name: ast::Name) {\n     let mut err = error_392(tcx, span, param_name);\n \n     let suggested_marker_id = tcx.lang_items().phantom_data();\n@@ -1022,7 +1023,7 @@ fn reject_shadowing_parameters(tcx: TyCtxt<'_>, def_id: DefId) {\n \n /// Feature gates RFC 2056 -- trivial bounds, checking for global bounds that\n /// aren't true.\n-fn check_false_global_bounds<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, span: Span, id: hir::HirId) {\n+fn check_false_global_bounds(fcx: &FnCtxt<'_, '_>, span: Span, id: hir::HirId) {\n     let empty_env = ty::ParamEnv::empty();\n \n     let def_id = fcx.tcx.hir().local_def_id_from_hir_id(id);\n@@ -1103,6 +1104,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let field_ty = self.tcx.type_of(self.tcx.hir().local_def_id_from_hir_id(field.hir_id));\n             let field_ty = self.normalize_associated_types_in(field.span,\n                                                               &field_ty);\n+            let field_ty = self.resolve_vars_if_possible(&field_ty);\n+            debug!(\"non_enum_variant: type of field {:?} is {:?}\", field, field_ty);\n             AdtField { ty: field_ty, span: field.span }\n         })\n         .collect();\n@@ -1134,11 +1137,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n }\n \n-fn error_392<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+fn error_392(\n+    tcx: TyCtxt<'_>,\n     span: Span,\n     param_name: ast::Name,\n-) -> DiagnosticBuilder<'tcx> {\n+) -> DiagnosticBuilder<'_> {\n     let mut err = struct_span_err!(tcx.sess, span, E0392,\n                   \"parameter `{}` is never used\", param_name);\n     err.span_label(span, \"unused parameter\");"}, {"sha": "28711e32a4c51d5eaf1d26b2329276ec12829a1c", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 14, "deletions": 21, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -363,10 +363,8 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n     }\n \n     fn visit_free_region_map(&mut self) {\n-        let free_region_map = self.tcx()\n-            .lift_to_global(&self.fcx.tables.borrow().free_region_map);\n-        let free_region_map = free_region_map.expect(\"all regions in free-region-map are global\");\n-        self.tables.free_region_map = free_region_map;\n+        self.tables.free_region_map = self.fcx.tables.borrow().free_region_map.clone();\n+        debug_assert!(!self.tables.free_region_map.elements().any(|r| r.has_local_value()));\n     }\n \n     fn visit_user_provided_tys(&mut self) {\n@@ -381,12 +379,10 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                 local_id,\n             };\n \n-            let c_ty = if let Some(c_ty) = self.tcx().lift_to_global(c_ty) {\n-                c_ty\n-            } else {\n+            if cfg!(debug_assertions) && c_ty.has_local_value() {\n                 span_bug!(\n                     hir_id.to_span(self.fcx.tcx),\n-                    \"writeback: `{:?}` missing from the global type context\",\n+                    \"writeback: `{:?}` is a local value\",\n                     c_ty\n                 );\n             };\n@@ -423,12 +419,10 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         debug_assert_eq!(fcx_tables.local_id_root, self.tables.local_id_root);\n \n         for (&def_id, c_sig) in fcx_tables.user_provided_sigs.iter() {\n-            let c_sig = if let Some(c_sig) = self.tcx().lift_to_global(c_sig) {\n-                c_sig\n-            } else {\n+            if cfg!(debug_assertions) && c_sig.has_local_value() {\n                 span_bug!(\n                     self.fcx.tcx.hir().span_if_local(def_id).unwrap(),\n-                    \"writeback: `{:?}` missing from the global type context\",\n+                    \"writeback: `{:?}` is a local value\",\n                     c_sig\n                 );\n             };\n@@ -592,10 +586,10 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                 }\n             }\n \n-            if let Some(substs) = self.tcx().lift_to_global(&opaque_defn.substs) {\n+            if !opaque_defn.substs.has_local_value() {\n                 let new = ty::ResolvedOpaqueTy {\n                     concrete_type: definition_ty,\n-                    substs,\n+                    substs: opaque_defn.substs,\n                 };\n \n                 let old = self.tables\n@@ -617,7 +611,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n             } else {\n                 self.tcx().sess.delay_span_bug(\n                     span,\n-                    \"cannot lift `opaque_defn` substs to global type context\",\n+                    \"`opaque_defn` is a local value\",\n                 );\n             }\n         }\n@@ -743,20 +737,19 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         }\n     }\n \n-    fn resolve<T>(&self, x: &T, span: &dyn Locatable) -> T::Lifted\n+    fn resolve<T>(&self, x: &T, span: &dyn Locatable) -> T\n     where\n-        T: TypeFoldable<'tcx> + ty::Lift<'tcx>,\n+        T: TypeFoldable<'tcx>,\n     {\n         let x = x.fold_with(&mut Resolver::new(self.fcx, span, self.body));\n-        if let Some(lifted) = self.tcx().lift_to_global(&x) {\n-            lifted\n-        } else {\n+        if cfg!(debug_assertions) && x.has_local_value() {\n             span_bug!(\n                 span.to_span(self.fcx.tcx),\n-                \"writeback: `{:?}` missing from the global type context\",\n+                \"writeback: `{:?}` is a local value\",\n                 x\n             );\n         }\n+        x\n     }\n }\n "}, {"sha": "8614de1977085f3f3a2993a10a450e76115f1901", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -13,7 +13,7 @@ use rustc::util::nodemap::DefIdSet;\n \n use rustc_data_structures::fx::FxHashMap;\n \n-pub fn check_crate<'tcx>(tcx: TyCtxt<'tcx>) {\n+pub fn check_crate(tcx: TyCtxt<'_>) {\n     let mut used_trait_imports = DefIdSet::default();\n     for &body_id in tcx.hir().krate().bodies.keys() {\n         let item_def_id = tcx.hir().body_owner_def_id(body_id);\n@@ -70,7 +70,7 @@ impl CheckVisitor<'tcx> {\n     }\n }\n \n-fn unused_crates_lint<'tcx>(tcx: TyCtxt<'tcx>) {\n+fn unused_crates_lint(tcx: TyCtxt<'_>) {\n     let lint = lint::builtin::UNUSED_EXTERN_CRATES;\n \n     // Collect first the crates that are completely unused.  These we"}, {"sha": "68bdcbfe3fd952a893144d137b96535be91b13ca", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -17,7 +17,7 @@ use rustc::hir::def_id::DefId;\n use hir::Node;\n use rustc::hir::{self, ItemKind};\n \n-pub fn check_trait<'tcx>(tcx: TyCtxt<'tcx>, trait_def_id: DefId) {\n+pub fn check_trait(tcx: TyCtxt<'_>, trait_def_id: DefId) {\n     Checker { tcx, trait_def_id }\n         .check(tcx.lang_items().drop_trait(), visit_implementation_of_drop)\n         .check(tcx.lang_items().copy_trait(), visit_implementation_of_copy)\n@@ -46,7 +46,7 @@ impl<'tcx> Checker<'tcx> {\n     }\n }\n \n-fn visit_implementation_of_drop<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) {\n+fn visit_implementation_of_drop(tcx: TyCtxt<'_>, impl_did: DefId) {\n     if let ty::Adt(..) = tcx.type_of(impl_did).sty {\n         /* do nothing */\n     } else {\n@@ -74,7 +74,7 @@ fn visit_implementation_of_drop<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) {\n     }\n }\n \n-fn visit_implementation_of_copy<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) {\n+fn visit_implementation_of_copy(tcx: TyCtxt<'_>, impl_did: DefId) {\n     debug!(\"visit_implementation_of_copy: impl_did={:?}\", impl_did);\n \n     let impl_hir_id = if let Some(n) = tcx.hir().as_local_hir_id(impl_did) {\n@@ -154,7 +154,7 @@ fn visit_implementation_of_coerce_unsized(tcx: TyCtxt<'tcx>, impl_did: DefId) {\n     }\n }\n \n-fn visit_implementation_of_dispatch_from_dyn<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) {\n+fn visit_implementation_of_dispatch_from_dyn(tcx: TyCtxt<'_>, impl_did: DefId) {\n     debug!(\"visit_implementation_of_dispatch_from_dyn: impl_did={:?}\",\n            impl_did);\n     if impl_did.is_local() {"}, {"sha": "9efe1273ac04489400768b1f3461b4263a47fe06", "filename": "src/librustc_typeck/coherence/inherent_impls.rs", "status": "modified", "additions": 8, "deletions": 33, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -7,7 +7,6 @@\n //! `tcx.inherent_impls(def_id)`). That value, however,\n //! is computed by selecting an idea from this table.\n \n-use rustc::dep_graph::DepKind;\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::hir;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n@@ -17,10 +16,10 @@ use syntax::ast;\n use syntax_pos::Span;\n \n /// On-demand query: yields a map containing all types mapped to their inherent impls.\n-pub fn crate_inherent_impls<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+pub fn crate_inherent_impls(\n+    tcx: TyCtxt<'_>,\n     crate_num: CrateNum,\n-) -> &'tcx CrateInherentImpls {\n+) -> &CrateInherentImpls {\n     assert_eq!(crate_num, LOCAL_CRATE);\n \n     let krate = tcx.hir().krate();\n@@ -33,38 +32,14 @@ pub fn crate_inherent_impls<'tcx>(\n }\n \n /// On-demand query: yields a vector of the inherent impls for a specific type.\n-pub fn inherent_impls<'tcx>(tcx: TyCtxt<'tcx>, ty_def_id: DefId) -> &'tcx [DefId] {\n+pub fn inherent_impls(tcx: TyCtxt<'_>, ty_def_id: DefId) -> &[DefId] {\n     assert!(ty_def_id.is_local());\n \n-    // NB. Until we adopt the red-green dep-tracking algorithm (see\n-    // [the plan] for details on that), we do some hackery here to get\n-    // the dependencies correct.  Basically, we use a `with_ignore` to\n-    // read the result we want. If we didn't have the `with_ignore`,\n-    // we would wind up with a dependency on the entire crate, which\n-    // we don't want. Then we go and add dependencies on all the impls\n-    // in the result (which is what we wanted).\n-    //\n-    // The result is a graph with an edge from `Hir(I)` for every impl\n-    // `I` defined on some type `T` to `CoherentInherentImpls(T)`,\n-    // thus ensuring that if any of those impls change, the set of\n-    // inherent impls is considered dirty.\n-    //\n-    // [the plan]: https://github.com/rust-lang/rust-roadmap/issues/4\n-\n-    let result = tcx.dep_graph.with_ignore(|| {\n-        let crate_map = tcx.crate_inherent_impls(ty_def_id.krate);\n-        match crate_map.inherent_impls.get(&ty_def_id) {\n-            Some(v) => &v[..],\n-            None => &[],\n-        }\n-    });\n-\n-    for &impl_def_id in &result[..] {\n-        let def_path_hash = tcx.def_path_hash(impl_def_id);\n-        tcx.dep_graph.read(def_path_hash.to_dep_node(DepKind::Hir));\n+    let crate_map = tcx.crate_inherent_impls(ty_def_id.krate);\n+    match crate_map.inherent_impls.get(&ty_def_id) {\n+        Some(v) => &v[..],\n+        None => &[],\n     }\n-\n-    result\n }\n \n struct InherentCollect<'tcx> {"}, {"sha": "1785304fb1d487449d81a3bee7d0594824c35295", "filename": "src/librustc_typeck/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -5,7 +5,7 @@ use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::traits::{self, IntercrateMode};\n use rustc::ty::TyCtxt;\n \n-pub fn crate_inherent_impls_overlap_check<'tcx>(tcx: TyCtxt<'tcx>, crate_num: CrateNum) {\n+pub fn crate_inherent_impls_overlap_check(tcx: TyCtxt<'_>, crate_num: CrateNum) {\n     assert_eq!(crate_num, LOCAL_CRATE);\n     let krate = tcx.hir().krate();\n     krate.visit_all_item_likes(&mut InherentOverlapChecker { tcx });"}, {"sha": "9b9789139b70f14c327ba51675c5d07184696f99", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -18,7 +18,7 @@ mod inherent_impls_overlap;\n mod orphan;\n mod unsafety;\n \n-fn check_impl<'tcx>(tcx: TyCtxt<'tcx>, hir_id: HirId) {\n+fn check_impl(tcx: TyCtxt<'_>, hir_id: HirId) {\n     let impl_def_id = tcx.hir().local_def_id_from_hir_id(hir_id);\n \n     // If there are no traits, then this implementation must have a\n@@ -124,7 +124,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     };\n }\n \n-fn coherent_trait<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) {\n+fn coherent_trait(tcx: TyCtxt<'_>, def_id: DefId) {\n     let impls = tcx.hir().trait_impls(def_id);\n     for &impl_id in impls {\n         check_impl(tcx, impl_id);\n@@ -135,7 +135,7 @@ fn coherent_trait<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) {\n     builtin::check_trait(tcx, def_id);\n }\n \n-pub fn check_coherence<'tcx>(tcx: TyCtxt<'tcx>) {\n+pub fn check_coherence(tcx: TyCtxt<'_>) {\n     for &trait_def_id in tcx.hir().krate().trait_impls.keys() {\n         tcx.ensure().coherent_trait(trait_def_id);\n     }\n@@ -151,7 +151,7 @@ pub fn check_coherence<'tcx>(tcx: TyCtxt<'tcx>) {\n /// Overlap: no two impls for the same trait are implemented for the\n /// same type. Likewise, no two inherent impls for a given type\n /// constructor provide a method with the same name.\n-fn check_impl_overlap<'tcx>(tcx: TyCtxt<'tcx>, hir_id: HirId) {\n+fn check_impl_overlap(tcx: TyCtxt<'_>, hir_id: HirId) {\n     let impl_def_id = tcx.hir().local_def_id_from_hir_id(hir_id);\n     let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n     let trait_def_id = trait_ref.def_id;"}, {"sha": "2d0faecd8ee71dbb8d3b94c3b71bbf96341665aa", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -6,7 +6,7 @@ use rustc::ty::{self, TyCtxt};\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir;\n \n-pub fn check<'tcx>(tcx: TyCtxt<'tcx>) {\n+pub fn check(tcx: TyCtxt<'_>) {\n     let mut orphan = OrphanChecker { tcx };\n     tcx.hir().krate().visit_all_item_likes(&mut orphan);\n }"}, {"sha": "123d7c6123b89a0a11db04471e64d576ad304734", "filename": "src/librustc_typeck/coherence/unsafety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -5,7 +5,7 @@ use rustc::ty::TyCtxt;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::{self, Unsafety};\n \n-pub fn check<'tcx>(tcx: TyCtxt<'tcx>) {\n+pub fn check(tcx: TyCtxt<'_>) {\n     let mut unsafety = UnsafetyChecker { tcx };\n     tcx.hir().krate().visit_all_item_likes(&mut unsafety);\n }"}, {"sha": "e5802179ec479328d0847313c37bc6f7a7ad174a", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -56,7 +56,7 @@ struct OnlySelfBounds(bool);\n ///////////////////////////////////////////////////////////////////////////\n // Main entry point\n \n-fn collect_mod_item_types<'tcx>(tcx: TyCtxt<'tcx>, module_def_id: DefId) {\n+fn collect_mod_item_types(tcx: TyCtxt<'_>, module_def_id: DefId) {\n     tcx.hir().visit_item_likes_in_module(\n         module_def_id,\n         &mut CollectItemTypesVisitor { tcx }.as_deep_visitor()\n@@ -253,10 +253,10 @@ impl AstConv<'tcx> for ItemCtxt<'tcx> {\n     }\n }\n \n-fn type_param_predicates<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+fn type_param_predicates(\n+    tcx: TyCtxt<'_>,\n     (item_def_id, def_id): (DefId, DefId),\n-) -> &'tcx ty::GenericPredicates<'tcx> {\n+) -> &ty::GenericPredicates<'_> {\n     use rustc::hir::*;\n \n     // In the AST, bounds can derive from two places. Either\n@@ -381,7 +381,7 @@ impl ItemCtxt<'tcx> {\n /// parameter with ID `param_id`. We use this so as to avoid running\n /// `ast_ty_to_ty`, because we want to avoid triggering an all-out\n /// conversion of the type to avoid inducing unnecessary cycles.\n-fn is_param<'tcx>(tcx: TyCtxt<'tcx>, ast_ty: &hir::Ty, param_id: hir::HirId) -> bool {\n+fn is_param(tcx: TyCtxt<'_>, ast_ty: &hir::Ty, param_id: hir::HirId) -> bool {\n     if let hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) = ast_ty.node {\n         match path.res {\n             Res::SelfTy(Some(def_id), None) | Res::Def(DefKind::TyParam, def_id) => {\n@@ -394,7 +394,7 @@ fn is_param<'tcx>(tcx: TyCtxt<'tcx>, ast_ty: &hir::Ty, param_id: hir::HirId) ->\n     }\n }\n \n-fn convert_item<'tcx>(tcx: TyCtxt<'tcx>, item_id: hir::HirId) {\n+fn convert_item(tcx: TyCtxt<'_>, item_id: hir::HirId) {\n     let it = tcx.hir().expect_item(item_id);\n     debug!(\"convert: item {} with id {}\", it.ident, it.hir_id);\n     let def_id = tcx.hir().local_def_id_from_hir_id(item_id);\n@@ -476,7 +476,7 @@ fn convert_item<'tcx>(tcx: TyCtxt<'tcx>, item_id: hir::HirId) {\n     }\n }\n \n-fn convert_trait_item<'tcx>(tcx: TyCtxt<'tcx>, trait_item_id: hir::HirId) {\n+fn convert_trait_item(tcx: TyCtxt<'_>, trait_item_id: hir::HirId) {\n     let trait_item = tcx.hir().expect_trait_item(trait_item_id);\n     let def_id = tcx.hir().local_def_id_from_hir_id(trait_item.hir_id);\n     tcx.generics_of(def_id);\n@@ -497,7 +497,7 @@ fn convert_trait_item<'tcx>(tcx: TyCtxt<'tcx>, trait_item_id: hir::HirId) {\n     tcx.predicates_of(def_id);\n }\n \n-fn convert_impl_item<'tcx>(tcx: TyCtxt<'tcx>, impl_item_id: hir::HirId) {\n+fn convert_impl_item(tcx: TyCtxt<'_>, impl_item_id: hir::HirId) {\n     let def_id = tcx.hir().local_def_id_from_hir_id(impl_item_id);\n     tcx.generics_of(def_id);\n     tcx.type_of(def_id);\n@@ -507,7 +507,7 @@ fn convert_impl_item<'tcx>(tcx: TyCtxt<'tcx>, impl_item_id: hir::HirId) {\n     }\n }\n \n-fn convert_variant_ctor<'tcx>(tcx: TyCtxt<'tcx>, ctor_id: hir::HirId) {\n+fn convert_variant_ctor(tcx: TyCtxt<'_>, ctor_id: hir::HirId) {\n     let def_id = tcx.hir().local_def_id_from_hir_id(ctor_id);\n     tcx.generics_of(def_id);\n     tcx.type_of(def_id);\n@@ -562,8 +562,8 @@ fn convert_enum_variant_types<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, variants:\n     }\n }\n \n-fn convert_variant<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+fn convert_variant(\n+    tcx: TyCtxt<'_>,\n     variant_did: Option<DefId>,\n     ctor_did: Option<DefId>,\n     ident: Ident,\n@@ -619,7 +619,7 @@ fn convert_variant<'tcx>(\n     )\n }\n \n-fn adt_def<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx ty::AdtDef {\n+fn adt_def(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::AdtDef {\n     use rustc::hir::*;\n \n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n@@ -686,10 +686,10 @@ fn adt_def<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx ty::AdtDef {\n /// Ensures that the super-predicates of the trait with a `DefId`\n /// of `trait_def_id` are converted and stored. This also ensures that\n /// the transitive super-predicates are converted.\n-fn super_predicates_of<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+fn super_predicates_of(\n+    tcx: TyCtxt<'_>,\n     trait_def_id: DefId,\n-) -> &'tcx ty::GenericPredicates<'tcx> {\n+) -> &ty::GenericPredicates<'_> {\n     debug!(\"super_predicates(trait_def_id={:?})\", trait_def_id);\n     let trait_hir_id = tcx.hir().as_local_hir_id(trait_def_id).unwrap();\n \n@@ -740,7 +740,7 @@ fn super_predicates_of<'tcx>(\n     })\n }\n \n-fn trait_def<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx ty::TraitDef {\n+fn trait_def(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::TraitDef {\n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n     let item = tcx.hir().expect_item(hir_id);\n \n@@ -879,7 +879,7 @@ fn has_late_bound_regions<'tcx>(tcx: TyCtxt<'tcx>, node: Node<'tcx>) -> Option<S\n     }\n }\n \n-fn generics_of<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx ty::Generics {\n+fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n     use rustc::hir::*;\n \n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n@@ -1122,7 +1122,7 @@ fn generics_of<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx ty::Generics {\n     })\n }\n \n-fn report_assoc_ty_on_inherent_impl<'tcx>(tcx: TyCtxt<'tcx>, span: Span) {\n+fn report_assoc_ty_on_inherent_impl(tcx: TyCtxt<'_>, span: Span) {\n     span_err!(\n         tcx.sess,\n         span,\n@@ -1131,15 +1131,15 @@ fn report_assoc_ty_on_inherent_impl<'tcx>(tcx: TyCtxt<'tcx>, span: Span) {\n     );\n }\n \n-fn type_of<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Ty<'tcx> {\n+fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n     checked_type_of(tcx, def_id, true).unwrap()\n }\n \n /// Same as [`type_of`] but returns [`Option`] instead of failing.\n ///\n /// If you want to fail anyway, you can set the `fail` parameter to true, but in this case,\n /// you'd better just call [`type_of`] directly.\n-pub fn checked_type_of<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, fail: bool) -> Option<Ty<'tcx>> {\n+pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<'_>> {\n     use rustc::hir::*;\n \n     let hir_id = match tcx.hir().as_local_hir_id(def_id) {\n@@ -1353,7 +1353,7 @@ pub fn checked_type_of<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, fail: bool) -> Op\n                                 None\n                             }\n                         }\n-                        Node::TraitRef(&hir::TraitRef { ref path, .. }) => Some(path),\n+                        Node::TraitRef(&hir::TraitRef { ref path, .. }) => Some(&**path),\n                         _ => None,\n                     };\n \n@@ -1464,7 +1464,7 @@ pub fn checked_type_of<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, fail: bool) -> Op\n     })\n }\n \n-fn find_existential_constraints<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Ty<'tcx> {\n+fn find_existential_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n     use rustc::hir::{ImplItem, Item, TraitItem};\n \n     debug!(\"find_existential_constraints({:?})\", def_id);\n@@ -1682,7 +1682,7 @@ fn find_existential_constraints<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Ty<'t\n     }\n }\n \n-fn fn_sig<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> ty::PolyFnSig<'tcx> {\n+fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n     use rustc::hir::*;\n     use rustc::hir::Node::*;\n \n@@ -1758,7 +1758,7 @@ fn fn_sig<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> ty::PolyFnSig<'tcx> {\n     }\n }\n \n-fn impl_trait_ref<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Option<ty::TraitRef<'tcx>> {\n+fn impl_trait_ref(tcx: TyCtxt<'_>, def_id: DefId) -> Option<ty::TraitRef<'_>> {\n     let icx = ItemCtxt::new(tcx, def_id);\n \n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n@@ -1773,7 +1773,7 @@ fn impl_trait_ref<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Option<ty::TraitRef\n     }\n }\n \n-fn impl_polarity<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> hir::ImplPolarity {\n+fn impl_polarity(tcx: TyCtxt<'_>, def_id: DefId) -> hir::ImplPolarity {\n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n     match tcx.hir().expect_item(hir_id).node {\n         hir::ItemKind::Impl(_, polarity, ..) => polarity,\n@@ -1804,10 +1804,10 @@ fn early_bound_lifetimes_from_generics<'a, 'tcx: 'a>(\n /// Returns a list of type predicates for the definition with ID `def_id`, including inferred\n /// lifetime constraints. This includes all predicates returned by `explicit_predicates_of`, plus\n /// inferred constraints concerning which regions outlive other regions.\n-fn predicates_defined_on<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+fn predicates_defined_on(\n+    tcx: TyCtxt<'_>,\n     def_id: DefId,\n-) -> &'tcx ty::GenericPredicates<'tcx> {\n+) -> &ty::GenericPredicates<'_> {\n     debug!(\"predicates_defined_on({:?})\", def_id);\n     let mut result = tcx.explicit_predicates_of(def_id);\n     debug!(\n@@ -1834,7 +1834,7 @@ fn predicates_defined_on<'tcx>(\n /// Returns a list of all type predicates (explicit and implicit) for the definition with\n /// ID `def_id`. This includes all predicates returned by `predicates_defined_on`, plus\n /// `Self: Trait` predicates for traits.\n-fn predicates_of<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx ty::GenericPredicates<'tcx> {\n+fn predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::GenericPredicates<'_> {\n     let mut result = tcx.predicates_defined_on(def_id);\n \n     if tcx.is_trait(def_id) {\n@@ -1861,10 +1861,10 @@ fn predicates_of<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx ty::GenericPre\n \n /// Returns a list of user-specified type predicates for the definition with ID `def_id`.\n /// N.B., this does not include any implied/inferred constraints.\n-fn explicit_predicates_of<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+fn explicit_predicates_of(\n+    tcx: TyCtxt<'_>,\n     def_id: DefId,\n-) -> &'tcx ty::GenericPredicates<'tcx> {\n+) -> &ty::GenericPredicates<'_> {\n     use rustc::hir::*;\n     use rustc_data_structures::fx::FxHashSet;\n \n@@ -2271,15 +2271,15 @@ fn compute_sig_of_foreign_fn_decl<'tcx>(\n     fty\n }\n \n-fn is_foreign_item<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> bool {\n+fn is_foreign_item(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n     match tcx.hir().get_if_local(def_id) {\n         Some(Node::ForeignItem(..)) => true,\n         Some(_) => false,\n         _ => bug!(\"is_foreign_item applied to non-local def-id {:?}\", def_id),\n     }\n }\n \n-fn static_mutability<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Option<hir::Mutability> {\n+fn static_mutability(tcx: TyCtxt<'_>, def_id: DefId) -> Option<hir::Mutability> {\n     match tcx.hir().get_if_local(def_id) {\n         Some(Node::Item(&hir::Item {\n             node: hir::ItemKind::Static(_, mutbl, _), ..\n@@ -2387,7 +2387,7 @@ fn from_target_feature(\n     }\n }\n \n-fn linkage_by_name<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, name: &str) -> Linkage {\n+fn linkage_by_name(tcx: TyCtxt<'_>, def_id: DefId, name: &str) -> Linkage {\n     use rustc::mir::mono::Linkage::*;\n \n     // Use the names from src/llvm/docs/LangRef.rst here. Most types are only\n@@ -2422,7 +2422,7 @@ fn linkage_by_name<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, name: &str) -> Linkag\n     }\n }\n \n-fn codegen_fn_attrs<'tcx>(tcx: TyCtxt<'tcx>, id: DefId) -> CodegenFnAttrs {\n+fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n     let attrs = tcx.get_attrs(id);\n \n     let mut codegen_fn_attrs = CodegenFnAttrs::new();"}, {"sha": "08c7cbc389a6756309c3d7131293a46140c019ea", "filename": "src/librustc_typeck/impl_wf_check.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -49,7 +49,7 @@ use syntax_pos::Span;\n /// impl<'a> Trait<Foo> for Bar { type X = &'a i32; }\n /// //   ^ 'a is unused and appears in assoc type, error\n /// ```\n-pub fn impl_wf_check<'tcx>(tcx: TyCtxt<'tcx>) {\n+pub fn impl_wf_check(tcx: TyCtxt<'_>) {\n     // We will tag this as part of the WF check -- logically, it is,\n     // but it's one that we must perform earlier than the rest of\n     // WfCheck.\n@@ -58,7 +58,7 @@ pub fn impl_wf_check<'tcx>(tcx: TyCtxt<'tcx>) {\n     }\n }\n \n-fn check_mod_impl_wf<'tcx>(tcx: TyCtxt<'tcx>, module_def_id: DefId) {\n+fn check_mod_impl_wf(tcx: TyCtxt<'_>, module_def_id: DefId) {\n     tcx.hir().visit_item_likes_in_module(\n         module_def_id,\n         &mut ImplWfCheck { tcx }\n@@ -92,8 +92,8 @@ impl ItemLikeVisitor<'tcx> for ImplWfCheck<'tcx> {\n     fn visit_impl_item(&mut self, _impl_item: &'tcx hir::ImplItem) { }\n }\n \n-fn enforce_impl_params_are_constrained<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+fn enforce_impl_params_are_constrained(\n+    tcx: TyCtxt<'_>,\n     impl_def_id: DefId,\n     impl_item_refs: &[hir::ImplItemRef],\n ) {\n@@ -183,7 +183,7 @@ fn report_unused_parameter(tcx: TyCtxt<'_>, span: Span, kind: &str, name: &str)\n }\n \n /// Enforce that we do not have two items in an impl with the same name.\n-fn enforce_impl_items_are_distinct<'tcx>(tcx: TyCtxt<'tcx>, impl_item_refs: &[hir::ImplItemRef]) {\n+fn enforce_impl_items_are_distinct(tcx: TyCtxt<'_>, impl_item_refs: &[hir::ImplItemRef]) {\n     let mut seen_type_items = FxHashMap::default();\n     let mut seen_value_items = FxHashMap::default();\n     for impl_item_ref in impl_item_refs {"}, {"sha": "88e6c0f579efa0bd06826c5cd0f7ca0a1efb1efd", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 6, "deletions": 20, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -69,6 +69,7 @@ This API is completely unstable and subject to change.\n #![feature(slice_patterns)]\n #![feature(never_type)]\n #![feature(inner_deref)]\n+#![feature(mem_take)]\n \n #![recursion_limit=\"256\"]\n \n@@ -105,7 +106,7 @@ use rustc::lint;\n use rustc::middle;\n use rustc::session;\n use rustc::util::common::ErrorReported;\n-use rustc::session::config::{EntryFnType, nightly_options};\n+use rustc::session::config::EntryFnType;\n use rustc::traits::{ObligationCause, ObligationCauseCode, TraitEngine, TraitEngineExt};\n use rustc::ty::subst::SubstsRef;\n use rustc::ty::{self, Ty, TyCtxt};\n@@ -124,21 +125,6 @@ pub struct TypeAndSubsts<'tcx> {\n     ty: Ty<'tcx>,\n }\n \n-fn check_type_alias_enum_variants_enabled<'tcx>(tcx: TyCtxt<'tcx>, span: Span) {\n-    if !tcx.features().type_alias_enum_variants {\n-        let mut err = tcx.sess.struct_span_err(\n-            span,\n-            \"enum variants on type aliases are experimental\"\n-        );\n-        if nightly_options::is_nightly_build() {\n-            help!(&mut err,\n-                \"add `#![feature(type_alias_enum_variants)]` to the \\\n-                crate attributes to enable\");\n-        }\n-        err.emit();\n-    }\n-}\n-\n fn require_c_abi_if_c_variadic(tcx: TyCtxt<'_>, decl: &hir::FnDecl, abi: Abi, span: Span) {\n     if decl.c_variadic && !(abi == Abi::C || abi == Abi::Cdecl) {\n         let mut err = struct_span_err!(tcx.sess, span, E0045,\n@@ -176,7 +162,7 @@ fn require_same_types<'tcx>(\n     })\n }\n \n-fn check_main_fn_ty<'tcx>(tcx: TyCtxt<'tcx>, main_def_id: DefId) {\n+fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: DefId) {\n     let main_id = tcx.hir().as_local_hir_id(main_def_id).unwrap();\n     let main_span = tcx.def_span(main_def_id);\n     let main_t = tcx.type_of(main_def_id);\n@@ -241,7 +227,7 @@ fn check_main_fn_ty<'tcx>(tcx: TyCtxt<'tcx>, main_def_id: DefId) {\n     }\n }\n \n-fn check_start_fn_ty<'tcx>(tcx: TyCtxt<'tcx>, start_def_id: DefId) {\n+fn check_start_fn_ty(tcx: TyCtxt<'_>, start_def_id: DefId) {\n     let start_id = tcx.hir().as_local_hir_id(start_def_id).unwrap();\n     let start_span = tcx.def_span(start_def_id);\n     let start_t = tcx.type_of(start_def_id);\n@@ -298,7 +284,7 @@ fn check_start_fn_ty<'tcx>(tcx: TyCtxt<'tcx>, start_def_id: DefId) {\n     }\n }\n \n-fn check_for_entry_fn<'tcx>(tcx: TyCtxt<'tcx>) {\n+fn check_for_entry_fn(tcx: TyCtxt<'_>) {\n     match tcx.entry_fn(LOCAL_CRATE) {\n         Some((def_id, EntryFnType::Main)) => check_main_fn_ty(tcx, def_id),\n         Some((def_id, EntryFnType::Start)) => check_start_fn_ty(tcx, def_id),\n@@ -315,7 +301,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     impl_wf_check::provide(providers);\n }\n \n-pub fn check_crate<'tcx>(tcx: TyCtxt<'tcx>) -> Result<(), ErrorReported> {\n+pub fn check_crate(tcx: TyCtxt<'_>) -> Result<(), ErrorReported> {\n     tcx.sess.profiler(|p| p.start_activity(\"type-check crate\"));\n \n     // this ensures that later parts of type checking can assume that items"}, {"sha": "6b8f6fccd40d73fba36dbadffc54f2d3658d9496", "filename": "src/librustc_typeck/outlives/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -20,10 +20,10 @@ pub fn provide(providers: &mut Providers<'_>) {\n     };\n }\n \n-fn inferred_outlives_of<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+fn inferred_outlives_of(\n+    tcx: TyCtxt<'_>,\n     item_def_id: DefId,\n-) -> &'tcx [ty::Predicate<'tcx>] {\n+) -> &[ty::Predicate<'_>] {\n     let id = tcx\n         .hir()\n         .as_local_hir_id(item_def_id)\n@@ -70,10 +70,10 @@ fn inferred_outlives_of<'tcx>(\n     }\n }\n \n-fn inferred_outlives_crate<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+fn inferred_outlives_crate(\n+    tcx: TyCtxt<'_>,\n     crate_num: CrateNum,\n-) -> &'tcx CratePredicatesMap<'tcx> {\n+) -> &CratePredicatesMap<'_> {\n     assert_eq!(crate_num, LOCAL_CRATE);\n \n     // Compute a map from each struct/enum/union S to the **explicit**"}, {"sha": "5ddf95b0f80c21ab5c1d14f62a77beb578fe214a", "filename": "src/librustc_typeck/outlives/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_typeck%2Foutlives%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_typeck%2Foutlives%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Ftest.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -3,7 +3,7 @@ use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::ty::TyCtxt;\n use syntax::symbol::sym;\n \n-pub fn test_inferred_outlives<'tcx>(tcx: TyCtxt<'tcx>) {\n+pub fn test_inferred_outlives(tcx: TyCtxt<'_>) {\n     tcx.hir()\n        .krate()\n        .visit_all_item_likes(&mut OutlivesTest { tcx });"}, {"sha": "783890da639f477ee40b64fdcdd1d3cddd155ae1", "filename": "src/librustc_typeck/outlives/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_typeck%2Foutlives%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_typeck%2Foutlives%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Futils.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -125,7 +125,7 @@ pub fn insert_outlives_predicate<'tcx>(\n     }\n }\n \n-fn is_free_region<'tcx>(tcx: TyCtxt<'tcx>, region: Region<'_>) -> bool {\n+fn is_free_region(tcx: TyCtxt<'_>, region: Region<'_>) -> bool {\n     // First, screen for regions that might appear in a type header.\n     match region {\n         // These correspond to `T: 'a` relationships:"}, {"sha": "343d7ea656fbb27d532d63ed696f1db19c66dca7", "filename": "src/librustc_typeck/variance/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -34,15 +34,15 @@ pub fn provide(providers: &mut Providers<'_>) {\n     };\n }\n \n-fn crate_variances<'tcx>(tcx: TyCtxt<'tcx>, crate_num: CrateNum) -> &'tcx CrateVariancesMap<'tcx> {\n+fn crate_variances(tcx: TyCtxt<'_>, crate_num: CrateNum) -> &CrateVariancesMap<'_> {\n     assert_eq!(crate_num, LOCAL_CRATE);\n     let mut arena = arena::TypedArena::default();\n     let terms_cx = terms::determine_parameters_to_be_inferred(tcx, &mut arena);\n     let constraints_cx = constraints::add_constraints_from_crate(terms_cx);\n     tcx.arena.alloc(solve::solve_constraints(constraints_cx))\n }\n \n-fn variances_of<'tcx>(tcx: TyCtxt<'tcx>, item_def_id: DefId) -> &'tcx [ty::Variance] {\n+fn variances_of(tcx: TyCtxt<'_>, item_def_id: DefId) -> &[ty::Variance] {\n     let id = tcx.hir().as_local_hir_id(item_def_id).expect(\"expected local def-id\");\n     let unsupported = || {\n         // Variance not relevant."}, {"sha": "0c7ebc34e8f6de8785ef6be04b2cca1dfc9043f7", "filename": "src/librustc_typeck/variance/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_typeck%2Fvariance%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustc_typeck%2Fvariance%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Ftest.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -3,7 +3,7 @@ use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::ty::TyCtxt;\n use syntax::symbol::sym;\n \n-pub fn test_variance<'tcx>(tcx: TyCtxt<'tcx>) {\n+pub fn test_variance(tcx: TyCtxt<'_>) {\n     tcx.hir().krate().visit_all_item_likes(&mut VarianceTest { tcx });\n }\n "}, {"sha": "ad211763a6c46e4be4106948c0ad873f7aecf6fb", "filename": "src/librustdoc/clean/cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fcfg.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -16,7 +16,7 @@ use syntax_pos::Span;\n \n use crate::html::escape::Escape;\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, PartialEq, Eq, Hash)]\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n pub enum Cfg {\n     /// Accepts all configurations.\n     True,"}, {"sha": "8ae96d8665718f37daa6c3f5e1a9fe599b983438", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 56, "deletions": 59, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -20,6 +20,7 @@ use rustc::mir::interpret::{GlobalId, ConstValue};\n use rustc::hir;\n use rustc::hir::def::{CtorKind, DefKind, Res};\n use rustc::hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use rustc::hir::ptr::P;\n use rustc::ty::subst::{InternalSubsts, SubstsRef, UnpackedKind};\n use rustc::ty::{self, DefIdTree, TyCtxt, Region, RegionVid, Ty, AdtKind};\n use rustc::ty::fold::TypeFolder;\n@@ -29,7 +30,6 @@ use syntax::ast::{self, AttrStyle, Ident};\n use syntax::attr;\n use syntax::ext::base::MacroKind;\n use syntax::source_map::{dummy_spanned, Spanned};\n-use syntax::ptr::P;\n use syntax::symbol::{Symbol, kw, sym};\n use syntax::symbol::InternedString;\n use syntax_pos::{self, Pos, FileName};\n@@ -223,7 +223,7 @@ impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Debug)]\n pub struct ExternalCrate {\n     pub name: String,\n     pub src: FileName,\n@@ -355,7 +355,7 @@ impl Clean<ExternalCrate> for CrateNum {\n /// Anything with a source location and set of attributes and, optionally, a\n /// name. That is, anything that can be documented. This doesn't correspond\n /// directly to the AST's concept of an item; it's a strict superset.\n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone)]\n pub struct Item {\n     /// Stringified span\n     pub source: Span,\n@@ -528,7 +528,7 @@ impl Item {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Debug)]\n pub enum ItemEnum {\n     ExternCrateItem(String, Option<String>),\n     ImportItem(Import),\n@@ -594,7 +594,7 @@ impl ItemEnum {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Debug)]\n pub struct Module {\n     pub items: Vec<Item>,\n     pub is_crate: bool,\n@@ -731,7 +731,7 @@ impl<I: IntoIterator<Item=ast::NestedMetaItem>> NestedAttributesExt for I {\n /// Included files are kept separate from inline doc comments so that proper line-number\n /// information can be given when a doctest fails. Sugared doc comments and \"raw\" doc comments are\n /// kept separate because of issue #42760.\n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Hash)]\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub enum DocFragment {\n     /// A doc fragment created from a `///` or `//!` doc comment.\n     SugaredDoc(usize, syntax_pos::Span, String),\n@@ -781,7 +781,7 @@ impl<'a> FromIterator<&'a DocFragment> for String {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Default)]\n+#[derive(Clone, Debug, Default)]\n pub struct Attributes {\n     pub doc_strings: Vec<DocFragment>,\n     pub other_attrs: Vec<ast::Attribute>,\n@@ -1048,7 +1048,7 @@ impl Clean<Attributes> for [ast::Attribute] {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Hash)]\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub enum GenericBound {\n     TraitBound(PolyTrait, hir::TraitBoundModifier),\n     Outlives(Lifetime),\n@@ -1231,7 +1231,7 @@ impl<'tcx> Clean<Option<Vec<GenericBound>>> for InternalSubsts<'tcx> {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Hash)]\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub struct Lifetime(String);\n \n impl Lifetime {\n@@ -1326,7 +1326,7 @@ impl Clean<Option<Lifetime>> for ty::RegionKind {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Hash)]\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub enum WherePredicate {\n     BoundPredicate { ty: Type, bounds: Vec<GenericBound> },\n     RegionPredicate { lifetime: Lifetime, bounds: Vec<GenericBound> },\n@@ -1464,7 +1464,7 @@ impl<'tcx> Clean<Type> for ty::ProjectionTy<'tcx> {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Hash)]\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub enum GenericParamDefKind {\n     Lifetime,\n     Type {\n@@ -1498,7 +1498,7 @@ impl GenericParamDefKind {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Hash)]\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub struct GenericParamDef {\n     pub name: String,\n \n@@ -1610,7 +1610,7 @@ impl Clean<GenericParamDef> for hir::GenericParam {\n }\n \n // maybe use a Generic enum and use Vec<Generic>?\n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Default, Hash)]\n+#[derive(Clone, PartialEq, Eq, Debug, Default, Hash)]\n pub struct Generics {\n     pub params: Vec<GenericParamDef>,\n     pub where_predicates: Vec<WherePredicate>,\n@@ -1874,7 +1874,7 @@ pub fn get_all_types(\n     (all_types.into_iter().collect(), ret_types)\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Debug)]\n pub struct Method {\n     pub generics: Generics,\n     pub decl: FnDecl,\n@@ -1902,7 +1902,7 @@ impl<'a> Clean<Method> for (&'a hir::MethodSig, &'a hir::Generics, hir::BodyId,\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Debug)]\n pub struct TyMethod {\n     pub header: hir::FnHeader,\n     pub decl: FnDecl,\n@@ -1911,7 +1911,7 @@ pub struct TyMethod {\n     pub ret_types: Vec<Type>,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Debug)]\n pub struct Function {\n     pub decl: FnDecl,\n     pub generics: Generics,\n@@ -1952,7 +1952,7 @@ impl Clean<Item> for doctree::Function<'_> {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Hash)]\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub struct FnDecl {\n     pub inputs: Arguments,\n     pub output: FunctionRetTy,\n@@ -1989,7 +1989,7 @@ impl FnDecl {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Hash)]\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub struct Arguments {\n     pub values: Vec<Argument>,\n }\n@@ -2063,13 +2063,13 @@ impl<'tcx> Clean<FnDecl> for (DefId, ty::PolyFnSig<'tcx>) {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Hash)]\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub struct Argument {\n     pub type_: Type,\n     pub name: String,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n+#[derive(Clone, PartialEq, Debug)]\n pub enum SelfTy {\n     SelfValue,\n     SelfBorrowed(Option<Lifetime>, Mutability),\n@@ -2093,7 +2093,7 @@ impl Argument {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Hash)]\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub enum FunctionRetTy {\n     Return(Type),\n     DefaultReturn,\n@@ -2117,7 +2117,7 @@ impl GetDefId for FunctionRetTy {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Debug)]\n pub struct Trait {\n     pub auto: bool,\n     pub unsafety: hir::Unsafety,\n@@ -2153,7 +2153,7 @@ impl Clean<Item> for doctree::Trait<'_> {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Debug)]\n pub struct TraitAlias {\n     pub generics: Generics,\n     pub bounds: Vec<GenericBound>,\n@@ -2437,7 +2437,7 @@ impl Clean<Item> for ty::AssocItem {\n }\n \n /// A trait reference, which may have higher ranked lifetimes.\n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Hash)]\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub struct PolyTrait {\n     pub trait_: Type,\n     pub generic_params: Vec<GenericParamDef>,\n@@ -2446,7 +2446,7 @@ pub struct PolyTrait {\n /// A representation of a type suitable for hyperlinking purposes. Ideally, one can get the original\n /// type out of the AST/`TyCtxt` given one of these, if more information is needed. Most\n /// importantly, it does not preserve mutability or boxes.\n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Hash)]\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub enum Type {\n     /// Structs/enums/traits (most that would be an `hir::TyKind::Path`).\n     ResolvedPath {\n@@ -2469,7 +2469,6 @@ pub enum Type {\n     Array(Box<Type>, String),\n     Never,\n     CVarArgs,\n-    Unique(Box<Type>),\n     RawPointer(Mutability, Box<Type>),\n     BorrowedRef {\n         lifetime: Option<Lifetime>,\n@@ -2491,7 +2490,7 @@ pub enum Type {\n     ImplTrait(Vec<GenericBound>),\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Copy, Debug)]\n+#[derive(Clone, PartialEq, Eq, Hash, Copy, Debug)]\n pub enum PrimitiveType {\n     Isize, I8, I16, I32, I64, I128,\n     Usize, U8, U16, U32, U64, U128,\n@@ -2510,7 +2509,7 @@ pub enum PrimitiveType {\n     CVarArgs,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Copy, Debug)]\n+#[derive(Clone, Copy, Debug)]\n pub enum TypeKind {\n     Enum,\n     Function,\n@@ -2520,7 +2519,6 @@ pub enum TypeKind {\n     Struct,\n     Union,\n     Trait,\n-    Variant,\n     Typedef,\n     Foreign,\n     Macro,\n@@ -3190,7 +3188,7 @@ impl Clean<Item> for ty::FieldDef {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcDecodable, RustcEncodable, Debug)]\n+#[derive(Clone, PartialEq, Eq, Debug)]\n pub enum Visibility {\n     Public,\n     Inherited,\n@@ -3219,15 +3217,15 @@ impl Clean<Option<Visibility>> for ty::Visibility {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Debug)]\n pub struct Struct {\n     pub struct_type: doctree::StructType,\n     pub generics: Generics,\n     pub fields: Vec<Item>,\n     pub fields_stripped: bool,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Debug)]\n pub struct Union {\n     pub struct_type: doctree::StructType,\n     pub generics: Generics,\n@@ -3278,7 +3276,7 @@ impl Clean<Item> for doctree::Union<'_> {\n /// This is a more limited form of the standard Struct, different in that\n /// it lacks the things most items have (name, id, parameterization). Found\n /// only as a variant in an enum.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Debug)]\n pub struct VariantStruct {\n     pub struct_type: doctree::StructType,\n     pub fields: Vec<Item>,\n@@ -3295,7 +3293,7 @@ impl Clean<VariantStruct> for ::rustc::hir::VariantData {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Debug)]\n pub struct Enum {\n     pub variants: IndexVec<VariantIdx, Item>,\n     pub generics: Generics,\n@@ -3321,7 +3319,7 @@ impl Clean<Item> for doctree::Enum<'_> {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Debug)]\n pub struct Variant {\n     pub kind: VariantKind,\n }\n@@ -3384,7 +3382,7 @@ impl Clean<Item> for ty::VariantDef {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Debug)]\n pub enum VariantKind {\n     CLike,\n     Tuple(Vec<Type>),\n@@ -3402,7 +3400,7 @@ impl Clean<VariantKind> for hir::VariantData {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Debug)]\n pub struct Span {\n     pub filename: FileName,\n     pub loline: usize,\n@@ -3448,7 +3446,7 @@ impl Clean<Span> for syntax_pos::Span {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Hash)]\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub struct Path {\n     pub global: bool,\n     pub res: Res,\n@@ -3471,7 +3469,7 @@ impl Clean<Path> for hir::Path {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Hash)]\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub enum GenericArg {\n     Lifetime(Lifetime),\n     Type(Type),\n@@ -3488,7 +3486,7 @@ impl fmt::Display for GenericArg {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Hash)]\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub enum GenericArgs {\n     AngleBracketed {\n         args: Vec<GenericArg>,\n@@ -3528,7 +3526,7 @@ impl Clean<GenericArgs> for hir::GenericArgs {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Hash)]\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub struct PathSegment {\n     pub name: String,\n     pub args: GenericArgs,\n@@ -3553,7 +3551,6 @@ fn strip_type(ty: Type) -> Type {\n         }\n         Type::Slice(inner_ty) => Type::Slice(Box::new(strip_type(*inner_ty))),\n         Type::Array(inner_ty, s) => Type::Array(Box::new(strip_type(*inner_ty)), s),\n-        Type::Unique(inner_ty) => Type::Unique(Box::new(strip_type(*inner_ty))),\n         Type::RawPointer(m, inner_ty) => Type::RawPointer(m, Box::new(strip_type(*inner_ty))),\n         Type::BorrowedRef { lifetime, mutability, type_ } => {\n             Type::BorrowedRef { lifetime, mutability, type_: Box::new(strip_type(*type_)) }\n@@ -3625,7 +3622,7 @@ impl Clean<String> for InternedString {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Debug)]\n pub struct Typedef {\n     pub type_: Type,\n     pub generics: Generics,\n@@ -3649,7 +3646,7 @@ impl Clean<Item> for doctree::Typedef<'_> {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Debug)]\n pub struct Existential {\n     pub bounds: Vec<GenericBound>,\n     pub generics: Generics,\n@@ -3673,7 +3670,7 @@ impl Clean<Item> for doctree::Existential<'_> {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Hash)]\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub struct BareFunctionDecl {\n     pub unsafety: hir::Unsafety,\n     pub generic_params: Vec<GenericParamDef>,\n@@ -3695,7 +3692,7 @@ impl Clean<BareFunctionDecl> for hir::BareFnTy {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Debug)]\n pub struct Static {\n     pub type_: Type,\n     pub mutability: Mutability,\n@@ -3725,7 +3722,7 @@ impl Clean<Item> for doctree::Static<'_> {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub struct Constant {\n     pub type_: Type,\n     pub expr: String,\n@@ -3749,7 +3746,7 @@ impl Clean<Item> for doctree::Constant<'_> {\n     }\n }\n \n-#[derive(Debug, Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Copy, Hash)]\n+#[derive(Debug, Clone, PartialEq, Eq, Copy, Hash)]\n pub enum Mutability {\n     Mutable,\n     Immutable,\n@@ -3764,7 +3761,7 @@ impl Clean<Mutability> for hir::Mutability {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Copy, Debug, Hash)]\n+#[derive(Clone, PartialEq, Eq, Copy, Debug, Hash)]\n pub enum ImplPolarity {\n     Positive,\n     Negative,\n@@ -3779,7 +3776,7 @@ impl Clean<ImplPolarity> for hir::ImplPolarity {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Debug)]\n pub struct Impl {\n     pub unsafety: hir::Unsafety,\n     pub generics: Generics,\n@@ -4003,15 +4000,15 @@ impl Clean<Vec<Item>> for doctree::Import<'_> {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Debug)]\n pub enum Import {\n     // use source as str;\n     Simple(String, ImportSource),\n     // use source::*;\n     Glob(ImportSource)\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Debug)]\n pub struct ImportSource {\n     pub path: Path,\n     pub did: Option<DefId>,\n@@ -4227,7 +4224,7 @@ fn resolve_use_source(cx: &DocContext<'_>, path: Path) -> ImportSource {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Debug)]\n pub struct Macro {\n     pub source: String,\n     pub imported_from: Option<String>,\n@@ -4256,7 +4253,7 @@ impl Clean<Item> for doctree::Macro<'_> {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Debug)]\n pub struct ProcMacro {\n     pub kind: MacroKind,\n     pub helpers: Vec<String>,\n@@ -4280,7 +4277,7 @@ impl Clean<Item> for doctree::ProcMacro<'_> {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Debug)]\n pub struct Stability {\n     pub level: stability::StabilityLevel,\n     pub feature: Option<String>,\n@@ -4290,7 +4287,7 @@ pub struct Stability {\n     pub issue: Option<u32>,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Debug)]\n pub struct Deprecation {\n     pub since: Option<String>,\n     pub note: Option<String>,\n@@ -4340,13 +4337,13 @@ impl Clean<Deprecation> for attr::Deprecation {\n \n /// An type binding on an associated type (e.g., `A = Bar` in `Foo<A = Bar>` or\n /// `A: Send + Sync` in `Foo<A: Send + Sync>`).\n-#[derive(Clone, PartialEq, Eq, RustcDecodable, RustcEncodable, Debug, Hash)]\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub struct TypeBinding {\n     pub name: String,\n     pub kind: TypeBindingKind,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcDecodable, RustcEncodable, Debug, Hash)]\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub enum TypeBindingKind {\n     Equality {\n         ty: Type,\n@@ -4411,7 +4408,7 @@ pub fn enter_impl_trait<F, R>(cx: &DocContext<'_>, f: F) -> R\n where\n     F: FnOnce() -> R,\n {\n-    let old_bounds = mem::replace(&mut *cx.impl_trait_bounds.borrow_mut(), Default::default());\n+    let old_bounds = mem::take(&mut *cx.impl_trait_bounds.borrow_mut());\n     let r = f();\n     assert!(cx.impl_trait_bounds.borrow().is_empty());\n     *cx.impl_trait_bounds.borrow_mut() = old_bounds;"}, {"sha": "e4fba73b8205a21c1c9e8f242092d1f88fd55d6c", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -131,7 +131,7 @@ pub fn ty_params(mut params: Vec<clean::GenericParamDef>) -> Vec<clean::GenericP\n     for param in &mut params {\n         match param.kind {\n             clean::GenericParamDefKind::Type { ref mut bounds, .. } => {\n-                *bounds = ty_bounds(mem::replace(bounds, Vec::new()));\n+                *bounds = ty_bounds(mem::take(bounds));\n             }\n             _ => panic!(\"expected only type parameters\"),\n         }"}, {"sha": "67ca7f407d80164735e2b323444b44db8323a0c4", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -351,9 +351,6 @@ impl Options {\n                             .unwrap_or_else(|| PathBuf::from(\"doc\"));\n         let mut cfgs = matches.opt_strs(\"cfg\");\n         cfgs.push(\"rustdoc\".to_string());\n-        if should_test {\n-            cfgs.push(\"test\".to_string());\n-        }\n \n         let extension_css = matches.opt_str(\"e\").map(|s| PathBuf::from(&s));\n "}, {"sha": "45a3c8a3c2256ae20eb1e17ced42d1997a612527", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -6,11 +6,11 @@ use syntax::ast;\n use syntax::ast::{Name, NodeId};\n use syntax::attr;\n use syntax::ext::base::MacroKind;\n-use syntax::ptr::P;\n use syntax_pos::{self, Span};\n \n use rustc::hir;\n use rustc::hir::def_id::CrateNum;\n+use rustc::hir::ptr::P;\n \n pub struct Module<'hir> {\n     pub name: Option<Name>,\n@@ -78,7 +78,7 @@ impl Module<'hir> {\n     }\n }\n \n-#[derive(Debug, Clone, RustcEncodable, RustcDecodable, Copy)]\n+#[derive(Debug, Clone, Copy)]\n pub enum StructType {\n     /// A braced struct\n     Plain,"}, {"sha": "9e5cc03b8312323f01505e4371c1e80b8a959474", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -737,9 +737,6 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter<'_>, use_absolute: bool) ->\n                 }\n             }\n         }\n-        clean::Unique(..) => {\n-            panic!(\"should have been cleaned\")\n-        }\n     }\n }\n "}, {"sha": "5f1a1b31616c1f0869bac051fac1206247021e1c", "filename": "src/librustdoc/html/item_type.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -110,7 +110,6 @@ impl From<clean::TypeKind> for ItemType {\n             clean::TypeKind::Module     => ItemType::Module,\n             clean::TypeKind::Static     => ItemType::Static,\n             clean::TypeKind::Const      => ItemType::Constant,\n-            clean::TypeKind::Variant    => ItemType::Variant,\n             clean::TypeKind::Typedef    => ItemType::Typedef,\n             clean::TypeKind::Foreign    => ItemType::ForeignType,\n             clean::TypeKind::Macro      => ItemType::Macro,"}, {"sha": "2d6503c944560d313beb2775d8fec3feb743e875", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -660,7 +660,7 @@ pub fn run(mut krate: clean::Crate,\n         deref_trait_did,\n         deref_mut_trait_did,\n         owned_box_did,\n-        masked_crates: mem::replace(&mut krate.masked_crates, Default::default()),\n+        masked_crates: mem::take(&mut krate.masked_crates),\n         param_names: external_param_names,\n         aliases: Default::default(),\n     };\n@@ -5188,9 +5188,6 @@ fn collect_paths_for_type(first_ty: clean::Type) -> Vec<String> {\n             clean::Type::Array(ty, _) => {\n                 work.push_back(*ty);\n             },\n-            clean::Type::Unique(ty) => {\n-                work.push_back(*ty);\n-            },\n             clean::Type::RawPointer(_, ty) => {\n                 work.push_back(*ty);\n             },"}, {"sha": "342264db43c792946f48db921e75a46d6a53e406", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -21,6 +21,7 @@\n #![feature(drain_filter)]\n #![feature(inner_deref)]\n #![feature(never_type)]\n+#![feature(mem_take)]\n \n #![recursion_limit=\"256\"]\n \n@@ -42,8 +43,6 @@ extern crate test as testing;\n #[macro_use] extern crate log;\n extern crate rustc_errors as errors;\n \n-extern crate serialize as rustc_serialize; // used by deriving\n-\n use std::default::Default;\n use std::env;\n use std::panic;"}, {"sha": "144ff226c4283c619090d8a8f1deedbf613f2fd6", "filename": "src/librustdoc/passes/collapse_docs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustdoc%2Fpasses%2Fcollapse_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustdoc%2Fpasses%2Fcollapse_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollapse_docs.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -4,7 +4,7 @@ use crate::fold;\n use crate::fold::{DocFolder};\n use crate::passes::Pass;\n \n-use std::mem::replace;\n+use std::mem::take;\n \n pub const COLLAPSE_DOCS: Pass = Pass {\n     name: \"collapse-docs\",\n@@ -46,7 +46,7 @@ fn collapse(doc_strings: &mut Vec<DocFragment>) {\n     let mut docs = vec![];\n     let mut last_frag: Option<DocFragment> = None;\n \n-    for frag in replace(doc_strings, vec![]) {\n+    for frag in take(doc_strings) {\n         if let Some(mut curr_frag) = last_frag.take() {\n             let curr_kind = curr_frag.kind();\n             let new_kind = frag.kind();"}, {"sha": "63545ab45bf64fbb3da8b1689d08fe8f0d94a477", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -44,8 +44,7 @@ pub fn run(options: Options) -> i32 {\n     let input = config::Input::File(options.input.clone());\n \n     let sessopts = config::Options {\n-        maybe_sysroot: options.maybe_sysroot.clone().or_else(\n-            || Some(env::current_exe().unwrap().parent().unwrap().parent().unwrap().to_path_buf())),\n+        maybe_sysroot: options.maybe_sysroot.clone(),\n         search_paths: options.libs.clone(),\n         crate_types: vec![config::CrateType::Dylib],\n         cg: options.codegen_options.clone(),\n@@ -225,8 +224,7 @@ fn run_test(\n     let outputs = OutputTypes::new(&[(OutputType::Exe, None)]);\n \n     let sessopts = config::Options {\n-        maybe_sysroot: maybe_sysroot.or_else(\n-            || Some(env::current_exe().unwrap().parent().unwrap().parent().unwrap().to_path_buf())),\n+        maybe_sysroot,\n         search_paths: libs,\n         crate_types: vec![config::CrateType::Executable],\n         output_types: outputs,\n@@ -530,13 +528,8 @@ pub fn make_test(s: &str,\n         prog.push_str(everything_else);\n     } else {\n         let returns_result = everything_else.trim_end().ends_with(\"(())\");\n-        let returns_option = everything_else.trim_end().ends_with(\"Some(())\");\n         let (main_pre, main_post) = if returns_result {\n-            (if returns_option {\n-                \"fn main() { fn _inner() -> Option<()> {\"\n-            } else {\n-                \"fn main() { fn _inner() -> Result<(), impl core::fmt::Debug> {\"\n-            },\n+            (\"fn main() { fn _inner() -> Result<(), impl core::fmt::Debug> {\",\n              \"}\\n_inner().unwrap() }\")\n         } else {\n             (\"fn main() {\\n\", \"\\n}\")"}, {"sha": "2925d8362c8d9a9cd2a0a44c00668e91da42d3d6", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -2608,6 +2608,12 @@ mod test_map {\n     use realstd::collections::CollectionAllocErr::*;\n     use realstd::usize;\n \n+    // https://github.com/rust-lang/rust/issues/62301\n+    fn _assert_hashmap_is_unwind_safe() {\n+        fn assert_unwind_safe<T: crate::panic::UnwindSafe>() {}\n+        assert_unwind_safe::<HashMap<(), crate::cell::UnsafeCell<()>>>();\n+    }\n+\n     #[test]\n     fn test_zero_capacities() {\n         type HM = HashMap<i32, i32>;"}, {"sha": "fb9a228880eb7304d9484bce138313d6a9ec9c2d", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -272,6 +272,7 @@\n #![feature(libc)]\n #![feature(link_args)]\n #![feature(linkage)]\n+#![feature(mem_take)]\n #![feature(needs_panic_runtime)]\n #![feature(never_type)]\n #![feature(nll)]"}, {"sha": "1d4fd98dd754f2991846a5330f59263a1403b0d5", "filename": "src/libstd/panic.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibstd%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibstd%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanic.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -4,6 +4,7 @@\n \n use crate::any::Any;\n use crate::cell::UnsafeCell;\n+use crate::collections;\n use crate::fmt;\n use crate::future::Future;\n use crate::pin::Pin;\n@@ -285,6 +286,11 @@ impl RefUnwindSafe for atomic::AtomicBool {}\n #[stable(feature = \"unwind_safe_atomic_refs\", since = \"1.14.0\")]\n impl<T> RefUnwindSafe for atomic::AtomicPtr<T> {}\n \n+// https://github.com/rust-lang/rust/issues/62301\n+#[stable(feature = \"hashbrown\", since = \"1.36.0\")]\n+impl<K, V, S> UnwindSafe for collections::HashMap<K, V, S>\n+    where K: UnwindSafe, V: UnwindSafe, S: UnwindSafe {}\n+\n #[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n impl<T> Deref for AssertUnwindSafe<T> {\n     type Target = T;"}, {"sha": "952fd9ebfdf0723d20494c6bd683ed537bdc4f76", "filename": "src/libstd/panicking.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibstd%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibstd%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanicking.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -103,7 +103,9 @@ pub fn set_hook(hook: Box<dyn Fn(&PanicInfo<'_>) + 'static + Sync + Send>) {\n         HOOK_LOCK.write_unlock();\n \n         if let Hook::Custom(ptr) = old_hook {\n-            Box::from_raw(ptr);\n+            #[allow(unused_must_use)] {\n+                Box::from_raw(ptr);\n+            }\n         }\n     }\n }\n@@ -362,7 +364,7 @@ fn continue_panic_fmt(info: &PanicInfo<'_>) -> ! {\n \n     unsafe impl<'a> BoxMeUp for PanicPayload<'a> {\n         fn box_me_up(&mut self) -> *mut (dyn Any + Send) {\n-            let contents = mem::replace(self.fill(), String::new());\n+            let contents = mem::take(self.fill());\n             Box::into_raw(Box::new(contents))\n         }\n "}, {"sha": "000f80f99e7a9bb861b3ffde10defa09355e8c1a", "filename": "src/libstd/process.rs", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -1765,33 +1765,6 @@ mod tests {\n         assert_eq!(out, \"foobar\\n\");\n     }\n \n-\n-    #[test]\n-    #[cfg_attr(target_os = \"android\", ignore)]\n-    #[cfg(unix)]\n-    fn uid_works() {\n-        use crate::os::unix::prelude::*;\n-\n-        let mut p = Command::new(\"/bin/sh\")\n-                            .arg(\"-c\").arg(\"true\")\n-                            .uid(unsafe { libc::getuid() })\n-                            .gid(unsafe { libc::getgid() })\n-                            .spawn().unwrap();\n-        assert!(p.wait().unwrap().success());\n-    }\n-\n-    #[test]\n-    #[cfg_attr(target_os = \"android\", ignore)]\n-    #[cfg(unix)]\n-    fn uid_to_root_fails() {\n-        use crate::os::unix::prelude::*;\n-\n-        // if we're already root, this isn't a valid test. Most of the bots run\n-        // as non-root though (android is an exception).\n-        if unsafe { libc::getuid() == 0 } { return }\n-        assert!(Command::new(\"/bin/ls\").uid(0).gid(0).spawn().is_err());\n-    }\n-\n     #[test]\n     #[cfg_attr(target_os = \"android\", ignore)]\n     fn test_process_status() {"}, {"sha": "f8fcd3ff5a5bccb5b07cabfb3e1d627af13cb224", "filename": "src/libstd/sync/mpsc/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -383,7 +383,7 @@ impl<T> Packet<T> {\n         // needs to be careful to destroy the data *outside* of the lock to\n         // prevent deadlock.\n         let _data = if guard.cap != 0 {\n-            mem::replace(&mut guard.buf.buf, Vec::new())\n+            mem::take(&mut guard.buf.buf)\n         } else {\n             Vec::new()\n         };"}, {"sha": "4201de794b70835406a05713122b0816d5e584ea", "filename": "src/libstd/sys/unix/condvar.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -40,15 +40,15 @@ impl Condvar {\n                   target_os = \"android\",\n                   target_os = \"hermit\")))]\n     pub unsafe fn init(&mut self) {\n-        use crate::mem;\n-        let mut attr: libc::pthread_condattr_t = mem::uninitialized();\n-        let r = libc::pthread_condattr_init(&mut attr);\n+        use crate::mem::MaybeUninit;\n+        let mut attr = MaybeUninit::<libc::pthread_condattr_t>::uninit();\n+        let r = libc::pthread_condattr_init(attr.as_mut_ptr());\n         assert_eq!(r, 0);\n-        let r = libc::pthread_condattr_setclock(&mut attr, libc::CLOCK_MONOTONIC);\n+        let r = libc::pthread_condattr_setclock(attr.as_mut_ptr(), libc::CLOCK_MONOTONIC);\n         assert_eq!(r, 0);\n-        let r = libc::pthread_cond_init(self.inner.get(), &attr);\n+        let r = libc::pthread_cond_init(self.inner.get(), attr.as_ptr());\n         assert_eq!(r, 0);\n-        let r = libc::pthread_condattr_destroy(&mut attr);\n+        let r = libc::pthread_condattr_destroy(attr.as_mut_ptr());\n         assert_eq!(r, 0);\n     }\n "}, {"sha": "41090caee8459fea5e08e6ad9054379d9da08da3", "filename": "src/libstd/sys/unix/ext/net.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -40,10 +40,9 @@ use libc::MSG_NOSIGNAL;\n               target_os = \"haiku\")))]\n const MSG_NOSIGNAL: libc::c_int = 0x0;\n \n-fn sun_path_offset() -> usize {\n+fn sun_path_offset(addr: &libc::sockaddr_un) -> usize {\n     // Work with an actual instance of the type since using a null pointer is UB\n-    let addr: libc::sockaddr_un = unsafe { mem::uninitialized() };\n-    let base = &addr as *const _ as usize;\n+    let base = addr as *const _ as usize;\n     let path = &addr.sun_path as *const _ as usize;\n     path - base\n }\n@@ -69,7 +68,7 @@ unsafe fn sockaddr_un(path: &Path) -> io::Result<(libc::sockaddr_un, libc::sockl\n     // null byte for pathname addresses is already there because we zeroed the\n     // struct\n \n-    let mut len = sun_path_offset() + bytes.len();\n+    let mut len = sun_path_offset(&addr) + bytes.len();\n     match bytes.get(0) {\n         Some(&0) | None => {}\n         Some(_) => len += 1,\n@@ -122,7 +121,7 @@ impl SocketAddr {\n         if len == 0 {\n             // When there is a datagram from unnamed unix socket\n             // linux returns zero bytes of address\n-            len = sun_path_offset() as libc::socklen_t;  // i.e., zero-length address\n+            len = sun_path_offset(&addr) as libc::socklen_t;  // i.e., zero-length address\n         } else if addr.sun_family != libc::AF_UNIX as libc::sa_family_t {\n             return Err(io::Error::new(io::ErrorKind::InvalidInput,\n                                       \"file descriptor did not correspond to a Unix socket\"));\n@@ -200,7 +199,7 @@ impl SocketAddr {\n     }\n \n     fn address<'a>(&'a self) -> AddressKind<'a> {\n-        let len = self.len as usize - sun_path_offset();\n+        let len = self.len as usize - sun_path_offset(&self.addr);\n         let path = unsafe { mem::transmute::<&[libc::c_char], &[u8]>(&self.addr.sun_path) };\n \n         // macOS seems to return a len of 16 and a zeroed sun_path for unnamed addresses"}, {"sha": "b43af8fdcaaa12ed392c2b3679464772a53104e6", "filename": "src/libstd/sys/unix/mutex.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -1,5 +1,5 @@\n use crate::cell::UnsafeCell;\n-use crate::mem;\n+use crate::mem::MaybeUninit;\n \n pub struct Mutex { inner: UnsafeCell<libc::pthread_mutex_t> }\n \n@@ -40,14 +40,14 @@ impl Mutex {\n         // references, we instead create the mutex with type\n         // PTHREAD_MUTEX_NORMAL which is guaranteed to deadlock if we try to\n         // re-lock it from the same thread, thus avoiding undefined behavior.\n-        let mut attr: libc::pthread_mutexattr_t = mem::uninitialized();\n-        let r = libc::pthread_mutexattr_init(&mut attr);\n+        let mut attr = MaybeUninit::<libc::pthread_mutexattr_t>::uninit();\n+        let r = libc::pthread_mutexattr_init(attr.as_mut_ptr());\n         debug_assert_eq!(r, 0);\n-        let r = libc::pthread_mutexattr_settype(&mut attr, libc::PTHREAD_MUTEX_NORMAL);\n+        let r = libc::pthread_mutexattr_settype(attr.as_mut_ptr(), libc::PTHREAD_MUTEX_NORMAL);\n         debug_assert_eq!(r, 0);\n-        let r = libc::pthread_mutex_init(self.inner.get(), &attr);\n+        let r = libc::pthread_mutex_init(self.inner.get(), attr.as_ptr());\n         debug_assert_eq!(r, 0);\n-        let r = libc::pthread_mutexattr_destroy(&mut attr);\n+        let r = libc::pthread_mutexattr_destroy(attr.as_mut_ptr());\n         debug_assert_eq!(r, 0);\n     }\n     #[inline]\n@@ -89,19 +89,19 @@ unsafe impl Sync for ReentrantMutex {}\n \n impl ReentrantMutex {\n     pub unsafe fn uninitialized() -> ReentrantMutex {\n-        ReentrantMutex { inner: mem::uninitialized() }\n+        ReentrantMutex { inner: UnsafeCell::new(libc::PTHREAD_MUTEX_INITIALIZER) }\n     }\n \n     pub unsafe fn init(&mut self) {\n-        let mut attr: libc::pthread_mutexattr_t = mem::uninitialized();\n-        let result = libc::pthread_mutexattr_init(&mut attr as *mut _);\n+        let mut attr = MaybeUninit::<libc::pthread_mutexattr_t>::uninit();\n+        let result = libc::pthread_mutexattr_init(attr.as_mut_ptr());\n         debug_assert_eq!(result, 0);\n-        let result = libc::pthread_mutexattr_settype(&mut attr as *mut _,\n+        let result = libc::pthread_mutexattr_settype(attr.as_mut_ptr(),\n                                                     libc::PTHREAD_MUTEX_RECURSIVE);\n         debug_assert_eq!(result, 0);\n-        let result = libc::pthread_mutex_init(self.inner.get(), &attr as *const _);\n+        let result = libc::pthread_mutex_init(self.inner.get(), attr.as_ptr());\n         debug_assert_eq!(result, 0);\n-        let result = libc::pthread_mutexattr_destroy(&mut attr as *mut _);\n+        let result = libc::pthread_mutexattr_destroy(attr.as_mut_ptr());\n         debug_assert_eq!(result, 0);\n     }\n "}, {"sha": "3ff4f194cd1a913451cfa89f4e1514de05b83c46", "filename": "src/libstd/sys/unix/process/process_common.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -437,7 +437,7 @@ mod tests {\n \n     #[cfg(target_os = \"android\")]\n     unsafe fn sigemptyset(set: *mut libc::sigset_t) -> libc::c_int {\n-        libc::memset(set as *mut _, 0, mem::size_of::<libc::sigset_t>());\n+        set.write_bytes(0u8, 1);\n         return 0;\n     }\n \n@@ -466,11 +466,11 @@ mod tests {\n             // Test to make sure that a signal mask does not get inherited.\n             let mut cmd = Command::new(OsStr::new(\"cat\"));\n \n-            let mut set: libc::sigset_t = mem::uninitialized();\n-            let mut old_set: libc::sigset_t = mem::uninitialized();\n-            t!(cvt(sigemptyset(&mut set)));\n-            t!(cvt(sigaddset(&mut set, libc::SIGINT)));\n-            t!(cvt(libc::pthread_sigmask(libc::SIG_SETMASK, &set, &mut old_set)));\n+            let mut set = mem::MaybeUninit::<libc::sigset_t>::uninit();\n+            let mut old_set = mem::MaybeUninit::<libc::sigset_t>::uninit();\n+            t!(cvt(sigemptyset(set.as_mut_ptr())));\n+            t!(cvt(sigaddset(set.as_mut_ptr(), libc::SIGINT)));\n+            t!(cvt(libc::pthread_sigmask(libc::SIG_SETMASK, set.as_ptr(), old_set.as_mut_ptr())));\n \n             cmd.stdin(Stdio::MakePipe);\n             cmd.stdout(Stdio::MakePipe);\n@@ -479,7 +479,7 @@ mod tests {\n             let stdin_write = pipes.stdin.take().unwrap();\n             let stdout_read = pipes.stdout.take().unwrap();\n \n-            t!(cvt(libc::pthread_sigmask(libc::SIG_SETMASK, &old_set,\n+            t!(cvt(libc::pthread_sigmask(libc::SIG_SETMASK, old_set.as_ptr(),\n                                          ptr::null_mut())));\n \n             t!(cvt(libc::kill(cat.id() as libc::pid_t, libc::SIGINT)));"}, {"sha": "be38a1334ec32acfa25690b7f9c7f01e39f1e9c6", "filename": "src/libstd/sys/unix/process/process_unix.rs", "status": "modified", "additions": 28, "deletions": 30, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -202,26 +202,24 @@ impl Command {\n         // emscripten has no signal support.\n         #[cfg(not(any(target_os = \"emscripten\")))]\n         {\n-            use crate::mem;\n+            use crate::mem::MaybeUninit;\n             // Reset signal handling so the child process starts in a\n             // standardized state. libstd ignores SIGPIPE, and signal-handling\n             // libraries often set a mask. Child processes inherit ignored\n             // signals and the signal mask from their parent, but most\n             // UNIX programs do not reset these things on their own, so we\n             // need to clean things up now to avoid confusing the program\n             // we're about to run.\n-            let mut set: libc::sigset_t = mem::uninitialized();\n+            let mut set = MaybeUninit::<libc::sigset_t>::uninit();\n             if cfg!(target_os = \"android\") {\n                 // Implementing sigemptyset allow us to support older Android\n                 // versions. See the comment about Android and sig* functions in\n                 // process_common.rs\n-                libc::memset(&mut set as *mut _ as *mut _,\n-                             0,\n-                             mem::size_of::<libc::sigset_t>());\n+                set.as_mut_ptr().write_bytes(0u8, 1);\n             } else {\n-                cvt(libc::sigemptyset(&mut set))?;\n+                cvt(libc::sigemptyset(set.as_mut_ptr()))?;\n             }\n-            cvt(libc::pthread_sigmask(libc::SIG_SETMASK, &set,\n+            cvt(libc::pthread_sigmask(libc::SIG_SETMASK, set.as_ptr(),\n                                          ptr::null_mut()))?;\n             let ret = sys::signal(libc::SIGPIPE, libc::SIG_DFL);\n             if ret == libc::SIG_ERR {\n@@ -273,7 +271,7 @@ impl Command {\n     fn posix_spawn(&mut self, stdio: &ChildPipes, envp: Option<&CStringArray>)\n         -> io::Result<Option<Process>>\n     {\n-        use crate::mem;\n+        use crate::mem::MaybeUninit;\n         use crate::sys;\n \n         if self.get_gid().is_some() ||\n@@ -315,63 +313,63 @@ impl Command {\n \n         let mut p = Process { pid: 0, status: None };\n \n-        struct PosixSpawnFileActions(libc::posix_spawn_file_actions_t);\n+        struct PosixSpawnFileActions(MaybeUninit<libc::posix_spawn_file_actions_t>);\n \n         impl Drop for PosixSpawnFileActions {\n             fn drop(&mut self) {\n                 unsafe {\n-                    libc::posix_spawn_file_actions_destroy(&mut self.0);\n+                    libc::posix_spawn_file_actions_destroy(self.0.as_mut_ptr());\n                 }\n             }\n         }\n \n-        struct PosixSpawnattr(libc::posix_spawnattr_t);\n+        struct PosixSpawnattr(MaybeUninit<libc::posix_spawnattr_t>);\n \n         impl Drop for PosixSpawnattr {\n             fn drop(&mut self) {\n                 unsafe {\n-                    libc::posix_spawnattr_destroy(&mut self.0);\n+                    libc::posix_spawnattr_destroy(self.0.as_mut_ptr());\n                 }\n             }\n         }\n \n         unsafe {\n-            let mut file_actions = PosixSpawnFileActions(mem::uninitialized());\n-            let mut attrs = PosixSpawnattr(mem::uninitialized());\n+            let mut file_actions = PosixSpawnFileActions(MaybeUninit::uninit());\n+            let mut attrs = PosixSpawnattr(MaybeUninit::uninit());\n \n-            libc::posix_spawnattr_init(&mut attrs.0);\n-            libc::posix_spawn_file_actions_init(&mut file_actions.0);\n+            libc::posix_spawnattr_init(attrs.0.as_mut_ptr());\n+            libc::posix_spawn_file_actions_init(file_actions.0.as_mut_ptr());\n \n             if let Some(fd) = stdio.stdin.fd() {\n-                cvt(libc::posix_spawn_file_actions_adddup2(&mut file_actions.0,\n+                cvt(libc::posix_spawn_file_actions_adddup2(file_actions.0.as_mut_ptr(),\n                                                            fd,\n                                                            libc::STDIN_FILENO))?;\n             }\n             if let Some(fd) = stdio.stdout.fd() {\n-                cvt(libc::posix_spawn_file_actions_adddup2(&mut file_actions.0,\n+                cvt(libc::posix_spawn_file_actions_adddup2(file_actions.0.as_mut_ptr(),\n                                                            fd,\n                                                            libc::STDOUT_FILENO))?;\n             }\n             if let Some(fd) = stdio.stderr.fd() {\n-                cvt(libc::posix_spawn_file_actions_adddup2(&mut file_actions.0,\n+                cvt(libc::posix_spawn_file_actions_adddup2(file_actions.0.as_mut_ptr(),\n                                                            fd,\n                                                            libc::STDERR_FILENO))?;\n             }\n             if let Some((f, cwd)) = addchdir {\n-                cvt(f(&mut file_actions.0, cwd.as_ptr()))?;\n+                cvt(f(file_actions.0.as_mut_ptr(), cwd.as_ptr()))?;\n             }\n \n-            let mut set: libc::sigset_t = mem::uninitialized();\n-            cvt(libc::sigemptyset(&mut set))?;\n-            cvt(libc::posix_spawnattr_setsigmask(&mut attrs.0,\n-                                                 &set))?;\n-            cvt(libc::sigaddset(&mut set, libc::SIGPIPE))?;\n-            cvt(libc::posix_spawnattr_setsigdefault(&mut attrs.0,\n-                                                    &set))?;\n+            let mut set = MaybeUninit::<libc::sigset_t>::uninit();\n+            cvt(libc::sigemptyset(set.as_mut_ptr()))?;\n+            cvt(libc::posix_spawnattr_setsigmask(attrs.0.as_mut_ptr(),\n+                                                 set.as_ptr()))?;\n+            cvt(libc::sigaddset(set.as_mut_ptr(), libc::SIGPIPE))?;\n+            cvt(libc::posix_spawnattr_setsigdefault(attrs.0.as_mut_ptr(),\n+                                                    set.as_ptr()))?;\n \n             let flags = libc::POSIX_SPAWN_SETSIGDEF |\n                 libc::POSIX_SPAWN_SETSIGMASK;\n-            cvt(libc::posix_spawnattr_setflags(&mut attrs.0, flags as _))?;\n+            cvt(libc::posix_spawnattr_setflags(attrs.0.as_mut_ptr(), flags as _))?;\n \n             // Make sure we synchronize access to the global `environ` resource\n             let _env_lock = sys::os::env_lock();\n@@ -380,8 +378,8 @@ impl Command {\n             let ret = libc::posix_spawnp(\n                 &mut p.pid,\n                 self.get_argv()[0],\n-                &file_actions.0,\n-                &attrs.0,\n+                file_actions.0.as_ptr(),\n+                attrs.0.as_ptr(),\n                 self.get_argv().as_ptr() as *const _,\n                 envp as *const _,\n             );"}, {"sha": "c77f30dfc7109cbd1d9f1c9287d216c6463210b4", "filename": "src/libstd/sys/windows/pipe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -342,7 +342,7 @@ impl<'a> Drop for AsyncPipe<'a> {\n         // If anything here fails, there's not really much we can do, so we leak\n         // the buffer/OVERLAPPED pointers to ensure we're at least memory safe.\n         if self.pipe.cancel_io().is_err() || self.result().is_err() {\n-            let buf = mem::replace(self.dst, Vec::new());\n+            let buf = mem::take(self.dst);\n             let overlapped = Box::new(unsafe { mem::zeroed() });\n             let overlapped = mem::replace(&mut self.overlapped, overlapped);\n             mem::forget((buf, overlapped));"}, {"sha": "453b6ebf3c49d5c2f60f2030057b95482108f553", "filename": "src/libsyntax/attr/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibsyntax%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibsyntax%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fmod.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -440,12 +440,12 @@ pub fn contains_name(attrs: &[Attribute], name: Symbol) -> bool {\n     })\n }\n \n-pub fn find_by_name<'a>(attrs: &'a [Attribute], name: Symbol) -> Option<&'a Attribute> {\n+pub fn find_by_name(attrs: &[Attribute], name: Symbol) -> Option<&Attribute> {\n     attrs.iter().find(|attr| attr.check_name(name))\n }\n \n-pub fn filter_by_name<'a>(attrs: &'a [Attribute], name: Symbol)\n-    -> impl Iterator<Item = &'a Attribute> {\n+pub fn filter_by_name(attrs: &[Attribute], name: Symbol)\n+                      -> impl Iterator<Item=&Attribute> {\n     attrs.iter().filter(move |attr| attr.check_name(name))\n }\n "}, {"sha": "c71fa61443c4360243196973997ac32a30db2d13", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 13, "deletions": 34, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -13,8 +13,7 @@ use crate::parse::{DirectoryOwnership, PResult, ParseSess};\n use crate::parse::token;\n use crate::parse::parser::Parser;\n use crate::ptr::P;\n-use crate::symbol::Symbol;\n-use crate::symbol::{kw, sym};\n+use crate::symbol::{sym, Symbol};\n use crate::tokenstream::{TokenStream, TokenTree};\n use crate::visit::{self, Visitor};\n use crate::util::map_in_place::MapInPlace;\n@@ -197,7 +196,6 @@ pub struct Invocation {\n pub enum InvocationKind {\n     Bang {\n         mac: ast::Mac,\n-        ident: Option<Ident>,\n         span: Span,\n     },\n     Attr {\n@@ -307,7 +305,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             } else {\n                 self.resolve_imports();\n                 if undetermined_invocations.is_empty() { break }\n-                invocations = mem::replace(&mut undetermined_invocations, Vec::new());\n+                invocations = mem::take(&mut undetermined_invocations);\n                 force = !mem::replace(&mut progress, false);\n                 continue\n             };\n@@ -664,13 +662,12 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                          ext: &SyntaxExtension)\n                          -> Option<AstFragment> {\n         let kind = invoc.fragment_kind;\n-        let (mac, ident, span) = match invoc.kind {\n-            InvocationKind::Bang { mac, ident, span } => (mac, ident, span),\n+        let (mac, span) = match invoc.kind {\n+            InvocationKind::Bang { mac, span } => (mac, span),\n             _ => unreachable!(),\n         };\n         let path = &mac.node.path;\n \n-        let ident = ident.unwrap_or_else(|| Ident::invalid());\n         let validate = |this: &mut Self| {\n             // feature-gate the macro invocation\n             if let Some((feature, issue)) = ext.unstable_feature {\n@@ -690,12 +687,6 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 }\n             }\n \n-            if ident.name != kw::Invalid {\n-                let msg = format!(\"macro {}! expects no ident argument, given '{}'\", path, ident);\n-                this.cx.span_err(path.span, &msg);\n-                this.cx.trace_macros_diag();\n-                return Err(kind.dummy(span));\n-            }\n             Ok(())\n         };\n \n@@ -729,19 +720,11 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             }\n \n             SyntaxExtensionKind::Bang(expander) => {\n-                if ident.name != kw::Invalid {\n-                    let msg =\n-                        format!(\"macro {}! expects no ident argument, given '{}'\", path, ident);\n-                    self.cx.span_err(path.span, &msg);\n-                    self.cx.trace_macros_diag();\n-                    kind.dummy(span)\n-                } else {\n-                    self.gate_proc_macro_expansion_kind(span, kind);\n-                    let tok_result = expander.expand(self.cx, span, mac.node.stream());\n-                    let result = self.parse_ast_fragment(tok_result, kind, path, span);\n-                    self.gate_proc_macro_expansion(span, &result);\n-                    result\n-                }\n+                self.gate_proc_macro_expansion_kind(span, kind);\n+                let tok_result = expander.expand(self.cx, span, mac.node.stream());\n+                let result = self.parse_ast_fragment(tok_result, kind, path, span);\n+                self.gate_proc_macro_expansion(span, &result);\n+                result\n             }\n         };\n \n@@ -944,7 +927,7 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n     }\n \n     fn collect_bang(&mut self, mac: ast::Mac, span: Span, kind: AstFragmentKind) -> AstFragment {\n-        self.collect(kind, InvocationKind::Bang { mac, ident: None, span })\n+        self.collect(kind, InvocationKind::Bang { mac, span })\n     }\n \n     fn collect_attr(&mut self,\n@@ -1179,13 +1162,9 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n             ast::ItemKind::Mac(..) => {\n                 self.check_attributes(&item.attrs);\n                 item.and_then(|item| match item.node {\n-                    ItemKind::Mac(mac) => {\n-                        self.collect(AstFragmentKind::Items, InvocationKind::Bang {\n-                            mac,\n-                            ident: Some(item.ident),\n-                            span: item.span,\n-                        }).make_items()\n-                    }\n+                    ItemKind::Mac(mac) => self.collect(\n+                        AstFragmentKind::Items, InvocationKind::Bang { mac, span: item.span }\n+                    ).make_items(),\n                     _ => unreachable!(),\n                 })\n             }"}, {"sha": "fc8aa4793bc6111eba60d007e077c69ac1d7be7c", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -901,7 +901,7 @@ fn may_begin_with(token: &Token, name: Name) -> bool {\n /// # Returns\n ///\n /// The parsed non-terminal.\n-fn parse_nt<'a>(p: &mut Parser<'a>, sp: Span, name: Symbol) -> Nonterminal {\n+fn parse_nt(p: &mut Parser<'_>, sp: Span, name: Symbol) -> Nonterminal {\n     if name == sym::tt {\n         return token::NtTT(p.parse_token_tree());\n     }"}, {"sha": "e04fd2ddc05bce62332409adbd00515ad3de7069", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e45bbaf48c9fb0439426967009d837f0fe4f74ce/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=e45bbaf48c9fb0439426967009d837f0fe4f74ce", "patch": "@@ -249,7 +249,7 @@ pub fn transcribe(\n             quoted::TokenTree::Delimited(mut span, delimited) => {\n                 span = span.apply_mark(cx.current_expansion.mark);\n                 stack.push(Frame::Delimited { forest: delimited, idx: 0, span });\n-                result_stack.push(mem::replace(&mut result, Vec::new()));\n+                result_stack.push(mem::take(&mut result));\n             }\n \n             // Nothing much to do here. Just push the token to the result, being careful to"}]}