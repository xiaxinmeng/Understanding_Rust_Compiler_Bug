{"sha": "b13a5bf3c4d66ce375f5978c2c2233f9714b721e", "node_id": "C_kwDOAAsO6NoAKGIxM2E1YmYzYzRkNjZjZTM3NWY1OTc4YzJjMjIzM2Y5NzE0YjcyMWU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-15T10:57:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-15T10:57:03Z"}, "message": "Auto merge of #92927 - matthiaskrgr:rollup-pgzwfcm, r=matthiaskrgr\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #92747 (Simplification of BigNum::bit_length)\n - #92767 (Use the new language identifier for Rust in the PDB debug format)\n - #92775 (Inline std::os::unix::ffi::OsStringExt methods)\n - #92863 (Remove `&mut` from `io::read_to_string` signature)\n - #92865 (Ignore static lifetimes for GATs outlives lint)\n - #92873 (Generate more precise generator names)\n - #92879 (Add Sync bound to allocator parameter in vec::IntoIter)\n - #92892 (Do not fail evaluation in const blocks)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "ff0a003ba0175b321403bff0885636893e33b818", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ff0a003ba0175b321403bff0885636893e33b818"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b13a5bf3c4d66ce375f5978c2c2233f9714b721e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b13a5bf3c4d66ce375f5978c2c2233f9714b721e", "html_url": "https://github.com/rust-lang/rust/commit/b13a5bf3c4d66ce375f5978c2c2233f9714b721e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b13a5bf3c4d66ce375f5978c2c2233f9714b721e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38c22af0153cf8f920c01ef04493e8878401fd18", "url": "https://api.github.com/repos/rust-lang/rust/commits/38c22af0153cf8f920c01ef04493e8878401fd18", "html_url": "https://github.com/rust-lang/rust/commit/38c22af0153cf8f920c01ef04493e8878401fd18"}, {"sha": "539175c026c70e32150ca8c5ed2e0bacd3bb12e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/539175c026c70e32150ca8c5ed2e0bacd3bb12e6", "html_url": "https://github.com/rust-lang/rust/commit/539175c026c70e32150ca8c5ed2e0bacd3bb12e6"}], "stats": {"total": 227, "additions": 157, "deletions": 70}, "files": [{"sha": "61322a6e556ed02cd418b28793035f0dc1b649ad", "filename": "compiler/rustc_codegen_ssa/src/debuginfo/type_names.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b13a5bf3c4d66ce375f5978c2c2233f9714b721e/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b13a5bf3c4d66ce375f5978c2c2233f9714b721e/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs?ref=b13a5bf3c4d66ce375f5978c2c2233f9714b721e", "patch": "@@ -519,12 +519,18 @@ fn push_unqualified_item_name(\n             output.push_str(tcx.crate_name(def_id.krate).as_str());\n         }\n         DefPathData::ClosureExpr if tcx.generator_kind(def_id).is_some() => {\n+            let key = match tcx.generator_kind(def_id).unwrap() {\n+                hir::GeneratorKind::Async(hir::AsyncGeneratorKind::Block) => \"async_block\",\n+                hir::GeneratorKind::Async(hir::AsyncGeneratorKind::Closure) => \"async_closure\",\n+                hir::GeneratorKind::Async(hir::AsyncGeneratorKind::Fn) => \"async_fn\",\n+                hir::GeneratorKind::Gen => \"generator\",\n+            };\n             // Generators look like closures, but we want to treat them differently\n             // in the debug info.\n             if cpp_like_debuginfo(tcx) {\n-                write!(output, \"generator${}\", disambiguated_data.disambiguator).unwrap();\n+                write!(output, \"{}${}\", key, disambiguated_data.disambiguator).unwrap();\n             } else {\n-                write!(output, \"{{generator#{}}}\", disambiguated_data.disambiguator).unwrap();\n+                write!(output, \"{{{}#{}}}\", key, disambiguated_data.disambiguator).unwrap();\n             }\n         }\n         _ => match disambiguated_data.data.name() {"}, {"sha": "faf3ef1e543c97d3beaf51c62b2fa770e9ee4f17", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b13a5bf3c4d66ce375f5978c2c2233f9714b721e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b13a5bf3c4d66ce375f5978c2c2233f9714b721e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=b13a5bf3c4d66ce375f5978c2c2233f9714b721e", "patch": "@@ -1226,7 +1226,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let body = self.tcx.hir().body(anon_const.body);\n \n         // Create a new function context.\n-        let fcx = FnCtxt::new(self, self.param_env, body.value.hir_id);\n+        let fcx = FnCtxt::new(self, self.param_env.with_const(), body.value.hir_id);\n         crate::check::GatherLocalsVisitor::new(&fcx).visit_body(body);\n \n         let ty = fcx.check_expr_with_expectation(&body.value, expected);"}, {"sha": "fbc446e3ea42e9cacd4c0ecd2019b04059f1658f", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 48, "deletions": 46, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/b13a5bf3c4d66ce375f5978c2c2233f9714b721e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b13a5bf3c4d66ce375f5978c2c2233f9714b721e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=b13a5bf3c4d66ce375f5978c2c2233f9714b721e", "patch": "@@ -14,8 +14,9 @@ use rustc_hir::lang_items::LangItem;\n use rustc_hir::ItemKind;\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n use rustc_infer::infer::outlives::obligations::TypeOutlives;\n-use rustc_infer::infer::TyCtxtInferExt;\n-use rustc_infer::infer::{self, RegionckMode, SubregionOrigin};\n+use rustc_infer::infer::region_constraints::GenericKind;\n+use rustc_infer::infer::{self, RegionckMode};\n+use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n use rustc_middle::hir::map as hir_map;\n use rustc_middle::ty::subst::{GenericArgKind, InternalSubsts, Subst};\n use rustc_middle::ty::trait_def::TraitSpecializationKind;\n@@ -332,6 +333,12 @@ fn check_gat_where_clauses(\n         // outlives relationship (`Self: 'a`), then we want to ensure that is\n         // reflected in a where clause on the GAT itself.\n         for (region, region_idx) in &regions {\n+            // Ignore `'static` lifetimes for the purpose of this lint: it's\n+            // because we know it outlives everything and so doesn't give meaninful\n+            // clues\n+            if let ty::ReStatic = region {\n+                continue;\n+            }\n             for (ty, ty_idx) in &types {\n                 // In our example, requires that Self: 'a\n                 if ty_known_to_outlive(tcx, id, param_env, &wf_tys, *ty, *region) {\n@@ -371,10 +378,19 @@ fn check_gat_where_clauses(\n         // outlives relationship, then we want to ensure that is\n         // reflected in a where clause on the GAT itself.\n         for (region_a, region_a_idx) in &regions {\n+            // Ignore `'static` lifetimes for the purpose of this lint: it's\n+            // because we know it outlives everything and so doesn't give meaninful\n+            // clues\n+            if let ty::ReStatic = region_a {\n+                continue;\n+            }\n             for (region_b, region_b_idx) in &regions {\n                 if region_a == region_b {\n                     continue;\n                 }\n+                if let ty::ReStatic = region_b {\n+                    continue;\n+                }\n \n                 if region_known_to_outlive(tcx, id, param_env, &wf_tys, *region_a, *region_b) {\n                     debug!(?region_a_idx, ?region_b_idx);\n@@ -502,8 +518,6 @@ fn check_gat_where_clauses(\n     }\n }\n \n-// FIXME(jackh726): refactor some of the shared logic between the two functions below\n-\n /// Given a known `param_env` and a set of well formed types, can we prove that\n /// `ty` outlives `region`.\n fn ty_known_to_outlive<'tcx>(\n@@ -514,54 +528,49 @@ fn ty_known_to_outlive<'tcx>(\n     ty: Ty<'tcx>,\n     region: ty::Region<'tcx>,\n ) -> bool {\n-    // Unfortunately, we have to use a new `InferCtxt` each call, because\n-    // region constraints get added and solved there and we need to test each\n-    // call individually.\n-    tcx.infer_ctxt().enter(|infcx| {\n-        let mut outlives_environment = OutlivesEnvironment::new(param_env);\n-        outlives_environment.add_implied_bounds(&infcx, wf_tys.clone(), id, DUMMY_SP);\n-        outlives_environment.save_implied_bounds(id);\n-        let region_bound_pairs = outlives_environment.region_bound_pairs_map().get(&id).unwrap();\n-\n-        let cause = ObligationCause::new(DUMMY_SP, id, ObligationCauseCode::MiscObligation);\n-\n-        let sup_type = ty;\n-        let sub_region = region;\n-\n-        let origin = SubregionOrigin::from_obligation_cause(&cause, || {\n-            infer::RelateParamBound(cause.span, sup_type, None)\n-        });\n-\n+    resolve_regions_with_wf_tys(tcx, id, param_env, &wf_tys, |infcx, region_bound_pairs| {\n+        let origin = infer::RelateParamBound(DUMMY_SP, ty, None);\n         let outlives = &mut TypeOutlives::new(\n-            &infcx,\n+            infcx,\n             tcx,\n-            &region_bound_pairs,\n+            region_bound_pairs,\n             Some(infcx.tcx.lifetimes.re_root_empty),\n             param_env,\n         );\n-        outlives.type_must_outlive(origin, sup_type, sub_region);\n-\n-        let errors = infcx.resolve_regions(\n-            id.expect_owner().to_def_id(),\n-            &outlives_environment,\n-            RegionckMode::default(),\n-        );\n-\n-        debug!(?errors, \"errors\");\n-\n-        // If we were able to prove that the type outlives the region without\n-        // an error, it must be because of the implied or explicit bounds...\n-        errors.is_empty()\n+        outlives.type_must_outlive(origin, ty, region);\n     })\n }\n \n+/// Given a known `param_env` and a set of well formed types, can we prove that\n+/// `region_a` outlives `region_b`\n fn region_known_to_outlive<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     id: hir::HirId,\n     param_env: ty::ParamEnv<'tcx>,\n     wf_tys: &FxHashSet<Ty<'tcx>>,\n     region_a: ty::Region<'tcx>,\n     region_b: ty::Region<'tcx>,\n+) -> bool {\n+    resolve_regions_with_wf_tys(tcx, id, param_env, &wf_tys, |mut infcx, _| {\n+        use rustc_infer::infer::outlives::obligations::TypeOutlivesDelegate;\n+        let origin = infer::RelateRegionParamBound(DUMMY_SP);\n+        // `region_a: region_b` -> `region_b <= region_a`\n+        infcx.push_sub_region_constraint(origin, region_b, region_a);\n+    })\n+}\n+\n+/// Given a known `param_env` and a set of well formed types, set up an\n+/// `InferCtxt`, call the passed function (to e.g. set up region constraints\n+/// to be tested), then resolve region and return errors\n+fn resolve_regions_with_wf_tys<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    id: hir::HirId,\n+    param_env: ty::ParamEnv<'tcx>,\n+    wf_tys: &FxHashSet<Ty<'tcx>>,\n+    add_constraints: impl for<'a> FnOnce(\n+        &'a InferCtxt<'a, 'tcx>,\n+        &'a Vec<(&'tcx ty::RegionKind, GenericKind<'tcx>)>,\n+    ),\n ) -> bool {\n     // Unfortunately, we have to use a new `InferCtxt` each call, because\n     // region constraints get added and solved there and we need to test each\n@@ -570,16 +579,9 @@ fn region_known_to_outlive<'tcx>(\n         let mut outlives_environment = OutlivesEnvironment::new(param_env);\n         outlives_environment.add_implied_bounds(&infcx, wf_tys.clone(), id, DUMMY_SP);\n         outlives_environment.save_implied_bounds(id);\n+        let region_bound_pairs = outlives_environment.region_bound_pairs_map().get(&id).unwrap();\n \n-        let cause = ObligationCause::new(DUMMY_SP, id, ObligationCauseCode::MiscObligation);\n-\n-        let origin = SubregionOrigin::from_obligation_cause(&cause, || {\n-            infer::RelateRegionParamBound(cause.span)\n-        });\n-\n-        use rustc_infer::infer::outlives::obligations::TypeOutlivesDelegate;\n-        // `region_a: region_b` -> `region_b <= region_a`\n-        (&infcx).push_sub_region_constraint(origin, region_b, region_a);\n+        add_constraints(&infcx, region_bound_pairs);\n \n         let errors = infcx.resolve_regions(\n             id.expect_owner().to_def_id(),"}, {"sha": "f985fb78465b9a459ce72547e61123a521c793cc", "filename": "library/alloc/src/vec/into_iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b13a5bf3c4d66ce375f5978c2c2233f9714b721e/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b13a5bf3c4d66ce375f5978c2c2233f9714b721e/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs?ref=b13a5bf3c4d66ce375f5978c2c2233f9714b721e", "patch": "@@ -125,7 +125,7 @@ impl<T, A: Allocator> AsRef<[T]> for IntoIter<T, A> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl<T: Send, A: Allocator + Send> Send for IntoIter<T, A> {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<T: Sync, A: Allocator> Sync for IntoIter<T, A> {}\n+unsafe impl<T: Sync, A: Allocator + Sync> Sync for IntoIter<T, A> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, A: Allocator> Iterator for IntoIter<T, A> {"}, {"sha": "98d8a8a1d74aebd822326df20390147d4e099d47", "filename": "library/core/src/num/bignum.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b13a5bf3c4d66ce375f5978c2c2233f9714b721e/library%2Fcore%2Fsrc%2Fnum%2Fbignum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b13a5bf3c4d66ce375f5978c2c2233f9714b721e/library%2Fcore%2Fsrc%2Fnum%2Fbignum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fbignum.rs?ref=b13a5bf3c4d66ce375f5978c2c2233f9714b721e", "patch": "@@ -158,24 +158,15 @@ macro_rules! define_bignum {\n             /// Returns the number of bits necessary to represent this value. Note that zero\n             /// is considered to need 0 bits.\n             pub fn bit_length(&self) -> usize {\n-                // Skip over the most significant digits which are zero.\n+                let digitbits = <$ty>::BITS as usize;\n                 let digits = self.digits();\n-                let zeros = digits.iter().rev().take_while(|&&x| x == 0).count();\n-                let end = digits.len() - zeros;\n-                let nonzero = &digits[..end];\n-\n-                if nonzero.is_empty() {\n+                // Find the most significant non-zero digit.\n+                let msd = digits.iter().rposition(|&x| x != 0);\n+                match msd {\n+                    Some(msd) => msd * digitbits + digits[msd].log2() as usize + 1,\n                     // There are no non-zero digits, i.e., the number is zero.\n-                    return 0;\n-                }\n-                // This could be optimized with leading_zeros() and bit shifts, but that's\n-                // probably not worth the hassle.\n-                let digitbits = <$ty>::BITS as usize;\n-                let mut i = nonzero.len() * digitbits - 1;\n-                while self.get_bit(i) == 0 {\n-                    i -= 1;\n+                    _ => 0,\n                 }\n-                i + 1\n             }\n \n             /// Adds `other` to itself and returns its own mutable reference."}, {"sha": "416e7cea7a67bcf040206dbcc777f1d6a6838aeb", "filename": "library/core/tests/num/bignum.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/b13a5bf3c4d66ce375f5978c2c2233f9714b721e/library%2Fcore%2Ftests%2Fnum%2Fbignum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b13a5bf3c4d66ce375f5978c2c2233f9714b721e/library%2Fcore%2Ftests%2Fnum%2Fbignum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fbignum.rs?ref=b13a5bf3c4d66ce375f5978c2c2233f9714b721e", "patch": "@@ -1,4 +1,5 @@\n use core::num::bignum::tests::Big8x3 as Big;\n+use core::num::bignum::Big32x40;\n \n #[test]\n #[should_panic]\n@@ -215,6 +216,16 @@ fn test_get_bit_out_of_range() {\n \n #[test]\n fn test_bit_length() {\n+    for i in 0..8 * 3 {\n+        // 010000...000\n+        assert_eq!(Big::from_small(1).mul_pow2(i).bit_length(), i + 1);\n+    }\n+    for i in 1..8 * 3 - 1 {\n+        // 010000...001\n+        assert_eq!(Big::from_small(1).mul_pow2(i).add(&Big::from_small(1)).bit_length(), i + 1);\n+        // 110000...000\n+        assert_eq!(Big::from_small(3).mul_pow2(i).bit_length(), i + 2);\n+    }\n     assert_eq!(Big::from_small(0).bit_length(), 0);\n     assert_eq!(Big::from_small(1).bit_length(), 1);\n     assert_eq!(Big::from_small(5).bit_length(), 3);\n@@ -223,6 +234,30 @@ fn test_bit_length() {\n     assert_eq!(Big::from_u64(0xffffff).bit_length(), 24);\n }\n \n+#[test]\n+fn test_bit_length_32x40() {\n+    for i in 0..32 * 40 {\n+        // 010000...000\n+        assert_eq!(Big32x40::from_small(1).mul_pow2(i).bit_length(), i + 1);\n+    }\n+    for i in 1..32 * 40 - 1 {\n+        // 010000...001\n+        assert_eq!(\n+            Big32x40::from_small(1).mul_pow2(i).add(&Big32x40::from_small(1)).bit_length(),\n+            i + 1\n+        );\n+        // 110000...000\n+        assert_eq!(Big32x40::from_small(3).mul_pow2(i).bit_length(), i + 2);\n+    }\n+    assert_eq!(Big32x40::from_small(0).bit_length(), 0);\n+    assert_eq!(Big32x40::from_small(1).bit_length(), 1);\n+    assert_eq!(Big32x40::from_small(5).bit_length(), 3);\n+    assert_eq!(Big32x40::from_small(0x18).bit_length(), 5);\n+    assert_eq!(Big32x40::from_u64(0x4073).bit_length(), 15);\n+    assert_eq!(Big32x40::from_u64(0xffffff).bit_length(), 24);\n+    assert_eq!(Big32x40::from_u64(0xffffffffffffffff).bit_length(), 64);\n+}\n+\n #[test]\n fn test_ord() {\n     assert!(Big::from_u64(0) < Big::from_u64(0xffffff));"}, {"sha": "824938ce38e68b430e5f45cd8ca53b62c2e35f27", "filename": "library/std/src/io/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b13a5bf3c4d66ce375f5978c2c2233f9714b721e/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b13a5bf3c4d66ce375f5978c2c2233f9714b721e/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fmod.rs?ref=b13a5bf3c4d66ce375f5978c2c2233f9714b721e", "patch": "@@ -1031,14 +1031,14 @@ pub trait Read {\n ///\n /// # use std::io;\n /// fn main() -> io::Result<()> {\n-///     let stdin = io::read_to_string(&mut io::stdin())?;\n+///     let stdin = io::read_to_string(io::stdin())?;\n ///     println!(\"Stdin was:\");\n ///     println!(\"{}\", stdin);\n ///     Ok(())\n /// }\n /// ```\n #[unstable(feature = \"io_read_to_string\", issue = \"80218\")]\n-pub fn read_to_string<R: Read>(reader: &mut R) -> Result<String> {\n+pub fn read_to_string<R: Read>(mut reader: R) -> Result<String> {\n     let mut buf = String::new();\n     reader.read_to_string(&mut buf)?;\n     Ok(buf)"}, {"sha": "650f712bc6eef979f7170175eaa0b294d42c58b8", "filename": "library/std/src/os/unix/ffi/os_str.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b13a5bf3c4d66ce375f5978c2c2233f9714b721e/library%2Fstd%2Fsrc%2Fos%2Funix%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b13a5bf3c4d66ce375f5978c2c2233f9714b721e/library%2Fstd%2Fsrc%2Fos%2Funix%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fffi%2Fos_str.rs?ref=b13a5bf3c4d66ce375f5978c2c2233f9714b721e", "patch": "@@ -28,9 +28,11 @@ pub trait OsStringExt: Sealed {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl OsStringExt for OsString {\n+    #[inline]\n     fn from_vec(vec: Vec<u8>) -> OsString {\n         FromInner::from_inner(Buf { inner: vec })\n     }\n+    #[inline]\n     fn into_vec(self) -> Vec<u8> {\n         self.into_inner().inner\n     }"}, {"sha": "2abffbf977a9e8c6ca4174a08fe5c4d7781f0aac", "filename": "src/llvm-project", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm-project?ref=b13a5bf3c4d66ce375f5978c2c2233f9714b721e", "patch": "@@ -1 +1 @@\n-Subproject commit 6b3dbcc81a470e5da84576d63fcfc19e3b1154cd\n+Subproject commit 2abffbf977a9e8c6ca4174a08fe5c4d7781f0aac"}, {"sha": "bb0db9d3d8514bdfa0158316329075579ec626ef", "filename": "src/test/codegen/async-fn-debug-msvc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b13a5bf3c4d66ce375f5978c2c2233f9714b721e/src%2Ftest%2Fcodegen%2Fasync-fn-debug-msvc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b13a5bf3c4d66ce375f5978c2c2233f9714b721e/src%2Ftest%2Fcodegen%2Fasync-fn-debug-msvc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fasync-fn-debug-msvc.rs?ref=b13a5bf3c4d66ce375f5978c2c2233f9714b721e", "patch": "@@ -17,7 +17,7 @@ async fn async_fn_test() {\n // FIXME: No way to reliably check the filename.\n \n // CHECK-DAG:  [[ASYNC_FN:!.*]] = !DINamespace(name: \"async_fn_test\"\n-// CHECK-DAG:  [[GEN:!.*]] = !DICompositeType(tag: DW_TAG_union_type, name: \"generator$0\"\n+// CHECK-DAG:  [[GEN:!.*]] = !DICompositeType(tag: DW_TAG_union_type, name: \"async_fn$0\"\n // CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"variant0\", scope: [[GEN]],\n // For brevity, we only check the struct name and members of the last variant.\n // CHECK-SAME: file: [[FILE:![0-9]*]], line: 11,"}, {"sha": "f456f7ffc0fba7f6b6ce4e8e8790a7c9643d0d88", "filename": "src/test/codegen/async-fn-debug.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b13a5bf3c4d66ce375f5978c2c2233f9714b721e/src%2Ftest%2Fcodegen%2Fasync-fn-debug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b13a5bf3c4d66ce375f5978c2c2233f9714b721e/src%2Ftest%2Fcodegen%2Fasync-fn-debug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fasync-fn-debug.rs?ref=b13a5bf3c4d66ce375f5978c2c2233f9714b721e", "patch": "@@ -17,7 +17,7 @@ async fn async_fn_test() {\n // FIXME: No way to reliably check the filename.\n \n // CHECK-DAG:  [[ASYNC_FN:!.*]] = !DINamespace(name: \"async_fn_test\"\n-// CHECK-DAG:  [[GEN:!.*]] = !DICompositeType(tag: DW_TAG_structure_type, name: \"{generator#0}\", scope: [[ASYNC_FN]]\n+// CHECK-DAG:  [[GEN:!.*]] = !DICompositeType(tag: DW_TAG_structure_type, name: \"{async_fn#0}\", scope: [[ASYNC_FN]]\n // CHECK:      [[VARIANT:!.*]] = !DICompositeType(tag: DW_TAG_variant_part, scope: [[ASYNC_FN]],\n // CHECK-NOT:  flags: DIFlagArtificial\n // CHECK-SAME: discriminator: [[DISC:![0-9]*]]"}, {"sha": "3bfc759a9aef72131bda31b2550e1e5cc0eb582b", "filename": "src/test/ui/consts/const-block-const-bound.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b13a5bf3c4d66ce375f5978c2c2233f9714b721e/src%2Ftest%2Fui%2Fconsts%2Fconst-block-const-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b13a5bf3c4d66ce375f5978c2c2233f9714b721e/src%2Ftest%2Fui%2Fconsts%2Fconst-block-const-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-block-const-bound.rs?ref=b13a5bf3c4d66ce375f5978c2c2233f9714b721e", "patch": "@@ -0,0 +1,17 @@\n+#![allow(unused)]\n+#![feature(const_fn_trait_bound, const_trait_impl, inline_const)]\n+\n+const fn f<T: ~const Drop>(x: T) {}\n+\n+struct UnconstDrop;\n+\n+impl Drop for UnconstDrop {\n+    fn drop(&mut self) {}\n+}\n+\n+fn main() {\n+    const {\n+        f(UnconstDrop);\n+        //~^ ERROR the trait bound `UnconstDrop: Drop` is not satisfied\n+    }\n+}"}, {"sha": "0e6e426e7c2c83c5c2361bbc513e4e0bad90ffb2", "filename": "src/test/ui/consts/const-block-const-bound.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b13a5bf3c4d66ce375f5978c2c2233f9714b721e/src%2Ftest%2Fui%2Fconsts%2Fconst-block-const-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b13a5bf3c4d66ce375f5978c2c2233f9714b721e/src%2Ftest%2Fui%2Fconsts%2Fconst-block-const-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-block-const-bound.stderr?ref=b13a5bf3c4d66ce375f5978c2c2233f9714b721e", "patch": "@@ -0,0 +1,21 @@\n+error[E0277]: the trait bound `UnconstDrop: Drop` is not satisfied\n+  --> $DIR/const-block-const-bound.rs:14:11\n+   |\n+LL |         f(UnconstDrop);\n+   |         - ^^^^^^^^^^^ the trait `Drop` is not implemented for `UnconstDrop`\n+   |         |\n+   |         required by a bound introduced by this call\n+   |\n+note: required by a bound in `f`\n+  --> $DIR/const-block-const-bound.rs:4:15\n+   |\n+LL | const fn f<T: ~const Drop>(x: T) {}\n+   |               ^^^^^^^^^^^ required by this bound in `f`\n+help: consider introducing a `where` bound, but there might be an alternative better way to express this requirement\n+   |\n+LL | fn main() where UnconstDrop: Drop {\n+   |           +++++++++++++++++++++++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "fcc53b4ede0cb65ceacc59a96c18bcdfdf0214d8", "filename": "src/test/ui/generic-associated-types/self-outlives-lint.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b13a5bf3c4d66ce375f5978c2c2233f9714b721e/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fself-outlives-lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b13a5bf3c4d66ce375f5978c2c2233f9714b721e/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fself-outlives-lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fself-outlives-lint.rs?ref=b13a5bf3c4d66ce375f5978c2c2233f9714b721e", "patch": "@@ -189,4 +189,17 @@ trait Trait: 'static {\n     fn make_assoc(_: &u32) -> Self::Assoc<'_>;\n }\n \n+// We ignore `'static` lifetimes for any lints\n+trait StaticReturn<'a> {\n+    type Y<'b>;\n+    fn foo(&self) -> Self::Y<'static>;\n+}\n+\n+// Same as above, but with extra method that takes GAT - just make sure this works\n+trait StaticReturnAndTakes<'a> {\n+    type Y<'b>;\n+    fn foo(&self) -> Self::Y<'static>;\n+    fn bar<'b>(&self, arg: Self::Y<'b>);\n+}\n+\n fn main() {}"}]}