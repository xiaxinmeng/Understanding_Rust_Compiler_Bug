{"sha": "9f41f074be3a600a40b398dd3f4e57a0d69db256", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmNDFmMDc0YmUzYTYwMGE0MGIzOThkZDNmNGU1N2EwZDY5ZGIyNTY=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2020-10-14T17:56:20Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2020-10-14T17:56:20Z"}, "message": "Add qualify path assist", "tree": {"sha": "6e5f06f49c8aa34e1705500b028734811742d9d0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6e5f06f49c8aa34e1705500b028734811742d9d0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f41f074be3a600a40b398dd3f4e57a0d69db256", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f41f074be3a600a40b398dd3f4e57a0d69db256", "html_url": "https://github.com/rust-lang/rust/commit/9f41f074be3a600a40b398dd3f4e57a0d69db256", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f41f074be3a600a40b398dd3f4e57a0d69db256/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84d6cdef86dfe1054ecafaedfddbf90a2b3a469d", "url": "https://api.github.com/repos/rust-lang/rust/commits/84d6cdef86dfe1054ecafaedfddbf90a2b3a469d", "html_url": "https://github.com/rust-lang/rust/commit/84d6cdef86dfe1054ecafaedfddbf90a2b3a469d"}], "stats": {"total": 1022, "additions": 1022, "deletions": 0}, "files": [{"sha": "cff20788957eb34371a2202e9848addf703fa401", "filename": "crates/assists/src/handlers/qualify_path.rs", "status": "added", "additions": 1020, "deletions": 0, "changes": 1020, "blob_url": "https://github.com/rust-lang/rust/blob/9f41f074be3a600a40b398dd3f4e57a0d69db256/crates%2Fassists%2Fsrc%2Fhandlers%2Fqualify_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f41f074be3a600a40b398dd3f4e57a0d69db256/crates%2Fassists%2Fsrc%2Fhandlers%2Fqualify_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fqualify_path.rs?ref=9f41f074be3a600a40b398dd3f4e57a0d69db256", "patch": "@@ -0,0 +1,1020 @@\n+use std::collections::BTreeSet;\n+\n+use syntax::{ast, AstNode, TextRange};\n+\n+use crate::{\n+    assist_context::{AssistContext, Assists},\n+    utils::import_assets::{ImportAssets, ImportCandidate},\n+    utils::mod_path_to_ast,\n+    AssistId, AssistKind, GroupLabel,\n+};\n+\n+// Assist: qualify_path\n+//\n+// If the name is unresolved, provides all possible qualified paths for it.\n+//\n+// ```\n+// fn main() {\n+//     let map = HashMap<|>::new();\n+// }\n+// # pub mod std { pub mod collections { pub struct HashMap { } } }\n+// ```\n+// ->\n+// ```\n+// fn main() {\n+//     let map = std::collections::HashMap::new();\n+// }\n+// # pub mod std { pub mod collections { pub struct HashMap { } } }\n+// ```\n+pub(crate) fn qualify_path(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    let import_assets =\n+        if let Some(path_under_caret) = ctx.find_node_at_offset_with_descend::<ast::Path>() {\n+            ImportAssets::for_regular_path(path_under_caret, &ctx.sema)\n+        } else if let Some(method_under_caret) =\n+            ctx.find_node_at_offset_with_descend::<ast::MethodCallExpr>()\n+        {\n+            ImportAssets::for_method_call(method_under_caret, &ctx.sema)\n+        } else {\n+            None\n+        }?;\n+    let proposed_imports = import_assets.search_for_relative_paths(&ctx.sema);\n+    if proposed_imports.is_empty() {\n+        return None;\n+    }\n+\n+    let range = ctx.sema.original_range(import_assets.syntax_under_caret()).range;\n+    match import_assets.import_candidate() {\n+        ImportCandidate::QualifierStart(candidate) => {\n+            let path = ast::Path::cast(import_assets.syntax_under_caret().clone())?;\n+            let segment = path.segment()?;\n+            qualify_path_qualifier_start(acc, proposed_imports, range, segment, &candidate.name)\n+        }\n+        ImportCandidate::UnqualifiedName(candidate) => {\n+            qualify_path_unqualified_name(acc, proposed_imports, range, &candidate.name)\n+        }\n+        ImportCandidate::TraitAssocItem(candidate) => {\n+            let path = ast::Path::cast(import_assets.syntax_under_caret().clone())?;\n+            let (qualifier, segment) = (path.qualifier()?, path.segment()?);\n+            qualify_path_trait_assoc_item(\n+                acc,\n+                proposed_imports,\n+                range,\n+                qualifier,\n+                segment,\n+                &candidate.name,\n+            )\n+        }\n+        ImportCandidate::TraitMethod(candidate) => {\n+            let mcall_expr = ast::MethodCallExpr::cast(import_assets.syntax_under_caret().clone())?;\n+            let receiver = mcall_expr.receiver()?;\n+            let name_ref = mcall_expr.name_ref()?;\n+            qualify_path_trait_method(\n+                acc,\n+                proposed_imports,\n+                range,\n+                receiver,\n+                name_ref,\n+                &candidate.name,\n+            )\n+        }\n+    };\n+    Some(())\n+}\n+\n+// a test that covers this -> `associated_struct_const`\n+fn qualify_path_qualifier_start(\n+    acc: &mut Assists,\n+    proposed_imports: BTreeSet<hir::ModPath>,\n+    range: TextRange,\n+    segment: ast::PathSegment,\n+    qualifier_start: &str,\n+) {\n+    let group_label = GroupLabel(format!(\"Qualify {}\", qualifier_start));\n+    for import in proposed_imports {\n+        acc.add_group(\n+            &group_label,\n+            AssistId(\"qualify_path\", AssistKind::QuickFix),\n+            format!(\"Qualify with `{}`\", &import),\n+            range,\n+            |builder| {\n+                let import = mod_path_to_ast(&import);\n+                builder.replace(range, format!(\"{}::{}\", import, segment));\n+            },\n+        );\n+    }\n+}\n+\n+// a test that covers this -> `applicable_when_found_an_import_partial`\n+fn qualify_path_unqualified_name(\n+    acc: &mut Assists,\n+    proposed_imports: BTreeSet<hir::ModPath>,\n+    range: TextRange,\n+    name: &str,\n+) {\n+    let group_label = GroupLabel(format!(\"Qualify {}\", name));\n+    for import in proposed_imports {\n+        acc.add_group(\n+            &group_label,\n+            AssistId(\"qualify_path\", AssistKind::QuickFix),\n+            format!(\"Qualify as `{}`\", &import),\n+            range,\n+            |builder| builder.replace(range, mod_path_to_ast(&import).to_string()),\n+        );\n+    }\n+}\n+\n+// a test that covers this -> `associated_trait_const`\n+fn qualify_path_trait_assoc_item(\n+    acc: &mut Assists,\n+    proposed_imports: BTreeSet<hir::ModPath>,\n+    range: TextRange,\n+    qualifier: ast::Path,\n+    segment: ast::PathSegment,\n+    trait_assoc_item_name: &str,\n+) {\n+    let group_label = GroupLabel(format!(\"Qualify {}\", trait_assoc_item_name));\n+    for import in proposed_imports {\n+        acc.add_group(\n+            &group_label,\n+            AssistId(\"qualify_path\", AssistKind::QuickFix),\n+            format!(\"Qualify with cast as `{}`\", &import),\n+            range,\n+            |builder| {\n+                let import = mod_path_to_ast(&import);\n+                builder.replace(range, format!(\"<{} as {}>::{}\", qualifier, import, segment));\n+            },\n+        );\n+    }\n+}\n+\n+// a test that covers this -> `trait_method`\n+fn qualify_path_trait_method(\n+    acc: &mut Assists,\n+    proposed_imports: BTreeSet<hir::ModPath>,\n+    range: TextRange,\n+    receiver: ast::Expr,\n+    name_ref: ast::NameRef,\n+    trait_method_name: &str,\n+) {\n+    let group_label = GroupLabel(format!(\"Qualify {}\", trait_method_name));\n+    for import in proposed_imports {\n+        acc.add_group(\n+            &group_label,\n+            AssistId(\"qualify_path\", AssistKind::QuickFix), // < Does this still count as quickfix?\n+            format!(\"Qualify `{}`\", &import),\n+            range,\n+            |builder| {\n+                let import = mod_path_to_ast(&import);\n+                // TODO: check the receiver self type and emit refs accordingly, don't discard other function parameters\n+                builder.replace(range, format!(\"{}::{}(&{})\", import, name_ref, receiver));\n+            },\n+        );\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use crate::tests::{check_assist, check_assist_not_applicable, check_assist_target};\n+    #[test]\n+    fn applicable_when_found_an_import_partial() {\n+        check_assist(\n+            qualify_path,\n+            r\"\n+            mod std {\n+                pub mod fmt {\n+                    pub struct Formatter;\n+                }\n+            }\n+\n+            use std::fmt;\n+\n+            <|>Formatter\n+            \",\n+            r\"\n+            mod std {\n+                pub mod fmt {\n+                    pub struct Formatter;\n+                }\n+            }\n+\n+            use std::fmt;\n+\n+            fmt::Formatter\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn applicable_when_found_an_import() {\n+        check_assist(\n+            qualify_path,\n+            r\"\n+            <|>PubStruct\n+\n+            pub mod PubMod {\n+                pub struct PubStruct;\n+            }\n+            \",\n+            r\"\n+            PubMod::PubStruct\n+\n+            pub mod PubMod {\n+                pub struct PubStruct;\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn applicable_in_macros() {\n+        check_assist(\n+            qualify_path,\n+            r\"\n+            macro_rules! foo {\n+                ($i:ident) => { fn foo(a: $i) {} }\n+            }\n+            foo!(Pub<|>Struct);\n+\n+            pub mod PubMod {\n+                pub struct PubStruct;\n+            }\n+            \",\n+            r\"\n+            macro_rules! foo {\n+                ($i:ident) => { fn foo(a: $i) {} }\n+            }\n+            foo!(PubMod::PubStruct);\n+\n+            pub mod PubMod {\n+                pub struct PubStruct;\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn applicable_when_found_multiple_imports() {\n+        check_assist(\n+            qualify_path,\n+            r\"\n+            PubSt<|>ruct\n+\n+            pub mod PubMod1 {\n+                pub struct PubStruct;\n+            }\n+            pub mod PubMod2 {\n+                pub struct PubStruct;\n+            }\n+            pub mod PubMod3 {\n+                pub struct PubStruct;\n+            }\n+            \",\n+            r\"\n+            PubMod3::PubStruct\n+\n+            pub mod PubMod1 {\n+                pub struct PubStruct;\n+            }\n+            pub mod PubMod2 {\n+                pub struct PubStruct;\n+            }\n+            pub mod PubMod3 {\n+                pub struct PubStruct;\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn not_applicable_for_already_imported_types() {\n+        check_assist_not_applicable(\n+            qualify_path,\n+            r\"\n+            use PubMod::PubStruct;\n+\n+            PubStruct<|>\n+\n+            pub mod PubMod {\n+                pub struct PubStruct;\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn not_applicable_for_types_with_private_paths() {\n+        check_assist_not_applicable(\n+            qualify_path,\n+            r\"\n+            PrivateStruct<|>\n+\n+            pub mod PubMod {\n+                struct PrivateStruct;\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn not_applicable_when_no_imports_found() {\n+        check_assist_not_applicable(\n+            qualify_path,\n+            \"\n+            PubStruct<|>\",\n+        );\n+    }\n+\n+    #[test]\n+    fn not_applicable_in_import_statements() {\n+        check_assist_not_applicable(\n+            qualify_path,\n+            r\"\n+            use PubStruct<|>;\n+\n+            pub mod PubMod {\n+                pub struct PubStruct;\n+            }\",\n+        );\n+    }\n+\n+    #[test]\n+    fn qualify_function() {\n+        check_assist(\n+            qualify_path,\n+            r\"\n+            test_function<|>\n+\n+            pub mod PubMod {\n+                pub fn test_function() {};\n+            }\n+            \",\n+            r\"\n+            PubMod::test_function\n+\n+            pub mod PubMod {\n+                pub fn test_function() {};\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn qualify_macro() {\n+        check_assist(\n+            qualify_path,\n+            r\"\n+//- /lib.rs crate:crate_with_macro\n+#[macro_export]\n+macro_rules! foo {\n+    () => ()\n+}\n+\n+//- /main.rs crate:main deps:crate_with_macro\n+fn main() {\n+    foo<|>\n+}\n+\",\n+            r\"\n+fn main() {\n+    crate_with_macro::foo\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn qualify_path_target() {\n+        check_assist_target(\n+            qualify_path,\n+            r\"\n+            struct AssistInfo {\n+                group_label: Option<<|>GroupLabel>,\n+            }\n+\n+            mod m { pub struct GroupLabel; }\n+            \",\n+            \"GroupLabel\",\n+        )\n+    }\n+\n+    #[test]\n+    fn not_applicable_when_path_start_is_imported() {\n+        check_assist_not_applicable(\n+            qualify_path,\n+            r\"\n+            pub mod mod1 {\n+                pub mod mod2 {\n+                    pub mod mod3 {\n+                        pub struct TestStruct;\n+                    }\n+                }\n+            }\n+\n+            use mod1::mod2;\n+            fn main() {\n+                mod2::mod3::TestStruct<|>\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn not_applicable_for_imported_function() {\n+        check_assist_not_applicable(\n+            qualify_path,\n+            r\"\n+            pub mod test_mod {\n+                pub fn test_function() {}\n+            }\n+\n+            use test_mod::test_function;\n+            fn main() {\n+                test_function<|>\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn associated_struct_function() {\n+        check_assist(\n+            qualify_path,\n+            r\"\n+            mod test_mod {\n+                pub struct TestStruct {}\n+                impl TestStruct {\n+                    pub fn test_function() {}\n+                }\n+            }\n+\n+            fn main() {\n+                TestStruct::test_function<|>\n+            }\n+            \",\n+            r\"\n+            mod test_mod {\n+                pub struct TestStruct {}\n+                impl TestStruct {\n+                    pub fn test_function() {}\n+                }\n+            }\n+\n+            fn main() {\n+                test_mod::TestStruct::test_function\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn associated_struct_const() {\n+        check_assist(\n+            qualify_path,\n+            r\"\n+            mod test_mod {\n+                pub struct TestStruct {}\n+                impl TestStruct {\n+                    const TEST_CONST: u8 = 42;\n+                }\n+            }\n+\n+            fn main() {\n+                TestStruct::TEST_CONST<|>\n+            }\n+            \",\n+            r\"\n+            mod test_mod {\n+                pub struct TestStruct {}\n+                impl TestStruct {\n+                    const TEST_CONST: u8 = 42;\n+                }\n+            }\n+\n+            fn main() {\n+                test_mod::TestStruct::TEST_CONST\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn associated_trait_function() {\n+        check_assist(\n+            qualify_path,\n+            r\"\n+            mod test_mod {\n+                pub trait TestTrait {\n+                    fn test_function();\n+                }\n+                pub struct TestStruct {}\n+                impl TestTrait for TestStruct {\n+                    fn test_function() {}\n+                }\n+            }\n+\n+            fn main() {\n+                test_mod::TestStruct::test_function<|>\n+            }\n+            \",\n+            r\"\n+            mod test_mod {\n+                pub trait TestTrait {\n+                    fn test_function();\n+                }\n+                pub struct TestStruct {}\n+                impl TestTrait for TestStruct {\n+                    fn test_function() {}\n+                }\n+            }\n+\n+            fn main() {\n+                <test_mod::TestStruct as test_mod::TestTrait>::test_function\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn not_applicable_for_imported_trait_for_function() {\n+        check_assist_not_applicable(\n+            qualify_path,\n+            r\"\n+            mod test_mod {\n+                pub trait TestTrait {\n+                    fn test_function();\n+                }\n+                pub trait TestTrait2 {\n+                    fn test_function();\n+                }\n+                pub enum TestEnum {\n+                    One,\n+                    Two,\n+                }\n+                impl TestTrait2 for TestEnum {\n+                    fn test_function() {}\n+                }\n+                impl TestTrait for TestEnum {\n+                    fn test_function() {}\n+                }\n+            }\n+\n+            use test_mod::TestTrait2;\n+            fn main() {\n+                test_mod::TestEnum::test_function<|>;\n+            }\n+            \",\n+        )\n+    }\n+\n+    #[test]\n+    fn associated_trait_const() {\n+        check_assist(\n+            qualify_path,\n+            r\"\n+            mod test_mod {\n+                pub trait TestTrait {\n+                    const TEST_CONST: u8;\n+                }\n+                pub struct TestStruct {}\n+                impl TestTrait for TestStruct {\n+                    const TEST_CONST: u8 = 42;\n+                }\n+            }\n+\n+            fn main() {\n+                test_mod::TestStruct::TEST_CONST<|>\n+            }\n+            \",\n+            r\"\n+            mod test_mod {\n+                pub trait TestTrait {\n+                    const TEST_CONST: u8;\n+                }\n+                pub struct TestStruct {}\n+                impl TestTrait for TestStruct {\n+                    const TEST_CONST: u8 = 42;\n+                }\n+            }\n+\n+            fn main() {\n+                <test_mod::TestStruct as test_mod::TestTrait>::TEST_CONST\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn not_applicable_for_imported_trait_for_const() {\n+        check_assist_not_applicable(\n+            qualify_path,\n+            r\"\n+            mod test_mod {\n+                pub trait TestTrait {\n+                    const TEST_CONST: u8;\n+                }\n+                pub trait TestTrait2 {\n+                    const TEST_CONST: f64;\n+                }\n+                pub enum TestEnum {\n+                    One,\n+                    Two,\n+                }\n+                impl TestTrait2 for TestEnum {\n+                    const TEST_CONST: f64 = 42.0;\n+                }\n+                impl TestTrait for TestEnum {\n+                    const TEST_CONST: u8 = 42;\n+                }\n+            }\n+\n+            use test_mod::TestTrait2;\n+            fn main() {\n+                test_mod::TestEnum::TEST_CONST<|>;\n+            }\n+            \",\n+        )\n+    }\n+\n+    #[test]\n+    fn trait_method() {\n+        check_assist(\n+            qualify_path,\n+            r\"\n+            mod test_mod {\n+                pub trait TestTrait {\n+                    fn test_method(&self);\n+                }\n+                pub struct TestStruct {}\n+                impl TestTrait for TestStruct {\n+                    fn test_method(&self) {}\n+                }\n+            }\n+\n+            fn main() {\n+                let test_struct = test_mod::TestStruct {};\n+                test_struct.test_meth<|>od()\n+            }\n+            \",\n+            r\"\n+            mod test_mod {\n+                pub trait TestTrait {\n+                    fn test_method(&self);\n+                }\n+                pub struct TestStruct {}\n+                impl TestTrait for TestStruct {\n+                    fn test_method(&self) {}\n+                }\n+            }\n+\n+            fn main() {\n+                let test_struct = test_mod::TestStruct {};\n+                test_mod::TestTrait::test_method(&test_struct)\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn trait_method_multi_params() {\n+        check_assist(\n+            qualify_path,\n+            r\"\n+            mod test_mod {\n+                pub trait TestTrait {\n+                    fn test_method(&self, test: i32);\n+                }\n+                pub struct TestStruct {}\n+                impl TestTrait for TestStruct {\n+                    fn test_method(&self, test: i32) {}\n+                }\n+            }\n+\n+            fn main() {\n+                let test_struct = test_mod::TestStruct {};\n+                test_struct.test_meth<|>od(42)\n+            }\n+            \",\n+            r\"\n+            mod test_mod {\n+                pub trait TestTrait {\n+                    fn test_method(&self, test: i32);\n+                }\n+                pub struct TestStruct {}\n+                impl TestTrait for TestStruct {\n+                    fn test_method(&self, test: i32) {}\n+                }\n+            }\n+\n+            fn main() {\n+                let test_struct = test_mod::TestStruct {};\n+                test_mod::TestTrait::test_method(&test_struct, 42)\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn trait_method_consume() {\n+        check_assist(\n+            qualify_path,\n+            r\"\n+            mod test_mod {\n+                pub trait TestTrait {\n+                    fn test_method(self);\n+                }\n+                pub struct TestStruct {}\n+                impl TestTrait for TestStruct {\n+                    fn test_method(self) {}\n+                }\n+            }\n+\n+            fn main() {\n+                let test_struct = test_mod::TestStruct {};\n+                test_struct.test_meth<|>od()\n+            }\n+            \",\n+            r\"\n+            mod test_mod {\n+                pub trait TestTrait {\n+                    fn test_method(self);\n+                }\n+                pub struct TestStruct {}\n+                impl TestTrait for TestStruct {\n+                    fn test_method(self) {}\n+                }\n+            }\n+\n+            fn main() {\n+                let test_struct = test_mod::TestStruct {};\n+                test_mod::TestTrait::test_method(test_struct)\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn trait_method_cross_crate() {\n+        check_assist(\n+            qualify_path,\n+            r\"\n+            //- /main.rs crate:main deps:dep\n+            fn main() {\n+                let test_struct = dep::test_mod::TestStruct {};\n+                test_struct.test_meth<|>od()\n+            }\n+            //- /dep.rs crate:dep\n+            pub mod test_mod {\n+                pub trait TestTrait {\n+                    fn test_method(&self);\n+                }\n+                pub struct TestStruct {}\n+                impl TestTrait for TestStruct {\n+                    fn test_method(&self) {}\n+                }\n+            }\n+            \",\n+            r\"\n+            fn main() {\n+                let test_struct = dep::test_mod::TestStruct {};\n+                dep::test_mod::TestTrait::test_method(&test_struct)\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn assoc_fn_cross_crate() {\n+        check_assist(\n+            qualify_path,\n+            r\"\n+            //- /main.rs crate:main deps:dep\n+            fn main() {\n+                dep::test_mod::TestStruct::test_func<|>tion\n+            }\n+            //- /dep.rs crate:dep\n+            pub mod test_mod {\n+                pub trait TestTrait {\n+                    fn test_function();\n+                }\n+                pub struct TestStruct {}\n+                impl TestTrait for TestStruct {\n+                    fn test_function() {}\n+                }\n+            }\n+            \",\n+            r\"\n+            fn main() {\n+                <dep::test_mod::TestStruct as dep::test_mod::TestTrait>::test_function\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn assoc_const_cross_crate() {\n+        check_assist(\n+            qualify_path,\n+            r\"\n+            //- /main.rs crate:main deps:dep\n+            fn main() {\n+                dep::test_mod::TestStruct::CONST<|>\n+            }\n+            //- /dep.rs crate:dep\n+            pub mod test_mod {\n+                pub trait TestTrait {\n+                    const CONST: bool;\n+                }\n+                pub struct TestStruct {}\n+                impl TestTrait for TestStruct {\n+                    const CONST: bool = true;\n+                }\n+            }\n+            \",\n+            r\"\n+            fn main() {\n+                <dep::test_mod::TestStruct as dep::test_mod::TestTrait>::CONST\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn assoc_fn_as_method_cross_crate() {\n+        check_assist_not_applicable(\n+            qualify_path,\n+            r\"\n+            //- /main.rs crate:main deps:dep\n+            fn main() {\n+                let test_struct = dep::test_mod::TestStruct {};\n+                test_struct.test_func<|>tion()\n+            }\n+            //- /dep.rs crate:dep\n+            pub mod test_mod {\n+                pub trait TestTrait {\n+                    fn test_function();\n+                }\n+                pub struct TestStruct {}\n+                impl TestTrait for TestStruct {\n+                    fn test_function() {}\n+                }\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn private_trait_cross_crate() {\n+        check_assist_not_applicable(\n+            qualify_path,\n+            r\"\n+            //- /main.rs crate:main deps:dep\n+            fn main() {\n+                let test_struct = dep::test_mod::TestStruct {};\n+                test_struct.test_meth<|>od()\n+            }\n+            //- /dep.rs crate:dep\n+            pub mod test_mod {\n+                trait TestTrait {\n+                    fn test_method(&self);\n+                }\n+                pub struct TestStruct {}\n+                impl TestTrait for TestStruct {\n+                    fn test_method(&self) {}\n+                }\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn not_applicable_for_imported_trait_for_method() {\n+        check_assist_not_applicable(\n+            qualify_path,\n+            r\"\n+            mod test_mod {\n+                pub trait TestTrait {\n+                    fn test_method(&self);\n+                }\n+                pub trait TestTrait2 {\n+                    fn test_method(&self);\n+                }\n+                pub enum TestEnum {\n+                    One,\n+                    Two,\n+                }\n+                impl TestTrait2 for TestEnum {\n+                    fn test_method(&self) {}\n+                }\n+                impl TestTrait for TestEnum {\n+                    fn test_method(&self) {}\n+                }\n+            }\n+\n+            use test_mod::TestTrait2;\n+            fn main() {\n+                let one = test_mod::TestEnum::One;\n+                one.test<|>_method();\n+            }\n+            \",\n+        )\n+    }\n+\n+    #[test]\n+    fn dep_import() {\n+        check_assist(\n+            qualify_path,\n+            r\"\n+//- /lib.rs crate:dep\n+pub struct Struct;\n+\n+//- /main.rs crate:main deps:dep\n+fn main() {\n+    Struct<|>\n+}\n+\",\n+            r\"\n+fn main() {\n+    dep::Struct\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn whole_segment() {\n+        // Tests that only imports whose last segment matches the identifier get suggested.\n+        check_assist(\n+            qualify_path,\n+            r\"\n+//- /lib.rs crate:dep\n+pub mod fmt {\n+    pub trait Display {}\n+}\n+\n+pub fn panic_fmt() {}\n+\n+//- /main.rs crate:main deps:dep\n+struct S;\n+\n+impl f<|>mt::Display for S {}\n+\",\n+            r\"\n+struct S;\n+\n+impl dep::fmt::Display for S {}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn macro_generated() {\n+        // Tests that macro-generated items are suggested from external crates.\n+        check_assist(\n+            qualify_path,\n+            r\"\n+//- /lib.rs crate:dep\n+macro_rules! mac {\n+    () => {\n+        pub struct Cheese;\n+    };\n+}\n+\n+mac!();\n+\n+//- /main.rs crate:main deps:dep\n+fn main() {\n+    Cheese<|>;\n+}\n+\",\n+            r\"\n+fn main() {\n+    dep::Cheese;\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn casing() {\n+        // Tests that differently cased names don't interfere and we only suggest the matching one.\n+        check_assist(\n+            qualify_path,\n+            r\"\n+//- /lib.rs crate:dep\n+pub struct FMT;\n+pub struct fmt;\n+\n+//- /main.rs crate:main deps:dep\n+fn main() {\n+    FMT<|>;\n+}\n+\",\n+            r\"\n+fn main() {\n+    dep::FMT;\n+}\n+\",\n+        );\n+    }\n+}"}, {"sha": "f29b8212f9cdb3a1e199275f69a08608413678f0", "filename": "crates/assists/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f41f074be3a600a40b398dd3f4e57a0d69db256/crates%2Fassists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f41f074be3a600a40b398dd3f4e57a0d69db256/crates%2Fassists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Flib.rs?ref=9f41f074be3a600a40b398dd3f4e57a0d69db256", "patch": "@@ -150,6 +150,7 @@ mod handlers {\n     mod merge_match_arms;\n     mod move_bounds;\n     mod move_guard;\n+    mod qualify_path;\n     mod raw_string;\n     mod remove_dbg;\n     mod remove_mut;\n@@ -196,6 +197,7 @@ mod handlers {\n             move_bounds::move_bounds_to_where_clause,\n             move_guard::move_arm_cond_to_match_guard,\n             move_guard::move_guard_to_arm_body,\n+            qualify_path::qualify_path,\n             raw_string::add_hash,\n             raw_string::make_raw_string,\n             raw_string::make_usual_string,"}]}