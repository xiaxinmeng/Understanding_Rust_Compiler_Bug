{"sha": "5e52ada714a46b6150e78c7c5a2ff7178a2d79d3", "node_id": "C_kwDOAAsO6NoAKDVlNTJhZGE3MTRhNDZiNjE1MGU3OGM3YzVhMmZmNzE3OGEyZDc5ZDM", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-03-11T11:55:43Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-03-11T11:55:43Z"}, "message": "Rollup merge of #108927 - Ayush1325:pal-cleanup, r=workingjubilee\n\nMove __thread_local_inner to sys\n\nMove `__thread_local_inner` macro in `crate::thread::local` to `crate::sys`. Initially, I was thinking about removing this macro completely, but I could not find a way to create the generic statics without macros, so in the end, I just moved to code around.\n\nThis probably will need a rebase once https://github.com/rust-lang/rust/pull/108917 is merged\n\nr? ``@workingjubilee``", "tree": {"sha": "26f5009e610ecdb566eb26e05ea84957b0ecc643", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/26f5009e610ecdb566eb26e05ea84957b0ecc643"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e52ada714a46b6150e78c7c5a2ff7178a2d79d3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkDGw/CRBK7hj4Ov3rIwAAk88IACDoumdOTPvF5kN7pb5oeP0d\nvwfNbZoSCOzG2bqWmUCD5zHKI1mFXNVsDufHMjWQ1qJAnxCVLyswuELoV5i2fYyq\nXHqR/xa/lkZwKKBSHV8rcWtOf44Ul6kznhEpcUTCEpqI9SC0n1jlRIVDpfUhIBGn\nn62iDAHGD6+ahB7tWtoGS1N6DBoUAyrO9CpDUAGp3A2wBGDOJ+lngIalHir5FPDE\nEw292CFqI+lDeUEbHmjaZmiuPsYBaMA1oUEW9wAt9I3NOyUmug8tNQR6xkYSH7B3\nJmO4YnBKQu7MtaIib4rxab3nLbMqGSMAF+jkWHlQNZmm/Hep1pzDiGZ0qpIV1Zg=\n=sT5N\n-----END PGP SIGNATURE-----\n", "payload": "tree 26f5009e610ecdb566eb26e05ea84957b0ecc643\nparent 25794194fa2bd25221411c08f6b3e33f13e9ec74\nparent 5828910ff4ea90eb2092074dd641d36f0146a734\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1678535743 +0100\ncommitter GitHub <noreply@github.com> 1678535743 +0100\n\nRollup merge of #108927 - Ayush1325:pal-cleanup, r=workingjubilee\n\nMove __thread_local_inner to sys\n\nMove `__thread_local_inner` macro in `crate::thread::local` to `crate::sys`. Initially, I was thinking about removing this macro completely, but I could not find a way to create the generic statics without macros, so in the end, I just moved to code around.\n\nThis probably will need a rebase once https://github.com/rust-lang/rust/pull/108917 is merged\n\nr? ``@workingjubilee``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e52ada714a46b6150e78c7c5a2ff7178a2d79d3", "html_url": "https://github.com/rust-lang/rust/commit/5e52ada714a46b6150e78c7c5a2ff7178a2d79d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e52ada714a46b6150e78c7c5a2ff7178a2d79d3/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "25794194fa2bd25221411c08f6b3e33f13e9ec74", "url": "https://api.github.com/repos/rust-lang/rust/commits/25794194fa2bd25221411c08f6b3e33f13e9ec74", "html_url": "https://github.com/rust-lang/rust/commit/25794194fa2bd25221411c08f6b3e33f13e9ec74"}, {"sha": "5828910ff4ea90eb2092074dd641d36f0146a734", "url": "https://api.github.com/repos/rust-lang/rust/commits/5828910ff4ea90eb2092074dd641d36f0146a734", "html_url": "https://github.com/rust-lang/rust/commit/5828910ff4ea90eb2092074dd641d36f0146a734"}], "stats": {"total": 1334, "additions": 724, "deletions": 610}, "files": [{"sha": "2b8782ddf4482c6ba242e79730a81a1896c81cc6", "filename": "library/std/src/sys/common/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e52ada714a46b6150e78c7c5a2ff7178a2d79d3/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e52ada714a46b6150e78c7c5a2ff7178a2d79d3/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fmod.rs?ref=5e52ada714a46b6150e78c7c5a2ff7178a2d79d3", "patch": "@@ -12,6 +12,7 @@\n \n pub mod alloc;\n pub mod small_c_string;\n+pub mod thread_local;\n \n #[cfg(test)]\n mod tests;"}, {"sha": "2addcc4a759d0382c55ef5d3779a08ccefa6213e", "filename": "library/std/src/sys/common/thread_local/fast_local.rs", "status": "added", "additions": 276, "deletions": 0, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/5e52ada714a46b6150e78c7c5a2ff7178a2d79d3/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fthread_local%2Ffast_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e52ada714a46b6150e78c7c5a2ff7178a2d79d3/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fthread_local%2Ffast_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fthread_local%2Ffast_local.rs?ref=5e52ada714a46b6150e78c7c5a2ff7178a2d79d3", "patch": "@@ -0,0 +1,276 @@\n+#[doc(hidden)]\n+#[macro_export]\n+#[allow_internal_unstable(\n+    thread_local_internals,\n+    cfg_target_thread_local,\n+    thread_local,\n+    libstd_thread_internals\n+)]\n+#[allow_internal_unsafe]\n+macro_rules! __thread_local_inner {\n+    // used to generate the `LocalKey` value for const-initialized thread locals\n+    (@key $t:ty, const $init:expr) => {{\n+        #[cfg_attr(not(windows), inline)] // see comments below\n+        #[deny(unsafe_op_in_unsafe_fn)]\n+        unsafe fn __getit(\n+            _init: $crate::option::Option<&mut $crate::option::Option<$t>>,\n+        ) -> $crate::option::Option<&'static $t> {\n+            const INIT_EXPR: $t = $init;\n+            // If the platform has support for `#[thread_local]`, use it.\n+            #[thread_local]\n+            static mut VAL: $t = INIT_EXPR;\n+\n+            // If a dtor isn't needed we can do something \"very raw\" and\n+            // just get going.\n+            if !$crate::mem::needs_drop::<$t>() {\n+                unsafe {\n+                    return $crate::option::Option::Some(&VAL)\n+                }\n+            }\n+\n+            // 0 == dtor not registered\n+            // 1 == dtor registered, dtor not run\n+            // 2 == dtor registered and is running or has run\n+            #[thread_local]\n+            static mut STATE: $crate::primitive::u8 = 0;\n+\n+            unsafe extern \"C\" fn destroy(ptr: *mut $crate::primitive::u8) {\n+                let ptr = ptr as *mut $t;\n+\n+                unsafe {\n+                    $crate::debug_assert_eq!(STATE, 1);\n+                    STATE = 2;\n+                    $crate::ptr::drop_in_place(ptr);\n+                }\n+            }\n+\n+            unsafe {\n+                match STATE {\n+                    // 0 == we haven't registered a destructor, so do\n+                    //   so now.\n+                    0 => {\n+                        $crate::thread::__LocalKeyInner::<$t>::register_dtor(\n+                            $crate::ptr::addr_of_mut!(VAL) as *mut $crate::primitive::u8,\n+                            destroy,\n+                        );\n+                        STATE = 1;\n+                        $crate::option::Option::Some(&VAL)\n+                    }\n+                    // 1 == the destructor is registered and the value\n+                    //   is valid, so return the pointer.\n+                    1 => $crate::option::Option::Some(&VAL),\n+                    // otherwise the destructor has already run, so we\n+                    // can't give access.\n+                    _ => $crate::option::Option::None,\n+                }\n+            }\n+        }\n+\n+        unsafe {\n+            $crate::thread::LocalKey::new(__getit)\n+        }\n+    }};\n+\n+    // used to generate the `LocalKey` value for `thread_local!`\n+    (@key $t:ty, $init:expr) => {\n+        {\n+            #[inline]\n+            fn __init() -> $t { $init }\n+\n+            // When reading this function you might ask \"why is this inlined\n+            // everywhere other than Windows?\", and that's a very reasonable\n+            // question to ask. The short story is that it segfaults rustc if\n+            // this function is inlined. The longer story is that Windows looks\n+            // to not support `extern` references to thread locals across DLL\n+            // boundaries. This appears to at least not be supported in the ABI\n+            // that LLVM implements.\n+            //\n+            // Because of this we never inline on Windows, but we do inline on\n+            // other platforms (where external references to thread locals\n+            // across DLLs are supported). A better fix for this would be to\n+            // inline this function on Windows, but only for \"statically linked\"\n+            // components. For example if two separately compiled rlibs end up\n+            // getting linked into a DLL then it's fine to inline this function\n+            // across that boundary. It's only not fine to inline this function\n+            // across a DLL boundary. Unfortunately rustc doesn't currently\n+            // have this sort of logic available in an attribute, and it's not\n+            // clear that rustc is even equipped to answer this (it's more of a\n+            // Cargo question kinda). This means that, unfortunately, Windows\n+            // gets the pessimistic path for now where it's never inlined.\n+            //\n+            // The issue of \"should enable on Windows sometimes\" is #84933\n+            #[cfg_attr(not(windows), inline)]\n+            unsafe fn __getit(\n+                init: $crate::option::Option<&mut $crate::option::Option<$t>>,\n+            ) -> $crate::option::Option<&'static $t> {\n+                #[thread_local]\n+                static __KEY: $crate::thread::__LocalKeyInner<$t> =\n+                    $crate::thread::__LocalKeyInner::<$t>::new();\n+\n+                // FIXME: remove the #[allow(...)] marker when macros don't\n+                // raise warning for missing/extraneous unsafe blocks anymore.\n+                // See https://github.com/rust-lang/rust/issues/74838.\n+                #[allow(unused_unsafe)]\n+                unsafe {\n+                    __KEY.get(move || {\n+                        if let $crate::option::Option::Some(init) = init {\n+                            if let $crate::option::Option::Some(value) = init.take() {\n+                                return value;\n+                            } else if $crate::cfg!(debug_assertions) {\n+                                $crate::unreachable!(\"missing default value\");\n+                            }\n+                        }\n+                        __init()\n+                    })\n+                }\n+            }\n+\n+            unsafe {\n+                $crate::thread::LocalKey::new(__getit)\n+            }\n+        }\n+    };\n+    ($(#[$attr:meta])* $vis:vis $name:ident, $t:ty, $($init:tt)*) => {\n+        $(#[$attr])* $vis const $name: $crate::thread::LocalKey<$t> =\n+            $crate::__thread_local_inner!(@key $t, $($init)*);\n+    }\n+}\n+\n+#[doc(hidden)]\n+pub mod fast {\n+    use super::super::lazy::LazyKeyInner;\n+    use crate::cell::Cell;\n+    use crate::sys::thread_local_dtor::register_dtor;\n+    use crate::{fmt, mem, panic};\n+\n+    #[derive(Copy, Clone)]\n+    enum DtorState {\n+        Unregistered,\n+        Registered,\n+        RunningOrHasRun,\n+    }\n+\n+    // This data structure has been carefully constructed so that the fast path\n+    // only contains one branch on x86. That optimization is necessary to avoid\n+    // duplicated tls lookups on OSX.\n+    //\n+    // LLVM issue: https://bugs.llvm.org/show_bug.cgi?id=41722\n+    pub struct Key<T> {\n+        // If `LazyKeyInner::get` returns `None`, that indicates either:\n+        //   * The value has never been initialized\n+        //   * The value is being recursively initialized\n+        //   * The value has already been destroyed or is being destroyed\n+        // To determine which kind of `None`, check `dtor_state`.\n+        //\n+        // This is very optimizer friendly for the fast path - initialized but\n+        // not yet dropped.\n+        inner: LazyKeyInner<T>,\n+\n+        // Metadata to keep track of the state of the destructor. Remember that\n+        // this variable is thread-local, not global.\n+        dtor_state: Cell<DtorState>,\n+    }\n+\n+    impl<T> fmt::Debug for Key<T> {\n+        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+            f.debug_struct(\"Key\").finish_non_exhaustive()\n+        }\n+    }\n+\n+    impl<T> Key<T> {\n+        pub const fn new() -> Key<T> {\n+            Key { inner: LazyKeyInner::new(), dtor_state: Cell::new(DtorState::Unregistered) }\n+        }\n+\n+        // note that this is just a publicly-callable function only for the\n+        // const-initialized form of thread locals, basically a way to call the\n+        // free `register_dtor` function defined elsewhere in std.\n+        pub unsafe fn register_dtor(a: *mut u8, dtor: unsafe extern \"C\" fn(*mut u8)) {\n+            unsafe {\n+                register_dtor(a, dtor);\n+            }\n+        }\n+\n+        pub unsafe fn get<F: FnOnce() -> T>(&self, init: F) -> Option<&'static T> {\n+            // SAFETY: See the definitions of `LazyKeyInner::get` and\n+            // `try_initialize` for more information.\n+            //\n+            // The caller must ensure no mutable references are ever active to\n+            // the inner cell or the inner T when this is called.\n+            // The `try_initialize` is dependant on the passed `init` function\n+            // for this.\n+            unsafe {\n+                match self.inner.get() {\n+                    Some(val) => Some(val),\n+                    None => self.try_initialize(init),\n+                }\n+            }\n+        }\n+\n+        // `try_initialize` is only called once per fast thread local variable,\n+        // except in corner cases where thread_local dtors reference other\n+        // thread_local's, or it is being recursively initialized.\n+        //\n+        // Macos: Inlining this function can cause two `tlv_get_addr` calls to\n+        // be performed for every call to `Key::get`.\n+        // LLVM issue: https://bugs.llvm.org/show_bug.cgi?id=41722\n+        #[inline(never)]\n+        unsafe fn try_initialize<F: FnOnce() -> T>(&self, init: F) -> Option<&'static T> {\n+            // SAFETY: See comment above (this function doc).\n+            if !mem::needs_drop::<T>() || unsafe { self.try_register_dtor() } {\n+                // SAFETY: See comment above (this function doc).\n+                Some(unsafe { self.inner.initialize(init) })\n+            } else {\n+                None\n+            }\n+        }\n+\n+        // `try_register_dtor` is only called once per fast thread local\n+        // variable, except in corner cases where thread_local dtors reference\n+        // other thread_local's, or it is being recursively initialized.\n+        unsafe fn try_register_dtor(&self) -> bool {\n+            match self.dtor_state.get() {\n+                DtorState::Unregistered => {\n+                    // SAFETY: dtor registration happens before initialization.\n+                    // Passing `self` as a pointer while using `destroy_value<T>`\n+                    // is safe because the function will build a pointer to a\n+                    // Key<T>, which is the type of self and so find the correct\n+                    // size.\n+                    unsafe { register_dtor(self as *const _ as *mut u8, destroy_value::<T>) };\n+                    self.dtor_state.set(DtorState::Registered);\n+                    true\n+                }\n+                DtorState::Registered => {\n+                    // recursively initialized\n+                    true\n+                }\n+                DtorState::RunningOrHasRun => false,\n+            }\n+        }\n+    }\n+\n+    unsafe extern \"C\" fn destroy_value<T>(ptr: *mut u8) {\n+        let ptr = ptr as *mut Key<T>;\n+\n+        // SAFETY:\n+        //\n+        // The pointer `ptr` has been built just above and comes from\n+        // `try_register_dtor` where it is originally a Key<T> coming from `self`,\n+        // making it non-NUL and of the correct type.\n+        //\n+        // Right before we run the user destructor be sure to set the\n+        // `Option<T>` to `None`, and `dtor_state` to `RunningOrHasRun`. This\n+        // causes future calls to `get` to run `try_initialize_drop` again,\n+        // which will now fail, and return `None`.\n+        //\n+        // Wrap the call in a catch to ensure unwinding is caught in the event\n+        // a panic takes place in a destructor.\n+        if let Err(_) = panic::catch_unwind(panic::AssertUnwindSafe(|| unsafe {\n+            let value = (*ptr).inner.take();\n+            (*ptr).dtor_state.set(DtorState::RunningOrHasRun);\n+            drop(value);\n+        })) {\n+            rtabort!(\"thread local panicked on drop\");\n+        }\n+    }\n+}"}, {"sha": "1fee84a04349cde2d2382f9c484ff725f457161e", "filename": "library/std/src/sys/common/thread_local/mod.rs", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/5e52ada714a46b6150e78c7c5a2ff7178a2d79d3/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fthread_local%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e52ada714a46b6150e78c7c5a2ff7178a2d79d3/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fthread_local%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fthread_local%2Fmod.rs?ref=5e52ada714a46b6150e78c7c5a2ff7178a2d79d3", "patch": "@@ -0,0 +1,109 @@\n+//! The following module declarations are outside cfg_if because the internal\n+//! `__thread_local_internal` macro does not seem to be exported properly when using cfg_if\n+#![unstable(feature = \"thread_local_internals\", reason = \"should not be necessary\", issue = \"none\")]\n+\n+#[cfg(all(target_thread_local, not(all(target_family = \"wasm\", not(target_feature = \"atomics\")))))]\n+mod fast_local;\n+#[cfg(all(\n+    not(target_thread_local),\n+    not(all(target_family = \"wasm\", not(target_feature = \"atomics\")))\n+))]\n+mod os_local;\n+#[cfg(all(target_family = \"wasm\", not(target_feature = \"atomics\")))]\n+mod static_local;\n+\n+#[cfg(not(test))]\n+cfg_if::cfg_if! {\n+    if #[cfg(all(target_family = \"wasm\", not(target_feature = \"atomics\")))] {\n+        #[doc(hidden)]\n+        pub use static_local::statik::Key;\n+    } else if #[cfg(all(target_thread_local, not(all(target_family = \"wasm\", not(target_feature = \"atomics\")))))] {\n+        #[doc(hidden)]\n+        pub use fast_local::fast::Key;\n+    } else if #[cfg(all(not(target_thread_local), not(all(target_family = \"wasm\", not(target_feature = \"atomics\")))))] {\n+        #[doc(hidden)]\n+        pub use os_local::os::Key;\n+    }\n+}\n+\n+#[doc(hidden)]\n+#[cfg(test)]\n+pub use realstd::thread::__LocalKeyInner as Key;\n+\n+mod lazy {\n+    use crate::cell::UnsafeCell;\n+    use crate::hint;\n+    use crate::mem;\n+\n+    pub struct LazyKeyInner<T> {\n+        inner: UnsafeCell<Option<T>>,\n+    }\n+\n+    impl<T> LazyKeyInner<T> {\n+        pub const fn new() -> LazyKeyInner<T> {\n+            LazyKeyInner { inner: UnsafeCell::new(None) }\n+        }\n+\n+        pub unsafe fn get(&self) -> Option<&'static T> {\n+            // SAFETY: The caller must ensure no reference is ever handed out to\n+            // the inner cell nor mutable reference to the Option<T> inside said\n+            // cell. This make it safe to hand a reference, though the lifetime\n+            // of 'static is itself unsafe, making the get method unsafe.\n+            unsafe { (*self.inner.get()).as_ref() }\n+        }\n+\n+        /// The caller must ensure that no reference is active: this method\n+        /// needs unique access.\n+        pub unsafe fn initialize<F: FnOnce() -> T>(&self, init: F) -> &'static T {\n+            // Execute the initialization up front, *then* move it into our slot,\n+            // just in case initialization fails.\n+            let value = init();\n+            let ptr = self.inner.get();\n+\n+            // SAFETY:\n+            //\n+            // note that this can in theory just be `*ptr = Some(value)`, but due to\n+            // the compiler will currently codegen that pattern with something like:\n+            //\n+            //      ptr::drop_in_place(ptr)\n+            //      ptr::write(ptr, Some(value))\n+            //\n+            // Due to this pattern it's possible for the destructor of the value in\n+            // `ptr` (e.g., if this is being recursively initialized) to re-access\n+            // TLS, in which case there will be a `&` and `&mut` pointer to the same\n+            // value (an aliasing violation). To avoid setting the \"I'm running a\n+            // destructor\" flag we just use `mem::replace` which should sequence the\n+            // operations a little differently and make this safe to call.\n+            //\n+            // The precondition also ensures that we are the only one accessing\n+            // `self` at the moment so replacing is fine.\n+            unsafe {\n+                let _ = mem::replace(&mut *ptr, Some(value));\n+            }\n+\n+            // SAFETY: With the call to `mem::replace` it is guaranteed there is\n+            // a `Some` behind `ptr`, not a `None` so `unreachable_unchecked`\n+            // will never be reached.\n+            unsafe {\n+                // After storing `Some` we want to get a reference to the contents of\n+                // what we just stored. While we could use `unwrap` here and it should\n+                // always work it empirically doesn't seem to always get optimized away,\n+                // which means that using something like `try_with` can pull in\n+                // panicking code and cause a large size bloat.\n+                match *ptr {\n+                    Some(ref x) => x,\n+                    None => hint::unreachable_unchecked(),\n+                }\n+            }\n+        }\n+\n+        /// The other methods hand out references while taking &self.\n+        /// As such, callers of this method must ensure no `&` and `&mut` are\n+        /// available and used at the same time.\n+        #[allow(unused)]\n+        pub unsafe fn take(&mut self) -> Option<T> {\n+            // SAFETY: See doc comment for this method.\n+            unsafe { (*self.inner.get()).take() }\n+        }\n+    }\n+}"}, {"sha": "6f6560c4aa94998708483a73ed2c43117a7df2d2", "filename": "library/std/src/sys/common/thread_local/os_local.rs", "status": "added", "additions": 217, "deletions": 0, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/5e52ada714a46b6150e78c7c5a2ff7178a2d79d3/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fthread_local%2Fos_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e52ada714a46b6150e78c7c5a2ff7178a2d79d3/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fthread_local%2Fos_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fthread_local%2Fos_local.rs?ref=5e52ada714a46b6150e78c7c5a2ff7178a2d79d3", "patch": "@@ -0,0 +1,217 @@\n+#[doc(hidden)]\n+#[macro_export]\n+#[allow_internal_unstable(\n+    thread_local_internals,\n+    cfg_target_thread_local,\n+    thread_local,\n+    libstd_thread_internals\n+)]\n+#[allow_internal_unsafe]\n+macro_rules! __thread_local_inner {\n+    // used to generate the `LocalKey` value for const-initialized thread locals\n+    (@key $t:ty, const $init:expr) => {{\n+        #[cfg_attr(not(windows), inline)] // see comments below\n+        #[deny(unsafe_op_in_unsafe_fn)]\n+        unsafe fn __getit(\n+            _init: $crate::option::Option<&mut $crate::option::Option<$t>>,\n+        ) -> $crate::option::Option<&'static $t> {\n+            const INIT_EXPR: $t = $init;\n+\n+                        // On platforms without `#[thread_local]` we fall back to the\n+            // same implementation as below for os thread locals.\n+            #[inline]\n+            const fn __init() -> $t { INIT_EXPR }\n+            static __KEY: $crate::thread::__LocalKeyInner<$t> =\n+                $crate::thread::__LocalKeyInner::new();\n+            #[allow(unused_unsafe)]\n+            unsafe {\n+                __KEY.get(move || {\n+                    if let $crate::option::Option::Some(init) = _init {\n+                        if let $crate::option::Option::Some(value) = init.take() {\n+                            return value;\n+                        } else if $crate::cfg!(debug_assertions) {\n+                            $crate::unreachable!(\"missing initial value\");\n+                        }\n+                    }\n+                    __init()\n+                })\n+            }\n+        }\n+\n+        unsafe {\n+            $crate::thread::LocalKey::new(__getit)\n+        }\n+    }};\n+\n+    // used to generate the `LocalKey` value for `thread_local!`\n+    (@key $t:ty, $init:expr) => {\n+        {\n+            #[inline]\n+            fn __init() -> $t { $init }\n+\n+            // When reading this function you might ask \"why is this inlined\n+            // everywhere other than Windows?\", and that's a very reasonable\n+            // question to ask. The short story is that it segfaults rustc if\n+            // this function is inlined. The longer story is that Windows looks\n+            // to not support `extern` references to thread locals across DLL\n+            // boundaries. This appears to at least not be supported in the ABI\n+            // that LLVM implements.\n+            //\n+            // Because of this we never inline on Windows, but we do inline on\n+            // other platforms (where external references to thread locals\n+            // across DLLs are supported). A better fix for this would be to\n+            // inline this function on Windows, but only for \"statically linked\"\n+            // components. For example if two separately compiled rlibs end up\n+            // getting linked into a DLL then it's fine to inline this function\n+            // across that boundary. It's only not fine to inline this function\n+            // across a DLL boundary. Unfortunately rustc doesn't currently\n+            // have this sort of logic available in an attribute, and it's not\n+            // clear that rustc is even equipped to answer this (it's more of a\n+            // Cargo question kinda). This means that, unfortunately, Windows\n+            // gets the pessimistic path for now where it's never inlined.\n+            //\n+            // The issue of \"should enable on Windows sometimes\" is #84933\n+            #[cfg_attr(not(windows), inline)]\n+            unsafe fn __getit(\n+                init: $crate::option::Option<&mut $crate::option::Option<$t>>,\n+            ) -> $crate::option::Option<&'static $t> {\n+                static __KEY: $crate::thread::__LocalKeyInner<$t> =\n+                    $crate::thread::__LocalKeyInner::new();\n+\n+                // FIXME: remove the #[allow(...)] marker when macros don't\n+                // raise warning for missing/extraneous unsafe blocks anymore.\n+                // See https://github.com/rust-lang/rust/issues/74838.\n+                #[allow(unused_unsafe)]\n+                unsafe {\n+                    __KEY.get(move || {\n+                        if let $crate::option::Option::Some(init) = init {\n+                            if let $crate::option::Option::Some(value) = init.take() {\n+                                return value;\n+                            } else if $crate::cfg!(debug_assertions) {\n+                                $crate::unreachable!(\"missing default value\");\n+                            }\n+                        }\n+                        __init()\n+                    })\n+                }\n+            }\n+\n+            unsafe {\n+                $crate::thread::LocalKey::new(__getit)\n+            }\n+        }\n+    };\n+    ($(#[$attr:meta])* $vis:vis $name:ident, $t:ty, $($init:tt)*) => {\n+        $(#[$attr])* $vis const $name: $crate::thread::LocalKey<$t> =\n+            $crate::__thread_local_inner!(@key $t, $($init)*);\n+    }\n+}\n+\n+#[doc(hidden)]\n+pub mod os {\n+    use super::super::lazy::LazyKeyInner;\n+    use crate::cell::Cell;\n+    use crate::sys_common::thread_local_key::StaticKey as OsStaticKey;\n+    use crate::{fmt, marker, panic, ptr};\n+\n+    /// Use a regular global static to store this key; the state provided will then be\n+    /// thread-local.\n+    pub struct Key<T> {\n+        // OS-TLS key that we'll use to key off.\n+        os: OsStaticKey,\n+        marker: marker::PhantomData<Cell<T>>,\n+    }\n+\n+    impl<T> fmt::Debug for Key<T> {\n+        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+            f.debug_struct(\"Key\").finish_non_exhaustive()\n+        }\n+    }\n+\n+    unsafe impl<T> Sync for Key<T> {}\n+\n+    struct Value<T: 'static> {\n+        inner: LazyKeyInner<T>,\n+        key: &'static Key<T>,\n+    }\n+\n+    impl<T: 'static> Key<T> {\n+        #[rustc_const_unstable(feature = \"thread_local_internals\", issue = \"none\")]\n+        pub const fn new() -> Key<T> {\n+            Key { os: OsStaticKey::new(Some(destroy_value::<T>)), marker: marker::PhantomData }\n+        }\n+\n+        /// It is a requirement for the caller to ensure that no mutable\n+        /// reference is active when this method is called.\n+        pub unsafe fn get(&'static self, init: impl FnOnce() -> T) -> Option<&'static T> {\n+            // SAFETY: See the documentation for this method.\n+            let ptr = unsafe { self.os.get() as *mut Value<T> };\n+            if ptr.addr() > 1 {\n+                // SAFETY: the check ensured the pointer is safe (its destructor\n+                // is not running) + it is coming from a trusted source (self).\n+                if let Some(ref value) = unsafe { (*ptr).inner.get() } {\n+                    return Some(value);\n+                }\n+            }\n+            // SAFETY: At this point we are sure we have no value and so\n+            // initializing (or trying to) is safe.\n+            unsafe { self.try_initialize(init) }\n+        }\n+\n+        // `try_initialize` is only called once per os thread local variable,\n+        // except in corner cases where thread_local dtors reference other\n+        // thread_local's, or it is being recursively initialized.\n+        unsafe fn try_initialize(&'static self, init: impl FnOnce() -> T) -> Option<&'static T> {\n+            // SAFETY: No mutable references are ever handed out meaning getting\n+            // the value is ok.\n+            let ptr = unsafe { self.os.get() as *mut Value<T> };\n+            if ptr.addr() == 1 {\n+                // destructor is running\n+                return None;\n+            }\n+\n+            let ptr = if ptr.is_null() {\n+                // If the lookup returned null, we haven't initialized our own\n+                // local copy, so do that now.\n+                let ptr = Box::into_raw(Box::new(Value { inner: LazyKeyInner::new(), key: self }));\n+                // SAFETY: At this point we are sure there is no value inside\n+                // ptr so setting it will not affect anyone else.\n+                unsafe {\n+                    self.os.set(ptr as *mut u8);\n+                }\n+                ptr\n+            } else {\n+                // recursive initialization\n+                ptr\n+            };\n+\n+            // SAFETY: ptr has been ensured as non-NUL just above an so can be\n+            // dereferenced safely.\n+            unsafe { Some((*ptr).inner.initialize(init)) }\n+        }\n+    }\n+\n+    unsafe extern \"C\" fn destroy_value<T: 'static>(ptr: *mut u8) {\n+        // SAFETY:\n+        //\n+        // The OS TLS ensures that this key contains a null value when this\n+        // destructor starts to run. We set it back to a sentinel value of 1 to\n+        // ensure that any future calls to `get` for this thread will return\n+        // `None`.\n+        //\n+        // Note that to prevent an infinite loop we reset it back to null right\n+        // before we return from the destructor ourselves.\n+        //\n+        // Wrap the call in a catch to ensure unwinding is caught in the event\n+        // a panic takes place in a destructor.\n+        if let Err(_) = panic::catch_unwind(|| unsafe {\n+            let ptr = Box::from_raw(ptr as *mut Value<T>);\n+            let key = ptr.key;\n+            key.os.set(ptr::invalid_mut(1));\n+            drop(ptr);\n+            key.os.set(ptr::null_mut());\n+        }) {\n+            rtabort!(\"thread local panicked on drop\");\n+        }\n+    }\n+}"}, {"sha": "ec4f2a12b7ee4a277412b40a1abefa88a87b3da5", "filename": "library/std/src/sys/common/thread_local/static_local.rs", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/5e52ada714a46b6150e78c7c5a2ff7178a2d79d3/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fthread_local%2Fstatic_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e52ada714a46b6150e78c7c5a2ff7178a2d79d3/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fthread_local%2Fstatic_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fthread_local%2Fstatic_local.rs?ref=5e52ada714a46b6150e78c7c5a2ff7178a2d79d3", "patch": "@@ -0,0 +1,115 @@\n+#[doc(hidden)]\n+#[macro_export]\n+#[allow_internal_unstable(\n+    thread_local_internals,\n+    cfg_target_thread_local,\n+    thread_local,\n+    libstd_thread_internals\n+)]\n+#[allow_internal_unsafe]\n+macro_rules! __thread_local_inner {\n+    // used to generate the `LocalKey` value for const-initialized thread locals\n+    (@key $t:ty, const $init:expr) => {{\n+        #[inline] // see comments below\n+        #[deny(unsafe_op_in_unsafe_fn)]\n+        unsafe fn __getit(\n+            _init: $crate::option::Option<&mut $crate::option::Option<$t>>,\n+        ) -> $crate::option::Option<&'static $t> {\n+            const INIT_EXPR: $t = $init;\n+\n+            // wasm without atomics maps directly to `static mut`, and dtors\n+            // aren't implemented because thread dtors aren't really a thing\n+            // on wasm right now\n+            //\n+            // FIXME(#84224) this should come after the `target_thread_local`\n+            // block.\n+            static mut VAL: $t = INIT_EXPR;\n+            unsafe { $crate::option::Option::Some(&VAL) }\n+        }\n+\n+        unsafe {\n+            $crate::thread::LocalKey::new(__getit)\n+        }\n+    }};\n+\n+    // used to generate the `LocalKey` value for `thread_local!`\n+    (@key $t:ty, $init:expr) => {\n+        {\n+            #[inline]\n+            fn __init() -> $t { $init }\n+            #[inline]\n+            unsafe fn __getit(\n+                init: $crate::option::Option<&mut $crate::option::Option<$t>>,\n+            ) -> $crate::option::Option<&'static $t> {\n+                static __KEY: $crate::thread::__LocalKeyInner<$t> =\n+                    $crate::thread::__LocalKeyInner::new();\n+\n+                // FIXME: remove the #[allow(...)] marker when macros don't\n+                // raise warning for missing/extraneous unsafe blocks anymore.\n+                // See https://github.com/rust-lang/rust/issues/74838.\n+                #[allow(unused_unsafe)]\n+                unsafe {\n+                    __KEY.get(move || {\n+                        if let $crate::option::Option::Some(init) = init {\n+                            if let $crate::option::Option::Some(value) = init.take() {\n+                                return value;\n+                            } else if $crate::cfg!(debug_assertions) {\n+                                $crate::unreachable!(\"missing default value\");\n+                            }\n+                        }\n+                        __init()\n+                    })\n+                }\n+            }\n+\n+            unsafe {\n+                $crate::thread::LocalKey::new(__getit)\n+            }\n+        }\n+    };\n+    ($(#[$attr:meta])* $vis:vis $name:ident, $t:ty, $($init:tt)*) => {\n+        $(#[$attr])* $vis const $name: $crate::thread::LocalKey<$t> =\n+            $crate::__thread_local_inner!(@key $t, $($init)*);\n+    }\n+}\n+\n+/// On some targets like wasm there's no threads, so no need to generate\n+/// thread locals and we can instead just use plain statics!\n+#[doc(hidden)]\n+pub mod statik {\n+    use super::super::lazy::LazyKeyInner;\n+    use crate::fmt;\n+\n+    pub struct Key<T> {\n+        inner: LazyKeyInner<T>,\n+    }\n+\n+    unsafe impl<T> Sync for Key<T> {}\n+\n+    impl<T> fmt::Debug for Key<T> {\n+        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+            f.debug_struct(\"Key\").finish_non_exhaustive()\n+        }\n+    }\n+\n+    impl<T> Key<T> {\n+        pub const fn new() -> Key<T> {\n+            Key { inner: LazyKeyInner::new() }\n+        }\n+\n+        pub unsafe fn get(&self, init: impl FnOnce() -> T) -> Option<&'static T> {\n+            // SAFETY: The caller must ensure no reference is ever handed out to\n+            // the inner cell nor mutable reference to the Option<T> inside said\n+            // cell. This make it safe to hand a reference, though the lifetime\n+            // of 'static is itself unsafe, making the get method unsafe.\n+            let value = unsafe {\n+                match self.inner.get() {\n+                    Some(ref value) => value,\n+                    None => self.inner.initialize(init),\n+                }\n+            };\n+\n+            Some(value)\n+        }\n+    }\n+}"}, {"sha": "7fdf03acc14d92c0c716122469a1ee86bc7c5b2f", "filename": "library/std/src/thread/local.rs", "status": "modified", "additions": 0, "deletions": 567, "changes": 567, "blob_url": "https://github.com/rust-lang/rust/blob/5e52ada714a46b6150e78c7c5a2ff7178a2d79d3/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e52ada714a46b6150e78c7c5a2ff7178a2d79d3/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs?ref=5e52ada714a46b6150e78c7c5a2ff7178a2d79d3", "patch": "@@ -173,200 +173,6 @@ macro_rules! thread_local {\n     );\n }\n \n-#[doc(hidden)]\n-#[unstable(feature = \"thread_local_internals\", reason = \"should not be necessary\", issue = \"none\")]\n-#[macro_export]\n-#[allow_internal_unstable(thread_local_internals, cfg_target_thread_local, thread_local)]\n-#[allow_internal_unsafe]\n-macro_rules! __thread_local_inner {\n-    // used to generate the `LocalKey` value for const-initialized thread locals\n-    (@key $t:ty, const $init:expr) => {{\n-        #[cfg_attr(not(windows), inline)] // see comments below\n-        #[deny(unsafe_op_in_unsafe_fn)]\n-        unsafe fn __getit(\n-            _init: $crate::option::Option<&mut $crate::option::Option<$t>>,\n-        ) -> $crate::option::Option<&'static $t> {\n-            const INIT_EXPR: $t = $init;\n-\n-            // wasm without atomics maps directly to `static mut`, and dtors\n-            // aren't implemented because thread dtors aren't really a thing\n-            // on wasm right now\n-            //\n-            // FIXME(#84224) this should come after the `target_thread_local`\n-            // block.\n-            #[cfg(all(target_family = \"wasm\", not(target_feature = \"atomics\")))]\n-            {\n-                static mut VAL: $t = INIT_EXPR;\n-                unsafe { $crate::option::Option::Some(&VAL) }\n-            }\n-\n-            // If the platform has support for `#[thread_local]`, use it.\n-            #[cfg(all(\n-                target_thread_local,\n-                not(all(target_family = \"wasm\", not(target_feature = \"atomics\"))),\n-            ))]\n-            {\n-                #[thread_local]\n-                static mut VAL: $t = INIT_EXPR;\n-\n-                // If a dtor isn't needed we can do something \"very raw\" and\n-                // just get going.\n-                if !$crate::mem::needs_drop::<$t>() {\n-                    unsafe {\n-                        return $crate::option::Option::Some(&VAL)\n-                    }\n-                }\n-\n-                // 0 == dtor not registered\n-                // 1 == dtor registered, dtor not run\n-                // 2 == dtor registered and is running or has run\n-                #[thread_local]\n-                static mut STATE: $crate::primitive::u8 = 0;\n-\n-                unsafe extern \"C\" fn destroy(ptr: *mut $crate::primitive::u8) {\n-                    let ptr = ptr as *mut $t;\n-\n-                    unsafe {\n-                        $crate::debug_assert_eq!(STATE, 1);\n-                        STATE = 2;\n-                        $crate::ptr::drop_in_place(ptr);\n-                    }\n-                }\n-\n-                unsafe {\n-                    match STATE {\n-                        // 0 == we haven't registered a destructor, so do\n-                        //   so now.\n-                        0 => {\n-                            $crate::thread::__FastLocalKeyInner::<$t>::register_dtor(\n-                                $crate::ptr::addr_of_mut!(VAL) as *mut $crate::primitive::u8,\n-                                destroy,\n-                            );\n-                            STATE = 1;\n-                            $crate::option::Option::Some(&VAL)\n-                        }\n-                        // 1 == the destructor is registered and the value\n-                        //   is valid, so return the pointer.\n-                        1 => $crate::option::Option::Some(&VAL),\n-                        // otherwise the destructor has already run, so we\n-                        // can't give access.\n-                        _ => $crate::option::Option::None,\n-                    }\n-                }\n-            }\n-\n-            // On platforms without `#[thread_local]` we fall back to the\n-            // same implementation as below for os thread locals.\n-            #[cfg(all(\n-                not(target_thread_local),\n-                not(all(target_family = \"wasm\", not(target_feature = \"atomics\"))),\n-            ))]\n-            {\n-                #[inline]\n-                const fn __init() -> $t { INIT_EXPR }\n-                static __KEY: $crate::thread::__OsLocalKeyInner<$t> =\n-                    $crate::thread::__OsLocalKeyInner::new();\n-                #[allow(unused_unsafe)]\n-                unsafe {\n-                    __KEY.get(move || {\n-                        if let $crate::option::Option::Some(init) = _init {\n-                            if let $crate::option::Option::Some(value) = init.take() {\n-                                return value;\n-                            } else if $crate::cfg!(debug_assertions) {\n-                                $crate::unreachable!(\"missing initial value\");\n-                            }\n-                        }\n-                        __init()\n-                    })\n-                }\n-            }\n-        }\n-\n-        unsafe {\n-            $crate::thread::LocalKey::new(__getit)\n-        }\n-    }};\n-\n-    // used to generate the `LocalKey` value for `thread_local!`\n-    (@key $t:ty, $init:expr) => {\n-        {\n-            #[inline]\n-            fn __init() -> $t { $init }\n-\n-            // When reading this function you might ask \"why is this inlined\n-            // everywhere other than Windows?\", and that's a very reasonable\n-            // question to ask. The short story is that it segfaults rustc if\n-            // this function is inlined. The longer story is that Windows looks\n-            // to not support `extern` references to thread locals across DLL\n-            // boundaries. This appears to at least not be supported in the ABI\n-            // that LLVM implements.\n-            //\n-            // Because of this we never inline on Windows, but we do inline on\n-            // other platforms (where external references to thread locals\n-            // across DLLs are supported). A better fix for this would be to\n-            // inline this function on Windows, but only for \"statically linked\"\n-            // components. For example if two separately compiled rlibs end up\n-            // getting linked into a DLL then it's fine to inline this function\n-            // across that boundary. It's only not fine to inline this function\n-            // across a DLL boundary. Unfortunately rustc doesn't currently\n-            // have this sort of logic available in an attribute, and it's not\n-            // clear that rustc is even equipped to answer this (it's more of a\n-            // Cargo question kinda). This means that, unfortunately, Windows\n-            // gets the pessimistic path for now where it's never inlined.\n-            //\n-            // The issue of \"should enable on Windows sometimes\" is #84933\n-            #[cfg_attr(not(windows), inline)]\n-            unsafe fn __getit(\n-                init: $crate::option::Option<&mut $crate::option::Option<$t>>,\n-            ) -> $crate::option::Option<&'static $t> {\n-                #[cfg(all(target_family = \"wasm\", not(target_feature = \"atomics\")))]\n-                static __KEY: $crate::thread::__StaticLocalKeyInner<$t> =\n-                    $crate::thread::__StaticLocalKeyInner::new();\n-\n-                #[thread_local]\n-                #[cfg(all(\n-                    target_thread_local,\n-                    not(all(target_family = \"wasm\", not(target_feature = \"atomics\"))),\n-                ))]\n-                static __KEY: $crate::thread::__FastLocalKeyInner<$t> =\n-                    $crate::thread::__FastLocalKeyInner::new();\n-\n-                #[cfg(all(\n-                    not(target_thread_local),\n-                    not(all(target_family = \"wasm\", not(target_feature = \"atomics\"))),\n-                ))]\n-                static __KEY: $crate::thread::__OsLocalKeyInner<$t> =\n-                    $crate::thread::__OsLocalKeyInner::new();\n-\n-                // FIXME: remove the #[allow(...)] marker when macros don't\n-                // raise warning for missing/extraneous unsafe blocks anymore.\n-                // See https://github.com/rust-lang/rust/issues/74838.\n-                #[allow(unused_unsafe)]\n-                unsafe {\n-                    __KEY.get(move || {\n-                        if let $crate::option::Option::Some(init) = init {\n-                            if let $crate::option::Option::Some(value) = init.take() {\n-                                return value;\n-                            } else if $crate::cfg!(debug_assertions) {\n-                                $crate::unreachable!(\"missing default value\");\n-                            }\n-                        }\n-                        __init()\n-                    })\n-                }\n-            }\n-\n-            unsafe {\n-                $crate::thread::LocalKey::new(__getit)\n-            }\n-        }\n-    };\n-    ($(#[$attr:meta])* $vis:vis $name:ident, $t:ty, $($init:tt)*) => {\n-        $(#[$attr])* $vis const $name: $crate::thread::LocalKey<$t> =\n-            $crate::__thread_local_inner!(@key $t, $($init)*);\n-    }\n-}\n-\n /// An error returned by [`LocalKey::try_with`](struct.LocalKey.html#method.try_with).\n #[stable(feature = \"thread_local_try_with\", since = \"1.26.0\")]\n #[non_exhaustive]\n@@ -779,376 +585,3 @@ impl<T: 'static> LocalKey<RefCell<T>> {\n         self.with(|cell| cell.replace(value))\n     }\n }\n-\n-mod lazy {\n-    use crate::cell::UnsafeCell;\n-    use crate::hint;\n-    use crate::mem;\n-\n-    pub struct LazyKeyInner<T> {\n-        inner: UnsafeCell<Option<T>>,\n-    }\n-\n-    impl<T> LazyKeyInner<T> {\n-        pub const fn new() -> LazyKeyInner<T> {\n-            LazyKeyInner { inner: UnsafeCell::new(None) }\n-        }\n-\n-        pub unsafe fn get(&self) -> Option<&'static T> {\n-            // SAFETY: The caller must ensure no reference is ever handed out to\n-            // the inner cell nor mutable reference to the Option<T> inside said\n-            // cell. This make it safe to hand a reference, though the lifetime\n-            // of 'static is itself unsafe, making the get method unsafe.\n-            unsafe { (*self.inner.get()).as_ref() }\n-        }\n-\n-        /// The caller must ensure that no reference is active: this method\n-        /// needs unique access.\n-        pub unsafe fn initialize<F: FnOnce() -> T>(&self, init: F) -> &'static T {\n-            // Execute the initialization up front, *then* move it into our slot,\n-            // just in case initialization fails.\n-            let value = init();\n-            let ptr = self.inner.get();\n-\n-            // SAFETY:\n-            //\n-            // note that this can in theory just be `*ptr = Some(value)`, but due to\n-            // the compiler will currently codegen that pattern with something like:\n-            //\n-            //      ptr::drop_in_place(ptr)\n-            //      ptr::write(ptr, Some(value))\n-            //\n-            // Due to this pattern it's possible for the destructor of the value in\n-            // `ptr` (e.g., if this is being recursively initialized) to re-access\n-            // TLS, in which case there will be a `&` and `&mut` pointer to the same\n-            // value (an aliasing violation). To avoid setting the \"I'm running a\n-            // destructor\" flag we just use `mem::replace` which should sequence the\n-            // operations a little differently and make this safe to call.\n-            //\n-            // The precondition also ensures that we are the only one accessing\n-            // `self` at the moment so replacing is fine.\n-            unsafe {\n-                let _ = mem::replace(&mut *ptr, Some(value));\n-            }\n-\n-            // SAFETY: With the call to `mem::replace` it is guaranteed there is\n-            // a `Some` behind `ptr`, not a `None` so `unreachable_unchecked`\n-            // will never be reached.\n-            unsafe {\n-                // After storing `Some` we want to get a reference to the contents of\n-                // what we just stored. While we could use `unwrap` here and it should\n-                // always work it empirically doesn't seem to always get optimized away,\n-                // which means that using something like `try_with` can pull in\n-                // panicking code and cause a large size bloat.\n-                match *ptr {\n-                    Some(ref x) => x,\n-                    None => hint::unreachable_unchecked(),\n-                }\n-            }\n-        }\n-\n-        /// The other methods hand out references while taking &self.\n-        /// As such, callers of this method must ensure no `&` and `&mut` are\n-        /// available and used at the same time.\n-        #[allow(unused)]\n-        pub unsafe fn take(&mut self) -> Option<T> {\n-            // SAFETY: See doc comment for this method.\n-            unsafe { (*self.inner.get()).take() }\n-        }\n-    }\n-}\n-\n-/// On some targets like wasm there's no threads, so no need to generate\n-/// thread locals and we can instead just use plain statics!\n-#[doc(hidden)]\n-#[cfg(all(target_family = \"wasm\", not(target_feature = \"atomics\")))]\n-pub mod statik {\n-    use super::lazy::LazyKeyInner;\n-    use crate::fmt;\n-\n-    pub struct Key<T> {\n-        inner: LazyKeyInner<T>,\n-    }\n-\n-    unsafe impl<T> Sync for Key<T> {}\n-\n-    impl<T> fmt::Debug for Key<T> {\n-        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-            f.debug_struct(\"Key\").finish_non_exhaustive()\n-        }\n-    }\n-\n-    impl<T> Key<T> {\n-        pub const fn new() -> Key<T> {\n-            Key { inner: LazyKeyInner::new() }\n-        }\n-\n-        pub unsafe fn get(&self, init: impl FnOnce() -> T) -> Option<&'static T> {\n-            // SAFETY: The caller must ensure no reference is ever handed out to\n-            // the inner cell nor mutable reference to the Option<T> inside said\n-            // cell. This make it safe to hand a reference, though the lifetime\n-            // of 'static is itself unsafe, making the get method unsafe.\n-            let value = unsafe {\n-                match self.inner.get() {\n-                    Some(ref value) => value,\n-                    None => self.inner.initialize(init),\n-                }\n-            };\n-\n-            Some(value)\n-        }\n-    }\n-}\n-\n-#[doc(hidden)]\n-#[cfg(all(target_thread_local, not(all(target_family = \"wasm\", not(target_feature = \"atomics\"))),))]\n-pub mod fast {\n-    use super::lazy::LazyKeyInner;\n-    use crate::cell::Cell;\n-    use crate::sys::thread_local_dtor::register_dtor;\n-    use crate::{fmt, mem, panic};\n-\n-    #[derive(Copy, Clone)]\n-    enum DtorState {\n-        Unregistered,\n-        Registered,\n-        RunningOrHasRun,\n-    }\n-\n-    // This data structure has been carefully constructed so that the fast path\n-    // only contains one branch on x86. That optimization is necessary to avoid\n-    // duplicated tls lookups on OSX.\n-    //\n-    // LLVM issue: https://bugs.llvm.org/show_bug.cgi?id=41722\n-    pub struct Key<T> {\n-        // If `LazyKeyInner::get` returns `None`, that indicates either:\n-        //   * The value has never been initialized\n-        //   * The value is being recursively initialized\n-        //   * The value has already been destroyed or is being destroyed\n-        // To determine which kind of `None`, check `dtor_state`.\n-        //\n-        // This is very optimizer friendly for the fast path - initialized but\n-        // not yet dropped.\n-        inner: LazyKeyInner<T>,\n-\n-        // Metadata to keep track of the state of the destructor. Remember that\n-        // this variable is thread-local, not global.\n-        dtor_state: Cell<DtorState>,\n-    }\n-\n-    impl<T> fmt::Debug for Key<T> {\n-        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-            f.debug_struct(\"Key\").finish_non_exhaustive()\n-        }\n-    }\n-\n-    impl<T> Key<T> {\n-        pub const fn new() -> Key<T> {\n-            Key { inner: LazyKeyInner::new(), dtor_state: Cell::new(DtorState::Unregistered) }\n-        }\n-\n-        // note that this is just a publicly-callable function only for the\n-        // const-initialized form of thread locals, basically a way to call the\n-        // free `register_dtor` function defined elsewhere in std.\n-        pub unsafe fn register_dtor(a: *mut u8, dtor: unsafe extern \"C\" fn(*mut u8)) {\n-            unsafe {\n-                register_dtor(a, dtor);\n-            }\n-        }\n-\n-        pub unsafe fn get<F: FnOnce() -> T>(&self, init: F) -> Option<&'static T> {\n-            // SAFETY: See the definitions of `LazyKeyInner::get` and\n-            // `try_initialize` for more information.\n-            //\n-            // The caller must ensure no mutable references are ever active to\n-            // the inner cell or the inner T when this is called.\n-            // The `try_initialize` is dependant on the passed `init` function\n-            // for this.\n-            unsafe {\n-                match self.inner.get() {\n-                    Some(val) => Some(val),\n-                    None => self.try_initialize(init),\n-                }\n-            }\n-        }\n-\n-        // `try_initialize` is only called once per fast thread local variable,\n-        // except in corner cases where thread_local dtors reference other\n-        // thread_local's, or it is being recursively initialized.\n-        //\n-        // Macos: Inlining this function can cause two `tlv_get_addr` calls to\n-        // be performed for every call to `Key::get`.\n-        // LLVM issue: https://bugs.llvm.org/show_bug.cgi?id=41722\n-        #[inline(never)]\n-        unsafe fn try_initialize<F: FnOnce() -> T>(&self, init: F) -> Option<&'static T> {\n-            // SAFETY: See comment above (this function doc).\n-            if !mem::needs_drop::<T>() || unsafe { self.try_register_dtor() } {\n-                // SAFETY: See comment above (this function doc).\n-                Some(unsafe { self.inner.initialize(init) })\n-            } else {\n-                None\n-            }\n-        }\n-\n-        // `try_register_dtor` is only called once per fast thread local\n-        // variable, except in corner cases where thread_local dtors reference\n-        // other thread_local's, or it is being recursively initialized.\n-        unsafe fn try_register_dtor(&self) -> bool {\n-            match self.dtor_state.get() {\n-                DtorState::Unregistered => {\n-                    // SAFETY: dtor registration happens before initialization.\n-                    // Passing `self` as a pointer while using `destroy_value<T>`\n-                    // is safe because the function will build a pointer to a\n-                    // Key<T>, which is the type of self and so find the correct\n-                    // size.\n-                    unsafe { register_dtor(self as *const _ as *mut u8, destroy_value::<T>) };\n-                    self.dtor_state.set(DtorState::Registered);\n-                    true\n-                }\n-                DtorState::Registered => {\n-                    // recursively initialized\n-                    true\n-                }\n-                DtorState::RunningOrHasRun => false,\n-            }\n-        }\n-    }\n-\n-    unsafe extern \"C\" fn destroy_value<T>(ptr: *mut u8) {\n-        let ptr = ptr as *mut Key<T>;\n-\n-        // SAFETY:\n-        //\n-        // The pointer `ptr` has been built just above and comes from\n-        // `try_register_dtor` where it is originally a Key<T> coming from `self`,\n-        // making it non-NUL and of the correct type.\n-        //\n-        // Right before we run the user destructor be sure to set the\n-        // `Option<T>` to `None`, and `dtor_state` to `RunningOrHasRun`. This\n-        // causes future calls to `get` to run `try_initialize_drop` again,\n-        // which will now fail, and return `None`.\n-        //\n-        // Wrap the call in a catch to ensure unwinding is caught in the event\n-        // a panic takes place in a destructor.\n-        if let Err(_) = panic::catch_unwind(panic::AssertUnwindSafe(|| unsafe {\n-            let value = (*ptr).inner.take();\n-            (*ptr).dtor_state.set(DtorState::RunningOrHasRun);\n-            drop(value);\n-        })) {\n-            rtabort!(\"thread local panicked on drop\");\n-        }\n-    }\n-}\n-\n-#[doc(hidden)]\n-#[cfg(all(\n-    not(target_thread_local),\n-    not(all(target_family = \"wasm\", not(target_feature = \"atomics\"))),\n-))]\n-pub mod os {\n-    use super::lazy::LazyKeyInner;\n-    use crate::cell::Cell;\n-    use crate::sys_common::thread_local_key::StaticKey as OsStaticKey;\n-    use crate::{fmt, marker, panic, ptr};\n-\n-    /// Use a regular global static to store this key; the state provided will then be\n-    /// thread-local.\n-    pub struct Key<T> {\n-        // OS-TLS key that we'll use to key off.\n-        os: OsStaticKey,\n-        marker: marker::PhantomData<Cell<T>>,\n-    }\n-\n-    impl<T> fmt::Debug for Key<T> {\n-        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-            f.debug_struct(\"Key\").finish_non_exhaustive()\n-        }\n-    }\n-\n-    unsafe impl<T> Sync for Key<T> {}\n-\n-    struct Value<T: 'static> {\n-        inner: LazyKeyInner<T>,\n-        key: &'static Key<T>,\n-    }\n-\n-    impl<T: 'static> Key<T> {\n-        #[rustc_const_unstable(feature = \"thread_local_internals\", issue = \"none\")]\n-        pub const fn new() -> Key<T> {\n-            Key { os: OsStaticKey::new(Some(destroy_value::<T>)), marker: marker::PhantomData }\n-        }\n-\n-        /// It is a requirement for the caller to ensure that no mutable\n-        /// reference is active when this method is called.\n-        pub unsafe fn get(&'static self, init: impl FnOnce() -> T) -> Option<&'static T> {\n-            // SAFETY: See the documentation for this method.\n-            let ptr = unsafe { self.os.get() as *mut Value<T> };\n-            if ptr.addr() > 1 {\n-                // SAFETY: the check ensured the pointer is safe (its destructor\n-                // is not running) + it is coming from a trusted source (self).\n-                if let Some(ref value) = unsafe { (*ptr).inner.get() } {\n-                    return Some(value);\n-                }\n-            }\n-            // SAFETY: At this point we are sure we have no value and so\n-            // initializing (or trying to) is safe.\n-            unsafe { self.try_initialize(init) }\n-        }\n-\n-        // `try_initialize` is only called once per os thread local variable,\n-        // except in corner cases where thread_local dtors reference other\n-        // thread_local's, or it is being recursively initialized.\n-        unsafe fn try_initialize(&'static self, init: impl FnOnce() -> T) -> Option<&'static T> {\n-            // SAFETY: No mutable references are ever handed out meaning getting\n-            // the value is ok.\n-            let ptr = unsafe { self.os.get() as *mut Value<T> };\n-            if ptr.addr() == 1 {\n-                // destructor is running\n-                return None;\n-            }\n-\n-            let ptr = if ptr.is_null() {\n-                // If the lookup returned null, we haven't initialized our own\n-                // local copy, so do that now.\n-                let ptr = Box::into_raw(Box::new(Value { inner: LazyKeyInner::new(), key: self }));\n-                // SAFETY: At this point we are sure there is no value inside\n-                // ptr so setting it will not affect anyone else.\n-                unsafe {\n-                    self.os.set(ptr as *mut u8);\n-                }\n-                ptr\n-            } else {\n-                // recursive initialization\n-                ptr\n-            };\n-\n-            // SAFETY: ptr has been ensured as non-NUL just above an so can be\n-            // dereferenced safely.\n-            unsafe { Some((*ptr).inner.initialize(init)) }\n-        }\n-    }\n-\n-    unsafe extern \"C\" fn destroy_value<T: 'static>(ptr: *mut u8) {\n-        // SAFETY:\n-        //\n-        // The OS TLS ensures that this key contains a null value when this\n-        // destructor starts to run. We set it back to a sentinel value of 1 to\n-        // ensure that any future calls to `get` for this thread will return\n-        // `None`.\n-        //\n-        // Note that to prevent an infinite loop we reset it back to null right\n-        // before we return from the destructor ourselves.\n-        //\n-        // Wrap the call in a catch to ensure unwinding is caught in the event\n-        // a panic takes place in a destructor.\n-        if let Err(_) = panic::catch_unwind(|| unsafe {\n-            let ptr = Box::from_raw(ptr as *mut Value<T>);\n-            let key = ptr.key;\n-            key.os.set(ptr::invalid_mut(1));\n-            drop(ptr);\n-            key.os.set(ptr::null_mut());\n-        }) {\n-            rtabort!(\"thread local panicked on drop\");\n-        }\n-    }\n-}"}, {"sha": "b9aaf5f6e15dbb58571c3f68f30d7d71609c17f7", "filename": "library/std/src/thread/mod.rs", "status": "modified", "additions": 1, "deletions": 36, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/5e52ada714a46b6150e78c7c5a2ff7178a2d79d3/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e52ada714a46b6150e78c7c5a2ff7178a2d79d3/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs?ref=5e52ada714a46b6150e78c7c5a2ff7178a2d79d3", "patch": "@@ -203,44 +203,9 @@ pub use self::local::{AccessError, LocalKey};\n // by the elf linker. \"static\" is for single-threaded platforms where a global\n // static is sufficient.\n \n-#[unstable(feature = \"libstd_thread_internals\", issue = \"none\")]\n-#[cfg(not(test))]\n-#[cfg(all(\n-    target_thread_local,\n-    not(all(target_family = \"wasm\", not(target_feature = \"atomics\"))),\n-))]\n-#[doc(hidden)]\n-pub use self::local::fast::Key as __FastLocalKeyInner;\n-// when building for tests, use real std's type\n-#[unstable(feature = \"libstd_thread_internals\", issue = \"none\")]\n-#[cfg(test)]\n-#[cfg(all(\n-    target_thread_local,\n-    not(all(target_family = \"wasm\", not(target_feature = \"atomics\"))),\n-))]\n-pub use realstd::thread::__FastLocalKeyInner;\n-\n-#[unstable(feature = \"libstd_thread_internals\", issue = \"none\")]\n-#[cfg(not(test))]\n-#[cfg(all(\n-    not(target_thread_local),\n-    not(all(target_family = \"wasm\", not(target_feature = \"atomics\"))),\n-))]\n #[doc(hidden)]\n-pub use self::local::os::Key as __OsLocalKeyInner;\n-// when building for tests, use real std's type\n-#[unstable(feature = \"libstd_thread_internals\", issue = \"none\")]\n-#[cfg(test)]\n-#[cfg(all(\n-    not(target_thread_local),\n-    not(all(target_family = \"wasm\", not(target_feature = \"atomics\"))),\n-))]\n-pub use realstd::thread::__OsLocalKeyInner;\n-\n #[unstable(feature = \"libstd_thread_internals\", issue = \"none\")]\n-#[cfg(all(target_family = \"wasm\", not(target_feature = \"atomics\")))]\n-#[doc(hidden)]\n-pub use self::local::statik::Key as __StaticLocalKeyInner;\n+pub use crate::sys::common::thread_local::Key as __LocalKeyInner;\n \n ////////////////////////////////////////////////////////////////////////////////\n // Builder"}, {"sha": "868579b4b1a8c92e86c630b9e4b34a612ea5ca3b", "filename": "src/tools/tidy/src/pal.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e52ada714a46b6150e78c7c5a2ff7178a2d79d3/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e52ada714a46b6150e78c7c5a2ff7178a2d79d3/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs?ref=5e52ada714a46b6150e78c7c5a2ff7178a2d79d3", "patch": "@@ -62,8 +62,6 @@ const EXCEPTION_PATHS: &[&str] = &[\n     \"library/std/src/panic.rs\",   // fuchsia-specific panic backtrace handling\n     \"library/std/src/personality.rs\",\n     \"library/std/src/personality/\",\n-    \"library/std/src/thread/mod.rs\",\n-    \"library/std/src/thread/local.rs\",\n ];\n \n pub fn check(path: &Path, bad: &mut bool) {"}, {"sha": "8f7a9c0837510ffb0763bf95e4a3de5b18894adb", "filename": "tests/ui/threads-sendsync/issue-43733-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e52ada714a46b6150e78c7c5a2ff7178a2d79d3/tests%2Fui%2Fthreads-sendsync%2Fissue-43733-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e52ada714a46b6150e78c7c5a2ff7178a2d79d3/tests%2Fui%2Fthreads-sendsync%2Fissue-43733-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fthreads-sendsync%2Fissue-43733-2.rs?ref=5e52ada714a46b6150e78c7c5a2ff7178a2d79d3", "patch": "@@ -21,7 +21,7 @@ impl<T> Key<T> {\n }\n \n #[cfg(target_thread_local)]\n-use std::thread::__FastLocalKeyInner as Key;\n+use std::thread::__LocalKeyInner as Key;\n \n static __KEY: Key<()> = Key::new();\n //~^ ERROR `UnsafeCell<Option<()>>` cannot be shared between threads"}, {"sha": "0eadef3e3e8cb8e4de2b114d4547de5f7b52052a", "filename": "tests/ui/threads-sendsync/issue-43733.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5e52ada714a46b6150e78c7c5a2ff7178a2d79d3/tests%2Fui%2Fthreads-sendsync%2Fissue-43733.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e52ada714a46b6150e78c7c5a2ff7178a2d79d3/tests%2Fui%2Fthreads-sendsync%2Fissue-43733.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fthreads-sendsync%2Fissue-43733.rs?ref=5e52ada714a46b6150e78c7c5a2ff7178a2d79d3", "patch": "@@ -1,8 +1,8 @@\n // ignore-wasm32\n // revisions: mir thir\n // [thir]compile-flags: -Z thir-unsafeck\n-// normalize-stderr-test: \"__FastLocalKeyInner::<T>::get\" -> \"$$LOCALKEYINNER::<T>::get\"\n-// normalize-stderr-test: \"__OsLocalKeyInner::<T>::get\" -> \"$$LOCALKEYINNER::<T>::get\"\n+// normalize-stderr-test: \"__LocalKeyInner::<T>::get\" -> \"$$LOCALKEYINNER::<T>::get\"\n+// normalize-stderr-test: \"__LocalKeyInner::<T>::get\" -> \"$$LOCALKEYINNER::<T>::get\"\n #![feature(thread_local)]\n #![feature(cfg_target_thread_local, thread_local_internals)]\n \n@@ -12,10 +12,10 @@ type Foo = std::cell::RefCell<String>;\n \n #[cfg(target_thread_local)]\n #[thread_local]\n-static __KEY: std::thread::__FastLocalKeyInner<Foo> = std::thread::__FastLocalKeyInner::new();\n+static __KEY: std::thread::__LocalKeyInner<Foo> = std::thread::__LocalKeyInner::new();\n \n #[cfg(not(target_thread_local))]\n-static __KEY: std::thread::__OsLocalKeyInner<Foo> = std::thread::__OsLocalKeyInner::new();\n+static __KEY: std::thread::__LocalKeyInner<Foo> = std::thread::__LocalKeyInner::new();\n \n fn __getit(_: Option<&mut Option<RefCell<String>>>) -> std::option::Option<&'static Foo> {\n     __KEY.get(Default::default)"}]}