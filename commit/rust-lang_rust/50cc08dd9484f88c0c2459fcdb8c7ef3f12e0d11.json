{"sha": "50cc08dd9484f88c0c2459fcdb8c7ef3f12e0d11", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwY2MwOGRkOTQ4NGY4OGMwYzI0NTlmY2RiOGM3ZWYzZjEyZTBkMTE=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2018-10-20T20:15:48Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2018-10-20T20:15:48Z"}, "message": "Rollup merge of #55203 - scalexm:program-clauses, r=nikomatsakis\n\nSometimes I just return `ty::List::empty()` because I cannot express these \\\"built-in\\\" clauses without bound tys support.\n\nr? @nikomatsakis", "tree": {"sha": "00a2eba6edb1fd1fefbcc69b8c39c13a10ca0dbd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/00a2eba6edb1fd1fefbcc69b8c39c13a10ca0dbd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/50cc08dd9484f88c0c2459fcdb8c7ef3f12e0d11", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/50cc08dd9484f88c0c2459fcdb8c7ef3f12e0d11", "html_url": "https://github.com/rust-lang/rust/commit/50cc08dd9484f88c0c2459fcdb8c7ef3f12e0d11", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/50cc08dd9484f88c0c2459fcdb8c7ef3f12e0d11/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ddf33eaa67ef010fea4371cc15365fd16533b365", "url": "https://api.github.com/repos/rust-lang/rust/commits/ddf33eaa67ef010fea4371cc15365fd16533b365", "html_url": "https://github.com/rust-lang/rust/commit/ddf33eaa67ef010fea4371cc15365fd16533b365"}, {"sha": "91da1a5c17d45076b5e5aa41a3f5c1ce75d973f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/91da1a5c17d45076b5e5aa41a3f5c1ce75d973f5", "html_url": "https://github.com/rust-lang/rust/commit/91da1a5c17d45076b5e5aa41a3f5c1ce75d973f5"}], "stats": {"total": 239, "additions": 214, "deletions": 25}, "files": [{"sha": "5d6badf120286c42d5be864cae36f6efb33cc71c", "filename": "src/librustc_traits/chalk_context.rs", "status": "modified", "additions": 207, "deletions": 21, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/50cc08dd9484f88c0c2459fcdb8c7ef3f12e0d11/src%2Flibrustc_traits%2Fchalk_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cc08dd9484f88c0c2459fcdb8c7ef3f12e0d11/src%2Flibrustc_traits%2Fchalk_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context.rs?ref=50cc08dd9484f88c0c2459fcdb8c7ef3f12e0d11", "patch": "@@ -23,13 +23,15 @@ use rustc::traits::{\n     Goal,\n     GoalKind,\n     Clause,\n+    ProgramClauseCategory,\n     QuantifierKind,\n     Environment,\n     InEnvironment,\n };\n use rustc::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use rustc::ty::subst::Kind;\n use rustc::ty::{self, TyCtxt};\n+use rustc::hir::def_id::DefId;\n \n use std::fmt::{self, Debug};\n use std::marker::PhantomData;\n@@ -330,46 +332,230 @@ impl context::UnificationOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n {\n     fn program_clauses(\n         &self,\n-        _environment: &Environment<'tcx>,\n+        environment: &Environment<'tcx>,\n         goal: &DomainGoal<'tcx>,\n     ) -> Vec<Clause<'tcx>> {\n         use rustc::traits::WhereClause::*;\n \n-        match goal {\n-            DomainGoal::Holds(Implemented(_trait_predicate)) => {\n+        fn assemble_clauses_from_impls<'tcx>(\n+            tcx: ty::TyCtxt<'_, '_, 'tcx>,\n+            trait_def_id: DefId,\n+            clauses: &mut Vec<Clause<'tcx>>\n+        ) {\n+            tcx.for_each_impl(trait_def_id, |impl_def_id| {\n+                clauses.extend(\n+                    tcx.program_clauses_for(impl_def_id)\n+                        .into_iter()\n+                        .cloned()\n+                );\n+            });\n+        }\n+\n+        fn assemble_clauses_from_assoc_ty_values<'tcx>(\n+            tcx: ty::TyCtxt<'_, '_, 'tcx>,\n+            trait_def_id: DefId,\n+            clauses: &mut Vec<Clause<'tcx>>\n+        ) {\n+            tcx.for_each_impl(trait_def_id, |impl_def_id| {\n+                for def_id in tcx.associated_item_def_ids(impl_def_id).iter() {\n+                    clauses.extend(\n+                        tcx.program_clauses_for(*def_id)\n+                            .into_iter()\n+                            .cloned()\n+                    );\n+                }\n+            });\n+        }\n+\n+        let mut clauses = match goal {\n+            DomainGoal::Holds(Implemented(trait_predicate)) => {\n+                // These come from:\n+                // * implementations of the trait itself (rule `Implemented-From-Impl`)\n+                // * the trait decl (rule `Implemented-From-Env`)\n+\n+                let mut clauses = vec![];\n+                assemble_clauses_from_impls(\n+                    self.infcx.tcx,\n+                    trait_predicate.def_id(),\n+                    &mut clauses\n+                );\n+\n+                // FIXME: we need to add special rules for builtin impls:\n+                // * `Copy` / `Clone`\n+                // * `Sized`\n+                // * `Unsize`\n+                // * `Generator`\n+                // * `FnOnce` / `FnMut` / `Fn`\n+                // * trait objects\n+                // * auto traits\n+\n+                // Rule `Implemented-From-Env` will be computed from the environment.\n+                clauses\n+            }\n+\n+            DomainGoal::Holds(ProjectionEq(projection_predicate)) => {\n+                // These come from:\n+                // * the assoc type definition (rule `ProjectionEq-Placeholder`)\n+                // * normalization of the assoc ty values (rule `ProjectionEq-Normalize`)\n+                // * implied bounds from trait definitions (rule `Implied-Bound-From-Trait`)\n+                // * implied bounds from type definitions (rule `Implied-Bound-From-Type`)\n+\n+                let clauses = self.infcx.tcx.program_clauses_for(\n+                    projection_predicate.projection_ty.item_def_id\n+                ).into_iter()\n+\n+                    // only select `ProjectionEq-Placeholder` and `ProjectionEq-Normalize`\n+                    .filter(|clause| clause.category() == ProgramClauseCategory::Other)\n+\n+                    .cloned()\n+                    .collect::<Vec<_>>();\n+\n+                // Rules `Implied-Bound-From-Trait` and `Implied-Bound-From-Type` will be computed\n+                // from the environment.\n+                clauses\n+            }\n+\n+            DomainGoal::Holds(RegionOutlives(..)) => {\n                 // These come from:\n-                //\n-                // - Trait definitions (implied bounds)\n-                // - Implementations of the trait itself\n-                panic!()\n+                // * implied bounds from trait definitions (rule `Implied-Bound-From-Trait`)\n+                // * implied bounds from type definitions (rule `Implied-Bound-From-Type`)\n+\n+                // All of these rules are computed in the environment.\n+                vec![]\n             }\n \n-            DomainGoal::Holds(ProjectionEq(_projection_predicate)) => {\n+            DomainGoal::Holds(TypeOutlives(..)) => {\n                 // These come from:\n-                panic!()\n+                // * implied bounds from trait definitions (rule `Implied-Bound-From-Trait`)\n+                // * implied bounds from type definitions (rule `Implied-Bound-From-Type`)\n+\n+                // All of these rules are computed in the environment.\n+                vec![]\n             }\n \n-            DomainGoal::Holds(RegionOutlives(_region_outlives)) => {\n-                panic!()\n+            DomainGoal::WellFormed(WellFormed::Trait(trait_predicate)) => {\n+                // These come from -- the trait decl (rule `WellFormed-TraitRef`).\n+                self.infcx.tcx.program_clauses_for(trait_predicate.def_id())\n+                    .into_iter()\n+\n+                    // only select `WellFormed-TraitRef`\n+                    .filter(|clause| clause.category() == ProgramClauseCategory::WellFormed)\n+\n+                    .cloned()\n+                    .collect()\n             }\n \n-            DomainGoal::Holds(TypeOutlives(_type_outlives)) => {\n-                panic!()\n+            DomainGoal::WellFormed(WellFormed::Ty(ty)) => {\n+                // These come from:\n+                // * the associated type definition if `ty` refers to an unnormalized\n+                //   associated type (rule `WellFormed-AssocTy`)\n+                // * custom rules for built-in types\n+                // * the type definition otherwise (rule `WellFormed-Type`)\n+                let clauses = match ty.sty {\n+                    ty::Projection(data) => {\n+                        self.infcx.tcx.program_clauses_for(data.item_def_id)\n+                    }\n+\n+                    // These types are always WF (recall that we do not check\n+                    // for parameters to be WF)\n+                    ty::Bool |\n+                    ty::Char |\n+                    ty::Int(..) |\n+                    ty::Uint(..) |\n+                    ty::Float(..) |\n+                    ty::Str |\n+                    ty::RawPtr(..) |\n+                    ty::FnPtr(..) |\n+                    ty::Param(..) |\n+                    ty::Never => {\n+                        ty::List::empty()\n+                    }\n+\n+                    // WF if inner type is `Sized`\n+                    ty::Slice(..) |\n+                    ty::Array(..) => {\n+                        ty::List::empty()\n+                    }\n+\n+                    ty::Tuple(..) => {\n+                        ty::List::empty()\n+                    }\n+\n+                    // WF if `sub_ty` outlives `region`\n+                    ty::Ref(..) => {\n+                        ty::List::empty()\n+                    }\n+\n+                    ty::Dynamic(..) => {\n+                        // FIXME: no rules yet for trait objects\n+                        ty::List::empty()\n+                    }\n+\n+                    ty::Adt(def, ..) => {\n+                        self.infcx.tcx.program_clauses_for(def.did)\n+                    }\n+\n+                    ty::Foreign(def_id) |\n+                    ty::FnDef(def_id, ..) |\n+                    ty::Closure(def_id, ..) |\n+                    ty::Generator(def_id, ..) |\n+                    ty::Opaque(def_id, ..) => {\n+                        self.infcx.tcx.program_clauses_for(def_id)\n+                    }\n+\n+                    ty::GeneratorWitness(..) |\n+                    ty::UnnormalizedProjection(..) |\n+                    ty::Infer(..) |\n+                    ty::Error => {\n+                        bug!(\"unexpected type {:?}\", ty)\n+                    }\n+                };\n+\n+                clauses.into_iter()\n+                    .filter(|clause| clause.category() == ProgramClauseCategory::WellFormed)\n+                    .cloned()\n+                    .collect()\n             }\n \n-            DomainGoal::WellFormed(WellFormed::Trait(_trait_predicate)) => {\n-                // These come from -- the trait decl.\n-                panic!()\n+            DomainGoal::FromEnv(FromEnv::Trait(..)) => {\n+                // These come from:\n+                // * implied bounds from trait definitions (rule `Implied-Bound-From-Trait`)\n+                // * implied bounds from type definitions (rule `Implied-Bound-From-Type`)\n+                // * implied bounds from assoc type defs (rules `Implied-Trait-From-AssocTy`,\n+                //   `Implied-Bound-From-AssocTy` and `Implied-WC-From-AssocTy`)\n+\n+                // All of these rules are computed in the environment.\n+                vec![]\n             }\n \n-            DomainGoal::WellFormed(WellFormed::Ty(_ty)) => panic!(),\n+            DomainGoal::FromEnv(FromEnv::Ty(..)) => {\n+                // There are no `FromEnv::Ty(..) :- ...` rules (this predicate only\n+                // comes from the environment).\n+                vec![]\n+            }\n \n-            DomainGoal::FromEnv(FromEnv::Trait(_trait_predicate)) => panic!(),\n+            DomainGoal::Normalize(projection_predicate) => {\n+                // These come from -- assoc ty values (rule `Normalize-From-Impl`).\n+                let mut clauses = vec![];\n \n-            DomainGoal::FromEnv(FromEnv::Ty(_ty)) => panic!(),\n+                assemble_clauses_from_assoc_ty_values(\n+                    self.infcx.tcx,\n+                    projection_predicate.projection_ty.trait_ref(self.infcx.tcx).def_id,\n+                    &mut clauses\n+                );\n \n-            DomainGoal::Normalize(_) => panic!(),\n-        }\n+                clauses\n+            }\n+        };\n+\n+        let environment = self.infcx.tcx.lift_to_global(environment)\n+            .expect(\"environment is not global\");\n+        clauses.extend(\n+            self.infcx.tcx.program_clauses_for_env(environment)\n+                .into_iter()\n+                .cloned()\n+        );\n+        clauses\n     }\n \n     fn instantiate_binders_universally("}, {"sha": "c71898f73ecad69267aa9f0b395ba479d47f411a", "filename": "src/librustc_traits/lowering/environment.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/50cc08dd9484f88c0c2459fcdb8c7ef3f12e0d11/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cc08dd9484f88c0c2459fcdb8c7ef3f12e0d11/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs?ref=50cc08dd9484f88c0c2459fcdb8c7ef3f12e0d11", "patch": "@@ -86,13 +86,16 @@ impl ClauseVisitor<'set, 'a, 'tcx> {\n             ty::Slice(..) |\n             ty::RawPtr(..) |\n             ty::FnPtr(..) |\n-            ty::Never |\n             ty::Tuple(..) |\n+            ty::Never |\n+            ty::Param(..) => (),\n+\n             ty::GeneratorWitness(..) |\n             ty::UnnormalizedProjection(..) |\n-            ty::Param(..) |\n             ty::Infer(..) |\n-            ty::Error => (),\n+            ty::Error => {\n+                bug!(\"unexpected type {:?}\", ty);\n+            }\n         }\n     }\n "}, {"sha": "46581397aee2db08f6fe2d21d8b93020f291ffad", "filename": "src/librustc_traits/lowering/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50cc08dd9484f88c0c2459fcdb8c7ef3f12e0d11/src%2Flibrustc_traits%2Flowering%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cc08dd9484f88c0c2459fcdb8c7ef3f12e0d11/src%2Flibrustc_traits%2Flowering%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering%2Fmod.rs?ref=50cc08dd9484f88c0c2459fcdb8c7ef3f12e0d11", "patch": "@@ -433,7 +433,7 @@ pub fn program_clauses_for_associated_type_def<'a, 'tcx>(\n     let wf_clause = ProgramClause {\n         goal: DomainGoal::WellFormed(WellFormed::Ty(placeholder_ty)),\n         hypotheses: tcx.mk_goals(iter::once(hypothesis)),\n-        category: ProgramClauseCategory::Other,\n+        category: ProgramClauseCategory::WellFormed,\n     };\n \n     // Rule Implied-Trait-From-AssocTy"}]}