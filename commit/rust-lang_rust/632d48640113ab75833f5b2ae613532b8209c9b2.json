{"sha": "632d48640113ab75833f5b2ae613532b8209c9b2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzMmQ0ODY0MDExM2FiNzU4MzNmNWIyYWU2MTM1MzJiODIwOWM5YjI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-16T00:36:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-16T00:36:27Z"}, "message": "auto merge of #14196 : chris-morgan/rust/hashmap-mangle, r=cmr\n\nThis used to be called `mangle` and was removed when the Robin Hood hash map came along, but it is a useful thing to have in certain situations (I just hit it with my Teepee header representation), so I want it back.\r\n\r\nThe method is renamed to `find_with_or_insert_with`, also with the parameters swapped to make sense\u2014find and then insert, not insert and then find.\r\n\r\n/cc @cgaebel", "tree": {"sha": "1b72e74a3d64c55ca8642d91d04a5d5b46a3775d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b72e74a3d64c55ca8642d91d04a5d5b46a3775d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/632d48640113ab75833f5b2ae613532b8209c9b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/632d48640113ab75833f5b2ae613532b8209c9b2", "html_url": "https://github.com/rust-lang/rust/commit/632d48640113ab75833f5b2ae613532b8209c9b2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/632d48640113ab75833f5b2ae613532b8209c9b2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0481d628b826104085c5df267cf6089a89fcd17b", "url": "https://api.github.com/repos/rust-lang/rust/commits/0481d628b826104085c5df267cf6089a89fcd17b", "html_url": "https://github.com/rust-lang/rust/commit/0481d628b826104085c5df267cf6089a89fcd17b"}, {"sha": "ff98afebf47da86cce6e7c033634c36c40bf63b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff98afebf47da86cce6e7c033634c36c40bf63b6", "html_url": "https://github.com/rust-lang/rust/commit/ff98afebf47da86cce6e7c033634c36c40bf63b6"}], "stats": {"total": 79, "additions": 58, "deletions": 21}, "files": [{"sha": "4b9c8ccadd2475629911767321643bc82a63a4b7", "filename": "src/libcollections/hashmap.rs", "status": "modified", "additions": 58, "deletions": 21, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/632d48640113ab75833f5b2ae613532b8209c9b2/src%2Flibcollections%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/632d48640113ab75833f5b2ae613532b8209c9b2/src%2Flibcollections%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fhashmap.rs?ref=632d48640113ab75833f5b2ae613532b8209c9b2", "patch": "@@ -1239,31 +1239,14 @@ impl<K: TotalEq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// Return the value corresponding to the key in the map, or insert\n     /// and return the value if it doesn't exist.\n     pub fn find_or_insert<'a>(&'a mut self, k: K, v: V) -> &'a mut V {\n-        let hash = self.make_hash(&k);\n-        match self.search_hashed(&hash, &k) {\n-            Some(idx) => {\n-                let (_, v_ref) = self.table.read_mut(&idx);\n-                v_ref\n-            },\n-            None => self.insert_hashed(hash, k, v)\n-        }\n+        self.find_with_or_insert_with(k, v, |_k, _v, _a| (), |_k, a| a)\n     }\n \n     /// Return the value corresponding to the key in the map, or create,\n     /// insert, and return a new value if it doesn't exist.\n     pub fn find_or_insert_with<'a>(&'a mut self, k: K, f: |&K| -> V)\n                                -> &'a mut V {\n-        let hash = self.make_hash(&k);\n-        match self.search_hashed(&hash, &k) {\n-            Some(idx) => {\n-                let (_, v_ref) = self.table.read_mut(&idx);\n-                v_ref\n-            },\n-            None => {\n-                let v = f(&k);\n-                self.insert_hashed(hash, k, v)\n-            }\n-        }\n+        self.find_with_or_insert_with(k, (), |_k, _v, _a| (), |k, _a| f(k))\n     }\n \n     /// Insert a key-value pair into the map if the key is not already present.\n@@ -1275,12 +1258,66 @@ impl<K: TotalEq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n                                  v: V,\n                                  f: |&K, &mut V|)\n                                  -> &'a mut V {\n+        self.find_with_or_insert_with(k, v, |k, v, _a| f(k, v), |_k, a| a)\n+    }\n+\n+    /// Modify and return the value corresponding to the key in the map, or\n+    /// insert and return a new value if it doesn't exist.\n+    ///\n+    /// This method allows for all insertion behaviours of a hashmap;\n+    /// see methods like `insert`, `find_or_insert` and\n+    /// `insert_or_update_with` for less general and more friendly\n+    /// variations of this.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use collections::HashMap;\n+    ///\n+    /// // map some strings to vectors of strings\n+    /// let mut map = HashMap::new();\n+    /// map.insert(\"a key\", vec![\"value\"]);\n+    /// map.insert(\"z key\", vec![\"value\"]);\n+    ///\n+    /// let new = vec![\"a key\", \"b key\", \"z key\"];\n+    ///\n+    /// for k in new.move_iter() {\n+    ///     map.find_with_or_insert_with(\n+    ///         k, \"new value\",\n+    ///         // if the key does exist either prepend or append this\n+    ///         // new value based on the first letter of the key.\n+    ///         |key, already, new| {\n+    ///             if key.as_slice().starts_with(\"z\") {\n+    ///                 already.unshift(new);\n+    ///             } else {\n+    ///                 already.push(new);\n+    ///             }\n+    ///         },\n+    ///         // if the key doesn't exist in the map yet, add it in\n+    ///         // the obvious way.\n+    ///         |_k, v| vec![v]);\n+    /// }\n+    ///\n+    /// assert_eq!(map.len(), 3);\n+    /// assert_eq!(map.get(&\"a key\"), &vec![\"value\", \"new value\"]);\n+    /// assert_eq!(map.get(&\"b key\"), &vec![\"new value\"]);\n+    /// assert_eq!(map.get(&\"z key\"), &vec![\"new value\", \"value\"]);\n+    /// ```\n+    pub fn find_with_or_insert_with<'a, A>(&'a mut self,\n+                                           k: K,\n+                                           a: A,\n+                                           found: |&K, &mut V, A|,\n+                                           not_found: |&K, A| -> V)\n+                                          -> &'a mut V {\n         let hash = self.make_hash(&k);\n         match self.search_hashed(&hash, &k) {\n-            None      => self.insert_hashed(hash, k, v),\n+            None => {\n+                let v = not_found(&k, a);\n+                self.insert_hashed(hash, k, v)\n+            },\n             Some(idx) => {\n                 let (_, v_ref) = self.table.read_mut(&idx);\n-                f(&k, v_ref);\n+                found(&k, v_ref, a);\n                 v_ref\n             }\n         }"}]}