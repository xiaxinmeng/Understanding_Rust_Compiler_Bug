{"sha": "fb30b64f6379eb22880d70bfebce66ceccc75269", "node_id": "C_kwDOAAsO6NoAKGZiMzBiNjRmNjM3OWViMjI4ODBkNzBiZmViY2U2NmNlY2NjNzUyNjk", "commit": {"author": {"name": "Nahua Kang", "email": "kangnahua@gmail.com", "date": "2022-08-08T20:31:53Z"}, "committer": {"name": "Nahua Kang", "email": "kangnahua@gmail.com", "date": "2022-08-19T18:00:20Z"}, "message": "Adjust test cases; run cargo dev bless", "tree": {"sha": "9eacd2c9af31fb39e847e9b6a86cacbcb5ecfcb3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9eacd2c9af31fb39e847e9b6a86cacbcb5ecfcb3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb30b64f6379eb22880d70bfebce66ceccc75269", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb30b64f6379eb22880d70bfebce66ceccc75269", "html_url": "https://github.com/rust-lang/rust/commit/fb30b64f6379eb22880d70bfebce66ceccc75269", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb30b64f6379eb22880d70bfebce66ceccc75269/comments", "author": {"login": "nahuakang", "id": 18533347, "node_id": "MDQ6VXNlcjE4NTMzMzQ3", "avatar_url": "https://avatars.githubusercontent.com/u/18533347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nahuakang", "html_url": "https://github.com/nahuakang", "followers_url": "https://api.github.com/users/nahuakang/followers", "following_url": "https://api.github.com/users/nahuakang/following{/other_user}", "gists_url": "https://api.github.com/users/nahuakang/gists{/gist_id}", "starred_url": "https://api.github.com/users/nahuakang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nahuakang/subscriptions", "organizations_url": "https://api.github.com/users/nahuakang/orgs", "repos_url": "https://api.github.com/users/nahuakang/repos", "events_url": "https://api.github.com/users/nahuakang/events{/privacy}", "received_events_url": "https://api.github.com/users/nahuakang/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nahuakang", "id": 18533347, "node_id": "MDQ6VXNlcjE4NTMzMzQ3", "avatar_url": "https://avatars.githubusercontent.com/u/18533347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nahuakang", "html_url": "https://github.com/nahuakang", "followers_url": "https://api.github.com/users/nahuakang/followers", "following_url": "https://api.github.com/users/nahuakang/following{/other_user}", "gists_url": "https://api.github.com/users/nahuakang/gists{/gist_id}", "starred_url": "https://api.github.com/users/nahuakang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nahuakang/subscriptions", "organizations_url": "https://api.github.com/users/nahuakang/orgs", "repos_url": "https://api.github.com/users/nahuakang/repos", "events_url": "https://api.github.com/users/nahuakang/events{/privacy}", "received_events_url": "https://api.github.com/users/nahuakang/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c989746ccfae22dd0f7f6d1e3d4f984ac8889e9f", "url": "https://api.github.com/repos/rust-lang/rust/commits/c989746ccfae22dd0f7f6d1e3d4f984ac8889e9f", "html_url": "https://github.com/rust-lang/rust/commit/c989746ccfae22dd0f7f6d1e3d4f984ac8889e9f"}], "stats": {"total": 257, "additions": 174, "deletions": 83}, "files": [{"sha": "4c6288e798cd490f341dab5751c48ffce26dc494", "filename": "clippy_lints/src/methods/collapsible_str_replace.rs", "status": "modified", "additions": 27, "deletions": 38, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/fb30b64f6379eb22880d70bfebce66ceccc75269/clippy_lints%2Fsrc%2Fmethods%2Fcollapsible_str_replace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30b64f6379eb22880d70bfebce66ceccc75269/clippy_lints%2Fsrc%2Fmethods%2Fcollapsible_str_replace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fcollapsible_str_replace.rs?ref=fb30b64f6379eb22880d70bfebce66ceccc75269", "patch": "@@ -1,3 +1,5 @@\n+// run-rustfix\n+\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::get_parent_expr;\n use clippy_utils::visitors::for_each_expr;\n@@ -7,7 +9,7 @@ use rustc_ast::ast::LitKind;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n-use rustc_hir::*;\n+use rustc_hir::{ExprKind, Path, QPath};\n use rustc_lint::LateContext;\n use rustc_middle::ty;\n use rustc_span::source_map::Spanned;\n@@ -21,44 +23,31 @@ pub(super) fn check<'tcx>(\n     expr: &'tcx hir::Expr<'tcx>,\n     name: &str,\n     recv: &'tcx hir::Expr<'tcx>,\n-    args: &'tcx [hir::Expr<'tcx>],\n ) {\n-    match (name, args) {\n-        (\"replace\", ..) => {\n-            // The receiver of the method call must be `str` type to lint `collapsible_str_replace`\n-            let original_recv = find_original_recv(recv);\n-            let original_recv_ty_kind = cx.typeck_results().expr_ty(original_recv).peel_refs().kind();\n-            let original_recv_is_str_kind = matches!(original_recv_ty_kind, ty::Str);\n+    if name == \"replace\" {\n+        // The receiver of the method call must be `str` type to lint `collapsible_str_replace`\n+        let original_recv = find_original_recv(recv);\n+        let original_recv_ty_kind = cx.typeck_results().expr_ty(original_recv).peel_refs().kind();\n+        let original_recv_is_str_kind = matches!(original_recv_ty_kind, ty::Str);\n \n-            if_chain! {\n-                if original_recv_is_str_kind;\n-                if let Some(parent) = get_parent_expr(cx, expr);\n-                if let Some((name, ..)) = method_call(parent);\n+        if_chain! {\n+            if original_recv_is_str_kind;\n+            if let Some(parent) = get_parent_expr(cx, expr);\n+            if let Some((name, ..)) = method_call(parent);\n+            if name == \"replace\";\n \n-                then {\n-                    match name {\n-                        // If the parent node is a `str::replace` call, we've already handled the lint, don't lint again\n-                        \"replace\" => return,\n-                        _ => {\n-                            check_consecutive_replace_calls(cx, expr);\n-                            return;\n-                        },\n-                    }\n-                }\n+            then {\n+                // If the parent node is a `str::replace` call, we've already handled the lint, don't lint again\n+                return;\n             }\n+        }\n \n-            match method_call(recv) {\n-                // Check if there's an earlier `str::replace` call\n-                Some((\"replace\", ..)) => {\n-                    if original_recv_is_str_kind {\n-                        check_consecutive_replace_calls(cx, expr);\n-                        return;\n-                    }\n-                },\n-                _ => {},\n+        if let Some((\"replace\", ..)) = method_call(recv) {\n+            // Check if there's an earlier `str::replace` call\n+            if original_recv_is_str_kind {\n+                check_consecutive_replace_calls(cx, expr);\n             }\n-        },\n-        _ => {},\n+        }\n     }\n }\n \n@@ -116,7 +105,7 @@ fn check_consecutive_replace_calls<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir\n \n /// Check if all the `from` arguments of a chain of consecutive calls to `str::replace`\n /// are all of `ExprKind::Lit` types. If any is not, return false.\n-fn replace_call_from_args_are_only_lit_chars<'tcx>(from_args: &Vec<&'tcx hir::Expr<'tcx>>) -> bool {\n+fn replace_call_from_args_are_only_lit_chars<'tcx>(from_args: &[&'tcx hir::Expr<'tcx>]) -> bool {\n     let mut only_lit_chars = true;\n \n     for from_arg in from_args.iter() {\n@@ -159,9 +148,9 @@ fn get_replace_call_from_args_if_all_char_ty<'tcx>(\n \n     if all_from_args_are_chars {\n         return Some(from_args);\n-    } else {\n-        return None;\n     }\n+\n+    None\n }\n \n /// Return a unique String representation of the `to` argument used in a chain of `str::replace`\n@@ -186,13 +175,13 @@ fn get_replace_call_unique_to_arg_repr<'tcx>(expr: &'tcx hir::Expr<'tcx>) -> Opt\n \n     // let mut to_arg_repr_set = FxHashSet::default();\n     let mut to_arg_reprs = Vec::new();\n-    for &to_arg in to_args.iter() {\n+    for &to_arg in &to_args {\n         if let Some(to_arg_repr) = get_replace_call_char_arg_repr(to_arg) {\n             to_arg_reprs.push(to_arg_repr);\n         }\n     }\n \n-    let to_arg_repr_set = FxHashSet::from_iter(to_arg_reprs.iter().cloned());\n+    let to_arg_repr_set = to_arg_reprs.iter().cloned().collect::<FxHashSet<_>>();\n     // Check if the set of `to` argument representations has more than one unique value\n     if to_arg_repr_set.len() != 1 {\n         return None;"}, {"sha": "8b2fa8e945774b9d46faf5e2cfdd11bbf12367c8", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb30b64f6379eb22880d70bfebce66ceccc75269/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30b64f6379eb22880d70bfebce66ceccc75269/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=fb30b64f6379eb22880d70bfebce66ceccc75269", "patch": "@@ -152,11 +152,11 @@ declare_clippy_lint! {\n     /// let hello = \"hesuo worpd\"\n     ///     .replace('s', \"l\")\n     ///     .replace(\"u\", \"l\")\n-    ///     .replace('p', \"l\")\n+    ///     .replace('p', \"l\");\n     /// ```\n     /// Use instead:\n     /// ```rust\n-    /// let hello = \"hesuo worpd\".replace(|c| matches!(c, 's' | 'u' | 'p'), \"l\")\n+    /// let hello = \"hesuo worpd\".replace(|c| matches!(c, 's' | 'u' | 'p'), \"l\");\n     /// ```\n     #[clippy::version = \"1.64.0\"]\n     pub COLLAPSIBLE_STR_REPLACE,\n@@ -3521,7 +3521,7 @@ impl Methods {\n                 },\n                 (\"replace\" | \"replacen\", [arg1, arg2] | [arg1, arg2, _]) => {\n                     no_effect_replace::check(cx, expr, arg1, arg2);\n-                    collapsible_str_replace::check(cx, expr, name, recv, args);\n+                    collapsible_str_replace::check(cx, expr, name, recv);\n                 },\n                 (\"splitn\" | \"rsplitn\", [count_arg, pat_arg]) => {\n                     if let Some((Constant::Int(count), _)) = constant(cx, cx.typeck_results(), count_arg) {"}, {"sha": "0bf857d9837e945238a56d5226cb8869c831f961", "filename": "tests/ui/collapsible_str_replace.fixed", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/fb30b64f6379eb22880d70bfebce66ceccc75269/tests%2Fui%2Fcollapsible_str_replace.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/fb30b64f6379eb22880d70bfebce66ceccc75269/tests%2Fui%2Fcollapsible_str_replace.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcollapsible_str_replace.fixed?ref=fb30b64f6379eb22880d70bfebce66ceccc75269", "patch": "@@ -0,0 +1,65 @@\n+// run-rustfix\n+\n+#![warn(clippy::collapsible_str_replace)]\n+\n+fn get_filter() -> &'static str {\n+    \"u\"\n+}\n+\n+fn main() {\n+    let misspelled = \"hesuo worpd\";\n+\n+    let p = 'p';\n+    let s = 's';\n+    let u = 'u';\n+    let l = \"l\";\n+\n+    // LINT CASES\n+    let _ = misspelled.replace(|c| matches!(c, 'u' | 's'), \"l\");\n+\n+    let _ = misspelled.replace(|c| matches!(c, 'u' | 's'), l);\n+\n+    let _ = misspelled.replace(|c| matches!(c, 'p' | 'u' | 's'), \"l\");\n+\n+    let _ = misspelled\n+        .replace(|c| matches!(c, 'd' | 'p' | 'u' | 's'), \"l\");\n+\n+    // FALLBACK CASES\n+    // If there are consecutive calls to `str::replace` and all or any chars are variables,\n+    // recommend the fallback `misspelled.replace(&[s, u, p], \"l\")`\n+    let _ = misspelled.replace(&['u' , s], \"l\");\n+\n+    let _ = misspelled.replace(&['p' , 'u' , s], \"l\");\n+\n+    let _ = misspelled.replace(&['p' , u , s], \"l\");\n+\n+    let _ = misspelled.replace(&[p , u , s], \"l\");\n+\n+    // NO LINT CASES\n+    let _ = misspelled.replace('s', \"l\");\n+\n+    let _ = misspelled.replace(s, \"l\");\n+\n+    // If the consecutive `str::replace` calls have different `to` arguments, do not lint\n+    let _ = misspelled.replace('s', \"l\").replace('u', \"p\");\n+\n+    let _ = misspelled.replace(&get_filter(), \"l\");\n+\n+    let _ = misspelled.replace(&['s', 'u', 'p'], \"l\");\n+\n+    let _ = misspelled.replace(&['s', 'u', 'p'], l);\n+\n+    let _ = misspelled.replace(&['s', 'u'], \"l\").replace(&['u', 'p'], \"l\");\n+\n+    let _ = misspelled.replace('s', \"l\").replace(&['u', 'p'], \"l\");\n+\n+    let _ = misspelled.replace(&['s', 'u'], \"l\").replace('p', \"l\");\n+\n+    let _ = misspelled.replace(&['s', u, 'p'], \"l\");\n+\n+    let _ = misspelled.replace(&[s, u, 'p'], \"l\");\n+\n+    let _ = misspelled.replace(&[s, u, p], \"l\");\n+\n+    let _ = misspelled.replace(&[s, u], \"l\").replace(&[u, p], \"l\");\n+}"}, {"sha": "45d9fd87e5e4a0d1bacc30739d3880d71579f923", "filename": "tests/ui/collapsible_str_replace.rs", "status": "modified", "additions": 23, "deletions": 42, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/fb30b64f6379eb22880d70bfebce66ceccc75269/tests%2Fui%2Fcollapsible_str_replace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30b64f6379eb22880d70bfebce66ceccc75269/tests%2Fui%2Fcollapsible_str_replace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcollapsible_str_replace.rs?ref=fb30b64f6379eb22880d70bfebce66ceccc75269", "patch": "@@ -1,3 +1,5 @@\n+// run-rustfix\n+\n #![warn(clippy::collapsible_str_replace)]\n \n fn get_filter() -> &'static str {\n@@ -13,75 +15,54 @@ fn main() {\n     let l = \"l\";\n \n     // LINT CASES\n-    let replacement = misspelled.replace('s', \"l\").replace('u', \"l\");\n-    println!(\"{replacement}\");\n+    let _ = misspelled.replace('s', \"l\").replace('u', \"l\");\n \n-    let replacement = misspelled.replace('s', l).replace('u', l);\n-    println!(\"{replacement}\");\n+    let _ = misspelled.replace('s', l).replace('u', l);\n \n-    let replacement = misspelled.replace('s', \"l\").replace('u', \"l\").replace('p', \"l\");\n-    println!(\"{replacement}\");\n+    let _ = misspelled.replace('s', \"l\").replace('u', \"l\").replace('p', \"l\");\n \n-    let replacement = misspelled\n+    let _ = misspelled\n         .replace('s', \"l\")\n         .replace('u', \"l\")\n         .replace('p', \"l\")\n         .replace('d', \"l\");\n-    println!(\"{replacement}\");\n \n     // FALLBACK CASES\n     // If there are consecutive calls to `str::replace` and all or any chars are variables,\n     // recommend the fallback `misspelled.replace(&[s, u, p], \"l\")`\n-    let replacement = misspelled.replace(s, \"l\").replace('u', \"l\");\n-    println!(\"{replacement}\");\n+    let _ = misspelled.replace(s, \"l\").replace('u', \"l\");\n \n-    let replacement = misspelled.replace(s, \"l\").replace('u', \"l\").replace('p', \"l\");\n-    println!(\"{replacement}\");\n+    let _ = misspelled.replace(s, \"l\").replace('u', \"l\").replace('p', \"l\");\n \n-    let replacement = misspelled.replace(s, \"l\").replace(u, \"l\").replace('p', \"l\");\n-    println!(\"{replacement}\");\n+    let _ = misspelled.replace(s, \"l\").replace(u, \"l\").replace('p', \"l\");\n \n-    let replacement = misspelled.replace(s, \"l\").replace(u, \"l\").replace(p, \"l\");\n-    println!(\"{replacement}\");\n+    let _ = misspelled.replace(s, \"l\").replace(u, \"l\").replace(p, \"l\");\n \n     // NO LINT CASES\n-    let replacement = misspelled.replace('s', \"l\");\n-    println!(\"{replacement}\");\n+    let _ = misspelled.replace('s', \"l\");\n \n-    let replacement = misspelled.replace(s, \"l\");\n-    println!(\"{replacement}\");\n+    let _ = misspelled.replace(s, \"l\");\n \n     // If the consecutive `str::replace` calls have different `to` arguments, do not lint\n-    let replacement = misspelled.replace('s', \"l\").replace('u', \"p\");\n-    println!(\"{replacement}\");\n+    let _ = misspelled.replace('s', \"l\").replace('u', \"p\");\n \n-    let replacement = misspelled.replace(&get_filter(), \"l\");\n-    println!(\"{replacement}\");\n+    let _ = misspelled.replace(&get_filter(), \"l\");\n \n-    let replacement = misspelled.replace(&['s', 'u', 'p'], \"l\");\n-    println!(\"{replacement}\");\n+    let _ = misspelled.replace(&['s', 'u', 'p'], \"l\");\n \n-    let replacement = misspelled.replace(&['s', 'u', 'p'], l);\n-    println!(\"{replacement}\");\n+    let _ = misspelled.replace(&['s', 'u', 'p'], l);\n \n-    let replacement = misspelled.replace(&['s', 'u'], \"l\").replace(&['u', 'p'], \"l\");\n-    println!(\"{replacement}\");\n+    let _ = misspelled.replace(&['s', 'u'], \"l\").replace(&['u', 'p'], \"l\");\n \n-    let replacement = misspelled.replace('s', \"l\").replace(&['u', 'p'], \"l\");\n-    println!(\"{replacement}\");\n+    let _ = misspelled.replace('s', \"l\").replace(&['u', 'p'], \"l\");\n \n-    let replacement = misspelled.replace(&['s', 'u'], \"l\").replace('p', \"l\");\n-    println!(\"replacement\");\n+    let _ = misspelled.replace(&['s', 'u'], \"l\").replace('p', \"l\");\n \n-    let replacement = misspelled.replace(&['s', u, 'p'], \"l\");\n-    println!(\"{replacement}\");\n+    let _ = misspelled.replace(&['s', u, 'p'], \"l\");\n \n-    let replacement = misspelled.replace(&[s, u, 'p'], \"l\");\n-    println!(\"{replacement}\");\n+    let _ = misspelled.replace(&[s, u, 'p'], \"l\");\n \n-    let replacement = misspelled.replace(&[s, u, p], \"l\");\n-    println!(\"{replacement}\");\n+    let _ = misspelled.replace(&[s, u, p], \"l\");\n \n-    let replacement = misspelled.replace(&[s, u], \"l\").replace(&[u, p], \"l\");\n-    println!(\"{replacement}\");\n+    let _ = misspelled.replace(&[s, u], \"l\").replace(&[u, p], \"l\");\n }"}, {"sha": "372fe1da4480d5ea529a7718c4a8d42b098ebca3", "filename": "tests/ui/collapsible_str_replace.stderr", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/fb30b64f6379eb22880d70bfebce66ceccc75269/tests%2Fui%2Fcollapsible_str_replace.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb30b64f6379eb22880d70bfebce66ceccc75269/tests%2Fui%2Fcollapsible_str_replace.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcollapsible_str_replace.stderr?ref=fb30b64f6379eb22880d70bfebce66ceccc75269", "patch": "@@ -0,0 +1,56 @@\n+error: used consecutive `str::replace` call\n+  --> $DIR/collapsible_str_replace.rs:18:24\n+   |\n+LL |     let _ = misspelled.replace('s', \"l\").replace('u', \"l\");\n+   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `replace(|c| matches!(c, 'u' | 's'), \"l\")`\n+   |\n+   = note: `-D clippy::collapsible-str-replace` implied by `-D warnings`\n+\n+error: used consecutive `str::replace` call\n+  --> $DIR/collapsible_str_replace.rs:20:24\n+   |\n+LL |     let _ = misspelled.replace('s', l).replace('u', l);\n+   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `replace(|c| matches!(c, 'u' | 's'), l)`\n+\n+error: used consecutive `str::replace` call\n+  --> $DIR/collapsible_str_replace.rs:22:24\n+   |\n+LL |     let _ = misspelled.replace('s', \"l\").replace('u', \"l\").replace('p', \"l\");\n+   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `replace(|c| matches!(c, 'p' | 'u' | 's'), \"l\")`\n+\n+error: used consecutive `str::replace` call\n+  --> $DIR/collapsible_str_replace.rs:25:10\n+   |\n+LL |           .replace('s', \"l\")\n+   |  __________^\n+LL | |         .replace('u', \"l\")\n+LL | |         .replace('p', \"l\")\n+LL | |         .replace('d', \"l\");\n+   | |__________________________^ help: replace with: `replace(|c| matches!(c, 'd' | 'p' | 'u' | 's'), \"l\")`\n+\n+error: used consecutive `str::replace` call\n+  --> $DIR/collapsible_str_replace.rs:33:24\n+   |\n+LL |     let _ = misspelled.replace(s, \"l\").replace('u', \"l\");\n+   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `replace(&['u' , s], \"l\")`\n+\n+error: used consecutive `str::replace` call\n+  --> $DIR/collapsible_str_replace.rs:35:24\n+   |\n+LL |     let _ = misspelled.replace(s, \"l\").replace('u', \"l\").replace('p', \"l\");\n+   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `replace(&['p' , 'u' , s], \"l\")`\n+\n+error: used consecutive `str::replace` call\n+  --> $DIR/collapsible_str_replace.rs:37:24\n+   |\n+LL |     let _ = misspelled.replace(s, \"l\").replace(u, \"l\").replace('p', \"l\");\n+   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `replace(&['p' , u , s], \"l\")`\n+\n+error: used consecutive `str::replace` call\n+  --> $DIR/collapsible_str_replace.rs:39:24\n+   |\n+LL |     let _ = misspelled.replace(s, \"l\").replace(u, \"l\").replace(p, \"l\");\n+   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `replace(&[p , u , s], \"l\")`\n+\n+error: aborting due to 8 previous errors\n+"}]}