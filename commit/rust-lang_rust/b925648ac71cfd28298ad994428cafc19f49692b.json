{"sha": "b925648ac71cfd28298ad994428cafc19f49692b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5MjU2NDhhYzcxY2ZkMjgyOThhZDk5NDQyOGNhZmMxOWY0OTY5MmI=", "commit": {"author": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-07-06T22:15:52Z"}, "committer": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-07-06T22:16:16Z"}, "message": "Added a k-nucleotide version that uses pipes. 31% speedup.", "tree": {"sha": "1acf87eafe6c529cdc7ade83fa475aec4495a91c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1acf87eafe6c529cdc7ade83fa475aec4495a91c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b925648ac71cfd28298ad994428cafc19f49692b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b925648ac71cfd28298ad994428cafc19f49692b", "html_url": "https://github.com/rust-lang/rust/commit/b925648ac71cfd28298ad994428cafc19f49692b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b925648ac71cfd28298ad994428cafc19f49692b/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fce064db6b40de3c75714e6a1323eee0726675d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/fce064db6b40de3c75714e6a1323eee0726675d6", "html_url": "https://github.com/rust-lang/rust/commit/fce064db6b40de3c75714e6a1323eee0726675d6"}], "stats": {"total": 289, "additions": 289, "deletions": 0}, "files": [{"sha": "f41e24c623f70bfe505f7135770f53fe952b9fe1", "filename": "src/libcore/task.rs", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/b925648ac71cfd28298ad994428cafc19f49692b/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b925648ac71cfd28298ad994428cafc19f49692b/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=b925648ac71cfd28298ad994428cafc19f49692b", "patch": "@@ -47,6 +47,7 @@ export unsupervise;\n export run_listener;\n \n export spawn;\n+export spawn_with;\n export spawn_listener;\n export spawn_sched;\n export try;\n@@ -338,6 +339,28 @@ fn unsupervise(builder: builder) {\n     });\n }\n \n+fn run_with<A:send>(-builder: builder,\n+                    +arg: A,\n+                    +f: fn~(+A)) {\n+\n+    /*!\n+     *\n+     * Runs a task, while transfering ownership of one argument to the\n+     * child.\n+     *\n+     * This is useful for transfering ownership of noncopyables to\n+     * another task.\n+     *\n+     */\n+\n+    let arg = ~mut some(arg);\n+    do run(builder) {\n+        let mut my_arg = none;\n+        my_arg <-> *arg;\n+        f(option::unwrap(my_arg))\n+    }\n+}\n+\n fn run_listener<A:send>(-builder: builder,\n                         +f: fn~(comm::port<A>)) -> comm::chan<A> {\n     /*!\n@@ -381,6 +404,22 @@ fn spawn(+f: fn~()) {\n     run(builder(), f);\n }\n \n+fn spawn_with<A:send>(+arg: A, +f: fn~(+A)) {\n+    /*!\n+     * Runs a new task while providing a channel from the parent to the child\n+     *\n+     * Sets up a communication channel from the current task to the new\n+     * child task, passes the port to child's body, and returns a channel\n+     * linked to the port to the parent.\n+     *\n+     * This encapsulates some boilerplate handshaking logic that would\n+     * otherwise be required to establish communication from the parent\n+     * to the child.\n+     */\n+\n+    run_with(builder(), arg, f)\n+}\n+\n fn spawn_listener<A:send>(+f: fn~(comm::port<A>)) -> comm::chan<A> {\n     /*!\n      * Runs a new task while providing a channel from the parent to the child"}, {"sha": "7212bbc765b1a046c997d19246b446dc870083ee", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "added", "additions": 250, "deletions": 0, "changes": 250, "blob_url": "https://github.com/rust-lang/rust/blob/b925648ac71cfd28298ad994428cafc19f49692b/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b925648ac71cfd28298ad994428cafc19f49692b/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=b925648ac71cfd28298ad994428cafc19f49692b", "patch": "@@ -0,0 +1,250 @@\n+// xfail-pretty\n+\n+// multi tasking k-nucleotide\n+\n+import io::reader_util;\n+\n+use std;\n+import std::map;\n+import std::map::hashmap;\n+import std::sort;\n+\n+import stream::{stream, chan, port};\n+\n+// After a snapshot, this should move into core, or std.\n+mod stream {\n+    import option::unwrap;\n+\n+    proto! streamp {\n+        open:send<T: send> {\n+            data(T) -> open<T>\n+        }\n+    }\n+\n+    type chan<T:send> = { mut endp: option<streamp::client::open<T>> };\n+    type port<T:send> = { mut endp: option<streamp::server::open<T>> };\n+\n+    fn stream<T:send>() -> (chan<T>, port<T>) {\n+        let (c, s) = streamp::init();\n+        ({ mut endp: some(c) }, { mut endp: some(s) })\n+    }\n+\n+    impl chan<T: send> for chan<T> {\n+        fn send(+x: T) {\n+            let mut endp = none;\n+            endp <-> self.endp;\n+            self.endp = some(\n+                streamp::client::data(unwrap(endp), x))\n+        }\n+    }\n+\n+    impl port<T: send> for port<T> {\n+        fn recv() -> T {\n+            let mut endp = none;\n+            endp <-> self.endp;\n+            let streamp::data(x, endp) = unwrap(\n+                pipes::recv(unwrap(endp)));\n+            self.endp = some(endp);\n+            x\n+        }\n+    }\n+}\n+\n+// given a map, print a sorted version of it\n+fn sort_and_fmt(mm: hashmap<~[u8], uint>, total: uint) -> str { \n+   fn pct(xx: uint, yy: uint) -> float {\n+      ret (xx as float) * 100f / (yy as float);\n+   }\n+\n+   fn le_by_val<TT: copy, UU: copy>(kv0: (TT,UU), kv1: (TT,UU)) -> bool {\n+      let (_, v0) = kv0;\n+      let (_, v1) = kv1;\n+      ret v0 >= v1;\n+   }\n+\n+   fn le_by_key<TT: copy, UU: copy>(kv0: (TT,UU), kv1: (TT,UU)) -> bool {\n+      let (k0, _) = kv0;\n+      let (k1, _) = kv1;\n+      ret k0 <= k1;\n+   }\n+\n+   // sort by key, then by value\n+   fn sortKV<TT: copy, UU: copy>(orig: ~[(TT,UU)]) -> ~[(TT,UU)] {\n+      ret sort::merge_sort(le_by_val, sort::merge_sort(le_by_key, orig));\n+   }\n+\n+   let mut pairs = ~[];\n+\n+   // map -> [(k,%)]\n+   mm.each(fn&(key: ~[u8], val: uint) -> bool {\n+      vec::push(pairs, (key, pct(val, total)));\n+      ret true;\n+   });\n+\n+   let pairs_sorted = sortKV(pairs);\n+   \n+   let mut buffer = \"\";\n+\n+   pairs_sorted.each(fn&(kv: (~[u8], float)) -> bool unsafe {\n+      let (k,v) = kv;\n+      buffer += (#fmt[\"%s %0.3f\\n\", str::to_upper(str::unsafe::from_bytes(k)), v]);\n+      ret true;\n+   });\n+\n+   ret buffer;\n+}\n+\n+// given a map, search for the frequency of a pattern\n+fn find(mm: hashmap<~[u8], uint>, key: str) -> uint {\n+   alt mm.find(str::bytes(str::to_lower(key))) {\n+      option::none      { ret 0u; }\n+      option::some(num) { ret num; }\n+   }\n+}\n+\n+// given a map, increment the counter for a key\n+fn update_freq(mm: hashmap<~[u8], uint>, key: &[u8]) {\n+    let key = vec::slice(key, 0, key.len());\n+    alt mm.find(key) {\n+      option::none      { mm.insert(key, 1u      ); }\n+      option::some(val) { mm.insert(key, 1u + val); }\n+    }\n+}\n+\n+// given a ~[u8], for each window call a function\n+// i.e., for \"hello\" and windows of size four,\n+// run it(\"hell\") and it(\"ello\"), then return \"llo\"\n+fn windows_with_carry(bb: ~[const u8], nn: uint,\n+                      it: fn(window: &[u8])) -> ~[u8] {\n+   let mut ii = 0u;\n+\n+   let len = vec::len(bb);\n+   while ii < len - (nn - 1u) {\n+      it(vec::view(bb, ii, ii+nn));\n+      ii += 1u;\n+   }\n+\n+   ret vec::slice(bb, len - (nn - 1u), len); \n+}\n+\n+fn make_sequence_processor(sz: uint, from_parent: stream::port<~[u8]>,\n+                           to_parent: stream::chan<str>) {\n+   \n+   let freqs: hashmap<~[u8], uint> = map::bytes_hash();\n+   let mut carry: ~[u8] = ~[];\n+   let mut total: uint = 0u;\n+\n+   let mut line: ~[u8];\n+\n+   loop {\n+\n+      line = from_parent.recv();\n+      if line == ~[] { break; }\n+\n+       carry = windows_with_carry(carry + line, sz, |window| {\n+         update_freq(freqs, window);\n+         total += 1u;\n+      });\n+   }\n+\n+   let buffer = alt sz { \n+       1u { sort_and_fmt(freqs, total) }\n+       2u { sort_and_fmt(freqs, total) }\n+       3u { #fmt[\"%u\\t%s\", find(freqs, \"GGT\"), \"GGT\"] }\n+       4u { #fmt[\"%u\\t%s\", find(freqs, \"GGTA\"), \"GGTA\"] }\n+       6u { #fmt[\"%u\\t%s\", find(freqs, \"GGTATT\"), \"GGTATT\"] }\n+      12u { #fmt[\"%u\\t%s\", find(freqs, \"GGTATTTTAATT\"), \"GGTATTTTAATT\"] }\n+      18u { #fmt[\"%u\\t%s\", find(freqs, \"GGTATTTTAATTTATAGT\"), \"GGTATTTTAATTTATAGT\"] }\n+        _ { \"\" }\n+   };\n+\n+   //comm::send(to_parent, #fmt[\"yay{%u}\", sz]);\n+    to_parent.send(buffer);\n+}\n+\n+// given a FASTA file on stdin, process sequence THREE\n+fn main(args: ~[str]) {\n+   let rdr = if os::getenv(\"RUST_BENCH\").is_some() {\n+       // FIXME: Using this compile-time env variable is a crummy way to\n+       // get to this massive data set, but #include_bin chokes on it (#2598)\n+       let path = path::connect(\n+           #env(\"CFG_SRC_DIR\"),\n+           \"src/test/bench/shootout-k-nucleotide.data\"\n+           );\n+       result::get(io::file_reader(path))\n+   } else {\n+      io::stdin()\n+   };\n+\n+\n+\n+   // initialize each sequence sorter\n+   let sizes = ~[1u,2u,3u,4u,6u,12u,18u];\n+    let streams = vec::map(sizes, |_sz| some(stream()));\n+    let streams = vec::to_mut(streams);\n+    let mut from_child = ~[];\n+    let to_child   = vec::mapi(sizes, |ii, sz| {\n+        let mut stream = none;\n+        stream <-> streams[ii];\n+        let (to_parent_, from_child_) = option::unwrap(stream);\n+\n+        vec::push(from_child, from_child_);\n+\n+        let (to_child, from_parent) = stream::stream();\n+\n+        do task::spawn_with(from_parent) |from_parent| {\n+            make_sequence_processor(sz, from_parent, to_parent_);\n+        };\n+        \n+        to_child\n+    });\n+         \n+   \n+   // latch stores true after we've started\n+   // reading the sequence of interest\n+   let mut proc_mode = false;\n+\n+   while !rdr.eof() {\n+      let line: str = rdr.read_line();\n+\n+      if str::len(line) == 0u { cont; }\n+\n+      alt (line[0], proc_mode) {\n+\n+         // start processing if this is the one\n+         ('>' as u8, false) {\n+            alt str::find_str_from(line, \"THREE\", 1u) {\n+               option::some(_) { proc_mode = true; }\n+               option::none    { }\n+            }\n+         }\n+\n+         // break our processing\n+         ('>' as u8, true) { break; }\n+\n+         // process the sequence for k-mers\n+         (_, true) {\n+            let line_bytes = str::bytes(line);\n+\n+           for sizes.eachi |ii, _sz| {\n+               let mut lb = line_bytes;\n+               to_child[ii].send(lb);\n+            }\n+         }\n+\n+         // whatever\n+         _ { }\n+      }\n+   }\n+\n+   // finish...\n+    for sizes.eachi |ii, _sz| {\n+      to_child[ii].send(~[]);\n+   }\n+\n+   // now fetch and print result messages\n+    for sizes.eachi |ii, _sz| {\n+      io::println(from_child[ii].recv());\n+   }\n+}\n+"}]}