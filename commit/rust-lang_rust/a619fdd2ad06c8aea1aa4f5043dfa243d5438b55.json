{"sha": "a619fdd2ad06c8aea1aa4f5043dfa243d5438b55", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2MTlmZGQyYWQwNmM4YWVhMWFhNGY1MDQzZGZhMjQzZDU0MzhiNTU=", "commit": {"author": {"name": "Piotr Czarnecki", "email": "pioczarn@gmail.com", "date": "2016-03-05T21:11:15Z"}, "committer": {"name": "Piotr Czarnecki", "email": "pioczarn@gmail.com", "date": "2016-03-05T21:11:15Z"}, "message": "Add `InternalEntry` for use in all searches.", "tree": {"sha": "851e51ab9a0741cfbc199e120ff45182e327764b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/851e51ab9a0741cfbc199e120ff45182e327764b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a619fdd2ad06c8aea1aa4f5043dfa243d5438b55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a619fdd2ad06c8aea1aa4f5043dfa243d5438b55", "html_url": "https://github.com/rust-lang/rust/commit/a619fdd2ad06c8aea1aa4f5043dfa243d5438b55", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a619fdd2ad06c8aea1aa4f5043dfa243d5438b55/comments", "author": {"login": "pczarn", "id": 3356767, "node_id": "MDQ6VXNlcjMzNTY3Njc=", "avatar_url": "https://avatars.githubusercontent.com/u/3356767?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pczarn", "html_url": "https://github.com/pczarn", "followers_url": "https://api.github.com/users/pczarn/followers", "following_url": "https://api.github.com/users/pczarn/following{/other_user}", "gists_url": "https://api.github.com/users/pczarn/gists{/gist_id}", "starred_url": "https://api.github.com/users/pczarn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pczarn/subscriptions", "organizations_url": "https://api.github.com/users/pczarn/orgs", "repos_url": "https://api.github.com/users/pczarn/repos", "events_url": "https://api.github.com/users/pczarn/events{/privacy}", "received_events_url": "https://api.github.com/users/pczarn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pczarn", "id": 3356767, "node_id": "MDQ6VXNlcjMzNTY3Njc=", "avatar_url": "https://avatars.githubusercontent.com/u/3356767?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pczarn", "html_url": "https://github.com/pczarn", "followers_url": "https://api.github.com/users/pczarn/followers", "following_url": "https://api.github.com/users/pczarn/following{/other_user}", "gists_url": "https://api.github.com/users/pczarn/gists{/gist_id}", "starred_url": "https://api.github.com/users/pczarn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pczarn/subscriptions", "organizations_url": "https://api.github.com/users/pczarn/orgs", "repos_url": "https://api.github.com/users/pczarn/repos", "events_url": "https://api.github.com/users/pczarn/events{/privacy}", "received_events_url": "https://api.github.com/users/pczarn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c71f720d9bf331c2922eafc35c27ccac05e94e5d", "url": "https://api.github.com/repos/rust-lang/rust/commits/c71f720d9bf331c2922eafc35c27ccac05e94e5d", "html_url": "https://github.com/rust-lang/rust/commit/c71f720d9bf331c2922eafc35c27ccac05e94e5d"}], "stats": {"total": 286, "additions": 119, "deletions": 167}, "files": [{"sha": "91626b8d16b639ebba65d0d23766a5639ad179b7", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 109, "deletions": 159, "changes": 268, "blob_url": "https://github.com/rust-lang/rust/blob/a619fdd2ad06c8aea1aa4f5043dfa243d5438b55/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a619fdd2ad06c8aea1aa4f5043dfa243d5438b55/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=a619fdd2ad06c8aea1aa4f5043dfa243d5438b55", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use self::Entry::*;\n-use self::SearchResult::*;\n use self::VacantEntryState::*;\n \n use borrow::Borrow;\n@@ -26,7 +25,6 @@ use super::table::{\n     Bucket,\n     EmptyBucket,\n     FullBucket,\n-    FullBucketImm,\n     FullBucketMut,\n     RawTable,\n     SafeHash\n@@ -342,48 +340,62 @@ pub struct HashMap<K, V, S = RandomState> {\n }\n \n /// Search for a pre-hashed key.\n+#[inline]\n fn search_hashed<K, V, M, F>(table: M,\n                              hash: SafeHash,\n                              mut is_match: F)\n-                             -> SearchResult<K, V, M> where\n+                             -> InternalEntry<K, V, M> where\n     M: Deref<Target=RawTable<K, V>>,\n     F: FnMut(&K) -> bool,\n {\n     // This is the only function where capacity can be zero. To avoid\n     // undefined behavior when Bucket::new gets the raw bucket in this\n     // case, immediately return the appropriate search result.\n     if table.capacity() == 0 {\n-        return TableRef(table);\n+        return InternalEntry::TableIsEmpty;\n     }\n \n-    let size = table.size();\n+    let size = table.size() as isize;\n     let mut probe = Bucket::new(table, hash);\n-    let ib = probe.index();\n+    let ib = probe.index() as isize;\n \n-    while probe.index() != ib + size {\n+    loop {\n         let full = match probe.peek() {\n-            Empty(b) => return TableRef(b.into_table()), // hit an empty bucket\n-            Full(b) => b\n+            Empty(bucket) => {\n+                // Found a hole!\n+                return InternalEntry::Vacant {\n+                    hash: hash,\n+                    elem: NoElem(bucket),\n+                };\n+            }\n+            Full(bucket) => bucket\n         };\n \n-        if full.distance() + ib < full.index() {\n+        let robin_ib = full.index() as isize - full.displacement() as isize;\n+\n+        if ib < robin_ib {\n+            // Found a luckier bucket than me.\n             // We can finish the search early if we hit any bucket\n             // with a lower distance to initial bucket than we've probed.\n-            return TableRef(full.into_table());\n+            return InternalEntry::Vacant {\n+                hash: hash,\n+                elem: NeqElem(full, robin_ib as usize),\n+            };\n         }\n \n         // If the hash doesn't match, it can't be this one..\n         if hash == full.hash() {\n             // If the key doesn't match, it can't be this one..\n             if is_match(full.read().0) {\n-                return FoundExisting(full);\n+                return InternalEntry::Occupied {\n+                    elem: full\n+                };\n             }\n         }\n \n         probe = full.next();\n+        assert!(probe.index() as isize != ib + size + 1);\n     }\n-\n-    TableRef(probe.into_table())\n }\n \n fn pop_internal<K, V>(starting_bucket: FullBucketMut<K, V>) -> (K, V) {\n@@ -462,25 +474,6 @@ fn robin_hood<'a, K: 'a, V: 'a>(mut bucket: FullBucketMut<'a, K, V>,\n     }\n }\n \n-/// A result that works like Option<FullBucket<..>> but preserves\n-/// the reference that grants us access to the table in any case.\n-enum SearchResult<K, V, M> {\n-    // This is an entry that holds the given key:\n-    FoundExisting(FullBucket<K, V, M>),\n-\n-    // There was no such entry. The reference is given back:\n-    TableRef(M)\n-}\n-\n-impl<K, V, M> SearchResult<K, V, M> {\n-    fn into_option(self) -> Option<FullBucket<K, V, M>> {\n-        match self {\n-            FoundExisting(bucket) => Some(bucket),\n-            TableRef(_) => None\n-        }\n-    }\n-}\n-\n impl<K, V, S> HashMap<K, V, S>\n     where K: Eq + Hash, S: BuildHasher\n {\n@@ -491,20 +484,20 @@ impl<K, V, S> HashMap<K, V, S>\n     /// Search for a key, yielding the index if it's found in the hashtable.\n     /// If you already have the hash for the key lying around, use\n     /// search_hashed.\n-    fn search<'a, Q: ?Sized>(&'a self, q: &Q) -> Option<FullBucketImm<'a, K, V>>\n+    #[inline]\n+    fn search<'a, Q: ?Sized>(&'a self, q: &Q) -> InternalEntry<K, V, &'a RawTable<K, V>>\n         where K: Borrow<Q>, Q: Eq + Hash\n     {\n         let hash = self.make_hash(q);\n         search_hashed(&self.table, hash, |k| q.eq(k.borrow()))\n-            .into_option()\n     }\n \n-    fn search_mut<'a, Q: ?Sized>(&'a mut self, q: &Q) -> Option<FullBucketMut<'a, K, V>>\n+    #[inline]\n+    fn search_mut<'a, Q: ?Sized>(&'a mut self, q: &Q) -> InternalEntry<K, V, &'a mut RawTable<K, V>>\n         where K: Borrow<Q>, Q: Eq + Hash\n     {\n         let hash = self.make_hash(q);\n         search_hashed(&mut self.table, hash, |k| q.eq(k.borrow()))\n-            .into_option()\n     }\n \n     // The caller should ensure that invariants by Robin Hood Hashing hold.\n@@ -824,53 +817,19 @@ impl<K, V, S> HashMap<K, V, S>\n     ///\n     /// If the key already exists, the hashtable will be returned untouched\n     /// and a reference to the existing element will be returned.\n-    fn insert_hashed_nocheck(&mut self, hash: SafeHash, k: K, v: V) -> &mut V {\n-        self.insert_or_replace_with(hash, k, v, |_, _, _, _| ())\n-    }\n-\n-    fn insert_or_replace_with<'a, F>(&'a mut self,\n-                                     hash: SafeHash,\n-                                     k: K,\n-                                     v: V,\n-                                     mut found_existing: F)\n-                                     -> &'a mut V where\n-        F: FnMut(&mut K, &mut V, K, V),\n-    {\n-        // Worst case, we'll find one empty bucket among `size + 1` buckets.\n-        let size = self.table.size();\n-        let mut probe = Bucket::new(&mut self.table, hash);\n-        let ib = probe.index();\n-\n-        loop {\n-            let mut bucket = match probe.peek() {\n-                Empty(bucket) => {\n-                    // Found a hole!\n-                    return bucket.put(hash, k, v).into_mut_refs().1;\n-                }\n-                Full(bucket) => bucket\n-            };\n-\n-            // hash matches?\n-            if bucket.hash() == hash {\n-                // key matches?\n-                if k == *bucket.read_mut().0 {\n-                    let (bucket_k, bucket_v) = bucket.into_mut_refs();\n-                    debug_assert!(k == *bucket_k);\n-                    // Key already exists. Get its reference.\n-                    found_existing(bucket_k, bucket_v, k, v);\n-                    return bucket_v;\n-                }\n+    fn insert_hashed_nocheck(&mut self, hash: SafeHash, k: K, v: V) -> Option<V> {\n+        let entry = search_hashed(&mut self.table, hash, |key| *key == k).into_entry(k);\n+        match entry {\n+            Some(Occupied(mut elem)) => {\n+                Some(elem.insert(v))\n             }\n-\n-            let robin_ib = bucket.index() as isize - bucket.distance() as isize;\n-\n-            if (ib as isize) < robin_ib {\n-                // Found a luckier bucket than me. Better steal his spot.\n-                return robin_hood(bucket, robin_ib as usize, hash, k, v);\n+            Some(Vacant(elem)) => {\n+                elem.insert(v);\n+                None\n+            }\n+            None => {\n+                unreachable!()\n             }\n-\n-            probe = bucket.next();\n-            assert!(probe.index() != ib + size + 1);\n         }\n     }\n \n@@ -997,9 +956,7 @@ impl<K, V, S> HashMap<K, V, S>\n     pub fn entry(&mut self, key: K) -> Entry<K, V> {\n         // Gotta resize now.\n         self.reserve(1);\n-\n-        let hash = self.make_hash(&key);\n-        search_entry_hashed(&mut self.table, hash, key)\n+        self.search_mut(&key).into_entry(key).expect(\"unreachable\")\n     }\n \n     /// Returns the number of elements in the map.\n@@ -1102,7 +1059,7 @@ impl<K, V, S> HashMap<K, V, S>\n     pub fn get<Q: ?Sized>(&self, k: &Q) -> Option<&V>\n         where K: Borrow<Q>, Q: Hash + Eq\n     {\n-        self.search(k).map(|bucket| bucket.into_refs().1)\n+        self.search(k).into_occupied_bucket().map(|bucket| bucket.into_refs().1)\n     }\n \n     /// Returns true if the map contains a value for the specified key.\n@@ -1125,7 +1082,7 @@ impl<K, V, S> HashMap<K, V, S>\n     pub fn contains_key<Q: ?Sized>(&self, k: &Q) -> bool\n         where K: Borrow<Q>, Q: Hash + Eq\n     {\n-        self.search(k).is_some()\n+        self.search(k).into_occupied_bucket().is_some()\n     }\n \n     /// Returns a mutable reference to the value corresponding to the key.\n@@ -1150,7 +1107,7 @@ impl<K, V, S> HashMap<K, V, S>\n     pub fn get_mut<Q: ?Sized>(&mut self, k: &Q) -> Option<&mut V>\n         where K: Borrow<Q>, Q: Hash + Eq\n     {\n-        self.search_mut(k).map(|bucket| bucket.into_mut_refs().1)\n+        self.search_mut(k).into_occupied_bucket().map(|bucket| bucket.into_mut_refs().1)\n     }\n \n     /// Inserts a key-value pair into the map.\n@@ -1181,12 +1138,7 @@ impl<K, V, S> HashMap<K, V, S>\n     pub fn insert(&mut self, k: K, v: V) -> Option<V> {\n         let hash = self.make_hash(&k);\n         self.reserve(1);\n-\n-        let mut retval = None;\n-        self.insert_or_replace_with(hash, k, v, |_, val_ref, _, val| {\n-            retval = Some(replace(val_ref, val));\n-        });\n-        retval\n+        self.insert_hashed_nocheck(hash, k, v)\n     }\n \n     /// Removes a key from the map, returning the value at the key if the key\n@@ -1214,54 +1166,7 @@ impl<K, V, S> HashMap<K, V, S>\n             return None\n         }\n \n-        self.search_mut(k).map(|bucket| pop_internal(bucket).1)\n-    }\n-}\n-\n-fn search_entry_hashed<'a, K: Eq, V>(table: &'a mut RawTable<K,V>, hash: SafeHash, k: K)\n-        -> Entry<'a, K, V>\n-{\n-    // Worst case, we'll find one empty bucket among `size + 1` buckets.\n-    let size = table.size();\n-    let mut probe = Bucket::new(table, hash);\n-    let ib = probe.index();\n-\n-    loop {\n-        let bucket = match probe.peek() {\n-            Empty(bucket) => {\n-                // Found a hole!\n-                return Vacant(VacantEntry {\n-                    hash: hash,\n-                    key: k,\n-                    elem: NoElem(bucket),\n-                });\n-            },\n-            Full(bucket) => bucket\n-        };\n-\n-        // hash matches?\n-        if bucket.hash() == hash {\n-            // key matches?\n-            if k == *bucket.read().0 {\n-                return Occupied(OccupiedEntry{\n-                    elem: bucket,\n-                });\n-            }\n-        }\n-\n-        let robin_ib = bucket.index() as isize - bucket.distance() as isize;\n-\n-        if (ib as isize) < robin_ib {\n-            // Found a luckier bucket than me. Better steal his spot.\n-            return Vacant(VacantEntry {\n-                hash: hash,\n-                key: k,\n-                elem: NeqElem(bucket, robin_ib as usize),\n-            });\n-        }\n-\n-        probe = bucket.next();\n-        assert!(probe.index() != ib + size + 1);\n+        self.search_mut(k).into_occupied_bucket().map(|bucket| pop_internal(bucket).1)\n     }\n }\n \n@@ -1382,18 +1287,46 @@ pub struct Drain<'a, K: 'a, V: 'a> {\n     inner: iter::Map<table::Drain<'a, K, V>, fn((SafeHash, K, V)) -> (K, V)>\n }\n \n-/// A view into a single occupied location in a HashMap.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct OccupiedEntry<'a, K: 'a, V: 'a> {\n-    elem: FullBucket<K, V, &'a mut RawTable<K, V>>,\n+enum InternalEntry<K, V, M> {\n+    Occupied {\n+        elem: FullBucket<K, V, M>,\n+    },\n+    Vacant {\n+        hash: SafeHash,\n+        elem: VacantEntryState<K, V, M>,\n+    },\n+    TableIsEmpty,\n }\n \n-/// A view into a single empty location in a HashMap.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct VacantEntry<'a, K: 'a, V: 'a> {\n-    hash: SafeHash,\n-    key: K,\n-    elem: VacantEntryState<K, V, &'a mut RawTable<K, V>>,\n+impl<K, V, M> InternalEntry<K, V, M> {\n+    #[inline]\n+    fn into_occupied_bucket(self) -> Option<FullBucket<K, V, M>> {\n+        match self {\n+            InternalEntry::Occupied { elem } => Some(elem),\n+            _ => None,\n+        }\n+    }\n+}\n+\n+impl<'a, K, V> InternalEntry<K, V, &'a mut RawTable<K, V>> {\n+    #[inline]\n+    fn into_entry(self, key: K) -> Option<Entry<'a, K, V>> {\n+        match self {\n+            InternalEntry::Occupied { elem } => {\n+                Some(Occupied(OccupiedEntry {\n+                    elem: elem\n+                }))\n+            }\n+            InternalEntry::Vacant { hash, elem } => {\n+                Some(Vacant(VacantEntry {\n+                    hash: hash,\n+                    key: key,\n+                    elem: elem,\n+                }))\n+            }\n+            InternalEntry::TableIsEmpty => None\n+        }\n+    }\n }\n \n /// A view into a single location in a map, which may be vacant or occupied.\n@@ -1412,6 +1345,20 @@ pub enum Entry<'a, K: 'a, V: 'a> {\n     ),\n }\n \n+/// A view into a single occupied location in a HashMap.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct OccupiedEntry<'a, K: 'a, V: 'a> {\n+    elem: FullBucket<K, V, &'a mut RawTable<K, V>>,\n+}\n+\n+/// A view into a single empty location in a HashMap.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct VacantEntry<'a, K: 'a, V: 'a> {\n+    hash: SafeHash,\n+    key: K,\n+    elem: VacantEntryState<K, V, &'a mut RawTable<K, V>>,\n+}\n+\n /// Possible states of a VacantEntry.\n enum VacantEntryState<K, V, M> {\n     /// The index is occupied, but the key to insert has precedence,\n@@ -1703,26 +1650,29 @@ impl<K, S, Q: ?Sized> super::Recover<Q> for HashMap<K, (), S>\n     type Key = K;\n \n     fn get(&self, key: &Q) -> Option<&K> {\n-        self.search(key).map(|bucket| bucket.into_refs().0)\n+        self.search(key).into_occupied_bucket().map(|bucket| bucket.into_refs().0)\n     }\n \n     fn take(&mut self, key: &Q) -> Option<K> {\n         if self.table.size() == 0 {\n             return None\n         }\n \n-        self.search_mut(key).map(|bucket| pop_internal(bucket).0)\n+        self.search_mut(key).into_occupied_bucket().map(|bucket| pop_internal(bucket).0)\n     }\n \n     fn replace(&mut self, key: K) -> Option<K> {\n         let hash = self.make_hash(&key);\n         self.reserve(1);\n \n-        let mut retkey = None;\n-        self.insert_or_replace_with(hash, key, (), |key_ref, _, key, _| {\n-            retkey = Some(replace(key_ref, key));\n-        });\n-        retkey\n+        match search_hashed(&mut self.table, hash, |k| *k == key) {\n+            InternalEntry::Occupied { mut elem } => {\n+                Some(mem::replace(elem.read_mut().0, key))\n+            }\n+            _ => {\n+                None\n+            }\n+        }\n     }\n }\n "}, {"sha": "1a29c2c159a85e5fb3f1597a36f1a25f094af8aa", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a619fdd2ad06c8aea1aa4f5043dfa243d5438b55/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a619fdd2ad06c8aea1aa4f5043dfa243d5438b55/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=a619fdd2ad06c8aea1aa4f5043dfa243d5438b55", "patch": "@@ -180,6 +180,8 @@ impl<K, V> RawBucket<K, V> {\n     }\n }\n \n+// Uncomment dead code when it's needed.\n+\n // Buckets hold references to the table.\n impl<K, V, M> FullBucket<K, V, M> {\n     /// Borrow a reference to the table.\n@@ -201,17 +203,17 @@ impl<K, V, M> EmptyBucket<K, V, M> {\n     pub fn table(&self) -> &M {\n         &self.table\n     }\n-    /// Move out the reference to the table.\n-    pub fn into_table(self) -> M {\n-        self.table\n-    }\n+    // /// Move out the reference to the table.\n+    // pub fn into_table(self) -> M {\n+    //     self.table\n+    // }\n }\n \n impl<K, V, M> Bucket<K, V, M> {\n-    /// Move out the reference to the table.\n-    pub fn into_table(self) -> M {\n-        self.table\n-    }\n+    // /// Move out the reference to the table.\n+    // pub fn into_table(self) -> M {\n+    //     self.table\n+    // }\n     /// Get the raw index.\n     pub fn index(&self) -> usize {\n         self.idx"}]}