{"sha": "fc4f6eda96f6a31d9417a3a25977faf2e4684ba6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjNGY2ZWRhOTZmNmEzMWQ5NDE3YTNhMjU5NzdmYWYyZTQ2ODRiYTY=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2014-07-17T12:28:03Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2014-07-18T11:48:06Z"}, "message": "Removed `index_to_bitset` from the dataflow context.\n\nPart of addressing 15019.", "tree": {"sha": "672e4dd66df21216492068582d6d2b6daa35b7be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/672e4dd66df21216492068582d6d2b6daa35b7be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fc4f6eda96f6a31d9417a3a25977faf2e4684ba6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fc4f6eda96f6a31d9417a3a25977faf2e4684ba6", "html_url": "https://github.com/rust-lang/rust/commit/fc4f6eda96f6a31d9417a3a25977faf2e4684ba6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fc4f6eda96f6a31d9417a3a25977faf2e4684ba6/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d9f1d6b7f69f293ba5f060fd9e179de228d9497b", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9f1d6b7f69f293ba5f060fd9e179de228d9497b", "html_url": "https://github.com/rust-lang/rust/commit/d9f1d6b7f69f293ba5f060fd9e179de228d9497b"}], "stats": {"total": 71, "additions": 15, "deletions": 56}, "files": [{"sha": "fb3299013efd77f45bbd276ede5340d409008241", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 15, "deletions": 56, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/fc4f6eda96f6a31d9417a3a25977faf2e4684ba6/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc4f6eda96f6a31d9417a3a25977faf2e4684ba6/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=fc4f6eda96f6a31d9417a3a25977faf2e4684ba6", "patch": "@@ -48,9 +48,6 @@ pub struct DataFlowContext<'a, O> {\n     /// equal to bits_per_id/uint::BITS rounded up.\n     words_per_id: uint,\n \n-    // mapping from cfg node index to bitset index.\n-    index_to_bitset: Vec<Option<uint>>,\n-\n     // mapping from node to cfg node index\n     // FIXME (#6298): Shouldn't this go with CFG?\n     nodeid_to_index: NodeMap<CFGIndex>,\n@@ -98,58 +95,16 @@ fn to_cfgidx_or_die(id: ast::NodeId, index: &NodeMap<CFGIndex>) -> CFGIndex {\n impl<'a, O:DataFlowOperator> DataFlowContext<'a, O> {\n     fn has_bitset_for_nodeid(&self, n: ast::NodeId) -> bool {\n         assert!(n != ast::DUMMY_NODE_ID);\n-        match self.nodeid_to_index.find(&n) {\n-            None => false,\n-            Some(&cfgidx) => self.has_bitset_for_cfgidx(cfgidx),\n-        }\n+        self.nodeid_to_index.contains_key(&n)\n     }\n-    fn has_bitset_for_cfgidx(&self, cfgidx: CFGIndex) -> bool {\n-        let node_id = cfgidx.node_id();\n-        node_id < self.index_to_bitset.len() &&\n-            self.index_to_bitset.get(node_id).is_some()\n+    fn has_bitset_for_cfgidx(&self, _cfgidx: CFGIndex) -> bool {\n+        true\n     }\n     fn get_bitset_index(&self, cfgidx: CFGIndex) -> uint {\n-        let node_id = cfgidx.node_id();\n-        self.index_to_bitset.get(node_id).unwrap()\n+        cfgidx.node_id()\n     }\n     fn get_or_create_bitset_index(&mut self, cfgidx: CFGIndex) -> uint {\n-        assert!(self.words_per_id > 0);\n-        let len = self.gens.len() / self.words_per_id;\n-        let expanded;\n-        let n;\n-        if self.index_to_bitset.len() <= cfgidx.node_id() {\n-            self.index_to_bitset.grow_set(cfgidx.node_id(), &None, Some(len));\n-            expanded = true;\n-            n = len;\n-        } else {\n-            let entry = self.index_to_bitset.get_mut(cfgidx.node_id());\n-            match *entry {\n-                None => {\n-                    *entry = Some(len);\n-                    expanded = true;\n-                    n = len;\n-                }\n-                Some(bitidx) => {\n-                    expanded = false;\n-                    n = bitidx;\n-                }\n-            }\n-        }\n-        if expanded {\n-            let entry = if self.oper.initial_value() { uint::MAX } else {0};\n-            for _ in range(0, self.words_per_id) {\n-                self.gens.push(0);\n-                self.kills.push(0);\n-                self.on_entry.push(entry);\n-            }\n-        }\n-\n-        let start = n * self.words_per_id;\n-        let end = start + self.words_per_id;\n-        let len = self.gens.len();\n-        assert!(start < len);\n-        assert!(end <= len);\n-        n\n+        cfgidx.node_id()\n     }\n }\n \n@@ -243,22 +198,26 @@ impl<'a, O:DataFlowOperator> DataFlowContext<'a, O> {\n                id_range: IdRange,\n                bits_per_id: uint) -> DataFlowContext<'a, O> {\n         let words_per_id = (bits_per_id + uint::BITS - 1) / uint::BITS;\n+        let num_nodes = cfg.graph.all_nodes().len();\n \n         debug!(\"DataFlowContext::new(analysis_name: {:s}, id_range={:?}, \\\n-                                     bits_per_id={:?}, words_per_id={:?})\",\n-               analysis_name, id_range, bits_per_id, words_per_id);\n+                                     bits_per_id={:?}, words_per_id={:?}) \\\n+                                     num_nodes: {}\",\n+               analysis_name, id_range, bits_per_id, words_per_id,\n+               num_nodes);\n+\n+        let entry = if oper.initial_value() { uint::MAX } else {0};\n \n-        let gens = Vec::new();\n-        let kills = Vec::new();\n-        let on_entry = Vec::new();\n+        let gens = Vec::from_elem(num_nodes * words_per_id, 0);\n+        let kills = Vec::from_elem(num_nodes * words_per_id, 0);\n+        let on_entry = Vec::from_elem(num_nodes * words_per_id, entry);\n \n         let nodeid_to_index = build_nodeid_to_index(decl, cfg);\n \n         DataFlowContext {\n             tcx: tcx,\n             analysis_name: analysis_name,\n             words_per_id: words_per_id,\n-            index_to_bitset: Vec::new(),\n             nodeid_to_index: nodeid_to_index,\n             bits_per_id: bits_per_id,\n             oper: oper,"}]}