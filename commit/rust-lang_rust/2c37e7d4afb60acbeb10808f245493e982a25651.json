{"sha": "2c37e7d4afb60acbeb10808f245493e982a25651", "node_id": "C_kwDOAAsO6NoAKDJjMzdlN2Q0YWZiNjBhY2JlYjEwODA4ZjI0NTQ5M2U5ODJhMjU2NTE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-05T12:16:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-05T12:16:18Z"}, "message": "Auto merge of #13549 - Veykril:search-fix, r=Veykril\n\nfix: Fix reference searching only accounting substrings instead of whole identifiers\n\nFixes https://github.com/rust-lang/rust-analyzer/issues/13498", "tree": {"sha": "466f2c08864eba5842bb4e0b80cbae53ac2b9aac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/466f2c08864eba5842bb4e0b80cbae53ac2b9aac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2c37e7d4afb60acbeb10808f245493e982a25651", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2c37e7d4afb60acbeb10808f245493e982a25651", "html_url": "https://github.com/rust-lang/rust/commit/2c37e7d4afb60acbeb10808f245493e982a25651", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2c37e7d4afb60acbeb10808f245493e982a25651/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "df3877037e448ca90b17525b00418a2c30da8ddb", "url": "https://api.github.com/repos/rust-lang/rust/commits/df3877037e448ca90b17525b00418a2c30da8ddb", "html_url": "https://github.com/rust-lang/rust/commit/df3877037e448ca90b17525b00418a2c30da8ddb"}, {"sha": "17619de7119ef00f5588f5b472cc331f4607e411", "url": "https://api.github.com/repos/rust-lang/rust/commits/17619de7119ef00f5588f5b472cc331f4607e411", "html_url": "https://github.com/rust-lang/rust/commit/17619de7119ef00f5588f5b472cc331f4607e411"}], "stats": {"total": 105, "additions": 78, "deletions": 27}, "files": [{"sha": "aa5d7e9beb54f155c9b1753d1ca6283f11f0b99a", "filename": "crates/ide-db/src/search.rs", "status": "modified", "additions": 45, "deletions": 25, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/2c37e7d4afb60acbeb10808f245493e982a25651/crates%2Fide-db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c37e7d4afb60acbeb10808f245493e982a25651/crates%2Fide-db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fsearch.rs?ref=2c37e7d4afb60acbeb10808f245493e982a25651", "patch": "@@ -446,33 +446,47 @@ impl<'a> FindUsages<'a> {\n             })\n         }\n \n-        // FIXME: There should be optimization potential here\n-        // Currently we try to descend everything we find which\n-        // means we call `Semantics::descend_into_macros` on\n-        // every textual hit. That function is notoriously\n-        // expensive even for things that do not get down mapped\n-        // into macros.\n+        let find_nodes = move |name: &str, node: &syntax::SyntaxNode, offset: TextSize| {\n+            node.token_at_offset(offset).find(|it| it.text() == name).map(|token| {\n+                // FIXME: There should be optimization potential here\n+                // Currently we try to descend everything we find which\n+                // means we call `Semantics::descend_into_macros` on\n+                // every textual hit. That function is notoriously\n+                // expensive even for things that do not get down mapped\n+                // into macros.\n+                sema.descend_into_macros(token).into_iter().filter_map(|it| it.parent())\n+            })\n+        };\n+\n         for (text, file_id, search_range) in scope_files(sema, &search_scope) {\n             let tree = Lazy::new(move || sema.parse(file_id).syntax().clone());\n \n             // Search for occurrences of the items name\n             for offset in match_indices(&text, finder, search_range) {\n-                for name in sema.find_nodes_at_offset_with_descend(&tree, offset) {\n-                    if match name {\n-                        ast::NameLike::NameRef(name_ref) => self.found_name_ref(&name_ref, sink),\n-                        ast::NameLike::Name(name) => self.found_name(&name, sink),\n-                        ast::NameLike::Lifetime(lifetime) => self.found_lifetime(&lifetime, sink),\n-                    } {\n-                        return;\n+                if let Some(iter) = find_nodes(name, &tree, offset) {\n+                    for name in iter.filter_map(ast::NameLike::cast) {\n+                        if match name {\n+                            ast::NameLike::NameRef(name_ref) => {\n+                                self.found_name_ref(&name_ref, sink)\n+                            }\n+                            ast::NameLike::Name(name) => self.found_name(&name, sink),\n+                            ast::NameLike::Lifetime(lifetime) => {\n+                                self.found_lifetime(&lifetime, sink)\n+                            }\n+                        } {\n+                            return;\n+                        }\n                     }\n                 }\n             }\n             // Search for occurrences of the `Self` referring to our type\n             if let Some((self_ty, finder)) = &include_self_kw_refs {\n                 for offset in match_indices(&text, finder, search_range) {\n-                    for name_ref in sema.find_nodes_at_offset_with_descend(&tree, offset) {\n-                        if self.found_self_ty_name_ref(self_ty, &name_ref, sink) {\n-                            return;\n+                    if let Some(iter) = find_nodes(\"Self\", &tree, offset) {\n+                        for name_ref in iter.filter_map(ast::NameRef::cast) {\n+                            if self.found_self_ty_name_ref(self_ty, &name_ref, sink) {\n+                                return;\n+                            }\n                         }\n                     }\n                 }\n@@ -493,17 +507,21 @@ impl<'a> FindUsages<'a> {\n                     let tree = Lazy::new(move || sema.parse(file_id).syntax().clone());\n \n                     for offset in match_indices(&text, finder, search_range) {\n-                        for name_ref in sema.find_nodes_at_offset_with_descend(&tree, offset) {\n-                            if self.found_name_ref(&name_ref, sink) {\n-                                return;\n+                        if let Some(iter) = find_nodes(\"super\", &tree, offset) {\n+                            for name_ref in iter.filter_map(ast::NameRef::cast) {\n+                                if self.found_name_ref(&name_ref, sink) {\n+                                    return;\n+                                }\n                             }\n                         }\n                     }\n                     if let Some(finder) = &is_crate_root {\n                         for offset in match_indices(&text, finder, search_range) {\n-                            for name_ref in sema.find_nodes_at_offset_with_descend(&tree, offset) {\n-                                if self.found_name_ref(&name_ref, sink) {\n-                                    return;\n+                            if let Some(iter) = find_nodes(\"crate\", &tree, offset) {\n+                                for name_ref in iter.filter_map(ast::NameRef::cast) {\n+                                    if self.found_name_ref(&name_ref, sink) {\n+                                        return;\n+                                    }\n                                 }\n                             }\n                         }\n@@ -544,9 +562,11 @@ impl<'a> FindUsages<'a> {\n                 let finder = &Finder::new(\"self\");\n \n                 for offset in match_indices(&text, finder, search_range) {\n-                    for name_ref in sema.find_nodes_at_offset_with_descend(&tree, offset) {\n-                        if self.found_self_module_name_ref(&name_ref, sink) {\n-                            return;\n+                    if let Some(iter) = find_nodes(\"self\", &tree, offset) {\n+                        for name_ref in iter.filter_map(ast::NameRef::cast) {\n+                            if self.found_self_module_name_ref(&name_ref, sink) {\n+                                return;\n+                            }\n                         }\n                     }\n                 }"}, {"sha": "b4df0437050f4d4de0be9b6886c1b0b4d66e00b4", "filename": "crates/ide/src/rename.rs", "status": "modified", "additions": 33, "deletions": 2, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/2c37e7d4afb60acbeb10808f245493e982a25651/crates%2Fide%2Fsrc%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c37e7d4afb60acbeb10808f245493e982a25651/crates%2Fide%2Fsrc%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Frename.rs?ref=2c37e7d4afb60acbeb10808f245493e982a25651", "patch": "@@ -40,7 +40,9 @@ pub(crate) fn prepare_rename(\n             if def.range_for_rename(&sema).is_none() {\n                 bail!(\"No references found at position\")\n             }\n-            let frange = sema.original_range(name_like.syntax());\n+            let Some(frange) = sema.original_range_opt(name_like.syntax()) else {\n+                bail!(\"No references found at position\");\n+            };\n \n             always!(\n                 frange.range.contains_inclusive(position.offset)\n@@ -51,7 +53,7 @@ pub(crate) fn prepare_rename(\n         .reduce(|acc, cur| match (acc, cur) {\n             // ensure all ranges are the same\n             (Ok(acc_inner), Ok(cur_inner)) if acc_inner == cur_inner => Ok(acc_inner),\n-            (Err(e), _) => Err(e),\n+            (e @ Err(_), _) | (_, e @ Err(_)) => e,\n             _ => bail!(\"inconsistent text range\"),\n         });\n \n@@ -2249,4 +2251,33 @@ fn foo((bar | bar | bar): ()) {\n \"#,\n         );\n     }\n+\n+    #[test]\n+    fn regression_13498() {\n+        check(\n+            \"Testing\",\n+            r\"\n+mod foo {\n+    pub struct Test$0;\n+}\n+\n+use foo::Test as Tester;\n+\n+fn main() {\n+    let t = Tester;\n+}\n+\",\n+            r\"\n+mod foo {\n+    pub struct Testing;\n+}\n+\n+use foo::Testing as Tester;\n+\n+fn main() {\n+    let t = Tester;\n+}\n+\",\n+        )\n+    }\n }"}]}