{"sha": "e8ca3c6eae160310c310b15002587b1f2579d4e5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4Y2EzYzZlYWUxNjAzMTBjMzEwYjE1MDAyNTg3YjFmMjU3OWQ0ZTU=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-05-20T06:52:19Z"}, "committer": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-05-20T06:52:19Z"}, "message": "new lints len_zero and len_without_is_empty", "tree": {"sha": "3c2ce894b6171aa8df52b59b5a79d8846adf5ca4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3c2ce894b6171aa8df52b59b5a79d8846adf5ca4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e8ca3c6eae160310c310b15002587b1f2579d4e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e8ca3c6eae160310c310b15002587b1f2579d4e5", "html_url": "https://github.com/rust-lang/rust/commit/e8ca3c6eae160310c310b15002587b1f2579d4e5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e8ca3c6eae160310c310b15002587b1f2579d4e5/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5556d89f560ae2948f2bb3ce5415ba6aff6aca4f", "url": "https://api.github.com/repos/rust-lang/rust/commits/5556d89f560ae2948f2bb3ce5415ba6aff6aca4f", "html_url": "https://github.com/rust-lang/rust/commit/5556d89f560ae2948f2bb3ce5415ba6aff6aca4f"}], "stats": {"total": 163, "additions": 163, "deletions": 0}, "files": [{"sha": "e081630326fa209be8e7b530742d24b574576740", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8ca3c6eae160310c310b15002587b1f2579d4e5/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/e8ca3c6eae160310c310b15002587b1f2579d4e5/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=e8ca3c6eae160310c310b15002587b1f2579d4e5", "patch": "@@ -23,6 +23,8 @@ Lints included in this crate:\n  - `redundant_closure`: Warns on usage of eta-reducible closures like `|a| foo(a)` (which can be written as just `foo`)\n  - `identity_op`: Warns on identity operations like `x + 0` or `y / 1` (which can be reduced to `x` and `y`, respectively)\n  - `mut_mut`: Warns on `&mut &mut` which is either a copy'n'paste error, or shows a fundamental misunderstanding of references\n+ - `len_zero`: Warns on `_.len() == 0` and suggests using `_.is_empty()` (or similar comparisons with `>` or `!=`)\n+ - `len_without_is_empty`: Warns on traits or impls that have a `.len()` but no `.is_empty()` method\n \n To use, add the following lines to your Cargo.toml:\n "}, {"sha": "18ddbccc9a2f7d946d66476e3484bb788f8368b9", "filename": "src/len_zero.rs", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/e8ca3c6eae160310c310b15002587b1f2579d4e5/src%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8ca3c6eae160310c310b15002587b1f2579d4e5/src%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flen_zero.rs?ref=e8ca3c6eae160310c310b15002587b1f2579d4e5", "patch": "@@ -0,0 +1,101 @@\n+extern crate rustc_typeck as typeck;\n+\n+use syntax::ptr::P;\n+use syntax::ast::*;\n+use rustc::lint::{Context, LintPass, LintArray, Lint};\n+use rustc::middle::ty::{self, node_id_to_type, sty, ty_ptr, ty_rptr, mt, MethodTraitItemId};\n+use rustc::middle::def::{DefTy, DefStruct, DefTrait};\n+use syntax::codemap::{Span, Spanned};\n+\n+declare_lint!(pub LEN_ZERO, Warn,\n+              \"Warn on usage of double-mut refs, e.g. '&mut &mut ...'\");\n+\n+declare_lint!(pub LEN_WITHOUT_IS_EMPTY, Warn,\n+              \"Warn on traits and impls that have .len() but not .is_empty()\");\n+\n+#[derive(Copy,Clone)]\n+pub struct LenZero;\n+\n+impl LintPass for LenZero {\n+\tfn get_lints(&self) -> LintArray {\n+        lint_array!(LEN_ZERO, LEN_WITHOUT_IS_EMPTY)\n+\t}\n+\t\n+\tfn check_item(&mut self, cx: &Context, item: &Item) {\n+\t\tmatch &item.node {\n+\t\t\t&ItemTrait(_, _, _, ref trait_items) => \n+\t\t\t\tcheck_trait_items(cx, item, trait_items),\n+\t\t\t&ItemImpl(_, _, _, None, _, ref impl_items) => // only non-trait\n+\t\t\t\tcheck_impl_items(cx, item, impl_items),\n+\t\t\t_ => ()\n+\t\t}\n+\t}\n+\t\n+\tfn check_expr(&mut self, cx: &Context, expr: &Expr) {\n+\t\tif let &ExprBinary(Spanned{node: cmp, ..}, ref left, ref right) = \n+\t\t\t\t&expr.node {\n+\t\t\tmatch cmp {\n+\t\t\t\tBiEq => check_cmp(cx, expr.span, left, right, \"\"),\n+\t\t\t\tBiGt | BiNe => check_cmp(cx, expr.span, left, right, \"!\"),\n+\t\t\t\t_ => ()\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+fn check_trait_items(cx: &Context, item: &Item, trait_items: &[P<TraitItem>]) {\n+\tfn is_named_self(item: &TraitItem, name: &str) -> bool {\n+\t\titem.ident.as_str() == name && item.attrs.len() == 0\n+\t}\n+\n+\tif !trait_items.iter().any(|i| is_named_self(i, \"is_empty\")) {\n+\t\t//cx.span_lint(LEN_WITHOUT_IS_EMPTY, item.span, &format!(\"trait {}\", item.ident.as_str()));\n+\t\tfor i in trait_items {\n+\t\t\tif is_named_self(i, \"len\") {\n+\t\t\t\tcx.span_lint(LEN_WITHOUT_IS_EMPTY, i.span,\n+\t\t\t\t\t&format!(\"Trait '{}' has a '.len()' method, but no \\\n+\t\t\t\t\t\t'.is_empty()' method. Consider adding one.\", \n+\t\t\t\t\t\titem.ident.as_str()));\n+\t\t\t}\n+\t\t};\n+\t}\n+}\n+\n+fn check_impl_items(cx: &Context, item: &Item, impl_items: &[P<ImplItem>]) {\n+\tfn is_named_self(item: &ImplItem, name: &str) -> bool {\n+\t\titem.ident.as_str() == name && item.attrs.len() == 0\n+\t}\n+\n+\tif !impl_items.iter().any(|i| is_named_self(i, \"is_empty\")) {\n+\t\tfor i in impl_items {\n+\t\t\tif is_named_self(i, \"len\") {\n+\t\t\t\tcx.span_lint(LEN_WITHOUT_IS_EMPTY, i.span,\n+\t\t\t\t\t&format!(\"Item '{}' has a '.len()' method, but no \\\n+\t\t\t\t\t\t'.is_empty()' method. Consider adding one.\", \n+\t\t\t\t\t\titem.ident.as_str()));\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+fn check_cmp(cx: &Context, span: Span, left: &Expr, right: &Expr, empty: &str) {\n+\tmatch (&left.node, &right.node) {\n+\t\t(&ExprLit(ref lit), &ExprMethodCall(ref method, _, ref args)) => \n+\t\t\tcheck_len_zero(cx, span, method, args, lit, empty),\n+\t\t(&ExprMethodCall(ref method, _, ref args), &ExprLit(ref lit)) => \n+\t\t\tcheck_len_zero(cx, span, method, args, lit, empty),\n+\t\t_ => ()\n+\t}\n+}\n+\n+fn check_len_zero(cx: &Context, span: Span, method: &SpannedIdent, \n+\t\targs: &[P<Expr>], lit: &Lit, empty: &str) {\n+\tif let &Spanned{node: LitInt(0, _), ..} = lit {\n+\t\tif method.node.as_str() == \"len\" && args.len() == 1 {\n+\t\t\tcx.span_lint(LEN_ZERO, span, &format!(\n+\t\t\t\t\"Consider replacing the len comparison with '{}_.is_empty()' if available\",\n+\t\t\t\t\tempty))\n+\t\t}\n+\t}\n+}"}, {"sha": "e22ee28e77e27818962c8c046a72b1a8aa6f4c86", "filename": "src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e8ca3c6eae160310c310b15002587b1f2579d4e5/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8ca3c6eae160310c310b15002587b1f2579d4e5/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=e8ca3c6eae160310c310b15002587b1f2579d4e5", "patch": "@@ -24,6 +24,7 @@ pub mod approx_const;\n pub mod eta_reduction;\n pub mod identity_op;\n pub mod mut_mut;\n+pub mod len_zero;\n \n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n@@ -42,6 +43,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_lint_pass(box eta_reduction::EtaPass as LintPassObject);\n     reg.register_lint_pass(box identity_op::IdentityOp as LintPassObject);\n     reg.register_lint_pass(box mut_mut::MutMut as LintPassObject);\n+    reg.register_lint_pass(box len_zero::LenZero as LintPassObject);\n     \n     reg.register_lint_group(\"clippy\", vec![types::BOX_VEC, types::LINKEDLIST,\n                                            misc::SINGLE_MATCH, misc::STR_TO_STRING,\n@@ -56,5 +58,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n                                            eta_reduction::REDUNDANT_CLOSURE,\n                                            identity_op::IDENTITY_OP,\n                                            mut_mut::MUT_MUT,\n+                                           len_zero::LEN_ZERO,\n+                                           len_zero::LEN_WITHOUT_IS_EMPTY,\n                                            ]);\n }"}, {"sha": "7b1aafd409d59856fcd1f821c7a4a944e927dd1d", "filename": "tests/compile-fail/len_zero.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/e8ca3c6eae160310c310b15002587b1f2579d4e5/tests%2Fcompile-fail%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8ca3c6eae160310c310b15002587b1f2579d4e5/tests%2Fcompile-fail%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Flen_zero.rs?ref=e8ca3c6eae160310c310b15002587b1f2579d4e5", "patch": "@@ -0,0 +1,56 @@\n+#![feature(plugin)]\n+#![plugin(clippy)]\n+\n+struct One;\n+\n+#[deny(len_without_is_empty)]\n+impl One {\n+\tfn len(self: &Self) -> isize { //~ERROR\n+\t\t1\n+\t}\n+}\n+\n+#[deny(len_without_is_empty)]\n+trait TraitsToo {\n+\tfn len(self: &Self) -> isize; //~ERROR\n+}\n+\n+impl TraitsToo for One {\n+\tfn len(self: &Self) -> isize {\n+\t\t0\n+\t}\n+}\n+\n+#[allow(dead_code)]\n+struct HasIsEmpty;\n+\n+#[deny(len_without_is_empty)]\n+#[allow(dead_code)]\n+impl HasIsEmpty {\n+\tfn len(self: &Self) -> isize {\n+\t\t1\n+\t}\n+\t\n+\tfn is_empty() -> bool {\n+\t\tfalse\n+\t}\n+}\n+\n+#[deny(len_zero)]\n+fn main() {\n+\tlet x = [1, 2];\n+\tif x.len() == 0 { //~ERROR\n+\t\tprintln!(\"This should not happen!\");\n+\t}\n+\t\n+\tlet y = One;\n+\t// false positives here\n+\tif y.len()  == 0 { //~ERROR\n+\t\tprintln!(\"This should not happen either!\");\n+\t}\n+\t\n+\tlet z : &TraitsToo = &y;\n+\tif z.len() > 0 { //~ERROR\n+\t\tprintln!(\"Nor should this!\");\n+\t}\n+}"}]}