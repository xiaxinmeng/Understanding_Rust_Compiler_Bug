{"sha": "2cf736f76563f054aecd84207b39114c6fceb8ed", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjZjczNmY3NjU2M2YwNTRhZWNkODQyMDdiMzkxMTRjNmZjZWI4ZWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-13T17:08:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-13T17:08:24Z"}, "message": "Auto merge of #57577 - Centril:rollup, r=Centril\n\nRollup of 4 pull requests\n\nSuccessful merges:\n\n - #57004 (Make `TokenStream` less recursive.)\n - #57102 (NLL: Add union justifications to conflicting borrows.)\n - #57337 (rustc: Place wasm linker args first instead of last)\n - #57549 (Add #[must_use] message to Iterator and Future)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "3700724bbe6c6438f2aef5999ed54084c9c17018", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3700724bbe6c6438f2aef5999ed54084c9c17018"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2cf736f76563f054aecd84207b39114c6fceb8ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2cf736f76563f054aecd84207b39114c6fceb8ed", "html_url": "https://github.com/rust-lang/rust/commit/2cf736f76563f054aecd84207b39114c6fceb8ed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2cf736f76563f054aecd84207b39114c6fceb8ed/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c561d9b55aabc7df484f8faba24430421aee998", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c561d9b55aabc7df484f8faba24430421aee998", "html_url": "https://github.com/rust-lang/rust/commit/1c561d9b55aabc7df484f8faba24430421aee998"}, {"sha": "e2311b31c64e56c3d3218f6101c22ffe573bb687", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2311b31c64e56c3d3218f6101c22ffe573bb687", "html_url": "https://github.com/rust-lang/rust/commit/e2311b31c64e56c3d3218f6101c22ffe573bb687"}], "stats": {"total": 1180, "additions": 601, "deletions": 579}, "files": [{"sha": "539b07fc21eea4ec8031e0347d7f56cc4b8eea00", "filename": "src/libcore/future/future.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2cf736f76563f054aecd84207b39114c6fceb8ed/src%2Flibcore%2Ffuture%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf736f76563f054aecd84207b39114c6fceb8ed/src%2Flibcore%2Ffuture%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Ffuture.rs?ref=2cf736f76563f054aecd84207b39114c6fceb8ed", "patch": "@@ -23,7 +23,7 @@ use task::{Poll, LocalWaker};\n ///\n /// When using a future, you generally won't call `poll` directly, but instead\n /// `await!` the value.\n-#[must_use]\n+#[must_use = \"futures do nothing unless polled\"]\n pub trait Future {\n     /// The result of the `Future`.\n     type Output;"}, {"sha": "640af748172826294af275cdf165539557b34508", "filename": "src/libcore/iter/iterator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2cf736f76563f054aecd84207b39114c6fceb8ed/src%2Flibcore%2Fiter%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf736f76563f054aecd84207b39114c6fceb8ed/src%2Flibcore%2Fiter%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fiterator.rs?ref=2cf736f76563f054aecd84207b39114c6fceb8ed", "patch": "@@ -88,7 +88,7 @@ fn _assert_is_object_safe(_: &dyn Iterator<Item=()>) {}\n     message=\"`{Self}` is not an iterator\"\n )]\n #[doc(spotlight)]\n-#[must_use]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n pub trait Iterator {\n     /// The type of the elements being iterated over.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "1ef5428a789cf9cbbd3df9b50e5c64927306bb07", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/2cf736f76563f054aecd84207b39114c6fceb8ed/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf736f76563f054aecd84207b39114c6fceb8ed/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=2cf736f76563f054aecd84207b39114c6fceb8ed", "patch": "@@ -243,7 +243,7 @@\n //! using it. The compiler will warn us about this kind of behavior:\n //!\n //! ```text\n-//! warning: unused result that must be used: iterator adaptors are lazy and\n+//! warning: unused result that must be used: iterators are lazy and\n //! do nothing unless consumed\n //! ```\n //!\n@@ -404,7 +404,7 @@ impl<R: Try> LoopState<R::Ok, R> {\n /// [`rev`]: trait.Iterator.html#method.rev\n /// [`Iterator`]: trait.Iterator.html\n #[derive(Clone, Debug)]\n-#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Rev<T> {\n     iter: T\n@@ -505,7 +505,7 @@ unsafe impl<I> TrustedLen for Rev<I>\n /// [`copied`]: trait.Iterator.html#method.copied\n /// [`Iterator`]: trait.Iterator.html\n #[unstable(feature = \"iter_copied\", issue = \"57127\")]\n-#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[derive(Clone, Debug)]\n pub struct Copied<I> {\n     it: I,\n@@ -605,7 +605,7 @@ unsafe impl<'a, I, T: 'a> TrustedLen for Copied<I>\n /// [`cloned`]: trait.Iterator.html#method.cloned\n /// [`Iterator`]: trait.Iterator.html\n #[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n-#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[derive(Clone, Debug)]\n pub struct Cloned<I> {\n     it: I,\n@@ -717,7 +717,7 @@ unsafe impl<'a, I, T: 'a> TrustedLen for Cloned<I>\n /// [`cycle`]: trait.Iterator.html#method.cycle\n /// [`Iterator`]: trait.Iterator.html\n #[derive(Clone, Debug)]\n-#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Cycle<I> {\n     orig: I,\n@@ -757,7 +757,7 @@ impl<I> FusedIterator for Cycle<I> where I: Clone + Iterator {}\n ///\n /// [`step_by`]: trait.Iterator.html#method.step_by\n /// [`Iterator`]: trait.Iterator.html\n-#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"iterator_step_by\", since = \"1.28.0\")]\n #[derive(Clone, Debug)]\n pub struct StepBy<I> {\n@@ -849,7 +849,7 @@ impl<I> ExactSizeIterator for StepBy<I> where I: ExactSizeIterator {}\n /// [`chain`]: trait.Iterator.html#method.chain\n /// [`Iterator`]: trait.Iterator.html\n #[derive(Clone, Debug)]\n-#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Chain<A, B> {\n     a: A,\n@@ -1100,7 +1100,7 @@ unsafe impl<A, B> TrustedLen for Chain<A, B>\n /// [`zip`]: trait.Iterator.html#method.zip\n /// [`Iterator`]: trait.Iterator.html\n #[derive(Clone, Debug)]\n-#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Zip<A, B> {\n     a: A,\n@@ -1400,7 +1400,7 @@ unsafe impl<A, B> TrustedLen for Zip<A, B>\n ///     println!(\"{:?}\", pair);\n /// }\n /// ```\n-#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Clone)]\n pub struct Map<I, F> {\n@@ -1511,7 +1511,7 @@ unsafe impl<B, I, F> TrustedRandomAccess for Map<I, F>\n ///\n /// [`filter`]: trait.Iterator.html#method.filter\n /// [`Iterator`]: trait.Iterator.html\n-#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Clone)]\n pub struct Filter<I, P> {\n@@ -1643,7 +1643,7 @@ impl<I: FusedIterator, P> FusedIterator for Filter<I, P>\n ///\n /// [`filter_map`]: trait.Iterator.html#method.filter_map\n /// [`Iterator`]: trait.Iterator.html\n-#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Clone)]\n pub struct FilterMap<I, F> {\n@@ -1754,7 +1754,7 @@ impl<B, I: FusedIterator, F> FusedIterator for FilterMap<I, F>\n /// [`enumerate`]: trait.Iterator.html#method.enumerate\n /// [`Iterator`]: trait.Iterator.html\n #[derive(Clone, Debug)]\n-#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Enumerate<I> {\n     iter: I,\n@@ -1915,7 +1915,7 @@ unsafe impl<I> TrustedLen for Enumerate<I>\n /// [`peekable`]: trait.Iterator.html#method.peekable\n /// [`Iterator`]: trait.Iterator.html\n #[derive(Clone, Debug)]\n-#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Peekable<I: Iterator> {\n     iter: I,\n@@ -2066,7 +2066,7 @@ impl<I: Iterator> Peekable<I> {\n ///\n /// [`skip_while`]: trait.Iterator.html#method.skip_while\n /// [`Iterator`]: trait.Iterator.html\n-#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Clone)]\n pub struct SkipWhile<I, P> {\n@@ -2149,7 +2149,7 @@ impl<I, P> FusedIterator for SkipWhile<I, P>\n ///\n /// [`take_while`]: trait.Iterator.html#method.take_while\n /// [`Iterator`]: trait.Iterator.html\n-#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Clone)]\n pub struct TakeWhile<I, P> {\n@@ -2233,7 +2233,7 @@ impl<I, P> FusedIterator for TakeWhile<I, P>\n /// [`skip`]: trait.Iterator.html#method.skip\n /// [`Iterator`]: trait.Iterator.html\n #[derive(Clone, Debug)]\n-#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Skip<I> {\n     iter: I,\n@@ -2371,7 +2371,7 @@ impl<I> FusedIterator for Skip<I> where I: FusedIterator {}\n /// [`take`]: trait.Iterator.html#method.take\n /// [`Iterator`]: trait.Iterator.html\n #[derive(Clone, Debug)]\n-#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Take<I> {\n     iter: I,\n@@ -2458,7 +2458,7 @@ unsafe impl<I: TrustedLen> TrustedLen for Take<I> {}\n ///\n /// [`scan`]: trait.Iterator.html#method.scan\n /// [`Iterator`]: trait.Iterator.html\n-#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Clone)]\n pub struct Scan<I, St, F> {\n@@ -2518,7 +2518,7 @@ impl<B, I, St, F> Iterator for Scan<I, St, F> where\n ///\n /// [`flat_map`]: trait.Iterator.html#method.flat_map\n /// [`Iterator`]: trait.Iterator.html\n-#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct FlatMap<I, U: IntoIterator, F> {\n     inner: FlattenCompat<Map<I, F>, <U as IntoIterator>::IntoIter>\n@@ -2603,7 +2603,7 @@ impl<I, U, F> FusedIterator for FlatMap<I, U, F>\n ///\n /// [`flatten`]: trait.Iterator.html#method.flatten\n /// [`Iterator`]: trait.Iterator.html\n-#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n pub struct Flatten<I: Iterator>\n where I::Item: IntoIterator {\n@@ -2832,7 +2832,7 @@ impl<I, U> DoubleEndedIterator for FlattenCompat<I, U>\n /// [`fuse`]: trait.Iterator.html#method.fuse\n /// [`Iterator`]: trait.Iterator.html\n #[derive(Clone, Debug)]\n-#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Fuse<I> {\n     iter: I,\n@@ -3056,7 +3056,7 @@ impl<I> ExactSizeIterator for Fuse<I> where I: ExactSizeIterator {\n ///\n /// [`inspect`]: trait.Iterator.html#method.inspect\n /// [`Iterator`]: trait.Iterator.html\n-#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Clone)]\n pub struct Inspect<I, F> {"}, {"sha": "cafb29ed99a416b886d7289db2f70200b3c636cc", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2cf736f76563f054aecd84207b39114c6fceb8ed/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf736f76563f054aecd84207b39114c6fceb8ed/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=2cf736f76563f054aecd84207b39114c6fceb8ed", "patch": "@@ -557,12 +557,8 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                 if new_loan.loan_path.has_fork(&old_loan.loan_path) && common.is_some() {\n                     let nl = self.bccx.loan_path_to_string(&common.unwrap());\n                     let ol = nl.clone();\n-                    let new_loan_msg = format!(\" (via `{}`)\",\n-                                               self.bccx.loan_path_to_string(\n-                                                   &new_loan.loan_path));\n-                    let old_loan_msg = format!(\" (via `{}`)\",\n-                                               self.bccx.loan_path_to_string(\n-                                                   &old_loan.loan_path));\n+                    let new_loan_msg = self.bccx.loan_path_to_string(&new_loan.loan_path);\n+                    let old_loan_msg = self.bccx.loan_path_to_string(&old_loan.loan_path);\n                     (nl, ol, new_loan_msg, old_loan_msg)\n                 } else {\n                     (self.bccx.loan_path_to_string(&new_loan.loan_path),"}, {"sha": "06d4f940436da82fd0e545cc950815461782dc12", "filename": "src/librustc_codegen_ssa/back/linker.rs", "status": "modified", "additions": 62, "deletions": 60, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/2cf736f76563f054aecd84207b39114c6fceb8ed/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf736f76563f054aecd84207b39114c6fceb8ed/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs?ref=2cf736f76563f054aecd84207b39114c6fceb8ed", "patch": "@@ -81,11 +81,7 @@ impl LinkerInfo {\n             }\n \n             LinkerFlavor::Lld(LldFlavor::Wasm) => {\n-                Box::new(WasmLd {\n-                    cmd,\n-                    sess,\n-                    info: self\n-                }) as Box<dyn Linker>\n+                Box::new(WasmLd::new(cmd, sess, self)) as Box<dyn Linker>\n             }\n         }\n     }\n@@ -876,6 +872,67 @@ pub struct WasmLd<'a> {\n     info: &'a LinkerInfo,\n }\n \n+impl<'a> WasmLd<'a> {\n+    fn new(mut cmd: Command, sess: &'a Session, info: &'a LinkerInfo) -> WasmLd<'a> {\n+        // There have been reports in the wild (rustwasm/wasm-bindgen#119) of\n+        // using threads causing weird hangs and bugs. Disable it entirely as\n+        // this isn't yet the bottleneck of compilation at all anyway.\n+        cmd.arg(\"--no-threads\");\n+\n+        // By default LLD only gives us one page of stack (64k) which is a\n+        // little small. Default to a larger stack closer to other PC platforms\n+        // (1MB) and users can always inject their own link-args to override this.\n+        cmd.arg(\"-z\").arg(\"stack-size=1048576\");\n+\n+        // By default LLD's memory layout is:\n+        //\n+        // 1. First, a blank page\n+        // 2. Next, all static data\n+        // 3. Finally, the main stack (which grows down)\n+        //\n+        // This has the unfortunate consequence that on stack overflows you\n+        // corrupt static data and can cause some exceedingly weird bugs. To\n+        // help detect this a little sooner we instead request that the stack is\n+        // placed before static data.\n+        //\n+        // This means that we'll generate slightly larger binaries as references\n+        // to static data will take more bytes in the ULEB128 encoding, but\n+        // stack overflow will be guaranteed to trap as it underflows instead of\n+        // corrupting static data.\n+        cmd.arg(\"--stack-first\");\n+\n+        // FIXME we probably shouldn't pass this but instead pass an explicit\n+        // whitelist of symbols we'll allow to be undefined. Unfortunately\n+        // though we can't handle symbols like `log10` that LLVM injects at a\n+        // super late date without actually parsing object files. For now let's\n+        // stick to this and hopefully fix it before stabilization happens.\n+        cmd.arg(\"--allow-undefined\");\n+\n+        // For now we just never have an entry symbol\n+        cmd.arg(\"--no-entry\");\n+\n+        // Make the default table accessible\n+        cmd.arg(\"--export-table\");\n+\n+        // Rust code should never have warnings, and warnings are often\n+        // indicative of bugs, let's prevent them.\n+        cmd.arg(\"--fatal-warnings\");\n+\n+        // The symbol visibility story is a bit in flux right now with LLD.\n+        // It's... not entirely clear to me what's going on, but this looks to\n+        // make everything work when `export_symbols` isn't otherwise called for\n+        // things like executables.\n+        cmd.arg(\"--export-dynamic\");\n+\n+        // LLD only implements C++-like demangling, which doesn't match our own\n+        // mangling scheme. Tell LLD to not demangle anything and leave it up to\n+        // us to demangle these symbols later.\n+        cmd.arg(\"--no-demangle\");\n+\n+        WasmLd { cmd, sess, info }\n+    }\n+}\n+\n impl<'a> Linker for WasmLd<'a> {\n     fn link_dylib(&mut self, lib: &str) {\n         self.cmd.arg(\"-l\").arg(lib);\n@@ -982,61 +1039,6 @@ impl<'a> Linker for WasmLd<'a> {\n     }\n \n     fn finalize(&mut self) -> Command {\n-        // There have been reports in the wild (rustwasm/wasm-bindgen#119) of\n-        // using threads causing weird hangs and bugs. Disable it entirely as\n-        // this isn't yet the bottleneck of compilation at all anyway.\n-        self.cmd.arg(\"--no-threads\");\n-\n-        // By default LLD only gives us one page of stack (64k) which is a\n-        // little small. Default to a larger stack closer to other PC platforms\n-        // (1MB) and users can always inject their own link-args to override this.\n-        self.cmd.arg(\"-z\").arg(\"stack-size=1048576\");\n-\n-        // By default LLD's memory layout is:\n-        //\n-        // 1. First, a blank page\n-        // 2. Next, all static data\n-        // 3. Finally, the main stack (which grows down)\n-        //\n-        // This has the unfortunate consequence that on stack overflows you\n-        // corrupt static data and can cause some exceedingly weird bugs. To\n-        // help detect this a little sooner we instead request that the stack is\n-        // placed before static data.\n-        //\n-        // This means that we'll generate slightly larger binaries as references\n-        // to static data will take more bytes in the ULEB128 encoding, but\n-        // stack overflow will be guaranteed to trap as it underflows instead of\n-        // corrupting static data.\n-        self.cmd.arg(\"--stack-first\");\n-\n-        // FIXME we probably shouldn't pass this but instead pass an explicit\n-        // whitelist of symbols we'll allow to be undefined. Unfortunately\n-        // though we can't handle symbols like `log10` that LLVM injects at a\n-        // super late date without actually parsing object files. For now let's\n-        // stick to this and hopefully fix it before stabilization happens.\n-        self.cmd.arg(\"--allow-undefined\");\n-\n-        // For now we just never have an entry symbol\n-        self.cmd.arg(\"--no-entry\");\n-\n-        // Make the default table accessible\n-        self.cmd.arg(\"--export-table\");\n-\n-        // Rust code should never have warnings, and warnings are often\n-        // indicative of bugs, let's prevent them.\n-        self.cmd.arg(\"--fatal-warnings\");\n-\n-        // The symbol visibility story is a bit in flux right now with LLD.\n-        // It's... not entirely clear to me what's going on, but this looks to\n-        // make everything work when `export_symbols` isn't otherwise called for\n-        // things like executables.\n-        self.cmd.arg(\"--export-dynamic\");\n-\n-        // LLD only implements C++-like demangling, which doesn't match our own\n-        // mangling scheme. Tell LLD to not demangle anything and leave it up to\n-        // us to demangle these symbols later.\n-        self.cmd.arg(\"--no-demangle\");\n-\n         ::std::mem::replace(&mut self.cmd, Command::new(\"\"))\n     }\n "}, {"sha": "233db12b03001967b728223f2759258cf51d80c9", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 116, "deletions": 10, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/2cf736f76563f054aecd84207b39114c6fceb8ed/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf736f76563f054aecd84207b39114c6fceb8ed/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=2cf736f76563f054aecd84207b39114c6fceb8ed", "patch": "@@ -327,10 +327,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             \"closure\"\n         };\n \n-        let desc_place = self.describe_place(place).unwrap_or_else(|| \"_\".to_owned());\n-        let tcx = self.infcx.tcx;\n-\n-        let first_borrow_desc;\n+        let (desc_place, msg_place, msg_borrow, union_type_name) =\n+            self.describe_place_for_conflicting_borrow(place, &issued_borrow.borrowed_place);\n \n         let explanation = self.explain_why_borrow_contains_point(context, issued_borrow, None);\n         let second_borrow_desc = if explanation.is_explained() {\n@@ -340,6 +338,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         };\n \n         // FIXME: supply non-\"\" `opt_via` when appropriate\n+        let tcx = self.infcx.tcx;\n+        let first_borrow_desc;\n         let mut err = match (\n             gen_borrow_kind,\n             \"immutable\",\n@@ -353,12 +353,12 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 tcx.cannot_reborrow_already_borrowed(\n                     span,\n                     &desc_place,\n-                    \"\",\n+                    &msg_place,\n                     lft,\n                     issued_span,\n                     \"it\",\n                     rgt,\n-                    \"\",\n+                    &msg_borrow,\n                     None,\n                     Origin::Mir,\n                 )\n@@ -368,12 +368,12 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 tcx.cannot_reborrow_already_borrowed(\n                     span,\n                     &desc_place,\n-                    \"\",\n+                    &msg_place,\n                     lft,\n                     issued_span,\n                     \"it\",\n                     rgt,\n-                    \"\",\n+                    &msg_borrow,\n                     None,\n                     Origin::Mir,\n                 )\n@@ -384,9 +384,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 tcx.cannot_mutably_borrow_multiply(\n                     span,\n                     &desc_place,\n-                    \"\",\n+                    &msg_place,\n                     issued_span,\n-                    \"\",\n+                    &msg_borrow,\n                     None,\n                     Origin::Mir,\n                 )\n@@ -510,12 +510,118 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             );\n         }\n \n+        if union_type_name != \"\" {\n+            err.note(&format!(\n+                \"`{}` is a field of the union `{}`, so it overlaps the field `{}`\",\n+                msg_place, union_type_name, msg_borrow,\n+            ));\n+        }\n+\n         explanation\n             .add_explanation_to_diagnostic(self.infcx.tcx, self.mir, &mut err, first_borrow_desc);\n \n         err.buffer(&mut self.errors_buffer);\n     }\n \n+    /// Returns the description of the root place for a conflicting borrow and the full\n+    /// descriptions of the places that caused the conflict.\n+    ///\n+    /// In the simplest case, where there are no unions involved, if a mutable borrow of `x` is\n+    /// attempted while a shared borrow is live, then this function will return:\n+    ///\n+    ///     (\"x\", \"\", \"\")\n+    ///\n+    /// In the simple union case, if a mutable borrow of a union field `x.z` is attempted while\n+    /// a shared borrow of another field `x.y`, then this function will return:\n+    ///\n+    ///     (\"x\", \"x.z\", \"x.y\")\n+    ///\n+    /// In the more complex union case, where the union is a field of a struct, then if a mutable\n+    /// borrow of a union field in a struct `x.u.z` is attempted while a shared borrow of\n+    /// another field `x.u.y`, then this function will return:\n+    ///\n+    ///     (\"x.u\", \"x.u.z\", \"x.u.y\")\n+    ///\n+    /// This is used when creating error messages like below:\n+    ///\n+    /// >  cannot borrow `a.u` (via `a.u.z.c`) as immutable because it is also borrowed as\n+    /// >  mutable (via `a.u.s.b`) [E0502]\n+    pub(super) fn describe_place_for_conflicting_borrow(\n+        &self,\n+        first_borrowed_place: &Place<'tcx>,\n+        second_borrowed_place: &Place<'tcx>,\n+    ) -> (String, String, String, String) {\n+        // Define a small closure that we can use to check if the type of a place\n+        // is a union.\n+        let is_union = |place: &Place<'tcx>| -> bool {\n+            place.ty(self.mir, self.infcx.tcx)\n+                .to_ty(self.infcx.tcx)\n+                .ty_adt_def()\n+                .map(|adt| adt.is_union())\n+                .unwrap_or(false)\n+        };\n+\n+        // Start with an empty tuple, so we can use the functions on `Option` to reduce some\n+        // code duplication (particularly around returning an empty description in the failure\n+        // case).\n+        Some(())\n+            .filter(|_| {\n+                // If we have a conflicting borrow of the same place, then we don't want to add\n+                // an extraneous \"via x.y\" to our diagnostics, so filter out this case.\n+                first_borrowed_place != second_borrowed_place\n+            })\n+            .and_then(|_| {\n+                // We're going to want to traverse the first borrowed place to see if we can find\n+                // field access to a union. If we find that, then we will keep the place of the\n+                // union being accessed and the field that was being accessed so we can check the\n+                // second borrowed place for the same union and a access to a different field.\n+                let mut current = first_borrowed_place;\n+                while let Place::Projection(box PlaceProjection { base, elem }) = current {\n+                    match elem {\n+                        ProjectionElem::Field(field, _) if is_union(base) => {\n+                            return Some((base, field));\n+                        },\n+                        _ => current = base,\n+                    }\n+                }\n+                None\n+            })\n+            .and_then(|(target_base, target_field)| {\n+                // With the place of a union and a field access into it, we traverse the second\n+                // borrowed place and look for a access to a different field of the same union.\n+                let mut current = second_borrowed_place;\n+                while let Place::Projection(box PlaceProjection { base, elem }) = current {\n+                    match elem {\n+                        ProjectionElem::Field(field, _) if {\n+                            is_union(base) && field != target_field && base == target_base\n+                        } => {\n+                            let desc_base = self.describe_place(base)\n+                                .unwrap_or_else(|| \"_\".to_owned());\n+                            let desc_first = self.describe_place(first_borrowed_place)\n+                                .unwrap_or_else(|| \"_\".to_owned());\n+                            let desc_second = self.describe_place(second_borrowed_place)\n+                                .unwrap_or_else(|| \"_\".to_owned());\n+\n+                            // Also compute the name of the union type, eg. `Foo` so we\n+                            // can add a helpful note with it.\n+                            let ty = base.ty(self.mir, self.infcx.tcx).to_ty(self.infcx.tcx);\n+\n+                            return Some((desc_base, desc_first, desc_second, ty.to_string()));\n+                        },\n+                        _ => current = base,\n+                    }\n+                }\n+                None\n+            })\n+            .unwrap_or_else(|| {\n+                // If we didn't find a field access into a union, or both places match, then\n+                // only return the description of the first place.\n+                let desc_place = self.describe_place(first_borrowed_place)\n+                    .unwrap_or_else(|| \"_\".to_owned());\n+                (desc_place, \"\".to_string(), \"\".to_string(), \"\".to_string())\n+            })\n+    }\n+\n     /// Reports StorageDeadOrDrop of `place` conflicts with `borrow`.\n     ///\n     /// This means that some data referenced by `borrow` needs to live"}, {"sha": "7ad73aaa3f9a958a7ff81a51d86d1d4ca5cf0d01", "filename": "src/librustc_mir/util/borrowck_errors.rs", "status": "modified", "additions": 32, "deletions": 11, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/2cf736f76563f054aecd84207b39114c6fceb8ed/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf736f76563f054aecd84207b39114c6fceb8ed/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs?ref=2cf736f76563f054aecd84207b39114c6fceb8ed", "patch": "@@ -138,13 +138,15 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n         old_load_end_span: Option<Span>,\n         o: Origin,\n     ) -> DiagnosticBuilder<'cx> {\n+        let via = |msg: &str|\n+            if msg.is_empty() { msg.to_string() } else { format!(\" (via `{}`)\", msg) };\n         let mut err = struct_span_err!(\n             self,\n             new_loan_span,\n             E0499,\n             \"cannot borrow `{}`{} as mutable more than once at a time{OGN}\",\n             desc,\n-            opt_via,\n+            via(opt_via),\n             OGN = o\n         );\n         if old_loan_span == new_loan_span {\n@@ -164,11 +166,11 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n         } else {\n             err.span_label(\n                 old_loan_span,\n-                format!(\"first mutable borrow occurs here{}\", old_opt_via),\n+                format!(\"first mutable borrow occurs here{}\", via(old_opt_via)),\n             );\n             err.span_label(\n                 new_loan_span,\n-                format!(\"second mutable borrow occurs here{}\", opt_via),\n+                format!(\"second mutable borrow occurs here{}\", via(opt_via)),\n             );\n             if let Some(old_load_end_span) = old_load_end_span {\n                 err.span_label(old_load_end_span, \"first borrow ends here\");\n@@ -292,27 +294,46 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n         old_load_end_span: Option<Span>,\n         o: Origin,\n     ) -> DiagnosticBuilder<'cx> {\n+        let via = |msg: &str|\n+            if msg.is_empty() { msg.to_string() } else { format!(\" (via `{}`)\", msg) };\n         let mut err = struct_span_err!(\n             self,\n             span,\n             E0502,\n-            \"cannot borrow `{}`{} as {} because {} is also borrowed as {}{}{OGN}\",\n+            \"cannot borrow `{}`{} as {} because {} is also borrowed \\\n+             as {}{}{OGN}\",\n             desc_new,\n-            msg_new,\n+            via(msg_new),\n             kind_new,\n             noun_old,\n             kind_old,\n-            msg_old,\n+            via(msg_old),\n             OGN = o\n         );\n-        err.span_label(span, format!(\"{} borrow occurs here{}\", kind_new, msg_new));\n-        err.span_label(\n-            old_span,\n-            format!(\"{} borrow occurs here{}\", kind_old, msg_old),\n-        );\n+\n+        if msg_new == \"\" {\n+            // If `msg_new` is empty, then this isn't a borrow of a union field.\n+            err.span_label(span, format!(\"{} borrow occurs here\", kind_new));\n+            err.span_label(old_span, format!(\"{} borrow occurs here\", kind_old));\n+        } else {\n+            // If `msg_new` isn't empty, then this a borrow of a union field.\n+            err.span_label(\n+                span,\n+                format!(\n+                    \"{} borrow of `{}` -- which overlaps with `{}` -- occurs here\",\n+                    kind_new, msg_new, msg_old,\n+                )\n+            );\n+            err.span_label(\n+                old_span,\n+                format!(\"{} borrow occurs here{}\", kind_old, via(msg_old)),\n+            );\n+        }\n+\n         if let Some(old_load_end_span) = old_load_end_span {\n             err.span_label(old_load_end_span, format!(\"{} borrow ends here\", kind_old));\n         }\n+\n         self.cancel_if_wrong_origin(err, o)\n     }\n "}, {"sha": "d03563f8891aa56982862e1dda9ce45344a9f96d", "filename": "src/libsyntax/attr/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2cf736f76563f054aecd84207b39114c6fceb8ed/src%2Flibsyntax%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf736f76563f054aecd84207b39114c6fceb8ed/src%2Flibsyntax%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fmod.rs?ref=2cf736f76563f054aecd84207b39114c6fceb8ed", "patch": "@@ -472,7 +472,7 @@ impl MetaItem {\n                                          Token::from_ast_ident(segment.ident)).into());\n             last_pos = segment.ident.span.hi();\n         }\n-        idents.push(self.node.tokens(self.span));\n+        self.node.tokens(self.span).append_to_tree_and_joint_vec(&mut idents);\n         TokenStream::new(idents)\n     }\n \n@@ -529,15 +529,17 @@ impl MetaItemKind {\n         match *self {\n             MetaItemKind::Word => TokenStream::empty(),\n             MetaItemKind::NameValue(ref lit) => {\n-                TokenStream::new(vec![TokenTree::Token(span, Token::Eq).into(), lit.tokens()])\n+                let mut vec = vec![TokenTree::Token(span, Token::Eq).into()];\n+                lit.tokens().append_to_tree_and_joint_vec(&mut vec);\n+                TokenStream::new(vec)\n             }\n             MetaItemKind::List(ref list) => {\n                 let mut tokens = Vec::new();\n                 for (i, item) in list.iter().enumerate() {\n                     if i > 0 {\n                         tokens.push(TokenTree::Token(span, Token::Comma).into());\n                     }\n-                    tokens.push(item.node.tokens());\n+                    item.node.tokens().append_to_tree_and_joint_vec(&mut tokens);\n                 }\n                 TokenTree::Delimited(\n                     DelimSpan::from_single(span),"}, {"sha": "c3124144009ab61bfc2b7f589d8df50e59d3586c", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2cf736f76563f054aecd84207b39114c6fceb8ed/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf736f76563f054aecd84207b39114c6fceb8ed/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=2cf736f76563f054aecd84207b39114c6fceb8ed", "patch": "@@ -233,7 +233,7 @@ pub mod rt {\n                     self.span, token::Token::from_ast_ident(segment.ident)\n                 ).into());\n             }\n-            inner.push(self.tokens.clone());\n+            self.tokens.clone().append_to_tree_and_joint_vec(&mut inner);\n \n             let delim_span = DelimSpan::from_single(self.span);\n             r.push(TokenTree::Delimited("}, {"sha": "0ef2d3b749d810f962e5b226fba17f94a58e0eac", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2cf736f76563f054aecd84207b39114c6fceb8ed/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf736f76563f054aecd84207b39114c6fceb8ed/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=2cf736f76563f054aecd84207b39114c6fceb8ed", "patch": "@@ -7,7 +7,7 @@ use fold::noop_fold_tt;\n use parse::token::{self, Token, NtTT};\n use smallvec::SmallVec;\n use syntax_pos::DUMMY_SP;\n-use tokenstream::{TokenStream, TokenTree, DelimSpan};\n+use tokenstream::{DelimSpan, TokenStream, TokenTree, TreeAndJoint};\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n@@ -63,7 +63,7 @@ pub fn transcribe(cx: &ExtCtxt,\n     let mut stack: SmallVec<[Frame; 1]> = smallvec![Frame::new(src)];\n     let interpolations = interp.unwrap_or_else(FxHashMap::default); /* just a convenience */\n     let mut repeats = Vec::new();\n-    let mut result: Vec<TokenStream> = Vec::new();\n+    let mut result: Vec<TreeAndJoint> = Vec::new();\n     let mut result_stack = Vec::new();\n \n     loop {\n@@ -78,7 +78,7 @@ pub fn transcribe(cx: &ExtCtxt,\n                     if let Some(sep) = sep.clone() {\n                         // repeat same span, I guess\n                         let prev_span = match result.last() {\n-                            Some(stream) => stream.trees().next().unwrap().span(),\n+                            Some((tt, _)) => tt.span(),\n                             None => DUMMY_SP,\n                         };\n                         result.push(TokenTree::Token(prev_span, sep).into());"}, {"sha": "d219f29f06c204ba2145ec8a9a3da8195e29a23f", "filename": "src/libsyntax/parse/lexer/tokentrees.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2cf736f76563f054aecd84207b39114c6fceb8ed/src%2Flibsyntax%2Fparse%2Flexer%2Ftokentrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf736f76563f054aecd84207b39114c6fceb8ed/src%2Flibsyntax%2Fparse%2Flexer%2Ftokentrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Ftokentrees.rs?ref=2cf736f76563f054aecd84207b39114c6fceb8ed", "patch": "@@ -1,7 +1,7 @@\n use print::pprust::token_to_string;\n use parse::lexer::StringReader;\n use parse::{token, PResult};\n-use tokenstream::{DelimSpan, IsJoint::*, TokenStream, TokenTree};\n+use tokenstream::{DelimSpan, IsJoint::*, TokenStream, TokenTree, TreeAndJoint};\n \n impl<'a> StringReader<'a> {\n     // Parse a stream of tokens into a list of `TokenTree`s, up to an `Eof`.\n@@ -33,7 +33,7 @@ impl<'a> StringReader<'a> {\n         }\n     }\n \n-    fn parse_token_tree(&mut self) -> PResult<'a, TokenStream> {\n+    fn parse_token_tree(&mut self) -> PResult<'a, TreeAndJoint> {\n         let sm = self.sess.source_map();\n         match self.token {\n             token::Eof => {\n@@ -156,7 +156,7 @@ impl<'a> StringReader<'a> {\n                 Ok(TokenTree::Delimited(\n                     delim_span,\n                     delim,\n-                    tts.into(),\n+                    tts.into()\n                 ).into())\n             },\n             token::CloseDelim(_) => {\n@@ -176,7 +176,7 @@ impl<'a> StringReader<'a> {\n                 let raw = self.span_src_raw;\n                 self.real_token();\n                 let is_joint = raw.hi() == self.span_src_raw.lo() && token::is_op(&self.token);\n-                Ok(TokenStream::Tree(tt, if is_joint { Joint } else { NonJoint }))\n+                Ok((tt, if is_joint { Joint } else { NonJoint }))\n             }\n         }\n     }"}, {"sha": "5c8ed94731afbb16785163a68e350cfe0714bfc1", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2cf736f76563f054aecd84207b39114c6fceb8ed/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf736f76563f054aecd84207b39114c6fceb8ed/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=2cf736f76563f054aecd84207b39114c6fceb8ed", "patch": "@@ -2914,7 +2914,7 @@ impl<'a> Parser<'a> {\n                 TokenTree::Delimited(\n                     frame.span,\n                     frame.delim,\n-                    frame.tree_cursor.original_stream().into(),\n+                    frame.tree_cursor.stream.into(),\n                 )\n             },\n             token::CloseDelim(_) | token::Eof => unreachable!(),"}, {"sha": "fb72ef9c956ce5057041339d2645dbb56b31c1d8", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 127, "deletions": 323, "changes": 450, "blob_url": "https://github.com/rust-lang/rust/blob/2cf736f76563f054aecd84207b39114c6fceb8ed/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf736f76563f054aecd84207b39114c6fceb8ed/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=2cf736f76563f054aecd84207b39114c6fceb8ed", "patch": "@@ -147,9 +147,11 @@ impl TokenTree {\n pub enum TokenStream {\n     Empty,\n     Tree(TokenTree, IsJoint),\n-    Stream(Lrc<Vec<TokenStream>>),\n+    Stream(Lrc<Vec<TreeAndJoint>>),\n }\n \n+pub type TreeAndJoint = (TokenTree, IsJoint);\n+\n // `TokenStream` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(target_arch = \"x86_64\")]\n static_assert!(MEM_SIZE_OF_TOKEN_STREAM: mem::size_of::<TokenStream>() == 32);\n@@ -173,16 +175,14 @@ impl TokenStream {\n             while let Some((pos, ts)) = iter.next() {\n                 if let Some((_, next)) = iter.peek() {\n                     let sp = match (&ts, &next) {\n-                        (TokenStream::Tree(TokenTree::Token(_, token::Token::Comma), NonJoint), _) |\n-                        (_, TokenStream::Tree(TokenTree::Token(_, token::Token::Comma), NonJoint))\n-                          => continue,\n-                        (TokenStream::Tree(TokenTree::Token(sp, _), NonJoint), _) => *sp,\n-                        (TokenStream::Tree(TokenTree::Delimited(sp, ..), NonJoint), _) =>\n-                            sp.entire(),\n+                        ((TokenTree::Token(_, token::Token::Comma), NonJoint), _) |\n+                        (_, (TokenTree::Token(_, token::Token::Comma), NonJoint)) => continue,\n+                        ((TokenTree::Token(sp, _), NonJoint), _) => *sp,\n+                        ((TokenTree::Delimited(sp, ..), NonJoint), _) => sp.entire(),\n                         _ => continue,\n                     };\n                     let sp = sp.shrink_to_hi();\n-                    let comma = TokenStream::Tree(TokenTree::Token(sp, token::Comma), NonJoint);\n+                    let comma = (TokenTree::Token(sp, token::Comma), NonJoint);\n                     suggestion = Some((pos, comma, sp));\n                 }\n             }\n@@ -200,8 +200,14 @@ impl TokenStream {\n }\n \n impl From<TokenTree> for TokenStream {\n-    fn from(tt: TokenTree) -> TokenStream {\n-        TokenStream::Tree(tt, NonJoint)\n+    fn from(tree: TokenTree) -> TokenStream {\n+        TokenStream::Tree(tree, NonJoint)\n+    }\n+}\n+\n+impl From<TokenTree> for TreeAndJoint {\n+    fn from(tree: TokenTree) -> TreeAndJoint {\n+        (tree, NonJoint)\n     }\n }\n \n@@ -213,56 +219,7 @@ impl From<Token> for TokenStream {\n \n impl<T: Into<TokenStream>> iter::FromIterator<T> for TokenStream {\n     fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Self {\n-        TokenStream::new(iter.into_iter().map(Into::into).collect::<Vec<_>>())\n-    }\n-}\n-\n-impl Extend<TokenStream> for TokenStream {\n-    fn extend<I: IntoIterator<Item = TokenStream>>(&mut self, iter: I) {\n-        let iter = iter.into_iter();\n-        let this = mem::replace(self, TokenStream::Empty);\n-\n-        // Vector of token streams originally in self.\n-        let tts: Vec<TokenStream> = match this {\n-            TokenStream::Empty => {\n-                let mut vec = Vec::new();\n-                vec.reserve(iter.size_hint().0);\n-                vec\n-            }\n-            TokenStream::Tree(..) => {\n-                let mut vec = Vec::new();\n-                vec.reserve(1 + iter.size_hint().0);\n-                vec.push(this);\n-                vec\n-            }\n-            TokenStream::Stream(rc_vec) => match Lrc::try_unwrap(rc_vec) {\n-                Ok(mut vec) => {\n-                    // Extend in place using the existing capacity if possible.\n-                    // This is the fast path for libraries like `quote` that\n-                    // build a token stream.\n-                    vec.reserve(iter.size_hint().0);\n-                    vec\n-                }\n-                Err(rc_vec) => {\n-                    // Self is shared so we need to copy and extend that.\n-                    let mut vec = Vec::new();\n-                    vec.reserve(rc_vec.len() + iter.size_hint().0);\n-                    vec.extend_from_slice(&rc_vec);\n-                    vec\n-                }\n-            }\n-        };\n-\n-        // Perform the extend, joining tokens as needed along the way.\n-        let mut builder = TokenStreamBuilder(tts);\n-        for stream in iter {\n-            builder.push(stream);\n-        }\n-\n-        // Build the resulting token stream. If it contains more than one token,\n-        // preserve capacity in the vector in anticipation of the caller\n-        // performing additional calls to extend.\n-        *self = TokenStream::new(builder.0);\n+        TokenStream::from_streams(iter.into_iter().map(Into::into).collect::<Vec<_>>())\n     }\n }\n \n@@ -294,14 +251,43 @@ impl TokenStream {\n         }\n     }\n \n-    pub fn new(mut streams: Vec<TokenStream>) -> TokenStream {\n+    fn from_streams(mut streams: Vec<TokenStream>) -> TokenStream {\n         match streams.len() {\n             0 => TokenStream::empty(),\n             1 => streams.pop().unwrap(),\n+            _ => {\n+                let mut vec = vec![];\n+                for stream in streams {\n+                    match stream {\n+                        TokenStream::Empty => {},\n+                        TokenStream::Tree(tree, is_joint) => vec.push((tree, is_joint)),\n+                        TokenStream::Stream(stream2) => vec.extend(stream2.iter().cloned()),\n+                    }\n+                }\n+                TokenStream::new(vec)\n+            }\n+        }\n+    }\n+\n+    pub fn new(mut streams: Vec<TreeAndJoint>) -> TokenStream {\n+        match streams.len() {\n+            0 => TokenStream::empty(),\n+            1 => {\n+                let (tree, is_joint) = streams.pop().unwrap();\n+                TokenStream::Tree(tree, is_joint)\n+            }\n             _ => TokenStream::Stream(Lrc::new(streams)),\n         }\n     }\n \n+    pub fn append_to_tree_and_joint_vec(self, vec: &mut Vec<TreeAndJoint>) {\n+        match self {\n+            TokenStream::Empty => {}\n+            TokenStream::Tree(tree, is_joint) => vec.push((tree, is_joint)),\n+            TokenStream::Stream(stream) => vec.extend(stream.iter().cloned()),\n+        }\n+    }\n+\n     pub fn trees(&self) -> Cursor {\n         self.clone().into_trees()\n     }\n@@ -362,54 +348,58 @@ impl TokenStream {\n         t1.next().is_none() && t2.next().is_none()\n     }\n \n-    /// Precondition: `self` consists of a single token tree.\n-    /// Returns true if the token tree is a joint operation w.r.t. `proc_macro::TokenNode`.\n-    pub fn as_tree(self) -> (TokenTree, bool /* joint? */) {\n-        match self {\n-            TokenStream::Tree(tree, is_joint) => (tree, is_joint == Joint),\n-            _ => unreachable!(),\n-        }\n-    }\n-\n     pub fn map_enumerated<F: FnMut(usize, TokenTree) -> TokenTree>(self, mut f: F) -> TokenStream {\n-        let mut trees = self.into_trees();\n-        let mut result = Vec::new();\n-        let mut i = 0;\n-        while let Some(stream) = trees.next_as_stream() {\n-            result.push(match stream {\n-                TokenStream::Tree(tree, is_joint) => TokenStream::Tree(f(i, tree), is_joint),\n-                _ => unreachable!()\n-            });\n-            i += 1;\n+        match self {\n+            TokenStream::Empty => TokenStream::Empty,\n+            TokenStream::Tree(tree, is_joint) => TokenStream::Tree(f(0, tree), is_joint),\n+            TokenStream::Stream(stream) => TokenStream::Stream(Lrc::new(\n+                stream\n+                    .iter()\n+                    .enumerate()\n+                    .map(|(i, (tree, is_joint))| (f(i, tree.clone()), *is_joint))\n+                    .collect()\n+            )),\n         }\n-        TokenStream::new(result)\n     }\n \n     pub fn map<F: FnMut(TokenTree) -> TokenTree>(self, mut f: F) -> TokenStream {\n-        let mut trees = self.into_trees();\n-        let mut result = Vec::new();\n-        while let Some(stream) = trees.next_as_stream() {\n-            result.push(match stream {\n-                TokenStream::Tree(tree, is_joint) => TokenStream::Tree(f(tree), is_joint),\n-                _ => unreachable!()\n-            });\n+        match self {\n+            TokenStream::Empty => TokenStream::Empty,\n+            TokenStream::Tree(tree, is_joint) => TokenStream::Tree(f(tree), is_joint),\n+            TokenStream::Stream(stream) => TokenStream::Stream(Lrc::new(\n+                stream\n+                    .iter()\n+                    .map(|(tree, is_joint)| (f(tree.clone()), *is_joint))\n+                    .collect()\n+            )),\n         }\n-        TokenStream::new(result)\n     }\n \n     fn first_tree_and_joint(&self) -> Option<(TokenTree, IsJoint)> {\n         match self {\n             TokenStream::Empty => None,\n             TokenStream::Tree(ref tree, is_joint) => Some((tree.clone(), *is_joint)),\n-            TokenStream::Stream(ref stream) => stream.first().unwrap().first_tree_and_joint(),\n+            TokenStream::Stream(ref stream) => Some(stream.first().unwrap().clone())\n         }\n     }\n \n     fn last_tree_if_joint(&self) -> Option<TokenTree> {\n         match self {\n-            TokenStream::Empty | TokenStream::Tree(_, NonJoint) => None,\n-            TokenStream::Tree(ref tree, Joint) => Some(tree.clone()),\n-            TokenStream::Stream(ref stream) => stream.last().unwrap().last_tree_if_joint(),\n+            TokenStream::Empty => None,\n+            TokenStream::Tree(ref tree, is_joint) => {\n+                if *is_joint == Joint {\n+                    Some(tree.clone())\n+                } else {\n+                    None\n+                }\n+            }\n+            TokenStream::Stream(ref stream) => {\n+                if let (tree, Joint) = stream.last().unwrap() {\n+                    Some(tree.clone())\n+                } else {\n+                    None\n+                }\n+            }\n         }\n     }\n }\n@@ -442,24 +432,18 @@ impl TokenStreamBuilder {\n         self.0.push(stream);\n     }\n \n-    pub fn add<T: Into<TokenStream>>(mut self, stream: T) -> Self {\n-        self.push(stream);\n-        self\n-    }\n-\n     pub fn build(self) -> TokenStream {\n-        TokenStream::new(self.0)\n+        TokenStream::from_streams(self.0)\n     }\n \n     fn push_all_but_last_tree(&mut self, stream: &TokenStream) {\n         if let TokenStream::Stream(ref streams) = stream {\n             let len = streams.len();\n             match len {\n                 1 => {}\n-                2 => self.0.push(streams[0].clone().into()),\n-                _ => self.0.push(TokenStream::new(streams[0 .. len - 1].to_vec())),\n+                2 => self.0.push(TokenStream::Tree(streams[0].0.clone(), streams[0].1)),\n+                _ => self.0.push(TokenStream::Stream(Lrc::new(streams[0 .. len - 1].to_vec()))),\n             }\n-            self.push_all_but_last_tree(&streams[len - 1])\n         }\n     }\n \n@@ -468,162 +452,85 @@ impl TokenStreamBuilder {\n             let len = streams.len();\n             match len {\n                 1 => {}\n-                2 => self.0.push(streams[1].clone().into()),\n-                _ => self.0.push(TokenStream::new(streams[1 .. len].to_vec())),\n+                2 => self.0.push(TokenStream::Tree(streams[1].0.clone(), streams[1].1)),\n+                _ => self.0.push(TokenStream::Stream(Lrc::new(streams[1 .. len].to_vec()))),\n             }\n-            self.push_all_but_first_tree(&streams[0])\n         }\n     }\n }\n \n #[derive(Clone)]\n-pub struct Cursor(CursorKind);\n-\n-#[derive(Clone)]\n-enum CursorKind {\n-    Empty,\n-    Tree(TokenTree, IsJoint, bool /* consumed? */),\n-    Stream(StreamCursor),\n-}\n-\n-#[derive(Clone)]\n-struct StreamCursor {\n-    stream: Lrc<Vec<TokenStream>>,\n+pub struct Cursor {\n+    pub stream: TokenStream,\n     index: usize,\n-    stack: Vec<(Lrc<Vec<TokenStream>>, usize)>,\n-}\n-\n-impl StreamCursor {\n-    fn new(stream: Lrc<Vec<TokenStream>>) -> Self {\n-        StreamCursor { stream: stream, index: 0, stack: Vec::new() }\n-    }\n-\n-    fn next_as_stream(&mut self) -> Option<TokenStream> {\n-        loop {\n-            if self.index < self.stream.len() {\n-                self.index += 1;\n-                let next = self.stream[self.index - 1].clone();\n-                match next {\n-                    TokenStream::Empty => {}\n-                    TokenStream::Tree(..) => return Some(next),\n-                    TokenStream::Stream(stream) => self.insert(stream),\n-                }\n-            } else if let Some((stream, index)) = self.stack.pop() {\n-                self.stream = stream;\n-                self.index = index;\n-            } else {\n-                return None;\n-            }\n-        }\n-    }\n-\n-    fn insert(&mut self, stream: Lrc<Vec<TokenStream>>) {\n-        self.stack.push((mem::replace(&mut self.stream, stream),\n-                         mem::replace(&mut self.index, 0)));\n-    }\n }\n \n impl Iterator for Cursor {\n     type Item = TokenTree;\n \n     fn next(&mut self) -> Option<TokenTree> {\n-        self.next_as_stream().map(|stream| match stream {\n-            TokenStream::Tree(tree, _) => tree,\n-            _ => unreachable!()\n-        })\n+        self.next_with_joint().map(|(tree, _)| tree)\n     }\n }\n \n impl Cursor {\n     fn new(stream: TokenStream) -> Self {\n-        Cursor(match stream {\n-            TokenStream::Empty => CursorKind::Empty,\n-            TokenStream::Tree(tree, is_joint) => CursorKind::Tree(tree, is_joint, false),\n-            TokenStream::Stream(stream) => CursorKind::Stream(StreamCursor::new(stream)),\n-        })\n-    }\n-\n-    pub fn next_as_stream(&mut self) -> Option<TokenStream> {\n-        let (stream, consumed) = match self.0 {\n-            CursorKind::Tree(ref tree, ref is_joint, ref mut consumed @ false) =>\n-                (TokenStream::Tree(tree.clone(), *is_joint), consumed),\n-            CursorKind::Stream(ref mut cursor) => return cursor.next_as_stream(),\n-            _ => return None,\n-        };\n-\n-        *consumed = true;\n-        Some(stream)\n+        Cursor { stream, index: 0 }\n     }\n \n-    pub fn insert(&mut self, stream: TokenStream) {\n-        match self.0 {\n-            _ if stream.is_empty() => return,\n-            CursorKind::Empty => *self = stream.trees(),\n-            CursorKind::Tree(_, _, consumed) => {\n-                *self = TokenStream::new(vec![self.original_stream(), stream]).trees();\n-                if consumed {\n-                    self.next();\n+    pub fn next_with_joint(&mut self) -> Option<TreeAndJoint> {\n+        match self.stream {\n+            TokenStream::Empty => None,\n+            TokenStream::Tree(ref tree, ref is_joint) => {\n+                if self.index == 0 {\n+                    self.index = 1;\n+                    Some((tree.clone(), *is_joint))\n+                } else {\n+                    None\n                 }\n             }\n-            CursorKind::Stream(ref mut cursor) => {\n-                cursor.insert(ThinTokenStream::from(stream).0.unwrap());\n+            TokenStream::Stream(ref stream) => {\n+                if self.index < stream.len() {\n+                    self.index += 1;\n+                    Some(stream[self.index - 1].clone())\n+                } else {\n+                    None\n+                }\n             }\n         }\n     }\n \n-    pub fn original_stream(&self) -> TokenStream {\n-        match self.0 {\n-            CursorKind::Empty => TokenStream::empty(),\n-            CursorKind::Tree(ref tree, ref is_joint, _) =>\n-                TokenStream::Tree(tree.clone(), *is_joint),\n-            CursorKind::Stream(ref cursor) => TokenStream::Stream(\n-                cursor.stack.get(0).cloned().map(|(stream, _)| stream)\n-                    .unwrap_or_else(|| cursor.stream.clone())\n-            ),\n+    pub fn append(&mut self, new_stream: TokenStream) {\n+        if new_stream.is_empty() {\n+            return;\n         }\n+        let index = self.index;\n+        let stream = mem::replace(&mut self.stream, TokenStream::Empty);\n+        *self = TokenStream::from_streams(vec![stream, new_stream]).into_trees();\n+        self.index = index;\n     }\n \n     pub fn look_ahead(&self, n: usize) -> Option<TokenTree> {\n-        fn look_ahead(streams: &[TokenStream], mut n: usize) -> Result<TokenTree, usize> {\n-            for stream in streams {\n-                n = match stream {\n-                    TokenStream::Tree(ref tree, _) if n == 0 => return Ok(tree.clone()),\n-                    TokenStream::Tree(..) => n - 1,\n-                    TokenStream::Stream(ref stream) => match look_ahead(stream, n) {\n-                        Ok(tree) => return Ok(tree),\n-                        Err(n) => n,\n-                    },\n-                    _ => n,\n-                };\n+        match self.stream {\n+            TokenStream::Empty => None,\n+            TokenStream::Tree(ref tree, _) => {\n+                if n == 0 && self.index == 0 {\n+                    Some(tree.clone())\n+                } else {\n+                    None\n+                }\n             }\n-            Err(n)\n+            TokenStream::Stream(ref stream) =>\n+                stream[self.index ..].get(n).map(|(tree, _)| tree.clone()),\n         }\n-\n-        match self.0 {\n-            CursorKind::Empty |\n-            CursorKind::Tree(_, _, true) => Err(n),\n-            CursorKind::Tree(ref tree, _, false) => look_ahead(&[tree.clone().into()], n),\n-            CursorKind::Stream(ref cursor) => {\n-                look_ahead(&cursor.stream[cursor.index ..], n).or_else(|mut n| {\n-                    for &(ref stream, index) in cursor.stack.iter().rev() {\n-                        n = match look_ahead(&stream[index..], n) {\n-                            Ok(tree) => return Ok(tree),\n-                            Err(n) => n,\n-                        }\n-                    }\n-\n-                    Err(n)\n-                })\n-            }\n-        }.ok()\n     }\n }\n \n /// The `TokenStream` type is large enough to represent a single `TokenTree` without allocation.\n /// `ThinTokenStream` is smaller, but needs to allocate to represent a single `TokenTree`.\n /// We must use `ThinTokenStream` in `TokenTree::Delimited` to avoid infinite size due to recursion.\n #[derive(Debug, Clone)]\n-pub struct ThinTokenStream(Option<Lrc<Vec<TokenStream>>>);\n+pub struct ThinTokenStream(Option<Lrc<Vec<TreeAndJoint>>>);\n \n impl ThinTokenStream {\n     pub fn stream(&self) -> TokenStream {\n@@ -635,7 +542,7 @@ impl From<TokenStream> for ThinTokenStream {\n     fn from(stream: TokenStream) -> ThinTokenStream {\n         ThinTokenStream(match stream {\n             TokenStream::Empty => None,\n-            TokenStream::Tree(..) => Some(Lrc::new(vec![stream])),\n+            TokenStream::Tree(tree, is_joint) => Some(Lrc::new(vec![(tree, is_joint)])),\n             TokenStream::Stream(stream) => Some(stream),\n         })\n     }\n@@ -742,7 +649,7 @@ mod tests {\n             let test_res = string_to_ts(\"foo::bar::baz\");\n             let test_fst = string_to_ts(\"foo::bar\");\n             let test_snd = string_to_ts(\"::baz\");\n-            let eq_res = TokenStream::new(vec![test_fst, test_snd]);\n+            let eq_res = TokenStream::from_streams(vec![test_fst, test_snd]);\n             assert_eq!(test_res.trees().count(), 5);\n             assert_eq!(eq_res.trees().count(), 5);\n             assert_eq!(test_res.eq_unspanned(&eq_res), true);\n@@ -827,107 +734,4 @@ mod tests {\n         assert!(stream.eq_unspanned(&string_to_ts(\"...\")));\n         assert_eq!(stream.trees().count(), 1);\n     }\n-\n-    #[test]\n-    fn test_extend_empty() {\n-        with_globals(|| {\n-            // Append a token onto an empty token stream.\n-            let mut stream = TokenStream::empty();\n-            stream.extend(vec![string_to_ts(\"t\")]);\n-\n-            let expected = string_to_ts(\"t\");\n-            assert!(stream.eq_unspanned(&expected));\n-        });\n-    }\n-\n-    #[test]\n-    fn test_extend_nothing() {\n-        with_globals(|| {\n-            // Append nothing onto a token stream containing one token.\n-            let mut stream = string_to_ts(\"t\");\n-            stream.extend(vec![]);\n-\n-            let expected = string_to_ts(\"t\");\n-            assert!(stream.eq_unspanned(&expected));\n-        });\n-    }\n-\n-    #[test]\n-    fn test_extend_single() {\n-        with_globals(|| {\n-            // Append a token onto token stream containing a single token.\n-            let mut stream = string_to_ts(\"t1\");\n-            stream.extend(vec![string_to_ts(\"t2\")]);\n-\n-            let expected = string_to_ts(\"t1 t2\");\n-            assert!(stream.eq_unspanned(&expected));\n-        });\n-    }\n-\n-    #[test]\n-    fn test_extend_in_place() {\n-        with_globals(|| {\n-            // Append a token onto token stream containing a reference counted\n-            // vec of tokens. The token stream has a reference count of 1 so\n-            // this can happen in place.\n-            let mut stream = string_to_ts(\"t1 t2\");\n-            stream.extend(vec![string_to_ts(\"t3\")]);\n-\n-            let expected = string_to_ts(\"t1 t2 t3\");\n-            assert!(stream.eq_unspanned(&expected));\n-        });\n-    }\n-\n-    #[test]\n-    fn test_extend_copy() {\n-        with_globals(|| {\n-            // Append a token onto token stream containing a reference counted\n-            // vec of tokens. The token stream is shared so the extend takes\n-            // place on a copy.\n-            let mut stream = string_to_ts(\"t1 t2\");\n-            let _incref = stream.clone();\n-            stream.extend(vec![string_to_ts(\"t3\")]);\n-\n-            let expected = string_to_ts(\"t1 t2 t3\");\n-            assert!(stream.eq_unspanned(&expected));\n-        });\n-    }\n-\n-    #[test]\n-    fn test_extend_no_join() {\n-        with_globals(|| {\n-            let first = TokenTree::Token(DUMMY_SP, Token::Dot);\n-            let second = TokenTree::Token(DUMMY_SP, Token::Dot);\n-\n-            // Append a dot onto a token stream containing a dot, but do not\n-            // join them.\n-            let mut stream = TokenStream::from(first);\n-            stream.extend(vec![TokenStream::from(second)]);\n-\n-            let expected = string_to_ts(\". .\");\n-            assert!(stream.eq_unspanned(&expected));\n-\n-            let unexpected = string_to_ts(\"..\");\n-            assert!(!stream.eq_unspanned(&unexpected));\n-        });\n-    }\n-\n-    #[test]\n-    fn test_extend_join() {\n-        with_globals(|| {\n-            let first = TokenTree::Token(DUMMY_SP, Token::Dot).joint();\n-            let second = TokenTree::Token(DUMMY_SP, Token::Dot);\n-\n-            // Append a dot onto a token stream containing a dot, forming a\n-            // dotdot.\n-            let mut stream = first;\n-            stream.extend(vec![TokenStream::from(second)]);\n-\n-            let expected = string_to_ts(\"..\");\n-            assert!(stream.eq_unspanned(&expected));\n-\n-            let unexpected = string_to_ts(\". .\");\n-            assert!(!stream.eq_unspanned(&unexpected));\n-        });\n-    }\n }"}, {"sha": "158cbc791ef504f30cf0d5ff6802f84769480874", "filename": "src/libsyntax_ext/proc_macro_server.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2cf736f76563f054aecd84207b39114c6fceb8ed/src%2Flibsyntax_ext%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf736f76563f054aecd84207b39114c6fceb8ed/src%2Flibsyntax_ext%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_server.rs?ref=2cf736f76563f054aecd84207b39114c6fceb8ed", "patch": "@@ -11,7 +11,7 @@ use syntax::ast;\n use syntax::ext::base::ExtCtxt;\n use syntax::parse::lexer::comments;\n use syntax::parse::{self, token, ParseSess};\n-use syntax::tokenstream::{self, DelimSpan, IsJoint::*, TokenStream};\n+use syntax::tokenstream::{self, DelimSpan, IsJoint::*, TokenStream, TreeAndJoint};\n use syntax_pos::hygiene::{SyntaxContext, Transparency};\n use syntax_pos::symbol::{keywords, Symbol};\n use syntax_pos::{BytePos, FileName, MultiSpan, Pos, SourceFile, Span};\n@@ -46,13 +46,14 @@ impl ToInternal<token::DelimToken> for Delimiter {\n     }\n }\n \n-impl FromInternal<(TokenStream, &'_ ParseSess, &'_ mut Vec<Self>)>\n+impl FromInternal<(TreeAndJoint, &'_ ParseSess, &'_ mut Vec<Self>)>\n     for TokenTree<Group, Punct, Ident, Literal>\n {\n-    fn from_internal((stream, sess, stack): (TokenStream, &ParseSess, &mut Vec<Self>)) -> Self {\n+    fn from_internal(((tree, is_joint), sess, stack): (TreeAndJoint, &ParseSess, &mut Vec<Self>))\n+                    -> Self {\n         use syntax::parse::token::*;\n \n-        let (tree, joint) = stream.as_tree();\n+        let joint = is_joint == Joint;\n         let (span, token) = match tree {\n             tokenstream::TokenTree::Delimited(span, delim, tts) => {\n                 let delimiter = Delimiter::from_internal(delim);\n@@ -450,7 +451,7 @@ impl server::TokenStreamIter for Rustc<'_> {\n     ) -> Option<TokenTree<Self::Group, Self::Punct, Self::Ident, Self::Literal>> {\n         loop {\n             let tree = iter.stack.pop().or_else(|| {\n-                let next = iter.cursor.next_as_stream()?;\n+                let next = iter.cursor.next_with_joint()?;\n                 Some(TokenTree::from_internal((next, self.sess, &mut iter.stack)))\n             })?;\n             // HACK: The condition \"dummy span + group with empty delimiter\" represents an AST\n@@ -461,7 +462,7 @@ impl server::TokenStreamIter for Rustc<'_> {\n             // and not doing the roundtrip through AST.\n             if let TokenTree::Group(ref group) = tree {\n                 if group.delimiter == Delimiter::None && group.span.entire().is_dummy() {\n-                    iter.cursor.insert(group.stream.clone());\n+                    iter.cursor.append(group.stream.clone());\n                     continue;\n                 }\n             }"}, {"sha": "e116cb70c1c311499e9a4699a2facf3fb967e9dd", "filename": "src/test/ui/borrowck/borrowck-borrow-from-owned-ptr.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2cf736f76563f054aecd84207b39114c6fceb8ed/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-borrow-from-owned-ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2cf736f76563f054aecd84207b39114c6fceb8ed/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-borrow-from-owned-ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-borrow-from-owned-ptr.stderr?ref=2cf736f76563f054aecd84207b39114c6fceb8ed", "patch": "@@ -138,7 +138,7 @@ error[E0502]: cannot borrow `foo` (via `foo.bar2`) as immutable because `foo` is\n LL |     let bar1 = &mut foo.bar1;\n    |                     -------- mutable borrow occurs here (via `foo.bar1`)\n LL |     let _foo1 = &foo.bar2; //~ ERROR cannot borrow\n-   |                  ^^^^^^^^ immutable borrow occurs here (via `foo.bar2`)\n+   |                  ^^^^^^^^ immutable borrow of `foo.bar2` -- which overlaps with `foo.bar1` -- occurs here\n LL |     *bar1;\n LL | }\n    | - mutable borrow ends here"}, {"sha": "236064da3e8b6ed409eb3dd2543acf4919c19e2b", "filename": "src/test/ui/borrowck/borrowck-box-insensitivity.ast.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2cf736f76563f054aecd84207b39114c6fceb8ed/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-box-insensitivity.ast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2cf736f76563f054aecd84207b39114c6fceb8ed/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-box-insensitivity.ast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-box-insensitivity.ast.stderr?ref=2cf736f76563f054aecd84207b39114c6fceb8ed", "patch": "@@ -61,7 +61,7 @@ error[E0502]: cannot borrow `a` (via `a.y`) as immutable because `a` is also bor\n LL |     let _x = &mut a.x;\n    |                   --- mutable borrow occurs here (via `a.x`)\n LL |     let _y = &a.y; //[ast]~ ERROR cannot borrow\n-   |               ^^^ immutable borrow occurs here (via `a.y`)\n+   |               ^^^ immutable borrow of `a.y` -- which overlaps with `a.x` -- occurs here\n ...\n LL | }\n    | - mutable borrow ends here\n@@ -72,7 +72,7 @@ error[E0502]: cannot borrow `a` (via `a.y`) as mutable because `a` is also borro\n LL |     let _x = &a.x;\n    |               --- immutable borrow occurs here (via `a.x`)\n LL |     let _y = &mut a.y; //[ast]~ ERROR cannot borrow\n-   |                   ^^^ mutable borrow occurs here (via `a.y`)\n+   |                   ^^^ mutable borrow of `a.y` -- which overlaps with `a.x` -- occurs here\n ...\n LL | }\n    | - immutable borrow ends here"}, {"sha": "e72048d0ea4bc66ed949be508f99c1d31640ce6e", "filename": "src/test/ui/borrowck/borrowck-box-insensitivity.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2cf736f76563f054aecd84207b39114c6fceb8ed/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-box-insensitivity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf736f76563f054aecd84207b39114c6fceb8ed/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-box-insensitivity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-box-insensitivity.rs?ref=2cf736f76563f054aecd84207b39114c6fceb8ed", "patch": "@@ -83,14 +83,14 @@ fn borrow_after_mut_borrow() {\n     let mut a: Box<_> = box A { x: box 0, y: 1 };\n     let _x = &mut a.x;\n     let _y = &a.y; //[ast]~ ERROR cannot borrow\n-    //[ast]~^ immutable borrow occurs here (via `a.y`)\n+    //[ast]~^ immutable borrow of `a.y` -- which overlaps with `a.x` -- occurs here\n     use_mut(_x);\n }\n fn mut_borrow_after_borrow() {\n     let mut a: Box<_> = box A { x: box 0, y: 1 };\n     let _x = &a.x;\n     let _y = &mut a.y; //[ast]~ ERROR cannot borrow\n-    //[ast]~^ mutable borrow occurs here (via `a.y`)\n+    //[ast]~^ mutable borrow of `a.y` -- which overlaps with `a.x` -- occurs here\n     use_imm(_x);\n }\n fn copy_after_move_nested() {"}, {"sha": "5cba30b43b8a0b5774bb74bcb8456e501e76f36b", "filename": "src/test/ui/borrowck/borrowck-union-borrow.nll.stderr", "status": "renamed", "additions": 40, "deletions": 45, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/2cf736f76563f054aecd84207b39114c6fceb8ed/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-union-borrow.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2cf736f76563f054aecd84207b39114c6fceb8ed/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-union-borrow.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-union-borrow.nll.stderr?ref=2cf736f76563f054aecd84207b39114c6fceb8ed", "patch": "@@ -1,132 +1,127 @@\n error[E0502]: cannot borrow `u.a` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-union-borrow.rs:27:23\n+  --> $DIR/borrowck-union-borrow.rs:25:23\n    |\n LL |             let ra = &u.a;\n    |                      ---- immutable borrow occurs here\n-LL |             let rma = &mut u.a; //[ast]~ ERROR cannot borrow `u.a` as mutable because it is also borrowed as immutable\n+LL |             let rma = &mut u.a; //~ ERROR cannot borrow `u.a` as mutable because it is also borrowed as immutable\n    |                       ^^^^^^^^ mutable borrow occurs here\n-LL |                                 //[mir]~^ ERROR cannot borrow `u.a` as mutable because it is also borrowed as immutable\n LL |             drop(ra);\n    |                  -- immutable borrow later used here\n \n error[E0506]: cannot assign to `u.a` because it is borrowed\n-  --> $DIR/borrowck-union-borrow.rs:33:13\n+  --> $DIR/borrowck-union-borrow.rs:30:13\n    |\n LL |             let ra = &u.a;\n    |                      ---- borrow of `u.a` occurs here\n-LL |             u.a = 1; //[ast]~ ERROR cannot assign to `u.a` because it is borrowed\n+LL |             u.a = 1; //~ ERROR cannot assign to `u.a` because it is borrowed\n    |             ^^^^^^^ assignment to borrowed `u.a` occurs here\n-LL |                      //[mir]~^ ERROR cannot assign to `u.a` because it is borrowed\n LL |             drop(ra);\n    |                  -- borrow later used here\n \n-error[E0502]: cannot borrow `u.b` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-union-borrow.rs:50:23\n+error[E0502]: cannot borrow `u` (via `u.b`) as mutable because it is also borrowed as immutable (via `u.a`)\n+  --> $DIR/borrowck-union-borrow.rs:46:23\n    |\n LL |             let ra = &u.a;\n-   |                      ---- immutable borrow occurs here\n-LL |             let rmb = &mut u.b; //[ast]~ ERROR cannot borrow `u` (via `u.b`) as mutable because `u` is also borrowed as immutable (via `u.a`)\n-   |                       ^^^^^^^^ mutable borrow occurs here\n-LL |                                 //[mir]~^ ERROR cannot borrow `u.b` as mutable because it is also borrowed as immutable\n+   |                      ---- immutable borrow occurs here (via `u.a`)\n+LL |             let rmb = &mut u.b; //~ ERROR cannot borrow `u` (via `u.b`) as mutable because `u` is also borrowed as immutable (via `u.a`)\n+   |                       ^^^^^^^^ mutable borrow of `u.b` -- which overlaps with `u.a` -- occurs here\n LL |             drop(ra);\n    |                  -- immutable borrow later used here\n+   |\n+   = note: `u.b` is a field of the union `U`, so it overlaps the field `u.a`\n \n error[E0506]: cannot assign to `u.b` because it is borrowed\n-  --> $DIR/borrowck-union-borrow.rs:56:13\n+  --> $DIR/borrowck-union-borrow.rs:51:13\n    |\n LL |             let ra = &u.a;\n    |                      ---- borrow of `u.b` occurs here\n-LL |             u.b = 1; //[ast]~ ERROR cannot assign to `u.b` because it is borrowed\n+LL |             u.b = 1; //~ ERROR cannot assign to `u.b` because it is borrowed\n    |             ^^^^^^^ assignment to borrowed `u.b` occurs here\n-LL |                      //[mir]~^ ERROR cannot assign to `u.b` because it is borrowed\n LL |             drop(ra);\n    |                  -- borrow later used here\n \n error[E0502]: cannot borrow `u.a` as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-union-borrow.rs:63:22\n+  --> $DIR/borrowck-union-borrow.rs:57:22\n    |\n LL |             let rma = &mut u.a;\n    |                       -------- mutable borrow occurs here\n-LL |             let ra = &u.a; //[ast]~ ERROR cannot borrow `u.a` as immutable because it is also borrowed as mutable\n+LL |             let ra = &u.a; //~ ERROR cannot borrow `u.a` as immutable because it is also borrowed as mutable\n    |                      ^^^^ immutable borrow occurs here\n-LL |                          //[mir]~^ ERROR cannot borrow `u.a` as immutable because it is also borrowed as mutable\n LL |             drop(rma);\n    |                  --- mutable borrow later used here\n \n error[E0503]: cannot use `u.a` because it was mutably borrowed\n-  --> $DIR/borrowck-union-borrow.rs:69:21\n+  --> $DIR/borrowck-union-borrow.rs:62:21\n    |\n LL |             let ra = &mut u.a;\n    |                      -------- borrow of `u.a` occurs here\n-LL |             let a = u.a; //[ast]~ ERROR cannot use `u.a` because it was mutably borrowed\n+LL |             let a = u.a; //~ ERROR cannot use `u.a` because it was mutably borrowed\n    |                     ^^^ use of borrowed `u.a`\n-LL |                          //[mir]~^ ERROR cannot use `u.a` because it was mutably borrowed\n LL |             drop(ra);\n    |                  -- borrow later used here\n \n error[E0499]: cannot borrow `u.a` as mutable more than once at a time\n-  --> $DIR/borrowck-union-borrow.rs:75:24\n+  --> $DIR/borrowck-union-borrow.rs:67:24\n    |\n LL |             let rma = &mut u.a;\n    |                       -------- first mutable borrow occurs here\n-LL |             let rma2 = &mut u.a; //[ast]~ ERROR cannot borrow `u.a` as mutable more than once at a time\n+LL |             let rma2 = &mut u.a; //~ ERROR cannot borrow `u.a` as mutable more than once at a time\n    |                        ^^^^^^^^ second mutable borrow occurs here\n-LL |                                  //[mir]~^ ERROR cannot borrow `u.a` as mutable more than once at a time\n LL |             drop(rma);\n    |                  --- first borrow later used here\n \n error[E0506]: cannot assign to `u.a` because it is borrowed\n-  --> $DIR/borrowck-union-borrow.rs:81:13\n+  --> $DIR/borrowck-union-borrow.rs:72:13\n    |\n LL |             let rma = &mut u.a;\n    |                       -------- borrow of `u.a` occurs here\n-LL |             u.a = 1; //[ast]~ ERROR cannot assign to `u.a` because it is borrowed\n+LL |             u.a = 1; //~ ERROR cannot assign to `u.a` because it is borrowed\n    |             ^^^^^^^ assignment to borrowed `u.a` occurs here\n-LL |                      //[mir]~^ ERROR cannot assign to `u.a` because it is borrowed\n LL |             drop(rma);\n    |                  --- borrow later used here\n \n-error[E0502]: cannot borrow `u.b` as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-union-borrow.rs:88:22\n+error[E0502]: cannot borrow `u` (via `u.b`) as immutable because it is also borrowed as mutable (via `u.a`)\n+  --> $DIR/borrowck-union-borrow.rs:78:22\n    |\n LL |             let rma = &mut u.a;\n-   |                       -------- mutable borrow occurs here\n-LL |             let rb = &u.b; //[ast]~ ERROR cannot borrow `u` (via `u.b`) as immutable because `u` is also borrowed as mutable (via `u.a`)\n-   |                      ^^^^ immutable borrow occurs here\n-LL |                            //[mir]~^ ERROR cannot borrow `u.b` as immutable because it is also borrowed as mutable\n+   |                       -------- mutable borrow occurs here (via `u.a`)\n+LL |             let rb = &u.b; //~ ERROR cannot borrow `u` (via `u.b`) as immutable because `u` is also borrowed as mutable (via `u.a`)\n+   |                      ^^^^ immutable borrow of `u.b` -- which overlaps with `u.a` -- occurs here\n LL |             drop(rma);\n    |                  --- mutable borrow later used here\n+   |\n+   = note: `u.b` is a field of the union `U`, so it overlaps the field `u.a`\n \n error[E0503]: cannot use `u.b` because it was mutably borrowed\n-  --> $DIR/borrowck-union-borrow.rs:94:21\n+  --> $DIR/borrowck-union-borrow.rs:83:21\n    |\n LL |             let ra = &mut u.a;\n    |                      -------- borrow of `u.a` occurs here\n-LL |             let b = u.b; //[ast]~ ERROR cannot use `u.b` because it was mutably borrowed\n+LL |             let b = u.b; //~ ERROR cannot use `u.b` because it was mutably borrowed\n    |                     ^^^ use of borrowed `u.a`\n-...\n+LL | \n LL |             drop(ra);\n    |                  -- borrow later used here\n \n-error[E0499]: cannot borrow `u.b` as mutable more than once at a time\n-  --> $DIR/borrowck-union-borrow.rs:101:24\n+error[E0499]: cannot borrow `u` (via `u.b`) as mutable more than once at a time\n+  --> $DIR/borrowck-union-borrow.rs:89:24\n    |\n LL |             let rma = &mut u.a;\n-   |                       -------- first mutable borrow occurs here\n-LL |             let rmb2 = &mut u.b; //[ast]~ ERROR cannot borrow `u` (via `u.b`) as mutable more than once at a time\n-   |                        ^^^^^^^^ second mutable borrow occurs here\n-LL |                                  //[mir]~^ ERROR cannot borrow `u.b` as mutable more than once at a time\n+   |                       -------- first mutable borrow occurs here (via `u.a`)\n+LL |             let rmb2 = &mut u.b; //~ ERROR cannot borrow `u` (via `u.b`) as mutable more than once at a time\n+   |                        ^^^^^^^^ second mutable borrow occurs here (via `u.b`)\n LL |             drop(rma);\n    |                  --- first borrow later used here\n+   |\n+   = note: `u.b` is a field of the union `U`, so it overlaps the field `u.a`\n \n error[E0506]: cannot assign to `u.b` because it is borrowed\n-  --> $DIR/borrowck-union-borrow.rs:107:13\n+  --> $DIR/borrowck-union-borrow.rs:94:13\n    |\n LL |             let rma = &mut u.a;\n    |                       -------- borrow of `u.b` occurs here\n-LL |             u.b = 1; //[ast]~ ERROR cannot assign to `u.b` because it is borrowed\n+LL |             u.b = 1; //~ ERROR cannot assign to `u.b` because it is borrowed\n    |             ^^^^^^^ assignment to borrowed `u.b` occurs here\n-LL |                      //[mir]~^ ERROR cannot assign to `u.b` because it is borrowed\n LL |             drop(rma);\n    |                  --- borrow later used here\n ", "previous_filename": "src/test/ui/borrowck/borrowck-union-borrow.ast.nll.stderr"}, {"sha": "8afc0be8b55c523800d0fc0cd3000a1f6cb71a74", "filename": "src/test/ui/borrowck/borrowck-union-borrow.rs", "status": "modified", "additions": 12, "deletions": 26, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/2cf736f76563f054aecd84207b39114c6fceb8ed/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-union-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf736f76563f054aecd84207b39114c6fceb8ed/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-union-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-union-borrow.rs?ref=2cf736f76563f054aecd84207b39114c6fceb8ed", "patch": "@@ -1,6 +1,4 @@\n // ignore-tidy-linelength\n-// revisions: ast mir\n-//[mir]compile-flags: -Z borrowck=mir\n \n #[derive(Clone, Copy)]\n union U {\n@@ -24,14 +22,12 @@ fn main() {\n         }\n         {\n             let ra = &u.a;\n-            let rma = &mut u.a; //[ast]~ ERROR cannot borrow `u.a` as mutable because it is also borrowed as immutable\n-                                //[mir]~^ ERROR cannot borrow `u.a` as mutable because it is also borrowed as immutable\n+            let rma = &mut u.a; //~ ERROR cannot borrow `u.a` as mutable because it is also borrowed as immutable\n             drop(ra);\n         }\n         {\n             let ra = &u.a;\n-            u.a = 1; //[ast]~ ERROR cannot assign to `u.a` because it is borrowed\n-                     //[mir]~^ ERROR cannot assign to `u.a` because it is borrowed\n+            u.a = 1; //~ ERROR cannot assign to `u.a` because it is borrowed\n             drop(ra);\n         }\n         // Imm borrow, other field\n@@ -47,65 +43,55 @@ fn main() {\n         }\n         {\n             let ra = &u.a;\n-            let rmb = &mut u.b; //[ast]~ ERROR cannot borrow `u` (via `u.b`) as mutable because `u` is also borrowed as immutable (via `u.a`)\n-                                //[mir]~^ ERROR cannot borrow `u.b` as mutable because it is also borrowed as immutable\n+            let rmb = &mut u.b; //~ ERROR cannot borrow `u` (via `u.b`) as mutable because `u` is also borrowed as immutable (via `u.a`)\n             drop(ra);\n         }\n         {\n             let ra = &u.a;\n-            u.b = 1; //[ast]~ ERROR cannot assign to `u.b` because it is borrowed\n-                     //[mir]~^ ERROR cannot assign to `u.b` because it is borrowed\n+            u.b = 1; //~ ERROR cannot assign to `u.b` because it is borrowed\n             drop(ra);\n         }\n         // Mut borrow, same field\n         {\n             let rma = &mut u.a;\n-            let ra = &u.a; //[ast]~ ERROR cannot borrow `u.a` as immutable because it is also borrowed as mutable\n-                         //[mir]~^ ERROR cannot borrow `u.a` as immutable because it is also borrowed as mutable\n+            let ra = &u.a; //~ ERROR cannot borrow `u.a` as immutable because it is also borrowed as mutable\n             drop(rma);\n         }\n         {\n             let ra = &mut u.a;\n-            let a = u.a; //[ast]~ ERROR cannot use `u.a` because it was mutably borrowed\n-                         //[mir]~^ ERROR cannot use `u.a` because it was mutably borrowed\n+            let a = u.a; //~ ERROR cannot use `u.a` because it was mutably borrowed\n             drop(ra);\n         }\n         {\n             let rma = &mut u.a;\n-            let rma2 = &mut u.a; //[ast]~ ERROR cannot borrow `u.a` as mutable more than once at a time\n-                                 //[mir]~^ ERROR cannot borrow `u.a` as mutable more than once at a time\n+            let rma2 = &mut u.a; //~ ERROR cannot borrow `u.a` as mutable more than once at a time\n             drop(rma);\n         }\n         {\n             let rma = &mut u.a;\n-            u.a = 1; //[ast]~ ERROR cannot assign to `u.a` because it is borrowed\n-                     //[mir]~^ ERROR cannot assign to `u.a` because it is borrowed\n+            u.a = 1; //~ ERROR cannot assign to `u.a` because it is borrowed\n             drop(rma);\n         }\n         // Mut borrow, other field\n         {\n             let rma = &mut u.a;\n-            let rb = &u.b; //[ast]~ ERROR cannot borrow `u` (via `u.b`) as immutable because `u` is also borrowed as mutable (via `u.a`)\n-                           //[mir]~^ ERROR cannot borrow `u.b` as immutable because it is also borrowed as mutable\n+            let rb = &u.b; //~ ERROR cannot borrow `u` (via `u.b`) as immutable because `u` is also borrowed as mutable (via `u.a`)\n             drop(rma);\n         }\n         {\n             let ra = &mut u.a;\n-            let b = u.b; //[ast]~ ERROR cannot use `u.b` because it was mutably borrowed\n-                         //[mir]~^ ERROR cannot use `u.b` because it was mutably borrowed\n+            let b = u.b; //~ ERROR cannot use `u.b` because it was mutably borrowed\n \n             drop(ra);\n         }\n         {\n             let rma = &mut u.a;\n-            let rmb2 = &mut u.b; //[ast]~ ERROR cannot borrow `u` (via `u.b`) as mutable more than once at a time\n-                                 //[mir]~^ ERROR cannot borrow `u.b` as mutable more than once at a time\n+            let rmb2 = &mut u.b; //~ ERROR cannot borrow `u` (via `u.b`) as mutable more than once at a time\n             drop(rma);\n         }\n         {\n             let rma = &mut u.a;\n-            u.b = 1; //[ast]~ ERROR cannot assign to `u.b` because it is borrowed\n-                     //[mir]~^ ERROR cannot assign to `u.b` because it is borrowed\n+            u.b = 1; //~ ERROR cannot assign to `u.b` because it is borrowed\n             drop(rma);\n         }\n     }"}, {"sha": "ef6a331eda04c0eabf6a1dd98137ad69ddfdb9f8", "filename": "src/test/ui/borrowck/borrowck-union-borrow.stderr", "status": "renamed", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/2cf736f76563f054aecd84207b39114c6fceb8ed/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-union-borrow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2cf736f76563f054aecd84207b39114c6fceb8ed/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-union-borrow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-union-borrow.stderr?ref=2cf736f76563f054aecd84207b39114c6fceb8ed", "patch": "@@ -1,115 +1,115 @@\n error[E0502]: cannot borrow `u.a` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-union-borrow.rs:27:28\n+  --> $DIR/borrowck-union-borrow.rs:25:28\n    |\n LL |             let ra = &u.a;\n    |                       --- immutable borrow occurs here\n-LL |             let rma = &mut u.a; //[ast]~ ERROR cannot borrow `u.a` as mutable because it is also borrowed as immutable\n+LL |             let rma = &mut u.a; //~ ERROR cannot borrow `u.a` as mutable because it is also borrowed as immutable\n    |                            ^^^ mutable borrow occurs here\n-...\n+LL |             drop(ra);\n LL |         }\n    |         - immutable borrow ends here\n \n error[E0506]: cannot assign to `u.a` because it is borrowed\n-  --> $DIR/borrowck-union-borrow.rs:33:13\n+  --> $DIR/borrowck-union-borrow.rs:30:13\n    |\n LL |             let ra = &u.a;\n    |                       --- borrow of `u.a` occurs here\n-LL |             u.a = 1; //[ast]~ ERROR cannot assign to `u.a` because it is borrowed\n+LL |             u.a = 1; //~ ERROR cannot assign to `u.a` because it is borrowed\n    |             ^^^^^^^ assignment to borrowed `u.a` occurs here\n \n error[E0502]: cannot borrow `u` (via `u.b`) as mutable because `u` is also borrowed as immutable (via `u.a`)\n-  --> $DIR/borrowck-union-borrow.rs:50:28\n+  --> $DIR/borrowck-union-borrow.rs:46:28\n    |\n LL |             let ra = &u.a;\n    |                       --- immutable borrow occurs here (via `u.a`)\n-LL |             let rmb = &mut u.b; //[ast]~ ERROR cannot borrow `u` (via `u.b`) as mutable because `u` is also borrowed as immutable (via `u.a`)\n-   |                            ^^^ mutable borrow occurs here (via `u.b`)\n-...\n+LL |             let rmb = &mut u.b; //~ ERROR cannot borrow `u` (via `u.b`) as mutable because `u` is also borrowed as immutable (via `u.a`)\n+   |                            ^^^ mutable borrow of `u.b` -- which overlaps with `u.a` -- occurs here\n+LL |             drop(ra);\n LL |         }\n    |         - immutable borrow ends here\n \n error[E0506]: cannot assign to `u.b` because it is borrowed\n-  --> $DIR/borrowck-union-borrow.rs:56:13\n+  --> $DIR/borrowck-union-borrow.rs:51:13\n    |\n LL |             let ra = &u.a;\n    |                       --- borrow of `u.b` occurs here\n-LL |             u.b = 1; //[ast]~ ERROR cannot assign to `u.b` because it is borrowed\n+LL |             u.b = 1; //~ ERROR cannot assign to `u.b` because it is borrowed\n    |             ^^^^^^^ assignment to borrowed `u.b` occurs here\n \n error[E0502]: cannot borrow `u.a` as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-union-borrow.rs:63:23\n+  --> $DIR/borrowck-union-borrow.rs:57:23\n    |\n LL |             let rma = &mut u.a;\n    |                            --- mutable borrow occurs here\n-LL |             let ra = &u.a; //[ast]~ ERROR cannot borrow `u.a` as immutable because it is also borrowed as mutable\n+LL |             let ra = &u.a; //~ ERROR cannot borrow `u.a` as immutable because it is also borrowed as mutable\n    |                       ^^^ immutable borrow occurs here\n-...\n+LL |             drop(rma);\n LL |         }\n    |         - mutable borrow ends here\n \n error[E0503]: cannot use `u.a` because it was mutably borrowed\n-  --> $DIR/borrowck-union-borrow.rs:69:17\n+  --> $DIR/borrowck-union-borrow.rs:62:17\n    |\n LL |             let ra = &mut u.a;\n    |                           --- borrow of `u.a` occurs here\n-LL |             let a = u.a; //[ast]~ ERROR cannot use `u.a` because it was mutably borrowed\n+LL |             let a = u.a; //~ ERROR cannot use `u.a` because it was mutably borrowed\n    |                 ^ use of borrowed `u.a`\n \n error[E0499]: cannot borrow `u.a` as mutable more than once at a time\n-  --> $DIR/borrowck-union-borrow.rs:75:29\n+  --> $DIR/borrowck-union-borrow.rs:67:29\n    |\n LL |             let rma = &mut u.a;\n    |                            --- first mutable borrow occurs here\n-LL |             let rma2 = &mut u.a; //[ast]~ ERROR cannot borrow `u.a` as mutable more than once at a time\n+LL |             let rma2 = &mut u.a; //~ ERROR cannot borrow `u.a` as mutable more than once at a time\n    |                             ^^^ second mutable borrow occurs here\n-...\n+LL |             drop(rma);\n LL |         }\n    |         - first borrow ends here\n \n error[E0506]: cannot assign to `u.a` because it is borrowed\n-  --> $DIR/borrowck-union-borrow.rs:81:13\n+  --> $DIR/borrowck-union-borrow.rs:72:13\n    |\n LL |             let rma = &mut u.a;\n    |                            --- borrow of `u.a` occurs here\n-LL |             u.a = 1; //[ast]~ ERROR cannot assign to `u.a` because it is borrowed\n+LL |             u.a = 1; //~ ERROR cannot assign to `u.a` because it is borrowed\n    |             ^^^^^^^ assignment to borrowed `u.a` occurs here\n \n error[E0502]: cannot borrow `u` (via `u.b`) as immutable because `u` is also borrowed as mutable (via `u.a`)\n-  --> $DIR/borrowck-union-borrow.rs:88:23\n+  --> $DIR/borrowck-union-borrow.rs:78:23\n    |\n LL |             let rma = &mut u.a;\n    |                            --- mutable borrow occurs here (via `u.a`)\n-LL |             let rb = &u.b; //[ast]~ ERROR cannot borrow `u` (via `u.b`) as immutable because `u` is also borrowed as mutable (via `u.a`)\n-   |                       ^^^ immutable borrow occurs here (via `u.b`)\n-...\n+LL |             let rb = &u.b; //~ ERROR cannot borrow `u` (via `u.b`) as immutable because `u` is also borrowed as mutable (via `u.a`)\n+   |                       ^^^ immutable borrow of `u.b` -- which overlaps with `u.a` -- occurs here\n+LL |             drop(rma);\n LL |         }\n    |         - mutable borrow ends here\n \n error[E0503]: cannot use `u.b` because it was mutably borrowed\n-  --> $DIR/borrowck-union-borrow.rs:94:17\n+  --> $DIR/borrowck-union-borrow.rs:83:17\n    |\n LL |             let ra = &mut u.a;\n    |                           --- borrow of `u.a` occurs here\n-LL |             let b = u.b; //[ast]~ ERROR cannot use `u.b` because it was mutably borrowed\n+LL |             let b = u.b; //~ ERROR cannot use `u.b` because it was mutably borrowed\n    |                 ^ use of borrowed `u.a`\n \n error[E0499]: cannot borrow `u` (via `u.b`) as mutable more than once at a time\n-  --> $DIR/borrowck-union-borrow.rs:101:29\n+  --> $DIR/borrowck-union-borrow.rs:89:29\n    |\n LL |             let rma = &mut u.a;\n    |                            --- first mutable borrow occurs here (via `u.a`)\n-LL |             let rmb2 = &mut u.b; //[ast]~ ERROR cannot borrow `u` (via `u.b`) as mutable more than once at a time\n+LL |             let rmb2 = &mut u.b; //~ ERROR cannot borrow `u` (via `u.b`) as mutable more than once at a time\n    |                             ^^^ second mutable borrow occurs here (via `u.b`)\n-...\n+LL |             drop(rma);\n LL |         }\n    |         - first borrow ends here\n \n error[E0506]: cannot assign to `u.b` because it is borrowed\n-  --> $DIR/borrowck-union-borrow.rs:107:13\n+  --> $DIR/borrowck-union-borrow.rs:94:13\n    |\n LL |             let rma = &mut u.a;\n    |                            --- borrow of `u.b` occurs here\n-LL |             u.b = 1; //[ast]~ ERROR cannot assign to `u.b` because it is borrowed\n+LL |             u.b = 1; //~ ERROR cannot assign to `u.b` because it is borrowed\n    |             ^^^^^^^ assignment to borrowed `u.b` occurs here\n \n error: aborting due to 12 previous errors", "previous_filename": "src/test/ui/borrowck/borrowck-union-borrow.ast.stderr"}, {"sha": "823f2c747d686b3a8c819d2b348e0e86a8cc13a0", "filename": "src/test/ui/issues/issue-17263.ast.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2cf736f76563f054aecd84207b39114c6fceb8ed/src%2Ftest%2Fui%2Fissues%2Fissue-17263.ast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2cf736f76563f054aecd84207b39114c6fceb8ed/src%2Ftest%2Fui%2Fissues%2Fissue-17263.ast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17263.ast.stderr?ref=2cf736f76563f054aecd84207b39114c6fceb8ed", "patch": "@@ -13,7 +13,7 @@ error[E0502]: cannot borrow `foo` (via `foo.b`) as immutable because `foo` is al\n   --> $DIR/issue-17263.rs:21:32\n    |\n LL |     let (c, d) = (&mut foo.a, &foo.b);\n-   |                        -----   ^^^^^ immutable borrow occurs here (via `foo.b`)\n+   |                        -----   ^^^^^ immutable borrow of `foo.b` -- which overlaps with `foo.a` -- occurs here\n    |                        |\n    |                        mutable borrow occurs here (via `foo.a`)\n ..."}, {"sha": "22ea254a769e842d64dc1a690031127a43267dbe", "filename": "src/test/ui/issues/issue-45157.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2cf736f76563f054aecd84207b39114c6fceb8ed/src%2Ftest%2Fui%2Fissues%2Fissue-45157.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf736f76563f054aecd84207b39114c6fceb8ed/src%2Ftest%2Fui%2Fissues%2Fissue-45157.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-45157.rs?ref=2cf736f76563f054aecd84207b39114c6fceb8ed", "patch": "@@ -1,6 +1,8 @@\n #![allow(unused)]\n #![feature(nll)]\n \n+// ignore-tidy-linelength\n+\n #[derive(Clone, Copy, Default)]\n struct S {\n     a: u8,\n@@ -25,8 +27,7 @@ fn main() {\n         *mref = 22;\n \n         let nref = &u.z.c;\n-        //~^ ERROR cannot borrow `u.z.c` as immutable because it is also borrowed as mutable [E0502]\n+        //~^ ERROR cannot borrow `u` (via `u.z.c`) as immutable because it is also borrowed as mutable (via `u.s.a`) [E0502]\n         println!(\"{} {}\", mref, nref)\n     }\n }\n-"}, {"sha": "3b15a8dbd9ef86f92635d4240dfd556a232ece48", "filename": "src/test/ui/issues/issue-45157.stderr", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2cf736f76563f054aecd84207b39114c6fceb8ed/src%2Ftest%2Fui%2Fissues%2Fissue-45157.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2cf736f76563f054aecd84207b39114c6fceb8ed/src%2Ftest%2Fui%2Fissues%2Fissue-45157.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-45157.stderr?ref=2cf736f76563f054aecd84207b39114c6fceb8ed", "patch": "@@ -1,14 +1,16 @@\n-error[E0502]: cannot borrow `u.z.c` as immutable because it is also borrowed as mutable\n-  --> $DIR/issue-45157.rs:27:20\n+error[E0502]: cannot borrow `u` (via `u.z.c`) as immutable because it is also borrowed as mutable (via `u.s.a`)\n+  --> $DIR/issue-45157.rs:29:20\n    |\n LL |         let mref = &mut u.s.a;\n-   |                    ---------- mutable borrow occurs here\n+   |                    ---------- mutable borrow occurs here (via `u.s.a`)\n ...\n LL |         let nref = &u.z.c;\n-   |                    ^^^^^^ immutable borrow occurs here\n-LL |         //~^ ERROR cannot borrow `u.z.c` as immutable because it is also borrowed as mutable [E0502]\n+   |                    ^^^^^^ immutable borrow of `u.z.c` -- which overlaps with `u.s.a` -- occurs here\n+LL |         //~^ ERROR cannot borrow `u` (via `u.z.c`) as immutable because it is also borrowed as mutable (via `u.s.a`) [E0502]\n LL |         println!(\"{} {}\", mref, nref)\n    |                           ---- mutable borrow later used here\n+   |\n+   = note: `u.z.c` is a field of the union `U`, so it overlaps the field `u.s.a`\n \n error: aborting due to previous error\n "}, {"sha": "f669fe00956ef5047bb2fcdc4f7b3f24a228b398", "filename": "src/test/ui/nll/issue-57100.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/2cf736f76563f054aecd84207b39114c6fceb8ed/src%2Ftest%2Fui%2Fnll%2Fissue-57100.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf736f76563f054aecd84207b39114c6fceb8ed/src%2Ftest%2Fui%2Fnll%2Fissue-57100.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-57100.rs?ref=2cf736f76563f054aecd84207b39114c6fceb8ed", "patch": "@@ -0,0 +1,69 @@\n+#![allow(unused)]\n+#![feature(nll)]\n+\n+// ignore-tidy-linelength\n+\n+// This tests the error messages for borrows of union fields when the unions are embedded in other\n+// structs or unions.\n+\n+#[derive(Clone, Copy, Default)]\n+struct Leaf {\n+    l1_u8: u8,\n+    l2_u8: u8,\n+}\n+\n+#[derive(Clone, Copy)]\n+union First {\n+    f1_leaf: Leaf,\n+    f2_leaf: Leaf,\n+    f3_union: Second,\n+}\n+\n+#[derive(Clone, Copy)]\n+union Second {\n+    s1_leaf: Leaf,\n+    s2_leaf: Leaf,\n+}\n+\n+struct Root {\n+    r1_u8: u8,\n+    r2_union: First,\n+}\n+\n+// Borrow a different field of the nested union.\n+fn nested_union() {\n+    unsafe {\n+        let mut r = Root {\n+            r1_u8: 3,\n+            r2_union: First { f3_union: Second { s2_leaf: Leaf { l1_u8: 8, l2_u8: 4 } } }\n+        };\n+\n+        let mref = &mut r.r2_union.f3_union.s1_leaf.l1_u8;\n+        //                                  ^^^^^^^\n+        *mref = 22;\n+        let nref = &r.r2_union.f3_union.s2_leaf.l1_u8;\n+        //                              ^^^^^^^\n+        //~^^ ERROR cannot borrow `r.r2_union.f3_union` (via `r.r2_union.f3_union.s2_leaf.l1_u8`) as immutable because it is also borrowed as mutable (via `r.r2_union.f3_union.s1_leaf.l1_u8`) [E0502]\n+        println!(\"{} {}\", mref, nref)\n+    }\n+}\n+\n+// Borrow a different field of the first union.\n+fn first_union() {\n+    unsafe {\n+        let mut r = Root {\n+            r1_u8: 3,\n+            r2_union: First { f3_union: Second { s2_leaf: Leaf { l1_u8: 8, l2_u8: 4 } } }\n+        };\n+\n+        let mref = &mut r.r2_union.f2_leaf.l1_u8;\n+        //                         ^^^^^^^\n+        *mref = 22;\n+        let nref = &r.r2_union.f1_leaf.l1_u8;\n+        //                     ^^^^^^^\n+        //~^^ ERROR cannot borrow `r.r2_union` (via `r.r2_union.f1_leaf.l1_u8`) as immutable because it is also borrowed as mutable (via `r.r2_union.f2_leaf.l1_u8`) [E0502]\n+        println!(\"{} {}\", mref, nref)\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "5d5c86c34875c2af9b6cc0ef966f01907de55acd", "filename": "src/test/ui/nll/issue-57100.stderr", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/2cf736f76563f054aecd84207b39114c6fceb8ed/src%2Ftest%2Fui%2Fnll%2Fissue-57100.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2cf736f76563f054aecd84207b39114c6fceb8ed/src%2Ftest%2Fui%2Fnll%2Fissue-57100.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-57100.stderr?ref=2cf736f76563f054aecd84207b39114c6fceb8ed", "patch": "@@ -0,0 +1,31 @@\n+error[E0502]: cannot borrow `r.r2_union.f3_union` (via `r.r2_union.f3_union.s2_leaf.l1_u8`) as immutable because it is also borrowed as mutable (via `r.r2_union.f3_union.s1_leaf.l1_u8`)\n+  --> $DIR/issue-57100.rs:44:20\n+   |\n+LL |         let mref = &mut r.r2_union.f3_union.s1_leaf.l1_u8;\n+   |                    -------------------------------------- mutable borrow occurs here (via `r.r2_union.f3_union.s1_leaf.l1_u8`)\n+...\n+LL |         let nref = &r.r2_union.f3_union.s2_leaf.l1_u8;\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ immutable borrow of `r.r2_union.f3_union.s2_leaf.l1_u8` -- which overlaps with `r.r2_union.f3_union.s1_leaf.l1_u8` -- occurs here\n+...\n+LL |         println!(\"{} {}\", mref, nref)\n+   |                           ---- mutable borrow later used here\n+   |\n+   = note: `r.r2_union.f3_union.s2_leaf.l1_u8` is a field of the union `Second`, so it overlaps the field `r.r2_union.f3_union.s1_leaf.l1_u8`\n+\n+error[E0502]: cannot borrow `r.r2_union` (via `r.r2_union.f1_leaf.l1_u8`) as immutable because it is also borrowed as mutable (via `r.r2_union.f2_leaf.l1_u8`)\n+  --> $DIR/issue-57100.rs:62:20\n+   |\n+LL |         let mref = &mut r.r2_union.f2_leaf.l1_u8;\n+   |                    ----------------------------- mutable borrow occurs here (via `r.r2_union.f2_leaf.l1_u8`)\n+...\n+LL |         let nref = &r.r2_union.f1_leaf.l1_u8;\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^ immutable borrow of `r.r2_union.f1_leaf.l1_u8` -- which overlaps with `r.r2_union.f2_leaf.l1_u8` -- occurs here\n+...\n+LL |         println!(\"{} {}\", mref, nref)\n+   |                           ---- mutable borrow later used here\n+   |\n+   = note: `r.r2_union.f1_leaf.l1_u8` is a field of the union `First`, so it overlaps the field `r.r2_union.f2_leaf.l1_u8`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0502`."}, {"sha": "e0184164b3ac22c68975dc89d1cc15899d7b0a49", "filename": "src/test/ui/rfc1598-generic-associated-types/streaming_iterator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2cf736f76563f054aecd84207b39114c6fceb8ed/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fstreaming_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf736f76563f054aecd84207b39114c6fceb8ed/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fstreaming_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fstreaming_iterator.rs?ref=2cf736f76563f054aecd84207b39114c6fceb8ed", "patch": "@@ -28,7 +28,7 @@ fn foo<T>(iter: T) where T: StreamingIterator, for<'a> T::Item<'a>: Display { /*\n \n // Full example of enumerate iterator\n \n-#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n struct StreamEnumerate<I> {\n     iter: I,\n     count: usize,"}, {"sha": "848c3d9bdb017caf607aea607654a35ab57199be", "filename": "src/test/ui/union/union-borrow-move-parent-sibling.nll.stderr", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2cf736f76563f054aecd84207b39114c6fceb8ed/src%2Ftest%2Fui%2Funion%2Funion-borrow-move-parent-sibling.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2cf736f76563f054aecd84207b39114c6fceb8ed/src%2Ftest%2Fui%2Funion%2Funion-borrow-move-parent-sibling.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-borrow-move-parent-sibling.nll.stderr?ref=2cf736f76563f054aecd84207b39114c6fceb8ed", "patch": "@@ -1,12 +1,14 @@\n-error[E0502]: cannot borrow `u.y` as immutable because it is also borrowed as mutable\n+error[E0502]: cannot borrow `u` (via `u.y`) as immutable because it is also borrowed as mutable (via `u.x.0`)\n   --> $DIR/union-borrow-move-parent-sibling.rs:15:13\n    |\n LL |     let a = &mut u.x.0;\n-   |             ---------- mutable borrow occurs here\n+   |             ---------- mutable borrow occurs here (via `u.x.0`)\n LL |     let b = &u.y; //~ ERROR cannot borrow `u.y`\n-   |             ^^^^ immutable borrow occurs here\n+   |             ^^^^ immutable borrow of `u.y` -- which overlaps with `u.x.0` -- occurs here\n LL |     use_borrow(a);\n    |                - mutable borrow later used here\n+   |\n+   = note: `u.y` is a field of the union `U`, so it overlaps the field `u.x.0`\n \n error[E0382]: use of moved value: `u`\n   --> $DIR/union-borrow-move-parent-sibling.rs:22:13\n@@ -18,15 +20,17 @@ LL |     let b = u.y; //~ ERROR use of moved value: `u.y`\n    |\n    = note: move occurs because `u` has type `U`, which does not implement the `Copy` trait\n \n-error[E0502]: cannot borrow `u.y` as immutable because it is also borrowed as mutable\n+error[E0502]: cannot borrow `u` (via `u.y`) as immutable because it is also borrowed as mutable (via `u.x.0.0`)\n   --> $DIR/union-borrow-move-parent-sibling.rs:28:13\n    |\n LL |     let a = &mut (u.x.0).0;\n-   |             -------------- mutable borrow occurs here\n+   |             -------------- mutable borrow occurs here (via `u.x.0.0`)\n LL |     let b = &u.y; //~ ERROR cannot borrow `u.y`\n-   |             ^^^^ immutable borrow occurs here\n+   |             ^^^^ immutable borrow of `u.y` -- which overlaps with `u.x.0.0` -- occurs here\n LL |     use_borrow(a);\n    |                - mutable borrow later used here\n+   |\n+   = note: `u.y` is a field of the union `U`, so it overlaps the field `u.x.0.0`\n \n error[E0382]: use of moved value: `u`\n   --> $DIR/union-borrow-move-parent-sibling.rs:35:13\n@@ -38,15 +42,17 @@ LL |     let b = u.y; //~ ERROR use of moved value: `u.y`\n    |\n    = note: move occurs because `u` has type `U`, which does not implement the `Copy` trait\n \n-error[E0502]: cannot borrow `u.x` as immutable because it is also borrowed as mutable\n+error[E0502]: cannot borrow `u` (via `u.x`) as immutable because it is also borrowed as mutable (via `*u.y`)\n   --> $DIR/union-borrow-move-parent-sibling.rs:41:13\n    |\n LL |     let a = &mut *u.y;\n-   |             --------- mutable borrow occurs here\n+   |             --------- mutable borrow occurs here (via `*u.y`)\n LL |     let b = &u.x; //~ ERROR cannot borrow `u` (via `u.x`)\n-   |             ^^^^ immutable borrow occurs here\n+   |             ^^^^ immutable borrow of `u.x` -- which overlaps with `*u.y` -- occurs here\n LL |     use_borrow(a);\n    |                - mutable borrow later used here\n+   |\n+   = note: `u.x` is a field of the union `U`, so it overlaps the field `*u.y`\n \n error[E0382]: use of moved value: `u`\n   --> $DIR/union-borrow-move-parent-sibling.rs:48:13"}, {"sha": "9058707e505168bfc0f6c8db7c837c6ce694975b", "filename": "src/test/ui/union/union-borrow-move-parent-sibling.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2cf736f76563f054aecd84207b39114c6fceb8ed/src%2Ftest%2Fui%2Funion%2Funion-borrow-move-parent-sibling.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2cf736f76563f054aecd84207b39114c6fceb8ed/src%2Ftest%2Fui%2Funion%2Funion-borrow-move-parent-sibling.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-borrow-move-parent-sibling.stderr?ref=2cf736f76563f054aecd84207b39114c6fceb8ed", "patch": "@@ -46,7 +46,7 @@ error[E0502]: cannot borrow `u` (via `u.x`) as immutable because `u` is also bor\n LL |     let a = &mut *u.y;\n    |                  ---- mutable borrow occurs here (via `*u.y`)\n LL |     let b = &u.x; //~ ERROR cannot borrow `u` (via `u.x`)\n-   |              ^^^ immutable borrow occurs here (via `u.x`)\n+   |              ^^^ immutable borrow of `u.x` -- which overlaps with `*u.y` -- occurs here\n LL |     use_borrow(a);\n LL | }\n    | - mutable borrow ends here"}]}