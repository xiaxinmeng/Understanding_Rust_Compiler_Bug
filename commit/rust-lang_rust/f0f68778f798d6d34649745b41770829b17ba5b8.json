{"sha": "f0f68778f798d6d34649745b41770829b17ba5b8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwZjY4Nzc4Zjc5OGQ2ZDM0NjQ5NzQ1YjQxNzcwODI5YjE3YmE1Yjg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-09T19:53:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-09T19:53:23Z"}, "message": "Auto merge of #77611 - oli-obk:atomic_miri_leakage, r=nagisa\n\nDirectly use raw pointers in `AtomicPtr` store/load\n\nI was unable to find any reason for this limitation in the latest source of LLVM or in the documentation [here](http://llvm.org/docs/Atomics.html#libcalls-atomic).\n\nfixes https://github.com/rust-lang/miri/issues/1574", "tree": {"sha": "d82c4fc6b90775fa56761ed5538afa4fe471df6a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d82c4fc6b90775fa56761ed5538afa4fe471df6a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f0f68778f798d6d34649745b41770829b17ba5b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f0f68778f798d6d34649745b41770829b17ba5b8", "html_url": "https://github.com/rust-lang/rust/commit/f0f68778f798d6d34649745b41770829b17ba5b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f0f68778f798d6d34649745b41770829b17ba5b8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c16d52db7778fba1c8b6c07b06510cfd6c32ae4f", "url": "https://api.github.com/repos/rust-lang/rust/commits/c16d52db7778fba1c8b6c07b06510cfd6c32ae4f", "html_url": "https://github.com/rust-lang/rust/commit/c16d52db7778fba1c8b6c07b06510cfd6c32ae4f"}, {"sha": "41f988e6ae5b44a2ca742c39fe5551b700379762", "url": "https://api.github.com/repos/rust-lang/rust/commits/41f988e6ae5b44a2ca742c39fe5551b700379762", "html_url": "https://github.com/rust-lang/rust/commit/41f988e6ae5b44a2ca742c39fe5551b700379762"}], "stats": {"total": 103, "additions": 73, "deletions": 30}, "files": [{"sha": "df8aa1b3e6983b7eb517774081b0bd0bacc08ffe", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f0f68778f798d6d34649745b41770829b17ba5b8/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f68778f798d6d34649745b41770829b17ba5b8/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs?ref=f0f68778f798d6d34649745b41770829b17ba5b8", "patch": "@@ -146,12 +146,12 @@ macro atomic_minmax($fx:expr, $cc:expr, <$T:ident> ($ptr:ident, $src:ident) -> $\n \n macro validate_atomic_type($fx:ident, $intrinsic:ident, $span:ident, $ty:expr) {\n     match $ty.kind() {\n-        ty::Uint(_) | ty::Int(_) => {}\n+        ty::Uint(_) | ty::Int(_) | ty::RawPtr(..) => {}\n         _ => {\n             $fx.tcx.sess.span_err(\n                 $span,\n                 &format!(\n-                    \"`{}` intrinsic: expected basic integer type, found `{:?}`\",\n+                    \"`{}` intrinsic: expected basic integer or raw pointer type, found `{:?}`\",\n                     $intrinsic, $ty\n                 ),\n             );"}, {"sha": "72a64a8c5103467a4af39e574a34b9ffbb15756e", "filename": "compiler/rustc_codegen_ssa/src/mir/intrinsic.rs", "status": "modified", "additions": 41, "deletions": 14, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/f0f68778f798d6d34649745b41770829b17ba5b8/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f68778f798d6d34649745b41770829b17ba5b8/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs?ref=f0f68778f798d6d34649745b41770829b17ba5b8", "patch": "@@ -437,16 +437,20 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 match split[1] {\n                     \"cxchg\" | \"cxchgweak\" => {\n                         let ty = substs.type_at(0);\n-                        if int_type_width_signed(ty, bx.tcx()).is_some() {\n+                        if int_type_width_signed(ty, bx.tcx()).is_some() || ty.is_unsafe_ptr() {\n                             let weak = split[1] == \"cxchgweak\";\n-                            let pair = bx.atomic_cmpxchg(\n-                                args[0].immediate(),\n-                                args[1].immediate(),\n-                                args[2].immediate(),\n-                                order,\n-                                failorder,\n-                                weak,\n-                            );\n+                            let mut dst = args[0].immediate();\n+                            let mut cmp = args[1].immediate();\n+                            let mut src = args[2].immediate();\n+                            if ty.is_unsafe_ptr() {\n+                                // Some platforms do not support atomic operations on pointers,\n+                                // so we cast to integer first.\n+                                let ptr_llty = bx.type_ptr_to(bx.type_isize());\n+                                dst = bx.pointercast(dst, ptr_llty);\n+                                cmp = bx.ptrtoint(cmp, bx.type_isize());\n+                                src = bx.ptrtoint(src, bx.type_isize());\n+                            }\n+                            let pair = bx.atomic_cmpxchg(dst, cmp, src, order, failorder, weak);\n                             let val = bx.extract_value(pair, 0);\n                             let success = bx.extract_value(pair, 1);\n                             let val = bx.from_immediate(val);\n@@ -464,19 +468,42 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n                     \"load\" => {\n                         let ty = substs.type_at(0);\n-                        if int_type_width_signed(ty, bx.tcx()).is_some() {\n-                            let size = bx.layout_of(ty).size;\n-                            bx.atomic_load(args[0].immediate(), order, size)\n+                        if int_type_width_signed(ty, bx.tcx()).is_some() || ty.is_unsafe_ptr() {\n+                            let layout = bx.layout_of(ty);\n+                            let size = layout.size;\n+                            let mut source = args[0].immediate();\n+                            if ty.is_unsafe_ptr() {\n+                                // Some platforms do not support atomic operations on pointers,\n+                                // so we cast to integer first...\n+                                let ptr_llty = bx.type_ptr_to(bx.type_isize());\n+                                source = bx.pointercast(source, ptr_llty);\n+                            }\n+                            let result = bx.atomic_load(source, order, size);\n+                            if ty.is_unsafe_ptr() {\n+                                // ... and then cast the result back to a pointer\n+                                bx.inttoptr(result, bx.backend_type(layout))\n+                            } else {\n+                                result\n+                            }\n                         } else {\n                             return invalid_monomorphization(ty);\n                         }\n                     }\n \n                     \"store\" => {\n                         let ty = substs.type_at(0);\n-                        if int_type_width_signed(ty, bx.tcx()).is_some() {\n+                        if int_type_width_signed(ty, bx.tcx()).is_some() || ty.is_unsafe_ptr() {\n                             let size = bx.layout_of(ty).size;\n-                            bx.atomic_store(args[1].immediate(), args[0].immediate(), order, size);\n+                            let mut val = args[1].immediate();\n+                            let mut ptr = args[0].immediate();\n+                            if ty.is_unsafe_ptr() {\n+                                // Some platforms do not support atomic operations on pointers,\n+                                // so we cast to integer first.\n+                                let ptr_llty = bx.type_ptr_to(bx.type_isize());\n+                                ptr = bx.pointercast(ptr, ptr_llty);\n+                                val = bx.ptrtoint(val, bx.type_isize());\n+                            }\n+                            bx.atomic_store(val, ptr, order, size);\n                             return;\n                         } else {\n                             return invalid_monomorphization(ty);"}, {"sha": "be6c86b5176106789f36efabc17ec30bad675ef3", "filename": "library/core/src/sync/atomic.rs", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f0f68778f798d6d34649745b41770829b17ba5b8/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f68778f798d6d34649745b41770829b17ba5b8/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs?ref=f0f68778f798d6d34649745b41770829b17ba5b8", "patch": "@@ -966,8 +966,16 @@ impl<T> AtomicPtr<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn load(&self, order: Ordering) -> *mut T {\n+        #[cfg(not(bootstrap))]\n         // SAFETY: data races are prevented by atomic intrinsics.\n-        unsafe { atomic_load(self.p.get() as *mut usize, order) as *mut T }\n+        unsafe {\n+            atomic_load(self.p.get(), order)\n+        }\n+        #[cfg(bootstrap)]\n+        // SAFETY: data races are prevented by atomic intrinsics.\n+        unsafe {\n+            atomic_load(self.p.get() as *mut usize, order) as *mut T\n+        }\n     }\n \n     /// Stores a value into the pointer.\n@@ -994,6 +1002,12 @@ impl<T> AtomicPtr<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn store(&self, ptr: *mut T, order: Ordering) {\n+        #[cfg(not(bootstrap))]\n+        // SAFETY: data races are prevented by atomic intrinsics.\n+        unsafe {\n+            atomic_store(self.p.get(), ptr, order);\n+        }\n+        #[cfg(bootstrap)]\n         // SAFETY: data races are prevented by atomic intrinsics.\n         unsafe {\n             atomic_store(self.p.get() as *mut usize, ptr as usize, order);\n@@ -1105,6 +1119,7 @@ impl<T> AtomicPtr<T> {\n         success: Ordering,\n         failure: Ordering,\n     ) -> Result<*mut T, *mut T> {\n+        #[cfg(bootstrap)]\n         // SAFETY: data races are prevented by atomic intrinsics.\n         unsafe {\n             let res = atomic_compare_exchange(\n@@ -1119,6 +1134,11 @@ impl<T> AtomicPtr<T> {\n                 Err(x) => Err(x as *mut T),\n             }\n         }\n+        #[cfg(not(bootstrap))]\n+        // SAFETY: data races are prevented by atomic intrinsics.\n+        unsafe {\n+            atomic_compare_exchange(self.p.get(), current, new, success, failure)\n+        }\n     }\n \n     /// Stores a value into the pointer if the current value is the same as the `current` value.\n@@ -1165,6 +1185,7 @@ impl<T> AtomicPtr<T> {\n         success: Ordering,\n         failure: Ordering,\n     ) -> Result<*mut T, *mut T> {\n+        #[cfg(bootstrap)]\n         // SAFETY: data races are prevented by atomic intrinsics.\n         unsafe {\n             let res = atomic_compare_exchange_weak(\n@@ -1179,6 +1200,14 @@ impl<T> AtomicPtr<T> {\n                 Err(x) => Err(x as *mut T),\n             }\n         }\n+        #[cfg(not(bootstrap))]\n+        // SAFETY: This intrinsic is unsafe because it operates on a raw pointer\n+        // but we know for sure that the pointer is valid (we just got it from\n+        // an `UnsafeCell` that we have by reference) and the atomic operation\n+        // itself allows us to safely mutate the `UnsafeCell` contents.\n+        unsafe {\n+            atomic_compare_exchange_weak(self.p.get(), current, new, success, failure)\n+        }\n     }\n \n     /// Fetches the value, and applies a function to it that returns an optional"}, {"sha": "fb2bb0613ee88e96ddcf1dfd4d3cfa926bff6fa7", "filename": "library/std/src/sys/windows/thread_local_key.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f0f68778f798d6d34649745b41770829b17ba5b8/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread_local_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f68778f798d6d34649745b41770829b17ba5b8/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread_local_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread_local_key.rs?ref=f0f68778f798d6d34649745b41770829b17ba5b8", "patch": "@@ -110,16 +110,6 @@ struct Node {\n     next: *mut Node,\n }\n \n-#[cfg(miri)]\n-extern \"Rust\" {\n-    /// Miri-provided extern function to mark the block `ptr` points to as a \"root\"\n-    /// for some static memory. This memory and everything reachable by it is not\n-    /// considered leaking even if it still exists when the program terminates.\n-    ///\n-    /// `ptr` has to point to the beginning of an allocated block.\n-    fn miri_static_root(ptr: *const u8);\n-}\n-\n unsafe fn register_dtor(key: Key, dtor: Dtor) {\n     let mut node = Box::new(Node { key, dtor, next: ptr::null_mut() });\n \n@@ -128,9 +118,6 @@ unsafe fn register_dtor(key: Key, dtor: Dtor) {\n         node.next = head;\n         match DTORS.compare_exchange(head, &mut *node, SeqCst, SeqCst) {\n             Ok(_) => {\n-                #[cfg(miri)]\n-                miri_static_root(&*node as *const _ as *const u8);\n-\n                 mem::forget(node);\n                 return;\n             }"}]}